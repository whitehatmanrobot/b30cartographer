
}

void __RPC_API
IIndexDefinition_RemoteCreateIndex_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IIndexDefinition *This;
        DBID *pTableID;
        DBID *pIndexID;
        DBORDINAL cIndexColumnDescs;
        const DBINDEXCOLUMNDESC *rgIndexColumnDescs;
        ULONG cPropertySets;
        char Pad0[4];
        DBPROPSET *rgPropertySets;
        DBID **ppIndexID;
        ULONG cTotalProps;
        char Pad1[4];
        DBPROPSTATUS *rgPropStatus;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IIndexDefinition_CreateIndex_Stub(
                                            (IIndexDefinition *) pParamStruct->This,
                                            pParamStruct->pTableID,
                                            pParamStruct->pIndexID,
                                            pParamStruct->cIndexColumnDescs,
                                            pParamStruct->rgIndexColumnDescs,
                                            pParamStruct->cPropertySets,
                                            pParamStruct->rgPropertySets,
                                            pParamStruct->ppIndexID,
                                            pParamStruct->cTotalProps,
                                            pParamStruct->rgPropStatus,
                                            pParamStruct->ppErrorInfoRem);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE IIndexDefinition_RemoteDropIndex_Proxy( 
    IIndexDefinition * This,
    /* [unique][in] */ DBID *pTableID,
    /* [unique][in] */ DBID *pIndexID,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[3588],
                  ( unsigned char * )This,
                  pTableID,
                  pIndexID,
                  ppErrorInfoRem);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IIndexDefinition_RemoteDropIndex_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IIndexDefinition *This;
        DBID *pTableID;
        DBID *pIndexID;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IIndexDefinition_DropIndex_Stub(
                                          (IIndexDefinition *) pParamStruct->This,
                                          pParamStruct->pTableID,
                                          pParamStruct->pIndexID,
                                          pParamStruct->ppErrorInfoRem);
    
}


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ITableDefinition_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ITableDefinition_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE ITableDefinition_RemoteCreateTable_Proxy( 
    ITableDefinition * This,
    /* [in] */ IUnknown *pUnkOuter,
    /* [unique][in] */ DBID *pTableID,
    /* [in] */ DBORDINAL cColumnDescs,
    /* [size_is][in] */ const DBCOLUMNDESC *rgColumnDescs,
    /* [in] */ REFIID riid,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][in] */ DBPROPSET *rgPropertySets,
    /* [unique][out][in] */ DBID **ppTableID,
    /* [iid_is][unique][out][in] */ IUnknown **ppRowset,
    /* [in] */ ULONG cTotalProps,
    /* [size_is][out] */ DBPROPSTATUS *rgPropStatus,
    /* [out] */ BOOL *pfTableCreated,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[3638],
                  ( unsigned char * )This,
                  pUnkOuter,
                  pTableID,
                  cColumnDescs,
                  rgColumnDescs,
                  riid,
                  cPropertySets,
                  rgPropertySets,
                  ppTableID,
                  ppRowset,
                  cTotalProps,
                  rgPropStatus,
                  pfTableCreated,
                  ppErrorInfoRem);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
ITableDefinition_RemoteCreateTable_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITableDefinition *This;
        IUnknown *pUnkOuter;
        DBID *pTableID;
        DBORDINAL cColumnDescs;
        const DBCOLUMNDESC *rgColumnDescs;
        REFIID riid;
        ULONG cPropertySets;
        char Pad0[4];
        DBPROPSET *rgPropertySets;
        DBID **ppTableID;
        IUnknown **ppRowset;
        ULONG cTotalProps;
        char Pad1[4];
        DBPROPSTATUS *rgPropStatus;
        BOOL *pfTableCreated;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITableDefinition_CreateTable_Stub(
                                            (ITableDefinition *) pParamStruct->This,
                                            pParamStruct->pUnkOuter,
                                            pParamStruct->pTableID,
                                            pParamStruct->cColumnDescs,
                                            pParamStruct->rgColumnDescs,
                                            pParamStruct->riid,
                                            pParamStruct->cPropertySets,
                                            pParamStruct->rgPropertySets,
                                            pParamStruct->ppTableID,
                                            pParamStruct->ppRowset,
                                            pParamStruct->cTotalProps,
                                            pParamStruct->rgPropStatus,
                                            pParamStruct->pfTableCreated,
                                            pParamStruct->ppErrorInfoRem);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE ITableDefinition_RemoteDropTable_Proxy( 
    ITableDefinition * This,
    /* [unique][in] */ DBID *pTableID,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[3748],
                  ( unsigned char * )This,
                  pTableID,
                  ppErrorInfoRem);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
ITableDefinition_RemoteDropTable_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITableDefinition *This;
        DBID *pTableID;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITableDefinition_DropTable_Stub(
                                          (ITableDefinition *) pParamStruct->This,
                                          pParamStruct->pTableID,
                                          pParamStruct->ppErrorInfoRem);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE ITableDefinition_RemoteAddColumn_Proxy( 
    ITableDefinition * This,
    /* [in] */ DBID *pTableID,
    /* [in] */ DBCOLUMNDESC *pColumnDesc,
    /* [unique][out][in] */ DBID **ppColumnID,
    /* [in] */ ULONG cTotalProps,
    /* [size_is][out] */ DBPROPSTATUS *rgPropStatus,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[3792],
                  ( unsigned char * )This,
                  pTableID,
                  pColumnDesc,
                  ppColumnID,
                  cTotalProps,
                  rgPropStatus,
                  ppErrorInfoRem);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
ITableDefinition_RemoteAddColumn_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITableDefinition *This;
        DBID *pTableID;
        DBCOLUMNDESC *pColumnDesc;
        DBID **ppColumnID;
        ULONG cTotalProps;
        char Pad0[4];
        DBPROPSTATUS *rgPropStatus;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITableDefinition_AddColumn_Stub(
                                          (ITableDefinition *) pParamStruct->This,
                                          pParamStruct->pTableID,
                                          pParamStruct->pColumnDesc,
                                          pParamStruct->ppColumnID,
                                          pParamStruct->cTotalProps,
                                          pParamStruct->rgPropStatus,
                                          pParamStruct->ppErrorInfoRem);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE ITableDefinition_RemoteDropColumn_Proxy( 
    ITableDefinition * This,
    /* [unique][in] */ DBID *pTableID,
    /* [unique][in] */ DBID *pColumnID,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[3860],
                  ( unsigned char * )This,
                  pTableID,
                  pColumnID,
                  ppErrorInfoRem);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
ITableDefinition_RemoteDropColumn_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITableDefinition *This;
        DBID *pTableID;
        DBID *pColumnID;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITableDefinition_DropColumn_Stub(
                                           (ITableDefinition *) pParamStruct->This,
                                           pParamStruct->pTableID,
                                           pParamStruct->pColumnID,
                                           pParamStruct->ppErrorInfoRem);
    
}


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IOpenRowset_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IOpenRowset_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE IOpenRowset_RemoteOpenRowset_Proxy( 
    IOpenRowset * This,
    /* [in] */ IUnknown *pUnkOuter,
    /* [unique][in] */ DBID *pTableID,
    /* [unique][in] */ DBID *pIndexID,
    /* [in] */ REFIID riid,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][in] */ DBPROPSET *rgPropertySets,
    /* [iid_is][unique][out][in] */ IUnknown **ppRowset,
    /* [in] */ ULONG cTotalProps,
    /* [size_is][out] */ DBPROPSTATUS *rgPropStatus,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[3910],
                  ( unsigned char * )This,
                  pUnkOuter,
                  pTableID,
                  pIndexID,
                  riid,
                  cPropertySets,
                  rgPropertySets,
                  ppRowset,
                  cTotalProps,
                  rgPropStatus,
                  ppErrorInfoRem);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IOpenRowset_RemoteOpenRowset_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IOpenRowset *This;
        IUnknown *pUnkOuter;
        DBID *pTableID;
        DBID *pIndexID;
        REFIID riid;
        ULONG cPropertySets;
        char Pad0[4];
        DBPROPSET *rgPropertySets;
        IUnknown **ppRowset;
        ULONG cTotalProps;
        char Pad1[4];
        DBPROPSTATUS *rgPropStatus;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IOpenRowset_OpenRowset_Stub(
                                      (IOpenRowset *) pParamStruct->This,
                                      pParamStruct->pUnkOuter,
                                      pParamStruct->pTableID,
                                      pParamStruct->pIndexID,
                                      pParamStruct->riid,
                                      pParamStruct->cPropertySets,
                                      pParamStruct->rgPropertySets,
                                      pParamStruct->ppRowset,
                                      pParamStruct->cTotalProps,
                                      pParamStruct->rgPropStatus,
                                      pParamStruct->ppErrorInfoRem);
    
}


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDBSchemaRowset_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDBSchemaRowset_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBSchemaRowset_RemoteGetRowset_Proxy( 
    IDBSchemaRowset * This,
    /* [in] */ IUnknown *pUnkOuter,
    /* [in] */ REFGUID rguidSchema,
    /* [in] */ ULONG cRestrictions,
    /* [size_is][unique][in] */ const VARIANT *rgRestrictions,
    /* [in] */ REFIID riid,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][in] */ DBPROPSET *rgPropertySets,
    /* [iid_is][out] */ IUnknown **ppRowset,
    /* [in] */ ULONG cTotalProps,
    /* [size_is][out] */ DBPROPSTATUS *rgPropStatus,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[4002],
                  ( unsigned char * )This,
                  pUnkOuter,
                  rguidSchema,
                  cRestrictions,
                  rgRestrictions,
                  riid,
                  cPropertySets,
                  rgPropertySets,
                  ppRowset,
                  cTotalProps,
                  rgPropStatus,
                  ppErrorInfoRem);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IDBSchemaRowset_RemoteGetRowset_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IDBSchemaRowset *This;
        IUnknown *pUnkOuter;
        REFGUID rguidSchema;
        ULONG cRestrictions;
        char Pad0[4];
        const VARIANT *rgRestrictions;
        REFIID riid;
        ULONG cPropertySets;
        char Pad1[4];
        DBPROPSET *rgPropertySets;
        IUnknown **ppRowset;
        ULONG cTotalProps;
        char Pad2[4];
        DBPROPSTATUS *rgPropStatus;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IDBSchemaRowset_GetRowset_Stub(
                                         (IDBSchemaRowset *) pParamStruct->This,
                                         pParamStruct->pUnkOuter,
                                         pParamStruct->rguidSchema,
                                         pParamStruct->cRestrictions,
                                         pParamStruct->rgRestrictions,
                                         pParamStruct->riid,
                                         pParamStruct->cPropertySets,
                                         pParamStruct->rgPropertySets,
                                         pParamStruct->ppRowset,
                                         pParamStruct->cTotalProps,
                                         pParamStruct->rgPropStatus,
                                         pParamStruct->ppErrorInfoRem);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE IDBSchemaRowset_RemoteGetSchemas_Proxy( 
    IDBSchemaRowset * This,
    /* [out][in] */ ULONG *pcSchemas,
    /* [size_is][size_is][out] */ GUID **prgSchemas,
    /* [size_is][size_is][out] */ ULONG **prgRestrictionSupport,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[4100],
                  ( unsigned char * )This,
                  pcSchemas,
                  prgSchemas,
                  prgRestrictionSupport,
                  ppErrorInfoRem);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IDBSchemaRowset_RemoteGetSchemas_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IDBSchemaRowset *This;
        ULONG *pcSchemas;
        GUID **prgSchemas;
        ULONG **prgRestrictionSupport;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IDBSchemaRowset_GetSchemas_Stub(
                                          (IDBSchemaRowset *) pParamStruct->This,
                                          pParamStruct->pcSchemas,
                                          pParamStruct->prgSchemas,
                                          pParamStruct->prgRestrictionSupport,
                                          pParamStruct->ppErrorInfoRem);
    
}


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IErrorRecords_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IErrorRecords_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE IErrorRecords_RemoteAddErrorRecord_Proxy( 
    IErrorRecords * This,
    /* [in] */ ERRORINFO *pErrorInfo,
    /* [in] */ DWORD dwLookupID,
    /* [in] */ DISPPARAMS *pdispparams,
    /* [in] */ IUnknown *punkCustomError,
    /* [in] */ DWORD dwDynamicErrorID,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[4156],
                  ( unsigned char * )This,
                  pErrorInfo,
                  dwLookupID,
                  pdispparams,
                  punkCustomError,
                  dwDynamicErrorID,
                  ppErrorInfoRem);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IErrorRecords_RemoteAddErrorRecord_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IErrorRecords *This;
        ERRORINFO *pErrorInfo;
        DWORD dwLookupID;
        char Pad0[4];
        DISPPARAMS *pdispparams;
        IUnknown *punkCustomError;
        DWORD dwDynamicErrorID;
        char Pad1[4];
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IErrorRecords_AddErrorRecord_Stub(
                                            (IErrorRecords *) pParamStruct->This,
                                            pParamStruct->pErrorInfo,
                                            pParamStruct->dwLookupID,
                                            pParamStruct->pdispparams,
                                            pParamStruct->punkCustomError,
                                            pParamStruct->dwDynamicErrorID,
                                            pParamStruct->ppErrorInfoRem);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE IErrorRecords_RemoteGetBasicErrorInfo_Proxy( 
    IErrorRecords * This,
    /* [in] */ ULONG ulRecordNum,
    /* [out] */ ERRORINFO *pErrorInfo,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[4224],
                  ( unsigned char * )This,
                  ulRecordNum,
                  pErrorInfo,
                  ppErrorInfoRem);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IErrorRecords_RemoteGetBasicErrorInfo_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IErrorRecords *This;
        ULONG ulRecordNum;
        char Pad0[4];
        ERRORINFO *pErrorInfo;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IErrorRecords_GetBasicErrorInfo_Stub(
                                               (IErrorRecords *) pParamStruct->This,
                                               pParamStruct->ulRecordNum,
                                               pParamStruct->pErrorInfo,
                                               pParamStruct->ppErrorInfoRem);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE IErrorRecords_RemoteGetCustomErrorObject_Proxy( 
    IErrorRecords * This,
    /* [in] */ ULONG ulRecordNum,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppObject,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[4274],
                  ( unsigned char * )This,
                  ulRecordNum,
                  riid,
                  ppObject,
                  ppErrorInfoRem);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IErrorRecords_RemoteGetCustomErrorObject_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IErrorRecords *This;
        ULONG ulRecordNum;
        char Pad0[4];
        REFIID riid;
        IUnknown **ppObject;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IErrorRecords_GetCustomErrorObject_Stub(
                                                  (IErrorRecords *) pParamStruct->This,
                                                  pParamStruct->ulRecordNum,
                                                  pParamStruct->riid,
                                                  pParamStruct->ppObject,
                                                  pParamStruct->ppErrorInfoRem);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE IErrorRecords_RemoteGetErrorInfo_Proxy( 
    IErrorRecords * This,
    /* [in] */ ULONG ulRecordNum,
    /* [in] */ LCID lcid,
    /* [out] */ IErrorInfo **ppErrorInfo,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[4330],
                  ( unsigned char * )This,
                  ulRecordNum,
                  lcid,
                  ppErrorInfo,
                  ppErrorInfoRem);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IErrorRecords_RemoteGetErrorInfo_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IErrorRecords *This;
        ULONG ulRecordNum;
        char Pad0[4];
        LCID lcid;
        char Pad1[4];
        IErrorInfo **ppErrorInfo;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IErrorRecords_GetErrorInfo_Stub(
                                          (IErrorRecords *) pParamStruct->This,
                                          pParamStruct->ulRecordNum,
                                          pParamStruct->lcid,
                                          pParamStruct->ppErrorInfo,
                                          pParamStruct->ppErrorInfoRem);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE IErrorRecords_RemoteGetErrorParameters_Proxy( 
    IErrorRecords * This,
    /* [in] */ ULONG ulRecordNum,
    /* [out] */ DISPPARAMS *pdispparams,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[4386],
                  ( unsigned char * )This,
                  ulRecordNum,
                  pdispparams,
                  ppErrorInfoRem);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IErrorRecords_RemoteGetErrorParameters_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IErrorRecords *This;
        ULONG ulRecordNum;
        char Pad0[4];
        DISPPARAMS *pdispparams;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IErrorRecords_GetErrorParameters_Stub(
                                                (IErrorRecords *) pParamStruct->This,
                                                pParamStruct->ulRecordNum,
                                                pParamStruct->pdispparams,
                                                pParamStruct->ppErrorInfoRem);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE IErrorRecords_RemoteGetRecordCount_Proxy( 
    IErrorRecords * This,
    /* [out] */ ULONG *pcRecords,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[4436],
                  ( unsigned char * )This,
                  pcRecords,
                  ppErrorInfoRem);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IErrorRecords_RemoteGetRecordCount_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IErrorRecords *This;
        ULONG *pcRecords;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IErrorRecords_GetRecordCount_Stub(
                                            (IErrorRecords *) pParamStruct->This,
                                            pParamStruct->pcRecords,
                                            pParamStruct->ppErrorInfoRem);
    
}


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IErrorLookup_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IErrorLookup_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE IErrorLookup_RemoteGetErrorDescription_Proxy( 
    IErrorLookup * This,
    /* [in] */ HRESULT hrError,
    /* [in] */ DWORD dwLookupID,
    /* [in] */ DISPPARAMS *pdispparams,
    /* [in] */ LCID lcid,
    /* [out] */ BSTR *pbstrSource,
    /* [out] */ BSTR *pbstrDescription,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[4480],
                  ( unsigned char * )This,
                  hrError,
                  dwLookupID,
                  pdispparams,
                  lcid,
                  pbstrSource,
                  pbstrDescription,
                  ppErrorInfoRem);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IErrorLookup_RemoteGetErrorDescription_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IErrorLookup *This;
        HRESULT hrError;
        char Pad0[4];
        DWORD dwLookupID;
        char Pad1[4];
        DISPPARAMS *pdispparams;
        LCID lcid;
        char Pad2[4];
        BSTR *pbstrSource;
        BSTR *pbstrDescription;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IErrorLookup_GetErrorDescription_Stub(
                                                (IErrorLookup *) pParamStruct->This,
                                                pParamStruct->hrError,
                                                pParamStruct->dwLookupID,
                                                pParamStruct->pdispparams,
                                                pParamStruct->lcid,
                                                pParamStruct->pbstrSource,
                                                pParamStruct->pbstrDescription,
                                                pParamStruct->ppErrorInfoRem);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE IErrorLookup_RemoteGetHelpInfo_Proxy( 
    IErrorLookup * This,
    /* [in] */ HRESULT hrError,
    /* [in] */ DWORD dwLookupID,
    /* [in] */ LCID lcid,
    /* [out] */ BSTR *pbstrHelpFile,
    /* [out] */ DWORD *pdwHelpContext,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[4554],
                  ( unsigned char * )This,
                  hrError,
                  dwLookupID,
                  lcid,
                  pbstrHelpFile,
                  pdwHelpContext,
                  ppErrorInfoRem);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IErrorLookup_RemoteGetHelpInfo_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IErrorLookup *This;
        HRESULT hrError;
        char Pad0[4];
        DWORD dwLookupID;
        char Pad1[4];
        LCID lcid;
        char Pad2[4];
        BSTR *pbstrHelpFile;
        DWORD *pdwHelpContext;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IErrorLookup_GetHelpInfo_Stub(
                                        (IErrorLookup *) pParamStruct->This,
                                        pParamStruct->hrError,
                                        pParamStruct->dwLookupID,
                                        pParamStruct->lcid,
                                        pParamStruct->pbstrHelpFile,
                                        pParamStruct->pdwHelpContext,
                                        pParamStruct->ppErrorInfoRem);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE IErrorLookup_RemoteReleaseErrors_Proxy( 
    IErrorLookup * This,
    /* [in] */ const DWORD dwDynamicErrorID,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[4622],
                  ( unsigned char * )This,
                  dwDynamicErrorID,
                  ppErrorInfoRem);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IErrorLookup_RemoteReleaseErrors_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IErrorLookup *This;
        DWORD dwDynamicErrorID;
        char Pad0[4];
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IErrorLookup_ReleaseErrors_Stub(
                                          (IErrorLookup *) pParamStruct->This,
                                          pParamStruct->dwDynamicErrorID,
                                          pParamStruct->ppErrorInfoRem);
    
}


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ISQLErrorInfo_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ISQLErrorInfo_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE ISQLErrorInfo_RemoteGetSQLInfo_Proxy( 
    ISQLErrorInfo * This,
    /* [out] */ BSTR *pbstrSQLState,
    /* [out] */ LONG *plNativeError,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[4666],
                  ( unsigned char * )This,
                  pbstrSQLState,
                  plNativeError,
                  ppErrorInfoRem);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
ISQLErrorInfo_RemoteGetSQLInfo_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ISQLErrorInfo *This;
        BSTR *pbstrSQLState;
        LONG *plNativeError;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ISQLErrorInfo_GetSQLInfo_Stub(
                                        (ISQLErrorInfo *) pParamStruct->This,
                                        pParamStruct->pbstrSQLState,
                                        pParamStruct->plNativeError,
                                        pParamStruct->ppErrorInfoRem);
    
}


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IGetDataSource_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IGetDataSource_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE IGetDataSource_RemoteGetDataSource_Proxy( 
    IGetDataSource * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppDataSource,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[4716],
                  ( unsigned char * )This,
                  riid,
                  ppDataSource,
                  ppErrorInfoRem);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IGetDataSource_RemoteGetDataSource_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IGetDataSource *This;
        REFIID riid;
        IUnknown **ppDataSource;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IGetDataSource_GetDataSource_Stub(
                                            (IGetDataSource *) pParamStruct->This,
                                            pParamStruct->riid,
                                            pParamStruct->ppDataSource,
                                            pParamStruct->ppErrorInfoRem);
    
}


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ITransactionLocal_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ITransactionLocal_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE ITransactionLocal_RemoteGetOptionsObject_Proxy( 
    ITransactionLocal * This,
    /* [out] */ ITransactionOptions **ppOptions,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[4766],
                  ( unsigned char * )This,
                  ppOptions,
                  ppErrorInfoRem);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
ITransactionLocal_RemoteGetOptionsObject_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITransactionLocal *This;
        ITransactionOptions **ppOptions;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITransactionLocal_GetOptionsObject_Stub(
                                                  (ITransactionLocal *) pParamStruct->This,
                                                  pParamStruct->ppOptions,
                                                  pParamStruct->ppErrorInfoRem);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE ITransactionLocal_RemoteStartTransaction_Proxy( 
    ITransactionLocal * This,
    /* [in] */ ISOLEVEL isoLevel,
    /* [in] */ ULONG isoFlags,
    /* [in] */ ITransactionOptions *pOtherOptions,
    /* [unique][out][in] */ ULONG *pulTransactionLevel,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[4810],
                  ( unsigned char * )This,
                  isoLevel,
                  isoFlags,
                  pOtherOptions,
                  pulTransactionLevel,
                  ppErrorInfoRem);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
ITransactionLocal_RemoteStartTransaction_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITransactionLocal *This;
        ISOLEVEL isoLevel;
        char Pad0[4];
        ULONG isoFlags;
        char Pad1[4];
        ITransactionOptions *pOtherOptions;
        ULONG *pulTransactionLevel;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITransactionLocal_StartTransaction_Stub(
                                                  (ITransactionLocal *) pParamStruct->This,
                                                  pParamStruct->isoLevel,
                                                  pParamStruct->isoFlags,
                                                  pParamStruct->pOtherOptions,
                                                  pParamStruct->pulTransactionLevel,
                                                  pParamStruct->ppErrorInfoRem);
    
}


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ITransactionJoin_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ITransactionJoin_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE ITransactionJoin_RemoteGetOptionsObject_Proxy( 
    ITransactionJoin * This,
    /* [out] */ ITransactionOptions **ppOptions,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[4872],
                  ( unsigned char * )This,
                  ppOptions,
                  ppErrorInfoRem);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
ITransactionJoin_RemoteGetOptionsObject_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITransactionJoin *This;
        ITransactionOptions **ppOptions;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITransactionJoin_GetOptionsObject_Stub(
                                                 (ITransactionJoin *) pParamStruct->This,
                                                 pParamStruct->ppOptions,
                                                 pParamStruct->ppErrorInfoRem);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE ITransactionJoin_RemoteJoinTransaction_Proxy( 
    ITransactionJoin * This,
    /* [unique][in] */ IUnknown *punkTransactionCoord,
    /* [in] */ ISOLEVEL isoLevel,
    /* [in] */ ULONG isoFlags,
    /* [in] */ ITransactionOptions *pOtherOptions,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[4916],
                  ( unsigned char * )This,
                  punkTransactionCoord,
                  isoLevel,
                  isoFlags,
                  pOtherOptions,
                  ppErrorInfoRem);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
ITransactionJoin_RemoteJoinTransaction_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITransactionJoin *This;
        IUnknown *punkTransactionCoord;
        ISOLEVEL isoLevel;
        char Pad0[4];
        ULONG isoFlags;
        char Pad1[4];
        ITransactionOptions *pOtherOptions;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITransactionJoin_JoinTransaction_Stub(
                                                (ITransactionJoin *) pParamStruct->This,
                                                pParamStruct->punkTransactionCoord,
                                                pParamStruct->isoLevel,
                                                pParamStruct->isoFlags,
                                                pParamStruct->pOtherOptions,
                                                pParamStruct->ppErrorInfoRem);
    
}


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ITransactionObject_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ITransactionObject_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE ITransactionObject_RemoteGetTransactionObject_Proxy( 
    ITransactionObject * This,
    /* [in] */ ULONG ulTransactionLevel,
    /* [out] */ ITransaction **ppTransactionObject,
    /* [out] */ IErrorInfo **ppErrorInfoRem)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[4978],
                  ( unsigned char * )This,
                  ulTransactionLevel,
                  ppTransactionObject,
                  ppErrorInfoRem);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
ITransactionObject_RemoteGetTransactionObject_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ITransactionObject *This;
        ULONG ulTransactionLevel;
        char Pad0[4];
        ITransaction **ppTransactionObject;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ITransactionObject_GetTransactionObject_Stub(
                                                       (ITransactionObject *) pParamStruct->This,
                                                       pParamStruct->ulTransactionLevel,
                                                       pParamStruct->ppTransactionObject,
                                                       pParamStruct->ppErrorInfoRem);
    
}


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IBindResource_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IBindResource_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE IBindResource_RemoteBind_Proxy( 
    IBindResource * This,
    /* [in] */ IUnknown *pUnkOuter,
    /* [in] */ LPCOLESTR pwszURL,
    /* [in] */ DBBINDURLFLAG dwBindURLFlags,
    /* [in] */ REFGUID rguid,
    /* [in] */ REFIID riid,
    /* [in] */ IAuthenticate *pAuthenticate,
    /* [in] */ IUnknown *pSessionUnkOuter,
    /* [unique][in] */ IID *piid,
    /* [iid_is][unique][out][in] */ IUnknown **ppSession,
    /* [unique][out][in] */ DBBINDURLSTATUS *pdwBindStatus,
    /* [iid_is][out] */ IUnknown **ppUnk)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[5028],
                  ( unsigned char * )This,
                  pUnkOuter,
                  pwszURL,
                  dwBindURLFlags,
                  rguid,
                  riid,
                  pAuthenticate,
                  pSessionUnkOuter,
                  piid,
                  ppSession,
                  pdwBindStatus,
                  ppUnk);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IBindResource_RemoteBind_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IBindResource *This;
        IUnknown *pUnkOuter;
        LPCOLESTR pwszURL;
        DBBINDURLFLAG dwBindURLFlags;
        char Pad0[4];
        REFGUID rguid;
        REFIID riid;
        IAuthenticate *pAuthenticate;
        IUnknown *pSessionUnkOuter;
        IID *piid;
        IUnknown **ppSession;
        DBBINDURLSTATUS *pdwBindStatus;
        IUnknown **ppUnk;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IBindResource_Bind_Stub(
                                  (IBindResource *) pParamStruct->This,
                                  pParamStruct->pUnkOuter,
                                  pParamStruct->pwszURL,
                                  pParamStruct->dwBindURLFlags,
                                  pParamStruct->rguid,
                                  pParamStruct->riid,
                                  pParamStruct->pAuthenticate,
                                  pParamStruct->pSessionUnkOuter,
                                  pParamStruct->piid,
                                  pParamStruct->ppSession,
                                  pParamStruct->pdwBindStatus,
                                  pParamStruct->ppUnk);
    
}


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IScopedOperations_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IScopedOperations_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE IScopedOperations_RemoteCopy_Proxy( 
    IScopedOperations * This,
    /* [in] */ DBCOUNTITEM cRows,
    /* [size_is][in] */ LPCOLESTR *rgpwszSourceURLs,
    /* [size_is][in] */ LPCOLESTR *rgpwszDestURLs,
    /* [in] */ DWORD dwCopyFlags,
    /* [in] */ IAuthenticate *pAuthenticate,
    /* [size_is][out] */ DBSTATUS *rgdwStatus,
    /* [size_is][size_is][out] */ DBBYTEOFFSET **prgulNewURLOffsets,
    /* [out][in] */ ULONG *pcbStringsBuffer,
    /* [size_is][size_is][unique][out][in] */ OLECHAR **ppStringsBuffer)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[5126],
                  ( unsigned char * )This,
                  cRows,
                  rgpwszSourceURLs,
                  rgpwszDestURLs,
                  dwCopyFlags,
                  pAuthenticate,
                  rgdwStatus,
                  prgulNewURLOffsets,
                  pcbStringsBuffer,
                  ppStringsBuffer);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IScopedOperations_RemoteCopy_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IScopedOperations *This;
        DBCOUNTITEM cRows;
        LPCOLESTR *rgpwszSourceURLs;
        LPCOLESTR *rgpwszDestURLs;
        DWORD dwCopyFlags;
        char Pad0[4];
        IAuthenticate *pAuthenticate;
        DBSTATUS *rgdwStatus;
        DBBYTEOFFSET **prgulNewURLOffsets;
        ULONG *pcbStringsBuffer;
        OLECHAR **ppStringsBuffer;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IScopedOperations_Copy_Stub(
                                      (IScopedOperations *) pParamStruct->This,
                                      pParamStruct->cRows,
                                      pParamStruct->rgpwszSourceURLs,
                                      pParamStruct->rgpwszDestURLs,
                                      pParamStruct->dwCopyFlags,
                                      pParamStruct->pAuthenticate,
                                      pParamStruct->rgdwStatus,
                                      pParamStruct->prgulNewURLOffsets,
                                      pParamStruct->pcbStringsBuffer,
                                      pParamStruct->ppStringsBuffer);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE IScopedOperations_RemoteMove_Proxy( 
    IScopedOperations * This,
    /* [in] */ DBCOUNTITEM cRows,
    /* [size_is][in] */ LPCOLESTR *rgpwszSourceURLs,
    /* [size_is][in] */ LPCOLESTR *rgpwszDestURLs,
    /* [in] */ DWORD dwMoveFlags,
    /* [in] */ IAuthenticate *pAuthenticate,
    /* [size_is][out] */ DBSTATUS *rgdwStatus,
    /* [size_is][size_is][out] */ DBBYTEOFFSET **prgulNewURLOffsets,
    /* [out][in] */ ULONG *pcbStringsBuffer,
    /* [size_is][size_is][unique][out][in] */ OLECHAR **ppStringsBuffer)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[5212],
                  ( unsigned char * )This,
                  cRows,
                  rgpwszSourceURLs,
                  rgpwszDestURLs,
                  dwMoveFlags,
                  pAuthenticate,
                  rgdwStatus,
                  prgulNewURLOffsets,
                  pcbStringsBuffer,
                  ppStringsBuffer);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IScopedOperations_RemoteMove_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IScopedOperations *This;
        DBCOUNTITEM cRows;
        LPCOLESTR *rgpwszSourceURLs;
        LPCOLESTR *rgpwszDestURLs;
        DWORD dwMoveFlags;
        char Pad0[4];
        IAuthenticate *pAuthenticate;
        DBSTATUS *rgdwStatus;
        DBBYTEOFFSET **prgulNewURLOffsets;
        ULONG *pcbStringsBuffer;
        OLECHAR **ppStringsBuffer;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IScopedOperations_Move_Stub(
                                      (IScopedOperations *) pParamStruct->This,
                                      pParamStruct->cRows,
                                      pParamStruct->rgpwszSourceURLs,
                                      pParamStruct->rgpwszDestURLs,
                                      pParamStruct->dwMoveFlags,
                                      pParamStruct->pAuthenticate,
                                      pParamStruct->rgdwStatus,
                                      pParamStruct->prgulNewURLOffsets,
                                      pParamStruct->pcbStringsBuffer,
                                      pParamStruct->ppStringsBuffer);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE IScopedOperations_RemoteDelete_Proxy( 
    IScopedOperations * This,
    /* [in] */ DBCOUNTITEM cRows,
    /* [size_is][in] */ LPCOLESTR *rgpwszURLs,
    /* [in] */ DWORD dwDeleteFlags,
    /* [size_is][out] */ DBSTATUS *rgdwStatus)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[5298],
                  ( unsigned char * )This,
                  cRows,
                  rgpwszURLs,
                  dwDeleteFlags,
                  rgdwStatus);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IScopedOperations_RemoteDelete_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IScopedOperations *This;
        DBCOUNTITEM cRows;
        LPCOLESTR *rgpwszURLs;
        DWORD dwDeleteFlags;
        char Pad0[4];
        DBSTATUS *rgdwStatus;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IScopedOperations_Delete_Stub(
                                        (IScopedOperations *) pParamStruct->This,
                                        pParamStruct->cRows,
                                        pParamStruct->rgpwszURLs,
                                        pParamStruct->dwDeleteFlags,
                                        pParamStruct->rgdwStatus);
    
}

/* [call_as] */ HRESULT STDMETHODCALLTYPE IScopedOperations_RemoteOpenRowset_Proxy( 
    IScopedOperations * This,
    /* [in] */ IUnknown *pUnkOuter,
    /* [unique][in] */ DBID *pTableID,
    /* [unique][in] */ DBID *pIndexID,
    /* [in] */ REFIID riid,
    /* [in] */ ULONG cPropertySets,
    /* [size_is][unique][in] */ DBPROPSET *rgPropertySets,
    /* [iid_is][unique][out][in] */ IUnknown **ppRowset,
    /* [in] */ ULONG cTotalProps,
    /* [size_is][out] */ DBPROPSTATUS *rgPropStatus)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[5354],
                  ( unsigned char * )This,
                  pUnkOuter,
                  pTableID,
                  pIndexID,
                  riid,
                  cPropertySets,
                  rgPropertySets,
                  ppRowset,
                  cTotalProps,
                  rgPropStatus);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IScopedOperations_RemoteOpenRowset_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IScopedOperations *This;
        IUnknown *pUnkOuter;
        DBID *pTableID;
        DBID *pIndexID;
        REFIID riid;
        ULONG cPropertySets;
        char Pad0[4];
        DBPROPSET *rgPropertySets;
        IUnknown **ppRowset;
        ULONG cTotalProps;
        char Pad1[4];
        DBPROPSTATUS *rgPropStatus;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IScopedOperations_OpenRowset_Stub(
                                            (IScopedOperations *) pParamStruct->This,
                                            pParamStruct->pUnkOuter,
                                            pParamStruct->pTableID,
                                            pParamStruct->pIndexID,
                                            pParamStruct->riid,
                                            pParamStruct->cPropertySets,
                                            pParamStruct->rgPropertySets,
                                            pParamStruct->ppRowset,
                                            pParamStruct->cTotalProps,
                                            pParamStruct->rgPropStatus);
    
}


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICreateRow_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICreateRow_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE ICreateRow_RemoteCreateRow_Proxy( 
    ICreateRow * This,
    /* [in] */ IUnknown *pUnkOuter,
    /* [in] */ LPCOLESTR pwszURL,
    /* [in] */ DBBINDURLFLAG dwBindURLFlags,
    /* [in] */ REFGUID rguid,
    /* [in] */ REFIID riid,
    /* [in] */ IAuthenticate *pAuthenticate,
    /* [in] */ IUnknown *pSessionUnkOuter,
    /* [unique][in] */ IID *piid,
    /* [iid_is][unique][out][in] */ IUnknown **ppSession,
    /* [unique][out][in] */ DBBINDURLSTATUS *pdwBindStatus,
    /* [unique][out][in] */ LPOLESTR *ppwszNewURL,
    /* [iid_is][out] */ IUnknown **ppUnk)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[5440],
                  ( unsigned char * )This,
                  pUnkOuter,
                  pwszURL,
                  dwBindURLFlags,
                  rguid,
                  riid,
                  pAuthenticate,
                  pSessionUnkOuter,
                  piid,
                  ppSession,
                  pdwBindStatus,
                  ppwszNewURL,
                  ppUnk);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
ICreateRow_RemoteCreateRow_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        ICreateRow *This;
        IUnknown *pUnkOuter;
        LPCOLESTR pwszURL;
        DBBINDURLFLAG dwBindURLFlags;
        char Pad0[4];
        REFGUID rguid;
        REFIID riid;
        IAuthenticate *pAuthenticate;
        IUnknown *pSessionUnkOuter;
        IID *piid;
        IUnknown **ppSession;
        DBBINDURLSTATUS *pdwBindStatus;
        LPOLESTR *ppwszNewURL;
        IUnknown **ppUnk;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = ICreateRow_CreateRow_Stub(
                                    (ICreateRow *) pParamStruct->This,
                                    pParamStruct->pUnkOuter,
                                    pParamStruct->pwszURL,
                                    pParamStruct->dwBindURLFlags,
                                    pParamStruct->rguid,
                                    pParamStruct->riid,
                                    pParamStruct->pAuthenticate,
                                    pParamStruct->pSessionUnkOuter,
                                    pParamStruct->piid,
                                    pParamStruct->ppSession,
                                    pParamStruct->pdwBindStatus,
                                    pParamStruct->ppwszNewURL,
                                    pParamStruct->ppUnk);
    
}


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IDBBinderProperties_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IDBBinderProperties_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IColumnsInfo2_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IColumnsInfo2_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE IColumnsInfo2_RemoteGetRestrictedColumnInfo_Proxy( 
    IColumnsInfo2 * This,
    /* [in] */ DBORDINAL cColumnIDMasks,
    /* [size_is][unique][in] */ const DBID *rgColumnIDMasks,
    /* [in] */ DWORD dwFlags,
    /* [out][in] */ DBORDINAL *pcColumns,
    /* [size_is][size_is][unique][out][in] */ DBID **prgColumnIDs,
    /* [size_is][size_is][unique][out][in] */ DBCOLUMNINFO **prgColumnInfo,
    /* [size_is][size_is][out] */ DBBYTEOFFSET **prgNameOffsets,
    /* [size_is][size_is][out] */ DBBYTEOFFSET **prgcolumnidOffsets,
    /* [out][in] */ DBLENGTH *pcbStringsBuffer,
    /* [size_is][size_is][unique][out][in] */ OLECHAR **ppStringsBuffer)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[5576],
                  ( unsigned char * )This,
                  cColumnIDMasks,
                  rgColumnIDMasks,
                  dwFlags,
                  pcColumns,
                  prgColumnIDs,
                  prgColumnInfo,
                  prgNameOffsets,
                  prgcolumnidOffsets,
                  pcbStringsBuffer,
                  ppStringsBuffer);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IColumnsInfo2_RemoteGetRestrictedColumnInfo_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IColumnsInfo2 *This;
        DBORDINAL cColumnIDMasks;
        const DBID *rgColumnIDMasks;
        DWORD dwFlags;
        char Pad0[4];
        DBORDINAL *pcColumns;
        DBID **prgColumnIDs;
        DBCOLUMNINFO **prgColumnInfo;
        DBBYTEOFFSET **prgNameOffsets;
        DBBYTEOFFSET **prgcolumnidOffsets;
        DBLENGTH *pcbStringsBuffer;
        OLECHAR **ppStringsBuffer;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IColumnsInfo2_GetRestrictedColumnInfo_Stub(
                                                     (IColumnsInfo2 *) pParamStruct->This,
                                                     pParamStruct->cColumnIDMasks,
                                                     pParamStruct->rgColumnIDMasks,
                                                     pParamStruct->dwFlags,
                                                     pParamStruct->pcColumns,
                                                     pParamStruct->prgColumnIDs,
                                                     pParamStruct->prgColumnInfo,
                                                     pParamStruct->prgNameOffsets,
                                                     pParamStruct->prgcolumnidOffsets,
                                                     pParamStruct->pcbStringsBuffer,
                                                     pParamStruct->ppStringsBuffer);
    
}


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IRegisterProvider_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IRegisterProvider_ProxyInfo;

/* [call_as] */ HRESULT STDMETHODCALLTYPE IRegisterProvider_RemoteGetURLMapping_Proxy( 
    IRegisterProvider * This,
    /* [in] */ LPCOLESTR pwszURL,
    /* [in] */ DB_DWRESERVE dwReserved,
    /* [out] */ CLSID *pclsidProvider)
{
CLIENT_CALL_RETURN _RetVal;

_RetVal = NdrClientCall2(
                  ( PMIDL_STUB_DESC  )&Object_StubDesc,
                  (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[5668],
                  ( unsigned char * )This,
                  pwszURL,
                  dwReserved,
                  pclsidProvider);
return ( HRESULT  )_RetVal.Simple;

}

void __RPC_API
IRegisterProvider_RemoteGetURLMapping_Thunk(
    PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRegisterProvider *This;
        LPCOLESTR pwszURL;
        DB_DWRESERVE dwReserved;
        CLSID *pclsidProvider;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT * pParamStruct;

    pParamStruct = (struct _PARAM_STRUCT *) pStubMsg->StackTop;
    
    /* Call the server */
    
    pParamStruct->_RetVal = IRegisterProvider_GetURLMapping_Stub(
                                               (IRegisterProvider *) pParamStruct->This,
                                               pParamStruct->pwszURL,
                                               pParamStruct->dwReserved,
                                               pParamStruct->pclsidProvider);
    
}


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IGetSession_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IGetSession_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IGetSourceRow_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IGetSourceRow_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IRowsetBookmark_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IRowsetBookmark_ProxyInfo;


extern const EXPR_EVAL ExprEvalRoutines[];
extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure RemoteAddRefAccessor */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 10 */	NdrFcShort( 0x24 ),	/* 36 */
/* 12 */	NdrFcShort( 0x24 ),	/* 36 */
/* 14 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 16 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter hAccessor */

/* 26 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 28 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 30 */	0xb9,		/* FC_UINT3264 */
			0x0,		/* 0 */

	/* Parameter pcRefCount */

/* 32 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 34 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 36 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ppErrorInfoRem */

/* 38 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 40 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 42 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 44 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 46 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 48 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteCreateAccessor */

/* 50 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 52 */	NdrFcLong( 0x0 ),	/* 0 */
/* 56 */	NdrFcShort( 0x4 ),	/* 4 */
/* 58 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 60 */	NdrFcShort( 0x28 ),	/* 40 */
/* 62 */	NdrFcShort( 0x24 ),	/* 36 */
/* 64 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 66 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 68 */	NdrFcShort( 0x1 ),	/* 1 */
/* 70 */	NdrFcShort( 0x3 ),	/* 3 */
/* 72 */	NdrFcShort( 0x0 ),	/* 0 */
/* 74 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter dwAccessorFlags */

/* 76 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 78 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 80 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter cBindings */

/* 82 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 84 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 86 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter rgBindings */

/* 88 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 90 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 92 */	NdrFcShort( 0x1c ),	/* Type Offset=28 */

	/* Parameter cbRowSize */

/* 94 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 96 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 98 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter phAccessor */

/* 100 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 102 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 104 */	0xb9,		/* FC_UINT3264 */
			0x0,		/* 0 */

	/* Parameter rgStatus */

/* 106 */	NdrFcShort( 0x1b ),	/* Flags:  must size, must free, in, out, */
/* 108 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 110 */	NdrFcShort( 0xa8 ),	/* Type Offset=168 */

	/* Parameter ppErrorInfoRem */

/* 112 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 114 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 116 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 118 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 120 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 122 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetBindings */

/* 124 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 126 */	NdrFcLong( 0x0 ),	/* 0 */
/* 130 */	NdrFcShort( 0x5 ),	/* 5 */
/* 132 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 134 */	NdrFcShort( 0x2c ),	/* 44 */
/* 136 */	NdrFcShort( 0x48 ),	/* 72 */
/* 138 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x6,		/* 6 */
/* 140 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 142 */	NdrFcShort( 0x2 ),	/* 2 */
/* 144 */	NdrFcShort( 0x0 ),	/* 0 */
/* 146 */	NdrFcShort( 0x0 ),	/* 0 */
/* 148 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter hAccessor */

/* 150 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 152 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 154 */	0xb9,		/* FC_UINT3264 */
			0x0,		/* 0 */

	/* Parameter pdwAccessorFlags */

/* 156 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 158 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 160 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcBindings */

/* 162 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 164 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 166 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter prgBindings */

/* 168 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 170 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 172 */	NdrFcShort( 0xc0 ),	/* Type Offset=192 */

	/* Parameter ppErrorInfoRem */

/* 174 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 176 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 178 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 180 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 182 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 184 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteReleaseAccessor */

/* 186 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 188 */	NdrFcLong( 0x0 ),	/* 0 */
/* 192 */	NdrFcShort( 0x6 ),	/* 6 */
/* 194 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 196 */	NdrFcShort( 0x24 ),	/* 36 */
/* 198 */	NdrFcShort( 0x24 ),	/* 36 */
/* 200 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 202 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 204 */	NdrFcShort( 0x0 ),	/* 0 */
/* 206 */	NdrFcShort( 0x0 ),	/* 0 */
/* 208 */	NdrFcShort( 0x0 ),	/* 0 */
/* 210 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter hAccessor */

/* 212 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 214 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 216 */	0xb9,		/* FC_UINT3264 */
			0x0,		/* 0 */

	/* Parameter pcRefCount */

/* 218 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 220 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 222 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ppErrorInfoRem */

/* 224 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 226 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 228 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 230 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 232 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 234 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetProperties */


	/* Procedure RemoteGetProperties */


	/* Procedure RemoteGetProperties */


	/* Procedure RemoteGetProperties */

/* 236 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 238 */	NdrFcLong( 0x0 ),	/* 0 */
/* 242 */	NdrFcShort( 0x3 ),	/* 3 */
/* 244 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 246 */	NdrFcShort( 0x24 ),	/* 36 */
/* 248 */	NdrFcShort( 0x24 ),	/* 36 */
/* 250 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 252 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 254 */	NdrFcShort( 0x24 ),	/* 36 */
/* 256 */	NdrFcShort( 0x2 ),	/* 2 */
/* 258 */	NdrFcShort( 0x0 ),	/* 0 */
/* 260 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cPropertyIDSets */


	/* Parameter cPropertyIDSets */


	/* Parameter cPropertyIDSets */


	/* Parameter cPropertyIDSets */

/* 262 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 264 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 266 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgPropertyIDSets */


	/* Parameter rgPropertyIDSets */


	/* Parameter rgPropertyIDSets */


	/* Parameter rgPropertyIDSets */

/* 268 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 270 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 272 */	NdrFcShort( 0xde ),	/* Type Offset=222 */

	/* Parameter pcPropertySets */


	/* Parameter pcPropertySets */


	/* Parameter pcPropertySets */


	/* Parameter pcPropertySets */

/* 274 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 276 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 278 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter prgPropertySets */


	/* Parameter prgPropertySets */


	/* Parameter prgPropertySets */


	/* Parameter prgPropertySets */

/* 280 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 282 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 284 */	NdrFcShort( 0x11c ),	/* Type Offset=284 */

	/* Parameter ppErrorInfoRem */


	/* Parameter ppErrorInfoRem */


	/* Parameter ppErrorInfoRem */


	/* Parameter ppErrorInfoRem */

/* 286 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 288 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 290 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */


	/* Return value */


	/* Return value */


	/* Return value */

/* 292 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 294 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 296 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetReferencedRowset */

/* 298 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 300 */	NdrFcLong( 0x0 ),	/* 0 */
/* 304 */	NdrFcShort( 0x4 ),	/* 4 */
/* 306 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 308 */	NdrFcShort( 0x54 ),	/* 84 */
/* 310 */	NdrFcShort( 0x8 ),	/* 8 */
/* 312 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x5,		/* 5 */
/* 314 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 316 */	NdrFcShort( 0x1 ),	/* 1 */
/* 318 */	NdrFcShort( 0x0 ),	/* 0 */
/* 320 */	NdrFcShort( 0x0 ),	/* 0 */
/* 322 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter iOrdinal */

/* 324 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 326 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 328 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter riid */

/* 330 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 332 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 334 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter ppReferencedRowset */

/* 336 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 338 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 340 */	NdrFcShort( 0x5d2 ),	/* Type Offset=1490 */

	/* Parameter ppErrorInfoRem */

/* 342 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 344 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 346 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 348 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 350 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 352 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetSpecification */

/* 354 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 356 */	NdrFcLong( 0x0 ),	/* 0 */
/* 360 */	NdrFcShort( 0x5 ),	/* 5 */
/* 362 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 364 */	NdrFcShort( 0x44 ),	/* 68 */
/* 366 */	NdrFcShort( 0x8 ),	/* 8 */
/* 368 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 370 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 372 */	NdrFcShort( 0x1 ),	/* 1 */
/* 374 */	NdrFcShort( 0x0 ),	/* 0 */
/* 376 */	NdrFcShort( 0x0 ),	/* 0 */
/* 378 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter riid */

/* 380 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 382 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 384 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter ppSpecification */

/* 386 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 388 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 390 */	NdrFcShort( 0x5de ),	/* Type Offset=1502 */

	/* Parameter ppErrorInfoRem */

/* 392 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 394 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 396 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 398 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 400 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 402 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteAddRefChapter */

/* 404 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 406 */	NdrFcLong( 0x0 ),	/* 0 */
/* 410 */	NdrFcShort( 0x3 ),	/* 3 */
/* 412 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 414 */	NdrFcShort( 0x8 ),	/* 8 */
/* 416 */	NdrFcShort( 0x24 ),	/* 36 */
/* 418 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 420 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 422 */	NdrFcShort( 0x0 ),	/* 0 */
/* 424 */	NdrFcShort( 0x0 ),	/* 0 */
/* 426 */	NdrFcShort( 0x0 ),	/* 0 */
/* 428 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter hChapter */

/* 430 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 432 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 434 */	0xb9,		/* FC_UINT3264 */
			0x0,		/* 0 */

	/* Parameter pcRefCount */

/* 436 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 438 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 440 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppErrorInfoRem */

/* 442 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 444 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 446 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 448 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 450 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 452 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteReleaseChapter */

/* 454 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 456 */	NdrFcLong( 0x0 ),	/* 0 */
/* 460 */	NdrFcShort( 0x4 ),	/* 4 */
/* 462 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 464 */	NdrFcShort( 0x8 ),	/* 8 */
/* 466 */	NdrFcShort( 0x24 ),	/* 36 */
/* 468 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 470 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 472 */	NdrFcShort( 0x0 ),	/* 0 */
/* 474 */	NdrFcShort( 0x0 ),	/* 0 */
/* 476 */	NdrFcShort( 0x0 ),	/* 0 */
/* 478 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter hChapter */

/* 480 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 482 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 484 */	0xb9,		/* FC_UINT3264 */
			0x0,		/* 0 */

	/* Parameter pcRefCount */

/* 486 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 488 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 490 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppErrorInfoRem */

/* 492 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 494 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 496 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 498 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 500 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 502 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteInitialize */


	/* Procedure RemoteCancel */


	/* Procedure RemoteClearRowPosition */

/* 504 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 506 */	NdrFcLong( 0x0 ),	/* 0 */
/* 510 */	NdrFcShort( 0x3 ),	/* 3 */
/* 512 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 514 */	NdrFcShort( 0x0 ),	/* 0 */
/* 516 */	NdrFcShort( 0x8 ),	/* 8 */
/* 518 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 520 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 522 */	NdrFcShort( 0x0 ),	/* 0 */
/* 524 */	NdrFcShort( 0x0 ),	/* 0 */
/* 526 */	NdrFcShort( 0x0 ),	/* 0 */
/* 528 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppErrorInfoRem */


	/* Parameter ppErrorInfoRem */


	/* Parameter ppErrorInfoRem */

/* 530 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 532 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 534 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */


	/* Return value */


	/* Return value */

/* 536 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 538 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 540 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetRowPosition */

/* 542 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 544 */	NdrFcLong( 0x0 ),	/* 0 */
/* 548 */	NdrFcShort( 0x4 ),	/* 4 */
/* 550 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 552 */	NdrFcShort( 0x0 ),	/* 0 */
/* 554 */	NdrFcShort( 0x5c ),	/* 92 */
/* 556 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x5,		/* 5 */
/* 558 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 560 */	NdrFcShort( 0x0 ),	/* 0 */
/* 562 */	NdrFcShort( 0x0 ),	/* 0 */
/* 564 */	NdrFcShort( 0x0 ),	/* 0 */
/* 566 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter phChapter */

/* 568 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 570 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 572 */	0xb9,		/* FC_UINT3264 */
			0x0,		/* 0 */

	/* Parameter phRow */

/* 574 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 576 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 578 */	0xb9,		/* FC_UINT3264 */
			0x0,		/* 0 */

	/* Parameter pdwPositionFlags */

/* 580 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 582 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 584 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppErrorInfoRem */

/* 586 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 588 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 590 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 592 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 594 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 596 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetRowset */

/* 598 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 600 */	NdrFcLong( 0x0 ),	/* 0 */
/* 604 */	NdrFcShort( 0x5 ),	/* 5 */
/* 606 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 608 */	NdrFcShort( 0x44 ),	/* 68 */
/* 610 */	NdrFcShort( 0x8 ),	/* 8 */
/* 612 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 614 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 616 */	NdrFcShort( 0x1 ),	/* 1 */
/* 618 */	NdrFcShort( 0x0 ),	/* 0 */
/* 620 */	NdrFcShort( 0x0 ),	/* 0 */
/* 622 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter riid */

/* 624 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 626 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 628 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter ppRowset */

/* 630 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 632 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 634 */	NdrFcShort( 0x5ea ),	/* Type Offset=1514 */

	/* Parameter ppErrorInfoRem */

/* 636 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 638 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 640 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 642 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 644 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 646 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteInitialize */

/* 648 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 650 */	NdrFcLong( 0x0 ),	/* 0 */
/* 654 */	NdrFcShort( 0x6 ),	/* 6 */
/* 656 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 658 */	NdrFcShort( 0x0 ),	/* 0 */
/* 660 */	NdrFcShort( 0x8 ),	/* 8 */
/* 662 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 664 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 666 */	NdrFcShort( 0x0 ),	/* 0 */
/* 668 */	NdrFcShort( 0x0 ),	/* 0 */
/* 670 */	NdrFcShort( 0x0 ),	/* 0 */
/* 672 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pRowset */

/* 674 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 676 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 678 */	NdrFcShort( 0x302 ),	/* Type Offset=770 */

	/* Parameter ppErrorInfoRem */

/* 680 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 682 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 684 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 686 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 688 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 690 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteSetRowPosition */

/* 692 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 694 */	NdrFcLong( 0x0 ),	/* 0 */
/* 698 */	NdrFcShort( 0x7 ),	/* 7 */
/* 700 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 702 */	NdrFcShort( 0x18 ),	/* 24 */
/* 704 */	NdrFcShort( 0x8 ),	/* 8 */
/* 706 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x5,		/* 5 */
/* 708 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 710 */	NdrFcShort( 0x0 ),	/* 0 */
/* 712 */	NdrFcShort( 0x0 ),	/* 0 */
/* 714 */	NdrFcShort( 0x0 ),	/* 0 */
/* 716 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter hChapter */

/* 718 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 720 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 722 */	0xb9,		/* FC_UINT3264 */
			0x0,		/* 0 */

	/* Parameter hRow */

/* 724 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 726 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 728 */	0xb9,		/* FC_UINT3264 */
			0x0,		/* 0 */

	/* Parameter dwPositionFlags */

/* 730 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 732 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 734 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppErrorInfoRem */

/* 736 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 738 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 740 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 742 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 744 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 746 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteOnRowPositionChange */

/* 748 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 750 */	NdrFcLong( 0x0 ),	/* 0 */
/* 754 */	NdrFcShort( 0x3 ),	/* 3 */
/* 756 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 758 */	NdrFcShort( 0x18 ),	/* 24 */
/* 760 */	NdrFcShort( 0x8 ),	/* 8 */
/* 762 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x5,		/* 5 */
/* 764 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 766 */	NdrFcShort( 0x0 ),	/* 0 */
/* 768 */	NdrFcShort( 0x0 ),	/* 0 */
/* 770 */	NdrFcShort( 0x0 ),	/* 0 */
/* 772 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter eReason */

/* 774 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 776 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 778 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ePhase */

/* 780 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 782 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 784 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter fCantDeny */

/* 786 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 788 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 790 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppErrorInfoRem */

/* 792 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 794 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 796 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 798 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 800 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 802 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetSpecification */

/* 804 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 806 */	NdrFcLong( 0x0 ),	/* 0 */
/* 810 */	NdrFcShort( 0x3 ),	/* 3 */
/* 812 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 814 */	NdrFcShort( 0x44 ),	/* 68 */
/* 816 */	NdrFcShort( 0x8 ),	/* 8 */
/* 818 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 820 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 822 */	NdrFcShort( 0x1 ),	/* 1 */
/* 824 */	NdrFcShort( 0x0 ),	/* 0 */
/* 826 */	NdrFcShort( 0x0 ),	/* 0 */
/* 828 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter riid */

/* 830 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 832 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 834 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter ppObject */

/* 836 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 838 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 840 */	NdrFcShort( 0x5f6 ),	/* Type Offset=1526 */

	/* Parameter ppErrorInfoRem */

/* 842 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 844 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 846 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 848 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 850 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 852 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteOpenViewRowset */

/* 854 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 856 */	NdrFcLong( 0x0 ),	/* 0 */
/* 860 */	NdrFcShort( 0x4 ),	/* 4 */
/* 862 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 864 */	NdrFcShort( 0x44 ),	/* 68 */
/* 866 */	NdrFcShort( 0x8 ),	/* 8 */
/* 868 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 870 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 872 */	NdrFcShort( 0x1 ),	/* 1 */
/* 874 */	NdrFcShort( 0x0 ),	/* 0 */
/* 876 */	NdrFcShort( 0x0 ),	/* 0 */
/* 878 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pUnkOuter */

/* 880 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 882 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 884 */	NdrFcShort( 0x302 ),	/* Type Offset=770 */

	/* Parameter riid */

/* 886 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 888 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 890 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter ppRowset */

/* 892 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 894 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 896 */	NdrFcShort( 0x602 ),	/* Type Offset=1538 */

	/* Parameter ppErrorInfoRem */

/* 898 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 900 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 902 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 904 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 906 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 908 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetSpecification */

/* 910 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 912 */	NdrFcLong( 0x0 ),	/* 0 */
/* 916 */	NdrFcShort( 0x3 ),	/* 3 */
/* 918 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 920 */	NdrFcShort( 0x44 ),	/* 68 */
/* 922 */	NdrFcShort( 0x8 ),	/* 8 */
/* 924 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 926 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 928 */	NdrFcShort( 0x1 ),	/* 1 */
/* 930 */	NdrFcShort( 0x0 ),	/* 0 */
/* 932 */	NdrFcShort( 0x0 ),	/* 0 */
/* 934 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter riid */

/* 936 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 938 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 940 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter ppRowset */

/* 942 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 944 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 946 */	NdrFcShort( 0x60e ),	/* Type Offset=1550 */

	/* Parameter ppErrorInfoRem */

/* 948 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 950 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 952 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 954 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 956 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 958 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteOpenViewChapter */

/* 960 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 962 */	NdrFcLong( 0x0 ),	/* 0 */
/* 966 */	NdrFcShort( 0x4 ),	/* 4 */
/* 968 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 970 */	NdrFcShort( 0x8 ),	/* 8 */
/* 972 */	NdrFcShort( 0x24 ),	/* 36 */
/* 974 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 976 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 978 */	NdrFcShort( 0x0 ),	/* 0 */
/* 980 */	NdrFcShort( 0x0 ),	/* 0 */
/* 982 */	NdrFcShort( 0x0 ),	/* 0 */
/* 984 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter hSource */

/* 986 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 988 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 990 */	0xb9,		/* FC_UINT3264 */
			0x0,		/* 0 */

	/* Parameter phViewChapter */

/* 992 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 994 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 996 */	0xb9,		/* FC_UINT3264 */
			0x0,		/* 0 */

	/* Parameter ppErrorInfoRem */

/* 998 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1000 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1002 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 1004 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1006 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1008 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetSortOrder */

/* 1010 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1012 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1016 */	NdrFcShort( 0x3 ),	/* 3 */
/* 1018 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 1020 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1022 */	NdrFcShort( 0x2c ),	/* 44 */
/* 1024 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x5,		/* 5 */
/* 1026 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1028 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1030 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1032 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1034 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pcValues */

/* 1036 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 1038 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1040 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter prgColumns */

/* 1042 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1044 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1046 */	NdrFcShort( 0x61a ),	/* Type Offset=1562 */

	/* Parameter prgOrders */

/* 1048 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1050 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1052 */	NdrFcShort( 0x62e ),	/* Type Offset=1582 */

	/* Parameter ppErrorInfoRem */

/* 1054 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1056 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1058 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 1060 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1062 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1064 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteSetSortOrder */

/* 1066 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1068 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1072 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1074 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 1076 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1078 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1080 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 1082 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1084 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1086 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1088 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1090 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cValues */

/* 1092 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1094 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1096 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter rgColumns */

/* 1098 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1100 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1102 */	NdrFcShort( 0x646 ),	/* Type Offset=1606 */

	/* Parameter rgOrders */

/* 1104 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1106 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1108 */	NdrFcShort( 0x656 ),	/* Type Offset=1622 */

	/* Parameter ppErrorInfoRem */

/* 1110 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1112 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1114 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 1116 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1118 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1120 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetFilterBindings */

/* 1122 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1124 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1128 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1130 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1132 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1134 */	NdrFcShort( 0x2c ),	/* 44 */
/* 1136 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 1138 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1140 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1142 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1144 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1146 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pcBindings */

/* 1148 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 1150 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1152 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter prgBindings */

/* 1154 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 1156 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1158 */	NdrFcShort( 0x662 ),	/* Type Offset=1634 */

	/* Parameter ppErrorInfoRem */

/* 1160 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1162 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1164 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 1166 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1168 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1170 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteCreateView */

/* 1172 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1174 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1178 */	NdrFcShort( 0x3 ),	/* 3 */
/* 1180 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 1182 */	NdrFcShort( 0x44 ),	/* 68 */
/* 1184 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1186 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 1188 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1190 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1192 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1194 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1196 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pUnkOuter */

/* 1198 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1200 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1202 */	NdrFcShort( 0x302 ),	/* Type Offset=770 */

	/* Parameter riid */

/* 1204 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 1206 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1208 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter ppView */

/* 1210 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1212 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1214 */	NdrFcShort( 0x680 ),	/* Type Offset=1664 */

	/* Parameter ppErrorInfoRem */

/* 1216 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1218 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1220 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 1222 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1224 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1226 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetView */

/* 1228 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1230 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1234 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1236 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 1238 */	NdrFcShort( 0x4c ),	/* 76 */
/* 1240 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1242 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x6,		/* 6 */
/* 1244 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1246 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1248 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1250 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1252 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter hChapter */

/* 1254 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1256 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1258 */	0xb9,		/* FC_UINT3264 */
			0x0,		/* 0 */

	/* Parameter riid */

/* 1260 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 1262 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1264 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter phChapterSource */

/* 1266 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 1268 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1270 */	0xb9,		/* FC_UINT3264 */
			0x0,		/* 0 */

	/* Parameter ppView */

/* 1272 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1274 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1276 */	NdrFcShort( 0x68c ),	/* Type Offset=1676 */

	/* Parameter ppErrorInfoRem */

/* 1278 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1280 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1282 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 1284 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1286 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 1288 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteIsSameRow */

/* 1290 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1292 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1296 */	NdrFcShort( 0x3 ),	/* 3 */
/* 1298 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1300 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1302 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1304 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 1306 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1308 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1310 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1312 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1314 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter hThisRow */

/* 1316 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1318 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1320 */	0xb9,		/* FC_UINT3264 */
			0x0,		/* 0 */

	/* Parameter hThatRow */

/* 1322 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1324 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1326 */	0xb9,		/* FC_UINT3264 */
			0x0,		/* 0 */

	/* Parameter ppErrorInfoRem */

/* 1328 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1330 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1332 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 1334 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1336 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1338 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteOnFieldChange */

/* 1340 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1342 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1346 */	NdrFcShort( 0x3 ),	/* 3 */
/* 1348 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 1350 */	NdrFcShort( 0x30 ),	/* 48 */
/* 1352 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1354 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 1356 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1358 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1360 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1362 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1364 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pRowset */

/* 1366 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1368 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1370 */	NdrFcShort( 0x698 ),	/* Type Offset=1688 */

	/* Parameter hRow */

/* 1372 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1374 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1376 */	0xb9,		/* FC_UINT3264 */
			0x0,		/* 0 */

	/* Parameter cColumns */

/* 1378 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1380 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1382 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter rgColumns */

/* 1384 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1386 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1388 */	NdrFcShort( 0x6ae ),	/* Type Offset=1710 */

	/* Parameter eReason */

/* 1390 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1392 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1394 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ePhase */

/* 1396 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1398 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 1400 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter fCantDeny */

/* 1402 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1404 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 1406 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1408 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1410 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 1412 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteOnRowChange */

/* 1414 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1416 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1420 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1422 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 1424 */	NdrFcShort( 0x28 ),	/* 40 */
/* 1426 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1428 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 1430 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 1432 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1434 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1436 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1438 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pRowset */

/* 1440 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1442 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1444 */	NdrFcShort( 0x698 ),	/* Type Offset=1688 */

	/* Parameter cRows */

/* 1446 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1448 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1450 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter rghRows */

/* 1452 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 1454 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1456 */	NdrFcShort( 0x6be ),	/* Type Offset=1726 */

	/* Parameter eReason */

/* 1458 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1460 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1462 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ePhase */

/* 1464 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1466 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1468 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter fCantDeny */

/* 1470 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1472 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 1474 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1476 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1478 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 1480 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteOnRowsetChange */

/* 1482 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1484 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1488 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1490 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 1492 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1494 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1496 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 1498 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1500 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1502 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1504 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1506 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pRowset */

/* 1508 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1510 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1512 */	NdrFcShort( 0x698 ),	/* Type Offset=1688 */

	/* Parameter eReason */

/* 1514 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1516 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1518 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ePhase */

/* 1520 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1522 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1524 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter fCantDeny */

/* 1526 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1528 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1530 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 1532 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1534 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1536 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteExecute */

/* 1538 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1540 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1544 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1546 */	NdrFcShort( 0x78 ),	/* ia64 Stack size/offset = 120 */
/* 1548 */	NdrFcShort( 0xdc ),	/* 220 */
/* 1550 */	NdrFcShort( 0x2c ),	/* 44 */
/* 1552 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0xe,		/* 14 */
/* 1554 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1556 */	NdrFcShort( 0x8c ),	/* 140 */
/* 1558 */	NdrFcShort( 0x118 ),	/* 280 */
/* 1560 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1562 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pUnkOuter */

/* 1564 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1566 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1568 */	NdrFcShort( 0x302 ),	/* Type Offset=770 */

	/* Parameter riid */

/* 1570 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 1572 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1574 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter hAccessor */

/* 1576 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1578 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1580 */	0xb9,		/* FC_UINT3264 */
			0x0,		/* 0 */

	/* Parameter cParamSets */

/* 1582 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1584 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1586 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter pGuid */

/* 1588 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 1590 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1592 */	NdrFcShort( 0x6d0 ),	/* Type Offset=1744 */

	/* Parameter ulGuidOffset */

/* 1594 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1596 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 1598 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pInputParams */

/* 1600 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1602 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 1604 */	NdrFcShort( 0x6d4 ),	/* Type Offset=1748 */

	/* Parameter pOutputParams */

/* 1606 */	NdrFcShort( 0x1b ),	/* Flags:  must size, must free, in, out, */
/* 1608 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 1610 */	NdrFcShort( 0x6d4 ),	/* Type Offset=1748 */

	/* Parameter cBindings */

/* 1612 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1614 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 1616 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter rgBindings */

/* 1618 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1620 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 1622 */	NdrFcShort( 0xd22 ),	/* Type Offset=3362 */

	/* Parameter rgStatus */

/* 1624 */	NdrFcShort( 0x1b ),	/* Flags:  must size, must free, in, out, */
/* 1626 */	NdrFcShort( 0x58 ),	/* ia64 Stack size/offset = 88 */
/* 1628 */	NdrFcShort( 0xd3c ),	/* Type Offset=3388 */

	/* Parameter pcRowsAffected */

/* 1630 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 1632 */	NdrFcShort( 0x60 ),	/* ia64 Stack size/offset = 96 */
/* 1634 */	NdrFcShort( 0xd4c ),	/* Type Offset=3404 */

	/* Parameter ppRowset */

/* 1636 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 1638 */	NdrFcShort( 0x68 ),	/* ia64 Stack size/offset = 104 */
/* 1640 */	NdrFcShort( 0xd50 ),	/* Type Offset=3408 */

	/* Return value */

/* 1642 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1644 */	NdrFcShort( 0x70 ),	/* ia64 Stack size/offset = 112 */
/* 1646 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetDBSession */

/* 1648 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1650 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1654 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1656 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1658 */	NdrFcShort( 0x44 ),	/* 68 */
/* 1660 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1662 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 1664 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 1666 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1668 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1670 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1672 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter riid */

/* 1674 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 1676 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1678 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter ppSession */

/* 1680 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1682 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1684 */	NdrFcShort( 0xd5c ),	/* Type Offset=3420 */

	/* Parameter ppErrorInfoRem */

/* 1686 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1688 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1690 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 1692 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1694 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1696 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetResult */

/* 1698 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1700 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1704 */	NdrFcShort( 0x3 ),	/* 3 */
/* 1706 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 1708 */	NdrFcShort( 0x78 ),	/* 120 */
/* 1710 */	NdrFcShort( 0x2c ),	/* 44 */
/* 1712 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 1714 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1716 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1718 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1720 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1722 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pUnkOuter */

/* 1724 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1726 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1728 */	NdrFcShort( 0x302 ),	/* Type Offset=770 */

	/* Parameter lResultFlag */

/* 1730 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1732 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1734 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter riid */

/* 1736 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 1738 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1740 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter pcRowsAffected */

/* 1742 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 1744 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1746 */	NdrFcShort( 0xd4c ),	/* Type Offset=3404 */

	/* Parameter ppRowset */

/* 1748 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 1750 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1752 */	NdrFcShort( 0xd68 ),	/* Type Offset=3432 */

	/* Parameter ppErrorInfoRem */

/* 1754 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1756 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 1758 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 1760 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1762 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 1764 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteCanConvert */

/* 1766 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1768 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1772 */	NdrFcShort( 0x3 ),	/* 3 */
/* 1774 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 1776 */	NdrFcShort( 0x14 ),	/* 20 */
/* 1778 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1780 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x5,		/* 5 */
/* 1782 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1784 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1786 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1788 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1790 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter wFromType */

/* 1792 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1794 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1796 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Parameter wToType */

/* 1798 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1800 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1802 */	0x6,		/* FC_SHORT */
			0x0,		/* 0 */

	/* Parameter dwConvertFlags */

/* 1804 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1806 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1808 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppErrorInfoRem */

/* 1810 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1812 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1814 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 1816 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1818 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1820 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemotePrepare */

/* 1822 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1824 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1828 */	NdrFcShort( 0x3 ),	/* 3 */
/* 1830 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1832 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1834 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1836 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 1838 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1840 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1842 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1844 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1846 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cExpectedRuns */

/* 1848 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1850 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1852 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppErrorInfoRem */

/* 1854 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1856 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1858 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 1860 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1862 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1864 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteDestroyDataSource */


	/* Procedure RemoteUninitialize */


	/* Procedure RemoteUnprepare */

/* 1866 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1868 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1872 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1874 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1876 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1878 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1880 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 1882 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1884 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1886 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1888 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1890 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppErrorInfoRem */


	/* Parameter ppErrorInfoRem */


	/* Parameter ppErrorInfoRem */

/* 1892 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1894 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1896 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */


	/* Return value */


	/* Return value */

/* 1898 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1900 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1902 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteSetProperties */


	/* Procedure RemoteSetProperties */

/* 1904 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1906 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1910 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1912 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 1914 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1916 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1918 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 1920 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 1922 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1924 */	NdrFcShort( 0x24 ),	/* 36 */
/* 1926 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1928 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cPropertySets */


	/* Parameter cPropertySets */

/* 1930 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1932 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1934 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgPropertySets */


	/* Parameter rgPropertySets */

/* 1936 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 1938 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1940 */	NdrFcShort( 0xd74 ),	/* Type Offset=3444 */

	/* Parameter cTotalProps */


	/* Parameter cTotalProps */

/* 1942 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 1944 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1946 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgPropStatus */


	/* Parameter rgPropStatus */

/* 1948 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 1950 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 1952 */	NdrFcShort( 0xd92 ),	/* Type Offset=3474 */

	/* Parameter ppErrorInfoRem */


	/* Parameter ppErrorInfoRem */

/* 1954 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 1956 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1958 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */


	/* Return value */

/* 1960 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 1962 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 1964 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetCommandText */

/* 1966 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 1968 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1972 */	NdrFcShort( 0x6 ),	/* 6 */
/* 1974 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 1976 */	NdrFcShort( 0x44 ),	/* 68 */
/* 1978 */	NdrFcShort( 0x4c ),	/* 76 */
/* 1980 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 1982 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 1984 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1986 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1988 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1990 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pguidDialect */

/* 1992 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 1994 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1996 */	NdrFcShort( 0x6d0 ),	/* Type Offset=1744 */

	/* Parameter ppwszCommand */

/* 1998 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 2000 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2002 */	NdrFcShort( 0xd9e ),	/* Type Offset=3486 */

	/* Parameter ppErrorInfoRem */

/* 2004 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2006 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2008 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 2010 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2012 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 2014 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteSetCommandText */

/* 2016 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2018 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2022 */	NdrFcShort( 0x7 ),	/* 7 */
/* 2024 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 2026 */	NdrFcShort( 0x44 ),	/* 68 */
/* 2028 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2030 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 2032 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2034 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2036 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2038 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2040 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter rguidDialect */

/* 2042 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 2044 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2046 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter pwszCommand */

/* 2048 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2050 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2052 */	NdrFcShort( 0x9f8 ),	/* Type Offset=2552 */

	/* Parameter ppErrorInfoRem */

/* 2054 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2056 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2058 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 2060 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2062 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 2064 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetParameterInfo */

/* 2066 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2068 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2072 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2074 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 2076 */	NdrFcShort( 0x48 ),	/* 72 */
/* 2078 */	NdrFcShort( 0x50 ),	/* 80 */
/* 2080 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 2082 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 2084 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2086 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2088 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2090 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pcParams */

/* 2092 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 2094 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2096 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter prgParamInfo */

/* 2098 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 2100 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2102 */	NdrFcShort( 0xda2 ),	/* Type Offset=3490 */

	/* Parameter prgNameOffsets */

/* 2104 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 2106 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2108 */	NdrFcShort( 0xdda ),	/* Type Offset=3546 */

	/* Parameter pcbNamesBuffer */

/* 2110 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 2112 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 2114 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter ppNamesBuffer */

/* 2116 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 2118 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 2120 */	NdrFcShort( 0xdee ),	/* Type Offset=3566 */

	/* Parameter ppErrorInfoRem */

/* 2122 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2124 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 2126 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 2128 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2130 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 2132 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteMapParameterNames */

/* 2134 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2136 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2140 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2142 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 2144 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2146 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2148 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 2150 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 2152 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2154 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2156 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2158 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cParamNames */

/* 2160 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2162 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2164 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter rgParamNames */

/* 2166 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2168 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2170 */	NdrFcShort( 0xe06 ),	/* Type Offset=3590 */

	/* Parameter rgParamOrdinals */

/* 2172 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 2174 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2176 */	NdrFcShort( 0xe20 ),	/* Type Offset=3616 */

	/* Parameter ppErrorInfoRem */

/* 2178 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2180 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 2182 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 2184 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2186 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 2188 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteSetParameterInfo */

/* 2190 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2192 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2196 */	NdrFcShort( 0x5 ),	/* 5 */
/* 2198 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 2200 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2202 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2204 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 2206 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 2208 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2210 */	NdrFcShort( 0x2 ),	/* 2 */
/* 2212 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2214 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cParams */

/* 2216 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2218 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2220 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter rgParamOrdinals */

/* 2222 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2224 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2226 */	NdrFcShort( 0xe2c ),	/* Type Offset=3628 */

	/* Parameter rgParamBindInfo */

/* 2228 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2230 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2232 */	NdrFcShort( 0xe3c ),	/* Type Offset=3644 */

	/* Parameter ppErrorInfoRem */

/* 2234 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2236 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 2238 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 2240 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2242 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 2244 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetAvailableColumns */

/* 2246 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2248 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2252 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2254 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 2256 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2258 */	NdrFcShort( 0x2c ),	/* 44 */
/* 2260 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 2262 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2264 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2266 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2268 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2270 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pcOptColumns */

/* 2272 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 2274 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2276 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter prgOptColumns */

/* 2278 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 2280 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2282 */	NdrFcShort( 0xe6e ),	/* Type Offset=3694 */

	/* Parameter ppErrorInfoRem */

/* 2284 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2286 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2288 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 2290 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2292 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 2294 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetColumnsRowset */

/* 2296 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2298 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2302 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2304 */	NdrFcShort( 0x60 ),	/* ia64 Stack size/offset = 96 */
/* 2306 */	NdrFcShort( 0x64 ),	/* 100 */
/* 2308 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2310 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0xb,		/* 11 */
/* 2312 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 2314 */	NdrFcShort( 0x2 ),	/* 2 */
/* 2316 */	NdrFcShort( 0x27 ),	/* 39 */
/* 2318 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2320 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pUnkOuter */

/* 2322 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2324 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2326 */	NdrFcShort( 0x302 ),	/* Type Offset=770 */

	/* Parameter cOptColumns */

/* 2328 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2330 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2332 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter rgOptColumns */

/* 2334 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2336 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2338 */	NdrFcShort( 0xe8c ),	/* Type Offset=3724 */

	/* Parameter riid */

/* 2340 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 2342 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 2344 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter cPropertySets */

/* 2346 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2348 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 2350 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgPropertySets */

/* 2352 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2354 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 2356 */	NdrFcShort( 0xea6 ),	/* Type Offset=3750 */

	/* Parameter ppColRowset */

/* 2358 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2360 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 2362 */	NdrFcShort( 0xec0 ),	/* Type Offset=3776 */

	/* Parameter cTotalProps */

/* 2364 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2366 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 2368 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgPropStatus */

/* 2370 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 2372 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 2374 */	NdrFcShort( 0xed0 ),	/* Type Offset=3792 */

	/* Parameter ppErrorInfoRem */

/* 2376 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2378 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 2380 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 2382 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2384 */	NdrFcShort( 0x58 ),	/* ia64 Stack size/offset = 88 */
/* 2386 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetColumnInfo */

/* 2388 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2390 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2394 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2396 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 2398 */	NdrFcShort( 0x48 ),	/* 72 */
/* 2400 */	NdrFcShort( 0x50 ),	/* 80 */
/* 2402 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 2404 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 2406 */	NdrFcShort( 0x6 ),	/* 6 */
/* 2408 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2410 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2412 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pcColumns */

/* 2414 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 2416 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2418 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter prgInfo */

/* 2420 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 2422 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2424 */	NdrFcShort( 0xedc ),	/* Type Offset=3804 */

	/* Parameter prgNameOffsets */

/* 2426 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 2428 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2430 */	NdrFcShort( 0xf18 ),	/* Type Offset=3864 */

	/* Parameter prgcolumnidOffsets */

/* 2432 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 2434 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 2436 */	NdrFcShort( 0xf2c ),	/* Type Offset=3884 */

	/* Parameter pcbStringsBuffer */

/* 2438 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 2440 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 2442 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter ppStringsBuffer */

/* 2444 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 2446 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 2448 */	NdrFcShort( 0xf40 ),	/* Type Offset=3904 */

	/* Parameter ppErrorInfoRem */

/* 2450 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2452 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 2454 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 2456 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2458 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 2460 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteMapColumnIDs */

/* 2462 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2464 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2468 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2470 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 2472 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2474 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2476 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 2478 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 2480 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2482 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2484 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2486 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cColumnIDs */

/* 2488 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2490 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2492 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter rgColumnIDs */

/* 2494 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 2496 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2498 */	NdrFcShort( 0xf58 ),	/* Type Offset=3928 */

	/* Parameter rgColumns */

/* 2500 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 2502 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2504 */	NdrFcShort( 0xf72 ),	/* Type Offset=3954 */

	/* Parameter ppErrorInfoRem */

/* 2506 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2508 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 2510 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 2512 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2514 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 2516 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteCreateCommand */

/* 2518 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2520 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2524 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2526 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 2528 */	NdrFcShort( 0x44 ),	/* 68 */
/* 2530 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2532 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 2534 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2536 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2538 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2540 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2542 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pUnkOuter */

/* 2544 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2546 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2548 */	NdrFcShort( 0x302 ),	/* Type Offset=770 */

	/* Parameter riid */

/* 2550 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 2552 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2554 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter ppCommand */

/* 2556 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2558 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2560 */	NdrFcShort( 0xf7e ),	/* Type Offset=3966 */

	/* Parameter ppErrorInfoRem */

/* 2562 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2564 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 2566 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 2568 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2570 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 2572 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteCreateSession */

/* 2574 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2576 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2580 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2582 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 2584 */	NdrFcShort( 0x44 ),	/* 68 */
/* 2586 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2588 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 2590 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 2592 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2594 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2596 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2598 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pUnkOuter */

/* 2600 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2602 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2604 */	NdrFcShort( 0x302 ),	/* Type Offset=770 */

	/* Parameter riid */

/* 2606 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 2608 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2610 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter ppDBSession */

/* 2612 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2614 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2616 */	NdrFcShort( 0xf8a ),	/* Type Offset=3978 */

	/* Parameter ppErrorInfoRem */

/* 2618 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2620 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 2622 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 2624 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2626 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 2628 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetSourcesRowset */

/* 2630 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2632 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2636 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2638 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 2640 */	NdrFcShort( 0x54 ),	/* 84 */
/* 2642 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2644 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x9,		/* 9 */
/* 2646 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 2648 */	NdrFcShort( 0x2 ),	/* 2 */
/* 2650 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2652 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2654 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pUnkOuter */

/* 2656 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2658 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2660 */	NdrFcShort( 0x302 ),	/* Type Offset=770 */

	/* Parameter riid */

/* 2662 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 2664 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2666 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter cPropertySets */

/* 2668 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2670 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2672 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgProperties */

/* 2674 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2676 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 2678 */	NdrFcShort( 0xf96 ),	/* Type Offset=3990 */

	/* Parameter ppSourcesRowset */

/* 2680 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2682 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 2684 */	NdrFcShort( 0xfb0 ),	/* Type Offset=4016 */

	/* Parameter cTotalProps */

/* 2686 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2688 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 2690 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgPropStatus */

/* 2692 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 2694 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 2696 */	NdrFcShort( 0xfc0 ),	/* Type Offset=4032 */

	/* Parameter ppErrorInfoRem */

/* 2698 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2700 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 2702 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 2704 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2706 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 2708 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetPropertyInfo */

/* 2710 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2712 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2716 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2718 */	NdrFcShort( 0x58 ),	/* ia64 Stack size/offset = 88 */
/* 2720 */	NdrFcShort( 0x5c ),	/* 92 */
/* 2722 */	NdrFcShort( 0x5c ),	/* 92 */
/* 2724 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0xa,		/* 10 */
/* 2726 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 2728 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2730 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2732 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2734 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cPropertyIDSets */

/* 2736 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2738 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2740 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgPropertyIDSets */

/* 2742 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2744 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2746 */	NdrFcShort( 0xde ),	/* Type Offset=222 */

	/* Parameter pcPropertyInfoSets */

/* 2748 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 2750 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2752 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter prgPropertyInfoSets */

/* 2754 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 2756 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 2758 */	NdrFcShort( 0xfcc ),	/* Type Offset=4044 */

	/* Parameter pcOffsets */

/* 2760 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 2762 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 2764 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter prgDescOffsets */

/* 2766 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 2768 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 2770 */	NdrFcShort( 0x102a ),	/* Type Offset=4138 */

	/* Parameter pcbDescBuffer */

/* 2772 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 2774 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 2776 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppDescBuffer */

/* 2778 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 2780 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 2782 */	NdrFcShort( 0x103e ),	/* Type Offset=4158 */

	/* Parameter ppErrorInfoRem */

/* 2784 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2786 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 2788 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 2790 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2792 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 2794 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteSetProperties */

/* 2796 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2798 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2802 */	NdrFcShort( 0x5 ),	/* 5 */
/* 2804 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 2806 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2808 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2810 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 2812 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 2814 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2816 */	NdrFcShort( 0x24 ),	/* 36 */
/* 2818 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2820 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cPropertySets */

/* 2822 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2824 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2826 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgPropertySets */

/* 2828 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2830 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2832 */	NdrFcShort( 0xd74 ),	/* Type Offset=3444 */

	/* Parameter cTotalProps */

/* 2834 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2836 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2838 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgPropStatus */

/* 2840 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 2842 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 2844 */	NdrFcShort( 0xd92 ),	/* Type Offset=3474 */

	/* Parameter ppErrorInfoRem */

/* 2846 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2848 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 2850 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 2852 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2854 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 2856 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetKeywords */

/* 2858 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2860 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2864 */	NdrFcShort( 0x3 ),	/* 3 */
/* 2866 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 2868 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2870 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2872 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 2874 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 2876 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2878 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2880 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2882 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppwszKeywords */

/* 2884 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 2886 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2888 */	NdrFcShort( 0x1052 ),	/* Type Offset=4178 */

	/* Parameter ppErrorInfoRem */

/* 2890 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2892 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2894 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 2896 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2898 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2900 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetLiteralInfo */

/* 2902 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2904 */	NdrFcLong( 0x0 ),	/* 0 */
/* 2908 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2910 */	NdrFcShort( 0x60 ),	/* ia64 Stack size/offset = 96 */
/* 2912 */	NdrFcShort( 0x40 ),	/* 64 */
/* 2914 */	NdrFcShort( 0x40 ),	/* 64 */
/* 2916 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0xb,		/* 11 */
/* 2918 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 2920 */	NdrFcShort( 0x5 ),	/* 5 */
/* 2922 */	NdrFcShort( 0x2 ),	/* 2 */
/* 2924 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2926 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cLiterals */

/* 2928 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 2930 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 2932 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgLiterals */

/* 2934 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 2936 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 2938 */	NdrFcShort( 0x1056 ),	/* Type Offset=4182 */

	/* Parameter pcLiteralInfo */

/* 2940 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 2942 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 2944 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter prgLiteralInfo */

/* 2946 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 2948 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 2950 */	NdrFcShort( 0x1066 ),	/* Type Offset=4198 */

	/* Parameter prgLVOffsets */

/* 2952 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 2954 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 2956 */	NdrFcShort( 0x10a0 ),	/* Type Offset=4256 */

	/* Parameter prgICOffsets */

/* 2958 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 2960 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 2962 */	NdrFcShort( 0x10a0 ),	/* Type Offset=4256 */

	/* Parameter prgISCOffsets */

/* 2964 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 2966 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 2968 */	NdrFcShort( 0x10a0 ),	/* Type Offset=4256 */

	/* Parameter pcbCharBuffer */

/* 2970 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 2972 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 2974 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppCharBuffer */

/* 2976 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 2978 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 2980 */	NdrFcShort( 0x10b4 ),	/* Type Offset=4276 */

	/* Parameter ppErrorInfoRem */

/* 2982 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 2984 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 2986 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 2988 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 2990 */	NdrFcShort( 0x58 ),	/* ia64 Stack size/offset = 88 */
/* 2992 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteCreateDataSource */

/* 2994 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 2996 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3000 */	NdrFcShort( 0x3 ),	/* 3 */
/* 3002 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 3004 */	NdrFcShort( 0x54 ),	/* 84 */
/* 3006 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3008 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x9,		/* 9 */
/* 3010 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 3012 */	NdrFcShort( 0x2 ),	/* 2 */
/* 3014 */	NdrFcShort( 0x25 ),	/* 37 */
/* 3016 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3018 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cPropertySets */

/* 3020 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3022 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 3024 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgPropertySets */

/* 3026 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3028 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 3030 */	NdrFcShort( 0xd74 ),	/* Type Offset=3444 */

	/* Parameter pUnkOuter */

/* 3032 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3034 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 3036 */	NdrFcShort( 0x302 ),	/* Type Offset=770 */

	/* Parameter riid */

/* 3038 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 3040 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 3042 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter ppDBSession */

/* 3044 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 3046 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 3048 */	NdrFcShort( 0x10c8 ),	/* Type Offset=4296 */

	/* Parameter cTotalProps */

/* 3050 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3052 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 3054 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgPropStatus */

/* 3056 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 3058 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 3060 */	NdrFcShort( 0xfc0 ),	/* Type Offset=4032 */

	/* Parameter ppErrorInfoRem */

/* 3062 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3064 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 3066 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 3068 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3070 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 3072 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetCreationProperties */

/* 3074 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3076 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3080 */	NdrFcShort( 0x5 ),	/* 5 */
/* 3082 */	NdrFcShort( 0x58 ),	/* ia64 Stack size/offset = 88 */
/* 3084 */	NdrFcShort( 0x64 ),	/* 100 */
/* 3086 */	NdrFcShort( 0x64 ),	/* 100 */
/* 3088 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0xa,		/* 10 */
/* 3090 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 3092 */	NdrFcShort( 0x24 ),	/* 36 */
/* 3094 */	NdrFcShort( 0x3 ),	/* 3 */
/* 3096 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3098 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cPropertyIDSets */

/* 3100 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3102 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 3104 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgPropertyIDSets */

/* 3106 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3108 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 3110 */	NdrFcShort( 0xde ),	/* Type Offset=222 */

	/* Parameter pcPropertyInfoSets */

/* 3112 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 3114 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 3116 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter prgPropertyInfoSets */

/* 3118 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 3120 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 3122 */	NdrFcShort( 0xfcc ),	/* Type Offset=4044 */

	/* Parameter pcOffsets */

/* 3124 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 3126 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 3128 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter prgDescOffsets */

/* 3130 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 3132 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 3134 */	NdrFcShort( 0x10d4 ),	/* Type Offset=4308 */

	/* Parameter pcbDescBuffer */

/* 3136 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 3138 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 3140 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppDescBuffer */

/* 3142 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 3144 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 3146 */	NdrFcShort( 0x103e ),	/* Type Offset=4158 */

	/* Parameter ppErrorInfoRem */

/* 3148 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3150 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 3152 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 3154 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3156 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 3158 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteModifyDataSource */

/* 3160 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3162 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3166 */	NdrFcShort( 0x6 ),	/* 6 */
/* 3168 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 3170 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3172 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3174 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 3176 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 3178 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3180 */	NdrFcShort( 0x24 ),	/* 36 */
/* 3182 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3184 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cPropertySets */

/* 3186 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3188 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 3190 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgPropertySets */

/* 3192 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3194 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 3196 */	NdrFcShort( 0xd78 ),	/* Type Offset=3448 */

	/* Parameter ppErrorInfoRem */

/* 3198 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3200 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 3202 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 3204 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3206 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 3208 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteOnLowResource */

/* 3210 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3212 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3216 */	NdrFcShort( 0x3 ),	/* 3 */
/* 3218 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 3220 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3222 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3224 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 3226 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3228 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3230 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3232 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3234 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter dwReserved */

/* 3236 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3238 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 3240 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Return value */

/* 3242 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3244 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 3246 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteOnProgress */

/* 3248 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3250 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3254 */	NdrFcShort( 0x4 ),	/* 4 */
/* 3256 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 3258 */	NdrFcShort( 0x38 ),	/* 56 */
/* 3260 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3262 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 3264 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3266 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3268 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3270 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3272 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter hChapter */

/* 3274 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3276 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 3278 */	0xb9,		/* FC_UINT3264 */
			0x0,		/* 0 */

	/* Parameter eOperation */

/* 3280 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3282 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 3284 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ulProgress */

/* 3286 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3288 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 3290 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter ulProgressMax */

/* 3292 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3294 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 3296 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter eAsynchPhase */

/* 3298 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3300 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 3302 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pwszStatusText */

/* 3304 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3306 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 3308 */	NdrFcShort( 0x9f8 ),	/* Type Offset=2552 */

	/* Return value */

/* 3310 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3312 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 3314 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteOnStop */

/* 3316 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3318 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3322 */	NdrFcShort( 0x5 ),	/* 5 */
/* 3324 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 3326 */	NdrFcShort( 0x18 ),	/* 24 */
/* 3328 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3330 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 3332 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3334 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3336 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3338 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3340 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter hChapter */

/* 3342 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3344 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 3346 */	0xb9,		/* FC_UINT3264 */
			0x0,		/* 0 */

	/* Parameter eOperation */

/* 3348 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3350 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 3352 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter hrStatus */

/* 3354 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3356 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 3358 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pwszStatusText */

/* 3360 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3362 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 3364 */	NdrFcShort( 0x9f8 ),	/* Type Offset=2552 */

	/* Return value */

/* 3366 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3368 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 3370 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteAbort */

/* 3372 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3374 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3378 */	NdrFcShort( 0x3 ),	/* 3 */
/* 3380 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 3382 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3384 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3386 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 3388 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3390 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3392 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3394 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3396 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter hChapter */

/* 3398 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3400 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 3402 */	0xb9,		/* FC_UINT3264 */
			0x0,		/* 0 */

	/* Parameter eOperation */

/* 3404 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3406 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 3408 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppErrorInfoRem */

/* 3410 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3412 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 3414 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 3416 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3418 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 3420 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetStatus */

/* 3422 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3424 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3428 */	NdrFcShort( 0x4 ),	/* 4 */
/* 3430 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 3432 */	NdrFcShort( 0x74 ),	/* 116 */
/* 3434 */	NdrFcShort( 0x6c ),	/* 108 */
/* 3436 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 3438 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 3440 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3442 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3444 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3446 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter hChapter */

/* 3448 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3450 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 3452 */	0xb9,		/* FC_UINT3264 */
			0x0,		/* 0 */

	/* Parameter eOperation */

/* 3454 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3456 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 3458 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pulProgress */

/* 3460 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 3462 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 3464 */	NdrFcShort( 0xd4c ),	/* Type Offset=3404 */

	/* Parameter pulProgressMax */

/* 3466 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 3468 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 3470 */	NdrFcShort( 0xd4c ),	/* Type Offset=3404 */

	/* Parameter peAsynchPhase */

/* 3472 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 3474 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 3476 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ppwszStatusText */

/* 3478 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 3480 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 3482 */	NdrFcShort( 0x1052 ),	/* Type Offset=4178 */

	/* Parameter ppErrorInfoRem */

/* 3484 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3486 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 3488 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 3490 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3492 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 3494 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteCreateIndex */

/* 3496 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3498 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3502 */	NdrFcShort( 0x3 ),	/* 3 */
/* 3504 */	NdrFcShort( 0x60 ),	/* ia64 Stack size/offset = 96 */
/* 3506 */	NdrFcShort( 0x20 ),	/* 32 */
/* 3508 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3510 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0xb,		/* 11 */
/* 3512 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 3514 */	NdrFcShort( 0x3 ),	/* 3 */
/* 3516 */	NdrFcShort( 0x2d ),	/* 45 */
/* 3518 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3520 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pTableID */

/* 3522 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3524 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 3526 */	NdrFcShort( 0x1a0 ),	/* Type Offset=416 */

	/* Parameter pIndexID */

/* 3528 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3530 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 3532 */	NdrFcShort( 0x10f0 ),	/* Type Offset=4336 */

	/* Parameter cIndexColumnDescs */

/* 3534 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3536 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 3538 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter rgIndexColumnDescs */

/* 3540 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3542 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 3544 */	NdrFcShort( 0x1108 ),	/* Type Offset=4360 */

	/* Parameter cPropertySets */

/* 3546 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3548 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 3550 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgPropertySets */

/* 3552 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3554 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 3556 */	NdrFcShort( 0x111e ),	/* Type Offset=4382 */

	/* Parameter ppIndexID */

/* 3558 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 3560 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 3562 */	NdrFcShort( 0x1138 ),	/* Type Offset=4408 */

	/* Parameter cTotalProps */

/* 3564 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3566 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 3568 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgPropStatus */

/* 3570 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 3572 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 3574 */	NdrFcShort( 0x1144 ),	/* Type Offset=4420 */

	/* Parameter ppErrorInfoRem */

/* 3576 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3578 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 3580 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 3582 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3584 */	NdrFcShort( 0x58 ),	/* ia64 Stack size/offset = 88 */
/* 3586 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteDropIndex */

/* 3588 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3590 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3594 */	NdrFcShort( 0x4 ),	/* 4 */
/* 3596 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 3598 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3600 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3602 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 3604 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 3606 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3608 */	NdrFcShort( 0x4 ),	/* 4 */
/* 3610 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3612 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pTableID */

/* 3614 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3616 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 3618 */	NdrFcShort( 0x10f0 ),	/* Type Offset=4336 */

	/* Parameter pIndexID */

/* 3620 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3622 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 3624 */	NdrFcShort( 0x10f0 ),	/* Type Offset=4336 */

	/* Parameter ppErrorInfoRem */

/* 3626 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3628 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 3630 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 3632 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3634 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 3636 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteCreateTable */

/* 3638 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3640 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3644 */	NdrFcShort( 0x3 ),	/* 3 */
/* 3646 */	NdrFcShort( 0x78 ),	/* ia64 Stack size/offset = 120 */
/* 3648 */	NdrFcShort( 0x64 ),	/* 100 */
/* 3650 */	NdrFcShort( 0x24 ),	/* 36 */
/* 3652 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0xe,		/* 14 */
/* 3654 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 3656 */	NdrFcShort( 0x4 ),	/* 4 */
/* 3658 */	NdrFcShort( 0x50 ),	/* 80 */
/* 3660 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3662 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pUnkOuter */

/* 3664 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3666 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 3668 */	NdrFcShort( 0x302 ),	/* Type Offset=770 */

	/* Parameter pTableID */

/* 3670 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3672 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 3674 */	NdrFcShort( 0x10f0 ),	/* Type Offset=4336 */

	/* Parameter cColumnDescs */

/* 3676 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3678 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 3680 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter rgColumnDescs */

/* 3682 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3684 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 3686 */	NdrFcShort( 0x1192 ),	/* Type Offset=4498 */

	/* Parameter riid */

/* 3688 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 3690 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 3692 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter cPropertySets */

/* 3694 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3696 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 3698 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgPropertySets */

/* 3700 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3702 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 3704 */	NdrFcShort( 0x11a8 ),	/* Type Offset=4520 */

	/* Parameter ppTableID */

/* 3706 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 3708 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 3710 */	NdrFcShort( 0x1138 ),	/* Type Offset=4408 */

	/* Parameter ppRowset */

/* 3712 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 3714 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 3716 */	NdrFcShort( 0x11c2 ),	/* Type Offset=4546 */

	/* Parameter cTotalProps */

/* 3718 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3720 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 3722 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgPropStatus */

/* 3724 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 3726 */	NdrFcShort( 0x58 ),	/* ia64 Stack size/offset = 88 */
/* 3728 */	NdrFcShort( 0x11d2 ),	/* Type Offset=4562 */

	/* Parameter pfTableCreated */

/* 3730 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 3732 */	NdrFcShort( 0x60 ),	/* ia64 Stack size/offset = 96 */
/* 3734 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppErrorInfoRem */

/* 3736 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3738 */	NdrFcShort( 0x68 ),	/* ia64 Stack size/offset = 104 */
/* 3740 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 3742 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3744 */	NdrFcShort( 0x70 ),	/* ia64 Stack size/offset = 112 */
/* 3746 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteDropTable */

/* 3748 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3750 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3754 */	NdrFcShort( 0x4 ),	/* 4 */
/* 3756 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 3758 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3760 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3762 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x3,		/* 3 */
/* 3764 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 3766 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3768 */	NdrFcShort( 0x2 ),	/* 2 */
/* 3770 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3772 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pTableID */

/* 3774 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3776 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 3778 */	NdrFcShort( 0x10f0 ),	/* Type Offset=4336 */

	/* Parameter ppErrorInfoRem */

/* 3780 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3782 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 3784 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 3786 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3788 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 3790 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteAddColumn */

/* 3792 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3794 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3798 */	NdrFcShort( 0x5 ),	/* 5 */
/* 3800 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 3802 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3804 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3806 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 3808 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 3810 */	NdrFcShort( 0x3 ),	/* 3 */
/* 3812 */	NdrFcShort( 0x2a ),	/* 42 */
/* 3814 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3816 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pTableID */

/* 3818 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3820 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 3822 */	NdrFcShort( 0x1a0 ),	/* Type Offset=416 */

	/* Parameter pColumnDesc */

/* 3824 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 3826 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 3828 */	NdrFcShort( 0x116a ),	/* Type Offset=4458 */

	/* Parameter ppColumnID */

/* 3830 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 3832 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 3834 */	NdrFcShort( 0x1138 ),	/* Type Offset=4408 */

	/* Parameter cTotalProps */

/* 3836 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3838 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 3840 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgPropStatus */

/* 3842 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 3844 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 3846 */	NdrFcShort( 0x11e6 ),	/* Type Offset=4582 */

	/* Parameter ppErrorInfoRem */

/* 3848 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3850 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 3852 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 3854 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3856 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 3858 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteDropColumn */

/* 3860 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3862 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3866 */	NdrFcShort( 0x6 ),	/* 6 */
/* 3868 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 3870 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3872 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3874 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 3876 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 3878 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3880 */	NdrFcShort( 0x4 ),	/* 4 */
/* 3882 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3884 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pTableID */

/* 3886 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3888 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 3890 */	NdrFcShort( 0x10f0 ),	/* Type Offset=4336 */

	/* Parameter pColumnID */

/* 3892 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3894 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 3896 */	NdrFcShort( 0x10f0 ),	/* Type Offset=4336 */

	/* Parameter ppErrorInfoRem */

/* 3898 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3900 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 3902 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 3904 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3906 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 3908 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteOpenRowset */

/* 3910 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 3912 */	NdrFcLong( 0x0 ),	/* 0 */
/* 3916 */	NdrFcShort( 0x3 ),	/* 3 */
/* 3918 */	NdrFcShort( 0x60 ),	/* ia64 Stack size/offset = 96 */
/* 3920 */	NdrFcShort( 0x54 ),	/* 84 */
/* 3922 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3924 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0xb,		/* 11 */
/* 3926 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 3928 */	NdrFcShort( 0x2 ),	/* 2 */
/* 3930 */	NdrFcShort( 0x29 ),	/* 41 */
/* 3932 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3934 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pUnkOuter */

/* 3936 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3938 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 3940 */	NdrFcShort( 0x302 ),	/* Type Offset=770 */

	/* Parameter pTableID */

/* 3942 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3944 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 3946 */	NdrFcShort( 0x10f0 ),	/* Type Offset=4336 */

	/* Parameter pIndexID */

/* 3948 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3950 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 3952 */	NdrFcShort( 0x10f0 ),	/* Type Offset=4336 */

	/* Parameter riid */

/* 3954 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 3956 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 3958 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter cPropertySets */

/* 3960 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3962 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 3964 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgPropertySets */

/* 3966 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 3968 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 3970 */	NdrFcShort( 0x111e ),	/* Type Offset=4382 */

	/* Parameter ppRowset */

/* 3972 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 3974 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 3976 */	NdrFcShort( 0x11f2 ),	/* Type Offset=4594 */

	/* Parameter cTotalProps */

/* 3978 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 3980 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 3982 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgPropStatus */

/* 3984 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 3986 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 3988 */	NdrFcShort( 0x1144 ),	/* Type Offset=4420 */

	/* Parameter ppErrorInfoRem */

/* 3990 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 3992 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 3994 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 3996 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 3998 */	NdrFcShort( 0x58 ),	/* ia64 Stack size/offset = 88 */
/* 4000 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetRowset */

/* 4002 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4004 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4008 */	NdrFcShort( 0x3 ),	/* 3 */
/* 4010 */	NdrFcShort( 0x68 ),	/* ia64 Stack size/offset = 104 */
/* 4012 */	NdrFcShort( 0xa0 ),	/* 160 */
/* 4014 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4016 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0xc,		/* 12 */
/* 4018 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 4020 */	NdrFcShort( 0x2 ),	/* 2 */
/* 4022 */	NdrFcShort( 0x45 ),	/* 69 */
/* 4024 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4026 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pUnkOuter */

/* 4028 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 4030 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 4032 */	NdrFcShort( 0x302 ),	/* Type Offset=770 */

	/* Parameter rguidSchema */

/* 4034 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 4036 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 4038 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter cRestrictions */

/* 4040 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4042 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 4044 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgRestrictions */

/* 4046 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 4048 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 4050 */	NdrFcShort( 0x11fe ),	/* Type Offset=4606 */

	/* Parameter riid */

/* 4052 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 4054 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 4056 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter cPropertySets */

/* 4058 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4060 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 4062 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgPropertySets */

/* 4064 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 4066 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 4068 */	NdrFcShort( 0x11a8 ),	/* Type Offset=4520 */

	/* Parameter ppRowset */

/* 4070 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4072 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 4074 */	NdrFcShort( 0x1218 ),	/* Type Offset=4632 */

	/* Parameter cTotalProps */

/* 4076 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4078 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 4080 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgPropStatus */

/* 4082 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 4084 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 4086 */	NdrFcShort( 0x1228 ),	/* Type Offset=4648 */

	/* Parameter ppErrorInfoRem */

/* 4088 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4090 */	NdrFcShort( 0x58 ),	/* ia64 Stack size/offset = 88 */
/* 4092 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 4094 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4096 */	NdrFcShort( 0x60 ),	/* ia64 Stack size/offset = 96 */
/* 4098 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetSchemas */

/* 4100 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4102 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4106 */	NdrFcShort( 0x4 ),	/* 4 */
/* 4108 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 4110 */	NdrFcShort( 0x1c ),	/* 28 */
/* 4112 */	NdrFcShort( 0x24 ),	/* 36 */
/* 4114 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x5,		/* 5 */
/* 4116 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 4118 */	NdrFcShort( 0x2 ),	/* 2 */
/* 4120 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4122 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4124 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pcSchemas */

/* 4126 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 4128 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 4130 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter prgSchemas */

/* 4132 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 4134 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 4136 */	NdrFcShort( 0x1234 ),	/* Type Offset=4660 */

	/* Parameter prgRestrictionSupport */

/* 4138 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 4140 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 4142 */	NdrFcShort( 0x124c ),	/* Type Offset=4684 */

	/* Parameter ppErrorInfoRem */

/* 4144 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4146 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 4148 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 4150 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4152 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 4154 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteAddErrorRecord */

/* 4156 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4158 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4162 */	NdrFcShort( 0x3 ),	/* 3 */
/* 4164 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 4166 */	NdrFcShort( 0xa0 ),	/* 160 */
/* 4168 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4170 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x7,		/* 7 */
/* 4172 */	0xa,		/* 10 */
			0x5,		/* Ext Flags:  new corr desc, srv corr check, */
/* 4174 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4176 */	NdrFcShort( 0x22 ),	/* 34 */
/* 4178 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4180 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pErrorInfo */

/* 4182 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 4184 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 4186 */	NdrFcShort( 0x1264 ),	/* Type Offset=4708 */

	/* Parameter dwLookupID */

/* 4188 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4190 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 4192 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pdispparams */

/* 4194 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 4196 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 4198 */	NdrFcShort( 0x129a ),	/* Type Offset=4762 */

	/* Parameter punkCustomError */

/* 4200 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 4202 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 4204 */	NdrFcShort( 0x302 ),	/* Type Offset=770 */

	/* Parameter dwDynamicErrorID */

/* 4206 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4208 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 4210 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppErrorInfoRem */

/* 4212 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4214 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 4216 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 4218 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4220 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 4222 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetBasicErrorInfo */

/* 4224 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4226 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4230 */	NdrFcShort( 0x4 ),	/* 4 */
/* 4232 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 4234 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4236 */	NdrFcShort( 0x98 ),	/* 152 */
/* 4238 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 4240 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 4242 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4244 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4246 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4248 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulRecordNum */

/* 4250 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4252 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 4254 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pErrorInfo */

/* 4256 */	NdrFcShort( 0xc112 ),	/* Flags:  must free, out, simple ref, srv alloc size=48 */
/* 4258 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 4260 */	NdrFcShort( 0x1264 ),	/* Type Offset=4708 */

	/* Parameter ppErrorInfoRem */

/* 4262 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4264 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 4266 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 4268 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4270 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 4272 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetCustomErrorObject */

/* 4274 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4276 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4280 */	NdrFcShort( 0x5 ),	/* 5 */
/* 4282 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 4284 */	NdrFcShort( 0x4c ),	/* 76 */
/* 4286 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4288 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x5,		/* 5 */
/* 4290 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 4292 */	NdrFcShort( 0x1 ),	/* 1 */
/* 4294 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4296 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4298 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulRecordNum */

/* 4300 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4302 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 4304 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter riid */

/* 4306 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 4308 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 4310 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter ppObject */

/* 4312 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4314 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 4316 */	NdrFcShort( 0x12b4 ),	/* Type Offset=4788 */

	/* Parameter ppErrorInfoRem */

/* 4318 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4320 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 4322 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 4324 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4326 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 4328 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetErrorInfo */

/* 4330 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4332 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4336 */	NdrFcShort( 0x6 ),	/* 6 */
/* 4338 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 4340 */	NdrFcShort( 0x10 ),	/* 16 */
/* 4342 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4344 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x5,		/* 5 */
/* 4346 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 4348 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4350 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4352 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4354 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulRecordNum */

/* 4356 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4358 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 4360 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter lcid */

/* 4362 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4364 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 4366 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppErrorInfo */

/* 4368 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4370 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 4372 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Parameter ppErrorInfoRem */

/* 4374 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4376 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 4378 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 4380 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4382 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 4384 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetErrorParameters */

/* 4386 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4388 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4392 */	NdrFcShort( 0x7 ),	/* 7 */
/* 4394 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 4396 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4398 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4400 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 4402 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 4404 */	NdrFcShort( 0x22 ),	/* 34 */
/* 4406 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4408 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4410 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulRecordNum */

/* 4412 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4414 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 4416 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pdispparams */

/* 4418 */	NdrFcShort( 0x6113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=24 */
/* 4420 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 4422 */	NdrFcShort( 0x129a ),	/* Type Offset=4762 */

	/* Parameter ppErrorInfoRem */

/* 4424 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4426 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 4428 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 4430 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4432 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 4434 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetRecordCount */

/* 4436 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4438 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4442 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4444 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 4446 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4448 */	NdrFcShort( 0x24 ),	/* 36 */
/* 4450 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 4452 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 4454 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4456 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4458 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4460 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pcRecords */

/* 4462 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 4464 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 4466 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppErrorInfoRem */

/* 4468 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4470 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 4472 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 4474 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4476 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 4478 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetErrorDescription */

/* 4480 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4482 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4486 */	NdrFcShort( 0x3 ),	/* 3 */
/* 4488 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 4490 */	NdrFcShort( 0x18 ),	/* 24 */
/* 4492 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4494 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x8,		/* 8 */
/* 4496 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 4498 */	NdrFcShort( 0x2 ),	/* 2 */
/* 4500 */	NdrFcShort( 0x22 ),	/* 34 */
/* 4502 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4504 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter hrError */

/* 4506 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4508 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 4510 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwLookupID */

/* 4512 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4514 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 4516 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pdispparams */

/* 4518 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 4520 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 4522 */	NdrFcShort( 0x129a ),	/* Type Offset=4762 */

	/* Parameter lcid */

/* 4524 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4526 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 4528 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pbstrSource */

/* 4530 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 4532 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 4534 */	NdrFcShort( 0x12c8 ),	/* Type Offset=4808 */

	/* Parameter pbstrDescription */

/* 4536 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 4538 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 4540 */	NdrFcShort( 0x12c8 ),	/* Type Offset=4808 */

	/* Parameter ppErrorInfoRem */

/* 4542 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4544 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 4546 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 4548 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4550 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 4552 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetHelpInfo */

/* 4554 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4556 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4560 */	NdrFcShort( 0x4 ),	/* 4 */
/* 4562 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 4564 */	NdrFcShort( 0x18 ),	/* 24 */
/* 4566 */	NdrFcShort( 0x24 ),	/* 36 */
/* 4568 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x7,		/* 7 */
/* 4570 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 4572 */	NdrFcShort( 0x1 ),	/* 1 */
/* 4574 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4576 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4578 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter hrError */

/* 4580 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4582 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 4584 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter dwLookupID */

/* 4586 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4588 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 4590 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter lcid */

/* 4592 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4594 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 4596 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pbstrHelpFile */

/* 4598 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 4600 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 4602 */	NdrFcShort( 0x12c8 ),	/* Type Offset=4808 */

	/* Parameter pdwHelpContext */

/* 4604 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 4606 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 4608 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppErrorInfoRem */

/* 4610 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4612 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 4614 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 4616 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4618 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 4620 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteReleaseErrors */

/* 4622 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4624 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4628 */	NdrFcShort( 0x5 ),	/* 5 */
/* 4630 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 4632 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4634 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4636 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 4638 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 4640 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4642 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4644 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4646 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter dwDynamicErrorID */

/* 4648 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4650 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 4652 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppErrorInfoRem */

/* 4654 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4656 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 4658 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 4660 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4662 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 4664 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetSQLInfo */

/* 4666 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4668 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4672 */	NdrFcShort( 0x3 ),	/* 3 */
/* 4674 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 4676 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4678 */	NdrFcShort( 0x24 ),	/* 36 */
/* 4680 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 4682 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 4684 */	NdrFcShort( 0x1 ),	/* 1 */
/* 4686 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4688 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4690 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pbstrSQLState */

/* 4692 */	NdrFcShort( 0x2113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=8 */
/* 4694 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 4696 */	NdrFcShort( 0x12c8 ),	/* Type Offset=4808 */

	/* Parameter plNativeError */

/* 4698 */	NdrFcShort( 0x2150 ),	/* Flags:  out, base type, simple ref, srv alloc size=8 */
/* 4700 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 4702 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppErrorInfoRem */

/* 4704 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4706 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 4708 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 4710 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4712 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 4714 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetDataSource */

/* 4716 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4718 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4722 */	NdrFcShort( 0x3 ),	/* 3 */
/* 4724 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 4726 */	NdrFcShort( 0x44 ),	/* 68 */
/* 4728 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4730 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 4732 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 4734 */	NdrFcShort( 0x1 ),	/* 1 */
/* 4736 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4738 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4740 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter riid */

/* 4742 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 4744 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 4746 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter ppDataSource */

/* 4748 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4750 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 4752 */	NdrFcShort( 0x12d2 ),	/* Type Offset=4818 */

	/* Parameter ppErrorInfoRem */

/* 4754 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4756 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 4758 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 4760 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4762 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 4764 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetOptionsObject */

/* 4766 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4768 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4772 */	NdrFcShort( 0x6 ),	/* 6 */
/* 4774 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 4776 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4778 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4780 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 4782 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 4784 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4786 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4788 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4790 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppOptions */

/* 4792 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4794 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 4796 */	NdrFcShort( 0x12de ),	/* Type Offset=4830 */

	/* Parameter ppErrorInfoRem */

/* 4798 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4800 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 4802 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 4804 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4806 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 4808 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteStartTransaction */

/* 4810 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4812 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4816 */	NdrFcShort( 0x7 ),	/* 7 */
/* 4818 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 4820 */	NdrFcShort( 0x2c ),	/* 44 */
/* 4822 */	NdrFcShort( 0x24 ),	/* 36 */
/* 4824 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 4826 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 4828 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4830 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4832 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4834 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter isoLevel */

/* 4836 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4838 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 4840 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter isoFlags */

/* 4842 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4844 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 4846 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pOtherOptions */

/* 4848 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 4850 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 4852 */	NdrFcShort( 0x12e2 ),	/* Type Offset=4834 */

	/* Parameter pulTransactionLevel */

/* 4854 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 4856 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 4858 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ppErrorInfoRem */

/* 4860 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4862 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 4864 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 4866 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4868 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 4870 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetOptionsObject */

/* 4872 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4874 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4878 */	NdrFcShort( 0x3 ),	/* 3 */
/* 4880 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 4882 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4884 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4886 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 4888 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 4890 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4892 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4894 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4896 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppOptions */

/* 4898 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4900 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 4902 */	NdrFcShort( 0x12de ),	/* Type Offset=4830 */

	/* Parameter ppErrorInfoRem */

/* 4904 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4906 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 4908 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 4910 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4912 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 4914 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteJoinTransaction */

/* 4916 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4918 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4922 */	NdrFcShort( 0x4 ),	/* 4 */
/* 4924 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 4926 */	NdrFcShort( 0x10 ),	/* 16 */
/* 4928 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4930 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 4932 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 4934 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4936 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4938 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4940 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter punkTransactionCoord */

/* 4942 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 4944 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 4946 */	NdrFcShort( 0x302 ),	/* Type Offset=770 */

	/* Parameter isoLevel */

/* 4948 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4950 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 4952 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter isoFlags */

/* 4954 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 4956 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 4958 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pOtherOptions */

/* 4960 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 4962 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 4964 */	NdrFcShort( 0x12e2 ),	/* Type Offset=4834 */

	/* Parameter ppErrorInfoRem */

/* 4966 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 4968 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 4970 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 4972 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 4974 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 4976 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetTransactionObject */

/* 4978 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 4980 */	NdrFcLong( 0x0 ),	/* 0 */
/* 4984 */	NdrFcShort( 0x3 ),	/* 3 */
/* 4986 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 4988 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4990 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4992 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x4,		/* 4 */
/* 4994 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 4996 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4998 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5000 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5002 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ulTransactionLevel */

/* 5004 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5006 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 5008 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppTransactionObject */

/* 5010 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5012 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 5014 */	NdrFcShort( 0x12f4 ),	/* Type Offset=4852 */

	/* Parameter ppErrorInfoRem */

/* 5016 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5018 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 5020 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */

	/* Return value */

/* 5022 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5024 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 5026 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteBind */

/* 5028 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5030 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5034 */	NdrFcShort( 0x3 ),	/* 3 */
/* 5036 */	NdrFcShort( 0x68 ),	/* ia64 Stack size/offset = 104 */
/* 5038 */	NdrFcShort( 0xf0 ),	/* 240 */
/* 5040 */	NdrFcShort( 0x24 ),	/* 36 */
/* 5042 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0xc,		/* 12 */
/* 5044 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 5046 */	NdrFcShort( 0x2 ),	/* 2 */
/* 5048 */	NdrFcShort( 0x1 ),	/* 1 */
/* 5050 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5052 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pUnkOuter */

/* 5054 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5056 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 5058 */	NdrFcShort( 0x302 ),	/* Type Offset=770 */

	/* Parameter pwszURL */

/* 5060 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 5062 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 5064 */	NdrFcShort( 0x130c ),	/* Type Offset=4876 */

	/* Parameter dwBindURLFlags */

/* 5066 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5068 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 5070 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rguid */

/* 5072 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 5074 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 5076 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter riid */

/* 5078 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 5080 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 5082 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter pAuthenticate */

/* 5084 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5086 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 5088 */	NdrFcShort( 0x130e ),	/* Type Offset=4878 */

	/* Parameter pSessionUnkOuter */

/* 5090 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5092 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 5094 */	NdrFcShort( 0x302 ),	/* Type Offset=770 */

	/* Parameter piid */

/* 5096 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 5098 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 5100 */	NdrFcShort( 0x6d0 ),	/* Type Offset=1744 */

	/* Parameter ppSession */

/* 5102 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 5104 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 5106 */	NdrFcShort( 0x1320 ),	/* Type Offset=4896 */

	/* Parameter pdwBindStatus */

/* 5108 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 5110 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 5112 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ppUnk */

/* 5114 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5116 */	NdrFcShort( 0x58 ),	/* ia64 Stack size/offset = 88 */
/* 5118 */	NdrFcShort( 0x132c ),	/* Type Offset=4908 */

	/* Return value */

/* 5120 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5122 */	NdrFcShort( 0x60 ),	/* ia64 Stack size/offset = 96 */
/* 5124 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteCopy */

/* 5126 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5128 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5132 */	NdrFcShort( 0x4 ),	/* 4 */
/* 5134 */	NdrFcShort( 0x58 ),	/* ia64 Stack size/offset = 88 */
/* 5136 */	NdrFcShort( 0x34 ),	/* 52 */
/* 5138 */	NdrFcShort( 0x24 ),	/* 36 */
/* 5140 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0xa,		/* 10 */
/* 5142 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 5144 */	NdrFcShort( 0x3 ),	/* 3 */
/* 5146 */	NdrFcShort( 0x3 ),	/* 3 */
/* 5148 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5150 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cRows */

/* 5152 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5154 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 5156 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter rgpwszSourceURLs */

/* 5158 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 5160 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 5162 */	NdrFcShort( 0x133c ),	/* Type Offset=4924 */

	/* Parameter rgpwszDestURLs */

/* 5164 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 5166 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 5168 */	NdrFcShort( 0x1356 ),	/* Type Offset=4950 */

	/* Parameter dwCopyFlags */

/* 5170 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5172 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 5174 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pAuthenticate */

/* 5176 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5178 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 5180 */	NdrFcShort( 0x130e ),	/* Type Offset=4878 */

	/* Parameter rgdwStatus */

/* 5182 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 5184 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 5186 */	NdrFcShort( 0x1370 ),	/* Type Offset=4976 */

	/* Parameter prgulNewURLOffsets */

/* 5188 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 5190 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 5192 */	NdrFcShort( 0x137c ),	/* Type Offset=4988 */

	/* Parameter pcbStringsBuffer */

/* 5194 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 5196 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 5198 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppStringsBuffer */

/* 5200 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 5202 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 5204 */	NdrFcShort( 0x10b4 ),	/* Type Offset=4276 */

	/* Return value */

/* 5206 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5208 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 5210 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteMove */

/* 5212 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5214 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5218 */	NdrFcShort( 0x5 ),	/* 5 */
/* 5220 */	NdrFcShort( 0x58 ),	/* ia64 Stack size/offset = 88 */
/* 5222 */	NdrFcShort( 0x34 ),	/* 52 */
/* 5224 */	NdrFcShort( 0x24 ),	/* 36 */
/* 5226 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0xa,		/* 10 */
/* 5228 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 5230 */	NdrFcShort( 0x3 ),	/* 3 */
/* 5232 */	NdrFcShort( 0x3 ),	/* 3 */
/* 5234 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5236 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cRows */

/* 5238 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5240 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 5242 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter rgpwszSourceURLs */

/* 5244 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 5246 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 5248 */	NdrFcShort( 0x1394 ),	/* Type Offset=5012 */

	/* Parameter rgpwszDestURLs */

/* 5250 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 5252 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 5254 */	NdrFcShort( 0x13ae ),	/* Type Offset=5038 */

	/* Parameter dwMoveFlags */

/* 5256 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5258 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 5260 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pAuthenticate */

/* 5262 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5264 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 5266 */	NdrFcShort( 0x130e ),	/* Type Offset=4878 */

	/* Parameter rgdwStatus */

/* 5268 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 5270 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 5272 */	NdrFcShort( 0x13c8 ),	/* Type Offset=5064 */

	/* Parameter prgulNewURLOffsets */

/* 5274 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 5276 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 5278 */	NdrFcShort( 0x13d4 ),	/* Type Offset=5076 */

	/* Parameter pcbStringsBuffer */

/* 5280 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 5282 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 5284 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter ppStringsBuffer */

/* 5286 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 5288 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 5290 */	NdrFcShort( 0x10b4 ),	/* Type Offset=4276 */

	/* Return value */

/* 5292 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5294 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 5296 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteDelete */

/* 5298 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5300 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5304 */	NdrFcShort( 0x6 ),	/* 6 */
/* 5306 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 5308 */	NdrFcShort( 0x18 ),	/* 24 */
/* 5310 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5312 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x5,		/* 5 */
/* 5314 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 5316 */	NdrFcShort( 0x1 ),	/* 1 */
/* 5318 */	NdrFcShort( 0x1 ),	/* 1 */
/* 5320 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5322 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cRows */

/* 5324 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5326 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 5328 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter rgpwszURLs */

/* 5330 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 5332 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 5334 */	NdrFcShort( 0x13ec ),	/* Type Offset=5100 */

	/* Parameter dwDeleteFlags */

/* 5336 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5338 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 5340 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgdwStatus */

/* 5342 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 5344 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 5346 */	NdrFcShort( 0x1406 ),	/* Type Offset=5126 */

	/* Return value */

/* 5348 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5350 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 5352 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteOpenRowset */

/* 5354 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5356 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5360 */	NdrFcShort( 0x7 ),	/* 7 */
/* 5362 */	NdrFcShort( 0x58 ),	/* ia64 Stack size/offset = 88 */
/* 5364 */	NdrFcShort( 0x54 ),	/* 84 */
/* 5366 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5368 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0xa,		/* 10 */
/* 5370 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 5372 */	NdrFcShort( 0x2 ),	/* 2 */
/* 5374 */	NdrFcShort( 0x29 ),	/* 41 */
/* 5376 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5378 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pUnkOuter */

/* 5380 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5382 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 5384 */	NdrFcShort( 0x302 ),	/* Type Offset=770 */

	/* Parameter pTableID */

/* 5386 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5388 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 5390 */	NdrFcShort( 0x10f0 ),	/* Type Offset=4336 */

	/* Parameter pIndexID */

/* 5392 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5394 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 5396 */	NdrFcShort( 0x10f0 ),	/* Type Offset=4336 */

	/* Parameter riid */

/* 5398 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 5400 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 5402 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter cPropertySets */

/* 5404 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5406 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 5408 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgPropertySets */

/* 5410 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5412 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 5414 */	NdrFcShort( 0x111e ),	/* Type Offset=4382 */

	/* Parameter ppRowset */

/* 5416 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 5418 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 5420 */	NdrFcShort( 0x1412 ),	/* Type Offset=5138 */

	/* Parameter cTotalProps */

/* 5422 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5424 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 5426 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rgPropStatus */

/* 5428 */	NdrFcShort( 0x113 ),	/* Flags:  must size, must free, out, simple ref, */
/* 5430 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 5432 */	NdrFcShort( 0x1144 ),	/* Type Offset=4420 */

	/* Return value */

/* 5434 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5436 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 5438 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteCreateRow */

/* 5440 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5442 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5446 */	NdrFcShort( 0x3 ),	/* 3 */
/* 5448 */	NdrFcShort( 0x70 ),	/* ia64 Stack size/offset = 112 */
/* 5450 */	NdrFcShort( 0xf0 ),	/* 240 */
/* 5452 */	NdrFcShort( 0x24 ),	/* 36 */
/* 5454 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0xd,		/* 13 */
/* 5456 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 5458 */	NdrFcShort( 0x2 ),	/* 2 */
/* 5460 */	NdrFcShort( 0x1 ),	/* 1 */
/* 5462 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5464 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pUnkOuter */

/* 5466 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5468 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 5470 */	NdrFcShort( 0x302 ),	/* Type Offset=770 */

	/* Parameter pwszURL */

/* 5472 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 5474 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 5476 */	NdrFcShort( 0x130c ),	/* Type Offset=4876 */

	/* Parameter dwBindURLFlags */

/* 5478 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5480 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 5482 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter rguid */

/* 5484 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 5486 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 5488 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter riid */

/* 5490 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 5492 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 5494 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter pAuthenticate */

/* 5496 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5498 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 5500 */	NdrFcShort( 0x130e ),	/* Type Offset=4878 */

	/* Parameter pSessionUnkOuter */

/* 5502 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5504 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 5506 */	NdrFcShort( 0x302 ),	/* Type Offset=770 */

	/* Parameter piid */

/* 5508 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 5510 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 5512 */	NdrFcShort( 0x6d0 ),	/* Type Offset=1744 */

	/* Parameter ppSession */

/* 5514 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 5516 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 5518 */	NdrFcShort( 0x141e ),	/* Type Offset=5150 */

	/* Parameter pdwBindStatus */

/* 5520 */	NdrFcShort( 0x1a ),	/* Flags:  must free, in, out, */
/* 5522 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 5524 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter ppwszNewURL */

/* 5526 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 5528 */	NdrFcShort( 0x58 ),	/* ia64 Stack size/offset = 88 */
/* 5530 */	NdrFcShort( 0x1052 ),	/* Type Offset=4178 */

	/* Parameter ppUnk */

/* 5532 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5534 */	NdrFcShort( 0x60 ),	/* ia64 Stack size/offset = 96 */
/* 5536 */	NdrFcShort( 0x142a ),	/* Type Offset=5162 */

	/* Return value */

/* 5538 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5540 */	NdrFcShort( 0x68 ),	/* ia64 Stack size/offset = 104 */
/* 5542 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Reset */

/* 5544 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5546 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5550 */	NdrFcShort( 0x6 ),	/* 6 */
/* 5552 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 5554 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5556 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5558 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 5560 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 5562 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5564 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5566 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5568 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 5570 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5572 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 5574 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetRestrictedColumnInfo */

/* 5576 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5578 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5582 */	NdrFcShort( 0x5 ),	/* 5 */
/* 5584 */	NdrFcShort( 0x60 ),	/* ia64 Stack size/offset = 96 */
/* 5586 */	NdrFcShort( 0x60 ),	/* 96 */
/* 5588 */	NdrFcShort( 0x50 ),	/* 80 */
/* 5590 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0xb,		/* 11 */
/* 5592 */	0xa,		/* 10 */
			0x7,		/* Ext Flags:  new corr desc, clt corr check, srv corr check, */
/* 5594 */	NdrFcShort( 0x9 ),	/* 9 */
/* 5596 */	NdrFcShort( 0xa ),	/* 10 */
/* 5598 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5600 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter cColumnIDMasks */

/* 5602 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5604 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 5606 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter rgColumnIDMasks */

/* 5608 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5610 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 5612 */	NdrFcShort( 0x1436 ),	/* Type Offset=5174 */

	/* Parameter dwFlags */

/* 5614 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5616 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 5618 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pcColumns */

/* 5620 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 5622 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 5624 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter prgColumnIDs */

/* 5626 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 5628 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 5630 */	NdrFcShort( 0x1450 ),	/* Type Offset=5200 */

	/* Parameter prgColumnInfo */

/* 5632 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 5634 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 5636 */	NdrFcShort( 0x146e ),	/* Type Offset=5230 */

	/* Parameter prgNameOffsets */

/* 5638 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 5640 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 5642 */	NdrFcShort( 0x148c ),	/* Type Offset=5260 */

	/* Parameter prgcolumnidOffsets */

/* 5644 */	NdrFcShort( 0x2013 ),	/* Flags:  must size, must free, out, srv alloc size=8 */
/* 5646 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 5648 */	NdrFcShort( 0x14a0 ),	/* Type Offset=5280 */

	/* Parameter pcbStringsBuffer */

/* 5650 */	NdrFcShort( 0x158 ),	/* Flags:  in, out, base type, simple ref, */
/* 5652 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 5654 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter ppStringsBuffer */

/* 5656 */	NdrFcShort( 0x201b ),	/* Flags:  must size, must free, in, out, srv alloc size=8 */
/* 5658 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 5660 */	NdrFcShort( 0x14b4 ),	/* Type Offset=5300 */

	/* Return value */

/* 5662 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5664 */	NdrFcShort( 0x58 ),	/* ia64 Stack size/offset = 88 */
/* 5666 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RemoteGetURLMapping */

/* 5668 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5670 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5674 */	NdrFcShort( 0x3 ),	/* 3 */
/* 5676 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 5678 */	NdrFcShort( 0x10 ),	/* 16 */
/* 5680 */	NdrFcShort( 0x4c ),	/* 76 */
/* 5682 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 5684 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 5686 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5688 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5690 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5692 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pwszURL */

/* 5694 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
/* 5696 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 5698 */	NdrFcShort( 0x130c ),	/* Type Offset=4876 */

	/* Parameter dwReserved */

/* 5700 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5702 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 5704 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter pclsidProvider */

/* 5706 */	NdrFcShort( 0x4112 ),	/* Flags:  must free, out, simple ref, srv alloc size=16 */
/* 5708 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 5710 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Return value */

/* 5712 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5714 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 5716 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetURLMapping */

/* 5718 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5720 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5724 */	NdrFcShort( 0x4 ),	/* 4 */
/* 5726 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 5728 */	NdrFcShort( 0x54 ),	/* 84 */
/* 5730 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5732 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 5734 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 5736 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5738 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5740 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5742 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pwszURL */

/* 5744 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5746 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 5748 */	NdrFcShort( 0x9f8 ),	/* Type Offset=2552 */

	/* Parameter dwReserved */

/* 5750 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5752 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 5754 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter rclsidProvider */

/* 5756 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 5758 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 5760 */	NdrFcShort( 0x6d0 ),	/* Type Offset=1744 */

	/* Return value */

/* 5762 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5764 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 5766 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure UnregisterProvider */

/* 5768 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5770 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5774 */	NdrFcShort( 0x5 ),	/* 5 */
/* 5776 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 5778 */	NdrFcShort( 0x54 ),	/* 84 */
/* 5780 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5782 */	0x46,		/* Oi2 Flags:  clt must size, has return, has ext, */
			0x4,		/* 4 */
/* 5784 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 5786 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5788 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5790 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5792 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pwszURL */

/* 5794 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 5796 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 5798 */	NdrFcShort( 0x9f8 ),	/* Type Offset=2552 */

	/* Parameter dwReserved */

/* 5800 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 5802 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 5804 */	0xb,		/* FC_HYPER */
			0x0,		/* 0 */

	/* Parameter rclsidProvider */

/* 5806 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 5808 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 5810 */	NdrFcShort( 0x6d0 ),	/* Type Offset=1744 */

	/* Return value */

/* 5812 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5814 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 5816 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSession */

/* 5818 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5820 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5824 */	NdrFcShort( 0x3 ),	/* 3 */
/* 5826 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 5828 */	NdrFcShort( 0x44 ),	/* 68 */
/* 5830 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5832 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 5834 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 5836 */	NdrFcShort( 0x1 ),	/* 1 */
/* 5838 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5840 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5842 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter riid */

/* 5844 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 5846 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 5848 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter ppSession */

/* 5850 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5852 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 5854 */	NdrFcShort( 0x14cc ),	/* Type Offset=5324 */

	/* Return value */

/* 5856 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5858 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 5860 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSourceRow */

/* 5862 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 5864 */	NdrFcLong( 0x0 ),	/* 0 */
/* 5868 */	NdrFcShort( 0x3 ),	/* 3 */
/* 5870 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 5872 */	NdrFcShort( 0x44 ),	/* 68 */
/* 5874 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5876 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x3,		/* 3 */
/* 5878 */	0xa,		/* 10 */
			0x3,		/* Ext Flags:  new corr desc, clt corr check, */
/* 5880 */	NdrFcShort( 0x1 ),	/* 1 */
/* 5882 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5884 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5886 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter riid */

/* 5888 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 5890 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 5892 */	NdrFcShort( 0x38 ),	/* Type Offset=56 */

	/* Parameter ppRow */

/* 5894 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 5896 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 5898 */	NdrFcShort( 0x14d8 ),	/* Type Offset=5336 */

	/* Return value */

/* 5900 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 5902 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 5904 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/*  4 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/*  6 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/*  8 */	NdrFcShort( 0x2 ),	/* Offset= 2 (10) */
/* 10 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 12 */	NdrFcLong( 0x1cf2b120 ),	/* 485667104 */
/* 16 */	NdrFcShort( 0x547d ),	/* 21629 */
/* 18 */	NdrFcShort( 0x101b ),	/* 4123 */
/* 20 */	0x8e,		/* 142 */
			0x65,		/* 101 */
/* 22 */	0x8,		/* 8 */
			0x0,		/* 0 */
/* 24 */	0x2b,		/* 43 */
			0x2b,		/* 43 */
/* 26 */	0xd1,		/* 209 */
			0x19,		/* 25 */
/* 28 */	
			0x12, 0x0,	/* FC_UP */
/* 30 */	NdrFcShort( 0x70 ),	/* Offset= 112 (142) */
/* 32 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 34 */	NdrFcLong( 0x20401 ),	/* 132097 */
/* 38 */	NdrFcShort( 0x0 ),	/* 0 */
/* 40 */	NdrFcShort( 0x0 ),	/* 0 */
/* 42 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 44 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 46 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 48 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 50 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 52 */	NdrFcShort( 0x8 ),	/* 8 */
/* 54 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 56 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 58 */	NdrFcShort( 0x10 ),	/* 16 */
/* 60 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 62 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 64 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (50) */
			0x5b,		/* FC_END */
/* 68 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 70 */	NdrFcShort( 0x14 ),	/* 20 */
/* 72 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 74 */	0x0,		/* 0 */
			NdrFcShort( 0xffffffed ),	/* Offset= -19 (56) */
			0x5b,		/* FC_END */
/* 78 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 80 */	NdrFcShort( 0x1 ),	/* 1 */
/* 82 */	0x10,		/* Corr desc:  field pointer,  */
			0x59,		/* FC_CALLBACK */
/* 84 */	NdrFcShort( 0x0 ),	/* 0 */
/* 86 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 88 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 90 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 92 */	NdrFcShort( 0x10 ),	/* 16 */
/* 94 */	NdrFcShort( 0x0 ),	/* 0 */
/* 96 */	NdrFcShort( 0x6 ),	/* Offset= 6 (102) */
/* 98 */	0x36,		/* FC_POINTER */
			0xb,		/* FC_HYPER */
/* 100 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 102 */	
			0x12, 0x0,	/* FC_UP */
/* 104 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (78) */
/* 106 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 108 */	NdrFcShort( 0x58 ),	/* 88 */
/* 110 */	NdrFcShort( 0x0 ),	/* 0 */
/* 112 */	NdrFcShort( 0x16 ),	/* Offset= 22 (134) */
/* 114 */	0xb,		/* FC_HYPER */
			0xb,		/* FC_HYPER */
/* 116 */	0xb,		/* FC_HYPER */
			0xb,		/* FC_HYPER */
/* 118 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 120 */	NdrFcShort( 0xffffffa8 ),	/* Offset= -88 (32) */
/* 122 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 124 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 126 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 128 */	0xb,		/* FC_HYPER */
			0x8,		/* FC_LONG */
/* 130 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 132 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 134 */	
			0x12, 0x0,	/* FC_UP */
/* 136 */	NdrFcShort( 0xffffffbc ),	/* Offset= -68 (68) */
/* 138 */	
			0x12, 0x0,	/* FC_UP */
/* 140 */	NdrFcShort( 0xffffffce ),	/* Offset= -50 (90) */
/* 142 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x7,		/* 7 */
/* 144 */	NdrFcShort( 0x0 ),	/* 0 */
/* 146 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 148 */	NdrFcShort( 0x1 ),	/* 1 */
/* 150 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 152 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 156 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 158 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 160 */	NdrFcShort( 0xffffffca ),	/* Offset= -54 (106) */
/* 162 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 164 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 166 */	0xb9,		/* FC_UINT3264 */
			0x5c,		/* FC_PAD */
/* 168 */	
			0x12, 0x0,	/* FC_UP */
/* 170 */	NdrFcShort( 0x2 ),	/* Offset= 2 (172) */
/* 172 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 174 */	NdrFcShort( 0x4 ),	/* 4 */
/* 176 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 178 */	NdrFcShort( 0x2 ),	/* 2 */
/* 180 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 182 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 184 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/* 186 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 188 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 190 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 192 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 194 */	NdrFcShort( 0x2 ),	/* Offset= 2 (196) */
/* 196 */	
			0x13, 0x0,	/* FC_OP */
/* 198 */	NdrFcShort( 0x2 ),	/* Offset= 2 (200) */
/* 200 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x7,		/* 7 */
/* 202 */	NdrFcShort( 0x0 ),	/* 0 */
/* 204 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 206 */	NdrFcShort( 0x3 ),	/* 3 */
/* 208 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 210 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 214 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 216 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 218 */	NdrFcShort( 0xffffff90 ),	/* Offset= -112 (106) */
/* 220 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 222 */	
			0x12, 0x0,	/* FC_UP */
/* 224 */	NdrFcShort( 0x22 ),	/* Offset= 34 (258) */
/* 226 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 228 */	NdrFcShort( 0x4 ),	/* 4 */
/* 230 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 232 */	NdrFcShort( 0x8 ),	/* 8 */
/* 234 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 236 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 238 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 240 */	NdrFcShort( 0x20 ),	/* 32 */
/* 242 */	NdrFcShort( 0x0 ),	/* 0 */
/* 244 */	NdrFcShort( 0xa ),	/* Offset= 10 (254) */
/* 246 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 248 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 250 */	NdrFcShort( 0xffffff3e ),	/* Offset= -194 (56) */
/* 252 */	0x40,		/* FC_STRUCTPAD4 */
			0x5b,		/* FC_END */
/* 254 */	
			0x12, 0x0,	/* FC_UP */
/* 256 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (226) */
/* 258 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 260 */	NdrFcShort( 0x0 ),	/* 0 */
/* 262 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 264 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 266 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 268 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 272 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 274 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 276 */	NdrFcShort( 0xffffffda ),	/* Offset= -38 (238) */
/* 278 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 280 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 282 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 284 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 286 */	NdrFcShort( 0x2 ),	/* Offset= 2 (288) */
/* 288 */	
			0x13, 0x0,	/* FC_OP */
/* 290 */	NdrFcShort( 0x496 ),	/* Offset= 1174 (1464) */
/* 292 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 294 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 296 */	NdrFcShort( 0x10 ),	/* 16 */
/* 298 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 300 */	NdrFcShort( 0x2 ),	/* Offset= 2 (302) */
/* 302 */	NdrFcShort( 0x10 ),	/* 16 */
/* 304 */	NdrFcShort( 0x7 ),	/* 7 */
/* 306 */	NdrFcLong( 0x0 ),	/* 0 */
/* 310 */	NdrFcShort( 0xffffff02 ),	/* Offset= -254 (56) */
/* 312 */	NdrFcLong( 0x1 ),	/* 1 */
/* 316 */	NdrFcShort( 0xfffffefc ),	/* Offset= -260 (56) */
/* 318 */	NdrFcLong( 0x6 ),	/* 6 */
/* 322 */	NdrFcShort( 0xfffffef6 ),	/* Offset= -266 (56) */
/* 324 */	NdrFcLong( 0x2 ),	/* 2 */
/* 328 */	NdrFcShort( 0xfffffef0 ),	/* Offset= -272 (56) */
/* 330 */	NdrFcLong( 0x5 ),	/* 5 */
/* 334 */	NdrFcShort( 0xfffffeea ),	/* Offset= -278 (56) */
/* 336 */	NdrFcLong( 0x3 ),	/* 3 */
/* 340 */	NdrFcShort( 0xa ),	/* Offset= 10 (350) */
/* 342 */	NdrFcLong( 0x4 ),	/* 4 */
/* 346 */	NdrFcShort( 0x4 ),	/* Offset= 4 (350) */
/* 348 */	NdrFcShort( 0x0 ),	/* Offset= 0 (348) */
/* 350 */	
			0x13, 0x0,	/* FC_OP */
/* 352 */	NdrFcShort( 0xfffffed8 ),	/* Offset= -296 (56) */
/* 354 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 356 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 358 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 360 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 362 */	NdrFcShort( 0x2 ),	/* Offset= 2 (364) */
/* 364 */	NdrFcShort( 0x8 ),	/* 8 */
/* 366 */	NdrFcShort( 0x7 ),	/* 7 */
/* 368 */	NdrFcLong( 0x0 ),	/* 0 */
/* 372 */	NdrFcShort( 0x28 ),	/* Offset= 40 (412) */
/* 374 */	NdrFcLong( 0x2 ),	/* 2 */
/* 378 */	NdrFcShort( 0x22 ),	/* Offset= 34 (412) */
/* 380 */	NdrFcLong( 0x3 ),	/* 3 */
/* 384 */	NdrFcShort( 0x1c ),	/* Offset= 28 (412) */
/* 386 */	NdrFcLong( 0x1 ),	/* 1 */
/* 390 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 392 */	NdrFcLong( 0x4 ),	/* 4 */
/* 396 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 398 */	NdrFcLong( 0x5 ),	/* 5 */
/* 402 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 404 */	NdrFcLong( 0x6 ),	/* 6 */
/* 408 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 410 */	NdrFcShort( 0x0 ),	/* Offset= 0 (410) */
/* 412 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 414 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 416 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 418 */	NdrFcShort( 0x20 ),	/* 32 */
/* 420 */	NdrFcShort( 0x0 ),	/* 0 */
/* 422 */	NdrFcShort( 0x0 ),	/* Offset= 0 (422) */
/* 424 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 426 */	NdrFcShort( 0xffffff7a ),	/* Offset= -134 (292) */
/* 428 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 430 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 432 */	NdrFcShort( 0xffffffb2 ),	/* Offset= -78 (354) */
/* 434 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 436 */	
			0x13, 0x0,	/* FC_OP */
/* 438 */	NdrFcShort( 0x3a4 ),	/* Offset= 932 (1370) */
/* 440 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 442 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 444 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 446 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 448 */	NdrFcShort( 0x2 ),	/* Offset= 2 (450) */
/* 450 */	NdrFcShort( 0x10 ),	/* 16 */
/* 452 */	NdrFcShort( 0x2f ),	/* 47 */
/* 454 */	NdrFcLong( 0x14 ),	/* 20 */
/* 458 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
/* 460 */	NdrFcLong( 0x3 ),	/* 3 */
/* 464 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 466 */	NdrFcLong( 0x11 ),	/* 17 */
/* 470 */	NdrFcShort( 0x8001 ),	/* Simple arm type: FC_BYTE */
/* 472 */	NdrFcLong( 0x2 ),	/* 2 */
/* 476 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 478 */	NdrFcLong( 0x4 ),	/* 4 */
/* 482 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 484 */	NdrFcLong( 0x5 ),	/* 5 */
/* 488 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 490 */	NdrFcLong( 0xb ),	/* 11 */
/* 494 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 496 */	NdrFcLong( 0xa ),	/* 10 */
/* 500 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 502 */	NdrFcLong( 0x6 ),	/* 6 */
/* 506 */	NdrFcShort( 0xe8 ),	/* Offset= 232 (738) */
/* 508 */	NdrFcLong( 0x7 ),	/* 7 */
/* 512 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 514 */	NdrFcLong( 0x8 ),	/* 8 */
/* 518 */	NdrFcShort( 0xe2 ),	/* Offset= 226 (744) */
/* 520 */	NdrFcLong( 0xd ),	/* 13 */
/* 524 */	NdrFcShort( 0xf6 ),	/* Offset= 246 (770) */
/* 526 */	NdrFcLong( 0x9 ),	/* 9 */
/* 530 */	NdrFcShort( 0x102 ),	/* Offset= 258 (788) */
/* 532 */	NdrFcLong( 0x2000 ),	/* 8192 */
/* 536 */	NdrFcShort( 0x10e ),	/* Offset= 270 (806) */
/* 538 */	NdrFcLong( 0x24 ),	/* 36 */
/* 542 */	NdrFcShort( 0x2f2 ),	/* Offset= 754 (1296) */
/* 544 */	NdrFcLong( 0x4024 ),	/* 16420 */
/* 548 */	NdrFcShort( 0x2ec ),	/* Offset= 748 (1296) */
/* 550 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 554 */	NdrFcShort( 0x2ea ),	/* Offset= 746 (1300) */
/* 556 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 560 */	NdrFcShort( 0x2e8 ),	/* Offset= 744 (1304) */
/* 562 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 566 */	NdrFcShort( 0x2e6 ),	/* Offset= 742 (1308) */
/* 568 */	NdrFcLong( 0x4014 ),	/* 16404 */
/* 572 */	NdrFcShort( 0x2e4 ),	/* Offset= 740 (1312) */
/* 574 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 578 */	NdrFcShort( 0x2e2 ),	/* Offset= 738 (1316) */
/* 580 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 584 */	NdrFcShort( 0x2e0 ),	/* Offset= 736 (1320) */
/* 586 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 590 */	NdrFcShort( 0x2ca ),	/* Offset= 714 (1304) */
/* 592 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 596 */	NdrFcShort( 0x2c8 ),	/* Offset= 712 (1308) */
/* 598 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 602 */	NdrFcShort( 0x2d2 ),	/* Offset= 722 (1324) */
/* 604 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 608 */	NdrFcShort( 0x2c8 ),	/* Offset= 712 (1320) */
/* 610 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 614 */	NdrFcShort( 0x2ca ),	/* Offset= 714 (1328) */
/* 616 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 620 */	NdrFcShort( 0x2c8 ),	/* Offset= 712 (1332) */
/* 622 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 626 */	NdrFcShort( 0x2c6 ),	/* Offset= 710 (1336) */
/* 628 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 632 */	NdrFcShort( 0x2c4 ),	/* Offset= 708 (1340) */
/* 634 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 638 */	NdrFcShort( 0x2c2 ),	/* Offset= 706 (1344) */
/* 640 */	NdrFcLong( 0x10 ),	/* 16 */
/* 644 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 646 */	NdrFcLong( 0x12 ),	/* 18 */
/* 650 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 652 */	NdrFcLong( 0x13 ),	/* 19 */
/* 656 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 658 */	NdrFcLong( 0x15 ),	/* 21 */
/* 662 */	NdrFcShort( 0x800b ),	/* Simple arm type: FC_HYPER */
/* 664 */	NdrFcLong( 0x16 ),	/* 22 */
/* 668 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 670 */	NdrFcLong( 0x17 ),	/* 23 */
/* 674 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 676 */	NdrFcLong( 0xe ),	/* 14 */
/* 680 */	NdrFcShort( 0x2a0 ),	/* Offset= 672 (1352) */
/* 682 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 686 */	NdrFcShort( 0x2a4 ),	/* Offset= 676 (1362) */
/* 688 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 692 */	NdrFcShort( 0x2a2 ),	/* Offset= 674 (1366) */
/* 694 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 698 */	NdrFcShort( 0x25e ),	/* Offset= 606 (1304) */
/* 700 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 704 */	NdrFcShort( 0x25c ),	/* Offset= 604 (1308) */
/* 706 */	NdrFcLong( 0x4015 ),	/* 16405 */
/* 710 */	NdrFcShort( 0x25a ),	/* Offset= 602 (1312) */
/* 712 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 716 */	NdrFcShort( 0x250 ),	/* Offset= 592 (1308) */
/* 718 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 722 */	NdrFcShort( 0x24a ),	/* Offset= 586 (1308) */
/* 724 */	NdrFcLong( 0x0 ),	/* 0 */
/* 728 */	NdrFcShort( 0x0 ),	/* Offset= 0 (728) */
/* 730 */	NdrFcLong( 0x1 ),	/* 1 */
/* 734 */	NdrFcShort( 0x0 ),	/* Offset= 0 (734) */
/* 736 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (735) */
/* 738 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 740 */	NdrFcShort( 0x8 ),	/* 8 */
/* 742 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 744 */	
			0x13, 0x0,	/* FC_OP */
/* 746 */	NdrFcShort( 0xe ),	/* Offset= 14 (760) */
/* 748 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 750 */	NdrFcShort( 0x2 ),	/* 2 */
/* 752 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 754 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 756 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 758 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 760 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 762 */	NdrFcShort( 0x8 ),	/* 8 */
/* 764 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (748) */
/* 766 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 768 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 770 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 772 */	NdrFcLong( 0x0 ),	/* 0 */
/* 776 */	NdrFcShort( 0x0 ),	/* 0 */
/* 778 */	NdrFcShort( 0x0 ),	/* 0 */
/* 780 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 782 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 784 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 786 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 788 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 790 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 794 */	NdrFcShort( 0x0 ),	/* 0 */
/* 796 */	NdrFcShort( 0x0 ),	/* 0 */
/* 798 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 800 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 802 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 804 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 806 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 808 */	NdrFcShort( 0x2 ),	/* Offset= 2 (810) */
/* 810 */	
			0x13, 0x0,	/* FC_OP */
/* 812 */	NdrFcShort( 0x1d2 ),	/* Offset= 466 (1278) */
/* 814 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x89,		/* 137 */
/* 816 */	NdrFcShort( 0x20 ),	/* 32 */
/* 818 */	NdrFcShort( 0xa ),	/* 10 */
/* 820 */	NdrFcLong( 0x8 ),	/* 8 */
/* 824 */	NdrFcShort( 0x50 ),	/* Offset= 80 (904) */
/* 826 */	NdrFcLong( 0xd ),	/* 13 */
/* 830 */	NdrFcShort( 0x70 ),	/* Offset= 112 (942) */
/* 832 */	NdrFcLong( 0x9 ),	/* 9 */
/* 836 */	NdrFcShort( 0x90 ),	/* Offset= 144 (980) */
/* 838 */	NdrFcLong( 0xc ),	/* 12 */
/* 842 */	NdrFcShort( 0xb0 ),	/* Offset= 176 (1018) */
/* 844 */	NdrFcLong( 0x24 ),	/* 36 */
/* 848 */	NdrFcShort( 0x102 ),	/* Offset= 258 (1106) */
/* 850 */	NdrFcLong( 0x800d ),	/* 32781 */
/* 854 */	NdrFcShort( 0x10c ),	/* Offset= 268 (1122) */
/* 856 */	NdrFcLong( 0x10 ),	/* 16 */
/* 860 */	NdrFcShort( 0x126 ),	/* Offset= 294 (1154) */
/* 862 */	NdrFcLong( 0x2 ),	/* 2 */
/* 866 */	NdrFcShort( 0x13c ),	/* Offset= 316 (1182) */
/* 868 */	NdrFcLong( 0x3 ),	/* 3 */
/* 872 */	NdrFcShort( 0x152 ),	/* Offset= 338 (1210) */
/* 874 */	NdrFcLong( 0x14 ),	/* 20 */
/* 878 */	NdrFcShort( 0x168 ),	/* Offset= 360 (1238) */
/* 880 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (879) */
/* 882 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 884 */	NdrFcShort( 0x0 ),	/* 0 */
/* 886 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 888 */	NdrFcShort( 0x0 ),	/* 0 */
/* 890 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 892 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 896 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 898 */	
			0x13, 0x0,	/* FC_OP */
/* 900 */	NdrFcShort( 0xffffff74 ),	/* Offset= -140 (760) */
/* 902 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 904 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 906 */	NdrFcShort( 0x10 ),	/* 16 */
/* 908 */	NdrFcShort( 0x0 ),	/* 0 */
/* 910 */	NdrFcShort( 0x6 ),	/* Offset= 6 (916) */
/* 912 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 914 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 916 */	
			0x11, 0x0,	/* FC_RP */
/* 918 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (882) */
/* 920 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 922 */	NdrFcShort( 0x0 ),	/* 0 */
/* 924 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 926 */	NdrFcShort( 0x0 ),	/* 0 */
/* 928 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 930 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 934 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 936 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 938 */	NdrFcShort( 0xffffff58 ),	/* Offset= -168 (770) */
/* 940 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 942 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 944 */	NdrFcShort( 0x10 ),	/* 16 */
/* 946 */	NdrFcShort( 0x0 ),	/* 0 */
/* 948 */	NdrFcShort( 0x6 ),	/* Offset= 6 (954) */
/* 950 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 952 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 954 */	
			0x11, 0x0,	/* FC_RP */
/* 956 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (920) */
/* 958 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 960 */	NdrFcShort( 0x0 ),	/* 0 */
/* 962 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 964 */	NdrFcShort( 0x0 ),	/* 0 */
/* 966 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 968 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 972 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 974 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 976 */	NdrFcShort( 0xffffff44 ),	/* Offset= -188 (788) */
/* 978 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 980 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 982 */	NdrFcShort( 0x10 ),	/* 16 */
/* 984 */	NdrFcShort( 0x0 ),	/* 0 */
/* 986 */	NdrFcShort( 0x6 ),	/* Offset= 6 (992) */
/* 988 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 990 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 992 */	
			0x11, 0x0,	/* FC_RP */
/* 994 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (958) */
/* 996 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 998 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1000 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1002 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1004 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1006 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1010 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1012 */	
			0x13, 0x0,	/* FC_OP */
/* 1014 */	NdrFcShort( 0x164 ),	/* Offset= 356 (1370) */
/* 1016 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1018 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1020 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1022 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1024 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1030) */
/* 1026 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1028 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1030 */	
			0x11, 0x0,	/* FC_RP */
/* 1032 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (996) */
/* 1034 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1036 */	NdrFcLong( 0x2f ),	/* 47 */
/* 1040 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1042 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1044 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 1046 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1048 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 1050 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 1052 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1054 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1056 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1058 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1060 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1062 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1064 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1066 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1068 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1070 */	NdrFcShort( 0xa ),	/* Offset= 10 (1080) */
/* 1072 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1074 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1076 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (1034) */
/* 1078 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1080 */	
			0x13, 0x0,	/* FC_OP */
/* 1082 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (1052) */
/* 1084 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1086 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1088 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1090 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1092 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1094 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1098 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1100 */	
			0x13, 0x0,	/* FC_OP */
/* 1102 */	NdrFcShort( 0xffffffda ),	/* Offset= -38 (1064) */
/* 1104 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1106 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1108 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1110 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1112 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1118) */
/* 1114 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1116 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1118 */	
			0x11, 0x0,	/* FC_RP */
/* 1120 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (1084) */
/* 1122 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1124 */	NdrFcShort( 0x20 ),	/* 32 */
/* 1126 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1128 */	NdrFcShort( 0xa ),	/* Offset= 10 (1138) */
/* 1130 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1132 */	0x36,		/* FC_POINTER */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 1134 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffbc9 ),	/* Offset= -1079 (56) */
			0x5b,		/* FC_END */
/* 1138 */	
			0x11, 0x0,	/* FC_RP */
/* 1140 */	NdrFcShort( 0xffffff24 ),	/* Offset= -220 (920) */
/* 1142 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 1144 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1146 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1148 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1150 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1152 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 1154 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1156 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1158 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1160 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1166) */
/* 1162 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1164 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1166 */	
			0x13, 0x0,	/* FC_OP */
/* 1168 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1142) */
/* 1170 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 1172 */	NdrFcShort( 0x2 ),	/* 2 */
/* 1174 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1176 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1178 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1180 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 1182 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1184 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1186 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1188 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1194) */
/* 1190 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1192 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1194 */	
			0x13, 0x0,	/* FC_OP */
/* 1196 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1170) */
/* 1198 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1200 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1202 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1204 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1206 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1208 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1210 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1212 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1214 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1216 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1222) */
/* 1218 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1220 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1222 */	
			0x13, 0x0,	/* FC_OP */
/* 1224 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1198) */
/* 1226 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1228 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1230 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1232 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1234 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1236 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 1238 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1240 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1242 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1244 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1250) */
/* 1246 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1248 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 1250 */	
			0x13, 0x0,	/* FC_OP */
/* 1252 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (1226) */
/* 1254 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 1256 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1258 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1260 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1262 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1264 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1266 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 1268 */	NdrFcShort( 0xffc8 ),	/* -56 */
/* 1270 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1272 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1274 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (1254) */
/* 1276 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1278 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1280 */	NdrFcShort( 0x38 ),	/* 56 */
/* 1282 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (1262) */
/* 1284 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1284) */
/* 1286 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1288 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1290 */	0x40,		/* FC_STRUCTPAD4 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 1292 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffe21 ),	/* Offset= -479 (814) */
			0x5b,		/* FC_END */
/* 1296 */	
			0x13, 0x0,	/* FC_OP */
/* 1298 */	NdrFcShort( 0xffffff16 ),	/* Offset= -234 (1064) */
/* 1300 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1302 */	0x1,		/* FC_BYTE */
			0x5c,		/* FC_PAD */
/* 1304 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1306 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 1308 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1310 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 1312 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1314 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 1316 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1318 */	0xa,		/* FC_FLOAT */
			0x5c,		/* FC_PAD */
/* 1320 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1322 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 1324 */	
			0x13, 0x0,	/* FC_OP */
/* 1326 */	NdrFcShort( 0xfffffdb4 ),	/* Offset= -588 (738) */
/* 1328 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1330 */	NdrFcShort( 0xfffffdb6 ),	/* Offset= -586 (744) */
/* 1332 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1334 */	NdrFcShort( 0xfffffdcc ),	/* Offset= -564 (770) */
/* 1336 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1338 */	NdrFcShort( 0xfffffdda ),	/* Offset= -550 (788) */
/* 1340 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1342 */	NdrFcShort( 0xfffffde8 ),	/* Offset= -536 (806) */
/* 1344 */	
			0x13, 0x10,	/* FC_OP [pointer_deref] */
/* 1346 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1348) */
/* 1348 */	
			0x13, 0x0,	/* FC_OP */
/* 1350 */	NdrFcShort( 0x14 ),	/* Offset= 20 (1370) */
/* 1352 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 1354 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1356 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 1358 */	0x1,		/* FC_BYTE */
			0x8,		/* FC_LONG */
/* 1360 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 1362 */	
			0x13, 0x0,	/* FC_OP */
/* 1364 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (1352) */
/* 1366 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 1368 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 1370 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 1372 */	NdrFcShort( 0x20 ),	/* 32 */
/* 1374 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1376 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1376) */
/* 1378 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1380 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1382 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 1384 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1386 */	NdrFcShort( 0xfffffc4e ),	/* Offset= -946 (440) */
/* 1388 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1390 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1392 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1394 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1396 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1398 */	NdrFcShort( 0xfffffc3e ),	/* Offset= -962 (436) */
/* 1400 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1402 */	NdrFcShort( 0x48 ),	/* 72 */
/* 1404 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1406 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1406) */
/* 1408 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 1410 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 1412 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1414 */	NdrFcShort( 0xfffffc1a ),	/* Offset= -998 (416) */
/* 1416 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1418 */	NdrFcShort( 0xffffffe4 ),	/* Offset= -28 (1390) */
/* 1420 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1422 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1424 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1426 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1428 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1430 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1432 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1436 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1438 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1440 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (1400) */
/* 1442 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1444 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 1446 */	NdrFcShort( 0x20 ),	/* 32 */
/* 1448 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1450 */	NdrFcShort( 0xa ),	/* Offset= 10 (1460) */
/* 1452 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 1454 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1456 */	NdrFcShort( 0xfffffa88 ),	/* Offset= -1400 (56) */
/* 1458 */	0x40,		/* FC_STRUCTPAD4 */
			0x5b,		/* FC_END */
/* 1460 */	
			0x13, 0x0,	/* FC_OP */
/* 1462 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (1422) */
/* 1464 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1466 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1468 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 1470 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 1472 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1474 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1478 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1480 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1482 */	NdrFcShort( 0xffffffda ),	/* Offset= -38 (1444) */
/* 1484 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1486 */	
			0x11, 0x0,	/* FC_RP */
/* 1488 */	NdrFcShort( 0xfffffa68 ),	/* Offset= -1432 (56) */
/* 1490 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1492 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1494) */
/* 1494 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 1496 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 1498 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1500 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 1502 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1504 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1506) */
/* 1506 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 1508 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 1510 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1512 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 1514 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1516 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1518) */
/* 1518 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 1520 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 1522 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1524 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 1526 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1528 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1530) */
/* 1530 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 1532 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 1534 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1536 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 1538 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1540 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1542) */
/* 1542 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 1544 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 1546 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1548 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 1550 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1552 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1554) */
/* 1554 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 1556 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 1558 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 1560 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 1562 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1564 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1566) */
/* 1566 */	
			0x13, 0x0,	/* FC_OP */
/* 1568 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1570) */
/* 1570 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1572 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1574 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 1576 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1578 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1580 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 1582 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1584 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1586) */
/* 1586 */	
			0x13, 0x0,	/* FC_OP */
/* 1588 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1590) */
/* 1590 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1592 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1594 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 1596 */	NdrFcShort( 0x5 ),	/* 5 */
/* 1598 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1600 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1602 */	
			0x11, 0x0,	/* FC_RP */
/* 1604 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1606) */
/* 1606 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1608 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1610 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 1612 */	NdrFcShort( 0x6 ),	/* 6 */
/* 1614 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1616 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 1618 */	
			0x11, 0x0,	/* FC_RP */
/* 1620 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1622) */
/* 1622 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 1624 */	NdrFcShort( 0x4 ),	/* 4 */
/* 1626 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 1628 */	NdrFcShort( 0x7 ),	/* 7 */
/* 1630 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1632 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 1634 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 1636 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1638) */
/* 1638 */	
			0x13, 0x0,	/* FC_OP */
/* 1640 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1642) */
/* 1642 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x7,		/* 7 */
/* 1644 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1646 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 1648 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1650 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1652 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1656 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1658 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1660 */	NdrFcShort( 0xfffff9ee ),	/* Offset= -1554 (106) */
/* 1662 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1664 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1666 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1668) */
/* 1668 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 1670 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 1672 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1674 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 1676 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 1678 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1680) */
/* 1680 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 1682 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 1684 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 1686 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 1688 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1690 */	NdrFcLong( 0xc733a7c ),	/* 208878204 */
/* 1694 */	NdrFcShort( 0x2a1c ),	/* 10780 */
/* 1696 */	NdrFcShort( 0x11ce ),	/* 4558 */
/* 1698 */	0xad,		/* 173 */
			0xe5,		/* 229 */
/* 1700 */	0x0,		/* 0 */
			0xaa,		/* 170 */
/* 1702 */	0x0,		/* 0 */
			0x44,		/* 68 */
/* 1704 */	0x77,		/* 119 */
			0x3d,		/* 61 */
/* 1706 */	
			0x11, 0x0,	/* FC_RP */
/* 1708 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1710) */
/* 1710 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 1712 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1714 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 1716 */	NdrFcShort( 0x9 ),	/* 9 */
/* 1718 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1720 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 1722 */	
			0x11, 0x0,	/* FC_RP */
/* 1724 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1726) */
/* 1726 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1728 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1730 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 1732 */	NdrFcShort( 0xa ),	/* 10 */
/* 1734 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1736 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1740 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1742 */	0xb9,		/* FC_UINT3264 */
			0x5b,		/* FC_END */
/* 1744 */	
			0x12, 0x0,	/* FC_UP */
/* 1746 */	NdrFcShort( 0xfffff966 ),	/* Offset= -1690 (56) */
/* 1748 */	
			0x12, 0x0,	/* FC_UP */
/* 1750 */	NdrFcShort( 0x614 ),	/* Offset= 1556 (3306) */
/* 1752 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 1754 */	NdrFcLong( 0xc733a30 ),	/* 208878128 */
/* 1758 */	NdrFcShort( 0x2a1c ),	/* 10780 */
/* 1760 */	NdrFcShort( 0x11ce ),	/* 4558 */
/* 1762 */	0xad,		/* 173 */
			0xe5,		/* 229 */
/* 1764 */	0x0,		/* 0 */
			0xaa,		/* 170 */
/* 1766 */	0x0,		/* 0 */
			0x44,		/* 68 */
/* 1768 */	0x77,		/* 119 */
			0x3d,		/* 61 */
/* 1770 */	
			0x12, 0x0,	/* FC_UP */
/* 1772 */	NdrFcShort( 0xfffffc0c ),	/* Offset= -1012 (760) */
/* 1774 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1776 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1778 */	NdrFcShort( 0x8 ),	/* 8 */
/* 1780 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1782 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (1770) */
/* 1784 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1786 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1788 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1790 */	NdrFcShort( 0xc ),	/* 12 */
/* 1792 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1794 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1798 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1800 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1802 */	NdrFcShort( 0xffffffe4 ),	/* Offset= -28 (1774) */
/* 1804 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1806 */	
			0x12, 0x0,	/* FC_UP */
/* 1808 */	NdrFcShort( 0xfffffe4a ),	/* Offset= -438 (1370) */
/* 1810 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1812 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1814 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1816 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1818 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (1806) */
/* 1820 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1822 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1824 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1826 */	NdrFcShort( 0x18 ),	/* 24 */
/* 1828 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1830 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1834 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1836 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1838 */	NdrFcShort( 0xffffffe4 ),	/* Offset= -28 (1810) */
/* 1840 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1842 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1844 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1846 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1848 */	NdrFcShort( 0x28 ),	/* 40 */
/* 1850 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1852 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1856 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1858 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1860 */	NdrFcShort( 0xfffffbd0 ),	/* Offset= -1072 (788) */
/* 1862 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1864 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 1866 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1868 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 1870 */	NdrFcShort( 0x38 ),	/* 56 */
/* 1872 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 1874 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 1878 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1880 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 1882 */	NdrFcShort( 0xfffffba8 ),	/* Offset= -1112 (770) */
/* 1884 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 1886 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x7,		/* FC_USHORT */
/* 1888 */	0x0,		/* Corr desc:  */
			0x59,		/* FC_CALLBACK */
/* 1890 */	NdrFcShort( 0xb ),	/* 11 */
/* 1892 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 1894 */	NdrFcShort( 0x2 ),	/* Offset= 2 (1896) */
/* 1896 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1898 */	NdrFcShort( 0x61 ),	/* 97 */
/* 1900 */	NdrFcLong( 0x0 ),	/* 0 */
/* 1904 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1904) */
/* 1906 */	NdrFcLong( 0x1 ),	/* 1 */
/* 1910 */	NdrFcShort( 0x0 ),	/* Offset= 0 (1910) */
/* 1912 */	NdrFcLong( 0x10 ),	/* 16 */
/* 1916 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 1918 */	NdrFcLong( 0x11 ),	/* 17 */
/* 1922 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 1924 */	NdrFcLong( 0x2 ),	/* 2 */
/* 1928 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1930 */	NdrFcLong( 0x12 ),	/* 18 */
/* 1934 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1936 */	NdrFcLong( 0x3 ),	/* 3 */
/* 1940 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1942 */	NdrFcLong( 0x13 ),	/* 19 */
/* 1946 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1948 */	NdrFcLong( 0x16 ),	/* 22 */
/* 1952 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1954 */	NdrFcLong( 0x17 ),	/* 23 */
/* 1958 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 1960 */	NdrFcLong( 0xe ),	/* 14 */
/* 1964 */	NdrFcShort( 0xfffffb36 ),	/* Offset= -1226 (738) */
/* 1966 */	NdrFcLong( 0x14 ),	/* 20 */
/* 1970 */	NdrFcShort( 0xfffffb30 ),	/* Offset= -1232 (738) */
/* 1972 */	NdrFcLong( 0x15 ),	/* 21 */
/* 1976 */	NdrFcShort( 0xfffffb2a ),	/* Offset= -1238 (738) */
/* 1978 */	NdrFcLong( 0x4 ),	/* 4 */
/* 1982 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 1984 */	NdrFcLong( 0x5 ),	/* 5 */
/* 1988 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 1990 */	NdrFcLong( 0xb ),	/* 11 */
/* 1994 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 1996 */	NdrFcLong( 0xffff ),	/* 65535 */
/* 2000 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 2002 */	NdrFcLong( 0xa ),	/* 10 */
/* 2006 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 2008 */	NdrFcLong( 0x6 ),	/* 6 */
/* 2012 */	NdrFcShort( 0xfffffb06 ),	/* Offset= -1274 (738) */
/* 2014 */	NdrFcLong( 0x7 ),	/* 7 */
/* 2018 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 2020 */	NdrFcLong( 0x40 ),	/* 64 */
/* 2024 */	NdrFcShort( 0xfffffcfe ),	/* Offset= -770 (1254) */
/* 2026 */	NdrFcLong( 0x48 ),	/* 72 */
/* 2030 */	NdrFcShort( 0xfffffee2 ),	/* Offset= -286 (1744) */
/* 2032 */	NdrFcLong( 0x47 ),	/* 71 */
/* 2036 */	NdrFcShort( 0x1c0 ),	/* Offset= 448 (2484) */
/* 2038 */	NdrFcLong( 0x8 ),	/* 8 */
/* 2042 */	NdrFcShort( 0xfffffef4 ),	/* Offset= -268 (1774) */
/* 2044 */	NdrFcLong( 0xfff ),	/* 4095 */
/* 2048 */	NdrFcShort( 0x1d4 ),	/* Offset= 468 (2516) */
/* 2050 */	NdrFcLong( 0x41 ),	/* 65 */
/* 2054 */	NdrFcShort( 0x1de ),	/* Offset= 478 (2532) */
/* 2056 */	NdrFcLong( 0x46 ),	/* 70 */
/* 2060 */	NdrFcShort( 0x1d8 ),	/* Offset= 472 (2532) */
/* 2062 */	NdrFcLong( 0x1e ),	/* 30 */
/* 2066 */	NdrFcShort( 0x1e2 ),	/* Offset= 482 (2548) */
/* 2068 */	NdrFcLong( 0x1f ),	/* 31 */
/* 2072 */	NdrFcShort( 0x1e0 ),	/* Offset= 480 (2552) */
/* 2074 */	NdrFcLong( 0xd ),	/* 13 */
/* 2078 */	NdrFcShort( 0xfffffae4 ),	/* Offset= -1308 (770) */
/* 2080 */	NdrFcLong( 0x9 ),	/* 9 */
/* 2084 */	NdrFcShort( 0xfffffaf0 ),	/* Offset= -1296 (788) */
/* 2086 */	NdrFcLong( 0x42 ),	/* 66 */
/* 2090 */	NdrFcShort( 0x1d2 ),	/* Offset= 466 (2556) */
/* 2092 */	NdrFcLong( 0x44 ),	/* 68 */
/* 2096 */	NdrFcShort( 0x1cc ),	/* Offset= 460 (2556) */
/* 2098 */	NdrFcLong( 0x43 ),	/* 67 */
/* 2102 */	NdrFcShort( 0x1d8 ),	/* Offset= 472 (2574) */
/* 2104 */	NdrFcLong( 0x45 ),	/* 69 */
/* 2108 */	NdrFcShort( 0x1d2 ),	/* Offset= 466 (2574) */
/* 2110 */	NdrFcLong( 0x49 ),	/* 73 */
/* 2114 */	NdrFcShort( 0x1de ),	/* Offset= 478 (2592) */
/* 2116 */	NdrFcLong( 0x2010 ),	/* 8208 */
/* 2120 */	NdrFcShort( 0x1f6 ),	/* Offset= 502 (2622) */
/* 2122 */	NdrFcLong( 0x2011 ),	/* 8209 */
/* 2126 */	NdrFcShort( 0x1f0 ),	/* Offset= 496 (2622) */
/* 2128 */	NdrFcLong( 0x2002 ),	/* 8194 */
/* 2132 */	NdrFcShort( 0x1ea ),	/* Offset= 490 (2622) */
/* 2134 */	NdrFcLong( 0x2012 ),	/* 8210 */
/* 2138 */	NdrFcShort( 0x1e4 ),	/* Offset= 484 (2622) */
/* 2140 */	NdrFcLong( 0x2003 ),	/* 8195 */
/* 2144 */	NdrFcShort( 0x1de ),	/* Offset= 478 (2622) */
/* 2146 */	NdrFcLong( 0x2013 ),	/* 8211 */
/* 2150 */	NdrFcShort( 0x1d8 ),	/* Offset= 472 (2622) */
/* 2152 */	NdrFcLong( 0x2016 ),	/* 8214 */
/* 2156 */	NdrFcShort( 0x1d2 ),	/* Offset= 466 (2622) */
/* 2158 */	NdrFcLong( 0x2017 ),	/* 8215 */
/* 2162 */	NdrFcShort( 0x1cc ),	/* Offset= 460 (2622) */
/* 2164 */	NdrFcLong( 0x2004 ),	/* 8196 */
/* 2168 */	NdrFcShort( 0x1c6 ),	/* Offset= 454 (2622) */
/* 2170 */	NdrFcLong( 0x2005 ),	/* 8197 */
/* 2174 */	NdrFcShort( 0x1c0 ),	/* Offset= 448 (2622) */
/* 2176 */	NdrFcLong( 0x2006 ),	/* 8198 */
/* 2180 */	NdrFcShort( 0x1ba ),	/* Offset= 442 (2622) */
/* 2182 */	NdrFcLong( 0x2007 ),	/* 8199 */
/* 2186 */	NdrFcShort( 0x1b4 ),	/* Offset= 436 (2622) */
/* 2188 */	NdrFcLong( 0x2008 ),	/* 8200 */
/* 2192 */	NdrFcShort( 0x1ae ),	/* Offset= 430 (2622) */
/* 2194 */	NdrFcLong( 0x200b ),	/* 8203 */
/* 2198 */	NdrFcShort( 0x1a8 ),	/* Offset= 424 (2622) */
/* 2200 */	NdrFcLong( 0x200e ),	/* 8206 */
/* 2204 */	NdrFcShort( 0x1a2 ),	/* Offset= 418 (2622) */
/* 2206 */	NdrFcLong( 0x2009 ),	/* 8201 */
/* 2210 */	NdrFcShort( 0x19c ),	/* Offset= 412 (2622) */
/* 2212 */	NdrFcLong( 0x200d ),	/* 8205 */
/* 2216 */	NdrFcShort( 0x196 ),	/* Offset= 406 (2622) */
/* 2218 */	NdrFcLong( 0x200a ),	/* 8202 */
/* 2222 */	NdrFcShort( 0x190 ),	/* Offset= 400 (2622) */
/* 2224 */	NdrFcLong( 0x200c ),	/* 8204 */
/* 2228 */	NdrFcShort( 0x18a ),	/* Offset= 394 (2622) */
/* 2230 */	NdrFcLong( 0x1010 ),	/* 4112 */
/* 2234 */	NdrFcShort( 0x19a ),	/* Offset= 410 (2644) */
/* 2236 */	NdrFcLong( 0x1011 ),	/* 4113 */
/* 2240 */	NdrFcShort( 0x1a4 ),	/* Offset= 420 (2660) */
/* 2242 */	NdrFcLong( 0x1002 ),	/* 4098 */
/* 2246 */	NdrFcShort( 0x1ae ),	/* Offset= 430 (2676) */
/* 2248 */	NdrFcLong( 0x1012 ),	/* 4114 */
/* 2252 */	NdrFcShort( 0x1b8 ),	/* Offset= 440 (2692) */
/* 2254 */	NdrFcLong( 0x1003 ),	/* 4099 */
/* 2258 */	NdrFcShort( 0x1c2 ),	/* Offset= 450 (2708) */
/* 2260 */	NdrFcLong( 0x1013 ),	/* 4115 */
/* 2264 */	NdrFcShort( 0x1cc ),	/* Offset= 460 (2724) */
/* 2266 */	NdrFcLong( 0x1014 ),	/* 4116 */
/* 2270 */	NdrFcShort( 0x1e6 ),	/* Offset= 486 (2756) */
/* 2272 */	NdrFcLong( 0x1015 ),	/* 4117 */
/* 2276 */	NdrFcShort( 0x1f0 ),	/* Offset= 496 (2772) */
/* 2278 */	NdrFcLong( 0x1004 ),	/* 4100 */
/* 2282 */	NdrFcShort( 0x206 ),	/* Offset= 518 (2800) */
/* 2284 */	NdrFcLong( 0x1005 ),	/* 4101 */
/* 2288 */	NdrFcShort( 0x21c ),	/* Offset= 540 (2828) */
/* 2290 */	NdrFcLong( 0x100b ),	/* 4107 */
/* 2294 */	NdrFcShort( 0x226 ),	/* Offset= 550 (2844) */
/* 2296 */	NdrFcLong( 0x100a ),	/* 4106 */
/* 2300 */	NdrFcShort( 0x230 ),	/* Offset= 560 (2860) */
/* 2302 */	NdrFcLong( 0x1006 ),	/* 4102 */
/* 2306 */	NdrFcShort( 0x23a ),	/* Offset= 570 (2876) */
/* 2308 */	NdrFcLong( 0x1007 ),	/* 4103 */
/* 2312 */	NdrFcShort( 0x244 ),	/* Offset= 580 (2892) */
/* 2314 */	NdrFcLong( 0x1040 ),	/* 4160 */
/* 2318 */	NdrFcShort( 0x25e ),	/* Offset= 606 (2924) */
/* 2320 */	NdrFcLong( 0x1048 ),	/* 4168 */
/* 2324 */	NdrFcShort( 0x278 ),	/* Offset= 632 (2956) */
/* 2326 */	NdrFcLong( 0x1047 ),	/* 4167 */
/* 2330 */	NdrFcShort( 0x298 ),	/* Offset= 664 (2994) */
/* 2332 */	NdrFcLong( 0x1008 ),	/* 4104 */
/* 2336 */	NdrFcShort( 0x2b8 ),	/* Offset= 696 (3032) */
/* 2338 */	NdrFcLong( 0x1fff ),	/* 8191 */
/* 2342 */	NdrFcShort( 0x2d8 ),	/* Offset= 728 (3070) */
/* 2344 */	NdrFcLong( 0x101e ),	/* 4126 */
/* 2348 */	NdrFcShort( 0x2f8 ),	/* Offset= 760 (3108) */
/* 2350 */	NdrFcLong( 0x101f ),	/* 4127 */
/* 2354 */	NdrFcShort( 0x318 ),	/* Offset= 792 (3146) */
/* 2356 */	NdrFcLong( 0x100c ),	/* 4108 */
/* 2360 */	NdrFcShort( 0x338 ),	/* Offset= 824 (3184) */
/* 2362 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 2366 */	NdrFcShort( 0x342 ),	/* Offset= 834 (3200) */
/* 2368 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 2372 */	NdrFcShort( 0x33c ),	/* Offset= 828 (3200) */
/* 2374 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 2378 */	NdrFcShort( 0x33a ),	/* Offset= 826 (3204) */
/* 2380 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 2384 */	NdrFcShort( 0x334 ),	/* Offset= 820 (3204) */
/* 2386 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 2390 */	NdrFcShort( 0xfffff6ac ),	/* Offset= -2388 (2) */
/* 2392 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 2396 */	NdrFcShort( 0xfffff6a6 ),	/* Offset= -2394 (2) */
/* 2398 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 2402 */	NdrFcShort( 0xfffff6a0 ),	/* Offset= -2400 (2) */
/* 2404 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 2408 */	NdrFcShort( 0xfffff69a ),	/* Offset= -2406 (2) */
/* 2410 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 2414 */	NdrFcShort( 0x31a ),	/* Offset= 794 (3208) */
/* 2416 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 2420 */	NdrFcShort( 0x318 ),	/* Offset= 792 (3212) */
/* 2422 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 2426 */	NdrFcShort( 0x30a ),	/* Offset= 778 (3204) */
/* 2428 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 2432 */	NdrFcShort( 0x310 ),	/* Offset= 784 (3216) */
/* 2434 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 2438 */	NdrFcShort( 0xfffff67c ),	/* Offset= -2436 (2) */
/* 2440 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 2444 */	NdrFcShort( 0x308 ),	/* Offset= 776 (3220) */
/* 2446 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 2450 */	NdrFcShort( 0x2fa ),	/* Offset= 762 (3212) */
/* 2452 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 2456 */	NdrFcShort( 0x300 ),	/* Offset= 768 (3224) */
/* 2458 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 2462 */	NdrFcShort( 0x2fe ),	/* Offset= 766 (3228) */
/* 2464 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 2468 */	NdrFcShort( 0x2fc ),	/* Offset= 764 (3232) */
/* 2470 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 2474 */	NdrFcShort( 0x2fa ),	/* Offset= 762 (3236) */
/* 2476 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 2480 */	NdrFcShort( 0x2f8 ),	/* Offset= 760 (3240) */
/* 2482 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (2481) */
/* 2484 */	
			0x12, 0x0,	/* FC_UP */
/* 2486 */	NdrFcShort( 0xe ),	/* Offset= 14 (2500) */
/* 2488 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 2490 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2492 */	0x10,		/* Corr desc:  field pointer,  */
			0x59,		/* FC_CALLBACK */
/* 2494 */	NdrFcShort( 0xc ),	/* 12 */
/* 2496 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2498 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 2500 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2502 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2504 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2506 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2512) */
/* 2508 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 2510 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2512 */	
			0x12, 0x0,	/* FC_UP */
/* 2514 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (2488) */
/* 2516 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2518 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2520 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2522 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2528) */
/* 2524 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2526 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2528 */	
			0x12, 0x0,	/* FC_UP */
/* 2530 */	NdrFcShort( 0xfffffa94 ),	/* Offset= -1388 (1142) */
/* 2532 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2534 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2536 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2538 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2544) */
/* 2540 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2542 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2544 */	
			0x12, 0x0,	/* FC_UP */
/* 2546 */	NdrFcShort( 0xfffffa84 ),	/* Offset= -1404 (1142) */
/* 2548 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 2550 */	
			0x22,		/* FC_C_CSTRING */
			0x5c,		/* FC_PAD */
/* 2552 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 2554 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 2556 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2558 */	NdrFcLong( 0xc ),	/* 12 */
/* 2562 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2564 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2566 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 2568 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2570 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2572 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 2574 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 2576 */	NdrFcLong( 0xb ),	/* 11 */
/* 2580 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2582 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2584 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 2586 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2588 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 2590 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 2592 */	
			0x12, 0x0,	/* FC_UP */
/* 2594 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2596) */
/* 2596 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2598 */	NdrFcShort( 0x18 ),	/* 24 */
/* 2600 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2602 */	NdrFcShort( 0xc ),	/* Offset= 12 (2614) */
/* 2604 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2606 */	NdrFcShort( 0xfffff60a ),	/* Offset= -2550 (56) */
/* 2608 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2610 */	NdrFcShort( 0xffffffca ),	/* Offset= -54 (2556) */
/* 2612 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2614 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 2616 */	NdrFcShort( 0x2 ),	/* Offset= 2 (2618) */
/* 2618 */	
			0x12, 0x0,	/* FC_UP */
/* 2620 */	NdrFcShort( 0xfffffac2 ),	/* Offset= -1342 (1278) */
/* 2622 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 2624 */	NdrFcShort( 0x2 ),	/* 2 */
/* 2626 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2628 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2630 */	NdrFcShort( 0xfffffff0 ),	/* Offset= -16 (2614) */
/* 2632 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 2634 */	NdrFcShort( 0x1 ),	/* 1 */
/* 2636 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2638 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2640 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2642 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 2644 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2646 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2648 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2650 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2656) */
/* 2652 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2654 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2656 */	
			0x12, 0x0,	/* FC_UP */
/* 2658 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (2632) */
/* 2660 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2662 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2664 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2666 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2672) */
/* 2668 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2670 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2672 */	
			0x12, 0x0,	/* FC_UP */
/* 2674 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (2632) */
/* 2676 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2678 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2680 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2682 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2688) */
/* 2684 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2686 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2688 */	
			0x12, 0x0,	/* FC_UP */
/* 2690 */	NdrFcShort( 0xfffffa10 ),	/* Offset= -1520 (1170) */
/* 2692 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2694 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2696 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2698 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2704) */
/* 2700 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2702 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2704 */	
			0x12, 0x0,	/* FC_UP */
/* 2706 */	NdrFcShort( 0xfffffa00 ),	/* Offset= -1536 (1170) */
/* 2708 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2710 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2712 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2714 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2720) */
/* 2716 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2718 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2720 */	
			0x12, 0x0,	/* FC_UP */
/* 2722 */	NdrFcShort( 0xfffffa0c ),	/* Offset= -1524 (1198) */
/* 2724 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2726 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2728 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2730 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2736) */
/* 2732 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2734 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2736 */	
			0x12, 0x0,	/* FC_UP */
/* 2738 */	NdrFcShort( 0xfffff9fc ),	/* Offset= -1540 (1198) */
/* 2740 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 2742 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2744 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2746 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2748 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2750 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2752 */	NdrFcShort( 0xfffff822 ),	/* Offset= -2014 (738) */
/* 2754 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2756 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2758 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2760 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2762 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2768) */
/* 2764 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2766 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2768 */	
			0x12, 0x0,	/* FC_UP */
/* 2770 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (2740) */
/* 2772 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2774 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2776 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2778 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2784) */
/* 2780 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2782 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2784 */	
			0x12, 0x0,	/* FC_UP */
/* 2786 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (2740) */
/* 2788 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 2790 */	NdrFcShort( 0x4 ),	/* 4 */
/* 2792 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2794 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2796 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2798 */	0xa,		/* FC_FLOAT */
			0x5b,		/* FC_END */
/* 2800 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2802 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2804 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2806 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2812) */
/* 2808 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2810 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2812 */	
			0x12, 0x0,	/* FC_UP */
/* 2814 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (2788) */
/* 2816 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 2818 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2820 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2822 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2824 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2826 */	0xc,		/* FC_DOUBLE */
			0x5b,		/* FC_END */
/* 2828 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2830 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2832 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2834 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2840) */
/* 2836 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2838 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2840 */	
			0x12, 0x0,	/* FC_UP */
/* 2842 */	NdrFcShort( 0xffffffe6 ),	/* Offset= -26 (2816) */
/* 2844 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2846 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2848 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2850 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2856) */
/* 2852 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2854 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2856 */	
			0x12, 0x0,	/* FC_UP */
/* 2858 */	NdrFcShort( 0xfffff968 ),	/* Offset= -1688 (1170) */
/* 2860 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2862 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2864 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2866 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2872) */
/* 2868 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2870 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2872 */	
			0x12, 0x0,	/* FC_UP */
/* 2874 */	NdrFcShort( 0xfffff974 ),	/* Offset= -1676 (1198) */
/* 2876 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2878 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2880 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2882 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2888) */
/* 2884 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2886 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2888 */	
			0x12, 0x0,	/* FC_UP */
/* 2890 */	NdrFcShort( 0xffffff6a ),	/* Offset= -150 (2740) */
/* 2892 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2894 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2896 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2898 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2904) */
/* 2900 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2902 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2904 */	
			0x12, 0x0,	/* FC_UP */
/* 2906 */	NdrFcShort( 0xffffffa6 ),	/* Offset= -90 (2816) */
/* 2908 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 2910 */	NdrFcShort( 0x8 ),	/* 8 */
/* 2912 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2914 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2916 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2918 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2920 */	NdrFcShort( 0xfffff97e ),	/* Offset= -1666 (1254) */
/* 2922 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2924 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2926 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2928 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2930 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2936) */
/* 2932 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2934 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2936 */	
			0x12, 0x0,	/* FC_UP */
/* 2938 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (2908) */
/* 2940 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 2942 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2944 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2946 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2948 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2950 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2952 */	NdrFcShort( 0xfffff4b0 ),	/* Offset= -2896 (56) */
/* 2954 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2956 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2958 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2960 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2962 */	NdrFcShort( 0x6 ),	/* Offset= 6 (2968) */
/* 2964 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 2966 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 2968 */	
			0x12, 0x0,	/* FC_UP */
/* 2970 */	NdrFcShort( 0xffffffe2 ),	/* Offset= -30 (2940) */
/* 2972 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 2974 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2976 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 2978 */	NdrFcShort( 0x0 ),	/* 0 */
/* 2980 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 2982 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 2986 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 2988 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 2990 */	NdrFcShort( 0xfffffe16 ),	/* Offset= -490 (2500) */
/* 2992 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 2994 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 2996 */	NdrFcShort( 0x10 ),	/* 16 */
/* 2998 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3000 */	NdrFcShort( 0x6 ),	/* Offset= 6 (3006) */
/* 3002 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 3004 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 3006 */	
			0x12, 0x0,	/* FC_UP */
/* 3008 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (2972) */
/* 3010 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 3012 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3014 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 3016 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3018 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 3020 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 3024 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3026 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3028 */	NdrFcShort( 0xfffffb1a ),	/* Offset= -1254 (1774) */
/* 3030 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3032 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 3034 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3036 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3038 */	NdrFcShort( 0x6 ),	/* Offset= 6 (3044) */
/* 3040 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 3042 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 3044 */	
			0x12, 0x0,	/* FC_UP */
/* 3046 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (3010) */
/* 3048 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 3050 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3052 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 3054 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3056 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 3058 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 3062 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3064 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3066 */	NdrFcShort( 0xfffffdda ),	/* Offset= -550 (2516) */
/* 3068 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3070 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 3072 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3074 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3076 */	NdrFcShort( 0x6 ),	/* Offset= 6 (3082) */
/* 3078 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 3080 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 3082 */	
			0x12, 0x0,	/* FC_UP */
/* 3084 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (3048) */
/* 3086 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 3088 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3090 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 3092 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3094 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 3096 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 3100 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3102 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 3104 */	
			0x22,		/* FC_C_CSTRING */
			0x5c,		/* FC_PAD */
/* 3106 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3108 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 3110 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3112 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3114 */	NdrFcShort( 0x6 ),	/* Offset= 6 (3120) */
/* 3116 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 3118 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 3120 */	
			0x12, 0x0,	/* FC_UP */
/* 3122 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (3086) */
/* 3124 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 3126 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3128 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 3130 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3132 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 3134 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 3138 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3140 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 3142 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 3144 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3146 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 3148 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3150 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3152 */	NdrFcShort( 0x6 ),	/* Offset= 6 (3158) */
/* 3154 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 3156 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 3158 */	
			0x12, 0x0,	/* FC_UP */
/* 3160 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (3124) */
/* 3162 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x7,		/* 7 */
/* 3164 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3166 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 3168 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3170 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 3172 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 3176 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3178 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3180 */	NdrFcShort( 0x40 ),	/* Offset= 64 (3244) */
/* 3182 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3184 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 3186 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3188 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3190 */	NdrFcShort( 0x6 ),	/* Offset= 6 (3196) */
/* 3192 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 3194 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 3196 */	
			0x12, 0x0,	/* FC_UP */
/* 3198 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (3162) */
/* 3200 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 3202 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 3204 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 3206 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 3208 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 3210 */	0xa,		/* FC_FLOAT */
			0x5c,		/* FC_PAD */
/* 3212 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 3214 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 3216 */	
			0x12, 0x0,	/* FC_UP */
/* 3218 */	NdrFcShort( 0xfffff8b6 ),	/* Offset= -1866 (1352) */
/* 3220 */	
			0x12, 0x0,	/* FC_UP */
/* 3222 */	NdrFcShort( 0xfffff64c ),	/* Offset= -2484 (738) */
/* 3224 */	
			0x12, 0x0,	/* FC_UP */
/* 3226 */	NdrFcShort( 0xfffffa54 ),	/* Offset= -1452 (1774) */
/* 3228 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 3230 */	NdrFcShort( 0xfffff664 ),	/* Offset= -2460 (770) */
/* 3232 */	
			0x12, 0x10,	/* FC_UP [pointer_deref] */
/* 3234 */	NdrFcShort( 0xfffff672 ),	/* Offset= -2446 (788) */
/* 3236 */	
			0x12, 0x0,	/* FC_UP */
/* 3238 */	NdrFcShort( 0xfffffd98 ),	/* Offset= -616 (2622) */
/* 3240 */	
			0x12, 0x0,	/* FC_UP */
/* 3242 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3244) */
/* 3244 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 3246 */	NdrFcShort( 0x18 ),	/* 24 */
/* 3248 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3250 */	NdrFcShort( 0x0 ),	/* Offset= 0 (3250) */
/* 3252 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 3254 */	0x1,		/* FC_BYTE */
			0x8,		/* FC_LONG */
/* 3256 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3258 */	NdrFcShort( 0xfffffaa4 ),	/* Offset= -1372 (1886) */
/* 3260 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3262 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x7,		/* 7 */
/* 3264 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3266 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 3268 */	NdrFcShort( 0x48 ),	/* 72 */
/* 3270 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 3272 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 3276 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3278 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3280 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (3244) */
/* 3282 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3284 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 3286 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3288 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 3290 */	NdrFcShort( 0x58 ),	/* 88 */
/* 3292 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 3294 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 3298 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3300 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3302 */	NdrFcShort( 0xfffffa2c ),	/* Offset= -1492 (1810) */
/* 3304 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3306 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 3308 */	NdrFcShort( 0x68 ),	/* 104 */
/* 3310 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3312 */	NdrFcShort( 0x1a ),	/* Offset= 26 (3338) */
/* 3314 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3316 */	NdrFcShort( 0xfffff9e4 ),	/* Offset= -1564 (1752) */
/* 3318 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 3320 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 3322 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 3324 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 3326 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 3328 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 3330 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 3332 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 3334 */	0x40,		/* FC_STRUCTPAD4 */
			0x36,		/* FC_POINTER */
/* 3336 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3338 */	
			0x12, 0x0,	/* FC_UP */
/* 3340 */	NdrFcShort( 0xfffff9ec ),	/* Offset= -1556 (1784) */
/* 3342 */	
			0x12, 0x0,	/* FC_UP */
/* 3344 */	NdrFcShort( 0xfffffa0c ),	/* Offset= -1524 (1820) */
/* 3346 */	
			0x12, 0x0,	/* FC_UP */
/* 3348 */	NdrFcShort( 0xfffffa1e ),	/* Offset= -1506 (1842) */
/* 3350 */	
			0x12, 0x0,	/* FC_UP */
/* 3352 */	NdrFcShort( 0xfffffa30 ),	/* Offset= -1488 (1864) */
/* 3354 */	
			0x12, 0x0,	/* FC_UP */
/* 3356 */	NdrFcShort( 0xffffffa2 ),	/* Offset= -94 (3262) */
/* 3358 */	
			0x12, 0x0,	/* FC_UP */
/* 3360 */	NdrFcShort( 0xffffffb4 ),	/* Offset= -76 (3284) */
/* 3362 */	
			0x12, 0x0,	/* FC_UP */
/* 3364 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3366) */
/* 3366 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x7,		/* 7 */
/* 3368 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3370 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 3372 */	NdrFcShort( 0xd ),	/* 13 */
/* 3374 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3376 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 3380 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3382 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3384 */	NdrFcShort( 0xfffff332 ),	/* Offset= -3278 (106) */
/* 3386 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3388 */	
			0x12, 0x0,	/* FC_UP */
/* 3390 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3392) */
/* 3392 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 3394 */	NdrFcShort( 0x4 ),	/* 4 */
/* 3396 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 3398 */	NdrFcShort( 0xe ),	/* 14 */
/* 3400 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3402 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 3404 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 3406 */	0xb,		/* FC_HYPER */
			0x5c,		/* FC_PAD */
/* 3408 */	
			0x12, 0x14,	/* FC_UP [alloced_on_stack] [pointer_deref] */
/* 3410 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3412) */
/* 3412 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 3414 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 3416 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 3418 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 3420 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3422 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3424) */
/* 3424 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 3426 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 3428 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 3430 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 3432 */	
			0x12, 0x14,	/* FC_UP [alloced_on_stack] [pointer_deref] */
/* 3434 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3436) */
/* 3436 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 3438 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 3440 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 3442 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 3444 */	
			0x12, 0x0,	/* FC_UP */
/* 3446 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3448) */
/* 3448 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 3450 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3452 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 3454 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 3456 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 3458 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 3462 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3464 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3466 */	NdrFcShort( 0xfffff81a ),	/* Offset= -2022 (1444) */
/* 3468 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3470 */	
			0x11, 0x0,	/* FC_RP */
/* 3472 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3474) */
/* 3474 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 3476 */	NdrFcShort( 0x4 ),	/* 4 */
/* 3478 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 3480 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 3482 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 3484 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 3486 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 3488 */	NdrFcShort( 0xfffff3fc ),	/* Offset= -3076 (412) */
/* 3490 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 3492 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3494) */
/* 3494 */	
			0x13, 0x0,	/* FC_OP */
/* 3496 */	NdrFcShort( 0x1c ),	/* Offset= 28 (3524) */
/* 3498 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 3500 */	NdrFcShort( 0x30 ),	/* 48 */
/* 3502 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3504 */	NdrFcShort( 0x10 ),	/* Offset= 16 (3520) */
/* 3506 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 3508 */	0xb,		/* FC_HYPER */
			0x36,		/* FC_POINTER */
/* 3510 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3512 */	NdrFcShort( 0xfffff268 ),	/* Offset= -3480 (32) */
/* 3514 */	0xb,		/* FC_HYPER */
			0x6,		/* FC_SHORT */
/* 3516 */	0x1,		/* FC_BYTE */
			0x1,		/* FC_BYTE */
/* 3518 */	0x40,		/* FC_STRUCTPAD4 */
			0x5b,		/* FC_END */
/* 3520 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 3522 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 3524 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x7,		/* 7 */
/* 3526 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3528 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 3530 */	NdrFcShort( 0xf ),	/* 15 */
/* 3532 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3534 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 3538 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3540 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3542 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (3498) */
/* 3544 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3546 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 3548 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3550) */
/* 3550 */	
			0x13, 0x0,	/* FC_OP */
/* 3552 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3554) */
/* 3554 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 3556 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3558 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 3560 */	NdrFcShort( 0x10 ),	/* 16 */
/* 3562 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3564 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 3566 */	
			0x12, 0x14,	/* FC_UP [alloced_on_stack] [pointer_deref] */
/* 3568 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3570) */
/* 3570 */	
			0x13, 0x0,	/* FC_OP */
/* 3572 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3574) */
/* 3574 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 3576 */	NdrFcShort( 0x2 ),	/* 2 */
/* 3578 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 3580 */	NdrFcShort( 0x11 ),	/* 17 */
/* 3582 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3584 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 3586 */	
			0x11, 0x0,	/* FC_RP */
/* 3588 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3590) */
/* 3590 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 3592 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3594 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 3596 */	NdrFcShort( 0x12 ),	/* 18 */
/* 3598 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3600 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 3604 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3606 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 3608 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 3610 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3612 */	
			0x11, 0x0,	/* FC_RP */
/* 3614 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3616) */
/* 3616 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 3618 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3620 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 3622 */	NdrFcShort( 0x13 ),	/* 19 */
/* 3624 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3626 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 3628 */	
			0x12, 0x0,	/* FC_UP */
/* 3630 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3632) */
/* 3632 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 3634 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3636 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 3638 */	NdrFcShort( 0x14 ),	/* 20 */
/* 3640 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3642 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 3644 */	
			0x12, 0x0,	/* FC_UP */
/* 3646 */	NdrFcShort( 0x1a ),	/* Offset= 26 (3672) */
/* 3648 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 3650 */	NdrFcShort( 0x20 ),	/* 32 */
/* 3652 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3654 */	NdrFcShort( 0xa ),	/* Offset= 10 (3664) */
/* 3656 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 3658 */	0xb,		/* FC_HYPER */
			0x8,		/* FC_LONG */
/* 3660 */	0x1,		/* FC_BYTE */
			0x1,		/* FC_BYTE */
/* 3662 */	0x3e,		/* FC_STRUCTPAD2 */
			0x5b,		/* FC_END */
/* 3664 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 3666 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 3668 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 3670 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 3672 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x7,		/* 7 */
/* 3674 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3676 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 3678 */	NdrFcShort( 0x15 ),	/* 21 */
/* 3680 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3682 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 3686 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3688 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3690 */	NdrFcShort( 0xffffffd6 ),	/* Offset= -42 (3648) */
/* 3692 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3694 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 3696 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3698) */
/* 3698 */	
			0x13, 0x0,	/* FC_OP */
/* 3700 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3702) */
/* 3702 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 3704 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3706 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 3708 */	NdrFcShort( 0x16 ),	/* 22 */
/* 3710 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3712 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 3716 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3718 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3720 */	NdrFcShort( 0xfffff318 ),	/* Offset= -3304 (416) */
/* 3722 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3724 */	
			0x12, 0x0,	/* FC_UP */
/* 3726 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3728) */
/* 3728 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 3730 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3732 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 3734 */	NdrFcShort( 0x17 ),	/* 23 */
/* 3736 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3738 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 3742 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3744 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3746 */	NdrFcShort( 0xfffff2fe ),	/* Offset= -3330 (416) */
/* 3748 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3750 */	
			0x12, 0x0,	/* FC_UP */
/* 3752 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3754) */
/* 3754 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 3756 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3758 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 3760 */	NdrFcShort( 0x18 ),	/* 24 */
/* 3762 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3764 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 3768 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3770 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3772 */	NdrFcShort( 0xfffff6e8 ),	/* Offset= -2328 (1444) */
/* 3774 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3776 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3778 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3780) */
/* 3780 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 3782 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 3784 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 3786 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 3788 */	
			0x11, 0x0,	/* FC_RP */
/* 3790 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3792) */
/* 3792 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 3794 */	NdrFcShort( 0x4 ),	/* 4 */
/* 3796 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 3798 */	NdrFcShort( 0x19 ),	/* 25 */
/* 3800 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3802 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 3804 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 3806 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3808) */
/* 3808 */	
			0x13, 0x0,	/* FC_OP */
/* 3810 */	NdrFcShort( 0x20 ),	/* Offset= 32 (3842) */
/* 3812 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 3814 */	NdrFcShort( 0x50 ),	/* 80 */
/* 3816 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3818 */	NdrFcShort( 0x14 ),	/* Offset= 20 (3838) */
/* 3820 */	0x36,		/* FC_POINTER */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 3822 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff131 ),	/* Offset= -3791 (32) */
			0xb,		/* FC_HYPER */
/* 3826 */	0x8,		/* FC_LONG */
			0x40,		/* FC_STRUCTPAD4 */
/* 3828 */	0xb,		/* FC_HYPER */
			0x6,		/* FC_SHORT */
/* 3830 */	0x1,		/* FC_BYTE */
			0x1,		/* FC_BYTE */
/* 3832 */	0x40,		/* FC_STRUCTPAD4 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 3834 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff2a5 ),	/* Offset= -3419 (416) */
			0x5b,		/* FC_END */
/* 3838 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 3840 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 3842 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x7,		/* 7 */
/* 3844 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3846 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 3848 */	NdrFcShort( 0x1a ),	/* 26 */
/* 3850 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3852 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 3856 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3858 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3860 */	NdrFcShort( 0xffffffd0 ),	/* Offset= -48 (3812) */
/* 3862 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3864 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 3866 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3868) */
/* 3868 */	
			0x13, 0x0,	/* FC_OP */
/* 3870 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3872) */
/* 3872 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 3874 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3876 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 3878 */	NdrFcShort( 0x1b ),	/* 27 */
/* 3880 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3882 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 3884 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 3886 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3888) */
/* 3888 */	
			0x13, 0x0,	/* FC_OP */
/* 3890 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3892) */
/* 3892 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 3894 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3896 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 3898 */	NdrFcShort( 0x1c ),	/* 28 */
/* 3900 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3902 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 3904 */	
			0x12, 0x14,	/* FC_UP [alloced_on_stack] [pointer_deref] */
/* 3906 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3908) */
/* 3908 */	
			0x13, 0x0,	/* FC_OP */
/* 3910 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3912) */
/* 3912 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 3914 */	NdrFcShort( 0x2 ),	/* 2 */
/* 3916 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 3918 */	NdrFcShort( 0x1d ),	/* 29 */
/* 3920 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3922 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 3924 */	
			0x11, 0x0,	/* FC_RP */
/* 3926 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3928) */
/* 3928 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 3930 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3932 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 3934 */	NdrFcShort( 0x1e ),	/* 30 */
/* 3936 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3938 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 3942 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3944 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 3946 */	NdrFcShort( 0xfffff236 ),	/* Offset= -3530 (416) */
/* 3948 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 3950 */	
			0x11, 0x0,	/* FC_RP */
/* 3952 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3954) */
/* 3954 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 3956 */	NdrFcShort( 0x8 ),	/* 8 */
/* 3958 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 3960 */	NdrFcShort( 0x1f ),	/* 31 */
/* 3962 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 3964 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 3966 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3968 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3970) */
/* 3970 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 3972 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 3974 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 3976 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 3978 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 3980 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3982) */
/* 3982 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 3984 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 3986 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 3988 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 3990 */	
			0x12, 0x0,	/* FC_UP */
/* 3992 */	NdrFcShort( 0x2 ),	/* Offset= 2 (3994) */
/* 3994 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 3996 */	NdrFcShort( 0x0 ),	/* 0 */
/* 3998 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 4000 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 4002 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 4004 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 4008 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 4010 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4012 */	NdrFcShort( 0xfffff5f8 ),	/* Offset= -2568 (1444) */
/* 4014 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4016 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 4018 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4020) */
/* 4020 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 4022 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 4024 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 4026 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 4028 */	
			0x11, 0x0,	/* FC_RP */
/* 4030 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4032) */
/* 4032 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 4034 */	NdrFcShort( 0x4 ),	/* 4 */
/* 4036 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 4038 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 4040 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 4042 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 4044 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 4046 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4048) */
/* 4048 */	
			0x13, 0x0,	/* FC_OP */
/* 4050 */	NdrFcShort( 0x42 ),	/* Offset= 66 (4116) */
/* 4052 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 4054 */	NdrFcShort( 0x30 ),	/* 48 */
/* 4056 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4058 */	NdrFcShort( 0xc ),	/* Offset= 12 (4070) */
/* 4060 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 4062 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 4064 */	0x42,		/* FC_STRUCTPAD6 */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 4066 */	0x0,		/* 0 */
			NdrFcShort( 0xfffff58b ),	/* Offset= -2677 (1390) */
			0x5b,		/* FC_END */
/* 4070 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 4072 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 4074 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 4076 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4078 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 4080 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4082 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 4084 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 4088 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 4090 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4092 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (4052) */
/* 4094 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4096 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 4098 */	NdrFcShort( 0x20 ),	/* 32 */
/* 4100 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4102 */	NdrFcShort( 0xa ),	/* Offset= 10 (4112) */
/* 4104 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 4106 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4108 */	NdrFcShort( 0xfffff02c ),	/* Offset= -4052 (56) */
/* 4110 */	0x40,		/* FC_STRUCTPAD4 */
			0x5b,		/* FC_END */
/* 4112 */	
			0x13, 0x0,	/* FC_OP */
/* 4114 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (4074) */
/* 4116 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 4118 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4120 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 4122 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 4124 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 4126 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 4130 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 4132 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4134 */	NdrFcShort( 0xffffffda ),	/* Offset= -38 (4096) */
/* 4136 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4138 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 4140 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4142) */
/* 4142 */	
			0x13, 0x0,	/* FC_OP */
/* 4144 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4146) */
/* 4146 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 4148 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4150 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 4152 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 4154 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 4156 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 4158 */	
			0x12, 0x14,	/* FC_UP [alloced_on_stack] [pointer_deref] */
/* 4160 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4162) */
/* 4162 */	
			0x13, 0x0,	/* FC_OP */
/* 4164 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4166) */
/* 4166 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 4168 */	NdrFcShort( 0x2 ),	/* 2 */
/* 4170 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 4172 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 4174 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 4176 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 4178 */	
			0x12, 0x14,	/* FC_UP [alloced_on_stack] [pointer_deref] */
/* 4180 */	NdrFcShort( 0xfffff148 ),	/* Offset= -3768 (412) */
/* 4182 */	
			0x12, 0x0,	/* FC_UP */
/* 4184 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4186) */
/* 4186 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 4188 */	NdrFcShort( 0x4 ),	/* 4 */
/* 4190 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 4192 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 4194 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 4196 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 4198 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 4200 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4202) */
/* 4202 */	
			0x13, 0x0,	/* FC_OP */
/* 4204 */	NdrFcShort( 0x1e ),	/* Offset= 30 (4234) */
/* 4206 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 4208 */	NdrFcShort( 0x28 ),	/* 40 */
/* 4210 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4212 */	NdrFcShort( 0xa ),	/* Offset= 10 (4222) */
/* 4214 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 4216 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 4218 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 4220 */	0x40,		/* FC_STRUCTPAD4 */
			0x5b,		/* FC_END */
/* 4222 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 4224 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 4226 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 4228 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 4230 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 4232 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 4234 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 4236 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4238 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 4240 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 4242 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 4244 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 4248 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 4250 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4252 */	NdrFcShort( 0xffffffd2 ),	/* Offset= -46 (4206) */
/* 4254 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4256 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 4258 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4260) */
/* 4260 */	
			0x13, 0x0,	/* FC_OP */
/* 4262 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4264) */
/* 4264 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 4266 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4268 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 4270 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 4272 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 4274 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 4276 */	
			0x12, 0x14,	/* FC_UP [alloced_on_stack] [pointer_deref] */
/* 4278 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4280) */
/* 4280 */	
			0x13, 0x0,	/* FC_OP */
/* 4282 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4284) */
/* 4284 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 4286 */	NdrFcShort( 0x2 ),	/* 2 */
/* 4288 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 4290 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 4292 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 4294 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 4296 */	
			0x12, 0x14,	/* FC_UP [alloced_on_stack] [pointer_deref] */
/* 4298 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4300) */
/* 4300 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 4302 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 4304 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 4306 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 4308 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 4310 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4312) */
/* 4312 */	
			0x13, 0x0,	/* FC_OP */
/* 4314 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4316) */
/* 4316 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 4318 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4320 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 4322 */	NdrFcShort( 0x20 ),	/* 32 */
/* 4324 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 4326 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 4328 */	
			0x11, 0x0,	/* FC_RP */
/* 4330 */	NdrFcShort( 0xfffffc8e ),	/* Offset= -882 (3448) */
/* 4332 */	
			0x11, 0x0,	/* FC_RP */
/* 4334 */	NdrFcShort( 0xfffff0b2 ),	/* Offset= -3918 (416) */
/* 4336 */	
			0x12, 0x0,	/* FC_UP */
/* 4338 */	NdrFcShort( 0xfffff0ae ),	/* Offset= -3922 (416) */
/* 4340 */	
			0x11, 0x0,	/* FC_RP */
/* 4342 */	NdrFcShort( 0x12 ),	/* Offset= 18 (4360) */
/* 4344 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 4346 */	NdrFcShort( 0x10 ),	/* 16 */
/* 4348 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4350 */	NdrFcShort( 0x6 ),	/* Offset= 6 (4356) */
/* 4352 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 4354 */	0x40,		/* FC_STRUCTPAD4 */
			0x5b,		/* FC_END */
/* 4356 */	
			0x12, 0x0,	/* FC_UP */
/* 4358 */	NdrFcShort( 0xfffff09a ),	/* Offset= -3942 (416) */
/* 4360 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 4362 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4364 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 4366 */	NdrFcShort( 0x21 ),	/* 33 */
/* 4368 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 4370 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 4374 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 4376 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4378 */	NdrFcShort( 0xffffffde ),	/* Offset= -34 (4344) */
/* 4380 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4382 */	
			0x12, 0x0,	/* FC_UP */
/* 4384 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4386) */
/* 4386 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 4388 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4390 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 4392 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 4394 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 4396 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 4400 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 4402 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4404 */	NdrFcShort( 0xfffff470 ),	/* Offset= -2960 (1444) */
/* 4406 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4408 */	
			0x12, 0x14,	/* FC_UP [alloced_on_stack] [pointer_deref] */
/* 4410 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4412) */
/* 4412 */	
			0x13, 0x0,	/* FC_OP */
/* 4414 */	NdrFcShort( 0xfffff062 ),	/* Offset= -3998 (416) */
/* 4416 */	
			0x11, 0x0,	/* FC_RP */
/* 4418 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4420) */
/* 4420 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 4422 */	NdrFcShort( 0x4 ),	/* 4 */
/* 4424 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 4426 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 4428 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 4430 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 4432 */	
			0x11, 0x0,	/* FC_RP */
/* 4434 */	NdrFcShort( 0x40 ),	/* Offset= 64 (4498) */
/* 4436 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 4438 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4440 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 4442 */	NdrFcShort( 0x20 ),	/* 32 */
/* 4444 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 4446 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 4450 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 4452 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4454 */	NdrFcShort( 0xfffff43e ),	/* Offset= -3010 (1444) */
/* 4456 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4458 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 4460 */	NdrFcShort( 0x58 ),	/* 88 */
/* 4462 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4464 */	NdrFcShort( 0x16 ),	/* Offset= 22 (4486) */
/* 4466 */	0x36,		/* FC_POINTER */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 4468 */	0x0,		/* 0 */
			NdrFcShort( 0xffffeeab ),	/* Offset= -4437 (32) */
			0x36,		/* FC_POINTER */
/* 4472 */	0x36,		/* FC_POINTER */
			0x8,		/* FC_LONG */
/* 4474 */	0x40,		/* FC_STRUCTPAD4 */
			0xb,		/* FC_HYPER */
/* 4476 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4478 */	NdrFcShort( 0xfffff022 ),	/* Offset= -4062 (416) */
/* 4480 */	0x6,		/* FC_SHORT */
			0x1,		/* FC_BYTE */
/* 4482 */	0x1,		/* FC_BYTE */
			0x40,		/* FC_STRUCTPAD4 */
/* 4484 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4486 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 4488 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 4490 */	
			0x12, 0x0,	/* FC_UP */
/* 4492 */	NdrFcShort( 0xffffffc8 ),	/* Offset= -56 (4436) */
/* 4494 */	
			0x12, 0x0,	/* FC_UP */
/* 4496 */	NdrFcShort( 0xffffeea8 ),	/* Offset= -4440 (56) */
/* 4498 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x7,		/* 7 */
/* 4500 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4502 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 4504 */	NdrFcShort( 0x22 ),	/* 34 */
/* 4506 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 4508 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 4512 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 4514 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4516 */	NdrFcShort( 0xffffffc6 ),	/* Offset= -58 (4458) */
/* 4518 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4520 */	
			0x12, 0x0,	/* FC_UP */
/* 4522 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4524) */
/* 4524 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 4526 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4528 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 4530 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 4532 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 4534 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 4538 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 4540 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4542 */	NdrFcShort( 0xfffff3e6 ),	/* Offset= -3098 (1444) */
/* 4544 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4546 */	
			0x12, 0x14,	/* FC_UP [alloced_on_stack] [pointer_deref] */
/* 4548 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4550) */
/* 4550 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 4552 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 4554 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 4556 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 4558 */	
			0x11, 0x0,	/* FC_RP */
/* 4560 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4562) */
/* 4562 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 4564 */	NdrFcShort( 0x4 ),	/* 4 */
/* 4566 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 4568 */	NdrFcShort( 0x50 ),	/* ia64 Stack size/offset = 80 */
/* 4570 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 4572 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 4574 */	
			0x11, 0x0,	/* FC_RP */
/* 4576 */	NdrFcShort( 0xffffff8a ),	/* Offset= -118 (4458) */
/* 4578 */	
			0x11, 0x0,	/* FC_RP */
/* 4580 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4582) */
/* 4582 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 4584 */	NdrFcShort( 0x4 ),	/* 4 */
/* 4586 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 4588 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 4590 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 4592 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 4594 */	
			0x12, 0x14,	/* FC_UP [alloced_on_stack] [pointer_deref] */
/* 4596 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4598) */
/* 4598 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 4600 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 4602 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 4604 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 4606 */	
			0x12, 0x0,	/* FC_UP */
/* 4608 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4610) */
/* 4610 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 4612 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4614 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 4616 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 4618 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 4620 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 4624 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 4626 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4628 */	NdrFcShort( 0xfffff4fe ),	/* Offset= -2818 (1810) */
/* 4630 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4632 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 4634 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4636) */
/* 4636 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 4638 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 4640 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 4642 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 4644 */	
			0x11, 0x0,	/* FC_RP */
/* 4646 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4648) */
/* 4648 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 4650 */	NdrFcShort( 0x4 ),	/* 4 */
/* 4652 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x0,		/*  */
/* 4654 */	NdrFcShort( 0x48 ),	/* ia64 Stack size/offset = 72 */
/* 4656 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 4658 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 4660 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 4662 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4664) */
/* 4664 */	
			0x13, 0x0,	/* FC_OP */
/* 4666 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4668) */
/* 4668 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 4670 */	NdrFcShort( 0x10 ),	/* 16 */
/* 4672 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 4674 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 4676 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 4678 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4680 */	NdrFcShort( 0xffffedf0 ),	/* Offset= -4624 (56) */
/* 4682 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4684 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 4686 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4688) */
/* 4688 */	
			0x13, 0x0,	/* FC_OP */
/* 4690 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4692) */
/* 4692 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 4694 */	NdrFcShort( 0x4 ),	/* 4 */
/* 4696 */	0x29,		/* Corr desc:  parameter, FC_ULONG */
			0x54,		/* FC_DEREFERENCE */
/* 4698 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 4700 */	NdrFcShort( 0x1 ),	/* Corr flags:  early, */
/* 4702 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 4704 */	
			0x11, 0x0,	/* FC_RP */
/* 4706 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4708) */
/* 4708 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 4710 */	NdrFcShort( 0x2c ),	/* 44 */
/* 4712 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 4714 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4716 */	NdrFcShort( 0xffffedcc ),	/* Offset= -4660 (56) */
/* 4718 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4720 */	NdrFcShort( 0xffffedc8 ),	/* Offset= -4664 (56) */
/* 4722 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 4724 */	
			0x11, 0x0,	/* FC_RP */
/* 4726 */	NdrFcShort( 0x24 ),	/* Offset= 36 (4762) */
/* 4728 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 4730 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4732 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 4734 */	NdrFcShort( 0x10 ),	/* 16 */
/* 4736 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 4738 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 4742 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 4744 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 4746 */	NdrFcShort( 0xfffff488 ),	/* Offset= -2936 (1810) */
/* 4748 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4750 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 4752 */	NdrFcShort( 0x4 ),	/* 4 */
/* 4754 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 4756 */	NdrFcShort( 0x14 ),	/* 20 */
/* 4758 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 4760 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 4762 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 4764 */	NdrFcShort( 0x18 ),	/* 24 */
/* 4766 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4768 */	NdrFcShort( 0x8 ),	/* Offset= 8 (4776) */
/* 4770 */	0x36,		/* FC_POINTER */
			0x36,		/* FC_POINTER */
/* 4772 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 4774 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4776 */	
			0x12, 0x0,	/* FC_UP */
/* 4778 */	NdrFcShort( 0xffffffce ),	/* Offset= -50 (4728) */
/* 4780 */	
			0x12, 0x0,	/* FC_UP */
/* 4782 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (4750) */
/* 4784 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 4786 */	NdrFcShort( 0xffffffb2 ),	/* Offset= -78 (4708) */
/* 4788 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 4790 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4792) */
/* 4792 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 4794 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 4796 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 4798 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 4800 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 4802 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (4762) */
/* 4804 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 4806 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4808) */
/* 4808 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 4810 */	NdrFcShort( 0x1 ),	/* 1 */
/* 4812 */	NdrFcShort( 0x8 ),	/* 8 */
/* 4814 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4816 */	NdrFcShort( 0xfffff018 ),	/* Offset= -4072 (744) */
/* 4818 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 4820 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4822) */
/* 4822 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 4824 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 4826 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 4828 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 4830 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 4832 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4834) */
/* 4834 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4836 */	NdrFcLong( 0x3a6ad9e0 ),	/* 980081120 */
/* 4840 */	NdrFcShort( 0x23b9 ),	/* 9145 */
/* 4842 */	NdrFcShort( 0x11cf ),	/* 4559 */
/* 4844 */	0xad,		/* 173 */
			0x60,		/* 96 */
/* 4846 */	0x0,		/* 0 */
			0xaa,		/* 170 */
/* 4848 */	0x0,		/* 0 */
			0xa7,		/* 167 */
/* 4850 */	0x4c,		/* 76 */
			0xcd,		/* 205 */
/* 4852 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 4854 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4856) */
/* 4856 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4858 */	NdrFcLong( 0xfb15084 ),	/* 263278724 */
/* 4862 */	NdrFcShort( 0xaf41 ),	/* -20671 */
/* 4864 */	NdrFcShort( 0x11ce ),	/* 4558 */
/* 4866 */	0xbd,		/* 189 */
			0x2b,		/* 43 */
/* 4868 */	0x20,		/* 32 */
			0x4c,		/* 76 */
/* 4870 */	0x4f,		/* 79 */
			0x4f,		/* 79 */
/* 4872 */	0x50,		/* 80 */
			0x20,		/* 32 */
/* 4874 */	
			0x11, 0x8,	/* FC_RP [simple_pointer] */
/* 4876 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 4878 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 4880 */	NdrFcLong( 0x79eac9d0 ),	/* 2045430224 */
/* 4884 */	NdrFcShort( 0xbaf9 ),	/* -17671 */
/* 4886 */	NdrFcShort( 0x11ce ),	/* 4558 */
/* 4888 */	0x8c,		/* 140 */
			0x82,		/* 130 */
/* 4890 */	0x0,		/* 0 */
			0xaa,		/* 170 */
/* 4892 */	0x0,		/* 0 */
			0x4b,		/* 75 */
/* 4894 */	0xa9,		/* 169 */
			0xb,		/* 11 */
/* 4896 */	
			0x12, 0x14,	/* FC_UP [alloced_on_stack] [pointer_deref] */
/* 4898 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4900) */
/* 4900 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 4902 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 4904 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 4906 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 4908 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 4910 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4912) */
/* 4912 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 4914 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 4916 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 4918 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 4920 */	
			0x11, 0x0,	/* FC_RP */
/* 4922 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4924) */
/* 4924 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 4926 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4928 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 4930 */	NdrFcShort( 0x23 ),	/* 35 */
/* 4932 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 4934 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 4938 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 4940 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 4942 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 4944 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4946 */	
			0x11, 0x0,	/* FC_RP */
/* 4948 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4950) */
/* 4950 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 4952 */	NdrFcShort( 0x0 ),	/* 0 */
/* 4954 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 4956 */	NdrFcShort( 0x24 ),	/* 36 */
/* 4958 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 4960 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 4964 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 4966 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 4968 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 4970 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 4972 */	
			0x11, 0x0,	/* FC_RP */
/* 4974 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4976) */
/* 4976 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 4978 */	NdrFcShort( 0x4 ),	/* 4 */
/* 4980 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 4982 */	NdrFcShort( 0x25 ),	/* 37 */
/* 4984 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 4986 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 4988 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 4990 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4992) */
/* 4992 */	
			0x13, 0x0,	/* FC_OP */
/* 4994 */	NdrFcShort( 0x2 ),	/* Offset= 2 (4996) */
/* 4996 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 4998 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5000 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 5002 */	NdrFcShort( 0x26 ),	/* 38 */
/* 5004 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 5006 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 5008 */	
			0x11, 0x0,	/* FC_RP */
/* 5010 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5012) */
/* 5012 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 5014 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5016 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 5018 */	NdrFcShort( 0x27 ),	/* 39 */
/* 5020 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 5022 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 5026 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 5028 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 5030 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 5032 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 5034 */	
			0x11, 0x0,	/* FC_RP */
/* 5036 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5038) */
/* 5038 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 5040 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5042 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 5044 */	NdrFcShort( 0x28 ),	/* 40 */
/* 5046 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 5048 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 5052 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 5054 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 5056 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 5058 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 5060 */	
			0x11, 0x0,	/* FC_RP */
/* 5062 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5064) */
/* 5064 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 5066 */	NdrFcShort( 0x4 ),	/* 4 */
/* 5068 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 5070 */	NdrFcShort( 0x29 ),	/* 41 */
/* 5072 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 5074 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 5076 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 5078 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5080) */
/* 5080 */	
			0x13, 0x0,	/* FC_OP */
/* 5082 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5084) */
/* 5084 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 5086 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5088 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 5090 */	NdrFcShort( 0x2a ),	/* 42 */
/* 5092 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 5094 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 5096 */	
			0x11, 0x0,	/* FC_RP */
/* 5098 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5100) */
/* 5100 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 5102 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5104 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 5106 */	NdrFcShort( 0x2b ),	/* 43 */
/* 5108 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 5110 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 5114 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 5116 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 5118 */	
			0x25,		/* FC_C_WSTRING */
			0x5c,		/* FC_PAD */
/* 5120 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 5122 */	
			0x11, 0x0,	/* FC_RP */
/* 5124 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5126) */
/* 5126 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 5128 */	NdrFcShort( 0x4 ),	/* 4 */
/* 5130 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 5132 */	NdrFcShort( 0x2c ),	/* 44 */
/* 5134 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 5136 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 5138 */	
			0x12, 0x14,	/* FC_UP [alloced_on_stack] [pointer_deref] */
/* 5140 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5142) */
/* 5142 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 5144 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 5146 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 5148 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 5150 */	
			0x12, 0x14,	/* FC_UP [alloced_on_stack] [pointer_deref] */
/* 5152 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5154) */
/* 5154 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 5156 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 5158 */	NdrFcShort( 0x40 ),	/* ia64 Stack size/offset = 64 */
/* 5160 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 5162 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 5164 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5166) */
/* 5166 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 5168 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 5170 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 5172 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 5174 */	
			0x12, 0x0,	/* FC_UP */
/* 5176 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5178) */
/* 5178 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 5180 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5182 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 5184 */	NdrFcShort( 0x2d ),	/* 45 */
/* 5186 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 5188 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 5192 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 5194 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 5196 */	NdrFcShort( 0xffffed54 ),	/* Offset= -4780 (416) */
/* 5198 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 5200 */	
			0x12, 0x14,	/* FC_UP [alloced_on_stack] [pointer_deref] */
/* 5202 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5204) */
/* 5204 */	
			0x13, 0x0,	/* FC_OP */
/* 5206 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5208) */
/* 5208 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 5210 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5212 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 5214 */	NdrFcShort( 0x2e ),	/* 46 */
/* 5216 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 5218 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 5222 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 5224 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 5226 */	NdrFcShort( 0xffffed36 ),	/* Offset= -4810 (416) */
/* 5228 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 5230 */	
			0x12, 0x14,	/* FC_UP [alloced_on_stack] [pointer_deref] */
/* 5232 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5234) */
/* 5234 */	
			0x13, 0x0,	/* FC_OP */
/* 5236 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5238) */
/* 5238 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x7,		/* 7 */
/* 5240 */	NdrFcShort( 0x0 ),	/* 0 */
/* 5242 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 5244 */	NdrFcShort( 0x2f ),	/* 47 */
/* 5246 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 5248 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 5252 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 5254 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 5256 */	NdrFcShort( 0xfffffa5c ),	/* Offset= -1444 (3812) */
/* 5258 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 5260 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 5262 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5264) */
/* 5264 */	
			0x13, 0x0,	/* FC_OP */
/* 5266 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5268) */
/* 5268 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 5270 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5272 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 5274 */	NdrFcShort( 0x30 ),	/* 48 */
/* 5276 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 5278 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 5280 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/* 5282 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5284) */
/* 5284 */	
			0x13, 0x0,	/* FC_OP */
/* 5286 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5288) */
/* 5288 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 5290 */	NdrFcShort( 0x8 ),	/* 8 */
/* 5292 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 5294 */	NdrFcShort( 0x31 ),	/* 49 */
/* 5296 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 5298 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 5300 */	
			0x12, 0x14,	/* FC_UP [alloced_on_stack] [pointer_deref] */
/* 5302 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5304) */
/* 5304 */	
			0x13, 0x0,	/* FC_OP */
/* 5306 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5308) */
/* 5308 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 5310 */	NdrFcShort( 0x2 ),	/* 2 */
/* 5312 */	0x20,		/* Corr desc:  parameter,  */
			0x59,		/* FC_CALLBACK */
/* 5314 */	NdrFcShort( 0x32 ),	/* 50 */
/* 5316 */	NdrFcShort( 0x0 ),	/* Corr flags:  */
/* 5318 */	0x5,		/* FC_WCHAR */
			0x5b,		/* FC_END */
/* 5320 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 5322 */	NdrFcShort( 0xffffeb6e ),	/* Offset= -5266 (56) */
/* 5324 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 5326 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5328) */
/* 5328 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 5330 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 5332 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 5334 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */
/* 5336 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 5338 */	NdrFcShort( 0x2 ),	/* Offset= 2 (5340) */
/* 5340 */	
			0x2f,		/* FC_IP */
			0x5c,		/* FC_PAD */
/* 5342 */	0x2b,		/* Corr desc:  parameter, FC_HYPER */
			0x0,		/*  */
/* 5344 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 5346 */	NdrFcShort( 0x5 ),	/* Corr flags:  early, iid_is, */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            VARIANT_UserSize
            ,VARIANT_UserMarshal
            ,VARIANT_UserUnmarshal
            ,VARIANT_UserFree
            },
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            },
            {
            LPSAFEARRAY_UserSize
            ,LPSAFEARRAY_UserMarshal
            ,LPSAFEARRAY_UserUnmarshal
            ,LPSAFEARRAY_UserFree
            }

        };


static void __RPC_USER IViewSort_RemoteSetSortOrderExprEval_0006( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBORDINAL cValues;
        const DBORDINAL *rgColumns;
        const DBSORT *rgOrders;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->cValues );
}

static void __RPC_USER IViewSort_RemoteSetSortOrderExprEval_0007( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBORDINAL cValues;
        const DBORDINAL *rgColumns;
        const DBSORT *rgOrders;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->cValues );
}

static void __RPC_USER IAccessor_DBBINDEXTExprEval_0000( PMIDL_STUB_MESSAGE pStubMsg )
{
    DBBINDEXT *pS	=	( DBBINDEXT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->ulExtension );
}

static void __RPC_USER IAccessor_RemoteCreateAccessorExprEval_0001( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBACCESSORFLAGS dwAccessorFlags;
        char Pad0[4];
        DBCOUNTITEM cBindings;
        DBBINDING *rgBindings;
        DBLENGTH cbRowSize;
        HACCESSOR *phAccessor;
        DBBINDSTATUS *rgStatus;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->cBindings );
}

static void __RPC_USER IAccessor_RemoteCreateAccessorExprEval_0002( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBACCESSORFLAGS dwAccessorFlags;
        char Pad0[4];
        DBCOUNTITEM cBindings;
        DBBINDING *rgBindings;
        DBLENGTH cbRowSize;
        HACCESSOR *phAccessor;
        DBBINDSTATUS *rgStatus;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->cBindings );
}

static void __RPC_USER IAccessor_RemoteGetBindingsExprEval_0003( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        HACCESSOR hAccessor;
        DBACCESSORFLAGS *pdwAccessorFlags;
        DBCOUNTITEM *pcBindings;
        DBBINDING **prgBindings;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )*pS->pcBindings );
}

static void __RPC_USER ICommand_RemoteExecuteExprEval_000d( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        IUnknown *pUnkOuter;
        REFIID riid;
        HACCESSOR hAccessor;
        DB_UPARAMS cParamSets;
        GUID *pGuid;
        ULONG ulGuidOffset;
        char Pad0[4];
        RMTPACK *pInputParams;
        RMTPACK *pOutputParams;
        DBCOUNTITEM cBindings;
        DBBINDING *rgBindings;
        DBSTATUS *rgStatus;
        DBROWCOUNT *pcRowsAffected;
        IUnknown **ppRowset;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->cBindings );
}

static void __RPC_USER ICommand_RemoteExecuteExprEval_000e( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        IUnknown *pUnkOuter;
        REFIID riid;
        HACCESSOR hAccessor;
        DB_UPARAMS cParamSets;
        GUID *pGuid;
        ULONG ulGuidOffset;
        char Pad0[4];
        RMTPACK *pInputParams;
        RMTPACK *pOutputParams;
        DBCOUNTITEM cBindings;
        DBBINDING *rgBindings;
        DBSTATUS *rgStatus;
        DBROWCOUNT *pcRowsAffected;
        IUnknown **ppRowset;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->cBindings );
}

static void __RPC_USER IViewSort_RemoteGetSortOrderExprEval_0004( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBORDINAL *pcValues;
        DBORDINAL **prgColumns;
        DBSORT **prgOrders;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )*pS->pcValues );
}

static void __RPC_USER IViewSort_RemoteGetSortOrderExprEval_0005( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBORDINAL *pcValues;
        DBORDINAL **prgColumns;
        DBSORT **prgOrders;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )*pS->pcValues );
}

static void __RPC_USER ICommandWithParameters_RemoteGetParameterInfoExprEval_0011( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DB_UPARAMS *pcParams;
        DBPARAMINFO **prgParamInfo;
        DBBYTEOFFSET **prgNameOffsets;
        DBLENGTH *pcbNamesBuffer;
        OLECHAR **ppNamesBuffer;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )*pS->pcbNamesBuffer );
}

static void __RPC_USER ICommandWithParameters_RemoteMapParameterNamesExprEval_0012( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DB_UPARAMS cParamNames;
        LPCOLESTR *rgParamNames;
        DB_LPARAMS *rgParamOrdinals;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->cParamNames );
}

static void __RPC_USER ICommandWithParameters_RemoteMapParameterNamesExprEval_0013( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DB_UPARAMS cParamNames;
        LPCOLESTR *rgParamNames;
        DB_LPARAMS *rgParamOrdinals;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->cParamNames );
}

static void __RPC_USER ICommandWithParameters_RemoteSetParameterInfoExprEval_0014( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DB_UPARAMS cParams;
        const DB_UPARAMS *rgParamOrdinals;
        const DBPARAMBINDINFO *rgParamBindInfo;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->cParams );
}

static void __RPC_USER ICommandWithParameters_RemoteSetParameterInfoExprEval_0015( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DB_UPARAMS cParams;
        const DB_UPARAMS *rgParamOrdinals;
        const DBPARAMBINDINFO *rgParamBindInfo;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->cParams );
}

static void __RPC_USER IViewFilter_RemoteGetFilterBindingsExprEval_0008( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBCOUNTITEM *pcBindings;
        DBBINDING **prgBindings;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )*pS->pcBindings );
}

static void __RPC_USER IRowsetNotify_RemoteOnFieldChangeExprEval_0009( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        IRowset *pRowset;
        HROW hRow;
        DBORDINAL cColumns;
        DBORDINAL *rgColumns;
        DBREASON eReason;
        char Pad0[4];
        DBEVENTPHASE ePhase;
        char Pad1[4];
        BOOL fCantDeny;
        char Pad2[4];
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->cColumns );
}

static void __RPC_USER IRowsetNotify_RemoteOnRowChangeExprEval_000a( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        IRowset *pRowset;
        DBCOUNTITEM cRows;
        const HROW *rghRows;
        DBREASON eReason;
        char Pad0[4];
        DBEVENTPHASE ePhase;
        char Pad1[4];
        BOOL fCantDeny;
        char Pad2[4];
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->cRows );
}

static void __RPC_USER ICommand_PROPVARIANTExprEval_000b( PMIDL_STUB_MESSAGE pStubMsg )
{
    PROPVARIANT *pS	=	( PROPVARIANT * )(pStubMsg->StackTop - 8);
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( unsigned short  )pS->vt );
}

static void __RPC_USER ICommand_CLIPDATAExprEval_000c( PMIDL_STUB_MESSAGE pStubMsg )
{
    CLIPDATA *pS	=	( CLIPDATA * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( pS->cbSize - 4 );
}

static void __RPC_USER ICommandWithParameters_RemoteGetParameterInfoExprEval_000f( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DB_UPARAMS *pcParams;
        DBPARAMINFO **prgParamInfo;
        DBBYTEOFFSET **prgNameOffsets;
        DBLENGTH *pcbNamesBuffer;
        OLECHAR **ppNamesBuffer;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )*pS->pcParams );
}

static void __RPC_USER ICommandWithParameters_RemoteGetParameterInfoExprEval_0010( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DB_UPARAMS *pcParams;
        DBPARAMINFO **prgParamInfo;
        DBBYTEOFFSET **prgNameOffsets;
        DBLENGTH *pcbNamesBuffer;
        OLECHAR **ppNamesBuffer;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )*pS->pcParams );
}

static void __RPC_USER IColumnsRowset_RemoteGetAvailableColumnsExprEval_0016( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBORDINAL *pcOptColumns;
        DBID **prgOptColumns;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )*pS->pcOptColumns );
}

static void __RPC_USER IColumnsRowset_RemoteGetColumnsRowsetExprEval_0017( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        IUnknown *pUnkOuter;
        DBORDINAL cOptColumns;
        const DBID *rgOptColumns;
        REFIID riid;
        ULONG cPropertySets;
        char Pad0[4];
        DBPROPSET *rgPropertySets;
        IUnknown **ppColRowset;
        ULONG cTotalProps;
        char Pad1[4];
        DBPROPSTATUS *rgPropStatus;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->cOptColumns );
}

static void __RPC_USER IColumnsRowset_RemoteGetColumnsRowsetExprEval_0018( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        IUnknown *pUnkOuter;
        DBORDINAL cOptColumns;
        const DBID *rgOptColumns;
        REFIID riid;
        ULONG cPropertySets;
        char Pad0[4];
        DBPROPSET *rgPropertySets;
        IUnknown **ppColRowset;
        ULONG cTotalProps;
        char Pad1[4];
        DBPROPSTATUS *rgPropStatus;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->cPropertySets );
}

static void __RPC_USER IColumnsRowset_RemoteGetColumnsRowsetExprEval_0019( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        IUnknown *pUnkOuter;
        DBORDINAL cOptColumns;
        const DBID *rgOptColumns;
        REFIID riid;
        ULONG cPropertySets;
        char Pad0[4];
        DBPROPSET *rgPropertySets;
        IUnknown **ppColRowset;
        ULONG cTotalProps;
        char Pad1[4];
        DBPROPSTATUS *rgPropStatus;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->cTotalProps );
}

static void __RPC_USER IColumnsInfo_RemoteGetColumnInfoExprEval_001a( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBORDINAL *pcColumns;
        DBCOLUMNINFO **prgInfo;
        DBBYTEOFFSET **prgNameOffsets;
        DBBYTEOFFSET **prgcolumnidOffsets;
        DBLENGTH *pcbStringsBuffer;
        OLECHAR **ppStringsBuffer;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )*pS->pcColumns );
}

static void __RPC_USER IColumnsInfo_RemoteGetColumnInfoExprEval_001b( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBORDINAL *pcColumns;
        DBCOLUMNINFO **prgInfo;
        DBBYTEOFFSET **prgNameOffsets;
        DBBYTEOFFSET **prgcolumnidOffsets;
        DBLENGTH *pcbStringsBuffer;
        OLECHAR **ppStringsBuffer;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )*pS->pcColumns );
}

static void __RPC_USER IColumnsInfo_RemoteGetColumnInfoExprEval_001c( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBORDINAL *pcColumns;
        DBCOLUMNINFO **prgInfo;
        DBBYTEOFFSET **prgNameOffsets;
        DBBYTEOFFSET **prgcolumnidOffsets;
        DBLENGTH *pcbStringsBuffer;
        OLECHAR **ppStringsBuffer;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )*pS->pcColumns );
}

static void __RPC_USER IColumnsInfo_RemoteGetColumnInfoExprEval_001d( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBORDINAL *pcColumns;
        DBCOLUMNINFO **prgInfo;
        DBBYTEOFFSET **prgNameOffsets;
        DBBYTEOFFSET **prgcolumnidOffsets;
        DBLENGTH *pcbStringsBuffer;
        OLECHAR **ppStringsBuffer;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )*pS->pcbStringsBuffer );
}

static void __RPC_USER IColumnsInfo_RemoteMapColumnIDsExprEval_001e( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBORDINAL cColumnIDs;
        const DBID *rgColumnIDs;
        DBORDINAL *rgColumns;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->cColumnIDs );
}

static void __RPC_USER IColumnsInfo_RemoteMapColumnIDsExprEval_001f( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBORDINAL cColumnIDs;
        const DBID *rgColumnIDs;
        DBORDINAL *rgColumns;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->cColumnIDs );
}

static void __RPC_USER IDBDataSourceAdmin_RemoteGetCreationPropertiesExprEval_0020( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        ULONG cPropertyIDSets;
        char Pad0[4];
        const DBPROPIDSET *rgPropertyIDSets;
        ULONG *pcPropertyInfoSets;
        DBPROPINFOSET **prgPropertyInfoSets;
        DBCOUNTITEM *pcOffsets;
        DBBYTEOFFSET **prgDescOffsets;
        ULONG *pcbDescBuffer;
        OLECHAR **ppDescBuffer;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )*pS->pcOffsets );
}

static void __RPC_USER IIndexDefinition_RemoteCreateIndexExprEval_0021( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBID *pTableID;
        DBID *pIndexID;
        DBORDINAL cIndexColumnDescs;
        const DBINDEXCOLUMNDESC *rgIndexColumnDescs;
        ULONG cPropertySets;
        char Pad0[4];
        DBPROPSET *rgPropertySets;
        DBID **ppIndexID;
        ULONG cTotalProps;
        char Pad1[4];
        DBPROPSTATUS *rgPropStatus;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->cIndexColumnDescs );
}

static void __RPC_USER ITableDefinition_RemoteCreateTableExprEval_0022( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        IUnknown *pUnkOuter;
        DBID *pTableID;
        DBORDINAL cColumnDescs;
        const DBCOLUMNDESC *rgColumnDescs;
        REFIID riid;
        ULONG cPropertySets;
        char Pad0[4];
        DBPROPSET *rgPropertySets;
        DBID **ppTableID;
        IUnknown **ppRowset;
        ULONG cTotalProps;
        char Pad1[4];
        DBPROPSTATUS *rgPropStatus;
        BOOL *pfTableCreated;
        IErrorInfo **ppErrorInfoRem;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->cColumnDescs );
}

static void __RPC_USER IScopedOperations_RemoteCopyExprEval_0023( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBCOUNTITEM cRows;
        LPCOLESTR *rgpwszSourceURLs;
        LPCOLESTR *rgpwszDestURLs;
        DWORD dwCopyFlags;
        char Pad0[4];
        IAuthenticate *pAuthenticate;
        DBSTATUS *rgdwStatus;
        DBBYTEOFFSET **prgulNewURLOffsets;
        ULONG *pcbStringsBuffer;
        OLECHAR **ppStringsBuffer;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->cRows );
}

static void __RPC_USER IScopedOperations_RemoteCopyExprEval_0024( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBCOUNTITEM cRows;
        LPCOLESTR *rgpwszSourceURLs;
        LPCOLESTR *rgpwszDestURLs;
        DWORD dwCopyFlags;
        char Pad0[4];
        IAuthenticate *pAuthenticate;
        DBSTATUS *rgdwStatus;
        DBBYTEOFFSET **prgulNewURLOffsets;
        ULONG *pcbStringsBuffer;
        OLECHAR **ppStringsBuffer;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->cRows );
}

static void __RPC_USER IScopedOperations_RemoteCopyExprEval_0025( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBCOUNTITEM cRows;
        LPCOLESTR *rgpwszSourceURLs;
        LPCOLESTR *rgpwszDestURLs;
        DWORD dwCopyFlags;
        char Pad0[4];
        IAuthenticate *pAuthenticate;
        DBSTATUS *rgdwStatus;
        DBBYTEOFFSET **prgulNewURLOffsets;
        ULONG *pcbStringsBuffer;
        OLECHAR **ppStringsBuffer;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->cRows );
}

static void __RPC_USER IScopedOperations_RemoteCopyExprEval_0026( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBCOUNTITEM cRows;
        LPCOLESTR *rgpwszSourceURLs;
        LPCOLESTR *rgpwszDestURLs;
        DWORD dwCopyFlags;
        char Pad0[4];
        IAuthenticate *pAuthenticate;
        DBSTATUS *rgdwStatus;
        DBBYTEOFFSET **prgulNewURLOffsets;
        ULONG *pcbStringsBuffer;
        OLECHAR **ppStringsBuffer;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->cRows );
}

static void __RPC_USER IScopedOperations_RemoteMoveExprEval_0027( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBCOUNTITEM cRows;
        LPCOLESTR *rgpwszSourceURLs;
        LPCOLESTR *rgpwszDestURLs;
        DWORD dwMoveFlags;
        char Pad0[4];
        IAuthenticate *pAuthenticate;
        DBSTATUS *rgdwStatus;
        DBBYTEOFFSET **prgulNewURLOffsets;
        ULONG *pcbStringsBuffer;
        OLECHAR **ppStringsBuffer;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->cRows );
}

static void __RPC_USER IScopedOperations_RemoteMoveExprEval_0028( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBCOUNTITEM cRows;
        LPCOLESTR *rgpwszSourceURLs;
        LPCOLESTR *rgpwszDestURLs;
        DWORD dwMoveFlags;
        char Pad0[4];
        IAuthenticate *pAuthenticate;
        DBSTATUS *rgdwStatus;
        DBBYTEOFFSET **prgulNewURLOffsets;
        ULONG *pcbStringsBuffer;
        OLECHAR **ppStringsBuffer;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->cRows );
}

static void __RPC_USER IScopedOperations_RemoteMoveExprEval_0029( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBCOUNTITEM cRows;
        LPCOLESTR *rgpwszSourceURLs;
        LPCOLESTR *rgpwszDestURLs;
        DWORD dwMoveFlags;
        char Pad0[4];
        IAuthenticate *pAuthenticate;
        DBSTATUS *rgdwStatus;
        DBBYTEOFFSET **prgulNewURLOffsets;
        ULONG *pcbStringsBuffer;
        OLECHAR **ppStringsBuffer;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->cRows );
}

static void __RPC_USER IScopedOperations_RemoteMoveExprEval_002a( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBCOUNTITEM cRows;
        LPCOLESTR *rgpwszSourceURLs;
        LPCOLESTR *rgpwszDestURLs;
        DWORD dwMoveFlags;
        char Pad0[4];
        IAuthenticate *pAuthenticate;
        DBSTATUS *rgdwStatus;
        DBBYTEOFFSET **prgulNewURLOffsets;
        ULONG *pcbStringsBuffer;
        OLECHAR **ppStringsBuffer;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->cRows );
}

static void __RPC_USER IScopedOperations_RemoteDeleteExprEval_002b( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBCOUNTITEM cRows;
        LPCOLESTR *rgpwszURLs;
        DWORD dwDeleteFlags;
        char Pad0[4];
        DBSTATUS *rgdwStatus;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->cRows );
}

static void __RPC_USER IScopedOperations_RemoteDeleteExprEval_002c( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBCOUNTITEM cRows;
        LPCOLESTR *rgpwszURLs;
        DWORD dwDeleteFlags;
        char Pad0[4];
        DBSTATUS *rgdwStatus;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->cRows );
}

static void __RPC_USER IColumnsInfo2_RemoteGetRestrictedColumnInfoExprEval_002d( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBORDINAL cColumnIDMasks;
        const DBID *rgColumnIDMasks;
        DWORD dwFlags;
        char Pad0[4];
        DBORDINAL *pcColumns;
        DBID **prgColumnIDs;
        DBCOLUMNINFO **prgColumnInfo;
        DBBYTEOFFSET **prgNameOffsets;
        DBBYTEOFFSET **prgcolumnidOffsets;
        DBLENGTH *pcbStringsBuffer;
        OLECHAR **ppStringsBuffer;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )pS->cColumnIDMasks );
}

static void __RPC_USER IColumnsInfo2_RemoteGetRestrictedColumnInfoExprEval_002e( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBORDINAL cColumnIDMasks;
        const DBID *rgColumnIDMasks;
        DWORD dwFlags;
        char Pad0[4];
        DBORDINAL *pcColumns;
        DBID **prgColumnIDs;
        DBCOLUMNINFO **prgColumnInfo;
        DBBYTEOFFSET **prgNameOffsets;
        DBBYTEOFFSET **prgcolumnidOffsets;
        DBLENGTH *pcbStringsBuffer;
        OLECHAR **ppStringsBuffer;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )*pS->pcColumns );
}

static void __RPC_USER IColumnsInfo2_RemoteGetRestrictedColumnInfoExprEval_002f( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBORDINAL cColumnIDMasks;
        const DBID *rgColumnIDMasks;
        DWORD dwFlags;
        char Pad0[4];
        DBORDINAL *pcColumns;
        DBID **prgColumnIDs;
        DBCOLUMNINFO **prgColumnInfo;
        DBBYTEOFFSET **prgNameOffsets;
        DBBYTEOFFSET **prgcolumnidOffsets;
        DBLENGTH *pcbStringsBuffer;
        OLECHAR **ppStringsBuffer;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )*pS->pcColumns );
}

static void __RPC_USER IColumnsInfo2_RemoteGetRestrictedColumnInfoExprEval_0030( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBORDINAL cColumnIDMasks;
        const DBID *rgColumnIDMasks;
        DWORD dwFlags;
        char Pad0[4];
        DBORDINAL *pcColumns;
        DBID **prgColumnIDs;
        DBCOLUMNINFO **prgColumnInfo;
        DBBYTEOFFSET **prgNameOffsets;
        DBBYTEOFFSET **prgcolumnidOffsets;
        DBLENGTH *pcbStringsBuffer;
        OLECHAR **ppStringsBuffer;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )*pS->pcColumns );
}

static void __RPC_USER IColumnsInfo2_RemoteGetRestrictedColumnInfoExprEval_0031( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBORDINAL cColumnIDMasks;
        const DBID *rgColumnIDMasks;
        DWORD dwFlags;
        char Pad0[4];
        DBORDINAL *pcColumns;
        DBID **prgColumnIDs;
        DBCOLUMNINFO **prgColumnInfo;
        DBBYTEOFFSET **prgNameOffsets;
        DBBYTEOFFSET **prgcolumnidOffsets;
        DBLENGTH *pcbStringsBuffer;
        OLECHAR **ppStringsBuffer;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )*pS->pcColumns );
}

static void __RPC_USER IColumnsInfo2_RemoteGetRestrictedColumnInfoExprEval_0032( PMIDL_STUB_MESSAGE pStubMsg )
{
    #pragma pack(8)
    struct _PARAM_STRUCT
        {
        IRowsetBookmark *This;
        DBORDINAL cColumnIDMasks;
        const DBID *rgColumnIDMasks;
        DWORD dwFlags;
        char Pad0[4];
        DBORDINAL *pcColumns;
        DBID **prgColumnIDs;
        DBCOLUMNINFO **prgColumnInfo;
        DBBYTEOFFSET **prgNameOffsets;
        DBBYTEOFFSET **prgcolumnidOffsets;
        DBLENGTH *pcbStringsBuffer;
        OLECHAR **ppStringsBuffer;
        HRESULT _RetVal;
        };
    #pragma pack()
    struct _PARAM_STRUCT *pS	=	( struct _PARAM_STRUCT * )pStubMsg->StackTop;
    
    pStubMsg->Offset = 0;
    pStubMsg->MaxCount = (ULONG_PTR) ( ( ULONG  )*pS->pcbStringsBuffer );
}

static const EXPR_EVAL ExprEvalRoutines[] = 
    {
    IAccessor_DBBINDEXTExprEval_0000
    ,IAccessor_RemoteCreateAccessorExprEval_0001
    ,IAccessor_RemoteCreateAccessorExprEval_0002
    ,IAccessor_RemoteGetBindingsExprEval_0003
    ,IViewSort_RemoteGetSortOrderExprEval_0004
    ,IViewSort_RemoteGetSortOrderExprEval_0005
    ,IViewSort_RemoteSetSortOrderExprEval_0006
    ,IViewSort_RemoteSetSortOrderExprEval_0007
    ,IViewFilter_RemoteGetFilterBindingsExprEval_0008
    ,IRowsetNotify_RemoteOnFieldChangeExprEval_0009
    ,IRowsetNotify_RemoteOnRowChangeExprEval_000a
    ,ICommand_PROPVARIANTExprEval_000b
    ,ICommand_CLIPDATAExprEval_000c
    ,ICommand_RemoteExecuteExprEval_000d
    ,ICommand_RemoteExecuteExprEval_000e
    ,ICommandWithParameters_RemoteGetParameterInfoExprEval_000f
    ,ICommandWithParameters_RemoteGetParameterInfoExprEval_0010
    ,ICommandWithParameters_RemoteGetParameterInfoExprEval_0011
    ,ICommandWithParameters_RemoteMapParameterNamesExprEval_0012
    ,ICommandWithParameters_RemoteMapParameterNamesExprEval_0013
    ,ICommandWithParameters_RemoteSetParameterInfoExprEval_0014
    ,ICommandWithParameters_RemoteSetParameterInfoExprEval_0015
    ,IColumnsRowset_RemoteGetAvailableColumnsExprEval_0016
    ,IColumnsRowset_RemoteGetColumnsRowsetExprEval_0017
    ,IColumnsRowset_RemoteGetColumnsRowsetExprEval_0018
    ,IColumnsRowset_RemoteGetColumnsRowsetExprEval_0019
    ,IColumnsInfo_RemoteGetColumnInfoExprEval_001a
    ,IColumnsInfo_RemoteGetColumnInfoExprEval_001b
    ,IColumnsInfo_RemoteGetColumnInfoExprEval_001c
    ,IColumnsInfo_RemoteGetColumnInfoExprEval_001d
    ,IColumnsInfo_RemoteMapColumnIDsExprEval_001e
    ,IColumnsInfo_RemoteMapColumnIDsExprEval_001f
    ,IDBDataSourceAdmin_RemoteGetCreationPropertiesExprEval_0020
    ,IIndexDefinition_RemoteCreateIndexExprEval_0021
    ,ITableDefinition_RemoteCreateTableExprEval_0022
    ,IScopedOperations_RemoteCopyExprEval_0023
    ,IScopedOperations_RemoteCopyExprEval_0024
    ,IScopedOperations_RemoteCopyExprEval_0025
    ,IScopedOperations_RemoteCopyExprEval_0026
    ,IScopedOperations_RemoteMoveExprEval_0027
    ,IScopedOperations_RemoteMoveExprEval_0028
    ,IScopedOperations_RemoteMoveExprEval_0029
    ,IScopedOperations_RemoteMoveExprEval_002a
    ,IScopedOperations_RemoteDeleteExprEval_002b
    ,IScopedOperations_RemoteDeleteExprEval_002c
    ,IColumnsInfo2_RemoteGetRestrictedColumnInfoExprEval_002d
    ,IColumnsInfo2_RemoteGetRestrictedColumnInfoExprEval_002e
    ,IColumnsInfo2_RemoteGetRestrictedColumnInfoExprEval_002f
    ,IColumnsInfo2_RemoteGetRestrictedColumnInfoExprEval_0030
    ,IColumnsInfo2_RemoteGetRestrictedColumnInfoExprEval_0031
    ,IColumnsInfo2_RemoteGetRestrictedColumnInfoExprEval_0032
    };



/* Standard interface: __MIDL_itf_oledb_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Standard interface: DBStructureDefinitions, ver. 0.0,
   GUID={0x0c733a80,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IAccessor, ver. 0.0,
   GUID={0x0c733a8c,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IAccessor_FormatStringOffsetTable[] =
    {
    0,
    50,
    124,
    186
    };

static const MIDL_STUBLESS_PROXY_INFO IAccessor_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IAccessor_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IAccessor_StubThunkTable[] = 
    {
    IAccessor_RemoteAddRefAccessor_Thunk,
    IAccessor_RemoteCreateAccessor_Thunk,
    IAccessor_RemoteGetBindings_Thunk,
    IAccessor_RemoteReleaseAccessor_Thunk
    };

static const MIDL_SERVER_INFO IAccessor_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IAccessor_FormatStringOffsetTable[-3],
    &IAccessor_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(7) _IAccessorProxyVtbl = 
{
    &IAccessor_ProxyInfo,
    &IID_IAccessor,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IAccessor_AddRefAccessor_Proxy ,
    IAccessor_CreateAccessor_Proxy ,
    IAccessor_GetBindings_Proxy ,
    IAccessor_ReleaseAccessor_Proxy
};

const CInterfaceStubVtbl _IAccessorStubVtbl =
{
    &IID_IAccessor,
    &IAccessor_ServerInfo,
    7,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IRowset, ver. 0.0,
   GUID={0x0c733a7c,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IRowsetInfo, ver. 0.0,
   GUID={0x0c733a55,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IRowsetInfo_FormatStringOffsetTable[] =
    {
    236,
    298,
    354
    };

static const MIDL_STUBLESS_PROXY_INFO IRowsetInfo_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IRowsetInfo_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IRowsetInfo_StubThunkTable[] = 
    {
    IRowsetInfo_RemoteGetProperties_Thunk,
    IRowsetInfo_RemoteGetReferencedRowset_Thunk,
    IRowsetInfo_RemoteGetSpecification_Thunk
    };

static const MIDL_SERVER_INFO IRowsetInfo_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IRowsetInfo_FormatStringOffsetTable[-3],
    &IRowsetInfo_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(6) _IRowsetInfoProxyVtbl = 
{
    &IRowsetInfo_ProxyInfo,
    &IID_IRowsetInfo,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IRowsetInfo_GetProperties_Proxy ,
    IRowsetInfo_GetReferencedRowset_Proxy ,
    IRowsetInfo_GetSpecification_Proxy
};

const CInterfaceStubVtbl _IRowsetInfoStubVtbl =
{
    &IID_IRowsetInfo,
    &IRowsetInfo_ServerInfo,
    6,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IRowsetLocate, ver. 0.0,
   GUID={0x0c733a7d,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IRowsetResynch, ver. 0.0,
   GUID={0x0c733a84,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IRowsetScroll, ver. 0.0,
   GUID={0x0c733a7e,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Standard interface: __MIDL_itf_oledb_0265, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IChapteredRowset, ver. 0.0,
   GUID={0x0c733a93,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IChapteredRowset_FormatStringOffsetTable[] =
    {
    404,
    454
    };

static const MIDL_STUBLESS_PROXY_INFO IChapteredRowset_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IChapteredRowset_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IChapteredRowset_StubThunkTable[] = 
    {
    IChapteredRowset_RemoteAddRefChapter_Thunk,
    IChapteredRowset_RemoteReleaseChapter_Thunk
    };

static const MIDL_SERVER_INFO IChapteredRowset_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IChapteredRowset_FormatStringOffsetTable[-3],
    &IChapteredRowset_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IChapteredRowsetProxyVtbl = 
{
    &IChapteredRowset_ProxyInfo,
    &IID_IChapteredRowset,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IChapteredRowset_AddRefChapter_Proxy ,
    IChapteredRowset_ReleaseChapter_Proxy
};

const CInterfaceStubVtbl _IChapteredRowsetStubVtbl =
{
    &IID_IChapteredRowset,
    &IChapteredRowset_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IRowsetFind, ver. 0.0,
   GUID={0x0c733a9d,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IRowPosition, ver. 0.0,
   GUID={0x0c733a94,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IRowPosition_FormatStringOffsetTable[] =
    {
    504,
    542,
    598,
    648,
    692
    };

static const MIDL_STUBLESS_PROXY_INFO IRowPosition_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IRowPosition_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IRowPosition_StubThunkTable[] = 
    {
    IRowPosition_RemoteClearRowPosition_Thunk,
    IRowPosition_RemoteGetRowPosition_Thunk,
    IRowPosition_RemoteGetRowset_Thunk,
    IRowPosition_RemoteInitialize_Thunk,
    IRowPosition_RemoteSetRowPosition_Thunk
    };

static const MIDL_SERVER_INFO IRowPosition_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IRowPosition_FormatStringOffsetTable[-3],
    &IRowPosition_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IRowPositionProxyVtbl = 
{
    &IRowPosition_ProxyInfo,
    &IID_IRowPosition,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IRowPosition_ClearRowPosition_Proxy ,
    IRowPosition_GetRowPosition_Proxy ,
    IRowPosition_GetRowset_Proxy ,
    IRowPosition_Initialize_Proxy ,
    IRowPosition_SetRowPosition_Proxy
};

const CInterfaceStubVtbl _IRowPositionStubVtbl =
{
    &IID_IRowPosition,
    &IRowPosition_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IRowPositionChange, ver. 0.0,
   GUID={0x0997a571,0x126e,0x11d0,{0x9f,0x8a,0x00,0xa0,0xc9,0xa0,0x63,0x1e}} */

#pragma code_seg(".orpc")
static const unsigned short IRowPositionChange_FormatStringOffsetTable[] =
    {
    748
    };

static const MIDL_STUBLESS_PROXY_INFO IRowPositionChange_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IRowPositionChange_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IRowPositionChange_StubThunkTable[] = 
    {
    IRowPositionChange_RemoteOnRowPositionChange_Thunk
    };

static const MIDL_SERVER_INFO IRowPositionChange_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IRowPositionChange_FormatStringOffsetTable[-3],
    &IRowPositionChange_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IRowPositionChangeProxyVtbl = 
{
    &IRowPositionChange_ProxyInfo,
    &IID_IRowPositionChange,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IRowPositionChange_OnRowPositionChange_Proxy
};

const CInterfaceStubVtbl _IRowPositionChangeStubVtbl =
{
    &IID_IRowPositionChange,
    &IRowPositionChange_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IViewRowset, ver. 0.0,
   GUID={0x0c733a97,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IViewRowset_FormatStringOffsetTable[] =
    {
    804,
    854
    };

static const MIDL_STUBLESS_PROXY_INFO IViewRowset_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IViewRowset_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IViewRowset_StubThunkTable[] = 
    {
    IViewRowset_RemoteGetSpecification_Thunk,
    IViewRowset_RemoteOpenViewRowset_Thunk
    };

static const MIDL_SERVER_INFO IViewRowset_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IViewRowset_FormatStringOffsetTable[-3],
    &IViewRowset_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IViewRowsetProxyVtbl = 
{
    &IViewRowset_ProxyInfo,
    &IID_IViewRowset,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IViewRowset_GetSpecification_Proxy ,
    IViewRowset_OpenViewRowset_Proxy
};

const CInterfaceStubVtbl _IViewRowsetStubVtbl =
{
    &IID_IViewRowset,
    &IViewRowset_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IViewChapter, ver. 0.0,
   GUID={0x0c733a98,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IViewChapter_FormatStringOffsetTable[] =
    {
    910,
    960
    };

static const MIDL_STUBLESS_PROXY_INFO IViewChapter_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IViewChapter_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IViewChapter_StubThunkTable[] = 
    {
    IViewChapter_RemoteGetSpecification_Thunk,
    IViewChapter_RemoteOpenViewChapter_Thunk
    };

static const MIDL_SERVER_INFO IViewChapter_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IViewChapter_FormatStringOffsetTable[-3],
    &IViewChapter_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IViewChapterProxyVtbl = 
{
    &IViewChapter_ProxyInfo,
    &IID_IViewChapter,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IViewChapter_GetSpecification_Proxy ,
    IViewChapter_OpenViewChapter_Proxy
};

const CInterfaceStubVtbl _IViewChapterStubVtbl =
{
    &IID_IViewChapter,
    &IViewChapter_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IViewSort, ver. 0.0,
   GUID={0x0c733a9a,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IViewSort_FormatStringOffsetTable[] =
    {
    1010,
    1066
    };

static const MIDL_STUBLESS_PROXY_INFO IViewSort_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IViewSort_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IViewSort_StubThunkTable[] = 
    {
    IViewSort_RemoteGetSortOrder_Thunk,
    IViewSort_RemoteSetSortOrder_Thunk
    };

static const MIDL_SERVER_INFO IViewSort_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IViewSort_FormatStringOffsetTable[-3],
    &IViewSort_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IViewSortProxyVtbl = 
{
    &IViewSort_ProxyInfo,
    &IID_IViewSort,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IViewSort_GetSortOrder_Proxy ,
    IViewSort_SetSortOrder_Proxy
};

const CInterfaceStubVtbl _IViewSortStubVtbl =
{
    &IID_IViewSort,
    &IViewSort_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IViewFilter, ver. 0.0,
   GUID={0x0c733a9b,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IViewFilter_FormatStringOffsetTable[] =
    {
    (unsigned short) -1,
    1122,
    (unsigned short) -1
    };

static const MIDL_STUBLESS_PROXY_INFO IViewFilter_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IViewFilter_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IViewFilter_StubThunkTable[] = 
    {
    0,
    IViewFilter_RemoteGetFilterBindings_Thunk,
    0
    };

static const MIDL_SERVER_INFO IViewFilter_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IViewFilter_FormatStringOffsetTable[-3],
    &IViewFilter_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(6) _IViewFilterProxyVtbl = 
{
    &IViewFilter_ProxyInfo,
    &IID_IViewFilter,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IViewFilter::GetFilter */ ,
    IViewFilter_GetFilterBindings_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IViewFilter::SetFilter */
};

const CInterfaceStubVtbl _IViewFilterStubVtbl =
{
    &IID_IViewFilter,
    &IViewFilter_ServerInfo,
    6,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IRowsetView, ver. 0.0,
   GUID={0x0c733a99,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IRowsetView_FormatStringOffsetTable[] =
    {
    1172,
    1228
    };

static const MIDL_STUBLESS_PROXY_INFO IRowsetView_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IRowsetView_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IRowsetView_StubThunkTable[] = 
    {
    IRowsetView_RemoteCreateView_Thunk,
    IRowsetView_RemoteGetView_Thunk
    };

static const MIDL_SERVER_INFO IRowsetView_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IRowsetView_FormatStringOffsetTable[-3],
    &IRowsetView_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IRowsetViewProxyVtbl = 
{
    &IRowsetView_ProxyInfo,
    &IID_IRowsetView,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IRowsetView_CreateView_Proxy ,
    IRowsetView_GetView_Proxy
};

const CInterfaceStubVtbl _IRowsetViewStubVtbl =
{
    &IID_IRowsetView,
    &IRowsetView_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_oledb_0274, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IRowsetExactScroll, ver. 0.0,
   GUID={0x0c733a7f,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Standard interface: __MIDL_itf_oledb_0275, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IRowsetChange, ver. 0.0,
   GUID={0x0c733a05,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IRowsetUpdate, ver. 0.0,
   GUID={0x0c733a6d,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IRowsetIdentity, ver. 0.0,
   GUID={0x0c733a09,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IRowsetIdentity_FormatStringOffsetTable[] =
    {
    1290
    };

static const MIDL_STUBLESS_PROXY_INFO IRowsetIdentity_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IRowsetIdentity_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IRowsetIdentity_StubThunkTable[] = 
    {
    IRowsetIdentity_RemoteIsSameRow_Thunk
    };

static const MIDL_SERVER_INFO IRowsetIdentity_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IRowsetIdentity_FormatStringOffsetTable[-3],
    &IRowsetIdentity_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IRowsetIdentityProxyVtbl = 
{
    &IRowsetIdentity_ProxyInfo,
    &IID_IRowsetIdentity,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IRowsetIdentity_IsSameRow_Proxy
};

const CInterfaceStubVtbl _IRowsetIdentityStubVtbl =
{
    &IID_IRowsetIdentity,
    &IRowsetIdentity_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IRowsetNotify, ver. 0.0,
   GUID={0x0c733a83,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IRowsetNotify_FormatStringOffsetTable[] =
    {
    1340,
    1414,
    1482
    };

static const MIDL_STUBLESS_PROXY_INFO IRowsetNotify_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IRowsetNotify_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IRowsetNotify_StubThunkTable[] = 
    {
    IRowsetNotify_RemoteOnFieldChange_Thunk,
    IRowsetNotify_RemoteOnRowChange_Thunk,
    IRowsetNotify_RemoteOnRowsetChange_Thunk
    };

static const MIDL_SERVER_INFO IRowsetNotify_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IRowsetNotify_FormatStringOffsetTable[-3],
    &IRowsetNotify_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(6) _IRowsetNotifyProxyVtbl = 
{
    &IRowsetNotify_ProxyInfo,
    &IID_IRowsetNotify,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IRowsetNotify_OnFieldChange_Proxy ,
    IRowsetNotify_OnRowChange_Proxy ,
    IRowsetNotify_OnRowsetChange_Proxy
};

const CInterfaceStubVtbl _IRowsetNotifyStubVtbl =
{
    &IID_IRowsetNotify,
    &IRowsetNotify_ServerInfo,
    6,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IRowsetIndex, ver. 0.0,
   GUID={0x0c733a82,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: ICommand, ver. 0.0,
   GUID={0x0c733a63,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short ICommand_FormatStringOffsetTable[] =
    {
    504,
    1538,
    1648
    };

static const MIDL_STUBLESS_PROXY_INFO ICommand_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICommand_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK ICommand_StubThunkTable[] = 
    {
    ICommand_RemoteCancel_Thunk,
    ICommand_RemoteExecute_Thunk,
    ICommand_RemoteGetDBSession_Thunk
    };

static const MIDL_SERVER_INFO ICommand_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICommand_FormatStringOffsetTable[-3],
    &ICommand_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(6) _ICommandProxyVtbl = 
{
    &ICommand_ProxyInfo,
    &IID_ICommand,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    ICommand_Cancel_Proxy ,
    ICommand_Execute_Proxy ,
    ICommand_GetDBSession_Proxy
};

const CInterfaceStubVtbl _ICommandStubVtbl =
{
    &IID_ICommand,
    &ICommand_ServerInfo,
    6,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IMultipleResults, ver. 0.0,
   GUID={0x0c733a90,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IMultipleResults_FormatStringOffsetTable[] =
    {
    1698
    };

static const MIDL_STUBLESS_PROXY_INFO IMultipleResults_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IMultipleResults_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IMultipleResults_StubThunkTable[] = 
    {
    IMultipleResults_RemoteGetResult_Thunk
    };

static const MIDL_SERVER_INFO IMultipleResults_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IMultipleResults_FormatStringOffsetTable[-3],
    &IMultipleResults_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IMultipleResultsProxyVtbl = 
{
    &IMultipleResults_ProxyInfo,
    &IID_IMultipleResults,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IMultipleResults_GetResult_Proxy
};

const CInterfaceStubVtbl _IMultipleResultsStubVtbl =
{
    &IID_IMultipleResults,
    &IMultipleResults_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IConvertType, ver. 0.0,
   GUID={0x0c733a88,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IConvertType_FormatStringOffsetTable[] =
    {
    1766
    };

static const MIDL_STUBLESS_PROXY_INFO IConvertType_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IConvertType_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IConvertType_StubThunkTable[] = 
    {
    IConvertType_RemoteCanConvert_Thunk
    };

static const MIDL_SERVER_INFO IConvertType_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IConvertType_FormatStringOffsetTable[-3],
    &IConvertType_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IConvertTypeProxyVtbl = 
{
    &IConvertType_ProxyInfo,
    &IID_IConvertType,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IConvertType_CanConvert_Proxy
};

const CInterfaceStubVtbl _IConvertTypeStubVtbl =
{
    &IID_IConvertType,
    &IConvertType_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICommandPrepare, ver. 0.0,
   GUID={0x0c733a26,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short ICommandPrepare_FormatStringOffsetTable[] =
    {
    1822,
    1866
    };

static const MIDL_STUBLESS_PROXY_INFO ICommandPrepare_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICommandPrepare_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK ICommandPrepare_StubThunkTable[] = 
    {
    ICommandPrepare_RemotePrepare_Thunk,
    ICommandPrepare_RemoteUnprepare_Thunk
    };

static const MIDL_SERVER_INFO ICommandPrepare_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICommandPrepare_FormatStringOffsetTable[-3],
    &ICommandPrepare_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _ICommandPrepareProxyVtbl = 
{
    &ICommandPrepare_ProxyInfo,
    &IID_ICommandPrepare,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    ICommandPrepare_Prepare_Proxy ,
    ICommandPrepare_Unprepare_Proxy
};

const CInterfaceStubVtbl _ICommandPrepareStubVtbl =
{
    &IID_ICommandPrepare,
    &ICommandPrepare_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICommandProperties, ver. 0.0,
   GUID={0x0c733a79,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short ICommandProperties_FormatStringOffsetTable[] =
    {
    236,
    1904
    };

static const MIDL_STUBLESS_PROXY_INFO ICommandProperties_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICommandProperties_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK ICommandProperties_StubThunkTable[] = 
    {
    ICommandProperties_RemoteGetProperties_Thunk,
    ICommandProperties_RemoteSetProperties_Thunk
    };

static const MIDL_SERVER_INFO ICommandProperties_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICommandProperties_FormatStringOffsetTable[-3],
    &ICommandProperties_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _ICommandPropertiesProxyVtbl = 
{
    &ICommandProperties_ProxyInfo,
    &IID_ICommandProperties,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    ICommandProperties_GetProperties_Proxy ,
    ICommandProperties_SetProperties_Proxy
};

const CInterfaceStubVtbl _ICommandPropertiesStubVtbl =
{
    &IID_ICommandProperties,
    &ICommandProperties_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICommandText, ver. 0.0,
   GUID={0x0c733a27,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short ICommandText_FormatStringOffsetTable[] =
    {
    504,
    1538,
    1648,
    1966,
    2016
    };

static const MIDL_STUBLESS_PROXY_INFO ICommandText_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICommandText_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK ICommandText_StubThunkTable[] = 
    {
    ICommand_RemoteCancel_Thunk,
    ICommand_RemoteExecute_Thunk,
    ICommand_RemoteGetDBSession_Thunk,
    ICommandText_RemoteGetCommandText_Thunk,
    ICommandText_RemoteSetCommandText_Thunk
    };

static const MIDL_SERVER_INFO ICommandText_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICommandText_FormatStringOffsetTable[-3],
    &ICommandText_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _ICommandTextProxyVtbl = 
{
    &ICommandText_ProxyInfo,
    &IID_ICommandText,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    ICommand_Cancel_Proxy ,
    ICommand_Execute_Proxy ,
    ICommand_GetDBSession_Proxy ,
    ICommandText_GetCommandText_Proxy ,
    ICommandText_SetCommandText_Proxy
};

const CInterfaceStubVtbl _ICommandTextStubVtbl =
{
    &IID_ICommandText,
    &ICommandText_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICommandWithParameters, ver. 0.0,
   GUID={0x0c733a64,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short ICommandWithParameters_FormatStringOffsetTable[] =
    {
    2066,
    2134,
    2190
    };

static const MIDL_STUBLESS_PROXY_INFO ICommandWithParameters_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICommandWithParameters_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK ICommandWithParameters_StubThunkTable[] = 
    {
    ICommandWithParameters_RemoteGetParameterInfo_Thunk,
    ICommandWithParameters_RemoteMapParameterNames_Thunk,
    ICommandWithParameters_RemoteSetParameterInfo_Thunk
    };

static const MIDL_SERVER_INFO ICommandWithParameters_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICommandWithParameters_FormatStringOffsetTable[-3],
    &ICommandWithParameters_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(6) _ICommandWithParametersProxyVtbl = 
{
    &ICommandWithParameters_ProxyInfo,
    &IID_ICommandWithParameters,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    ICommandWithParameters_GetParameterInfo_Proxy ,
    ICommandWithParameters_MapParameterNames_Proxy ,
    ICommandWithParameters_SetParameterInfo_Proxy
};

const CInterfaceStubVtbl _ICommandWithParametersStubVtbl =
{
    &IID_ICommandWithParameters,
    &ICommandWithParameters_ServerInfo,
    6,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IColumnsRowset, ver. 0.0,
   GUID={0x0c733a10,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IColumnsRowset_FormatStringOffsetTable[] =
    {
    2246,
    2296
    };

static const MIDL_STUBLESS_PROXY_INFO IColumnsRowset_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IColumnsRowset_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IColumnsRowset_StubThunkTable[] = 
    {
    IColumnsRowset_RemoteGetAvailableColumns_Thunk,
    IColumnsRowset_RemoteGetColumnsRowset_Thunk
    };

static const MIDL_SERVER_INFO IColumnsRowset_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IColumnsRowset_FormatStringOffsetTable[-3],
    &IColumnsRowset_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IColumnsRowsetProxyVtbl = 
{
    &IColumnsRowset_ProxyInfo,
    &IID_IColumnsRowset,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IColumnsRowset_GetAvailableColumns_Proxy ,
    IColumnsRowset_GetColumnsRowset_Proxy
};

const CInterfaceStubVtbl _IColumnsRowsetStubVtbl =
{
    &IID_IColumnsRowset,
    &IColumnsRowset_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IColumnsInfo, ver. 0.0,
   GUID={0x0c733a11,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IColumnsInfo_FormatStringOffsetTable[] =
    {
    2388,
    2462
    };

static const MIDL_STUBLESS_PROXY_INFO IColumnsInfo_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IColumnsInfo_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IColumnsInfo_StubThunkTable[] = 
    {
    IColumnsInfo_RemoteGetColumnInfo_Thunk,
    IColumnsInfo_RemoteMapColumnIDs_Thunk
    };

static const MIDL_SERVER_INFO IColumnsInfo_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IColumnsInfo_FormatStringOffsetTable[-3],
    &IColumnsInfo_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IColumnsInfoProxyVtbl = 
{
    &IColumnsInfo_ProxyInfo,
    &IID_IColumnsInfo,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IColumnsInfo_GetColumnInfo_Proxy ,
    IColumnsInfo_MapColumnIDs_Proxy
};

const CInterfaceStubVtbl _IColumnsInfoStubVtbl =
{
    &IID_IColumnsInfo,
    &IColumnsInfo_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDBCreateCommand, ver. 0.0,
   GUID={0x0c733a1d,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IDBCreateCommand_FormatStringOffsetTable[] =
    {
    2518
    };

static const MIDL_STUBLESS_PROXY_INFO IDBCreateCommand_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDBCreateCommand_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IDBCreateCommand_StubThunkTable[] = 
    {
    IDBCreateCommand_RemoteCreateCommand_Thunk
    };

static const MIDL_SERVER_INFO IDBCreateCommand_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDBCreateCommand_FormatStringOffsetTable[-3],
    &IDBCreateCommand_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IDBCreateCommandProxyVtbl = 
{
    &IDBCreateCommand_ProxyInfo,
    &IID_IDBCreateCommand,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IDBCreateCommand_CreateCommand_Proxy
};

const CInterfaceStubVtbl _IDBCreateCommandStubVtbl =
{
    &IID_IDBCreateCommand,
    &IDBCreateCommand_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDBCreateSession, ver. 0.0,
   GUID={0x0c733a5d,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IDBCreateSession_FormatStringOffsetTable[] =
    {
    2574
    };

static const MIDL_STUBLESS_PROXY_INFO IDBCreateSession_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDBCreateSession_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IDBCreateSession_StubThunkTable[] = 
    {
    IDBCreateSession_RemoteCreateSession_Thunk
    };

static const MIDL_SERVER_INFO IDBCreateSession_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDBCreateSession_FormatStringOffsetTable[-3],
    &IDBCreateSession_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IDBCreateSessionProxyVtbl = 
{
    &IDBCreateSession_ProxyInfo,
    &IID_IDBCreateSession,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IDBCreateSession_CreateSession_Proxy
};

const CInterfaceStubVtbl _IDBCreateSessionStubVtbl =
{
    &IID_IDBCreateSession,
    &IDBCreateSession_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ISourcesRowset, ver. 0.0,
   GUID={0x0c733a1e,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short ISourcesRowset_FormatStringOffsetTable[] =
    {
    2630
    };

static const MIDL_STUBLESS_PROXY_INFO ISourcesRowset_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISourcesRowset_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK ISourcesRowset_StubThunkTable[] = 
    {
    ISourcesRowset_RemoteGetSourcesRowset_Thunk
    };

static const MIDL_SERVER_INFO ISourcesRowset_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISourcesRowset_FormatStringOffsetTable[-3],
    &ISourcesRowset_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _ISourcesRowsetProxyVtbl = 
{
    &ISourcesRowset_ProxyInfo,
    &IID_ISourcesRowset,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    ISourcesRowset_GetSourcesRowset_Proxy
};

const CInterfaceStubVtbl _ISourcesRowsetStubVtbl =
{
    &IID_ISourcesRowset,
    &ISourcesRowset_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDBProperties, ver. 0.0,
   GUID={0x0c733a8a,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IDBProperties_FormatStringOffsetTable[] =
    {
    236,
    2710,
    2796
    };

static const MIDL_STUBLESS_PROXY_INFO IDBProperties_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDBProperties_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IDBProperties_StubThunkTable[] = 
    {
    IDBProperties_RemoteGetProperties_Thunk,
    IDBProperties_RemoteGetPropertyInfo_Thunk,
    IDBProperties_RemoteSetProperties_Thunk
    };

static const MIDL_SERVER_INFO IDBProperties_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDBProperties_FormatStringOffsetTable[-3],
    &IDBProperties_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(6) _IDBPropertiesProxyVtbl = 
{
    &IDBProperties_ProxyInfo,
    &IID_IDBProperties,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IDBProperties_GetProperties_Proxy ,
    IDBProperties_GetPropertyInfo_Proxy ,
    IDBProperties_SetProperties_Proxy
};

const CInterfaceStubVtbl _IDBPropertiesStubVtbl =
{
    &IID_IDBProperties,
    &IDBProperties_ServerInfo,
    6,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDBInitialize, ver. 0.0,
   GUID={0x0c733a8b,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IDBInitialize_FormatStringOffsetTable[] =
    {
    504,
    1866
    };

static const MIDL_STUBLESS_PROXY_INFO IDBInitialize_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDBInitialize_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IDBInitialize_StubThunkTable[] = 
    {
    IDBInitialize_RemoteInitialize_Thunk,
    IDBInitialize_RemoteUninitialize_Thunk
    };

static const MIDL_SERVER_INFO IDBInitialize_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDBInitialize_FormatStringOffsetTable[-3],
    &IDBInitialize_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IDBInitializeProxyVtbl = 
{
    &IDBInitialize_ProxyInfo,
    &IID_IDBInitialize,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IDBInitialize_Initialize_Proxy ,
    IDBInitialize_Uninitialize_Proxy
};

const CInterfaceStubVtbl _IDBInitializeStubVtbl =
{
    &IID_IDBInitialize,
    &IDBInitialize_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDBInfo, ver. 0.0,
   GUID={0x0c733a89,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IDBInfo_FormatStringOffsetTable[] =
    {
    2858,
    2902
    };

static const MIDL_STUBLESS_PROXY_INFO IDBInfo_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDBInfo_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IDBInfo_StubThunkTable[] = 
    {
    IDBInfo_RemoteGetKeywords_Thunk,
    IDBInfo_RemoteGetLiteralInfo_Thunk
    };

static const MIDL_SERVER_INFO IDBInfo_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDBInfo_FormatStringOffsetTable[-3],
    &IDBInfo_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IDBInfoProxyVtbl = 
{
    &IDBInfo_ProxyInfo,
    &IID_IDBInfo,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IDBInfo_GetKeywords_Proxy ,
    IDBInfo_GetLiteralInfo_Proxy
};

const CInterfaceStubVtbl _IDBInfoStubVtbl =
{
    &IID_IDBInfo,
    &IDBInfo_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDBDataSourceAdmin, ver. 0.0,
   GUID={0x0c733a7a,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IDBDataSourceAdmin_FormatStringOffsetTable[] =
    {
    2994,
    1866,
    3074,
    3160
    };

static const MIDL_STUBLESS_PROXY_INFO IDBDataSourceAdmin_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDBDataSourceAdmin_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IDBDataSourceAdmin_StubThunkTable[] = 
    {
    IDBDataSourceAdmin_RemoteCreateDataSource_Thunk,
    IDBDataSourceAdmin_RemoteDestroyDataSource_Thunk,
    IDBDataSourceAdmin_RemoteGetCreationProperties_Thunk,
    IDBDataSourceAdmin_RemoteModifyDataSource_Thunk
    };

static const MIDL_SERVER_INFO IDBDataSourceAdmin_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDBDataSourceAdmin_FormatStringOffsetTable[-3],
    &IDBDataSourceAdmin_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(7) _IDBDataSourceAdminProxyVtbl = 
{
    &IDBDataSourceAdmin_ProxyInfo,
    &IID_IDBDataSourceAdmin,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IDBDataSourceAdmin_CreateDataSource_Proxy ,
    IDBDataSourceAdmin_DestroyDataSource_Proxy ,
    IDBDataSourceAdmin_GetCreationProperties_Proxy ,
    IDBDataSourceAdmin_ModifyDataSource_Proxy
};

const CInterfaceStubVtbl _IDBDataSourceAdminStubVtbl =
{
    &IID_IDBDataSourceAdmin,
    &IDBDataSourceAdmin_ServerInfo,
    7,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_oledb_0296, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IDBAsynchNotify, ver. 0.0,
   GUID={0x0c733a96,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IDBAsynchNotify_FormatStringOffsetTable[] =
    {
    3210,
    3248,
    3316
    };

static const MIDL_STUBLESS_PROXY_INFO IDBAsynchNotify_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDBAsynchNotify_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IDBAsynchNotify_StubThunkTable[] = 
    {
    IDBAsynchNotify_RemoteOnLowResource_Thunk,
    IDBAsynchNotify_RemoteOnProgress_Thunk,
    IDBAsynchNotify_RemoteOnStop_Thunk
    };

static const MIDL_SERVER_INFO IDBAsynchNotify_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDBAsynchNotify_FormatStringOffsetTable[-3],
    &IDBAsynchNotify_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(6) _IDBAsynchNotifyProxyVtbl = 
{
    &IDBAsynchNotify_ProxyInfo,
    &IID_IDBAsynchNotify,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IDBAsynchNotify_OnLowResource_Proxy ,
    IDBAsynchNotify_OnProgress_Proxy ,
    IDBAsynchNotify_OnStop_Proxy
};

const CInterfaceStubVtbl _IDBAsynchNotifyStubVtbl =
{
    &IID_IDBAsynchNotify,
    &IDBAsynchNotify_ServerInfo,
    6,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDBAsynchStatus, ver. 0.0,
   GUID={0x0c733a95,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IDBAsynchStatus_FormatStringOffsetTable[] =
    {
    3372,
    3422
    };

static const MIDL_STUBLESS_PROXY_INFO IDBAsynchStatus_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDBAsynchStatus_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IDBAsynchStatus_StubThunkTable[] = 
    {
    IDBAsynchStatus_RemoteAbort_Thunk,
    IDBAsynchStatus_RemoteGetStatus_Thunk
    };

static const MIDL_SERVER_INFO IDBAsynchStatus_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDBAsynchStatus_FormatStringOffsetTable[-3],
    &IDBAsynchStatus_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IDBAsynchStatusProxyVtbl = 
{
    &IDBAsynchStatus_ProxyInfo,
    &IID_IDBAsynchStatus,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IDBAsynchStatus_Abort_Proxy ,
    IDBAsynchStatus_GetStatus_Proxy
};

const CInterfaceStubVtbl _IDBAsynchStatusStubVtbl =
{
    &IID_IDBAsynchStatus,
    &IDBAsynchStatus_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_oledb_0298, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: ISessionProperties, ver. 0.0,
   GUID={0x0c733a85,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short ISessionProperties_FormatStringOffsetTable[] =
    {
    236,
    1904
    };

static const MIDL_STUBLESS_PROXY_INFO ISessionProperties_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISessionProperties_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK ISessionProperties_StubThunkTable[] = 
    {
    ISessionProperties_RemoteGetProperties_Thunk,
    ISessionProperties_RemoteSetProperties_Thunk
    };

static const MIDL_SERVER_INFO ISessionProperties_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISessionProperties_FormatStringOffsetTable[-3],
    &ISessionProperties_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _ISessionPropertiesProxyVtbl = 
{
    &ISessionProperties_ProxyInfo,
    &IID_ISessionProperties,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    ISessionProperties_GetProperties_Proxy ,
    ISessionProperties_SetProperties_Proxy
};

const CInterfaceStubVtbl _ISessionPropertiesStubVtbl =
{
    &IID_ISessionProperties,
    &ISessionProperties_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IIndexDefinition, ver. 0.0,
   GUID={0x0c733a68,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IIndexDefinition_FormatStringOffsetTable[] =
    {
    3496,
    3588
    };

static const MIDL_STUBLESS_PROXY_INFO IIndexDefinition_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IIndexDefinition_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IIndexDefinition_StubThunkTable[] = 
    {
    IIndexDefinition_RemoteCreateIndex_Thunk,
    IIndexDefinition_RemoteDropIndex_Thunk
    };

static const MIDL_SERVER_INFO IIndexDefinition_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IIndexDefinition_FormatStringOffsetTable[-3],
    &IIndexDefinition_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IIndexDefinitionProxyVtbl = 
{
    &IIndexDefinition_ProxyInfo,
    &IID_IIndexDefinition,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IIndexDefinition_CreateIndex_Proxy ,
    IIndexDefinition_DropIndex_Proxy
};

const CInterfaceStubVtbl _IIndexDefinitionStubVtbl =
{
    &IID_IIndexDefinition,
    &IIndexDefinition_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ITableDefinition, ver. 0.0,
   GUID={0x0c733a86,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short ITableDefinition_FormatStringOffsetTable[] =
    {
    3638,
    3748,
    3792,
    3860
    };

static const MIDL_STUBLESS_PROXY_INFO ITableDefinition_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ITableDefinition_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK ITableDefinition_StubThunkTable[] = 
    {
    ITableDefinition_RemoteCreateTable_Thunk,
    ITableDefinition_RemoteDropTable_Thunk,
    ITableDefinition_RemoteAddColumn_Thunk,
    ITableDefinition_RemoteDropColumn_Thunk
    };

static const MIDL_SERVER_INFO ITableDefinition_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ITableDefinition_FormatStringOffsetTable[-3],
    &ITableDefinition_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(7) _ITableDefinitionProxyVtbl = 
{
    &ITableDefinition_ProxyInfo,
    &IID_ITableDefinition,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    ITableDefinition_CreateTable_Proxy ,
    ITableDefinition_DropTable_Proxy ,
    ITableDefinition_AddColumn_Proxy ,
    ITableDefinition_DropColumn_Proxy
};

const CInterfaceStubVtbl _ITableDefinitionStubVtbl =
{
    &IID_ITableDefinition,
    &ITableDefinition_ServerInfo,
    7,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IOpenRowset, ver. 0.0,
   GUID={0x0c733a69,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IOpenRowset_FormatStringOffsetTable[] =
    {
    3910
    };

static const MIDL_STUBLESS_PROXY_INFO IOpenRowset_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IOpenRowset_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IOpenRowset_StubThunkTable[] = 
    {
    IOpenRowset_RemoteOpenRowset_Thunk
    };

static const MIDL_SERVER_INFO IOpenRowset_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IOpenRowset_FormatStringOffsetTable[-3],
    &IOpenRowset_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IOpenRowsetProxyVtbl = 
{
    &IOpenRowset_ProxyInfo,
    &IID_IOpenRowset,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IOpenRowset_OpenRowset_Proxy
};

const CInterfaceStubVtbl _IOpenRowsetStubVtbl =
{
    &IID_IOpenRowset,
    &IOpenRowset_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDBSchemaRowset, ver. 0.0,
   GUID={0x0c733a7b,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IDBSchemaRowset_FormatStringOffsetTable[] =
    {
    4002,
    4100
    };

static const MIDL_STUBLESS_PROXY_INFO IDBSchemaRowset_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDBSchemaRowset_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IDBSchemaRowset_StubThunkTable[] = 
    {
    IDBSchemaRowset_RemoteGetRowset_Thunk,
    IDBSchemaRowset_RemoteGetSchemas_Thunk
    };

static const MIDL_SERVER_INFO IDBSchemaRowset_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDBSchemaRowset_FormatStringOffsetTable[-3],
    &IDBSchemaRowset_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _IDBSchemaRowsetProxyVtbl = 
{
    &IDBSchemaRowset_ProxyInfo,
    &IID_IDBSchemaRowset,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IDBSchemaRowset_GetRowset_Proxy ,
    IDBSchemaRowset_GetSchemas_Proxy
};

const CInterfaceStubVtbl _IDBSchemaRowsetStubVtbl =
{
    &IID_IDBSchemaRowset,
    &IDBSchemaRowset_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_oledb_0303, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IMDDataset, ver. 0.0,
   GUID={0xa07cccd1,0x8148,0x11d0,{0x87,0xbb,0x00,0xc0,0x4f,0xc3,0x39,0x42}} */


/* Object interface: IMDFind, ver. 0.0,
   GUID={0xa07cccd2,0x8148,0x11d0,{0x87,0xbb,0x00,0xc0,0x4f,0xc3,0x39,0x42}} */


/* Object interface: IMDRangeRowset, ver. 0.0,
   GUID={0x0c733aa0,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IAlterTable, ver. 0.0,
   GUID={0x0c733aa5,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IAlterIndex, ver. 0.0,
   GUID={0x0c733aa6,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IRowsetChapterMember, ver. 0.0,
   GUID={0x0c733aa8,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: ICommandPersist, ver. 0.0,
   GUID={0x0c733aa7,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IRowsetRefresh, ver. 0.0,
   GUID={0x0c733aa9,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IParentRowset, ver. 0.0,
   GUID={0x0c733aaa,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Standard interface: __MIDL_itf_oledb_0312, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IErrorRecords, ver. 0.0,
   GUID={0x0c733a67,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IErrorRecords_FormatStringOffsetTable[] =
    {
    4156,
    4224,
    4274,
    4330,
    4386,
    4436
    };

static const MIDL_STUBLESS_PROXY_INFO IErrorRecords_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IErrorRecords_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IErrorRecords_StubThunkTable[] = 
    {
    IErrorRecords_RemoteAddErrorRecord_Thunk,
    IErrorRecords_RemoteGetBasicErrorInfo_Thunk,
    IErrorRecords_RemoteGetCustomErrorObject_Thunk,
    IErrorRecords_RemoteGetErrorInfo_Thunk,
    IErrorRecords_RemoteGetErrorParameters_Thunk,
    IErrorRecords_RemoteGetRecordCount_Thunk
    };

static const MIDL_SERVER_INFO IErrorRecords_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IErrorRecords_FormatStringOffsetTable[-3],
    &IErrorRecords_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(9) _IErrorRecordsProxyVtbl = 
{
    &IErrorRecords_ProxyInfo,
    &IID_IErrorRecords,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IErrorRecords_AddErrorRecord_Proxy ,
    IErrorRecords_GetBasicErrorInfo_Proxy ,
    IErrorRecords_GetCustomErrorObject_Proxy ,
    IErrorRecords_GetErrorInfo_Proxy ,
    IErrorRecords_GetErrorParameters_Proxy ,
    IErrorRecords_GetRecordCount_Proxy
};

const CInterfaceStubVtbl _IErrorRecordsStubVtbl =
{
    &IID_IErrorRecords,
    &IErrorRecords_ServerInfo,
    9,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IErrorLookup, ver. 0.0,
   GUID={0x0c733a66,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IErrorLookup_FormatStringOffsetTable[] =
    {
    4480,
    4554,
    4622
    };

static const MIDL_STUBLESS_PROXY_INFO IErrorLookup_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IErrorLookup_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IErrorLookup_StubThunkTable[] = 
    {
    IErrorLookup_RemoteGetErrorDescription_Thunk,
    IErrorLookup_RemoteGetHelpInfo_Thunk,
    IErrorLookup_RemoteReleaseErrors_Thunk
    };

static const MIDL_SERVER_INFO IErrorLookup_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IErrorLookup_FormatStringOffsetTable[-3],
    &IErrorLookup_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(6) _IErrorLookupProxyVtbl = 
{
    &IErrorLookup_ProxyInfo,
    &IID_IErrorLookup,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IErrorLookup_GetErrorDescription_Proxy ,
    IErrorLookup_GetHelpInfo_Proxy ,
    IErrorLookup_ReleaseErrors_Proxy
};

const CInterfaceStubVtbl _IErrorLookupStubVtbl =
{
    &IID_IErrorLookup,
    &IErrorLookup_ServerInfo,
    6,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ISQLErrorInfo, ver. 0.0,
   GUID={0x0c733a74,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short ISQLErrorInfo_FormatStringOffsetTable[] =
    {
    4666
    };

static const MIDL_STUBLESS_PROXY_INFO ISQLErrorInfo_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ISQLErrorInfo_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK ISQLErrorInfo_StubThunkTable[] = 
    {
    ISQLErrorInfo_RemoteGetSQLInfo_Thunk
    };

static const MIDL_SERVER_INFO ISQLErrorInfo_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ISQLErrorInfo_FormatStringOffsetTable[-3],
    &ISQLErrorInfo_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _ISQLErrorInfoProxyVtbl = 
{
    &ISQLErrorInfo_ProxyInfo,
    &IID_ISQLErrorInfo,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    ISQLErrorInfo_GetSQLInfo_Proxy
};

const CInterfaceStubVtbl _ISQLErrorInfoStubVtbl =
{
    &IID_ISQLErrorInfo,
    &ISQLErrorInfo_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IGetDataSource, ver. 0.0,
   GUID={0x0c733a75,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IGetDataSource_FormatStringOffsetTable[] =
    {
    4716
    };

static const MIDL_STUBLESS_PROXY_INFO IGetDataSource_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IGetDataSource_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IGetDataSource_StubThunkTable[] = 
    {
    IGetDataSource_RemoteGetDataSource_Thunk
    };

static const MIDL_SERVER_INFO IGetDataSource_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IGetDataSource_FormatStringOffsetTable[-3],
    &IGetDataSource_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IGetDataSourceProxyVtbl = 
{
    &IGetDataSource_ProxyInfo,
    &IID_IGetDataSource,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IGetDataSource_GetDataSource_Proxy
};

const CInterfaceStubVtbl _IGetDataSourceStubVtbl =
{
    &IID_IGetDataSource,
    &IGetDataSource_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ITransaction, ver. 0.0,
   GUID={0x0fb15084,0xaf41,0x11ce,{0xbd,0x2b,0x20,0x4c,0x4f,0x4f,0x50,0x20}} */


/* Object interface: ITransactionLocal, ver. 0.0,
   GUID={0x0c733a5f,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short ITransactionLocal_FormatStringOffsetTable[] =
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    4766,
    4810
    };

static const MIDL_STUBLESS_PROXY_INFO ITransactionLocal_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ITransactionLocal_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK ITransactionLocal_StubThunkTable[] = 
    {
    0,
    0,
    0,
    ITransactionLocal_RemoteGetOptionsObject_Thunk,
    ITransactionLocal_RemoteStartTransaction_Thunk
    };

static const MIDL_SERVER_INFO ITransactionLocal_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ITransactionLocal_FormatStringOffsetTable[-3],
    &ITransactionLocal_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _ITransactionLocalProxyVtbl = 
{
    &ITransactionLocal_ProxyInfo,
    &IID_ITransactionLocal,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* ITransaction::Commit */ ,
    0 /* (void *) (INT_PTR) -1 /* ITransaction::Abort */ ,
    0 /* (void *) (INT_PTR) -1 /* ITransaction::GetTransactionInfo */ ,
    ITransactionLocal_GetOptionsObject_Proxy ,
    ITransactionLocal_StartTransaction_Proxy
};


static const PRPC_STUB_FUNCTION ITransactionLocal_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _ITransactionLocalStubVtbl =
{
    &IID_ITransactionLocal,
    &ITransactionLocal_ServerInfo,
    8,
    &ITransactionLocal_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};


/* Object interface: ITransactionJoin, ver. 0.0,
   GUID={0x0c733a5e,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short ITransactionJoin_FormatStringOffsetTable[] =
    {
    4872,
    4916
    };

static const MIDL_STUBLESS_PROXY_INFO ITransactionJoin_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ITransactionJoin_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK ITransactionJoin_StubThunkTable[] = 
    {
    ITransactionJoin_RemoteGetOptionsObject_Thunk,
    ITransactionJoin_RemoteJoinTransaction_Thunk
    };

static const MIDL_SERVER_INFO ITransactionJoin_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ITransactionJoin_FormatStringOffsetTable[-3],
    &ITransactionJoin_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _ITransactionJoinProxyVtbl = 
{
    &ITransactionJoin_ProxyInfo,
    &IID_ITransactionJoin,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    ITransactionJoin_GetOptionsObject_Proxy ,
    ITransactionJoin_JoinTransaction_Proxy
};

const CInterfaceStubVtbl _ITransactionJoinStubVtbl =
{
    &IID_ITransactionJoin,
    &ITransactionJoin_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ITransactionObject, ver. 0.0,
   GUID={0x0c733a60,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short ITransactionObject_FormatStringOffsetTable[] =
    {
    4978
    };

static const MIDL_STUBLESS_PROXY_INFO ITransactionObject_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ITransactionObject_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK ITransactionObject_StubThunkTable[] = 
    {
    ITransactionObject_RemoteGetTransactionObject_Thunk
    };

static const MIDL_SERVER_INFO ITransactionObject_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ITransactionObject_FormatStringOffsetTable[-3],
    &ITransactionObject_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _ITransactionObjectProxyVtbl = 
{
    &ITransactionObject_ProxyInfo,
    &IID_ITransactionObject,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    ITransactionObject_GetTransactionObject_Proxy
};

const CInterfaceStubVtbl _ITransactionObjectStubVtbl =
{
    &IID_ITransactionObject,
    &ITransactionObject_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_oledb_0326, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: ITrusteeAdmin, ver. 0.0,
   GUID={0x0c733aa1,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: ITrusteeGroupAdmin, ver. 0.0,
   GUID={0x0c733aa2,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IObjectAccessControl, ver. 0.0,
   GUID={0x0c733aa3,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: ISecurityInfo, ver. 0.0,
   GUID={0x0c733aa4,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Standard interface: __MIDL_itf_oledb_0330, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: ITableCreation, ver. 0.0,
   GUID={0x0c733abc,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: ITableDefinitionWithConstraints, ver. 0.0,
   GUID={0x0c733aab,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Standard interface: __MIDL_itf_oledb_0331, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IRow, ver. 0.0,
   GUID={0x0c733ab4,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IRowChange, ver. 0.0,
   GUID={0x0c733ab5,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IRowSchemaChange, ver. 0.0,
   GUID={0x0c733aae,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IGetRow, ver. 0.0,
   GUID={0x0c733aaf,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IBindResource, ver. 0.0,
   GUID={0x0c733ab1,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IBindResource_FormatStringOffsetTable[] =
    {
    5028
    };

static const MIDL_STUBLESS_PROXY_INFO IBindResource_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IBindResource_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IBindResource_StubThunkTable[] = 
    {
    IBindResource_RemoteBind_Thunk
    };

static const MIDL_SERVER_INFO IBindResource_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IBindResource_FormatStringOffsetTable[-3],
    &IBindResource_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IBindResourceProxyVtbl = 
{
    &IBindResource_ProxyInfo,
    &IID_IBindResource,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IBindResource_Bind_Proxy
};

const CInterfaceStubVtbl _IBindResourceStubVtbl =
{
    &IID_IBindResource,
    &IBindResource_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IScopedOperations, ver. 0.0,
   GUID={0x0c733ab0,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IScopedOperations_FormatStringOffsetTable[] =
    {
    5028,
    5126,
    5212,
    5298,
    5354
    };

static const MIDL_STUBLESS_PROXY_INFO IScopedOperations_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IScopedOperations_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IScopedOperations_StubThunkTable[] = 
    {
    IBindResource_RemoteBind_Thunk,
    IScopedOperations_RemoteCopy_Thunk,
    IScopedOperations_RemoteMove_Thunk,
    IScopedOperations_RemoteDelete_Thunk,
    IScopedOperations_RemoteOpenRowset_Thunk
    };

static const MIDL_SERVER_INFO IScopedOperations_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IScopedOperations_FormatStringOffsetTable[-3],
    &IScopedOperations_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(8) _IScopedOperationsProxyVtbl = 
{
    &IScopedOperations_ProxyInfo,
    &IID_IScopedOperations,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IBindResource_Bind_Proxy ,
    IScopedOperations_Copy_Proxy ,
    IScopedOperations_Move_Proxy ,
    IScopedOperations_Delete_Proxy ,
    IScopedOperations_OpenRowset_Proxy
};

const CInterfaceStubVtbl _IScopedOperationsStubVtbl =
{
    &IID_IScopedOperations,
    &IScopedOperations_ServerInfo,
    8,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ICreateRow, ver. 0.0,
   GUID={0x0c733ab2,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short ICreateRow_FormatStringOffsetTable[] =
    {
    5440
    };

static const MIDL_STUBLESS_PROXY_INFO ICreateRow_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICreateRow_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK ICreateRow_StubThunkTable[] = 
    {
    ICreateRow_RemoteCreateRow_Thunk
    };

static const MIDL_SERVER_INFO ICreateRow_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICreateRow_FormatStringOffsetTable[-3],
    &ICreateRow_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _ICreateRowProxyVtbl = 
{
    &ICreateRow_ProxyInfo,
    &IID_ICreateRow,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    ICreateRow_CreateRow_Proxy
};

const CInterfaceStubVtbl _ICreateRowStubVtbl =
{
    &IID_ICreateRow,
    &ICreateRow_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IDBBinderProperties, ver. 0.0,
   GUID={0x0c733ab3,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IDBBinderProperties_FormatStringOffsetTable[] =
    {
    236,
    2710,
    2796,
    5544
    };

static const MIDL_STUBLESS_PROXY_INFO IDBBinderProperties_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IDBBinderProperties_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IDBBinderProperties_StubThunkTable[] = 
    {
    IDBProperties_RemoteGetProperties_Thunk,
    IDBProperties_RemoteGetPropertyInfo_Thunk,
    IDBProperties_RemoteSetProperties_Thunk,
    0
    };

static const MIDL_SERVER_INFO IDBBinderProperties_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IDBBinderProperties_FormatStringOffsetTable[-3],
    &IDBBinderProperties_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(7) _IDBBinderPropertiesProxyVtbl = 
{
    &IDBBinderProperties_ProxyInfo,
    &IID_IDBBinderProperties,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IDBProperties_GetProperties_Proxy ,
    IDBProperties_GetPropertyInfo_Proxy ,
    IDBProperties_SetProperties_Proxy ,
    (void *) (INT_PTR) -1 /* IDBBinderProperties::Reset */
};

const CInterfaceStubVtbl _IDBBinderPropertiesStubVtbl =
{
    &IID_IDBBinderProperties,
    &IDBBinderProperties_ServerInfo,
    7,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IColumnsInfo2, ver. 0.0,
   GUID={0x0c733ab8,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IColumnsInfo2_FormatStringOffsetTable[] =
    {
    2388,
    2462,
    5576
    };

static const MIDL_STUBLESS_PROXY_INFO IColumnsInfo2_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IColumnsInfo2_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IColumnsInfo2_StubThunkTable[] = 
    {
    IColumnsInfo_RemoteGetColumnInfo_Thunk,
    IColumnsInfo_RemoteMapColumnIDs_Thunk,
    IColumnsInfo2_RemoteGetRestrictedColumnInfo_Thunk
    };

static const MIDL_SERVER_INFO IColumnsInfo2_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IColumnsInfo2_FormatStringOffsetTable[-3],
    &IColumnsInfo2_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(6) _IColumnsInfo2ProxyVtbl = 
{
    &IColumnsInfo2_ProxyInfo,
    &IID_IColumnsInfo2,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IColumnsInfo_GetColumnInfo_Proxy ,
    IColumnsInfo_MapColumnIDs_Proxy ,
    IColumnsInfo2_GetRestrictedColumnInfo_Proxy
};

const CInterfaceStubVtbl _IColumnsInfo2StubVtbl =
{
    &IID_IColumnsInfo2,
    &IColumnsInfo2_ServerInfo,
    6,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IRegisterProvider, ver. 0.0,
   GUID={0x0c733ab9,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IRegisterProvider_FormatStringOffsetTable[] =
    {
    5668,
    5718,
    5768
    };

static const MIDL_STUBLESS_PROXY_INFO IRegisterProvider_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IRegisterProvider_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const STUB_THUNK IRegisterProvider_StubThunkTable[] = 
    {
    IRegisterProvider_RemoteGetURLMapping_Thunk,
    0,
    0
    };

static const MIDL_SERVER_INFO IRegisterProvider_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IRegisterProvider_FormatStringOffsetTable[-3],
    &IRegisterProvider_StubThunkTable[-3],
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(6) _IRegisterProviderProxyVtbl = 
{
    &IRegisterProvider_ProxyInfo,
    &IID_IRegisterProvider,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    IRegisterProvider_GetURLMapping_Proxy ,
    (void *) (INT_PTR) -1 /* IRegisterProvider::SetURLMapping */ ,
    (void *) (INT_PTR) -1 /* IRegisterProvider::UnregisterProvider */
};

const CInterfaceStubVtbl _IRegisterProviderStubVtbl =
{
    &IID_IRegisterProvider,
    &IRegisterProvider_ServerInfo,
    6,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_oledb_0341, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IGetSession, ver. 0.0,
   GUID={0x0c733aba,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IGetSession_FormatStringOffsetTable[] =
    {
    5818
    };

static const MIDL_STUBLESS_PROXY_INFO IGetSession_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IGetSession_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IGetSession_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IGetSession_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IGetSessionProxyVtbl = 
{
    &IGetSession_ProxyInfo,
    &IID_IGetSession,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IGetSession::GetSession */
};

const CInterfaceStubVtbl _IGetSessionStubVtbl =
{
    &IID_IGetSession,
    &IGetSession_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IGetSourceRow, ver. 0.0,
   GUID={0x0c733abb,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IGetSourceRow_FormatStringOffsetTable[] =
    {
    5862
    };

static const MIDL_STUBLESS_PROXY_INFO IGetSourceRow_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IGetSourceRow_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IGetSourceRow_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IGetSourceRow_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IGetSourceRowProxyVtbl = 
{
    &IGetSourceRow_ProxyInfo,
    &IID_IGetSourceRow,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* IGetSourceRow::GetSourceRow */
};

const CInterfaceStubVtbl _IGetSourceRowStubVtbl =
{
    &IID_IGetSourceRow,
    &IGetSourceRow_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: IRowsetCurrentIndex, ver. 0.0,
   GUID={0x0c733abd,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Standard interface: __MIDL_itf_oledb_0345, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: ICommandStream, ver. 0.0,
   GUID={0x0c733abf,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */


/* Object interface: IRowsetBookmark, ver. 0.0,
   GUID={0x0c733ac2,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IRowsetBookmark_FormatStringOffsetTable[] =
    {
    (unsigned short) -1
    };

static const MIDL_STUBLESS_PROXY_INFO IRowsetBookmark_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IRowsetBookmark_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IRowsetBookmark_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IRowsetBookmark_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IRowsetBookmarkProxyVtbl = 
{
    &IRowsetBookmark_ProxyInfo,
    &IID_IRowsetBookmark,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IRowsetBookmark::PositionOnBookmark */
};

const CInterfaceStubVtbl _IRowsetBookmarkStubVtbl =
{
    &IID_IRowsetBookmark,
    &IRowsetBookmark_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_oledb_0347, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    ExprEvalRoutines,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000159, /* MIDL Version 6.0.345 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _oledb_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IRowsetIdentityProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IColumnsRowsetProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IColumnsInfoProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDBCreateCommandProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ISourcesRowsetProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICommandPrepareProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICommandTextProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IRowsetInfoProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDBCreateSessionProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ITransactionJoinProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ITransactionLocalProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ITransactionObjectProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICommandProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICommandWithParametersProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IErrorLookupProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IErrorRecordsProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IIndexDefinitionProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IOpenRowsetProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IRowPositionChangeProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ISQLErrorInfoProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IGetDataSourceProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICommandPropertiesProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDBDataSourceAdminProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDBSchemaRowsetProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IRowsetNotifyProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ISessionPropertiesProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ITableDefinitionProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IConvertTypeProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDBInfoProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDBPropertiesProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDBInitializeProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IAccessorProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IMultipleResultsProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IChapteredRowsetProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IRowPositionProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDBAsynchStatusProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDBAsynchNotifyProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IViewRowsetProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IViewChapterProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IRowsetViewProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IViewSortProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IViewFilterProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IScopedOperationsProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IBindResourceProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ICreateRowProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IDBBinderPropertiesProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IColumnsInfo2ProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IRegisterProviderProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IGetSessionProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IGetSourceRowProxyVtbl,
    ( CInterfaceProxyVtbl *) &_IRowsetBookmarkProxyVtbl,
    0
};

const CInterfaceStubVtbl * _oledb_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IRowsetIdentityStubVtbl,
    ( CInterfaceStubVtbl *) &_IColumnsRowsetStubVtbl,
    ( CInterfaceStubVtbl *) &_IColumnsInfoStubVtbl,
    ( CInterfaceStubVtbl *) &_IDBCreateCommandStubVtbl,
    ( CInterfaceStubVtbl *) &_ISourcesRowsetStubVtbl,
    ( CInterfaceStubVtbl *) &_ICommandPrepareStubVtbl,
    ( CInterfaceStubVtbl *) &_ICommandTextStubVtbl,
    ( CInterfaceStubVtbl *) &_IRowsetInfoStubVtbl,
    ( CInterfaceStubVtbl *) &_IDBCreateSessionStubVtbl,
    ( CInterfaceStubVtbl *) &_ITransactionJoinStubVtbl,
    ( CInterfaceStubVtbl *) &_ITransactionLocalStubVtbl,
    ( CInterfaceStubVtbl *) &_ITransactionObjectStubVtbl,
    ( CInterfaceStubVtbl *) &_ICommandStubVtbl,
    ( CInterfaceStubVtbl *) &_ICommandWithParametersStubVtbl,
    ( CInterfaceStubVtbl *) &_IErrorLookupStubVtbl,
    ( CInterfaceStubVtbl *) &_IErrorRecordsStubVtbl,
    ( CInterfaceStubVtbl *) &_IIndexDefinitionStubVtbl,
    ( CInterfaceStubVtbl *) &_IOpenRowsetStubVtbl,
    ( CInterfaceStubVtbl *) &_IRowPositionChangeStubVtbl,
    ( CInterfaceStubVtbl *) &_ISQLErrorInfoStubVtbl,
    ( CInterfaceStubVtbl *) &_IGetDataSourceStubVtbl,
    ( CInterfaceStubVtbl *) &_ICommandPropertiesStubVtbl,
    ( CInterfaceStubVtbl *) &_IDBDataSourceAdminStubVtbl,
    ( CInterfaceStubVtbl *) &_IDBSchemaRowsetStubVtbl,
    ( CInterfaceStubVtbl *) &_IRowsetNotifyStubVtbl,
    ( CInterfaceStubVtbl *) &_ISessionPropertiesStubVtbl,
    ( CInterfaceStubVtbl *) &_ITableDefinitionStubVtbl,
    ( CInterfaceStubVtbl *) &_IConvertTypeStubVtbl,
    ( CInterfaceStubVtbl *) &_IDBInfoStubVtbl,
    ( CInterfaceStubVtbl *) &_IDBPropertiesStubVtbl,
    ( CInterfaceStubVtbl *) &_IDBInitializeStubVtbl,
    ( CInterfaceStubVtbl *) &_IAccessorStubVtbl,
    ( CInterfaceStubVtbl *) &_IMultipleResultsStubVtbl,
    ( CInterfaceStubVtbl *) &_IChapteredRowsetStubVtbl,
    ( CInterfaceStubVtbl *) &_IRowPositionStubVtbl,
    ( CInterfaceStubVtbl *) &_IDBAsynchStatusStubVtbl,
    ( CInterfaceStubVtbl *) &_IDBAsynchNotifyStubVtbl,
    ( CInterfaceStubVtbl *) &_IViewRowsetStubVtbl,
    ( CInterfaceStubVtbl *) &_IViewChapterStubVtbl,
    ( CInterfaceStubVtbl *) &_IRowsetViewStubVtbl,
    ( CInterfaceStubVtbl *) &_IViewSortStubVtbl,
    ( CInterfaceStubVtbl *) &_IViewFilterStubVtbl,
    ( CInterfaceStubVtbl *) &_IScopedOperationsStubVtbl,
    ( CInterfaceStubVtbl *) &_IBindResourceStubVtbl,
    ( CInterfaceStubVtbl *) &_ICreateRowStubVtbl,
    ( CInterfaceStubVtbl *) &_IDBBinderPropertiesStubVtbl,
    ( CInterfaceStubVtbl *) &_IColumnsInfo2StubVtbl,
    ( CInterfaceStubVtbl *) &_IRegisterProviderStubVtbl,
    ( CInterfaceStubVtbl *) &_IGetSessionStubVtbl,
    ( CInterfaceStubVtbl *) &_IGetSourceRowStubVtbl,
    ( CInterfaceStubVtbl *) &_IRowsetBookmarkStubVtbl,
    0
};

PCInterfaceName const _oledb_InterfaceNamesList[] = 
{
    "IRowsetIdentity",
    "IColumnsRowset",
    "IColumnsInfo",
    "IDBCreateCommand",
    "ISourcesRowset",
    "ICommandPrepare",
    "ICommandText",
    "IRowsetInfo",
    "IDBCreateSession",
    "ITransactionJoin",
    "ITransactionLocal",
    "ITransactionObject",
    "ICommand",
    "ICommandWithParameters",
    "IErrorLookup",
    "IErrorRecords",
    "IIndexDefinition",
    "IOpenRowset",
    "IRowPositionChange",
    "ISQLErrorInfo",
    "IGetDataSource",
    "ICommandProperties",
    "IDBDataSourceAdmin",
    "IDBSchemaRowset",
    "IRowsetNotify",
    "ISessionProperties",
    "ITableDefinition",
    "IConvertType",
    "IDBInfo",
    "IDBProperties",
    "IDBInitialize",
    "IAccessor",
    "IMultipleResults",
    "IChapteredRowset",
    "IRowPosition",
    "IDBAsynchStatus",
    "IDBAsynchNotify",
    "IViewRowset",
    "IViewChapter",
    "IRowsetView",
    "IViewSort",
    "IViewFilter",
    "IScopedOperations",
    "IBindResource",
    "ICreateRow",
    "IDBBinderProperties",
    "IColumnsInfo2",
    "IRegisterProvider",
    "IGetSession",
    "IGetSourceRow",
    "IRowsetBookmark",
    0
};

const IID *  _oledb_BaseIIDList[] = 
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    &IID_ITransaction,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};


#define _oledb_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _oledb, pIID, n)

int __stdcall _oledb_IID_Lookup( const IID * pIID, int * pIndex )
{
    IID_BS_LOOKUP_SETUP

    IID_BS_LOOKUP_INITIAL_TEST( _oledb, 51, 32 )
    IID_BS_LOOKUP_NEXT_TEST( _oledb, 16 )
    IID_BS_LOOKUP_NEXT_TEST( _oledb, 8 )
    IID_BS_LOOKUP_NEXT_TEST( _oledb, 4 )
    IID_BS_LOOKUP_NEXT_TEST( _oledb, 2 )
    IID_BS_LOOKUP_NEXT_TEST( _oledb, 1 )
    IID_BS_LOOKUP_RETURN_RESULT( _oledb, 51, *pIndex )
    
}

const ExtendedProxyFileInfo oledb_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _oledb_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _oledb_StubVtblList,
    (const PCInterfaceName * ) & _oledb_InterfaceNamesList,
    (const IID ** ) & _oledb_BaseIIDList,
    & _oledb_IID_Lookup, 
    51,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\oledb\fre\oledbnew_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for oledbnew.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "oledbnew.h"

#define TYPE_FORMAT_STRING_SIZE   3                                 
#define PROC_FORMAT_STRING_SIZE   1                                 
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IRowInfo_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IRowInfo_ProxyInfo;



#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */

			0x0
        }
    };


/* Standard interface: __MIDL_itf_oledbnew_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IRowInfo, ver. 0.0,
   GUID={0x0c733ac1,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IRowInfo_FormatStringOffsetTable[] =
    {
    (unsigned short) -1
    };

static const MIDL_STUBLESS_PROXY_INFO IRowInfo_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IRowInfo_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IRowInfo_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IRowInfo_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IRowInfoProxyVtbl = 
{
    &IRowInfo_ProxyInfo,
    &IID_IRowInfo,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IRowInfo::GetParentRow */
};

const CInterfaceStubVtbl _IRowInfoStubVtbl =
{
    &IID_IRowInfo,
    &IRowInfo_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_oledbnew_0349, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x6000159, /* MIDL Version 6.0.345 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _oledbnew_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IRowInfoProxyVtbl,
    0
};

const CInterfaceStubVtbl * _oledbnew_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IRowInfoStubVtbl,
    0
};

PCInterfaceName const _oledbnew_InterfaceNamesList[] = 
{
    "IRowInfo",
    0
};


#define _oledbnew_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _oledbnew, pIID, n)

int __stdcall _oledbnew_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_oledbnew_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo oledbnew_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _oledbnew_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _oledbnew_StubVtblList,
    (const PCInterfaceName * ) & _oledbnew_InterfaceNamesList,
    0, // no delegation
    & _oledbnew_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for oledbnew.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "oledbnew.h"

#define TYPE_FORMAT_STRING_SIZE   3                                 
#define PROC_FORMAT_STRING_SIZE   1                                 
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IRowInfo_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IRowInfo_ProxyInfo;



#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */

			0x0
        }
    };


/* Standard interface: __MIDL_itf_oledbnew_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IRowInfo, ver. 0.0,
   GUID={0x0c733ac1,0x2a1c,0x11ce,{0xad,0xe5,0x00,0xaa,0x00,0x44,0x77,0x3d}} */

#pragma code_seg(".orpc")
static const unsigned short IRowInfo_FormatStringOffsetTable[] =
    {
    (unsigned short) -1
    };

static const MIDL_STUBLESS_PROXY_INFO IRowInfo_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &IRowInfo_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO IRowInfo_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &IRowInfo_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(4) _IRowInfoProxyVtbl = 
{
    &IRowInfo_ProxyInfo,
    &IID_IRowInfo,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *) (INT_PTR) -1 /* IRowInfo::GetParentRow */
};

const CInterfaceStubVtbl _IRowInfoStubVtbl =
{
    &IID_IRowInfo,
    &IRowInfo_ServerInfo,
    4,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_oledbnew_0349, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000159, /* MIDL Version 6.0.345 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _oledbnew_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IRowInfoProxyVtbl,
    0
};

const CInterfaceStubVtbl * _oledbnew_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IRowInfoStubVtbl,
    0
};

PCInterfaceName const _oledbnew_InterfaceNamesList[] = 
{
    "IRowInfo",
    0
};


#define _oledbnew_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _oledbnew, pIID, n)

int __stdcall _oledbnew_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_oledbnew_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo oledbnew_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _oledbnew_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _oledbnew_StubVtblList,
    (const PCInterfaceName * ) & _oledbnew_InterfaceNamesList,
    0, // no delegation
    & _oledbnew_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\olepro32\olepro32.c ===
#include <windows.h>
#include <ole2.h>

STDAPI DllRegisterServer(void) {return E_NOTIMPL; }

STDAPI DllUnregisterServer(void) {return E_NOTIMPL; }

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR* ppv) { return E_NOTIMPL; }

STDAPI DllCanUnloadNow(void) { return E_NOTIMPL; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\osptk\msdaosp_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for msdaosp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_MSDAOSPT,0x0ae9a4e0,0x18d4,0x11d1,0xb3,0xb3,0x00,0xaa,0x00,0xc1,0xa9,0x24);


MIDL_DEFINE_GUID(IID, DIID_DataSourceObject,0x0ae9a4e4,0x18d4,0x11d1,0xb3,0xb3,0x00,0xaa,0x00,0xc1,0xa9,0x24);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for msdaosp.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_MSDAOSPT,0x0ae9a4e0,0x18d4,0x11d1,0xb3,0xb3,0x00,0xaa,0x00,0xc1,0xa9,0x24);


MIDL_DEFINE_GUID(IID, DIID_DataSourceObject,0x0ae9a4e4,0x18d4,0x11d1,0xb3,0xb3,0x00,0xaa,0x00,0xc1,0xa9,0x24);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\osptk\simpdata_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for simpdata.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_MSDAOSP,0xE0E270C2,0xC0BE,0x11d0,0x8F,0xE4,0x00,0xA0,0xC9,0x0A,0x63,0x41);


MIDL_DEFINE_GUID(IID, IID_OLEDBSimpleProviderListener,0xE0E270C1,0xC0BE,0x11d0,0x8F,0xE4,0x00,0xA0,0xC9,0x0A,0x63,0x41);


MIDL_DEFINE_GUID(IID, IID_OLEDBSimpleProvider,0xE0E270C0,0xC0BE,0x11d0,0x8F,0xE4,0x00,0xA0,0xC9,0x0A,0x63,0x41);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for simpdata.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_MSDAOSP,0xE0E270C2,0xC0BE,0x11d0,0x8F,0xE4,0x00,0xA0,0xC9,0x0A,0x63,0x41);


MIDL_DEFINE_GUID(IID, IID_OLEDBSimpleProviderListener,0xE0E270C1,0xC0BE,0x11d0,0x8F,0xE4,0x00,0xA0,0xC9,0x0A,0x63,0x41);


MIDL_DEFINE_GUID(IID, IID_OLEDBSimpleProvider,0xE0E270C0,0xC0BE,0x11d0,0x8F,0xE4,0x00,0xA0,0xC9,0x0A,0x63,0x41);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\osptk\msdatsrc_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for msdatsrc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_MSDATASRC,0x7c0ffab0,0xcd84,0x11d0,0x94,0x9a,0x00,0xa0,0xc9,0x11,0x10,0xed);


MIDL_DEFINE_GUID(IID, IID_DataSourceListener,0x7c0ffab2,0xcd84,0x11d0,0x94,0x9a,0x00,0xa0,0xc9,0x11,0x10,0xed);


MIDL_DEFINE_GUID(IID, IID_DataSource,0x7c0ffab3,0xcd84,0x11d0,0x94,0x9a,0x00,0xa0,0xc9,0x11,0x10,0xed);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for msdatsrc.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_MSDATASRC,0x7c0ffab0,0xcd84,0x11d0,0x94,0x9a,0x00,0xa0,0xc9,0x11,0x10,0xed);


MIDL_DEFINE_GUID(IID, IID_DataSourceListener,0x7c0ffab2,0xcd84,0x11d0,0x94,0x9a,0x00,0xa0,0xc9,0x11,0x10,0xed);


MIDL_DEFINE_GUID(IID, IID_DataSource,0x7c0ffab3,0xcd84,0x11d0,0x94,0x9a,0x00,0xa0,0xc9,0x11,0x10,0xed);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\svcguid\byot_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for byot.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ICreateWithTransactionEx,0x455ACF57,0x5345,0x11d2,0x99,0xCF,0x00,0xC0,0x4F,0x79,0x7B,0xC9);


MIDL_DEFINE_GUID(IID, IID_ICreateWithTipTransactionEx,0x455ACF59,0x5345,0x11d2,0x99,0xCF,0x00,0xC0,0x4F,0x79,0x7B,0xC9);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for byot.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ICreateWithTransactionEx,0x455ACF57,0x5345,0x11d2,0x99,0xCF,0x00,0xC0,0x4F,0x79,0x7B,0xC9);


MIDL_DEFINE_GUID(IID, IID_ICreateWithTipTransactionEx,0x455ACF59,0x5345,0x11d2,0x99,0xCF,0x00,0xC0,0x4F,0x79,0x7B,0xC9);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\oledb\fre\transact_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for transact.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "transact.h"

#define TYPE_FORMAT_STRING_SIZE   125                               
#define PROC_FORMAT_STRING_SIZE   393                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ITransaction_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ITransaction_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ITransactionDispenser_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ITransactionDispenser_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ITransactionOptions_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ITransactionOptions_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ITransactionOutcomeEvents_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ITransactionOutcomeEvents_ProxyInfo;



#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure Commit */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 10 */	NdrFcShort( 0x18 ),	/* 24 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x4,		/* Oi2 Flags:  has return, */
			0x4,		/* 4 */

	/* Parameter fRetaining */

/* 16 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 18 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 20 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter grfTC */

/* 22 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 24 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 26 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter grfRM */

/* 28 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 30 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 32 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 34 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 36 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 38 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Abort */

/* 40 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 42 */	NdrFcLong( 0x0 ),	/* 0 */
/* 46 */	NdrFcShort( 0x4 ),	/* 4 */
/* 48 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 50 */	NdrFcShort( 0x54 ),	/* 84 */
/* 52 */	NdrFcShort( 0x8 ),	/* 8 */
/* 54 */	0x4,		/* Oi2 Flags:  has return, */
			0x4,		/* 4 */

	/* Parameter pboidReason */

/* 56 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 58 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 60 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter fRetaining */

/* 62 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 64 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 66 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter fAsync */

/* 68 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 70 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 72 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 74 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 76 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 78 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetTransactionInfo */

/* 80 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 82 */	NdrFcLong( 0x0 ),	/* 0 */
/* 86 */	NdrFcShort( 0x5 ),	/* 5 */
/* 88 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 90 */	NdrFcShort( 0x0 ),	/* 0 */
/* 92 */	NdrFcShort( 0x74 ),	/* 116 */
/* 94 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pinfo */

/* 96 */	NdrFcShort( 0xa112 ),	/* Flags:  must free, out, simple ref, srv alloc size=40 */
/* 98 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 100 */	NdrFcShort( 0x1a ),	/* Type Offset=26 */

	/* Return value */

/* 102 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 104 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 106 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetOptionsObject */

/* 108 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 110 */	NdrFcLong( 0x0 ),	/* 0 */
/* 114 */	NdrFcShort( 0x3 ),	/* 3 */
/* 116 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 118 */	NdrFcShort( 0x0 ),	/* 0 */
/* 120 */	NdrFcShort( 0x8 ),	/* 8 */
/* 122 */	0x5,		/* Oi2 Flags:  srv must size, has return, */
			0x2,		/* 2 */

	/* Parameter ppOptions */

/* 124 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 126 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 128 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Return value */

/* 130 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 132 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 134 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure BeginTransaction */

/* 136 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 138 */	NdrFcLong( 0x0 ),	/* 0 */
/* 142 */	NdrFcShort( 0x4 ),	/* 4 */
/* 144 */	NdrFcShort( 0x1c ),	/* x86 Stack size/offset = 28 */
/* 146 */	NdrFcShort( 0x10 ),	/* 16 */
/* 148 */	NdrFcShort( 0x8 ),	/* 8 */
/* 150 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x6,		/* 6 */

	/* Parameter punkOuter */

/* 152 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 154 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 156 */	NdrFcShort( 0x40 ),	/* Type Offset=64 */

	/* Parameter isoLevel */

/* 158 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 160 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 162 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter isoFlags */

/* 164 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 166 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 168 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pOptions */

/* 170 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 172 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 174 */	NdrFcShort( 0x2e ),	/* Type Offset=46 */

	/* Parameter ppTransaction */

/* 176 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 178 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 180 */	NdrFcShort( 0x52 ),	/* Type Offset=82 */

	/* Return value */

/* 182 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 184 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 186 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetOptions */

/* 188 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 190 */	NdrFcLong( 0x0 ),	/* 0 */
/* 194 */	NdrFcShort( 0x3 ),	/* 3 */
/* 196 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 198 */	NdrFcShort( 0x60 ),	/* 96 */
/* 200 */	NdrFcShort( 0x8 ),	/* 8 */
/* 202 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pOptions */

/* 204 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 206 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 208 */	NdrFcShort( 0x72 ),	/* Type Offset=114 */

	/* Return value */

/* 210 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 212 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 214 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetOptions */

/* 216 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 218 */	NdrFcLong( 0x0 ),	/* 0 */
/* 222 */	NdrFcShort( 0x4 ),	/* 4 */
/* 224 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 226 */	NdrFcShort( 0x60 ),	/* 96 */
/* 228 */	NdrFcShort( 0x68 ),	/* 104 */
/* 230 */	0x4,		/* Oi2 Flags:  has return, */
			0x2,		/* 2 */

	/* Parameter pOptions */

/* 232 */	NdrFcShort( 0x11a ),	/* Flags:  must free, in, out, simple ref, */
/* 234 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 236 */	NdrFcShort( 0x72 ),	/* Type Offset=114 */

	/* Return value */

/* 238 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 240 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 242 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Committed */

/* 244 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 246 */	NdrFcLong( 0x0 ),	/* 0 */
/* 250 */	NdrFcShort( 0x3 ),	/* 3 */
/* 252 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 254 */	NdrFcShort( 0x54 ),	/* 84 */
/* 256 */	NdrFcShort( 0x8 ),	/* 8 */
/* 258 */	0x4,		/* Oi2 Flags:  has return, */
			0x4,		/* 4 */

	/* Parameter fRetaining */

/* 260 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 262 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 264 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pNewUOW */

/* 266 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 268 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 270 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter hr */

/* 272 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 274 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 276 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 278 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 280 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 282 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Aborted */

/* 284 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 286 */	NdrFcLong( 0x0 ),	/* 0 */
/* 290 */	NdrFcShort( 0x4 ),	/* 4 */
/* 292 */	NdrFcShort( 0x18 ),	/* x86 Stack size/offset = 24 */
/* 294 */	NdrFcShort( 0x98 ),	/* 152 */
/* 296 */	NdrFcShort( 0x8 ),	/* 8 */
/* 298 */	0x4,		/* Oi2 Flags:  has return, */
			0x5,		/* 5 */

	/* Parameter pboidReason */

/* 300 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 302 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 304 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter fRetaining */

/* 306 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 308 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 310 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pNewUOW */

/* 312 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 314 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 316 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter hr */

/* 318 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 320 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 322 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 324 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 326 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 328 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure HeuristicDecision */

/* 330 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 332 */	NdrFcLong( 0x0 ),	/* 0 */
/* 336 */	NdrFcShort( 0x5 ),	/* 5 */
/* 338 */	NdrFcShort( 0x14 ),	/* x86 Stack size/offset = 20 */
/* 340 */	NdrFcShort( 0x54 ),	/* 84 */
/* 342 */	NdrFcShort( 0x8 ),	/* 8 */
/* 344 */	0x4,		/* Oi2 Flags:  has return, */
			0x4,		/* 4 */

	/* Parameter dwDecision */

/* 346 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 348 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 350 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pboidReason */

/* 352 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 354 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 356 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter hr */

/* 358 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 360 */	NdrFcShort( 0xc ),	/* x86 Stack size/offset = 12 */
/* 362 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 364 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 366 */	NdrFcShort( 0x10 ),	/* x86 Stack size/offset = 16 */
/* 368 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Indoubt */

/* 370 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 372 */	NdrFcLong( 0x0 ),	/* 0 */
/* 376 */	NdrFcShort( 0x6 ),	/* 6 */
/* 378 */	NdrFcShort( 0x8 ),	/* x86 Stack size/offset = 8 */
/* 380 */	NdrFcShort( 0x0 ),	/* 0 */
/* 382 */	NdrFcShort( 0x8 ),	/* 8 */
/* 384 */	0x4,		/* Oi2 Flags:  has return, */
			0x1,		/* 1 */

	/* Return value */

/* 386 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 388 */	NdrFcShort( 0x4 ),	/* x86 Stack size/offset = 4 */
/* 390 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x0,	/* FC_UP */
/*  4 */	NdrFcShort( 0x8 ),	/* Offset= 8 (12) */
/*  6 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/*  8 */	NdrFcShort( 0x10 ),	/* 16 */
/* 10 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 12 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 14 */	NdrFcShort( 0x10 ),	/* 16 */
/* 16 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 18 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (6) */
/* 20 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 22 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 24 */	NdrFcShort( 0x2 ),	/* Offset= 2 (26) */
/* 26 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 28 */	NdrFcShort( 0x28 ),	/* 40 */
/* 30 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 32 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (12) */
/* 34 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 36 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 38 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 40 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 42 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 44 */	NdrFcShort( 0x2 ),	/* Offset= 2 (46) */
/* 46 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 48 */	NdrFcLong( 0x3a6ad9e0 ),	/* 980081120 */
/* 52 */	NdrFcShort( 0x23b9 ),	/* 9145 */
/* 54 */	NdrFcShort( 0x11cf ),	/* 4559 */
/* 56 */	0xad,		/* 173 */
			0x60,		/* 96 */
/* 58 */	0x0,		/* 0 */
			0xaa,		/* 170 */
/* 60 */	0x0,		/* 0 */
			0xa7,		/* 167 */
/* 62 */	0x4c,		/* 76 */
			0xcd,		/* 205 */
/* 64 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 66 */	NdrFcLong( 0x0 ),	/* 0 */
/* 70 */	NdrFcShort( 0x0 ),	/* 0 */
/* 72 */	NdrFcShort( 0x0 ),	/* 0 */
/* 74 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 76 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 78 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 80 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 82 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 84 */	NdrFcShort( 0x2 ),	/* Offset= 2 (86) */
/* 86 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 88 */	NdrFcLong( 0xfb15084 ),	/* 263278724 */
/* 92 */	NdrFcShort( 0xaf41 ),	/* -20671 */
/* 94 */	NdrFcShort( 0x11ce ),	/* 4558 */
/* 96 */	0xbd,		/* 189 */
			0x2b,		/* 43 */
/* 98 */	0x20,		/* 32 */
			0x4c,		/* 76 */
/* 100 */	0x4f,		/* 79 */
			0x4f,		/* 79 */
/* 102 */	0x50,		/* 80 */
			0x20,		/* 32 */
/* 104 */	
			0x11, 0x0,	/* FC_RP */
/* 106 */	NdrFcShort( 0x8 ),	/* Offset= 8 (114) */
/* 108 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 110 */	NdrFcShort( 0x28 ),	/* 40 */
/* 112 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 114 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 116 */	NdrFcShort( 0x2c ),	/* 44 */
/* 118 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 120 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff3 ),	/* Offset= -13 (108) */
			0x5b,		/* FC_END */

			0x0
        }
    };


/* Standard interface: __MIDL_itf_transact_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Standard interface: BasicTransactionTypes, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: ITransaction, ver. 0.0,
   GUID={0x0fb15084,0xaf41,0x11ce,{0xbd,0x2b,0x20,0x4c,0x4f,0x4f,0x50,0x20}} */

#pragma code_seg(".orpc")
static const unsigned short ITransaction_FormatStringOffsetTable[] =
    {
    0,
    40,
    80
    };

static const MIDL_STUBLESS_PROXY_INFO ITransaction_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ITransaction_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ITransaction_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ITransaction_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(6) _ITransactionProxyVtbl = 
{
    &ITransaction_ProxyInfo,
    &IID_ITransaction,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ITransaction::Commit */ ,
    (void *) (INT_PTR) -1 /* ITransaction::Abort */ ,
    (void *) (INT_PTR) -1 /* ITransaction::GetTransactionInfo */
};

const CInterfaceStubVtbl _ITransactionStubVtbl =
{
    &IID_ITransaction,
    &ITransaction_ServerInfo,
    6,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ITransactionDispenser, ver. 0.0,
   GUID={0x3A6AD9E1,0x23B9,0x11cf,{0xAD,0x60,0x00,0xAA,0x00,0xA7,0x4C,0xCD}} */

#pragma code_seg(".orpc")
static const unsigned short ITransactionDispenser_FormatStringOffsetTable[] =
    {
    108,
    136
    };

static const MIDL_STUBLESS_PROXY_INFO ITransactionDispenser_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ITransactionDispenser_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ITransactionDispenser_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ITransactionDispenser_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _ITransactionDispenserProxyVtbl = 
{
    &ITransactionDispenser_ProxyInfo,
    &IID_ITransactionDispenser,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ITransactionDispenser::GetOptionsObject */ ,
    (void *) (INT_PTR) -1 /* ITransactionDispenser::BeginTransaction */
};

const CInterfaceStubVtbl _ITransactionDispenserStubVtbl =
{
    &IID_ITransactionDispenser,
    &ITransactionDispenser_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ITransactionOptions, ver. 0.0,
   GUID={0x3A6AD9E0,0x23B9,0x11cf,{0xAD,0x60,0x00,0xAA,0x00,0xA7,0x4C,0xCD}} */

#pragma code_seg(".orpc")
static const unsigned short ITransactionOptions_FormatStringOffsetTable[] =
    {
    188,
    216
    };

static const MIDL_STUBLESS_PROXY_INFO ITransactionOptions_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ITransactionOptions_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ITransactionOptions_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ITransactionOptions_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _ITransactionOptionsProxyVtbl = 
{
    &ITransactionOptions_ProxyInfo,
    &IID_ITransactionOptions,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ITransactionOptions::SetOptions */ ,
    (void *) (INT_PTR) -1 /* ITransactionOptions::GetOptions */
};

const CInterfaceStubVtbl _ITransactionOptionsStubVtbl =
{
    &IID_ITransactionOptions,
    &ITransactionOptions_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ITransactionOutcomeEvents, ver. 0.0,
   GUID={0x3A6AD9E2,0x23B9,0x11cf,{0xAD,0x60,0x00,0xAA,0x00,0xA7,0x4C,0xCD}} */

#pragma code_seg(".orpc")
static const unsigned short ITransactionOutcomeEvents_FormatStringOffsetTable[] =
    {
    244,
    284,
    330,
    370
    };

static const MIDL_STUBLESS_PROXY_INFO ITransactionOutcomeEvents_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ITransactionOutcomeEvents_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ITransactionOutcomeEvents_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ITransactionOutcomeEvents_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(7) _ITransactionOutcomeEventsProxyVtbl = 
{
    &ITransactionOutcomeEvents_ProxyInfo,
    &IID_ITransactionOutcomeEvents,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ITransactionOutcomeEvents::Committed */ ,
    (void *) (INT_PTR) -1 /* ITransactionOutcomeEvents::Aborted */ ,
    (void *) (INT_PTR) -1 /* ITransactionOutcomeEvents::HeuristicDecision */ ,
    (void *) (INT_PTR) -1 /* ITransactionOutcomeEvents::Indoubt */
};

const CInterfaceStubVtbl _ITransactionOutcomeEventsStubVtbl =
{
    &IID_ITransactionOutcomeEvents,
    &ITransactionOutcomeEvents_ServerInfo,
    7,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_transact_0013, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x6000159, /* MIDL Version 6.0.345 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _transact_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_ITransactionProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ITransactionOptionsProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ITransactionDispenserProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ITransactionOutcomeEventsProxyVtbl,
    0
};

const CInterfaceStubVtbl * _transact_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_ITransactionStubVtbl,
    ( CInterfaceStubVtbl *) &_ITransactionOptionsStubVtbl,
    ( CInterfaceStubVtbl *) &_ITransactionDispenserStubVtbl,
    ( CInterfaceStubVtbl *) &_ITransactionOutcomeEventsStubVtbl,
    0
};

PCInterfaceName const _transact_InterfaceNamesList[] = 
{
    "ITransaction",
    "ITransactionOptions",
    "ITransactionDispenser",
    "ITransactionOutcomeEvents",
    0
};


#define _transact_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _transact, pIID, n)

int __stdcall _transact_IID_Lookup( const IID * pIID, int * pIndex )
{
    IID_BS_LOOKUP_SETUP

    IID_BS_LOOKUP_INITIAL_TEST( _transact, 4, 2 )
    IID_BS_LOOKUP_NEXT_TEST( _transact, 1 )
    IID_BS_LOOKUP_RETURN_RESULT( _transact, 4, *pIndex )
    
}

const ExtendedProxyFileInfo transact_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _transact_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _transact_StubVtblList,
    (const PCInterfaceName * ) & _transact_InterfaceNamesList,
    0, // no delegation
    & _transact_IID_Lookup, 
    4,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for transact.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)
#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "transact.h"

#define TYPE_FORMAT_STRING_SIZE   125                               
#define PROC_FORMAT_STRING_SIZE   503                               
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ITransaction_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ITransaction_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ITransactionDispenser_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ITransactionDispenser_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ITransactionOptions_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ITransactionOptions_ProxyInfo;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ITransactionOutcomeEvents_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ITransactionOutcomeEvents_ProxyInfo;



#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure Commit */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x3 ),	/* 3 */
/*  8 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 10 */	NdrFcShort( 0x18 ),	/* 24 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x4,		/* 4 */
/* 16 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
/* 20 */	NdrFcShort( 0x0 ),	/* 0 */
/* 22 */	NdrFcShort( 0x0 ),	/* 0 */
/* 24 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter fRetaining */

/* 26 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 28 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 30 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter grfTC */

/* 32 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 34 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 36 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter grfRM */

/* 38 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 40 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 42 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 44 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 46 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 48 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Abort */

/* 50 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 52 */	NdrFcLong( 0x0 ),	/* 0 */
/* 56 */	NdrFcShort( 0x4 ),	/* 4 */
/* 58 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 60 */	NdrFcShort( 0x54 ),	/* 84 */
/* 62 */	NdrFcShort( 0x8 ),	/* 8 */
/* 64 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x4,		/* 4 */
/* 66 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 68 */	NdrFcShort( 0x0 ),	/* 0 */
/* 70 */	NdrFcShort( 0x0 ),	/* 0 */
/* 72 */	NdrFcShort( 0x0 ),	/* 0 */
/* 74 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pboidReason */

/* 76 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 78 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 80 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter fRetaining */

/* 82 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 84 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 86 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter fAsync */

/* 88 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 90 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 92 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 94 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 96 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 98 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetTransactionInfo */

/* 100 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 102 */	NdrFcLong( 0x0 ),	/* 0 */
/* 106 */	NdrFcShort( 0x5 ),	/* 5 */
/* 108 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 110 */	NdrFcShort( 0x0 ),	/* 0 */
/* 112 */	NdrFcShort( 0x74 ),	/* 116 */
/* 114 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 116 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 118 */	NdrFcShort( 0x0 ),	/* 0 */
/* 120 */	NdrFcShort( 0x0 ),	/* 0 */
/* 122 */	NdrFcShort( 0x0 ),	/* 0 */
/* 124 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pinfo */

/* 126 */	NdrFcShort( 0xa112 ),	/* Flags:  must free, out, simple ref, srv alloc size=40 */
/* 128 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 130 */	NdrFcShort( 0x1a ),	/* Type Offset=26 */

	/* Return value */

/* 132 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 134 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 136 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetOptionsObject */

/* 138 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 140 */	NdrFcLong( 0x0 ),	/* 0 */
/* 144 */	NdrFcShort( 0x3 ),	/* 3 */
/* 146 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 148 */	NdrFcShort( 0x0 ),	/* 0 */
/* 150 */	NdrFcShort( 0x8 ),	/* 8 */
/* 152 */	0x45,		/* Oi2 Flags:  srv must size, has return, has ext, */
			0x2,		/* 2 */
/* 154 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 156 */	NdrFcShort( 0x0 ),	/* 0 */
/* 158 */	NdrFcShort( 0x0 ),	/* 0 */
/* 160 */	NdrFcShort( 0x0 ),	/* 0 */
/* 162 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter ppOptions */

/* 164 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 166 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 168 */	NdrFcShort( 0x2a ),	/* Type Offset=42 */

	/* Return value */

/* 170 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 172 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 174 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure BeginTransaction */

/* 176 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 178 */	NdrFcLong( 0x0 ),	/* 0 */
/* 182 */	NdrFcShort( 0x4 ),	/* 4 */
/* 184 */	NdrFcShort( 0x38 ),	/* ia64 Stack size/offset = 56 */
/* 186 */	NdrFcShort( 0x10 ),	/* 16 */
/* 188 */	NdrFcShort( 0x8 ),	/* 8 */
/* 190 */	0x47,		/* Oi2 Flags:  srv must size, clt must size, has return, has ext, */
			0x6,		/* 6 */
/* 192 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 194 */	NdrFcShort( 0x0 ),	/* 0 */
/* 196 */	NdrFcShort( 0x0 ),	/* 0 */
/* 198 */	NdrFcShort( 0x0 ),	/* 0 */
/* 200 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter punkOuter */

/* 202 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 204 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 206 */	NdrFcShort( 0x40 ),	/* Type Offset=64 */

	/* Parameter isoLevel */

/* 208 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 210 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 212 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter isoFlags */

/* 214 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 216 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 218 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pOptions */

/* 220 */	NdrFcShort( 0xb ),	/* Flags:  must size, must free, in, */
/* 222 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 224 */	NdrFcShort( 0x2e ),	/* Type Offset=46 */

	/* Parameter ppTransaction */

/* 226 */	NdrFcShort( 0x13 ),	/* Flags:  must size, must free, out, */
/* 228 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 230 */	NdrFcShort( 0x52 ),	/* Type Offset=82 */

	/* Return value */

/* 232 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 234 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 236 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure SetOptions */

/* 238 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 240 */	NdrFcLong( 0x0 ),	/* 0 */
/* 244 */	NdrFcShort( 0x3 ),	/* 3 */
/* 246 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 248 */	NdrFcShort( 0x60 ),	/* 96 */
/* 250 */	NdrFcShort( 0x8 ),	/* 8 */
/* 252 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 254 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 256 */	NdrFcShort( 0x0 ),	/* 0 */
/* 258 */	NdrFcShort( 0x0 ),	/* 0 */
/* 260 */	NdrFcShort( 0x0 ),	/* 0 */
/* 262 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pOptions */

/* 264 */	NdrFcShort( 0x10a ),	/* Flags:  must free, in, simple ref, */
/* 266 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 268 */	NdrFcShort( 0x72 ),	/* Type Offset=114 */

	/* Return value */

/* 270 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 272 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 274 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetOptions */

/* 276 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 278 */	NdrFcLong( 0x0 ),	/* 0 */
/* 282 */	NdrFcShort( 0x4 ),	/* 4 */
/* 284 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 286 */	NdrFcShort( 0x60 ),	/* 96 */
/* 288 */	NdrFcShort( 0x68 ),	/* 104 */
/* 290 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x2,		/* 2 */
/* 292 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 294 */	NdrFcShort( 0x0 ),	/* 0 */
/* 296 */	NdrFcShort( 0x0 ),	/* 0 */
/* 298 */	NdrFcShort( 0x0 ),	/* 0 */
/* 300 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pOptions */

/* 302 */	NdrFcShort( 0x11a ),	/* Flags:  must free, in, out, simple ref, */
/* 304 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 306 */	NdrFcShort( 0x72 ),	/* Type Offset=114 */

	/* Return value */

/* 308 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 310 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 312 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Committed */

/* 314 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 316 */	NdrFcLong( 0x0 ),	/* 0 */
/* 320 */	NdrFcShort( 0x3 ),	/* 3 */
/* 322 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 324 */	NdrFcShort( 0x54 ),	/* 84 */
/* 326 */	NdrFcShort( 0x8 ),	/* 8 */
/* 328 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x4,		/* 4 */
/* 330 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 332 */	NdrFcShort( 0x0 ),	/* 0 */
/* 334 */	NdrFcShort( 0x0 ),	/* 0 */
/* 336 */	NdrFcShort( 0x0 ),	/* 0 */
/* 338 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter fRetaining */

/* 340 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 342 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 344 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pNewUOW */

/* 346 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 348 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 350 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter hr */

/* 352 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 354 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 356 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 358 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 360 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 362 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Aborted */

/* 364 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 366 */	NdrFcLong( 0x0 ),	/* 0 */
/* 370 */	NdrFcShort( 0x4 ),	/* 4 */
/* 372 */	NdrFcShort( 0x30 ),	/* ia64 Stack size/offset = 48 */
/* 374 */	NdrFcShort( 0x98 ),	/* 152 */
/* 376 */	NdrFcShort( 0x8 ),	/* 8 */
/* 378 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x5,		/* 5 */
/* 380 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 382 */	NdrFcShort( 0x0 ),	/* 0 */
/* 384 */	NdrFcShort( 0x0 ),	/* 0 */
/* 386 */	NdrFcShort( 0x0 ),	/* 0 */
/* 388 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter pboidReason */

/* 390 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 392 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 394 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter fRetaining */

/* 396 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 398 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 400 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pNewUOW */

/* 402 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 404 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 406 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter hr */

/* 408 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 410 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 412 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 414 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 416 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 418 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure HeuristicDecision */

/* 420 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 422 */	NdrFcLong( 0x0 ),	/* 0 */
/* 426 */	NdrFcShort( 0x5 ),	/* 5 */
/* 428 */	NdrFcShort( 0x28 ),	/* ia64 Stack size/offset = 40 */
/* 430 */	NdrFcShort( 0x54 ),	/* 84 */
/* 432 */	NdrFcShort( 0x8 ),	/* 8 */
/* 434 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x4,		/* 4 */
/* 436 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 438 */	NdrFcShort( 0x0 ),	/* 0 */
/* 440 */	NdrFcShort( 0x0 ),	/* 0 */
/* 442 */	NdrFcShort( 0x0 ),	/* 0 */
/* 444 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Parameter dwDecision */

/* 446 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 448 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 450 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Parameter pboidReason */

/* 452 */	NdrFcShort( 0xa ),	/* Flags:  must free, in, */
/* 454 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 456 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */

	/* Parameter hr */

/* 458 */	NdrFcShort( 0x48 ),	/* Flags:  in, base type, */
/* 460 */	NdrFcShort( 0x18 ),	/* ia64 Stack size/offset = 24 */
/* 462 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Return value */

/* 464 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 466 */	NdrFcShort( 0x20 ),	/* ia64 Stack size/offset = 32 */
/* 468 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Indoubt */

/* 470 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 472 */	NdrFcLong( 0x0 ),	/* 0 */
/* 476 */	NdrFcShort( 0x6 ),	/* 6 */
/* 478 */	NdrFcShort( 0x10 ),	/* ia64 Stack size/offset = 16 */
/* 480 */	NdrFcShort( 0x0 ),	/* 0 */
/* 482 */	NdrFcShort( 0x8 ),	/* 8 */
/* 484 */	0x44,		/* Oi2 Flags:  has return, has ext, */
			0x1,		/* 1 */
/* 486 */	0xa,		/* 10 */
			0x1,		/* Ext Flags:  new corr desc, */
/* 488 */	NdrFcShort( 0x0 ),	/* 0 */
/* 490 */	NdrFcShort( 0x0 ),	/* 0 */
/* 492 */	NdrFcShort( 0x0 ),	/* 0 */
/* 494 */	NdrFcShort( 0x0 ),	/* 0 */

	/* Return value */

/* 496 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
/* 498 */	NdrFcShort( 0x8 ),	/* ia64 Stack size/offset = 8 */
/* 500 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x12, 0x0,	/* FC_UP */
/*  4 */	NdrFcShort( 0x8 ),	/* Offset= 8 (12) */
/*  6 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/*  8 */	NdrFcShort( 0x10 ),	/* 16 */
/* 10 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 12 */	
			0x15,		/* FC_STRUCT */
			0x0,		/* 0 */
/* 14 */	NdrFcShort( 0x10 ),	/* 16 */
/* 16 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 18 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (6) */
/* 20 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 22 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 24 */	NdrFcShort( 0x2 ),	/* Offset= 2 (26) */
/* 26 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 28 */	NdrFcShort( 0x28 ),	/* 40 */
/* 30 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 32 */	NdrFcShort( 0xffffffec ),	/* Offset= -20 (12) */
/* 34 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 36 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 38 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 40 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 42 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 44 */	NdrFcShort( 0x2 ),	/* Offset= 2 (46) */
/* 46 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 48 */	NdrFcLong( 0x3a6ad9e0 ),	/* 980081120 */
/* 52 */	NdrFcShort( 0x23b9 ),	/* 9145 */
/* 54 */	NdrFcShort( 0x11cf ),	/* 4559 */
/* 56 */	0xad,		/* 173 */
			0x60,		/* 96 */
/* 58 */	0x0,		/* 0 */
			0xaa,		/* 170 */
/* 60 */	0x0,		/* 0 */
			0xa7,		/* 167 */
/* 62 */	0x4c,		/* 76 */
			0xcd,		/* 205 */
/* 64 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 66 */	NdrFcLong( 0x0 ),	/* 0 */
/* 70 */	NdrFcShort( 0x0 ),	/* 0 */
/* 72 */	NdrFcShort( 0x0 ),	/* 0 */
/* 74 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 76 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 78 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 80 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 82 */	
			0x11, 0x10,	/* FC_RP [pointer_deref] */
/* 84 */	NdrFcShort( 0x2 ),	/* Offset= 2 (86) */
/* 86 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 88 */	NdrFcLong( 0xfb15084 ),	/* 263278724 */
/* 92 */	NdrFcShort( 0xaf41 ),	/* -20671 */
/* 94 */	NdrFcShort( 0x11ce ),	/* 4558 */
/* 96 */	0xbd,		/* 189 */
			0x2b,		/* 43 */
/* 98 */	0x20,		/* 32 */
			0x4c,		/* 76 */
/* 100 */	0x4f,		/* 79 */
			0x4f,		/* 79 */
/* 102 */	0x50,		/* 80 */
			0x20,		/* 32 */
/* 104 */	
			0x11, 0x0,	/* FC_RP */
/* 106 */	NdrFcShort( 0x8 ),	/* Offset= 8 (114) */
/* 108 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 110 */	NdrFcShort( 0x28 ),	/* 40 */
/* 112 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 114 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 116 */	NdrFcShort( 0x2c ),	/* 44 */
/* 118 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 120 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff3 ),	/* Offset= -13 (108) */
			0x5b,		/* FC_END */

			0x0
        }
    };


/* Standard interface: __MIDL_itf_transact_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Standard interface: BasicTransactionTypes, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: ITransaction, ver. 0.0,
   GUID={0x0fb15084,0xaf41,0x11ce,{0xbd,0x2b,0x20,0x4c,0x4f,0x4f,0x50,0x20}} */

#pragma code_seg(".orpc")
static const unsigned short ITransaction_FormatStringOffsetTable[] =
    {
    0,
    50,
    100
    };

static const MIDL_STUBLESS_PROXY_INFO ITransaction_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ITransaction_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ITransaction_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ITransaction_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(6) _ITransactionProxyVtbl = 
{
    &ITransaction_ProxyInfo,
    &IID_ITransaction,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ITransaction::Commit */ ,
    (void *) (INT_PTR) -1 /* ITransaction::Abort */ ,
    (void *) (INT_PTR) -1 /* ITransaction::GetTransactionInfo */
};

const CInterfaceStubVtbl _ITransactionStubVtbl =
{
    &IID_ITransaction,
    &ITransaction_ServerInfo,
    6,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ITransactionDispenser, ver. 0.0,
   GUID={0x3A6AD9E1,0x23B9,0x11cf,{0xAD,0x60,0x00,0xAA,0x00,0xA7,0x4C,0xCD}} */

#pragma code_seg(".orpc")
static const unsigned short ITransactionDispenser_FormatStringOffsetTable[] =
    {
    138,
    176
    };

static const MIDL_STUBLESS_PROXY_INFO ITransactionDispenser_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ITransactionDispenser_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ITransactionDispenser_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ITransactionDispenser_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _ITransactionDispenserProxyVtbl = 
{
    &ITransactionDispenser_ProxyInfo,
    &IID_ITransactionDispenser,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ITransactionDispenser::GetOptionsObject */ ,
    (void *) (INT_PTR) -1 /* ITransactionDispenser::BeginTransaction */
};

const CInterfaceStubVtbl _ITransactionDispenserStubVtbl =
{
    &IID_ITransactionDispenser,
    &ITransactionDispenser_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ITransactionOptions, ver. 0.0,
   GUID={0x3A6AD9E0,0x23B9,0x11cf,{0xAD,0x60,0x00,0xAA,0x00,0xA7,0x4C,0xCD}} */

#pragma code_seg(".orpc")
static const unsigned short ITransactionOptions_FormatStringOffsetTable[] =
    {
    238,
    276
    };

static const MIDL_STUBLESS_PROXY_INFO ITransactionOptions_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ITransactionOptions_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ITransactionOptions_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ITransactionOptions_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(5) _ITransactionOptionsProxyVtbl = 
{
    &ITransactionOptions_ProxyInfo,
    &IID_ITransactionOptions,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ITransactionOptions::SetOptions */ ,
    (void *) (INT_PTR) -1 /* ITransactionOptions::GetOptions */
};

const CInterfaceStubVtbl _ITransactionOptionsStubVtbl =
{
    &IID_ITransactionOptions,
    &ITransactionOptions_ServerInfo,
    5,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Object interface: ITransactionOutcomeEvents, ver. 0.0,
   GUID={0x3A6AD9E2,0x23B9,0x11cf,{0xAD,0x60,0x00,0xAA,0x00,0xA7,0x4C,0xCD}} */

#pragma code_seg(".orpc")
static const unsigned short ITransactionOutcomeEvents_FormatStringOffsetTable[] =
    {
    314,
    364,
    420,
    470
    };

static const MIDL_STUBLESS_PROXY_INFO ITransactionOutcomeEvents_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ITransactionOutcomeEvents_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ITransactionOutcomeEvents_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ITransactionOutcomeEvents_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(7) _ITransactionOutcomeEventsProxyVtbl = 
{
    &ITransactionOutcomeEvents_ProxyInfo,
    &IID_ITransactionOutcomeEvents,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    (void *) (INT_PTR) -1 /* ITransactionOutcomeEvents::Committed */ ,
    (void *) (INT_PTR) -1 /* ITransactionOutcomeEvents::Aborted */ ,
    (void *) (INT_PTR) -1 /* ITransactionOutcomeEvents::HeuristicDecision */ ,
    (void *) (INT_PTR) -1 /* ITransactionOutcomeEvents::Indoubt */
};

const CInterfaceStubVtbl _ITransactionOutcomeEventsStubVtbl =
{
    &IID_ITransactionOutcomeEvents,
    &ITransactionOutcomeEvents_ServerInfo,
    7,
    0, /* pure interpreted */
    CStdStubBuffer_METHODS
};


/* Standard interface: __MIDL_itf_transact_0013, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x50002, /* Ndr library version */
    0,
    0x6000159, /* MIDL Version 6.0.345 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * _transact_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_ITransactionProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ITransactionOptionsProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ITransactionDispenserProxyVtbl,
    ( CInterfaceProxyVtbl *) &_ITransactionOutcomeEventsProxyVtbl,
    0
};

const CInterfaceStubVtbl * _transact_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_ITransactionStubVtbl,
    ( CInterfaceStubVtbl *) &_ITransactionOptionsStubVtbl,
    ( CInterfaceStubVtbl *) &_ITransactionDispenserStubVtbl,
    ( CInterfaceStubVtbl *) &_ITransactionOutcomeEventsStubVtbl,
    0
};

PCInterfaceName const _transact_InterfaceNamesList[] = 
{
    "ITransaction",
    "ITransactionOptions",
    "ITransactionDispenser",
    "ITransactionOutcomeEvents",
    0
};


#define _transact_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _transact, pIID, n)

int __stdcall _transact_IID_Lookup( const IID * pIID, int * pIndex )
{
    IID_BS_LOOKUP_SETUP

    IID_BS_LOOKUP_INITIAL_TEST( _transact, 4, 2 )
    IID_BS_LOOKUP_NEXT_TEST( _transact, 1 )
    IID_BS_LOOKUP_RETURN_RESULT( _transact, 4, *pIndex )
    
}

const ExtendedProxyFileInfo transact_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _transact_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _transact_StubVtblList,
    (const PCInterfaceName * ) & _transact_InterfaceNamesList,
    0, // no delegation
    & _transact_IID_Lookup, 
    4,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\svcguid\comvbdbg_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for comvbdbg.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IMtsVbHelper,0xFC4886B2,0xA40F,0x11d1,0xAA,0x88,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_IClassFactoryWithCoContext,0x0628a7e8,0x6918,0x11d2,0x9f,0xed,0x00,0xc0,0x4f,0x8e,0xf9,0x34);


MIDL_DEFINE_GUID(IID, IID_IClassVbDebugInfo,0x2aac1488,0x7809,0x11d2,0x9f,0xef,0x00,0xc0,0x4f,0x8e,0xf9,0x34);


MIDL_DEFINE_GUID(IID, LIBID_ComPlusVbDebugLib,0xa7e931d8,0x6918,0x11d2,0x9f,0xed,0x00,0xc0,0x4f,0x8e,0xf9,0x34);


MIDL_DEFINE_GUID(CLSID, CLSID_MtsVbHelper,0xFC4886B3,0xA40F,0x11d1,0xAA,0x88,0x00,0xAA,0x00,0xBA,0x32,0x58);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for comvbdbg.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IMtsVbHelper,0xFC4886B2,0xA40F,0x11d1,0xAA,0x88,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_IClassFactoryWithCoContext,0x0628a7e8,0x6918,0x11d2,0x9f,0xed,0x00,0xc0,0x4f,0x8e,0xf9,0x34);


MIDL_DEFINE_GUID(IID, IID_IClassVbDebugInfo,0x2aac1488,0x7809,0x11d2,0x9f,0xef,0x00,0xc0,0x4f,0x8e,0xf9,0x34);


MIDL_DEFINE_GUID(IID, LIBID_ComPlusVbDebugLib,0xa7e931d8,0x6918,0x11d2,0x9f,0xed,0x00,0xc0,0x4f,0x8e,0xf9,0x34);


MIDL_DEFINE_GUID(CLSID, CLSID_MtsVbHelper,0xFC4886B3,0xA40F,0x11d1,0xAA,0x88,0x00,0xAA,0x00,0xBA,0x32,0x58);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\svcguid\comsvcsevents_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for comsvcsevents.idl:
    Os, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IPackageEventsInternal,0xD64AC5F0,0x58C7,0x11D2,0x9B,0x7C,0x00,0x60,0x08,0xB1,0x43,0x2F);


MIDL_DEFINE_GUID(IID, IID_IPackageEventsInternal2,0xFDC8C384,0xF1C9,0x4436,0xB1,0x2F,0x5A,0x71,0xAA,0xE2,0xF2,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_MTSPackage,0x51372af3,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for comsvcsevents.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IPackageEventsInternal,0xD64AC5F0,0x58C7,0x11D2,0x9B,0x7C,0x00,0x60,0x08,0xB1,0x43,0x2F);


MIDL_DEFINE_GUID(IID, IID_IPackageEventsInternal2,0xFDC8C384,0xF1C9,0x4436,0xB1,0x2F,0x5A,0x71,0xAA,0xE2,0xF2,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_MTSPackage,0x51372af3,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\svcguid\comadmin_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for comadmin.idl:
    Os, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IRunningAppCollection,0xab9d3261,0xd6ea,0x4fbd,0x80,0xf6,0xcf,0x7b,0xad,0x07,0x32,0xf3);


MIDL_DEFINE_GUID(IID, IID_IRunningAppInfo,0x1fd6f178,0xbfb9,0x4629,0x93,0xc7,0x4c,0xa9,0xa2,0x72,0x4e,0xfd);


MIDL_DEFINE_GUID(IID, IID_ICOMAdminCatalog,0xDD662187,0xDFC2,0x11d1,0xA2,0xCF,0x00,0x80,0x5F,0xC7,0x92,0x35);


MIDL_DEFINE_GUID(IID, IID_ICOMAdminCatalog2,0xD81AB10D,0x2EE4,0x48db,0x9C,0x90,0x54,0x11,0x09,0x98,0xB1,0x05);


MIDL_DEFINE_GUID(IID, IID_ICatalogObject,0x6eb22871,0x8a19,0x11d0,0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29);


MIDL_DEFINE_GUID(IID, IID_ICatalogCollection,0x6eb22872,0x8a19,0x11d0,0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29);


MIDL_DEFINE_GUID(IID, LIBID_COMAdmin,0xF618C513,0xDFB8,0x11d1,0xA2,0xCF,0x00,0x80,0x5F,0xC7,0x92,0x35);


MIDL_DEFINE_GUID(CLSID, CLSID_COMAdminCatalog,0xF618C514,0xDFB8,0x11d1,0xA2,0xCF,0x00,0x80,0x5F,0xC7,0x92,0x35);


MIDL_DEFINE_GUID(CLSID, CLSID_COMAdminCatalogObject,0xF618C515,0xDFB8,0x11d1,0xA2,0xCF,0x00,0x80,0x5F,0xC7,0x92,0x35);


MIDL_DEFINE_GUID(CLSID, CLSID_COMAdminCatalogCollection,0xF618C516,0xDFB8,0x11d1,0xA2,0xCF,0x00,0x80,0x5F,0xC7,0x92,0x35);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for comadmin.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IRunningAppCollection,0xab9d3261,0xd6ea,0x4fbd,0x80,0xf6,0xcf,0x7b,0xad,0x07,0x32,0xf3);


MIDL_DEFINE_GUID(IID, IID_IRunningAppInfo,0x1fd6f178,0xbfb9,0x4629,0x93,0xc7,0x4c,0xa9,0xa2,0x72,0x4e,0xfd);


MIDL_DEFINE_GUID(IID, IID_ICOMAdminCatalog,0xDD662187,0xDFC2,0x11d1,0xA2,0xCF,0x00,0x80,0x5F,0xC7,0x92,0x35);


MIDL_DEFINE_GUID(IID, IID_ICOMAdminCatalog2,0xD81AB10D,0x2EE4,0x48db,0x9C,0x90,0x54,0x11,0x09,0x98,0xB1,0x05);


MIDL_DEFINE_GUID(IID, IID_ICatalogObject,0x6eb22871,0x8a19,0x11d0,0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29);


MIDL_DEFINE_GUID(IID, IID_ICatalogCollection,0x6eb22872,0x8a19,0x11d0,0x81,0xb6,0x00,0xa0,0xc9,0x23,0x1c,0x29);


MIDL_DEFINE_GUID(IID, LIBID_COMAdmin,0xF618C513,0xDFB8,0x11d1,0xA2,0xCF,0x00,0x80,0x5F,0xC7,0x92,0x35);


MIDL_DEFINE_GUID(CLSID, CLSID_COMAdminCatalog,0xF618C514,0xDFB8,0x11d1,0xA2,0xCF,0x00,0x80,0x5F,0xC7,0x92,0x35);


MIDL_DEFINE_GUID(CLSID, CLSID_COMAdminCatalogObject,0xF618C515,0xDFB8,0x11d1,0xA2,0xCF,0x00,0x80,0x5F,0xC7,0x92,0x35);


MIDL_DEFINE_GUID(CLSID, CLSID_COMAdminCatalogCollection,0xF618C516,0xDFB8,0x11d1,0xA2,0xCF,0x00,0x80,0x5F,0xC7,0x92,0x35);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\svcguid\casperpriv_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for casperpriv.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IMtsEventsPriv,0x44F876D8,0x8391,0x11d0,0xB1,0x6F,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_IMtsEventsPriv2,0x59415D35,0xA530,0x4c14,0xAF,0x2A,0xC7,0x1F,0x8B,0xFA,0xE2,0xEE);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for casperpriv.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IMtsEventsPriv,0x44F876D8,0x8391,0x11d0,0xB1,0x6F,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_IMtsEventsPriv2,0x59415D35,0xA530,0x4c14,0xAF,0x2A,0xC7,0x1F,0x8B,0xFA,0xE2,0xEE);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\svcguid\comsvcs_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for comsvcs.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_COMSVCSLib,0x2A005C00,0xA5DE,0x11CF,0x9E,0x66,0x00,0xAA,0x00,0xA3,0xF4,0x64);


MIDL_DEFINE_GUID(CLSID, CLSID_TrkInfoCollUnmarshal,0xecabafcd,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_TrkInfoObjUnmarshal,0xecabafce,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_PartitionPropertyUnmarshal,0xecabafcc,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ActivityUnmarshal,0xecabafaa,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_SecurityEnvoy,0xecabafab,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_TransactionUnmarshal,0xecabafac,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_NonRootTransactionEnvoy,0xecabafad,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_sca,0xecabafae,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_CFAct,0xecabafaf,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_obja,0xecabafb0,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_stapa,0xecabafb1,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_vca,0xecabafb2,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_UserContextProperty,0xecabafb3,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_AssociationUnmarshal,0xecabafb4,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ObjPoolAct,0xecabafb6,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_SoapAct,0xecabafd0,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_CtorAct,0xecabafb7,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ObjectConstruct,0xecabafb8,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_AppTracker,0xecabafba,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ClassTracker,0xecabafbb,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_NtaHelper,0xecabafbe,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComLceEventDispatcher,0xecabafbf,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComEventRegistrar,0xecabafcf,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_cfw,0xecabafc0,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ClerksCollection,0xecabafc1,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_Recorder,0xecabafc2,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_QCListener,0xecabafc3,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_Integrator,0xecabafc4,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_Player,0xecabafc5,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_NewMoniker,0xecabafc6,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_QueueMoniker,0xecabafc7,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_QCQueueAdmin,0xecabafc9,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_DLQListenerStarter,0xecabafca,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_QCMarshalInterceptor,0xecabafcb,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComThreadEvents,0xecabb0ad,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComUserEvent,0xecabb0ae,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComAppEvents,0xecabb0af,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComInstanceEvents,0xecabb0b0,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComTransactionEvents,0xecabb0b1,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComMethodEvents,0xecabb0b2,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComObjectEvents,0xecabb0b3,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComResourceEvents,0xecabb0b4,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComSecurityEvents,0xecabb0b5,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComObjectPoolEvents,0xecabb0b6,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComObjectPoolEvents2,0xecabb0b7,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComObjectConstructionEvents,0xecabb0b8,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComActivityEvents,0xecabb0b9,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComIdentityEvents,0xecabb0ba,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComQCEvents,0xecabb0bb,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComCRMEvents,0xecabb0c2,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComExceptionEvents,0xecabb0bc,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_SecurityCertificate,0xecabb0a4,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_SecurityIdentity,0xecabb0a5,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_SecurityCallers,0xecabb0a6,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_SecurityCallContext,0xecabb0a7,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_GetSecurityCallContextAppObject,0xecabb0a8,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_Dummy30040732,0xecabb0a9,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_AppServer,0x71E38F91,0x7E88,0x11CF,0x9E,0xDE,0x00,0x80,0xC7,0x8B,0x7F,0x89);


MIDL_DEFINE_GUID(CLSID, CLSID_TransactionContext,0x7999FC25,0xD3C6,0x11CF,0xAC,0xAB,0x00,0xA0,0x24,0xA5,0x5A,0xEF);


MIDL_DEFINE_GUID(CLSID, CLSID_TransactionContextEx,0x5cb66670,0xd3d4,0x11cf,0xac,0xab,0x00,0xa0,0x24,0xa5,0x5a,0xef);


MIDL_DEFINE_GUID(CLSID, CLSID_ByotServerEx,0xecabb0aa,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_SharedProperty,0x2A005C05,0xA5DE,0x11CF,0x9E,0x66,0x00,0xAA,0x00,0xA3,0xF4,0x64);


MIDL_DEFINE_GUID(CLSID, CLSID_SharedPropertyGroup,0x2A005C0B,0xA5DE,0x11CF,0x9E,0x66,0x00,0xAA,0x00,0xA3,0xF4,0x64);


MIDL_DEFINE_GUID(CLSID, CLSID_SharedPropertyGroupManager,0x2A005C11,0xA5DE,0x11CF,0x9E,0x66,0x00,0xAA,0x00,0xA3,0xF4,0x64);


MIDL_DEFINE_GUID(CLSID, CLSID_COMEvents,0xecabb0ab,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_CoMTSLocator,0xecabb0ac,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_MtsGrp,0x4B2E958D,0x0393,0x11D1,0xB1,0xAB,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(CLSID, CLSID_ComServiceEvents,0xecabb0c3,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComSystemAppEventData,0xecabb0c6,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_CRMClerk,0xecabb0bd,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_CRMRecoveryClerk,0xecabb0be,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_LBEvents,0xecabb0c1,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_MessageMover,0xecabb0bf,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_DispenserManager,0xecabb0c0,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_PoolMgr,0xecabafb5,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_EventServer,0xecabafbc,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_TrackerServer,0xecabafb9,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ProcessDump,0xecabb0c4,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_PartitionMoniker,0xecabb0c5,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_SoapMoniker,0xecabb0c7,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for comsvcs.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_COMSVCSLib,0x2A005C00,0xA5DE,0x11CF,0x9E,0x66,0x00,0xAA,0x00,0xA3,0xF4,0x64);


MIDL_DEFINE_GUID(CLSID, CLSID_TrkInfoCollUnmarshal,0xecabafcd,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_TrkInfoObjUnmarshal,0xecabafce,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_PartitionPropertyUnmarshal,0xecabafcc,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ActivityUnmarshal,0xecabafaa,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_SecurityEnvoy,0xecabafab,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_TransactionUnmarshal,0xecabafac,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_NonRootTransactionEnvoy,0xecabafad,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_sca,0xecabafae,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_CFAct,0xecabafaf,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_obja,0xecabafb0,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_stapa,0xecabafb1,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_vca,0xecabafb2,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_UserContextProperty,0xecabafb3,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_AssociationUnmarshal,0xecabafb4,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ObjPoolAct,0xecabafb6,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_SoapAct,0xecabafd0,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_CtorAct,0xecabafb7,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ObjectConstruct,0xecabafb8,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_AppTracker,0xecabafba,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ClassTracker,0xecabafbb,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_NtaHelper,0xecabafbe,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComLceEventDispatcher,0xecabafbf,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComEventRegistrar,0xecabafcf,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_cfw,0xecabafc0,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ClerksCollection,0xecabafc1,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_Recorder,0xecabafc2,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_QCListener,0xecabafc3,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_Integrator,0xecabafc4,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_Player,0xecabafc5,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_NewMoniker,0xecabafc6,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_QueueMoniker,0xecabafc7,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_QCQueueAdmin,0xecabafc9,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_DLQListenerStarter,0xecabafca,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_QCMarshalInterceptor,0xecabafcb,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComThreadEvents,0xecabb0ad,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComUserEvent,0xecabb0ae,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComAppEvents,0xecabb0af,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComInstanceEvents,0xecabb0b0,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComTransactionEvents,0xecabb0b1,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComMethodEvents,0xecabb0b2,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComObjectEvents,0xecabb0b3,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComResourceEvents,0xecabb0b4,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComSecurityEvents,0xecabb0b5,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComObjectPoolEvents,0xecabb0b6,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComObjectPoolEvents2,0xecabb0b7,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComObjectConstructionEvents,0xecabb0b8,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComActivityEvents,0xecabb0b9,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComIdentityEvents,0xecabb0ba,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComQCEvents,0xecabb0bb,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComCRMEvents,0xecabb0c2,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComExceptionEvents,0xecabb0bc,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_SecurityCertificate,0xecabb0a4,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_SecurityIdentity,0xecabb0a5,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_SecurityCallers,0xecabb0a6,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_SecurityCallContext,0xecabb0a7,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_GetSecurityCallContextAppObject,0xecabb0a8,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_Dummy30040732,0xecabb0a9,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_AppServer,0x71E38F91,0x7E88,0x11CF,0x9E,0xDE,0x00,0x80,0xC7,0x8B,0x7F,0x89);


MIDL_DEFINE_GUID(CLSID, CLSID_TransactionContext,0x7999FC25,0xD3C6,0x11CF,0xAC,0xAB,0x00,0xA0,0x24,0xA5,0x5A,0xEF);


MIDL_DEFINE_GUID(CLSID, CLSID_TransactionContextEx,0x5cb66670,0xd3d4,0x11cf,0xac,0xab,0x00,0xa0,0x24,0xa5,0x5a,0xef);


MIDL_DEFINE_GUID(CLSID, CLSID_ByotServerEx,0xecabb0aa,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_SharedProperty,0x2A005C05,0xA5DE,0x11CF,0x9E,0x66,0x00,0xAA,0x00,0xA3,0xF4,0x64);


MIDL_DEFINE_GUID(CLSID, CLSID_SharedPropertyGroup,0x2A005C0B,0xA5DE,0x11CF,0x9E,0x66,0x00,0xAA,0x00,0xA3,0xF4,0x64);


MIDL_DEFINE_GUID(CLSID, CLSID_SharedPropertyGroupManager,0x2A005C11,0xA5DE,0x11CF,0x9E,0x66,0x00,0xAA,0x00,0xA3,0xF4,0x64);


MIDL_DEFINE_GUID(CLSID, CLSID_COMEvents,0xecabb0ab,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_CoMTSLocator,0xecabb0ac,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_MtsGrp,0x4B2E958D,0x0393,0x11D1,0xB1,0xAB,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(CLSID, CLSID_ComServiceEvents,0xecabb0c3,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ComSystemAppEventData,0xecabb0c6,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_CRMClerk,0xecabb0bd,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_CRMRecoveryClerk,0xecabb0be,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_LBEvents,0xecabb0c1,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_MessageMover,0xecabb0bf,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_DispenserManager,0xecabb0c0,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_PoolMgr,0xecabafb5,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_EventServer,0xecabafbc,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_TrackerServer,0xecabafb9,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_ProcessDump,0xecabb0c4,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_PartitionMoniker,0xecabb0c5,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);


MIDL_DEFINE_GUID(CLSID, CLSID_SoapMoniker,0xecabb0c7,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\svcguid\enteract_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for enteract.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IEnterActivityWithNoLock,0xD7174F82,0x36B8,0x4aa8,0x80,0x0A,0xE9,0x63,0xAB,0x2D,0xFA,0xB9);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for enteract.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IEnterActivityWithNoLock,0xD7174F82,0x36B8,0x4aa8,0x80,0x0A,0xE9,0x63,0xAB,0x2D,0xFA,0xB9);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\svcguid\eventsys2_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for eventsys2.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IEventClass3,0x7FB7EA43,0x2D76,0x4ea8,0x8C,0xD9,0x3D,0xEC,0xC2,0x70,0x29,0x5E);


MIDL_DEFINE_GUID(IID, IID_IEventSubscription2,0x4A6B0E16,0x2E38,0x11D1,0x99,0x65,0x00,0xC0,0x4F,0xBB,0xB3,0x45);


MIDL_DEFINE_GUID(IID, IID_IEventSubscription3,0xFBC1D17D,0xC498,0x43a0,0x81,0xAF,0x42,0x3D,0xDD,0x53,0x0A,0xF6);


MIDL_DEFINE_GUID(IID, IID_IEventSystem2,0x99CC098F,0xA48A,0x4e9c,0x8E,0x58,0x96,0x5C,0x0A,0xFC,0x19,0xD5);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for eventsys2.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IEventClass3,0x7FB7EA43,0x2D76,0x4ea8,0x8C,0xD9,0x3D,0xEC,0xC2,0x70,0x29,0x5E);


MIDL_DEFINE_GUID(IID, IID_IEventSubscription2,0x4A6B0E16,0x2E38,0x11D1,0x99,0x65,0x00,0xC0,0x4F,0xBB,0xB3,0x45);


MIDL_DEFINE_GUID(IID, IID_IEventSubscription3,0xFBC1D17D,0xC498,0x43a0,0x81,0xAF,0x42,0x3D,0xDD,0x53,0x0A,0xF6);


MIDL_DEFINE_GUID(IID, IID_IEventSystem2,0x99CC098F,0xA48A,0x4e9c,0x8E,0x58,0x96,0x5C,0x0A,0xFC,0x19,0xD5);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\svcguid\eventcpts_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for eventcpts.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IComUserEvent,0x683130A4,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComThreadEvents,0x683130A5,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComAppEvents,0x683130A6,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComInstanceEvents,0x683130A7,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComTransactionEvents,0x683130A8,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComMethodEvents,0x683130A9,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComObjectEvents,0x683130AA,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComResourceEvents,0x683130AB,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComSecurityEvents,0x683130AC,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComObjectPoolEvents,0x683130AD,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComObjectPoolEvents2,0x683130AE,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComObjectConstructionEvents,0x683130AF,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComActivityEvents,0x683130B0,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComIdentityEvents,0x683130B1,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComQCEvents,0x683130B2,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComExceptionEvents,0x683130B3,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_ILBEvents,0x683130B4,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComCRMEvents,0x683130B5,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComMethod2Events,0xFB388AAA,0x567D,0x4024,0xAF,0x8E,0x6E,0x93,0xEE,0x74,0x85,0x73);


MIDL_DEFINE_GUID(IID, IID_IComTrackingInfoEvents,0x4e6cdcc9,0xfb25,0x4fd5,0x9c,0xc5,0xc9,0xf4,0xb6,0x55,0x9c,0xec);


MIDL_DEFINE_GUID(IID, IID_IComTrackingInfoCollection,0xc266c677,0xc9ad,0x49ab,0x9f,0xd9,0xd9,0x66,0x10,0x78,0x58,0x8a);


MIDL_DEFINE_GUID(IID, IID_IComTrackingInfoObject,0x116e42c5,0xd8b1,0x47bf,0xab,0x1e,0xc8,0x95,0xed,0x3e,0x23,0x72);


MIDL_DEFINE_GUID(IID, IID_IComTrackingInfoProperties,0x789b42be,0x6f6b,0x443a,0x89,0x8e,0x67,0xab,0xf3,0x90,0xaa,0x14);


MIDL_DEFINE_GUID(IID, IID_IComAdmAppEvents,0x53F85949,0xAE04,0x45ec,0x8D,0x18,0xC4,0x9E,0x36,0x34,0x06,0xA4);


MIDL_DEFINE_GUID(IID, IID_IComAdmCompEvents,0x0F6B3B72,0x41C2,0x435e,0x88,0xC4,0x26,0x48,0xB5,0x0E,0x7F,0x07);


MIDL_DEFINE_GUID(IID, IID_IComAdmItfEvents,0x9EF28B83,0x6AEE,0x4291,0xBE,0x38,0x3C,0x35,0x49,0x4F,0xA3,0x42);


MIDL_DEFINE_GUID(IID, IID_IComAdmMetEvents,0x63FCB3F8,0x5036,0x41f3,0xAA,0x1E,0x59,0xA0,0x91,0x46,0xD1,0xAB);


MIDL_DEFINE_GUID(IID, IID_IComAdmSecEvents,0xDE599469,0x6B1C,0x4b04,0x88,0xB6,0x99,0xF7,0xD3,0xBC,0x84,0x7A);


MIDL_DEFINE_GUID(IID, IID_IComAdmMashEvents,0x96835522,0x0827,0x4fb2,0xA8,0x6B,0x74,0xE4,0xF3,0x93,0x5C,0x65);


MIDL_DEFINE_GUID(IID, IID_IComAdmSubscrEvents,0x8AFD3770,0x7949,0x4c75,0x92,0x0F,0xE2,0x50,0x59,0x26,0x8D,0x0F);


MIDL_DEFINE_GUID(IID, IID_IComAdmPartEvents,0xDE25DF69,0x9A64,0x4845,0xBF,0x15,0x70,0xE4,0x62,0xA6,0xAA,0x3F);


MIDL_DEFINE_GUID(IID, IID_IComApp2Events,0x1290BC1A,0xB219,0x418d,0xB0,0x78,0x59,0x34,0xDE,0xD0,0x82,0x42);


MIDL_DEFINE_GUID(IID, IID_IComTransaction2Events,0xA136F62A,0x2F94,0x4288,0x86,0xE0,0xD8,0xA1,0xFA,0x4C,0x02,0x99);


MIDL_DEFINE_GUID(IID, IID_IComInstance2Events,0x20E3BF07,0xB506,0x4ad5,0xA5,0x0C,0xD2,0xCA,0x5B,0x9C,0x15,0x8E);


MIDL_DEFINE_GUID(IID, IID_IComObjectPool2Events,0x65BF6534,0x85EA,0x4f64,0x8C,0xF4,0x3D,0x97,0x4B,0x2A,0xB1,0xCF);


MIDL_DEFINE_GUID(IID, IID_IComObjectConstruction2Events,0x4B5A7827,0x8DF2,0x45c0,0x8F,0x6F,0x57,0xEA,0x1F,0x85,0x6A,0x9F);


MIDL_DEFINE_GUID(IID, IID_ISystemAppEventData,0xD6D48A3C,0xD5C5,0x49E7,0x8C,0x74,0x99,0xE4,0x88,0x9E,0xD5,0x2F);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for eventcpts.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IComUserEvent,0x683130A4,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComThreadEvents,0x683130A5,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComAppEvents,0x683130A6,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComInstanceEvents,0x683130A7,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComTransactionEvents,0x683130A8,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComMethodEvents,0x683130A9,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComObjectEvents,0x683130AA,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComResourceEvents,0x683130AB,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComSecurityEvents,0x683130AC,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComObjectPoolEvents,0x683130AD,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComObjectPoolEvents2,0x683130AE,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComObjectConstructionEvents,0x683130AF,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComActivityEvents,0x683130B0,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComIdentityEvents,0x683130B1,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComQCEvents,0x683130B2,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComExceptionEvents,0x683130B3,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_ILBEvents,0x683130B4,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComCRMEvents,0x683130B5,0x2E50,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComMethod2Events,0xFB388AAA,0x567D,0x4024,0xAF,0x8E,0x6E,0x93,0xEE,0x74,0x85,0x73);


MIDL_DEFINE_GUID(IID, IID_IComTrackingInfoEvents,0x4e6cdcc9,0xfb25,0x4fd5,0x9c,0xc5,0xc9,0xf4,0xb6,0x55,0x9c,0xec);


MIDL_DEFINE_GUID(IID, IID_IComTrackingInfoCollection,0xc266c677,0xc9ad,0x49ab,0x9f,0xd9,0xd9,0x66,0x10,0x78,0x58,0x8a);


MIDL_DEFINE_GUID(IID, IID_IComTrackingInfoObject,0x116e42c5,0xd8b1,0x47bf,0xab,0x1e,0xc8,0x95,0xed,0x3e,0x23,0x72);


MIDL_DEFINE_GUID(IID, IID_IComTrackingInfoProperties,0x789b42be,0x6f6b,0x443a,0x89,0x8e,0x67,0xab,0xf3,0x90,0xaa,0x14);


MIDL_DEFINE_GUID(IID, IID_IComAdmAppEvents,0x53F85949,0xAE04,0x45ec,0x8D,0x18,0xC4,0x9E,0x36,0x34,0x06,0xA4);


MIDL_DEFINE_GUID(IID, IID_IComAdmCompEvents,0x0F6B3B72,0x41C2,0x435e,0x88,0xC4,0x26,0x48,0xB5,0x0E,0x7F,0x07);


MIDL_DEFINE_GUID(IID, IID_IComAdmItfEvents,0x9EF28B83,0x6AEE,0x4291,0xBE,0x38,0x3C,0x35,0x49,0x4F,0xA3,0x42);


MIDL_DEFINE_GUID(IID, IID_IComAdmMetEvents,0x63FCB3F8,0x5036,0x41f3,0xAA,0x1E,0x59,0xA0,0x91,0x46,0xD1,0xAB);


MIDL_DEFINE_GUID(IID, IID_IComAdmSecEvents,0xDE599469,0x6B1C,0x4b04,0x88,0xB6,0x99,0xF7,0xD3,0xBC,0x84,0x7A);


MIDL_DEFINE_GUID(IID, IID_IComAdmMashEvents,0x96835522,0x0827,0x4fb2,0xA8,0x6B,0x74,0xE4,0xF3,0x93,0x5C,0x65);


MIDL_DEFINE_GUID(IID, IID_IComAdmSubscrEvents,0x8AFD3770,0x7949,0x4c75,0x92,0x0F,0xE2,0x50,0x59,0x26,0x8D,0x0F);


MIDL_DEFINE_GUID(IID, IID_IComAdmPartEvents,0xDE25DF69,0x9A64,0x4845,0xBF,0x15,0x70,0xE4,0x62,0xA6,0xAA,0x3F);


MIDL_DEFINE_GUID(IID, IID_IComApp2Events,0x1290BC1A,0xB219,0x418d,0xB0,0x78,0x59,0x34,0xDE,0xD0,0x82,0x42);


MIDL_DEFINE_GUID(IID, IID_IComTransaction2Events,0xA136F62A,0x2F94,0x4288,0x86,0xE0,0xD8,0xA1,0xFA,0x4C,0x02,0x99);


MIDL_DEFINE_GUID(IID, IID_IComInstance2Events,0x20E3BF07,0xB506,0x4ad5,0xA5,0x0C,0xD2,0xCA,0x5B,0x9C,0x15,0x8E);


MIDL_DEFINE_GUID(IID, IID_IComObjectPool2Events,0x65BF6534,0x85EA,0x4f64,0x8C,0xF4,0x3D,0x97,0x4B,0x2A,0xB1,0xCF);


MIDL_DEFINE_GUID(IID, IID_IComObjectConstruction2Events,0x4B5A7827,0x8DF2,0x45c0,0x8F,0x6F,0x57,0xEA,0x1F,0x85,0x6A,0x9F);


MIDL_DEFINE_GUID(IID, IID_ISystemAppEventData,0xD6D48A3C,0xD5C5,0x49E7,0x8C,0x74,0x99,0xE4,0x88,0x9E,0xD5,0x2F);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\svcguid\eventsys_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for eventsys.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IEventSystem,0x4E14FB9F,0x2E22,0x11D1,0x99,0x64,0x00,0xC0,0x4F,0xBB,0xB3,0x45);


MIDL_DEFINE_GUID(IID, IID_IEventPublisher,0xE341516B,0x2E32,0x11D1,0x99,0x64,0x00,0xC0,0x4F,0xBB,0xB3,0x45);


MIDL_DEFINE_GUID(IID, IID_IEventClass,0xfb2b72a0,0x7a68,0x11d1,0x88,0xf9,0x00,0x80,0xc7,0xd7,0x71,0xbf);


MIDL_DEFINE_GUID(IID, IID_IEventClass2,0xfb2b72a1,0x7a68,0x11d1,0x88,0xf9,0x00,0x80,0xc7,0xd7,0x71,0xbf);


MIDL_DEFINE_GUID(IID, IID_IEventSubscription,0x4A6B0E15,0x2E38,0x11D1,0x99,0x65,0x00,0xC0,0x4F,0xBB,0xB3,0x45);


MIDL_DEFINE_GUID(IID, IID_IFiringControl,0xe0498c93,0x4efe,0x11d1,0x99,0x71,0x00,0xc0,0x4f,0xbb,0xb3,0x45);


MIDL_DEFINE_GUID(IID, IID_IPublisherFilter,0x465e5cc0,0x7b26,0x11d1,0x88,0xfb,0x00,0x80,0xc7,0xd7,0x71,0xbf);


MIDL_DEFINE_GUID(IID, IID_IMultiInterfacePublisherFilter,0x465e5cc1,0x7b26,0x11d1,0x88,0xfb,0x00,0x80,0xc7,0xd7,0x71,0xbf);


MIDL_DEFINE_GUID(IID, IID_IEventObjectChange,0xF4A07D70,0x2E25,0x11D1,0x99,0x64,0x00,0xC0,0x4F,0xBB,0xB3,0x45);


MIDL_DEFINE_GUID(IID, IID_IEventObjectChange2,0x7701A9C3,0xBD68,0x438f,0x83,0xE0,0x67,0xBF,0x4F,0x53,0xA4,0x22);


MIDL_DEFINE_GUID(IID, IID_IEnumEventObject,0xF4A07D63,0x2E25,0x11D1,0x99,0x64,0x00,0xC0,0x4F,0xBB,0xB3,0x45);


MIDL_DEFINE_GUID(IID, IID_IEventObjectCollection,0xf89ac270,0xd4eb,0x11d1,0xb6,0x82,0x00,0x80,0x5f,0xc7,0x92,0x16);


MIDL_DEFINE_GUID(IID, IID_IEventProperty,0xda538ee2,0xf4de,0x11d1,0xb6,0xbb,0x00,0x80,0x5f,0xc7,0x92,0x16);


MIDL_DEFINE_GUID(IID, IID_IEventControl,0x0343e2f4,0x86f6,0x11d1,0xb7,0x60,0x00,0xc0,0x4f,0xb9,0x26,0xaf);


MIDL_DEFINE_GUID(IID, IID_IMultiInterfaceEventControl,0x0343e2f5,0x86f6,0x11d1,0xb7,0x60,0x00,0xc0,0x4f,0xb9,0x26,0xaf);


MIDL_DEFINE_GUID(IID, LIBID_DummyEventSystemLib,0xe81221dc,0xc4d8,0x11d1,0xb6,0x53,0x00,0x80,0x5f,0xc7,0x92,0x16);


MIDL_DEFINE_GUID(CLSID, CLSID_CEventSystem,0x4E14FBA2,0x2E22,0x11D1,0x99,0x64,0x00,0xC0,0x4F,0xBB,0xB3,0x45);


MIDL_DEFINE_GUID(CLSID, CLSID_CEventPublisher,0xab944620,0x79c6,0x11d1,0x88,0xf9,0x00,0x80,0xc7,0xd7,0x71,0xbf);


MIDL_DEFINE_GUID(CLSID, CLSID_CEventClass,0xcdbec9c0,0x7a68,0x11d1,0x88,0xf9,0x00,0x80,0xc7,0xd7,0x71,0xbf);


MIDL_DEFINE_GUID(CLSID, CLSID_CEventSubscription,0x7542e960,0x79c7,0x11d1,0x88,0xf9,0x00,0x80,0xc7,0xd7,0x71,0xbf);


MIDL_DEFINE_GUID(CLSID, CLSID_EventObjectChange,0xd0565000,0x9df4,0x11d1,0xa2,0x81,0x00,0xc0,0x4f,0xca,0x0a,0xa7);


MIDL_DEFINE_GUID(CLSID, CLSID_EventObjectChange2,0xBB07BACD,0xCD56,0x4e63,0xA8,0xFF,0xCB,0xF0,0x35,0x5F,0xB9,0xF4);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for eventsys.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IEventSystem,0x4E14FB9F,0x2E22,0x11D1,0x99,0x64,0x00,0xC0,0x4F,0xBB,0xB3,0x45);


MIDL_DEFINE_GUID(IID, IID_IEventPublisher,0xE341516B,0x2E32,0x11D1,0x99,0x64,0x00,0xC0,0x4F,0xBB,0xB3,0x45);


MIDL_DEFINE_GUID(IID, IID_IEventClass,0xfb2b72a0,0x7a68,0x11d1,0x88,0xf9,0x00,0x80,0xc7,0xd7,0x71,0xbf);


MIDL_DEFINE_GUID(IID, IID_IEventClass2,0xfb2b72a1,0x7a68,0x11d1,0x88,0xf9,0x00,0x80,0xc7,0xd7,0x71,0xbf);


MIDL_DEFINE_GUID(IID, IID_IEventSubscription,0x4A6B0E15,0x2E38,0x11D1,0x99,0x65,0x00,0xC0,0x4F,0xBB,0xB3,0x45);


MIDL_DEFINE_GUID(IID, IID_IFiringControl,0xe0498c93,0x4efe,0x11d1,0x99,0x71,0x00,0xc0,0x4f,0xbb,0xb3,0x45);


MIDL_DEFINE_GUID(IID, IID_IPublisherFilter,0x465e5cc0,0x7b26,0x11d1,0x88,0xfb,0x00,0x80,0xc7,0xd7,0x71,0xbf);


MIDL_DEFINE_GUID(IID, IID_IMultiInterfacePublisherFilter,0x465e5cc1,0x7b26,0x11d1,0x88,0xfb,0x00,0x80,0xc7,0xd7,0x71,0xbf);


MIDL_DEFINE_GUID(IID, IID_IEventObjectChange,0xF4A07D70,0x2E25,0x11D1,0x99,0x64,0x00,0xC0,0x4F,0xBB,0xB3,0x45);


MIDL_DEFINE_GUID(IID, IID_IEventObjectChange2,0x7701A9C3,0xBD68,0x438f,0x83,0xE0,0x67,0xBF,0x4F,0x53,0xA4,0x22);


MIDL_DEFINE_GUID(IID, IID_IEnumEventObject,0xF4A07D63,0x2E25,0x11D1,0x99,0x64,0x00,0xC0,0x4F,0xBB,0xB3,0x45);


MIDL_DEFINE_GUID(IID, IID_IEventObjectCollection,0xf89ac270,0xd4eb,0x11d1,0xb6,0x82,0x00,0x80,0x5f,0xc7,0x92,0x16);


MIDL_DEFINE_GUID(IID, IID_IEventProperty,0xda538ee2,0xf4de,0x11d1,0xb6,0xbb,0x00,0x80,0x5f,0xc7,0x92,0x16);


MIDL_DEFINE_GUID(IID, IID_IEventControl,0x0343e2f4,0x86f6,0x11d1,0xb7,0x60,0x00,0xc0,0x4f,0xb9,0x26,0xaf);


MIDL_DEFINE_GUID(IID, IID_IMultiInterfaceEventControl,0x0343e2f5,0x86f6,0x11d1,0xb7,0x60,0x00,0xc0,0x4f,0xb9,0x26,0xaf);


MIDL_DEFINE_GUID(IID, LIBID_DummyEventSystemLib,0xe81221dc,0xc4d8,0x11d1,0xb6,0x53,0x00,0x80,0x5f,0xc7,0x92,0x16);


MIDL_DEFINE_GUID(CLSID, CLSID_CEventSystem,0x4E14FBA2,0x2E22,0x11D1,0x99,0x64,0x00,0xC0,0x4F,0xBB,0xB3,0x45);


MIDL_DEFINE_GUID(CLSID, CLSID_CEventPublisher,0xab944620,0x79c6,0x11d1,0x88,0xf9,0x00,0x80,0xc7,0xd7,0x71,0xbf);


MIDL_DEFINE_GUID(CLSID, CLSID_CEventClass,0xcdbec9c0,0x7a68,0x11d1,0x88,0xf9,0x00,0x80,0xc7,0xd7,0x71,0xbf);


MIDL_DEFINE_GUID(CLSID, CLSID_CEventSubscription,0x7542e960,0x79c7,0x11d1,0x88,0xf9,0x00,0x80,0xc7,0xd7,0x71,0xbf);


MIDL_DEFINE_GUID(CLSID, CLSID_EventObjectChange,0xd0565000,0x9df4,0x11d1,0xa2,0x81,0x00,0xc0,0x4f,0xca,0x0a,0xa7);


MIDL_DEFINE_GUID(CLSID, CLSID_EventObjectChange2,0xBB07BACD,0xCD56,0x4e63,0xA8,0xFF,0xCB,0xF0,0x35,0x5F,0xB9,0xF4);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\svcguid\qcprivat_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for qcprivat.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IMarshal3,0x7090ED49,0xE141,0x11d1,0xB5,0x86,0x00,0xE0,0x29,0x0E,0x6C,0x31);


MIDL_DEFINE_GUID(IID, IID_IRecorderInternal,0x5D0B6204,0x35DE,0x4a66,0xAB,0x26,0x1E,0x5A,0x7B,0x33,0x2A,0x4A);


MIDL_DEFINE_GUID(IID, IID_IChannelManager,0x99921E41,0xC341,0x11D0,0x8B,0x1D,0x00,0xA0,0xC9,0x03,0x65,0xD6);


MIDL_DEFINE_GUID(IID, IID_IRpcChannelBufferInternal,0x6bc6df07,0x620f,0x4219,0xbc,0x54,0xb5,0xc6,0x5b,0xb7,0x1e,0x9b);


MIDL_DEFINE_GUID(IID, IID_IQCInterfaceManager,0x7dab9041,0x3180,0x42c6,0xa4,0xd6,0xd8,0x95,0xb5,0x12,0x74,0x6b);


MIDL_DEFINE_GUID(IID, IID_IQCListener,0x2a36cf7e,0x9b12,0x11d4,0x83,0x73,0x00,0xc0,0x4f,0x60,0x55,0x88);


MIDL_DEFINE_GUID(IID, IID_ILMessage,0xcb34adca,0x9c0d,0x11d4,0x83,0x73,0x00,0xc0,0x4f,0x60,0x55,0x88);


MIDL_DEFINE_GUID(IID, IID_ILQue,0xEC9E950E,0xAF2A,0x11d2,0x9A,0x72,0x00,0xC0,0x4F,0x79,0xB1,0x4C);


MIDL_DEFINE_GUID(IID, IID_IIntegrator,0x1F20BC5A,0x0549,0x11d2,0x8B,0x2A,0x00,0x00,0xF8,0x06,0x50,0x31);


MIDL_DEFINE_GUID(IID, IID_IQCPlayer,0xA3E69F2B,0x00AA,0x11d2,0xB5,0x8A,0x00,0xE0,0x29,0x0E,0x6C,0x31);


MIDL_DEFINE_GUID(IID, IID_IMSMQQueueOptions,0xEF50B580,0x71BC,0x11d2,0x9B,0xB9,0x00,0xC0,0x4F,0x79,0x78,0xE0);


MIDL_DEFINE_GUID(IID, IID_IQCQueueAdministration,0x1FA984EA,0xE213,0x11d2,0x9B,0x41,0x00,0xC0,0x4F,0x79,0x78,0xE0);


MIDL_DEFINE_GUID(IID, IID_IMkOption,0xE83BCB9F,0x5B12,0x11d2,0x9B,0x88,0x00,0xC0,0x4F,0x79,0x78,0xE0);


MIDL_DEFINE_GUID(IID, IID_IQCMonikerInfo,0x83F3D27D,0x0646,0x11d2,0x9F,0x6F,0x00,0xC0,0x4F,0xC3,0x40,0xEE);


MIDL_DEFINE_GUID(IID, IID_IMarshalInterceptor,0xC99D1FC8,0xD0DC,0x11d2,0x92,0x28,0x00,0xC0,0x4F,0x79,0xD1,0xEB);


MIDL_DEFINE_GUID(IID, IID_IQCPartitionInfo,0x59AA8AFC,0xF483,0x4862,0xA9,0xA8,0xBE,0xF6,0x69,0xF6,0x58,0x3D);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for qcprivat.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IMarshal3,0x7090ED49,0xE141,0x11d1,0xB5,0x86,0x00,0xE0,0x29,0x0E,0x6C,0x31);


MIDL_DEFINE_GUID(IID, IID_IRecorderInternal,0x5D0B6204,0x35DE,0x4a66,0xAB,0x26,0x1E,0x5A,0x7B,0x33,0x2A,0x4A);


MIDL_DEFINE_GUID(IID, IID_IChannelManager,0x99921E41,0xC341,0x11D0,0x8B,0x1D,0x00,0xA0,0xC9,0x03,0x65,0xD6);


MIDL_DEFINE_GUID(IID, IID_IRpcChannelBufferInternal,0x6bc6df07,0x620f,0x4219,0xbc,0x54,0xb5,0xc6,0x5b,0xb7,0x1e,0x9b);


MIDL_DEFINE_GUID(IID, IID_IQCInterfaceManager,0x7dab9041,0x3180,0x42c6,0xa4,0xd6,0xd8,0x95,0xb5,0x12,0x74,0x6b);


MIDL_DEFINE_GUID(IID, IID_IQCListener,0x2a36cf7e,0x9b12,0x11d4,0x83,0x73,0x00,0xc0,0x4f,0x60,0x55,0x88);


MIDL_DEFINE_GUID(IID, IID_ILMessage,0xcb34adca,0x9c0d,0x11d4,0x83,0x73,0x00,0xc0,0x4f,0x60,0x55,0x88);


MIDL_DEFINE_GUID(IID, IID_ILQue,0xEC9E950E,0xAF2A,0x11d2,0x9A,0x72,0x00,0xC0,0x4F,0x79,0xB1,0x4C);


MIDL_DEFINE_GUID(IID, IID_IIntegrator,0x1F20BC5A,0x0549,0x11d2,0x8B,0x2A,0x00,0x00,0xF8,0x06,0x50,0x31);


MIDL_DEFINE_GUID(IID, IID_IQCPlayer,0xA3E69F2B,0x00AA,0x11d2,0xB5,0x8A,0x00,0xE0,0x29,0x0E,0x6C,0x31);


MIDL_DEFINE_GUID(IID, IID_IMSMQQueueOptions,0xEF50B580,0x71BC,0x11d2,0x9B,0xB9,0x00,0xC0,0x4F,0x79,0x78,0xE0);


MIDL_DEFINE_GUID(IID, IID_IQCQueueAdministration,0x1FA984EA,0xE213,0x11d2,0x9B,0x41,0x00,0xC0,0x4F,0x79,0x78,0xE0);


MIDL_DEFINE_GUID(IID, IID_IMkOption,0xE83BCB9F,0x5B12,0x11d2,0x9B,0x88,0x00,0xC0,0x4F,0x79,0x78,0xE0);


MIDL_DEFINE_GUID(IID, IID_IQCMonikerInfo,0x83F3D27D,0x0646,0x11d2,0x9F,0x6F,0x00,0xC0,0x4F,0xC3,0x40,0xEE);


MIDL_DEFINE_GUID(IID, IID_IMarshalInterceptor,0xC99D1FC8,0xD0DC,0x11d2,0x92,0x28,0x00,0xC0,0x4F,0x79,0xD1,0xEB);


MIDL_DEFINE_GUID(IID, IID_IQCPartitionInfo,0x59AA8AFC,0xF483,0x4862,0xA9,0xA8,0xBE,0xF6,0x69,0xF6,0x58,0x3D);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\svcguid\mtxas_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for mtxas.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_SecurityProperty,0xE74A7215,0x014D,0x11d1,0xA6,0x3C,0x00,0xA0,0xC9,0x11,0xB4,0xE0);


MIDL_DEFINE_GUID(IID, IID_ContextInfo,0x19A5A02C,0x0AC8,0x11d2,0xB2,0x86,0x00,0xC0,0x4F,0x8E,0xF9,0x34);


MIDL_DEFINE_GUID(IID, IID_ContextInfo2,0xc99d6e75,0x2375,0x11d4,0x83,0x31,0x00,0xc0,0x4f,0x60,0x55,0x88);


MIDL_DEFINE_GUID(IID, IID_ObjectContext,0x74C08646,0xCEDB,0x11CF,0x8B,0x49,0x00,0xAA,0x00,0xB8,0xA7,0x90);


MIDL_DEFINE_GUID(IID, IID_IMTxAS,0x74C08641,0xCEDB,0x11CF,0x8B,0x49,0x00,0xAA,0x00,0xB8,0xA7,0x90);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for mtxas.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_SecurityProperty,0xE74A7215,0x014D,0x11d1,0xA6,0x3C,0x00,0xA0,0xC9,0x11,0xB4,0xE0);


MIDL_DEFINE_GUID(IID, IID_ContextInfo,0x19A5A02C,0x0AC8,0x11d2,0xB2,0x86,0x00,0xC0,0x4F,0x8E,0xF9,0x34);


MIDL_DEFINE_GUID(IID, IID_ContextInfo2,0xc99d6e75,0x2375,0x11d4,0x83,0x31,0x00,0xc0,0x4f,0x60,0x55,0x88);


MIDL_DEFINE_GUID(IID, IID_ObjectContext,0x74C08646,0xCEDB,0x11CF,0x8B,0x49,0x00,0xAA,0x00,0xB8,0xA7,0x90);


MIDL_DEFINE_GUID(IID, IID_IMTxAS,0x74C08641,0xCEDB,0x11CF,0x8B,0x49,0x00,0xAA,0x00,0xB8,0xA7,0x90);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\svcguid\iid.c ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//
// *** NOTICE ***
//
// New CLSIDs added to this file MUST be within the range reserved for use
// here. The reserved range for each file is shown below:
//
// iid.c           from - ecabaeb0-7f19-11d2-978e-0000f8757e2a
//                 thru - ecabafa9-7f19-11d2-978e-0000f8757e2a
//
// ccprivat.idl    from - ecabafaa-7f19-11d2-978e-0000f8757e2a
//                 thru - ecabb0a3-7f19-11d2-978e-0000f8757e2a
//
// ccpublic.idl    from - ecabb0a4-7f19-11d2-978e-0000f8757e2a
//                 thru - ecabb19d-7f19-11d2-978e-0000f8757e2a
//
// unassigned      from - ecabb19e-7f19-11d2-978e-0000f8757e2a
//                 thru - ecabb297-7f19-11d2-978e-0000f8757e2a
//
//

#include "comsvcs_i.c"
//#include "mtx_i.c"
#include "mtxas_i.c"
#include "secctx_i.c"
#include "svcintfs_i.c"
#include "trust_i.c"
#include "txctx_i.c"
#include "byot_i.c"
#include "volpmidl_i.c"
#include "casperpriv_i.c"
#include "eventcpts_i.c"
#include "mtsevents_i.c"
#include "comadmin_i.c"
#include "vsevfire_i.c"
#include "EventSys_i.c"
#include "EventSys2_i.c"
#include "comvbdbg_i.c"
#include "QCPublic_i.c"
#include "QCPrivat_i.c"
#include <comsvcsevents_i.c>
#include "enteract_i.c"
#include "svcevents_i.c"

//
//	define any guids not put in IDL files here
//
const CLSID guidTransactionProperty			= {0xecabaeb1, 0x7f19, 0x11d2, {0x97, 0x8e, 0x00, 0x00, 0xf8, 0x75, 0x7e, 0x2a}};
const CLSID guidJITActivationPolicy			= {0xecabaeb2, 0x7f19, 0x11d2, {0x97, 0x8e, 0x00, 0x00, 0xf8, 0x75, 0x7e, 0x2a}};
const CLSID guidTrkPropPolicy				= {0xecabaeb3, 0x7f19, 0x11d2, {0x97, 0x8e, 0x00, 0x00, 0xf8, 0x75, 0x7e, 0x2a}};
const CLSID guidActivityPolicy				= {0xecabaeb4, 0x7f19, 0x11d2, {0x97, 0x8e, 0x00, 0x00, 0xf8, 0x75, 0x7e, 0x2a}};
const CLSID guidContextMarshaler			= {0xecabaeb5, 0x7f19, 0x11d2, {0x97, 0x8e, 0x00, 0x00, 0xf8, 0x75, 0x7e, 0x2a}};    
const CLSID guidUserPropertiesProperty		= {0xecabaeb6, 0x7f19, 0x11d2, {0x97, 0x8e, 0x00, 0x00, 0xf8, 0x75, 0x7e, 0x2a}};    
const CLSID guidApplicationInfo				= {0xecabaeb7, 0x7f19, 0x11d2, {0x97, 0x8e, 0x00, 0x00, 0xf8, 0x75, 0x7e, 0x2a}};    
const CLSID guidSecurityPolicy				= {0xecabaeb8, 0x7f19, 0x11d2, {0x97, 0x8e, 0x00, 0x00, 0xf8, 0x75, 0x7e, 0x2a}};    
const CLSID guidSPMPolicy					= {0xecabaeb9, 0x7f19, 0x11d2, {0x97, 0x8e, 0x00, 0x00, 0xf8, 0x75, 0x7e, 0x2a}};
const CLSID guidPartitionProperty			= {0xecabaeba, 0x7f19, 0x11d2, {0x97, 0x8e, 0x00, 0x00, 0xf8, 0x75, 0x7e, 0x2a}};

// Moved from itm/itmuuid/itmuuid.c
const CLSID CLSID_TrustManager				= {0xecabaebb, 0x7f19, 0x11d2, {0x97, 0x8e, 0x00, 0x00, 0xf8, 0x75, 0x7e, 0x2a}};
const CLSID CLSID_StdPolicyManager			= {0xecabaebc, 0x7f19, 0x11d2, {0x97, 0x8e, 0x00, 0x00, 0xf8, 0x75, 0x7e, 0x2a}};
const CLSID CLSID_StdPolicyPackage			= {0xecabaebd, 0x7f19, 0x11d2, {0x97, 0x8e, 0x00, 0x00, 0xf8, 0x75, 0x7e, 0x2a}};
const CLSID CLSID_ScriptPolicyMaker			= {0xecabaebe, 0x7f19, 0x11d2, {0x97, 0x8e, 0x00, 0x00, 0xf8, 0x75, 0x7e, 0x2a}};
const CLSID CLSID_VolatilePolicyManager		= {0xecabaebf, 0x7f19, 0x11d2, {0x97, 0x8e, 0x00, 0x00, 0xf8, 0x75, 0x7e, 0x2a}};
const CLSID CLSID_TrustGlobals				= {0xecabaec0, 0x7f19, 0x11d2, {0x97, 0x8e, 0x00, 0x00, 0xf8, 0x75, 0x7e, 0x2a}};

// This GUID is present in a Com+ Setup .infsrc file (in string form), as well as the QC Listener and QC QueueAdmin
// This is the Application ID of the QC Dead Letter Queue Listener Application

const GUID  guidQCDeadLetterQueueListenerAppId 
											= {0x7b4e1f3c, 0xa702, 0x11d2, {0xa3, 0x36, 0x00, 0xc0, 0x4f, 0x79, 0x78, 0xe0}};

// This is default application partition GUID. The default
// application partition is only identifiable through this unique
// identifier, therefore once COM+ 1.X ships, this ID is forever.

const CLSID GUID_DefaultAppPartition = 
{ 0x41e90f3e, 0x56c1, 0x4633, { 0x81, 0xc3, 0x6e, 0x8b, 0xac, 0x8b, 0xdd, 0x70 } };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\svcguid\mtsevents_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for mtsevents.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IMtsEvents,0xBACEDF4D,0x74AB,0x11D0,0xB1,0x62,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_IMtsEventInfo,0xD56C3DC1,0x8482,0x11d0,0xB1,0x70,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_IMTSLocator,0xD19B8BFD,0x7F88,0x11D0,0xB1,0x6E,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_IMtsGrp,0x4B2E958C,0x0393,0x11D1,0xB1,0xAB,0x00,0xAA,0x00,0xBA,0x32,0x58);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for mtsevents.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IMtsEvents,0xBACEDF4D,0x74AB,0x11D0,0xB1,0x62,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_IMtsEventInfo,0xD56C3DC1,0x8482,0x11d0,0xB1,0x70,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_IMTSLocator,0xD19B8BFD,0x7F88,0x11D0,0xB1,0x6E,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_IMtsGrp,0x4B2E958C,0x0393,0x11D1,0xB1,0xAB,0x00,0xAA,0x00,0xBA,0x32,0x58);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\svcguid\svcevents_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for svcevents.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IEventSourceCallback,0x3194B4CC,0xEF32,0x11d1,0x93,0xAE,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_AsyncIEventSourceCallback,0x90D6AF82,0x0648,0x11d2,0xB7,0x19,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IEventSourceCallback2,0xF4C459A1,0xA13D,0x4bb8,0xB0,0xF3,0xB7,0x6F,0x86,0x0A,0x07,0xA0);


MIDL_DEFINE_GUID(IID, IID_AsyncIEventSourceCallback2,0xC95BFC3D,0x76C5,0x4fdf,0xB0,0xDE,0xA3,0x1F,0x56,0x78,0x56,0x38);


MIDL_DEFINE_GUID(IID, IID_IEventCall,0x90D6AF83,0x0648,0x11d2,0xB7,0x19,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IEventDispatcher,0x3194B4CD,0xEF32,0x11d1,0x93,0xAE,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_IEventRegistrar,0xB4777622,0x6EB8,0x4655,0xAE,0x1B,0xAF,0x0A,0x6E,0x04,0x6C,0xD0);


MIDL_DEFINE_GUID(IID, IID_IEventServer,0xF1CB0608,0xEC04,0x11D1,0x93,0xAE,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_IEventServer2,0x378F3CA7,0xBD24,0x481c,0x8D,0xC3,0x5E,0x5E,0xCE,0x1B,0xCA,0xD7);


MIDL_DEFINE_GUID(IID, IID_IProcessTerminateNotify,0x3194B4CF,0xEF32,0x11d1,0x93,0xAE,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_IProcessWatch,0x3194B4CE,0xEF32,0x11d1,0x93,0xAE,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_INtaHelper,0xF5659960,0x0799,0x11d2,0xB7,0x20,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComLceEventDispatcher,0x6E35779B,0x305C,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IEventServerTrace,0x9A9F12B8,0x80AF,0x47ab,0xA5,0x79,0x35,0xEA,0x57,0x72,0x53,0x70);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for svcevents.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IEventSourceCallback,0x3194B4CC,0xEF32,0x11d1,0x93,0xAE,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_AsyncIEventSourceCallback,0x90D6AF82,0x0648,0x11d2,0xB7,0x19,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IEventSourceCallback2,0xF4C459A1,0xA13D,0x4bb8,0xB0,0xF3,0xB7,0x6F,0x86,0x0A,0x07,0xA0);


MIDL_DEFINE_GUID(IID, IID_AsyncIEventSourceCallback2,0xC95BFC3D,0x76C5,0x4fdf,0xB0,0xDE,0xA3,0x1F,0x56,0x78,0x56,0x38);


MIDL_DEFINE_GUID(IID, IID_IEventCall,0x90D6AF83,0x0648,0x11d2,0xB7,0x19,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IEventDispatcher,0x3194B4CD,0xEF32,0x11d1,0x93,0xAE,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_IEventRegistrar,0xB4777622,0x6EB8,0x4655,0xAE,0x1B,0xAF,0x0A,0x6E,0x04,0x6C,0xD0);


MIDL_DEFINE_GUID(IID, IID_IEventServer,0xF1CB0608,0xEC04,0x11D1,0x93,0xAE,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_IEventServer2,0x378F3CA7,0xBD24,0x481c,0x8D,0xC3,0x5E,0x5E,0xCE,0x1B,0xCA,0xD7);


MIDL_DEFINE_GUID(IID, IID_IProcessTerminateNotify,0x3194B4CF,0xEF32,0x11d1,0x93,0xAE,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_IProcessWatch,0x3194B4CE,0xEF32,0x11d1,0x93,0xAE,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_INtaHelper,0xF5659960,0x0799,0x11d2,0xB7,0x20,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComLceEventDispatcher,0x6E35779B,0x305C,0x11d2,0x98,0xA5,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IEventServerTrace,0x9A9F12B8,0x80AF,0x47ab,0xA5,0x79,0x35,0xEA,0x57,0x72,0x53,0x70);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\svcguid\qcpublic_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for qcpublic.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IMessageMover,0x588A085A,0xB795,0x11D1,0x80,0x54,0x00,0xC0,0x4F,0xC3,0x40,0xEE);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for qcpublic.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IMessageMover,0x588A085A,0xB795,0x11D1,0x80,0x54,0x00,0xC0,0x4F,0xC3,0x40,0xEE);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\svcguid\secctx_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for secctx.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ISecurityCallCtxPrivate,0x29012F73,0x8C30,0x11d1,0x8E,0x04,0x00,0x80,0xC7,0xF8,0xC2,0xBF);


MIDL_DEFINE_GUID(IID, IID_ISecurityCertificateColl,0xCAFC823B,0xB441,0x11d1,0xB8,0x2B,0x00,0x00,0xF8,0x75,0x7E,0x2A);


MIDL_DEFINE_GUID(IID, IID_ISecurityIdentityColl,0xCAFC823C,0xB441,0x11d1,0xB8,0x2B,0x00,0x00,0xF8,0x75,0x7E,0x2A);


MIDL_DEFINE_GUID(IID, IID_ISecurityCallersColl,0xCAFC823D,0xB441,0x11d1,0xB8,0x2B,0x00,0x00,0xF8,0x75,0x7E,0x2A);


MIDL_DEFINE_GUID(IID, IID_ISecurityCallContext,0xCAFC823E,0xB441,0x11d1,0xB8,0x2B,0x00,0x00,0xF8,0x75,0x7E,0x2A);


MIDL_DEFINE_GUID(IID, IID_IGetSecurityCallContext,0xCAFC823F,0xB441,0x11d1,0xB8,0x2B,0x00,0x00,0xF8,0x75,0x7E,0x2A);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for secctx.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ISecurityCallCtxPrivate,0x29012F73,0x8C30,0x11d1,0x8E,0x04,0x00,0x80,0xC7,0xF8,0xC2,0xBF);


MIDL_DEFINE_GUID(IID, IID_ISecurityCertificateColl,0xCAFC823B,0xB441,0x11d1,0xB8,0x2B,0x00,0x00,0xF8,0x75,0x7E,0x2A);


MIDL_DEFINE_GUID(IID, IID_ISecurityIdentityColl,0xCAFC823C,0xB441,0x11d1,0xB8,0x2B,0x00,0x00,0xF8,0x75,0x7E,0x2A);


MIDL_DEFINE_GUID(IID, IID_ISecurityCallersColl,0xCAFC823D,0xB441,0x11d1,0xB8,0x2B,0x00,0x00,0xF8,0x75,0x7E,0x2A);


MIDL_DEFINE_GUID(IID, IID_ISecurityCallContext,0xCAFC823E,0xB441,0x11d1,0xB8,0x2B,0x00,0x00,0xF8,0x75,0x7E,0x2A);


MIDL_DEFINE_GUID(IID, IID_IGetSecurityCallContext,0xCAFC823F,0xB441,0x11d1,0xB8,0x2B,0x00,0x00,0xF8,0x75,0x7E,0x2A);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\svcguid\trust_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for trust.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ITrustable,0x9211A270,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_IProvideEvalContext,0x9211A297,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_ITrustPolicy,0x9211A271,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_ITrustManager,0x9211A272,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_IPolicyManager,0x9211A274,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_IPolicyCategoryRegister,0x9211A275,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_ICategoriesCollection,0x9211A27D,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_IInstancesCollection,0x9211A27E,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_ITrustEvaluationContext,0x9211A276,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_ITrustEvaluationContextProvider,0x9211A27C,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_ITrustPropertySet,0x9211A277,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_ITrustPolicyVerbs,0x9211A278,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_ITrustPolicySetup,0x9211A279,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_ITrustPolicyScript,0x9211A27A,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_IScriptPolicyMaker,0x9211A27B,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_IEnumTrustPolicy,0x9211A290,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_IEnumTRUSTPOLICYINFO,0x9211A291,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_IPolicyPackage,0x9211A295,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_ICreatePolicyPackage,0x9211A296,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for trust.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ITrustable,0x9211A270,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_IProvideEvalContext,0x9211A297,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_ITrustPolicy,0x9211A271,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_ITrustManager,0x9211A272,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_IPolicyManager,0x9211A274,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_IPolicyCategoryRegister,0x9211A275,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_ICategoriesCollection,0x9211A27D,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_IInstancesCollection,0x9211A27E,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_ITrustEvaluationContext,0x9211A276,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_ITrustEvaluationContextProvider,0x9211A27C,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_ITrustPropertySet,0x9211A277,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_ITrustPolicyVerbs,0x9211A278,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_ITrustPolicySetup,0x9211A279,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_ITrustPolicyScript,0x9211A27A,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_IScriptPolicyMaker,0x9211A27B,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_IEnumTrustPolicy,0x9211A290,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_IEnumTRUSTPOLICYINFO,0x9211A291,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_IPolicyPackage,0x9211A295,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);


MIDL_DEFINE_GUID(IID, IID_ICreatePolicyPackage,0x9211A296,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\svcguid\svcintfs_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for svcintfs.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IAppTracker,0x9096B831,0x7472,0x11CF,0xBE,0x39,0x00,0xAA,0x00,0xA2,0xFA,0x25);


MIDL_DEFINE_GUID(IID, IID_IClassTrackerUpdate,0xea61e3c2,0x7c62,0x11cf,0xbe,0x3f,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IReceiveAppData,0x413dafb0,0xbcf4,0x11d1,0x86,0x1d,0x00,0x80,0xc7,0x29,0x26,0x4d);


MIDL_DEFINE_GUID(IID, IID_IGetAppData,0xb60040e0,0xbcf3,0x11d1,0x86,0x1d,0x00,0x80,0xc7,0x29,0x26,0x4d);


MIDL_DEFINE_GUID(IID, IID_ITrkSvrAppControl,0x6eb6ba78,0xbe49,0x4044,0x9f,0xe5,0x25,0xb9,0x83,0x80,0xca,0x3f);


MIDL_DEFINE_GUID(IID, IID_IProcessDump,0x23C9DD26,0x2355,0x4FE2,0x84,0xDE,0xF7,0x79,0xA2,0x38,0xAD,0xBD);


MIDL_DEFINE_GUID(IID, IID_IDispenserManager,0x5cb31e10,0x2b5f,0x11cf,0xbe,0x10,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IDispenserManagerShutdownGuarantee,0x5cb31e11,0x2b5f,0x11cf,0xbe,0x10,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IHolder,0xbf6a1850,0x2b45,0x11cf,0xbe,0x10,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IDispenserDriver,0x208b3651,0x2b48,0x11cf,0xbe,0x10,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IObjectContext,0x51372ae0,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IObjectControl,0x51372aec,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IEnumNames,0x51372af2,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_ISecurityProperty,0x51372aea,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_ObjectControl,0x7DC41850,0x0C31,0x11d0,0x8B,0x79,0x00,0xAA,0x00,0xB8,0xA7,0x90);


MIDL_DEFINE_GUID(IID, IID_ISharedProperty,0x2A005C01,0xA5DE,0x11CF,0x9E,0x66,0x00,0xAA,0x00,0xA3,0xF4,0x64);


MIDL_DEFINE_GUID(IID, IID_ISharedPropertyGroup,0x2A005C07,0xA5DE,0x11CF,0x9E,0x66,0x00,0xAA,0x00,0xA3,0xF4,0x64);


MIDL_DEFINE_GUID(IID, IID_ISharedPropertyGroupManager,0x2A005C0D,0xA5DE,0x11CF,0x9E,0x66,0x00,0xAA,0x00,0xA3,0xF4,0x64);


MIDL_DEFINE_GUID(IID, IID_IObjectConstruct,0x41C4F8B3,0x7439,0x11D2,0x98,0xCB,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IObjectConstructString,0x41C4F8B2,0x7439,0x11D2,0x98,0xCB,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IObjectContextActivity,0x51372afc,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IObjectContextInfo,0x75B52DDB,0xE8ED,0x11d1,0x93,0xAD,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_IObjectContextInfo2,0x594BE71A,0x4BC4,0x438b,0x91,0x97,0xCF,0xD1,0x76,0x24,0x8B,0x09);


MIDL_DEFINE_GUID(IID, IID_IObjectContextTip,0x92FD41CA,0xBAD9,0x11d2,0x9A,0x2D,0x00,0xC0,0x4F,0x79,0x7B,0xC9);


MIDL_DEFINE_GUID(IID, IID_IPlaybackControl,0x51372afd,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IGetContextProperties,0x51372af4,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IContextState,0x3C05E54B,0xA42A,0x11d2,0xAF,0xC4,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IPoolManager,0x0a469861,0x5a91,0x43a0,0x99,0xb6,0xd5,0xe1,0x79,0xbb,0x06,0x31);


MIDL_DEFINE_GUID(IID, IID_ISelectCOMLBServer,0xdcf443f4,0x3f8a,0x4872,0xb9,0xf0,0x36,0x9a,0x79,0x6d,0x12,0xd6);


MIDL_DEFINE_GUID(IID, IID_ICOMLBArguments,0x3a0f150f,0x8ee5,0x4b94,0xb4,0x0e,0xae,0xf2,0xf9,0xe4,0x2e,0xd2);


MIDL_DEFINE_GUID(IID, IID_ICrmLogControl,0xA0E174B3,0xD26E,0x11d2,0x8F,0x84,0x00,0x80,0x5F,0xC7,0xBC,0xD9);


MIDL_DEFINE_GUID(IID, IID_ICrmCompensatorVariants,0xF0BAF8E4,0x7804,0x11d1,0x82,0xE9,0x00,0xA0,0xC9,0x1E,0xED,0xE9);


MIDL_DEFINE_GUID(IID, IID_ICrmCompensator,0xBBC01830,0x8D3B,0x11d1,0x82,0xEC,0x00,0xA0,0xC9,0x1E,0xED,0xE9);


MIDL_DEFINE_GUID(IID, IID_ICrmMonitorLogRecords,0x70C8E441,0xC7ED,0x11d1,0x82,0xFB,0x00,0xA0,0xC9,0x1E,0xED,0xE9);


MIDL_DEFINE_GUID(IID, IID_ICrmMonitorClerks,0x70C8E442,0xC7ED,0x11d1,0x82,0xFB,0x00,0xA0,0xC9,0x1E,0xED,0xE9);


MIDL_DEFINE_GUID(IID, IID_ICrmMonitor,0x70C8E443,0xC7ED,0x11d1,0x82,0xFB,0x00,0xA0,0xC9,0x1E,0xED,0xE9);


MIDL_DEFINE_GUID(IID, IID_ICrmFormatLogRecords,0x9C51D821,0xC98B,0x11d1,0x82,0xFB,0x00,0xA0,0xC9,0x1E,0xED,0xE9);


MIDL_DEFINE_GUID(IID, IID_IPhase0Notify,0x0199706C,0x7B3E,0x11d2,0x99,0xFB,0x00,0xC0,0x4F,0x79,0x7B,0xC9);


MIDL_DEFINE_GUID(IID, IID_IRegisterPhase0,0x0199706D,0x7B3E,0x11d2,0x99,0xFB,0x00,0xC0,0x4F,0x79,0x7B,0xC9);


MIDL_DEFINE_GUID(IID, IID_IActivationEvents,0x788ea812,0x87b1,0x11d1,0xbb,0xa6,0x00,0xc0,0x4f,0xc2,0xfa,0x5f);


MIDL_DEFINE_GUID(IID, IID_IJITActivationProperty,0x788ea813,0x87b1,0x11d1,0xbb,0xa6,0x00,0xc0,0x4f,0xc2,0xfa,0x5f);


MIDL_DEFINE_GUID(IID, IID_ICallContextNotify,0x51372aeb,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IActivity,0xC3813A4A,0xCE3A,0x11d1,0x93,0x9A,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_ITransactionStream,0x97199110,0xDB2E,0x11d1,0xA2,0x51,0x00,0x00,0xF8,0x05,0xCA,0x53);


MIDL_DEFINE_GUID(IID, IID_ITransactionEvents,0x6287E875,0x9050,0x11d1,0x9D,0xCE,0x00,0xC0,0x4F,0xC2,0xFB,0xA2);


MIDL_DEFINE_GUID(IID, IID_ITxStreamInternal,0x4E31107F,0x8E81,0x11d1,0x9D,0xCE,0x00,0xC0,0x4F,0xC2,0xFB,0xA2);


MIDL_DEFINE_GUID(IID, IID_IRootTxStreamInternal,0x4E311080,0x8E81,0x11d1,0x9D,0xCE,0x00,0xC0,0x4F,0xC2,0xFB,0xA2);


MIDL_DEFINE_GUID(IID, IID_ITransactionProperty,0x788ea814,0x87b1,0x11d1,0xbb,0xa6,0x00,0xc0,0x4f,0xc2,0xfa,0x5f);


MIDL_DEFINE_GUID(IID, IID_IObjectContextTransaction,0x51372AEE,0xCAE7,0x11cf,0xBE,0x81,0x00,0xAA,0x00,0xA2,0xFA,0x25);


MIDL_DEFINE_GUID(IID, IID_ISecurityInternal,0xA71D9C69,0xAE37,0x11d1,0xB8,0x2B,0x00,0x00,0xF8,0x75,0x7E,0x2A);


MIDL_DEFINE_GUID(IID, IID_IContextProperties,0xD396DA85,0xBF8F,0x11d1,0xBB,0xAE,0x00,0xC0,0x4F,0xC2,0xFA,0x5F);


MIDL_DEFINE_GUID(IID, IID_IPackageControlInternal,0xB1B229B0,0xB77E,0x11d0,0x80,0x79,0x00,0xC0,0x4F,0xC2,0xF9,0xC1);


MIDL_DEFINE_GUID(IID, IID_IMTSPackageControl,0x51372af1,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IMTSPackage,0x9A83A958,0xB859,0x11d1,0xAA,0x90,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_IPauseResumeApp,0xE7228E0B,0xA708,0x4113,0x84,0xE8,0x23,0x9D,0xB1,0x2E,0x0D,0xB2);


MIDL_DEFINE_GUID(IID, IID_IThreadPoolKnobs,0x51372af7,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IComStaThreadPoolKnobs,0x324B64FA,0x33B6,0x11d2,0x98,0xB7,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComStaThreadPoolKnobs2,0x73707523,0xFF9A,0x4974,0xBF,0x84,0x21,0x08,0xDC,0x21,0x37,0x40);


MIDL_DEFINE_GUID(IID, IID_IFailfastControl,0x51372af8,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IThreadEvents,0x51372af9,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IThreadEventSource,0x51372afa,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_INonMTSActivation,0x51372afb,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IImpersonationControl,0x51372aff,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IMTSCall,0x51372AEF,0xCAE7,0x11CF,0xBE,0x81,0x00,0xAA,0x00,0xA2,0xFA,0x25);


MIDL_DEFINE_GUID(IID, IID_IMTSActivity,0x51372AF0,0xCAE7,0x11CF,0xBE,0x81,0x00,0xAA,0x00,0xA2,0xFA,0x25);


MIDL_DEFINE_GUID(IID, IID_IAssociation,0xFE454FF4,0xC5CF,0x11d1,0x93,0x96,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_IUserPropsInternal,0x2599BAB0,0xC5FB,0x11d1,0x93,0x96,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_ISTAPropStore,0xF4319F39,0xC523,0x11d1,0xA6,0x4E,0x00,0x00,0xF8,0x05,0xB4,0xB0);


MIDL_DEFINE_GUID(IID, IID_IPooledObj,0x7D8805A1,0x2EA7,0x11D1,0xB1,0xCC,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_IObjPool,0x7D8805A0,0x2EA7,0x11D1,0xB1,0xCC,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_ITransactionResourcePool,0xC5FEB7C1,0x346A,0x11D1,0xB1,0xCC,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_IPoolMgr,0xAA089089,0x3689,0x11D1,0xB1,0xCF,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_IPoolMgrPrivate,0x2BD0C880,0xD2E2,0x11d1,0x93,0x9A,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_ICRMClerk,0x53610480,0x9695,0x11D1,0x82,0xED,0x00,0xA0,0xC9,0x1E,0xED,0xE9);


MIDL_DEFINE_GUID(IID, IID_ICRMRecoveryClerk,0x46E4FA02,0x8789,0x4ab9,0x8A,0xD3,0x8C,0xF4,0x6B,0x84,0x59,0xC7);


MIDL_DEFINE_GUID(IID, IID_IClerksCollection,0x3ADEFFE3,0xC802,0x11D1,0x82,0xFB,0x00,0xA0,0xC9,0x1E,0xED,0xE9);


MIDL_DEFINE_GUID(IID, IID_IClrObjectFactory,0xecabafd2,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for svcintfs.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IAppTracker,0x9096B831,0x7472,0x11CF,0xBE,0x39,0x00,0xAA,0x00,0xA2,0xFA,0x25);


MIDL_DEFINE_GUID(IID, IID_IClassTrackerUpdate,0xea61e3c2,0x7c62,0x11cf,0xbe,0x3f,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IReceiveAppData,0x413dafb0,0xbcf4,0x11d1,0x86,0x1d,0x00,0x80,0xc7,0x29,0x26,0x4d);


MIDL_DEFINE_GUID(IID, IID_IGetAppData,0xb60040e0,0xbcf3,0x11d1,0x86,0x1d,0x00,0x80,0xc7,0x29,0x26,0x4d);


MIDL_DEFINE_GUID(IID, IID_ITrkSvrAppControl,0x6eb6ba78,0xbe49,0x4044,0x9f,0xe5,0x25,0xb9,0x83,0x80,0xca,0x3f);


MIDL_DEFINE_GUID(IID, IID_IProcessDump,0x23C9DD26,0x2355,0x4FE2,0x84,0xDE,0xF7,0x79,0xA2,0x38,0xAD,0xBD);


MIDL_DEFINE_GUID(IID, IID_IDispenserManager,0x5cb31e10,0x2b5f,0x11cf,0xbe,0x10,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IDispenserManagerShutdownGuarantee,0x5cb31e11,0x2b5f,0x11cf,0xbe,0x10,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IHolder,0xbf6a1850,0x2b45,0x11cf,0xbe,0x10,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IDispenserDriver,0x208b3651,0x2b48,0x11cf,0xbe,0x10,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IObjectContext,0x51372ae0,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IObjectControl,0x51372aec,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IEnumNames,0x51372af2,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_ISecurityProperty,0x51372aea,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_ObjectControl,0x7DC41850,0x0C31,0x11d0,0x8B,0x79,0x00,0xAA,0x00,0xB8,0xA7,0x90);


MIDL_DEFINE_GUID(IID, IID_ISharedProperty,0x2A005C01,0xA5DE,0x11CF,0x9E,0x66,0x00,0xAA,0x00,0xA3,0xF4,0x64);


MIDL_DEFINE_GUID(IID, IID_ISharedPropertyGroup,0x2A005C07,0xA5DE,0x11CF,0x9E,0x66,0x00,0xAA,0x00,0xA3,0xF4,0x64);


MIDL_DEFINE_GUID(IID, IID_ISharedPropertyGroupManager,0x2A005C0D,0xA5DE,0x11CF,0x9E,0x66,0x00,0xAA,0x00,0xA3,0xF4,0x64);


MIDL_DEFINE_GUID(IID, IID_IObjectConstruct,0x41C4F8B3,0x7439,0x11D2,0x98,0xCB,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IObjectConstructString,0x41C4F8B2,0x7439,0x11D2,0x98,0xCB,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IObjectContextActivity,0x51372afc,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IObjectContextInfo,0x75B52DDB,0xE8ED,0x11d1,0x93,0xAD,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_IObjectContextInfo2,0x594BE71A,0x4BC4,0x438b,0x91,0x97,0xCF,0xD1,0x76,0x24,0x8B,0x09);


MIDL_DEFINE_GUID(IID, IID_IObjectContextTip,0x92FD41CA,0xBAD9,0x11d2,0x9A,0x2D,0x00,0xC0,0x4F,0x79,0x7B,0xC9);


MIDL_DEFINE_GUID(IID, IID_IPlaybackControl,0x51372afd,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IGetContextProperties,0x51372af4,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IContextState,0x3C05E54B,0xA42A,0x11d2,0xAF,0xC4,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IPoolManager,0x0a469861,0x5a91,0x43a0,0x99,0xb6,0xd5,0xe1,0x79,0xbb,0x06,0x31);


MIDL_DEFINE_GUID(IID, IID_ISelectCOMLBServer,0xdcf443f4,0x3f8a,0x4872,0xb9,0xf0,0x36,0x9a,0x79,0x6d,0x12,0xd6);


MIDL_DEFINE_GUID(IID, IID_ICOMLBArguments,0x3a0f150f,0x8ee5,0x4b94,0xb4,0x0e,0xae,0xf2,0xf9,0xe4,0x2e,0xd2);


MIDL_DEFINE_GUID(IID, IID_ICrmLogControl,0xA0E174B3,0xD26E,0x11d2,0x8F,0x84,0x00,0x80,0x5F,0xC7,0xBC,0xD9);


MIDL_DEFINE_GUID(IID, IID_ICrmCompensatorVariants,0xF0BAF8E4,0x7804,0x11d1,0x82,0xE9,0x00,0xA0,0xC9,0x1E,0xED,0xE9);


MIDL_DEFINE_GUID(IID, IID_ICrmCompensator,0xBBC01830,0x8D3B,0x11d1,0x82,0xEC,0x00,0xA0,0xC9,0x1E,0xED,0xE9);


MIDL_DEFINE_GUID(IID, IID_ICrmMonitorLogRecords,0x70C8E441,0xC7ED,0x11d1,0x82,0xFB,0x00,0xA0,0xC9,0x1E,0xED,0xE9);


MIDL_DEFINE_GUID(IID, IID_ICrmMonitorClerks,0x70C8E442,0xC7ED,0x11d1,0x82,0xFB,0x00,0xA0,0xC9,0x1E,0xED,0xE9);


MIDL_DEFINE_GUID(IID, IID_ICrmMonitor,0x70C8E443,0xC7ED,0x11d1,0x82,0xFB,0x00,0xA0,0xC9,0x1E,0xED,0xE9);


MIDL_DEFINE_GUID(IID, IID_ICrmFormatLogRecords,0x9C51D821,0xC98B,0x11d1,0x82,0xFB,0x00,0xA0,0xC9,0x1E,0xED,0xE9);


MIDL_DEFINE_GUID(IID, IID_IPhase0Notify,0x0199706C,0x7B3E,0x11d2,0x99,0xFB,0x00,0xC0,0x4F,0x79,0x7B,0xC9);


MIDL_DEFINE_GUID(IID, IID_IRegisterPhase0,0x0199706D,0x7B3E,0x11d2,0x99,0xFB,0x00,0xC0,0x4F,0x79,0x7B,0xC9);


MIDL_DEFINE_GUID(IID, IID_IActivationEvents,0x788ea812,0x87b1,0x11d1,0xbb,0xa6,0x00,0xc0,0x4f,0xc2,0xfa,0x5f);


MIDL_DEFINE_GUID(IID, IID_IJITActivationProperty,0x788ea813,0x87b1,0x11d1,0xbb,0xa6,0x00,0xc0,0x4f,0xc2,0xfa,0x5f);


MIDL_DEFINE_GUID(IID, IID_ICallContextNotify,0x51372aeb,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IActivity,0xC3813A4A,0xCE3A,0x11d1,0x93,0x9A,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_ITransactionStream,0x97199110,0xDB2E,0x11d1,0xA2,0x51,0x00,0x00,0xF8,0x05,0xCA,0x53);


MIDL_DEFINE_GUID(IID, IID_ITransactionEvents,0x6287E875,0x9050,0x11d1,0x9D,0xCE,0x00,0xC0,0x4F,0xC2,0xFB,0xA2);


MIDL_DEFINE_GUID(IID, IID_ITxStreamInternal,0x4E31107F,0x8E81,0x11d1,0x9D,0xCE,0x00,0xC0,0x4F,0xC2,0xFB,0xA2);


MIDL_DEFINE_GUID(IID, IID_IRootTxStreamInternal,0x4E311080,0x8E81,0x11d1,0x9D,0xCE,0x00,0xC0,0x4F,0xC2,0xFB,0xA2);


MIDL_DEFINE_GUID(IID, IID_ITransactionProperty,0x788ea814,0x87b1,0x11d1,0xbb,0xa6,0x00,0xc0,0x4f,0xc2,0xfa,0x5f);


MIDL_DEFINE_GUID(IID, IID_IObjectContextTransaction,0x51372AEE,0xCAE7,0x11cf,0xBE,0x81,0x00,0xAA,0x00,0xA2,0xFA,0x25);


MIDL_DEFINE_GUID(IID, IID_ISecurityInternal,0xA71D9C69,0xAE37,0x11d1,0xB8,0x2B,0x00,0x00,0xF8,0x75,0x7E,0x2A);


MIDL_DEFINE_GUID(IID, IID_IContextProperties,0xD396DA85,0xBF8F,0x11d1,0xBB,0xAE,0x00,0xC0,0x4F,0xC2,0xFA,0x5F);


MIDL_DEFINE_GUID(IID, IID_IPackageControlInternal,0xB1B229B0,0xB77E,0x11d0,0x80,0x79,0x00,0xC0,0x4F,0xC2,0xF9,0xC1);


MIDL_DEFINE_GUID(IID, IID_IMTSPackageControl,0x51372af1,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IMTSPackage,0x9A83A958,0xB859,0x11d1,0xAA,0x90,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_IPauseResumeApp,0xE7228E0B,0xA708,0x4113,0x84,0xE8,0x23,0x9D,0xB1,0x2E,0x0D,0xB2);


MIDL_DEFINE_GUID(IID, IID_IThreadPoolKnobs,0x51372af7,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IComStaThreadPoolKnobs,0x324B64FA,0x33B6,0x11d2,0x98,0xB7,0x00,0xC0,0x4F,0x8E,0xE1,0xC4);


MIDL_DEFINE_GUID(IID, IID_IComStaThreadPoolKnobs2,0x73707523,0xFF9A,0x4974,0xBF,0x84,0x21,0x08,0xDC,0x21,0x37,0x40);


MIDL_DEFINE_GUID(IID, IID_IFailfastControl,0x51372af8,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IThreadEvents,0x51372af9,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IThreadEventSource,0x51372afa,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_INonMTSActivation,0x51372afb,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IImpersonationControl,0x51372aff,0xcae7,0x11cf,0xbe,0x81,0x00,0xaa,0x00,0xa2,0xfa,0x25);


MIDL_DEFINE_GUID(IID, IID_IMTSCall,0x51372AEF,0xCAE7,0x11CF,0xBE,0x81,0x00,0xAA,0x00,0xA2,0xFA,0x25);


MIDL_DEFINE_GUID(IID, IID_IMTSActivity,0x51372AF0,0xCAE7,0x11CF,0xBE,0x81,0x00,0xAA,0x00,0xA2,0xFA,0x25);


MIDL_DEFINE_GUID(IID, IID_IAssociation,0xFE454FF4,0xC5CF,0x11d1,0x93,0x96,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_IUserPropsInternal,0x2599BAB0,0xC5FB,0x11d1,0x93,0x96,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_ISTAPropStore,0xF4319F39,0xC523,0x11d1,0xA6,0x4E,0x00,0x00,0xF8,0x05,0xB4,0xB0);


MIDL_DEFINE_GUID(IID, IID_IPooledObj,0x7D8805A1,0x2EA7,0x11D1,0xB1,0xCC,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_IObjPool,0x7D8805A0,0x2EA7,0x11D1,0xB1,0xCC,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_ITransactionResourcePool,0xC5FEB7C1,0x346A,0x11D1,0xB1,0xCC,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_IPoolMgr,0xAA089089,0x3689,0x11D1,0xB1,0xCF,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_IPoolMgrPrivate,0x2BD0C880,0xD2E2,0x11d1,0x93,0x9A,0x00,0xAA,0x00,0xBA,0x32,0x58);


MIDL_DEFINE_GUID(IID, IID_ICRMClerk,0x53610480,0x9695,0x11D1,0x82,0xED,0x00,0xA0,0xC9,0x1E,0xED,0xE9);


MIDL_DEFINE_GUID(IID, IID_ICRMRecoveryClerk,0x46E4FA02,0x8789,0x4ab9,0x8A,0xD3,0x8C,0xF4,0x6B,0x84,0x59,0xC7);


MIDL_DEFINE_GUID(IID, IID_IClerksCollection,0x3ADEFFE3,0xC802,0x11D1,0x82,0xFB,0x00,0xA0,0xC9,0x1E,0xED,0xE9);


MIDL_DEFINE_GUID(IID, IID_IClrObjectFactory,0xecabafd2,0x7f19,0x11d2,0x97,0x8e,0x00,0x00,0xf8,0x75,0x7e,0x2a);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\svcguid\volpmidl_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for volpmidl.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IVolatilePolicyManager,0x9211A2CA,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for volpmidl.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IVolatilePolicyManager,0x9211A2CA,0x7B10,0x11D1,0x86,0x33,0x00,0x60,0x08,0x9F,0x60,0x07);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\svcguid\vsevfire_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for vsevfire.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ISystemDebugEventFire,0x6c736dC1,0xAB0D,0x11d0,0xA2,0xAD,0x00,0xA0,0xC9,0x0F,0x27,0xE8);


MIDL_DEFINE_GUID(IID, IID_ISystemDebugEventFireAuto,0x6c736dee,0xAB0e,0x11d0,0xA2,0xAD,0x00,0xA0,0xC9,0x0F,0x27,0xE8);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for vsevfire.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ISystemDebugEventFire,0x6c736dC1,0xAB0D,0x11d0,0xA2,0xAD,0x00,0xA0,0xC9,0x0F,0x27,0xE8);


MIDL_DEFINE_GUID(IID, IID_ISystemDebugEventFireAuto,0x6c736dee,0xAB0e,0x11d0,0xA2,0xAD,0x00,0xA0,0xC9,0x0F,0x27,0xE8);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\svcguid\txctx_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for txctx.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ITransactionContextEx,0x7999FC22,0xD3C6,0x11CF,0xAC,0xAB,0x00,0xA0,0x24,0xA5,0x5A,0xEF);


MIDL_DEFINE_GUID(IID, IID_ITransactionContext,0x7999FC21,0xD3C6,0x11CF,0xAC,0xAB,0x00,0xA0,0x24,0xA5,0x5A,0xEF);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0344 */
/* Compiler settings for txctx.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ITransactionContextEx,0x7999FC22,0xD3C6,0x11CF,0xAC,0xAB,0x00,0xA0,0x24,0xA5,0x5A,0xEF);


MIDL_DEFINE_GUID(IID, IID_ITransactionContext,0x7999FC21,0xD3C6,0x11CF,0xAC,0xAB,0x00,0xA0,0x24,0xA5,0x5A,0xEF);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\stuff\vbajet32\vbajet32.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    vbajet32.c

Abstract:

   This module implements stub functions for shell32 interfaces.

Author:

    David N. Cutler (davec) 11-Jun-2001

Environment:

    Kernel mode only.

Revision History:

--*/

#include "windows.h"

#define STUBFUNC(x)     \
int                     \
x(                      \
    void                \
    )                   \
{                       \
    return 0;           \
}

STUBFUNC(LoadExprSrvDll)
STUBFUNC(VBAGetExprSrv)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\bndist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       bndist.h
//
//--------------------------------------------------------------------------

//
//	bndist.h: Belief Network Distributions
//

#ifndef _BNDIST_H_
#define _BNDIST_H_

#include "mddist.h"

////////////////////////////////////////////////////////////////////
//	class BNDIST:  
//
//		Base class for probability distributions used in belief networks.  
//
//		This is a reference counted object which usually lives in the 
//		distribution map of an MBNET.
//
//		However, BNDISTs are also created for various other purposes
//		such as CI network expansion.  In these cases, the BNDIST
//		is automatically deleted when the reference count goes to zero.
//		See BNDIST::NoRef().
//
////////////////////////////////////////////////////////////////////
class BNDIST : public REFCNT
{
	friend class DSCPARSER;
  public:
	BNDIST ();
	~ BNDIST ();
	BNDIST ( const BNDIST & bnd );

	enum EDIST
	{
		ED_NONE,			//  illegal value
		ED_DENSE,			//  lowest enum value for a dense distribution
		ED_SPARSE,			//  lowest enum value for a	sparse distribution
		ED_CI_MAX,			//  therefore, CI "max" is sparse
		ED_CI_PLUS,			//		as is CI "plus"
		ED_MAX				//  first unused value
	};
	EDIST Edist () const	
		{ return _edist; }

	BNDIST & operator = ( const BNDIST & bnd );

	//  Set distribution to "dense"
	void SetDense ( const VIMD & vimd );
	//  Set distribution to sparse
	void SetSparse ( const VIMD & vimd );

	static bool BDenseType ( EDIST edist )
		{ return edist >= ED_DENSE && edist < ED_SPARSE ; }
	static bool BSparseType ( EDIST edist )
		{  return edist >= ED_SPARSE && edist < ED_MAX ; }

	bool BDense () const
		{ return BDenseType( Edist() ); }
	bool BSparse () const
		{  return BSparseType( Edist() ); }

	bool BChangeSubtype ( EDIST edist );

	//  Convert a dense representation to a sparse one
	void ConvertToDense ( const VIMD & vimd );

	void Clear ()
	{
		delete _pmdvcpd;
		_pmdvcpd = NULL;
		delete _mpcpdd;
		_mpcpdd = NULL;
	}

	MDVCPD & Mdvcpd ()
	{	
		assert( _pmdvcpd );
		return *_pmdvcpd ;
	}
	const MDVCPD & Mdvcpd () const
	{	
		assert( _pmdvcpd );
		return *_pmdvcpd ;
	}

	MPCPDD & Mpcpdd ()
	{
		assert( _mpcpdd );
		return *_mpcpdd;
	}
 	const MPCPDD & Mpcpdd () const
	{
		assert( _mpcpdd );
		return *_mpcpdd;
	}
	const VIMD & VimdDim () const
		{ return _vimdDim; }

	//  Return the "leak" or "default" vector for a sparse distribution
	const VLREAL * PVlrLeak () const;

	void Dump();
	void Clone ( const BNDIST & bndist );

	LEAK_VAR_ACCESSOR

 protected:
	EDIST _edist;				// Type of distribution
	MDVCPD * _pmdvcpd;			// Ptr to dense m-d array
	MPCPDD * _mpcpdd;			// Ptr to sparse array
	VIMD _vimdDim;				// Dense dimensionality

	//  Called when object's reference count goes to zero
	void NoRef ();

	//  Dumper functions
	void DumpSparse();
	void DumpDense();

	LEAK_VAR_DECL
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\basics.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       basics.h
//
//--------------------------------------------------------------------------

//
//	BASICS.H:  Basic STL-based declarations
//

#ifndef _BASICS_H_
#define _BASICS_H_

// handle version differences
#include "mscver.h"

#include <tchar.h>
// STL Inclusions
#include <exception>
#include <vector>

USE_STD_NAMESPACE;


//	General common typedefs
typedef TCHAR * TZC;
typedef const TCHAR * TSZC;
typedef const char * SZC;
typedef char * SZ;
typedef unsigned int UINT;
typedef unsigned short USINT;
typedef unsigned long ULONG;
typedef long	LONG;
typedef int		INT;
typedef short	SINT;
typedef double	REAL;
typedef double	DBL;
typedef double	PROB;
typedef double  COST;
typedef double	SSTAT;
typedef	double	PARAM;
typedef double  MEAN;
typedef double	COV;
typedef	double	LOGPROB;
typedef UINT	IDPI;		// 2^n, last-fastest (I)ndex indicating a (D)iscrete
							//	(P)arent (I)nstance

//  Define array indexing values and discrete state counting values identically
typedef UINT	IMD;		// Index into a multidimensional array
typedef UINT	CST;		// Count of states
typedef UINT	IST;		// Index of a discrete state
typedef INT		SIMD;		// Signed index into a multidimensonal array
typedef	float	RST;		// Real-valued state
typedef UINT	TOKEN;		// Parser token
typedef int		BOOL;		// Must remain int, because windows.h defines it also
							
#ifndef VOID
#define VOID	void		// MSRDEVBUG: Archaic usage
#endif

typedef char	CHAR;
//  'qsort' interface function prototypedef
typedef	INT		(*PFNCMP)(const VOID*, const VOID*);

#define CONSTANT static const					//  define a program-scoped constant

//  General constants
CONSTANT INT	INIL		= INT_MAX;			//  Invalid signed integer
CONSTANT UINT	UINIL		= INT_MAX;			//  Invalid unsigned integer (compatible with int)
CONSTANT long	INFINITY	= 100000000;		//  A very large integer value
CONSTANT REAL	RTINY		= 1.0e-20;			//  A number very close to zero (from Numerical Recipies)
CONSTANT REAL	RNEARLYONE	= 1.0 - RTINY;		//  A number very close to one
CONSTANT REAL   RNA			= -1.0;				//  "unassessed" value

//	Database constant values
CONSTANT IST	istMissing	= 22223;
CONSTANT IST	istInvalid	= IST(-1);			//  MSRDEVBUG: should be UINIL
CONSTANT RST	rstMissing	= (RST) 22223.12345;
CONSTANT RST	rstInvalid	= (RST) 22223.54321;


// A useful alias in member functions
#define self (*this)

//  Define common vector classes and macros to generalize declarations.

typedef vector<bool> vbool;		//  Vector of 'bool': lower case to distinguish from BOOL (in windows.h)

#define DEFINEV(T)		typedef vector<T> V##T;
#define DEFINEVP(T)		typedef vector<T *> VP##T;
#define DEFINEVCP(T)	typedef vector<const T *> VCP##T;

DEFINEV(UINT);		// Define VUINT
DEFINEV(VUINT);
DEFINEV(INT);		// Define VINT
DEFINEV(USINT);		// Define VUSINT
DEFINEV(REAL);		// Define VREAL
DEFINEV(PROB);	
DEFINEV(VPROB);	
DEFINEV(DBL);
DEFINEV(VDBL);
DEFINEV(VVDBL);
DEFINEV(SSTAT);
DEFINEV(VSSTAT);
DEFINEV(CST);
DEFINEV(VCST);
DEFINEV(IST);
DEFINEV(VIST);
DEFINEV(RST);
DEFINEV(BOOL);
DEFINEV(VBOOL);
DEFINEV(PARAM);
DEFINEV(SZ);
DEFINEV(VSZ);
DEFINEV(SZC);
DEFINEV(VSZC);
DEFINEV(MEAN);
DEFINEV(COV);
DEFINEV(IMD);		// Define VIMD: vector of indicies into an m-d array
DEFINEV(SIMD);		// Define VSIMD: for an array of SIGNED dimensions

//  Macro to control hiding of unsafe elements
#ifndef DONT_HIDE_ALL_UNSAFE
  #define HIDE_UNSAFE(T)				\
	private:							\
		T(const T &);					\
		T & operator = (const T &);
  #define HIDE_AS(T) private: T & operator = (const T &);
  #define HIDE_CC(T) T(const T &);	
#else
  #define HIDE_UNSAFE(T)
#endif


//  Macro to generate the ordering operators which must be declared
//	for use in arrays but which do not need to exist unless used.
#define DECLARE_ORDERING_OPERATORS(T)				\
	bool operator <  ( const T & ) const;			\
	bool operator >  ( const T & ) const;			\
	bool operator == ( const T & ) const;			\
	bool operator != ( const T & ) const;

//
//	UBOUND: macro to return the number of elements in a static array
//
#ifndef UBOUND
  #define UBOUND(rg)  (sizeof rg/sizeof rg[0])
#endif

#include "gmexcept.h"
#include "dyncast.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\algos.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       algos.h
//
//--------------------------------------------------------------------------

//
//   algos.h: additions to <algorithms>
//  

#ifndef _ALGOS_H_
#define _ALGOS_H_

#include "mscver.h"

#include <vector>
#include <valarray>
#include <algorithm>
#include <functional>
#include <assert.h>

using namespace std;

////////////////////////////////////////////////////////////////////////////////////
//
//	Extensions to (plagarisms from) "algorithm" templates
//
////////////////////////////////////////////////////////////////////////////////////

// Template Function count_set_intersection()
//		Return the number of elements in common between two ORDERED sets.
//		Elements must support operator<.
//
//   Usage:  count_set_intersection ( iter_beg_1, iter_end_1, iter_beg_2, iter_end_2 );
//
template<class _II1, class _II2> inline
int count_set_intersection(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2)
{
	for (int _C=0; _F1 != _L1 && _F2 != _L2; )
	{
		if (*_F1 < *_F2)
			++_F1;
		else if (*_F2 < *_F1)
			++_F2;
		else
			++_F1, ++_F2, ++_C;
	}
	return _C; 
}

// Template Function count_set_intersection() with predicate.  Same as above;
//		a predicate function is used to determine ordering; must behave as 
//		operator<.
template<class _II1, class _II2, class _Pr> inline
int count_set_intersection(_II1 _F1, _II1 _L1, _II2 _F2, _II2 _L2, _Pr _P)
{
	for (int _C=0; _F1 != _L1 && _F2 != _L2; )
	{
		if (_P(*_F1, *_F2))
			++_F1;
		else if (_P(*_F2, *_F1))
			++_F2;
		else
			++_F1, ++_F2, ++_C;
	}
	return _C; 
}


//  Template function ifind().  
//		Return the index of an item in a vector or -1 if not found.
template <class _VT, class _T>
int ifind ( const _VT & vt, _T t )
{
	_VT::const_iterator vtibeg = vt.begin();
	_VT::const_iterator vtiend = vt.end();
	_VT::const_iterator vtiter = find( vtibeg, vtiend, t );
	return vtiter == vtiend
		 ? -1 
		 : vtiter - vtibeg;
}


// Template function pexchange().
//		Exchange contents of a pair of pointers
template<class _T> 
void pexchange ( _T * & pta, _T * & ptb )
{
	_T * ptt = pta;
	pta = ptb;
	ptb = ptt;
}

//  Template function vswap(). 
//		Swap elements of a vector
template<class _T>
void vswap ( vector<_T> & vt, int ia, int ib )
{
	assert( ia < vt.size() );
	assert( ib < vt.size() );
	if ( ia != ib )
	{
		_T tt = vt[ia];
		vt[ia] = vt[ib];
		vt[ib] = tt;
	}
}

// Template function appendset(). 
//		Append to vector-based set (add if not present)
template <class _T>
bool appendset ( vector<_T> & vt, _T t )
{
	if ( ifind( vt, t ) >= 0 )
		return false;
	vt.push_back(t);
	return true;	
}

//  Template function vclear().
//		Clear a valarray or vector to a single value
template <class _VT, class _T>
_VT & vclear ( _VT & vt, const _T & t )
{
	for ( int i = 0; i < vt.size(); )
		vt[i++] = t;
	return vt;
}

//  Template function vdup().
//		Duplicate a valarray or vector from one or the other
template <class _VTA, class _VTB>
_VTA & vdup ( _VTA & vta, const _VTB & vtb )
{
	vta.resize( vtb.size() );
	for ( int i = 0; i < vta.size(); i++ )
		vta[i] = vtb[i];
	return vta;
}

//	Template function vequal()
//		Compare valarrays or vectors for equality
template <class _VTA, class _VTB>
bool vequal ( _VTA & vta, const _VTB & vtb )
{
	if ( vta.size() != vtb.size() ) 
		return false;

	for ( int i = 0; i < vta.size(); i++ )
	{
		if ( vta[i] != vtb[i] )
			return false;
	}
	return true;
}

//  Template function vdimchk()
//		Treating the first argument as a subscript vector
//		and the second as a vector of dimensions, return true
//		if the subscript vector is valid for the space.
template <class _VTA, class _VTB>
bool vdimchk ( const _VTA & vta, const _VTB & vtb )
{
	if ( vta.size() != vtb.size() ) 
		return false;

	for ( int i = 0; i < vta.size(); i++ )
	{
		if ( vta[i] >= vtb[i] )
			return false;
	}
	return true;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\bndist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       bndist.cpp
//
//--------------------------------------------------------------------------

//
//	BNDIST.CPP
//

#include <basetsd.h>
#include <iostream>
#include <fstream>

#include "symtmbn.h"

LEAK_VAR_DEF(BNDIST)

static void dumpVimd ( const VIMD & vimd )
{
	for ( int i = 0 ; i < vimd.size(); i++ )
	{
		cout << vimd[i];
		if ( i + 1 < vimd.size() )
			cout << ",";
	}	
}

static void dumpVlr ( const VLREAL & vlr )
{
	for ( int i = 0 ; i < vlr.size(); i++ )
	{
		cout << vlr[i];
		if ( i + 1 < vlr.size() )
			cout << ",";
	}	
}

static void dumpSlice ( const MDVSLICE & mslice, bool bStrides = true)
{
	VIMD vimdLengths = mslice.size();
	VIMD vimdStrides = mslice.stride();
	size_t iStart = mslice.start();

	cout << "\nslice start="
		 << (UINT) iStart
		 << "\tlengths=";
	dumpVimd( vimdLengths );
	if ( bStrides )
	{
		cout << "\tstrides=" ;
		dumpVimd( vimdStrides );
	}
	cout << "\ttotlen="
		 << (UINT) mslice._Totlen();
}

static void dumpMdv ( MDVCPD & mdv, const MDVSLICE * pslice = NULL )
{	
	if ( pslice == NULL )
		pslice = & mdv.Slice();
	dumpSlice( *pslice );
	MDVCPD::Iterator itmd(mdv, *pslice );
	while (itmd.BNext())
	{
		size_t icurr = itmd.ICurr();
		cout << "\n";
		dumpVimd( itmd.Vitmd() );
		REAL & r = itmd.Next();
		cout << "\t["
			<< (UINT) icurr
			<< "] = "
			<< r ;
	}
	cout << "\n";
}

BNDIST :: BNDIST ()
	:_edist(ED_NONE),
	_pmdvcpd(NULL),
	_mpcpdd(NULL)
{
	LEAK_VAR_UPD(1)
}

BNDIST :: ~ BNDIST ()
{
	Clear();
	LEAK_VAR_UPD(-1)
}

void BNDIST :: NoRef ()
{
	delete this;
}

BNDIST & BNDIST :: operator = ( const BNDIST & bnd )
{
	Clear();
	switch ( _edist = bnd._edist )
	{
		default:
		case ED_NONE:
			break;
		case ED_DENSE:
			_pmdvcpd = new MDVCPD( bnd.Mdvcpd() );
			assert( _pmdvcpd->first.size() == bnd.Mdvcpd().first.size() );
			break;
		case ED_CI_MAX:
		case ED_CI_PLUS:
		case ED_SPARSE:
			_mpcpdd = new MPCPDD( bnd.Mpcpdd() ) ;
			assert( _mpcpdd->size() == bnd.Mpcpdd().size() );
			break;			
	}
	return self;
}

BNDIST :: BNDIST ( const BNDIST & bnd )
	:_edist(ED_NONE),
	_pmdvcpd(NULL),
	_mpcpdd(NULL)
{
	(*this) = bnd;

	LEAK_VAR_UPD(1)
}

bool BNDIST :: BChangeSubtype ( EDIST edist )
{
	if ( BDenseType(edist) ^ BDense() )
		return false;
	_edist = edist;
	return true;
}

void BNDIST :: Dump ()
{
	if ( _pmdvcpd )
	{
		cout << "\n\tDense version:";
		DumpDense();
	}
	if ( _mpcpdd )
	{
		cout << "\n\tSparse version:";
		DumpSparse();
	}
	cout << "\n\n";
}

void BNDIST :: DumpSparse ()
{
	assert( _mpcpdd );
	MPCPDD & dmap = *_mpcpdd;
	int i = 0;
	for ( MPCPDD::iterator itdm = dmap.begin();
		  itdm != dmap.end();
		  ++itdm, ++i )
	{
		const VIMD & vimd = (*itdm).first;
		const VLREAL & vlr = (*itdm).second;
		cout << "\n["
			 << i
			 << "] (";
		dumpVimd(vimd);
		cout << ")\t";
		dumpVlr(vlr);
	}
}

void BNDIST :: DumpDense ()
{
	assert( _pmdvcpd );
	dumpMdv( *_pmdvcpd );
}

void BNDIST :: ConvertToDense ( const VIMD & vimd )
{
	assert( _edist == ED_NONE || _edist == ED_SPARSE );

	if ( _edist == ED_NONE )
	{
		assert( ! _mpcpdd );
		return;
	}
	//  See if there is a sparse distribution to convert
	if ( ! _mpcpdd )
		throw GMException( EC_DIST_MISUSE, "no prior sparse distribution to convert" );

	int cParent = vimd.size() - 1;
	int cState = vimd[cParent];
	MPCPDD & dmap = *_mpcpdd;
	VIMD vimdMt;					//  Empty subscript array
	VLREAL vlrDefault(cState);		//	Default value array

	//  First, try to find the default entry; use -1 if not found
	MPCPDD::iterator itdm = dmap.find(vimdMt);
	if ( itdm != dmap.end() )
		vlrDefault = (*itdm).second;
	else
		vlrDefault = -1;	// fill the array with -1.

	assert( vlrDefault.size() == cState );

	//  Allocate the new dense m-d array
	delete _pmdvcpd;
	_pmdvcpd = new MDVCPD( vimd );
	MDVCPD & mdv = *_pmdvcpd;
	//  Fill each DPI with the appropriate default value
	MDVCPD::Iterator itmdv(mdv);
	for ( int iState = 0; itmdv.BNext() ; iState++ )
	{
		itmdv.Next() = vlrDefault[ iState % cState ];
	}
	
	//
	//  Now, iterate over the sparse array and store in the appropriate locations.
	//	Each entry in the sparse map is a complete state set for the target node.
	//  Since the child (target) node probabilities are the fastest varying subscript,
	//  each entry in sparse map is spread across "cState" entries in the dense map.
	//	
	//	Of course, this could be more efficient, but we're just testing for now.
	//
	VIMD vimdDense(vimd.size());
	for ( itdm = dmap.begin(); itdm != dmap.end() ; ++itdm )
	{
		const VIMD & vimdSub = (*itdm).first;
		VLREAL & vlrNext = (*itdm).second;
		for ( int ip = 0 ; ip < cParent; ip++ )
		{
			vimdDense[ip] = vimdSub[ip];
		}
		for ( int ist = 0 ; ist < cState; ++ist )
		{
			vimdDense[cParent] = ist;
			mdv[vimdDense] = vlrNext[ist];
		}
	}
	
	//  Finally, nuke the old sparse distribution
	delete _mpcpdd;
	_mpcpdd = NULL;
	//  Set distribution type
	_edist = ED_DENSE;
}

//  Set distribution to "dense"
void BNDIST :: SetDense ( const VIMD & vimd )
{
	Clear();
	_vimdDim = vimd;
	_pmdvcpd = new MDVCPD( vimd );
	_edist = ED_DENSE;
}

//  Set distribution to sparse
void BNDIST :: SetSparse ( const VIMD & vimd )
{
	Clear();
	_vimdDim = vimd;
	_mpcpdd = new MPCPDD;
	_edist = ED_SPARSE;
}

//  Return the "leak" or "default" vector from a sparse distribution
const VLREAL * BNDIST :: PVlrLeak () const
{
	assert( BSparse() );
	const MPCPDD & dmap = Mpcpdd();
	const VIMD & vimdDim = VimdDim();
	VIMD vimdLeak;

	//  First try to find the dimensionless "default" vector.
	const VLREAL * pvlrDefault = dmap.PVlrDefault();

	//  Now try to find a specific zeroth vector; note that valarray<T>::resize
	//		stores all zeroes into the valarray by default.  Also, skip the
	//		loweest dimension, since that's the size of each vector in the
	//		sparse map.
	vimdLeak.resize( vimdDim.size() - 1 );	
	const VLREAL * pvlrLeak = NULL;
	MPCPDD::const_iterator itdm = dmap.find( vimdLeak );
	if ( itdm != dmap.end() )
		pvlrLeak = & (*itdm).second;

	return pvlrLeak
		 ? pvlrLeak
		 : pvlrDefault;
}

void BNDIST :: Clone ( const BNDIST & bndist )
{
	ASSERT_THROW( _edist == ED_NONE,
			EC_INVALID_CLONE,
			"cannot clone into non-empty structure" );
	self = bndist;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\bnparse.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       bnparse.cpp
//
//--------------------------------------------------------------------------

//
//	BNPARSE.CPP
//
#include <windows.h>
#include <stdarg.h>
#include <assert.h>

#include "bnparse.h"
#include "bnreg.h"

DSCPARSER :: DSCPARSER (
	MBNET & mbnet,
	PARSIN & flpIn,
	PARSOUT & _flpOut )
	: _flpIn( flpIn ),
	_flpOut( _flpOut ),
	_mbnet(mbnet),
	_cchToken(0),
	_iLine(1),
	_cError(0),
	_cWarning(0),
	_bUngetToken(false),
	_cerrorNode(0),
	_pnode(NULL),
	_bCI(false),
	_edist(BNDIST::ED_NONE),
	_bDefault(false),
	_idpi(0),
	_cdpi(0),
	_idpiLast(-1),
	_chCur(' '),
	_chUnget(0),
	_tokenCur(tokenNil),
	_bPropDefs(false),
	_cNode(0),
	_eBlk(EBLKNONE),
	_ppropMgr(NULL),
	_elbl(ESTDLBL_other),
	_ilimNext(-1)
{
	ResetParser();
}

DSCPARSER :: ~ DSCPARSER ()
{
	ResetParser();
}

bool    DSCPARSER :: BInitOpen( SZC szcFile )
{
	return _flpIn.Open( szcFile, "rt" );
}

//  Clear the string references from the parser.   Since our
//  definition of YYSTYPE contains a ZSREF, we must reset the
//  contents of all such structures so that the MBNET's symbol
//  table can be destroyed at any time.
void	DSCPARSER :: ResetParser ()
{
	_vchToken.resize( _cchTokenMax + 1 );

	//  Clear all ZSREF information maintained by the parser token ensemble
	yyval.zsr.Clear();	
	yylval.zsr.Clear();
	for ( int i = 0; i < YYMAXDEPTH; )
	{
		yyv[i++].zsr.Clear();
	}

	//  Do normal member variable clearing
	_chUnget = 0;
	_bUngetToken = false;
	delete _ppropMgr;
	_ppropMgr = NULL;
}

bool	DSCPARSER :: BParse ( UINT & cError, UINT & cWarning )
{
	bool bResult = YaccParse() == 0 && _cError == 0;

	cError = _cError;
	cWarning = _cWarning;

	//  Mark the model as having topology
	Mbnet().BSetBFlag( EIBF_Topology );

	ResetParser();
	
	_flpOut.Flush();

	return bResult;
}

GOBJMBN *	DSCPARSER :: PbnobjFind ( SZC szcName )
{
	return Mpsymtbl().find(szcName);
}

GNODEMBND *  DSCPARSER::PgndbnFind (SZC szc)
{
	GOBJMBN * pbnobj = PbnobjFind(szc);	
	if ( pbnobj == NULL )
		return NULL;
	INT ebno = pbnobj->EType() ;
	if ( ebno != GOBJMBN::EBNO_NODE )
		return NULL;
	GNODEMBND * pgndd;
	DynCastThrow(pbnobj,pgndd);
	return pgndd;
}

bool  DSCPARSER :: BChNext()
{
	if ( _chUnget > 0 )
	{
		_chCur = _chUnget;
		_chUnget = 0;
	}
	else
	{
		_chCur = (char)_flpIn.Getch();
	}
    if ( _chCur == '\n')
          _iLine++;
    return bool(_chCur != EOF);
}


void    DSCPARSER :: SkipWS()        //  skip white space
{
    while (isspace(_chCur) && BChNext());
}

void    DSCPARSER :: SkipToEOL()
{
    while (_chCur != '\n'  && BChNext());
}

//
//	Add a character to a normal token; if overlength, truncate.
//
void    DSCPARSER :: AddChar ( TCHAR tch )
{
	int cch = _vchToken.size() - 2;

    if ( _cchToken < cch )
	{
        _vchToken[_cchToken]	= tch ? tch : _chCur;
		_vchToken[_cchToken+1]	= 0;
	}
	//  Add to scanned length to report overlength token
    _cchToken++;
}

//
//	Add a character to a string token; do not truncate.
//
void    DSCPARSER :: AddCharStr ( TCHAR tch )
{
	int cch = _vchToken.size() - 2;

    if ( _cchToken >= cch )
	{
		_vchToken.resize( 2 * _vchToken.size() );
	}

    _vchToken[_cchToken]	= tch ? tch : _chCur;
	_vchToken[_cchToken+1]	= 0;
    _cchToken++;
}

char    DSCPARSER :: ChEscape()
{
    BChNext();

    switch (_chCur)
    {
      case 'n':
        return '\n';

      case 't':
        return '\t';

      case 'v':
        return '\v';

      case 'b':
        return '\b';

      case 'r':
        return '\r';

      case 'f':
        return '\f';

      case 'a':
        return '\a';

      default:
        return _chCur;
    }
}


void    DSCPARSER :: CloseIdentifier()
{
	if ( ! MBNET::BSzLegal( SzcToken() ) )
        Error("identifier \'%s\' is not legal", SzcToken() );
	CloseToken("identifier");
}

void    DSCPARSER :: CloseToken(SZC szcTokenType)
{
    if (_cchToken >= _cchTokenMax)
    {
        Warning("%s of length %u exceeded maximum length %u",
                szcTokenType, _cchToken, _cchTokenMax);
    }
}


TOKEN   DSCPARSER :: TokenKeyword()
{
	//  See if the captured token is a keyword
    TOKEN token = MBNETDSC::TokenFind( SzcToken() );	
    if ( token != tokenNil )
        return token;

	//  Intern the symbol
    yylval.zsr = Mpsymtbl().intern( SzcToken() );

	//  See if it's a property type
	GOBJMBN * pbnobj = PbnobjFind(yylval.zsr);
	if ( pbnobj && pbnobj->EType() == GOBJMBN::EBNO_PROP_TYPE )
		return tokenPropIdent;

	//  It's an identifier
    return tokenIdent;
}

void	DSCPARSER::ErrorWarn ( bool bErr, SZC szcFormat, va_list & valist )
{
	SZC szcType = bErr
				? "error"
				: "warning" ;

	if ( bErr )
		_cError++;
	else
		_cWarning++;

	int iLine =	_chCur != '\n'
			   ? _iLine
			   : _iLine - 1;

	_flpOut.Fprint("\n%s(%u) %s: ", _flpIn.ZsFn().Szc(), iLine, szcType);
    _flpOut.Vsprint(szcFormat, valist);
	_flpOut.ErrWarn( bErr, iLine );
	_flpOut.Flush();
}

void    DSCPARSER::ErrorWarn( bool bErr, SZC szcFormat, ...)
{
    va_list valist;
    va_start(valist, szcFormat);
	ErrorWarn(bErr,szcFormat,valist);
    va_end(valist);
}

void    DSCPARSER::Error( SZC szcFormat, ...)
{
    va_list valist;
    va_start(valist, szcFormat);
	ErrorWarn(true,szcFormat,valist);
    va_end(valist);
}

void    DSCPARSER::Warning(SZC szcFormat, ...)
{
    va_list  valist;
    va_start(valist, szcFormat);
	ErrorWarn(false,szcFormat,valist);
    va_end(valist);
}

void    DSCPARSER::ErrorWarnNode(bool bErr, SZC szcFormat, ...)
{
	//  If this node has already been deleted, other errors supercede
    if (!_pnode)
        return;

	//  Report the error
    ErrorWarn(bErr, "node %s: ", _pnode->ZsrefName().Szc());

    va_list     valist;
    va_start(valist, szcFormat);
    _flpOut.Vsprint(szcFormat, valist);
    va_end(valist);

    if (++_cerrorNode == 5 || bErr)
        _pnode = NULL;
}

void	DSCPARSER::WarningSkip ( ZSREF zsrBlockName )
{
	Warning("unrecognized block name \'%s\' skipped entirely",
			zsrBlockName.Szc());	
}

void DSCPARSER :: ReportNYI (SZC szcWhich)
{
	ErrorWarn(true,"** UNIMPLEMENTED FUNCTION: \'%s\' **", szcWhich);
}

TOKEN   DSCPARSER::TokenNextBasic()
{
    for (;;)
    {
        //  skip over white space and comments
        SkipWS();

        if (_chCur != '/')
            break;

        BChNext();

        if      (_chCur == '/')
        {
            //  it's a line comment
            SkipToEOL();
            BChNext();      //  discard '\n'
        }
        else
		if (_chCur == '*')
        {
            //  it's a block comment
            bool    fFoundEnd = false;

            BChNext();

            for (char chPrev = _chCur; BChNext(); chPrev = _chCur)
            {
                if (_chCur == '/' && chPrev == '*')
                {
                    fFoundEnd = true;
                    break;
                }
            }
            if (fFoundEnd)
                BChNext();      //  discard terminating '/'
            else
            {
                ErrorWarn(true,"end of file reached in block comment");
                return tokenEOF;
            }
        }
        else
        {
            //  not a comment, return '/'
            _vchToken[1] = '\0';
            return TOKEN(_vchToken[0] = '/');
        }
    }

    if (_chCur == EOF)
        return tokenEOF;

    _cchToken = 0;

	if ( MBNET::BChLegal( _chCur, MBNET::ECHNM_First ) )
    {
        AddChar();
		char chLast = _chCur;

        while (BChNext() && MBNET::BChLegal( _chCur, MBNET::ECHNM_Middle ))
		{
			//  Check for the "range" operator ".."
			if ( _chCur == chLast && _chCur == '.' )
				break;
			chLast = _chCur;
            AddChar();
		}
        CloseIdentifier();
        return TokenKeyword();
    }
    else
	if (isdigit(_chCur) || _chCur == '.')
    {
        TOKEN token  = _chCur == '.'
			   	     ? tokenReal
					 : tokenInteger;

        AddChar();

        while ( BChNext() && isdigit(_chCur) )
            AddChar();

		//  Check for the "range" operator ".."	
		if ( token == tokenReal && _chCur == '.' && _cchToken == 1 )
		{
			AddChar();
			BChNext();
			CloseToken("rangeop");
			return tokenRangeOp;
		}

        if (_cchToken == 1 && _vchToken[0] == '.')
        {
            CloseToken("punctuation");
            return TOKEN('.');
        }

        if (_chCur == '.' && token == tokenInteger)
        {
            AddChar();

            token = tokenReal;
			UINT cchOld = _cchToken;
            while (BChNext() && isdigit(_chCur))
                AddChar();

			//  Check for the "range" operator ".."	
			if ( _chCur == '.' && cchOld == _cchToken )
			{
				_vchToken[ -- _cchToken] = 0;
				_chUnget = '.';
				token = tokenInteger;
			}
			//  Note that check for [eE] below will fail
        }

        if (_chCur == 'e' || _chCur == 'E')
        {
            AddChar();
            BChNext();

            token = tokenReal;

            if (_chCur == '-' || _chCur == '+')
            {
                AddChar();
                BChNext();
            }

            if (isdigit(_chCur))
            {
                AddChar();

                while (BChNext() && isdigit(_chCur))
                    AddChar();
            }
        }
        CloseToken("integer/real");

        if (token == tokenInteger)
            yylval.ui   = UINT(::atol(SzcToken()));
        else
            yylval.real = ::atof(SzcToken());
        return token;
    }
    else
	if (_chCur == '"')
    {
        while (BChNext() && _chCur != '\n' && _chCur != '"')
        {
            if (_chCur == '\\')
                _chCur = ChEscape();

            AddCharStr();
        }

        if (_chCur == '"')
        {
            BChNext();
            CloseToken("string");

            yylval.zsr = Mpsymtbl().intern( SzcToken() );

            return tokenString;
        }

        ErrorWarn(true, _chCur == '\n' ? "new line in string" : "end of file in string");

        return tokenError;
    }

    AddChar();

    BChNext();

    CloseToken(NULL);

    return TOKEN(_vchToken[0]);
}

TOKEN  DSCPARSER::TokenNext()
{
    //  we need this to be able to skip tokens
    if (!_bUngetToken)
        _tokenCur = TokenNextBasic();
    else
        _bUngetToken = false;

    return _tokenCur;
}

void DSCPARSER::SkipUntil ( SZC szcStop, bool bDidLookAhead )
{
    UINT    cparen = 0;
    UINT    cbrace = 0;

    for (; _tokenCur != tokenEOF; TokenNext())
    {
        if      (_tokenCur == '}')
        {
            if (cbrace > 0)
                cbrace--;
            else
                break;
        }
        else
		if (_tokenCur == ')')
        {
            if (cparen > 0)
                cparen--;
            else
                break;
        }

        if (cparen == 0 && cbrace == 0)
        {
            if (_tokenCur < 256 && ::strchr(szcStop, _tokenCur))
                break;
        }

        if (_tokenCur == '{')
            cbrace++;
        else
		if (_tokenCur == '(')
            cparen++;

        bDidLookAhead = false;
    }

    if (!bDidLookAhead)
        _bUngetToken = true;
}


void DSCPARSER::SyntaxError ( SZC szcMessage )
{
	static char szTemp[256];
	static char szFile[256];

    SZC szcError = "";

    switch (_tokenCur)
    {
      case tokenIdent:
        szcError = ": unexpected identifier '%s'";
        break;

      case tokenEOF:
        szcError = ": unexpected end-of-file";
        break;

      case tokenError:
        return;

      default:
        szcError = ": unexpected token '%s'";
        break;
    }

    sprintf(szTemp, "%s%s\n", szcMessage, szcError);
    ErrorWarn(true, szTemp, SzcToken());
}


GNODEMBND * DSCPARSER::PgndbnAdd(ZSREF zsr)
{
	GOBJMBN * pbnobj = PbnobjFind(zsr);
	assert( pbnobj == NULL );

	if ( ! Mbnet().BAddElem( zsr, _pnode = new GNODEMBND ) )
	{
		delete _pnode;
		_pnode = NULL;
	}
	return _pnode;
}

void DSCPARSER::AddSymb(ZSREF zsr)
{
	_vzsr.push_back(zsr);
}

void DSCPARSER::AddStr(ZSREF zsr)
{
	Mpsymtbl().intern(zsr);
	AddSymb(zsr);
}

void DSCPARSER::AddPv ( PROPVAR & pv )
{
	_vpv.push_back(pv);
}
void DSCPARSER::AddPropVar (ZSREF zsr)
{
	AddPv( PROPVAR(zsr) );
}
void DSCPARSER::AddPropVar (REAL & r)
{
	AddPv( PROPVAR(r) );
}

void DSCPARSER::AddUi(UINT ui)
{
	_vui.push_back(ui);
}
void DSCPARSER::AddReal(REAL real)
{
	_vreal.push_back(real);
}

UINT DSCPARSER::UiDpi(ZSREF zsr)
{
    if (!_pnode || _vui.size() >= _vzsrParent.size())
        return 0;

	GNODEMBND * pParent = PgndbnFind(_vzsrParent[_vui.size()]);
	assert( pParent );

	for ( UINT is = 0; is < pParent->CState(); is++ )
	{
		if ( zsr == pParent->VzsrStates()[is] )
			return is;
	}
    ErrorWarnNode(true, "parent \'%s\' doesn\'t have a state named \'%s\'",
				pParent->ZsrefName().Szc(),
				zsr.Szc());
	return 0;
}

UINT DSCPARSER::UiDpi(UINT ui)
{
    if (!_pnode || _vui.size() >= _vzsrParent.size())
        return 0;

	GNODEMBND * pParent = PgndbnFind(_vzsrParent[_vui.size()]);
	assert( pParent );
	if ( ui < pParent->CState() )
		return ui;
    ErrorWarnNode(true, "parent \'%s\' doesn\'t have a state %d",
				pParent->ZsrefName().Szc(),
				ui) ;
	return 0;
}

void DSCPARSER::SetCreator(ZSREF zsr)
{
	Mbnet().ZsCreator() = zsr;
}

void DSCPARSER::SetFormat(ZSREF zsr)
{
	Mbnet().ZsFormat() = zsr;
}

void DSCPARSER::SetVersion(REAL r)
{
	Mbnet().RVersion() = r;
}

void DSCPARSER::SetStates ()
{
	UINT cstr = _vzsr.size();

	if (_pnode)
	{
		if ( cstr != _pnode->CState() )
		{
			ErrorWarnNode(true, "wrong number of state labels, %d != %d",
					  cstr, _pnode->CState() );
			return;
		}	
		_pnode->SetStates(_vzsr);
	}
}

void DSCPARSER::SetNetworkSymb(ZSREF zsr)
{
	Mbnet().ZsNetworkID() = zsr;
}

void DSCPARSER::ClearNodeInfo()
{
    _pnode      = NULL;
	_elbl		= ESTDLBL_other;
	RefBndist().Deref();
    _cerrorNode = 0;
    _idpi		= -1;
	_idpiLast	= -1;
	_cdpi       = 0;
    _bDefault   = false;
    _bCI        = false;

	ClearCstr();
	ClearVpv();

	_vimdDim.clear();
	_vui.clear();
	_vreal.clear();
	_vsdpi.clear();
	_vzsrParent.clear();
	_edist = BNDIST::ED_SPARSE;
}

void DSCPARSER :: StartNodeDecl ( ZSREF zsr )
{
	ClearNodeInfo();
	SetNodeSymb(zsr, true);

	//  If this is the first node we've seen and no property declarations
	//	were seen, import the standard properties from the Registry.

	if ( _cNode++ == 0 )
	{
		if ( ! _bPropDefs )
			ImportPropStandard();
	}
}

void DSCPARSER::SetNodeSymb(ZSREF zsr, bool bNew)
{	
	_pnode = PgndbnFind(zsr);
	if ( bNew && _pnode == NULL )
	{
		PgndbnAdd(zsr);
		ASSERT_THROW( _pnode != NULL, EC_INTERNAL_ERROR, "undetected duplicate name" );
	}

	if ( _pnode == NULL )
	{
		ErrorWarn(true, "identifier '%s' has %s been defined",
				zsr.Szc(),
				bNew ? "already" : "not");
	}
	else
	{
		assert( _ppropMgr );

		//  Find the standard label for this node, if any.
		PROPMBN * pprop = _ppropMgr->PFind( *_pnode, ESTDP_label );
		_elbl = pprop
			  ? (ESTDLBL) _ppropMgr->IUserToLbl( pprop->Real() )
			  : ESTDLBL_other;
	}
}

void DSCPARSER::SetNodeFullName(ZSREF zsr)
{
	assert(_pnode);
	_pnode->ZsFullName() = zsr;
}

void DSCPARSER::SetNodePosition( int x, int y )
{
	assert(_pnode);
	_pnode->PtPos()._x = x;
	_pnode->PtPos()._y = y;
}

void DSCPARSER::CheckNodeInfo()
{
	if ( ! _pnode )
		return;

	if ( ! _pnode->LtProp().Uniqify() )
	{
		ErrorWarnNode(false,"some properties defined more than once");
	}

	if ( _pnode->CState() == 0 )
	{
		ErrorWarnNode(true,"no states defined");
	}
}

void DSCPARSER::SetNodeCstate(UINT cstate)
{
	if ( ! _pnode )
		return;
	_pnode->_vzsrState.resize( cstate );
}


void DSCPARSER::ClearCstr()
{
	_vzsr.clear();
}
void DSCPARSER::ClearVpv()
{
	_vpv.clear();
}

void DSCPARSER::AddPropType(ZSREF zsrName, UINT fType, ZSREF zsrComment)
{
	GOBJMBN * pbnobj = PbnobjFind(zsrName);
	if ( pbnobj )
	{
		Error("symbol name \'%s\' has already been defined",
			   zsrName.Szc() );
	}
	else
	{
		GOBJPROPTYPE * pbnpt = new GOBJPROPTYPE;
		pbnpt->_fType = fType;
		pbnpt->_zsrComment = zsrComment;
		if ( fType & fPropChoice )
		{
			for ( UINT ichoice = 0 ; ichoice < _vzsr.size(); ichoice )
			{
				pbnpt->_vzsrChoice.push_back(_vzsr[ichoice++]);
			}
		}
		
		bool bOk = Mbnet().BAddElem( zsrName, pbnpt );
		assert( bOk );  // shouldn't happen; we've already checked for duplicates above
	}
}

void DSCPARSER::StartProperties()
{
	_eBlk = EBLKPROP;	
	_bPropDefs = true;	
}

void DSCPARSER::EndProperties()
{
	_eBlk = EBLKNONE;
	delete _ppropMgr;
	_ppropMgr = new PROPMGR( Mbnet() );
}

void DSCPARSER::CheckProperty( ZSREF zsrName )
{
	GOBJMBN * pbnobj = PbnobjFind(zsrName);
	if ( pbnobj == NULL || pbnobj->EType() != GOBJMBN::EBNO_PROP_TYPE )
	{
		Error("\'%s\' is not a valid property name",
			  zsrName.Szc() );
		return;
	}
	GOBJPROPTYPE * pbnpt = (GOBJPROPTYPE*) pbnobj;

	UINT fType = pbnpt->FPropType();
	bool bArray = (fType & fPropArray) == fPropArray;
	bool bStr = (fType & fPropString) == fPropString;
	bool bOK = true;
	UINT cpv = _vpv.size();

	//  Check the context; that is, what kind of block are we parsing?
	LTBNPROP * pLtProp = NULL;
	switch ( _eBlk )
	{		
		case EBLKNODE:		//  We're in a node block
			if ( _pnode )
				pLtProp = & _pnode->LtProp();
			break;
		case EBLKPROP:		//  We're in the properties block
			pLtProp = & _mbnet.LtProp();
			break;
		default:			//  How did the parser let this happen?
			SyntaxError("unexpected property declaration");
			return;
			break;	
	}

	if ( cpv > 1 && ! bArray )
	{
		Error("property \'%s\' is not an array property",
					zsrName.Szc() );		
		bOK = false;
	}
	else
	if ( pLtProp )
	{
		pLtProp->push_back( PROPMBN() );
		PROPMBN & bnp = pLtProp->back();
		bnp.Init( *pbnpt );

		for ( UINT ip = 0; ip < cpv ; ip++ )
		{
			REAL r = -1.0;
			ZSREF zsr;

			switch ( _vpv[ip]._eType )
			{
				case PROPVAR::ETPV_STR:
					if ( bStr)						
					{	
						zsr = _vpv[ip]._zsref;
						break;
					}
					if ( bOK = (fType & fPropChoice) > 0 )
					{
						UINT cChoice = pbnpt->VzsrChoice().size();
						ZSREF zsrChoice = _vpv[ip]._zsref;
						//  find the property choice in the array
						for ( UINT ic = 0 ; ic < cChoice; ic++ )
						{
							ZSREF zsr = pbnpt->VzsrChoice()[ic];
							if ( zsrChoice == zsr )
								break;
						}
						if ( ic == cChoice )
						{
							Error("property \'%s\' does not have a choice of \'%s\'",
								  zsrName.Szc(),
								  zsrChoice.Szc()) ;
							bOK = false;
						}	
						else
						{
							r = ic;
						}
					}
					break;

				case PROPVAR::ETPV_REAL:
					bOK = (fType & (fPropChoice | fPropString)) == 0 ;
					if ( bOK )
					{
						r = _vpv[ip]._r;
					}
					break;

				default:
					break;
			}
			if ( ! bOK )
				break;
			if ( bArray && bStr )
				bnp.Add( zsr );
			else
			if ( bArray )
				bnp.Add( r );
			else
			if ( bStr )
				bnp.Set( zsr );
			else
				bnp.Set( r );
		}
		if ( ! bOK )
		{
			Error("item number %d is invalid for this property", ip );		
		}
	}
}


//  Import the standard properties from the Registry
void DSCPARSER::ImportPropStandard()
{
	BNREG bnreg;
	try
	{
		bnreg.LoadPropertyTypes( _mbnet, true );
	}
	catch ( GMException & exbn )
	{
		if ( exbn.Ec() != EC_REGISTRY_ACCESS )
			throw exbn;
		
		Error( "standard properties failed to load, error '%s'",
			   (SZC) exbn.what() );
	}
}

//  Import a specific named property from the Registry
void DSCPARSER :: ImportProp ( ZSREF zsrName )
{
	if ( PbnobjFind(zsrName) != NULL )
	{
		Error("symbol name \'%s\' has already been defined",
			   zsrName.Szc() );
		return;
	}

	BNREG bnreg;
	try
	{
		bnreg.LoadPropertyType( _mbnet, zsrName );
	}
	catch ( GMException & exbn )
	{
		if ( exbn.Ec() != EC_REGISTRY_ACCESS )
			throw exbn;
		
		Error( "imported property \'%s\' failed to load, error '%s'",
			   zsrName.Szc(),
			   (SZC) exbn.what() );
	}
}

void DSCPARSER::CheckCIFunc(ZSREF zsr)
{
	if ( _pnode == NULL )
		return;

	ZSREF zsrMax = Mpsymtbl().intern("max");
	ZSREF zsrPlus = Mpsymtbl().intern("plus");

	if ( zsr == zsrMax )
	{
		_edist = BNDIST::ED_CI_MAX;
	}
	else
	{
		ErrorWarnNode(true,"unsupported PD function type \'%s\'", zsr.Szc());
		if ( zsr == zsrPlus )
			_edist = BNDIST::ED_CI_PLUS;
	}

	if ( _edist != BNDIST::ED_SPARSE && _vzsrParent.size() == 0 )
	{
		ErrorWarnNode(false,"parentless node cannot have distribution type \'%s\'; ignored", zsr.Szc());
		_edist = BNDIST::ED_SPARSE;
	}

	_bCI = true;
}

void DSCPARSER::CheckParentList()
{
	if ( ! _pnode )
		return;

	UINT cErrs = 0;

	if ( _vzsr.size() > 0 )
	{
		switch ( _elbl )
		{
			case ESTDLBL_fixobs:
		    case ESTDLBL_fixunobs:
			case ESTDLBL_unfix:
				ErrorWarnNode(false,"fixable node has parents");
				cErrs++;
				break;
			default:
				break;
		}
	}

	assert(_pnode);

	// Construct the probability distribution for this node & parent list
	VTKNPD vtknpd;

	// Cons-up "p(<node>|"
	vtknpd.push_back( TKNPD(DTKN_PD) );
	vtknpd.push_back( TKNPD( _pnode->ZsrefName() ) );
	_vimdDim.resize(_vzsr.size()+1);

	int iParent = 0;
	for ( UINT ip = 0 ; ip < _vzsr.size(); ip++ )
	{
		if ( ip > 0 )			
			vtknpd.push_back( TKNPD(DTKN_AND) );
		else
			vtknpd.push_back( TKNPD(DTKN_COND) );

		ZSREF zsrParent = _vzsr[ip];
		GNODEMBND * pgndbnParent = PgndbnFind(zsrParent);
		if ( ! pgndbnParent )
		{
			ErrorWarnNode(true,"named parent \'%s\' was not declared", zsrParent.Szc());
			cErrs++;
		}
		else
		if ( ifind( _vzsrParent, zsrParent ) >= 0 )
		{	
			ErrorWarnNode( true, "node \'%s\' has already been declared as a parent",
							zsrParent.Szc() );
			cErrs++;
		}
		else
		{
			_vzsrParent.push_back(zsrParent);
			vtknpd.push_back( TKNPD( pgndbnParent->ZsrefName() ) );
			_vimdDim[iParent++] = pgndbnParent->CState();

			if ( _pnode )
			{
				if ( Mbnet().BAcyclicEdge( pgndbnParent, _pnode ) )
				{
					Mbnet().AddElem( new GEDGEMBN_PROB( pgndbnParent, _pnode ) );
				}
				else
				{
					ErrorWarnNode( true, "connecting to parent \'%s\' creates a cycle",
									zsrParent.Szc() );
					cErrs++;
				}
			}
		}
	}
	_vimdDim.resize(iParent+1);

	if ( cErrs == 0 )
	{
		assert( _pnode );
		//  Add the final dimension to the dimension array
		_vimdDim[iParent]  = _pnode->CState();
		//  Create the distribution
		CreateBndist( vtknpd, _vimdDim );
	}
	//  If errors occurred, "_refbndist" remains empty
}

void DSCPARSER :: CreateBndist ( const VTKNPD & vtknpd, const VIMD & vimdDim )
{
	//  Check that there is no current distribution
	assert( ! RefBndist().BRef() );

	//  Create the new distribution and its reference
	RefBndist() = new BNDIST;
	//  Add it to the map in the model
	Mppd()[vtknpd] = RefBndist();

	//  Declare it as "sparse" and provide its dimensionality
	RefBndist()->SetSparse( _vimdDim );

	//  Check that everything worked
	assert( RefBndist().BRef() );
}

void DSCPARSER::InitProbEntries()
{
	if ( ! BNodeProbOK() )
		return;

	_cdpi = 1;
	UINT cparent = _vzsrParent.size();
    for (UINT ip = cparent; ip-- > 0; )
	{
		GNODEMBND * pgndbnParent = PgndbnFind(_vzsrParent[ip]);
		assert( pgndbnParent );

		UINT cParentState = pgndbnParent->CState();
		if ( _bCI )
			_cdpi += cParentState - 1;
		else
	        _cdpi *= cParentState;
	}

	_vsdpi.resize(_cdpi);
	for ( UINT idpi = 0; idpi < _cdpi; idpi++ )
	{
		_vsdpi[idpi] = sdpiAbsent;
	}
}

void DSCPARSER::CheckProbVector()
{
	if ( _idpiLast < 0 || ! BNodeProbOK() )
		return;		//  Error already reported at higher level

    if (_vreal.size() != _pnode->CState())
    {
        ErrorWarnNode(true, "incorrect number of probabilities, found %u, expected %u",
					_vreal.size(),
					_pnode->CState());
        return;
    }

	//	
	//	At this point, _vui has the parent instantiation info,
	//	  and _vreal has the values.  Create the subscript
	//	  array for the key to the map and the vector of
	//	  reals for the values;
	//
	//  MSRDEVBUG: the member variable arrays should be valarrays
	//			to make this more efficient
	//
	assert( _vui.size() == _vzsrParent.size() );

	VIMD vimd;
	VLREAL vlr;

	//
	//	If this is the 'default' vector, store it with an empty subscript array.
	//  This special value will trigger its propagation into any empty slots of
	//  the dense version.
	//
	if ( !_bDefault )
	{
		//  Not the 'default' vector; store it as the DPI
		vdup( vimd, _vui );
	}
	vdup( vlr, _vreal );
	//  store the DPI and values into the map.
	assert( RefBndist().BRef() );
	RefBndist()->Mpcpdd()[vimd] = vlr;
}

//  This node has an explictly empty probability distribution.  Create just the "default"
//	entry, and make it completely "unassessed" ("na" = -1.0).
void	DSCPARSER::EmptyProbEntries()
{
	if ( ! BNodeProbOK() )
        return;
	VIMD vimd;	// Empty subscript array
	//  Build default vector of "na", a.k.a -1
	VLREAL vlr( _pnode->CState() );
	vlr = RNA;
	RefBndist()->Mpcpdd()[vimd] = vlr;
}

//  Check the discrete parent instantiation in _vui
void DSCPARSER::CheckDPI(bool bDefault)
{
	_idpiLast = -1;
	
	if ( ! BNodeProbOK() )
        return;

    if (bDefault)
    {
        if (!_bDefault)
		{
            _bDefault = bDefault;
		}
        else
		{
            ErrorWarnNode(true, "default entry already defined");
			return;
		}
    }

	UINT cui = _vui.size();
	if ( (cui > 0 && _idpi > 0) || (cui == 0 && _idpi < -1) )
	{
	    ErrorWarnNode(true, "mixtures of prefixed and unprefixed probability entries are not allowed");
		return;
	}
	if ( cui > 0 )
		_idpi = -2;   // Disallow any further non-prefixed entries
	else
		_idpi++;

    if (cui != _vzsrParent.size())
    {
        ErrorWarnNode(true, "incorrect number of instantiations, found %u, expected %u",
				  cui,
				  _vzsrParent.size());
        return;
    }

    UINT idpi = 0 ;

	if ( cui > 0 )
	{
		UINT cstate = 0;
		UINT iui;
		UINT isi;

		if ( _bCI )
		{
			UINT cZeros = 0;
			for (iui = cui; iui-- > 0; )
			{   if ( _vui[iui] == 0 )
					cZeros++ ;
			}
			if ( cZeros < cui - 1 )
			{
				ErrorWarnNode(true, "invalid discrete CI parent instantiation");
				return;
			}
		
			if ( _bCI && cZeros == cui)
			{
				idpi = 0;	//  It's the leak term
			}
			else
			for (UINT iui = 0; iui < cui; iui++)
			{
				GNODEMBND * pgndbnParent = PgndbnFind(_vzsrParent[iui]);
				assert(pgndbnParent);

				isi = _vui[iui];
				cstate = pgndbnParent->CState();
				if ( isi > 0 )
				{
					idpi += isi;  // This is the only non-zero term
					break;
				}
				idpi += cstate - 1;
			}
		}
		else
		for ( iui = cui; iui-- > 0; )
		{
			GNODEMBND * pgndbnParent = PgndbnFind(_vzsrParent[iui]);
			assert(pgndbnParent);
			isi = _vui[iui];
			cstate = pgndbnParent->CState();

			if (isi >= cstate)
			{
				ErrorWarnNode(true, "invalid discrete parent instantiation");
				return;
			}
			idpi *= cstate;
			idpi += isi;
		}
	}
	else
	{
		idpi = _idpi;
	}

    assert(idpi < _cdpi);

    if (_vsdpi[idpi] != sdpiAbsent)
    {
        ErrorWarnNode(true, "DPI ");
		PrintDPI(idpi);
        _flpOut.Fprint( " %s\n", _vsdpi[idpi] == sdpiPresent
											? "already defined"
											: "not needed");
    }
    _vsdpi[idpi] = sdpiPresent;
	_idpiLast = idpi;
}

void DSCPARSER::PrintDPI ( UINT idpi )
{
    _flpOut.Fprint("(");
    for (UINT ip = 0; ip < _vzsrParent.size(); ip++)
    {
 		GNODEMBND * pgndbnParent = PgndbnFind(_vzsrParent[ip]);
		assert( pgndbnParent );
        UINT    cstate = pgndbnParent->CState();
        _flpOut.Fprint( "%s%u", ip == 0 ? "" : ", ", idpi % cstate);
        idpi /= cstate;
    }
    _flpOut.Fprint(")");
}


void DSCPARSER::CheckProbEntries()
{
	if ( ! BNodeProbOK() )
		return;

	int cErrors = _cError;

    if (!_bDefault)
    {
		UINT cdpiAbsent = 0;
        for (UINT idpi = 0; idpi < _cdpi && _pnode; idpi++)
        {
            if (_vsdpi[idpi] == sdpiAbsent)
            {	
				cdpiAbsent++;
            }
        }
		if ( _cdpi == cdpiAbsent )
		{
			Warning("probabilities not defined for node \'%s\'",
			  	    _pnode->ZsrefName().Szc());
		}
		else
        for (idpi = 0; idpi < _cdpi && _pnode; idpi++)
        {
            if (_vsdpi[idpi] == sdpiAbsent)
            {
                ErrorWarnNode(true, "no probabilities for DPI ");
                PrintDPI(idpi);
                _flpOut.Fprint( "\n");
            }
        }
    }

	// If no new errors arose, process probabilities
	if ( cErrors == _cError )
	{
		assert( BNodeProbOK() ) ;
		bool bOK = RefBndist()->BChangeSubtype( _edist );
		assert( bOK );
	}
}

void DSCPARSER :: ClearDomain()
{
	_eBlk = EBLKDOM; 	
	_domain.clear();
	_ilimNext = -1;
}

void DSCPARSER :: SetRanges( bool bLower, REAL rLower, bool bUpper, REAL rUpper)
{
	_rlimLower.first	= bLower;
	_rlimLower.second	= rLower;
	_rlimUpper.first	= bUpper;
	_rlimUpper.second	= rUpper;
	_ilimNext = rUpper;
}

void DSCPARSER :: SetRanges( ZSREF zsrLower, ZSREF zsrUpper )
{
	if ( _eBlk != EBLKDIST )
		Error("names are not allow in domain elements");
}

//  Add a subrange to the currently building RDOMAIN
void DSCPARSER :: AddRange( ZSREF zsr, bool bSingleton )
{
	if ( bSingleton )
	{
		++_ilimNext;
		SetRanges( true, _ilimNext, true, _ilimNext );
	}

	RANGEDEF rthis( _rlimLower, _rlimUpper, zsr );

	if ( ! rthis.BValid() )
	{
		Error( "range \'%s\' is invalid", zsr.Szc() );
		return;
	}
	else
	if ( _domain.size() > 0 )
	{
		RANGEDEF & rlast = _domain.back();
		//  Overlap check detects and fails on equality
		if ( rthis.BOverlap( rlast ) )
		{
			Error( "range \'%s\' overlaps with range \'%s\'",
					zsr.Szc(),
					rlast.ZsrName().Szc() );
			return;
		}
		if ( rthis < rlast )
		{
			ErrorWarn( false, "range \'%s\' is out of sequence with \'%s\'",
					zsr.Szc(),
					rlast.ZsrName().Szc() );
		}
		else
		{
			assert( rlast < rthis );
		}
		RDOMAIN::const_iterator itdm = _domain.begin();
		for ( ; itdm != _domain.end(); itdm++ )
		{
			const RANGEDEF & rdef = *itdm;
			
			if ( rdef.ZsrName() == rthis.ZsrName() )
			{
				Error( "range name \'%s\' has already been used in this domain",
					   rdef.ZsrName().Szc() );
				return;
			}			
		}
	}
	_domain.push_back( rthis );
}

void DSCPARSER::CheckDomain ( ZSREF zsr )
{
	GOBJMBN_DOMAIN * pgobjdom = new GOBJMBN_DOMAIN( & _domain );
	if ( ! Mbnet().BAddElem( zsr, pgobjdom ) )
	{
		Error( "domain name \'%s\' is already in use", zsr.Szc() );
		delete pgobjdom;
	}
	_domain.clear();
	_eBlk = EBLKNONE;
}

//  Set the state list for a node based upon a domain
void DSCPARSER::SetNodeDomain( ZSREF zsr )
{
	//  Verify the domain name referenced
	GOBJMBN_DOMAIN * pgobjdom = NULL;
	GOBJMBN * pbnobj = PbnobjFind(zsr);	
	if ( pbnobj )
		pgobjdom = dynamic_cast<GOBJMBN_DOMAIN *>(pbnobj);
	if ( pgobjdom == NULL )
	{
		Error( "domain name \'%s\' has not been defined", zsr.Szc() );
		return;
	}

	//  Copy the state names from the domain to the variable
	_pnode->SetDomain( *pgobjdom );
}

void DSCPARSER::CheckPDF( ZSREF zsr )
{
	if ( ! _pnode )
		return;
	ReportNYI("CheckPDF");
}

void DSCPARSER::CheckIdent( ZSREF zsr )
{
	ReportNYI("CheckIdent");
}

// End of BNPARSE.CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\bnreg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       bnreg.cpp
//
//--------------------------------------------------------------------------

//
//	BNREG.CPP: Use Registry to store persistent BN properties, etc.
//
#include <windows.h>
#include "bnreg.h"
#include "gmobj.h"


//
//	String constants for Registry handling
//
static const SZC szcBn				= "Software\\Microsoft\\DTAS\\BeliefNetworks";
static const SZC szcPropertyTypes	= "PropertyTypes";
static const SZC szcFlags			= "Flags";
static const SZC szcComment			= "Comment";
static const SZC szcChoices			= "Choices";
static const SZC szcCount			= "Count";


BNREG :: BNREG ()
{
	OpenOrCreate( HKEY_LOCAL_MACHINE, _rkBn, szcBn );
}


BNREG :: ~ BNREG ()
{
}

void BNREG :: OpenOrCreate ( HKEY hk, REGKEY & rk, SZC szcKeyName )
{
	LONG ec;
	ec = rk.Open( hk, szcKeyName );
	if ( ec != ERROR_SUCCESS )
		ec = rk.Create( hk, szcKeyName );
	if ( ec != ERROR_SUCCESS )
		throw GMException( EC_REGISTRY_ACCESS, "unable to open or create key" );
}

//
//  Store the property types from this network into the Registry.
//	If 'bStandard', force property types to be marked as "standard".
//
void BNREG :: StorePropertyTypes ( MBNET & mbnet, bool bStandard )
{
	REGKEY rkPtype;
	assert( _rkBn.HKey() != NULL );
	OpenOrCreate( _rkBn, rkPtype, szcPropertyTypes );

	MBNET::ITER mbnit( mbnet, GOBJMBN::EBNO_PROP_TYPE );
	GOBJMBN * pgmobj;
	SZC szcName;
	for ( ; pgmobj = *mbnit ; ++mbnit )
	{
		ZSREF zsrName = mbnit.ZsrCurrent();
		GOBJPROPTYPE * pbnpt;
		DynCastThrow( pgmobj, pbnpt );
		//  Get the name of the property type
		szcName = pbnpt->ZsrefName();
		//  See if it already exists
		LONG fPropType = FPropType( szcName );
		if ( fPropType >= 0 )
		{
			//  Property type already exists; guarantee that its "standard"
			//		flag is consistent
			bool bOldStandard = (fPropType & fPropStandard) > 0;
			//  It's standard if it was already or is now being forced to be
			bool bNewStandard = (pbnpt->FPropType() & fPropStandard) > 0 || bStandard;
			if ( bNewStandard ^ bOldStandard )
				throw GMException( EC_REGISTRY_ACCESS,
						"conflict between standard and non-standard property types" );

			//  Delete any older version of this property type
			rkPtype.RecurseDeleteKey( szcName );
		}
		CreatePropType( rkPtype, szcName, *pbnpt, bStandard );
	}
}

//
//	Load the property types from the Registry into this network.  If
//  'bStandard', load only the types marked "standard" if !bStandard,
//  load only the types NOT so marked.
//
void BNREG :: LoadPropertyTypes ( MBNET & mbnet, bool bStandard )
{
	REGKEY rkPtype;
	assert( _rkBn.HKey() != NULL );
	OpenOrCreate( _rkBn, rkPtype, szcPropertyTypes );

	FILETIME time;
	TCHAR szBuffer[256];
	DWORD dwSize = 256;
	ZSTR zsPt;
	DWORD dwKey = 0;

	for (;;)
	{
		dwSize = 256;
		if ( RegEnumKeyEx(rkPtype,
						 dwKey++,
						 szBuffer,
						 & dwSize,
						 NULL,
						 NULL,
						 NULL,
						 & time ) != ERROR_SUCCESS )
			break;

		zsPt = szBuffer;
		LONG fPropType = FPropType( zsPt );
		ASSERT_THROW( fPropType >= 0,
					  EC_REGISTRY_ACCESS,
					  "registry property type load enumeration failure" );

		//  Load this type if appropriate
		if ( ((fPropType & fPropStandard) > 0) == bStandard )		
			LoadPropertyType( mbnet, zsPt );
	}	
}

//  Load a single property type from the Registry into the network
void BNREG :: LoadPropertyType ( MBNET & mbnet, SZC szcPropTypeName )
{
	REGKEY rkPtype;
	assert( _rkBn.HKey() != NULL );
	OpenOrCreate( _rkBn, rkPtype, szcPropertyTypes );

	TCHAR szValue [2000];
	DWORD dwCount;
	SZC szcError = NULL;
	GOBJPROPTYPE * pgobjPt = NULL;

	do  // false loop for error checking
	{
		//  Check that the belief network doesn't already have such a beast
		if ( mbnet.PgobjFind( szcPropTypeName ) != NULL )
		{
			szcError = "duplicate property type addition attempt";
			break;
		}
		REGKEY rkPt;
		if ( rkPt.Open( rkPtype, szcPropTypeName ) != ERROR_SUCCESS )
		{
			szcError = "property type key open failure";
			break;
		}

		LONG fPropType = FPropType( szcPropTypeName );
		if ( fPropType <  0 )
			throw GMException( EC_REGISTRY_ACCESS,
							  "property type flag query failure" );

		//  Create the new property type object
		GOBJPROPTYPE * pgobjPt = new GOBJPROPTYPE;
		//  Set its flags and mark it as "persistent" (imported)
		pgobjPt->_fType = fPropType | fPropPersist;

		//  Get the comment string
		dwCount = sizeof szValue;
		if ( rkPt.QueryValue( szValue, szcComment, & dwCount ) != ERROR_SUCCESS )
		{
			szcError = "property type key value query failure";
			break;
		}
		szValue[dwCount] = 0;
		pgobjPt->_zsrComment = mbnet.Mpsymtbl().intern( szValue );

		//  Is this a "choice" property type?
		if ( fPropType & fPropChoice )
		{
			REGKEY rkChoices;
			if ( rkChoices.Open( rkPt, szcChoices ) != ERROR_SUCCESS )
			{
				szcError = "choices key missing for property type";
				break;
			}
			//  Get the "Count" value
			if ( rkChoices.QueryValue( dwCount, szcCount ) != ERROR_SUCCESS )
			{
				szcError = "failure to create choice count value";
				break;
			}
			ZSTR zs;
			int cChoice = dwCount;
			for ( int i = 0; i < cChoice; i++ )
			{
				zs.Format("%d",i);
				dwCount = sizeof szValue;
				if ( rkChoices.QueryValue( szValue, zs, & dwCount ) != ERROR_SUCCESS )
				{
					szcError = "failure to query choice string";
					break;
				}
				szValue[dwCount] = 0;
				pgobjPt->_vzsrChoice.push_back( mbnet.Mpsymtbl().intern( szValue ) );
			}
			assert( i == cChoice );
		}

		if ( szcError )
			break;

		mbnet.AddElem( szcPropTypeName, pgobjPt );

	} while ( false );

	if ( szcError )
	{
		delete pgobjPt;
		throw GMException( EC_REGISTRY_ACCESS, szcError );
	}
}

//  Remove all property types from the Registry
void BNREG :: DeleteAllPropertyTypes ()
{
	assert( _rkBn.HKey() != NULL );
	_rkBn.RecurseDeleteKey( szcPropertyTypes );
}

//  Return the value of the property type flags or -1 if open failure
LONG BNREG :: FPropType ( SZC szcPropType )
{
	REGKEY rkPtype;
	assert( _rkBn.HKey() != NULL );
	if ( rkPtype.Open( _rkBn, szcPropertyTypes ) != ERROR_SUCCESS )
		return -1;
	REGKEY rkPt;
	if ( rkPt.Open( rkPtype, szcPropType ) != ERROR_SUCCESS )
		return -1;

	DWORD dwValue;
	if ( rkPt.QueryValue( dwValue, szcFlags ) != ERROR_SUCCESS )
		return -1;
	return dwValue;	
}

void BNREG :: CreatePropType (
	REGKEY & rkParent,
	SZC szcPropType,
	GOBJPROPTYPE & bnpt,
	bool bStandard )
{
	REGKEY rkPt;
	LONG ec = rkPt.Create( rkParent, szcPropType );
	if ( ec != ERROR_SUCCESS )
		throw GMException( EC_REGISTRY_ACCESS,
						   "property type key creation failure" );

	bool bOK = true;

	//  Add the "flags" value, clearing the "persistent" flag
	DWORD dwFlags = bnpt.FPropType();
	dwFlags &= ~ fPropPersist;
	if ( bStandard )
		dwFlags |= fPropStandard;
	bOK &= (rkPt.SetValue( dwFlags, szcFlags ) == ERROR_SUCCESS);

	//  Add the "comment" string
	bOK &= (rkPt.SetValue( bnpt.ZsrComment(), szcComment ) == ERROR_SUCCESS);

	//  Add the choices, if applicable
	if ( bnpt.VzsrChoice().size() > 0 )
	{
		// Add the "Choices" subkey
		REGKEY rkChoice;
		ZSTR zs;
		int cChoice = bnpt.VzsrChoice().size();
		ec = rkChoice.Create( rkPt, szcChoices );
		if ( ec != ERROR_SUCCESS )
			throw GMException( EC_REGISTRY_ACCESS,
							   "property type choices key creation failure" );

		bOK &= (rkChoice.SetValue( cChoice, szcCount ) == ERROR_SUCCESS);
		for ( int i = 0; i < cChoice; i++ )
		{
			zs.Format("%d",i);
			bOK &= (rkChoice.SetValue( bnpt.VzsrChoice()[i], zs ) == ERROR_SUCCESS);
		}
	}

	if ( ! bOK )
		throw GMException( EC_REGISTRY_ACCESS,
						  "property type value addition failure" );	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\bndist.new.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       bndist.cpp
//
//--------------------------------------------------------------------------

//
//	BNDIST.CPP
//

#include <basetsd.h>
#include <iostream>
#include <fstream>

#include "symtmbn.h"

LEAK_VAR_DEF(BNDIST)

static void dumpVimd ( const VIMD & vimd )
{
	for ( int i = 0 ; i < vimd.size(); i++ )
	{
		cout << vimd[i];
		if ( i + 1 < vimd.size() )
			cout << ",";
	}	
}

static void dumpVlr ( const VLREAL & vlr )
{
	for ( int i = 0 ; i < vlr.size(); i++ )
	{
		cout << vlr[i];
		if ( i + 1 < vlr.size() )
			cout << ",";
	}	
}

static void dumpSlice ( const MDVSLICE & mslice, bool bStrides = true)
{
	VIMD vimdLengths = mslice.size();
	VIMD vimdStrides = mslice.stride();
	size_t iStart = mslice.start();

	cout << "\nslice start="
		 << (UINT) iStart
		 << "\tlengths=";
	dumpVimd( vimdLengths );
	if ( bStrides )
	{
		cout << "\tstrides=" ;
		dumpVimd( vimdStrides );
	}
	cout << "\ttotlen="
		 << (UINT) mslice._Totlen();
}

static void dumpMdv ( MDVCPD & mdv, const MDVSLICE * pslice = NULL )
{	
	if ( pslice == NULL )
		pslice = & mdv.Slice();
	dumpSlice( *pslice );
	MDVCPD::Iterator itmd(mdv, *pslice );
	while (itmd.BNext())
	{
		size_t icurr = itmd.ICurr();
		cout << "\n";
		dumpVimd( itmd.Vitmd() );
		REAL & r = itmd.Next();
		cout << "\t["
			<< (UINT) icurr
			<< "] = "
			<< r ;
	}
	cout << "\n";
}

BNDIST :: BNDIST ()
	:_edist(ED_NONE),
	_pmdvcpd(NULL),
	_mpcpdd(NULL)
{
	LEAK_VAR_UPD(1)
}

BNDIST :: ~ BNDIST ()
{
	Clear();
	LEAK_VAR_UPD(-1)
}

void BNDIST :: NoRef ()
{
	delete this;
}

BNDIST & BNDIST :: operator = ( const BNDIST & bnd )
{
	Clear();
	switch ( _edist = bnd._edist )
	{
		default:
		case ED_NONE:
			break;
		case ED_DENSE:
			_pmdvcpd = new MDVCPD( bnd.Mdvcpd() );
			assert( _pmdvcpd->first.size() == bnd.Mdvcpd().first.size() );
			break;
		case ED_CI_MAX:
		case ED_CI_PLUS:
		case ED_SPARSE:
			_mpcpdd = new MPCPDD( bnd.Mpcpdd() ) ;
			assert( _mpcpdd->size() == bnd.Mpcpdd().size() );
			break;			
	}
	return self;
}

BNDIST :: BNDIST ( const BNDIST & bnd )
	:_edist(ED_NONE),
	_pmdvcpd(NULL),
	_mpcpdd(NULL)
{
	(*this) = bnd;

	LEAK_VAR_UPD(1)
}

bool BNDIST :: BChangeSubtype ( EDIST edist )
{
	if ( BDenseType(edist) ^ BDense() )
		return false;
	_edist = edist;
	return true;
}

void BNDIST :: Dump ()
{
	if ( _pmdvcpd )
	{
		cout << "\n\tDense version:";
		DumpDense();
	}
	if ( _mpcpdd )
	{
		cout << "\n\tSparse version:";
		DumpSparse();
	}
	cout << "\n\n";
}

void BNDIST :: DumpSparse ()
{
	assert( _mpcpdd );
	MPCPDD & dmap = *_mpcpdd;
	int i = 0;
	for ( MPCPDD::iterator itdm = dmap.begin();
		  itdm != dmap.end();
		  ++itdm, ++i )
	{
		const VIMD & vimd = (*itdm).first;
		const VLREAL & vlr = (*itdm).second;
		cout << "\n["
			 << i
			 << "] (";
		dumpVimd(vimd);
		cout << ")\t";
		dumpVlr(vlr);
	}
}

void BNDIST :: DumpDense ()
{
	assert( _pmdvcpd );
	dumpMdv( *_pmdvcpd );
}

void BNDIST :: ConvertToDense ( const VIMD & vimd )
{
	assert( _edist == ED_NONE || _edist == ED_SPARSE );

	if ( _edist == ED_NONE )
	{
		assert( ! _mpcpdd );
		return;
	}
	//  See if there is a sparse distribution to convert
	if ( ! _mpcpdd )
		throw GMException( EC_DIST_MISUSE, "no prior sparse distribution to convert" );

	int cParent = vimd.size() - 1;
	int cState = vimd[cParent];
	MPCPDD & dmap = *_mpcpdd;
	VIMD vimdMt;					//  Empty subscript array
	VLREAL vlrDefault(cState);		//	Default value array

	//  First, try to find the default entry; use -1 if not found
	MPCPDD::iterator itdm = dmap.find(vimdMt);
	if ( itdm != dmap.end() )
		vlrDefault = (*itdm).second;
	else
		vlrDefault = -1;	// fill the array with -1.

	assert( vlrDefault.size() == cState );

	//  Allocate the new dense m-d array
	delete _pmdvcpd;
	_pmdvcpd = new MDVCPD( vimd );
	MDVCPD & mdv = *_pmdvcpd;
	//  Fill each DPI with the appropriate default value
	MDVCPD::Iterator itmdv(mdv);
	for ( int iState = 0; itmdv.BNext() ; iState++ )
	{
		itmdv.Next() = vlrDefault[ iState % cState ];
	}
	
	//
	//  Now, iterate over the sparse array and store in the appropriate locations.
	//	Each entry in the sparse map is a complete state set for the target node.
	//  Since the child (target) node probabilities are the fastest varying subscript,
	//  each entry in sparse map is spread across "cState" entries in the dense map.
	//	
	//	Of course, this could be more efficient, but we're just testing for now.
	//
	VIMD vimdDense(vimd.size());
	for ( itdm = dmap.begin(); itdm != dmap.end() ; ++itdm )
	{
		const VIMD & vimdSub = (*itdm).first;
		VLREAL & vlrNext = (*itdm).second;
		for ( int ip = 0 ; ip < cParent; ip++ )
		{
			vimdDense[ip] = vimdSub[ip];
		}
		for ( int ist = 0 ; ist < cState; ++ist )
		{
			vimdDense[cParent] = ist;
			mdv[vimdDense] = vlrNext[ist];
		}
	}
	
	//  Finally, nuke the old sparse distribution
	delete _mpcpdd;
	_mpcpdd = NULL;
	//  Set distribution type
	_edist = ED_DENSE;
}

//  Set distribution to "dense"
void BNDIST :: SetDense ( const VIMD & vimd )
{
	Clear();
	_vimdDim = vimd;
	_pmdvcpd = new MDVCPD( vimd );
	_edist = ED_DENSE;
}

//  Set distribution to sparse
void BNDIST :: SetSparse ( const VIMD & vimd )
{
	Clear();
	_vimdDim = vimd;
	_mpcpdd = new MPCPDD;
	_edist = ED_SPARSE;
}

//  Return the "leak" or "default" vector from a sparse distribution
const VLREAL * BNDIST :: PVlrLeak () const
{
	assert( BSparse() );
	const MPCPDD & dmap = Mpcpdd();
	const VIMD & vimdDim = VimdDim();
	VIMD vimdLeak;

	//  First try to find the dimensionless "default" vector.
	const VLREAL * pvlrDefault = dmap.PVlrDefault();

	//  Now try to find a specific zeroth vector; note that valarray<T>::resize
	//		stores all zeroes into the valarray by default.  Also, skip the
	//		loweest dimension, since that's the size of each vector in the
	//		sparse map.
	vimdLeak.resize( vimdDim.size() - 1 );	
	VLREAL * pvlrLeak = NULL;
	//MPCPDD::iterator itdm = dmap.find( vimdLeak );
	MPCPDD::const_iterator itdm = dmap.find( vimdLeak );
	if ( itdm != dmap.end() )
		//pvlrLeak = & (*itdm).second;
		pvlrLeak = (VLREAL*)& (*itdm).second;

	return pvlrLeak
		 ? pvlrLeak
		 : pvlrDefault;
}

void BNDIST :: Clone ( const BNDIST & bndist )
{
	ASSERT_THROW( _edist == ED_NONE,
			EC_INVALID_CLONE,
			"cannot clone into non-empty structure" );
	self = bndist;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\bnparse.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       bnparse.h
//
//--------------------------------------------------------------------------

//
//	BNPARSE.H
//	
#ifndef _BNPARSE_H_
#define _BNPARSE_H_

#include "symtmbn.h"		//  Symbol table defs
#include "parser.h"			//  Generated YACC parser header
#include "gmobj.h"			//  Graphical model object defs
#include "parsfile.h"		//  Parser file stream thunks
#include "domain.h"			//  Named domains
#include "tchar.h"
typedef vector<CHAR> VTCHAR;

class	DSCPARSER;			//  The parser
class	BNDIST;				//	A probability distribution

#define YYSTATIC    static
#define YYVGLOBAL			//  Make parse stack "yyv" (only) global, not static

//  Manifests to map YACC elements to class DSCPARSER
#define yyparse     DSCPARSER::YaccParse
#define YYPARSER    DSCPARSER::YaccParse
#define YYLEX       TokenNext
#define yylex       TokenNext
#define yyerror     SyntaxError
#define YYMAXDEPTH	150

struct   YYSTYPE
{
	union {
		UINT        ui;
		INT         integer;		
		REAL        real;			
	};
    ZSREF zsr;				
};

extern YYSTYPE  yylval, yyval;
extern YYSTYPE  yyv[YYMAXDEPTH];


struct PROPVAR
{
	enum ETYPE { ETPV_NONE, ETPV_STR, ETPV_REAL } _eType;
	ZSREF  _zsref;	//  String
	REAL _r;		//	Real value

	PROPVAR ()
		: _eType( ETPV_NONE )
		{}	
	PROPVAR ( ZSREF zsr )
		: _eType(ETPV_STR),
		_r(0.0)
		{
			_zsref = zsr;
		}
	PROPVAR ( GOBJMBN * pbnobj )
		: _eType(ETPV_STR),
		_r(0.0)
		{
			_zsref = pbnobj->ZsrefName();
		}
	PROPVAR ( REAL & r )
		: _eType(ETPV_REAL),
		_r(r)
		{}
	bool operator == ( const PROPVAR & bnp ) const;
	bool operator != ( const PROPVAR & bnp ) const;
	bool operator < ( const PROPVAR & bnp ) const;
	bool operator > ( const PROPVAR & bnp ) const;
};

// Define VPROPVAR
DEFINEV(PROPVAR);

enum    SDPI            //  status of discrete parent instantiation
{
    sdpiAbsent, sdpiPresent, sdpiNotNeeded,
};

DEFINEV(SDPI);

class DSCPARSER 
{
  protected:
    enum 
	{ 
		_cchTokenMax = 256,
        _cstrMax  = _cchTokenMax,
        _crealMax = _cstrMax,
        _csymbMax =  32,
        _cuiMax   = _csymbMax
    };

	enum EBLKTYPE
	{
		EBLKNONE,		//  No block
		EBLKNET,		//  Network block
		EBLKPROP,		//  Properties block
		EBLKNODE,		//  Node block
		EBLKPROB,		//  Probabilities block
		EBLKDOM,		//  Domain block
		EBLKDIST,		//  Distribution block
		EBLKIGN,		//  Ignore block
	};

  public:
	DSCPARSER ( MBNET & mbnet, 
			    PARSIN & flpIn, 
				PARSOUT & flpOut );
	~ DSCPARSER ();

	//  Open the target file
    bool    BInitOpen(SZC szcFile);
	//  Parse it; return tallies of errors and warnings
	bool	BParse ( UINT & cError, UINT & cWarning );

	//  Return the network being built
	MBNET & Mbnet ()
		{ return _mbnet ; }

  protected:
	MPSYMTBL & Mpsymtbl ()		{ return _mbnet.Mpsymtbl();	}
	MPPD &	Mppd ()				{ return _mbnet.Mppd();		}

	//  Parsing function (in PARSER.Y/PARSER.CPP)
	INT     YaccParse();	

	// Parsing functions
	GNODEMBND* PgndbnAdd(ZSREF zsr);
    void    AddSymb(ZSREF zsr);
	void	AddStr(ZSREF zsr);
	void	AddPropVar (ZSREF zsr);
	void	AddPropVar (REAL & r);
	void	AddPv ( PROPVAR & pv );
	void    AddUi(UINT ui);
    void    AddReal(REAL real);
	UINT	UiDpi(ZSREF zsr);
	UINT	UiDpi(UINT ui);
	void	SetNodeFullName(ZSREF zsr);
	void	SetNodePosition( int x, int y );
	void	SetCreator(ZSREF zsr);
	void    SetFormat(ZSREF zsr);
	void	SetVersion(REAL r);
    void    SetNetworkSymb(ZSREF zsr);
    void    ClearNodeInfo();
    void    SetNodeSymb(ZSREF zsr, bool bNew);
	void	StartNodeDecl(ZSREF zsr);
    void    CheckNodeInfo();
    void    SetNodeCstate(UINT cstate);
    void    CheckParentList();
    void    CheckProbVector();
    void    InitProbEntries();
    void    CheckProbEntries();
	void	EmptyProbEntries();
    void    CheckCIFunc(ZSREF zsr);
    void    CheckDPI(bool bDefault);
	void	AddPropType(ZSREF zsrName, UINT fType, ZSREF zsrComment);
	void	ImportPropStandard();
	void	ImportProp(ZSREF zsrName);
	void	ClearCstr();
	void	ClearVpv();
	void	CheckProperty( ZSREF zsrName );
	void	StartProperties();
	void	EndProperties();
	void	SetStates();
	void	CheckDomain(ZSREF zsr);
	void	ClearDomain();
	void	SetRanges( bool bLower, REAL rLower, bool bUpper, REAL rUpper);
	void	SetRanges( ZSREF zsrLower, ZSREF zsrUpper);
	void	AddRange( ZSREF zsr, bool bSingleton = false );
	void	SetNodeDomain( ZSREF zsr );

//NYI START
    void    CheckPDF(ZSREF zsr);
	void	CheckIdent( ZSREF zsr );
//NYI END

  // Lexing functions
    TOKEN   TokenKeyword();
    TOKEN   TokenNext();
    TOKEN   TokenNextBasic();
    SZC     SzcToken()					{ return & _vchToken[0]; }
    void    Warning(SZC szcFormat, ...);
    void    Error(SZC szcFormat, ...);
	void	ErrorWarn( bool bErr, SZC szcFormat, va_list & valist );
    void    ErrorWarn(bool bErr, SZC szcFormat, ...);
    void    ErrorWarnNode(bool bErr, SZC szcFormat, ...);
	void	WarningSkip ( ZSREF zsrBlockName );

    bool    BChNext();
    void    SkipWS();
    void    SkipToEOL();
    void    AddChar ( TCHAR tch = 0 );
    void    AddCharStr ( TCHAR tch = 0 );
    char    ChEscape();
    void    CloseToken(SZC szcTokenType);
    void    CloseIdentifier();
	GOBJMBN * PbnobjFind ( SZC szcName );
	GNODEMBND * PgndbnFind ( SZC szcName );
    void	SkipUntil(SZC szcStop, bool bDidLookAhead = false);
    void	SyntaxError(SZC szcError);
	void	ReportNYI (SZC szcWhich);
	void	PrintDPI ( UINT idpi );

	void	ResetParser ();

	//  Return true if current node and its distribution are valid	
	bool	BNodeProbOK () const
			{ return _pnode != NULL && _refbndist.BRef(); }

	//  Return the current distribution reference
	REFBNDIST & RefBndist () 
			{ return _refbndist; }

	//	Allocate and identify a new distribution
	void	CreateBndist ( const VTKNPD & vtknpd, const VIMD & vimdDim );

  protected:
	//  Parsing and lexing control variables
	PARSIN  & _flpIn;			//  Input stream
	PARSOUT & _flpOut;			//  Output Stream
	char	_chCur;				//  Last character read
	char	_chUnget;			//  Pushed-back character (if != 0)
	VTCHAR  _vchToken;			//  The current token being built
	UINT	_cchToken;			//  Length of token
	UINT	_iLine;				//  Line number
	UINT	_cError;			//  Error count
	UINT	_cWarning;			//  Warning count
    UINT    _cerrorNode;        //  Number of errors for current node
    TOKEN   _tokenCur;			//  Current token
    bool    _bUngetToken;		//  Return current token again?

	//  Semantic variables
	MBNET &	_mbnet;				//  The belief network
    GNODEMBND*  _pnode;			//  Current node
	BNDIST::EDIST _edist;		//  Type of distribution
	REFBNDIST _refbndist;		//  Current distribution for the node
	VIMD	_vimdDim;			//  Dimensions for dense prob table
    UINT    _cdpi;				//  Number of discrete parent instantiations
    VSDPI	_vsdpi;             //  Checks discrete parent instantiations
	UINT	_cui;				//  DPI checking
	INT		_idpi;				//  Number of unprefixed DPIs seen
	INT		_idpiLast;			//  Ptable index of last DPI seen
    bool    _bCI;               //  Causally independent CPT
    bool    _bDefault;          //  Does CPT have have a default entry
	bool	_bPropDefs;			//  File had private property definitions
	INT		_cNode;				//  Count of node declarations seen
	VZSREF	_vzsrParent;		//	Parents of the node
	EBLKTYPE _eBlk;				//  Type of block being parsed	
	VUINT	_vui;				//  Storage for arrays of integers
    VREAL   _vreal;				//	Storage for arrays of reals
	VZSREF  _vzsr;				//  Storage for arrays of strings
	VPROPVAR _vpv;				//  Storage for PROPVARs
	PROPMGR * _ppropMgr;		//  Property manager
	ESTDLBL  _elbl;				//  Node label
	RDOMAIN  _domain;			//  Domain list for domain declarations
	RANGELIM _rlimLower;		//  Lower bound of domain subrange
	RANGELIM _rlimUpper;		//  Upper bound of domain subrange
	INT		 _ilimNext;			//  Last upper bound given
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\bntest.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       bntest.cpp
//
//--------------------------------------------------------------------------

//
//	BNTEST.CPP
//
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <math.h>
#include <float.h>

#include "bnparse.h"			// Parser class
#include "bnreg.h"				// Registry management
#include "testinfo.h"			// Output test file generation
#include "distdense.hxx"		// Distribution classes
#include "distsparse.h"

#ifdef TIME_DYN_CASTS
	//  Global variable containing count of calls to all forms of DynCastThrow function template
	int g_cDynCasts = 0;
#endif

enum EFN   //  File name in file name array
{
	EFN_IN,			// input DSC file
	EFN_OUT,		// output DSC file
	EFN_INFER		// output inference test file (see testinfo.cpp for format)
};

static 
inline
double RNan ()
{
	double rnan = sqrt(-1.0);
#ifndef NTALPHA
	assert( _isnan( rnan ) );
#endif
	return rnan;
}

static 
inline 
bool BFlag ( ULONG fCtl, ULONG fFlag )
{
	return (fCtl & fFlag) > 0;
}

static 
void usage ()
{
	cout << "\nBNTEST: Belief Network Test program"
		 << "\nCommand line:"
		 <<	"\n\tbntest [options] <input.DSC> [/s <output.DSC>] [/p <output.DMP>]"
		 << "\nOptions:"
		 << "\n\t/v\t\tverbose output"
		 << "\n\t/c\t\tclique the network"
		 << "\n\t/e\t\ttest CI network expansion"
		 << "\n\t/inn\t\ttest inference; nn = iterations (default 1)"
		 << "\n\t/p <filename>\twrite inference output (.dmp) file (sets /i)"
		 << "\n\t/s <filename>\trewrite input DSC into output file"
		 << "\n\t/t\t\tdisplay start and stop times"
		 << "\n\t/x\t\tpause at various stages (for memory measurement)"
		 << "\n\t/n\t\tuse symbolic names in inference output (default is full)"
		 << "\n\t/y\t\tclone the network (write cloned version if /s)"
		 << "\n\t/u\t\tinclude entropic utility records in /p output"
		 << "\n\t/b\t\tinclude troubleshooting recommendations in /p output"
		 << "\n\t/r\t\tstore property types in Registry for persistence"
		 << "\n\t/b\t\tcompute troubleshooting recommendations"
		 << "\n\t/z\t\tshow inference engine statistics"
		 << "\n\t/m<nnnnnn>\tset maximum estimated inference engine size"
		 << "\n\t/a<n.n>\t\tflag impossible evidence with numeric value"
		 << "\n\nInput DSC is read and parsed; errors and warnings go to stderr."
		 << "\nParse errors stop testing.  If cloning, output file is cloned version."
		 << "\nIf CI expansion (/e), output (/s) has pre- and post- expansion versions."
		 << "\nInference (/i or /p) takes precedence over CI expansion (/e)."
		 << "\nInference output (/p) writes file in common format with DXTEST."
		 << "\nCliquing (/c) just creates and destroys junction tree."
		 << "\n";
}

static 
void die( SZC szcFormat, ... )
{
	ZSTR zsMsg;

    va_list valist;
    va_start(valist, szcFormat);

	zsMsg.Vsprintf( szcFormat, valist );

    va_end(valist);

	cerr << "\nBNTEST error: "
		 << zsMsg.Szc()
		 << "\n";
	exit(1);
}


//  Show the debugging build options
static 
void showOptions ( ULONG fCtl )
{
	bool bComma = false;
	ZSTR zs = TESTINFO::ZsOptions( fCtl );
	cout << "(options: "
		 << zs;

	bComma = zs.length() > 0;

	// Show DYNAMIC CAST option
	if ( bComma )
		cout << ",";
	cout << 
#ifdef USE_STATIC_CAST
		"STATICCAST"
#else	
		"DYNCAST"
#endif
		;
	bComma = true;

	// Show DUMP option
#ifdef DUMP
	if ( bComma )
		cout << ",";
	cout << "DUMP";
	bComma = true;
#endif
	
	// Show DEBUG option
#ifdef _DEBUG
	if ( bComma )
		cout << ",";
	cout << "DEBUG";
	bComma = true;
#endif

	cout << ")";
}

//  Show memory leaks for primary object types, if any
static 
void showResiduals ()
{
#ifdef _DEBUG
	if  (GEDGE::CNew() + GNODE::CNew() + GNODE::CNew() )
	{
		cout << "\n(GEDGEs = "
			 << GEDGE::CNew()
			 << ", GNODESs = "
			 << GNODE::CNew()
			 << ", BNDISTs = "
			 << GNODE::CNew()
			 << ")";
	}
	if ( VMARGSUB::CNew() + MARGSUBREF::CNew() )
	{
		cout << "\n(VMARGSUBs = "
			 << VMARGSUB::CNew()
			 << ", MARGSUBREFs = "
			 << MARGSUBREF::CNew()
			 << ")";
	}
#endif
}


static 
void printResiduals ()
{
#ifdef _DEBUG
	showResiduals();
#endif
#ifdef TIME_DYN_CASTS
	cout << "\ntotal number of dynamic casts was "
		 << g_cDynCasts;
#endif
}

//  Display the message and pause if the "pause" option is active
inline
static
void pauseIf ( ULONG fCtl, SZC szcMsg )
{
	if ( (fCtl & fPause) == 0 )
		return;
	showResiduals();
	char c;
	cout << "\n"
		 << szcMsg
		 << " (pause)"
		 ;
	cin.get(c);
}

//  Display the phase message and, optionally, the time
typedef DWORD CTICKS;

inline
static
CTICKS showPhase ( ULONG fCtl, SZC szcPhase, CTICKS * ptmLast = NULL )
{
	//  Display the phase message
	cout << "\n" << szcPhase;
	CTICKS cticks = 0;

	if ( fCtl & fShowTime )
	{
		//  Save the current tick count
		cticks = ::GetTickCount();

		//  Prepare to display the current date/time
		time_t timeNow;
		time(& timeNow);
		ZSTR zsTime = ctime(&timeNow);
		int cnl = zsTime.find( '\n' );
		if ( cnl != 0 )
			zsTime.resize( cnl );
		cout << " " << zsTime;

		//  Display the elapsed time if we know it
		if ( ptmLast && *ptmLast != 0 )
		{
			CTICKS ticksElapsed = cticks - *ptmLast;
			cout << " (elapsed time "
				 << ticksElapsed
				 << " milliseconds)";
		}
	}
	return cticks;
}


static 
void testRegistry ( MBNET & mbnet )
{
	BNREG bnr;
	bnr.StorePropertyTypes( mbnet, true );
}

#ifdef TESTDIST
static void loadDistDenseFromMpcpdd ( DISTDENSE & ddense, const MPCPDD & mpcpdd )
{
	ddense.AllocateParams();

	CST cstNode = ddense.CstNode();

	// Find the default vector in the map or create a uniform vector
	const VLREAL * pvlrDefault = mpcpdd.PVlrDefault();
	VLREAL vlrDefault;
	if ( pvlrDefault )
	{
		vlrDefault = *pvlrDefault;
	}
	else
	{
		vlrDefault.resize( cstNode );
		REAL rDefault = 1 / cstNode ;
		vlrDefault = rDefault;
	}

	//  Fill the dense array with the default value
	UINT cParamgrp = ddense.Cparamgrp();
	UINT igrp = 0;
	for ( ; igrp < cParamgrp; igrp++ )
	{
		for ( UINT ist = 0; ist < cstNode; ist++ )
		{
			ddense.Param(ist, igrp) = vlrDefault[ist];
		}
	}

	//  Iterate over the sparse map, storing probabilities as parameters
	const VCST & vcstParent = ddense.VcstParent();
	VIST vist;
	for ( MPCPDD::iterator mpitcpd = mpcpdd.begin();
		  mpitcpd != mpcpdd.end();
		  mpitcpd++ )
	{
		const VIMD & vimd = (*mpitcpd).first;
		const VLREAL & vlr = (*mpitcpd).second;
		//  State vector size must match state space
		assert( vlr.size() == cstNode );
		//  Parent dimensions must match dimension index
		assert( vdimchk( vimd, vcstParent ) );
		//  Convert the vector of unsigneds to a vector of signeds
		vdup( vist, vimd );
		//	Get the parameter group index
		UINT igrp = ddense.Iparamgrp( vist );
		//  Copy the probabilities as parameters
		for ( UINT ist = 0; ist < cstNode; ist++ )
		{
			ddense.Param(ist, igrp) = vlr[ist];
		}
	}
}

static void testDistDenseWithMpcpdd( DISTDENSE & ddense, const MPCPDD & mpcpdd )
{
}

static void loadDistSparseFromMpcpdd ( DISTSPARSE & dsparse, const MPCPDD & mpcpdd )
{
	dsparse.Init( mpcpdd );
}

static void testDistSparseWithMpcpdd ( DISTSPARSE & dsparse, const MPCPDD & mpcpdd )
{
	MPCPDD mpcpddNew;
	dsparse.Fill( mpcpddNew );

	assert( mpcpddNew == mpcpdd );
}
#endif

//  Bind the model's distibutions and verify behavior of the DISTSPARSE
//  and DISTDENSE classes.
static
void testDistributions ( MBNETDSC & mbnetdsc, ULONG fCtl )
{

#ifdef TESTDIST

	//  Bind the distributions
	mbnetdsc.BindDistributions();
	GOBJMBN * pgmobj;
	for ( MBNETDSC::ITER mbnit( mbnetdsc, GOBJMBN::EBNO_NODE );
		  pgmobj = *mbnit ; 
		  ++mbnit)
	{
		ZSREF zsrName = mbnit.ZsrCurrent();
		GNODEMBND * pgndd;
		DynCastThrow( pgmobj, pgndd );
	
		// Convert this node's distribution to a DISTDENSE and
		// a DISTSPARSE, then compare them to the original
		assert( pgndd->BHasDist() );
		const BNDIST & bndist = pgndd->Bndist();
		assert( bndist.BSparse() );
		const MPCPDD & mpcpdd = bndist.Mpcpdd();

		// Get the parent list for this node; convert to a state count vector
		VPGNODEMBN vpgndParents;
		VIMD vimdParents;
		if ( ! pgndd->BGetVimd( vimdParents ) ) 
			continue;	//  Skip non-discrete ensembles
		VCST vcstParents;
		vdup( vcstParents, vimdParents );
		CST cStates = pgndd->CState();		

		DISTDENSE ddense( cStates, vcstParents );
		DISTSPARSE dsparse( cStates, vcstParents );
		loadDistDenseFromMpcpdd( ddense, mpcpdd );
		testDistDenseWithMpcpdd( ddense, mpcpdd );
		loadDistSparseFromMpcpdd( dsparse, mpcpdd );
		testDistSparseWithMpcpdd( dsparse, mpcpdd );
	}
	
	//  Release the distributions
	mbnetdsc.ClearDistributions();
#endif
}

static 
void
showInferStats ( TESTINFO & testinfo )
{
	GOBJMBN_INFER_ENGINE * pInferEng = testinfo.Mbnet().PInferEngine();
	assert( pInferEng );
	GOBJMBN_CLIQSET * pCliqset = dynamic_cast<GOBJMBN_CLIQSET *>(pInferEng);
	if ( pCliqset == NULL )
		return;		//  Don't know how to get statistics from this inference engine

	CLIQSETSTAT & cqstats = pCliqset->CqsetStat();
	cout << "\n\nInference statistics: "
		 << "\n\treloads = " << cqstats._cReload
		 << "\n\tcollects = " << cqstats._cCollect
		 << "\n\tset evidence = " << cqstats._cEnterEv
		 << "\n\tget belief = " << cqstats._cGetBel
		 << "\n\tprob norm = " << cqstats._cProbNorm
		 << "\n"
		 ;
}

static
void testInference ( ULONG fCtl, MBNETDSC & mbnet, SZC szcFnInfer, REAL rImposs )
{
	ofstream ofs;
	bool bOutput = (fCtl & fOutputFile) > 0 ;
	int cPass = fCtl & fPassCountMask;
	GOBJMBN_INFER_ENGINE * pInferEng = mbnet.PInferEngine();
	assert( pInferEng );

	if ( bOutput )
	{
		if ( szcFnInfer == NULL )
			szcFnInfer = "infer.dmp";
		ofs.open(szcFnInfer);
	}

	//  Construct the test data container
	TESTINFO testinfo( fCtl, mbnet, bOutput ? & ofs : NULL );
	testinfo._rImposs = rImposs;

	//  Run the test
	testinfo.InferTest();

	if ( bOutput )
		ofs.close();

	if ( fCtl & fInferStats )
		showInferStats( testinfo );
}

static
void testCliquingStart ( ULONG fCtl, MBNETDSC & mbnet, REAL rMaxEstSize = -1.0 )
{
#ifdef DUMP
	if ( BFlag( fCtl, fVerbose ) )
	{
		cout << "\nBNTEST: BEGIN model before cliquing";
		mbnet.Dump();
		cout << "\nBNTEST: END model before cliquing\n";
	}
#endif
	mbnet.CreateInferEngine( rMaxEstSize );

#ifdef DUMP
	if ( BFlag( fCtl, fVerbose ) )
	{
		cout << "\nBNTEST: BEGIN model after cliquing";
		mbnet.Dump();
		cout << "\nBNTEST: END model after cliquing\n";
	}
#endif
}

static
void testCliquingEnd ( MBNETDSC & mbnet, ULONG fCtl )
{
	GOBJMBN_INFER_ENGINE * pInferEng = mbnet.PInferEngine();
	if ( pInferEng == NULL )
		return;

	mbnet.DestroyInferEngine();

	//  For testing, nuke the topology
	mbnet.DestroyTopology( true );
	//  Create arcs from the given conditional probability distributions
	mbnet.CreateTopology();
	//  For testing, nuke the topology
	mbnet.DestroyTopology( false );
}

static
void testParser ( 
	ULONG fCtl, 
	SZC rgfn[], 
	REAL rMaxEstSize = -1.0,
	REAL rImposs = -1.0 )
{
	SZC szcFn		= rgfn[EFN_IN];
	SZC szcFnOut	= rgfn[EFN_OUT];
	SZC szcFnInfer	= rgfn[EFN_INFER];

	//  Instantiate the belief network
	MBNETDSC mbnet;

	//  See if there's an output file to write a DSC into
	FILE * pfOut = NULL;
	if ( (fCtl & fSaveDsc) > 0 && szcFnOut != NULL )
	{
		pfOut = fopen(szcFnOut,"w");
		if ( pfOut == NULL )
			die("error creating output DSC file \'%s\'", szcFnOut);
	}

	//  Input file wrapper object
	PARSIN_DSC flpIn;
	//  Output file wrapper object
	PARSOUT_STD flpOut(stderr);

	//  Construct the parser; errors go to 'stderr'
	DSCPARSER parser(mbnet, flpIn, flpOut);

	UINT cError, cWarning;

	try
	{
		//  Attempt to open the file
		if ( ! parser.BInitOpen( szcFn ) )
			die("unable to access input file");

		pauseIf( fCtl, "input DSC file open" );

		//	Parse the file
		if ( ! parser.BParse( cError, cWarning ) )
			die("parse failure; %d errors, %d warnings", cError, cWarning);
		if ( cWarning )
			cout << "\nBNTEST: file "
				 << szcFn
				 << " had "
				 << cWarning
				 << " warnings\n";

		if ( BFlag( fCtl, fReg ) )
			testRegistry( mbnet );

		pauseIf( fCtl, "DSC file read and processed" );

		if ( BFlag( fCtl, fDistributions ) )	
		{
			testDistributions( mbnet, fCtl );
		}

		//  If requested, test cloning
		if ( BFlag( fCtl, fClone ) )
		{
			MBNETDSC mbnetClone;
			mbnetClone.Clone( mbnet );
			if ( pfOut )
				mbnetClone.Print( pfOut );
		}
		else
		//  If requested, write out a DSC file
	    if ( pfOut )
		{
			mbnet.Print( pfOut );
		}

		//  Test cliquing if requested (/c) or required (/i)
		if ( BFlag( fCtl, fCliquing ) || BFlag( fCtl, fInference ) )
		{
			testCliquingStart( fCtl, mbnet, rMaxEstSize );

			pauseIf( fCtl, "Cliquing completed" );

			if ( BFlag( fCtl, fInference ) )
			{	
				//  Generate inference results (/i)
				testInference( fCtl, mbnet, szcFnInfer, rImposs );
				pauseIf( fCtl, "Inference output generation completed" );
			}
			testCliquingEnd( mbnet, fCtl ) ;

			pauseIf( fCtl, "Cliquing and inference completed" );
		}
		else
		//  Test if CI expansion requested (/e)
		if ( BFlag( fCtl, fExpand ) )
		{
			//  Perform CI expansion on the network.
			mbnet.ExpandCI();
			pauseIf( fCtl, "Network expansion complete" );

			//  If output file generation, do "before" and "after" expansion and reversal
			if ( pfOut )
			{
				fprintf( pfOut, "\n\n//////////////////////////////////////////////////////////////" );
				fprintf( pfOut,   "\n//          Network After Expansion                         //" );
				fprintf( pfOut,   "\n//////////////////////////////////////////////////////////////\n\n" );
				mbnet.Print( pfOut );
			}
			//  Undo the expansion
			mbnet.UnexpandCI();
			if ( pfOut )
			{
				fprintf( pfOut, "\n\n//////////////////////////////////////////////////////////////" );
				fprintf( pfOut,   "\n//          Network After Expansion Reversal                //" );
				fprintf( pfOut,   "\n//////////////////////////////////////////////////////////////\n\n" );
				mbnet.Print( pfOut );
			}
		}

		//  For testing, nuke the topology
		mbnet.DestroyTopology();
	}
	catch ( GMException & exbn )
	{
		die( exbn.what() );
	}

	if ( pfOut )
		fclose( pfOut );
}


int main (int argc, char * argv[])
{	
	int iArg ;
	short cPass = 1;
	int cFile = 0 ;
	const int cFnMax = 10 ;	
	SZC rgfn [cFnMax+1] ;
	ULONG fCtl = 0;
	REAL rMaxEstSize = -1.0;
	REAL rImposs = RNan();

	for ( int i = 0 ; i < cFnMax ; i++ )
	{
		rgfn[i] = NULL ;
	}			
	for ( iArg = 1 ; iArg < argc ; iArg++ )
	{
		switch ( argv[iArg][0] )
		{
			case '/':
			case '-':
				{
					char chOpt = toupper( argv[iArg][1] ) ;
					switch ( chOpt ) 						
					{
						case 'V':
							//  Provide verbose output
							fCtl |= fVerbose;
							break;
						case 'C':
							//  Perform cliquing
							fCtl |= fCliquing;
							break;
						case 'E':
							//  Test network CI expansion
							fCtl |= fExpand;
							break;
						case 'I':
							//  Exercise inference and optionally write the results in a standard form
							{
								int c = atoi( & argv[iArg][2] );
								if ( c > 0 )
								{
									fCtl |= fMulti;
									cPass = c;
								}
								fCtl |= fInference;
								break;
							}
						case 'P':
							//  Get the name of the inference output file
							fCtl |= fOutputFile | fInference;
							if ( ++iArg == argc )
								die("no output inference result file name given");
							rgfn[EFN_INFER] = argv[iArg];
							break;
						case 'S':
							//  Write the input DSC file as an output file
							fCtl |= fSaveDsc;
							if ( ++iArg == argc )
								die("no output DSC file name given");
							rgfn[EFN_OUT] = argv[iArg];
							break;
						case 'T':
							//  Display start and stop times
							fCtl |= fShowTime;
							break;
						case 'X':
							//  Pause at times during execution to allow the user to measure
							//		memory usage
							fCtl |= fPause;
							break;
						case 'Y':
							//  Clone the network after loading
							fCtl |= fClone;
							break;
						case 'N':
							//  Write the symbolic name into the inference exercise output file
							//		instead of the default full name.
							fCtl |= fSymName;
							break;
						case 'U':
							//  Compute utilities using inference
							fCtl |= fUtil | fInference;
							break;
						case 'B':
							//  Compute troubleshooting utilities using inference
							fCtl |= fTSUtil | fInference;
							break;
						case 'R':
							fCtl |= fReg;
							break;
						case 'Z':
							fCtl |= fInferStats;
							break;
						case 'M':
							{	//  Get the maximum estimated clique tree size
								float f = atof( & argv[iArg][2] );
								if ( f > 0.0 )
									rMaxEstSize = f;
								break;
							}
						case 'A':
							{
								if ( strlen( & argv[iArg][2] ) > 0 )
								{
									rImposs = atof( & argv[iArg][2] );
								}
								fCtl |= fImpossible;
								break;
							}
						case 'D':
							fCtl |= fDistributions;
							break;

						default:
							die("unrecognized option") ;
							break ;
					}
				}
				break;

			default:
				if ( cFile == 0 )
					rgfn[cFile++] = argv[iArg] ;
				else
					die("too many file names given");
				break ;
		}
	}

	fCtl |= fPassCountMask & cPass;


	if ( cFile == 0 )
	{
		usage();
		return 0;
	}
	
	//  Display options and the debugging build mode
	showOptions( fCtl );

	//  Display the start message
	CTICKS tmStart = showPhase( fCtl, "BNTEST starts" );

	if ( rMaxEstSize > 0.0 )
		cout << "\nMaximum clique tree size estimate is " << rMaxEstSize;

	//  Test the parser and everything else
	testParser( fCtl, rgfn, rMaxEstSize, rImposs );

	//  Display the stop message
	showPhase( fCtl, "BNTEST completed", & tmStart );

	//  Print memory leaks of primary objects, if any
	printResiduals();

	cout << "\n";

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\cliqset.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       cliqset.h
//
//--------------------------------------------------------------------------

//
// cliqset.h:  Definitions for the clique set object.
//
#ifndef _CLIQSET_H_
#define _CLIQSET_H_

#include "gmobj.h"
#include "infer.h"

class GEDGEMBN_CLIQ;

//  Counters maintained in the inference engine
struct CLIQSETSTAT
{
	long _cReload;		// Number of times clique tree was reloaded
	long _cCollect;		// Number of collect operations
	long _cEnterEv;		// Number of calls to EnterEvidence
	long _cGetBel;		// Number of calls to GetBelief
	long _cProbNorm;	// Number of calls to ProbNorm

	CLIQSETSTAT () { Clear(); }
	void Clear ()
	{
		_cReload = 0;
		_cCollect = 0;
		_cEnterEv = 0;
		_cGetBel = 0;
		_cProbNorm = 0;
	}
};

////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//
//	GOBJMBN_CLIQSET:
//
//		Since any model may decompose into a set of clique trees
//		(assemblages with no interconnections whatever), a CLIQSET
//		is defined as the join point or grouping for the clique
//		tree "forest".
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////

class GOBJMBN_CLIQSET: public GOBJMBN_INFER_ENGINE
{
	friend class CLIQSETWORK;

  public:
	GOBJMBN_CLIQSET ( MBNET & model, 
					  REAL rMaxEstimatedSize = -1.0, 
					  int iInferEngID = 0 );

	virtual ~ GOBJMBN_CLIQSET ();
	
	virtual INT EType () const
		{ return EBNO_CLIQUE_SET; }

	virtual void Create ();
	virtual void Destroy ();
	virtual void Reload ();
	virtual void EnterEvidence ( GNODEMBN * pgnd, const CLAMP & clamp );
	virtual void GetEvidence ( GNODEMBN * pgnd, CLAMP & clamp );
	virtual void Infer ();
	virtual void GetBelief ( GNODEMBN * pgnd, MDVCPD & mdvBel );
	virtual PROB ProbNorm ();
	virtual void Dump ();

	//  Return true if the state of information is impossible
	bool BImpossible ();
		
	enum ESTATE							//  State of the junction tree
	{
		CTOR,							//  Just constructed
		UNDIR,							//  Undirected graph created
		MORAL,							//  Moralized
		CLIQUED,						//  Cliques constructed
		BUILT,							//  Fully constructed
		CONSISTENT,						//  Fully propagated
		EVIDENCE						//  Unpropagated evidence present
	};

	ESTATE EState () const				{ return _eState;		}
	MBNET & Model ()					{ return _model;		}
	INT IInferEngID () const			{ return _iInferEngID;	}

	//  Force reloading of the clique tree and full inference
	void SetReset ( bool bReset = true )
		{ _bReset = bReset ; }
	//  Force full collect/distribute cycle
	void SetCollect ( bool bCollect = true )
		{ _bCollect = bCollect; }

	//  Provide access to inference statistics
	CLIQSETSTAT & CqsetStat ()			{ return _cqsetStat;	}

  protected:	
	ESTATE _eState;						//  State of junction tree

	// Tallies
	int _cCliques;						//  Number of cliques
	int _cCliqueMemberArcs;				//  Number of clique member arcs
	int _cSepsetArcs;					//  Number of sepsest (arcs)
	int _cUndirArcs;					//  Undirected arcs in moral graph

	//  Inference control
	bool _bCollect;						//  Is "collect/distribute" pass necessary?
	bool _bReset;						//  Does tree need resetting?
	REAL _probNorm;						//  Residual prob of tree

	CLIQSETSTAT _cqsetStat;				//  Statistics

  protected:
	bool BCollect() const
		{ return _bCollect; }

	//  Cliquing helper functions
	int CNeighborUnlinked ( GNODEMBN * pgndmbn, bool bLinkNeighbors = false );
	void Eliminate ( GNODEMBN * pgndmbn, CLIQSETWORK & clqsetWork ) ;
	void GenerateCliques ( CLIQSETWORK & clqsetWork );
	void CreateUndirectedGraph( bool bMarryParents = true );
	void DestroyDirectedGraph ();

	//  Inference and tree maintenance
	void Reset ();
	void CollectEvidence ();
	void DistributeEvidence ();	

	//  Create (but don't init/load) all the clique and sepset marginals
	void CreateMarginals();
	//  Load probabilities into cliques; initialize all the sepsets
	void LoadMarginals ();

	//  Return the "family" or "self" clique for a node
	GOBJMBN_CLIQUE * PCliqueFromNode ( GNODEMBN * pgnd,
									   bool bFamily,
									   GEDGEMBN_CLIQ * * ppgedgeClique = NULL );

	// Typedefs for pointer-to-member-functions; used by Walk(). If bDownwards,
	//   then object is being enumerated on the way down the tree.
	typedef bool (GOBJMBN_CLIQSET::*PFNC_JTREE) ( GOBJMBN_CLIQUE & clique,
												  bool bDownwards = true );
	typedef bool (GOBJMBN_CLIQSET::*PFNC_SEPSET) ( GEDGEMBN_SEPSET & sepset,
												  bool bDownwards = true );

	//  Apply the given member function(s) to all cliques and/or sepsets,
	//	  depth first.
	int WalkTree ( bool bDepthFirst,
				   PFNC_JTREE pfJtree = NULL,
				   PFNC_SEPSET pfSepset = NULL );

	//  Apply the given member function to cliques and sepsets, depth first
	int WalkDepthFirst ( GOBJMBN_CLIQUE * pClique,
						 PFNC_JTREE pfJtree = NULL,
						 PFNC_SEPSET pfSepset = NULL );
	int WalkBreadthFirst ( GOBJMBN_CLIQUE * pClique,
						 PFNC_JTREE pfJtree = NULL,
						 PFNC_SEPSET pfSepset = NULL );

	//  Add an undirected arc iff there isn't one already.
	bool BAddUndirArc ( GNODEMBN * pgndbnSource, GNODEMBN * pgndbnSink );

	//  Clique and sepset helper functions used during WalkTree().
	bool BCreateClique	( GOBJMBN_CLIQUE & clique,  bool bDownwards );
	bool BLoadClique	( GOBJMBN_CLIQUE & clique,  bool bDownwards );
	bool BCreateSepset	( GEDGEMBN_SEPSET & sepset, bool bDownwards );
	bool BLoadSepset	( GEDGEMBN_SEPSET & sepset, bool bDownwards );

	bool BCollectEvidenceAtSepset ( GEDGEMBN_SEPSET & sepset, bool bDownwards );
	bool BDistributeEvidenceAtSepset ( GEDGEMBN_SEPSET & sepset, bool bDownwards );
	bool BCollectEvidenceAtRoot ( GOBJMBN_CLIQUE & clique, bool bDownwards );
	bool BDistributeEvidenceAtRoot ( GOBJMBN_CLIQUE & clique, bool bDownwards );

	bool BCollectInitEvidenceAtSepset ( GEDGEMBN_SEPSET & sepset, bool bDownwards );
	bool BDistributeInitEvidenceAtSepset ( GEDGEMBN_SEPSET & sepset, bool bDownwards );
	bool BCollectInitEvidenceAtRoot ( GOBJMBN_CLIQUE & clique, bool bDownwards );
	bool BDistributeInitEvidenceAtRoot ( GOBJMBN_CLIQUE & clique, bool bDownwards );

	//   Perform initial inference collect/distribute cycle
	void InferInit ();	
	void CollectEvidenceInit ();
	void DistributeEvidenceInit ();	

	bool BDumpSepset ( GEDGEMBN_SEPSET & sepset, bool bDownwards );
	bool BDumpClique ( GOBJMBN_CLIQUE & clique, bool bDownwards );
	void CheckConsistency ();
	bool BConsistentSepset ( GEDGEMBN_SEPSET & sepset, bool bDownwards );

private:
	void Clear ();
};

#endif // _CLIQSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\bnreg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       bnreg.h
//
//--------------------------------------------------------------------------

//
//	BNREG.H: Belief Network Registry Access
//

#include "basics.h"
#include "regkey.h"

//
//	HKEY_LOCAL_MACHINE\Software\Microsoft\DTAS\BeliefNetworks
//	HKEY_LOCAL_MACHINE\Software\Microsoft\DTAS\BeliefNetworks\PropertyTypes
//
class MBNET;
class GOBJPROPTYPE;
class BNREG
{
  public:
	BNREG ();
	~ BNREG ();

	//  Store the property types from this network into the Registry
	void StorePropertyTypes ( MBNET & mbnet, bool bStandard = false );
	//	Load the property types from the Registry into this network
	void LoadPropertyTypes ( MBNET & mbnet, bool bStandard );
	//  Load a single property type from the Registry into the network
	void LoadPropertyType ( MBNET & mbnet, SZC szcPropTypeName );
	//  Remove all property types from the Registry
	void DeleteAllPropertyTypes ();
	//  Return the flags from a Registry-based property type or -1 if not found
	LONG FPropType ( SZC szcPropType );
	
  protected:
	REGKEY _rkBn;

	void OpenOrCreate ( HKEY hk, REGKEY & rk, SZC szcKeyName );
	void CreatePropType ( REGKEY & rkParent, 
						  SZC szcPropType, 
						  GOBJPROPTYPE & bnpt, 
						  bool bStandard = false );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\clique.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       clique.cpp
//
//--------------------------------------------------------------------------

//
//	clique.cpp
//

#include <basetsd.h>
#include "cliqset.h"
#include "clique.h"
#include "cliqwork.h"

#include "parmio.h"

#ifdef _DEBUG				//  In debug mode only...
    #define CONSISTENCY			//  Do complete consistency checking on sepsets
//	#define DUMP				//  Perform general dumping of objects
//  #define DUMPCLIQUESET		//  Dump extensive tables from clique tree
//	#define INFERINIT			//  Full initial tree balancing
#endif


////////////////////////////////////////////////////////
////////////////////////////////////////////////////////
// GEDGEMBN_CLIQ: Edges between cliques and member nodes
////////////////////////////////////////////////////////
////////////////////////////////////////////////////////

GEDGEMBN_CLIQ :: GEDGEMBN_CLIQ (
	GOBJMBN_CLIQUE * pgnSource,
	GNODEMBN * pgndSink,
	int iFcqlRole )
	: GEDGEMBN( pgnSource, pgndSink ),
	_iFcqlRole( iFcqlRole ),
	_iMark( pgndSink->IMark() ),
	_bBuilt( false )
{
}

void GEDGEMBN_CLIQ :: Build ()
{
	if ( ! BBuilt() )
	{
		GNODEMBND * pgndd;
		DynCastThrow( PgndSink(), pgndd );

		//  If role is "Family", this edge is used for marginalization of belief
		//		and creating joint distribution in clique
		if ( BFamily() )
		{
			ReorderFamily( pgndd, _vimdFamilyReorder );
			//  Build the reordered marginals table for the node
			MargCpd().CreateOrderedCPDFromNode( pgndd, _vimdFamilyReorder );
			//  Build an iterator between the CPD and the clique joint
			MiterLoadClique().Build( PclqParent()->Marginals(), MargCpd() );
			//  Build the belief marginalization structure
			MiterNodeBelief().Build( PclqParent()->Marginals(), pgndd );			
		}
	
		_bBuilt = true;
	}
}

void GEDGEMBN_CLIQ :: LoadCliqueFromNode ()
{
	assert( _bBuilt );
	MiterLoadClique().MultiplyBy( MargCpd() );	
}

GEDGEMBN_CLIQ :: ~ GEDGEMBN_CLIQ()
{
}

GOBJMBN_CLIQUE * GEDGEMBN_CLIQ :: PclqParent()
{
	GOBJMBN * pobj = PobjSource();
	GOBJMBN_CLIQUE * pclq;
	DynCastThrow( pobj, pclq );
	return pclq;
}

GNODEMBN * GEDGEMBN_CLIQ :: PgndSink()
{
	GOBJMBN * pobj = PobjSink();
	GNODEMBN * pgnd;
	DynCastThrow( pobj, pgnd );
	return pgnd;
}

//  Using the topological renumber of the nodes, produce
//		an array correlating the old family to the new order.
//		In other words, vimd[0] will be the family index of
//		the node which had the lowest topological order; vimd[1]
//		will be the family index of the next lowest, etc.
//
//	Note that node itself is always last in either ordering.
void GEDGEMBN_CLIQ :: ReorderFamily ( GNODEMBN * pgnd, VIMD & vimd )
{
	VPGNODEMBN vpgndFamily;
	//  Get the family (parents & self)
	pgnd->GetFamily( vpgndFamily );
	int cFam = vpgndFamily.size();
	vimd.resize( cFam );
	for ( int i = 0; i < cFam; i++ )
	{
		int iLow = INT_MAX;
		int iFam = INT_MAX;
		//  Find the lowest unrecorded family member
		for ( int j = 0; j < cFam; j++ )
		{
			GNODEMBN * pgndFam = vpgndFamily[j];
			if ( pgndFam == NULL )
				continue;
			if ( pgndFam->IMark() < iLow )
			{
				iLow = pgndFam->IMark();
				iFam = j;
			}
		}
		assert( iLow != INT_MAX );
		vimd[i] = iFam;
		vpgndFamily[iFam] = NULL;
	}
}

////////////////////////////////////////////////////////
////////////////////////////////////////////////////////
//	GEDGEMBN_SEPSET:  A separator marginal
////////////////////////////////////////////////////////
////////////////////////////////////////////////////////
GEDGEMBN_SEPSET :: GEDGEMBN_SEPSET (
	GOBJMBN_CLIQUE * pgnSource,
	GOBJMBN_CLIQUE * pgnSink )
	: GEDGEMBN( pgnSource, pgnSink ),
	_pmargOld( new MARGINALS ),
	_pmargNew( new MARGINALS )
{
}

GEDGEMBN_SEPSET :: ~ GEDGEMBN_SEPSET()
{
	delete _pmargOld;
	delete _pmargNew;
}

void GEDGEMBN_SEPSET :: ExchangeMarginals ()
{
	pexchange( _pmargOld, _pmargNew );
}

GOBJMBN_CLIQUE * GEDGEMBN_SEPSET :: PclqParent()
{
	GOBJMBN * pobj = PobjSource();
	GOBJMBN_CLIQUE * pclq;
	DynCastThrow( pobj, pclq );
	return pclq;
}

GOBJMBN_CLIQUE * GEDGEMBN_SEPSET :: PclqChild()
{
	GOBJMBN * pobj = PobjSink();
	GOBJMBN_CLIQUE * pclq;
	DynCastThrow( pobj, pclq );
	return pclq;
}

void GEDGEMBN_SEPSET :: GetMembers ( VPGNODEMBN & vpgnode )
{
	GOBJMBN_CLIQUE * pclqSource = PclqParent();
	GOBJMBN_CLIQUE * pclqSink = PclqChild();
	VPGNODEMBN vpgndSink;
	VPGNODEMBN vpgndSource;
	pclqSource->GetMembers( vpgndSource );
	pclqSink->GetMembers( vpgndSink );

	assert( vpgndSink.size() > 0 );
	assert( vpgndSource.size() > 0 );
	
	//  Fill the given array with the intersection of the two clique
	//	member node arrays.  Since we cannot sort them into cliqing order
	//	anymore (IMark() is unreliable after cliquing), we just search
	//  one against the other in order to guarantee that the intersection
	//  result set has the same node ordering as the original sets.

	int ibLast = -1;
	for ( int ia = 0; ia < vpgndSink.size(); ia++ )
	{	
		GNODEMBN * pa = vpgndSink[ia];
		for ( int ib = ibLast+1; ib < vpgndSource.size(); ib++ )
		{	
			GNODEMBN * pb = vpgndSource[ib];	
			if ( pa == pb )
			{	
				vpgnode.push_back(pa);
				ibLast = ib;
				break;
			}
		}
	}
#ifdef DUMP
	if ( vpgnode.size() == 0 )
	{
		cout << "\nSEPSET INTERSECTION NULL: source clique:";
		pclqSource->Dump();
		cout << "\n\t\tsink clique:";
		pclqSink->Dump();
		cout << "\n";
		cout.flush();
	}
#endif
	assert( vpgnode.size() > 0 );
}

void GEDGEMBN_SEPSET :: CreateMarginals ()
{
	VPGNODEMBN vpgnd;
	GetMembers( vpgnd );
	MarginalsOld().Init( vpgnd );
	MarginalsNew().Init( vpgnd );

}

void GEDGEMBN_SEPSET :: InitMarginals ()
{
	assert( VerifyMarginals() );
	MarginalsOld().Clear( 1.0 );
	MarginalsNew().Clear( 1.0 );

	if ( ! _miterParent.BBuilt() )
		_miterParent.Build( PclqParent()->Marginals(), MarginalsOld() );
	if ( ! _miterChild.BBuilt() )
		_miterChild.Build( PclqChild()->Marginals(), MarginalsOld() );
}

bool GEDGEMBN_SEPSET :: VerifyMarginals ()
{
	VPGNODEMBN vpgnd;
	GetMembers( vpgnd );
	VIMD vimd = MARGINALS::VimdFromVpgnd( vpgnd );
	return vimd == Marginals().Vimd(); 	
}

void GEDGEMBN_SEPSET :: UpdateRatios ()
{
	MarginalsOld().UpdateRatios( MarginalsNew() );
}

void GEDGEMBN_SEPSET :: AbsorbClique ( bool bFromParentToChild )
{
	MARGSUBITER * pmiterFrom;
	MARGSUBITER * pmiterTo;

	if ( bFromParentToChild )
	{
		pmiterFrom = & _miterParent;
		pmiterTo = & _miterChild;
	}
	else
	{
		pmiterFrom = & _miterChild;
		pmiterTo = & _miterParent;
	}	

	// Marginalize "from" probs into the "new" marginals table
	pmiterFrom->MarginalizeInto( MarginalsNew() );
	// Absorb the changes into the "old" marginals table
	UpdateRatios();
	// Multiply the table into the "to"'s marginals
	pmiterTo->MultiplyBy( MarginalsOld() );

	// Finally, exchange the marginals tables
	ExchangeMarginals();
}

void GEDGEMBN_SEPSET :: BalanceCliquesCollect ()
{
	//  Use the "new" table as a work area.

	//  Marginalize the child into the work area
	_miterChild.MarginalizeInto( MarginalsNew() );
	//	Update the parent with those values
	_miterParent.MultiplyBy( MarginalsNew() );
	//  Invert each value, so we're really dividing
	MarginalsNew().Invert();
	//  Update the child marginals by dividing by the marginals
	_miterChild.MultiplyBy( MarginalsNew() );
	//  Clear the "new" marginals back to 1.0.
	MarginalsNew().Clear( 1.0 );	
}

void GEDGEMBN_SEPSET :: BalanceCliquesDistribute ()
{
	//  Set the old marginals to the parent clique's values
	_miterParent.MarginalizeInto( MarginalsOld() );
	//  Update the child marginals by those values
	_miterChild.MultiplyBy( MarginalsOld() );
	//  "Old" marginals are left as they are
}


void GEDGEMBN_SEPSET :: UpdateParentClique ()
{
	AbsorbClique( false );
}

void GEDGEMBN_SEPSET :: UpdateChildClique ()
{
	AbsorbClique( true );
}

void GEDGEMBN_SEPSET :: Dump ()
{
	GOBJMBN_CLIQUE * pclqParent = PclqParent();
	GOBJMBN_CLIQUE * pclqChild = PclqChild();

	cout << "\n=== Sepset between parent clique "
		 << pclqParent->IClique()
		 << " and child clique "
		 << pclqChild->IClique()
		 << ", \n\n\tOld marginals:";

	_pmargOld->Dump();

	cout << "\n\n\tNew marginals:";
	_pmargNew->Dump();
	cout << "\n\n";
}

bool GEDGEMBN_SEPSET :: BConsistent ()
{
	//  Get the sepset member list for creation of temporary marginals
	VPGNODEMBN vpgnd;
	GetMembers( vpgnd );

	//  Create the marginals for the parent clique
	GOBJMBN_CLIQUE * pclqParent = PclqParent();
	MARGINALS margParent;
	margParent.Init( vpgnd );
	pclqParent->Marginals().Marginalize( margParent );

	//  Create the marginals for the child clique
	GOBJMBN_CLIQUE * pclqChild = PclqChild();
	MARGINALS margChild;
	margChild.Init( vpgnd );
	pclqChild->Marginals().Marginalize( margChild );

	//  Are they equivalent?
	bool bOK = margParent.BEquivalent( margChild, 0.00000001 );

#ifdef DUMP
	if ( ! bOK )
	{
		cout << "\nGEDGEMBN_SEPSET::BConsistent: cliques are NOT consistent, parent clique "
			 << pclqParent->IClique()
			 << ", child "
			 << pclqChild->IClique();
		MARGINALS::Iterator itParent(margParent);
		MARGINALS::Iterator itChild(margChild);
		cout << "\n\tparent marginals: "
			 << itParent;
		cout << "\n\tchild marginals: "
			 << itChild
			 << "\n";
		cout.flush();
	}
#endif

#ifdef NEVER
	MARGINALS margParent2;
	margParent2.Init( vpgnd );
	
	_miterParent.Test( margParent2 );
	_miterParent.MarginalizeInto( margParent2 );
	bOK = margParent.BEquivalent( margParent2, 0.00000001 );
#endif

	ASSERT_THROW( bOK, EC_INTERNAL_ERROR, "inconsistent cliques" );

	return bOK;
}

////////////////////////////////////////////////////////
////////////////////////////////////////////////////////
// GOBJMBN_CLIQUE: A Clique
////////////////////////////////////////////////////////
////////////////////////////////////////////////////////

GOBJMBN_CLIQUE :: GOBJMBN_CLIQUE (
	int iClique,
	int iInferEngID )
	: _iClique( iClique ),
	_iInferEngID( iInferEngID ),
	_bRoot(false),
	_bCollect(false)
{
}

GOBJMBN_CLIQUE :: ~ GOBJMBN_CLIQUE()
{
}

//	Initialize a clique by finding all edges leading from "family"
//	  arcs and initializing the marginals from there.
void GOBJMBN_CLIQUE :: LoadMarginals ()
{
	GNODEMBND * pgnddSink;
	GEDGEMBN_CLIQ * pgedgeMbr;

	//  Prepare to enumerate child member arcs
	GNODENUM<GOBJMBN> benumMembers(false);
	benumMembers.SetETypeFollow( GEDGEMBN::ETCLIQUE );

	//  Enumerate child member arcs, reloading the marginals for nodes for which this
	//		clique is their "self" clique.
	for ( benumMembers.Set( this );
		  benumMembers.PnodeCurrent();
		  benumMembers++ )
	{
		DynCastThrow( benumMembers.PgedgeCurrent(), pgedgeMbr );
		pgedgeMbr->Build();

		if ( pgedgeMbr->BFamily() )
			pgedgeMbr->LoadCliqueFromNode();
	}

	//  Enumerate child member arcs, entering evidence (clamped state) for nodes for which this
	//		clique is their "self"
 	for ( benumMembers.Set( this );
		  benumMembers.PnodeCurrent();
		  benumMembers++ )
	{
		DynCastThrow( benumMembers.PgedgeCurrent(), pgedgeMbr );
		if ( ! pgedgeMbr->BSelf() )
			continue;

		DynCastThrow( benumMembers.PnodeCurrent(), pgnddSink );
		//  Note: ClampNode is benign when node is unclamped.
		Marginals().ClampNode( pgnddSink, pgedgeMbr->Clamp() );
	}

	SetCollect();
}

void GOBJMBN_CLIQUE :: GetMembers ( VPGNODEMBN & vpgnode )
{
	GNODENUM<GOBJMBN> benumMembers(false);
	benumMembers.SetETypeFollow( GEDGEMBN::ETCLIQUE );
	for ( benumMembers.Set( this );
		  benumMembers.PnodeCurrent();
		  benumMembers++ )
	{
		GOBJMBN * pgobj = *benumMembers;
		GNODEMBN * pgnd;
		DynCastThrow( pgobj, pgnd );
		vpgnode.push_back( pgnd );
	}
	assert( vpgnode.size() > 0 );
}

void GOBJMBN_CLIQUE :: CreateMarginals ()
{
	VPGNODEMBN vpgnd;
	GetMembers( vpgnd );
	Marginals().Init( vpgnd );
}

void GOBJMBN_CLIQUE :: InitMarginals ()
{
	assert( VerifyMarginals() );
	Marginals().Clear( 1.0 );
}

bool GOBJMBN_CLIQUE :: VerifyMarginals ()
{
	VPGNODEMBN vpgnd;
	GetMembers( vpgnd );
	VIMD vimd = MARGINALS::VimdFromVpgnd( vpgnd );
	return vimd == Marginals().Vimd(); 	
}

void GOBJMBN_CLIQUE :: Dump ()
{
	cout << "\n=== Clique "
		 << _iClique
		 << ", tree ID: "
		 << _iInferEngID
		 << ", root = "
		 << _bRoot;
	_marg.Dump();
	cout << "\n\n";
}

void GOBJMBN_CLIQUE :: GetBelief ( GNODEMBN * pgnd, MDVCPD & mdvBel )
{
	GNODEMBND * pgndd;
	DynCastThrow( pgnd, pgndd );
	Marginals().Marginalize( pgndd, mdvBel );
}

////////////////////////////////////////////////////////
////////////////////////////////////////////////////////
// GOBJMBN_CLIQSET:  The graphical model junction tree
////////////////////////////////////////////////////////
////////////////////////////////////////////////////////

GOBJMBN_CLIQSET :: GOBJMBN_CLIQSET (
	MBNET & model,
	REAL rMaxEstimatedSize,
	int iInferEngID  )
	: GOBJMBN_INFER_ENGINE( model, rMaxEstimatedSize, iInferEngID )
{
	Clear() ;
}

void GOBJMBN_CLIQSET :: Clear ()
{
	_eState = CTOR;
	_cCliques = 0;
	_cCliqueMemberArcs = 0;
	_cSepsetArcs = 0;
	_cUndirArcs = 0;
	_probNorm = 1.0;
	_bReset = true;
	_bCollect = true;
	_cqsetStat.Clear();
};

GOBJMBN_CLIQSET :: ~ GOBJMBN_CLIQSET ()
{
#ifdef DUMP
	Dump();
#endif
	Destroy();
}

bool GOBJMBN_CLIQSET :: BImpossible ()
{
	return ProbNorm() == 0.0;
}
		

//  Add an undirected arc iff there isn't one already.
bool GOBJMBN_CLIQSET :: BAddUndirArc ( GNODEMBN * pgndbnSource, GNODEMBN * pgndbnSink )
{
	if ( pgndbnSource->BIsNeighbor( pgndbnSink ) )
		return false;

#ifdef DUMP
	cout << "\n\t\tADD undirected arc from "
		 << pgndbnSource->ZsrefName().Szc()
		 << " to "
		 << pgndbnSink->ZsrefName().Szc();
#endif

	Model().AddElem( new GEDGEMBN_U( pgndbnSource, pgndbnSink ) );
	++_cUndirArcs;
	return true;
}

void GOBJMBN_CLIQSET :: CreateUndirectedGraph ( bool bMarryParents )
{
	if ( EState() >= MORAL )
		return;

	int cDirArcs = 0;
	int cUndirArcs = 0;
	int cNodes = 0;
	GELEMLNK * pgelm;

#ifdef DUMP
	cout << "\n\n***** MORALIZE GRAPH";
#endif

	if ( EState() < MORAL )
	{
		//  Create an undirected arc for every directed arc.
		MODEL::MODELENUM mdlenum( Model() );
		while ( pgelm = mdlenum.PlnkelNext() )
		{	
			//  Check that it's an edge
			if ( ! pgelm->BIsEType( GELEM::EGELM_EDGE ) )
				continue;
				//  Check that it's a directed probabilistic arc
			if ( pgelm->EType() != GEDGEMBN::ETPROB )
				continue;

			GEDGEMBN * pgedge;
			DynCastThrow( pgelm, pgedge );
			GNODEMBN * pgndbnSource;
			GNODEMBN * pgndbnSink;
			DynCastThrow( pgedge->PnodeSource(), pgndbnSource );
			DynCastThrow( pgedge->PnodeSink(), pgndbnSink );

			//  If the sink (child) node has been expanded,
			//	consider only Expansion parents
			if (   pgndbnSink->BFlag( EIBF_Expanded )
				&& ! pgndbnSource->BFlag( EIBF_Expansion ) )
				continue;

			cDirArcs++;
			cUndirArcs += BAddUndirArc( pgndbnSource, pgndbnSink );
		}
		assert( cDirArcs == cUndirArcs ) ;

		//  Undirected graph has been created
		_eState = UNDIR;
	}
	if ( !bMarryParents )
		return;

#ifdef DUMP
	cout << "\n\n***** MARRY PARENTS";
#endif


	MODEL::MODELENUM mdlenum( Model() );
	GNODENUM<GNODEMBN> benumparent(true);
	benumparent.SetETypeFollow( GEDGEMBN::ETPROB );
	GNODEMBN * pgndmbn;
	VPGNODEMBN vpgnd;

	while ( pgelm = mdlenum.PlnkelNext() )
	{	
		if ( pgelm->EType() != EBNO_NODE )
			continue;
			
		DynCastThrow( pgelm, pgndmbn );

		//  Collect the parents
		vpgnd.resize(0);
		pgndmbn->GetParents( vpgnd );

		//  Marry them
		int cParent = vpgnd.size();
		for ( int iParent = 0; iParent < cParent - 1; iParent++ )
		{
			for ( int ip2 = iParent+1; ip2 < cParent ; ip2++ )
			{
				BAddUndirArc( vpgnd[iParent], vpgnd[ip2] );
			}
		}
	}

	//  Graph is now moral
	_eState = MORAL;
}

//
//	Return the number of neighbors of this node which are unlinked
//
int GOBJMBN_CLIQSET :: CNeighborUnlinked ( GNODEMBN * pgndmbn, bool bLinkNeighbors )
{
	int cNeighborUnlinked = 0;

	//  Get the array of neighbors
	VPGNODEMBN vpgnode;
	pgndmbn->GetNeighbors( vpgnode );

#ifdef DUMP
	cout << "\n\t\tCNeighborUnlinked, called for node "
		 << pgndmbn->ZsrefName().Szc();
#endif
	
	for ( int inbor = 0; inbor < vpgnode.size(); inbor++ )
	{
		GNODEMBN * pgndNbor = vpgnode[inbor];

#ifdef DUMP
		cout << "\n\t\t\t" << pgndNbor->ZsrefName().Szc();
		int cUnlinked = 0;
#endif
		if ( pgndNbor->IMark() )
			continue;		//  Node has been eliminated already

		//  Check it against all other neighbors.
		for ( int inbor2 = inbor + 1; inbor2 < vpgnode.size(); inbor2++ )
		{
			GNODEMBN * pgndNbor2 = vpgnode[inbor2];

			//  See if node has been eliminated already or is already a neighbor
			if ( pgndNbor2->IMark() )
				continue;

			if ( pgndNbor->BIsNeighbor( pgndNbor2 ) )
			{
				assert( pgndNbor2->BIsNeighbor( pgndNbor ) );
				continue;		
			}
#ifdef DUMP
			cUnlinked++;
#endif
			++cNeighborUnlinked;

			if ( bLinkNeighbors )
			{
				BAddUndirArc( pgndNbor, pgndNbor2 );
#ifdef DUMP
				cout << "  ("
					 << pgndNbor->ZsrefName().Szc()
					 << " <-> "
					 << pgndNbor2->ZsrefName().Szc()
					 << ")  ";
#endif
			}
		}
#ifdef DUMP
		if ( cUnlinked )
			cout << " <-- unlinked to "
				 << cUnlinked
				 << " neighbors";
#endif
	}
#ifdef DUMP
	cout << "\n\t\t---- total unlinked = " << cNeighborUnlinked;
#endif	
	return cNeighborUnlinked;
}

void GOBJMBN_CLIQSET :: Eliminate ( GNODEMBN * pgndmbn, CLIQSETWORK & clqsetWork )
{
#ifdef DUMP
	cout << "\n\n***** ELIMINATE "
		 << pgndmbn->ZsrefName().Szc();
#endif

	//  Add another array to the clique set and fill it with the clique menbers
	clqsetWork._vvpgnd.push_back( VPGNODEMBN() );
	VPGNODEMBN & vpgndClique = clqsetWork._vvpgnd[ clqsetWork._vvpgnd.size() - 1 ];

	//  Complete the elimination of this node and its neighbors.
	CNeighborUnlinked( pgndmbn, true );
	pgndmbn->IMark() = ++clqsetWork._iElimIndex;

	//  Start the clique with this entry.
	vpgndClique.push_back( pgndmbn );

	//  Iterate over the neighbors, adding the unmarked ones
	GNODENUM_UNDIR gnenumUndir;
	for ( gnenumUndir = pgndmbn;
		  gnenumUndir.PnodeCurrent();
		  gnenumUndir++ )
	{
		GNODEMBN * pgndmbNeighbor = *gnenumUndir;
		if ( pgndmbNeighbor->IMark() == 0 )
			vpgndClique.push_back( pgndmbNeighbor );
	}

#ifdef DUMP
	cout << "\n\t\tNEW CLIQUE: ";
	clqsetWork.DumpClique( clqsetWork._vvpgnd.size() - 1 );
#endif
	
	assert( pgndmbn->IMark() > 0 );
}

void GOBJMBN_CLIQSET :: GenerateCliques ( CLIQSETWORK & clqsetWork )
{
	//  Reset marks in all nodes
	Model().ClearNodeMarks();
	clqsetWork._vvpgnd.clear();

#ifdef DUMP
	cout << "\n\n***** GENERATE CLIQUES";
#endif

	for(;;)
	{	
		// Find the node that requires the fewest edges to turn into a clique.
		GNODEMBN * pgndmbnMin = NULL;
		int cNeighborMin = INT_MAX;

		MODEL::MODELENUM mdlenum( Model() );
		GELEMLNK * pgelm;
		while ( pgelm = mdlenum.PlnkelNext() )
		{	
			if ( pgelm->EType() != EBNO_NODE )
				continue;
				
			GNODEMBN * pgndmbn;
			DynCastThrow( pgelm, pgndmbn );

			if ( pgndmbn->IMark() )
				continue;		//  Node has been eliminated already
	
			int cNeighborUnlinked = CNeighborUnlinked( pgndmbn );

			if ( cNeighborMin > cNeighborUnlinked )
			{	
				pgndmbnMin = pgndmbn;
				if ( (cNeighborMin = cNeighborUnlinked) == 0 )
					break;   //  zero is as few neighbors as possible
			}
		}
		if ( pgndmbnMin == NULL )
			break;

		//  Mark the node for elimination and assign an elimination order to it.  This
		//		number is crucial for the construction of the strong junction tree.

#ifdef DUMP
		cout << "\nGenerateCliques:  Eliminate "
			 << pgndmbnMin->ZsrefName().Szc()
			 << ", which has "
			 << cNeighborMin
			 << " unlinked neighbors";
#endif

		Eliminate( pgndmbnMin, clqsetWork );
	}

#ifdef DUMP
	cout << "\n\n";
#endif
}

//
//  Create the junction tree.
//
void GOBJMBN_CLIQSET :: Create ()
{
	Model().CreateTopology();

	ASSERT_THROW( EState() == CTOR, EC_INTERNAL_ERROR, "GOBJMBN_CLIQSET:Create already called" );

	//  If it hasn't been done already, create the undirected graph and moralize it.
	CreateUndirectedGraph(true);

	CLIQSETWORK clqsetWork(self);

	clqsetWork._iElimIndex = 1;

	//  Triangulate the undirected graph, eliminating nodes and accumulating cliques
	//		along the way.
	GenerateCliques( clqsetWork );
	if ( clqsetWork._vvpgnd.size() == 0 )
		return;

	_eState = CLIQUED;

#ifdef DUMP
	clqsetWork.DumpCliques();
#endif

	//  Provide a total ordering over the nodes based upon topological level
	// MSRDEVBUG:  What happened to the elimination index?  Koos doesn't use it; will we?
	//   Renumbering here overwrites the elimination order.
	clqsetWork.RenumberNodesForCliquing();
	//  Build the cliques
	clqsetWork.BuildCliques();

	//  Set clique membership and topological information
	clqsetWork.SetTopologicalInfo();

	//  Check that the running intersection property holds
	ASSERT_THROW( clqsetWork.BCheckRIP(),
				  EC_INTERNAL_ERROR,
				  "GOBJMBN_CLIQSET::Create: junction tree failed RIP test" );

	//  See if the resulting memory allocation size would violate the size estimate
	if ( _rEstMaxSize > 0.0 )
	{
		REAL rSizeEstimate = clqsetWork.REstimatedSize();
		if ( rSizeEstimate > _rEstMaxSize )
			throw GMException( EC_OVER_SIZE_ESTIMATE,
							   "Clique tree size violates estimated size limit" );
	}

	//  Create the topology-- all the trees in the forest
	clqsetWork.CreateTopology();

	//  Nuke the moral graph
	DestroyDirectedGraph();

	//  Bind the known distributions to their target nodes;
	_model.BindDistributions();

	//  Reset/initialize the "lazy" switches
	SetReset();

	//  Create the marginals in the cliques and sepsets
	CreateMarginals();

	_eState = BUILT;

	//  Load and initialize the tree
	Reload();

	//  Release the distributions from their target nodes
	_model.ClearDistributions();
}

DEFINEVP(GELEMLNK);

//
//  Destroy the junction tree.  Allow the GOBJMBN_CLIQSET object to be reused
//	for another cliquing operation later.
//
void GOBJMBN_CLIQSET :: Destroy ()
{
	if ( ! Model().Pgraph() )
		return;

	int cCliques = 0;
	int cCliqueMemberArcs = 0;
	int cSepsetArcs = 0;
	int cUndirArcs = 0;
	int cRootCliqueArcs = 0;

	VPGELEMLNK vpgelm;
	GELEMLNK * pgelm;
	MODEL::MODELENUM mdlenum( Model() );

	while ( pgelm = mdlenum.PlnkelNext() )
	{	
		bool bDelete = false;

		int eType = pgelm->EType();

		if ( pgelm->BIsEType( GELEM::EGELM_EDGE ) )
		{
			GEDGEMBN * pgedge;
			DynCastThrow( pgelm , pgedge );
			int eType = pgedge->EType();
		
			switch ( eType )
			{
				case GEDGEMBN::ETPROB:
					break;
				case GEDGEMBN::ETCLIQUE:
					//  Clique membership arcs will go away automatically because
					//	cliques will be deleted.
					++cCliqueMemberArcs;
					break;
				case GEDGEMBN::ETJTREE:
					//  Junction tree arcs will go away automatically because
					//  cliques will be deleted.
					++cSepsetArcs;
					break;
				case GEDGEMBN::ETUNDIR:
					//  Undirected arcs must be deleted explicitly
					bDelete = true;
					++cUndirArcs;
					break;
				case GEDGEMBN::ETCLIQSET:
					++cRootCliqueArcs;
					break;
				default:
					THROW_ASSERT( EC_INTERNAL_ERROR, " GOBJMBN_CLIQSET::Destroy: Unrecognized edge object in graph" );
					break;
			}
		}
		else
		if ( pgelm->BIsEType( GELEM::EGELM_NODE ) )
		{
			GOBJMBN * pgobj;
			DynCastThrow( pgelm , pgobj );
			switch ( eType )
			{
				case GOBJMBN::EBNO_CLIQUE:
				{
					++cCliques;
					bDelete = true;
					break;
				}
				case GOBJMBN::EBNO_CLIQUE_SET:
				case GOBJMBN::EBNO_NODE:
				case GOBJMBN::EBNO_PROP_TYPE:
				case GOBJMBN::EBNO_USER:
					break;
				default:
					THROW_ASSERT( EC_INTERNAL_ERROR, " GOBJMBN_CLIQSET::Destroy: Unrecognized node object in graph" );
					break;
			}
		}
		else
		{
			THROW_ASSERT( EC_INTERNAL_ERROR, " GOBJMBN_CLIQSET::Destroy: Unrecognized object in graph" );
		}

		if ( bDelete )
			vpgelm.push_back( pgelm );
	}

	assert(	
				cCliques == _cCliques
			&&	cCliqueMemberArcs == _cCliqueMemberArcs
			&&	cSepsetArcs == _cSepsetArcs
			&&	cUndirArcs == _cUndirArcs
		  );

	for ( int i = 0; i < vpgelm.size(); )
	{
		delete vpgelm[i++];
	}
	Clear();
}

void GOBJMBN_CLIQSET :: DestroyDirectedGraph ()
{
	int cUndirArcs = 0;

	VPGELEMLNK vpgelm;	
	GELEMLNK * pgelm;
	MODEL::MODELENUM mdlenum( Model() );

	while ( pgelm = mdlenum.PlnkelNext() )
	{	
		if ( pgelm->BIsEType( GELEM::EGELM_EDGE ) )
		{
			GEDGEMBN * pgedge;
			DynCastThrow( pgelm , pgedge );
			int eType = pgedge->EType();
		
			switch ( eType )
			{
				case GEDGEMBN::ETUNDIR:
					vpgelm.push_back( pgelm );
					++cUndirArcs;
					break;
				default:
					break;
			}
		}
	}

	assert(	cUndirArcs == _cUndirArcs );
	_cUndirArcs = 0;

	for ( int i = 0; i < vpgelm.size(); )
	{
		delete vpgelm[i++];
	}
}

//  Create and initialize all marginals tables
void GOBJMBN_CLIQSET :: CreateMarginals ()
{
	assert( _eState == CLIQUED ) ;
	//MSRDEVBUG:  The class name qualifier should not be necessary here and below.
	WalkTree( true, & GOBJMBN_CLIQSET::BCreateClique, & GOBJMBN_CLIQSET::BCreateSepset );
}

//  Reset the entire tree by reloading all marginals tables
void GOBJMBN_CLIQSET :: LoadMarginals ()
{
	assert( _eState == BUILT ) ;
	
	WalkTree( true, & GOBJMBN_CLIQSET::BLoadClique, & GOBJMBN_CLIQSET::BLoadSepset );

	_cqsetStat._cReload++;
}

//  Apply the given member function(s) to every clique tree in the forest.
int GOBJMBN_CLIQSET :: WalkTree (
	bool bDepthFirst,				//  Depth first or breadth first?
	PFNC_JTREE pfJtree,				//	Function to apply to each clique
	PFNC_SEPSET pfSepset )			//  Function to apply to each sepset
{
	int cClique = 0;		// Don't count the clique set object
	int cWalk = 0;			// Return count of cliques visited
	GNODENUM<GOBJMBN> benumChildren(false);
	benumChildren.SetETypeFollow( GEDGEMBN::ETCLIQSET );
	for ( benumChildren.Set( this );
		  benumChildren.PnodeCurrent();
		  benumChildren++ )
	{
		GOBJMBN * pgobj = *benumChildren;
		assert( pgobj->EType() == GNODEMBN::EBNO_CLIQUE );
		GOBJMBN_CLIQUE * pCliqueTreeRoot;
		DynCastThrow( pgobj, pCliqueTreeRoot );

		cWalk = bDepthFirst
			  ? WalkDepthFirst( pCliqueTreeRoot, pfJtree, pfSepset )
			  : WalkBreadthFirst( pCliqueTreeRoot, pfJtree, pfSepset );

		if ( cWalk < 0 )
			return -1;
		cClique += cWalk;
	}
	assert( cClique < 0 || cClique == _cCliques );
	return cClique;
}

//
//	Recursive depth-first walk down the tree.
//
//  Apply the given member function(s), depth first from this clique.
//  If application function call returns false, walk is aborted and
//	-1 is returned;	otherwise, count of cliques traversed is returned.
int GOBJMBN_CLIQSET :: WalkDepthFirst (
	GOBJMBN_CLIQUE * pClique,		//  Starting point
	PFNC_JTREE pfJtree,				//	Function to apply to each clique
	PFNC_SEPSET pfSepset )			//  Function to apply to each sepset
{
	assert( pClique ) ;
	assert( pClique->IInferEngID() == IInferEngID() ) ;

	if ( pfJtree )
	{
		//  Call the application function on the way down
		if ( ! (self.*pfJtree)( *pClique, true ) )
			return -1;
	}

	int cWalks = 1;		// Count the clique we just processed above
	int cWalk = 0;		// Return count of cliques visited
	GNODENUM<GOBJMBN_CLIQUE> benumChildren(false);
	benumChildren.SetETypeFollow( GEDGEMBN::ETJTREE );
	for ( benumChildren.Set( pClique );
		  benumChildren.PnodeCurrent();
		  benumChildren++ )
	{
		GOBJMBN_CLIQUE * pCliqueChild = NULL;
		GEDGEMBN_SEPSET * pgedge = NULL;

		if ( pfSepset )
		{
			//  Call the application function on the way down
			DynCastThrow( benumChildren.PgedgeCurrent(), pgedge );
			if ( ! (self.*pfSepset)( *pgedge, true ) )
				return -1;
		}
		DynCastThrow( benumChildren.PnodeCurrent(), pCliqueChild );
		cWalk = WalkDepthFirst( pCliqueChild, pfJtree, pfSepset );
		if ( cWalk < 0 )
			return -1;
		cWalks += cWalk;

		if ( pfSepset )
		{
			assert( pgedge );
			//  Call the application function on the way up
			if ( ! (self.*pfSepset)( *pgedge, false ) )
				return -1;
		}
	}

	if ( pfJtree )
	{
		//  Call the application function on the way up
		if ( ! (self.*pfJtree)( *pClique, false ) )
			return -1;
	}
	return cWalks;
}

//
//	Non-recursive breadth-first walk down the tree.
//	No "up" actions are called using the function pointers.
//
int GOBJMBN_CLIQSET :: WalkBreadthFirst (
	GOBJMBN_CLIQUE * pClique,		//  Starting point
	PFNC_JTREE pfJtree,				//	Function to apply to each clique
	PFNC_SEPSET pfSepset )			//  Function to apply to each sepset
{
	assert( pClique ) ;
	assert( pClique->IInferEngID() == IInferEngID() ) ;

	VPGEDGEMBN_SEPSET vpgedgeThis;
	VPGEDGEMBN_SEPSET vpgedgeNext;
	VPGEDGEMBN_SEPSET * pvpgedgeThis = & vpgedgeThis;
	VPGEDGEMBN_SEPSET * pvpgedgeNext = & vpgedgeNext;
	VPGEDGEMBN_SEPSET * pvpgedgeTemp = NULL;
	GOBJMBN_CLIQUE * pgobjClique = NULL;
	GEDGEMBN_SEPSET * pgedgeSepset = NULL;

	// Count the cliques we process, including this one
	int cWalk = 1;		

	// Starting clique is a special case; process it now
	if ( pfJtree )
	{
		//  Call the application function on the way down
		if ( ! (self.*pfJtree)( *pClique, true ) )
			return -1;
	}

	//  Prepare an enumerator for child cliques
	GNODENUM<GOBJMBN_CLIQUE> benumChildren(false);
	benumChildren.SetETypeFollow( GEDGEMBN::ETJTREE );

	//  Since we don't have the edge that led us here, put a NULL
	//		in its place to start iteration
	pvpgedgeNext->push_back(NULL);

	//  While there were entries at the last topological level...
	while ( pvpgedgeNext->size() )
	{
		//  Swap the array pointers and clear next pass array
		pexchange( pvpgedgeThis, pvpgedgeNext );
		pvpgedgeNext->clear();

		for ( int iEdge = 0; iEdge < pvpgedgeThis->size(); iEdge++ )
		{
			pgedgeSepset = (*pvpgedgeThis)[iEdge];
			pgobjClique = pgedgeSepset == NULL		
						? pClique		// This is the start of iteration
						: pgedgeSepset->PclqChild();

			assert( pgobjClique );
	
			//  Accumulate all child cliques of this clique,
			//		processing as necessary
			for ( benumChildren.Set( pgobjClique );
				  benumChildren.PnodeCurrent();
				  benumChildren++ )
			{
				GEDGEMBN_SEPSET * pgedge;
				DynCastThrow( benumChildren.PgedgeCurrent(), pgedge );

				if ( pfSepset )
				{
					//  Call the sepset application function on the way down
					if ( ! (self.*pfSepset)( *pgedge, true ) )
						return -1;
				}
				if ( pfJtree )
				{
					//  Call the clique application function on the way down
					GOBJMBN_CLIQUE * pCliqueChild = pgedge->PclqChild();
					if ( ! (self.*pfJtree)( *pCliqueChild, true ) )
						return -1;
				}
				cWalk++;
				pvpgedgeNext->push_back( pgedge );
			}
		}
	}

	return cWalk;
}

//
//  Terminology: "Create", "Init" and "Load":
//
//		'Create' means to size the dynamic arrays;
//		'Init'   means to initialize them to 1.0;
//		'Load'	 means to multiply in the probabilities of the clique members.
//
bool GOBJMBN_CLIQSET :: BCreateClique ( GOBJMBN_CLIQUE & clique, bool bDownwards )
{
	if ( ! bDownwards )
		return true;

	clique.CreateMarginals();
	return true;
}

bool GOBJMBN_CLIQSET :: BLoadClique ( GOBJMBN_CLIQUE & clique, bool bDownwards )
{
	if ( ! bDownwards )
		return true;

	clique.InitMarginals();
	clique.LoadMarginals();
	return true;
}

bool GOBJMBN_CLIQSET :: BCreateSepset ( GEDGEMBN_SEPSET & sepset, bool bDownwards )
{
	if ( ! bDownwards )
		return true;

	sepset.CreateMarginals();
	return true;
}

bool GOBJMBN_CLIQSET :: BLoadSepset ( GEDGEMBN_SEPSET & sepset, bool bDownwards )
{
	if ( ! bDownwards )
		return true;

	sepset.InitMarginals();
	return true;
}

//  Return the "family" or "self" clique for a node
GOBJMBN_CLIQUE * GOBJMBN_CLIQSET :: PCliqueFromNode (
	GNODEMBN * pgnd,					//  Node to find clique for
	bool bFamily, 						//	"family" clique if true, "self" clique if false
	GEDGEMBN_CLIQ * * ppgedgeClique )	//  return pointer to edge if not NULL
{
	GEDGEMBN_CLIQ::FCQLROLE fcqlRole = bFamily
									 ? GEDGEMBN_CLIQ::FAMILY
									 : GEDGEMBN_CLIQ::SELF;
	//  Prepare to iterate over the source arcs
	GNODENUM<GOBJMBN> benumMembers(true);
	benumMembers.SetETypeFollow( GEDGEMBN::ETCLIQUE );
	for ( benumMembers.Set( pgnd );
		  benumMembers.PnodeCurrent();
		  benumMembers++ )
	{
		GEDGEMBN_CLIQ * pgedgeClique;
		DynCastThrow( benumMembers.PgedgeCurrent(), pgedgeClique );
		GOBJMBN_CLIQUE * pgobjClique = pgedgeClique->PclqParent();
		if ( pgobjClique->IInferEngID() != IInferEngID() )
			continue;  //  not an edge for this junction tree
		if ( pgedgeClique->IFcqlRole() & fcqlRole )
		{
			if ( ppgedgeClique )
				*ppgedgeClique = pgedgeClique;
			return pgedgeClique->PclqParent();
		}
	}
	assert( false );
	return NULL;
}

//
//  Enter evidence for a node.
//
void GOBJMBN_CLIQSET :: EnterEvidence ( GNODEMBN * pgnd, const CLAMP & clamp )
{	
	//  Get the pointer to the node's "self" clique and the edge leading to it
	GEDGEMBN_CLIQ * pgedgeClique = NULL;
	GOBJMBN_CLIQUE * pCliqueSelf = PCliqueFromNode( pgnd, false, & pgedgeClique );
	ASSERT_THROW( pCliqueSelf,
				  EC_INTERNAL_ERROR,
				  "GOBJMBN_CLIQSET::EnterEvidence: can\'t find self clique" );
	assert( pgedgeClique );

	//  Update with evidence if it has changed
	if ( pgedgeClique->Clamp() != clamp )
	{		
		//  Evidence is NOT the same as the old evidence
		pgedgeClique->Clamp() = clamp;
		//  Indicate that we must reload the tree
		SetReset();
		pCliqueSelf->SetCollect();

		_cqsetStat._cEnterEv++;
	}
}

//
//	Return the evidence "clamp" for a node.  It is stored in the edge
//	between the node and its "self" clique: the highest clique in the tree
//	of which the node is a member.
//
void GOBJMBN_CLIQSET :: GetEvidence ( GNODEMBN * pgnd, CLAMP & clamp )
{
	//  Get the pointer to the node's "self" clique and the edge leading to it
	GEDGEMBN_CLIQ * pgedgeClique = NULL;
	GOBJMBN_CLIQUE * pCliqueSelf = PCliqueFromNode( pgnd, false, & pgedgeClique );
	ASSERT_THROW( pCliqueSelf,
				  EC_INTERNAL_ERROR,
				  "GOBJMBN_CLIQSET::GetEvidence: can\'t find self clique" );

	assert( pgedgeClique );
	clamp = pgedgeClique->Clamp();
}

void GOBJMBN_CLIQSET :: GetBelief ( GNODEMBN * pgnd, MDVCPD & mdvBel )
{
	GEDGEMBN_CLIQ * pgedgeClique = NULL;
	GOBJMBN_CLIQUE * pCliqueFamily = PCliqueFromNode( pgnd, true, & pgedgeClique );
	ASSERT_THROW( pCliqueFamily,
				  EC_INTERNAL_ERROR,
				  "GOBJMBN_CLIQSET::GetBelief: can\'t find family clique" );
	//  Perform inference if necessary
	Infer();
	//  Marginalize the clique down to one node
	GNODEMBND * pgndd;
	DynCastThrow( pgnd, pgndd );
	pgedgeClique->MiterNodeBelief().MarginalizeBelief( mdvBel, pgndd );

	_cqsetStat._cGetBel++;
}

PROB GOBJMBN_CLIQSET :: ProbNorm ()
{
	// MSRDEVBUG
	/*
	Reset();
	CollectEvidence();
	*/
	Infer();

	_cqsetStat._cProbNorm++;
	return _probNorm;
}

//
//	Reload all marginals, reset the trees
//
void GOBJMBN_CLIQSET :: Reload ()
{
	SetReset( true );
	Reset();
}

//
//	Reset all marginals, restore all clamped evidence and
//		perform the initial inference pass.
//
void GOBJMBN_CLIQSET :: Reset ()
{
	assert( EState() >= BUILT );
	if ( ! _bReset )
		return;

	_probNorm = 1.0;
	LoadMarginals();
	SetReset( false );

	//  Initialize the entire tree for inference
#ifdef INFERINIT
	InferInit();
#endif

	SetCollect(true);
}

//  Perform an inference cycle if necessary
void GOBJMBN_CLIQSET :: Infer ()
{
	Reset();		//  Reloads the tree if necessary
	if ( ! BCollect() )
		return;

#ifdef DUMPCLIQUESET
	cout << "\n\n===============================================================";
	cout <<   "\n============= Dump of clique tree before inference ===============\n";
	Dump();
	cout << "\n========= End Dump of clique tree before inference ===============";
	cout << "\n===============================================================\n\n";
	cout << "\n\nGOBJMBN_CLIQSET::Infer: begin.";
#endif

	CollectEvidence();
	DistributeEvidence();	

#ifdef CONSISTENCY
	CheckConsistency();
#endif
	
	SetCollect( false );

#ifdef DUMPCLIQUESET
	cout << "\n\n===============================================================";
	cout <<   "\n============= Dump of clique tree after inference ===============\n";
	Dump();
	cout << "\n========= End Dump of clique tree after inference ===============";
	cout << "\n===============================================================\n\n";
	cout << "\nGOBJMBN_CLIQSET::Infer: end.\n\n";
#endif
}

//   Perform initial inference collect/distribute cycle
void GOBJMBN_CLIQSET :: InferInit ()
{
#ifdef DUMPCLIQUESET
	cout << "\n\n===============================================================";
	cout <<   "\n============= Dump of clique tree before inference INIT ======\n";
	Dump();
	cout << "\n========= End Dump of clique tree before inference  INIT ======";
	cout << "\n===============================================================\n\n";
	cout << "\n\nGOBJMBN_CLIQSET::InferInit: begin.";
#endif

	CollectEvidenceInit();
	DistributeEvidenceInit();	

#ifdef DUMPCLIQUESET
	cout << "\n\n===============================================================";
	cout <<   "\n============= Dump of clique tree after inference  INIT =======\n";
	Dump();
	cout << "\n========= End Dump of clique tree after inference  INIT ========";
	cout << "\n================================================================\n\n";
	cout << "\nGOBJMBN_CLIQSET::InferInit: end.\n\n";
#endif
}

void GOBJMBN_CLIQSET :: CollectEvidence()
{
	WalkTree( true, BCollectEvidenceAtRoot,
				    BCollectEvidenceAtSepset );

	_cqsetStat._cCollect++;
}

void GOBJMBN_CLIQSET :: DistributeEvidence()
{
	WalkTree( true, BDistributeEvidenceAtRoot,
				    BDistributeEvidenceAtSepset );
}

void GOBJMBN_CLIQSET :: CollectEvidenceInit ()
{
	WalkTree( true, BCollectInitEvidenceAtRoot,
				    BCollectInitEvidenceAtSepset );
}

void GOBJMBN_CLIQSET :: DistributeEvidenceInit ()
{
	WalkTree( true, BDistributeInitEvidenceAtRoot,
				    BDistributeInitEvidenceAtSepset );
}

void GOBJMBN_CLIQSET :: CheckConsistency ()
{
	WalkTree( true, NULL, BConsistentSepset );
}

bool GOBJMBN_CLIQSET :: BConsistentSepset ( GEDGEMBN_SEPSET & sepset, bool bDownwards )
{
	if ( ! bDownwards )
		return true;
	return sepset.BConsistent();
}

//  When the collection cycle has completed for a tree, recompute the
//	"prob norm" value.
bool GOBJMBN_CLIQSET :: BCollectEvidenceAtRoot ( GOBJMBN_CLIQUE & clique, bool bDownwards )
{
	if ( bDownwards || ! clique.BRoot() )
		return true;

	//  This is a root clique at the end of the collection cycle.
	//  Normalize the clique and maintain the norm of the the probability
	//  of the tree.
	//  MSRDEVBUG: (Explain this better!)
	REAL rProb = clique.Marginals().RSum();
	_probNorm *= rProb;
	if ( rProb != 0.0 )
	{
		rProb = 1.0 / rProb;
		clique.Marginals().Multiply( rProb );
	}

#ifdef DUMPCLIQUESET
	cout << "\nCollect Evidence (root), clique "
		 << clique._iClique
		 << ", root = "
		 << int(clique._bRoot)
		 << ", prob norm = "
		 << _probNorm;
#endif
	return true;
}

bool GOBJMBN_CLIQSET :: BDistributeEvidenceAtRoot ( GOBJMBN_CLIQUE & clique, bool bDownwards )
{
	if ( ! bDownwards || ! clique.BRoot() )
		return true;

#ifdef DUMPCLIQUESET
	cout << "\nDistribute Evidence (root), clique "
		 << clique._iClique
		 << ", root = "
		 << int(clique._bRoot);
#endif

	return true;
}

bool GOBJMBN_CLIQSET :: BCollectEvidenceAtSepset ( GEDGEMBN_SEPSET & sepset, bool bDownwards )
{
	GOBJMBN_CLIQUE * pCliqueChild = sepset.PclqChild();
	GOBJMBN_CLIQUE * pCliqueParent = sepset.PclqParent();

	if ( bDownwards )
		return true;

#ifdef DUMPCLIQUESET

	cout << "\nCollect Evidence (sepset), clique "
		 << pCliqueChild->_iClique
		 << ", root = "
		 << int(pCliqueChild->_bRoot)
		 << ", parent = "
		 << pCliqueParent->_iClique
		 ;
	cout.flush();
#endif

	if ( ! pCliqueChild->BCollect() )
		return true;
	pCliqueParent->SetCollect();

	sepset.UpdateParentClique();
	
	SetCollect( false );
	return true;
}

bool GOBJMBN_CLIQSET :: BDistributeEvidenceAtSepset ( GEDGEMBN_SEPSET & sepset, bool bDownwards )
{
	if ( ! bDownwards )
		return true;

#ifdef DUMPCLIQUESET
	GOBJMBN_CLIQUE * pCliqueChild = sepset.PclqChild();
	GOBJMBN_CLIQUE * pCliqueParent = sepset.PclqParent();

	cout << "\nDistribute Evidence (sepset), clique "
		 << pCliqueParent->_iClique
		 << ", root = "
		 << int(pCliqueParent->_bRoot)
		 << ", child = "
		 << pCliqueChild->_iClique
		 ;
	cout.flush();
#endif

	sepset.UpdateChildClique();

	return true;
}

bool GOBJMBN_CLIQSET :: BCollectInitEvidenceAtSepset ( GEDGEMBN_SEPSET & sepset, bool bDownwards )
{
	if ( bDownwards )
		return true;

#ifdef DUMPCLIQUESET
	GOBJMBN_CLIQUE * pCliqueChild = sepset.PclqChild();
	GOBJMBN_CLIQUE * pCliqueParent = sepset.PclqParent();

	cout << "\nCollect Initial Evidence (sepset), clique "
		 << pCliqueChild->_iClique
		 << ", root = "
		 << int(pCliqueChild->_bRoot)
		 << ", parent = "
		 << pCliqueParent->_iClique
		 ;
	cout.flush();
#endif

	sepset.BalanceCliquesCollect();

	return true;
}

bool GOBJMBN_CLIQSET :: BDistributeInitEvidenceAtSepset ( GEDGEMBN_SEPSET & sepset, bool bDownwards )
{
	if ( ! bDownwards )
		return true;

#ifdef DUMPCLIQUESET
	GOBJMBN_CLIQUE * pCliqueParent = sepset.PclqParent();
	GOBJMBN_CLIQUE * pCliqueChild = sepset.PclqChild();

	cout << "\nDistribute Initial Evidence (sepset), clique "
		 << pCliqueParent->_iClique
		 << ", root = "
		 << int(pCliqueParent->_bRoot)
		 << ", child = "
		 << pCliqueChild->_iClique
		 ;
	cout.flush();
#endif

	sepset.BalanceCliquesDistribute();
	return true;
}

bool GOBJMBN_CLIQSET :: BCollectInitEvidenceAtRoot ( GOBJMBN_CLIQUE & clique, bool bDownwards )
{
	if ( bDownwards || ! clique.BRoot() )
		return true;

#ifdef DUMPCLIQUESET
	cout << "\nCollect Initial Evidence at root, clique "
		 << clique._iClique
		 << ", root = "
		 << int(clique._bRoot);
#endif

	clique.Marginals().Normalize();
	return true;
}

bool GOBJMBN_CLIQSET :: BDistributeInitEvidenceAtRoot ( GOBJMBN_CLIQUE & clique, bool bDownwards )
{
	return true;
}

void GOBJMBN_CLIQSET :: Dump ()
{
	WalkTree( true, BDumpClique, BDumpSepset );
	MARGSUBITER::Dump();
}

bool GOBJMBN_CLIQSET :: BDumpSepset ( GEDGEMBN_SEPSET & sepset, bool bDownwards )
{
	if ( ! bDownwards )
		return true;

	sepset.Dump();
	return true;
}

bool GOBJMBN_CLIQSET :: BDumpClique ( GOBJMBN_CLIQUE & clique, bool bDownwards )
{
	if ( ! bDownwards )
		return true;

	clique.Dump();
	return true;
}

// End of CLIQUE.CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\cliqwork.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       cliqwork.h
//
//--------------------------------------------------------------------------

//
//	cliqwork.h: Helper structures and templates for junction tree formation
//
#ifndef _CLIQWORK_H_
#define _CLIQWORK_H_

#include "algos.h"		// Include the <algorithms> and additions

class NDCQINFO
{
  public:
	GNODEMBN * _pgnd;			//  Node pointer
	int _iCliqOrdSelf;			//	Index of ordered clique containing self
	int _iCliqOrdFamily;		//  Index of family clique (self & parents)

	NDCQINFO ()
		: _pgnd(NULL),
		_iCliqOrdSelf(-1),
		_iCliqOrdFamily(-1)
		{}
	DECLARE_ORDERING_OPERATORS(NDCQINFO);
};

inline bool NDCQINFO :: operator < ( const NDCQINFO & ndcq ) const
{
	assert( _pgnd && ndcq._pgnd );
	return _pgnd->ITopLevel() < ndcq._pgnd->ITopLevel() ;	
}

DEFINEV(NDCQINFO);
DEFINEVP(GOBJMBN_CLIQUE);

//  Helper structure for cliquing
class CLIQSETWORK 
{		
  public:
	CLIQSETWORK ( GOBJMBN_CLIQSET & cliqset )
		: _cliqset(cliqset),
		_iElimIndex(-1),
		_cTrees(0)
		{}

	void PrepareForBuild ();
	void RenumberNodesForCliquing ();
	int CNodesCommon ( int iClique1, int iClique2 );
	int CNodesCommon ( const VPGNODEMBN & vpgnd1,  const VPGNODEMBN & vpgnd2 );
	void SetCNodeMaxCommon ( int iClique1, int iCliqueOrdered2 );
	bool BUpdateCNodeMaxCommon ( int iClique );
	bool BBetter ( int iClique1, int iClique2 );
	void BuildCliques ();
	void SetTopologicalInfo ();
	void CreateTopology ();

	//  Return the ordered index of a clique or -1 if not in the tree yet.
	int IOrdered ( int iClique );
	bool BCheckRIP ();
	bool BCheckRIP ( int iCliqueOrdered );
	void TopSortNodeCliqueInfo ();
	static void MarkSortNodePtrArray ( VPGNODEMBN & vpgnd );

	MBNET & Model ()
		{ return _cliqset.Model(); }

	REAL REstimatedSize ();

	void DumpCliques ();
	void DumpClique ( int iClique );
	void DumpTree ();
	void DumpTopInfo ();

  public:
	GOBJMBN_CLIQSET & _cliqset;

	//  Vector of nodes pointers in total ordering
	VNDCQINFO _vndcqInfo;

	//  Vector of vectors of node pointers (clique members)
	VVPGNODEMBN _vvpgnd;

	//  Clique ordering; 
	//		< 0					==> subsumed into another clique;
	//		0 <= i < INT_MAX	==> ordering into _viOrdered;
	//		== INT_MAX			==> deleted or merged
	VINT _viOrder;

	//	Parent clique indicies by clique index
	VINT _viParent;
	
	//  Clique indicies as they are ordered
	VINT _viOrdered;

	//  Number of nodes in common with most common clique;
	//		indexed by absolute clique index.
	VINT _viCNodesCommon;

	//  Contains ordered clique index of most common clique;
	//		indexed by absolute clique index.
	VINT _viICliqCommon;

	//  Ordered parent index of each ordered clique
	VINT _viParentOrdered;
	//  Topological level of each ordered clique
	VINT _viTopLevelOrdered;  

	//	Array of pointers to cliques created
	VPGOBJMBN_CLIQUE _vpclq;

	//  Elimination index
	int _iElimIndex;

	//  Number of trees created
	int _cTrees;
};

#endif
// End Of JTREEWORK.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\cliqwork.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       cliqwork.cpp
//
//--------------------------------------------------------------------------

//
//	cliqwork.cpp
//

#include <basetsd.h>
#include "cliqset.h"
#include "clique.h"
#include "cliqwork.h"

#ifdef _DEBUG
//	#define DUMP
#endif

//  Sort helper 'less' function for sorting arrays of node pointers into 'mark' sequence.
class MARKSRTPGND : public binary_function<const GNODEMBN *, const GNODEMBN *, bool>
{	
  public:
	bool operator () (const GNODEMBN * pa, const GNODEMBN * pb) const
		{	return pa->IMark() < pb->IMark() ;	}
};

#ifdef _DEBUG
static void seqchkVpnodeByMark (const VPGNODEMBN & vpgnd)
{
	int imrk = INT_MIN;
	int imrk2;
	for ( int i = 0; i < vpgnd.size(); i++, imrk = imrk2)
	{
		imrk2 = vpgnd[i]->IMark();
		assert( imrk2 >= 0 );
		assert( imrk2 >= imrk );
	}
}
#endif

//  Sort the clique information array into topological sequence
void CLIQSETWORK :: TopSortNodeCliqueInfo ()
{
	sort( _vndcqInfo.begin(), _vndcqInfo.end() );
}

//  Sort the given node pointer array in to "mark" (cliquing order) sequence
void CLIQSETWORK :: MarkSortNodePtrArray ( VPGNODEMBN & vpgnd )
{
	MARKSRTPGND marksorter;
	sort( vpgnd.begin(), vpgnd.end(), marksorter );

#ifdef _DEBUG
	seqchkVpnodeByMark( vpgnd );
#endif
}

//  Establish an absolute ordering based upon the topological ordering
void  CLIQSETWORK :: RenumberNodesForCliquing ()
{
	//  Perform a topological sort of the network
	Model().TopSortNodes();

	MODEL::MODELENUM mdlenum( Model() );
	GELEMLNK * pgelm;
	_vndcqInfo.clear();

	//  Collect all the nodes into a pointer array
	while ( pgelm = mdlenum.PlnkelNext() )
	{	
		if ( pgelm->EType() != GOBJMBN::EBNO_NODE )
			continue;
			
		NDCQINFO ndcq;
		DynCastThrow( pgelm, ndcq._pgnd );

		_vndcqInfo.push_back( ndcq );
	}
	//  Sort the array into topological sequence.
	TopSortNodeCliqueInfo();

#ifdef _DEBUG
	int iTop = -1;
#endif

	//  Establish the total ordering based upon topological level.
	for ( int i = 0; i < _vndcqInfo.size() ; i++ )
	{
		GNODEMBN * pgnd = _vndcqInfo[i]._pgnd;
		assert( pgnd );
#ifdef _DEBUG
		//  Check sequence.
		assert( iTop <= pgnd->ITopLevel() );
		iTop = pgnd->ITopLevel();
#endif
		pgnd->IMark() = i;
	}
}

void CLIQSETWORK :: PrepareForBuild ()
{
	//  Resize and initialize the work arrays
	int cCliques = _vvpgnd.size();

	_viParent.resize( cCliques );
	_viOrder.resize( cCliques );
	_viCNodesCommon.resize( cCliques );
	_viICliqCommon.resize( cCliques );
	_viOrdered.clear();

	for ( int iClique = 0; iClique < cCliques; iClique++ )
	{
		MarkSortNodePtrArray( _vvpgnd[iClique] );

		_viParent[iClique]			= INT_MIN;
		_viOrder[iClique]			= INT_MIN;
		_viCNodesCommon[iClique]	= INT_MIN;
		_viICliqCommon[iClique]		= INT_MIN;
	}
}

//	Return the number of nodes in common between the two cliques
int CLIQSETWORK :: CNodesCommon ( int iClique1, int iClique2 )
{
	assert( iClique1 < _vvpgnd.size() && iClique2 < _vvpgnd.size() );

	return CNodesCommon( _vvpgnd[iClique1], _vvpgnd[iClique2] );
}

//	Return the number of nodes in common between the two node lists
int CLIQSETWORK :: CNodesCommon ( const VPGNODEMBN & vpgnd1, const VPGNODEMBN & vpgnd2 )
{
	MARKSRTPGND marksorter;

#ifdef _DEBUG
	seqchkVpnodeByMark( vpgnd1 );
	seqchkVpnodeByMark( vpgnd2 );
#endif

	int cCommon = count_set_intersection( vpgnd1.begin(),
										   vpgnd1.end(),
										   vpgnd2.begin(),
										   vpgnd2.end(),
										   marksorter );
	return cCommon;
}


//  Return the ordered index of a clique or -1 if not in the tree yet.
inline
int CLIQSETWORK :: IOrdered ( int iClique )
{
	return ifind( _viOrdered, iClique );
}

//  Update the "most common clique" info of iClique1 based upon iClique2.  This is
//  used to count the number of nodes in common between a candidate clique and a
//	clique already in the tree.
void CLIQSETWORK :: SetCNodeMaxCommon ( int iClique1, int iCliqueOrdered2 )
{
	assert( iCliqueOrdered2 < _viOrdered.size() );

	int iClique2 = _viOrdered[iCliqueOrdered2];
	int cCommon = CNodesCommon( iClique1, iClique2 );
	if ( cCommon > _viCNodesCommon[iClique1] )
	{
		_viCNodesCommon[iClique1] = cCommon;
		_viICliqCommon[iClique1] = iCliqueOrdered2;
	}
}

//
//	Completely update the "most common clique" information for this clique.
//	This is necessary because cliques can change membership due to subsumption
//	during generation of the clique tree.
//	Return true if there is any overlap with a clique already in the tree.
//
bool CLIQSETWORK :: BUpdateCNodeMaxCommon ( int iClique )
{
	assert( _viOrder[iClique] == INT_MIN );
	int & cNodesCommon = _viCNodesCommon[iClique];
	int & iCliqCommon = _viICliqCommon[iClique];
	cNodesCommon = INT_MIN;
	iCliqCommon = INT_MIN;
	for ( int iord = 0; iord < _viOrdered.size(); iord++ )		
	{
		SetCNodeMaxCommon( iClique, iord );
	}
	return cNodesCommon > 0;
}

//  Return true if clique 1 has more nodes in common with a clique that is already in
//		the tree than clique2.  If they have the same number of nodes in common, return
//		true if clique 1 has fewer nodes than clique2.
bool CLIQSETWORK :: BBetter ( int iClique1, int iClique2 )
{
	assert( _viCNodesCommon[iClique1] >= 0 );
	assert( _viCNodesCommon[iClique2] >= 0 );

	if ( _viCNodesCommon[iClique1] != _viCNodesCommon[iClique2] )
		return _viCNodesCommon[iClique1] > _viCNodesCommon[iClique2];

	return _vvpgnd[iClique1].size() < _vvpgnd[iClique2].size();
}


//  After building the cliques, topologically sort them and anchor each node
//  to the highest clique in the tree to which it belongs.
void CLIQSETWORK :: SetTopologicalInfo ()
{
#ifdef DUMP
	DumpTree();
#endif

	//  First, set up the ordered parent information array
	int cCliqueOrdered = _viOrdered.size();
	assert( cCliqueOrdered > 0 );
	int cClique = _viOrder.size();

	_viParentOrdered.resize(cCliqueOrdered);
	for ( int icq = 0; icq < cCliqueOrdered; ++icq )
	{
		int iClique = _viOrdered[icq];
		assert( iClique < cClique && iClique >= 0 );
		int iCliqueParent = _viParent[iClique];
		assert( iCliqueParent < cClique && iCliqueParent >= 0 );
		assert( CNodesCommon( iClique, iCliqueParent ) > 0 );
		int iCliqueParentOrdered = IOrdered( iCliqueParent );
		assert( iCliqueParentOrdered < cCliqueOrdered && iCliqueParentOrdered >= 0 );
		_viParentOrdered[icq] = iCliqueParentOrdered;
	}

	//  Next, follow each ordered clique's parentage to compute its topological level
	_viTopLevelOrdered.resize(cCliqueOrdered);
	int cTrees = 0;
	for ( icq = 0; icq < cCliqueOrdered; ++icq )
	{
		int icqParent  = icq;
		//  Follow until we get to a (the) root clique
		for ( int itop = 0; icqParent != _viParentOrdered[icqParent]; ++itop )
		{
			assert( itop < cCliqueOrdered );
			icqParent = _viParentOrdered[icqParent];
		}
		if ( itop == 0 )
			cTrees++ ;
		_viTopLevelOrdered[icq] = itop;
	}
	assert( cTrees == _cTrees );

	//  Next, find each node's "family" clique.  This is the smallest clique containing
	//  it and its parents.

	VPGNODEMBN vpgnd;
	for ( int ind = 0 ; ind < _vndcqInfo.size(); ind++ )
	{
		NDCQINFO & ndcq = _vndcqInfo[ind];
		vpgnd.clear();
		//  Get the "family" set and sort it for matching other cliques.
		ndcq._pgnd->GetFamily( vpgnd );
		MarkSortNodePtrArray( vpgnd );

		int cFamily = vpgnd.size();
		int cCommonSize = INT_MAX;
		int iCqCommon = -1;

		//  Find the smallest clique containing the family
		for ( icq = 0; icq < cCliqueOrdered; ++icq )
		{
			const VPGNODEMBN & vpgndClique = _vvpgnd[ _viOrdered[icq] ];
			int cCqCommon = CNodesCommon( vpgnd, vpgndClique );
			//  See if this clique contains the family and is smaller than any other.
			if ( cCqCommon == cFamily && vpgndClique.size() < cCommonSize )
			{	
				iCqCommon = icq;
			}
		}
		assert( iCqCommon >= 0 );
		ndcq._iCliqOrdFamily = iCqCommon;
		
		//  Now, find the highest clique in the tree containing this node.
		int itop = INT_MAX;
		int iCqTop = -1;
		for ( icq = 0; icq < cCliqueOrdered; ++icq )
		{
			const VPGNODEMBN & vpgndClique = _vvpgnd[ _viOrdered[icq] ];
			int ind = ifind( vpgndClique, ndcq._pgnd );
			if ( ind >= 0 && _viTopLevelOrdered[icq] < itop )
			{	
				iCqTop = icq;
				itop = _viTopLevelOrdered[icq];
			}
		}
		assert( iCqTop >= 0 );
		ndcq._iCliqOrdSelf = iCqTop;
	}

#ifdef DUMP
	DumpTopInfo();
#endif
}

void CLIQSETWORK :: BuildCliques ()
{
	//  Prepare tables for junction tree construction
	PrepareForBuild() ;

	//  Choose the zeroth arbitrarily as a starting point; set it as its own parent.
	//  As we iterate over the array, we assign an ordering to cliques.  If the clique has
	//  already been ordered, its value in _viOrder will either >= 0 (order in clique tree)
	//	
	_cTrees = 1;

	_viParent[0] = 0;
	_viOrder[0] = 0;
	_viOrdered.clear();
	_viOrdered.push_back(0);

	for (;;)
	{
		int iCliqueBest = INT_MAX;			//  Best clique found so far

		// Find a new clique that has the largest overlap with any of the cliques already in the tree.
		for ( int iClique = 0; iClique < _vvpgnd.size(); iClique++ )
		{
			int iord = _viOrder[iClique];
			if ( iord != INT_MIN )
				continue;	// Clique has already been ordered or dealt with

			//  Update the "most common clique already in tree" info between this clique
			//		and all the cliques in the trees
			BUpdateCNodeMaxCommon( iClique );

			//MSRDEVBUG:  SetCNodeMaxCommon( iClique, _viOrdered.size() - 1 );

			if ( iCliqueBest == INT_MAX )
			{
				// first time through the loop
				iCliqueBest = iClique;
			}
			else
			if ( BBetter( iClique, iCliqueBest ) )
			{
				//  This clique has an overlap as large as any other yet found.
				iCliqueBest = iClique;
			}
		}
		//  See if we're done
		if ( iCliqueBest == INT_MAX )
			break;

		// Get the ordered index and absolute index of the most common clique
		int iCliqueCommonOrdered = _viICliqCommon[iCliqueBest];
		assert( iCliqueCommonOrdered >= 0 && iCliqueCommonOrdered < _viOrdered.size() );
		int iCliqueCommon = _viOrdered[ iCliqueCommonOrdered ];
		assert( iCliqueCommon >= 0 );
		assert( iCliqueBest != iCliqueCommon );
		int cNodesCommon = _viCNodesCommon[iCliqueBest];
		assert( cNodesCommon <= _vvpgnd[iCliqueCommon].size() );
		assert( cNodesCommon <= _vvpgnd[iCliqueBest].size() );
		assert( cNodesCommon == CNodesCommon( iCliqueCommon, iCliqueBest ) ) ;

		//  Index of clique to be added to ordered clique set
		int iCliqueNew = INT_MAX;

		//  If the candidate clique has the same number of nodes in common with its most
		//  common clique as that clique has members, then this clique is either identical
		//  to or a superset of that clique.

		if ( cNodesCommon == _vvpgnd[iCliqueCommon].size() )
		{
			//  New clique is superset of its most common clique.
			assert( cNodesCommon != 0 );
			assert( iCliqueCommon != iCliqueBest );
			assert( _vvpgnd[iCliqueCommon].size() < _vvpgnd[iCliqueBest].size() );

			//  Assign this clique's node set to the previously ordered subset clique
			_vvpgnd[iCliqueCommon] = _vvpgnd[iCliqueBest] ;
			assert ( _vvpgnd[iCliqueCommon].size() == _vvpgnd[iCliqueBest].size() );
			//  Leave the parent the same as it was
			iCliqueNew = iCliqueCommon;
		}
		else
		if ( cNodesCommon == 0 )
		{
			//  This is the start of a new tree
			_cTrees++;
			//  Self and parent are the same
			_viParent[iCliqueBest] = iCliqueNew = iCliqueBest;
			_viOrdered.push_back( iCliqueNew );
		}
		else
		if ( cNodesCommon != _vvpgnd[iCliqueBest].size() )
		{
			//  New clique is child of existing clique.
			iCliqueNew = iCliqueBest;
			_viParent[iCliqueBest] = iCliqueCommon ;
			//  Keep this clique by adding it to the ordered clique set.
			_viOrdered.push_back( iCliqueNew );
		}
		else
		{
			//  Child is subset of parent; ignore by marking as "subsumed"
			iCliqueNew = - iCliqueCommon;
		}

		//  Mark the clique as either ordered or subsumed.
		_viOrder[iCliqueBest] = iCliqueNew;
	}	

#ifdef DUMP
	cout << "\n\nBuild cliques;  generated " << _cTrees << " clique trees\n\n";
#endif
}

//  Verify that the Running Intersection Property holds for this clique tree.
bool CLIQSETWORK :: BCheckRIP ()
{
	// Check that topological information has been generated
	assert( _viOrdered.size() == _viParentOrdered.size() );

	for ( int iCliqueOrdered = 0; iCliqueOrdered < _viOrdered.size(); iCliqueOrdered++ )
	{
		if ( ! BCheckRIP( iCliqueOrdered ) )
			return false;
	}
	return true;
}

//  Verify that the Running Intersection Property holds for this clique.
bool CLIQSETWORK :: BCheckRIP ( int iCliqueOrdered )
{
	int iClique = _viOrdered[iCliqueOrdered];
	const VPGNODEMBN & vpgndClique = _vvpgnd[iClique];
	int iCliqueParent = _viParent[iClique];
	const VPGNODEMBN & vpgndCliqueParent = _vvpgnd[iCliqueParent];

	bool bRoot = iCliqueParent == iClique;

	// For every node in this clique, check that either:
	//
	//		1) this is a root clique, or
	//		2) the node is present in the parent clique.
	//
	// If this test fails, check that this is the "self" clique,
	//		which is the highest clique in the tree in which the
	//		node appears.
	//
	for ( int iNode = 0; iNode < vpgndClique.size(); iNode++ )
	{
		//  Access the node information for this node
		GNODEMBN * pgnd = vpgndClique[iNode];
		if ( bRoot || ifind( vpgndCliqueParent, pgnd ) < 0 )
		{
			NDCQINFO & ndcq = _vndcqInfo[ pgnd->IMark() ];
			if ( ndcq._iCliqOrdSelf != iCliqueOrdered )
			{			
#ifdef _DEBUG
				cout << "RIP FAILURE: node "
					 << ndcq._pgnd->ZsrefName().Szc()
					 << " is in clique "
					 << iCliqueOrdered
					 << " but absent from "
					 << _viParentOrdered[iCliqueOrdered]
					 << "("
					 << _viParent[iClique]
					 << ")"
					 ;
#endif
				return false;
			}
		}
	}
	return true;
}

//  Using the constructed tables, create the clique objects and
//  link them to each other and their member nodes.

void CLIQSETWORK :: CreateTopology ()
{
	_vpclq.resize( _viOrdered.size() ) ;
	for ( int i = 0; i < _vpclq.size(); )
		_vpclq[i++] = NULL;

	int iInferEngID = _cliqset._iInferEngID;

	int ccq = 0;	// Total cliques created

	//  Create all cliques.  Iterate in topological order, creating
	//		the cliques and linking them to their parents.
	for ( int itop = 0;; itop++)
	{
		int ccqLevel = 0;	// Number of cliques added at this topological level
		for ( int icq = 0; icq < _viOrdered.size(); icq++ )
		{
			if ( _viTopLevelOrdered[icq] != itop )
				continue;

			GOBJMBN_CLIQUE * pclqParent = NULL;
			GOBJMBN_CLIQUE * pclqThis = NULL;
			int iParentOrdered = _viParentOrdered[icq];
			if ( iParentOrdered != icq )
			{
				//  Get the parent clique pointer
				pclqParent = _vpclq[ iParentOrdered ];
				assert( pclqParent );
			}
			else
			{
				//  Root cliques have toplevel zero
				assert( itop == 0 );
			}
			//  Create the new clique and its edge to its parent clique (if any)
			pclqThis = _vpclq[icq] = new GOBJMBN_CLIQUE( icq, iInferEngID );
			Model().AddElem( pclqThis );
			if ( pclqParent )
			{
				//  This is not a root clique; link it to its parent.
				Model().AddElem( new GEDGEMBN_SEPSET( pclqParent, pclqThis ) );
			}
			else
			{
				//  This IS a root clique; mark it and link it to the clique set top.
				pclqThis->_bRoot = true;
				Model().AddElem( new GEDGEMBN_CLIQSET( & _cliqset, pclqThis ) );
			}

			++_cliqset._cCliques;

			if ( pclqParent )
			{
				++_cliqset._cSepsetArcs;
			}
			ccq++;
			ccqLevel++;
		}
		if ( ccqLevel == 0 )
			break; // No cliques added at this topological level: we're done
	}
	assert( ccq == _viOrdered.size() );

	//  For each of the new cliques, add all members
	for ( i = 0; i < _vpclq.size(); i++ )
	{
		const VPGNODEMBN & vpgndMembers = _vvpgnd[ _viOrdered[i] ];

		for ( int ind = 0; ind < vpgndMembers.size(); ind++)
		{
			//  Get the node pointer and the data pointer
			GNODEMBN * pgnd = vpgndMembers[ind];
			const NDCQINFO & ndcq = _vndcqInfo[ pgnd->IMark() ];
			assert( pgnd == ndcq._pgnd );
			int fRole = GEDGEMBN_CLIQ::NONE;
			if ( ndcq._iCliqOrdSelf == i )	
				fRole |= GEDGEMBN_CLIQ::SELF;
			if ( ndcq._iCliqOrdFamily == i )	
				fRole |= GEDGEMBN_CLIQ::FAMILY;

			Model().AddElem( new GEDGEMBN_CLIQ( _vpclq[i], pgnd, fRole ) );
			++_cliqset._cCliqueMemberArcs;
		}
	}

#ifdef _DEBUG
	for ( i = 0; i < _vpclq.size(); i++ )
	{
		const VPGNODEMBN & vpgndMembers = _vvpgnd[ _viOrdered[i] ];
		VPGNODEMBN vpgndMembers2;
		_vpclq[i]->GetMembers( vpgndMembers2 );
		assert( vpgndMembers2.size() == vpgndMembers.size() );
		MarkSortNodePtrArray( vpgndMembers2 );
		assert( vpgndMembers2 == vpgndMembers );

		//  Exercise the topology by locating the "self" and "family" cliques
		for ( int imbr = 0; imbr < vpgndMembers.size(); imbr++ )
		{
			GNODEMBN * pgnd = vpgndMembers[imbr];
			GOBJMBN_CLIQUE * pCliqueFamily = _cliqset.PCliqueFromNode( pgnd, false );
			GOBJMBN_CLIQUE * pCliqueSelf = _cliqset.PCliqueFromNode( pgnd, false );
			assert( pCliqueFamily );
			assert( pCliqueSelf );
		}
	}
#endif
}

void CLIQSETWORK :: DumpClique ( int iClique )
{
	cout << "\tClique "
		<< iClique
		<< ':'
		<< _vvpgnd[iClique]
		<< "\n";		
	cout.flush();
}

void CLIQSETWORK :: DumpCliques ()
{
	for ( int iClique = 0; iClique < _vvpgnd.size(); ++iClique )
	{
		DumpClique( iClique );
	}
}

void CLIQSETWORK :: DumpTree ()
{
	for ( int iCliqueOrd = 0; iCliqueOrd < _viOrdered.size(); ++iCliqueOrd )
	{
		int iClique = _viOrdered[iCliqueOrd];

		cout << "\tTree Clique "
			<< iCliqueOrd
			<< " ("
			<< iClique
			<< "), parent "
			<< IOrdered( _viParent[iClique] )
			<< " ("
			<< _viParent[iClique]
			<< "): "
			<< _vvpgnd[iClique]
			<< "\n";		
	}
	cout.flush();
}

void CLIQSETWORK :: DumpTopInfo()
{
	for ( int iCliqueOrd = 0; iCliqueOrd < _viOrdered.size(); ++iCliqueOrd )
	{
		cout << "\tTree Clique "
			 << iCliqueOrd
			 << " (" << _viOrdered[iCliqueOrd] << ")"
			 << ", parent is "
			 << _viParentOrdered[iCliqueOrd]
			 << " (" << _viOrdered[_viParentOrdered[iCliqueOrd]] << ")"
			 << ", top level is "
			 << _viTopLevelOrdered[iCliqueOrd]
			 << "\n";
	}

	for ( int ind = 0 ; ind < _vndcqInfo.size(); ind++ )
	{
		NDCQINFO & ndcq = _vndcqInfo[ind];
		cout << "\tNode ";
		cout.width( 20 );
		cout << ndcq._pgnd->ZsrefName().Szc()
			 << "\tfamily is clique "
			 << ndcq._iCliqOrdFamily
			 << ", self is clique "
			 << ndcq._iCliqOrdSelf
			 << "\n";
	}
	cout.flush();
}

//
//	Estimate the total size of the structures necessary to support the
//	compute clique trees.
//
REAL CLIQSETWORK :: REstimatedSize ()
{
	int cClique = 0;
	int cSepsetArc = 0;
	int cCliqsetArc = 0;
	size_t cMbrArc = 0;
	int cCliqueEntries = 0;
	int cFamEntries = 0;

	for ( int icq = 0; icq < _viOrdered.size(); icq++ )
	{
		cClique++;	
		if ( icq != _viParentOrdered[icq] )
		{
			// Clique has a parent
			cSepsetArc++;
		}
		else
		{	
			//  Clique is root
			cCliqsetArc++;
		}

		//  Account for clique membership arcs
		const VPGNODEMBN & vpgndMembers = _vvpgnd[ _viOrdered[icq] ];
		int cMbr = vpgndMembers.size();
		cMbrArc += vpgndMembers.size();

		//  Compute the size of the joint table for this clique
		VIMD vimd(cMbr);
		GNODEMBND * pgndd;
		for ( int ind = 0; ind < vpgndMembers.size(); ind++)
		{
			//  Get the discrete node pointer and the data pointer
			DynCastThrow( vpgndMembers[ind], pgndd );
			//  Add to the clique's dimensionality
			vimd[ind] = pgndd->CState();

			const NDCQINFO & ndcq = _vndcqInfo[ pgndd->IMark() ];
			assert( pgndd == ndcq._pgnd );

			//  If this is the edge to the "family" clique, it will
			//	contain the reordered discrete conditional probabilities
			//	for this node, so we must compute it size.
			if ( ndcq._iCliqOrdFamily == icq )	
			{
				//  This is the edge leading to this node's "family" clique
				VPGNODEMBN vpgndFamily;  // List of parents and self
				pgndd->GetParents( vpgndFamily, true );
				GNODEMBND * pgnddFamily;
				int cStates = 1;
				for ( int ifam = 0; ifam < vpgndFamily.size(); ifam++ )
				{
					DynCastThrow( vpgndFamily[ifam], pgnddFamily );
					cStates *= pgnddFamily->CState();
				}
				cFamEntries += cStates;
			}
		}
		MDVSLICE mdvs( vimd );
		cCliqueEntries += mdvs._Totlen();
	}

	REAL rcb = 0;
	rcb += cClique * sizeof(GOBJMBN_CLIQUE);
	rcb += cSepsetArc * sizeof(GEDGEMBN_SEPSET);
	rcb += cCliqsetArc * sizeof(GEDGEMBN_CLIQSET);
	rcb += cMbrArc * sizeof(GEDGEMBN_CLIQ);
	rcb += cCliqueEntries * sizeof(REAL);
	rcb += cFamEntries * sizeof(REAL);

#ifdef DUMP
	cout << "\nEstimated clique tree memory is " << rcb;
#endif

	return rcb;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\clique.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       clique.h
//
//--------------------------------------------------------------------------

//
//	clique.h: junction tree and cliquing classes
//	
#ifndef _CLIQUE_H_
#define _CLIQUE_H_

#include "gmobj.h"
#include "marginals.h"
#include "margiter.h"

class GEDGEMBN_U;
class GEDGEMBN_CLIQ;
class GEDGEMBN_SEPSET;
class GOBJMBN_CLIQUE;
class GNODENUM_UNDIR;
class GOBJMBN_CLIQSET;


////////////////////////////////////////////////////////////////////
//	class GEDGEMBN_CLIQUE:
//		A clique; that is, an ensemble of nodes identified by linkages via
//		GEDGEMBN_CLIQ edges to nodes in the dag and GEDGEMBN_SEPSET
//		edges to other cliques in its junction tree.
////////////////////////////////////////////////////////////////////
class GOBJMBN_CLIQUE : public GOBJMBN
{
	friend class GOBJMBN_CLIQSET;
	friend class CLIQSETWORK;
  public:
	virtual ~ GOBJMBN_CLIQUE ();

 	//  Return true if this is the root clique of its junction tree
	bool BRoot () const
		{ return _bRoot ; }

 protected:
	GOBJMBN_CLIQUE ( int iClique, int iInferEngID = 0 );

  public:
	// Return the immutable object type
	virtual INT EType () const
		{ return EBNO_CLIQUE; }

	bool BCollect() const
		{ return _bCollect; }
	void SetCollect ( bool bCollect = true )
		{ _bCollect = bCollect; }

	INT & IInferEngID ()
		{ return _iInferEngID; }
	INT & IClique ()
		{ return _iClique; }

	void GetMembers ( VPGNODEMBN & vpgnode );
	void InitFromMembers ();
	void GetBelief ( GNODEMBN * pgnd, MDVCPD & mdvBel );
	const MARGINALS & Marginals () const	
		{ return _marg; }
	MARGINALS & Marginals ()
		{ return _marg; }

	void CreateMarginals ();
	void InitMarginals ();
	void LoadMarginals ();
	bool VerifyMarginals ();

	void Dump();

  protected:
	//  Identity
	int _iClique;						//  Clique index
	int _iInferEngID;					//  Junction tree identifier (unused)
	bool _bRoot;						//  Is this a root clique?
	bool _bCollect;						//  Is "collect/distribute" pass necessary?

	MARGINALS _marg;					//  The clique marginals
};

////////////////////////////////////////////////////////////////////
//	class GEDGEMBN_CLIQSET:
//		An edge between the clique set object and a root clique
////////////////////////////////////////////////////////////////////
class GEDGEMBN_CLIQSET : public GEDGEMBN
{
  public:
	GEDGEMBN_CLIQSET ( GOBJMBN_CLIQSET * pgobjSource,
					   GOBJMBN_CLIQUE * pgobjSink )
		: GEDGEMBN( pgobjSource, pgobjSink )
		{}

	GOBJMBN_CLIQSET * PclqsetSource ()		
		{ return (GOBJMBN_CLIQSET *) GEDGE::PnodeSource();	}

	GOBJMBN_CLIQUE * PclqChild ()			
		{ return (GOBJMBN_CLIQUE *)  GEDGE::PnodeSink();	}

	virtual INT EType () const
		{ return ETCLIQSET ; }
};


////////////////////////////////////////////////////////////////////
//	class GEDGEMBN_CLIQ:
//		An edge between a clique and its member nodes
////////////////////////////////////////////////////////////////////
class GEDGEMBN_CLIQ : public GEDGEMBN
{
  public:
	//  What role does this clique play for this node?
	enum FCQLROLE
	{	//  These are bit flags, not integer values
		NONE   = 0,			//  Just clique membership
		FAMILY = 1,			//  Link from "family" clique; i.e., smallest
							//      clique containing node and its family
		SELF   = 2			//	Link from "self" clique;
							//		i.e., the highest clique in the tree
							//		which mentions the sink node
	};

	GEDGEMBN_CLIQ ( GOBJMBN_CLIQUE * pgnSource,
				    GNODEMBN * pgndSink,
				    int iFcqlRole );

	virtual ~ GEDGEMBN_CLIQ();

	virtual INT EType () const
		{ return ETCLIQUE ; }
	
	int IFcqlRole () const
		{ return _iFcqlRole; }

	GOBJMBN_CLIQUE * PclqParent ();
	GNODEMBN * PgndSink ();

	//  Return true if this links node to its parent clique
	bool BFamily () const
		{	return _iFcqlRole & FAMILY; }
	//  Return true if this is the highest clique in the jtree in which
	//		this node appears.
	bool BSelf () const
		{	return _iFcqlRole & SELF; }

	//  Return the ordering index of the sink node at the time of cliquing
	int IMark () const
		{	return _iMark; }

	//  Return the family reordering table
	const VIMD & VimdFamilyReorder () const
	{
		assert( IFcqlRole() & (FAMILY | SELF) );
		return _vimdFamilyReorder;
	}

	void Build ();

	bool BBuilt () const
		{ return _bBuilt; }
	CLAMP & Clamp ()
		{ return _clamp ; }

	void LoadCliqueFromNode ();

	//  Return the iterator for full marginalization of the node ("family")
	MARGSUBITER & MiterNodeBelief ()
	{
		assert( BFamily() );
		return _miterBelief;
	}
	//  Return the iterator for loading the node's CPD into the clique ("family")
	MARGSUBITER & MiterLoadClique ()
	{	
		assert( BFamily() );
		return _miterLoad;
	}
	//  Return the (reordered) marginals for the node ("family")
	MARGINALS & MargCpd ()
	{
		assert( BFamily() );
		return _margCpd;
	}

  protected:
	int _iFcqlRole;			//  Role of this clique for the node
	int _iMark;				//	Node number in original clique-time ordering
	bool _bBuilt;			//  Constructed?

	//  This array is only filled for SELF and FAMILY edges.  It is the same
	//	size as the node's family, and contains, in CLIQUE ordering, the index
	//  of each member of the nodes family.  Note that the sink node has the
	//	highest index in its family set.
	VIMD _vimdFamilyReorder;

	//  The following variables are only used in "self" or "family" edges
	CLAMP _clamp;				//  Node evidence (used in "self")
	MARGINALS _margCpd;			//  Reordered marginals for node (used in "family")
	MARGSUBITER _miterBelief;	//  Marginals iterator for generating UPD (used in "family")
	MARGSUBITER _miterLoad;		//  Marginals iterator for loading CPD into clique (used in "family")

  protected:
	static void ReorderFamily ( GNODEMBN * pgnd, VIMD & vimd );
};


////////////////////////////////////////////////////////////////////
//	class GEDGEMBN_SEPSET:
//		An edge in the junction tree between cliques; i.e., a "sepset".
//		These are directed edges that point from parent clique to child.
////////////////////////////////////////////////////////////////////
class GEDGEMBN_SEPSET : public GEDGEMBN
{
  public:
	GEDGEMBN_SEPSET ( GOBJMBN_CLIQUE * pgnSource,
					 GOBJMBN_CLIQUE * pgnSink);
	virtual ~ GEDGEMBN_SEPSET();
	virtual INT EType () const
		{ return ETJTREE; }

	void GetMembers ( VPGNODEMBN & vpgnode );

	GOBJMBN_CLIQUE * PclqParent();
	GOBJMBN_CLIQUE * PclqChild();

	const MARGINALS & Marginals () const	
		{ return *_pmargOld; }
	MARGINALS & Marginals ()
		{ return *_pmargOld; }

	const MARGINALS & MarginalsOld () const	
		{ return *_pmargOld; }
	MARGINALS & MarginalsOld ()
		{ return *_pmargOld; }

	const MARGINALS & MarginalsMew () const	
		{ return *_pmargNew; }
	MARGINALS & MarginalsNew ()
		{ return *_pmargNew; }

	void ExchangeMarginals ();
	void CreateMarginals ();
	void InitMarginals ();
	void LoadMarginals ();
	bool VerifyMarginals ();
	void UpdateParentClique ();
	void UpdateChildClique ();
	bool BConsistent ();
	void BalanceCliquesCollect ();
	void BalanceCliquesDistribute ();

	void Dump();

  protected:
	MARGINALS * _pmargOld;
	MARGINALS * _pmargNew;

  protected:
	void UpdateRatios();
	void AbsorbClique ( bool bFromParentToChild );

	MARGSUBITER	_miterParent;	//  Iterator between sepset and parent
	MARGSUBITER _miterChild;	//  Iterator between sepset and child
};

DEFINEVP(GEDGEMBN_SEPSET);

//  Node enumeration subclass for undirected arcs.
class GNODENUM_UNDIR : public GNODENUM<GNODEMBN>
{
  public:
	GNODENUM_UNDIR ()
		: GNODENUM<GNODEMBN>(true,true,true)
	{
		SetETypeFollow( GEDGEMBN::ETUNDIR );
	}
	GNODENUM_UNDIR & operator = ( GNODEMBN * pgnd )
	{ 		
		Set( pgnd );
		return *this;
	}
};

#endif   // _CLIQUE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\dyncast.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       dyncast.h
//
//--------------------------------------------------------------------------

//
//	dyncast.h: Handle dynamic and static casting
//
#ifndef _DYNCAST_H_
#define _DYNCAST_H_


//  Macro to perform const_cast; i.e., cast away "const-ness" without
//	changing base type.
#define CONST_CAST(type,arg)  const_cast<type>(arg)

//
//	Function templates for generating error-detecting dynamic casts.
//	The compiler will generate the needed version of this based upon the types 
//	provided.  'DynCastThrow' should be used when you're certain of the 
//	type of an object.  'PdynCast" should be used when you intend to check
//	whether the conversion was successful (result != NULL).
//	If 'USE_STATIC_CAST' is defined, static casting is done in DynCastThrow().
//
//#define USE_STATIC_CAST	// Uncomment to force static casting
//#define TIME_DYN_CASTS	// Uncomment to generate timing information

template <class BASE, class SUB>
void DynCastThrow ( BASE * pbase, SUB * & psub )
{
#ifdef TIME_DYN_CASTS
	extern int g_cDynCasts;
	g_cDynCasts++;
#endif
#if defined(USE_STATIC_CAST) && !defined(_DEBUG) 
	psub = (SUB *) pbase;
#else
	psub = dynamic_cast<SUB *>(pbase);	
	ASSERT_THROW( psub, EC_DYN_CAST,"subclass pointer conversion failure");
#endif
}

template <class BASE, class SUB>
SUB * PdynCast ( BASE * pbase, SUB * psub )
{
	return dynamic_cast<SUB *>(pbase);	
}


#endif	// _DYNCAST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\enumstd.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       enumstd.h
//
//--------------------------------------------------------------------------

//
//	enumstd.h:  Standard global enumerations
//

#ifndef _ENUMSTD_H_
#define _ENUMSTD_H_

////////////////////////////////////////////////////////////////////
//	Property flags
////////////////////////////////////////////////////////////////////
const UINT fPropString = 1;			//  Property is a string (!fPropString ==> real)
const UINT fPropArray = 2;			//	Property is an array (!fPropArray  ==> scalar)
const UINT fPropChoice = 4;			//	Property is an enumerated value
const UINT fPropStandard = 8;		//  Property is standard (stored in Registry)
const UINT fPropPersist = 16;		//  Property is persistent (stored in Registry)

////////////////////////////////////////////////////////////////////
//	Definitions to enable usage of "MS_" standard properties
////////////////////////////////////////////////////////////////////
enum ESTDPROP
{
	ESTDP_label,			//  Node troubleshooting label (choice)
	ESTDP_cost_fix,			//  Cost to fix	(real)
	ESTDP_cost_observe,		//  Cost to observe (real)
	ESTDP_category,			//  Category (string)
	ESTDP_normalState,		//  Index of troubleshooting "normal" state (int)
	ESTDP_max				//  End
};

enum ESTDLBL		//  VOI-relative node label
{
	ESTDLBL_other,
	ESTDLBL_hypo,
	ESTDLBL_info,
	ESTDLBL_problem,
	ESTDLBL_fixobs,
	ESTDLBL_fixunobs,
	ESTDLBL_unfix,
	ESTDLBL_config,
	ESTDLBL_max
};


#endif // _ENUMSTD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\domain.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       domain.h
//
//--------------------------------------------------------------------------

//
//	domain.h:  domain declarations
//

#ifndef _DOMAIN_H_
#define _DOMAIN_H_

#include "symtmbn.h"
#include <list>

////////////////////////////////////////////////////////////////////
//	Declarations for common state or range sets.
//	For continuous variables, RANGEDEFs can be open or closed.
//	For discrete variables, RANGEDEFs must have lbound and ubound
//	(i.e., be closed) and the must be the same integer value.
////////////////////////////////////////////////////////////////////

//  Boundary of a domain
struct RANGELIM : pair<bool,REAL>
{
    RANGELIM( bool b = false, REAL r = 0.0 )
		: pair<bool,REAL>(b,r)
		{}

	DECLARE_ORDERING_OPERATORS(RANGELIM);
};

class RANGEDEF
{
  public:
	RANGEDEF ( bool bLower = false, 
			 REAL rLower = 0.0, 
			 bool bUpper = false, 
			 REAL rUpper = 0.0 )
	{
		_rlimLower.first = bLower;
		_rlimLower.second = rLower;
		_rlimUpper.first = bUpper;
		_rlimUpper.second = rUpper;
	}
	RANGEDEF ( const RANGELIM & rlimLower, 
			   const RANGELIM & rlimUpper,
			   ZSREF zsrName )
		: _rlimLower(rlimLower),
		_rlimUpper(rlimUpper),
		_zsrName(zsrName)
		{}
	bool BLbound () const
		{ return _rlimLower.first; }
	REAL RLbound () const
		{ return _rlimLower.second; }
	bool BUbound () const
		{ return _rlimUpper.first; }
	REAL RUbound () const
		{ return _rlimUpper.second; }
	ZSREF ZsrName () const
		{ return _zsrName; }
	void SetName ( ZSREF zsrName )
		{ _zsrName = zsrName; } 
	const RANGELIM & RlimLower () const
		{ return _rlimLower; }
	const RANGELIM & RlimUpper () const
		{ return _rlimUpper; }
	bool BValid () const;
	bool BOverlap ( const RANGEDEF & rdef ) const;
	bool BDiscrete () const
	{
		return BLbound()
			&& BUbound()
			&& int(RLbound()) == int(RUbound());
	}
	int IDiscrete () const
	{
		assert( BDiscrete() );
		return int(RLbound());
	}
	DECLARE_ORDERING_OPERATORS(RANGEDEF);

  protected:
	ZSREF _zsrName;
	RANGELIM _rlimLower;
	RANGELIM _rlimUpper;
};

//  A RDOMAIN is a sorted list of RANGELIMs
class RDOMAIN : public list<RANGEDEF> 
{
  public:
	//  Convert a numeric value to a state name
	SZC SzcState ( REAL rValue ) const;
	bool BOverlap () const;
};

////////////////////////////////////////////////////////////////////
//	GOBJMBN_DOMAIN:  Belief network object representing
//		a named, sharable mapping of names to scalar ranges.
////////////////////////////////////////////////////////////////////
class GOBJMBN_DOMAIN : public GOBJMBN
{
  public:
	GOBJMBN_DOMAIN ( RDOMAIN * pdomain = NULL)
	{
		if ( pdomain )
			_domain = *pdomain;
	}
	~ GOBJMBN_DOMAIN() {}

	virtual INT EType () const
		{ return EBNO_VARIABLE_DOMAIN ; }

	virtual GOBJMBN * CloneNew ( MODEL & modelSelf,
								 MODEL & modelNew,
								 GOBJMBN * pgobjNew = NULL );
	RDOMAIN & Domain ()
		{ return _domain; }
	const RDOMAIN & Domain () const
		{ return _domain; } 

  protected:
	//  Vector of RANGEDEFs
	RDOMAIN _domain;	
};

#endif  // _DOMAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\errordef.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       errordef.h
//
//--------------------------------------------------------------------------

//	
//	errordef.h: definitions and strings for standard errors
//	

#if !defined(_ERRORDEF_H_) && !defined(GMERRORSTR)
#define _ERRORDEF_H_

#undef GMERRORDEF

#ifdef GMERRORSTR
	//  Generate string table declarations
	#define GMERRORDEF(sym,str)  { EC_##sym, str },
#else
	//  Generate enumeration declarations
	#define GMERRORDEF(sym,str)  EC_##sym,
#endif

GMERRORDEF(CREF,					"Reference counted object error")
GMERRORDEF(DYN_CAST,				"Dynamic cast failure")
GMERRORDEF(NULLP,					"NULL pointer error")
GMERRORDEF(LINK_OFFSET,				"Linkage offset error")
GMERRORDEF(PROP_MISUSE,				"Invalid use of a property item")
GMERRORDEF(DIST_MISUSE,				"Misuse of a distribution")
GMERRORDEF(MDVECT_MISUSE,			"Misuse of an m-d array")
GMERRORDEF(INVALID_CLONE,			"Attempt to clone in invalid state")
GMERRORDEF(DUPLICATE_NAME,			"Attempt to add a duplicate name")
GMERRORDEF(INAPPLICABLE,			"Operation is not applicable to object")
GMERRORDEF(CREATES_CYCLE,			"Addition of directed arc creates cycle")
GMERRORDEF(INV_PD,					"Invalid probability distribution")
GMERRORDEF(TOPOLOGY_MISMATCH,		"Topology doesn't match distribution")
GMERRORDEF(NYI,						"Function not implemented")
GMERRORDEF(INTERNAL_ERROR,			"Internal error")
GMERRORDEF(VOI_NO_INFO,				"No info nodes in VOI calculation")
GMERRORDEF(VOI_FIXABLE_PARENTS,		"A fixable node has parents")
GMERRORDEF(VOI_FIXABLE_ABNORMAL,	"A fixable node is abnormal")
GMERRORDEF(VOI_PROBDEF_ABNORMAL,	"Count of abnormal PD nodes != 1")
GMERRORDEF(VOI_MODEL_COST_FIX,		"Model repair cost not set")
GMERRORDEF(VOI_NO_HYPO,				"No hypothesis node in network")
GMERRORDEF(REGISTRY_ACCESS,			"Registry access failure")
GMERRORDEF(OVER_SIZE_ESTIMATE,		"Allowed size exceeded")

#undef GMERRORDEF

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\domain.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       domain.cpp
//
//--------------------------------------------------------------------------

//
//	domain.cpp
//	

#include <basetsd.h>
#include "domain.h"

bool RANGELIM :: operator < ( const RANGELIM & rlim ) const
{
	if ( first ^ rlim.first )
	{
		//  One has a bound and the other doesn't.
		//  If we do not have an bound and other does, we are "less"
		return true;
	}
	//  Both either have or don't have bounds.  Therefore,
	//	we're "less" iff both have bounds and ours is less
	//  than the other's.
	return first && second < rlim.second;
}

bool RANGELIM :: operator > ( const RANGELIM & rlim ) const
{
	if ( first ^ rlim.first )
	{
		//  One has a bound and the other doesn't.
		//  If we have a bound and the other doesn't, it is "greater"
		return true;
	}
	//  Both either have or don't have bounds.  Therefore,
	//	we're "greater" iff both have bounds and ours is greater
	//  than the other's.
	return first && second > rlim.second;
}

bool RANGELIM :: operator == ( const RANGELIM & rlim ) const
{
	return first == rlim.first
		 && ( !first || (second == rlim.second) );
}

//  Order two RANGEDEFs according to their lower bounds.
bool RANGEDEF :: operator < ( const RANGEDEF & rdef ) const
{	
	if ( self == rdef )
		return false;

	//  If the other doesn't have a lower bound, we're geq
	if ( ! rdef.BLbound() )
		return false;
	//  If we don't have an upper bound, we're gtr
	if ( ! BUbound() )
		return false;

	// The other has a lower bound and we have an upper bound;
	//		start by checking them.
	bool bResult = RUbound() <= rdef.RLbound();
	if ( BLbound() )
	{
		// Both have lower bounds; self must be < other
		bResult &= (RLbound() <= rdef.RLbound());
	}
	
	if ( rdef.BUbound() )
	{
		// Both have upper bounds; self must be < other
		bResult &= (RUbound() <= rdef.RUbound());
	}
	return bResult;
}

bool RANGEDEF :: operator == ( const RANGEDEF & rdef ) const
{
	return RlimLower() == rdef.RlimLower()
		&& RlimUpper() == rdef.RlimUpper();
}

bool RANGEDEF :: operator > ( const RANGEDEF & rdef ) const
{	
	return !(self < rdef);
}

bool RANGEDEF :: BValid () const
{
	return RlimLower() < RlimUpper()
		|| RlimLower() == RlimUpper();
}

bool RANGEDEF :: BOverlap ( const RANGEDEF & rdef ) const
{
	if ( self == rdef )
		return true;
	bool bLess = self < rdef;
	if ( bLess )
		return RlimUpper() > rdef.RlimLower();
	return rdef.RlimUpper() > RlimLower();
}

SZC RDOMAIN :: SzcState ( REAL rValue ) const
{
	RANGELIM rlim(true,rValue);

	for ( const_iterator itdm = begin();
		  itdm != end();
		  itdm++ )
	{
		const RANGEDEF & rdef = (*itdm);
		SZC szcState = rdef.ZsrName();
		if ( rdef.RlimLower() == rlim )
			return szcState;
		if ( rdef.RlimUpper() < rlim )
			break;
		if (   rdef.RlimLower() < rlim )
			return szcState;		
	}
	return NULL;
}

//  Return true if any of the RANGEDEFs overlap
bool RDOMAIN :: BOverlap () const
{
	for ( const_iterator itdm = begin();
		  itdm != end();
		  itdm++ )
	{
		const_iterator itdmNext = itdm;
		itdmNext++;
		if ( itdmNext == end() )
			continue;

		//  Check sequence of the list
		assert( *itdm < *itdmNext );
		//  If ubounds collide, it's an overlap
		if ( *itdm > *itdmNext )
			return true;
	}
	return false;
}

GOBJMBN * GOBJMBN_DOMAIN :: CloneNew (
	MODEL & modelSelf,
	MODEL & modelNew,
	GOBJMBN * pgobjNew )
{
	GOBJMBN_DOMAIN * pgdom = NULL;
	if ( pgobjNew == NULL )
	{
		pgdom = new GOBJMBN_DOMAIN;
	}
	else
	{
		DynCastThrow( pgobjNew, pgdom );
	}
	ASSERT_THROW( GOBJMBN::CloneNew( modelSelf, modelNew, pgdom ),
				  EC_INTERNAL_ERROR,
				  "cloning failed to returned object pointer" );
	
	pgdom->_domain = _domain;

	return pgdom;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\expand.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       expand.h
//
//--------------------------------------------------------------------------

//
//	expand.h:  Declarations for network CI expansion
//
#ifndef _EXPAND_H_
#define _EXPAND_H_

#include "gmobj.h"

////////////////////////////////////////////////////////////////////
//	class GOBJMBN_MBNET_EXPANDER:  
//		An MBNET modifier which performs CI expansion on a network
////////////////////////////////////////////////////////////////////
class GOBJMBN_MBNET_EXPANDER : public MBNET_MODIFIER
{
  public:
	GOBJMBN_MBNET_EXPANDER ( MBNET & model );
	virtual ~ GOBJMBN_MBNET_EXPANDER ();

	virtual INT EType () const
		{ return EBNO_MBNET_EXPANDER; }

	//  Perform any creation-time operations
	void Create ();
	//  Perform any special destruction
	void Destroy ();
	//	Return true if no modidfications were performed.
	bool BMoot ();

  protected:

	PROPMGR _propmgr;	

	int _cNodesExpanded;
	int _cNodesCreated;
	int _cArcsCreated;

  protected:
	void Expand ( GNODEMBND & gndd );

	static const VLREAL * PVlrLeak ( const BNDIST & bndist );
};

#endif // _EXPAND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\gelem.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       gelem.h
//
//--------------------------------------------------------------------------

//
//	GELEM.H
//

#ifndef _GELEM_H_
#define _GELEM_H_

//  Disable	warning about using 'bool'
#pragma warning ( disable : 4237 )


#include "glnk.h"
#include "leakchk.h"

class GNODE;
class GEDGE;

//  Classes for the type-safe links in arcs to nodes and links in nodes
//		to arcs.
class GEDGLNK : public XLSS<GEDGE> {};
class GNODLNK : public XLSS<GNODE> {};

////////////////////////////////////////////////////////////////////
//	class GNODE:  Base class for node in a graph or tree.  Subclassed
//		from GELEM to imbedded LNKs will know how to compute
//		proper offsets.
////////////////////////////////////////////////////////////////////
class GNODE : public GELEMLNK
{
	friend class GEDGE;

  public:
	GNODE ();
	virtual ~ GNODE ();

	//	Accessors (const and non-const)
	//		Return the source arc cursor (or NULL)
	//		Return the sink arc cursor (or NULL)
	virtual GEDGE * & PedgeSource ()
		{ return _glkArcs.PlnkSource() ; }
	virtual GEDGE * & PedgeSink ()
		{ return _glkArcs.PlnkSink() ; }
	virtual GEDGE * PedgeSource () const
		{ return _glkArcs.PlnkSource() ; }
	virtual GEDGE * PedgeSink () const
		{ return _glkArcs.PlnkSink() ; }

	//  Return counts of arcs in the given direction
	virtual UINT CSourceArc () const;
	virtual UINT CSinkArc () const;

	//  Return counts of arcs in the given direction filtering by type
	virtual UINT CSourceArcByEType ( int eType ) const;
	virtual UINT CSinkArcByEType ( int eType ) const;

	virtual INT EType () const
			{ return EGELM_NODE ; }

	LEAK_VAR_ACCESSOR

  protected:
	//  Return the correct insertion point for a new arc, source or sink.  
	//		Called whenever a new arc is created to maintain ordering of arcs.
	//		Default behavior is to add the new arc as the last.
	virtual GEDGE * PedgeOrdering ( GEDGE * pgedge, bool bSource );

	//  Notification routine called when an arc dies; used to adjust cursors
	virtual void ArcDeath ( GEDGE * pgedge, bool bSource );

  protected:
	// Arc cursors: pointers to one source and one sink arc
	GEDGLNK _glkArcs;

	LEAK_VAR_DECL

	HIDE_UNSAFE(GNODE);
};

DEFINEVP(GNODE);

////////////////////////////////////////////////////////////////////
//	class GEDGE:  Base class for an arc in a graph.
////////////////////////////////////////////////////////////////////
class GEDGE : public GELEMLNK
{
  public:
	//  Internal class for chains (doubly-linked lists) of arcs
	typedef XCHN<GEDGE> CHN;

	//  Constructor requires source and sink nodes
	GEDGE ( GNODE * pgnSource, GNODE * pgnSink );
	virtual ~ GEDGE ();

	//  Accessors:
	//		Return source and sink arc chains
	CHN & ChnSource ()		{ return _lkchnSource;		}
	CHN & ChnSink	()		{ return _lkchnSink;		}
	//		Return source and sink node
	GNODE * & PnodeSource()	{ return _glkNodes.PlnkSource();	}
	GNODE * & PnodeSink()	{ return _glkNodes.PlnkSink();		}

	virtual INT EType () const
			{ return EGELM_EDGE ; }

	LEAK_VAR_ACCESSOR

  protected:
	//  Chain of all arcs originating in the same source node
	CHN _lkchnSource;
	//  Chain of all arcs terminating in the same sink node
	CHN _lkchnSink;
	//  Source and sink node pointers
	GNODLNK _glkNodes;

	LEAK_VAR_DECL

	HIDE_UNSAFE(GEDGE);
};


////////////////////////////////////////////////////////////////////
//	class GNODENUM_BASE:
//
//			Base class for generic linkable object enumerators.
//			Each enumerator can enumerate up or down (source or sink)
//			and forward or reverse in the chain.
////////////////////////////////////////////////////////////////////
class GNODENUM_BASE
{
	//	typedefs for pointer-to-member-function pointer types
	typedef bool (*PFFOLLOW) (GEDGE *);
	typedef GEDGE::CHN & (GEDGE::*PARCCHN)();
	typedef GEDGE * (GEDGE::CHN::*PNX)();
	typedef GNODE * & (GEDGE::*PARCDGN)();

 public:
	//  Construct an enumerator.
	GNODENUM_BASE ( bool bSource,			// true ==> enumerate source (parent) arcs
				    bool bDir = true,		// true ==> follow arc ordering forwards
					bool bBoth = false ) ;	// true ==> enumerate other arcs also
	
	//  Set the enumerator to have a new base; iDir == -1 means don't
	//		change direction flag; otherwise, it's really a "bool".
	void Reset ( bool bSource, int iDir = 0, int bBoth = 0 ) ;

	//  Set the arc following test function pointer.  To use, declare
	//		a function like "bool BMyFollow (GEDGE * pge)", and pass its
	//		address to "SetPfFollow()".  It will be called during enumeration
	//		to see if an arc should be followed.  Alternatively, you can
	//		override "BFollow()" in your templated-derived subclass.
	void SetPfFollow ( PFFOLLOW pfFollow )
		{ _pfFollow = pfFollow ; }

  	//  Set the intrinsic type of arc to follow (i.e., "EType()"); -1 ==> all.
	void SetETypeFollow ( int iEgelmTypeMin = -1, int iEgelmTypeMax = -1 )
		{ _iETypeFollowMin = iEgelmTypeMin; 
		  _iETypeFollowMax = iEgelmTypeMax; }
	//  Set the user-definable type of arc to follow (i.e., "IType()"); -1 ==> all.
	void SetITypeFollow ( int iITypeFollowMin = -1,  int iITypeFollowMax = -1 )
		{ _iITypeFollowMin = iITypeFollowMin;
		  _iITypeFollowMax = iITypeFollowMax; }

	// Return the edge used for the current position
	GEDGE * PgedgeCurrent ()
		{ return _pedgeCurrent; }

protected:
	//  Position to the next pointer; return NULL when done.
	bool BNext () ;

	//  Assign the node being enumerated and the starting point
	void Set ( GNODE * pnode );

	//  Overrideable routine to check arc type
	virtual bool BFollow ( GEDGE * pedge );

	//  Call either the "follower" function or the virtualized follower.
	bool BFollowTest ( GEDGE * pedge )
	{
		return _pfFollow 
			 ? (*_pfFollow)(pedge)
			 : BFollow(pedge);
	}
	// Set the starting point for this mode of iteration
	void SetStartPoint ();

  protected:
	PARCCHN _pfChn;				// Pointer to member function to return chain
	PNX _pfNxPv;				// Ptr to mbr func to move forward or back
	PARCDGN _pfPgn;				// Ptr to member func to get node from arc
	GEDGE * _pedgeNext;			// Next arc
	GEDGE * _pedgeStart;		// Starting arc
	GEDGE * _pedgeCurrent;		// Arc used for recent answer
	GNODE * _pnodeCurrent;		// Recent answer
	GNODE * _pnodeBase;			// Node of origin
	PFFOLLOW _pfFollow;			// Follow override
	bool _bDir;					// Horizontal direction of enumeration
	bool _bSource;				// Vertical direction of enumeration
	bool _bBoth;				// Enumerate arcs in both directions
	bool _bPhase;				// Phase of the search (for _bBoth == true)

	//  These values determine which kinds of arcs are to be followed; 
	//  -1 implies not set.  Used by BFollow().
	int _iETypeFollowMin;		// Follow this canonical type of arc
	int _iETypeFollowMax;		
	int _iITypeFollowMin;		// Follow this user-defined type of arc
	int _iITypeFollowMax;		
};


////////////////////////////////////////////////////////////////////
//	template GNODENUM:
//
//	Generic enumeration class for nodes.  All conversions are type-safe;
//	exceptions will be thrown if accesses are made to objects which are
//	node subclasses of GNODE.
//
//	Each enumerator can enumerate up or down (source or sink)
//	and forward or reverse in the chain.
//
//	*	Use Set() to set the starting node point.
//
//	*	Use the post-increment operator to advance.
//
//	*	Use Pcurrent() or pointer-dereference operator to get the 
//		current node pointer.
//
//	*	Enumerators are reusable.  To restart, reissue "Set()"; to
//		change enumeration parameters, use Reset().
//
////////////////////////////////////////////////////////////////////
template <class GND> 
class GNODENUM : public GNODENUM_BASE
{
 public:
	GNODENUM ( bool bSrc, bool bDir = true, bool bBoth = false )
		: GNODENUM_BASE( bSrc, bDir, bBoth )
		{}

	void Set ( GND * pgnd )
		{ GNODENUM_BASE::Set( pgnd ); }
	bool operator++ (int i)
		{ return BNext() ; }
	bool operator++ ()
		{ return BNext() ; }

	GND * PnodeCurrent ()
	{ 
		GND * pnode = NULL;
		if ( _pnodeCurrent )
			DynCastThrow( _pnodeCurrent, pnode );
		return pnode; 
	}
	GND * operator -> () 
		{ return PnodeCurrent() ; }
	GND * operator * () 
		{ return PnodeCurrent() ; }
	void Reset ( bool bSrc, int iDir = -1, int iBoth = -1 )
		{ GNODENUM_BASE::Reset( bSrc, iDir, iBoth ) ; }

  protected:
 	bool BNext ()
		{ return GNODENUM_BASE::BNext() ; }

	HIDE_UNSAFE(GNODENUM);
};

////////////////////////////////////////////////////////////////////
//	class GRPH:  a generalized graph
//
//		This is a linkable object because it acts as the anchor
//		for its linked list, which connects all enumerable items
//		in this collection.
////////////////////////////////////////////////////////////////////

class GRPH : public GELEMLNK
{
  public:
	GRPH () {}
	virtual ~ GRPH ()
		{ Clear(); }
	
	virtual void AddElem ( GELEMLNK & gelemlnk )
		{ gelemlnk.ChnColl().Link( this );	}

	virtual INT EType () const
		{ return EGELM_GRAPH ; }		

	//  Remove all elements from the graph
	void Clear ()
	{
		GELEMLNK * pgelem; 
		while ( pgelem = ChnColl().PgelemNext() )
			delete pgelem;	
	}

	HIDE_UNSAFE(GRPH);
};

////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//		Inline member functions
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
inline 
GNODE :: GNODE ()
{
	LEAK_VAR_UPD(1)
}

inline
GNODE :: ~ GNODE ()
{
	GEDGE * pedge = NULL;
	while ( pedge = PedgeSource() ) 
		delete pedge;
	while ( pedge = PedgeSink() ) 
		delete pedge;

	LEAK_VAR_UPD(-1)
}

inline
GEDGE :: GEDGE ( GNODE * pnodeSource, GNODE * pnodeSink )
	: _lkchnSource(this),
	  _lkchnSink(this)
{
	if ( pnodeSource == NULL || pnodeSink == NULL )
		throw GMException( EC_NULLP, 
						   "attempt to construct a GEDGE without linkage" );

	//  Bind to the pair of nodes
	PnodeSource() = pnodeSource;
	PnodeSink() = pnodeSink;

	//  Determine insertion point into source and sink chains, and
	//    inform nodes of our existence
	GEDGE * pedgeSource = pnodeSource->PedgeOrdering( this, false );
	GEDGE * pedgeSink = pnodeSink->PedgeOrdering( this, true );

	if ( pedgeSource )
	{
		ChnSource().Link( pedgeSource );
	}
	if ( pedgeSink )
	{
		ChnSink().Link( pedgeSink );
	}

	LEAK_VAR_UPD(1)
}

inline
GEDGE :: ~ GEDGE ()
{
	PnodeSource()->ArcDeath( this, false );
	PnodeSink()->ArcDeath( this, true );
	LEAK_VAR_UPD(-1)
}

inline
UINT GNODE :: CSourceArc () const
{
	return PedgeSource()
		 ? PedgeSource()->ChnSink().Count()
		 : 0;
}

inline
UINT GNODE :: CSinkArc () const
{
	return PedgeSink()
		 ? PedgeSink()->ChnSource().Count()
		 : 0;
}

//  Return counts of arcs in the given direction filtering by type
inline
UINT GNODE :: CSourceArcByEType ( int eType ) const
{
	UINT cArcs = 0;
	GEDGE * pgedgeStart = PedgeSource();
	GEDGE * pgedge = pgedgeStart;
	while ( pgedge )
	{
		if ( pgedge->EType() == eType )
			++cArcs;
		pgedge = pgedge->ChnSink().PgelemNext();
		if ( pgedge == pgedgeStart ) 
			break;
	}
	return cArcs;
}

inline
UINT GNODE :: CSinkArcByEType ( int eType ) const
{
	UINT cArcs = 0;
	GEDGE * pgedgeStart = PedgeSink();
	GEDGE * pgedge = pgedgeStart;
	while ( pgedge )
	{
		if ( pgedge->EType() == eType )
			++cArcs;
		pgedge = pgedge->ChnSource().PgelemNext();
		if ( pgedge == pgedgeStart ) 
			break;
	}
	return cArcs;
}

// Return the correct insertion point for a new edge, 
// source or sink.
inline
GEDGE * GNODE :: PedgeOrdering ( GEDGE * pedge, bool bSource )
{
	GEDGE * pedgeOrdering = NULL;

	if ( bSource )
	{
		pedgeOrdering = PedgeSource();
		if ( ! pedgeOrdering ) 
			PedgeSource() = pedge;
	}
	else
	{
		pedgeOrdering = PedgeSink();
		if ( ! pedgeOrdering ) 
			PedgeSink() = pedge;
	}
	return pedgeOrdering;
}

inline
void GNODE :: ArcDeath ( GEDGE * pedge, bool bSource )
{
	if ( bSource )
	{
		if ( pedge == PedgeSource() )
			PedgeSource() = pedge->ChnSink().PgelemNext();
		if ( pedge == PedgeSource() )
			PedgeSource() = NULL;
	}
	else
	{
		if ( pedge == PedgeSink() )
			PedgeSink() = pedge->ChnSource().PgelemNext();
		if ( pedge == PedgeSink() )
			PedgeSink() = NULL;
	}
}

inline
GNODENUM_BASE :: GNODENUM_BASE ( bool bSource, bool bDir, bool bBoth )
	: _pfChn(NULL),
	  _pfNxPv(NULL),
	  _pfPgn(NULL),
	  _pfFollow(NULL),
	  _iETypeFollowMin(-1),
	  _iETypeFollowMax(-1),
	  _iITypeFollowMin(-1),
	  _iITypeFollowMax(-1),
	  _pnodeBase(NULL)
{
	Reset( bSource, bDir, bBoth ) ;
}

	//  Set the base object for the enumeration
inline
void GNODENUM_BASE :: Reset ( bool bSource, int iDir, int iBoth )
{
	if ( iDir >= 0 )
		_bDir = iDir ;
	if ( iBoth >= 0 )
		_bBoth = iBoth;

	_bSource = bSource;

	_pfNxPv = _bDir
			? & GEDGE::CHN::PgelemNext
			: & GEDGE::CHN::PgelemPrev;

	if ( _bSource )
	{
		_pfChn = & GEDGE::ChnSink;
		_pfPgn = & GEDGE::PnodeSource;
	}
	else
	{
		_pfChn = & GEDGE::ChnSource;
		_pfPgn = & GEDGE::PnodeSink;
	}
	_pedgeStart = _pedgeNext = _pedgeCurrent = NULL;
	_pnodeCurrent = NULL;
	_bPhase = false;
}

//  Set the starting point of the iteration.  If 'pnode' is NULL,
//	use the original node.
inline
void GNODENUM_BASE :: Set ( GNODE * pnode )
{
	if ( pnode )
		_pnodeBase = pnode;
	SetStartPoint();
	BNext();
}

inline
void GNODENUM_BASE :: SetStartPoint ()
{
	_pedgeNext =  _bSource 
				  ? _pnodeBase->PedgeSource() 
				  : _pnodeBase->PedgeSink();
	_pedgeStart = _pedgeNext;
}

//  Follow the arc if the constraints are met, both inherent type (EType())
//	and user-definable type (IType().
inline
bool GNODENUM_BASE :: BFollow ( GEDGE * pedge )
{
	if ( _iETypeFollowMin >= 0 )
	{
		int etype = pedge->EType();
		if ( _iETypeFollowMax < 0 ) 
		{
			//  Just the "min" is set; compare equal
			if ( etype !=_iETypeFollowMin )
				return false;
		}
		else
		{
			if ( etype < _iETypeFollowMin || etype > _iETypeFollowMax )
				return false;
		}
	}
	if ( _iITypeFollowMin >= 0 )
	{
		int itype = pedge->IType();
		if ( _iITypeFollowMax < 0 ) 
		{
			//  Just the "min" is set; compare equal
			if ( itype !=_iITypeFollowMin )
				return false;
		}
		else
		{
			if ( itype < _iITypeFollowMin || itype > _iITypeFollowMax )
				return false;
		}
	}
	return true;
}

inline
bool GNODENUM_BASE :: BNext ()
{
	_pnodeCurrent = NULL;
	_pedgeCurrent = NULL;
	
	do
	{
		while ( _pedgeNext == NULL )
		{
			// If we're not iterating both directions, 
			//		or this is phase 2, exit.
			if ( _bPhase || ! _bBoth )		
				return false;
			// Set "2nd phase" flag, invert source/sink
			Reset( !_bSource );
			_bPhase = true;
			SetStartPoint();
		}

		if ( BFollowTest( _pedgeNext ) )
		{
			_pedgeCurrent = _pedgeNext;
			_pnodeCurrent = (_pedgeNext->*_pfPgn)();
		}
		GEDGE::CHN & chn = (_pedgeNext->*_pfChn)();
		_pedgeNext = (chn.*_pfNxPv)();
		if ( _pedgeStart == _pedgeNext )
			_pedgeNext = NULL;
	} while ( _pnodeCurrent == NULL );

	return _pnodeCurrent != NULL;
}
	



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\expand.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       expand.cpp
//
//--------------------------------------------------------------------------

//
//	expand.cpp: CI expansion
//

#include <basetsd.h>
#include "basics.h"
#include "algos.h"
#include "expand.h"

/*
	The Causal Independence model expansion.

	In all cases, the zeroth state is considered the "normal" state; all
	other states are "abnormal" in some sense.

	For each CI node, new "expansion" nodes and arcs are created.  All
	generated nodes have the same state space as the original CI node.

		1)  For each parent, a new intermediate node is created.

		2)  A "leak" node is created for the CI node, and one for each
			of the parents except the last.

		3)  The nodes are linked in a chain, such as:

			(A)  (B)							 (A)	 (B)
			 |	  |			becomes				  |		 |
			 \	  /								(Pca)	(Pcb)
			  \  /								  |		 |
			   (C)						(Lc) -- (La) -- (C')

		4)  In other words, the intermediate nodes are between the original
			parents and the CI leak nodes or the final, modified C node (labeled
			C').

		5)  Probabilities for C given abnormal states of each parent are moved
			to the intermediate parent nodes (labeled Pca and Pcb above).

		6)  Probabilities of the primary leak node (Lc) are set to the "leak"
			probabilties of the original node; namely, the pvector representing
			all parents in a normal state (0,0,...).

		7)  The replacement node for C (labeled C') is just another "leak" node
			for the original node given its final parent.  (This is a topological
			optimization.)

		8)  All of the leak nodes are deterministic; i.e., their ptables
			contain only 0 or 1.0 in every entry.

	Topological consistency is maintained as follows:

		1)	All newly generated nodes and arcs are marked with the "Expansion"
			bit flag.

		2)  The target node is marked as "Expanded". Its distribution reference
			is replaced with a reference to a distribution created to represent
			the expanded distribution.

		3)  New nodes are added for leak and expansion parents; they are marked
			accordingly as "Expansion" and "Leak".

		3)  New arcs are added between "Expanded" (modified) nodes and their new
			expansion parents, as well as between expansion nodes. These are marked
			as "Expansion" arcs.

	Note that the ordering of the parents of a node cannot change as a result of CI expansion.

	During cliquing and inference, if a node is marked as "Expanded", only its "Expansion"
	arcs are considered true parents.

	During expansion tear-down (in Destroy()), all "Expansion" by-products are deleted.
	"Expanded" flags are cleared from all remaining nodes and arcs.  This must be a
	complete "undo" of all that expansion accomplished.  Note that generated distributions
	(which are not recorded in the model's distribution map) will be automatically
	deleted
 */

GOBJMBN_MBNET_EXPANDER :: GOBJMBN_MBNET_EXPANDER ( MBNET & model )
	: MBNET_MODIFIER(model),
	_propmgr(model),
	_cNodesExpanded(0),
	_cNodesCreated(0),
	_cArcsCreated(0)
{
}

GOBJMBN_MBNET_EXPANDER :: ~ GOBJMBN_MBNET_EXPANDER ()
{
	Destroy();
}

	//	Return true if no modidfications were performed.
bool GOBJMBN_MBNET_EXPANDER :: BMoot ()
{
	return _cNodesExpanded == 0;
}

//  Perform any creation-time operations
void GOBJMBN_MBNET_EXPANDER :: Create ()
{
	// Test whether network has already been CI-expanded
	ASSERT_THROW( ! _model.BFlag( EIBF_Expanded ),
				  EC_INTERNAL_ERROR,
				  "network expansion called on expanded network" );

	//  Create the topology if necessary
	_model.CreateTopology();

	//  Connect the nodes to their distributions
	_model.BindDistributions();

	//  Collect the expandable nodes
	GOBJMBN * pgmobj;
	VPGNODEMBND vpgndd;
	MBNET::ITER mbnit( _model, GOBJMBN::EBNO_NODE );
	for ( ; pgmobj = *mbnit ; ++mbnit)
	{
		ZSREF zsrName = mbnit.ZsrCurrent();
		GNODEMBN * pbnode;
		DynCastThrow( pgmobj, pbnode );
		assert( zsrName == pbnode->ZsrefName() );
		assert( ! pbnode->BFlag( EIBF_Expanded ) );
		assert( ! pbnode->BFlag( EIBF_Expansion ) );

		//  For now, this routine only handles discrete nodes
		GNODEMBND * pbnoded;
		DynCastThrow( pbnode, pbnoded );
	
		//  Does this node have any parents?

		//  Is this a CI node?
		assert( pbnoded->BHasDist() );
		BNDIST::EDIST ed = pbnoded->Bndist().Edist() ;
		if ( ed <= BNDIST::ED_SPARSE )
			continue;
		ASSERT_THROW( ed == BNDIST::ED_CI_MAX,
					  EC_NYI,
					  "attempt to expand non-MAX CI node" );
		vpgndd.push_back( pbnoded );
	}

	//  Expand them
	for ( int ind = 0; ind < vpgndd.size(); )
	{
		Expand( *vpgndd[ind++] );		
		_cNodesExpanded++;
	}

	_model.BSetBFlag( EIBF_Expanded );
}

//  Perform any special destruction
void GOBJMBN_MBNET_EXPANDER :: Destroy ()
{
	ASSERT_THROW( _model.BFlag( EIBF_Expanded ),
				  EC_INTERNAL_ERROR,
				  "network expansion undo called on unexpanded network" );

	int cNodesExpanded = 0;
	int cNodesCreated = 0;
	int cArcsCreated = 0;

	VPGNODEMBN vpgnd;
	GELEMLNK * pgelm;
	MODEL::MODELENUM mdlenum( Model() );
	while ( pgelm = mdlenum.PlnkelNext() )
	{	
		//  See if it's an expansion-generated edge
		if ( pgelm->BIsEType( GELEM::EGELM_EDGE ) )
		{
			GEDGEMBN * pgedge;
			DynCastThrow( pgelm , pgedge );
			if ( pgedge->EType() == GEDGEMBN::ETPROB )
			{					
				GNODEMBN * pgndSource = dynamic_cast<GNODEMBN *> ( pgedge->PobjSource() );
				GNODEMBN * pgndSink = dynamic_cast<GNODEMBN *> ( pgedge->PobjSink() );
				if ( pgndSource && pgndSink )
				{
					//  Count this edge if either end connects to an expansion by-product
					if ( pgndSource->BFlag( EIBF_Expansion ) || pgndSink->BFlag( EIBF_Expansion ) )
					{
						//  This arc was created during expansion; it will be deleted along with
						//		the expansion node(s) it connects to.
						cArcsCreated++;
					}
				}
			}
		}
		else
		if ( pgelm->BIsEType( GELEM::EGELM_NODE ) )
		{
			GNODEMBND * pgndd = dynamic_cast<GNODEMBND *>(pgelm);
			if ( pgndd )
			{
				if ( pgndd->BFlag( EIBF_Expansion ) )
				{
					// Expansion node; kill it
					vpgnd.push_back( pgndd );
					cNodesCreated++;
				}
				else
				if ( pgndd->BFlag( EIBF_Expanded ) )
				{
					// Expanded node; zap the generated distribution, clear all flags
					pgndd->ClearDist();
					pgndd->BSetBFlag( EIBF_Expanded, false );
					cNodesExpanded++;
				}
			}
		}
	}
		
	assert(    cNodesCreated  == _cNodesCreated
			&& cArcsCreated   == _cArcsCreated
			&& cNodesExpanded == _cNodesExpanded );

	for ( int i = 0; i < vpgnd.size(); )
	{
		_model.DeleteElem( vpgnd[i++] ) ;
	}

	//  Disconnect the nodes from their distributions.  Note that this destroys distributions
	//	generated during expansion, since their reference counts will go to zero.
	_model.ClearDistributions();

	//  Unmark the network
	_model.BSetBFlag( EIBF_Expanded, false );
}

//
//  Perform the expansion operation against a node.
//
//  This creates:
//
//			A parentless "leak" node for the ensemble, marked as "expansion"
//
//			A "causal" node for each original parent, marked as "expansion"
//
//			An "expand/leak" node for each original parent but the last.  The given
//			node is (reversably) modified for reuse as the last in the chain. These
//			nodes are marked as "expanded" and "expansion", so that expansion
//			arcs will be considered real parents by GNODEMBN::GetParents().
//
void GOBJMBN_MBNET_EXPANDER :: Expand ( GNODEMBND & gndd )
{
	//  Guarantee that the node to be expanded has a sparse distribution
	assert( ! gndd.BFlag( EIBF_Expanded ) );
	assert( gndd.BHasDist() );
	assert( gndd.Bndist().BSparse() );

	//  Get the array of parents
	VPGNODEMBN vpgndParents;
	gndd.GetParents( vpgndParents );
	int cParent = vpgndParents.size();

	VIMD vimd1Dim(1);	//  Useful 1-dimensional subscript vector

	//  Build a leak distribution to use either on the leak
	//	node or on this node if the node has no parents.
	BNDIST * pbndistLeak = new BNDIST();
	{
		//  Locate the leak vector
		const VLREAL * pvlrLeak = gndd.Bndist().PVlrLeak();
		ASSERT_THROW( pvlrLeak,
					  EC_INTERNAL_ERROR,
					  "node CI expansion cannot locate leak/default vector" );
		assert( pvlrLeak->size() == gndd.CState() );

		//  Build a leak distribution
		assert( pvlrLeak->size() == gndd.CState() );
		vimd1Dim[0] = gndd.CState();
		pbndistLeak->SetDense( vimd1Dim );
		MDVCPD & mdvLeak = pbndistLeak->Mdvcpd();
		mdvLeak = *pvlrLeak;
	}

	if ( cParent == 0 )
	{
		//  CI node has no parents; use leak distribution.
		gndd.SetDist( pbndistLeak );
	}

	//  Use the special "internal symbol" character
	char chMark = _model.ChInternal();
	SZC szcNode = gndd.ZsrefName().Szc();

	//  Start the CI expansion chain with a node representing the "leak" or
	//	background event.
	ZSTR zsName;
	//  Format the name "$Leak$Nodename"
	zsName.Format( "%cLeak%c%s",  chMark, chMark, szcNode );
	//  Create the node, initialize it and add it to the network
	GNODEMBND * pgnddLeak = new GNODEMBND;
	pgnddLeak->BSetBFlag( EIBF_Leak );
	pgnddLeak->BSetBFlag( EIBF_Expansion );
	pgnddLeak->SetStates( gndd.VzsrStates() );
	_model.AddElem( zsName, pgnddLeak );
	_cNodesCreated++;
	pgnddLeak->SetDist( pbndistLeak );

	//  Prepare to iterate over the parents
		//  Dense dimensioned subscript vector for causal parent
	VIMD vimdCausal(2);
		//  Dense dimensioned subscript vector for leak/expansion parent
	VIMD vimdLeak(3);
		//  Sparse dimensioned subscript vector for real parent
	VIMD vimdTarget( gndd.Bndist().VimdDim().size() - 1 );
		//  Set up a "normal" vector for causal parents
	VLREAL vlrNormal( gndd.CState() );
	vlrNormal = 0.0;
	vlrNormal[0] = 1.0;
	
	//  Sparse map for this node's distribution.  Note that the last cycle through
	//	the loop will replace the distribution on this node.  However, the
	//	reference object will increment the reference count on the
	//	distribution object, and all created distributions will disappear when
	//  the expansion is reversed.
	REFBNDIST refbndThis = gndd.RefBndist();
	const MPCPDD & dmap = refbndThis->Mpcpdd();

	for ( int iParent = 0; iParent < cParent; iParent++ )
	{
		//  Set to create a new node if this isn't the last parent
		bool bNew = iParent+1 < cParent;
		GNODEMBND * pgnddParent;
		DynCastThrow( vpgndParents[iParent], pgnddParent );
		SZC szcParent = pgnddParent->ZsrefName().Szc();
		//  Create a new leak node if this isn't last parent
		GNODEMBND * pgnddLeakNew = NULL;
		if ( bNew )
		{
			//  Format the name "$Expand$Child$Parent"
			zsName.Format( "%cExpand%c%s%c%s",
							chMark, chMark, szcNode, chMark, szcParent );
			_model.AddElem( zsName, pgnddLeakNew = new GNODEMBND );
			_cNodesCreated++;
			pgnddLeakNew->SetStates( gndd.VzsrStates() );
			pgnddLeakNew->BSetBFlag( EIBF_Expansion );
		}
		else
		{
			pgnddLeakNew = & gndd;
		}
		pgnddLeakNew->BSetBFlag( EIBF_Expanded );

		//	Create a "causal" node for each parent to contain the probabilities
		//	for that parent's abnormal states.
		GNODEMBND * pgnddCausal = new GNODEMBND;
		pgnddCausal->BSetBFlag( EIBF_Expansion );
		pgnddCausal->SetStates( gndd.VzsrStates() );
		//  Format the name "$Causal$Child$Parent"
		zsName.Format( "%cCausal%c%s%c%s",	
						chMark, chMark, szcNode, chMark, szcParent );
		_model.AddElem( zsName, pgnddCausal );
		_cNodesCreated++;

		//  Add the appropriate edges:
		//		from the original parent to the causal parent
		_model.AddElem( new GEDGEMBN_PROB( pgnddParent, pgnddCausal) ) ;
		//		from the old leak node to the new leak node
		_model.AddElem( new GEDGEMBN_PROB( pgnddLeak, pgnddLeakNew ) );
		//		from the causal to the new "leak" node
		_model.AddElem( new GEDGEMBN_PROB( pgnddCausal, pgnddLeakNew ) );
		_cArcsCreated += 3;

		//  Set the priors for the new "causal" pseudo-parent
		//		p( causal | originalParent )
		{
			BNDIST * pbndist = new BNDIST;
			vimdCausal[0] = pgnddParent->CState();
			vimdCausal[1] = gndd.CState();
			pbndist->SetDense( vimdCausal );
			MDVCPD & mdvCausal = pbndist->Mdvcpd();
			vclear( vimdCausal, 0);
			vclear( vimdTarget, 0);
			vimd1Dim[0] = 0;
			//  Zero vector is deterministic based on parent being in normal state
			mdvCausal.UpdatePartial( vimd1Dim, vlrNormal );
			for ( int iAbnorm = 0; ++iAbnorm < pgnddParent->CState(); )
			{
				//  Look up priors in original node for each abnormal state of parent
				vimd1Dim[0] = iAbnorm;
				assert( iParent < vimdTarget.size() );
				vimdTarget[iParent] = iAbnorm;
				MPCPDD::const_iterator itdm = dmap.find(vimdTarget);
				ASSERT_THROW( itdm != dmap.end(), EC_MDVECT_MISUSE, "cannot locate abnormal parent probs" );
				mdvCausal.UpdatePartial( vimd1Dim, (*itdm).second );
			}
			//  Bind the distribution to the causal node
			pgnddCausal->SetDist( pbndist );
		}
			
		//  Set the priors for the new "leak" node
		//		p( newLeakExpand | oldLeakExpand, causal )
		{
			BNDIST * pbndist = new BNDIST;
			int cValue = gndd.CState();
			assert( cValue == pgnddCausal->CState() && cValue == pgnddLeak->CState() );
			vclear( vimdLeak, cValue );
			pbndist->SetDense( vimdLeak );
			MDVCPD & mdvLeak = pbndist->Mdvcpd();
		
			for ( int il = 0; il < cValue; il++ )
			{
				vimdLeak[0] = il;
				for ( int ic = 0; ic < cValue; ic++ )
				{
					vimdLeak[1] = ic;
					for ( int iself = 0; iself < cValue; iself++ )
					{
						vimdLeak[2] = iself;
						int ivalue = il >= ic ? il : ic;
						assert( ivalue < cValue );
						REAL r = ivalue == iself ? 1.0 : 0.0;
						mdvLeak[vimdLeak] = r;
					}
				}
			}

			pgnddLeakNew->SetDist( pbndist );
		}

		//  Verify that the dimensions of the created nodes match their
		//		created dense distributions
		assert( pgnddCausal->BCheckDistDense() );
		assert( pgnddLeakNew->BCheckDistDense() );

		pgnddLeak = pgnddLeakNew;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\glnk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       glnk.h
//
//--------------------------------------------------------------------------

//
//   GLNK.H
//
//       This file defines base classes for smart linked lists.
//

#if !defined(_GLNK_H_)
#define _GLNK_H_

#include "basics.h"

//  Disable "warning C4355: 'this' : used in base member initializer list"
#pragma warning ( disable : 4355 )

//  Disable	warning about using 'bool'
#pragma warning ( disable : 4237 )

//      Forward declarations
class GLNK;   				//  Just a linked list anchor
class GELEM;				//	Base class for trees or dags
class GLNKEL;				//  A linked element
class GLNKCHN ;  			//  An imbeddable element
class GELEMLNK;				//	A containerizable element

////////////////////////////////////////////////////////////////////
//	class GLNKBASE:  just a pair of pointers.  Used as a basis for
//			linked lists and bidirectional pointers.
//
////////////////////////////////////////////////////////////////////
class GLNKBASE  				// A linked list anchor
{
  protected:
	GLNKBASE * _plnkNext ;     	// The next link in the chain
	GLNKBASE * _plnkPrev ;    	// The previous link in the chain
  public:

	GLNKBASE ()
		: _plnkNext(NULL),
		  _plnkPrev(NULL)
		{}
	~ GLNKBASE () {};

	GLNKBASE * & PlnkNext ()       	{ return _plnkNext ; }
	GLNKBASE * & PlnkPrev ()      	{ return _plnkPrev ; }

  private:
	//  Block compiler from generating invalid functions
	HIDE_UNSAFE(GLNKBASE);
};

//  Template to generate a pair of pointers to given subclass
template<class L>
class XLBASE
{
  protected:
	L * _plNext ;
	L * _plPrev ; 
  public:
	XLBASE ()	
		: _plNext(NULL),
		_plPrev(NULL)
		{}
	L * & PlnkNext ()       		{ return _plNext ;	}
	L * & PlnkPrev ()      		{ return _plPrev ; }
	const L * PlnkNext () const		{ return _plNext ;	}
	const L * PlnkPrev () const	{ return _plPrev ; }
  private:
	XLBASE(const XLBASE &);
	XLBASE & operator == (const XLBASE &);
};

////////////////////////////////////////////////////////////////////
//  template XLSS:  simple alias template using "source" and "sink"
//		terminology.
////////////////////////////////////////////////////////////////////
template<class L>
class XLSS : public XLBASE<L>
{
  public:
	L * & PlnkSink ()       	{ return _plNext ; }
	L * & PlnkSource ()      	{ return _plPrev ; }
	L * PlnkSink () const      	{ return _plNext ; }
	L * PlnkSource () const    	{ return _plPrev ; }
};

////////////////////////////////////////////////////////////////////
//	class GLNK:  basic doubly-linked list.  Linkage is always
//			done directly between LNKs, not their containing objects
//
////////////////////////////////////////////////////////////////////
class GLNK : public GLNKBASE	// A linked list anchor
{
  protected:
	void Empty () 
	{
	   PlnkPrev() = this ;
	   PlnkNext() = this ;
	}

	GLNK () 
	{
		Empty() ;
	}

	~ GLNK ()
	{
		Unlink() ;
	}

	void Link ( GLNK * plnkNext ) 
	{
	   Unlink() ;
	   PlnkPrev() = plnkNext->PlnkPrev() ;
	   PlnkNext() = plnkNext ;
	   plnkNext->PlnkPrev()->PlnkNext() = this ;
	   PlnkNext()->PlnkPrev() = this ;
	}

	void Unlink ()
	{
	   PlnkNext()->PlnkPrev() = PlnkPrev() ;
	   PlnkPrev()->PlnkNext() = PlnkNext() ;
	   Empty() ;
	}

	// Const and non-const accessor to base pointer pair
	GLNK * & PlnkNext ()       	{ return (GLNK *&) _plnkNext ; }
	GLNK * & PlnkPrev ()      	{ return (GLNK *&) _plnkPrev ; }
	const GLNK * PlnkNext ()  const   	{ return (GLNK *) _plnkNext ; }
	const GLNK * PlnkPrev () const   	{ return (GLNK *) _plnkPrev ; }

  public:
	//  Return count of elements on list, including self
	long Count () const
	{
		long cItem = 1 ;

		for ( GLNK * plnkNext = (CONST_CAST(GLNK *, this))->PlnkNext() ;
			  plnkNext != this ;
			  plnkNext = plnkNext->PlnkNext() )
		{
			cItem++ ;
		}
		return cItem ;
	}

	bool BIsEmpty () const   { return PlnkNext() == this ; }

  private:
	//  Block compiler from generating invalid functions
	HIDE_UNSAFE(GLNK);
};

////////////////////////////////////////////////////////////////////
//	class GELEM: Base class for linkable objects
////////////////////////////////////////////////////////////////////
const int g_IGelemTypeInc = 10000;

class GELEM 
{
	friend class GLNKCHN ;
  public:
	GELEM() {}
	virtual ~ GELEM () {}
	
	enum EGELMTYPE
	{ 
		EGELM_NONE	 = 0, 
		EGELM_NODE	 = EGELM_NONE	+ g_IGelemTypeInc, 
		EGELM_EDGE	 = EGELM_NODE	+ g_IGelemTypeInc,
		EGELM_BRANCH = EGELM_EDGE	+ g_IGelemTypeInc,
		EGELM_LEAF	 = EGELM_BRANCH + g_IGelemTypeInc, 
		EGELM_GRAPH	 = EGELM_LEAF	+ g_IGelemTypeInc,
		EGELM_TREE	 = EGELM_GRAPH	+ g_IGelemTypeInc,
		EGELM_CLIQUE = EGELM_GRAPH  + g_IGelemTypeInc
	};
	virtual INT EType () const
			{ return EGELM_NONE ; }

	bool BIsEType ( INT egelmType )
	{
		INT etype = egelmType / g_IGelemTypeInc;
		INT etypeThis = EType() / g_IGelemTypeInc;
		return etype == etypeThis;	
	}

  protected:
  	//  Return the offset of the given pointer pair from the element.
	int CbOffsetFrom ( const GLNKBASE * p ) const
		//  One could assert that the GLNKCHN really lies within object
		//  boundaries by using a virtualized "sizeof" accessor.  Also,
		//	check mod-4 and other validity conditions.
	   { return ((char*)p) - ((char*)this) ; }
};

////////////////////////////////////////////////////////////////////
//	class GLNKCHN: 
//		A GLNK which knows its offset within the containing object.
//
//	To perform doubly-linked list operations, two pieces of information
//	are necessary:  the location of the pointer pair and the location
//	of the containing object.  By giving the GLNKCHN its offset from
//	the start of the object during construction, it can perform all
//	necessary operations, including automatically unlinking during
//	destruction.
////////////////////////////////////////////////////////////////////
class GLNKCHN : public GLNK
{
  private:
	int _cbOffset ; 			// Number of bytes offset from
								//   start of owning structure
  public:
	GLNKCHN ( GELEM * pgelemOwner )
		: _cbOffset(0)
	{
		_cbOffset = pgelemOwner->CbOffsetFrom( this );
	}
	~ GLNKCHN () {}
	void Link ( GELEM * pgelemNext ) 
	{
		//  Assuming that the GLNKCHN onto which we're linking is at the
		//  same offset in the given GLNKEL as it is in *this, link it.
		GLNKCHN * plnkchn = PlnkchnPtr( pgelemNext );
		GLNK::Link( plnkchn ) ;
	}

	void Unlink () 
	{
	   GLNK::Unlink() ;
	}

	GELEM * PgelemNext () 
	{
		return BIsEmpty()
			? NULL
			: PlnkchnNext()->PgelemChainOwnerPtr() ;
	}

	GELEM * PgelemPrev () 
	{
		return BIsEmpty()
			? NULL
			: PlnkchnPrev()->PgelemChainOwnerPtr() ;
	}

  protected:
	//      Return a pointer to the base object. given a pointer to one of
	//      	its GLNKCHN member objects.
	GELEM * PgelemChainOwnerPtr () const
		{ return (GELEM *) (((SZC) this) - _cbOffset) ; }

	//  Given a pointer to a GELEM presumed to be of the same base
	//  type as this object's container, return a pointer to the
	//  corresponding GLNKCHN in it.
	GLNKCHN * PlnkchnPtr ( const GELEM * pgelem ) const
	{ 
#ifdef _DEBUG
		//  Debug version does error checking
		GLNKCHN * plnkchn = (GLNKCHN *) (((SZC) pgelem) + _cbOffset); 
		if ( _cbOffset != plnkchn->_cbOffset )
			throw GMException(EC_LINK_OFFSET,"invalid GLNKCHN offset");
		return plnkchn;
#else
		return (GLNKCHN *) (((SZC) pgelem) + _cbOffset);
#endif
	}

	//  Protected accessors to GLNK pointers cast to GLNKCHN pointers
	GLNKCHN * PlnkchnNext  () { return (GLNKCHN *) GLNK::PlnkNext()  ; }
	GLNKCHN * PlnkchnPrev () { return (GLNKCHN *) GLNK::PlnkPrev() ; }
  private:
	HIDE_UNSAFE(GLNKCHN);
};

////////////////////////////////////////////////////////////////////
//	template XCHN: 
//		for creating types of chains given a containing object
//		which is a subclass of GELEM
////////////////////////////////////////////////////////////////////
template<class XOBJ>
class XCHN : public GLNKCHN
{
  public:
	XCHN ( XOBJ * pgelemOwner ) 
		: GLNKCHN(pgelemOwner) 
		{}
	void Link ( XOBJ * pgelemNext ) 
		{ GLNKCHN::Link(pgelemNext); }
	void Unlink () 
		{ GLNKCHN::Unlink(); }
	XOBJ * PgelemNext () 
		{ return (XOBJ *) GLNKCHN::PgelemNext(); }
	XOBJ * PgelemPrev () 
		{ return (XOBJ *) GLNKCHN::PgelemPrev(); }
	XOBJ * PgelemThis () 
		{ return PgelemChainOwnerPtr(); }

  protected:
	XOBJ * PgelemChainOwnerPtr () const
		{ return (XOBJ *) GLNKCHN::PgelemChainOwnerPtr(); }

	XCHN * PlnkchnPtr ( const XOBJ * pgelem ) const
		{ return (XCHN *) GLNKCHN::PlnkchnPtr(pgelem); }

	XCHN * PlnkchnNext () { return (XCHN *) GLNKCHN::PlnkchnNext()  ; }
	XCHN * PlnkchnPrev () { return (XCHN *) GLNKCHN::PlnkchnPrev() ; }
  private:
	XCHN(const XCHN &);
	XCHN & operator == (const XCHN &);
};

////////////////////////////////////////////////////////////////////
//  Class GLNKEL:
//      Simple base class for things managed as members of linked lists.
//      One or more LNKCHNs or LNKs can be contained within subclass objects;
//      it contains one "implicit" GLNKCHN for linking siblings in the
//      	implicit tree created by NTREE.
//		Trees are based upon this type.
////////////////////////////////////////////////////////////////////
class GLNKEL : public GELEM
{
  public:
  	//  Internal class for chains (doubly-linked lists)
	typedef XCHN<GLNKEL> CHN;

	GLNKEL ()
		: _chn( this ),
		_iType(0),
		_iMark(0)
		{}

	virtual ~ GLNKEL () {}
	CHN & Chn ()
		{ return _chn ; }
	GLNKEL * PlnkelPrev ()
		{ return Chn().PgelemPrev() ; }
	GLNKEL * PlnkelNext ()
		{ return Chn().PgelemNext() ; }

	// Return the mutable (user-definable) object type
	INT & IType ()				{ return _iType;	}
	INT IType() const			{ return _iType;	}
	INT & IMark ()				{ return _iMark;	}
	INT IMark () const			{ return _iMark;	}

  protected:
	CHN _chn ;					// Primary association chain
	INT _iType;					// User-definable type
	INT _iMark;					// Network walking mark

  protected:
	//  Throw an exception when an invalid cloning operation occurs
	void ThrowInvalidClone ( const GLNKEL & t );

  	HIDE_UNSAFE(GLNKEL);
};

////////////////////////////////////////////////////////////////////
//  Class GELEMLNK:
//		Base class for linkable objects in a collection, such as 
//		graph.  Trees are NOT based upon this type, since trees
//		are not forests (they cannot have associated but disjoint 
//		sets of objects).
////////////////////////////////////////////////////////////////////
class GELEMLNK : public GLNKEL
{
  public:
  	//  Internal class for chains (doubly-linked lists)
	typedef XCHN<GELEMLNK> CHN;

	GELEMLNK () {}
	virtual ~ GELEMLNK () {}

	//  Locate an element (other than 'this') by type
	GELEMLNK * PglnkFind ( EGELMTYPE eType, bool bExact = false )
	{	
		for ( GELEMLNK * pg = this;
			  pg->ChnColl().PgelemThis() != this;
			  pg = pg->ChnColl().PgelemNext() ) 
		{
			if ( bExact ? pg->EType() == eType : pg->BIsEType(eType) ) 
				return pg;
		}
		return NULL;
	}
		
	// Element chain:  all items belonging to this collection
	CHN & ChnColl ()
		{ return (CHN &) _chn ; }

  private:
	HIDE_UNSAFE(GELEMLNK);
};

#endif // !defined(_GLNK_H_)

//  End of glnk.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\glnkenum.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       glnkenum.h
//
//--------------------------------------------------------------------------

//
//	GLNKENUM.H
//
#if !defined(_GLNKENUM_H_)
#define _GLNKENUM_H_

	//  Base class for generic linkable object enumerators
class GLNKENUM_BASE
{
 public:
	//  Construct an enumerator.
	GLNKENUM_BASE ( const GLNKEL & lnkel, int iDir = 1 )
	{
		Reset( lnkel, iDir ) ;
	}

	//  Position to the next pointer
	GLNKEL * PlnkelNext () ;
	//  Return the current object pointer
	inline GLNKEL * PlnkelCurrent()
		{ return _plnkelNext ; }
	//  Set the enumerator to have a new base
	void Reset ( const GLNKEL & lnkel, int iDir = 0 ) 
	{
		_plnkelStart = const_cast<GLNKEL *>(& lnkel) ;
		_plnkelNext = NULL ;
		if ( iDir >= 0 )
			_iDir = iDir ;
	}

  protected:
	GLNKEL * _plnkelStart ;
	GLNKEL * _plnkelNext ;
	int _iDir ;    			// Enumeration direction
};


#define BOOL_CROSS_PRODUCT(a,b) (((a) > 0) + (((b) > 0) * 2))
inline 
GLNKEL * GLNKENUM_BASE :: PlnkelNext ()
{
	GLNKEL * plnkelResult = NULL ;

	switch ( BOOL_CROSS_PRODUCT( _plnkelNext != NULL, _iDir ) )
	{
		case BOOL_CROSS_PRODUCT( true, true ):
			if ( _plnkelNext->PlnkelNext() != _plnkelStart )
				plnkelResult =_plnkelNext = _plnkelNext->PlnkelNext() ;
			break ;

		case BOOL_CROSS_PRODUCT( true, false ):
			if ( _plnkelNext != _plnkelStart )
				plnkelResult = _plnkelNext = _plnkelNext->PlnkelPrev() ;
			break ;

		case BOOL_CROSS_PRODUCT( false, true ):
			plnkelResult = _plnkelNext = _plnkelStart ;
			break ;

		case BOOL_CROSS_PRODUCT( false, false ):
			plnkelResult = _plnkelNext = _plnkelStart->PlnkelPrev() ;
			break ;
	}
	return plnkelResult ;
}


template <class L, bool bAnchor> 
class GLNKENUM : public GLNKENUM_BASE
{
 public:
	//  Construct an enumerator.  If 'bAnchor', then the anchor object is
	//  skipped during enumeration.
	GLNKENUM ( const L & lnkel, bool bIsAnchor = bAnchor, int iDir = 1 )
		: GLNKENUM_BASE( lnkel, iDir )
		{
			if ( bIsAnchor )
				PlnkelNext() ;
		}
	//  Position to the next pointer
	L * PlnkelNext ()
		{ return (L *) GLNKENUM_BASE::PlnkelNext() ; }
	//  Return the current object pointer
	L * PlnkelCurrent()
		{ return (L *) _plnkelNext ; }
	//  Set the enumerator to have a new base
	void Reset ( const L & lnkel, int iDir = -1 )
		{ GLNKENUM_BASE::Reset( lnkel, iDir ) ; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\gelmwalk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       gelmwalk.h
//
//--------------------------------------------------------------------------

//
//  gelmwalk.h
//
#ifndef _GELMWALK_H_
#define _GELMWALK_H_

#include "gelem.h"


//  Control structure
struct EWALKCTL
{
	int _bBreadth : 1;				// Breath-first or Depth-first
	int _bAscend  : 1;				// Up or down
	int _bInvert  : 1;				// Normal order or backwards
};

////////////////////////////////////////////////////////////////////
//	class GRPHWALK: Generalize walk-a-graph class.  
//
//		Subclass and declare BSelect() and BMark().
//		BSelect() is called to decide if a node should be followed.
//		BMark() is called to perform unique work on the node.  If
//		it returns false, walk is terminated immediately.
//
////////////////////////////////////////////////////////////////////
class GRPHWALK
{
  public:
	GRPHWALK ( GNODE * pnodeStart, EWALKCTL ectl )
		: _pnodeStart(pnodeStart),
		  _ectl(ectl)
		{}

	~ GRPHWALK() {}

	void Walk ()
	{
		if ( _ectl._bBreadth )
			BBreadthFirst( _pnodeStart );
		else
			BDepthFirst( _pnodeStart );
	}
		
  protected:
	GNODE * _pnodeStart;			// Point of origin
	EWALKCTL _ectl;					// Type, ordering and direction flags

  protected:
	//  Return true if this node should be followed
	virtual bool BSelect ( GNODE * pnode ) = 0;
	//  Mark/fiddle with the node; return false if enumeration should end
	virtual bool BMark ( GNODE * pnode ) = 0;

	bool BDepthFirst ( GNODE * pnode );
	bool BBreadthFirst ( GNODE * pnode );
};

////////////////////////////////////////////////////////////////////
//	template GRPHWALKER:
//		Template for generating walk-a-graph routines
////////////////////////////////////////////////////////////////////
template <class GND> 
class GRPHWALKER : public GRPHWALK
{
  public:
	GRPHWALKER ( GND * pnodeStart, EWALKCTL ectl );

	//  You must write your own variants of these
	virtual bool BSelect ( GND * pnode );
	virtual bool BMark ( GND * pnode );

  protected:
	//  Type-safe redirectors for derived base types.
	virtual bool BSelect ( GNODE * pnode )
		{ return BSelect( (GND *) pnode ); }
	virtual bool BMark ( GNODE * pnode )
		{ return BMark( (GND *) pnode ); }

};

////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//  Inline member functions
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
inline
bool GRPHWALK :: BDepthFirst ( GNODE * pnode )
{
	GNODENUM<GNODE> itnd( _ectl._bAscend, _ectl._bInvert );
	
	for ( ; itnd.PnodeCurrent(); itnd++ )
	{
		GNODE * pnode2 = *itnd;
		if ( BSelect( pnode2 ) )
		{
			if ( ! BMark( pnode2 ) )
				return false;
			BDepthFirst( pnode2 );
		}
	}
	return true;
}

inline
bool GRPHWALK :: BBreadthFirst ( GNODE * pnode )
{
	VPGNODE vpnodeA;
	VPGNODE vpnodeB;
	VPGNODE * pvThis = & vpnodeA;
	VPGNODE * pvNext = & vpnodeB;
	VPGNODE * pvTemp = NULL;

	//  Seed the arrays with the starting position
	pvNext->push_back(pnode);

	//  Create the reusable enumerator
	GNODENUM<GNODE> itnd( _ectl._bAscend, _ectl._bInvert );

	while ( pvNext->size() > 0)
	{	
		//  Swap the arrays from the last cycle and this cycle
		pvTemp = pvThis;
		pvThis = pvNext;
		pvNext = pvTemp;
		pvNext->clear();

		//  Walk all descendents at this level and expand the next level
		//	  into the secondary array
		for ( INT iThis = 0; iThis < pvThis->size(); iThis++ )
		{
			GNODE * pnode = (*pvThis)[iThis];

			for ( itnd.Set( pnode ); itnd.PnodeCurrent(); itnd++ )
			{
				GNODE * pnode2 = *itnd;
				if ( BSelect( pnode2 ) )
				{
					if ( ! BMark( pnode2 ) )
						return false;
					pvNext->push_back(pnode2);
				}
			}
		}
	}
	return true;
}

#endif //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\gmexcept.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       gmexcept.h
//
//--------------------------------------------------------------------------

//
//	gmexcept.h:  Graphical Model Exception handling
//
#ifndef _GMEXCEPT_H_
#define _GMEXCEPT_H_

#include <assert.h>

////////////////////////////////////////////////////////////////
//	Exception Handling
//
//	Exception error code
////////////////////////////////////////////////////////////////
enum ECGM
{
	EC_OK,						//  No error
	EC_WARN_MIN = 100,			//  Lowest warning value
	EC_ERR_MIN = 10000,			//  Lowest error value

	// Include the standard translatable errors
	#include "errordef.h"

	EC_USER_MIN = 20000			//  Lowest user-definable error
};


//	Exception class, using STL class "exception".
//	An "__exString" is just a char *.
//  class "GMException": graphical model exception
class GMException : public exception
{
  public:
    GMException( ECGM ec)
		: _ec(ec)
		{}
    GMException(ECGM ec, const __exString& exs)
		: exception(exs),
		_ec(ec)
		{}
    GMException(ECGM ec, const exception& excp)
		: exception(excp),
		_ec(ec)
		{}
	ECGM Ec () const { return _ec ; }
  protected:
	ECGM _ec;	
};

//  Exception subclass for assertion operations, such as "not implemented"
//  or "internal error".  Can be used in place of any GMException.
//  If debug build, assertion will occur during exception processing.
class GMExceptionAssert : public GMException
{
  public:
    GMExceptionAssert(ECGM ec, const __exString& exs, SZC szcFile, unsigned iLine)
		: GMException(ec,exs)
		{
#if defined(_DEBUG)
			_assert((void*)exs, (void*)szcFile, iLine);
#endif
		}
};

#define ASSERT_THROW(expr,ec,exs)  { if ( !(expr) ) THROW_ASSERT(ec,exs) ; }
#define THROW_ASSERT(ec,exs)  throw GMExceptionAssert(ec,exs,__FILE__,__LINE__)

extern VOID NYI();

#endif  // _GMEXCEPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\gmobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       gmobj.h
//
//--------------------------------------------------------------------------

//
//	GMOBJ.H: Grapical model objects declarations
//

#ifndef _GMOBJ_H_
#define _GMOBJ_H_

#include <list>				//  STL list template
#include <assert.h>

#include <iostream>
#include <fstream>

#include "model.h"			//  Graphical model
#include "gmprop.h"			//  Properties and proplists
#include "mbnflags.h"		//	Belief network marking flags static declarations

class CLAMP;				//  An instantiation for a node, discrete or continuous
class GOBJMBN;				//  A named object in a belief network
class GNODEMBN;				//	A node in a belief network
class GNODEMBND;			//  A discrete node
class GEDGEMBN;				//  An arc in a belief network
class MBNET;				//  A belief network
class MBNET_MODIFIER;		//	An object that alters a belief network
class GOBJMBN_INFER_ENGINE;	//  Abstract class for inference engine, based on MBNET_MODIFIER
class GOBJMBN_CLIQSET;		//  A group of junction trees, based on GOBJMBN_INFER_ENGINE
class GOBJMBN_CLIQUE;		//  A clique in a junction tree
class GEDGEMBN_SEPSET;		//  An edge in the junction tree (sepset)
class GOBJMBN_DOMAIN;		//  Named, sharable state space domain

//	Define VGNODEMBN, an array of nodes
DEFINEVP(GNODEMBN);
DEFINEVCP(GNODEMBN);

struct PTPOS
{
	PTPOS( long x = 0, long y = 0 )
		: _x(x),_y(y)
	{}
	long _x;
	long _y;
};


////////////////////////////////////////////////////////////////////
//	class GEDGEMBN:
//		An edge of any kind in belief network.
////////////////////////////////////////////////////////////////////
class GEDGEMBN : public GEDGE
{
  public:
 	enum ETYPE
	{
		ETNONE = GELEM::EGELM_EDGE,	// None
		ETPROB,						// Probabilistic
		ETCLIQUE,					// Clique membership
		ETJTREE,					// Junction tree linkage
		ETUNDIR,					// Undirected edge for topological operations
		ETDIR,						// Directed edge for topological operations
		ETCLIQSET,					// Link to a root clique in a jtree
		ETEXPAND					// Link from original to expanded node
	};

	GEDGEMBN ( GOBJMBN * pgnSource,
			   GOBJMBN * pgnSink )
		: GEDGE( pgnSource, pgnSink )
		{}

	GOBJMBN * PobjSource ()		{ return (GOBJMBN *) GEDGE::PnodeSource();	}
	GOBJMBN * PobjSink ()		{ return (GOBJMBN *) GEDGE::PnodeSink();	}

	virtual GEDGEMBN * CloneNew ( MODEL & modelSelf,				// the original network
								  MODEL & modelNew,					// the new network
								  GOBJMBN * pgobjmbnSource,			// the original source node
								  GOBJMBN * pgobjmbnSink,			// the original sink node
								  GEDGEMBN * pgdegeNew = NULL );	// the new edge or NULL

	virtual INT EType () const
		{ return ETNONE ; }

	virtual ~ GEDGEMBN () {}

	//  Accessors for the array of flag bits
	bool BFlag ( IBFLAG ibf ) const	
		{ return _vFlags.BFlag( ibf );	}
	bool BSetBFlag ( IBFLAG ibf, bool bValue = true )
		{ return _vFlags.BSetBFlag( ibf, bValue );	}

  protected:
	VFLAGS _vFlags;						//  Bit vector of flags

	HIDE_UNSAFE(GEDGEMBN);
};

////////////////////////////////////////////////////////////////////
//	class CLAMP:
//		A forced value (evidence) for a node, continuous or discrete.
//		Use assignment operator to update.
////////////////////////////////////////////////////////////////////
class CLAMP
{
  public:
	CLAMP ( bool bDiscrete = true, RST rst = 0.0, bool bActive = false )
		: _bDiscrete(bDiscrete),
		_bActive(bActive),
		_rst(rst)
	{
	}

	bool BActive () const			{ return _bActive;	}
	bool BDiscrete () const			{ return _bActive;  }

	const RST & Rst () const		
	{
		assert( BActive() && ! BDiscrete() );
		return _rst;
	}
	IST Ist () const
	{
		assert( BActive() && BDiscrete() );
		return IST(_rst);
	}

	bool operator == ( const CLAMP & clamp ) const
	{
		return _bDiscrete == clamp._bDiscrete
		    && _bActive == clamp._bActive
			&& (!_bActive || _rst == clamp._rst);
	}
	bool operator != ( const CLAMP & clamp ) const
	{
		return ! (self == clamp);
	}

  protected:
	bool _bActive;				//  Is this clamp active?
	bool _bDiscrete;			//  Is this discrete or continuous?
	RST _rst;					//  State (coerced to integer if discrete)
};

////////////////////////////////////////////////////////////////////
//	class GNODEMBN:
//		A  node in belief network, continuous or discrete.
//		Hungarian: "gndbn"
////////////////////////////////////////////////////////////////////
class GNODEMBN : public GOBJMBN
{
	friend class DSCPARSER;
	friend class MBNET;

  public:
	GNODEMBN ();
	virtual ~ GNODEMBN();

	virtual INT EType () const
		{ return EBNO_NODE ; }

	virtual GOBJMBN * CloneNew ( MODEL & modelSelf,
								 MODEL & modelNew,
								 GOBJMBN * pgobjNew = NULL );

	//  Node sub-type: use IType() to access.
	enum FNODETYPE
	{	//  Flag definitions (i.e., bits, not values)
		FND_Void		= 0,	//  Node is abstract base class
		FND_Valid		= 1,	//  Node is usable
		FND_Discrete	= 2		//	Node is discrete
	};

	UINT CParent () const		{ return CSourceArcByEType( GEDGEMBN::ETPROB );	}
	UINT CChild () const		{ return CSinkArcByEType( GEDGEMBN::ETPROB );	}

	INT & ITopLevel ()			{ return _iTopLevel;			}
	INT ITopLevel () const		{ return _iTopLevel;			}
	PTPOS & PtPos ()			{ return _ptPos;				}
	ZSTR & ZsFullName ()		{ return _zsFullName;			}
	LTBNPROP & LtProp ()		{ return _ltProp;				}

	virtual void Dump ();
	virtual void Visit ( bool bUpwards = true );

	//  Add topological elements to given array; if "include self", self is last.
	//		Fill array with parent pointers	(follow directed arcs)
	void GetParents ( VPGNODEMBN & vpgnode,					//  Result array
					  bool bIncludeSelf = false,			//  Place self as last entry in list
					  bool bUseExpansion = true );			//  If expanded, use expansion only
	void GetFamily ( VPGNODEMBN & vpgnode,
					  bool bUseExpansion = true )
		{ GetParents(vpgnode,true,bUseExpansion); }
	//		Fill array with child pointers (follow directed arcs)
	void GetChildren ( VPGNODEMBN & vpgnode, bool bIncludeSelf = false );
	//		Fill array with neighbors (follow undirected arcs)
	void GetNeighbors ( VPGNODEMBN & vpgnode, bool bIncludeSelf = false );
	//  Return true if a node is neighbor
	bool BIsNeighbor ( GNODEMBN * pgndmb );
	//  Return the index number of the parent or child or -1 if no relation.
	int IParent ( GNODEMBN * pgndmb, bool bReverse = false );
	int IChild ( GNODEMBN * pgndmb, bool bReverse = false );
	//  Build the probability descriptor describing the node and its parents
	void GetVtknpd ( VTKNPD & vtknpd, bool bUseExpansion = true );

	//  Query and access clamping information
	const CLAMP & ClampIface () const	{ return _clampIface;	}
	CLAMP & ClampIface ()				{ return _clampIface;	}

  protected:
	INT _iTopLevel;				// Topological level
	LTBNPROP _ltProp;			// The list of user-definable properties
	PTPOS _ptPos;				// Display position in graphical display
	ZSTR _zsFullName;			// Full name of node
	CLAMP _clampIface;			// User interface clamp

  protected:
	//  Compare the topology of this node to that of the given distribution
	//		token list to this.  If 'pvpgnode', fill it with pointers to
	//		the parent nodes
	bool BMatchTopology ( MBNET & mbnet,
						  const VTKNPD & vtknpd,
						  VPGNODEMBN * pvpgnode = NULL );

	HIDE_UNSAFE(GNODEMBN);
};

////////////////////////////////////////////////////////////////////
//	class GEDGEMBN_U:  An undirected edge
////////////////////////////////////////////////////////////////////
class GEDGEMBN_U : public GEDGEMBN
{
  public:
	GEDGEMBN_U ( GNODEMBN * pgnSource,
			     GNODEMBN * pgnSink )
		: GEDGEMBN( pgnSource, pgnSink )
		{}
	virtual INT EType () const
		{ return ETUNDIR; }

	virtual ~ GEDGEMBN_U() {}
};

////////////////////////////////////////////////////////////////////
//	class GEDGEMBN_D:  A directed edge
////////////////////////////////////////////////////////////////////
class GEDGEMBN_D : public GEDGEMBN
{
  public:
	GEDGEMBN_D ( GNODEMBN * pgnSource,
			     GNODEMBN * pgnSink )
		: GEDGEMBN( pgnSource, pgnSink )
		{}
	virtual INT EType () const
		{ return ETDIR; }

	virtual ~ GEDGEMBN_D() {}
};


////////////////////////////////////////////////////////////////////
//	class GEDGEMBN_PROB:
//		A probabilistic arc in a belief network.
////////////////////////////////////////////////////////////////////
class GEDGEMBN_PROB : public GEDGEMBN_D
{
  public:
	GEDGEMBN_PROB ( GNODEMBN * pgndSource,
					GNODEMBN * pgndSink )
		: GEDGEMBN_D( pgndSource, pgndSink )
		{}

	virtual INT EType () const
		{ return ETPROB ; }

	virtual ~ GEDGEMBN_PROB () {}

	virtual GEDGEMBN * CloneNew ( MODEL & modelSelf,				// the original network
								  MODEL & modelNew,					// the new network
								  GOBJMBN * pgobjmbnSource,			// the original source node
								  GOBJMBN * pgobjmbnSink,			// the original sink node
								  GEDGEMBN * pgdegeNew = NULL );	// the new edge or NULL

	GNODEMBN * PgndSource ()	{ return (GNODEMBN *) GEDGE::PnodeSource();	}
	GNODEMBN * PgndSink ()		{ return (GNODEMBN *) GEDGE::PnodeSink();	}

	HIDE_UNSAFE(GEDGEMBN_PROB);
};


////////////////////////////////////////////////////////////////////
//	class GNODEMBND:
//		A discrete node in belief network.
////////////////////////////////////////////////////////////////////
class GNODEMBND : public GNODEMBN
{
	friend class DSCPARSER;

  public:
	GNODEMBND ();
	virtual ~ GNODEMBND ();
	virtual GOBJMBN * CloneNew ( MODEL & modelSelf,
								 MODEL & modelNew,
								 GOBJMBN * pgobjNew = NULL );

	UINT CState() const			
		{ return _vzsrState.size();	}
	const VZSREF & VzsrStates() const
		{ return _vzsrState; }
	void SetStates ( const VZSREF & vzsrState )
		{ _vzsrState = vzsrState; }
	//  Return true if there's an associated distribution
	bool BHasDist () const		
		{ return _refbndist.BRef();		}
	//	Set the distribution from the given net's distribution map
	void SetDist ( MBNET & mbnet );
	//  Bind the given distribution this node
	void SetDist ( BNDIST * pbndist );
	//  Return the distribution
	BNDIST & Bndist ()			
	{
		assert( BHasDist() );
		return *_refbndist;
	}
	const BNDIST & Bndist () const
	{
		assert( BHasDist() );
		return *_refbndist;
	}

	//  Return true if the distribution is dense (false ==> sparse)
	bool BDense () const		
	{
		assert( BHasDist() );
		return _refbndist->BDense() ;
	}
	
	//  Return the discrete dimension vector of this node if possible;
	//	return false if any parent is not discrete.
	bool BGetVimd ( VIMD & vimd,							//  Dimension array to fill
					bool bIncludeSelf = false,				//  Place self as last entry in list
					bool bUseExpansion = true );			//  If expanded, use expansion only

	void Dump ();

	void ClearDist()
	{
		_refbndist = NULL;
	}
	const REFBNDIST & RefBndist ()
		{ return _refbndist; }
	bool BCheckDistDense ();

	const ZSREF ZsrDomain() const
		{ return _zsrDomain; }
	void SetDomain ( const GOBJMBN_DOMAIN & gobjrdom );
	
  protected:
	VZSREF _vzsrState;			// Names of states
	ZSREF _zsrDomain;			// Domain of states, if any
	REFBNDIST _refbndist;		// Distribution object

	HIDE_UNSAFE(GNODEMBND);
};

DEFINEVP(GNODEMBND);			//  A vector containing pointers to nodes
DEFINEV(VPGNODEMBN);			//  A vector of vectors containing pointers to nodes
DEFINEV(VPGNODEMBND);			//  A vector of vectors containing pointers to discrete nodes

////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//
//	MBNET_MODIFIER:  A generic superclass for active objects
//		which modify a belief network in a reversible fashion.
//		The belief network (MBNET) object maintains a stack of these
//		things and calls each object's Destroy() function as necessary
//		to "unstack".
//
//		These objects should be reusable; that is, the outer level
//		creator may call Create(), followed by Destroy(), followed by
//		Create() again.
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
class MBNET_MODIFIER : public GOBJMBN
{
  public:
	MBNET_MODIFIER ( MBNET & model )
		: _model(model)
		{}
	virtual ~ MBNET_MODIFIER () {}

	virtual INT EType () const
		{ return EBNO_MBNET_MODIFIER; }

	//  Perform any creation-time operations
	virtual void Create () = 0;
	//  Perform any special destruction
	virtual void Destroy () = 0;
	//  Return true if positions in modifier stack can be reversed;
	//		default is "no" (false).
	virtual bool BCommute ( const MBNET_MODIFIER & mbnmod )
		{ return false; }
	//  Return true if construction resulted in no modifications to network
	//		i.e., operation was moot; default is "no" (false).
	virtual bool BMoot ()
		{ return false;	}

	MBNET & Model ()					{ return _model;		}

  protected:
	MBNET & _model;						//  The model we're operating on

	HIDE_UNSAFE(MBNET_MODIFIER);
};

// Define an array of pointers to modifiers, "VPMBNET_MODIFIER".
DEFINEVP(MBNET_MODIFIER);

////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//	MBNET_NODE_RANKER:  A generic superclass for external objects
//		which rank or order nodes by some criteria.  Operates as
//		a function object; i.e., it is activated by use of the
//		function call operator.
//
//	    Objects of subclasses of this class must be reusable.  
//		That is, the functin call operator must be callable
//		repeatedly.
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
class MBNET_NODE_RANKER : public GOBJMBN
{
  public:
	MBNET_NODE_RANKER ( MBNET & model )
		: _model(model)
		{}
	virtual ~ MBNET_NODE_RANKER () {}

	virtual INT EType () const
		{ return EBNO_NODE_RANKER; }

	MBNET & Model ()					{ return _model;			}

	//  The ranking function
	virtual void operator () () = 0;

	//  Return the number of items ranked
	INT CRanked () const				{ return _vzsrNodes.size(); }
	//  Return the nodes in rank order
	const VZSREF VzsrefNodes () const	{ return _vzsrNodes;		}
	//  Return the computed values in rank order
	const VLREAL VlrValues () const		{ return _vlrValues;		}

  protected:
	MBNET & _model;				//  The model we're operating on
	VZSREF _vzsrNodes;			//  The names of the nodes in rank order
	VLREAL _vlrValues;			//  THe values associated with the ranking (if any)

  protected:
	void Clear ()
	{
		_vzsrNodes.clear();
		_vlrValues.resize(0);
	}

	HIDE_UNSAFE(MBNET_NODE_RANKER);
};

////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//	class MBNET:  a belief network
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
class MBNET : public MODEL
{
  public:
	MBNET ();
	virtual ~ MBNET ();

	//  Clone this belief network from another
	virtual void Clone ( MODEL & model );

	//  Accessor for map of distribution
	MPPD &	Mppd ()					{ return _mppd;			}
	//  Return true if an edge is allowed between these two nodes
	bool BAcyclicEdge ( GNODEMBN * pgndSource, GNODEMBN * pgndSink );
	//	Add a named object to the graph and symbol table
	virtual void AddElem ( SZC szcName, GOBJMBN * pgobj );
	//  Delete named objects
	virtual void DeleteElem ( GOBJMBN * pgelem );
	void AddElem ( GOBJMBN * pgobjUnnamed )
		{ MODEL::AddElem( pgobjUnnamed ); }

	void AddElem ( GEDGEMBN * pgedge )
		{ MODEL::AddElem( pgedge ); }

	//  Topology and distribution management
		//  Add arcs conforming to the defined distributions
	virtual void CreateTopology ();	
		//  Destroy arcs.
	virtual void DestroyTopology ( bool bDirectedOnly = true ) ;
		//  Connect distribution information in MPPD to nodes
	virtual void BindDistributions ( bool bBind = true );
	void ClearDistributions ()
		{ BindDistributions( false ); }

	//  Write debugging info out
	virtual void Dump ();

	//  Network walking/marking helpers
	void ClearNodeMarks ();
	void TopSortNodes ();

	//  Index-to-name mapping functions
		//  Find the named object by index
	GOBJMBN * PgobjFindByIndex ( int inm );
		//  Return the index of a name
	int INameIndex ( ZSREF zsr );
		//	Return the index of an object's name
	int INameIndex ( const GOBJMBN * pgobj );
		//  Return the highest+1 name index
	int CNameMax () const					{ return _vzsrNames.size(); }

	//  Causal Independence expansion operations (automatic during inference)
	virtual void ExpandCI ();
	virtual void UnexpandCI ();

	//  Inference operations
		//  Return the most recently created inference engine
	GOBJMBN_INFER_ENGINE * PInferEngine ();
		//  Create an inference engine
	void CreateInferEngine ( REAL rEstimatedMaximumSize = 10e6 );
		//  Destroy an inference engine
	void DestroyInferEngine ();

  protected:	
	MPPD	 _mppd;							//  Declared probability distributions
	VZSREF   _vzsrNames;					//	Array associating indicies to names
	int		 _inmFree;						//  First free entry in _vsrNodes
	INT		 _iInferEngID;					//  Next inference engine identifier
	VPMBNET_MODIFIER _vpModifiers;			//  The stack of active modifiers

  protected:
	int		CreateNameIndex ( const GOBJMBN * pgobj );
	void	DeleteNameIndex ( const GOBJMBN * pgobj );
	void	DeleteNameIndex ( int inm );

	void PopModifierStack ( bool bAll = false );
	void PushModifierStack ( MBNET_MODIFIER * pmodf );
	MBNET_MODIFIER * PModifierStackTop ();
	void VerifyTopology ();

	HIDE_UNSAFE(MBNET);
};


////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//	class MBNETDSC:
//		Subclass of MBNET that knows how to load and save DSC from
//		the DSC file format.
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
class MBNETDSC : public MBNET
{
  public:
	MBNETDSC ();
	virtual ~ MBNETDSC ();

	//  Parse the network from a DSC file
	virtual bool BParse ( SZC szcFn, FILE * pfErr = NULL );

	//  Print the network in DSC format
	virtual void Print ( FILE * pf = NULL );

	//  Token translation
		//  Map a string to a token
	static TOKEN TokenFind ( SZC szc );
		//  Map a distribution type to a token
	static SZC SzcDist ( BNDIST::EDIST edist );
		//  Map a token to a string
	static SZC SzcTokenMap ( TOKEN tkn );

  protected:
	//  DSC file printing functions
	FILE * _pfDsc;				//  Output print destination

  protected:
	void PrintHeaderBlock();
	void PrintPropertyDeclarations();
	void PrintNodes();
	void PrintDomains();
	void PrintTopologyAndDistributions();
	void PrintDistribution ( GNODEMBN & gnode, BNDIST & bndist );
	void PrintPropertyList ( LTBNPROP & ltprop );

	HIDE_UNSAFE(MBNETDSC);
};

class BNWALKER : public GRPHWALKER<GNODEMBN>
{
  protected:
	bool BSelect ( GNODEMBN * pgn );
	bool BMark ( GNODEMBN * pgn );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\gndleak.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       gndleak.cpp
//
//--------------------------------------------------------------------------

//
//	Leak checking variables for common classes
//

#include <basetsd.h>
#include "basics.h"
#include "gmobj.h"

LEAK_VAR_DEF(GNODE)
LEAK_VAR_DEF(GEDGE)

void GLNKEL :: ThrowInvalidClone ( const GLNKEL & t )
{
	SZC szcTypeName = typeid(t).name();
	ZSTR zsMsg;
	zsMsg.Format("objects of type \'%s\' do not support cloning", szcTypeName);
	THROW_ASSERT( EC_INVALID_CLONE, zsMsg.Szc() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\gmprop.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       gmprop.h
//
//--------------------------------------------------------------------------

//
//	gmprop.h: Graphical model property and property type declarations
//

#ifndef _GMPROP_H_
#define	_GMPROP_H_

/*
	A word about DYNAMICALLY EXTENSIBLE OBJECTS and their usage.

	These graphical model object classes are designed to require only very occasional
	addition of new variables.   Most add-on algorithms and functionality do, of course,
	require new variables, but there are several ways of meeting that need.

		1) The standard C++ method of subclassing.   This is a reasonable approach for
		some objects, but typically not for nodes in a belief network.  Cascaded types
		nodes render header files unreadable and cause severe memory bloat.  Also, most 
		variables apply to a phase of processing or only certain nodes.  These cases
		are better handled by the subsequence approaches.

		2) Dynamic property lists.  Every node in a belief network, as well as the network 
		itself, has a property list.  New GOBJPROPTYPEs can be easily created, then new PROPMBNs
		can be added to the appropriate nodes.

		3) Dynamic bit flags.  Every node and the network has a VFLAG vector, and member functions
		of the MPSYMTBL symbol table support conversion of names to indicies.

		4) New edge types.  An "edge" is a real C++ object, and the need for seriously complex
		and versatile data types can be met by creating a new edge type which connects
		pairs of other data structures.  Edges can even be created which connect a node
		to itself, thus creating an "add-on" data structure.

 */
#include <list>

#include "basics.h"
#include "symtmbn.h"
#include "enumstd.h"


class MODEL;
class MBNET;

////////////////////////////////////////////////////////////////////
//	class GOBJPROPTYPE:
//		A named property type descriptor living in a belief network.
//		The word "choice" connotes an enumerated value (i.e., and 
//		an integer property where each value from zero on is named).
////////////////////////////////////////////////////////////////////
class GOBJPROPTYPE : public GOBJMBN
{
	friend class DSCPARSER;		//  So the parser can create them
	friend class BNREG;			//  So they can be loaded from the Registry

  public:
	GOBJPROPTYPE () {}
	virtual ~ GOBJPROPTYPE() {}

	//  Return object type
	virtual INT EType () const
		{ return EBNO_PROP_TYPE ; }

	virtual GOBJMBN * CloneNew ( MODEL & modelSelf, 
								 MODEL & modelNew,
								 GOBJMBN * pgobjNew = NULL );
	//  Return property type descriptor
	UINT FPropType() const
		{ return _fType; }
	//  Return the list of enumerated choices
	const VZSREF VzsrChoice() const
		{ return _vzsrChoice; }
	const ZSREF ZsrComment () const
		{ return _zsrComment; }

  protected:
	UINT _fType;			//	Property type flags
	VZSREF _vzsrChoice;		//	Array of choice names
	ZSREF _zsrComment;		//  Comment

	HIDE_UNSAFE(GOBJPROPTYPE);
};

////////////////////////////////////////////////////////////////////
//	class PROPMBN:
//		A property item definition living in a GNODEMBN
////////////////////////////////////////////////////////////////////
class PROPMBN
{
	friend class LTBNPROP;  // for cloning 

  public:
	PROPMBN ();
	PROPMBN ( const PROPMBN & bnp );
	PROPMBN & operator = ( const PROPMBN & bnp );
	// declare standard operators ==, !=, <, >
	DECLARE_ORDERING_OPERATORS(PROPMBN);

	bool operator == ( ZSREF zsrProp ) const;
	bool operator == ( SZC szcProp ) const;

	void Init ( GOBJPROPTYPE & bnpt );
	UINT Count () const;
	UINT FPropType () const
		{ return _fType; }
	ZSREF ZsrPropType () const
		{ return _zsrPropType; }
	ZSREF Zsr ( UINT i = 0 ) const;
	REAL Real ( UINT i = 0 ) const;
	void Reset ();
	void Set ( ZSREF zsr );
	void Set ( REAL r );
	void Add ( ZSREF zsr );
	void Add ( REAL r );

  protected:	
	UINT _fType;				//	Property type flags
	ZSREF _zsrPropType;			//	Property name
	VZSREF _vzsrStrings;		//  Array of strings
	VREAL _vrValues;			//  Array of reals (or integers or choices)
};

////////////////////////////////////////////////////////////////////
//	class LTBNPROP:
//		A list of properties
////////////////////////////////////////////////////////////////////
class LTBNPROP : public list<PROPMBN> 
{
  public:
	//  Find an element
	PROPMBN * PFind ( ZSREF zsrProp );
	const PROPMBN * PFind ( ZSREF zsrProp ) const;
	//  Update or add and element; return true if element was already present
	bool Update ( const PROPMBN & bnp );
	//  Force the list to contain only unique elements
	bool Uniqify ();
	//  Clone from another list with another symbol table
	void Clone ( MODEL & model, const MODEL & modelOther, const LTBNPROP & ltbnOther );
};


////////////////////////////////////////////////////////////////////
//	class PROPMGR:
//		Facilitates translation between user declarations of standard
//		properties and internal usage.
//
//	N.B.:  Remember that all ZSREFs are symbiotic to the MODEL of
//			origin and are therefore useless in other networks.
////////////////////////////////////////////////////////////////////
class MODEL;				//  A belief network
class GNODEMBN;				//	A node in a belief network

class PROPMGR
{
  public:
	PROPMGR ( MODEL & model );
	//  Return a pointer to the requested standard property type
	GOBJPROPTYPE * PPropType ( ESTDPROP evp );
	//  Return the name of the standard property
	ZSREF ZsrPropType ( ESTDPROP evp );
	//	Return the user-defined value of the standard label or -1 if not defined
	int ILblToUser ( ESTDLBL elbl )
	{ 
		ASSERT_THROW( elbl < ESTDLBL_max, EC_INTERNAL_ERROR, "invalid standard label index" );
		return _vLblToUser[elbl]; 
	}
	//  Return the standard label for the user-defined label value or -1
	int IUserToLbl ( int iLbl )
	{		
		return iLbl >= 0 && iLbl < _vUserToLbl.size() 
			 ? _vUserToLbl[iLbl] 
			 : -1 ;
	}
	//  Find a standard property in a property list
	PROPMBN * PFind ( LTBNPROP & ltprop, ESTDPROP estd );
	//  Find a standard property in a node's property list
	PROPMBN * PFind ( GNODEMBN & gnd, ESTDPROP estd );
	//  Find a standard property in the associated model's property list
	PROPMBN * PFind ( ESTDPROP estd );
	//  Return a displayable name for a standard label
	static SZC SzcLbl ( int iLbl );

  protected:
	//  The model we're referring to
	MODEL & _model;
	//  Pointers to property types for currently used VOI types
	GOBJPROPTYPE * _vPropMap [ ESTDP_max ];
	//  Map from predefined label index to user label index 
	int _vLblToUser [ ESTDLBL_max ];
	//  Map from user label index to predefined label index 
	VINT _vUserToLbl;
	//  Array of ZSREFs as recorded in the network used during construction
	VZSREF _vzsrPropType;

	HIDE_UNSAFE(PROPMGR);
};


#endif	// _GMPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\leakchk.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       leakchk.h
//
//--------------------------------------------------------------------------

//
//	leakchk.h:  simple macros to aid in checking for memory leaks in base classes
//
#ifndef _LEAKCHK_H_
#define _LEAKCHK_H_

#ifdef _DEBUG
	#define LEAK_VAR_DECL			static int _cNew;
	#define LEAK_VAR_UPD(i)				{ _cNew += i; }
	#define LEAK_VAR_DEF(CLS)		int CLS::_cNew = 0;
	#define LEAK_VAR_ACCESSOR		static int CNew () { return _cNew; }
#else 
	#define LEAK_VAR_DECL
	#define LEAK_VAR_UPD(i)
	#define LEAK_VAR_DEF(CLS)
	#define LEAK_VAR_ACCESSOR		static int CNew () { return -1; }
#endif

#endif // _LEAKCHK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\gnodembn.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       gnodembn.cpp
//
//--------------------------------------------------------------------------

//
//	GNODEMBN.CPP
//

#include <basetsd.h>
#include <typeinfo.h>

#include "gmobj.h"
#include "cliqset.h"
#include "clique.h"
#include "algos.h"
#include "domain.h"

/*****************************************************************************************
	Cloning and cloning functions.

		There are two types of cloning member functions:

				1) functions named "Clone", in which the new object is being
				asked to initialize itself from another existing object.
				This is not a copy constructor due to the complexity of timing
				chained construcions.

				2) functions named "CloneNew", in which an existing object is being
				asked to participate in the construction of a new object.

		Functions of type #1 are straightforward, such as

				virtual void MODEL :: Clone ( MODEL & model );

		Here, a MODEL is being asked to clone or copy information from an existing
		network into itself.  The object can place whatever restrictions it would like
		on such functions.  For example, the MODEL class requires that the new MODEL
		object be entirely empty.

		Functions of type #2 are more complex, such as

				virtual GOBJMBN * GOBJMBN :: CloneNew ( MBNET & mbnetSelf,
														MBNET & mbnetNew,
														GOBJMBN * pgobjNew = NULL );

		In this case, there are references to the original and clone networks (MBNETs),
		and a pointer to the newly constructed object, which may be NULL.  Consider a
		chain of inheritance such as:
					
				class OBJ;
				class SUB_OBJ : public OBJ;
				class SUB_SUB_OBJ : public SUB_OBJ;

		If a new SUB_SUB_OBJ is to be cloned from an existing one, an empty object must
		be constructed first. Then the CloneNew() function the original SUB_SUB_OBJ is
		called.  At this point, there's a choice: does the SUB_SUB_OBJ perform all the
		initialization for all base classes, or should it defer data member cloning
		to its base classes?  We use the latter approach, as C++ itself does for
		construction and destruction.

		So, at the top level of object cloning, the initial invocation of CloneNew() will
		usually have a NULL object pointer.  Each CloneNew() function must check for this,
		and either create a new object, if allowed, or throw an exception.   It will
		then call the CloneNew() function for its immediate ancestral base class using the
		new pointer.   The ancestral CloneNew() function will see that there already is a
		pointer and simply use it.
		
		In other words, the Clone() member functions are simple "build yourself from
		another" commands.  The CloneNew() functions collaborate with all ancestral base
		classes to correctly construct an object with interdependencies.  Note that
		the semantics (source vs. target) are reversed.

		The bulk of the complexity in cloning an MBNET or MODEL (or subclass) arises from
		the internal string symbol table and the storage of references to strings throughout
		the set of associated objects.
				
 *****************************************************************************************/

// MSRDEVBUG:  This should not be required since it's pure virtual, but VC++ 5.0 gets confused.
GOBJMBN :: ~ GOBJMBN ()
{
}

GOBJMBN * GOBJMBN :: CloneNew (
	MODEL & modelSelf,
	MODEL & modelNew,
	GOBJMBN * pgobjNew )
{
	// If we're expected to create the object, that's a no-no; throw an exception
	if ( pgobjNew == NULL )
	{
		ThrowInvalidClone( self );
	}

	//  Update class-specific member variables
	pgobjNew->IMark() = IMark();
	pgobjNew->IType() = IType();

	//  Convert and assign the name, if any
	if ( ZsrefName()->length() > 0 )
	{
		pgobjNew->SetName( modelNew.Mpsymtbl().intern( ZsrefName().Szc() ) ) ;
	}
	//  Handle other variables
	pgobjNew->_vFlags = _vFlags;
	return pgobjNew;
}

GNODEMBN :: GNODEMBN()
	:_iTopLevel(-1)
{
	IType() = 0;
}

GNODEMBN :: ~ GNODEMBN()
{
}

GOBJMBN * GNODEMBN :: CloneNew (	
	MODEL & modelSelf,
	MODEL & modelNew,
	GOBJMBN * pgobjNew )

{
	GNODEMBN * pgnd = NULL;
	if ( pgobjNew == NULL )
	{
		pgnd = new GNODEMBN;
	}
	else
	{
		DynCastThrow( pgobjNew, pgnd );
	}
	ASSERT_THROW( GOBJMBN::CloneNew( modelSelf, modelNew, pgnd ),
				  EC_INTERNAL_ERROR,
				  "cloning failed to returned object pointer" );

	//  Update class-specific member variables
	pgnd->_iTopLevel = _iTopLevel;
	pgnd->_ltProp.Clone( modelNew, modelSelf, _ltProp );
	pgnd->_ptPos = _ptPos;
	pgnd->_zsFullName = _zsFullName;
	pgnd->_clampIface = _clampIface;

	return pgnd;
}

GOBJMBN * GNODEMBND :: CloneNew (
	MODEL & modelSelf,
	MODEL & modelNew,
	GOBJMBN * pgobjNew )
{
	GNODEMBND * pgndd = NULL;
	if ( pgobjNew == NULL )
	{
		pgndd = new GNODEMBND;
	}
	else
	{
		DynCastThrow( pgobjNew, pgndd );
	}
	
	ASSERT_THROW( GNODEMBN::CloneNew( modelSelf, modelNew, pgndd ),
				  EC_INTERNAL_ERROR,
				  "cloning failed to returned object pointer" );

	//  Update class-specific member variables
	modelNew.Mpsymtbl().CloneVzsref( modelSelf.Mpsymtbl(), _vzsrState, pgndd->_vzsrState );
	return pgndd;
}

void GNODEMBN :: Visit ( bool bUpwards /* = true */ )
{
	if ( IMark() )
		return;

	INT iMarkMax = 0;
	GNODENUM<GNODEMBN> benum( bUpwards );
	benum.SetETypeFollow( GEDGEMBN::ETPROB );

	for ( benum.Set( this );
		  benum.PnodeCurrent();
		  benum++ )
	{
		GNODEMBN * pgndbn = *benum;
		pgndbn->Visit( bUpwards );
		if ( pgndbn->IMark() > iMarkMax )
			iMarkMax = pgndbn->IMark();
	}
	IMark() = iMarkMax + 1;
}

//
//  Fill array with parent pointers	(follow directed arcs)
//
//	About network "expansion".  When CI expansion occurs, nodes
//	affected are marked with the flag "EIBF_Expanded".  This routine
//	normally does one of two things:
//
//		If the node is expanded, only parents marked as "EIBF_Expansion"
//		are considered as real parents.
//
//		If the node is not marked, only parents which are not marked as
//		"expansion" are considered.
//
//  This can be overridden with the "bUseExpansion" flag, in which case
//	the original (pre-expansion) parents will be delivered.
//
void GNODEMBN :: GetParents (
	VPGNODEMBN & vpgnode,		//  Result array
	bool bIncludeSelf,			//  If true, place self as last entry in list
	bool bUseExpansion )		//  If true, consider expansion information
{
	//  If requested, and if this node is part of network expansion, only
	//	consider expansion parents.  Otherwise, ignore them and only use real
	//	parents.
	bool bOnlyUseExpansionParents =
			bUseExpansion && BFlag( EIBF_Expanded ) ;

	//  Prepare to iterate over the parents
	GNODENUM<GNODEMBN> benumparent(true);
	benumparent.SetETypeFollow( GEDGEMBN::ETPROB );
	for ( benumparent.Set( this );
		  benumparent.PnodeCurrent();
		  benumparent++ )
	{
		GNODEMBN * pgndParent = *benumparent;
		bool bExpansion = pgndParent->BFlag( EIBF_Expansion );
		if ( bOnlyUseExpansionParents ^ bExpansion )
			continue;
		vpgnode.push_back( pgndParent );
	}
	if ( bIncludeSelf )
		vpgnode.push_back( this );
}

//  Return the discrete dimension vector of this node if possible;
//	return false if any parent is not discrete.
bool GNODEMBND :: BGetVimd (
	VIMD & vimd,					//  Array to fill
	bool bIncludeSelf,				//  Place self as last entry in list
	bool bUseExpansion )			//  If expanded, use expansion only

{
	//  Get the parents according to the flags
	VPGNODEMBN vpgndParents;
	GetParents( vpgndParents, bIncludeSelf, bUseExpansion );
	//  Prepare the result array
	vimd.resize( vpgndParents.size() );
	for ( int i = 0; i < vimd.size(); i++ )
	{
		//  See if the next node is discrete; return false if not
		GNODEMBND * pgnddParent = dynamic_cast<GNODEMBND *> (vpgndParents[i]);
		if ( pgnddParent == NULL )
			return false;
		//  Add to the dimension array
		assert( pgnddParent->IType() & FND_Discrete );
		vimd[i] = pgnddParent->CState();
	}	
	return true;
}

//  Fill array with child pointers (follow directed arcs)
void GNODEMBN :: GetChildren ( VPGNODEMBN & vpgnode, bool bIncludeSelf )
{
	//  Prepare to iterate over the children
	GNODENUM<GNODEMBN> benumchild(false);
	benumchild.SetETypeFollow( GEDGEMBN::ETPROB );
	for ( benumchild.Set( this );
		  benumchild.PnodeCurrent();
		  benumchild++ )
	{
		vpgnode.push_back( *benumchild );
	}
	if ( bIncludeSelf )
		vpgnode.push_back( this );
}

//  Fill array with neighbors (follow undirected arcs)
void GNODEMBN :: GetNeighbors ( VPGNODEMBN & vpgnode, bool bIncludeSelf )
{
	//  Iterate over all connections to the source node.
	//	That is, arcs in either direction.
	GNODENUM_UNDIR gnenumUndir;
	//  Initialize the iterator	
	for ( gnenumUndir = this;
		  gnenumUndir.PnodeCurrent();
		  gnenumUndir++ )
	{
		vpgnode.push_back( *gnenumUndir );
	}
	if ( bIncludeSelf )
		vpgnode.push_back( this );
}

int GNODEMBN :: IParent ( GNODEMBN * pgndmb, bool bReverse )
{
	//  Prepare to iterate over the parents
	GNODENUM<GNODEMBN> benumparent( true, ! bReverse );
	benumparent.SetETypeFollow( GEDGEMBN::ETPROB );
	int iParent = 0;
	for ( benumparent.Set(this);
		  benumparent.PnodeCurrent();
		  benumparent++, iParent++ )
	{
		if ( *benumparent == pgndmb )
			return iParent;
	}
	return -1;
}

int GNODEMBN :: IChild ( GNODEMBN * pgndmb, bool bReverse )
{
	//  Prepare to iterate over the children
	GNODENUM<GNODEMBN> benumchild( false, ! bReverse );
	benumchild.SetETypeFollow( GEDGEMBN::ETPROB );
	int iChild = 0;
	for ( benumchild.Set(this);
		  benumchild.PnodeCurrent();
		  benumchild++ )
	{
		if ( *benumchild == pgndmb )
			return iChild;
	}
	return -1;
}

bool GNODEMBN :: BIsNeighbor ( GNODEMBN * pgndmb )
{
	GNODENUM_UNDIR gnenumUndir;
	for ( gnenumUndir = this;
		  gnenumUndir.PnodeCurrent();
		  gnenumUndir++ )
	{
		if ( *gnenumUndir == pgndmb )
			return true;
	}
	return false;
}

void GNODEMBN :: GetVtknpd ( VTKNPD & vtknpd, bool bUseExpansion )
{
	VPGNODEMBN vpgnodeParent;
	GetParents(vpgnodeParent, false, bUseExpansion);

	vtknpd.clear();
	vtknpd.push_back( TKNPD(DTKN_PD) );
	vtknpd.push_back( TKNPD( ZsrefName() ) );

	for ( int ip = 0; ip < vpgnodeParent.size(); ip++ )
	{
		if ( ip > 0 )			
			vtknpd.push_back( TKNPD(DTKN_AND) );
		else
			vtknpd.push_back( TKNPD(DTKN_COND) );
		vtknpd.push_back( TKNPD(vpgnodeParent[ip]->ZsrefName()) );	
	}
}

bool GNODEMBN :: BMatchTopology (
	MBNET & mbnet,
	const VTKNPD & vtknpd,
	VPGNODEMBN * pvpgnode )
{
	// Guarantee that the descriptor is of the form "p(X|...)"
	if (   vtknpd.size() < 2
		|| vtknpd[0] != TKNPD(DTKN_PD)
		|| ! vtknpd[1].BStr() )
		throw GMException( EC_INV_PD, "invalid token description on PD");

	VTKNPD vtknpdSelf;
	GetVtknpd( vtknpdSelf );

	if ( vtknpdSelf == vtknpd )
		return true;

#ifdef _DEBUG
	{
		ZSTR zs1 = vtknpd.ZstrSignature(0);
		ZSTR zs2 = vtknpdSelf.ZstrSignature(0);
		cout << "\nGNODEMBN::BMatchTopology mismatch: "
			 << "\n\tExpected "
			 << zs1
			 << "\n\tComputed "
			 << zs2
			 ;
	}
#endif
	return false;
}

void GNODEMBN :: Dump ()
{
	cout << "\t(toplev: "
		 << ITopLevel()
		 << "): "
		 << ZsrefName().Szc();

	int iParent = 0;
	GNODENUM<GNODEMBN> benumparent(true);
	benumparent.SetETypeFollow( GEDGEMBN::ETPROB );

	for ( benumparent.Set(this);
		  benumparent.PnodeCurrent();
		  benumparent++ )
	{
		GNODEMBN * pgndbnParent = *benumparent;
		if ( iParent++ == 0 )
			cout << ", parents: ";
		cout << pgndbnParent->ZsrefName().Szc()
			 << ',';
	}
}


GNODEMBND :: GNODEMBND ()
{
	IType() = FND_Valid | FND_Discrete ;
}

GNODEMBND :: ~ GNODEMBND ()
{
	ClearDist();
}

void GNODEMBND :: Dump ()
{
	GNODEMBN::Dump();
	if ( BHasDist() && Bndist().Edist() != BNDIST::ED_NONE )
	{
		cout << "\n\tprobability distribution of "
		     << ZsrefName().Szc()
			 << ": ";
		Bndist().Dump();
	}
}

//	Find the distribution for this node recorded in the belief network's
//		distribution map.
void GNODEMBND :: SetDist ( MBNET & mbnet )
{
	ClearDist();
	//  Construct the token array describing the distribution
	VTKNPD vtknpd;
	GetVtknpd( vtknpd );
	//  Locate that distribution in the belief network's map
	MPPD::iterator itmppd = mbnet.Mppd().find( vtknpd );
	ASSERT_THROW( itmppd != mbnet.Mppd().end(),
				  EC_INTERNAL_ERROR,
				  "missing distribution for node" );
	//  Set this node to use that distribution
	_refbndist = (*itmppd).second;
	assert( BHasDist() );
}

//  Bind the given distribution this node
void GNODEMBND :: SetDist ( BNDIST * pbndist )
{
#ifdef _DEBUG	
	if ( pbndist )
	{
		//  Check that the last dimension is the correct size.		
		int cDims = pbndist->VimdDim().size();
		assert( pbndist->VimdDim()[cDims-1] == CState() );
	}
#endif	
	_refbndist = pbndist;
}

//  Check that the dimensionality of the distribution matches that of
//	  the node itself according to the dag topology.
bool GNODEMBND :: BCheckDistDense ()
{
	//  Get the array of parents
	VPGNODEMBN vpgndParents;
	GetParents( vpgndParents );
	VIMD vimd( vpgndParents.size() + 1 );
	for ( int idim = 0; idim < vimd.size() - 1; idim++ )
	{
		GNODEMBND * pgndd;
		assert( vpgndParents[idim] );
		DynCastThrow( vpgndParents[idim], pgndd );
		vimd[idim] = pgndd->CState();
	}
	vimd[idim] = CState();
	MDVCPD & mdv = Bndist().Mdvcpd();
	return mdv.VimdDim() == vimd;
}

void GNODEMBND :: SetDomain ( const GOBJMBN_DOMAIN & gobjrdom )
{
	//  Copy the state names from the domain to the variable
	const RDOMAIN & rdom = gobjrdom.Domain();
	RDOMAIN::const_iterator itdm = rdom.begin();
	_vzsrState.resize( rdom.size() );
	for ( int i = 0; itdm != rdom.end(); itdm++ )
	{
		const RANGEDEF & rdef = *itdm;
		_vzsrState[i++] = rdef.ZsrName();
	}
	_zsrDomain = gobjrdom.ZsrefName();
}

//
//	Usage of this function without a new object implies that the
//	subclassed target object does not correctly support "CloneNew".
//	Throw a cloning exception in this case.
//
GEDGEMBN * GEDGEMBN :: CloneNew (
	MODEL & modelSelf,
	MODEL & modelNew,
	GOBJMBN * pgobjmbnSource,
	GOBJMBN * pgobjmbnSink,
	GEDGEMBN * pgedgeNew )
{
	if ( pgedgeNew == NULL )
	{
		ThrowInvalidClone( self );
	}
	pgedgeNew->_vFlags = _vFlags;
	return pgedgeNew;
}


GEDGEMBN * GEDGEMBN_PROB :: CloneNew (
	MODEL & modelSelf,
	MODEL & modelNew,
	GOBJMBN * pgobjmbnSource,
	GOBJMBN * pgobjmbnSink,
	GEDGEMBN * pgdegeNew  )
{
	assert( EType() == ETPROB );
	GNODEMBN * pgndSource;
	GNODEMBN * pgndSink;

	DynCastThrow( pgobjmbnSource, pgndSource );
	DynCastThrow( pgobjmbnSink,	  pgndSink );

	GEDGEMBN_PROB * pgedge = new GEDGEMBN_PROB( pgndSource, pgndSink );
	ASSERT_THROW( GEDGEMBN::CloneNew( modelSelf, modelNew, pgndSource, pgndSink, pgedge ),
				  EC_INTERNAL_ERROR,
				  "cloning failed to returned object pointer" );
	return pgedge;
}

bool BNWALKER :: BSelect ( GNODEMBN * pgn )
{
	return true;
}

bool BNWALKER :: BMark ( GNODEMBN * pgn )
{
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\infer.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       infer.h
//
//--------------------------------------------------------------------------

//
//	infer.h: inference engine declarations
//

#ifndef _INFER_H_
#define _INFER_H_

#include "gmobj.h"

////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//
//	GOBJMBN_INFER_ENGINE:  A generic superclass for inference engines
//		operating against a belief network.
//
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
class GOBJMBN_INFER_ENGINE: public MBNET_MODIFIER
{
  public:
	GOBJMBN_INFER_ENGINE ( 
		MBNET & model,						//  The model over which to infer
		REAL rEstimatedMaximumSize = -1.0,	//  Max size estimate; < 0 indicates "don't care"
		int iInferEngID = 0 )				//  Inference engine identifier
		: MBNET_MODIFIER(model),
		_iInferEngID( iInferEngID ),
		_rEstMaxSize(rEstimatedMaximumSize)
		{}

	virtual ~ GOBJMBN_INFER_ENGINE () {}
	
	virtual INT EType () const
		{ return EBNO_INFER_ENGINE; }

	//  Perform any creation-time operations
	virtual void Create () = 0;
	//  Perform any special destruction
	virtual void Destroy () = 0;
	//  Reload or reinitialize as necessary
	virtual void Reload () = 0;
	//  Accept evidence on a node
	virtual void EnterEvidence ( GNODEMBN * pgnd, const CLAMP & clamp ) = 0;
	//	Return stored evidence against a node
	virtual void GetEvidence ( GNODEMBN * pgnd, CLAMP & clamp ) = 0;
	//	Perform full inference
	virtual void Infer () = 0;
	//	Return the vector of beliefs for a node
	virtual void GetBelief ( GNODEMBN * pgnd, MDVCPD & mdvBel ) = 0;
	virtual void Dump () = 0;

	INT IInferEngId () const			{ return _iInferEngID;	}

  protected:	
	INT _iInferEngID;					//  This junction tree's identifier
	REAL _rEstMaxSize;					//	Maximum size estimate
};

#endif  // _INFER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\gnodera.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       gnodera.cxx
//
//--------------------------------------------------------------------------

#include "gnodera.hxx"

GNODERA::GNODERA()
{

}

GNODERA::~GNODERA()
{
	_vpnodeChild.erase(_vpnodeChild.begin(), _vpnodeChild.end());
	_vpnodeParent.erase(_vpnodeParent.begin(), _vpnodeParent.end());
}

// Override on most GNODE virtual accessors
// should throw an exception... for now, random
// access nodes do not handle linear access calls.
//
// To save some typing, I've defined the following
// macro to throw the appropriate exception for all
// of the calls.

#define THROW_RA_EXCEPTION() \
	throw GMException(EC_NYI, "Linear access accessor called on random access graph")



GEDGE*&	GNODERA::PedgeSource()
{
	THROW_RA_EXCEPTION();

	return _glkArcs.PlnkSource();
}

GEDGE*&	GNODERA::PedgeSink()
{
	THROW_RA_EXCEPTION();

	return _glkArcs.PlnkSink();
}

GEDGE*	GNODERA::PedgeSource() const
{
	THROW_RA_EXCEPTION();

	return _glkArcs.PlnkSource();
}

GEDGE*	GNODERA::PedgeSink() const
{
	THROW_RA_EXCEPTION();

	return _glkArcs.PlnkSink();
}

GEDGE*	GNODERA::PedgeOrdering(GEDGE* pgedge, BOOL bSource)
{
	THROW_RA_EXCEPTION();

	return pgedge;
}

VOID	GNODERA::ArcDeath(GEDGE* pgedge, BOOL bSource)
{
	THROW_RA_EXCEPTION();
}

UINT	GNODERA::CSourceArc() const
{
	THROW_RA_EXCEPTION();
	
	return 0;
}

UINT	GNODERA::CSinkArc() const
{
	THROW_RA_EXCEPTION();

	return 0;
}


UINT	GNODERA::CnodeChild()
{
	return _vpnodeChild.size();
}

UINT	GNODERA::CnodeParent()
{
	return _vpnodeParent.size();
}

VOID	GNODERA::InsertChild(GNODE* pnodeChild)
{
	_vpnodeChild.push_back(pnodeChild);
}

VOID	GNODERA::InsertParent(GNODE* pnodeParent)
{
	_vpnodeParent.push_back(pnodeParent);
}

VOID	GNODERA::InsertChild(UINT inodeChild, GNODE* pnodeChild)
{
	assert(inodeChild <= _vpnodeChild.size());

	_vpnodeChild.insert(&_vpnodeChild[inodeChild], pnodeChild);
}

VOID	GNODERA::InsertParent(UINT inodeParent, GNODE* pnodeParent)
{
	assert(inodeParent <= _vpnodeParent.size());

	_vpnodeParent.insert(&_vpnodeParent[inodeParent]);
}

VOID	GNODERA::DeleteChild(UINT inodeChild)
{

	assert(inodeChild < _vpnodeChild.size());

	_vpnodeChild.erase(&_vpnodeChild[inodeChild]);
}

VOID	GNODERA::DeleteParent(UINT inodeParent)
{
	assert(inodeParent < _vpnodeParent.size());

	_vpnodeParent.erase(&_vpnodeParent[inodeParent]);
}

BOOL	GNODERA::BParent(GNODE* pnode)
{
/*	for (UINT inodeParent = 0; inodeParent < CnodeParent(); inodeParent++)
	{
		if (PnodeParent(inodeParent) == pnode)
			return true;
	}

	return false;*/

	if (InodeParent(pnode) == (UINT) -1)
		return false;
	else
		return true;

}

UINT	GNODERA::InodeParent(GNODE* pnode)
{
	for (UINT inodeParent = 0; inodeParent < CnodeParent(); inodeParent++)
	{
		if (PnodeParent(inodeParent) == pnode)
			return inodeParent;
	}

	return (UINT) -1;
}


BOOL	GNODERA::BChild(GNODE* pnode)
{
	/*for (UINT inodeChild = 0; inodeChild < CnodeChild(); inodeChild++)
	{
		if (PnodeChild(inodeChild) == pnode)
			return true;
	}

	return false;*/

	if (InodeChild(pnode) == (UINT) -1)
		return false;
	else
		return true;

}

UINT	GNODERA::InodeChild(GNODE* pnode)
{
	for (UINT inodeChild = 0; inodeChild < CnodeChild(); inodeChild++)
	{
		if (PnodeChild(inodeChild) == pnode)
			return inodeChild;
	}

	return (UINT) -1;
}


GNODE*	GNODERA::PnodeParent(UINT inodeParent)
{
	assert(inodeParent < _vpnodeParent.size());

	return _vpnodeParent[inodeParent];
}

GNODERA*	GNODERA::PnoderaParent(UINT inodeParent)
{
	return (GNODERA*) PnodeParent(inodeParent);
}

GNODE*	GNODERA::PnodeChild(UINT inodeChild)
{
	assert(inodeChild < _vpnodeChild.size());

	return _vpnodeChild[inodeChild];
}

GNODERA*	GNODERA::PnoderaChild(UINT inodeChild)
{
	return (GNODERA*) PnodeChild(inodeChild);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\marginals.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       marginals.cpp
//
//--------------------------------------------------------------------------

//
//	marginals.cpp: Definitions for marginals tables
//

#include <basetsd.h>
#include <math.h>

#include "gmobj.h"
#include "marginals.h"
#include "algos.h"
#include "parmio.h"
#include "bndist.h"

/*
	The marginalization story.   Each MARGINALS structure maintains an array of node
	pointers representing the nodes whose discrete probabilities it covers.  Since there
	was a total ordering over all nodes at clique time, any two node sets can be merged
	to determine which members are absent.  Given, of course, that one table is a (possibly
	improper) subset of the other, which is always in a clique tree.  There are three cases:

			*	A node and its "parent" or "family" clique (the smallest clique containing it
				and all its parents); the clique must be at least as large as the node's family.

			*	A sepset and its source (parent) clique; the sepset marginal must be a proper
				subset of the clique.

			*   A sepset and its sink (child) clique; same as the other sepset case above.

	So we always know which of the two sets is the superset.
	
	There's the question of node ordering.  When the edge between a node and its "family"
	clique is created, a reordering table is computed based upon the clique-time total ordering.
	This table gives the family indicies in clique order.  (Note that the node itself will
	always be the last member of its family.)  Use of this table allows full marginalization
	of the family clique.

	(Hereafter, "CMARG" is the clique MARGINALS table; "NDPROB" is the table of probabilities
	for the node in question.)

	The CMARG has a complete set of dimensions and node pointers.
	Marginalization of a node given its parent clique works as follows.

			1)  Make a copy of CMARG's table of dimensions (Vimd()).
			2)  Create a one-dimensional MDVCPD based on the state space of the
				target node.
			3)  Walk the MARGINALS VPGNODEMBN array.  Change the sign of each entry
				which IS NOT the target node.  For example, if the array is:

					Node Pointer	VIMD
					0x4030ab30		3
					0x4030ab52		2
					0x4030ac10		4

				and the node pointer is 0x4030ab52 (entry #2), the resulting
				VIMD should be
					
					-3
					2
					-4
				
			4)	Then set up an MDVSLICE for the new MDVCPD which uses the
				special "pseudo-dimension" VIMD created in the last step.

			5)	Create two iterators: one for the MARGINALS table in its entirety,
				the other for the temporary MDVCPD and MDVSLICE create in the last step.

			6)  Iterate over the two, adding elements from the MARGINALS into
				the MDVCPD.

			7)  Normalize if necessary.

 */		

//////////////////////////////////////////////////////////////////////
//
//	Helper functions
//
//////////////////////////////////////////////////////////////////////

//  Reorder a single m-d vector subscript array. 'vimdReorder' is the
//  table in MARGINALS (topological) sequence of the original dimensions.	
inline
void MARGINALS :: ReorderVimd (
	const VIMD & vimdReorder,	//	Reordering array
	const VIMD & vimdIn,		//	Original subscript vector
	VIMD & vimdOut )			//	Result: must be properly sized already!
{
	int cDim = vimdReorder.size();
	assert( vimdIn.size() == cDim && vimdOut.size() == cDim );

	for	( int iDim = 0; iDim < cDim; iDim++ )
	{
		int iDimReord = vimdReorder[iDim];
		assert( iDimReord >= 0 && iDimReord < cDim );
		vimdOut[iDim] = vimdIn[iDimReord];
	}	
}

//  Reorder an array containing a node's family based upon the reordering
//		table given.
inline
void MARGINALS :: ReorderVimdNodes (
	const VIMD & vimdReorder,	//	Reordering array
	GNODEMBND * pgndd,			//  Discrete node to provide reorder for
	VPGNODEMBN & vpgnd )		//	Result
{
	VPGNODEMBN vpgndUnord;
	pgndd->GetFamily( vpgndUnord );
	int cDim = vimdReorder.size();
	assert( cDim == vpgndUnord.size() );
	vpgnd.resize( cDim );
	
	for	( int iDim = 0; iDim < cDim; iDim++ )
	{
		int iDimReord = vimdReorder[iDim];
		assert( iDimReord >= 0 && iDimReord < cDim );
		vpgnd[iDim] = vpgndUnord[iDimReord];
	}	
}

inline
static
int vimdProd ( const VIMD & vimd )
{
	int iprod = 1;
	for ( int i = 0; i < vimd.size() ; )
	{
		iprod *= vimd[i++];
	}
	return iprod;
}

inline
static
bool bIsProb ( const REAL & r )
{
	return r >= 0.0 && r <= 1.0;
}


//  Centralized "throw serious error" point
void MARGINALS :: ThrowMisuse ( SZC szcMsg )
{
	THROW_ASSERT( EC_MDVECT_MISUSE, szcMsg );
}

//  Return the table of pseudo-dimensions for marginalizing to a single node
VSIMD MARGINALS :: VsimdFromNode ( GNODEMBND * pgndd )
{
	//  Build the pseudo-dimension descriptor
	VIMD vimdMarg = VimdDim();
	VSIMD vsimdMarg( vimdMarg.size() );
	bool bFound = false;
	for ( int idim = 0; idim < vimdMarg.size(); idim++ )
	{
		SIMD simd = vimdMarg[idim];
		if ( pgndd != _vpgnd[idim] )
			simd = -simd;		// Negate the missing dimension
		else
		{
			assert( ! bFound );	// Better not be in the list twice!
			bFound = true;
		}
		vsimdMarg[idim] = simd;
	}
	if ( ! bFound )
		ThrowMisuse( "attempt to marginalize non-member node");
	return vsimdMarg;
}

//  Marginalize down to a single node
void MARGINALS :: Marginalize ( GNODEMBND * pgndd, MDVCPD & distd )
{
	//  Initialize and clear the UPD
	ResizeDistribution( pgndd, distd );	
	distd.Clear();

	//  Get the pseudo-dimension descriptor for this node
	VSIMD vsimdMarg = VsimdFromNode( pgndd );
	//  Construct the slice which governs the missing dimensions
	MDVSLICE mdvs( vsimdMarg );
	Iterator itSelf( self );
	Iterator itSubset( distd, mdvs );

	while ( itSelf.BNext() )
	{
		itSubset.Next() += itSelf.Next();
	}
	distd.Normalize();
}

VSIMD MARGINALS :: VsimdSubset ( const VPGNODEMBN & vpgndSubset )
{
	//  Build the pseudo-dimension descriptor.  This means to walk
	//  a copy of self's dimension array, negating dimensions which
	//  are not present in the result.
	VIMD vimdMarg = VimdDim();
	int idimSubset = 0;
	VSIMD vsimdMarg(vimdMarg.size());
	//  Iterate over each node in the self set
	for ( int idimSelf = 0;
		  idimSelf < vimdMarg.size();
		  idimSelf++ )
	{
		SIMD simd = vimdMarg[idimSelf];
		if (   idimSubset < vpgndSubset.size()
			&& _vpgnd[idimSelf] == vpgndSubset[idimSubset] )
		{
			//  Found; leave dimension alone
			idimSubset++;
		}
		else
		{
			//  Missing; mark as "pseudo-dimension"
			simd = - simd;
		}
		vsimdMarg[idimSelf] = simd;
	}

	if ( idimSubset != vpgndSubset.size() )
		ThrowMisuse( "attempt to marginalize non-member node");
	return vsimdMarg;
}

//	Marginalize down to a subset of our node set.  Note that the
//  the nodes must be in the same order (with gaps, of course, in the
//	subset).
void MARGINALS :: Marginalize (
	const VPGNODEMBN & vpgndSubset,		//  Subset array of nodes
	MARGINALS & margSubset )			//  Marginalized result structure
{
	//  Initialize the result mdv
	margSubset.Init( vpgndSubset );
	//  Call the common code
	Marginalize( margSubset );
}

//	Marginalize down to a subset of our node set using the other
//	marginal's built-in table of nodes
void MARGINALS :: Marginalize ( MARGINALS & margSubset )
{
	//  Build the pseudo-dimension descriptor.
	VSIMD vsimdMarg = VsimdSubset( margSubset.Vpgnd() );

	//  Construct the slice which governs the missing dimensions
	MDVSLICE mdvs( vsimdMarg );
	Iterator itSelf( self );
	Iterator itSubset( margSubset, mdvs );
	Marginalize( margSubset, itSelf, itSubset );
}

void MARGINALS :: Marginalize (
	MARGINALS & margSubset,
	Iterator & itSelf,
	Iterator & itSubset )
{
	margSubset.Clear();

	itSelf.Reset();
	itSubset.Reset();

	while ( itSelf.BNext() )
	{
		itSubset.Next() += itSelf.Next();
	}
}

//  For "absorption", update one sepset marginal from another
void MARGINALS :: UpdateRatios ( const MARGINALS & marg )
{
	int cElem = size();
	if ( cElem != marg.size() )
		ThrowMisuse( "updating ratios requires same sized marginals" );

	for ( int i = 0; i < cElem; i++ )
	{
		REAL & rThis = self[i];
		if ( rThis != 0.0 )
			rThis = marg[i] / rThis;	
	}
}

//  Given a reorder table, return true if it's moot (no reordering present)
bool MARGINALS :: BOrdered ( const VIMD & vimdReorder )
{
	for ( int i = 0; i < vimdReorder.size(); i++ )
	{
		if ( vimdReorder[i] != i )
			return false;
	}
	return true;
}

//  Assuming that the fastest-changing (highest) dimension is the base
//  state space, set the probabilities of this table to uniform.
void MARGINALS :: SetUniform ()
{
	const VIMD & vimdDim = VimdDim();
	int cState = vimdDim[ vimdDim.size() - 1 ];
	REAL rUniform = 1.0 / cState;
	Clear( rUniform );
}


//  Construct the complete table of conditional probabilities for a given node
//	given a reordering table.  The reordering table is maintained as part of
//	the clique membership arc (GEDGEMBN_CLIQ) for a node if the clique is
//	the "family" clique (the smallest clique containing node and its parents).
//
//	At exit, the node pointer table of self is complete and in standard order.
//
//	The "family reorder" vector is in clique order and contains the index
//	of the node's parents which occurs in that position.  Note that the
//	node itself is always last in either ordering.  In its own p-table,
//	its states are the fastest varying subcript.  In the clique, it must
//  fall last in any marginalization containing only itself and its parents
//	due to the topological sorting employed in ordering nodes for clique
//	membership.
void MARGINALS :: CreateOrderedCPDFromNode (
	GNODEMBND * pgndd,
	const VIMD & vimdFamilyReorder )
{
	int cFam = vimdFamilyReorder.size();

	//  Access the distribution in the node
	BNDIST & bndist = pgndd->Bndist();
	const VIMD & vimdDist = bndist.VimdDim();
	assert( vimdDist.size() == cFam );

	//  Create this m-d vector's dimension table by reordering the
	//	  array of dimensions of the node's distribution and
	//	  initializing accordingly.
	VIMD vimd( cFam );
	ReorderVimd( vimdFamilyReorder, vimdDist, vimd );
	ReorderVimdNodes( vimdFamilyReorder, pgndd, _vpgnd );
	assert( _vpgnd.size() == cFam );
	assert( ifind( _vpgnd, pgndd ) >= 0 );	

	Init( vimd );
	assert( vimdProd( vimdDist ) == size() );

	if ( bndist.BDense() )
	{
		//  Dense distribution
		//  Create the reordering iterator
		Iterator itNode( bndist.Mdvcpd() );
		if ( ! BOrdered( vimdFamilyReorder ) )
			itNode.SetDimReorder( vimdFamilyReorder );
		Iterator itSelf( self );

		while ( itSelf.BNext() )
		{
			itSelf.Next() = itNode.Next();	
		}
	}
	else
	{
		//  Sparse distribution.  Iterate over all elements
		//	and plop them into their proper locations.  Since
		//  there may be missing elements, set everything to
		//  uniform first, and normalize as we go.
		SetUniform();

		VIMD vimdState( cFam );
		int cPar = cFam - 1;
		int cState = VimdDim()[cPar];
		//  Prepare a value to be used to replace any bogus (n/a) values in the nodes.
		REAL rUniform = 1.0 / cState;
		MPCPDD::const_iterator itdmEnd = bndist.Mpcpdd().end();
		for ( MPCPDD::const_iterator itdm = bndist.Mpcpdd().begin();
			  itdm != itdmEnd;
			  itdm++ )
		{
			const VIMD & vimdIndex = (*itdm).first;
			const VLREAL & vlr = (*itdm).second;

			//  Construct a complete subscript vector; first, the parents
			for ( int iDim = 0; iDim < cPar; iDim++ )
				vimdState[iDim] = vimdIndex[iDim];
			//  Then iterate over each element of the DPI state vector
			vimdState[cPar] = 0;
			ReorderVimd( vimdFamilyReorder, vimdState, vimd );
			for ( int iState = 0; iState < cState; iState++ )			
			{
				vimd[cPar] = iState;
				const REAL & r = vlr[iState];
				self[vimd] = bIsProb( r )	
						   ? r
						   : rUniform;
			}
		}
	}
}


//  Multiply corresponding entries in this marginal by those in another
void MARGINALS :: MultiplyBySubset ( const MARGINALS & marg )
{
	//MSRDEVBUG:  create a const version of MDVDENSE::Iterator
	MARGINALS & margSubset = const_cast<MARGINALS &> (marg);

	//  Build the pseudo-dimension descriptor.
	VSIMD vsimdMarg = VsimdSubset( margSubset.Vpgnd() );
	//  Construct the slice which governs the missing dimensions
	MDVSLICE mdvs( vsimdMarg );
	//  Construct the iterators for self and subset with missing dimensions
	Iterator itSelf( self );
	Iterator itSubset( margSubset, mdvs );
	MultiplyBySubset( itSelf, itSubset );
}

//  Multiply corresponding entries using precomputed iterators
void MARGINALS :: MultiplyBySubset (
	Iterator & itSelf,
	Iterator & itSubset )
{
	itSelf.Reset();
	itSubset.Reset();

	while ( itSelf.BNext() )
	{
		itSelf.Next() *= itSubset.Next();
	}
}

void MARGINALS :: Multiply ( REAL r )
{
	for ( int i = 0; i < size(); )
	{
		self[i++] *= r;
	}
}

void MARGINALS :: Invert ()
{
	for ( int i = 0; i < size(); i++ )
	{
		REAL & r  = self[i];
		if ( r != 0.0 )
			r = 1.0 / r;
	}
}

void MARGINALS :: ClampNode ( GNODEMBND * pgndd, const CLAMP & clamp )
{
	if (! clamp.BActive() )
		return ;
		
	//  Get the clamped state
	IST ist = clamp.Ist();
	//  Find which dimension is represented by this node
	int iDim = ifind( _vpgnd, pgndd );	

	if (   iDim < 0
		|| ist >= Vimd()[iDim] )
		ThrowMisuse("invalid clamp");

	//  Iterate over the entire table, zapping states which are inconsistent
	//		with the evidence.
	Iterator itSelf( self );

	for ( int i = 0; itSelf.BNext(); i++ )
	{	
		int iIst = itSelf.Vitmd()[iDim];
		if ( iIst != ist )
			itSelf.Next() = 0.0;
		else
			itSelf.IndxUpd();
	}
	assert( i == size() );
}


void MARGINALS :: Dump()
{
	cout << "\n\tMarginals members: "
		 << (const VPGNODEMBN &)_vpgnd	// MSRDEVBUG: cast unnecessary for VC++ 5.0
		 << "\n\t";

	Iterator itSelf(self);
	cout << itSelf;
}

//  Return true if each entry in this marginal is equal the corresponding entry
//		in a like-dimensioned other marginal within the stated tolerance

bool MARGINALS :: BEquivalent ( const MARGINALS & marg, REAL rTolerance )
{
	// Test dimensionality
	if ( VimdDim() != marg.VimdDim() )
		return false;

	const VLREAL & vrSelf = first;
	const VLREAL & vrOther = marg.first;
	REAL rTol = fabs(rTolerance);
	for ( int i = 0; i < vrSelf.size(); i++ )
	{
		const REAL & rSelf = vrSelf[i];
		const REAL & rOther = vrOther[i];
		REAL rdiff = fabs(rSelf) - fabs(rOther);
		if ( fabs(rdiff) > rTol )
			break;
	}
	return i == vrSelf.size() && i == vrOther.size();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\mbnmod.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       mbnmod.cpp
//
//--------------------------------------------------------------------------

#include <basetsd.h>
#include "gmobj.h"
#include "cliqset.h"


void MBNET :: CreateInferEngine ( REAL rEstimatedMaximumSize )
{
	DestroyInferEngine();

	ExpandCI();

	//  Create the clique tree set object, push it onto the modifier stack
	//		and activate it
	PushModifierStack( new GOBJMBN_CLIQSET( self, rEstimatedMaximumSize, _iInferEngID++ ) );
}

void MBNET :: DestroyInferEngine ()
{
	MBNET_MODIFIER * pmodf = PModifierStackTop();
	if ( pmodf == NULL )
		return;
	if ( pmodf->EType() != GOBJMBN::EBNO_CLIQUE_SET )	
		return;

	PopModifierStack();

	UnexpandCI();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\margiter.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       margiter.h
//
//--------------------------------------------------------------------------

//
//	margiter.h: compiled marginals iterators
//

#ifndef _MARGITER_H_
#define _MARGITER_H_

/*
	This class is intended to be used in sepsets.  There will be two of them,
	one representing the parent clique and the sepset, the other representing
	the child clique and the sepset.  The sepset is the "subset" in both
	cases.

	A MARGSUBITER "compiles" the subscripts from the iteration of the subset
	marginal into an array of integers.  Iteration using this array is much
	faster than performing full array stride multiplication and summation.
	The cost is the additional memory to contain the offsets in each sepset,
	which is roughly:

		sizeof(int) * (	  (# of entries in child clique)
						+ (# of entries in parent clique))
*/

#include <list>

//  Class VMARGSUB: a reference counted array of subscripts
class VMARGSUB : public VINT, public REFCNT
{
  public:
	VMARGSUB ( MARGINALS::Iterator & itMarg );
	~ VMARGSUB ();
	void NoRef ();
	int ISearchPass () const
		{ return _iSearchPass; }
	int & ISearchPass ()
		{ return _iSearchPass; }

	LEAK_VAR_ACCESSOR

  protected:
	int _iSearchPass;

	LEAK_VAR_DECL

	HIDE_UNSAFE(VMARGSUB);
};

//  Class MARGSUBREF: a reference (via pointer) to a VMARGSUB
//		and an applicable length.  This class exists so that
//		when a new, longer, superset subscript array (VMARGSUB)
//		is added to the ensemble, all older references to smaller
//		VMARGSUBs can be converted to reference the new, larger
//		VMARGSUB and the older one discarded.
//
class MARGSUBREF : public REFCNT
{
  public:
	MARGSUBREF ( VMARGSUB * pvmsub = NULL, int cSize = -1 );
	~ MARGSUBREF ();
	MARGSUBREF ( const MARGSUBREF & msubr );
	MARGSUBREF & operator = ( const MARGSUBREF & msubr );

	//  Set the array
	void SetVmsub ( VMARGSUB * pvmsub, int cSize = -1 );

	//  Return iteration information
	VINT & VintSub ()
	{
		assert( _pvmsub );
		return *_pvmsub;
	}
	VMARGSUB & Vmsub ()
	{
		assert( _pvmsub );
		return *_pvmsub;
	}
	VMARGSUB * Pvmsub ()
	{
		assert( _pvmsub );
		return _pvmsub;
	}
	int CSize() const
		{ return _cSize ; }

	DECLARE_ORDERING_OPERATORS(MARGSUBREF);
	LEAK_VAR_ACCESSOR

  protected:
	VMARGSUB * _pvmsub;			//  Pointer to array of subscripts
	int _cSize;					//	Applicable length

	LEAK_VAR_DECL
};

typedef list<MARGSUBREF> LTMSUBR;

//  A wrapper for a linked list of MARGSUBREFs.
//	There is one global instance of this.
class LTMARGSUBREF
{
  public:
	LTMARGSUBREF ();
	MARGSUBREF * PmsubrAdd ( MARGINALS::Iterator & itMarg );
	void Release ( MARGSUBREF * pmsubr );
	void Dump ();

  protected:
	LTMSUBR _ltmsubr;

	int _iSearchPass;
	int _cArrays;
	size_t _cArrayTotalSize;
	int _cSubRefs;
};


class MARGSUBITER	//  Marginals Subset Iterator
{
  public:
	MARGSUBITER ();
	~ MARGSUBITER () ;
	bool BBuilt () const
		{ return _pmsubr != NULL; }
	//  Build the iterator for two cliques
	void Build ( MARGINALS & margSelf, MARGINALS & margSubset );
	//	Build the iterator for a clique and a node
	void Build ( MARGINALS & margSelf, GNODEMBND * pgndd );
	//  Marginalize the superset to the subset (subset changed)
	inline void MarginalizeInto ( MDVCPD & mdvSubset );
	//  Marginalize the superset to a node's UPD
	inline void MarginalizeBelief ( MDVCPD & mdvBel, GNODEMBND * pgndd );
	//  Multiply the superset by the subset (superset changed)
	inline void MultiplyBy ( MARGINALS & margSubset );
	//  Verify subscripts
	void Test ( MARGINALS & margSubset );
	
	static void Dump ()
		{ _ltmargsubr.Dump();  }

  protected:
	MARGINALS * _pmargSelf;
	MARGSUBREF * _pmsubr;

	static LTMARGSUBREF _ltmargsubr;
};

inline
void MARGSUBITER :: MarginalizeInto ( MDVCPD & mdvSubset )
{
	assert( _pmsubr && _pmargSelf );
	mdvSubset.Clear();

	VINT & visub = _pmsubr->VintSub();
	int cEnd = _pmsubr->CSize();
	const int * pisub = & visub[0];
	// Note: this funny reference is due to BoundsChecker complaining that I'm accessing memory
	//   beyond the end of the array.  I'm not, but it doesn't complain about this
	const int * pisubMax = & visub[0] + cEnd;
	double * pvlSubset = & mdvSubset.first[0];
	double * pvlSelf = & _pmargSelf->first[0];
	while ( pisub != pisubMax )
	{
		pvlSubset[*pisub++] += *pvlSelf++;
	}
}

inline
void MARGSUBITER :: MultiplyBy ( MARGINALS & margSubset )
{
	assert( _pmsubr && _pmargSelf );
	VINT & visub = _pmsubr->VintSub();
	int cEnd = _pmsubr->CSize();
	const int * pisub = & visub[0];
	// Note: See note above about funny subscripting
	const int * pisubMax = & visub[0] + cEnd;
	double * pvlSubset = & margSubset.first[0];
	double * pvlSelf = & _pmargSelf->first[0];
	while ( pisub != pisubMax )
	{
		*pvlSelf++ *= pvlSubset[*pisub++];
	}
}

//  Marginalize the superset to a node's UPD
inline
void MARGSUBITER :: MarginalizeBelief ( MDVCPD & mdvBel, GNODEMBND * pgndd )
{
	MARGINALS::ResizeDistribution( pgndd, mdvBel );

	MarginalizeInto( mdvBel );

	mdvBel.Normalize();
}

#endif  // _MARGITER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\mbnflags.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       mbnflags.h
//
//--------------------------------------------------------------------------

//
//  mbnflags.h:  
//
//		This inclusion generates names and constant strings
//		or a table of strings, depending upon the setting of
//		of the preprocessor manifest MBN_GENBFLAGS.
//
//		Botk belief networks (MBNET) and named belief network 
//		objects	(GOBJMBN) have arrays of bit flags in them.
//

#if (!defined(_MBNFLAGS_H_)) || defined(MBN_GEN_BFLAGS_TABLE)
#ifndef _MBNFLAGS_H_
	#define _MBNFLAGS_H_
#endif

/*******************************************************************
********************************************************************
	Belief network flag declarations.

	There is a set of predefined flag names which are recorded into 
	the symbol table of every constructed belief network.  These
	names are globally available as members of the enumeration EMBFLAGS;
	for example, "EIBF_Topology".

	Other flag definitions can be created at run-time and used in any 
	bit vector (type VFLAGS).

********************************************************************
********************************************************************/

#ifdef MBN_GEN_BFLAGS_TABLE
	//  Allow building of string name table in outer scope
	#define MBFLAGS_START	static SZC MBN_GEN_BFLAGS_TABLE [] = {
	#define MBFLAG(name)		#name,
	#define MBFLAGS_END			NULL };

#else
	//  Generate enumerated values
	#define MBFLAGS_START	enum EMBFLAGS {
	#define MBFLAG(name)		EIBF_##name,
	#define MBFLAGS_END			EIBF_max };
#endif

//
//	Statically predefined belief network bit flags.
//
	//  Open the declaration set
MBFLAGS_START
	//  Network has probabilistic topology arcs
MBFLAG(Topology)			//	EIBF_Topology
	//  Distributions have been bound
MBFLAG(Distributions)
	//  Network or node has been expanded
MBFLAG(Expanded)			//  EIBF_Expanded
	//  Node is an expansion by-product
MBFLAG(Expansion)			//  EIBF_Expansion
	//	Node is leak term
MBFLAG(Leak)				//  EIBF_Leak
	//  Terminate the declaration set
MBFLAGS_END

//  Rescind the declaration of the bidirectional macro
#undef MBFLAGS_START
#undef MBFLAG
#undef MBFLAGS_END
#undef MBN_GEN_BFLAGS_TABLE

#endif _MBNFLAGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\margiter.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       margiter.cpp
//
//--------------------------------------------------------------------------

//
//	margiter.cpp: compiled marginals iterators
//

#include <basetsd.h>
#include <math.h>
#include "basics.h"
#include "gmobj.h"
#include "marginals.h"
#include "margiter.h"
#include "algos.h"
#include "parmio.h"

LEAK_VAR_DEF(VMARGSUB)
LEAK_VAR_DEF(MARGSUBREF)

//
//  Construct a VMARGSUB from a marginals iterator
//
VMARGSUB :: VMARGSUB ( MARGINALS::Iterator & itMarg )
	: _iSearchPass(0)
{	
	itMarg.Reset();
	resize( itMarg.IEnd() );
	for ( int i = 0; itMarg.BNext() ; i++)
	{
		int ix = itMarg.IndxUpd();
		self[i] = ix;
	}
	LEAK_VAR_UPD(1)
}

VMARGSUB :: ~ VMARGSUB ()
{
	LEAK_VAR_UPD(-1)
}

void VMARGSUB :: NoRef ()
{
	delete this;
}

MARGSUBREF :: MARGSUBREF ( VMARGSUB * pvmsub, int cSize )
	: _pvmsub( NULL ),
	_cSize( -1 )
{
	SetVmsub( pvmsub, cSize );
	LEAK_VAR_UPD(1)
}

MARGSUBREF :: MARGSUBREF ( const MARGSUBREF & msubr )
	: _pvmsub( NULL ),
	_cSize( -1 )
{
	self = msubr;
	LEAK_VAR_UPD(1)
}

MARGSUBREF & MARGSUBREF :: operator = ( const MARGSUBREF & msubr )
{
	SetVmsub( msubr._pvmsub, msubr.CSize() );	
	return self;
}

void MARGSUBREF :: SetVmsub ( VMARGSUB * pvmsub, int cSize )
{
	if ( _pvmsub )
	{
		_pvmsub->Unbind();
		_pvmsub = NULL;
	}
	if ( pvmsub )
	{
		_cSize = cSize > 0 ? cSize : pvmsub->size();
		pvmsub->Bind();
		_pvmsub = pvmsub;
	}
	else
	{
		_cSize = 0;
	}
}

MARGSUBREF :: ~ MARGSUBREF ()
{
	SetVmsub( NULL );
	LEAK_VAR_UPD(-1)
}

bool MARGSUBREF :: operator == ( const MARGSUBREF & msr ) const
{
	return _pvmsub == msr._pvmsub && _cSize == msr._cSize;
}
bool MARGSUBREF :: operator != ( const MARGSUBREF & msr ) const
{
	return !(self == msr);
}

LTMARGSUBREF :: LTMARGSUBREF ()
	: _iSearchPass(0),
	_cArrays(0),
	_cArrayTotalSize(0),
	_cSubRefs(0)
{
}

void LTMARGSUBREF :: Dump ()
{
#ifdef DUMP
	cout << "\n\nLTMARGSUBREF::~ LTMARGSUBREF: "
		 << "\n\tTotal search passes to create marginals iterators = "
		 << _iSearchPass
		 << "\n\tTotal arrays = "
		 << _cArrays
		 << "\n\tTotal array size = "
		 << _cArrayTotalSize
		 << "\n\tTotal marg iterator references = "
		 << _cSubRefs
		 ;
	cout.flush();
#endif
}

//  Iterate over the list looking for a match
MARGSUBREF * LTMARGSUBREF :: PmsubrAdd ( MARGINALS::Iterator & itMarg )
{
	//  Bump the search pass
	_iSearchPass++;
	//  Get the minimum number of elements
	int cMin = itMarg.IEnd();

	MARGSUBREF * pmsubrBest = NULL;
	MARGSUBREF * pmsubrNew = NULL;

	//  Search the list for the longest matching subscript array
	//		in the pool.
	for ( LTMSUBR::iterator itlt = _ltmsubr.begin();
		  itlt != _ltmsubr.end();
		  itlt++ )
	{
		MARGSUBREF & msubr = (*itlt);
		VMARGSUB & vmsub = msubr.Vmsub();
		if ( vmsub.ISearchPass() == _iSearchPass )
			continue;   //  We've already looked at this one
		//  Mark this VMARGSUB as having been checked in this pass
		vmsub.ISearchPass() = _iSearchPass;

		//  Prepare to search it

		itMarg.Reset();
		for ( int i = 0; itMarg.BNext() && i < vmsub.size() ; i++ )
		{
			int ia = vmsub[i];
			int ib = itMarg.IndxUpd();

			if ( ia != ib )
				break;
		}
		//  If we made it to the end of the array, we found one.
		if ( i != cMin )
			continue;	// Mismatch somewhere
		//  See if it's the best (longest) found so far
		if ( pmsubrBest == NULL )
		{
			pmsubrBest = & msubr;
		}
		else
		if (  pmsubrBest->Vmsub().size() < vmsub.size()
			|| (	pmsubrBest->Vmsub().size() == vmsub.size()
				 && pmsubrBest->CSize() == cMin ) )
		{
			pmsubrBest = & msubr;
		}
	}

	//  If "pmsubrBest" != NULL, we found at least one matching array.
	//	Now see if we can find an exact match: a MARGSUBREF which has
	//  the same base array and the same length as what we want.
	if ( pmsubrBest )
	{
		//  If the "best" one doesn't match our size, find one that does
		if ( pmsubrBest->CSize() != cMin )
		{
			for ( itlt = _ltmsubr.begin();
				  itlt != _ltmsubr.end();
				  itlt++ )
			{
				MARGSUBREF & msubr = (*itlt);
				if ( msubr.Pvmsub() == pmsubrBest->Pvmsub()
					&& msubr.CSize() == cMin )
				{
					pmsubrBest = & msubr;
					break;
				}
			}
		}
		//  See if now have and exact match
		if ( pmsubrBest->CSize() == cMin )
		{
			//  Exact match: best array and same length
			pmsubrNew = pmsubrBest;
		}
		else
		{
			//  Well, we know which array to use, but we have
			//  to create a new MARGSUBREF for it
			_ltmsubr.push_back( MARGSUBREF( pmsubrBest->Pvmsub(), cMin ) );
			pmsubrNew = & _ltmsubr.back();
			_cSubRefs++;
		}
	}
	else
	{
		//  There does NOT appear to be a viable array in the ensemble,
		//  so we have to create a new one and a MARGSUBREF for it.
		VMARGSUB * pvmsub = new VMARGSUB( itMarg );
		_cArrays++;
		_cArrayTotalSize += cMin;
		_ltmsubr.push_back( MARGSUBREF( pvmsub, cMin ) );
		pmsubrNew = & _ltmsubr.back();
		_cSubRefs++;

		//  At this point we have a new array which may be a superset of
		//	some other array already in the pool.  Walk through the list
		//  of MARGSUBREFs and change any references whose base arrays
		//  are subsets of this new one to point to the new array.

		//  Bump the search pass
		_iSearchPass++;

		for ( itlt = _ltmsubr.begin();
			  itlt != _ltmsubr.end();
			  itlt++ )
		{
			MARGSUBREF & msubr = (*itlt);
			if ( & msubr == pmsubrNew )
				continue;
			VMARGSUB & vmsub = msubr.Vmsub();
			if ( vmsub.ISearchPass() == _iSearchPass )
				continue;   //  We've already looked at this one
			//  Mark this VMARGSUB as having been checked in this pass
			vmsub.ISearchPass() = _iSearchPass;
			if ( & vmsub == pvmsub || vmsub.size() > pvmsub->size() )
				continue;	//  Old array is larger; not a subset

			//  See if the old array is a subset
			for ( int i = 0; i < vmsub.size(); i++ )
			{
				int ia = vmsub[i];
				int ib = (*pvmsub)[i];

				if ( ia != ib )
					break;
			}
			if ( i == vmsub.size() )
			{	
				assert( vmsub.size() != pvmsub->size() );
				//  The subset is identical.  Change all refs that point to it.
				VMARGSUB * pvmsubDefunct = msubr.Pvmsub();
				for ( LTMSUBR::iterator itlt2 = _ltmsubr.begin();
					  itlt2 != _ltmsubr.end();
					  itlt2++ )
				{
					MARGSUBREF & msubr2 = (*itlt2);
					if ( msubr2.Pvmsub() == pvmsubDefunct )
					{
						//  If the array is about to disappear, do the bookkeepping
						if ( pvmsubDefunct->CRef() <= 1 )
						{
							_cArrays--;
							_cArrayTotalSize -= pvmsubDefunct->size();
						}
						//  Convert this reference to a reference to our new array
						msubr2.SetVmsub( pvmsub, msubr2.CSize() );
					}
				}
			}
		}
	}
	pmsubrNew->Bind();
	return pmsubrNew;
}

void LTMARGSUBREF :: Release ( MARGSUBREF * pmsubr )
{
	if ( pmsubr == NULL )
		return;
	pmsubr->Unbind();
	if ( pmsubr->CRef() > 0 )
		return;

	LTMSUBR::iterator itlt = find( _ltmsubr.begin(), _ltmsubr.end(), *pmsubr );
	assert( itlt != _ltmsubr.end() );
	_cSubRefs--;
	MARGSUBREF & msubr = (*itlt);
	if ( msubr.Vmsub().CRef() <= 1 )
	{
		_cArrays--;
		_cArrayTotalSize -= msubr.Vmsub().size();
	}
	_ltmsubr.erase(itlt);
}

//  The global subscript array reference list
LTMARGSUBREF MARGSUBITER :: _ltmargsubr;


MARGSUBITER :: MARGSUBITER ()
	:_pmsubr( NULL ),
	_pmargSelf( NULL )
{
}

MARGSUBITER :: ~ MARGSUBITER ()
{
	_ltmargsubr.Release( _pmsubr );
}

void MARGSUBITER :: Build ( MARGINALS & margSelf, MARGINALS & margSubset )
{
	assert( margSelf.size() >= margSubset.size() );
	assert( _pmsubr == NULL && _pmargSelf == NULL );

	_pmargSelf = & margSelf;

	//  Build the pseudo-dimension descriptor.
	VSIMD vsimdMarg = margSelf.VsimdSubset( margSubset.Vpgnd() );

	//  Construct the slice which governs the missing dimensions
	MDVSLICE mdvs( vsimdMarg );
	MARGINALS::Iterator itSubset( margSubset, mdvs );

	//  Find or construct a MARGSUBITER to match
	_pmsubr = _ltmargsubr.PmsubrAdd( itSubset );
}

//	Build the iterator for a clique and a node
void MARGSUBITER :: Build ( MARGINALS & margSelf, GNODEMBND * pgndd )
{
	assert( _pmsubr == NULL && _pmargSelf == NULL );
	_pmargSelf = & margSelf;

	//  Construct a dummy marginalization target
	MDVCPD distd;
	MARGINALS::ResizeDistribution( pgndd, distd );

	//  Get the pseudo-dimension descriptor for this node
	VSIMD vsimdMarg = margSelf.VsimdFromNode( pgndd );
	//  Construct the slice which governs the missing dimensions
	MDVSLICE mdvs( vsimdMarg );
	MARGINALS::Iterator itSelf( margSelf );
	MARGINALS::Iterator itSubset( distd, mdvs );
	//  Find or construct a MARGSUBITER to match
	_pmsubr = _ltmargsubr.PmsubrAdd( itSubset );
}

//  Verify subscripts
void MARGSUBITER :: Test ( MARGINALS & margSubset )
{
	assert( _pmsubr && _pmargSelf );
	assert( _pmargSelf->size() > margSubset.size() );

	//  Build the pseudo-dimension descriptor.
	VSIMD vsimdMarg = _pmargSelf->VsimdSubset( margSubset.Vpgnd() );

	//  Construct the slice which governs the missing dimensions
	MDVSLICE mdvs( vsimdMarg );
	MARGINALS::Iterator itSubset( margSubset, mdvs );
	MARGINALS::Iterator itSelf( *_pmargSelf );
	int isub = 0;
	VINT & vintSub = _pmsubr->VintSub();
	int cEnd = _pmsubr->CSize();
	for ( int iself = 0; itSelf.BNext(); iself++ )
	{
		int isubSelf = itSelf.IndxUpd();
		int isubSubset = itSubset.IndxUpd();
		assert( isubSelf == iself );
		int isubTest = vintSub[iself];
		assert( isubTest == isubSubset && iself < cEnd );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\marginals.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       marginals.h
//
//--------------------------------------------------------------------------

//
//	marginals.h: Definitions for marginals tables.
//
//		See marginals.cpp for documentation
//
#ifndef _MARGINALS_H_
#define _MARGINALS_H_

//  Class of multidimensional array capable of intelligent
//	marginalization.
class MARGINALS : public MDVCPD
{
	friend class MARGSUBITER;

  public:
	MARGINALS ( const VPGNODEMBN & vpgnd )
		{ Init( vpgnd ); }

	MARGINALS () {}

	//  Initialize from an array of node pointers
	//		(discrete only: GNODEMBND)
	void Init ( const VPGNODEMBN & vpgnd )
	{
		_vpgnd = vpgnd;
		Init( VimdFromVpgnd( _vpgnd ) );
	}

	//  Allow access to the table of dimensions
	const VIMD & Vimd () const
		{ return Slice().size();  }

	const VPGNODEMBN & Vpgnd () const
		{ return _vpgnd; }

	//  Marginalize down to a single node
	void Marginalize ( GNODEMBND * pgndd, MDVCPD & distd );
	//	Marginalize down to a subset of our node set using a table of nodes
	void Marginalize ( const VPGNODEMBN & vpgndSubset, MARGINALS & marg );
	//	Marginalize down to a subset of our node set using the other's table of nodes
	void Marginalize ( MARGINALS & marg );
	//  Marginalize to subset using pre-computed iterators
	void Marginalize ( MARGINALS & margSubset, Iterator & itSelf, Iterator & itSubset );

	//  For "absorption", update this sepset marginal from another
	void UpdateRatios ( const MARGINALS & marg );
	//  Multiply corresponding entries in this marginal by those in another
	void MultiplyBySubset ( const MARGINALS & margSubset );
	//  Multiply corresponding entries using precomputed iterators
	void MultiplyBySubset ( Iterator & itSelf, Iterator & itSubset );

	void Multiply ( REAL r );
	void Invert ();

	//  Construct the complete table of conditional probabilities for a given node
	//	given a reordering table.  Build _vpgnd accordingly.
	void CreateOrderedCPDFromNode ( GNODEMBND * pgndd,
									const VIMD & vimdFamilyReorder );

	void ClampNode ( GNODEMBND * pgndd, const CLAMP & clamp );

	//  Given a reorder table, return true if it's moot (no reordering present)
	static bool BOrdered ( const VIMD & vimdReorder );

	//  Convert a node table to a dimension array
	inline static VIMD VimdFromVpgnd ( const VPGNODEMBN & vpgnd )
	{
		VIMD vimd( vpgnd.size() );

		for ( int i = 0; i < vpgnd.size(); i++ )
		{
			const GNODEMBND * pgndd;
			DynCastThrow( vpgnd[i], pgndd );
			vimd[i] = pgndd->CState();
		}
		return vimd;
	}

	//  Return true if each entry in this marginal is equal the corresponding entry
	//		in a like-dimensioned other marginal within the stated tolerance
	bool BEquivalent ( const MARGINALS & marg, REAL rTolerance = 0.0 );

	void Dump();

	//  Return the signed table of dimensions used for marginalizing 
	VSIMD VsimdSubset ( const VPGNODEMBN & vpgndSubset );

  protected:
	//  Table of node pointers for each dimension of this marginal
	VPGNODEMBN _vpgnd;

  protected:
	MARGINALS ( const VIMD & vimd )
		: MDVCPD( vimd )
		{}

	//  Initialize from a table of dimensions
	void Init (  const VIMD & vimd, size_t start = 0 )
		{ MDVCPD::Init( vimd, start ); }

	//  Return the table of pseudo-dimensions for marginalizing to a single node
	VSIMD VsimdFromNode ( GNODEMBND * pgndd );
	
	void SetUniform	();

	void ThrowMisuse ( SZC szcMsg );

	//  Reorder a single m-d vector subscript array. 'vimdReorder' is the
	//  table in MARGINALS (topological) sequence of the original dimensions.	
	inline static
	void ReorderVimd ( const VIMD & vimdReorder, const VIMD & vimdIn, VIMD & vimdOut );
	//  Reorder an array containing a node's family based upon the reordering
	//		table given.
	inline static
	void ReorderVimdNodes ( const VIMD & vimdReorder, GNODEMBND * pgndd, VPGNODEMBN & vpgnd );
	//  Resize the MDVCPD for a UPD for the node
	inline static
	void ResizeDistribution ( GNODEMBND * pgndd, MDVCPD & distd );
};

//  Resize the MDVCPD for a UPD for the node
inline
void MARGINALS :: ResizeDistribution ( GNODEMBND * pgndd, MDVCPD & distd )
{
	distd.MDVDENSE::Init( 1, pgndd->CState() );
}

inline
static
ostream & operator << ( ostream & ostr, const VPGNODEMBN & vpgnd )
{
	ostr << '[';
	for ( int i = 0; i < vpgnd.size(); i++ )
	{
		const GNODEMBN * pgnd = vpgnd[i];
		ostr << pgnd->ZsrefName().Szc();
		if ( i + 1 < vpgnd.size() )
			ostr << ',';
	}
	return ostr << ']';
}

#endif   // _MARGINALS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\mbnetdsc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       mbnetdsc.cpp
//
//--------------------------------------------------------------------------

//
//   MBNETDSC.CPP: MBNETDSC functions
//

#include <basetsd.h>
#include "gmobj.h"
#include "bnparse.h"

MBNETDSC :: MBNETDSC ()
	: _pfDsc(NULL)
{
}

MBNETDSC :: ~ MBNETDSC ()
{
}

static
struct TKNFUNCMAP
{
	BNDIST::EDIST ed;
	SZC szc;
}
rgTknFunc[] =
{
	{ BNDIST::ED_CI_MAX,	"max"	},
	{ BNDIST::ED_CI_PLUS,	"plus"	},
	{ BNDIST::ED_MAX,		NULL	}		// must be last
};

SZC MBNETDSC :: SzcDist ( BNDIST::EDIST edist )
{
	for ( int i = 0; rgTknFunc[i].szc; i++ )
	{
		if ( rgTknFunc[i].ed == edist )
			break;
	}
	return rgTknFunc[i].szc;
}


//
//	String-to-token translation.
//
struct TKNMAP
{
    SZC     _szc;
    TOKEN   _token;
};

static TKNMAP rgTknStr[] =
{	//  This table must be kept in alphabetic order
	"",					tokenNil,
	"..",				tokenRangeOp,
	"array",			tokenArray,
	"as",				tokenAs,
	"branch",			tokenBranch,
	"choice",			tokenWordChoice,
	"continuous",		tokenContinuous,
	"creator",          tokenCreator,
	"decisionGraph",	tokenDecisionGraph,
	"default",          tokenDefault,
	"discrete",         tokenDiscrete,
	"distribution",		tokenDistribution,
	"domain",			tokenDomain,
	"for",				tokenFor,
	"format",           tokenFormat,
	"function",			tokenFunction,
	"import",			tokenImport,
	"is",				tokenIs,
	"leaf",				tokenLeaf,
	"leak",             tokenLeak,
	"level",			tokenLevel,
	"merge",			tokenMerge,
	"multinoulli",		tokenMultinoulli,
	"na",				tokenNA,
	"name",             tokenName,
	"named",			tokenNamed,
	"network",          tokenNetwork,
	"node",             tokenNode,
	"of",				tokenOf,
	"on",				tokenOn,
	"parent",           tokenParent,
	"position",         tokenPosition,
	"probability",		tokenProbability,
	"properties",		tokenProperties,
	"property",			tokenProperty,
	"real",				tokenWordReal,
	"standard",			tokenStandard,
	"state",            tokenState,
	"string",			tokenWordString,
	"type",             tokenType,
	"version",          tokenVersion,
	"vertex",			tokenVertex,
	"with",				tokenWith,
	NULL,               tokenNil            //  must be last one
};

//
//	Map a string to a token (case-sensitive)
//
TOKEN MBNETDSC :: TokenFind ( SZC szc )
{
	static bool bFirstTime = true;
	assert( szc != NULL );

	TKNMAP * ptknmap;
	
	if ( bFirstTime )
	{
		//  Verify that the parser token table is in sequence
		bFirstTime = false;
		TKNMAP * ptknmapLast = NULL;
		for ( ptknmap = rgTknStr;
			  ptknmap->_szc;
			  ++ptknmap)
		{
			ASSERT_THROW(     ptknmapLast == NULL
						   || ::strcmp( ptknmapLast->_szc, ptknmap->_szc ) < 0,
						   EC_INTERNAL_ERROR,
						   "parser token table out of sequence" );
			ptknmapLast = ptknmap;
		}
	}

    for ( ptknmap = rgTknStr;
		  ptknmap->_szc;
		  ++ptknmap)
    {
		int i = ::strcmp(szc, ptknmap->_szc);
		if ( i > 0 )
			continue;
		if ( i == 0 )
			break;
		return tokenNil;
    }
    return ptknmap->_token;
}

//
//	Map a token to a string.
//
SZC MBNETDSC :: SzcTokenMap ( TOKEN tkn )
{
    for ( TKNMAP * ptknmap = rgTknStr;
		  ptknmap->_szc;
		  ++ptknmap)
    {
		if ( ptknmap->_token == tkn )
			break;
    }
    return ptknmap->_szc;
}

bool MBNETDSC :: BParse ( SZC szcFn, FILE * pfErr )
{
	if ( pfErr == NULL )
		pfErr = stderr;
	PARSIN_DSC flpIn;
	PARSOUT_STD flpOut(pfErr);

	DSCPARSER parser(self, flpIn, flpOut);

	UINT cError, cWarning;
	return parser.BInitOpen( szcFn )
		&& parser.BParse( cError, cWarning );
}

void MBNETDSC :: Print ( FILE * pf )
{
	if ( ! pf )
		pf = stdout;
	_pfDsc = pf;

	PrintHeaderBlock();
	PrintPropertyDeclarations();
	PrintDomains();
	PrintNodes();
	PrintTopologyAndDistributions();

	_pfDsc = NULL;
}

void MBNETDSC :: PrintDomains ()
{
	MBNET::ITER mbnit( self, GOBJMBN::EBNO_VARIABLE_DOMAIN );
	GOBJMBN * pgmobj;
	ZSTR zstrRange;
	for ( ; pgmobj = *mbnit ; ++mbnit)
	{
		ZSREF zsrName = mbnit.ZsrCurrent();
		GOBJMBN_DOMAIN * pgdom;
		DynCastThrow( pgmobj, pgdom );
		fprintf( _pfDsc, "\ndomain %s\n{", zsrName.Szc() );
		const RDOMAIN & rdom = pgdom->Domain();
		RDOMAIN::const_iterator itdm = rdom.begin();
		for ( int i = 0; itdm != rdom.end(); i++ )
		{
			const RANGEDEF & rdef = *itdm;
			zstrRange.Reset();
			//  If the range is a singleton and is the next integer,
			//		just print it as-is.
			if ( ! rdef.BDiscrete() || rdef.IDiscrete() != i )
			{
				//  Format the range operator and arguments
				if ( rdef.BDiscrete() )
				{
					zstrRange.Format( "%d", rdef.IDiscrete() );
				}
				else
				{
					if ( rdef.BLbound() )
						zstrRange.FormatAppend( "%g ", rdef.RLbound() );
					zstrRange.FormatAppend( "%s", SzcTokenMap(tokenRangeOp) );
					if ( rdef.BUbound() )
						zstrRange.FormatAppend( " %g", rdef.RUbound() );
				}
				zstrRange.FormatAppend(" : ");
			}

			fprintf( _pfDsc, "\n\t%s\"%s\"", zstrRange.Szc(), rdef.ZsrName().Szc() );			

			if ( ++itdm != rdom.end() )
				fprintf( _pfDsc, "," );
		}
		fprintf( _pfDsc, "\n}\n" );
	}
}

void MBNETDSC :: PrintHeaderBlock()
{
	fprintf(_pfDsc, "%s", SzcTokenMap(tokenNetwork) );
	if ( ZsNetworkID().length() > 0 )
	{
		fprintf(_pfDsc, " \"%s\"", ZsNetworkID().Szc() );
	}
	fprintf(_pfDsc, "\n{");
	if ( RVersion() >= 0.0 )
	{
		fprintf(_pfDsc, "\n\t%s is %g;",
				SzcTokenMap(tokenVersion),
				RVersion() );
	}
	if ( ZsCreator().length() > 0 )
	{
		fprintf(_pfDsc, "\n\t%s is \"%s\";",
			   SzcTokenMap(tokenCreator),
			   ZsCreator().Szc() );
	}
	if ( ZsFormat().length() > 0 )
	{
		fprintf(_pfDsc, "\n\t%s is \"%s\";",
			   SzcTokenMap(tokenFormat),
			   ZsFormat().Szc() );
	}
	fprintf( _pfDsc, "\n}\n\n" );
}

//
//	Regenerate the property type declarations.
//
//		If any are marked "standard", generate the "import standard" declaration.
//		Generate explicit "import" declarations for any marked "persistent".
//
void MBNETDSC :: PrintPropertyDeclarations()
{
	int cTypes = 0;
	MBNET::ITER mbnit( self, GOBJMBN::EBNO_PROP_TYPE );
	GOBJMBN * pgmobj;
	bool bImportStandard = false;
	for ( ; pgmobj = *mbnit ; ++mbnit)
	{
		ZSREF zsrName = mbnit.ZsrCurrent();
		GOBJPROPTYPE * pbnpt;
		DynCastThrow( pgmobj, pbnpt );
		if ( cTypes++ == 0 )
		{
			fprintf( _pfDsc, "%s\n{",
					SzcTokenMap(tokenProperties) );
		}
		assert( zsrName == pbnpt->ZsrefName() );

		//  If this is a standard persistent property,
		//		write the import declaration once
		if ( pbnpt->FPropType() & fPropStandard )
		{
			if ( ! bImportStandard )
			{	
				//  Write the "import" statement once
				fprintf( _pfDsc, "\n\timport standard;" );
				bImportStandard = true;
			}
			//  Skip further processing of standard imported types
			continue;
		}

		//  If this is a persistent property, write the import declaration
		if ( pbnpt->FPropType() & fPropPersist )
		{
			fprintf( _pfDsc, "\n\timport %s;", zsrName.Szc() );
			continue;
		}

		//  User-declared (private, non-persistent) property

		fprintf( _pfDsc, "\n\ttype %s = ", zsrName.Szc() );
		if ( pbnpt->FPropType() & fPropArray )
		{
			fprintf( _pfDsc, "%s %s ",
					SzcTokenMap(tokenArray),
					SzcTokenMap(tokenOf) );
		}
		if ( pbnpt->FPropType() & fPropChoice )
		{
			fprintf( _pfDsc, "%s %s \n\t\t[",
					SzcTokenMap(tokenWordChoice),
					SzcTokenMap(tokenOf) );
			int cc = pbnpt->VzsrChoice().size();
			for ( int ic = 0; ic < cc; ic++ )
			{
				fprintf( _pfDsc, "%s", pbnpt->VzsrChoice()[ic].Szc() );
				if ( ic+1 < cc )
					fprintf( _pfDsc, "," );
			}
			fprintf( _pfDsc, "]" );
		}
		else
		if ( pbnpt->FPropType() & fPropString )
		{
			fprintf( _pfDsc, "%s", SzcTokenMap(tokenWordString) );
		}
		else
		{
			fprintf( _pfDsc, "%s", SzcTokenMap(tokenWordReal) );
		}
		if ( pbnpt->ZsrComment().Zstr().length() > 0 )
		{
			fprintf( _pfDsc, ",\n\t\t\"%s\"",
					pbnpt->ZsrComment().Szc() );
		}
		fprintf( _pfDsc, ";" );
	}

	if ( cTypes )
	{
		PrintPropertyList( LtProp() );

		fprintf( _pfDsc, "\n}\n" );
	}
}


void MBNETDSC :: PrintNodes()
{
	MBNET::ITER mbnit( self, GOBJMBN::EBNO_NODE );
	GOBJMBN * pgmobj;
	GNODEMBN * pbnode;
	GNODEMBND * pbnoded;
	for ( ; pgmobj = *mbnit ; ++mbnit)
	{
		ZSREF zsrName = mbnit.ZsrCurrent();
		DynCastThrow( pgmobj, pbnode );
		assert( zsrName == pbnode->ZsrefName() );

		fprintf( _pfDsc, "\n%s %s\n{",
				SzcTokenMap(tokenNode),
				pbnode->ZsrefName().Szc() );
		if ( pbnode->ZsFullName().length() > 0 )
		{
			fprintf( _pfDsc, "\n\t%s = \"%s\";",
					SzcTokenMap(tokenName),
					pbnode->ZsFullName().Szc() );
		}

		pbnoded = dynamic_cast<GNODEMBND *>(pbnode);
		ASSERT_THROW( pbnoded, EC_NYI, "only discrete nodes supported" )

		// Print the type and states using a domain, if given
		if ( pbnoded->ZsrDomain().Zstr().length() > 0 )
		{
			//  Explicit domain
			fprintf( _pfDsc, "\n\t%s = %s %s %s;",
					 SzcTokenMap(tokenType),
					 SzcTokenMap(tokenDiscrete),
					 SzcTokenMap(tokenDomain),
					 pbnoded->ZsrDomain().Szc() );
		}
		else
		{
			//  Variable-specific state enumeration
			int cState = pbnoded->CState();
			fprintf( _pfDsc, "\n\t%s = %s[%d]\n\t{",
					 SzcTokenMap(tokenType),
					 SzcTokenMap(tokenDiscrete),
					 cState );

			for ( int iState = 0; iState < cState; )
			{
				fprintf(_pfDsc, "\n\t\t\"%s\"",
						pbnoded->VzsrStates()[iState].Szc() );
				if ( ++iState < cState )
					fprintf( _pfDsc, "," );
			}
			fprintf( _pfDsc, "\n\t};\n" );
		}

		PTPOS pt = pbnode->PtPos();
		if ( pt._x != 0 || pt._y != 0 )
		{
			fprintf( _pfDsc, "\n\t%s = (%d, %d);",
					SzcTokenMap(tokenPosition),
					pt._x,
					pt._y );
		}

		PrintPropertyList( pbnode->LtProp() );

		fprintf( _pfDsc, "\n}\n");
	}
}

void MBNETDSC :: PrintPropertyList ( LTBNPROP & ltProp )
{
	for ( LTBNPROP::iterator ltit = ltProp.begin();
			ltit != ltProp.end();
			++ltit )
	{
		const PROPMBN & prop = *ltit;
		fprintf( _pfDsc, "\n\t%s = ",
				prop.ZsrPropType().Szc() );
		bool bArray = prop.FPropType() & fPropArray;
		if ( bArray )
			fprintf( _pfDsc, "[" );
		for ( int i = 0; i < prop.Count(); )
		{
			if ( prop.FPropType() & fPropChoice )
			{	
				GOBJMBN * pgmobj = Mpsymtbl().find( prop.ZsrPropType() );
				assert( pgmobj );
				GOBJPROPTYPE * pbnpt;
				DynCastThrow( pgmobj, pbnpt );
				fprintf( _pfDsc, "%s",
						 pbnpt->VzsrChoice()[(int) prop.Real(i)].Szc() );
			}
			else
			if ( prop.FPropType() & fPropString )
			{
				fprintf( _pfDsc, "\"%s\"",
						prop.Zsr(i).Szc() );
			}
			else
			{
				fprintf( _pfDsc, "%g",
						prop.Real(i) );
			}
			if ( ++i < prop.Count() )
				fprintf( _pfDsc, "," );
		}
		if ( bArray )
			fprintf( _pfDsc, "]" );
		fprintf( _pfDsc, ";" );
	}
}

//
//	Print network topology and probability distribution information for
//	all nodes.
//
//	Note that distributions are stored in the distribution map
//	most of the time.   However, during network expansion and inference
//	they are temporarly bound to their respective nodes (see 'BindDistributions').
//	For purposes of dumping the network at various stages, this logic
//	will print a bound distribution in preference to a mapped one.
//	If no distribution can be found, an error is generated as a comment into
//	the output file.
//
void MBNETDSC :: PrintTopologyAndDistributions()
{
	MBNET::ITER mbnit( self, GOBJMBN::EBNO_NODE );
	GOBJMBN * pgmobj;
	VTKNPD vtknpd;
	for ( ; pgmobj = *mbnit ; ++mbnit)
	{
		ZSREF zsrName = mbnit.ZsrCurrent();
		GNODEMBN * pbnode;
		DynCastThrow( pgmobj, pbnode );

		pbnode->GetVtknpd( vtknpd );

		GNODEMBND * pbnoded = dynamic_cast<GNODEMBND *>(pbnode);
		if ( pbnoded == NULL )
		{
			//  We don't have a clue as to how to print this node
			fprintf( _pfDsc,
					 "\n\n// Error: unable to print distribution for non-discrete node \'%s\'",
					 zsrName.Szc() );
			continue;
		}
		
		if ( pbnoded->BHasDist() )
		{
			//  This node already has a bound distribution
			//  Construct the token array describing the distribution
			ZSTR zsSig = vtknpd.ZstrSignature(1);
			fprintf( _pfDsc, "\n%s(%s)\t\n{",
					SzcTokenMap(tokenProbability),			
					zsSig.Szc() );
			PrintDistribution( *pbnoded, pbnoded->Bndist() );
			fprintf( _pfDsc,"\n}\n");
			continue;
		}

		//  Look the distribution up in the map
		//  Cons-up "p(<node>|"
		VTKNPD vtknpdNode;
		vtknpdNode.push_back( TKNPD(DTKN_PD) );
		vtknpdNode.push_back( TKNPD( pbnode->ZsrefName() ) );
		
		// Find the distribution(s) with that signature; print the first one
		int cFound = 0;
		for ( MPPD::iterator mppdit = Mppd().lower_bound( vtknpdNode );
			  mppdit != Mppd().end();
			  ++mppdit )
		{
			const VTKNPD & vtknpdMap = (*mppdit).first;
			if (   vtknpdMap.size() < 2
				|| vtknpdMap[0] != TKNPD(DTKN_PD)
				|| ! vtknpdMap[1].BStr() )
				break;
			SZC szcNode = vtknpdMap[1].Szc();
			if ( pbnode->ZsrefName().Szc() != szcNode )
				break;
			if ( cFound++ == 0 )
			{
				ZSTR zsTopol = vtknpdMap.ZstrSignature(1);
				fprintf( _pfDsc, "\n%s(%s)\t\n{",
						SzcTokenMap(tokenProbability),			
						zsTopol.Szc() );
				if ( vtknpd != vtknpdMap )
				{
					ZSTR zsSig = vtknpd.ZstrSignature();
					fprintf( _pfDsc,
							 "\n\n\t// Error: required distribution is %s",
							 zsSig.Szc() );
				}
				PrintDistribution( *pbnode, *(*mppdit).second );
				fprintf( _pfDsc,"\n}\n");
			}	
			else
			{
				ZSTR zsSig = vtknpd.ZstrSignature();
				fprintf( _pfDsc,
						 "\n\n// Warning: Superfluous distribution found for %s",
						 zsSig.Szc() );
			}
		}		

		if ( cFound > 0 )
			continue;

		//  Print a warning into the DSC output file
		ZSTR zsSigFull = vtknpd.ZstrSignature();
		fprintf( _pfDsc,
				 "\n\n// Error: Distribution missing for %s",
				 zsSigFull.Szc() );
		//  Construct the token array describing the distribution, but write
		//		it as empty.
		ZSTR zsSig = vtknpd.ZstrSignature(1);
		fprintf( _pfDsc, "\n%s(%s);",
				SzcTokenMap(tokenProbability),			
				zsSig.Szc() );
	}

	fflush( _pfDsc );
}

void MBNETDSC :: PrintDistribution ( GNODEMBN & gnode, BNDIST & bndist )
{
	BNDIST::EDIST edist = bndist.Edist();

	switch ( edist )
	{
		case BNDIST::ED_CI_MAX:
		case BNDIST::ED_CI_PLUS:
		{
			SZC szcFunc = SzcDist( edist );
			assert( szcFunc );
			fprintf( _pfDsc, "\n\tfunction = %s;", szcFunc );
			//  Fall through to handle as sparse
		}			
		case BNDIST::ED_SPARSE:
		{
			const MPCPDD & dmp = bndist.Mpcpdd();
			int cEntries = dmp.size();
			for ( MPCPDD::const_iterator dmit = dmp.begin();
				  dmit != dmp.end();
				  ++dmit)
			{
				const VIMD & vimd = (*dmit).first;
				const VLREAL & vr = (*dmit).second;
				fprintf( _pfDsc, "\n\t");
				if ( vimd.size() == 0 )
				{
					if ( cEntries > 1 )
						fprintf( _pfDsc, "%s = ", SzcTokenMap(tokenDefault) );
				}
				else
				{
					fprintf( _pfDsc, "(");
					for ( int i = 0; i < vimd.size() ; )
					{
						fprintf( _pfDsc, "%d", vimd[i] );
						if ( ++i < vimd.size() )
							fprintf( _pfDsc, ", " );
					}
					fprintf( _pfDsc, ") = ");
				}
				for ( int ir = 0; ir < vr.size(); )
				{					
					fprintf( _pfDsc, "%g", vr[ir] );
					if ( ++ir < vr.size() )
						fprintf( _pfDsc, ", " );
				}
				fprintf( _pfDsc, ";" );
			}
			break;
		}

		case BNDIST::ED_DENSE:
		{
			MDVCPD mdv = bndist.Mdvcpd();
			MDVCPD::Iterator itdd( mdv );
			int cDim = mdv.VimdDim().size();
			int cStates = mdv.VimdDim()[cDim -1];
			
			for ( int iState = 0; itdd.BNext(); iState++ )
			{
				const VIMD & vimd = itdd.Vitmd();
				if ( (iState % cStates) == 0 )
				{
					//  Start a new row
					fprintf( _pfDsc, "\n\t" );
					//  Prefix with parent instantations if necessary
					int cItems = vimd.size() - 1;
					if ( cItems )
					{
						fprintf( _pfDsc, "(" );
						for ( int i = 0; i < cItems ; )
						{
							fprintf( _pfDsc, "%d", vimd[i] );
							if ( ++i < cItems )
								fprintf( _pfDsc, ", " );
						}
						fprintf( _pfDsc, ") = ");
					}
				}
				REAL & r = itdd.Next();
				fprintf( _pfDsc, "%g%c ", r, ((iState+1) % cStates) ? ',' : ';'  );
			}

			break;
		}
		default:				
			THROW_ASSERT(EC_NYI, "PrintDistribution only implemented for sparse arrays");
			break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\mbnet.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       mbnet.cpp
//
//--------------------------------------------------------------------------

//
//	mbnet.cpp:  Belief network model member functions
//

#include <basetsd.h>
#include "basics.h"
#include "algos.h"
#include "gmprop.h"
#include "gmobj.h"
#include "cliqset.h"
#include "clique.h"
#include "expand.h"

MBNET :: MBNET ()
	:_inmFree(0),
	_iInferEngID(0)
{
}



MBNET :: ~ MBNET ()
{
	PopModifierStack( true );	//  Clear all modifiers from the network

	//  Clear the node-index-to-name information
	_inmFree = 0;
	_vzsrNames.clear();
}

//
//  Clone this belief network from another.  Note that the contents
//  of the modifier stack (inference engines, expanders, etc.) are
//	NOT cloned.
//
void MBNET :: Clone ( MODEL & model )
{
	//  This must be a truly empty structure
	ASSERT_THROW( _vpModifiers.size() == 0 && _vzsrNames.size() == 0,
				 EC_INVALID_CLONE,
				 "cannot clone into non-empty structure" );

	MODEL::Clone( model );
	MBNET * pmbnet;
	DynCastThrow( & model, pmbnet );
	MBNET & mbnet = *pmbnet;

	{
		// Build the name table by iterating over the contents and
		//		allocating a slot for each node
		GELEMLNK * pgelm;
		MODELENUM mdlenumNode( mbnet );
		while ( pgelm = mdlenumNode.PlnkelNext() )
		{	
			//  Check that it's a node (not an edge)
			if ( ! pgelm->BIsEType( GELEM::EGELM_NODE ) )
				continue;
			GOBJMBN * pgobjmbn;
			DynCastThrow( pgelm, pgobjmbn );
			_vzsrNames.push_back( pgobjmbn->ZsrefName() );
		}
		_inmFree = _vzsrNames.size();
	}

	//  Clone the distribution map
	_mppd.Clone( _mpsymtbl, mbnet._mppd ) ;

	//  Check the topology if it's supposed to be present
#ifdef _DEBUG
	if ( mbnet.BFlag( EIBF_Topology ) )
		VerifyTopology();
#endif
}

//
//	Iterate over the distributions, matching them to the nodes they belong to.
//
void MBNET :: VerifyTopology ()
{
	for ( MPPD::iterator itpd = Mppd().begin();
		  itpd != Mppd().end();
		  itpd++ )
	{
		const VTKNPD & vtknpd = (*itpd).first;
		const BNDIST * pbndist = (*itpd).second;

		// Guarantee that the descriptor is of the form "p(X|...)"
		if (   vtknpd.size() < 2
			|| vtknpd[0] != TKNPD(DTKN_PD)
			|| ! vtknpd[1].BStr() )
			throw GMException( EC_INV_PD, "invalid token descriptor on PD");

		// Get the name of the node whose distribution this is
		SZC szc = vtknpd[1].Szc();
		assert( szc ) ;
		// Find that named thing in the graph
		GOBJMBN * pbnobj = Mpsymtbl().find( szc );
		assert( pbnobj && pbnobj->EType() == GOBJMBN::EBNO_NODE );

		// Guarantee that it's a node
		GNODEMBN * pgndbn = dynamic_cast<GNODEMBN *> (pbnobj);
		ASSERT_THROW( pgndbn, EC_INV_PD, "token on PD references non-node");

		//  Verify the node's distribution
		if ( ! pgndbn->BMatchTopology( *this, vtknpd ) )
		{
			throw GMException( EC_TOPOLOGY_MISMATCH,
								"topology mismatch between PD and network");
		}
	}
}

MBNET_MODIFIER * MBNET :: PModifierStackTop ()
{
	return _vpModifiers.size() > 0
		 ? _vpModifiers[ _vpModifiers.size() - 1 ]
		 : NULL;
}

void MBNET :: PushModifierStack ( MBNET_MODIFIER * pmodf )
{
	assert( pmodf );
	pmodf->Create();
	_vpModifiers.push_back( pmodf );
}

void MBNET :: PopModifierStack ( bool bAll )
{
	int iPop = _vpModifiers.size();
	while ( iPop > 0 )
	{
		MBNET_MODIFIER * pmodf = _vpModifiers[ --iPop ];
		assert ( pmodf );
		//  NOTE:  Deleting the object should be all that's necessary;
		//		object's destructor should call its Destroy() function.
		delete pmodf;
		if ( ! bAll )
			break;
	}
	if ( iPop == 0 )
		_vpModifiers.clear();
	else
		_vpModifiers.resize(iPop);
}

//  Find the named object by index
GOBJMBN * MBNET :: PgobjFindByIndex ( int inm )
{
	ZSREF zsMt;
	if (   inm >= _vzsrNames.size()
		|| _vzsrNames[inm] == zsMt )
		return NULL;
	return Mpsymtbl().find( _vzsrNames[inm] );	
}

int MBNET :: INameIndex ( ZSREF zsr )
{
	return ifind( _vzsrNames, zsr );
}

int MBNET :: INameIndex ( const GOBJMBN * pgobj )
{
	return INameIndex( pgobj->ZsrefName() );
}

int MBNET :: CreateNameIndex ( const GOBJMBN * pgobj )
{
	int ind = -1;
	if ( _inmFree >= _vzsrNames.size() )
	{	
		// No free slots; grow the array
		ind = _vzsrNames.size();
		_vzsrNames.push_back( pgobj->ZsrefName() );		
		_inmFree = _vzsrNames.size();
	}
	else
	{
		// Use the given free slot, find the next
		_vzsrNames[ind = _inmFree] = pgobj->ZsrefName();
		ZSREF zsMt;
		for ( ; _inmFree < _vzsrNames.size() ; _inmFree++ )
		{
			if ( zsMt == _vzsrNames[_inmFree] )
				break;
		}
	}
	return ind;
}

void MBNET :: DeleteNameIndex ( int inm )
{
	ASSERT_THROW( inm < _vzsrNames.size(),
				  EC_INTERNAL_ERROR,
				  "MBNET name index out of range" );

	_vzsrNames[inm] = ZSREF();
	if ( inm < _inmFree )
		_inmFree = inm;
}

void MBNET :: DeleteNameIndex ( const GOBJMBN * pgobj )
{
	int inm = INameIndex( pgobj );
	if ( inm >= 0 )
		DeleteNameIndex(inm);
}


//	Add a named object to the graph and symbol table
void MBNET :: AddElem ( SZC szcName, GOBJMBN * pgelm )
{
	if ( szcName == NULL || ::strlen(szcName) == 0 )
	{
		MODEL::AddElem( pgelm );	// empty name
	}
	else
	{
		MODEL::AddElem( szcName, pgelm );
		assert( INameIndex( pgelm ) < 0 );	// guarantee no duplicates
		CreateNameIndex( pgelm );
	}
}

void MBNET :: DeleteElem ( GOBJMBN * pgobj )
{
	DeleteNameIndex( pgobj );
	MODEL::DeleteElem( pgobj );
}

/*

	Iterator has moved into the MODEL class... I've left the code here
	in case MBNET needs its own iterator. (Max, 05/12/97)

MBNET::ITER :: ITER ( MBNET & bnet, GOBJMBN::EBNOBJ eType )
	: _eType(eType),
	_bnet(bnet)
{
	Reset();
}

void MBNET::ITER :: Reset ()
{
	_pCurrent = NULL;
	_itsym = _bnet.Mpsymtbl().begin();
	BNext();
}

bool MBNET::ITER :: BNext ()
{
	while ( _itsym != _bnet.Mpsymtbl().end() )
	{
		_pCurrent = (*_itsym).second.Pobj();
		_zsrCurrent = (*_itsym).first;
		_itsym++;
		if ( _pCurrent->EType() == _eType )
			return true;
	}		
	_pCurrent = NULL;
	return false;
}

*/


void MBNET :: CreateTopology ()
{
	if ( BFlag( EIBF_Topology ) )
		return;

	//  Walk the map of distributions.  For each one, extract the node
	//  name and find it.  Then add arcs for each parent.

#ifdef _DEBUG
	UINT iCycleMax = 2;
#else
	UINT iCycleMax = 1;
#endif
	UINT iIter = 0;
	for ( UINT iCycle = 0 ; iCycle < iCycleMax ; iCycle++ )
	{
		for ( MPPD::iterator itpd = Mppd().begin();
			  itpd != Mppd().end();
			  itpd++, iIter++ )
		{
			const VTKNPD & vtknpd = (*itpd).first;
			const BNDIST * pbndist = (*itpd).second;
			// Guarantee that the descriptor is of the form "p(X|...)"
			if (   vtknpd.size() < 2
				|| vtknpd[0] != TKNPD(DTKN_PD)
				|| ! vtknpd[1].BStr() )
				throw GMException( EC_INV_PD, "invalid token descriptor on PD");

			// Get the name of the node whose distribution this is
			SZC szcChild = vtknpd[1].Szc();
			assert( szcChild ) ;
			// Find that named thing in the graph
			GOBJMBN * pbnobjChild = Mpsymtbl().find( szcChild );
			assert( pbnobjChild && pbnobjChild->EType() == GOBJMBN::EBNO_NODE );
			// Guarantee that it's a node
			GNODEMBN * pgndbnChild = dynamic_cast<GNODEMBN *> (pbnobjChild);
			ASSERT_THROW( pgndbnChild, EC_INV_PD, "token on PD references non-node");

			UINT cParents = 0;
			UINT cChildren = pgndbnChild->CChild();
			for ( int i = 2; i < vtknpd.size(); i++ )
			{
				if ( ! vtknpd[i].BStr() )
					continue;
				SZC szcParent = vtknpd[i].Szc();
				assert( szcParent) ;
				GOBJMBN * pbnobjParent = Mpsymtbl().find( szcParent );
				assert( pbnobjParent && pbnobjParent->EType() == GOBJMBN::EBNO_NODE );
				GNODEMBN * pgndbnParent = (GNODEMBN *) pbnobjParent;
				UINT cPrChildren = pgndbnParent->CChild();
				if ( iCycle == 0 )
				{
					AddElem( new GEDGEMBN_PROB( pgndbnParent, pgndbnChild ) );
				}

				cParents++;

				if ( iCycle == 0 )
				{
					UINT cChNew = pgndbnChild->CChild();
					UINT cPrNew = pgndbnChild->CParent();
					UINT cPrChNew = pgndbnParent->CChild();
					assert( cPrChNew = cPrChildren + 1 );
					assert( cChildren == cChNew );
				}
			}
			if ( iCycle )
			{
				UINT cPrNew = pgndbnChild->CParent();
				assert( cParents == cPrNew );
			}

			if ( iCycle == 0 )
			{
#ifdef _DEBUG
				if ( ! pgndbnChild->BMatchTopology( *this, vtknpd ) )
				{
					throw GMException( EC_TOPOLOGY_MISMATCH,
										"topology mismatch between PD and network");
				}
#endif
			}
		}
	}

	BSetBFlag( EIBF_Topology );
}

DEFINEVP(GEDGEMBN);

void MBNET :: DestroyTopology ( bool bDirectedOnly )
{
	// Size up an array to hold pointers to all the edges
	VPGEDGEMBN vpgedge;
	int cItem = Grph().Chn().Count();
	vpgedge.resize(cItem);

	//  Find all the arcs/edges
	int iItem = 0;
	GELEMLNK * pgelm;
	MODELENUM mdlenum( self );
	while ( pgelm = mdlenum.PlnkelNext() )
	{	
		//  Check that it's an edge
		if ( ! pgelm->BIsEType( GELEM::EGELM_EDGE ) )
			continue;
			//  Check that it's a directed probabilistic arc
		if ( bDirectedOnly && pgelm->EType() != GEDGEMBN::ETPROB )
			continue;
		GEDGEMBN * pgedge;
		DynCastThrow( pgelm, pgedge );
		vpgedge[iItem++] = pgedge;				
	}

	//  Delete all the accumulated edges
	for ( int i = 0; i < iItem; )
	{
		GEDGEMBN * pgedge = vpgedge[i++];
		delete pgedge;
	}

	assert( Grph().Chn().Count() + iItem == cItem );

	BSetBFlag( EIBF_Topology, false );
}

//
//	Bind distributions to nodes.  If they're already bound, exit.
//	If the node has a distribution already, leave it.
//
void MBNET :: BindDistributions ( bool bBind )
{
	bool bDist = BFlag( EIBF_Distributions );
	if ( ! (bDist ^ bBind) )
		return;

	ITER itnd( self, GOBJMBN::EBNO_NODE );
	for ( ; *itnd ; itnd++ )
	{
		GNODEMBND * pgndd = dynamic_cast<GNODEMBND *>(*itnd);
		if ( pgndd == NULL )
			continue;

		if ( ! bBind )
		{
			pgndd->ClearDist();
		}
		else
		if ( ! pgndd->BHasDist() )
		{
			pgndd->SetDist( self );				
		}
	}
	BSetBFlag( EIBF_Distributions, bBind );
}

void MBNET :: ClearNodeMarks ()
{
	ITER itnd( self, GOBJMBN::EBNO_NODE );
	for ( ; *itnd ; itnd++ )
	{
		GNODEMBN * pgndbn = NULL;
		DynCastThrow( *itnd, pgndbn );
		pgndbn->IMark() = 0;
	}
}

void MBNET :: TopSortNodes ()
{
	ClearNodeMarks();

	ITER itnd( self, GOBJMBN::EBNO_NODE );
	for ( ; *itnd ; itnd++ )
	{
		GNODEMBN * pgndbn = NULL;
		DynCastThrow( *itnd, pgndbn );
		pgndbn->Visit();
	}

	itnd.Reset();
	for ( ; *itnd ; itnd++ )
	{
		GNODEMBN * pgndbn = NULL;
		DynCastThrow( *itnd, pgndbn );
		pgndbn->ITopLevel() = pgndbn->IMark();
	}
}

void MBNET :: Dump ()
{
	TopSortNodes();

	UINT iEntry = 0;
	for ( MPSYMTBL::iterator itsym = Mpsymtbl().begin();
		  itsym != Mpsymtbl().end();
		  itsym++ )
	{
		GOBJMBN * pbnobj = (*itsym).second.Pobj();
		if ( pbnobj->EType() != GOBJMBN::EBNO_NODE )
			continue;	// It's not a node

		GNODEMBN * pgndbn;
		DynCastThrow(pbnobj,pgndbn);
		int iNode = INameIndex( pbnobj );
		assert( iNode == INameIndex( pbnobj->ZsrefName() ) );
		cout << "\n\tEntry "
			  << iEntry++
			  << ", inode "
			  << iNode
			  << " ";
		pgndbn->Dump();
	}
}

GOBJMBN_INFER_ENGINE * MBNET :: PInferEngine ()
{
	GOBJMBN_INFER_ENGINE * pInferEng = NULL;
	for ( int iMod = _vpModifiers.size(); --iMod >= 0; )
	{
		MBNET_MODIFIER * pmodf = _vpModifiers[iMod];
		pInferEng = dynamic_cast<GOBJMBN_INFER_ENGINE *> ( pmodf );
		if ( pInferEng )	
			break;
	}	
	return pInferEng;
}

void MBNET :: ExpandCI ()
{
	PushModifierStack( new GOBJMBN_MBNET_EXPANDER( self ) );
}

void MBNET :: UnexpandCI ()
{
	MBNET_MODIFIER * pmodf = PModifierStackTop();
	if ( pmodf == NULL )
		return;
	if ( pmodf->EType() == GOBJMBN::EBNO_MBNET_EXPANDER )
		PopModifierStack();
}

//  Return true if an edge is allowed between these two nodes
bool MBNET :: BAcyclicEdge ( GNODEMBN * pgndSource, GNODEMBN * pgndSink )
{
	ClearNodeMarks();
	pgndSink->Visit( false );
	return pgndSource->IMark() == 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\mscver.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       mscver.h
//
//--------------------------------------------------------------------------

#ifndef _MSCVER_H_
#define _MSCVER_H_

#if _MSC_VER >= 1100 
	#define USE_STD_NAMESPACE using namespace std
#else
	#define USE_STD_NAMESPACE 
#endif

// disable "'this' : used in base member initializer list"
#pragma warning ( disable : 4355 )
// disable "string too long - truncated to 255 characters in the debug information"
#pragma warning ( disable : 4786 )

//MSRDEVBUG: Caused by 'valarray': revisit these.
// disable "unsafe use of type 'bool' in operation"
#pragma warning ( disable : 4804 )	
// disable "forcing value to bool 'true' or 'false'"
#pragma warning ( disable : 4800 )	

// disable "identifier truncated"
#pragma warning ( disable : 4786 )	

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\ntree.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       ntree.cpp
//
//--------------------------------------------------------------------------

//
//  NTREE.CPP
//
#include <algorithm>
#include <functional>

#include "ntree.h"
#include "glnkenum.h"

NTELEM :: NTELEM ()
	: _pnteParent(NULL),
	_pnteChild(NULL)
{
}

NTELEM :: ~ NTELEM ()
{
	Orphan();
	NTELEM * pnteChild = NULL;
	while ( pnteChild = _pnteChild )
	{
		delete pnteChild;
	}
}

//  Adopt (link) a child
void NTELEM :: Adopt ( NTELEM * pnteChild, bool bSort )
{
	pnteChild->Orphan();

	NTELEM * pNextChild = _pnteChild ;
	bool bFoundHigher = true ;

	if ( pNextChild && bSort )
	{
		//  Position among the children based upon sort order.
		GLNKENUM<NTELEM,false> glnkEnum( *pNextChild );
		bFoundHigher = false;
		while ( pNextChild = glnkEnum.PlnkelNext() )
		{
			if ( pnteChild->ICompare( pNextChild ) < 0 )
				break ;
		}
		//  If we didn't find a higher child, link *this
		//  such that it points to the first child.
		if ( ! (bFoundHigher = pNextChild != NULL) )
			pNextChild = _pnteChild ;
	}

	//  If there is another child, insert this in front of it.
	if ( pNextChild )
		pnteChild->ChnSib().Link( pNextChild ) ;

	//  If this is the first child, or if this new child
	//      sorted low, use it as the anchor.
	if ( _pnteChild == NULL || pnteChild->ICompare( _pnteChild ) < 0 )
		_pnteChild = pnteChild;

	_pnteChild->_pnteParent = this ;
}

//  Disown (release) a child
void NTELEM :: Disown ( NTELEM * pnteChild ) 
{
	if ( _pnteChild == pnteChild )
	{
		_pnteChild = pnteChild->ChnSib().PgelemNext() ;
		if ( _pnteChild == pnteChild )
			_pnteChild = NULL ;	 // There goes the last child
	}
	pnteChild->ChnSib().Unlink() ;
	pnteChild->_pnteParent = NULL ;
}

//  Become an orphan
void NTELEM :: Orphan ()
{
	if ( _pnteParent )
		_pnteParent->Disown( this );
	_pnteParent = NULL;
}

INT NTELEM :: SiblingCount () 
{
	return ChnSib().Count();
}

INT NTELEM :: ChildCount () 
{
	if ( _pnteChild == NULL )
		return 0;
	return _pnteChild->ChnSib().Count();
}

NTELEM * NTELEM :: PnteChild ( INT index )
{
	if ( _pnteChild == NULL )
		return NULL ;

	GLNKENUM<NTELEM,false> glnkEnum( *_pnteChild );
	int i = 0 ;
	do
	{
		if ( i++ == index )
			return glnkEnum.PlnkelCurrent() ;
	} while ( glnkEnum.PlnkelNext() ) ;
	return NULL ;
}

bool NTELEM :: BIsChild ( NTELEM * pnte ) 
{
	if ( _pnteChild == NULL )
		return false ;

	GLNKENUM<NTELEM,false> glnkEnum( *_pnteChild );
	NTELEM * pnteCurr = NULL ;
	do
	{
		//  If this is it, we're done
		if ( (pnteCurr = glnkEnum.PlnkelCurrent()) == pnte )
			return true ;
		//  If current object has a child, search its siblings
		if ( pnteCurr->_pnteChild && pnteCurr->BIsChild( pnte) )
			return true ;
		//  On to the next object pointer
	}
	while ( glnkEnum.PlnkelNext() ) ;
	return false ;
}

DEFINEVP(NTELEM);

static NTELEM::SRTFNC srtpntelem;

void NTELEM :: ReorderChildren ( SRTFNC & fSortRoutine ) 
{
	INT cChildren = ChildCount() ;
	if ( cChildren == 0 )
		return;

	//  Enumerate the children into an array, disown them, sort the
	//  array and re-adopt them in the new order.

	VPNTELEM rgpnteChild;
	rgpnteChild.resize(cChildren);
	GLNKENUM<NTELEM,false> glnkEnum( *_pnteChild );

	for ( int iChild  = 0 ; rgpnteChild[iChild++] = glnkEnum.PlnkelNext() ; );

	while ( _pnteChild )
	{
		Disown( _pnteChild ) ;
	}

	sort( rgpnteChild.begin(), rgpnteChild.end(), fSortRoutine );

	//  Re-adopt the children in the given order
	for ( iChild = 0 ; iChild < rgpnteChild.size() ; )
	{
		Adopt( rgpnteChild[iChild++] );
	}
}

NTREE :: NTREE ()
{
}

NTREE :: ~ NTREE ()
{
}

// End of NTREE.CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\model.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       model.cpp
//
//--------------------------------------------------------------------------

//
//	MODEL.CPP
//

#include <basetsd.h>
#include <string.h>
#include "basics.h"
#include "algos.h"
#include "gmprop.h"
#include "model.h"
#include "gmobj.h"

struct EC_STR
{
	ECGM _ec;
	SZC _szc;
};
static EC_STR vEcToStr [] =
{
#define GMERRORSTR
#include "errordef.h"
	{ EC_OK, "no error" }
};

SZC MODEL :: SzcFromEc ( ECGM ec )
{
	int cEc = UBOUND(vEcToStr);
	for ( int i = 0; i < cEc; i++ )
	{
		if ( ec == vEcToStr[i]._ec )
			return vEcToStr[i]._szc;
	}
	return NULL;
}


// Iterator class for MODELs

MODEL::ITER::ITER(MODEL& model, GOBJMBN::EBNOBJ eType)
	:	_eType(eType),
		_model(model)
{
	Reset();
}


MODEL::ITER::ITER(MODEL& model) : _model(model)
{
	
}

void MODEL::ITER::CreateNodeIterator()
{
	_eType	=  GOBJMBN::EBNO_NODE;
	Reset();
}

void MODEL::ITER :: Reset ()
{
	_pCurrent	= NULL;
	_itsym		= _model.Mpsymtbl().begin();
	BNext();
}

bool MODEL::ITER :: BNext ()
{
	while ( _itsym != _model.Mpsymtbl().end() )
	{
		_pCurrent	= (*_itsym).second.Pobj();
		_zsrCurrent = (*_itsym).first;
		_itsym++;

		if ( _pCurrent->EType() == _eType )
			return true;
	}		
	_pCurrent = NULL;
	return false;
}



///////////////////////////////////////////////////////////////////////////
//	MODEL naming commentary.
//
//	Symbolic names in a belief network come in two types: names which users
//	can enter (or edit into a DSC file) and those which they cannot.
//
//	The basic (user-definable) symbolic name follows exactly the rules of
//	standard 'C', except that periods ('.') are allowed inside a name.
//
//	There is a need for generation of names which are clearly distinguishable
//	from user-definable names; these are called "internal" names.  The only
//	difference is that the legal character set is extended to include the '$'
//	(dollar sign) character as an alphabetic character (i.e., it can be the
//	first character in a name).
//
///////////////////////////////////////////////////////////////////////////
//  Return true if the character is legal in a name
bool MODEL :: BChLegal ( char ch, ECHNAME echnm, bool bInternal )
{	
	bool bOther = bInternal && ch == ChInternal();
	bool bOkForC = echnm == ECHNM_First
				? __iscsymf(ch)
				: __iscsym(ch) || (echnm == ECHNM_Middle && ch == '.');
	return bOther || bOkForC;
}

//  Return true if the name is legal
bool MODEL :: BSzLegal ( SZC szcName, bool bInternal )
{	
	for ( int i = 0; szcName[i]; i++ )
	{
		ECHNAME echnm = i == 0
					? ECHNM_First
					: (szcName[i+1] ? ECHNM_Middle : ECHNM_Last);
		if ( ! BChLegal( szcName[i], echnm, bInternal ) )
			return false;
	}
	return true;
}


MODEL :: MODEL ()
	: _pgrph(NULL),
	_rVersion(-1.0)
{
	//  Allocate the GRPH graph object
	SetPgraph(new GRPH);
	assert( _pgrph );
//
//	Define the table of known (early-defined) bit flags in this scope
//
#define MBN_GEN_BFLAGS_TABLE szcBitFlagNames
//	Include the header to generate the strings
#include "mbnflags.h"

	//  Define the table of known bit flags.
	for ( int i = 0; szcBitFlagNames[i]; i++ )
	{
		//  Note: this automatically interns the names into the symbol table
		IBFLAG ibf = Mpsymtbl().IAddBitFlag( szcBitFlagNames[i] );
	}
}

MODEL :: ~ MODEL ()
{
	//  We must clear the graph and symbol table at this point, because their
	//  elements interreference via the names (ZSREFs) and pointers (REFPOBJs).
	//  The symbol table is cleared first, so that no stray references to GOBJMBNs
	//  exist when the graph object is nuked.  Then the graph is cleared, so
	//  that embedded references to strings interned in the symbol table's string
	//	table will be removed.

	Mpsymtbl().clear();

	//  Delete the graph
	SetPgraph(NULL);
}

void MODEL :: SetPgraph ( GRPH * pgrph )
{
	delete _pgrph;
	_pgrph = pgrph;
}

//	Add an unnamed element to the graph
void MODEL :: AddElem ( GELEMLNK * pgelm )
{
	ASSERT_THROW( pgelm, EC_NULLP, "null ptr passed to MODEL::AddElem()" );
	Pgraph()->AddElem( *pgelm );
}


	//  Test the name for duplicate; add if not, otherwise return false
bool MODEL :: BAddElem ( SZC szcName, GOBJMBN * pgobj )
{
	if ( ::strlen( szcName ) == 0 )
		return false;	//  Name missing
	if ( Mpsymtbl().find( szcName ) )
		return false;  // duplicate name
	AddElem( szcName, pgobj );
	return true;
}

//	Add a (possibly) named object to the graph and symbol table
void MODEL :: AddElem ( SZC szcName, GOBJMBN * pgelm )
{
	if ( szcName != NULL && ::strlen(szcName) != 0 )
	{
		if ( Mpsymtbl().find( szcName ) )
			throw GMException( EC_DUPLICATE_NAME, "attempt to add duplicate name to MBNET" );

		Mpsymtbl().add( szcName, pgelm );
	}
	AddElem( pgelm );
}

void MODEL :: DeleteElem ( GOBJMBN * pgobj )
{
	if ( pgobj->ZsrefName().Zstr().length() > 0 )
		Mpsymtbl().remove( pgobj->ZsrefName() );
	else
		DeleteElem( (GELEMLNK *) pgobj );
}

void MODEL :: DeleteElem ( GELEMLNK * pgelem )
{
	delete pgelem;
}

void MODEL :: Clone ( MODEL & model )
{
	ASSERT_THROW( _pgrph->ChnColl().PgelemNext() == NULL,
				EC_INVALID_CLONE,
				"cannot clone into non-empty structure" );

	//  Clone the descriptive information
	_rVersion = model._rVersion;
	_zsFormat = model._zsFormat;
	_zsCreator = model._zsCreator;
	_zsNetworkID = model._zsNetworkID;

	//  Clone the symbol table
	_mpsymtbl.Clone( model._mpsymtbl );
	//  Copy the network bit flags array
	_vFlags = model._vFlags;

	//
	//  Clone the actual contents of the network, object by object
	//
	{
		//  Create a map to correlate old object pointers to new object pointers
		typedef map<GOBJMBN *, GOBJMBN *, less<GOBJMBN *> > MPPOBJPOBJ;
		MPPOBJPOBJ mppobjpobj;

		//  Add the property types first, then all the node-like things
		GELEMLNK * pgelm;
		MODELENUM mdlenumNode( model );
		for ( int icycle = 0; icycle < 2; icycle++ )
		{
			mdlenumNode.Reset(model.Grph());
			while ( pgelm = mdlenumNode.PlnkelNext() )
			{	
				//  Check that it's a node (not an edge)
				if ( ! pgelm->BIsEType( GELEM::EGELM_NODE ) )
					continue;

				GOBJMBN * pgobjmbn;
				GOBJMBN * pgobjmbnNew = NULL;
				DynCastThrow( pgelm, pgobjmbn );

				//  Clone property types on the first pass, all other nodeish things
				//		on the second.
				if ( (icycle == 0) ^ (pgelm->EType() == GOBJMBN::EBNO_PROP_TYPE) )
					continue;

				pgobjmbnNew = pgobjmbn->CloneNew( model, self );
				//  If the object was cloned or allowed itself to be cloned,
				//		add it
				if ( pgobjmbnNew )
				{
					assert( pgobjmbnNew->EType() == pgobjmbn->EType() );
					mppobjpobj[ pgobjmbn ] = pgobjmbnNew;
					//  Add the object as named or unnamed
					AddElem( pgobjmbnNew->ZsrefName(), pgobjmbnNew );
				}
			}
		}
		//  Add all the edge-like things
		MODELENUM mdlenumEdge( model );
		while ( pgelm = mdlenumEdge.PlnkelNext() )
		{	
			//  Check that it's a edge (not a node)
			if ( ! pgelm->BIsEType( GELEM::EGELM_EDGE ) )
				continue;
			GEDGEMBN * pgedge;
			DynCastThrow( pgelm, pgedge );

			GOBJMBN * pgobjmbnSource = pgedge->PobjSource();
			GOBJMBN * pgobjmbnSink = pgedge->PobjSink();
			assert( pgobjmbnSource && pgobjmbnSink );
			GOBJMBN * pgobjmbnSourceNew = mppobjpobj[  pgobjmbnSource ];
			GOBJMBN * pgobjmbnSinkNew = mppobjpobj[  pgobjmbnSink ];
			assert( pgobjmbnSourceNew && pgobjmbnSinkNew );
			GEDGEMBN * pgedgeNew = pgedge->CloneNew( model,
													 self,
													 pgobjmbnSourceNew,
													 pgobjmbnSinkNew );
			assert( pgedgeNew );
			AddElem( pgedgeNew );
		}
	}		

	//	Clone the network property list
	_ltProp.Clone( self, model, model._ltProp );
}

GOBJMBN * MODEL :: PgobjFind ( SZC szcName )
{
	return Mpsymtbl().find(szcName);
}



void MPSYMTBL :: Clone ( const MPSYMTBL & mpsymtbl )
{
	//  Clone all the interned strings
	_stszstr.Clone( mpsymtbl._stszstr );
	//  Clone the array of bit flag names
	CloneVzsref( mpsymtbl, mpsymtbl._mpzsrbit, _mpzsrbit );
	//  All other symbol entries must be created from above		
}

void MPSYMTBL :: CloneVzsref (
	const MPSYMTBL & mpsymtbl,
	const VZSREF & vzsrSource,
	VZSREF & vzsrTarget )
{
	vzsrTarget.resize( vzsrSource.size() );
	for ( int i = 0; i < vzsrTarget.size(); i++ )
	{
		SZC szc = vzsrSource[i].Szc();
		vzsrTarget[i] = intern(szc);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\ntree.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       ntree.h
//
//--------------------------------------------------------------------------

//
//  NTREE.H
//

#if !defined(_NTREE_H_)
#define _NTREE_H_

#include <functional>
#include "gelem.h"
#include "glnkenum.h"

class NTELEM;
class NTREE;

class NTELEM : public GLNKEL
{
  public:
	//  Internal class for chains (doubly-linked lists) of tree nodes
	typedef XCHN<NTELEM> CHN;
	//  Sort helper "less" binary function class
	class SRTFNC : public binary_function<const NTELEM *, const NTELEM *, bool>
	{	
	  public:
		virtual bool operator () (const NTELEM * pa, const NTELEM * pb) const
			{	return pa->ICompare( pb ) < 0;	}
	};
	static SRTFNC srtpntelem;

  public:
	NTELEM ();
	virtual ~ NTELEM ();

	//  Accessor for chain of siblings
	CHN & ChnSib ()
		{ return (CHN &) Chn() ; }

	virtual INT EType () const
		{ return _pnteChild ? EGELM_BRANCH : EGELM_LEAF ; }

	//  Adopt (link) a child
	void Adopt ( NTELEM * pnteChild, bool bSort = false ) ;
	//      Disown (release) a child
	void Disown ( NTELEM * pnteChild ) ;
	//      Become an orphan
	void Orphan () ;

	INT ChildCount () ;
	INT SiblingCount ();
	NTELEM * PnteChild ( INT index ) ;
	NTELEM * PnteParent () 
		{ return _pnteParent; }
	NTELEM * PnteChild () 
		{ return _pnteChild; }
	bool BIsChild ( NTELEM * pnte ) ;

	//  Return the sort value of *this versus another COBJ
	virtual INT ICompare ( const NTELEM * pnteOther ) const = 0;

	void ReorderChildren ( SRTFNC & fSortRoutine = srtpntelem ) ;

  protected:
	NTELEM * _pnteParent;	// Pointer to single parent (or NULL)
	NTELEM * _pnteChild;	// Pointer to one child (or NULL)

	HIDE_UNSAFE(NTELEM);
};


class NTREE : public NTELEM
{
  public:
	NTREE ();
	virtual ~ NTREE ();

	virtual INT EType () const
		{ return EGELM_TREE ; }

	HIDE_UNSAFE(NTREE);
};

template <class T, bool bAnchor> 
class NTENUM : public GLNKENUM<T,bAnchor>
{
 public:
	NTENUM (const T & ntel, bool bIsAnchor = bAnchor, bool iDir = true)
		: GLNKENUM<T,bAnchor>( ntel, bIsAnchor, iDir )
		{}
	//  Position to the next pointer
	T * PntelNext ()
		{ return (T *) GLNKENUM<T,bAnchor>::PlnkelNext() ; }
	//  Return the current object pointer
	T * PntelCurrent()
		{ return (T *) _plnkelNext ; }
	//  Set the enumerator to have a new base
	void Reset ( const T & ntel, int iDir = -1 )
		{ GLNKENUM<T,bAnchor>::Reset( ntel, iDir ) ; }
};

// Template for generating nested tree motion accessor class
template<class T>
class TWALKER
{
  public:
	TWALKER ( T & t )
		: _pt(&t) 
		{}
	void Reset ( T & t )
		{ _pt = &t; }
	T * PlnkchnPrev () 
  		{ return  PdynCast( _pt->Chn().PgelemPrev(), _pt ); }
	T * PlnkchnNext () 
  		{ return  PdynCast( _pt->Chn().PgelemNext(), _pt ); }
	T * Pparent ()
  		{ return  PdynCast( _pt->PnteParent(), _pt ); }
	T * Pchild ()
  		{ return  PdynCast( _pt->PnteChild(), _pt ); }
  protected:
	T * _pt;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\model.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       model.h
//
//--------------------------------------------------------------------------

//
//	MODEL.H
//	
#ifndef _MODEL_H_
#define _MODEL_H_

#include "gelem.h"			//  Graph object classes
#include "glnkenum.h"
#include "symtmbn.h"		//	Symbol table and string declarations
#include "gelmwalk.h"		//	Graph search algorithms
#include "gmprop.h"

class MODEL
{
  public:

	// Nested iterator class based on symbol table iteration.
	class ITER
	{
	  public:

		ITER ( MODEL& model, GOBJMBN::EBNOBJ eType );
		ITER ( MODEL& model );

		void	CreateNodeIterator();
		
		bool operator++ (int i)
			{ return BNext() ; }
		bool operator++ ()
			{ return BNext() ; }
		GOBJMBN * operator -> ()
			{ return _pCurrent; }
		GOBJMBN * operator * ()
			{ return _pCurrent; }
		ZSREF ZsrCurrent ()
			{ return _zsrCurrent; }
		void Reset ();

	  protected:	

		MPSYMTBL::iterator	_itsym;
		GOBJMBN::EBNOBJ		_eType;
		GOBJMBN*			_pCurrent;
		ZSREF				_zsrCurrent;
	  protected:

		bool				BNext();
		MODEL&				_model;
	};


  public:
	MODEL ();
	virtual ~ MODEL ();

	GRPH * Pgraph () const
		{ return _pgrph;	}
	GRPH & Grph () const
	{ 
		assert( _pgrph );
		return *_pgrph; 
	}

	//  Object addition and deletion functions
		//	Add and delete generic unnamed elements
	virtual void AddElem ( GELEMLNK * pgelm );
	virtual void DeleteElem ( GELEMLNK * pgelem );
		//  Add and delete named elements
		//  Test the name for duplicate; add if not, else return false
	virtual bool BAddElem ( SZC szcName, GOBJMBN * pgobj );
		//	Add a named object to the graph and symbol table
	virtual void AddElem ( SZC szcName, GOBJMBN * pgobj );
		//  Delete objects and edges
	virtual void DeleteElem ( GOBJMBN * pgobj );

	//  Enumerator for contents of the graph (GRPH);
	//  enumeration omits the GRPH object itself
	class MODELENUM : public GLNKENUM<GELEMLNK,true>
	{
	  public:
		MODELENUM ( const MODEL & model )
			: GLNKENUM<GELEMLNK,true>( model.Grph() )
			{}
	};
	
 	//  Accessors to format/versioning info
	REAL & RVersion ()				{ return _rVersion ;	}
	ZSTR & ZsFormat ()				{ return _zsFormat;		}
	ZSTR & ZsCreator ()				{ return _zsCreator;	}
	ZSTR & ZsNetworkID ()			{ return _zsNetworkID;	}

	//  Accessor for symbol table
	MPSYMTBL & Mpsymtbl ()			{ return _mpsymtbl;		}
	const MPSYMTBL & Mpsymtbl () const
									{ return _mpsymtbl;		}
	GOBJMBN * PgobjFind ( SZC szcName );

	//	Accessor for list of network-level properties
	LTBNPROP & LtProp ()			{ return _ltProp;		}

	//  Accessors for the array of flag bits
	bool BFlag ( IBFLAG ibf ) const	
		{ return _vFlags.BFlag( ibf );	}
	bool BSetBFlag ( IBFLAG ibf, bool bValue = true )
		{ return _vFlags.BSetBFlag( ibf, bValue );	}
	
  	//  Name validation and parsing functions
		//	Return a character which is illegal in a DSC-file-based name;
		//		used for building up "hidden" but otherwise descriptive names
	static char ChInternal ()				{ return '$';				}
		//  Return true if the character is legal in a name
	enum ECHNAME { ECHNM_First, ECHNM_Middle, ECHNM_Last };
	static bool BChLegal ( char ch, ECHNAME echnm, bool bInternal = false );
		//  Return true if the name is legal
	static bool BSzLegal ( SZC szcName, bool bInternal = false );
	//	Return a displayable string associated with an error code; NULL if not found
	static SZC SzcFromEc ( ECGM ec );

 protected:	
	GRPH * _pgrph;					//  The graph

	//  Format and versioning info
	REAL _rVersion;					//  Version/revision value
	ZSTR _zsFormat;					//  Format type string
	ZSTR _zsCreator;				//  Creator name
	ZSTR _zsNetworkID;				//  Network identification string

  	MPSYMTBL _mpsymtbl;				//  The symbol table
	LTBNPROP _ltProp;				//  The list of user-definable properties
	VFLAGS	 _vFlags;				//  Bit vector of flags

  protected:
	//  Set or reset the graph object
	virtual void SetPgraph ( GRPH * pgrph );
	//  Protected clone-this-from-other operation
	virtual void Clone ( MODEL & model );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\mddist.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       mddist.cpp
//
//--------------------------------------------------------------------------

//
//	MDDIST.CPP
//

#include <basetsd.h>
#include <iostream>
#include <fstream>

#include "symtmbn.h"

LEAK_VAR_DEF(BNDIST)

static void dumpVimd ( const VIMD & vimd )
{
	for ( int i = 0 ; i < vimd.size(); i++ )
	{
		cout << vimd[i];
		if ( i + 1 < vimd.size() )
			cout << ",";
	}	
}

static void dumpVlr ( const VLREAL & vlr )
{
	for ( int i = 0 ; i < vlr.size(); i++ )
	{
		cout << vlr[i];
		if ( i + 1 < vlr.size() )
			cout << ",";
	}	
}

static void dumpSlice ( const MDVSLICE & mslice, bool bStrides = true)
{
	VIMD vimdLengths = mslice.size();
	VIMD vimdStrides = mslice.stride();
	size_t iStart = mslice.start();

	cout << "\nslice start="
		 << iStart
		 << "\tlengths=";
	dumpVimd( vimdLengths );
	if ( bStrides )
	{
		cout << "\tstrides=" ;
		dumpVimd( vimdStrides );
	}
	cout << "\ttotlen="
		 << mslice._Totlen();
}

static void dumpMdv ( DISTDD & mdv, const MDVSLICE * pslice = NULL )
{	
	if ( pslice == NULL )
		pslice = & mdv.Slice();
	dumpSlice( *pslice );
	DISTDD::Iterator itmd(mdv, *pslice );
	while (itmd.BNext())
	{
		size_t icurr = itmd.ICurr();
		cout << "\n";
		dumpVimd( itmd.Vitmd() );
		REAL & r = itmd.Next();
		cout << "\t["
			<< icurr
			<< "] = "
			<< r ;
	}
	cout << "\n";
}

BNDIST :: BNDIST ()
	:_edist(ED_NONE),
	_pmvd(NULL),
	_pdrmap(NULL)
{
	LEAK_VAR_UPD(1)
}

BNDIST :: ~ BNDIST ()
{
	Clear();
	LEAK_VAR_UPD(-1)
}

void BNDIST :: NoRef ()
{
	delete this;
}

BNDIST & BNDIST :: operator = ( const BNDIST & bnd )
{
	Clear();
	switch ( _edist = bnd._edist )
	{
		default:
		case ED_NONE:
			break;
		case ED_DENSE:
			_pmvd = new DISTDD( bnd.Mvd() );
			assert( _pmvd->first.size() == bnd.Mvd().first.size() );
			break;
		case ED_CI_MAX:
		case ED_CI_PLUS:
		case ED_SPARSE:
			_pdrmap = new DISTMAP( bnd.Distmap() ) ;
			assert( _pdrmap->size() == bnd.Distmap().size() );
			break;			
	}
	return self;
}

BNDIST :: BNDIST ( const BNDIST & bnd )
	:_edist(ED_NONE),
	_pmvd(NULL),
	_pdrmap(NULL)
{
	(*this) = bnd;

	LEAK_VAR_UPD(1)
}

bool BNDIST :: BChangeSubtype ( EDIST edist )
{
	if ( BDenseType(edist) ^ BDense() )
		return false;
	_edist = edist;
	return true;
}

void BNDIST :: Dump ()
{
	if ( _pmvd )
	{
		cout << "\n\tDense version:";
		DumpDense();
	}
	if ( _pdrmap )
	{
		cout << "\n\tSparse version:";
		DumpSparse();
	}
	cout << "\n\n";
}

void BNDIST :: DumpSparse ()
{
	assert( _pdrmap );
	DISTMAP & dmap = *_pdrmap;
	int i = 0;
	for ( DISTMAP::iterator itdm = dmap.begin();
		  itdm != dmap.end();
		  ++itdm, ++i )
	{
		const VIMD & vimd = (*itdm).first;
		const VLREAL & vlr = (*itdm).second;
		cout << "\n["
			 << i
			 << "] (";
		dumpVimd(vimd);
		cout << ")\t";
		dumpVlr(vlr);
	}
}

void BNDIST :: DumpDense ()
{
	assert( _pmvd );
	dumpMdv( *_pmvd );
}

void BNDIST :: ConvertToDense ( const VIMD & vimd )
{
	assert( _edist == ED_NONE || _edist == ED_SPARSE );

	if ( _edist == ED_NONE )
	{
		assert( ! _pdrmap );
		return;
	}
	//  See if there is a sparse distribution to convert
	if ( ! _pdrmap )
		throw GMException( EC_DIST_MISUSE, "no prior sparse distribution to convert" );

	int cParent = vimd.size() - 1;
	int cState = vimd[cParent];
	DISTMAP & dmap = *_pdrmap;
	VIMD vimdMt;					//  Empty subscript array
	VLREAL vlrDefault(cState);		//	Default value array

	//  First, try to find the default entry; use -1 if not found
	DISTMAP::iterator itdm = dmap.find(vimdMt);
	if ( itdm != dmap.end() )
		vlrDefault = (*itdm).second;
	else
		vlrDefault = -1;	// fill the array with -1.

	assert( vlrDefault.size() == cState );

	//  Allocate the new dense m-d array
	delete _pmvd;
	_pmvd = new DISTDD( vimd );
	DISTDD & mdv = *_pmvd;
	//  Fill each DPI with the appropriate default value
	DISTDD::Iterator itmdv(mdv);
	for ( int iState = 0; itmdv.BNext() ; iState++ )
	{
		itmdv.Next() = vlrDefault[ iState % cState ];
	}
	
	//
	//  Now, iterate over the sparse array and store in the appropriate locations.
	//	Each entry in the sparse map is a complete state set for the target node.
	//  Since the child (target) node probabilities are the fastest varying subscript,
	//  each entry in sparse map is spread across "cState" entries in the dense map.
	//	
	//	Of course, this could be more efficient, but we're just testing for now.
	//
	VIMD vimdDense(vimd.size());
	for ( itdm = dmap.begin(); itdm != dmap.end() ; ++itdm )
	{
		const VIMD & vimdSub = (*itdm).first;
		VLREAL & vlrNext = (*itdm).second;
		for ( int ip = 0 ; ip < cParent; ip++ )
		{
			vimdDense[ip] = vimdSub[ip];
		}
		for ( int ist = 0 ; ist < cState; ++ist )
		{
			vimdDense[cParent] = ist;
			mdv[vimdDense] = vlrNext[ist];
		}
	}
	
	//  Finally, nuke the old sparse distribution
	delete _pdrmap;
	_pdrmap = NULL;
	//  Set distribution type
	_edist = ED_DENSE;
}

//  Set distribution to "dense"
void BNDIST :: SetDense ( const VIMD & vimd )
{
	Clear();
	_vimdDim = vimd;
	_pmvd = new DISTDD( vimd );
	_edist = ED_DENSE;
}

//  Set distribution to sparse
void BNDIST :: SetSparse ( const VIMD & vimd )
{
	Clear();
	_vimdDim = vimd;
	_pdrmap = new DISTMAP;
	_edist = ED_SPARSE;
}

//  Return the "leak" or "default" vector from a sparse distribution
VLREAL * BNDIST :: PVlrLeak ()
{
	assert( BSparse() );
	const DISTMAP & dmap = Distmap();
	const VIMD & vimdDim = VimdDim();
	VIMD vimdLeak;

	//  First try to find the dimensionless "default" vector.
	VLREAL * pvlrDefault = NULL;
	DISTMAP::iterator itdm = dmap.find( vimdLeak );
	if ( itdm != dmap.end() )
		pvlrDefault = & (*itdm).second;

	//  Now try to find a specific zeroth vector; note that valarray<T>::resize
	//		stores all zeroes into the valarray by default.  Also, skip the
	//		loweest dimension, since that's the size of each vector in the
	//		sparse map.
	vimdLeak.resize( vimdDim.size() - 1 );	
	VLREAL * pvlrLeak = NULL;
	itdm = dmap.find( vimdLeak );
	if ( itdm != dmap.end() )
		pvlrLeak = & (*itdm).second;

	return pvlrLeak
		 ? pvlrLeak
		 : pvlrDefault;
}

void BNDIST :: Clone ( const BNDIST & bndist )
{
	ASSERT_THROW( _edist == ED_NONE,
			EC_INVALID_CLONE,
			"cannot clone into non-empty structure" );
	self = bndist;	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\mddist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       mddist.h
//
//--------------------------------------------------------------------------

//
//  mddist.h: model distributions
//

#ifndef _MDDIST_H_
#define _MDDIST_H_

#include <map>

#include "mdvect.h"
#include "leakchk.h"

////////////////////////////////////////////////////////////////////
//	Probability table declarations
////////////////////////////////////////////////////////////////////

//  Dense multidimensional array.  Note that a null dimension set
//	produces a one entry array.
typedef TMDVDENSE<REAL> MDVDENSE;

class MDVCPD : public MDVDENSE
{
  public:
	MDVCPD ( const VIMD & vimd )
		: MDVDENSE ( vimd )
		{}
	MDVCPD () {}
	~ MDVCPD () {}

	void Init ( const VIMD & vimd, size_t start = 0 )
	{
		if ( vimd.size() > 0 )
		{
			MDVDENSE::Init( vimd, start );
		}
		else
		{
			assert( start == 0 );
			MDVDENSE::Init( 1, 1 );
		}
	}

	void Init ( int cdim, ... )
	{
		if ( cdim > 0 )
		{
			va_list vl;
			va_start( vl, cdim );
			MDVDENSE::Init( cdim, vl );
		}
		else
		{	
			MDVDENSE::Init( 1, 1 );
		}
	}

	void Clear ( REAL r = 0.0 )
	{
		size_t celem = size();
		for ( int i = 0; i < celem; )
			self[i++] = r;
	}
	REAL RSum () const
	{
		return first.sum();
	}
	void Normalize ()
	{
		REAL rSum = RSum();
		if ( rSum != 0.0 && rSum != 1.0 )
		{
			size_t celem = size();
			for ( int i = 0; i < celem; )
				self[i++] /= rSum;
		}
	}

	MDVCPD & operator = ( const MDVCPD & mdv )
	{
		MDVDENSE::Init( mdv.Slice() );
		first = mdv.first;
		return self;
	}
	//  Convert this MDVCPD to a single-dimension object
	MDVCPD & operator = ( const VLREAL & vlr )
	{
		Init( 1, vlr.size() );
		first = vlr;
		return self;
	}

	//  Given a partial dimension (incomplete) subscript, update the appropriate
	//		range of elements.  Note that providing an incomplete (i.e., short)
	//		subscript array to the "offset" functions  is valid; the results
	//		are the same as if the missing lower-order elements were zero.
	void UpdatePartial ( const VIMD & vimd, const VLREAL & vlr )
	{
		const VIMD vimdDim = VimdDim();
		//  Compute the appropriate number of elements
		size_t cElem = 1;
		assert( vimd.size() <= vimdDim.size() );
		for ( int idim = vimd.size(); idim < vimdDim.size(); idim++ )
		{
			cElem *= vimdDim[idim];
		}
		ASSERT_THROW( vlr.size() == cElem,
					  EC_MDVECT_MISUSE,
					  "m-d vector partial projection count invalid" );
		//  Index to the proper position and update from the source data
		assert( second._IOff(vimd) + cElem <= first.size() );
		REAL * prSelf = & self[vimd];
		for ( int iElem = 0; iElem < cElem; )
			*prSelf++ = vlr[iElem++];
	}

	void Clone ( const MDVCPD & mdv )
	{
		self = mdv;
	}
};

//  Class MPCPDD:  Distribution map by specific index
//		Hungarian: 'drmap'

class MPCPDD : public map<VIMD, VLREAL, lessv<VIMD> >
{
  public:
	MPCPDD () {}
	~ MPCPDD () {}
	void Clone ( const MPCPDD & dmap )
	{
		self = dmap;
	}

	//  Return a pointer to the dimensionless "default" vector or NULL
	const VLREAL * PVlrDefault () const
	{
		VIMD vimdDefault;
		const_iterator itdm = find( vimdDefault );
		return itdm == end()
			 ? NULL
			 : & (*itdm).second;
	}
	bool operator == ( const MPCPDD & mpcpdd ) const
	{
		if ( size() != mpcpdd.size() )
			return false;
		const_iterator itself = begin();
		const_iterator itmp = mpcpdd.begin();
		for ( ; itself != end(); itself++, itmp++ )
		{	
			if ( (*itself).first != (*itmp).first )
				return false;
			if ( ! vequal( (*itself).second, (*itmp).second ) )
				return false;				
		}
		return true;
	}
	bool operator != ( const MPCPDD & mpcpdd ) const
		{ return !(self == mpcpdd); }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\nyi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       nyi.cpp
//
//--------------------------------------------------------------------------

//
//	NYI.cpp: throw generic "not yet implemented" exception
//	

#include "basics.h"

void NYI() 
{
	THROW_ASSERT(EC_NYI,"Attempt to call unimplemented function");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\mdvect.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       mdvect.h
//
//--------------------------------------------------------------------------

//
//  mdvect.h:  multi-dimensional array handling
//
#ifndef _MDVECT_H_
#define _MDVECT_H_

/*
	Multidimensional array classes and templates.

	Each array carries the dimensionality of each dimension as a short integer;
	the signed value is reinterpreted for projections and redimensioning.

	Note that giving a subscript array (VIMD) whose length is less than the
	dimensionality of the target array produces a subscript with lower dimensions
	assumed to be equal to zero.  This is useful for indexing to lowest-dimensioned
	rows for probability tables.


	Types used (see basics.h):

			REAL		is a double
			VLREAL		is valarray<REAL>
			IMD			is an unsigned index into a multi-dimensional array
			VIMD		is a vector of IMD
			SIMD		is a signed index into a multi-dimensional array;
							it's used for projecting dimensions out
			VSIMD		is a vector of SIMD

	An MDVSLICE is dimensionality and iteration information for an m-d vector or maxtrix.

	The template TMDVDENSE defines a generic multi-dimensional array which a pair of
	elements:
	
			'first'		is a flat (1-d) valarray of an unspecified type (e.g., REAL)
			'second'	is an MDVSLICE describing its dimensionality

	The nested class TMDVDENSE::Iterator (note the capital 'I') is the smart iterator
	for classes derived from TMDVDENSE<>.
	
*/

#include <stdarg.h>
#include "algos.h"

typedef valarray<REAL> VLREAL;

//  'valarray' comparison templates
template<class _V>
struct lessv : binary_function<_V, _V, bool>
{
	bool operator()(const _V & vra, const _V & vrb) const
	{
		int cmin = _cpp_min( vra.size(), vrb.size() );
		for ( int i = 0 ; i < cmin ; i++ )
		{
			if ( vra[i] < vrb[i] )
				return true;
			if ( vra[i] > vrb[i] )
				return false;
		}
		return vra.size() < vrb.size();
	}
};

/////////////////////////////////////////////////////////////////////////////////
//  Class MDVSLICE:
//		Similar to 'gslice'.  Has gslice converter (see 'valarray' header).
//		Contains integer array of lengths, array of strides
//		and starting point.
/////////////////////////////////////////////////////////////////////////////////
class MDVSLICE
{
  public:
	//  Construct a slice from complete data (like gslice)
	MDVSLICE ( size_t _S,
			   const VIMD & _L,
			   const VIMD & _D)
		: _Start(_S),
		_Len(_L),
		_Stride(_D)
		{}

	//  Construct a slice given only the dimensions
	MDVSLICE ( const VIMD & _L, size_t _S = 0 )
	{
		Init( _L, _S );
	}
	MDVSLICE ( int cdim, int ibound, ... )
		: _Start(0)
	{
		va_list vl;
		va_start( vl, cdim );
		Init( cdim, vl );
	}

	MDVSLICE ( const VSIMD & vsimd, size_t _S = 0 )
	{
		Init( vsimd, _S );
	}

	bool operator == ( const MDVSLICE & sl ) const
	{
		return _Start == sl._Start
			 && vequal(_Len,sl._Len)
			 && vequal(_Stride,sl._Stride);
	}
	bool operator != ( const MDVSLICE & sl ) const
	{
		return !(*this == sl);
	}

	//  Provided for compatibility with gslice
	MDVSLICE()
		: _Start(0) {}

	//  Return an equivalent gslice for use with other 'valarray' operations
	gslice Gslice () const;

	void Init ( const VIMD & _L, size_t _S = 0 )
	{
		_Start = _S;
		_Len = _L;
		StrideFromLength();
	}

	void Init ( const VSIMD & vsimd, size_t _S = 0 )
	{
		int cd = vsimd.size();
		vbool vboolMissing(cd);
		_Len.resize(cd);
		_Start = _S;
		for ( int i = 0; i < cd; i++ )
		{
			SIMD simd = vsimd[i];
			if ( vboolMissing[i] = simd < 0 )
				_Len[i] = - simd;
			else
				_Len[i] = simd;
		}
		StrideFromLength( & vboolMissing );
	}

	void Init ( int cdim, ... )
	{
		va_list vl;
		va_start( vl, cdim );
		Init( cdim, vl );
	}

	void Init ( int cdim, va_list & vl )
	{
		_Len.resize(cdim);
		for ( int idim = 0; idim < cdim; idim++ )
		{
			_Len[idim] = va_arg(vl,int);	
		}
		StrideFromLength();
	}

	/********************************************************
	*  Accessors to internal data
	*********************************************************/
	size_t start() const
		{return _Start; }
	const VIMD & size() const
		{return _Len; }
	const VIMD & stride() const
		{return _Stride; }
	//  Return the number of dimensions
	size_t _Nslice() const
		{ return _Len.size(); }

	//  Return the total number of elements according to this slice
	size_t _Totlen() const
	{
		size_t _L = _Len.size() > 0;
		if ( _L )			
		{
			for (size_t _I = 0; _I < _Len.size(); ++_I )
			{
				if ( _Len[_I] )
					_L *= _Len[_I];
			}
		}
		return _L;
	}

	/********************************************************
	*	Subscript handling.  There are two levels, one leaves
	*	the subscript array unchanged, the other updates it.
	*   There is a set of overloads for these which allow
	*	reordering of dimensions.
	*********************************************************/

	//  Return the index offset based upon the subscript array given
	size_t _IOff ( const VIMD& _Idx ) const
	{
		size_t _K = _Start;
		for (size_t _I = 0; _I < _Idx.size(); ++_I)
			_K += _Idx[_I] * _Stride[_I];
		return _K;
	}
	//  Return the index offset based upon the varargs array given
	size_t _IOff ( int i, ...  ) const
	{
		va_list vl;
		va_start( vl, i );
		return _IOff( i, vl );
	}
	size_t _IOff ( int i, va_list & vl ) const
	{
		size_t ioff = _Start;
		int j;
		for ( j = 0; j < _Len.size() && i >= 0 ; ++j )
		{
			ioff += i * _Stride[j];
			i = va_arg(vl,int);
		}
		return j == _Len.size() ? ioff : -1;
	}
	//  Bump the subscript array to its next valid index
	void _Upd (VIMD & _Idx) const
	{
		for (size_t _I = _Len.size(); 0 < _I--;)
		{
			if (++_Idx[_I] < _Len[_I])
				break;
			_Idx[_I] = 0;
		}
	}

	//  Iterate to the next subscript by computing its offset and updating
	//		THIS IS THE FUNCTION USED FOR NORMAL ITERATION
	size_t _Off (VIMD& _Idx) const
	{
		size_t _K = _IOff(_Idx);
		_Upd(_Idx);
		return _K;
	}

	//  Dimension reordering overloads; each behaves identically to its
	//  base function, but accepts a dimension reordering array
	size_t _IOff(const VIMD& _Idx, const VIMD& _Idim) const
	{
		size_t _K = _Start;
		for (size_t _I = 0; _I < _Idx.size(); ++_I)
		{
			size_t _II = _Idim[_I];
			_K += _Idx[_II] * _Stride[_II];
		}
		return _K;
	}
	void _Upd (VIMD & _Idx, const VIMD& _Idim) const
	{
		for (size_t _I = _Len.size(); 0 < _I--;)
		{
			size_t _II = _Idim[_I];
			if (++_Idx[_II] < _Len[_II])
				break;
			_Idx[_II] = 0;
		}
	}

	size_t _Off (VIMD& _Idx, const VIMD& _Idim) const
	{
		size_t _K = _IOff(_Idx,_Idim);
		_Upd(_Idx,_Idim);
		return _K;
	}

	//  Return an array like (0,1,2,3,...) for use with
	//  the dimension-reordering members above
	void InitDimReorder ( VIMD & vimdDim ) const
	{
		vimdDim.resize( _Nslice() );
		for ( size_t i = 0 ; i < vimdDim.size() ; ++i )
		{
			vimdDim[i] = i;
		}
	}
	
  protected:
	size_t _Start;			//  Absolute starting offset into array
	VIMD _Len;				//	Signed integer array of dimension lengths
	VIMD _Stride;			//	Signed integer array of strides

	//  Given the dimension lengths, compute the array of strides.
	inline void StrideFromLength ( const vbool * pvboolMissing = NULL );
};

/////////////////////////////////////////////////////////////////////////////////
//
//	Template TMDVDENSE:  Generalized multidimensional array handling.
//			Base class is 'valarray', so member elements must be available
//			(directly or through conversion) for mathematical operations.
//			For example, there's a "sum()" member for valarrays.
//
/////////////////////////////////////////////////////////////////////////////////
template<class T>
class TMDVDENSE : public pair<valarray<T>,MDVSLICE>
{
	typedef valarray<T> vr_base;
	typedef pair<valarray<T>,MDVSLICE> pair_base;

  public:
	TMDVDENSE ( const VIMD & vimd )
		: pair_base( vr_base(), vimd )
		{ SyncSize(); }
	TMDVDENSE () {}
	~ TMDVDENSE () {}
	
	void Init ( const VIMD & vimd, size_t start = 0 )
	{
		second.Init( vimd, start );
		SyncSize();
	}

	void Init ( const MDVSLICE & mdvs )
	{
		second = mdvs;
		SyncSize();
	}
	void Init ( int cdim, ... )
	{
		va_list vl;
		va_start( vl, cdim );
		Init( cdim, vl );
	}

	void Init ( int cdim, va_list & vl )
	{
		second.Init( cdim, vl );
		SyncSize();
	}

	void SyncSize ()
	{	
		size_t cElem = second._Totlen();
		if ( first.size() != cElem )
			first.resize( cElem );
	}

	//  Subscripting as flat array
	T & operator [] ( int i )
		{ return first.operator[](i); }
	T operator [] ( int i ) const
		{ return first.operator[](i); }

	//  Subscripting as m-d array
	T & operator [] ( const VIMD & vimd )
		{ return (*this)[ second._IOff(vimd) ]; }
	T operator [] ( const VIMD & vimd ) const
		{ return (*this)[ second._IOff(vimd) ]; }

	size_t size () const
		{ return first.size(); }

	const MDVSLICE & Slice () const
		{ return second ; }

	const VIMD & VimdDim () const
		{ return second.size(); }

	bool operator == ( const TMDVDENSE & mdv ) const
	{
		return vequal(first,mdv.first)
			&& second == mdv.second;
	}
	bool operator != ( const TMDVDENSE & mdv ) const
	{
		return !(*this == mdv);
	}

	class Iterator
	{
	  public:
		Iterator ( TMDVDENSE & mdv )
			: _mdv(mdv),
			_mdvSlice( mdv.Slice() ),
			_itcurr(0),
			_itend( mdv.size() ),
			_bDimReorder(false)
		{
			assert( _mdvSlice._Totlen() == _itend );
			_vimd.resize(_mdvSlice._Nslice());
		}

		Iterator ( TMDVDENSE & mdv, const MDVSLICE & mdvslice )
			: _mdv(mdv),
			_mdvSlice( mdvslice ),
			_itcurr(0),
			_itend( mdvslice._Totlen() ),
			_bDimReorder(false)
		{
			_vimd.resize(_mdvSlice._Nslice());
		}

		void Reset()
		{
			vclear( _vimd, 0 );
			_itcurr = 0;
		}

		// Return flat index given const subscript array
		size_t Indx ( const VIMD & vimd ) const
		{
			return _bDimReorder
				 ? _mdvSlice._IOff( vimd, _vimdDim )
				 : _mdvSlice._IOff( vimd );
		}
		// Return flat index given subscript array; update sub array
		size_t IndxUpd ( VIMD & vimd )
		{
			return _bDimReorder
				 ? _mdvSlice._Off( vimd, _vimdDim )
				 : _mdvSlice._Off( vimd );
		}
		//  Return current flat index, no update
		size_t Indx () const
			{ return Indx( _vimd ); }
		//  Return current flat index, with update
		size_t IndxUpd ()
		{
			if ( _itcurr < _itend )
				_itcurr++;
			return IndxUpd( _vimd );
		}
		//  Return current datum, no update
		T & operator[] ( VIMD & vimd )
			{ return _mdv[Indx()]; }
		//	Return current datum, update sub array
		T & Next ()
			{ return _mdv[IndxUpd()]; }

		size_t ICurr () const
			{ return _itcurr; }
		size_t IEnd () const
			{ return _itend; }
		bool BNext () const
			{ return _itcurr < _itend; }
		const VIMD & Vitmd () const
			{ return _vimd; }
		const MDVSLICE & Slice() const
			{ return _mdvSlice; }
		void SetDimReorder ( const VIMD & vimdDim )
		{
			_vimdDim = vimdDim;
			_bDimReorder = true;
			// MSRDEVBUG:  assert that the contents mention all dimensions correctly
		}
		TMDVDENSE & Mdv ()
			{ return _mdv; }
		bool BReorder () const
			{ return _bDimReorder; }
		const VIMD & VimdReorder () const
			{ return _vimdDim; }
	  protected:		
	    TMDVDENSE & _mdv;				// Flat valarray
		const MDVSLICE & _mdvSlice;		// Multidimensional slice
		VIMD _vimd;						// Iteration control
		VIMD _vimdDim;					// Dimension reordering (optional)
		size_t _itcurr;					// Current iteration point
		size_t _itend;					// Iteration terminus
		bool _bDimReorder;				// Dimension reordering?
	};

	friend class Iterator;

};


/////////////////////////////////////////////////////////////////////////////////
//   MDVSLICE member functions
/////////////////////////////////////////////////////////////////////////////////

inline
void MDVSLICE :: StrideFromLength ( const vbool * pvboolMissing )
{
	size_t cd = _Len.size();
	_Stride.resize(cd);
	size_t c = 1;
	size_t cmiss = pvboolMissing
				 ? pvboolMissing->size()
				 : 0;

	for ( int i = cd; --i >= 0 ; )
	{
		int l = _Len[i];
		if ( l == 0 )
			continue;
		if ( i < cmiss && (*pvboolMissing)[i] )
		{
			_Stride[i] = 0;
		}
		else
		{
			_Stride[i] = c;
			c *= l;
		}
	}
}

//  Construct a gslice from an MDVSLICE
inline
gslice MDVSLICE :: Gslice () const
{
	_Sizarray vszLength;
	_Sizarray vszStride;
	return gslice( _Start,
				   vdup( vszLength, _Len ),
				   vdup( vszStride, _Stride ) );
}



// End of mdvect.h

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\parmiox.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       parmiox.h
//
//--------------------------------------------------------------------------

//////////////////////////////////////////////////////////////////////////////////
//
//  PARMIOX.H:  Parameter file I/O routines extended for older classes
//
//////////////////////////////////////////////////////////////////////////////////
#ifndef _PARMIOX_H_
#define _PARMIOX_H_

#include "parmio.h"

template<class _T> inline
PARMOUTSTREAM& operator << (PARMOUTSTREAM & ofs, const RG<_T> & rgt )
{
	UINT c = rgt.Celem();
	ofs << CH_DELM_OPEN;
	ofs << c;
	ofs << CH_PREAMBLE;
	for ( UINT i = 0; i < c; )
	{	
		ofs << rgt[i];
		if ( ++i != c )	
			ofs << ',' ;
	}
	ofs << CH_DELM_CLOSE;
	return ofs;
}

template<class _T> inline
PARMINSTREAM& operator >> (PARMINSTREAM & ifs, RG<_T> & rgt )
{
	char ch;
	ifs >> ch;
	if (ch != CH_DELM_OPEN)
		_THROW1(runtime_error("invalid block (1)"));
	UINT l;
	ifs >> l;
	ifs >> ch;
	if (ch != CH_PREAMBLE)
		_THROW1(runtime_error("invalid block (2)"));

	rgt.BxResize(l);
	for ( UINT i = 0 ; i < l; )
	{
		_T it;
		ifs >> it;
		rgt[i] = it;
		if ( ++i < l )
		{
			ifs >> ch;
			if (ch != CH_SEP)
				break;
		}
	}
	if ( i != l )
		_THROW1(runtime_error("invalid block (3)"));
	ifs >> ch;
	if (ch != CH_DELM_CLOSE)
		_THROW1(runtime_error("invalid block (4)"));
	return ifs;
}


#endif  // _PARMIOX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\parser.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       parser.cpp
//
//--------------------------------------------------------------------------

/*
 * Created by CSD YACC (IBM PC) from "parser.y" */

#include <basetsd.h>
#line 2 "parser.y"
    #include "bnparse.h"
	// disable warning C4102: unreferenced label
	#pragma warning (disable : 4102)
# define tokenEOF 0
# define tokenNil 258
# define tokenError 259
# define tokenIdent 260
# define tokenString 261
# define tokenInteger 262
# define tokenReal 263
# define tokenArray 264
# define tokenContinuous 265
# define tokenCreator 266
# define tokenDefault 267
# define tokenDiscrete 268
# define tokenFormat 269
# define tokenFunction 270
# define tokenImport 271
# define tokenIs 272
# define tokenKeyword 273
# define tokenLeak 274
# define tokenNA 275
# define tokenName 276
# define tokenNamed 277
# define tokenNetwork 278
# define tokenNode 279
# define tokenOf 280
# define tokenParent 281
# define tokenPosition 282
# define tokenProbability 283
# define tokenProperties 284
# define tokenProperty 285
# define tokenPropIdent 286
# define tokenStandard 287
# define tokenState 288
# define tokenType 289
# define tokenUser 290
# define tokenVersion 291
# define tokenWordChoice 292
# define tokenWordReal 293
# define tokenWordString 294
# define tokenAs 295
# define tokenLevel 296
# define tokenDomain 297
# define tokenDistribution 298
# define tokenDecisionGraph 299
# define tokenBranch 300
# define tokenOn 301
# define tokenLeaf 302
# define tokenVertex 303
# define tokenMultinoulli 304
# define tokenMerge 305
# define tokenWith 306
# define tokenFor 307
# define tokenRangeOp 308
# define UNARY 309
#define yyclearin yychar = -1
#define yyerrok yyerrflag = 0
#ifndef YYMAXDEPTH
#define YYMAXDEPTH 150
#endif
YYSTYPE yylval, yyval;
#ifndef YYFARDATA
#define	YYFARDATA	/*nothing*/
#endif
#if ! defined YYSTATIC
#define	YYSTATIC	/*nothing*/
#endif
#ifndef YYOPTTIME
#define	YYOPTTIME	0
#endif
#ifndef YYR_T
#define	YYR_T	int
#endif
typedef	YYR_T	yyr_t;
#ifndef YYEXIND_T
#define	YYEXIND_T	unsigned int
#endif
typedef	YYEXIND_T	yyexind_t;
#ifndef	YYACT
#define	YYACT	yyact
#endif
#ifndef	YYPACT
#define	YYPACT	yypact
#endif
#ifndef	YYPGO
#define	YYPGO	yypgo
#endif
#ifndef	YYR1
#define	YYR1	yyr1
#endif
#ifndef	YYR2
#define	YYR2	yyr2
#endif
#ifndef	YYCHK
#define	YYCHK	yychk
#endif
#ifndef	YYDEF
#define	YYDEF	yydef
#endif
#ifndef	YYV
#define	YYV	yyv
#endif
#ifndef	YYS
#define	YYS	yys
#endif
#ifndef	YYLOCAL
#define	YYLOCAL
#endif
# define YYERRCODE 256

#line 473 "parser.y"

YYSTATIC short yyexca[] ={
#if !(YYOPTTIME)
-1, 1,
#endif
	0, -1,
	-2, 0,
#if !(YYOPTTIME)
-1, 76,
#endif
	125, 168,
	44, 168,
	-2, 176,
#if !(YYOPTTIME)
-1, 260,
#endif
	125, 73,
	-2, 91,
	};
# define YYNPROD 200
#if YYOPTTIME
YYSTATIC yyexind_t yyexcaind[] = {
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
4,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
10,
	};
#endif
# define YYLAST 451
YYSTATIC short YYFARDATA YYACT[]={

 303,  24,  25,  80,  79, 120, 121,  89, 127, 295,
 128, 126, 158, 129, 160,  20,  31, 157, 239, 206,
  84, 306, 226, 225, 104, 133, 168,  54, 198, 178,
 221,  98, 197, 254,  16, 102,  98,   6,  17,  15,
 190, 185, 180,  62, 179,  80,  79, 238, 180,  78,
 179, 235,  18,  19, 171, 170, 169,  99,  96, 270,
 255, 101,  99, 180,  90, 179, 234,  91,  93,  94,
  77,  90, 213, 209,  91, 208, 304, 232, 103, 309,
 130, 308, 224, 119,  24,  25,  80,  79,  24,  25,
 174, 297, 298, 296, 184, 137, 135, 299, 282, 274,
 122, 261, 251, 216,  87, 148,  46,  28, 138, 139,
 140, 115, 207,  75, 175, 136, 191, 155,  86, 143,
 144, 145,  82, 278, 189, 264, 134, 173, 125, 118,
 277,  52,  50,  48,  45,  27, 214,  22, 319,  74,
  77, 264, 230, 152, 330, 317, 315, 317, 316, 247,
 318, 228, 318, 317, 315, 110, 316,  66, 318,  97,
 290, 289, 181, 181, 314, 272, 236, 166,  61, 165,
 311,  59, 164, 142,  95, 111, 286, 243, 242, 287,
 242, 113, 233, 240,  69,  70, 241, 196, 112,  67,
 265, 229, 188,  60, 181, 215, 181, 319, 313, 319,
 293, 202, 203,  69,  70, 319, 312,  68, 256, 124,
 117, 259, 146,  53,  77,  23, 181, 131, 292, 263,
 132, 192, 194, 186, 222, 205,  51,  37, 100, 109,
  33, 159,  83,   8,  81,  85,  49,  39, 218,  38,
  40,  26,  73, 116,  47,  30, 250, 161, 153, 200,
 141, 162, 181, 172,  65, 258,  64,  76, 149, 177,
 176,  80,  79,  77, 181, 177, 176,  80,  79, 183,
  63,  44, 253,  35, 182, 302, 301, 281,  92, 285,
 182, 294,  80,  79, 193,  92, 271, 123, 284, 201,
 283, 280, 210, 279, 269, 182, 305, 307,  80,  79,
 199, 310, 268, 181, 273, 320, 219, 262, 147, 321,
 322, 222, 291, 223, 267, 324, 325, 326, 327, 328,
 329, 323, 300, 260, 249, 275, 237,  76, 150, 151,
 212, 211, 187, 114,  72, 154,  29, 245, 227, 288,
 244, 276, 163, 266, 257, 246, 248, 204, 108, 107,
 105,  71,  36,  42,  88, 252,  41,  32, 156,  55,
  43,  34,  21,   5,  14,  13,  12,  11,  10,   9,
 195,   7,   4,   3,   2,   1,  57,  56, 106,  58,
 167,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0, 217,
   0, 220,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0, 231,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
 220 };
YYSTATIC short YYFARDATA YYPACT[]={

-1000,-1000,-241,-1000,-245,  14,-172,-245,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,  12,-153,-1000,-1000,-283,
 190,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000, 187,
-172,-172,-1000,-1000,-1000,-1000,  11,-154,  10,   9,
 186,   8, 172, -98, -82,-1000,-1000,-1000,-259,-1000,
-276,-156,-1000,-1000,-1000,-1000,-1000,-1000,-1000,   6,
   6,   6,-1000, 115,-1000,-1000,-1000,-229,-224,-225,
   6,-101, -13,  85,-1000,   6,-303,-302,-176,-1000,
-1000,  84,-1000,-292,-182, 176,-1000,-270,   1,-165,
-1000,-1000,-1000,-217,-166,-1000,-1000,-1000,-1000,-1000,
   6,   6,   6,-1000,-1000, 114,-1000,-1000,-1000,-1000,
-1000,   6,   6,   6, 171,-155,-1000,-1000,-259,-172,
-172,-217,-1000,-1000,-1000,-276,-172,-289,-290,-289,
-1000,-1000,-156,-172,-1000, 113, 110, 108,-238,-1000,
  -1,  -1,-1000,-167,-227, 183,-1000, 148,-1000,-1000,
-1000,-1000,-1000,-1000,-237, 181,-1000,-1000,-1000,-237,
 182,-172,-1000,-1000,-1000,-1000,-1000, 143,-248,-1000,
-1000,-252,  -1,-1000,   5,-1000,-1000,-1000,-1000,-217,
-217,-1000,-1000,-1000,-1000, -72,  30,  13,-157,-1000,
-172,-1000,-259,-1000,  20,-289,-179,-271,  60,-1000,
  98,-1000,-1000,-1000,-1000,-172,-185, 138,-196,-211,
-1000,-1000, 107,-1000,-223,-280,-1000,-1000, 142,-1000,
-303, 136,-1000, 181,-1000,-1000,-1000,-1000,-1000,-1000,
   5,-1000,  56,  30,-1000,-1000,-1000,-1000,   6,-158,
-1000,-259,  20,-1000,-1000,-172,-1000,   6, 170,-1000,
-159, 179,-1000,-1000,  97,-1000,-1000,-1000,-1000,-1000,
  19, 106,-1000,-161,-172,-1000,   7,  -2,-1000,-162,
-1000,   6,-1000, 135,-1000,-1000,-1000,-1000,-1000, 102,
 101,  20, 178, 159,-169,-1000,-1000,-163,-172,-1000,
-1000, 134,  36,   6, 126,-1000,-1000,-1000,-1000,-1000,
  81, 157, 120, 111,  36,-1000,-1000,-1000,  36,  36,
-1000,-169,-1000,-1000,  36,  36,  36,  36,  36,  36,
 103,-1000,-1000,-1000, 111, 105, 105,  44,  44,  44,
-1000 };
YYSTATIC short YYFARDATA YYPGO[]={

   0, 380,   9, 112, 208, 159,  60, 379, 378, 377,
  21,  29, 376, 375, 374, 373, 372, 371, 233, 369,
 368, 367, 366, 365, 364, 363, 362, 361, 360, 359,
   7, 358, 117, 357, 356, 354, 353, 352, 351, 350,
 349, 348, 157, 347, 344, 343, 341, 339,  33, 338,
 337, 336, 334, 333, 332, 331, 330, 326, 324, 323,
 314, 308, 307, 304, 302, 294, 293, 291, 290, 288,
 281, 277,  30, 276, 275,   0, 273, 271, 270, 256,
 254, 253, 127, 250, 249, 114, 245, 244, 242, 139,
 113, 116, 238, 237, 236, 235, 118, 234, 122, 232,
 124, 231 };
YYSTATIC yyr_t YYFARDATA YYR1[]={

   0,  14,  13,  15,  17,  17,  18,  18,  18,  18,
  18,  18,  16,  25,  25,  27,  26,  28,  28,  29,
  29,  29,  30,  30,  30,  31,  31,  32,  32,   9,
  12,   7,  34,  35,  24,  33,  36,  33,  37,  20,
  38,  38,  39,  39,  39,  39,  39,   8,  40,  43,
  45,  43,  44,  44,  46,  47,  46,  48,  48,  48,
   6,   4,   4,  50,  49,  41,  51,  52,  54,  21,
  55,  55,  58,  60,  55,  53,  53,  53,  61,  61,
  56,  62,  62,  63,  63,  57,  57,  59,  59,  64,
  64,  65,  65,  65,  69,  68,  70,  70,  70,   2,
   2,   2,  71,  66,  67,  73,  73,  74,  74,  72,
  72,   3,   3,   3,  11,  11,  11,  11,  10,  10,
  75,  75,  75,  75,  75,  75,  75,  75,  75,  75,
  75,  76,  19,  77,  77,  78,  78,  78,  79,  79,
  80,  80,   1,   1,   1,   1,   1,   5,   5,  81,
  42,  42,  83,  42,  82,  82,  84,  84,  85,  85,
  85,  86,  22,  87,  88,  88,  88,  89,  89,  90,
  90,  90,  90,  90,  90,  90,  90,  91,  92,  92,
  92,  23,  93,  95,  95,  95,  96,  96,  94,  97,
  97,  97,  98,  98,  98,  98,  99, 101, 100, 100 };
YYSTATIC yyr_t YYFARDATA YYR2[]={

   0,   0,   2,   2,   1,   2,   1,   1,   1,   1,
   1,   1,   2,   2,   1,   0,   4,   0,   2,   1,
   1,   1,   1,   1,   1,   1,   1,   1,   0,   4,
   4,   4,   0,   0,   6,   0,   0,   3,   0,   6,
   0,   3,   1,   1,   1,   1,   1,   3,   4,   2,
   0,   6,   0,   1,   0,   0,   4,   0,   1,   3,
   1,   1,   1,   0,   4,   7,   0,   0,   0,   9,
   2,   1,   0,   0,   6,   0,   2,   1,   1,   3,
   4,   0,   3,   1,   3,   0,   4,   0,   2,   3,
   3,   0,   4,   2,   0,   2,   0,   1,   3,   1,
   1,   1,   0,   2,   4,   0,   1,   1,   3,   1,
   3,   2,   2,   1,   2,   2,   1,   1,   1,   1,
   3,   3,   3,   3,   3,   3,   1,   1,   1,   2,
   2,   0,   5,   0,   3,   1,   1,   1,   2,   2,
   6,   4,   3,   3,   1,   1,   3,   1,   1,   0,
   5,   4,   0,   4,   3,   1,   1,   3,   1,   1,
   1,   0,   4,   3,   0,   1,   3,   3,   1,   3,
   3,   2,   2,   2,   2,   1,   1,   3,   0,   1,
   3,   4,   4,   0,   1,   3,   3,   1,   3,   0,
   1,   3,   4,   4,   4,   6,   2,   4,   0,   2 };
YYSTATIC short YYFARDATA YYCHK[]={

-1000, -13, -14, -15, -16, -25, 278, -17, -18, -19,
 -20, -21, -22, -23, -24, 284, 279, 283, 297, 298,
 260, -26, 123,  -4, 260, 261, -18, 123, 260, -51,
 -86, 299, -33,  40, -27, -76, -37,  40,  -4, -93,
  -4, -34, -36, -28, -77, 123, 260, -87, 123, -94,
 123,  40, 123,  41, 125, -29,  -9, -12,  -7, 269,
 291, 266, 125, -78, -79, -80, -42, 271, 289, 285,
 286, -38, -52, -88, -89, -90,  -4, -10, 308, 263,
 262, -97, -98, -99, 296, -95, -96, 260, -35, -30,
  58,  61, 272, -30, -30,  59, 287,  -5, 260, 286,
  -5, 286, 260, -30, 125, -39,  -8, -40, -41, -42,
 256, 276, 289, 282, -53, 124, 256, 125,  44, -30,
 308, 308, -10,  -4, 125,  44, 303, 300, 302, 305,
 262,  41,  44, 295, 125, 261, -10, 261, -30, -30,
 -30, -83,  59, -30, -30, -30,  41, -61, 260, -89,
  -4,  -4, -10, -98,  -4, -32, -31, 306, 301,-101,
 304, -32, -96,  -4,  59,  59,  59,  -1, 264, 294,
 293, 292, -81, -82,  91, -85, 261, 260, -11,  45,
  43, -10, 275, -82, 261, 268,  40, -54,  44,-100,
 277, -91,  40,-100,  40,  -4,  44, 280, 280, -82,
 -84, -85, -10, -10, -43, 297,  91,  -3,  45,  43,
 262, -55, -56,  59, 123, -30, 260,  -4, -92, -90,
  -4, -72, -11, -32, 261, 294, 293, -49,  91,  93,
  44,  -4, 262,  44, 262, 262,  59, -57, 270, 298,
  41,  44,  44,  41, -91, -50, -85,  93,  -3, -58,
 -30, 260, -90, -11, -48,  -6,  -4, -44, -30,  41,
 -59, 260, -62,  40,  44,  93, -45, -60, -64, -65,
  40, 267,  59, -63, 260,  -6, -46, 123, 125, -66,
 -67, -71, 260, -68, -69, -30,  41,  44, -47,  59,
  59, -72,  40,  41, -70,  -2, 262, 260, 261, 260,
 -48, -73, -74, -75,  40, 260, -10, 261,  45,  43,
 -30,  44, 125,  41,  44,  43,  45,  42,  47,  94,
 -75, -75, -75,  -2, -75, -75, -75, -75, -75, -75,
  41 };
YYSTATIC short YYFARDATA YYDEF[]={

   1,  -2,   0,   2,   0,   0,  14,   3,   4,   6,
   7,   8,   9,  10,  11,   0,   0,  66, 161,   0,
  35,  12,  15,  13,  61,  62,   5, 131,  38,   0,
   0,   0,  32,  36,  17, 133,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  40,  67, 162, 164, 181,
 189, 183,  33,  37,  16,  18,  19,  20,  21,   0,
   0,   0, 132,   0, 135, 136, 137,   0,   0,   0,
   0,   0,  75,   0, 165,   0,  -2, 175,   0, 118,
 119,   0, 190,   0,   0,   0, 184, 187,   0,   0,
  22,  23,  24,   0,   0, 134, 138, 139, 147, 148,
   0,   0,   0, 152,  39,   0,  42,  43,  44,  45,
  46,   0,   0,   0,   0,   0,  77, 163,   0,   0,
 174, 173, 171, 172, 188,   0,   0,  28,   0,  28,
 196, 182,   0,   0,  34,   0,   0,   0,   0, 149,
   0,   0,  41,   0,   0,   0,  68,  76,  78, 166,
 167, 170, 169, 191, 198,   0,  27,  25,  26, 198,
   0,   0, 185, 186,  29,  30,  31, 141,   0, 144,
 145,   0,   0, 151,   0, 155, 158, 159, 160,   0,
   0, 116, 117, 153,  47,   0,   0,   0,   0, 192,
   0, 193, 178, 194,   0,  28,   0,   0,   0, 150,
   0, 156, 114, 115,  48,   0,   0,   0,   0,   0,
 113,  69,   0,  71,  85,   0,  79, 199,   0, 179,
 176,   0, 109,   0, 140, 142, 143, 146,  63, 154,
   0,  49,   0,   0, 111, 112,  70,  72,   0,   0,
 177,   0,   0, 197, 195,  57, 157,  52,   0,  87,
   0,  81, 180, 110,   0,  58,  60,  50,  53,  65,
  -2,   0,  80,   0,   0,  64,  54,   0,  88, 102,
  94,   0,  86,   0,  83,  59,  51,  55,  74,   0,
   0,   0,   0,   0,  96,  93,  82,   0,  57,  89,
  90, 103, 105,   0,  95,  97,  99, 100, 101,  84,
   0,   0, 106, 107,   0, 126, 127, 128,   0,   0,
  92,   0,  56, 104,   0,   0,   0,   0,   0,   0,
   0, 129, 130,  98, 108, 121, 122, 123, 124, 125,
 120 };
#ifdef YYRECOVER
YYSTATIC short yyrecover[] = {
-1000	};
#endif
/* SCCSWHAT( "@(#)yypars.c	3.1 88/11/16 22:00:49	" ) */
#line 3 "yypars.c"
# define YYFLAG 	-1000
# define YYERROR 	goto yyerrlab
# define YYACCEPT 	return 0
# define YYABORT 	return 1

#ifdef YYDEBUG				/* RRR - 10/9/85 */
	#define yyprintf(a, b, c, d) 	printf(a, b, c, d)
#else
	#define yyprintf(a, b, c, d)
#endif

#ifndef YYPRINT
	#define	YYPRINT		printf
#endif

/*	parser for yacc output	*/

#ifdef YYDUMP
int yydump = 1; /* 1 for dumping */
void yydumpinfo(void);
#endif
#ifdef YYDEBUG
YYSTATIC int 	yydebug = 0; 			/* 1 for debugging */
#endif

#ifndef YYVGLOBAL
YYSTATIC
#endif
		YYSTYPE 	yyv[YYMAXDEPTH];	/* where the values are stored */
YYSTATIC short		yys[YYMAXDEPTH];	/* the parse stack */

#if ! defined(YYRECURSIVE)
YYSTATIC int 	yychar    = -1;			/* current input token number */
YYSTATIC int 	yynerrs   =  0;			/* number of errors */
YYSTATIC short 	yyerrflag =  0;			/* error recovery flag */
#endif

#ifdef YYRECOVER
/*
**  yyscpy : copy f onto t and return a ptr to the null terminator at the
**  end of t.
*/
YYSTATIC
char	*yyscpy(register char* t, register char* f)
{
	while (*t = *f++)
		t++;

	return t;	/*  ptr to the null char  */
}
#endif

#ifndef YYNEAR
#define YYNEAR
#endif
#ifndef YYPASCAL
#define YYPASCAL
#endif
#ifndef YYLOCAL
#define YYLOCAL
#endif
#if ! defined YYPARSER
#define YYPARSER yyparse
#endif
#if ! defined YYLEX
#define YYLEX yylex
#endif

#if defined(YYRECURSIVE)

	YYSTATIC int yychar = -1;			/* current input token number */
	YYSTATIC int yynerrs = 0;			/* number of errors */
	YYSTATIC short yyerrflag = 0;		/* error recovery flag */

	YYSTATIC short	yyn;
	YYSTATIC short	yystate = 0;
	YYSTATIC short	*yyps= &yys[-1];
	YYSTATIC YYSTYPE	*yypv= &yyv[-1];
	YYSTATIC short	yyj;
	YYSTATIC short	yym;

#endif

YYLOCAL YYNEAR YYPASCAL YYPARSER()
{
#if !defined(YYRECURSIVE)

	register	short	yyn;
	short		yystate = 0;
	short*		yyps    = &yys[-1];
	YYSTYPE*	yypv    = &yyv[-1];
	short		yyj, yym;
#endif

#ifdef YYDUMP
	yydumpinfo();
#endif
  yystack:	 /* put a state and value onto the stack */
	yyprintf("state %d, char %d\n", yystate, yychar, 0);

	if (++yyps > &yys[YYMAXDEPTH])
	{
		yyerror("yacc stack overflow");
		YYABORT;
	}

	*yyps = yystate;
	++yypv;

	*yypv = yyval;

yynewstate:

	yyn = YYPACT[yystate];

	if (yyn <= YYFLAG)		/*  simple state, no lookahead  */
		goto yydefault;

	if (yychar < 0) 		/*  need a lookahead */
		yychar = YYLEX();

	if (((yyn += (short)yychar) < 0) || (yyn >= YYLAST))
		goto yydefault;

	if (YYCHK[ yyn = YYACT[yyn]] == yychar)
	{		
		/* valid shift */
		yychar  = -1;
		yyval   = yylval;
		yystate = yyn;

		if (yyerrflag > 0)
			--yyerrflag;
		goto yystack;
	}

 yydefault:
	/* default state action */
	if ((yyn = YYDEF[yystate]) == -2)
	{
		register short*		yyxi;

		if (yychar < 0)
			yychar = YYLEX();

/*
**  search exception table, we find a -1 followed by the current state.
**  if we find one, we'll look through terminal,state pairs. if we find
**  a terminal which matches the current one, we have a match.
**  the exception table is when we have a reduce on a terminal.
*/

#if YYOPTTIME
		for (yyxi = yyexca + yyexcaind[yystate]; *yyxi != yychar && *yyxi >= 0; yyxi += 2)
			;
#else
		for (yyxi = yyexca; *yyxi != -1 || yyxi[1] != yystate; yyxi += 2)
			;

		while (*(yyxi += 2) >= 0)
		{
			if (*yyxi == yychar)
				break;
		}
#endif

		if ((yyn = yyxi[1]) < 0)
		{
			YYACCEPT;		//	accept
		}
	}

	if (yyn == 0)		/* error */
	{
		/* error ... attempt to resume parsing */

		switch (yyerrflag)
		{
		  case 0:		/* brand new error */
#ifdef YYRECOVER
			{
				register	int		i,j;

				for (i = 0; yyrecover[i] != -1000 && yystate > yyrecover[i]; i += 3)
					;

				if (yystate == yyrecover[i])
				{
					yyprintf("recovered, from state %d to state %d on token %d\n",
										yystate, yyrecover[i + 2], yyrecover[i + 1]);

					j = yyrecover[i + 1];

					if (j < 0)
					{
						/*
						**  here we have one of the injection set, so we're not quite
						**  sure that the next valid thing will be a shift. so we'll
						**  count it as an error and continue.
						**  actually we're not absolutely sure that the next token
						**  we were supposed to get is the one when j > 0. for example,
						**  for(+) {;} error recovery with yyerrflag always set, stops
						**  after inserting one ; before the +. at the point of the +,
						**  we're pretty sure the guy wants a 'for' loop. without
						**  setting the flag, when we're almost absolutely sure, we'll
						**  give him one, since the only thing we can shift on this
						**  error is after finding an expression followed by a +
						*/
						yyerrflag++;
						j = -j;
					}

					if (yyerrflag <= 1)
					{	
						/*  only on first insertion  */
						yyrecerr(yychar, j);		/*  what was, what should be first */
					}

					yyval   = yyeval(j);
					yystate = yyrecover[i + 2];
					goto yystack;
				}
			}
#endif
			yyerror("syntax error");

		  yyerrlab:
			++yynerrs;

		  case 1:
	  	  case 2: /* incompletely recovered error ... try again */
			yyerrflag = 3;

			/* find a state where "error" is a legal shift action */
			while (yyps >= yys)
			{
			   yyn = YYPACT[*yyps] + YYERRCODE;

			   if (yyn>= 0 && yyn < YYLAST && YYCHK[YYACT[yyn]] == YYERRCODE)
			   {
			      yystate = YYACT[yyn];  /* simulate a shift of "error" */
			      goto yystack;
			   }
			   yyn = YYPACT[*yyps];

			   /* the current yyps has no shift onn "error", pop stack */
				yyprintf("error recovery pops state %d, uncovers %d\n", *yyps, yyps[-1], 0);
			   --yyps;
			   --yypv;
			}

			/* there is no state on the stack with an error shift ... abort */
		  yyabort:
		  	YYABORT;

		  case 3:  /* no shift yet; clobber input char */
			yyprintf("error recovery discards char %d\n", yychar, 0, 0);

			if (yychar == 0)
				goto yyabort; /* don't discard EOF, quit */

			yychar = -1;
			goto yynewstate;   /* try again in the same state */
		}
	}

	/* reduction by production yyn */
  yyreduce:
	{
		register	YYSTYPE	*yypvt;
		yyprintf("reduce %d\n",yyn, 0, 0);
		yypvt = yypv;
		yyps -= YYR2[yyn];
		yypv -= YYR2[yyn];
		yyval = yypv[1];
		yym = yyn;
		yyn = (short)YYR1[yyn];	/* consult goto table to find next state */
		yyj = YYPGO[yyn] + *yyps + 1;

		if (yyj >= YYLAST || YYCHK[yystate = YYACT[yyj]] != -yyn)
		{
			yystate = YYACT[YYPGO[yyn]];
		}
#ifdef YYDUMP
		yydumpinfo();
#endif
		switch (yym)
		{
			
case 1:
#line 76 "parser.y"
{ yyclearin; } break;
case 13:
#line 97 "parser.y"
{ SetNetworkSymb(yypvt[-0].zsr); } break;
case 15:
#line 100 "parser.y"
{ _eBlk = EBLKNET;  } break;
case 16:
#line 102 "parser.y"
{ _eBlk = EBLKNONE; } break;
case 19:
#line 109 "parser.y"
{	SetFormat(yypvt[-0].zsr);	} break;
case 20:
#line 110 "parser.y"
{   SetVersion(yypvt[-0].real); } break;
case 21:
#line 111 "parser.y"
{   SetCreator(yypvt[-0].zsr); } break;
case 29:
#line 128 "parser.y"
{ yyval.zsr = yypvt[-1].zsr; } break;
case 30:
#line 131 "parser.y"
{ yyval.real = yypvt[-1].real; } break;
case 31:
#line 134 "parser.y"
{ yyval.zsr = yypvt[-1].zsr; } break;
case 32:
#line 138 "parser.y"
{ _eBlk = EBLKIGN; WarningSkip(yypvt[-1].zsr); } break;
case 33:
#line 140 "parser.y"
{ SkipUntil("}"); } break;
case 34:
#line 141 "parser.y"
{ _eBlk = EBLKNONE;	} break;
case 36:
#line 145 "parser.y"
{ SkipUntil(")"); } break;
case 38:
#line 150 "parser.y"
{ _eBlk = EBLKNODE; StartNodeDecl(yypvt[-0].zsr); } break;
case 39:
#line 153 "parser.y"
{ CheckNodeInfo(); _eBlk = EBLKNONE; } break;
case 47:
#line 167 "parser.y"
{ SetNodeFullName(yypvt[-0].zsr); } break;
case 49:
#line 173 "parser.y"
{ SetNodeDomain(yypvt[-0].zsr); } break;
case 50:
#line 174 "parser.y"
{ SetNodeCstate(yypvt[-2].ui); } break;
case 55:
#line 182 "parser.y"
{ ClearCstr(); } break;
case 56:
#line 182 "parser.y"
{ SetStates();		} break;
case 60:
#line 190 "parser.y"
{ AddStr(yypvt[-0].zsr); } break;
case 63:
#line 196 "parser.y"
{ ClearCstr(); } break;
case 65:
#line 199 "parser.y"
{ SetNodePosition(yypvt[-3].integer, yypvt[-1].integer); } break;
case 66:
#line 203 "parser.y"
{ _eBlk = EBLKPROB; ClearNodeInfo(); } break;
case 67:
#line 205 "parser.y"
{ SetNodeSymb(yypvt[-0].zsr, false); } break;
case 68:
#line 207 "parser.y"
{ CheckParentList(); } break;
case 69:
#line 208 "parser.y"
{ _eBlk = EBLKNONE;		} break;
case 71:
#line 212 "parser.y"
{ EmptyProbEntries(); } break;
case 72:
#line 215 "parser.y"
{ InitProbEntries(); } break;
case 73:
#line 217 "parser.y"
{ CheckProbEntries(); } break;
case 78:
#line 226 "parser.y"
{ AddSymb(yypvt[-0].zsr); } break;
case 79:
#line 227 "parser.y"
{ AddSymb(yypvt[-0].zsr); } break;
case 86:
#line 241 "parser.y"
{ CheckCIFunc(yypvt[-1].zsr);   } break;
case 91:
#line 252 "parser.y"
{ _vui.clear(); CheckDPI(false);	} break;
case 92:
#line 253 "parser.y"
{ CheckDPI(false);				} break;
case 93:
#line 254 "parser.y"
{ CheckDPI(true);				} break;
case 94:
#line 257 "parser.y"
{ _vui.clear(); } break;
case 97:
#line 261 "parser.y"
{ AddUi(yypvt[-0].ui); } break;
case 98:
#line 262 "parser.y"
{ AddUi(yypvt[-0].ui); } break;
case 99:
#line 265 "parser.y"
{ yyval.ui = UiDpi(yypvt[-0].ui);	} break;
case 100:
#line 266 "parser.y"
{ yyval.ui = UiDpi(yypvt[-0].zsr);	} break;
case 101:
#line 267 "parser.y"
{ yyval.ui = UiDpi(yypvt[-0].zsr);	} break;
case 102:
#line 270 "parser.y"
{ _vreal.clear(); } break;
case 103:
#line 270 "parser.y"
{ CheckProbVector(); } break;
case 104:
#line 273 "parser.y"
{ CheckPDF(yypvt[-3].zsr); } break;
case 109:
#line 284 "parser.y"
{ AddReal(yypvt[-0].real); } break;
case 110:
#line 285 "parser.y"
{ AddReal(yypvt[-0].real); } break;
case 111:
#line 289 "parser.y"
{ yyval.integer = -INT(yypvt[-0].ui); } break;
case 112:
#line 290 "parser.y"
{ yyval.integer = +INT(yypvt[-0].ui); } break;
case 113:
#line 291 "parser.y"
{ yyval.integer =  INT(yypvt[-0].ui); } break;
case 114:
#line 294 "parser.y"
{ yyval.real = -yypvt[-0].real; } break;
case 115:
#line 295 "parser.y"
{ yyval.real =  yypvt[-0].real; } break;
case 117:
#line 297 "parser.y"
{ yyval.real = -1;	} break;
case 118:
#line 300 "parser.y"
{ yyval.real =      yypvt[-0].real;  } break;
case 119:
#line 301 "parser.y"
{ yyval.real = REAL(yypvt[-0].ui); } break;
case 126:
#line 310 "parser.y"
{ CheckIdent(yypvt[-0].zsr); } break;
case 131:
#line 319 "parser.y"
{ StartProperties(); } break;
case 132:
#line 321 "parser.y"
{ EndProperties(); } break;
case 138:
#line 331 "parser.y"
{ ImportPropStandard(); } break;
case 139:
#line 332 "parser.y"
{ ImportProp(yypvt[-0].zsr);		} break;
case 140:
#line 335 "parser.y"
{ AddPropType(yypvt[-4].zsr, yypvt[-2].ui, yypvt[-0].zsr);			} break;
case 141:
#line 336 "parser.y"
{ AddPropType(yypvt[-2].zsr, yypvt[-0].ui, ZSREF());		} break;
case 142:
#line 339 "parser.y"
{ yyval.ui = fPropString | fPropArray;	} break;
case 143:
#line 340 "parser.y"
{ yyval.ui = fPropArray;					} break;
case 144:
#line 341 "parser.y"
{ yyval.ui = fPropString;					} break;
case 145:
#line 342 "parser.y"
{ yyval.ui = 0;							} break;
case 146:
#line 343 "parser.y"
{ yyval.ui = fPropChoice;					} break;
case 149:
#line 352 "parser.y"
{ ClearVpv(); } break;
case 150:
#line 352 "parser.y"
{ CheckProperty(yypvt[-3].zsr); } break;
case 152:
#line 354 "parser.y"
{ ClearVpv(); } break;
case 153:
#line 354 "parser.y"
{ CheckProperty(yypvt[-3].zsr); } break;
case 158:
#line 365 "parser.y"
{ AddPropVar( yypvt[-0].zsr ); } break;
case 159:
#line 366 "parser.y"
{ AddPropVar( yypvt[-0].zsr ); } break;
case 160:
#line 367 "parser.y"
{ AddPropVar( yypvt[-0].real ); } break;
case 161:
#line 371 "parser.y"
{ ClearDomain();	} break;
case 162:
#line 373 "parser.y"
{ CheckDomain( yypvt[-1].zsr ); } break;
case 167:
#line 385 "parser.y"
{  AddRange(yypvt[-0].zsr, false ); } break;
case 168:
#line 386 "parser.y"
{  AddRange(yypvt[-0].zsr, true ); } break;
case 169:
#line 393 "parser.y"
{  SetRanges( true, yypvt[-2].real, true, yypvt[-0].real );		} break;
case 170:
#line 395 "parser.y"
{  SetRanges( yypvt[-2].zsr, yypvt[-0].zsr );					} break;
case 171:
#line 397 "parser.y"
{  SetRanges( false, 0.0, true, yypvt[-0].real );	} break;
case 172:
#line 399 "parser.y"
{  SetRanges( ZSREF(), yypvt[-0].zsr );			} break;
case 173:
#line 401 "parser.y"
{  SetRanges( true, yypvt[-1].real, false, 0.0 );	} break;
case 174:
#line 403 "parser.y"
{  SetRanges( yypvt[-1].zsr, ZSREF() );			} break;
case 175:
#line 405 "parser.y"
{  SetRanges( true, yypvt[-0].real, true, yypvt[-0].real );		} break;
case 176:
#line 407 "parser.y"
{  SetRanges( yypvt[-0].zsr, yypvt[-0].zsr );					} break;/* End of actions */
		}
	}
	goto yystack;  	/* stack new state and value */
}



#ifdef YYDUMP
YYLOCAL
void YYNEAR YYPASCAL yydumpinfo(void)
{
	short stackindex;
	short valindex;

	//dump yys
	printf("short yys[%d] {\n", YYMAXDEPTH);
	for (stackindex = 0; stackindex < YYMAXDEPTH; stackindex++){
		if (stackindex)
			printf(", %s", stackindex % 10 ? "\0" : "\n");
		printf("%6d", yys[stackindex]);
		}
	printf("\n};\n");

	//dump yyv
	printf("YYSTYPE yyv[%d] {\n", YYMAXDEPTH);
	for (valindex = 0; valindex < YYMAXDEPTH; valindex++){
		if (valindex)
			printf(", %s", valindex % 5 ? "\0" : "\n");
		printf("%#*x", 3+sizeof(YYSTYPE), yyv[valindex]);
		}
	printf("\n};\n");
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\parmio.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       parmio.cpp
//
//--------------------------------------------------------------------------

//////////////////////////////////////////////////////////////////////////////////
//
//  PARMIO.CPP:  Parameter file I/O routines
//
//////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include <iostream>
#include <fstream>
#include <iomanip>
#include <ctype.h>

#include "parmio.h"


PARMOUTSTREAM :: PARMOUTSTREAM ()
{
}

PARMOUTSTREAM :: ~ PARMOUTSTREAM ()
{
	close();
}

void PARMOUTSTREAM :: close ()
{
	while ( BEndBlock() );
	ofstream::close();
}

void PARMOUTSTREAM :: StartChunk (
	PARMBLK::EPBLK eBlk,
	SZC szc,
	int indx )
{
	_stkblk.push_back( PARMBLK(eBlk,szc,indx) );
	const PARMBLK & prmblk = _stkblk.back();
	self.nl();
	if ( szc )
	{
		Stream() << szc;
		if ( indx >= 0 )
		{
			self << CH_INDEX_OPEN << indx << CH_INDEX_CLOSE;
		}
	}
	switch( prmblk._eBlk )
	{
		case PARMBLK::EPB_VAL:
			if ( szc )
				self << CH_EQ;
			break;
		case PARMBLK::EPB_BLK:
			self.nl();
			self << CH_BLOCK_OPEN;
			break;
	}
}

void PARMOUTSTREAM :: StartBlock (
	SZC szc,
	int indx )
{
	StartChunk( PARMBLK::EPB_BLK, szc, indx );
}

void PARMOUTSTREAM :: StartItem (
	SZC szc,
	int indx )
{
	StartChunk( PARMBLK::EPB_VAL, szc, indx );
}

bool PARMOUTSTREAM :: BEndBlock ()
{
	if ( _stkblk.size() == 0 )
		return false;
	const PARMBLK & prmblk = _stkblk.back();
	switch( prmblk._eBlk )
	{
		case PARMBLK::EPB_VAL:
			self << CH_DELM_ENTRY;
			break;
		case PARMBLK::EPB_BLK:
			nl();
			self << CH_BLOCK_CLOSE;
			break;
	}
	_stkblk.pop_back();
	return true;
}

void PARMOUTSTREAM :: nl ()
{
	self << '\n';
	for ( int i = 1 ; i < _stkblk.size(); ++i)
	{
		self << '\t';
	}
}


/*
	The general YACC-style form of a parameter file is:

	itemlist :	// empty
		     |  itemlist itemunit
			 ;

	itemunit :  itemdesc itembody
			 ;

	itemdesc :  itemname '[' itemindex ']'
			 |  itemname
			 ;

	itembody :  itemblock ';'
			 |  itemvalue ';'
			 ;
			
    itemblock : '{'  itemlist '}'
			  ;

	itemvalue :  '=' itemclump
			  ;
	

	An "itemclump" is a self-describing value, comprised of quoted
	strings and parenthetically nested blocks.

 */

static const char rgchWhite [] =
{
	' ',
	'\n',
	'\t',
	'\r',
	0
};

PARMINSTREAM :: PARMINSTREAM ()
	: _iline(0),
	_zsWhite(rgchWhite)
{
}

PARMINSTREAM :: ~ PARMINSTREAM ()
{
}

void PARMINSTREAM ::  close()
{
	_stkblk.clear();
	ifstream::close();
}

bool PARMINSTREAM :: BIswhite ( char ch )
{
	return _zsWhite.find(ch) < _zsWhite.length() ;	
}

int PARMINSTREAM :: IGetc ()
{
	char ich;
	self >> ich;
	if ( ich == '\n' )
		_iline++;

	return ich;
}

void PARMINSTREAM :: ScanQuote ( char ch )
{
	int imeta = 2;
	int iline = _iline;
	do
	{
		int chNext = IGetc();
		if ( rdstate() & ios::eofbit )
			ThrowParseError("EOF in quote", iline, ECPP_UNMATCHED_QUOTE);

		switch ( chNext )
		{
			case '\'':
			case '\"':
				if ( imeta != 1  && ch == chNext )
					imeta = -1;
				else
					ScanQuote((char)chNext);
				break;
			case '\\':
				imeta = 0;
				break;
			default:
				assert( chNext >= 0 );
				break;
		}
		if ( imeta++ < 0 )
			break;
	}
	while ( true );
}

void PARMINSTREAM :: ScanBlock ( char ch )
{
	int iline = _iline;
	do
	{
		int chNext = IGetc();
		if ( rdstate() & ios::eofbit )
			ThrowParseError("EOF in block", iline, ECPP_UNEXPECTED_EOF);

		switch ( chNext )
		{
			case CH_DELM_OPEN:
				ScanBlock((char)chNext);
				break;
			case CH_DELM_CLOSE:
				return;				
				break;
			case '\'':
			case '\"':
				ScanQuote((char)chNext);
				break;
			default:
				assert( chNext >= 0 );
				break;
		}
	}
	while ( true );
}

int PARMINSTREAM :: IScanUnwhite ( bool bEofOk )
{
	int chNext;
	do
	{
		chNext = IGetc();
		if ( rdstate() & ios::eofbit )
		{
			if ( bEofOk )
				return -1;
			ThrowParseError("Unexpected EOF", -1, ECPP_UNEXPECTED_EOF);
		}
	}
	while ( BIswhite((char)chNext) ) ;
	return chNext;
}

void PARMINSTREAM :: ScanClump ()
{
	int iline = _iline;
	char chNext;
	do
	{
		switch ( chNext = (char)IScanUnwhite() )
		{
			case CH_DELM_ENTRY:		// ';'
				putback(chNext);
				return;
				break;

			case CH_DELM_OPEN:		// '('
				ScanBlock( chNext );
				break;
			case '\'':
			case '\"':
				ScanQuote( chNext );
				break;
		}
	}
	while ( true );
}

void PARMINSTREAM :: ScanName ( ZSTR & zsName )
{
	zsName.empty();
	/*for ( char chNext = IScanUnwhite();
		  zsName.length() ? __iscsymf(chNext) : __iscsym(chNext) ;
		  chNext = IGetc() )
	{
		zsName += chNext;
	} */

	// This loop is giving me errors when there is a digit in a name...
	// I think that the ? and : are reversed. __iscsymf is false if
	// the character is a digit... I assume that the required behavior
	// is that a digit cannot be the first character in a name, as opposed
	// to a digit can ONLY be the first character:

	for ( char chNext = (char)IScanUnwhite();	; chNext = (char)IGetc() )
	{
		if (zsName.length() == 0)
		{
			if (__iscsymf(chNext) == false)
			{
				// Looking for the first character in a name, and
				// the next character is not a letter or an underscore:
				// stop parsing the name.

				break;
			}
		}
		else
		{
			// (Max) 2/1/97
			//
			// I'm using '?' in names to denote booleans... this seems
			// to be reasonable, but if someone has objections this
			// can change

			if (__iscsym(chNext) == false && chNext != '?')
			{
				// Reached the end of a string of alpha-numeric
				// characters: stop parsing the name.

				break;
			}
		}

		// The next character is a valid extension of the current
		// name: append to the name and continue

		zsName += chNext;
	}

	
	putback(chNext);
}

void PARMINSTREAM :: ScanItemDesc ( ZSTR & zsName, int & indx )
{
	zsName.empty();
	indx = -1;
	ScanName(zsName);
	if ( zsName.length() == 0 )
		ThrowParseError("Invalid item or block name", -1, ECPP_INVALID_NAME );
	int chNext = IScanUnwhite();
	if ( chNext == CH_INDEX_OPEN )
	{
		self >> indx;
		chNext = IScanUnwhite();
		if ( chNext != CH_INDEX_CLOSE )
			ThrowParseError("Invalid item or block name", -1, ECPP_INVALID_NAME );
	}
	else
		putback((char)chNext);
}

PARMBLK::EPBLK PARMINSTREAM :: EpblkScanItemBody ( streamoff & offsData )
{	
	int iline = _iline;
	int ch = IScanUnwhite();
	PARMBLK::EPBLK epblk = PARMBLK::EPB_NONE;
	offsData = tellg();
	switch ( ch )
	{
		case CH_EQ:
			//  'itemvalue'
			ScanClump();
			epblk = PARMBLK::EPB_VAL;
			ch = IScanUnwhite();
			if ( ch !=  CH_DELM_ENTRY )
				ThrowParseError("Invalid item or block body", iline, ECPP_INVALID_BODY );		
			break;
		case CH_BLOCK_OPEN:
			//  'itemblock'
			ScanItemList();
			epblk = PARMBLK::EPB_BLK;
			break;
		default:
			ThrowParseError("Invalid item or block body", iline, ECPP_INVALID_BODY );
			break;
	}
	return epblk;
}

void PARMINSTREAM :: ScanItemUnit ()
{
	//  Save the index of the current block	
	int iblk = _stkblk.size() - 1;
	{
		PARMBLKIN & blkin = _stkblk[iblk];
		blkin._iblkEnd = iblk;
		blkin._offsEnd  = blkin._offsBeg = tellg();
		ScanItemDesc( blkin._zsName, blkin._indx );
	}

	//  Because the block stack vector is reallocated within
	//		this recursively invoked routine, we must be careful
	//		to reestablish the address of the block.

	streamoff offsData;
	PARMBLK::EPBLK eblk = EpblkScanItemBody( offsData );

	{
		PARMBLKIN & blkin = _stkblk[iblk];
		blkin._eBlk = eblk ;
		blkin._offsEnd = tellg();
		--blkin._offsEnd;
		blkin._offsData = offsData;
		if ( eblk == PARMBLK::EPB_BLK )
			blkin._iblkEnd = _stkblk.size();
	}
}

void PARMINSTREAM :: ScanItemList ()
{
	for ( int ch = IScanUnwhite(true);
		  ch != CH_BLOCK_CLOSE ;
		  ch = IScanUnwhite(true) )
	{
		if ( rdstate() & ios::eofbit )
			return;
		putback((char)ch);
		_stkblk.resize( _stkblk.size() + 1 );	
		ScanItemUnit();
	}
}

void PARMINSTREAM :: ThrowParseError (
	SZC szcError,
	int iline,
	EC_PARM_PARSE ecpp )
{
	ZSTR zsErr;
	if ( iline < 0 )
		iline = _iline;
	zsErr.Format( "Parameter file parse error, line %d: %s",
				  szcError, iline );
	throw GMException( ECGM(ecpp), zsErr );
}

//  Build the rapid-access table
void PARMINSTREAM :: Scan ()
{
	_stkblk.clear();
	_iline = 0;
	seekg( 0 );
	ScanItemList();
	clear();
	seekg( 0 );
}

//  Find a block or item by name (and index).  'iblk' of -1
//	means "any block"; zero means at the outermost level.
//	Return subscript of block/item or -1 if not found.
int PARMINSTREAM :: IblkFind ( SZC szcName, int index, int iblkOuter )
{
	int iblk = 0;
	int iblkEnd = _stkblk.size();

	if ( iblkOuter >= 0 )
	{
		//  We have outer block scope, validate it
		if ( ! BBlkOk( iblkOuter ) )
			return -1;
		iblk = iblkOuter + 1;
		iblkEnd = _stkblk[iblkOuter]._iblkEnd;
	}

	ZSTR zsName(szcName);

	for ( ; iblk < iblkEnd; iblk++ )
	{
		PARMBLKIN & blkin = _stkblk[iblk];

		if ( blkin._zsName != zsName )
			continue;	// Not the correct name
		
		if ( index >= 0 && blkin._indx != index )
			continue;	// Not the correct index
		
		return iblk;	// This is it
	}
	return -1;
}

//	Return the name, index and type of the next block at this level or
//  false if there are no more items.
const PARMBLKIN * PARMINSTREAM :: Pparmblk ( int iblk, int iblkOuter )
{
	if ( ! BBlkOk( iblk ) )
		return NULL;
	
	int iblkEnd = _stkblk.size();

	if ( iblkOuter >= 0 )
	{
		//  We have outer block scope, validate it
		if ( ! BBlkOk( iblkOuter ) )
			return NULL;
		if ( iblk <= iblkOuter )
			return NULL;
		iblkEnd = _stkblk[iblkOuter]._iblkEnd;
	}
	if ( iblk >= iblkEnd )
		return NULL;
	return & _stkblk[iblk];
}

void PARMINSTREAM :: Dump ()
{
	int ilevel = 0;
	VINT viBlk;		//  The unclosed block stack

	for ( int i = 0 ; i < _stkblk.size(); i++ )
	{
		// close containing blocks
		int iblk = viBlk.size();
		while ( --iblk >= 0 )
		{
			if ( i < viBlk[iblk] )
				break;  // We're still within this block
		}
		if ( iblk+1 != viBlk.size() )
			viBlk.resize(iblk+1);

		PARMBLKIN & blkin = _stkblk[i];
		cout << '\n';
		for ( int t = 0; t < viBlk.size(); t++ )
		{
			cout << '\t';
		}
		cout << "(" << i << ":" << (UINT) viBlk.size() << ",";

		if ( blkin._eBlk == PARMBLK::EPB_BLK )
		{
			cout << "block:" << blkin._iblkEnd << ") " ;
			viBlk.push_back(blkin._iblkEnd);
		}
		else
		if ( blkin._eBlk == PARMBLK::EPB_VAL )
		{
			cout << "value) ";
		}
		else
		{
			cout << "?????) ";
		}
		cout << blkin._zsName;
		if ( blkin._indx >= 0 )
			cout << '[' << blkin._indx << ']';
		cout << "  (" << blkin._offsBeg << ',' << blkin._offsData << ',' << blkin._offsEnd << ')';

	}
}

bool PARMINSTREAM :: BSeekBlk ( int iblk )
{
	if ( iblk < 0 || iblk >= _stkblk.size() )
		return false;
	
	clear();
	seekg( _stkblk[iblk]._offsData, ios::beg );
	return true;
}

//  read the parameter into a string
bool PARMINSTREAM :: BSeekBlkString ( int iblk, ZSTR & zsParam )
{
	if ( ! BSeekBlk( iblk ) )
		return false;

	PARMBLKIN & blkin = _stkblk[iblk];
	streamsize cb = blkin._offsEnd - blkin._offsData;
	zsParam.resize(cb);
	read(zsParam.begin(),cb);
	return true;
}

PARMINSTREAM::Iterator::Iterator (
	PARMINSTREAM & fprm,
	SZC szcBlock,
	int index,
	int iblkOuter )
	: _fprm(fprm),
	_iblkOuter(iblkOuter),
	_iblk(0)
{
	if ( szcBlock )
	{
		_iblk = _fprm.IblkFind( szcBlock, index, _iblkOuter );
		if ( ! _fprm.BBlkOk( _iblk ) )
			_iblk = fprm.Cblk();
		else
			++_iblk;
	}
}

const PARMBLKIN * PARMINSTREAM :: Iterator :: PblkNext ()
{
	if ( ! _fprm.BBlkOk( _iblk ) )
		return NULL;
	const PARMBLKIN * presult = _fprm.Pparmblk(_iblk, _iblkOuter);
	if ( presult )
		++_iblk;
	return presult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\parmio.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       parmio.h
//
//--------------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////////////////
//  PARMIO.H:  Parameter file I/O routines
//
//////////////////////////////////////////////////////////////////////////////////
#ifndef _PARMIO_H_
#define _PARMIO_H_

#include "stlstream.h"

//  Parameter defining a named, nestable and iteratable item in a 
//	parameter file.   There are currently two type: blocks and values.
//	A block is a grouping of values and other blocks.  A value is
//	a name = value pair.  Blocks are bounded by {}, values are terminated
//	by ';'.
struct PARMBLK
{
	enum EPBLK
	{
		EPB_NONE,		// nothing
		EPB_VAL,		// simple name = value syntax
		EPB_BLK,		// named block
		EPB_MAX
	};
	ZSTR _zsName;		// Name of value or block
	int _indx;			// index (-1 for "not present")
	EPBLK _eBlk;		// type of block

	PARMBLK ( EPBLK eBlk = EPB_NONE, SZC szc = NULL, int indx = -1 )
		: _eBlk( eBlk ),
		_indx(indx)
	{
		if ( szc )
			_zsName = szc;
	}
	bool operator == ( const PARMBLK & pblk ) const;
	bool operator != ( const PARMBLK & pblk ) const;
	bool operator > ( const PARMBLK & pblk ) const;
	bool operator < ( const PARMBLK & pblk ) const;
};

// Define a stack of PARMBLKs; used for output parameter file writing
class STKPARMBLK : public vector<PARMBLK> {};

//  Extended descriptor for a block read in from a parameter file.
//  Contains starting and ending offsets within the positionable stream.
struct PARMBLKIN : PARMBLK
{
	int _iblkEnd;			// index of last+1 item/block in scope of this block
    streamoff _offsBeg;		// Starting offset in the stream
	streamoff _offsEnd;		// Ending offset in the stream
	streamoff _offsData;	// Starting offset of the data in the block

	PARMBLKIN ( EPBLK eBlk = EPB_NONE, SZC szc = NULL, int indx = -1 )
		: PARMBLK(eBlk,szc,indx),
		_iblkEnd(-1),
		_offsBeg(-1),
		_offsEnd(-1),
		_offsData(-1)
	{
	}
	bool operator == ( const PARMBLKIN & pblkin ) const;
	bool operator != ( const PARMBLKIN & pblkin ) const;
	bool operator > ( const PARMBLKIN & pblkin ) const;
	bool operator < ( const PARMBLKIN & pblkin ) const;
};

//  Define a stack of input parameter blocks for parameter file reading
class STKPARMBLKIN : public vector<PARMBLKIN> {};

//////////////////////////////////////////////////////////////////////////////////
//
//	Class PARMOUTSTREAM.  An output stream of parameters.
//
//		Blocks and values are written out in sequence.  Blocks
//		are opened, filled and closed using member functions
//		and function templates.   All unclosed blocks are are
//		closed automatically during close().
//
//////////////////////////////////////////////////////////////////////////////////
class PARMOUTSTREAM : public ofstream
{
  public:
	PARMOUTSTREAM ();
	~ PARMOUTSTREAM ();

	void close ();
	void StartBlock ( SZC szc = NULL, int indx = -1 );
	void StartItem ( SZC szc = NULL, int indx = -1 );
	bool BEndBlock ();
	bool BEndItem () { return BEndBlock(); }
	void nl ();
	ofstream & Stream () 
		{ return (ofstream&) self; }

  protected:
	STKPARMBLK _stkblk;
	void StartChunk ( PARMBLK::EPBLK eBlk, SZC szc = NULL, int indx = -1 );
};


//////////////////////////////////////////////////////////////////////////////////
//
//	Class PARMINSTREAM.  An input stream of parameters.
//
//		The input text stream is read once during scan(), and a table of
//		all blocks and values is built.  The scan creates an outermost block
//		defining the entire file.  Then other blocks are added as discovered,
//		and their starting and ending points are recorded.  
//
//		To use, construct, open() and scan().  Then, find the named section
//		(or value) in question using ifind(), which returns the scoping level.
//		Then, either construct an Iterator (nested class) to walk through the 
//		values at that level or use ifind() to locate specific items by name.
//
//////////////////////////////////////////////////////////////////////////////////
enum EC_PARM_PARSE
{
	ECPP_PARSE_ERROR = EC_ERR_MIN,
	ECPP_UNMATCHED_QUOTE,
	ECPP_UNEXPECTED_EOF,
	ECPP_INVALID_CLUMP,
	ECPP_INVALID_NAME,
	ECPP_INVALID_BODY,
};

class PARMINSTREAM : public ifstream
{
  public:
    PARMINSTREAM ();
	~ PARMINSTREAM ();

	void close();
	//  Build the rapid-access table
	void Scan ();
	//  Find a block or item at the given level; -1 means "current level",
	//	zero means outermost level.  Returns index of block or -1 if 
	//	not found.
	int IblkFind ( SZC szcName, int index = -1, int iblkOuter = -1 );
	//	Return the next data block in the array or
	//  false if there are no more items.
	const PARMBLKIN *  Pparmblk ( int iblk, int iblkOuter = -1 );
	//  position the stream to process the parameter
	bool BSeekBlk ( int iblk );
	//  read the parameter into a string
	bool BSeekBlkString ( int iblk, ZSTR & zsParam );
	//  Pretty-print the block stack with nesting information
	void Dump ();
	//  Return true if the block index is legal
	bool BBlkOk ( int iblk ) const 
		{ return  iblk >= 0 || iblk < _stkblk.size(); }
	int Cblk () const
		{ return _stkblk.size() ; }

	ifstream & Stream () 
		{ return (ifstream&) self; }

	class Iterator
	{
	  public:
		Iterator( PARMINSTREAM & fprm, 
				  SZC szcBlock = NULL, 
				  int index = -1,
				  int iblkOuter = -1 );
		const PARMBLKIN *  PblkNext ();
		
	  protected:
		PARMINSTREAM & _fprm;
		int _iblkOuter;
		int _iblk;
	};

	friend class Iterator;

  protected:
	STKPARMBLKIN _stkblk;			// The block array
	int _iline;						// The current line number (parsing)
	ZSTR _zsWhite;					// White space character set

	void ThrowParseError ( SZC szcError, 
						   int iline = -1,
						   EC_PARM_PARSE ecpp = ECPP_PARSE_ERROR );
	int  IGetc ();
	bool BIswhite ( char ch );
	void ScanQuote ( char ch );
	void ScanClump ();
	void ScanBlock ( char ch );
	PARMBLK::EPBLK EpblkScanItemBody ( streamoff & offsData );
	int IScanUnwhite ( bool bEofOk = false );
	void ScanItemList ();
	void ScanItemUnit ();
	void ScanItemDesc ( ZSTR & zsName, int & indx ) ;
	void ScanName ( ZSTR & szName );
};

//////////////////////////////////////////////////////////////////////////////////
//  Inline functions
//////////////////////////////////////////////////////////////////////////////////
inline
PARMINSTREAM & operator >> (PARMINSTREAM & is, ZSTR & zs)
{
	ios_base::iostate _St = ios_base::goodbit;
	zs.erase();
	const ifstream::sentry _Ok(is);
	if (_Ok)
	{
		_TRY_IO_BEGIN
		size_t _N = 0 < is.width() && is.width() < zs.max_size()
						 ? is.width() 
						 : zs.max_size();
		int _C = is.rdbuf()->sgetc();
		bool bmeta = false;
		bool bfirst = true;
		for (; 0 < --_N; _C = is.rdbuf()->snextc())
		{
			if(char_traits<char>::eq_int_type(char_traits<char>::eof(), _C))
			{	
				_St |= ios_base::eofbit;
				break; 
			}
			else 
			if ( ! bmeta && _C == CH_DELM_STR )
			{
				if ( ! bfirst )
				{
					is.rdbuf()->snextc();
					break;
				}
			}
			else
			if ( _C == CH_META && ! bmeta )
			{
				bmeta = true;
			}
			else
			{
				bmeta = false;
				zs.append(1, char_traits<char>::to_char_type(_C));
			}
			bfirst = false;
		}
		_CATCH_IO_(is);
	}
	else
	{
		_THROW1(runtime_error("file exhausted extracting string"));
	}
	is.width(0);
	is.setstate(_St);
	return is; 
}

//////////////////////////////////////////////////////////////////////////////////
//	Template functions for parameter streams
//////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////
//	Write SZC: no corresponding read, since no buffer exists
//////////////////////////////////////////////////////////////////////////////////
inline
PARMOUTSTREAM & operator << (PARMOUTSTREAM & ofs, SZC szc)
{
	ofs << CH_DELM_STR;

	for ( ; *szc ; )
	{
		char ch = *szc++;
		if ( ch == CH_DELM_STR || ch == CH_META )
		{
			if (char_traits<char>::eq_int_type(char_traits<char>::eof(),
				ofs.rdbuf()->sputc(CH_META)))
				break;
		}
		if (char_traits<char>::eq_int_type(char_traits<char>::eof(),
			ofs.rdbuf()->sputc(ch)))
			break;
	}
	ofs << CH_DELM_STR;
	return ofs; 
}

//////////////////////////////////////////////////////////////////////////////////
//	Read and write ZSTRs
//////////////////////////////////////////////////////////////////////////////////
inline
PARMOUTSTREAM & operator << (PARMOUTSTREAM & ofs, const ZSTR & zs)
{
	ofs << CH_DELM_STR;

	for ( int ich = 0; ich < zs.size(); ++ich)
	{
		char ch = zs.at(ich);
		if ( ch == CH_DELM_STR || ch == CH_META )
		{
			if (char_traits<char>::eq_int_type(char_traits<char>::eof(),
				ofs.rdbuf()->sputc(CH_META)))
				break;
		}
		if (char_traits<char>::eq_int_type(char_traits<char>::eof(),
			ofs.rdbuf()->sputc(ch)))
			break;
	}
	if ( ich < zs.size() )
		_THROW1(runtime_error("file exhausted inserting string"));

	ofs << CH_DELM_STR;
	return ofs; 
}


//////////////////////////////////////////////////////////////////////////////////
//	Simple parameter output routines using insertion
//////////////////////////////////////////////////////////////////////////////////
template<class T> inline
PARMOUTSTREAM & AddParamValue ( PARMOUTSTREAM & fprm, const T & t, SZC szc, int indx = -1 )
{
	fprm.StartItem( szc, indx );
	fprm << (const T &) t;
	fprm.BEndItem();
	return fprm;
}

//////////////////////////////////////////////////////////////////////////////////
//	Simple parameter input routines using extraction
//////////////////////////////////////////////////////////////////////////////////
template<class T> inline
bool BGetParamValue ( PARMINSTREAM & fprm, T & t, SZC szc, int index = -1, int iblkOuter = -1 )
{
	int iblk = fprm.IblkFind(szc, index, iblkOuter);
	if ( iblk < 0 ) 
		return false;
	fprm.BSeekBlk(iblk);
	fprm >> t;
	return true;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\parser.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       parser.h
//
//--------------------------------------------------------------------------

# define tokenEOF 0
# define tokenNil 258
# define tokenError 259
# define tokenIdent 260
# define tokenString 261
# define tokenInteger 262
# define tokenReal 263
# define tokenArray 264
# define tokenContinuous 265
# define tokenCreator 266
# define tokenDefault 267
# define tokenDiscrete 268
# define tokenFormat 269
# define tokenFunction 270
# define tokenImport 271
# define tokenIs 272
# define tokenKeyword 273
# define tokenLeak 274
# define tokenNA 275
# define tokenName 276
# define tokenNamed 277
# define tokenNetwork 278
# define tokenNode 279
# define tokenOf 280
# define tokenParent 281
# define tokenPosition 282
# define tokenProbability 283
# define tokenProperties 284
# define tokenProperty 285
# define tokenPropIdent 286
# define tokenStandard 287
# define tokenState 288
# define tokenType 289
# define tokenUser 290
# define tokenVersion 291
# define tokenWordChoice 292
# define tokenWordReal 293
# define tokenWordString 294
# define tokenAs 295
# define tokenLevel 296
# define tokenDomain 297
# define tokenDistribution 298
# define tokenDecisionGraph 299
# define tokenBranch 300
# define tokenOn 301
# define tokenLeaf 302
# define tokenVertex 303
# define tokenMultinoulli 304
# define tokenMerge 305
# define tokenWith 306
# define tokenFor 307
# define tokenRangeOp 308
# define UNARY 309
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\parsfile.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       parsfile.cpp
//
//--------------------------------------------------------------------------

//
//	parsfile.cpp
//
#include "basics.h"
#include "parsfile.h"

PARSIN :: ~ PARSIN ()
{
}

PARSOUT :: ~ PARSOUT ()
{
}

void PARSOUT :: Fprint ( SZC szcFmt, ... ) 
{
	va_list	valist;
	va_start( valist, szcFmt );
	
	Vsprint( szcFmt, valist ) ;
	
	va_end( valist );
}

PARSIN_DSC :: PARSIN_DSC ()
	:_pfile(NULL)
{
}

PARSIN_DSC :: ~ PARSIN_DSC ()
{
	Close();
}

void PARSIN_DSC :: Close ()
{
	if ( _pfile )
		::fclose(_pfile);
	_pfile = NULL;
}

bool PARSIN_DSC :: Open ( SZC szcFileName, SZC szcMode )
{
	Close();
	_pfile = ::fopen(szcFileName,szcMode);
	_zsFn = szcFileName;
	return _pfile != NULL;
}

int PARSIN_DSC :: Getch ()
{
	if ( ! _pfile )
		return EOF;
	return ::fgetc(_pfile);
}

bool PARSIN_DSC :: BEof ()
{
	return feof(_pfile);
}

bool PARSIN_DSC :: BOpen ()	
{
	return _pfile != NULL;
}

PARSOUT_STD :: PARSOUT_STD ( FILE * pfile )
	: _pfile(pfile)
{
}

PARSOUT_STD :: ~ PARSOUT_STD ()
{
	_pfile = NULL;
}

void PARSOUT_STD :: Vsprint ( SZC szcFmt, va_list valist ) 
{
	if ( _pfile == NULL )
		return;

	vfprintf( _pfile, szcFmt, valist );	
}

void PARSOUT_STD :: Flush ()
{
	if ( _pfile )
		fflush(_pfile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\parsfile.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       parsfile.h
//
//--------------------------------------------------------------------------

//
//	parsfile.h: abstract classes for parser I/O
//
//		This abstraction layer allows parser input and output to be
//		redirected as needed.
//
#ifndef _PARSFILE_H_
#define	_PARSFILE_H_

#include <stdio.h>
#include <stdarg.h>
#include "zstr.h"

typedef const char * SZC;

//
//	PARSIN: abstract base class for parser input file handling
//
class PARSIN 
{
  public:
	PARSIN () {}
	virtual ~ PARSIN ();
	virtual void Close () = 0;
	virtual bool Open ( SZC szcFileName, SZC szcMode = "r") = 0;
	virtual int Getch () = 0;
	virtual bool BEof () = 0;
	virtual bool BOpen () = 0;
	const ZSTR & ZsFn () const 
		{ return _zsFn; }
  protected:
	ZSTR _zsFn;
};

//
//	PARSOUT:  abstract base class for parser output file
//
class PARSOUT
{
  public:
    PARSOUT () {}
	virtual ~ PARSOUT ();
	//  Print generic formatted information
	virtual void Vsprint ( SZC szcFmt, va_list valist ) = 0;
	//  Notify about error and warning information
	virtual void ErrWarn ( bool bErr, int iLine ) {}
	virtual void Flush () {}
	//  Simple output 
	void Fprint ( SZC szcFmt, ... );
};


//
//	PARSIN_DSC:  parser DSC file input based on stdio.h
//	
class PARSIN_DSC : public PARSIN
{
  public:
	PARSIN_DSC ();
	~ PARSIN_DSC ();
	void Close ();
	bool Open ( SZC szcFileName, SZC szcMode = "r" );
	int Getch ();
	bool BEof ();
	bool BOpen ();

  protected:
	FILE * _pfile;
};

//
//	PARSOUT_STD: parser output data stream based on stdio.h
//
class PARSOUT_STD : public PARSOUT
{
  public:
    PARSOUT_STD ( FILE * pfile = NULL );
	virtual ~ PARSOUT_STD ();
	void Vsprint ( SZC szcFmt, va_list valist );
	void Flush ();

  protected:
	FILE * _pfile;
};

#endif // _PARSFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\recomend.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       recomend.cpp
//
//--------------------------------------------------------------------------

//
//	recomend.cpp:  Fix-or-repair planning recommendations
//

#include <basetsd.h>
#include <math.h>
#include <float.h>
#include "algos.h"
#include "recomend.h"
#include "parmio.h"

#ifdef _DEBUG
  //#define DUMP  //  Uncomment for copious diagnostic output
#endif

const PROB probTiny = 1e-6;					//  General probability tolerance

static
ostream & operator << ( ostream & os, GPNDDDIST & gpnddist )
{
	os << "GPNDDDIST: ";
	if ( gpnddist.Pgnd() )
	{
		os << gpnddist.Pgnd()->ZsrefName().Szc()
		   << ", distribution: "
		   << gpnddist.Dist();
	}
	else
	{
		os << "<NULL>";
	}
	return os;
}

static
ostream & operator << ( ostream & os, GNODEREFP & gndref )
{
	assert( gndref.Pgndd() );
  	os << "GNODEREFP: "
	   << gndref.Gndd().ZsrefName().Szc()
	   << " (obs = "
	   << gndref.CostObserve()
	   << ", fix = "
	   << gndref.CostFix()
	   << ", util = "
	   << gndref.Util()
	   << ", lbl = "
	   << PROPMGR::SzcLbl( gndref.ELbl() )
	   << ")";
	return os;
}	

static
ostream & operator << ( ostream & os, GNODERECWORK & gnrw )
{
	os << "GNODERECWORK: "
	   << gnrw.Gndref()
	   << ", p/c = "
	   << gnrw.PbOverCost()
	   << ", p(fault) = "
	   << gnrw.PbFault();
	return os;
}

static
inline
bool BIsUnity( const REAL & r )
{
	return 1.0 - probTiny < r && r < 1.0 + probTiny;
}

static
inline
bool BEqual ( const REAL & ra, const REAL & rb )
{	
	//return fabs( ra - rb ) <= probTiny;
	return ra != 0.0
		 ? BIsUnity( rb / ra )
		 : rb == 0.0;
}

//
//	Ordering routines for arrays of GNODERECWORKs
//
typedef	binary_function<const GNODERECWORK &, const GNODERECWORK &, bool> SORTGNODERECWORK;

//  The greater the prob-over-cost, the lower the sort order
class SRTGNW_SgnProbOverCost : public SORTGNODERECWORK
{	
  public:
	bool operator () (const GNODERECWORK & gnwa, const GNODERECWORK & gnwb) const
	{	
		PROB pra = gnwa.PbOverCost();
		PROB prb = gnwb.PbOverCost();
		return pra > prb;
	}
};

//  The greater the prob fault, the lower the sort order
class SRTGNW_SgnProb : public SORTGNODERECWORK
{	
  public:
	bool operator () (const GNODERECWORK & gnwa, const GNODERECWORK & gnwb) const
	{	
		//  Force leak terms to sort high
		int iLeak = 0;
		if ( ! gnwa->BLeak() && gnwb->BLeak() )
			iLeak = -1;	// Unleak < leak
		else
		if ( gnwa->BLeak() && ! gnwb->BLeak() )
			iLeak = 1;	// Leak > Unleak
		if ( iLeak != 0 )
			return iLeak;

		PROB pra = gnwa.PbFault();
		PROB prb = gnwb.PbFault();
		return pra > prb;
	}
};

//  The lower the cost-to-observe, the lower the sort order
class SRTGNW_SgnNegCost : public SORTGNODERECWORK
{	
  public:
	bool operator () (const GNODERECWORK & gnwa, const GNODERECWORK & gnwb) const
	{	
		COST costa = gnwa.CostObsIfFixable();
		COST costb = gnwb.CostObsIfFixable();
		return costa < costb;
	}
};

//  The higher the utility, the lower the sort order
class SRTGNW_SgnUtil : public SORTGNODERECWORK
{	
  public:
	bool operator () (const GNODERECWORK & gnwa, const GNODERECWORK & gnwb) const
	{	
		COST utila = gnwa.Gndref().Util();
		COST utilb = gnwb.Gndref().Util();
		return utila > utilb;
	}
};


//
//  Construct a node reference object.  Extract properties, etc.
//
GNODEREFP :: GNODEREFP ( PROPMGR & propMgr, GNODEMBND * pgndd )
	:_pgndd(pgndd),
	_costObserve(0.0),
	_costFix(0.0),
	_costUtil(0.0),
	_eLbl(ESTDLBL_other)
{
	ASSERT_THROW( pgndd, EC_NULLP, "invalid GNOEREFP construction" );		

	PROPMBN * pprop = propMgr.PFind( *pgndd, ESTDP_cost_fix );
	if ( pprop )
		_costFix = pprop->Real();
	pprop = propMgr.PFind( *pgndd, ESTDP_cost_observe );
	if ( pprop )
		_costObserve = pprop->Real();
	pprop = propMgr.PFind( *pgndd, ESTDP_label );
	if ( pprop )
		_eLbl = (ESTDLBL) propMgr.IUserToLbl( pprop->Real() );
	_bLeak = pgndd->BFlag( EIBF_Leak );

	//  If it's unobservable, use cost-to-fix as cost-to-observe
	if ( _eLbl == ESTDLBL_fixunobs && _costObserve == 0.0 )
	{
		_costObserve = _costFix;
		_costFix = 0.0;
	}
}

//  Initialize a work record from a node reference object and its fault probability
void GNODERECWORK :: Init ( GNODEREFP * pgndref, PROB pbFault )
{
	_pgndref = pgndref;
	_pbFault = pbFault;
	_pbOverCost = 0.0;
	if ( BFixable() )
	{
		COST costObserve = _pgndref->CostObserve();
		if ( costObserve != 0.0 )
			_pbOverCost = _pbFault / costObserve;
		assert( _finite( _pbOverCost ) );
	}
}

//  Initialize a work record from a node reference object
void GNODERECWORK :: Init ( MBNET_RECOMMENDER & mbnRecom, GNODEREFP * pgndref )
{	
	MDVCPD mdv;
	_pgndref = pgndref;
	mbnRecom.InferGetBelief( _pgndref->Pgndd(), mdv );
	Init( pgndref, 1.0 - mdv[0] );
}

void VGNODERECWORK :: InitElem ( GNODEREFP * pgndref, int index /* = -1 */ )
{
	//  Grow the array as needed
	if ( index < 0 )
		index = size();
	if ( index >= size() )
		resize( index+1 );

	//  Initialize the element
	self[index].Init( MbnRec(), pgndref );
}

void VGNODERECWORK :: InitElem ( GNODEMBND * pgndd, int index )
{
	//  Find the node reference record in the recommendations object's array
	VPGNODEREFP & vpgndref = MbnRec().Vpgndref();
	int indref = vpgndref.ifind( pgndd );
	ASSERT_THROW( indref >= 0,
				  EC_INTERNAL_ERROR,
				  "node ref not found during recommendations" );

	//  Initialize using that reference
	InitElem( vpgndref[indref], index );
}


COST VGNODERECWORK :: CostService () const
{
	return MbnRec().CostService();
}

void VGNODERECWORK :: Sort ( ESORT esort )
{
	iterator ibeg = begin();
	iterator iend = end();

	switch ( esort )
	{
		case ESRT_ProbOverCost:
		{
			sort( ibeg, iend, SRTGNW_SgnProbOverCost() );
			break;
		}
		case ESRT_SgnProb:
		{
			sort( ibeg, iend, SRTGNW_SgnProb() );
			break;
		}
		case ESRT_NegCost:
		{
			sort( ibeg, iend, SRTGNW_SgnNegCost() );
			break;
		}
		case ESRT_SgnUtil:
		{
			sort( ibeg, iend, SRTGNW_SgnUtil() );
			break;
		}
		default:
		{
			THROW_ASSERT( EC_INTERNAL_ERROR, "invalid sort selector in recommendations" );
			break;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//  class INFOPLAN:
//		Encloses an array of VGNODERECWORKs, each of which is a fix-and-repair
//		sequence corresponding to a particular state of an informational node.		
//
/////////////////////////////////////////////////////////////////////////////////////////
class INFOPLAN
{
  public:
	INFOPLAN ( MBNET_RECOMMENDER & mbnRec,			//  The recommendations object
			   GNODEMBND & gndInfo,					//  The information node
			   VGNODERECWORK & vgndrwFixRepair );	//  The existing f-r sequence

	//  Compute the cost of the sequence
	COST Cost();
	//  Return true if all plans are equivalent
	bool BSameSequence()							{ return _bSameSequence; };

  protected:
	MBNET_RECOMMENDER & _mbnRec;					//  The recommendations object
	GNODEMBND & _gndInfo;							//  The info node represented
	MDVCPD _dd;										//  Unconditional probability distribution
	VVGNODERECWORK _vvgndrw;						//  Array of plan arrays
	bool _bSameSequence;							//  True if all plans are equivalent
};


INFOPLAN ::	INFOPLAN (
	MBNET_RECOMMENDER & mbnRec,
	GNODEMBND & gndInfo,		
	VGNODERECWORK & vgndrwFixRepair )
	: _mbnRec(mbnRec),
	_gndInfo(gndInfo),
	_bSameSequence(false)
{
#ifdef DUMP
	cout << "\nINFOPLAN::INFOPLAN: info node "
		 << gndInfo.ZsrefName().Szc();
#endif

	CLAMP clampInfo;	//  State of info node at call time
	_mbnRec.InferGetEvidence( & _gndInfo, clampInfo );
	assert( ! clampInfo.BActive() );
	assert( _mbnRec.ELbl( _gndInfo ) == ESTDLBL_info );

	//  Get setup information
	GNODEMBND * pgnddPDAbnormal = _mbnRec.PgnddProbDefAbnormal();
	assert( pgnddPDAbnormal );
	COST costService = _mbnRec.CostService();

	//  Get beliefs under this state of information
	_mbnRec.InferGetBelief( & _gndInfo, _dd );

	//  Resize and initialize the array of fix/repair sequences
	int cStates = _gndInfo.CState();
	_vvgndrw.resize( cStates );
	for ( int iplan = 0; iplan < cStates; iplan++ )
	{
		_vvgndrw[iplan].PmbnRec() = & _mbnRec;
	}
	_bSameSequence = true;
	
	VGPNDDDIST vgndddFixRelevant;	//  Array of relevant fixable nodes
	for ( iplan = 0; iplan < cStates; iplan++ )
	{
		//  If this state is impossible, ignore it
		PROB pbPlan = _dd[iplan];
		if ( pbPlan == 0.0 )
			continue;

#ifdef DUMP
		cout << "\nINFOPLAN clamp "
			 << gndInfo.ZsrefName().Szc()
			 << " to state = "
			 << iplan
			 << ", prob = "
			 << _dd[iplan];
#endif

		//  Clamp this info node to this state
		CLAMP clamp( true, iplan, true );
		_mbnRec.InferEnterEvidence( & _gndInfo, clamp );		

		//  Determine which nodes are relevant given this state of information
		_mbnRec.DetermineRelevantFixableNodes( vgndddFixRelevant, true, & _gndInfo );

		//  If there are no relevant fixables then the configuration is impossible
		if ( vgndddFixRelevant.size() == 0 )
			continue;

		//  Collect and sequence the relevant fixable nodes accordingly
		_mbnRec.ComputeFixSequence( vgndddFixRelevant, _vvgndrw[iplan] );

		//  See if this is a new sequence
		if ( _bSameSequence )
			_bSameSequence = vgndrwFixRepair.BSameSequence( _vvgndrw[iplan] );
	}

	//  Restore the info node to its entry state
	_mbnRec.InferEnterEvidence( & _gndInfo, clampInfo );

#ifdef DUMP
	cout << "\nINFOPLAN::INFOPLAN: END info node "
		 << gndInfo.ZsrefName().Szc();
#endif
}

COST INFOPLAN :: Cost ()
{
	VPGNODEREFP & vpgndref = _mbnRec.Vpgndref();
	int indref = vpgndref.ifind( & _gndInfo );
	assert( indref >= 0 );
	COST cost = vpgndref[indref]->CostObserve();
	ASSERT_THROW( cost != 0.0, EC_INTERNAL_ERROR, "missing observation cost for info node" );

	//  Rescale the probabilities of each planning state based upon removal of the
	//	impossible states and renormalization.
	PROB pbTotal = 0.0;
	for ( int iplan = 0; iplan < _gndInfo.CState(); iplan++ )
	{
		if ( _vvgndrw[iplan].size() > 0 )
			pbTotal += _dd[iplan];
	}

	assert( pbTotal > 0.0 );

	for ( iplan = 0; iplan < _gndInfo.CState(); iplan++ )
	{
		//  Get the rescaled probability of this state of the info node
		PROB pbPlan = _dd[iplan];
		VGNODERECWORK & vgndrw = _vvgndrw[iplan];
		if ( vgndrw.size() == 0 )
		{
			//  The plan is zero length; in other words, no fixables were relevant
			//	and the plan is impossible
			pbPlan = 0.0;
		}
		pbPlan /= pbTotal;
		COST costPlan = _vvgndrw[iplan].Cost();
		cost += costPlan * pbPlan;
	}
	return cost;
}

//  Rescale the probabilities for the fix list.   This routine sets the
//  array bounds to ignore everything from the first unfixable node and beyond.
//  Fault probabilities for the list are renormalized against the cumulative
//	probability of all the faults in the array.  Since there should be no fixable
//  nodes of significance after the first unfixable node, the "probLeak" value
//  should be very small.
void VGNODERECWORK :: Rescale ()
{
	// Accumulate totals of all fault probabilities
	PROB probTot = 0.0;
	for ( int ind = 0; ind < size(); ind++ )
	{
		probTot += self[ind].PbFault();
	}

	PROB probLeak = 1.0;		//  Renormalized leak (residual) probability
	int i1stUnfix = size();		//  Index of 1st unfixable node

	for ( ind = 0; ind < size(); ind++ )
	{	
		GNODERECWORK & gndrw = self[ind];

		if ( ! gndrw.BFixable()	)
		{
			i1stUnfix = ind;
			break;
		}

		//modified to fix the problem
		//gndrw.SetPbFault( gndrw.PbFault()/probTot);

		PROB pbTemp = gndrw.PbFault();
		if(probTot>0.0)
			pbTemp /= probTot;
		gndrw.SetPbFault( pbTemp );


		probLeak -= gndrw.PbFault();
	}

	ASSERT_THROW( probLeak >= - probTiny,
				  EC_INTERNAL_ERROR,
				  "fix/repair recommendations rescaling: residual probability too large" );

#ifdef _DEBUG
	//  Verify that there are no fixable nodes of signifcance beyond the new end point
	int cBeyond = 0;
	for ( ; ind < size(); ind++ )
	{
		GNODERECWORK & gndrw = self[ind];

		if ( gndrw.PbFault() < probTiny )
			continue;  //  highly unlikely to be significant
		if ( ! gndrw.BFixable() )
			continue;
	}
	assert( cBeyond == 0 );
#endif	

	//  Resize to discard unfixable nodes
	resize( i1stUnfix );
}

/////////////////////////////////////////////////////////////////////////////////////////
//	VGNODERECWORK::Cost()
//
//	purpose:
//		calculate cost of a fix sequence (aka ECR(E)), given by
//		Cost = Co1 + p1 * Cr1 + (1 - p1) * Co2 + p2 * Cr2 + ... + (1 - sum_i^N pi) Cservice
//
//	The 'ielemFirst' argument, if non-zero, is the index of the element to treat as first.
//	The 'piMinK' argument, if present, is set to the minimum K value computed.
/////////////////////////////////////////////////////////////////////////////////////////
COST VGNODERECWORK :: Cost (
	int ielemFirst,			//  Element to consider as first in array
	int * piMinK )			//  Location to store minimum k
{
	COST cost = 0.0;
	PROB prob = 1.0;
	const COST costService = MbnRec().CostService();
	COST costK = costService * prob;

	assert( _iFixedK == -1 || _iFixedK < size() );
	int ielem = 0;
	int iMinK = ielemFirst;
	const COST costObsProbDef = MbnRec().CostObsProbDef();
	int cSize = size();

#ifdef DUMP
	cout << "\n\nVGNODERECWORK::Cost("
		 << ielemFirst
		 << "), _iFixedK = "
		 << _iFixedK;
#endif

	for ( int iel = 0; iel < cSize; iel++ )
	{
		//  Select the array location, using ielemFirst (if present) as starting point,
		//		and skipping ielemFirst as necessary later.
		ielem = iel == 0
			? ielemFirst
			: (iel - (ielemFirst > 0 && iel <= ielemFirst));

		//  Access the next element in the array
		GNODERECWORK & gndrw = self[ielem];		
		GNODEREFP & gndref = gndrw.Gndref();
		//  If the node is unfixable, ignore it
		if ( ! gndrw.BFixable() )
			continue;

		const PROB probFault = gndrw.PbFault();
		COST costDelta = prob * gndref.CostObserve()
					   + probFault * (gndref.CostFix() + costObsProbDef);
#ifdef DUMP
		cout << "\n\t"
			 << gndrw;

		cout << "\n\t(iel="
			 << iel
			 << ",ielem="
			 << ielem
			 << ",size="
			 << cSize
			 << ")\n\t\tcostDelta("
			 << costDelta
			 << ") = prob("
			 << prob
			 << ") * costObs("
			 << gndref.CostObserve()
			 << ") + probFault("
			 << probFault
			 << ") * costFix("
			 << gndref.CostFix()
			 << ")"
			 ;
#endif

		cost += costDelta;
		prob -= probFault;
		//  Compute the cost of the sequence if service is inserted here
		COST costNow = cost + prob * costService;

#ifdef DUMP
		cout << "\n\t\tcostPrior("
			 << costK
			 << "), costNow("
			 << costNow
			 << ") = cost("
			 << cost
			 << ") + prob("
			 << prob
			 << ") * costService("
			 << costService
			 << "), (prob ="
			 << prob
			 << ")";

		cout.flush();
#endif

		// Were we better off at the last step?  Or is K fixed at this point?
		if ( costNow < costK || iel == _iFixedK )
		{
			costK = costNow;
			iMinK = ielem;
			if ( iel == _iFixedK )
				break;  //  We've reached the fixed point, so stop
		}

		ASSERT_THROW( prob >= - probTiny,
					  EC_INTERNAL_ERROR,
					  "fix/repair recommendations costing: probability underflow" );
	}

#ifdef DUMP	
	cout << "\n\t** ielem="
		 << ielem
		 << ", first element = "
		 << ielemFirst;
	if ( _iFixedK < 0 )
		cout << ", minimum k = " << iMinK;
	else
		cout << ", fixed k = " << _iFixedK;
	cout << ", cost = "
		 << costK
		 << " (residual prob = "
		 << prob
		 << ")";
#endif

	if ( _iFixedK < 0 )
	{
		if ( piMinK )
			*piMinK = iMinK;
	}

	return costK;
}

//  Set the cost of each node in the sequence
void VGNODERECWORK :: SetSequenceCost ()
{
	//  Reset any prior minimum fixed K
	_iFixedK = -1;
	//  If "fixPlan", compute the minimum K only on the first cycle,
	//		then enforce it thereafter.
	int iFixedK = -1;

	for ( int ind = 0; ind < size(); ind++ )
	{
		//  Compute the cost of the sequence with this node as first
		COST cost = Cost( ind, & iFixedK );

		//  If not "fixplan", reset K for complete search next cycle
		if ( MbnRec().ErcMethod() != MBNET_RECOMMENDER::ERCM_FixPlan )
			iFixedK = -1;
		else
		//  Else, if first cycle, fix K for remaining cycles.
		if ( ind == 0 )
			_iFixedK = iFixedK;
		self[ind].SetCost( cost );

#ifdef DUMP
		cout << "\nSetSequenceCost: "
			 << self[ind]->Gndd().ZsrefName().Szc()
			 << " = "
			 << cost;
#endif
	}

	_iFixedK = -1;
	_bSeqSet = true;
}

bool VGNODERECWORK :: BSameSequence ( const VGNODERECWORK & vgnw )
{
	if ( size() != vgnw.size() )
		return false;
	for ( int ind = 0; ind < size(); ind++ )
	{
		if ( self[ind].Gndref() != vgnw[ind].Gndref() )
			return false;
	}
	return true;
}


MBNET_RECOMMENDER :: MBNET_RECOMMENDER (
	GOBJMBN_CLIQSET & inferEng,
	ERCMETHOD ercm )
	: MBNET_NODE_RANKER( inferEng.Model() ),
	_inferEng( inferEng ),
	_propMgr( inferEng.Model() ),
	_ercm(ercm),
	_err(EC_OK),
	_pgnddPDAbnormal(NULL),
	_costService(0.0),
	_costObsProbDef(0.0),
	_bReady(false)
{
}

MBNET_RECOMMENDER :: ~ MBNET_RECOMMENDER ()
{
}


//
//  Return true if the network is in a proper state for recommendations
//  Note that we don't check whether the network has been expanded or not.
//	Since there must already be an inference engine, it's assumed that the
//	network is in its correct state.
//
bool MBNET_RECOMMENDER :: BReady ()
{
	MODEL::MODELENUM mdlenum( Model() );
	_err = EC_OK;

	_costService = CostServiceModel();
	if ( _costService == 0.0 )
	{
		_err = EC_VOI_MODEL_COST_FIX;
		return false;
	}

	//  Clear the structure
	_vpgnddFix.clear();			// Prepare to collect fixable nodes
	_vpgndref.clear();			// Clear node reference array

	//  Iterate over the nodes in the network, checking constraints.
	GELEMLNK * pgelm;
	GNODEMBND * pgndd;
	CLAMP clamp;
	int cProbDefSet = 0;		// # of instantiated PD nodes
	int cFixSetAbnorm = 0;		// # of fixables set to "abnormal"
	int cInfo = 0;				// # of info nodes	
	int cFixWithParents = 0;	// # of fixables with parents

	while ( pgelm = mdlenum.PlnkelNext() )
	{	
		//  Check only nodes
		if ( pgelm->EType() != GOBJMBN::EBNO_NODE )
			continue;

		//  We only support discrete nodes for now
		DynCastThrow( pgelm, pgndd );

		//  See if it has a label		
		ESTDLBL eLbl = ELbl( *pgndd );
		bool bRef = false;
		switch ( eLbl )
		{
			case ESTDLBL_info:
				cInfo++;
				bRef = true;
				break;

			case ESTDLBL_problem:
				InferGetEvidence( pgndd, clamp );
				if ( clamp.BActive() && clamp.Ist() != istNormal )
				{
					cProbDefSet++;  //  Problem defining node set abnormal
					_pgnddPDAbnormal = pgndd;
					PROPMBN * ppropCostObs = _propMgr.PFind( *pgndd, ESTDP_cost_observe );
					if ( ppropCostObs )
						_costObsProbDef = ppropCostObs->Real();
				}
				break;

			case ESTDLBL_fixobs:
			case ESTDLBL_fixunobs:
			case ESTDLBL_unfix:
				//  Collect fixable nodes
				_vpgnddFix.push_back( pgndd );

				//  Check that it's not set abnormal
				InferGetEvidence( pgndd, clamp );
				if ( clamp.BActive() && clamp.Ist() != istNormal )
					cFixSetAbnorm++; //  Fixable node set abnormal
				bRef = true;
				if ( pgndd->CParent() > 0 )
					cFixWithParents++;	//  Fixable node with parents
				break;

			default:
				break;
		}

		//  If necessary, create a reference item for this node
		if ( bRef )
		{
			_vpgndref.push_back( new GNODEREFP( _propMgr, pgndd ) );
		}
	}
	

	if ( cProbDefSet != 1 )
		_err = EC_VOI_PROBDEF_ABNORMAL;		//	One and only one PD node must be abnormal
	else
	if ( cFixWithParents > 0 )
		_err = EC_VOI_FIXABLE_PARENTS;		//  Some fixable node(s) has parents
	else
	if ( cFixSetAbnorm > 0 )
		_err = EC_VOI_FIXABLE_ABNORMAL;		//  No fixable nodes can be abnormal

	return _bReady = (_err == EC_OK);				
}

//  Interface to inference engine
void MBNET_RECOMMENDER :: InferGetBelief ( GNODEMBND * pgndd, MDVCPD & mdvBel )
{
	InferEng().GetBelief( pgndd, mdvBel );
}

void MBNET_RECOMMENDER :: InferGetEvidence ( GNODEMBND * pgndd, CLAMP & clamp )
{
	InferEng().GetEvidence( pgndd, clamp );
}

void MBNET_RECOMMENDER :: InferEnterEvidence ( GNODEMBND * pgndd, const CLAMP & clamp )
{
	InferEng().EnterEvidence( pgndd, clamp );
}

bool MBNET_RECOMMENDER :: BInferImpossible ()
{
	return InferEng().BImpossible();
}

void MBNET_RECOMMENDER :: PrintInstantiations ()
{
#ifdef DUMP

	GELEMLNK * pgelm;
	GNODEMBND * pgndd;
	CLAMP clamp;

	cout << "\n\tInstantiations:";

	MODEL::MODELENUM mdlenum( Model() );
	while ( pgelm = mdlenum.PlnkelNext() )
	{	
		//  Check only nodes
		if ( pgelm->EType() != GOBJMBN::EBNO_NODE )
			continue;

		//  We only support discrete nodes for now
		DynCastThrow( pgelm, pgndd );
		InferGetEvidence( pgndd, clamp );
		if ( clamp.BActive() )
		{
			cout << "\n\t\tnode "
				 << pgndd->ZsrefName().Szc()
				 << " is instantiated to state "
				 << clamp.Ist()
				 << ", "
				 << pgndd->VzsrStates()[clamp.Ist()].Szc();
		}
	}
	cout << "\n\tInstantiations end.";
#endif
}

COST MBNET_RECOMMENDER :: CostServiceModel ()
{
	//  Get the model's cost-to-fix as service cost.
	PROPMBN * ppropFixCost = _propMgr.PFind( ESTDP_cost_fix );
	COST costService = ppropFixCost
					 ? ppropFixCost->Real()
					 : 0.0;

	return costService;
}

//  Look up the label property of a node; convert to standard enumeration value.
ESTDLBL MBNET_RECOMMENDER :: ELbl ( GNODEMBN & gnd )
{
	PROPMBN * propLbl = PropMgr().PFind( gnd, ESTDP_label );
	if ( ! propLbl )
		return ESTDLBL_other;

	int iUserLbl = propLbl->Real();
	int iLbl = PropMgr().IUserToLbl( propLbl->Real() );
	return iLbl < 0
			? ESTDLBL_other
			: (ESTDLBL) iLbl;
}

//  Enter evidence for a troubleshooting model.
//
//  If the node is a fixable node being "set" to "normal", uninstantiate all
//  information nodes downstream from it.
//
void MBNET_RECOMMENDER :: EnterEvidence (
	GNODEMBND * pgndd,
	const CLAMP & clamp,
	bool bSet )
{
	if ( bSet )
	{
		ESTDLBL eLbl = ELbl( *pgndd );
		switch ( eLbl )
		{	
			case ESTDLBL_unfix:
			case ESTDLBL_fixobs:
			case ESTDLBL_fixunobs:
			{
				//  This is a fixable node
				if ( ! clamp.BActive() )
					break;	// Node is being unset
				if ( clamp.Ist() != istNormal )
					break;	// Node is not being fixed

				//  Find all downstream information nodes which are instantiated.		
				VPGNODEMBND vpgndd;
				vpgndd.push_back(pgndd);
				ExpandDownstream(vpgndd);
				CLAMP clampInfo;
				for ( int ind = 0; ind < vpgndd.size(); ind++ )
				{
					GNODEMBND * pgnddInfo = vpgndd[ind];
					ESTDLBL l = ELbl( *pgnddInfo );
					if ( l != ESTDLBL_info )
						continue;
					InferGetEvidence( pgnddInfo, clampInfo );
					if ( ! clampInfo.BActive() )
						continue;
					//  This is a clamped information node downstream from the fixable
					//  node being repaired.  Unset its instantiation.
					InferEnterEvidence( pgnddInfo, CLAMP() );
				}
				break;
			}
			default:
				break;
		}
	}
	InferEnterEvidence( pgndd, clamp );
}

//
//	Compute the probability distribution of the node and compare it to
//	the stored distribution.  Return true If it has changed.
//
bool MBNET_RECOMMENDER :: BProbsChange ( GPNDDDIST & gpndddist )
{
	MDVCPD mdv;
	//  The the distribution given the current state of evidence
	InferGetBelief( gpndddist.Pgnd(), mdv );
	//  Compare it to the other distribution
	MDVCPD & mdvo = gpndddist.Dist();
	int cprob = mdvo.first.size();
	assert( mdv.first.size() == cprob );

	for ( int i = 0; i < cprob; i++ )
	{
#ifdef DUMP	
		cout << "\n\t\tBProbsChange, state = "
			 << i
			 << ", old = "
			 << mdvo[i]
			 << ", new = "
			 << mdv[i];
#endif
		if ( ! BEqual( mdv[i], mdvo[i] ) )
		{
			return true;
		}
	}
	return false;
}

//  Add to the given array all nodes which are downstream from members
void MBNET_RECOMMENDER :: ExpandDownstream ( VPGNODEMBND & vpgndd )
{
	Model().ClearNodeMarks();
	//  Mark all nodes downstream of every given node
	for ( int i = 0; i < vpgndd.size(); i++ )
	{
		vpgndd[i]->Visit(false);	
	}

	//  Collect those nodes
	MODEL::MODELENUM mdlenum( Model() );
	GELEMLNK * pgelm;
	GNODEMBND * pgndd;
	while ( pgelm = mdlenum.PlnkelNext() )
	{	
		if ( pgelm->EType() != GOBJMBN::EBNO_NODE )
			continue;

		//  We only support discrete nodes for now
		DynCastThrow( pgelm, pgndd );
		//  Add marked nodes which are not already present
		if ( pgndd->IMark() )
		{
			appendset( vpgndd, pgndd );
		}
	}
}

void MBNET_RECOMMENDER :: DetermineRelevantFixableNodes (
	VGPNDDDIST & vgndddFixRelevant,
	bool bUsePriorList,
	GNODEMBND * pgnddInfoPlan /* = NULL */ )
{
	assert( _vpgnddFix.size() > 0 );
	assert( _pgnddPDAbnormal != NULL );

#ifdef DUMP
	cout << "\nRecommendations, DetermineRelevantFixableNodes: abnormal PD node is "
		<< _pgnddPDAbnormal->ZsrefName().Szc();
	if ( bUsePriorList )
		cout << "  (secondary invocation)";
#endif

	/*
	    If 'bUsePriorList' is false:
		    Find all the relevant fixable nodes; i.e., those fixable nodes which
		  	linked to the Problem node and which are not clamped.  If unfixed,
		    (that is, not repaired and not "unfixable"), accumulate them for a
		  	search of relevant info nodes.
		    First, visit the problem defining node which is instantiated to an
		    abnormal state and mark all upstream links to it.
	    Else, if 'bUsePriorList' is true:
		    Use the relevant fixable list previously accumulated
	*/
	
	vgndddFixRelevant.clear();	//  clear the result array
	int cfix = 0;				//  count of fixables to search
	if ( bUsePriorList )
	{
		//  Use the original list of relevant fixables
		cfix = _vgndddFixRelevant.size();
	}
	else
	{	
		//  Fill in a new list of releveant fixables
		Model().ClearNodeMarks();
		_pgnddPDAbnormal->Visit();
		cfix = _vpgnddFix.size();
	}

	//  Accumulate the list of relevant, available (unfixed) fixable nodes, to
	//		which downstream info nodes will be added
	VPGNODEMBND vpgnddDownstreamFromRelevantFixable;
	int irel = 0;
	for ( int ifix = 0; ifix < cfix; ifix++ )
	{			
		GNODEMBND * pgnddFix;
		if ( bUsePriorList )
		{	// Use prior list element
			pgnddFix = _vgndddFixRelevant[ifix].Pgnd();
		}
		else
		{	//  See if this node was marked by "visit" above
			pgnddFix = _vpgnddFix[ifix];
			if ( pgnddFix->IMark() == 0 )
				continue;  // unconnected to current problem

			CLAMP clampFix;
			InferGetEvidence( pgnddFix, clampFix );
			if ( clampFix.BActive() )
				continue;	// Fixable node has been fixed; irrelevant
		}

		//  This is an unfixed, fixable node involved in the problem;
		//		append it to the list
		vgndddFixRelevant.resize(irel+1);
		GPNDDDIST & gpnddd = vgndddFixRelevant[irel++];
		gpnddd.Pgnd() = pgnddFix;
		//  Get its current PD and save it
		InferGetBelief( gpnddd.Pgnd(), gpnddd.Dist() );
		//  If fixable, add it to the list for accumulation of relevant info nodes
		ESTDLBL eLbl = ELbl( *pgnddFix );
		if ( eLbl == ESTDLBL_fixobs || eLbl == ESTDLBL_fixunobs )
		{
			vpgnddDownstreamFromRelevantFixable.push_back( pgnddFix );				
		}
	}

#ifdef DUMP
	cout << "\n\tInstantiations before relevance check";
	PrintInstantiations();
#endif

	//  Uninstantiate the info nodes which are downstream from any
	//	RELEVANT UNFIXED fixable nodes.  The first step, which is to gather such
	//  relevant fixable nodes, has been done above.
	//
	//	Note that this is NOT done for the info node being used for INFOPLAN (ECO)
	//	generation.  Since INFOPLAN::INFOPLAN precesses this node through its states,
	//	it's pointless to uninstantiate it here.
	//
	//  Next, find all info nodes downstream from the relevant unfixed fixables.
	//  Finally, temporarily rescind the instantiations of those info nodes.

	VPNDD_IST vpnddIstReset;	//  remember pairs of node pointers and ISTs to reset later

	//  Number of unfixed fixables so far
	int cUnfixedNodes = vpgnddDownstreamFromRelevantFixable.size();
	//  Expand the collection to include all downstream nodes
	ExpandDownstream( vpgnddDownstreamFromRelevantFixable );
	//	Get number of relevant info nodes
	int cInfoNodes = vpgnddDownstreamFromRelevantFixable.size() - cUnfixedNodes;
	CLAMP clampInfo;
	CLAMP clampReset;
	int ireset = 0;

#ifdef DUMP
	cout << "\n\t"
		 << cUnfixedNodes
		 << " fixable nodes are upstream of PD, "
		 << cInfoNodes
		 << " nodes are downstream from them";
#endif

	for ( int iinfo = cUnfixedNodes;
		  iinfo < vpgnddDownstreamFromRelevantFixable.size();
		  iinfo++ )
	{
		GNODEMBND * pgnddInfo = vpgnddDownstreamFromRelevantFixable[iinfo];
		if ( ELbl( *pgnddInfo ) != ESTDLBL_info )
			continue;	//  Not an info node
		if ( pgnddInfo == pgnddInfoPlan )
			continue;	//  The info node we're planning for
		InferGetEvidence( pgnddInfo, clampInfo );
		if ( ! clampInfo.BActive() )
			continue;	//  Not clamped
#ifdef DUMP
		cout << "\n\tinfo node "
			 << pgnddInfo->ZsrefName().Szc()
			 << " is being unclamped from state "
			 << clampInfo.Ist();
#endif
		//  Instantiated info node.  Save its ptr and current state for later.
		vpnddIstReset.push_back( PNDD_IST( pgnddInfo, clampInfo.Ist() ) );
		//  Unclamp it for relevance check
		InferEnterEvidence( pgnddInfo, clampReset );
	}

	//  Walk the list of relevant fixables accumulated so far and determine those
	//	which are probabilistically relevant.  Move those which are to the front
	//	of the relevance array, then chop the stragglers off the end.

	//  Get the current state of the PD node
	CLAMP clampProblem;
	InferGetEvidence( _pgnddPDAbnormal, clampProblem );
	IST istProblemSet = clampProblem.Ist();

#ifdef DUMP
	cout << "\n\tInstantiations during relevance check";
	PrintInstantiations();
#endif

	//  Iterate over all open (non-evidenced) states of the problem defining node.
	int cNodeFix = vgndddFixRelevant.size();
	int cRelevant = 0;
	for ( IST istProblem = 0; istProblem < _pgnddPDAbnormal->CState(); istProblem++ )
	{
		//  If we've already stored every possible relevant fixable node, quit
		if ( cRelevant == cUnfixedNodes )
			break;
		//  If this is the current problem state, skip it
		if ( istProblem == istProblemSet )
			continue;

		//  Temporarily instantiate the PD node to this alternative state
		InferEnterEvidence( _pgnddPDAbnormal, CLAMP(true, istProblem, true) );
		//  If state of evidence is impossible, continue
		if ( BInferImpossible() )
			continue;

		//  Iterate over the remaining relevant fixable nodes.  As they are found to be
		//	relevant, the nodes are moved to the front of the array and not checked again.
		for ( int inode = cRelevant; inode < cNodeFix; inode++ )
		{
			GPNDDDIST & gpndddist = vgndddFixRelevant[inode];
			GNODEMBND * pgnddFix = gpndddist.Pgnd();
			CLAMP clampFix;
			InferGetEvidence( pgnddFix, clampFix );
			if ( clampFix.BActive() && clampFix.Ist() == istNormal )
				continue;	//  This fixable node has been fixed and is irrelevant

			//  If the PD of this fixable node changes for this problem instantiation,
			//		it's relevant; move it to front of array.
			if ( BProbsChange( gpndddist ) )
			{
#ifdef DUMP
				cout << "\n\tfixable node "
					 << pgnddFix->ZsrefName().Szc()
					 << " is probabilistically relevant ";
#endif
				vswap( vgndddFixRelevant, cRelevant++, inode );
			}
#ifdef DUMP
			else
			{
				cout << "\n\tfixable node "
					 << pgnddFix->ZsrefName().Szc()
					 << " is NOT probabilistically relevant ";
			}
#endif
		}
	}

	//  Resize the computed array to chop off the irrelevant nodes
	vgndddFixRelevant.resize( cRelevant );

	//  Reset the probdef node back to its current instantiation
	InferEnterEvidence( _pgnddPDAbnormal, clampProblem );

	//  Reset the uninstantiated info nodes back to their prior states
	for ( ireset = 0; ireset < vpnddIstReset.size(); ireset++ )
	{
		IST ist = vpnddIstReset[ireset].second;
		GNODEMBND * pgndd = vpnddIstReset[ireset].first;
		CLAMP clampReset(true, ist, true);
		InferEnterEvidence( pgndd, clampReset );
	}

#ifdef DUMP	
	if ( cRelevant )
	{
		cout << "\nRecommendations, DetermineRelevantFixableNodes: relevant fixables are: " ;
		for ( int ifx = 0; ifx < vgndddFixRelevant.size(); ifx++ )
		{
			cout << "\n\tnode "
				 << vgndddFixRelevant[ifx].Pgnd()->ZsrefName().Szc()
				 << " is relevant fixable #"
				 << ifx;
		}
	}
	else
	{
		cout << "\nRecommendations, DetermineRelevantFixableNodes: there are NO relevant fixables " ;
	}
#endif

}

void MBNET_RECOMMENDER :: ComputeFixSequence (
	VGPNDDDIST & vgndddFixRelevant,		//  IN: Relevant fixable nodes
	VGNODERECWORK & vgnrwFix )			//  OUT: Ordered fix/repair sequence
{
	//  Using the array of node references and the array of relevant fixable nodes,
	//		initialize the fix/repair sequence array.
	vgnrwFix.resize( vgndddFixRelevant.size() ) ;
	for ( int ind = 0; ind < vgnrwFix.size(); ind++ )
	{
		GNODEMBND * pgndd = vgndddFixRelevant[ind].Pgnd();
		vgnrwFix.InitElem( pgndd, ind );
	}

	VGNODERECWORK::ESORT esort = VGNODERECWORK::ESRT_ProbOverCost;
	switch ( _ercm )
	{
		case ERCM_MostLikely:
			esort = VGNODERECWORK::ESRT_SgnProb;
			break;
		case ERCM_Cheap:
			esort = VGNODERECWORK::ESRT_NegCost;
			break;
	}
	vgnrwFix.Sort( esort );
	vgnrwFix.Rescale();

#ifdef DUMP
	cout << "\nRecommendations, ComputeFixSequence: fix/repair sequence is:";
	for ( ind = 0; ind < vgnrwFix.size(); ind++ )
	{	
		GNODEREFP & gndref = vgnrwFix[ind].Gndref();
		cout << "\n\tnode "
			 << ind
			 << " is "
			 << gndref.Gndd().ZsrefName().Szc()
			 << ", p/c = "
			 << vgnrwFix[ind].PbOverCost()
			 << ", utility = "
			 << gndref.Util();
	}
#endif
}


//  Identify the relevant info nodes and compute their costs.
//  Formerly "BxComputeCosts()"
void MBNET_RECOMMENDER :: DetermineRelevantInfoNodes (
	VGNODERECWORK & vgnrwFix,
	VGNODERECWORK & vgnrwInfo )
{
	assert( _pgnddPDAbnormal != NULL );
	CLAMP clampInfo;

	vgnrwInfo.clear();

#ifdef DUMP
	cout << "\nRecommendations, DetermineRelevantInfoNodes:";
#endif

	for ( int ind = 0; ind < _vpgndref.size(); ind++ )
	{
		GNODEREFP * pgndref = _vpgndref[ind];
		assert( pgndref );
		if ( pgndref->ELbl() != ESTDLBL_info )
			continue;
		InferGetEvidence( pgndref->Pgndd(), clampInfo );
		// Instantiated info nodes are irrelevant	
		if ( clampInfo.BActive() )
			continue;

		//  Create an array of fix/repair plans for all states of this info node
		INFOPLAN infoplan( self, pgndref->Gndd(), vgnrwFix );

		//  If all plans result in the same sequence, it's irrelevant
		if ( infoplan.BSameSequence() )
		{
#ifdef DUMP
			cout << "\n\tinfo node "
				 <<	pgndref->Gndd().ZsrefName().Szc()
				 << " is NOT relevant; all plans are the same";
#endif
		}
		else
		{
			//  Add this info node to the array
			vgnrwInfo.InitElem( pgndref->Pgndd() );

			//  Set the utility to be the negative of the plan cost
			COST cost = infoplan.Cost();
			pgndref->Util() = - cost;

#ifdef DUMP
			cout << "\n\tinfo node "
				 <<	pgndref->Gndd().ZsrefName().Szc()
				 << " is relevant, utility = "
				 << pgndref->Util();
#endif
		}
	}
}


void MBNET_RECOMMENDER :: operator () ()
{
	//  If BReady() has not been called yet, do it now.
	if ( ! _bReady )
	{
		if ( ! BReady() )
			throw GMException( _err, "network state invalid for recommendations" );
	}

#ifdef DUMP
	cout.precision(8);
#endif

	//  Clear the "ready" flag; i.e., force subsequent call to BReady().
	Unready();

	if ( _ercm != ERCM_FixPlan )
		throw GMException( EC_NYI, "only fix/plan recommendations supported" );

	assert( _pgnddPDAbnormal );

	//  Array of fixable nodes
	VGNODERECWORK vgnrwFix( this );
	//  Array of informational nodes
	VGNODERECWORK vgnrwInfo( this );

	//  Collect the relevant fixable nodes
	DetermineRelevantFixableNodes( _vgndddFixRelevant, false, NULL );

	//  Collect and order the relevant fixable node information,
	//		sorted according to planning method and rescaled.
	ComputeFixSequence( _vgndddFixRelevant, vgnrwFix );

	//  Compute ECR, the expected cost of repair.
	vgnrwFix.SetSequenceCost();

	//  If information nodes are relevant, determine the set of them.
	if ( _ercm == ERCM_FixPlan || _ercm == ERCM_FixPlanOnly )
	{
		//  Compute ECO, the expected cost of the Observation-Repair sequence.
		DetermineRelevantInfoNodes( vgnrwFix, vgnrwInfo );
	}

	//  Collect all relevant fixables and infos and sort them
	VGNODERECWORK vgnrwRecom( this );
	vgnrwRecom.resize( vgnrwFix.size() + vgnrwInfo.size() );

	//  Add fixables...
	for ( int ind = 0; ind < vgnrwFix.size(); ind++ )
	{
		vgnrwRecom[ind] = vgnrwFix[ind];
	}
	//  Add infos...
	int indStart = ind;
	for ( ind = 0; ind < vgnrwInfo.size(); ind++ )
	{
		vgnrwRecom[indStart + ind] = vgnrwInfo[ind];
	}
	
	//  Sort by negative utility
	vgnrwRecom.Sort( VGNODERECWORK::ESRT_SgnUtil );

	//  Copy information to the output areas, ordered by lowest cost.
	//  First, determine how many are more expensive than a service call
	//	since we discard those.
	int cRecom = vgnrwRecom.size();
	int iRecom = 0;
	if ( _costService != 0.0 )
	{
		for ( iRecom = 0; iRecom < cRecom; iRecom++ )
		{
			COST cost = vgnrwRecom[iRecom].Gndref().Util();
			if ( cost >= _costService )
				break;
		}
		cRecom = iRecom;
	}

	_vzsrNodes.resize(cRecom);
	_vlrValues.resize(cRecom);

	for ( iRecom = 0; iRecom < cRecom; iRecom++ )
	{
		GNODEREFP & gndref = vgnrwRecom[iRecom].Gndref();
		//  Add the node name to the list
		_vzsrNodes[iRecom] = gndref.Gndd().ZsrefName();
		//  and give its score (utility)
		_vlrValues[iRecom] = gndref.Util();

#ifdef DUMP
		cout << "\nRecommendation # "
			 << iRecom
			 << ", node "
			 << _vzsrNodes[iRecom].Szc()
			 << " = "
			 << _vlrValues[iRecom];
		cout.flush();
#endif
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\regkey.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       regkey.cpp
//
//--------------------------------------------------------------------------

#include <windows.h>
#include "regkey.h"

LONG REGKEY::Close()
{
	LONG lRes = ERROR_SUCCESS;
	if (m_hKey != NULL)
	{
		lRes = RegCloseKey(m_hKey);
		m_hKey = NULL;
	}
	return lRes;
}

void REGKEY::Attach(HKEY hKey)
{
	assert(m_hKey == NULL);
	m_hKey = hKey;
}


LONG REGKEY::Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
	LPTSTR lpszClass, DWORD dwOptions, REGSAM samDesired,
	LPSECURITY_ATTRIBUTES lpSecAttr, LPDWORD lpdwDisposition)
{
	assert(hKeyParent != NULL);
	DWORD dw;
	HKEY hKey = NULL;
	LONG lRes = RegCreateKeyEx(hKeyParent, lpszKeyName, 0,
		lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw);
	if (lpdwDisposition != NULL)
		*lpdwDisposition = dw;
	if (lRes == ERROR_SUCCESS)
	{
		lRes = Close();
		m_hKey = hKey;
	}
	return lRes;
}

LONG REGKEY::Open(HKEY hKeyParent, LPCTSTR lpszKeyName, REGSAM samDesired)
{
	assert(hKeyParent != NULL);
	HKEY hKey = NULL;
	LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);
	if (lRes == ERROR_SUCCESS)
	{
		lRes = Close();
		assert(lRes == ERROR_SUCCESS);
		m_hKey = hKey;
	}
	return lRes;
}

LONG REGKEY::QueryValue(DWORD& dwValue, LPCTSTR lpszValueName)
{
	DWORD dwType = NULL;
	DWORD dwCount = sizeof(DWORD);
	LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
		(LPBYTE)&dwValue, &dwCount);
	assert((lRes!=ERROR_SUCCESS) || (dwType == REG_DWORD));
	assert((lRes!=ERROR_SUCCESS) || (dwCount == sizeof(DWORD)));
	return lRes;
}

LONG REGKEY::QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* pdwCount)
{
	assert(pdwCount != NULL);
	DWORD dwType = NULL;
	LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
		(LPBYTE)szValue, pdwCount);
	assert((lRes!=ERROR_SUCCESS) || (dwType == REG_SZ) ||
			 (dwType == REG_MULTI_SZ) || (dwType == REG_EXPAND_SZ));
	return lRes;
}

LONG WINAPI REGKEY::SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	assert(lpszValue != NULL);
	REGKEY key;
	LONG lRes = key.Create(hKeyParent, lpszKeyName);
	if (lRes == ERROR_SUCCESS)
		lRes = key.SetValue(lpszValue, lpszValueName);
	return lRes;
}

LONG REGKEY::SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	assert(lpszValue != NULL);
	REGKEY key;
	LONG lRes = key.Create(m_hKey, lpszKeyName);
	if (lRes == ERROR_SUCCESS)
		lRes = key.SetValue(lpszValue, lpszValueName);
	return lRes;
}

LONG REGKEY::SetValue(DWORD dwValue, LPCTSTR lpszValueName)
{
	assert(m_hKey != NULL);
	return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_DWORD,
		(BYTE * const)&dwValue, sizeof(DWORD));
}

HRESULT REGKEY::SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	assert(lpszValue != NULL);
	assert(m_hKey != NULL);
	return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_SZ,
		(BYTE * const)lpszValue, (lstrlen(lpszValue)+1)*sizeof(TCHAR));
}

//RecurseDeleteKey is necessary because on NT RegDeleteKey doesn't work if the
//specified key has subkeys
LONG REGKEY::RecurseDeleteKey(LPCTSTR lpszKey)
{
	REGKEY key;
	LONG lRes = key.Open(m_hKey, lpszKey);
	if (lRes != ERROR_SUCCESS)
		return lRes;
	FILETIME time;
	TCHAR szBuffer[256];
	DWORD dwSize = 256;
	while (RegEnumKeyEx(key.m_hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL,
		&time)==ERROR_SUCCESS)
	{
		lRes = key.RecurseDeleteKey(szBuffer);
		if (lRes != ERROR_SUCCESS)
			return lRes;
		dwSize = 256;
	}
	key.Close();
	return DeleteSubKey(lpszKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\recomend.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       recomend.h
//
//--------------------------------------------------------------------------

//
//	recomend.h:  Recommendations computations
//

#ifndef _RECOMEND_H_
#define _RECOMEND_H_

#include "cliqset.h"

const IST istNormal = 0;	//  MSRDEVBUG!

class MBNET_RECOMMENDER;

class GPNDDDIST
{
  public:
	GPNDDDIST ( GNODEMBND * pgndd = NULL )
		:_pgndd(pgndd)
	{
	}
	GNODEMBND & Gnd()
	{
		assert( _pgndd != NULL );
		return *_pgndd;
	}
	GNODEMBND * & Pgnd()
	{
		return _pgndd;
	}
	MDVCPD & Dist ()
	{ 
		return _dd; 
	}
	DECLARE_ORDERING_OPERATORS(GPNDDDIST);

  protected:
	GNODEMBND * _pgndd;
	MDVCPD _dd;
};

inline bool GPNDDDIST :: operator < ( const GPNDDDIST & gpndist ) const
{
	return _pgndd < gpndist._pgndd;
}

//  Define VGPNDDDIST, an array of GPNDDDISTs
DEFINEV(GPNDDDIST);	

//  Define a pair of node pointer and state index
typedef pair<GNODEMBND *,IST> PNDD_IST;
//  Define VPNDD_IST
DEFINEV(PNDD_IST);


//
//	Helper class containing processed node information extracted from
//	the belief network.
//
class GNODEREFP
{
  public:
	GNODEREFP ( PROPMGR & propMgr, GNODEMBND * pgndd );

	const COST CostObserve () const			{ return _costObserve;	}
	const COST CostFix () const				{ return _costFix;		}
	COST & Util ()							{ return _costUtil;		}
	ESTDLBL ELbl () const					{ return _eLbl;			}
	GNODEMBND & Gndd ()						{ return *_pgndd;		}
	GNODEMBND * Pgndd ()					{ return _pgndd;		}
	bool BLeak () const						{ return _bLeak;		}

	bool operator == ( const GNODEREFP & gndref ) const
		{ return _pgndd == gndref._pgndd ; }
	bool operator < ( const GNODEREFP & gndref ) const
		{ return _pgndd < gndref._pgndd;  }
	bool operator != ( const GNODEREFP & gndref ) const
		{ return !(self == gndref); }

	bool operator == ( const GNODEMBND * pgndd ) const
		{ return _pgndd == pgndd ; }
	bool operator < ( const GNODEMBND * pgndd  ) const
		{ return _pgndd < pgndd;  }
	bool operator != ( const GNODEMBND * pgndd ) const
		{ return !(self == pgndd); }
	
  protected:
	GNODEMBND * _pgndd;			//  Node pointer
	ESTDLBL _eLbl;				//  Standard label
	COST _costObserve;			//  Cost to observe
	COST _costFix;				//	Cost to fix
	COST _costUtil;				//  Computed utility
	bool _bLeak;				//  Leak node from CI expansion?
};

class VPGNODEREFP : public vector<GNODEREFP *>
{
  public:
	~ VPGNODEREFP ()
	{
		clear();
	}

	int ifind ( const GNODEMBND * pgndd )
	{
		for ( int indref = 0; indref < size(); indref++ )
		{
			if ( self[indref]->Pgndd() == pgndd )
				return indref;
		}
		return -1;
	}
	void clear ()
	{
		for ( int i = 0; i < size(); i++ )
			delete self[i];

		vector<GNODEREFP *>::clear();
	}
};

//	
//	Recommendations work node structure.  (Formerly 'PROBNODE')
//
class GNODERECWORK
{
	friend class VGNODERECWORK;
  public:
    GNODERECWORK ()
		: _pgndref(NULL),
		_pbFault(0),
		_pbOverCost(0)
		{}
	GNODEREFP * operator -> ()
		{ return _pgndref; }
	GNODEREFP * operator -> () const
		{ return _pgndref; }

	COST CostObsIfFixable () const
	{
		return BFixable()
			? _pgndref->CostObserve()
			: 0.0;
	}

	GNODEREFP * Pgndref () const
		{ return _pgndref; }
	GNODEREFP & Gndref ()	const	
	{
		assert( _pgndref );
		return *_pgndref;
	}
	void SetCost ( COST cost )
	{
		assert( _pgndref );
		_pgndref->Util() = - cost;
	}
	bool BFixable () const	
	{
		ESTDLBL elbl = Pgndref()->ELbl();
		return elbl == ESTDLBL_fixunobs
			|| elbl == ESTDLBL_fixobs;
	}	
	PROB PbOverCost () const		{ return _pbOverCost; }
	PROB PbFault () const			{ return _pbFault;    }
	void SetPbFault ( PROB prob )
		{ _pbFault = prob ; }

    DECLARE_ORDERING_OPERATORS(GNODERECWORK);

  protected:
    GNODEREFP * _pgndref;
	PROB _pbFault;
	PROB _pbOverCost;	

  protected:
	void Init ( MBNET_RECOMMENDER & mbnRecom, GNODEREFP * pgndref );
	void Init ( GNODEREFP * pgndref, PROB pbFault );
};

//
//	Controlled array of recommendations node work structures (Formerly RGPROBNODE).
//
class VGNODERECWORK : public vector<GNODERECWORK>
{
  public:
	VGNODERECWORK ( MBNET_RECOMMENDER * pmbnRec = NULL )
		: _pmbnRec( pmbnRec ),
		_bSeqSet( false ),
		_iFixedK(-1)
		{}

	void InitElem ( GNODEMBND * pgndd, int index = -1 );
	void InitElem ( GNODEREFP * pgndref, int index = -1 );
	enum ESORT 
	{ 
		ESRT_ProbOverCost, 
		ESRT_SgnProb, 
		ESRT_NegCost, 
		ESRT_SgnUtil 
	};

	void Sort ( ESORT esort );
	void Rescale ();
	COST Cost ( int ielemFirst = 0, int * piMinK = NULL );
	bool BSameSequence ( const VGNODERECWORK & vgnw );
	void SetSequenceCost ();
	COST CostECRDefault () const
	{
		assert( _bSeqSet );
		return size()
			 ? self[0]->Util()
			 : CostService();
	}
	MBNET_RECOMMENDER & MbnRec ()
	{
		assert( _pmbnRec );
		return *_pmbnRec;
	}
	const MBNET_RECOMMENDER & MbnRec () const
	{
		assert( _pmbnRec );
		return *_pmbnRec;
	}
	MBNET_RECOMMENDER * & PmbnRec ()
		{ return _pmbnRec; }

	COST CostService () const;

  protected:
	MBNET_RECOMMENDER * _pmbnRec;			//  The controlling recommendations object
	bool _bSeqSet;							//	Has the sequence been set yet?
	int _iFixedK;							//  Fixed state point
};

DEFINEV(VGNODERECWORK);

///////////////////////////////////////////////////////////////////////////////////////
//
//	MBNET_RECOMMENDER: 
//	
//		The troubleshooting recommendations object.  It's a "node ranker",
//		so its results are a list of node pointers and real values stored in members
//		of the base class, MBNET_NODE_RANKER.
//
//		Since all evidence is relative to a particular inference engine, that engine
//		must be used during construction.
//	
//		To invoke, use operator().  To determine if network state is compatible with
//		troubleshooting recommendations, call BReady().  If successful, the information
//		collected is saved for the next recommendations call.  To force recollection
//		of troubleshooting information, call Unready().
//
///////////////////////////////////////////////////////////////////////////////////////
class MBNET_RECOMMENDER : public MBNET_NODE_RANKER
{
  public:
	//   Recommendations computation method
	enum ERCMETHOD 
	{ 
		ERCM_None,
		ERCM_FixPlan,
		ERCM_Cheap,
		ERCM_MostLikely,
		ERCM_Random,
		ERCM_FixPlanOnly,
		ERCM_Max
	};

	//  Construct using the appropriate inference engine
	MBNET_RECOMMENDER ( GOBJMBN_CLIQSET & inferEng, 
						ERCMETHOD ercm = ERCM_FixPlan );
	virtual ~ MBNET_RECOMMENDER ();

	INT EType () const
		{ return EBNO_RANKER_RECOMMENDATIONS; }
	
	//  The ranking function
	virtual void operator () ();

	//  Return true if the network is in a state compatible with
	//		troubleshooting recommendations or sets ErcError().  Can
	//		be called separately or will be called by ranking operator().
	bool BReady ();		
	//  Clear the "ready" condition of the object
	void Unready () 
		{ _bReady = false; }
	//  Check to see if the object is in the "ready" condition
	bool BIsReady() const
		{ return _bReady; }

	//  Enter evidence for a troubleshooting model
	void EnterEvidence ( GNODEMBND * pgndd,			//  Node to set/observe
						 const CLAMP & clamp,		//  Value to set/unset
						 bool bSet = true );		//  Set or observe?

	//  Return the cost-of-service from the model; it's stored as 
	//		the model's 'cost-to-fix'.
	COST CostServiceModel ();

	//  General accessors
	ECGM EcError () const
		{ return _err; }
	ERCMETHOD ErcMethod () const
		{ return _ercm; }
	COST CostService () const
		{ return _costService; }
	COST CostObsProbDef () const
		{ return _costObsProbDef; }
	PROPMGR & PropMgr() 
		{ return _propMgr; }
	GNODEMBND * PgnddProbDefAbnormal () const
		{ return _pgnddPDAbnormal; }
	VPGNODEMBND & VpgnddFix () 
		{ return _vpgnddFix; }
	VPGNODEREFP & Vpgndref ()
		{ return _vpgndref; }
	ESTDLBL ELbl ( GNODEMBN & gnd );

 	//  Result array of relevant fixables; if 'bUsePriorList'
	//		is true, member array is starting point.  'pgnddInfo'
	//		is optional pointer to info node used in INFOPLAN.
	void DetermineRelevantFixableNodes ( VGPNDDDIST & vgndddFixRelevant,	
										 bool bUsePriorList,
										 GNODEMBND * pgnddInfoPlan = NULL );		

	void ComputeFixSequence ( VGPNDDDIST & vgndddFixRelevant,		//  IN: Relevant fixable nodes
							  VGNODERECWORK & vgnrwFix );			//  OUT: Ordered fix/repair sequence

	//  Interface to inference engine
	void InferGetBelief ( GNODEMBND * pgndd, MDVCPD & mdvBel );
	void InferGetEvidence ( GNODEMBND * pgndd, CLAMP & clamp );
	void InferEnterEvidence ( GNODEMBND * pgndd, const CLAMP & clamp );
	bool BInferImpossible ();

  protected:
	GOBJMBN_CLIQSET & _inferEng;		//  Inference engine
	PROPMGR _propMgr;					//  Property handler
	ECGM _err;							//  Last error code
	ERCMETHOD _ercm;					//  Planning method
	GNODEMBND * _pgnddPDAbnormal;		//  Abnormal PD node
	COST _costService;					//  Service cost; cost-to-fix of network
	COST _costObsProbDef;				//  Cost to observe PD node
	VPGNODEMBND _vpgnddFix;				//  Fixable nodes
	VPGNODEREFP _vpgndref;				//  Array of references to all nodes
	bool _bReady;						//  BReady() has been successfully called
	VGPNDDDIST _vgndddFixRelevant;		//  Relevant fixable nodes with unconditional distributions

  protected:
	GOBJMBN_CLIQSET & InferEng ()  
		{ return _inferEng; }

	//  Formerly "ComputeCosts"
	void DetermineRelevantInfoNodes ( VGNODERECWORK & vgnrwFix,		// IN: relevant fixables
									  VGNODERECWORK & vgnrwInfo );	// OUT: relevant infos

	//  Add to the given array all nodes which are downstream
	void ExpandDownstream ( VPGNODEMBND & vpgndd );
	//  Return true if the current state of evidence gives a different probability
	//	distribution that the one stored 
	bool BProbsChange ( GPNDDDIST & gpndddist );

	void PrintInstantiations ();

	HIDE_UNSAFE(MBNET_RECOMMENDER);
};

#endif // _RECOMEND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\regkey.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       regkey.h
//
//--------------------------------------------------------------------------

#ifndef _REGKEY_H_
#define _REGKEY_H_

#include <assert.h>

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// REGKEY: Wrapper for a registry key
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class REGKEY
{
  public:
	REGKEY() : m_hKey(NULL) {}
	~ REGKEY()	{ Close(); }

	HKEY HKey () const { return m_hKey; }
 	operator HKEY() const { return m_hKey; }

	LONG SetValue(DWORD dwValue, LPCTSTR lpszValueName);
	LONG QueryValue(DWORD& dwValue, LPCTSTR lpszValueName);
	LONG QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* pdwCount);
	LONG SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);

	LONG SetKeyValue( LPCTSTR lpszKeyName, 
					  LPCTSTR lpszValue, 
					  LPCTSTR lpszValueName = NULL);

	static LONG WINAPI SetValue( HKEY hKeyParent, 
								 LPCTSTR lpszKeyName,
								 LPCTSTR lpszValue, 
								 LPCTSTR lpszValueName = NULL);

	LONG Create( HKEY hKeyParent, 
				 LPCTSTR lpszKeyName,
				 LPTSTR lpszClass = REG_NONE, 
				 DWORD dwOptions = REG_OPTION_NON_VOLATILE,
				 REGSAM samDesired = KEY_ALL_ACCESS,
				 LPSECURITY_ATTRIBUTES lpSecAttr = NULL,
				 LPDWORD lpdwDisposition = NULL);

	LONG Open( HKEY hKeyParent, 
			   LPCTSTR lpszKeyName,
			   REGSAM samDesired = KEY_ALL_ACCESS);

	LONG Close();

	LONG RecurseDeleteKey(LPCTSTR lpszKey);

	void Attach(HKEY hKey);

	HKEY Detach()
	{
		HKEY hKey = m_hKey;
		m_hKey = NULL;
		return hKey;
	}
	LONG DeleteSubKey(LPCTSTR lpszSubKey)
	{
		assert(m_hKey != NULL);
		return RegDeleteKey(m_hKey, lpszSubKey);
	}
	LONG DeleteValue(LPCTSTR lpszValue)
	{
		assert(m_hKey != NULL);
		return RegDeleteValue(m_hKey, (LPTSTR)lpszValue);
	}

  protected:
	HKEY m_hKey;
};


#endif // _REGKEY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\propmbn.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       propmbn.cpp
//
//--------------------------------------------------------------------------

//
//	PROPMBN.CPP
//

#include <basetsd.h>
#include <assert.h>
#include <string.h>
#include "gmprop.h"
#include "gmobj.h"
#include "algos.h"

GOBJMBN * GOBJPROPTYPE :: CloneNew (
	MODEL & modelSelf,
	MODEL & modelNew,
	GOBJMBN * pgobjNew )
{
	GOBJPROPTYPE * pgproptype;
	if ( pgobjNew )
	{
		DynCastThrow( pgobjNew, pgproptype );
	}
	else
	{
		pgproptype = new GOBJPROPTYPE;
	}	
	ASSERT_THROW( GOBJMBN::CloneNew( modelSelf, modelNew, pgproptype ),
				  EC_INTERNAL_ERROR,
				  "cloning failed to returned object pointer" );

	pgproptype->_fType = _fType;
	pgproptype->_zsrComment = modelNew.Mpsymtbl().intern( _zsrComment );
	modelNew.Mpsymtbl().CloneVzsref( modelSelf.Mpsymtbl(),
									_vzsrChoice,
									pgproptype->_vzsrChoice );
	return pgproptype;
}

PROPMBN :: PROPMBN ()
	:_fType(0)
{
}

PROPMBN :: PROPMBN ( const PROPMBN & bnp )
{
	self = bnp;
}

PROPMBN & PROPMBN :: operator = ( const PROPMBN & bnp )
{
	_zsrPropType = bnp._zsrPropType;
	_fType = bnp._fType;
	_vzsrStrings = bnp._vzsrStrings;
	_vrValues = bnp._vrValues;
	return self;
}

void PROPMBN :: Init ( GOBJPROPTYPE & bnpt )
{
	_zsrPropType = bnpt.ZsrefName();
	_fType = bnpt.FPropType();
}

bool PROPMBN :: operator == ( const PROPMBN & bnp ) const
{
	return _zsrPropType == bnp._zsrPropType;
}	

bool PROPMBN :: operator < ( const PROPMBN & bnp ) const
{
	return _zsrPropType < bnp._zsrPropType;
}

bool PROPMBN :: operator == ( ZSREF zsrProp ) const
{
	return ZsrPropType() == zsrProp;
}

bool PROPMBN :: operator == ( SZC szcProp ) const
{
	return ::strcmp( szcProp, ZsrPropType().Szc() ) == 0;
}

UINT PROPMBN :: Count () const
{
	if ( _fType & fPropString )
		return _vzsrStrings.size();
	else
		return _vrValues.size();
}

ZSREF PROPMBN :: Zsr ( UINT i ) const
{
	if (  ((_fType & fPropArray) == 0 && i > 0)
		|| (_fType & fPropString) == 0)
		throw GMException(EC_PROP_MISUSE,"not a string property or not an array");
	if ( i >= _vzsrStrings.size() )
		throw GMException(EC_PROP_MISUSE,"property index out of range");
	return _vzsrStrings[i];
}

REAL PROPMBN :: Real ( UINT i ) const
{
	if (  ((_fType & fPropArray) == 0 && i > 0)
		|| (_fType & fPropString) )
		throw GMException(EC_PROP_MISUSE,"not a numeric property or not an array");
	if ( i >= _vrValues.size() )
		throw GMException(EC_PROP_MISUSE,"property index out of range");
	return _vrValues[i];
}

void PROPMBN :: Reset ()
{
	_vrValues.clear();
	_vzsrStrings.clear();
}

void PROPMBN :: Set ( ZSREF zsr )
{
	if ( (_fType & fPropString) == 0 )
		throw GMException(EC_PROP_MISUSE,"not a string property");
	Reset();
	_vzsrStrings.push_back(zsr);
}

void PROPMBN :: Set ( REAL r )
{
	if ( _fType & fPropString )
		throw GMException(EC_PROP_MISUSE,"not a numeric property");
	Reset();
	_vrValues.push_back(r);
}

void PROPMBN :: Add ( ZSREF zsr )
{
	if ( (_fType & (fPropArray | fPropString)) == 0 )
		throw GMException(EC_PROP_MISUSE,"not a string array property");
	_vzsrStrings.push_back(zsr);
}

void PROPMBN :: Add ( REAL r )
{
	if ( (_fType & fPropArray) == 0 )
		throw GMException(EC_PROP_MISUSE,"not a numeric array property");
	_vrValues.push_back(r);
}


PROPMBN * LTBNPROP :: PFind ( ZSREF zsrProp )
{	
	iterator itlt = find( begin(), end(), zsrProp );
	if ( itlt == end() )
		 return NULL;
	return & (*itlt);
}
const PROPMBN * LTBNPROP :: PFind ( ZSREF zsrProp ) const
{
	const_iterator itlt = find( begin(), end(), zsrProp );
	if ( itlt == end() )
		 return NULL;
	return & (*itlt);
}

bool LTBNPROP :: Update ( const PROPMBN & bnp )
{
	PROPMBN * pprop = PFind( bnp.ZsrPropType() );
	if ( pprop )
		*pprop = bnp;
	else
		push_back( bnp );
	return pprop != NULL;
}

//  Force the list to contain only unique elements.  Note that
//  the act of sorting and uniquing will discard duplicates randomly.
bool LTBNPROP :: Uniqify ()
{
	int cBefore = size();
	sort();
	unique();
	return size() == cBefore;
}

//  Clone from another list with another symbol table
void LTBNPROP :: Clone (
	MODEL & model,
	const MODEL & modelOther,
	const LTBNPROP & ltbnOther )
{
	for ( const_iterator itlt = ltbnOther.begin(); itlt != ltbnOther.end(); itlt++ )
	{
		const PROPMBN & prpOther = (*itlt);
		//  Note that the dynamic cast below will test for failure to
		//		find property type object
		GOBJMBN * pgobj = model.PgobjFind( prpOther.ZsrPropType() );
		ASSERT_THROW( pgobj != NULL,
					  EC_INTERNAL_ERROR,
					  "missing property type in target network during cloning" );
		GOBJPROPTYPE * pgobjPropType;
		DynCastThrow( pgobj, pgobjPropType );
		PROPMBN prp;
		prp.Init( *pgobjPropType );
		model.Mpsymtbl().CloneVzsref( modelOther.Mpsymtbl(),
									  prpOther._vzsrStrings,
									  prp._vzsrStrings );
		prp._vrValues = prpOther._vrValues;
		push_back( prp );
	}
}

static
struct MPVOIPROPSZC
{
	ESTDPROP _eProp;
	SZC _szcProp;
}
vVoiProp [] =
{
	{ ESTDP_label,			"MS_label"			},
	{ ESTDP_cost_fix,		"MS_cost_fix"		},
	{ ESTDP_cost_observe,	"MS_cost_observe"	},
	{ ESTDP_category,		"MS_category"		},
	{ ESTDP_normalState,	"MS_normalState"	},
	{ ESTDP_max,			NULL				}
};

static
struct MPLBLSZC
{
	ESTDLBL _eLbl;
	SZC _szcLbl;
}
vLblSzc [] =
{
	{ ESTDLBL_other,		"other"			},
	{ ESTDLBL_hypo,			"hypothesis"	},
	{ ESTDLBL_info,			"informational"	},
	{ ESTDLBL_problem,		"problem"		},
	{ ESTDLBL_fixobs,		"fixobs"		},
	{ ESTDLBL_fixunobs,		"fixunobs"		},
	{ ESTDLBL_unfix,		"unfixable"		},
	{ ESTDLBL_config,		"configuration"	},
	{ ESTDLBL_max,			NULL			}
};

SZC PROPMGR :: SzcLbl ( int iLbl )
{
	SZC szcOther = NULL;
	for ( int i = 0; vLblSzc[i]._szcLbl; i++ )
	{
		if ( vLblSzc[i]._eLbl == iLbl )
			return vLblSzc[i]._szcLbl;
		if ( vLblSzc[i]._eLbl == ESTDLBL_other )
			szcOther = vLblSzc[i]._szcLbl;
	}
	return szcOther;
}


PROPMGR :: PROPMGR ( MODEL & model )
	: _model(model)
{
	//  Locate all the standard property types; save their
	//	name references whether or not they've been declared.
	SZC szcProp;
	for ( int i = 0; szcProp = vVoiProp[i]._szcProp ; i++ )
	{	
		GOBJPROPTYPE * ppt = NULL;
		_vzsrPropType.push_back( _model.Mpsymtbl().intern( szcProp ) );
		GOBJMBN * pgobj = _model.PgobjFind( szcProp );
		if ( pgobj )
		{
			if ( pgobj->EType() == GOBJMBN::EBNO_PROP_TYPE )
			{	
				DynCastThrow( pgobj, ppt );
			}
		}
		_vPropMap[i] = ppt;
	}

	//  If we found "MS_label", prepare the correspondence table
	GOBJPROPTYPE * pptLabel = _vPropMap[ESTDP_label];

	if ( pptLabel && (pptLabel->FPropType() & fPropChoice) > 0 )
	{
		SZC szcChoice;
		const VZSREF & vzsr	= pptLabel->VzsrChoice();
		_vUserToLbl.resize( vzsr.size() );

		//  Clear the user-to-standard-label map
		for ( i = 0; i < _vUserToLbl.size(); )
			_vUserToLbl[i++] = -1;

		for ( i = 0; szcChoice = vLblSzc[i]._szcLbl; i++ )
		{
			int iLbl = -1;
			ZSREF zsrChoice = _model.Mpsymtbl().intern( szcChoice );
			for ( int j = 0; j < vzsr.size(); j++ )
			{
				if ( zsrChoice == vzsr[j] )
				{
					iLbl = j;
					//  Mark which standard label this user element corresponds to
					_vUserToLbl[iLbl] = i;
					break;
				}
			}
			//  Mark which user element this standard label corresponds to
			_vLblToUser[i] = iLbl;
		}
	}
	else
	{	// Clear the correspondence information
		for ( i = 0; i < ESTDLBL_max; i++ )
		{
			_vLblToUser[i] = -1;
		}
	}
}

GOBJPROPTYPE * PROPMGR :: PPropType ( ESTDPROP evp )
{
	return _vPropMap[evp];
}

//  Return the name of the standard property
ZSREF PROPMGR :: ZsrPropType ( ESTDPROP evp )
{	
	ASSERT_THROW( evp >= 0 && evp < ESTDP_max,
				  EC_INTERNAL_ERROR,
				  "invalid property type usage" );
	return _vzsrPropType[evp];
}


//  Find a standard property in a property list
PROPMBN * PROPMGR :: PFind ( LTBNPROP & ltprop, ESTDPROP estd )
{
	return ltprop.PFind( ZsrPropType(estd) ) ;
}

//  Find a standard property in the associated model's property list
PROPMBN * PROPMGR :: PFind ( ESTDPROP estd )
{
	return _model.LtProp().PFind( ZsrPropType(estd) ) ;
}

//  Find a standard property in a node's property list
PROPMBN * PROPMGR :: PFind ( GNODEMBN & gnd, ESTDPROP estd )
{
	return gnd.LtProp().PFind( ZsrPropType(estd) ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\stlstream.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       stlstream.h
//
//--------------------------------------------------------------------------

//
//	stlstream.h:  Stream STL template classes.
//
//		Templates in this file typically generate functions which take a 
//		stream reference as an argument, along with a const reference to
//		the thing to be streamed; it returns a reference to the stream.
//
//		The reason that the stream parameter must be included in the 
//		template is generate a function which returns the correct stream type.
//		If the stream type were not a templated argument, then the 
//		template would be forced to return a single immutable type, such 
//		as "ostream".  This would cause cascaded stream insertion operators
//		to fail to compile, since type errors would occur in the middle of the
//		sequence.  In the following example, assume that there is a special
//		insertion operator defined between class MYSTREAM and class Y:
//
//			MYSTREAM myst;
//			extern MYSTREAM & operator << ( MYSTREAM & m, const Y & y );
//			X x;
//			Y y;
//
//			myst << x		// Template function generated and called
//				 << y;		// ERROR: return value of template function 
//							//    incorrect for special operator above.
//
#ifndef _STLSTREAM_H_
#define _STLSTREAM_H_

#include <iostream>			// C++ RTL/STL Streams inclusion
#include <fstream>

#include "mscver.h"			// Version-dependent stuff
#include "zstr.h"			// ZSTR handling
#include "mdvect.h"			// Multi-dimensional vector handling

//  Delimiters used in parameter files
#define	CH_EOS			((char)0)		// End of string
#define	CH_DELM_OPEN	((char)'(')		// Start of value group
#define	CH_DELM_CLOSE	((char)')')		// End of value group
#define	CH_BLOCK_OPEN	((char)'{')		// Start of value block
#define	CH_BLOCK_CLOSE	((char)'}')		// End of value block
#define CH_INDEX_OPEN   ((char)'[')		// Name index start
#define CH_INDEX_CLOSE  ((char)']')		// Name index end
#define	CH_PREAMBLE		((char)':')		// Delmiter for array size
#define	CH_FILL			((char)' ')		// Fill character
#define CH_SEP			((char)',')		// Value group separator
#define CH_DELM_STR		((char)'\"')	
#define CH_META			((char)'\\')
#define CH_DELM_ENTRY	((char)';')
#define CH_EQ			((char)'=')
#define CH_NAME_SEP     ((char)'.')

//////////////////////////////////////////////////////////////////////////////////
//	Read and write STL pairs from or to a stream
//////////////////////////////////////////////////////////////////////////////////

template<class _OS, class _First, class _Second> inline
_OS & operator << (_OS & os, const pair<_First,_Second> & pr)
{
	os << CH_DELM_OPEN;
	os << pr.first;
	os << pr.second;
	os << CH_DELM_CLOSE;
	return os;
}

template<class _IS, class _First, class _Second> inline
_IS & operator >> (_IS & is, pair<_First,_Second> & pr)
{
	char ch;
	is >> ch;
	if (ch != CH_DELM_OPEN)
		_THROW1(runtime_error("invalid block: pair >> (1)"));

	is >> pr.first;
	is >> pr.second;

	is >> ch;
	if (ch != CH_DELM_CLOSE)
		_THROW1(runtime_error("invalid block: pair >> (2)"));
	return is;
}  

//////////////////////////////////////////////////////////////////////////////////
//	Read and write STL vectors from or to a stream
//////////////////////////////////////////////////////////////////////////////////
template<class _OS, class _T> inline
_OS & operator << (_OS & os, const vector<_T>& vt )
{
	os << CH_DELM_OPEN;
	os << (UINT) vt.size();
	os << CH_PREAMBLE;
	for ( size_t i = 0; i < vt.size(); )
	{	
		os << vt[i];
		if ( ++i != vt.size() )	
			os << ',' ;
	}
	os << CH_DELM_CLOSE;
	return os;
}

template<class _IS, class _T> inline
_IS & operator >> (_IS & is, vector<_T>& vt )
{
	char ch;
	is >> ch;
	if (ch != CH_DELM_OPEN)
		_THROW1(runtime_error("invalid block: vector>> (1)"));
	size_t l;
	is >> l;
	is >> ch;
	if (ch != CH_PREAMBLE)
		_THROW1(runtime_error("invalid block: vector>> (2)"));

	vt.resize(l);
	for ( size_t i = 0 ; i < l; )
	{
		_T it;
		is >> it;
		vt[i] = it;
		if ( ++i < l )
		{
			is >> ch;
			if (ch != CH_SEP)
				break;
		}
	}
	if ( i != l )
		_THROW1(runtime_error("invalid block: vector>> (3)"));
	is >> ch;
	if (ch != CH_DELM_CLOSE)
		_THROW1(runtime_error("invalid block: vector>> (4)"));
	return is;
}

//////////////////////////////////////////////////////////////////////////////////
//	Read and write STL valarrays from or to a stream
//////////////////////////////////////////////////////////////////////////////////
template<class _OS, class _T> inline
_OS & operator << ( _OS & os, const valarray<_T>& vt )
{
	os << CH_DELM_OPEN;
	os << (UINT) vt.size();
	os << CH_PREAMBLE;
	for ( int i = 0;
		  i < vt.size() ; )
	{	
		os << vt[i];
		if ( ++i != vt.size() )	
			os << ',' ;
	}
	os << CH_DELM_CLOSE;
	return os;
}

template<class _IS, class _T> inline
_IS & operator >> (_IS & is, valarray<_T>& vt )
{
	char ch;
	is >> ch;
	if (ch != CH_DELM_OPEN)
		_THROW1(runtime_error("invalid block: valarray >> (1)"));
	size_t l;
	is >> l;
	is >> ch;
	if (ch != CH_PREAMBLE)
		_THROW1(runtime_error("invalid block: valarray >> (2)"));

	vt.resize(l);
	for ( size_t i = 0 ; i < l; )
	{
		_T it;
		is >> it;
		vt[i] = it;
		if ( ++i < l )
		{
			is >> ch;
			if (ch != CH_SEP)
				break;
		}
	}
	if ( i != l )
		_THROW1(runtime_error("invalid block: valarray >> (3)"));
	is >> ch;
	if (ch != CH_DELM_CLOSE)
		_THROW1(runtime_error("invalid block: valarray >> (4)"));
	return is;
}


//////////////////////////////////////////////////////////////////////////////////
//	Read and write MDVSLICEs from or to a stream
//////////////////////////////////////////////////////////////////////////////////
template<class _OS> inline
_OS & operator << (_OS & os, const MDVSLICE & mslice )
{	
	os << CH_DELM_OPEN;
	os << (UINT) mslice.start();
	os << mslice.size();
	os << mslice.stride();
	os << CH_DELM_CLOSE;
	return os;
}

template<class _IS> inline
_IS & operator >> ( _IS & is, MDVSLICE & mslice )
{	
	char ch;
	is >> ch;
	if (ch != CH_DELM_OPEN)
		_THROW1(runtime_error("invalid block: slice >> (1)"));
	VIMD vimdLen;
	VIMD vimdStride;
	size_t lStart;
	is >> lStart;
	is >> vimdLen;
	is >> vimdStride;
	mslice = MDVSLICE( lStart, vimdLen, vimdStride );
	
	is >> ch;
	if (ch != CH_DELM_CLOSE)
		_THROW1(runtime_error("invalid block: slice >> (2)"));
	return is;
}

//////////////////////////////////////////////////////////////////////////////////
//	Format (pretty-print) MDVDENSEs using an Iterator.
//
//  This is NOT the same as streaming out an MDVDENSE; it formats the array for
//	easy reading.  Note that it requires an Iterator.
//	
//	MSRDEVBUG: This, too, should be templatized, but there's a bug in template
//		expansion using nested class names.
//////////////////////////////////////////////////////////////////////////////////
inline 
ostream & operator << ( ostream & os, TMDVDENSE<double>::Iterator & itmdv )
{
	os << "\ndump of mdvect,\n\t\tslice = "
		<< itmdv.Slice();

	if ( itmdv.Slice() != itmdv.Mdv().Slice() )
	{
		os << ",\n\t\toriginal slice = "
		   << itmdv.Mdv().Slice();
	}
	if ( itmdv.BReorder() )
	{
		os << ",\n\t\treordered ";
		os << itmdv.VimdReorder();
	}
	os << '.';
	itmdv.Reset();
	for ( int ii = 0 ; itmdv.BNext() ; ii++ )
	{
		const VIMD & vimd = itmdv.Vitmd();
		cout << "\n\t[";
		for ( int i = 0 ; i < vimd.size(); i++ )
		{
			cout << vimd[i];
			if ( i + 1 < vimd.size() )
				cout << ",";
		}	
		size_t indx = itmdv.Indx();
		const double & t = itmdv.Next();
		cout << "] ("
			<< ii
			<< '='
			<< (UINT) indx
			<< ") = "
			<< t;
	}
	return os;
}

#endif //  _STLSTREAM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\refcnt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       refcnt.h
//
//--------------------------------------------------------------------------

//
//	refcnt.h:  base class for reference-counted objects
//
#ifndef _REFCNT_H_
#define _REFCNT_H_

class REFCNT
{
  public:
	//  Bind the object again
 	void Bind ()			{ IncRef(1) ;		}
	//  Release the object
	void Unbind ()			{ IncRef(-1) ;		}
	//  Return the reference count
	UINT CRef() const		{ return _cref;		}

  protected:
	REFCNT() : _cref(0) {}

	//	Virtual call-out when reference count goes to zero
	virtual void NoRef () {}

  private:
	UINT _cref;			// Number of references to this 

  protected:
	void IncRef ( int i = 1 )
	{
		 if ((_cref += i) > 0 )
			return;
		_cref = 0;
		NoRef();
	}
	// Hide the assignment operator
	HIDE_AS(REFCNT);		
};


////////////////////////////////////////////////////////////////////
//	template REFPOBJ:  Smart pointer wrapper template.  Knows
//		to destroy the pointed object when it itself is destroyed.
////////////////////////////////////////////////////////////////////
class ZSREF;

template<class T>
class REFPOBJ
{
	//  Friendship is required for manipulation by the symbol table
	friend pair<ZSREF, REFPOBJ<T> >;
	friend map<ZSREF, REFPOBJ<T>, less<ZSREF> >;

  public:
	~ REFPOBJ ()
		{ Deref(); }

	// Return the real object 
	T * Pobj () const
		{ return _pobj ; } 
	// Allow a REFPOBJ to be used wherever a T * is required
	operator T * () const
		{ return _pobj ; }
	// Operator == compares only pointers.
	bool operator == ( const REFPOBJ & pobj ) const
		{ return _pobj == pobj._pobj; }

	T * MoveTo (REFPOBJ & pobj)
	{
		pobj = Pobj();
		_pobj = NULL;
		return pobj;
	};


 	REFPOBJ & operator = ( T * pobj ) 
	{
		Deref();
		_pobj = pobj;
		return *this;
	}

 protected:
	REFPOBJ ()
		: _pobj(NULL)
		{}
  protected:
	T * _pobj;

  private:
	void Deref ()
	{
		delete _pobj;
		_pobj = NULL;
	}

	HIDE_AS(REFPOBJ);
};

////////////////////////////////////////////////////////////////////
//	template REFCWRAP:  Smart pointer wrapper template for objects
//		using REFCNT semantics.
////////////////////////////////////////////////////////////////////
template<class T>
class REFCWRAP
{
  public:
	REFCWRAP (T * pobj = NULL)	
		: _pobj(NULL) 
	{
		Ref( pobj );
	}
	~ REFCWRAP () 
	{ 
		Deref(); 
	}
	REFCWRAP ( const REFCWRAP & refp )
		: _pobj(NULL)
	{
		Ref( refp._pobj );
	}

	// Return true if there's a referenced object
	bool BRef () const
		{ return _pobj != NULL; }

	// Return the real object 
	T * Pobj () const
		{ return _pobj ; } 

	// Allow a REFPOBJ to be used wherever a T * is required
	operator T * () const
		{ return _pobj ; }
	// Operator == compares only pointers.
	bool operator == ( const REFCWRAP & pobj ) const
		{ return _pobj == pobj._pobj; }
	T * operator -> () const
	{ 
		assert( _pobj );
		return _pobj; 
	}
 	REFCWRAP & operator = ( T * pobj ) 
	{
		Ref(pobj);
		return *this;
	}
 	REFCWRAP & operator = ( const REFCWRAP & refp ) 
	{
		Ref(refp._pobj);
		return *this;
	}

	void Deref ()
	{
		if ( _pobj )
		{
			_pobj->Unbind();
			_pobj = NULL;
		}
	}

  protected:
	T * _pobj;

  private:
	void Ref ( T * pobj )
	{
		Deref();
		if ( pobj )
		{
			pobj->Bind();
			_pobj = pobj;
		}
	}
};
	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\symt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       symt.cpp
//
//--------------------------------------------------------------------------

//
//  SYMT.CPP
//

#include <basetsd.h>
#include <iostream>
#include <fstream>
#include <string.h>
#include "model.h"
#include "symtmbn.h"

//
//	Create a duplicate of the given token array given a source token
//		array and the symbol table associated with this token array.
//
void VTKNPD :: Clone ( MPSYMTBL & mpsymtbl, const VTKNPD & vtknpd )
{
	ASSERT_THROW( size() == 0,
				EC_INVALID_CLONE,
				"cannot clone into non-empty structure" );
	resize( vtknpd.size() );
	for ( int i = 0; i < size(); i++ )
	{
		TKNPD & tk = self[i];
		const TKNPD & tkOther = vtknpd[i];
		//  Get the token's string pointer or NULL if it's not a string
		if ( tkOther.BStr() )
		{
			SZC szcOther = tkOther.Szc();
			assert( szcOther && strlen( szcOther ) > 0 );
			tk = mpsymtbl.intern(szcOther);
		}
		else
		{
			tk = tkOther.Dtkn();
		}
	}
}

ZSTR VTKNPD :: ZstrSignature ( int iStart ) const
{
	ZSTR zs;
	bool bPdSeen = false;
	for ( int i = iStart; i < size(); i++ )
	{
		const TKNPD & tknpd = self[i];
		switch ( tknpd.UiTkn() )
		{
			case DTKN_PD:
				zs += _T("p(");
				bPdSeen = true;
				break;
			case DTKN_COND:
				zs += _T("|");
				break;
			case DTKN_AND:
				zs += _T(",");
				break;
			case DTKN_EQ:
				zs += _T("=");
				break;
			case DTKN_DIST:
				zs += _T("d(");
				bPdSeen = true;
				break;
			case DTKN_QUAL:
				zs += _T(":");
				break;

			case DTKN_STRING:
			{
				// It's the name of a node
				SZC szcName = tknpd.Szc();
				assert( szcName );
				bool bLegal = MODEL::BSzLegal( szcName );
				if ( ! bLegal )
					zs += _T("\"") ;
				zs += szcName;
				if ( ! bLegal )
					zs += _T("\"") ;
				break;
			}
				
			default:
			{
				if ( tknpd.UiTkn() >= DTKN_STATE_BASE && tknpd.UiTkn() < DTKN_TOKEN_MIN )
					// It's a discrete state index
					zs.FormatAppend(_T("%d"), tknpd.UiTkn() - DTKN_STATE_BASE);
				else
					//  Huh?
					zs += _T("?ERR?");
				break;
			}
		}
	}
	if ( bPdSeen )
		zs += ")";
	return zs;
}

void MPPD :: Clone ( MPSYMTBL & mpsymtbl, const MPPD & mppd )
{
	for ( const_iterator it = mppd.begin(); it != mppd.end(); it++ )
	{
		//  Access the key and value from the old map
		const VTKNPD & vtknpdOld = (*it).first;
		const BNDIST * pbndistOld = (*it).second.Pobj();
		assert( pbndistOld );
		//  Construct the new key using the new symbol table
		VTKNPD vtknpd;
		vtknpd.Clone( mpsymtbl, vtknpdOld );
		//  Add to the current map
		self[vtknpd] = new BNDIST;
		//  Duplicate the old distribution
		self[vtknpd]->Clone( *pbndistOld );
	}
}


void MPPD :: Dump ()
{
	cout << "\n=======================================\nDump of distribution table map \n";
	UINT ipd = 0;
	for ( iterator it = begin(); it != end(); it++, ipd++ )
	{
		const VTKNPD & vtknpd = (*it).first;

		ZSTR zs = vtknpd.ZstrSignature();
		bool bCI = (*it).second->Edist() > BNDIST::ED_SPARSE;
		REFBNDIST & refbndist = (*it).second;

		cout << "\tPD ["
			 << ipd
			 << "]: "
			 << zs.Szc()
			 << (bCI ? "  (CI max/plus)" : "" )
			 << ", (refs="
			 << refbndist->CRef()
			 << ")"
			 << "\n" ;

		refbndist->Dump();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\testinfo.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       testinfo.h
//
//--------------------------------------------------------------------------

//
//	testinfo.h: test file generation 
//
#ifndef _TESTINFO_H_
#define _TESTINFO_H_


#include "cliqset.h"			// Exact clique-based inference
#include "clique.h"				// Clique structure details
#include "parmio.h"				// Text Parameter streaming I/O
#include "utility.h"			// Entropic utility
#include "recomend.h"			// Troubleshooting recommendations

typedef unsigned long ULONG;

//
//	Options flags; first 16 bits are the pass count; i.e., number of times to run
//		the inference testing code for timing purposes.
//
const ULONG fPassCountMask  = 0x0FFF;
const ULONG fDistributions	= 1<<15;
const ULONG fImpossible		= 1<<16;
const ULONG fVerbose		= 1<<17;
const ULONG fCliquing		= 1<<18;
const ULONG fInference		= 1<<19;
const ULONG fMulti			= 1<<20;
const ULONG fOutputFile		= 1<<21;
const ULONG fShowTime		= 1<<22;
const ULONG fSaveDsc		= 1<<23;
const ULONG fPause			= 1<<24;
const ULONG fSymName		= 1<<25;
const ULONG fExpand			= 1<<26;
const ULONG fClone			= 1<<27;
const ULONG fUtil			= 1<<28;
const ULONG fReg			= 1<<29;
const ULONG fTSUtil			= 1<<30;
const ULONG fInferStats		= 1<<31;

//  Declare a map from strings to pointers to nodes
typedef map<ZSTR, GNODEMBND *, less<ZSTR> > MPSTRPND;

class TESTINFO
{
  public:
	TESTINFO ( ULONG fCtl, MBNETDSC & mbnet, ostream * pos = NULL )
		:_fCtl(fCtl),
		_mbnet(mbnet),
		_pos(pos),
		_pInferEng(NULL),
		_pmbUtil(NULL),
		_pmbRecom(NULL),
		_rImposs(-1.0),
		_clOut(0)
	{
		_pInferEng = mbnet.PInferEngine();
		assert( _pInferEng );
		if ( fCtl & fUtil )
		{
			_pmbUtil = new MBNET_ENTROPIC_UTILITY( *_pInferEng );
		}
		if ( fCtl & fTSUtil )
		{
			GOBJMBN_CLIQSET * pCliqueSet;
			DynCastThrow(_pInferEng, pCliqueSet);
			_pmbRecom = new MBNET_RECOMMENDER( *pCliqueSet );
		}
	}

	~ TESTINFO ()
	{
		delete _pmbUtil;
		delete _pmbRecom;
	}

	void InferTest ();

	MBNET_ENTROPIC_UTILITY & MbUtil () 
	{
		assert( _pmbUtil );
		return *_pmbUtil;
	}
	MBNET_RECOMMENDER & MbRecom ()
	{
		assert( _pmbRecom );
		return *_pmbRecom;
	}
	MBNETDSC & Mbnet ()
		{ return _mbnet; }
	GOBJMBN_INFER_ENGINE & InferEng ()
	{
		assert( _pInferEng );
		return *_pInferEng;
	}
	ostream * Postream ()
		{ return _pos; }
	ostream & Ostream ()
	{
		assert( _pos );
		return *_pos;
	}
	MPSTRPND & Mpstrpnd ()
		{ return _mpstrpnd; }
	ULONG FCtl ()
		{ return _fCtl; }

	void GetUtilities ();
	void GetTSUtilities ();
	void GetBeliefs ();

	SZC SzcNdName ( GNODEMBN * pgnd );
	SZC SzcNdName ( ZSREF zsSymName );

	bool BFlag ( ULONG fFlag )
	{
		return (FCtl() & fFlag) > 0;
	}

	//  Return a displayable string of the current options settings
	static ZSTR ZsOptions ( ULONG fFlag );

  public:

	ULONG _fCtl;					//  Control flags
	MBNETDSC & _mbnet;				//  The model to test
	MPSTRPND _mpstrpnd;				//  The set of nodes to use
	ostream * _pos;					//  The output stream or NULL
	REAL _rImposs;					//  The value to report for impossible probs
	int _clOut;						//  Output line counter
  protected:
	GOBJMBN_INFER_ENGINE * _pInferEng;
	MBNET_ENTROPIC_UTILITY * _pmbUtil;
	MBNET_RECOMMENDER * _pmbRecom;
};


#endif // _TESTINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\symtmbn.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       symtmbn.h
//
//--------------------------------------------------------------------------

//
//	SYMTMBN.H:  Symbol table for belief networks
//

#ifndef _SYMTMBN_H_
#define _SYMTMBN_H_

#include "basics.h"
#include "algos.h"
#include "symt.h"
#include "gelem.h"
#include "bndist.h"

//  Forward declaration of MBNET
class MBNET;
class MODEL;

/*
	A word about BIT FLAG VECTORS:

		Each GOBJMBN (abstract belief network object) has a bit vector.
		These values are typically accesssed by name, and the names
		are interned in the symbol table of the outer network.  Therefore,
		the symbol table class can return the bit flag index given the name,
		and the node can return the value given the bit flag index.

		Since these values are completely scoped by the network, they
		may differ (both in existence and index) from network to network.
		However, once they are declared they do not change, so caching is
		supported.
 */

//  Base class for a vector of bit flags and its index variable type
typedef int IBFLAG;						//  Index into a bit flag vector
class VFLAGS : public _Bvector			//  A vector of bit flags
{
  public:
	bool BFlag ( IBFLAG ibf ) const
	{
		return size() > ibf
			&& self[ibf];
	}
	//	Set a bit flag; return the previous value
	bool BSetBFlag ( IBFLAG ibf, bool bValue = true )
	{
		bool bOldValue = false;
		if ( size() <= ibf )
			resize(ibf+1);
		else
			bOldValue = self[ibf];
		self[ibf] = bValue;
		return bOldValue;
	}
};

////////////////////////////////////////////////////////////////////
//	class GOBJMBN:  Abstract base class for belief network objects.
//
//		Generic "named thing that lives in a belief network" object.
//		All such objects are graph nodes and can be linked with arcs.
////////////////////////////////////////////////////////////////////
class GOBJMBN : public GNODE
{
	friend class TMPSYMTBL<GOBJMBN>;

  public:
	// Return the immutable object type
	virtual INT EType () const
		{ return EBNO_NONE ; }

	enum EBNOBJ
	{
		EBNO_NONE = GELEM::EGELM_NODE,	// No value
		EBNO_NODE,						// A probabilistic node
		EBNO_PROP_TYPE,					// A property type
		EBNO_MBNET_MODIFIER,			// A general network modifier
		EBNO_MBNET_EXPANDER,			// A network CI expander
		EBNO_INFER_ENGINE,				// A general inference engine
		EBNO_CLIQUE,					// A clique
		EBNO_CLIQUE_SET,				// A set of clique trees
		EBNO_NODE_RANKER,				// A ranking/ordering mechanism
		EBNO_RANKER_ENTROPIC_UTIL,		// A ranking by entropic utility
		EBNO_RANKER_RECOMMENDATIONS,	// A ranking by fixplan recommendations
		EBNO_VARIABLE_DOMAIN,			// A user-defined discretization or domain
		EBNO_USER,						// A user-defined type
		EBNO_MAX
	};

	GOBJMBN () {}
	virtual ~ GOBJMBN() = 0;

	//  Clone contents into a new object relative to another belief network;
	//		return NULL if operation not supported.
	virtual GOBJMBN * CloneNew ( MODEL & modelSelf,
								 MODEL & modelNew,
								 GOBJMBN * pgobjNew = NULL );

	const ZSREF & ZsrefName () const
		{ return _zsrName; }

	//  Accessors for the array of flag bits
	bool BFlag ( IBFLAG ibf ) const	
		{ return _vFlags.BFlag( ibf );	}
	bool BSetBFlag ( IBFLAG ibf, bool bValue = true )
		{ return _vFlags.BSetBFlag( ibf, bValue );	}

  protected:
	//  Only subclasses should be able to do this.
	void SetName ( ZSREF zsr )
		{ _zsrName = zsr; }

  protected:
	ZSREF _zsrName;						//  Symbolic (permanent) name
	VFLAGS _vFlags;						//  Bit vector of flags

	HIDE_UNSAFE(GOBJMBN);
};


////////////////////////////////////////////////////////////////////
//	class MPZSRBIT: a map between a name and a bit index in a
//		bool/bit array.
////////////////////////////////////////////////////////////////////
class MPZSRBIT : public VZSREF
{
  public:
	MPZSRBIT ()	{}
	~ MPZSRBIT() {}
	//  Return the index of a name or -1 if not found
	IBFLAG IFind ( ZSREF zsr )
	{
		return ifind( self, zsr );
	}
	//  Return the index of a name, adding it if necessary
	IBFLAG IAdd ( ZSREF zsr )
	{
		IBFLAG i = ifind( self, zsr );
		if ( i < 0 )
		{
			i = size();
			push_back(zsr);
		}
		return i;
	}
};

////////////////////////////////////////////////////////////////////
//	class MPSYMTBL:
//		An STL "map" which is used as a symbol table.
//		It also supports dynamically declared named bit flags,
//		which are supported by classes GOBJMBN and MBNET.
////////////////////////////////////////////////////////////////////
class MPSYMTBL : public TMPSYMTBL<GOBJMBN>
{
  public:
	MPSYMTBL () {}
	~ MPSYMTBL () {}

	//  Support for dynamically assigned bit flags
	//	  Create a bit flag index for a name
	IBFLAG IAddBitFlag ( SZC szcName )
	{	
		return _mpzsrbit.IAdd( intern( szcName ) );
	}
	//	  Return the bit flag index of name
	IBFLAG IFindBitFlag ( SZC szcName )
	{
		return _mpzsrbit.IFind( intern( szcName ) );
	}
	//	  Test the bit flag of a node
	bool BFlag ( const GOBJMBN & gobj, SZC szcName )
	{
		IBFLAG iBit = IFindBitFlag( szcName );
		if ( iBit < 0 )
			return false;
		return gobj.BFlag(iBit);
	}
	//	  Re/set the bit flag of a node; returns old setting
	bool BSetBFlag ( GOBJMBN & gobj, SZC szcName, bool bValue = true )
	{
		IBFLAG iBit = IAddBitFlag( szcName );
		assert( iBit >= 0 );
		return gobj.BSetBFlag( iBit, bValue );
	}

	void CloneVzsref ( const MPSYMTBL & mpsymtbl,
					   const VZSREF & vzsrSource,
					   VZSREF & vzsrTarget );

	//  Clone this table from another
	void Clone ( const MPSYMTBL & mpsymtbl );

  protected:
	MPZSRBIT _mpzsrbit;
};


/*
	Probability distributions.

	PDs are defined similarly to their notation.  Tokens in the notation
	are converted to descriptor tokens, and the PD data is stored in a
	map structure cataloged by the string of tokens.   For example:
		
		p(X|Y,Z)

	is stored under a key which is a list of tokens:

		token[0]	token representing 'p'
		token[1]	token referencing interned symbolic name of node X
		token[2]	token representing '|'  (conditioning bar)
		token[3]	token referencing interned symbolic name of node Y
		token[4]	token representing ','  (and)
		token[5]	token referencing interned symbolic name of node Z

	Special values can represent states, so that PDs such as

		p(X=x|Y=y)

	can be represented. Since 'x' and 'y' (lower case) are state indicies,
	they are represented as integers.
 */

//  Enumeration for token types.  Values from DTKN_STRING_MIN to
//		DTNK_STATE_BASE are string pointers (equivalent to ZSREFs)
//	
enum DISTTOKEN
{
	DTKN_EMPTY = 0,
	DTKN_STRING,								//  String pointers
	DTKN_BASE = DTKN_STRING+1,					//  Base value for tokens
	DTKN_STATE_BASE = DTKN_BASE,				//  First state value (0)
	DTKN_TOKEN_MIN = DTKN_STATE_BASE + 0x20000,	//	Allow for >100000 discrete states
	DTKN_PD = DTKN_TOKEN_MIN,					//  'p'  as in p(X|Y)
	DTKN_COND,									//  '|', conditioning bar
	DTKN_AND,									//  ','  'and' symbol
	DTKN_EQ, 									//  '='  'equals' symbol
	DTKN_QUAL,									//  token used as domain qualification specifier
	DTKN_DIST,									//  'distribution' token, followed by name token
	DTKN_MAX									//  First illegal value
};

//  Probability distribution descriptor token
class TKNPD
{
  public:
  public:
	//  Constructors
	TKNPD();						// Initialization
	TKNPD( const TKNPD & tp );		// Copy constructor
	TKNPD( const ZSREF & zsr );		// From a string ref
	TKNPD( DISTTOKEN dtkn );		// From an explicit token
	~TKNPD();
	//	Assignment operators: similar to constructors
	TKNPD & operator = ( const TKNPD & tp );
	TKNPD & operator = ( const ZSREF & zsr );
	TKNPD & operator = ( DISTTOKEN dtkn );
	//	Return true if token represents a string
	bool BStr () const
		{ return _uitkn == DTKN_STRING; }
	bool BState () const
		{ return _uitkn >= DTKN_STATE_BASE && _uitkn < DTKN_TOKEN_MIN; }
	bool BToken () const
		{ return _uitkn >= DTKN_TOKEN_MIN && _uitkn < DTKN_MAX; }

	//  Ordering for vector and map classes
	bool operator < ( const TKNPD & tp ) const;
	bool operator == ( const TKNPD & tp ) const;
	bool operator > ( const TKNPD & tp ) const;
	bool operator != ( const TKNPD & tp ) const;

	//	Return the token as an integer
	UINT UiTkn () const		{ return _uitkn; }
	//  Return the token as a DISTTOKEN
	DISTTOKEN Dtkn () const { return (DISTTOKEN) _uitkn; }
	//  Return the token as a discrete state index
	IST Ist () const		
	{ 
		return BState() ? _uitkn - DTKN_STATE_BASE 
					    : -1;
	}

	//  Return the string as an SZC; NULL if not a string
	SZC Szc () const
	{
		return BStr()
			 ? Pzst()->Szc()
			 : NULL;
	}
	const ZSTRT * Pzst () const
		{ return _pzst; }

  protected:
	UINT _uitkn;			//  Simple unsigned integer token
	ZSTRT * _pzst;			//  String pointer (optional)

	void Deref ();
	void Ref ( const ZSREF & zsr );
	void Ref ( const TKNPD & tknpd );
	void Ref ( DISTTOKEN dtkn );
};


// Define VTKNPD
class VTKNPD : public vector<TKNPD>
{
  public:
	//  Generate a string containing the original probability distribution
	//	descriptor (e.g., "p(X|Y,Z)").
	ZSTR ZstrSignature ( int iStart = 0 ) const;

	void Clone ( MPSYMTBL & mpsymtbl, const VTKNPD & vtknpd );

	//  Provide "operator <" for map<> template.	
	bool operator < ( const VTKNPD & vtknpd ) const
	{
		int cmin = _cpp_min( size(), vtknpd.size() );
		for ( int i = 0 ; i < cmin ; i++ )
		{
			if ( self[i] < vtknpd[i] )
				return true;
			if ( vtknpd[i] < self[i])
				return false;
		}
		return size() < vtknpd.size();
	}
};

typedef REFCWRAP<BNDIST> REFBNDIST;
////////////////////////////////////////////////////////////////////
//	class MPPD:  A map associating probability distributions with
//				their descriptors (token arrays).
////////////////////////////////////////////////////////////////////
class MPPD : public map<VTKNPD, REFBNDIST>
{
  public:
	MPPD () {}
	~ MPPD ()
	{
	#if defined(DUMP)
		Dump();
	#endif
	}

	void Clone ( MPSYMTBL & mpsymtbl, const MPPD & mppd );

  private:
	void Dump ();
};


////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
//	Inline member functions
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
inline
TKNPD::TKNPD()
	: _uitkn(DTKN_EMPTY),
	_pzst(NULL)
{
}

inline
TKNPD::TKNPD( const TKNPD & tp )
	: _uitkn(DTKN_EMPTY),
	_pzst(NULL)
{
	Ref(tp);
}

inline
TKNPD::TKNPD( const ZSREF & zsr )
	: _uitkn(DTKN_EMPTY),
	_pzst(NULL)
{
	Ref(zsr);
}

inline
TKNPD::TKNPD( DISTTOKEN dtkn )
	: _uitkn(DTKN_EMPTY),
	_pzst(NULL)
{
	Ref(dtkn);
}

inline
TKNPD::~TKNPD()
{
	Deref();
}

inline
void TKNPD::Deref ()
{
	if ( BStr() )
	{
		_pzst->IncRef(-1);
		_pzst = NULL;
	}
	_uitkn = DTKN_EMPTY;
}

inline
void TKNPD::Ref ( const ZSREF & zsr )
{
	Deref();
	zsr.IncRef();
	_pzst = const_cast<ZSTRT *> (zsr.Pzst());
	_uitkn = DTKN_STRING;
}

inline
void TKNPD::Ref ( const TKNPD & tknpd )
{
	Deref();
	if ( tknpd.BStr() )
	{
		_pzst = tknpd._pzst;
		_pzst->IncRef();
	}
	_uitkn = tknpd._uitkn;
}

inline
void TKNPD::Ref ( DISTTOKEN dtkn )
{
	Deref();
	_uitkn = dtkn;
}

inline
TKNPD & TKNPD::operator = ( const TKNPD & tp )
{
	Ref(tp);
	return self;
}

inline
TKNPD & TKNPD::operator = ( const ZSREF & zsr )
{
	Ref(zsr);
	return self;
}

inline
TKNPD & TKNPD::operator = ( DISTTOKEN dtkn )
{
	Ref(dtkn);
	return self;
}

inline
bool TKNPD::operator < ( const TKNPD & tp ) const
{
	if ( _uitkn < tp._uitkn )
		return true;
	if ( _uitkn > tp._uitkn )
		return false;
	return _pzst < tp._pzst;
}

inline
bool TKNPD::operator > ( const TKNPD & tp ) const
{
	if ( _uitkn > tp._uitkn )
		return true;
	if ( _uitkn < tp._uitkn )
		return false;
	return _pzst > tp._pzst;
}

inline
bool TKNPD::operator == ( const TKNPD & tp ) const
{
	return _uitkn == tp._uitkn && _pzst == tp._pzst;
}

inline
bool TKNPD::operator != ( const TKNPD & tp ) const
{
	return _uitkn != tp._uitkn && _pzst != tp._pzst;	
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\testinfo.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       testinfo.cpp
//
//--------------------------------------------------------------------------

//
// testinfo.cpp: test file generation 
//

#include "testinfo.h"

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
/*
	Test inference and optionally Write an inference output file.  

	The format is the same as the program DXTEST, which	uses the older DXC32.DLL.  
	The format is:

	$COMPLETE						<< Indicates a complete pass without instantiations
	Alternator,0,0.99				<< One record for each state of each node, alphabetically,
	Alternator,1,0.01						with either the full or symbolic name (fSymName)
	Battery,0,0.9927
	Battery,1,0.0073
	Charge Delivered,0,0.95934
	Charge Delivered,1,0.0406603
	...								<<  Similar records for all other nodes
	...
	$INSTANTIATE,Alternator,0		<<  Indicates a node clamped to a state
	Alternator,0,1
	Alternator,1,0
	Battery,0,0.9927
	...
	...
	$PROBLEMINST,Engine Start,1		<<  Indicates a PD node instantiated

	$UTILITY,Node Name,3.14159		<<  Indicates an entropic utility record  (fUtil)
	...
	$RECOMEND,Node Name,-122.2222	<<  Indicates a troubleshooting recommendations record (fTSUtil)
	...

	This routine is used to compare both timings and numerical results with the older
	software.  The "fOutputFile" flag indicates whether an output file should be
	written.  The "fPassCountMask" indicates how many times the loop should be performed;
	this value is defaulted to 1.

	The logic works as follows:

		for each pass

			for 1 + each problem-defining (PD) node

				for each non-PD node

					if no non-PD node is instantiated
						print $COMPLETE
					else
						print $INSTANTIATE and data about instantiated node

					for each state of each non-PD node
						print the name, state and value (belief)
						print utilities if required
						print recommendations if required
					end for each state of each non-PD node

					advance to the next state of the next node
					unclamp previous node/sate
					clamp (next) node to next state

				end for eacn non-PD node

				advance to the next state of the next PD node				

			end for each problem-defining node

		end for each pass

	Note that each pass is set up so that all the uninstantiated values are printed first.

*/
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////

inline
SZC TESTINFO :: SzcNdName ( GNODEMBN * pgnd )
{
	return FCtl() & fSymName
		? pgnd->ZsrefName().Szc()
		: pgnd->ZsFullName().Szc();
}

inline
SZC TESTINFO :: SzcNdName ( ZSREF zsSymName )
{
	if ( FCtl() & fSymName )
		return zsSymName.Szc();

	GNODEMBN * pgnd;
	DynCastThrow( Mbnet().PgobjFind( zsSymName ), pgnd );
	return SzcNdName( pgnd );
}


void TESTINFO :: GetUtilities ()
{
	//  Compute the utilities
	MbUtil()();

	if ( ! Postream() )
		return;

	const VZSREF & vzsrNodes = MbUtil().VzsrefNodes();
	const VLREAL & vlrUtil = MbUtil().VlrValues();

	for ( int ind = 0; ind < vzsrNodes.size(); ind++ )
	{
		SZC szcName = SzcNdName( vzsrNodes[ind] );
		Ostream() 
			<< "$UTILITY,"
			<< szcName
			<< ","
			<< vlrUtil[ind]
			<< "\n";	
		_clOut++;
	}
}

void TESTINFO :: GetTSUtilities ()
{
	if ( ! MbRecom().BReady() )
		return;		// Invalid state for recommendations

	//  Compute the utilities
	MbRecom()();

	if ( ! Postream() )
		return;

	const VZSREF & vzsrNodes = MbRecom().VzsrefNodes();
	const VLREAL & vlrUtil = MbRecom().VlrValues();

	for ( int ind = 0; ind < vzsrNodes.size(); ind++ )
	{
		SZC szcName = SzcNdName( vzsrNodes[ind] );
		Ostream() 
			<< "$RECOMMEND,"
			<< szcName
			<< ","
			<< vlrUtil[ind]
			<< "\n";	
		_clOut++;
	}
}

//  Get the beliefs for the nodes in the given map; write data records if stream given
void TESTINFO :: GetBeliefs ()
{
	MDVCPD mdvBel;

	//  Prepare to check for impossible states of information
	GOBJMBN_CLIQSET * pCliqueSet = NULL;
	if ( BFlag( fImpossible ) )
		pCliqueSet = dynamic_cast<GOBJMBN_CLIQSET *>(&InferEng());
	//   See if this state of information is impossible
	bool bIsImposs = pCliqueSet != NULL 
					&& pCliqueSet->BImpossible();

	for ( MPSTRPND::iterator mpit = Mpstrpnd().begin();
		  mpit != Mpstrpnd().end();
		  mpit++ )
	{
		GNODEMBND * pgndd = (*mpit).second;
		int cState = pgndd->CState();

		if ( ! bIsImposs )
		{
			InferEng().GetBelief( pgndd, mdvBel );
			assert( cState == mdvBel.size() );
		}

		if ( Postream() )
		{
			SZC szcName = SzcNdName( pgndd );
			for ( int ist = 0; ist < cState; ist++ )
			{
				Ostream() << szcName << "," << ist << ",";
				if ( bIsImposs )
					Ostream() << _rImposs;
				else
					Ostream() << mdvBel[ist];
				Ostream() << "\n";
				_clOut++;
			}
		}
	}

	if ( BFlag( fUtil ) )
	{
		GetUtilities();
	}
	else 
	if ( BFlag( fTSUtil ) )
	{
		GetTSUtilities();
	}

#ifdef _DEBUG
	if ( Postream() )
		Ostream().flush();
#endif
}


void TESTINFO :: InferTest ()
{
	bool bOutput = Postream() != NULL;
	int cPass = FCtl() & fPassCountMask;

	//  Is network expanded?
	bool bExpanded = Mbnet().BFlag( EIBF_Expanded );
	PROPMGR propmgr( Mbnet() );	//  Property manager
	int iLblProblem = propmgr.ILblToUser( ESTDLBL_problem );		
	ZSREF zsrPropTypeLabel = propmgr.ZsrPropType( ESTDP_label );

	MPSTRPND & mpstrpnd = Mpstrpnd();	//  Map of strings to node ptrs
	MPSTRPND mpstrpndProblem;			//  Map of PD nodes

	for ( int inode = 0; inode < Mbnet().CNameMax(); inode++ )
	{
		GOBJMBN * pgobj = Mbnet().PgobjFindByIndex( inode );
		if ( ! pgobj )
			continue;
		GNODEMBND * pgndd = dynamic_cast<GNODEMBND *>(pgobj);
		if ( ! pgndd )
			continue;

		SZC szcName = FCtl() & fSymName
					? pgndd->ZsrefName().Szc()
					: pgndd->ZsFullName().Szc();
		//  See if this is a problem-defining node
		PROPMBN * propLbl = pgndd->LtProp().PFind( zsrPropTypeLabel );
		if ( propLbl && propLbl->Real() == iLblProblem )
		{	
			//  Put PD nodes into separate map
			mpstrpndProblem[szcName] = pgndd;
		}
		//  If the network is expanded, use only regular nodes
		if ( (! bExpanded) || ! pgndd->BFlag( EIBF_Expansion ) )
		{
			mpstrpnd[szcName] = pgndd;
		}
	}

	for ( int iPass = 0; iPass < cPass; iPass++ )
	{
		int iProb = -1;
		int iProbState = 0;
		int cProbState = 0;
		GNODEMBND * pgnddProblem = NULL;
		MPSTRPND::iterator mpitPd    = mpstrpndProblem.begin();
		MPSTRPND::iterator mpitPdEnd = mpstrpndProblem.end();

		for (;;)
		{
			//  After 1st cycle, advance the problem state of the PD node
			if ( pgnddProblem )
			{
				ZSTR zsNamePD;
				CLAMP clampProblemState(true, iProbState, true);
				InferEng().EnterEvidence( pgnddProblem, clampProblemState );
				if ( FCtl() & fSymName )
					zsNamePD = pgnddProblem->ZsrefName();
				else
					zsNamePD = pgnddProblem->ZsFullName();
				if ( bOutput )
				{
					Ostream()  << "$PROBLEMINST,"
							<< zsNamePD.Szc()
							<< ","
							<< iProbState
							<< "\n";
					_clOut++;
				}
			}
			
			MPSTRPND::iterator mpit  = mpstrpnd.begin();
			MPSTRPND::iterator mpend = mpstrpnd.end();
			int cpnd = mpstrpnd.size();
			for ( int inid = -1; inid < cpnd; inid++ )
			{
				GNODEMBND * pgndd = NULL;
				ZSTR zsName;
				int cst = 0;  //  Cause inner loop to run once on first cycle
				if ( inid >= 0 )
				{
					pgndd = (*mpit++).second;
					if ( FCtl() & fSymName )
						zsName = pgndd->ZsrefName();
					else
						zsName = pgndd->ZsFullName();
					cst = pgndd->CState();
				}
					
				for ( int ist = -1; ist < cst; ist++ )
				{
					if ( ist < 0 )
					{
						//  The first time through, print all the beliefs
						//		with no instantiations; do nothing on later cycles.
						if ( pgndd != NULL )
							continue;
						if ( bOutput )
						{
							Ostream() << "$COMPLETE\n";
							_clOut++;
						}
					}
					else
					{
						CLAMP clampState(true, ist, true);
						InferEng().EnterEvidence( pgndd, clampState );
						if ( bOutput )
						{
							Ostream() << "$INSTANTIATE,"
									<< zsName.Szc()
									<< ","
									<< ist
									<< "\n";
							_clOut++;
						}
					}
					GetBeliefs();
				}
				
				if ( pgndd )
				{
					//  Clear the instantitation of this node.
					InferEng().EnterEvidence( pgndd, CLAMP() );
				}
			}
			//  If this is the last abnormal state for this problem node,
			//		advance to the next node.
			if ( ++iProbState >= cProbState )
			{
				//  Unclamp the last problem node, if any
				if ( pgnddProblem )
					InferEng().EnterEvidence( pgnddProblem, CLAMP() );
				//  Move on to the next PD node
				if ( mpitPd == mpitPdEnd )
					break;
				pgnddProblem = (*mpitPd++).second;
				cProbState = pgnddProblem->CState();
				//  Reset to 1st problem state
				iProbState = 1;
			}
		}
	}
}


	//  Return a displayable string of the current options settings
ZSTR TESTINFO :: ZsOptions ( ULONG fFlag )
{
	static
	struct 
	{
		ULONG _f;		//  Bit flag
		SZC _szc;		//  Option name
	}
	vOptMap [] =
	{
		{ fVerbose,			"verbose"	},
		{ fCliquing,		"clique"	},
		{ fInference,		"infer"		},
		{ fMulti,			"multipass"	},
		{ fOutputFile,		"outfile"	},
		{ fShowTime,		"times"		},
		{ fSaveDsc,			"dscout"	},
		{ fPause,			"pause"		},
		{ fSymName,			"symname"	},
		{ fExpand,			"expand"	},
		{ fClone,			"clone"		},
		{ fUtil,			"utilities"	},
		{ fReg,				"registry"	},
		{ fTSUtil,			"recommend"	},
		{ fInferStats,		"inferstats"},
		{ fImpossible,		"impossible"},
		{ 0,				""			}
	};

	ZSTR zs;
	ULONG cpass = fFlag & fPassCountMask;
	fFlag &= ~ fPassCountMask;
	for ( int i = 0; vOptMap[i]._f != 0; i++ )
	{
		if ( fFlag & vOptMap[i]._f )
		{
			if ( zs.length() > 0 )
				zs += ',';
			zs += vOptMap[i]._szc;
		}
	}
	if ( fFlag & fMulti )
	{
		if ( zs.length() > 0 )
			zs += ",";
		zs.FormatAppend("passes=%d", cpass);
	}
	return zs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\utility.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       utility.cpp
//
//--------------------------------------------------------------------------

//
//	utility.cpp: utility computation
//

#include <basetsd.h>
#include <math.h>
#include "utility.h"
#include "infer.h"

MBNET_ENTROPIC_UTILITY :: MBNET_ENTROPIC_UTILITY ( GOBJMBN_INFER_ENGINE & inferEng )
	: MBNET_NODE_RANKER( inferEng.Model() ),
	_inferEng( inferEng ),
	_propMgr( inferEng.Model() ),
	_cHypo(0),
	_cInfo(0)
{
	_iLblHypo = _propMgr.ILblToUser( ESTDLBL_hypo );		
	_iLblInfo = _propMgr.ILblToUser( ESTDLBL_info );		
	_iLblProblem = _propMgr.ILblToUser( ESTDLBL_problem );		

	BuildWorkItems();
}


//
//	Collect all informational, problem defining and hypothesis nodes
//	into a structure with additional working data.
//
void MBNET_ENTROPIC_UTILITY :: BuildWorkItems ()
{
	ZSREF zsrPropTypeLabel = _propMgr.ZsrPropType( ESTDP_label );
	MODEL::MODELENUM mdlenum( Model() );

	_dquwrk.clear();
	_cHypo = 0;
	_cInfo = 0;

	UTILWORK uwDummy;
	GELEMLNK * pgelm;

	//  Collect all the nodes into a pointer array.  Three node labels
	//	are collected: info and probdef nodes (considered as info)
	//	and hypo nodes (considered as hypo).

	while ( pgelm = mdlenum.PlnkelNext() )
	{	
		if ( pgelm->EType() != GOBJMBN::EBNO_NODE )
			continue;

		//  We only support discrete nodes for now.
		DynCastThrow( pgelm, uwDummy._pgndd );

		//  See if this is an expansion (created) node
		if ( uwDummy._pgndd->BFlag( EIBF_Expansion ) )
			continue;	// not a user-identifiable artifact; skip it

		//  See if it has a label		
		PROPMBN * propLbl = uwDummy._pgndd->LtProp().PFind( zsrPropTypeLabel );		
		if ( ! propLbl )
			continue;	//  no label; skip it

		uwDummy._iLbl = propLbl->Real();
		if ( uwDummy._iLbl == _iLblHypo )
			_cHypo++;
		else
		if ( uwDummy._iLbl == _iLblInfo || uwDummy._iLbl == _iLblProblem )
			_cInfo++;
		else
			continue;	//  not a label of interest

		//  Initialize the other member variables
		uwDummy._rUtil = 0.0;
		uwDummy._iClamp = -1;
		//  Put the item on the work queue
		_dquwrk.push_back( uwDummy );
	}
	
}

REAL MBNET_ENTROPIC_UTILITY :: RComputeHypoGivenInfo (
	UTILWORK & uwHypo,
	UTILWORK & uwInfo )
{
	assert( uwHypo._iLbl == _iLblHypo );
	assert( uwInfo._iLbl != _iLblHypo );

	//  Clamped nodes are irrelevant
	if ( uwHypo._iClamp >= 0 || uwInfo._iClamp >= 0 )
		return 0.0;

	REAL rUtilOfInfoForHypo = 0.0;
	int cState = uwInfo._pgndd->CState();
	int cStateHypo = uwHypo._pgndd->CState();
	MDVCPD mdvhi;
	REAL rp_h0 = uwHypo._dd[0];	// Probability of hypo node being normal

	for ( int istInfo = 0; istInfo < cState; istInfo++ )
	{
		//  Get belief of hypo node given info state
		_inferEng.EnterEvidence( uwInfo._pgndd, CLAMP( true, istInfo, true ) );
		_inferEng.GetBelief( uwHypo._pgndd, mdvhi );
		REAL rp_h0xj = mdvhi[0];	//  p(h0|xj)
		REAL rLogSum = 0.0;
		for ( int istHypo = 1; istHypo < cStateHypo; istHypo++ )
		{
			REAL rp_hi = uwHypo._dd[istHypo];
			REAL rp_hixj = mdvhi[istHypo];
			rLogSum += fabs( log(rp_hixj) - log(rp_h0xj) - log(rp_hi) + log(rp_h0) );
		}
		rUtilOfInfoForHypo += rLogSum * uwInfo._dd[istInfo];
	}

	//  Clear evidence against info node
	_inferEng.EnterEvidence( uwInfo._pgndd, CLAMP() );

	return rUtilOfInfoForHypo;
}

DEFINEVP(UTILWORK);

void MBNET_ENTROPIC_UTILITY :: ComputeWorkItems()
{
	CLAMP clamp;
	VPUTILWORK vpuw; // Remember pointers to hypo items

	//  Get unconditional beliefs of all relevant (unclamped) nodes
	for ( DQUTILWORK::iterator itdq = _dquwrk.begin();
		  itdq != _dquwrk.end();
		  itdq++ )
	{
		UTILWORK & ut = *itdq;
		ut._rUtil = 0.0;
		ut._iClamp = -1;

		//  Remember the indicies of the hypo nodes
		if ( ut._iLbl == _iLblHypo )
			vpuw.push_back( & (*itdq) );

		//  Get the current evidence for the node
		_inferEng.GetEvidence( ut._pgndd, clamp );
		//  If node is unclamped,
		if ( ! clamp.BActive() )
		{
			//  get unconditional probs, else
			_inferEng.GetBelief( ut._pgndd, ut._dd );
		}
		else
		{
			//  remember clamped state (serves as marker)
			ut._iClamp = clamp.Ist();
		}
	}

	for ( itdq = _dquwrk.begin();
		  itdq != _dquwrk.end();
		  itdq++ )
	{
		UTILWORK & utInfo = *itdq;
		if ( utInfo._iLbl == _iLblHypo )
			continue;
		utInfo._rUtil = 0.0;
		for ( int ih = 0; ih < vpuw.size(); ih++ )
		{
			utInfo._rUtil += RComputeHypoGivenInfo( *vpuw[ih], utInfo );
		}				
	}
}


void MBNET_ENTROPIC_UTILITY :: operator () ()
{
	// Clear any old results
	Clear();

	if ( _cHypo == 0 || _cInfo == 0 )
		return;		//  Nothing to do

	//  Compute all utilities
	ComputeWorkItems();

	//  Sort the work queue by utility
	sort( _dquwrk.begin(), _dquwrk.end() );

	//  Pour the information into the output work areas
	_vzsrNodes.resize(_cInfo);
	_vlrValues.resize(_cInfo);
	int iInfo = 0;
	for ( DQUTILWORK::reverse_iterator ritdq = _dquwrk.rbegin();
		  ritdq != _dquwrk.rend();
		  ritdq++ )
	{
		UTILWORK & ut = *ritdq;
		if ( ut._iLbl == _iLblHypo )
			continue;		
		_vzsrNodes[iInfo] = ut._pgndd->ZsrefName();
		_vlrValues[iInfo++] = ut._rUtil;
	}
	assert( iInfo == _cInfo );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\symt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       symt.h
//
//--------------------------------------------------------------------------

//
//	SYMTMBN.H:  Symbol and symbol table handling declarations
//

#ifndef _SYMT_H_
#define _SYMT_H_

#include "zstrt.h"

////////////////////////////////////////////////////////////////////
//  template TMPSYMTBL: a symbol table
//
//		Names ares ZSREFs based upon strings interned into 
//		the internal string table using "intern()".  
//
//		Objects are smart pointers which destroy themselves
//		when assigned to or upon destruction of the symbol table.
//
//  Public functions:
//
//		add():		adds an association between an OBJ * and 
//					its name string
//		find():		returns an OBJ * or NULL
//		intern():	registers a string in the symbol table's 
//					string table.
////////////////////////////////////////////////////////////////////

class GOBJMBN;

template<class OBJ>
class TMPSYMTBL :
	public map<ZSREF, REFPOBJ<OBJ>, less<ZSREF> >
{
	typedef REFPOBJ<GOBJMBN> ROBJ;
	typedef map<ZSREF, REFPOBJ<OBJ>, less<ZSREF> > TSYMMAP;
  public:
	TMPSYMTBL () {};
	~ TMPSYMTBL () 
	{
		clear();
	};			

	void add ( SZC szc, OBJ * pobj )
	{
		ZSREF zsr = _stszstr.Zsref(szc);
		(*this)[zsr] = pobj;
		pobj->SetName(zsr);
	}

	OBJ * find ( SZC szc )
	{
		iterator it = TSYMMAP::find(_stszstr.Zsref(szc));

		return it == end() 
				? NULL 
				: (*it).second.Pobj();
	}

	ZSREF intern ( SZC szc )
	{
		return _stszstr.Zsref(szc);
	}	

	bool remove ( SZC szc )
	{
		iterator it = TSYMMAP::find(_stszstr.Zsref(szc));
		if ( it != end() )
		{
			erase(it);
			return true;
		}
		return false;
	}

  protected:
	//  The ensemble of strings
	STZSTR	_stszstr;
		
	HIDE_UNSAFE(TMPSYMTBL);
}; 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\vrmatrx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       vrmatrx.cpp
//
//--------------------------------------------------------------------------

#include <float.h>
#include <math.h>
#include <bitset>
#include "vrmatrx.h"

VRMATRIX VRMATRIX :: VrmatrixProject ( const VIMD & vimdRowColumnRetain ) const
{
	// Returns the projection of this matrix defined by the rows and columns
	// in vimdRowColumnRetain.

#define BSETSIZE 100
	
	size_t cDimMax = _cpp_max(CCol(),CRow());
	assert( cDimMax < BSETSIZE );

	// Build a bitset that keeps track of the rows and columns we're retaining

	bitset<BSETSIZE> bset;

	for ( int iRowCol = 0; iRowCol < vimdRowColumnRetain.size(); ++iRowCol)
	{
		bset[ vimdRowColumnRetain[iRowCol] ] = true;
	}

	int cCol = 0;
	int	cRow = 0;

	for ( iRowCol = 0; iRowCol < cDimMax; iRowCol++ )
	{	
		bool bKeep = bset[iRowCol];

		if ( cDimMax >= CCol() && bKeep )
			cCol++;
		if ( cDimMax >= CRow() && bKeep ) 
			cRow++;
	}

	// Make sure that a least one row and column are being retained
	if ( cCol == 0 || cRow == 0 )
		throw GMException(EC_MDVECT_MISUSE,"null matrix projection");

	// Construct the projection matrix
	VRMATRIX vrmatrix(cRow,cCol);
	
	int iRowProjection = 0;
	
	// Step through every element in this matrix, and insert into the
	// projection if the element is to be retained

	for ( int iRow = 0; iRow < CRow(); ++iRow )
	{
		if ( ! bset[iRow] )
		{
			// This row is excluded from the projection
			continue;
		}

		int iColProjection = 0;

		// This row is included... insert the members
		// of the row for every column in the projection

		for (int iCol = 0; iCol < CCol(); ++iCol )
		{
			if ( bset[iCol] ) 
			{
				vrmatrix(iRowProjection, iColProjection) = self(iRow,iCol);
				
				++iColProjection;
			}
		}

		++iRowProjection;
	}
	return vrmatrix;
}

VRMATRIXSQ VRMATRIXSQ :: VrmatrixProject ( const VIMD & vimdRowColumnRetain ) const
{
	// Returns the projection of this matrix defined by the rows and columns
	// in vimdRowColumnRetain.

#define BSETSIZE 100
	
	size_t cDimMax = _cpp_max(CCol(),CRow());
	assert( cDimMax < BSETSIZE );

	// Build a bitset that keeps track of the rows and columns we're retaining
	bitset<BSETSIZE> bset;

	for ( int iRowCol = 0; iRowCol < vimdRowColumnRetain.size(); ++iRowCol)
	{
		bset[ vimdRowColumnRetain[iRowCol] ] = true;
	}

	int cCol = 0;
	int	cRow = 0;

	for ( iRowCol = 0; iRowCol < cDimMax; iRowCol++ )
	{	
		bool bKeep = bset[iRowCol];

		if ( cDimMax >= CCol() && bKeep )
			cCol++;
		if ( cDimMax >= CRow() && bKeep ) 
			cRow++;
	}

	VRMATRIXSQ vrmatrix;

	// Make sure that a least one row and column are being retained
	if ( cCol > 0 && cRow > 0 )
	{
		// Initialize the projection matrix
		vrmatrix.Init(cRow,cCol);
		
		int iRowProjection = 0;
		
		// Step through every element in this matrix, and insert into the
		// projection if the element is to be retained

		for ( int iRow = 0; iRow < CRow(); ++iRow )
		{
			if ( ! bset[iRow] )
			{
				// This row is excluded from the projection
				continue;
			}

			int iColProjection = 0;

			// This row is included... insert the members
			// of the row for every column in the projection

			for (int iCol = 0; iCol < CCol(); ++iCol )
			{
				if ( bset[iCol] ) 
				{
					vrmatrix(iRowProjection, iColProjection) = self(iRow,iCol);
					
					++iColProjection;
				}
			}

			++iRowProjection;
		}
	}
	else
	{
		vrmatrix.Init(0,0);
	}
	return vrmatrix;
}

VLREAL VRMATRIX :: VectorRow ( int iRow ) const
{
	// Return a copy of the iRow'th row vector of the matrix

	if ( iRow >= CRow() ) 
		throw GMException(EC_MDVECT_MISUSE,"invalid matrix projection");

	VLREAL vectorRowReturn;

	int cCol = CCol();

	vectorRowReturn.resize(cCol);

	const REAL* rgrealRowMatrix = & self(iRow,0);
		
	for ( int iCol = 0; iCol < cCol; cCol++ )
	{
		vectorRowReturn[iCol] = rgrealRowMatrix[iCol];
	}
	//	*prv++ = *prm++;

	return vectorRowReturn;
}

VLREAL VRMATRIX :: VectorColumn ( int iCol ) const
{
	// Return a copy of the iCol'th column vector of the matrix

	if ( iCol >= CCol() ) 
		throw GMException(EC_MDVECT_MISUSE,"invalid matrix projection");

	VLREAL vectorColReturn;

	int cRow = CRow();

	vectorColReturn.resize(cRow);

	const REAL* rgrealColMatrix = & self(0, iCol);
		
	for ( int iRow = 0; iRow < cRow; iRow++ )
	{
		vectorColReturn[iRow] = rgrealColMatrix[iRow];
	}

	return vectorColReturn;
}

VRMATRIX VRMATRIX :: VrmatrixTranspose () const
{
	// Return the transpose of this matrix

	VRMATRIX vrmatrixTranspose( CCol(), CRow() );

	for ( int iRow = 0 ; iRow < CRow() ; iRow++ )
	{
		for ( int iCol = 0; iCol < CCol(); iCol++ )
		{
			vrmatrixTranspose(iCol,iRow) = self(iRow,iCol);
		}
	}
	return vrmatrixTranspose;
}

VRMATRIX VRMATRIX::operator * ( const VRMATRIX & matrix ) const
{
	if ( ! BCanMultiply( matrix ) ) 
		throw GMException(EC_MDVECT_MISUSE,"invalid matrix multiplication");
	
	//  Result matrix
	VRMATRIX mat( CRow(), matrix.CCol() );

	//  Compute distance in flat array between adjacent 
	//		column items in secondary
	int icolInc = matrix.second.stride()[0];

	const REAL * prrow = & self(0,0);
	REAL * prmat = & mat(0,0);
	for (int irow = 0; irow < CRow(); irow++)
	{
		const REAL * prrowt;
		for ( int icol = 0; icol < matrix.CCol(); icol++ )
		{
			prrowt = prrow;
			assert( prrowt == & self(irow,0) );

			// First column element in "matrix"
			const REAL * prcol = & matrix(0,icol);

			// Compute the new element
			REAL r = 0.0;
			for (int i = 0; i < CCol(); i++)
			{
				assert( prcol == & matrix(i,icol) );
				r += *prcol * *prrowt++;
				prcol += icolInc;
			}
			//  Store it
			*prmat++ = r;			
		}
		prrow = prrowt;
	}

	return mat;
}

VRMATRIX & VRMATRIX::operator += ( const VRMATRIX & vrmatrixAdd )
{
	// Add vrmatrixAdd to this matrix

	// Make sure the matrices are of the same dimension
	
	if (! BSameDimension(vrmatrixAdd) )
		throw GMException(EC_MDVECT_MISUSE,"inapplicable matrix operator");

	// Perform a flat add between all the elements in the matricies

	int crealTotal = second._Totlen();

	REAL*		rgrealSelf		= &self(0,0);
	const REAL*	rgrealMatrixAdd	= &vrmatrixAdd(0,0);

	for ( int ireal = 0 ; ireal < crealTotal ; ireal++ )
	{
		rgrealSelf[ireal] += rgrealMatrixAdd[ireal];
	}

	return self;
}

VRMATRIX & VRMATRIX::operator -= ( const VRMATRIX & vrmatrixMatrixSubtract )
{
	// Subtract vrmatrixAdd from this matrix

	// Make sure the matrices are of the same dimension

	if ( ! BSameDimension( vrmatrixMatrixSubtract ) )
		throw GMException(EC_MDVECT_MISUSE,"inapplicable matrix operator");

	// Perform a flat subtration between all the elements in the matricies

	int crealTotal = second._Totlen();

	REAL*		rgrealSelf				= &self(0,0);
	const REAL*	rgrealMatrixSubtract	= &vrmatrixMatrixSubtract(0,0);

	for ( int ireal = 0 ; ireal < crealTotal ; ireal++ )
	{
		rgrealSelf[ireal] -= rgrealMatrixSubtract[ireal];
	}

	return self;
}

VRMATRIX & VRMATRIX::operator *= ( REAL rScalar )
{
	// Multiply each element in the matrix by rScalar

	int crealTotal = second._Totlen();

	REAL*	rgrealSelf	= &self(0,0);
	
	for ( int ireal = 0 ; ireal < crealTotal ; ireal++ )
	{
		rgrealSelf[ireal] *= rScalar;
	}

	return self;
}

VRMATRIX & VRMATRIX::operator += ( REAL rScalar )
{
	// Add rScalar to each element in the matrix 

	int crealTotal = second._Totlen();

	REAL*	rgrealSelf	= &self(0,0);
	
	for ( int ireal = 0 ; ireal < crealTotal ; ireal++ )
	{
		rgrealSelf[ireal] += rScalar;
	}

	return self;
}

VRMATRIX & VRMATRIX::operator -= ( REAL rScalar )
{
	// Subtract rScalar from each element in the matrix 

	int crealTotal = second._Totlen();

	REAL*	rgrealSelf	= &self(0,0);
	
	for ( int ireal = 0 ; ireal < crealTotal ; ireal++ )
	{
		rgrealSelf[ireal] -= rScalar;
	}

	return self;
}

VRMATRIX & VRMATRIX::operator /= ( REAL rScalar )
{
	// Divide each element in the matrix by rScalar

	int crealTotal = second._Totlen();

	REAL*	rgrealSelf	= &self(0,0);
	
	for ( int ireal = 0 ; ireal < crealTotal ; ireal++ )
	{
		rgrealSelf[ireal] /= rScalar;
	}

	return self;
}

VRMATRIXSQ :: VRMATRIXSQ ( const VLREAL & vrColumn, const VLREAL & vrRow )
{	
	// Constructor for square matrices that takes a column and row vector.
	// The initial state of this matrix is the product of the input
	// vectors.

	// Make sure the vectors are of the same length

	if ( vrColumn.size() != vrRow.size() ) 
		throw GMException(EC_MDVECT_MISUSE,"invalid matrix multiplication");

	Init( vrColumn.size() );
	REAL * prm = & self(0,0);
	for ( int iRow = 0; iRow < CRow(); iRow++ )
	{
		for ( int iCol = 0; iCol < CCol(); iCol++ )
		{
			*prm++ = vrColumn[iCol] * vrRow[iRow];
		}
	}	
}	

VRMATRIXSQ & VRMATRIXSQ::operator *= (const VRMATRIXSQ& matrix)
{
	if (   matrix.CRow() != CRow() 
	    || matrix.CCol() != CRow() ) 
		throw GMException(EC_MDVECT_MISUSE,"invalid matrix multiplication");

	//  Temporary row for partial result
	VLREAL vrrow;
	vrrow.resize(CCol());
	
	//  Compute distance in flat array between rows
	int icolInc = matrix.second.stride()[0];

	REAL * prrow = & self(0,0);
	const REAL * prmat = & matrix(0,0);
	REAL * prtemp0 = & vrrow[0];
	for (int irow = 0; irow < CRow(); irow++)
	{
		REAL * prtemp = prtemp0;
		for ( int icol = 0; icol < matrix.CCol(); icol++ )
		{
			const REAL * prrowt = prrow;
			assert( prrowt == & self(irow,0) );

			// First column element in "matrix"
			const REAL * prcol = & matrix(0,icol);

			// Compute the new element
			REAL r = 0.0;
			for (int i = 0; i < CCol(); i++)
			{
				assert( prcol == & matrix(i,icol) );
				r += *prcol * *prrowt++;
				prcol += icolInc;
			}
			//  Store it temporary row vector
			*prtemp++ = r;			
		}

		//  Update row in self
		prtemp = prtemp0;
		for ( int icol2 = 0; icol2 < CCol(); icol2++ )
		{
			*prrow++ = *prtemp++;
		}
	}

	return self;
}

void VRMATRIXSQ::LUDBackSub (const VRMATRIXSQ& matrix)
{
	if ( ! matrix.BIsLUDecomposed() )
		throw GMException(EC_MDVECT_MISUSE,"matrix not in L-U decomposed form");

	for (int icol = 0; icol < CCol(); icol++)
	{
		int	irowNZ = -1;

		for (int irow = 0; irow < CRow(); irow++)
		{
			int	irowMax = matrix._vimdRow[irow];
			REAL	probSum = self(irowMax,icol);

			self(irowMax,icol) = self(irow,icol);

			if (irowNZ != -1)
			{
				for (int iMul = irowNZ; iMul < irow; iMul++)
					probSum -= matrix(irow,iMul) * self(iMul,icol);
			}
			else if (probSum != 0.0)
				irowNZ = irow;

			self(irow,icol) = probSum;
		}

		for (     irow = CRow(); irow-- > 0; )
		{
			REAL	probSum = self(irow,icol);

			for (int iMul = irow + 1; iMul < CRow(); iMul++)
				probSum -= matrix(irow,iMul) * self(iMul,icol);
			self(irow,icol) = probSum / matrix(irow,irow);
		}
	}
}

void VRMATRIXSQ::LUDecompose( bool bUseTinyIfSingular )
{
	// Perform L-U decomposition; throw exception if singular
	// If "use tiny" is set, pivots at zero are replaced with
	//	 RTINY value (1.0e-20)


	// Check that this matrix is not already LU decomposed
	if ( BIsLUDecomposed() )
		throw GMException(EC_MDVECT_MISUSE,"matrix is already in L-U decomposed form");

	if (CRow() == 0)
		return;	// trivial case

	int	cDim = CRow();

	_vimdRow.resize(cDim);

	VLREAL vlrealOverMax;
	vlrealOverMax.resize(cDim);

	_iSign = 1;

	for (int iRow = 0; iRow < cDim; iRow++)
	{
		REAL	realMax = 0.0;

		for (int iCol = 0; iCol < cDim; iCol++)
		{
			REAL	realAbs = fabs(self(iRow,iCol));

			if (realAbs > realMax)
				realMax = realAbs;
		}
		if (realMax == 0.0)
		{
			// Every element in the row is zero: this is a singular matrix

			throw GMException(EC_MDVECT_MISUSE,"matrix is singular");
		}

		vlrealOverMax[iRow] = 1.0 / realMax;
	}

	for (int iCol = 0; iCol < cDim; iCol++)
	{
		for (int iRow = 0;    iRow < iCol; iRow++)
		{
			REAL	realSum = self(iRow,iCol);
			
			for (int iMul = 0; iMul < iRow; iMul++)
				realSum -= self(iRow,iMul) * self(iMul,iCol);

			self(iRow,iCol) = realSum;
		}

		REAL realMax = 0.0;
		int	iRowMax = 0;

		for ( iRow = iCol; iRow < cDim; iRow++)
		{
			REAL	realSum = self(iRow,iCol);

			for (int iMul = 0; iMul < iCol; iMul++)
				realSum -= self(iRow,iMul) * self(iMul,iCol);

			self(iRow,iCol) = realSum;

			REAL	realAbs = vlrealOverMax[iRow] * fabs(realSum);

			if (realAbs >= realMax)
			{
				realMax = realAbs;
				iRowMax = iRow;
			}
		}

		if (iRowMax != iCol)
		{
			//	we need to interchange rows
			_iSign *= -1;
			vlrealOverMax[iRowMax] = vlrealOverMax[iCol];
			InterchangeRows(iRowMax,iCol);
		}

		_vimdRow[iCol] = iRowMax;

		REAL & rPivot = self(iCol,iCol);

		if ( rPivot == 0.0 )
		{
			if ( ! bUseTinyIfSingular )
			{
				// This is a singular matrix: throw exceptioin
				throw GMException(EC_MDVECT_MISUSE,"matrix is singular");
			}

			rPivot = RTINY;
		}

		REAL rScale = 1.0 / rPivot;

		for ( iRow = iCol + 1; iRow < cDim; iRow++)
			self(iRow,iCol) *= rScale;
	}
}

void VRMATRIXSQ::Invert( bool bUseTinyIfSingular )
{
	// Invert; throw exception if singular.  If not in L-U form,
	// L-U Decomp is called.

	if ( ! BIsLUDecomposed() )
	{
		LUDecompose( bUseTinyIfSingular );
	}

	VRMATRIXSQ	matrixOne(CRow());

	// Create the identity matrix

	for (int iDim1 = 0; iDim1 < CRow(); iDim1++)
	{
		for (int iDim2 = 0; iDim2 < CRow(); iDim2++)
			matrixOne(iDim1, iDim2) = iDim1 == iDim2 ? 1.0 : 0.0;
	}

	matrixOne.LUDBackSub(self);

	for ( iDim1 = 0; iDim1 < CRow(); iDim1++)
	{
		for (int iDim2 = 0; iDim2 < CRow(); iDim2++)
			self(iDim1, iDim2) = matrixOne(iDim1, iDim2);
	}

	//  Clear l-u decomp values
	_vimdRow.resize(0);
}

DBL VRMATRIXSQ::DblDeterminant()
{
	DBL	dblDet = _iSign;

	if ( CRow() > 0 && ! BIsLUDecomposed() )
		LUDecompose();			

	// Once the matrix has been LU decomposed, the determinant can be 
	// obtained by simply multiplying the elements of the diagonal

	for (int iRow = 0; iRow < CRow(); iRow++)
	{
		dblDet *= self(iRow,iRow);
	}

	return dblDet;
}

DBL VRMATRIXSQ :: DblAddLogDiagonal() const
// Adds the log of each element in the diagonal and returns the sum.
{
	DBL		dblLogDiag 	= 0;
//	bool	bPositive	= _iSign == 1;
	bool	bPositive	= 1;

	for (int iRow = 0; iRow < CRow(); iRow++)
	{
		if (self(iRow,iRow) < 0)
			bPositive = !bPositive;	

		// Assert that the element is not zero. We should probably 
		// throw an exception here instead.

		assert(self(iRow,iRow) != 0);

		dblLogDiag += log (fabs(self(iRow,iRow)));
	}

	if (!bPositive)	   
	{
		// Got a negative determinant, so we can't take the log... throw
		// an exception

		return false;
	}

	return dblLogDiag;
}


DBL	VRMATRIXSQ :: DblLogDeterminant()
{
	// Return the log of the determinant. If not in L-U form,
	// L-U Decomp is called. Throws exception if negative.

	if ( CRow() > 0 && ! BIsLUDecomposed() )
		LUDecompose();			

	DBL		dblLogDet 	= 0;
	bool	bPositive	= _iSign == 1;

	for (int iRow = 0; iRow < CRow(); iRow++)
	{
		if (self(iRow,iRow) < 0)
			bPositive = !bPositive;	

		// Assert that the deterninant is not zero. We should probably 
		// throw an exception here instead.

		assert(self(iRow,iRow) != 0);

		dblLogDet += log (fabs(self(iRow,iRow)));
	}

	if (!bPositive)	   
	{
		// Got a negative determinant, so we can't take the log... throw
		// an exception

		return false;
	}

	return dblLogDet;
}

void VRMATRIXSQ :: GetLUDecompose( VRMATRIXSQ & vmatrixResult, bool bUseTinyIfSingular ) const
{
	// Set vrmatResult to be the result of performing an L-U 
	// decomposition on the matrix. Will throw exception if 
	// the matrix is singular
	// If "use tiny" is set, pivots at zero are replaced with
	//	 RTINY value (1.0e-20)

	// Copy this matrix into vmatrixResult...
	vmatrixResult = self;

	// .. and perform the decomposition
	vmatrixResult.LUDecompose( bUseTinyIfSingular );
}

void VRMATRIXSQ :: GetInverse( VRMATRIXSQ & vmatrixResult, bool bUseTinyIfSingular ) const
{
	// Set vrmatResult to the inverse of the matrix.
	// Will throw an exception if the matrix is singular.

	// Copy this matrix into vmatrixResult...
	vmatrixResult = self;

	/// ...and invert
	vmatrixResult.Invert( bUseTinyIfSingular );
}

void VRMATRIXSQ :: GetDblDeterminant( DBL& dblDeterminant, VRMATRIXSQ & vmatrixResult ) const
{
	// Get the determinant without modifying (LU decomposing) the matrix.
	// vmatrixResult will contain the LU decomposed version of the matrix.
	
	// Copy this matrix into vmatrixResult...
	vmatrixResult	= self;
	dblDeterminant	=  vmatrixResult.DblDeterminant();
}

void VRMATRIXSQ :: GetDblLogDeterminant( DBL& dblLogDeterminant, VRMATRIXSQ & vmatrixResult ) const
{
	// Get the log of determinant without modifying (LU decomposing) the matrix.
	// vmatrixResult will contain the LU decomposed version of the matrix.
	
	vmatrixResult		= self;
	dblLogDeterminant	= vmatrixResult.DblLogDeterminant();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\utility.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       utility.h
//
//--------------------------------------------------------------------------

//
//	utility.h:  Algorithms for computation of utility
//	
#ifndef _UTILITY_H_
#define _UTILITY_H_

#include <deque>

#include "gmobj.h"

//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
//
//  class MBNET_ENTROPIC_UTILITY:
//
//		Ranking for entropic utility.  Uses function object
//		semantics.  Construct using an inference engine, since
//		utility calculations are computed w.r.t. a set of evidence.
//
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
struct UTILWORK
{
	GNODEMBND * _pgndd;			//  Pointer to node
	int _iLbl;					//  Label of node
	MDVCPD _dd;					//  Unconditional distribution given evidence
	REAL _rUtil;				//  Utility
	int _iClamp;				//  index of clamped state or -1
	bool operator < ( const UTILWORK & ut ) const
		{ return _rUtil < ut._rUtil ; }
};

typedef deque<UTILWORK> DQUTILWORK;

class MBNET_ENTROPIC_UTILITY : public MBNET_NODE_RANKER
{
  public:
	MBNET_ENTROPIC_UTILITY ( GOBJMBN_INFER_ENGINE & inferEng );
	virtual ~ MBNET_ENTROPIC_UTILITY () {}

	INT EType () const
		{ return EBNO_RANKER_ENTROPIC_UTIL; }

	//  The ranking function
	virtual void operator () ();

  protected:
	//  The inference engine we're operating against
	GOBJMBN_INFER_ENGINE & _inferEng;
	//  Property handler
	PROPMGR _propMgr;
	//  Queue of work items
	DQUTILWORK _dquwrk;
	//  Indicies of standard labels in this network
	int _iLblHypo;
	int _iLblInfo;
	int _iLblProblem;
	//  Counts of nodes by label
	int _cHypo;
	int _cInfo;

  protected:
	void BuildWorkItems ();
	void ComputeWorkItems ();

	REAL RComputeHypoGivenInfo ( UTILWORK & uwHypo, UTILWORK & uwInfo );
};

#endif	// _UTILITY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\vrmatrx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       vrmatrx.h
//
//--------------------------------------------------------------------------

#ifndef	_MATRIX_H_
#define _MATRIX_H_

#include <memory.h>

#include "basics.h"
#include "mdvect.h"

//
//	VRMATRIXSQ.H: Matrix handling
//

template<class T>
void fastMemMove(const T * ptfrom, T * ptto, int ct)
{
	::memmove( (void*) ptto, (void*) ptfrom, ct * sizeof(T) );
}

class VRMATRIX : public TMDVDENSE<REAL>
{
  public:
    VRMATRIX ( int cRow, int cCol = 0 )
	{
		Init( cRow, cCol );
	}
	VRMATRIX () {}

	void Init ( int cRow, int cCol = 0 )
	{
		second.Init( 2, cRow, cCol != 0 ? cCol : cRow );
		first.resize( second._Totlen() );
	}
	void Init ( const VRMATRIX & vrmat )
	{
		Init( vrmat.CRow(), vrmat.CCol() );
	}
	bool BCanMultiply( const VRMATRIX & mat ) const
	{
		return CCol() == mat.CRow();
	}

	bool BSameDimension( const VRMATRIX & mat ) const  
	{
		return CRow() == mat.CRow() && CCol() == mat.CCol() ;
	}
	
	int CDim ( int iDim ) const
	{ 
		return second.size().size() > iDim
		     ? second.size()[iDim]
			 : 0 ; 
	}
	int CRow () const
		{ return CDim(0); }
	int CCol () const
		{ return CDim(1); }

	bool BSquare() const
		{ return CRow() == CCol() ; }

	int IOffset ( int irow, int icol ) const
	{
		int cRow = CRow();
		int cCol = CCol();
		
		if (   irow >= CRow() 
			|| icol >= CCol() )
			throw GMException(EC_MDVECT_MISUSE,"subscript error on matrix");

		return second.stride()[0] * irow 
		     + second.stride()[1] * icol;
	}
	REAL & operator () ( int irow, int icol )
		{ return first[ IOffset(irow,icol) ]; }

	const REAL & operator () ( int irow, int icol ) const
	{ 
		VRMATRIX & vrmx = const_cast<VRMATRIX&>(self);
		return vrmx.first[ IOffset(irow,icol) ]; 
	}

	void InterchangeRows ( int irow1, int irow2 )
	{
		if (   irow1 >= CRow()
			&& irow2 >= CRow() )
			throw GMException(EC_MDVECT_MISUSE,"subscript error on matrix");			
		if ( irow1 == irow2 ) 
			return;		
		REAL * pr1 =  & self(irow1,0);
		REAL * pr2 =  & self(irow2,0);
		assert( & self(irow1,1) - pr1 == 1 );

		for ( int icol = 0; icol < CCol(); icol++ )
		{
			REAL r = *pr1;
			*pr1++ = *pr2;
			*pr2++ = r;			
		}
	}

	void InterchangeCols ( int icol1, int icol2 )
	{
		if (   icol1 >= CCol()
			&& icol2 >= CCol() )
			throw GMException(EC_MDVECT_MISUSE,"subscript error on matrix");
		if ( icol1 == icol2 ) 
			return;
		REAL * pr1 = & self(0,icol1);
		REAL * pr2 = & self(0,icol2);
		int icolInc = CCol();

		for ( int irow = 0; irow < CRow(); irow++ )
		{
			REAL r = *pr1;
			*pr1 = *pr2;
			*pr2 = r;			
			pr1 += icolInc;
			pr2 += icolInc;
		}
	}	

	//  Return the transpose of the matrix
	VRMATRIX VrmatrixTranspose () const;
	//	Return a row vector
	VLREAL VectorRow ( int irow ) const;
	//  Return a column vector
	VLREAL VectorColumn ( int icol ) const;
	//  Project a view of the matrix (see documentation below).
	VRMATRIX VrmatrixProject ( const VIMD & vimdRowColumnRetain ) const;
	VRMATRIX operator * ( const VRMATRIX & matrix ) const;
	VRMATRIX operator * ( const VLREAL & vreal ) const;

	VRMATRIX & operator += ( const VRMATRIX & matrix );
	VRMATRIX & operator -= ( const VRMATRIX & matrix );
	VRMATRIX & operator *= ( REAL rScalar );
	VRMATRIX & operator += ( REAL rScalar );
	VRMATRIX & operator -= ( REAL rScalar );
	VRMATRIX & operator /= ( REAL rScalar );
};

class VRMATRIXSQ : public VRMATRIX
{
  public:
  	VRMATRIXSQ(int cdim)
		: VRMATRIX(cdim,cdim),
		_iSign(1)
		{}
	VRMATRIXSQ () {}
	//  Construct a square matrix as the product of a column
	//    and a row vector.
	VRMATRIXSQ ( const VLREAL & vrColumn, const VLREAL & vrRow );

	~ VRMATRIXSQ() {}

	// Return true if matrix is in L-U decomposition form
	bool BIsLUDecomposed () const
		{ return _vimdRow.size() > 0 ; }

	//  Destructive computation routines
	VRMATRIXSQ & operator *= ( REAL rScalar )
	{
		VRMATRIX::operator*=(rScalar);
		return self;
	}
	VRMATRIXSQ & operator /= ( REAL rScalar )
	{
		VRMATRIX::operator/=(rScalar);
		return self;
	}
	VRMATRIXSQ & operator += ( REAL rScalar )
	{
		VRMATRIX::operator+=(rScalar);
		return self;
	}
	VRMATRIXSQ & operator -= ( REAL rScalar )
	{
		VRMATRIX::operator-=(rScalar);
		return self;
	}
	VRMATRIXSQ & operator += ( const VRMATRIXSQ & matrix )
	{
		VRMATRIX::operator+=(matrix);
		return self;
	}

	VRMATRIXSQ & operator -= ( const VRMATRIXSQ & matrix )
	{
		VRMATRIX::operator-=(matrix);
		return self;
	}

	VRMATRIXSQ & operator *= ( const VRMATRIXSQ & matrix );

		// Perform L-U decomposition; throw exception if singular
		// If "use tiny" is set, pivots at zero are replaced with
		//	 RTINY value (1.0e-20)
	void LUDecompose( bool bUseTinyIfSingular = false );
		
		// Invert; throw exception singular.  If not in L-U form,
		// L-U Decomp is called.
	void Invert( bool bUseTinyIfSingular = false );
		
		// Return the determinant.  If not in L-U form,
		// L-U Decomp is called.
	DBL DblDeterminant();

		// Return the log of the determinant. If not in L-U form,
		// L-U Decomp is called. Throws exception if negative.
	DBL DblLogDeterminant();


	//  ------------------------------------
	//  Non-destructive computation routines
	//  ------------------------------------
		
		// Adds the log of each element in the diagonal and returns the sum.
	DBL DblAddLogDiagonal() const;

		// Set vrmatResult to be the result of performing an L-U 
		// decomposition on the matrix. Will throw exception if 
		// the matrix is singular
		// If "use tiny" is set, pivots at zero are replaced with
		//	 RTINY value (1.0e-20)
	void GetLUDecompose( VRMATRIXSQ & vrmatResult, bool bUseTinyIfSingular = false ) const;
		
		// Set vrmatResult to the inverse of the matrix.
		// Will throw an exception if the matrix is singular.  
	void GetInverse( VRMATRIXSQ & vrmatResult, bool bUseTinyIfSingular = false ) const;
		
		// Get the determinant without modifying (LU decomposing) the matrix.
		// vrmatResult will contain the LU decomposed version of the matrix. 
	void GetDblDeterminant( DBL& dblDeterm, VRMATRIXSQ & vrmatResult ) const;

		 // Get the log of determinant without modifying (LU decomposing) the matrix.
		 // vrmatResult will contain the LU decomposed version of the matrix. 
	void GetDblLogDeterminant( DBL& dblLogDeterm, VRMATRIXSQ & vrmatResult) const;

	//  Project a view of the matrix (see documentation below).
	VRMATRIXSQ VrmatrixProject ( const VIMD & vimdRowColumnRetain ) const;

  protected:

	int		_iSign;
	VIMD	_vimdRow;

  	void LUDBackSub(const VRMATRIXSQ & matrix);
};


/*  
	How to use the VRMATRIX::Project() function.

	Original matrix:
	1 2 3
	4 5 6
	7 8 9

	The (0,2) projection is obtained by deleting the 2nd row and 2nd column:
	1 3
	7 9

	The (0,1) projection is obtained by deleting the 3rd row (and third column):
	1 2
	4 5

	The (1,2) projeciton is obtained by deleting the 1st row and 1st column:
	5 6
	8 9

	The (0) projection is obtained by deleting the 2nd and 3rd rows and columns:
	1
*/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\zstr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       zstr.cpp
//
//--------------------------------------------------------------------------

//
//	ZSTR.CPP
//

#include <iostream>
#include <fstream>
#include <stdarg.h>
#include <stdio.h>
#include "zstr.h"

void ZSTR :: Vsprintf ( SZC szcFmt, va_list valist )
{
	//  Attempt to "sprintf" the buffer. If it fails, reallocate
	//   a larger buffer and try again.	
	UINT cbMaxNew = 0;
	char * psz = NULL;
	INT cbOut;
	do {
		delete psz;
		if ( cbMaxNew == 0 )
			cbMaxNew = 256;
		else
			cbMaxNew += cbMaxNew / 2;
		psz = new char[cbMaxNew];
	} while (  (cbOut = ::_vsnprintf( psz, cbMaxNew-1, szcFmt, valist )) < 0 ) ; 
	psz[cbOut] = 0;
	self = psz;
	delete psz;
}

void ZSTR :: Format ( SZC szcFmt, ... )
{
	va_list	valist;
	va_start( valist, szcFmt );
	
	Vsprintf( szcFmt, valist ) ;
	
	va_end( valist );
}

void ZSTR :: FormatAppend ( SZC szcFmt, ... ) 
{
	ZSTR strTemp ;
	va_list	valist;
	va_start( valist, szcFmt );
	
	strTemp.Vsprintf( szcFmt, valist ) ;
	va_end( valist );
	
	self += strTemp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\zstr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       zstr.h
//
//--------------------------------------------------------------------------

//
//	ZSTR.H:	String management
//

#ifndef _ZSTR_H_
#define _ZSTR_H_

#include <string>		//  STL string class
#include "basics.h"

////////////////////////////////////////////////////////////////////
//	class ZSTR
//
//		simple string providing normally expected function
////////////////////////////////////////////////////////////////////
class ZSTR : public string
{
  public:
	ZSTR ( SZC szc = NULL )
		: string(szc == NULL ? "" : szc)
		{}
	SZC Szc() const
		{ return c_str(); }
	inline operator SZC () const
		{ return Szc(); }
	void Reset ()
		{ resize(0); }
	ZSTR & operator = ( SZC szc )
	{ 
		Reset();
		string::operator=(szc);
		return *this;
	}
	void FormatAppend ( SZC szcFmt, ... );
	void Format ( SZC szcFmt, ... );
	void Vsprintf ( SZC szcFmt, va_list valist );
};

DEFINEV(ZSTR);
DEFINEV(VZSTR);


// end of ZSTR.H

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\zstrt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       zstrt.cpp
//
//--------------------------------------------------------------------------

//
//	ZSTRT.CPP
//

#include <iostream>
#include <fstream>
#include <stdarg.h>
#include <stdio.h>
#include "zstrt.h"
	

ZSTRT ZSREF::Zsempty;


void STZSTR :: Dump () const
{
	STZSTR_BASE::const_iterator mpzi = IterBegin();
	STZSTR_BASE::const_iterator mpziend = IterEnd();
	
	for ( UINT i = 0; mpzi != mpziend ; mpzi++, i++ )
	{
		const ZSTRT & zsr = *mpzi;
		cout << "STZSTR #"
			 << i
			 << ": ";
		(*mpzi).Dump();
		cout << "\n";
	}
}

void ZSTRT :: Dump () const
{	
	cout << "("
		 << CRef()
		 << ") \""
		 << Szc()
		 << "\"";
}

//
//	Clone the contents of another string table into this one
//
void STZSTR :: Clone ( const STZSTR & stzstr )
{
	assert( & stzstr != this );	//  Guarantee source != target

	STZSTR_BASE::const_iterator mpzi = stzstr.IterBegin();
	STZSTR_BASE::const_iterator mpziend = stzstr.IterEnd();
	
	for ( UINT i = 0; mpzi != mpziend ; mpzi++, i++ )
	{
		const ZSTRT & zsr = *mpzi;
		Zsref( zsr.Szc() );
	}	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\bnts\bnstr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       bnstr.cpp
//
//--------------------------------------------------------------------------

//
//	BNSTR.CPP
//

#include <stdarg.h>
#include <ctype.h>

#include "bnstr.h"


SZC BNSTR :: _pmt = "" ;

static SZ	SzCopy(SZC szc)
{
	SZ		szNew = szc ? new char[::strlen(szc) + 1] : NULL;

	return  szNew ? ::strcpy(szNew, szc) : NULL;
}

BNSTR :: BNSTR ( SZC sz )
	: _cchMax( 0 ),
	_cchStr( 0 ),
	_sz( const_cast<SZ>(_pmt) )
{
	if ( sz )
	{
		Update( sz ) ;
	}
}

BNSTR :: BNSTR ( const BNSTR & str )
	: _cchMax( str._cchStr ),
	_cchStr( str._cchStr ),
	_sz( const_cast<SZ>(_pmt) )
{
	if ( str._sz != _pmt )
	{ 
		_sz = ::SzCopy( str._sz ) ;
	}
}


BNSTR :: ~ BNSTR ()
{
	Reset() ;
}

void BNSTR :: Reset ()
{   
	DeleteSz() ;
	_sz = const_cast<SZ>(_pmt) ;
	_cchStr = 0 ;
	_cchMax = 0 ;		
}

	//  Protectively delete either the given string or the 
	//  private string.
void BNSTR :: DeleteSz ()
{
	if ( _sz != NULL && _sz != _pmt )
	{
		delete [] _sz ;
		_sz = NULL ;
	}	
}

 	//  Release the current buffer; reset the BNSTR.
SZ BNSTR::Transfer ()
{
	SZ sz = _sz ;
	_sz = NULL ;
	Reset() ;
	return sz = _pmt ? NULL : sz ;
}

	//  Give the current buffer to a new string, reset *this.
void BNSTR :: Transfer ( BNSTR & str ) 
{
    str.Reset() ;
	str._sz = _sz ;
	str._cchMax = _cchMax ;
	str._cchStr = _cchStr ;
	_sz = NULL ;
	Reset() ;
}

void BNSTR :: Trunc ( UINT cchLen )
{
	if ( _sz == _pmt ) 
		return ;
	if ( cchLen < _cchStr )
		_sz[cchLen] = 0 ;
}

	//  Update the pointed string.  Since this routine is 
	//  used by the assignment operator, it's written to allow
	//  for the new string being part of the old string.
bool BNSTR :: Update ( SZC sz )
{
	bool bResult = true ;
	
	UINT cch = sz ? ::strlen( sz ) : 0 ;
	
	if ( cch > _cchMax )
	{    
		SZ szNew = ::SzCopy( sz ) ;
		if ( bResult = szNew != NULL )
		{
			DeleteSz() ;
			_sz = szNew ;
			_cchMax = _cchStr = cch ;
		}
	}
	else
	if ( cch == 0 )
	{
		Reset() ;
	}
	else
	{   
		//  REVIEW: this assumes that ::strcpy() handles overlapping regions correctly.
		::strcpy( _sz, sz ) ;
		_cchStr = cch ;
	}
	return bResult ;
}

	//  Grow the string.  if 'cchNewSize' == 0, expand by 50%.
	//  If 'ppszNew' is given, store the new string there (for efficiency in
	//  Prefix); note that this requires that we reallocate.
bool BNSTR :: Grow ( UINT cchNewSize, SZ * ppszNew )
{
	UINT cchNew = cchNewSize == 0
				? (_cchMax + (_cchMax/2))
				: cchNewSize ;
				
    bool bResult = true ;
	if ( cchNew > _cchMax || ppszNew )
	{
		SZ sz = new char [cchNew+1] ;
		if ( bResult = sz != NULL )
		{	
			_cchMax = cchNew ;
			if ( ppszNew )
			{
				*ppszNew = sz ;
			}
			else
			{
				::strcpy( sz, _sz ) ;
				DeleteSz() ;
				_sz = sz ;
			}
		}
	}
	return bResult ;
}

	//  Expand the string to the given length; make it a blank, null terminated 
	//  string.
bool BNSTR :: Pad ( UINT cchLength )
{
	//  Expand as necessary
	if ( ! Grow( cchLength + 1 ) ) 
		return false ;
	//  If expanding, pad the string with spaces.
	while ( _cchStr < cchLength ) 
	{
		_sz[_cchStr++] = ' ' ;
	}
	//  Truncate to proper length
	_sz[_cchStr = cchLength] = 0 ;
	return true ;
}

bool BNSTR :: Assign ( SZC szcData, UINT cchLen ) 
{
	if ( ! Grow( cchLen + 1 ) ) 
		return false ;
	::memcpy( _sz, szcData, cchLen ) ;
	_sz[cchLen] = 0 ;
	_cchMax = _cchStr = cchLen ;
	return true ;
}

SZC BNSTR :: Prefix ( SZC szPrefix )
{
	assert( szPrefix != NULL ) ;
	UINT cch = ::strlen( szPrefix ) ;
	SZ sz ;
	if ( ! Grow( _cchStr + cch + 1, & sz ) )
		return NULL ;
	::strcpy( sz, szPrefix ) ;
	::strcpy( sz + cch, _sz ) ;
	DeleteSz();
	_cchStr += cch ;			
	return _sz = sz ;
}

SZC BNSTR :: Suffix ( SZC szSuffix )
{
	if ( szSuffix )
	{		
		UINT cch = ::strlen( szSuffix ) ;

		if ( ! Grow( _cchStr + cch + 1 ) )
			return NULL ;

		::strcpy( _sz + _cchStr, szSuffix ) ; 		
		_cchStr += cch ;
	}

	return *this ;
}

SZC BNSTR :: Suffix ( char chSuffix )
{
	char rgch[2] ;
	rgch[0] = chSuffix ;
	rgch[1] = 0 ;
	return Suffix( rgch );
}

INT BNSTR :: Compare ( SZC szSource, bool bIgnoreCase ) const 
{
	return bIgnoreCase 
		? ::stricmp( _sz, szSource ) 
		: ::strcmp( _sz, szSource );	
}

	//  Comparison
bool BNSTR :: operator == ( SZC szcSource ) const
{
	return Compare( szcSource ) == 0 ;	
}

bool BNSTR :: operator != ( SZC szSource ) const
{
	return ! ((*this) == szSource) ;
}

char BNSTR :: operator [] ( UINT iChar ) const 
{
	assert( iChar < Length() ) ;
	return _sz[iChar] ;
}
	
bool BNSTR :: Vsprintf ( SZC szcFmt, va_list valist )
{
	//  Attempt to "sprintf" the buffer. If it fails, reallocate
	//  a larger buffer and try again.	
	UINT cbMaxNew = ( _cchMax < 50 
				 ? 50
				 : _cchMax ) + 1 ;
	do {
		if ( ! Grow( cbMaxNew ) )
		{
			Reset() ;
			return false ; 
		}
		// Cause buffer to grow by 50% on the next cycle (if necessary)
		cbMaxNew = 0 ;
		
		// Problem: If the buffer is not big enough, _sz may not have a '\0', and Grow()
		// will subsequently barf on the ::strcpy(). Quick fix:

		_sz[_cchMax] = '\0';

	} while ( ::_vsnprintf( _sz, _cchMax, szcFmt, valist ) < 0 ) ; 

	_sz[ _cchMax ] = '\0' ;			//	'cause _vsnprintf, like _strncpy, doesn't always append this

	//  Update the string length member
	_cchStr = ::strlen( _sz ) ;
	return true ;
}

bool BNSTR :: Sprintf ( SZC szcFmt, ... )
{
	va_list	valist;
	va_start( valist, szcFmt );
	
	bool bOk = Vsprintf( szcFmt, valist ) ;
	
	va_end( valist );
	return bOk ;
}

bool BNSTR :: SprintfAppend ( SZC szcFmt, ... ) 
{
	BNSTR strTemp ;
	va_list	valist;
	va_start( valist, szcFmt );
	
	bool bOk = strTemp.Vsprintf( szcFmt, valist ) ;
	va_end( valist );
	
	if ( bOk ) 
		bOk = Suffix( strTemp ) != NULL ;	
	return bOk ;
}
	
	//  Cr/Lf expansion or contraction
bool BNSTR :: ExpandNl () 
{
	UINT iCh ;
	BNSTR str ;
	Transfer( str ) ;
	
	for ( iCh = 0 ; iCh < str.Length() ; iCh++ )
	{   
		char ch = str[iCh];
		if ( ch == '\n' ) 
		{
			if ( Suffix( '\r' ) == NULL ) 
				return false ;	
		}
		if ( Suffix( ch ) == NULL ) 
			return false ;
	}
	return true ;
}

bool BNSTR :: ContractNl ()
{
	UINT iCh ;
	BNSTR str ;
	Transfer( str ) ;
	
	for ( iCh = 0 ; iCh < str.Length() ; iCh++ )
	{
		char ch = str[iCh];
		if ( ch != '\r' ) 
		{
			if ( Suffix( ch ) == NULL ) 
				return false ;
		}
	}
	return true ;
}

static char rgchEsc [][2] = 
{
	{ '\a', 'a'  },
	{ '\b', 'b'  },
	{ '\f', 'f'  },
	{ '\n', 'n'  },
	{ '\r', 'r'  },
	{ '\t', 't'  },
	{ '\v', 'v'  },
	{ '\'', '\'' },
	{ '\"', '\"' },
	{ '\?', '\?' },
	{ '\\', '\\' },
	{ 0,	0	 }
};

bool BNSTR :: ContractEscaped ()
{
	UINT iCh ;
	BNSTR str ;
	Transfer( str ) ;
	
	for ( iCh = 0 ; iCh < str.Length() ; iCh++ )
	{
		char ch = str[iCh];
		if ( ch == '\\' && str.Length() - iCh > 1 )
		{
			char chEsc = 0;
			for ( UINT ie = 0 ; rgchEsc[ie][0] ; ie++ )
			{
				if ( rgchEsc[ie][1] == ch )
					break;
			}
			if ( chEsc = rgchEsc[ie][0] )
			{
				iCh++;
				ch = chEsc;
			}
		}
		if ( Suffix( ch ) == NULL ) 
			return false ;
	}
	return true ;
}

	//  Convert unprintable characters to their escaped versions
bool BNSTR :: ExpandEscaped ()
{
	UINT iCh ;
	BNSTR str ;
	Transfer( str ) ;
	
	for ( iCh = 0 ; iCh < str.Length() ; iCh++ )
	{
		char ch = str[iCh];
		if ( ! isalnum(ch) )
		{
			char chEsc = 0;
			for ( UINT ie = 0 ; rgchEsc[ie][0] ; ie++ )
			{
				if ( rgchEsc[ie][0] == ch )
					break;
			}
			if ( chEsc = rgchEsc[ie][1] )
			{
				if (  Suffix('\\') == NULL )
					return false;
				ch = chEsc;
			}
		}
		if ( Suffix( ch ) == NULL ) 
			return false ;
	}
	return true ;	
}
		
	//  Change all alphabetic characters to the given case
void BNSTR :: UpCase ( bool bToUpper )
{
	if ( bToUpper )
		::strupr( _sz );
	else
		::strlwr( _sz );
}

	//
	//	If the given expression string contains the symbolic name,
	//	reconstruct it with the replacement name.
bool BNSTR :: ReplaceSymName ( 
	SZC szcSymName,
	SZC szcSymNameNew,
	bool bCaseInsensitive )
{   
	SZC szcFound ;		
	int cFound = 0 ;
	UINT cchOffset = 0 ;
	//  Make a working copy of the sought symbolic name
	BNSTR strSym( szcSymName );	
	if ( bCaseInsensitive )
		strSym.UpCase();
	
	do 
	{	
		BNSTR strTemp( Szc() );
		if ( bCaseInsensitive )
			strTemp.UpCase() ;	
		//  Locate the symbolic name in the temporary copy.
		szcFound = ::strstr( strTemp.Szc()+cchOffset, strSym ) ;
		//  If not found, we're done
		if ( szcFound == NULL )
			break ; 
		//  Check to see if it's really a valid token; i.e., it's delimited.
		if (   (   szcFound == strTemp.Szc() 
				|| ! iscsym(*(szcFound-1)) )
			&& (   szcFound >= strTemp.Szc()+strTemp.Length()-strSym.Length()
				|| ! iscsym(*(szcFound+strSym.Length())) )
		   )
		{
			//  Build new string from preceding characters, the new sym name 
			//	  and trailing chars.
			BNSTR strExprNew ;
			UINT cchFound = szcFound - strTemp.Szc() ;
			strExprNew.Assign( Szc(), cchFound );
			strExprNew += szcSymNameNew ;
			cchOffset = strExprNew.Length();
			strExprNew += Szc() + cchFound + strSym.Length() ;
			Assign( strExprNew );
			cFound++ ;
		}
		else
		{
			//  It was imbedded in another token.  Skip over it.
			cchOffset = szcFound - strTemp.Szc() + strSym.Length() ;
		}
	} while ( true );
		
	return cFound > 0 ;
}

	//  Find the next occurrence of the given character in the string;
	//  Return -1 if not found.
INT BNSTR :: Index ( char chFind, UINT uiOffset ) const 
{
	if ( uiOffset >= _cchStr ) 
		return -1 ;
		
	SZC szcFound = ::strchr( _sz, chFind ); 
	return szcFound  
		 ? szcFound - _sz 
		 : -1 ;
}

	//  Convert the string to a floating-point number.
double BNSTR :: Atof ( UINT uiOffset ) const
{
	return uiOffset < _cchStr  
		 ? ::atof( _sz + uiOffset )
		 : -1 ;
}
		

// End of BNSTR.CXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\bnts\bnstr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       bnstr.h
//
//--------------------------------------------------------------------------

//
//	BNSTR.HXX:  Generic string class.
//
#if !defined(_BNSTR_HXX_)
#define _BNSTR_HXX_

#include "basics.h"

class BNSTR
{
  public:
  	BNSTR ( const BNSTR & str ) ;
  	BNSTR ( SZC sz = NULL ) ;
  	~ BNSTR () ;
  	
 	SZC Szc () const 					{ return _sz ; }
 	
  	//  Allow use of a BNSTR anywhere an SZC is allowed
	operator const char * () const
		{ return _sz ; }

	//  Prefix or suffix the string with the given string or character
	SZC Prefix ( SZC szPrefix ) ;
	SZC Suffix ( SZC szSuffix ) ;
	SZC Suffix ( char chSuffix );
	
	//  Clear the string to empty	
  	void Reset () ;
  	//  Return the current length of the string
	UINT Length () const
		{ return _cchStr ; }	
	//  Return the maximum allowable length of the string
	UINT Max () const
		{ return _cchMax ; }
	//  Truncate the string to the given length.
	void Trunc ( UINT cchLen ) ;
  	//  Destructive assignment: release the current buffer and reset the BNSTR  	
  	SZ Transfer () ;
	void Transfer ( BNSTR & str ) ;
	
	//  Assignment operators
	BNSTR & operator = ( const BNSTR & str )
		{ Update( str ); return *this ; }
	BNSTR & operator = ( SZC szSource )
		{ Update( szSource ) ; return *this; }
		
	//  Assignment function (for error checking)
	bool Assign ( SZC szcSource ) 	
		{ return Update( szcSource ) ; }
	bool Assign ( SZC szcData, UINT cchLen ) ;

	//  Concatenation operators
	BNSTR & operator += ( SZC szSource )
		{ Suffix( szSource ) ; return *this ; }
	BNSTR & operator += ( char chSource )
		{ Suffix( chSource ) ; return *this ; }
	
	//  Comparison: functions and operators
	//  Standard low/eq/high plus case comparator.
	INT Compare ( SZC szSource, bool bIgnoreCase = false ) const ;
	bool operator == ( SZC szSource ) const ;
	bool operator != ( SZC szSource ) const ;
 	char operator [] ( UINT iChar ) const ;
	
	//  Formating	
	bool Vsprintf ( SZC szcFmt, va_list valist ) ;
	bool Sprintf ( SZC szcFmt, ... ) ;
	bool SprintfAppend ( SZC szcFmt, ... ) ;
	
	//  Cr/Lf expansion or contraction
	bool ExpandNl () ;
	bool ContractNl () ;
	bool ExpandEscaped ();
	bool ContractEscaped ();

	//  Expand the string to the given length; make it a blank, null terminated 
	//  string.
	bool Pad ( UINT cchLength ) ;
	
	//  Change all alphabetic characters to the given case
	void UpCase ( bool bToUpper = true ) ;
	
	bool ReplaceSymName ( SZC szcSymName, 
						  SZC szcSymNameNew, 
						  bool bCaseInsensitive = true );
	
	//  Find the next occurrence of the given character in the string;
	//  Return -1 if not found.
	INT Index ( char chFind, UINT uiOffset = 0 ) const ;						
	//  Convert the string to a floating-point number.
    double Atof ( UINT uiOffset = 0 ) const ;

	UINT CbyteCPT() const
		{ return _cchMax + 1 ; }
		
  protected:
  	bool Update ( SZC szc ) ;
  	bool Grow ( UINT cchNewSize = 0, SZ * ppszNew = NULL ) ;
  	
  	UINT _cchMax ;
  	UINT _cchStr ;
  	SZ _sz ;
  	
  private:
  	void DeleteSz () ;  	
  	static SZC _pmt ;  	
};

#endif   // !defined(_STR_HXX_)

//  End of BNSTR.HXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\zstrt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       zstrt.h
//
//--------------------------------------------------------------------------

//
//	ZSTRT.H:  String table management
//	
#ifndef _ZSTRT_H_
#define _ZSTRT_H_

#include <map>
#include <set>
#include <vector>
#include "basics.h"
#include "zstr.h"
#include "refcnt.h" 

//using namespace std;

//  Token used in probability distribution
class TKNPD;

////////////////////////////////////////////////////////////////////
//	class ZSTRT:
//		Class of reference-counted string maintained in string table
////////////////////////////////////////////////////////////////////
class ZSTRT : public ZSTR, public REFCNT
{
  friend class STZSTR;
  friend class ZSREF;
  friend class TKNPD;

  protected:
	ZSTRT( SZC szc = NULL )
		: ZSTR(szc)
		{}

  protected:
	void Dump () const;

  // Hide the assignment operator
  HIDE_AS(ZSTRT);		
};

////////////////////////////////////////////////////////////////////
//	class ZSREF:
//		Smart pointer acting as a reference to a string in a symbol
//		table (i.e., reference-counted).
//
//      ZSREF contains appropriate operators for const strings.
////////////////////////////////////////////////////////////////////
class ZSREF 
{
  friend class STZSTR;
  friend class TKNPD;

  protected:	
	ZSREF( ZSTRT & zstrt )
		: _pzstrt(& zstrt)
		{ IncRef();  }
	
  public:
	ZSREF ()
		: _pzstrt(& Zsempty)
		{}
	~ZSREF()
		{	IncRef(-1);	}
	ZSREF( const ZSREF & zsr )
		: _pzstrt(zsr._pzstrt)
		{	IncRef();	}

	ZSREF & operator = ( const ZSREF & zsr )
	{
		IncRef(-1);
		_pzstrt = zsr._pzstrt;
		IncRef(1);
		return *this;
	}
	const ZSTR & Zstr () const
		{ return *Pzst(); }
	SZC Szc () const
		{ return _pzstrt->c_str(); }
	operator SZC () const
		{ return Szc() ; }
	bool operator == ( const ZSREF & zsr ) const
	{ 
		return _pzstrt == zsr._pzstrt 
			|| ((Pzst()->length() + zsr.Pzst()->length()) == 0) ; 
	}
	bool operator < ( const ZSREF & zsr ) const
		{ return *_pzstrt < *zsr._pzstrt; }
	bool operator == ( const ZSTR & zst ) const
		{ return *_pzstrt == zst; }
	bool operator < ( const ZSTR & zst ) const
		{ return *_pzstrt < zst; }

	const ZSTRT * operator -> () const	
		{ return Pzst(); }	

	void Clear ()
	{  
		IncRef(-1);
		_pzstrt = & Zsempty;
	} 
	bool BEmpty () const
		{ return _pzstrt == & Zsempty; }

  protected:	
	ZSTRT * _pzstrt;

	void IncRef ( int i = 1 ) const
		{	_pzstrt->IncRef(i);	}
	const ZSTRT * Pzst () const
		{ return _pzstrt; }

	static ZSTRT Zsempty;
};

//  Define VZSREF
DEFINEV(ZSREF);

////////////////////////////////////////////////////////////////////
//	class STZSTR_BASE and STZSTR.  
//
//		STZSTR_BASE is an ensemble of strings.  STZSTR is a container
//		for a STZSTR_BASE.  The STL does not adequately hide 
//		implementations, so the string table had to be embedded into
//		a container to encapsulate it completely.
////////////////////////////////////////////////////////////////////
class STZSTR_BASE : public set<ZSTRT, less<ZSTRT> > {};

//  Container for a string table.  Returns only references to the string.
class STZSTR
{
  public:
	STZSTR() {}
	~ STZSTR()
	{
	#if defined(DUMP)
		Dump();
	#endif
	}

	//  The only public accessor: given a "const char *", return
	//		a ZSREF, whether by creation of a new string in the table
	//		or by returning a reference to an existing string.
	ZSREF Zsref (SZC szc)
	{
		ZSTRT zs(szc);
		STZSTR_BASE::_Pairib it = _stz.insert(zs);
		const ZSTRT & zst = *it.first;
		return ZSREF(const_cast<ZSTRT&>(zst));
	}
	void Clone ( const STZSTR & stzstr );

  protected:
	STZSTR_BASE _stz;		// The contained string table

  protected:
  	STZSTR_BASE & Stz ()
		{ return _stz; }
	//  Testing:  iterator accessors for hidden string set
	STZSTR_BASE::const_iterator IterBegin () const
		{  return _stz.begin(); }
	STZSTR_BASE::const_iterator IterEnd () const
		{  return _stz.end(); }
	void Dump () const;

	HIDE_UNSAFE(STZSTR);
};


// End of ZSTRT.H


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\bnts\bnts.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       bnts.h
//
//--------------------------------------------------------------------------

//
//	bnts.h:  Definitions for the Belief Network Troubleshooting object.
//
#ifndef _BNTS_H_
#define _BNTS_H_

//  BN system inclusions
#include "enumstd.h"		// Standard enumeration declarations for the BN system

// 'BNTS_EXPORT' should only be defined in the project that builds the DLL
#ifdef	BNTS_EXPORT
	//  We're building the DLL (exporting the class)
	#define	BNTS_RESIDENT __declspec(dllexport)
#else
	//  We're using the DLL (importing the class)
	#define	BNTS_RESIDENT __declspec(dllimport)
#endif

//  Forward declaration of internal belief network class
class MBNETDSCTS;										//  the encapsulated BN class
class GNODEMBND;										//  Discrete nodes
class LTBNPROP;											//  Property list
class ZSTR;

typedef const char * SZC;								//  simple alias
typedef char * SZ;
typedef double REAL;

////////////////////////////////////////////////////////////////////////////////////////////
//
//	class BNTS: the belief network troubleshooter
//
////////////////////////////////////////////////////////////////////////////////////////////
class BNTS_RESIDENT BNTS
{	
  public:
	//  CTOR and DTOR
	BNTS ();
	~ BNTS ();

	////////////////////////////////////////////////////////////////////
	//  Model-level queries and functions
	////////////////////////////////////////////////////////////////////
		//  Load and process a DSC-based model
	BOOL BReadModel ( SZC szcFn, SZC szcFnError = NULL );
		//  Return the number of (pre-expansion) nodes in the model
	int CNode ();
		//  Return the recommended nodes and, optionally, their values
	BOOL BGetRecommendations ();
		//  Return TRUE if the state of information is impossible
	BOOL BImpossible ();
		//  Return a property item string from the network
	BOOL BNetPropItemStr ( SZC szcPropType, int index );
		//  Return a property item number from the network
	BOOL BNetPropItemReal ( SZC szcPropType, int index, double & dbl );

	////////////////////////////////////////////////////////////////////
	//  Operations involving the "Currrent Node": call NodeSetCurrent()
	////////////////////////////////////////////////////////////////////
		//  Set the current node for other calls
	BOOL BNodeSetCurrent( int inode );
		//	Get the current node
	int INodeCurrent ();
		//  Return the index of a node given its symbolic name
	int INode ( SZC szcNodeSymName );	
		//	Return the label of the current node
	ESTDLBL ELblNode ();
		//  Return the number of discrete states in the current node
	int INodeCst ();
		//  Set the state of a node; use -1 to uninstatiate
	BOOL BNodeSet ( int istate, bool bSet = true );
		//  Return the state of a node
	int  INodeState ();
		//	Return the name of a node's state
	void NodeStateName ( int istate );
		//  Return the symbolic name of the node
	void NodeSymName ();
		//  Return the full name of the node
	void NodeFullName ();
		//  Return a property item string from the node
	BOOL BNodePropItemStr ( SZC szcPropType, int index );
		//  Return a property item number from the node
	BOOL BNodePropItemReal ( SZC szcPropType, int index, double & dbl );
		//  Return the belief for a node
	void NodeBelief ();
		//  Return true if the network is loaded and correct
	bool BValidNet () const;
		//  Return true if the current node is set
	bool BValidNode () const;
		//  Discard the model and all components
	void Clear();

	////////////////////////////////////////////////////////////////////
	//  Accessors to the function result information	
	////////////////////////////////////////////////////////////////////
	SZC SzcResult () const;					//  String answer		
	const REAL * RgReal () const;			//  Array of reals		
	const int * RgInt () const;				//  Array of Integers	
	int CReal () const;						//  Count of reals		
	int CInt () const;						//  Count of integers

  protected:
	MBNETDSCTS * _pmbnet;			//  The T/S DSC belief network
	int _inodeCurrent;				//  The current node

  protected:
	MBNETDSCTS & Mbnet();
	const MBNETDSCTS & Mbnet() const;
	GNODEMBND * Pgndd ();
	BOOL BGetPropItemStr ( LTBNPROP & ltprop, 
						   SZC szcPropType, 
						   int index, 
						   ZSTR & zstr );
	BOOL BGetPropItemReal ( LTBNPROP & ltprop, 
							SZC szcPropType, 
							int index, 
							double & dbl );
	void ClearArrays ();
	void ClearString ();
	ZSTR & ZstrResult ();
};

#endif // _BNTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\bnts\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by bnts.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\bnts\bntsdata.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       bntsdata.cpp
//
//--------------------------------------------------------------------------

//
//	bntsdata.cpp:   Data for Belief Network Troubleshooting DLL
//
#include <windows.h>

#include "bnts.h"

extern "C"
{
	int APIENTRY DllMain( HINSTANCE hInstance, 
				  		  DWORD dwReason, 
						  LPVOID lpReserved ) ;						      								
}

static BOOL init ( HINSTANCE hModule ) 
{
	return TRUE;
}

static void term () 
{
}

int APIENTRY DllMain (
    HINSTANCE hModule,
    DWORD dwReason,
    LPVOID lpReserved )
{
    BOOL bResult = TRUE ;

    switch ( dwReason )
    {
        case DLL_PROCESS_ATTACH:
            bResult = init( hModule ) ;
            break ;
        case DLL_PROCESS_DETACH:
            term() ;
            break ;
    }
    return bResult ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\bn\bnts\bnts.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       bnts.cpp
//
//--------------------------------------------------------------------------

//
//	BNTS.CPP: Belief Network Troubleshooting interface
//
#include <windows.h>

#include "bnts.h"
#include "gmobj.h"
#include "recomend.h"
#include "tchar.h"
/////////////////////////////////////////////////////////////////////////////////////
//	class MBNETDSCTS:  slightly extended version of MBNETDSC to simplify T/S interface
/////////////////////////////////////////////////////////////////////////////////////

class MBNETDSCTS : public MBNETDSC
{
	friend class BNTS;

  public:
	MBNETDSCTS ();
	virtual ~ MBNETDSCTS ();

	void PrepareForTS ();

	const VPGNODEMBND & Vpgndd ()
		{ return _vpgndd; }

	PROPMGR & PropMgr ()
		{ return _propMgr; }

	GOBJMBN_CLIQSET & InferEng ()
	{
		assert( _pCliqueSet );
		return *_pCliqueSet;
	}
	MBNET_RECOMMENDER & MbRecom ()
	{
		assert( _pmbRecom );
		return *_pmbRecom;
	}

	int INode ( int inodeSparse );
	int INode ( ZSREF zsr );

	bool BValid () const
	{
		return _pCliqueSet != NULL
			&& _pmbRecom != NULL;
	}
	bool BDirty () const
		{ return _bDirty; }
	void SetDirty ( bool bSet = true )
		{ _bDirty = bSet; }

  protected:
	void BuildNodeMap ();

  protected:
	VPGNODEMBND _vpgndd;					//  Map to node ptrs based on dense inode
	VINT _vimap;							//  Map to dense inodes based on real (sparse) inodes
	PROPMGR _propMgr;						//  Property management
	GOBJMBN_CLIQSET * _pCliqueSet;			//  The clique tree inference engine
	MBNET_RECOMMENDER * _pmbRecom;			//  The recommender
	bool _bDirty;							//  Do recommendations need to be recalced?

	//  Result fields for API
	ZSTR _zstr;			
	VREAL _vreal;
	VINT _vint;
};

MBNETDSCTS :: MBNETDSCTS ()
	: _propMgr(self),
	_pmbRecom(NULL),
	_pCliqueSet(NULL),
	_bDirty(true)
{
}

MBNETDSCTS :: ~ MBNETDSCTS ()
{
	delete _pmbRecom;
	if ( PInferEngine() )
		DestroyInferEngine();
}

//  Convert from the model's node index to the user's index
int MBNETDSCTS :: INode ( int inodeSparse )
{
	return _vimap[inodeSparse];
}

//  Convert from a string name to the user's node index
int MBNETDSCTS :: INode ( ZSREF zsr )
{
	int inode = INameIndex( zsr );
	if ( inode < 0 )
		return -1;
	return INode(inode);
}

//  Build the bi-directional maps
void MBNETDSCTS :: BuildNodeMap ()
{
	//  Allocate room to store pointers to all the named objects
	_vpgndd.resize( CNameMax() );
	_vimap.resize( CNameMax() );
	//  Find the discrete nodes
	GNODEMBND * pgndd;
	int igndd = 0;
	for ( int i = 0; i < CNameMax(); i++ )
	{
		_vimap[i] = -1;
		GOBJMBN * pgobj = PgobjFindByIndex( i );
		if ( pgobj == NULL )
			continue;
		pgndd = dynamic_cast<GNODEMBND *>( pgobj );
		if ( pgndd == NULL )
			continue;
		_vpgndd[igndd] = pgndd;
		_vimap[i] = igndd++;
	}
	_vpgndd.resize(igndd);
}

void MBNETDSCTS :: PrepareForTS ()
{
	BuildNodeMap();

	CreateInferEngine();

	DynCastThrow( PInferEngine(), _pCliqueSet);
	_pmbRecom = new MBNET_RECOMMENDER( *_pCliqueSet );
}

//  CTOR and DTOR
BNTS :: BNTS ()
	:_pmbnet(NULL),
	_inodeCurrent(-1)
{
}

BNTS :: ~ BNTS ()
{
	Clear();
}

void BNTS :: Clear ()
{
	delete _pmbnet;
	_pmbnet = NULL;
	_inodeCurrent = -1;
}

void BNTS :: ClearArrays ()
{
	if ( ! _pmbnet )
		return;
	Mbnet()._vreal.resize(0);
	Mbnet()._vint.resize(0);
}

ZSTR & BNTS :: ZstrResult ()
{
	return Mbnet()._zstr;
}

void BNTS :: ClearString ()
{
	ZstrResult() == "";
}

MBNETDSCTS & BNTS :: Mbnet()
{
	assert( _pmbnet );
	return *_pmbnet;
}

const MBNETDSCTS & BNTS :: Mbnet() const
{
	assert( _pmbnet );
	return *_pmbnet;
}

bool BNTS :: BValidNet () const
{
	return _pmbnet != NULL
		&& Mbnet().BValid();
}

bool BNTS :: BValidNode () const
{
	MBNETDSCTS & mbnts = const_cast<MBNETDSCTS &>(Mbnet());
	return BValidNet()
		&& _inodeCurrent >= 0
		&& _inodeCurrent < mbnts.Vpgndd().size();
}


////////////////////////////////////////////////////////////////////
//  Model-level queries and functions
////////////////////////////////////////////////////////////////////
	//  Load and process a DSC-based model
BOOL BNTS :: BReadModel ( SZC szcFn, SZC szcFnError )
{
	BOOL bResult = FALSE;;
	try
	{

		Clear();
		_pmbnet = new MBNETDSCTS;
		assert( _pmbnet );
		
		FILE * pfErr = szcFnError
					 ? fopen( szcFnError, "w" )
					 : NULL;

		if ( ! Mbnet().BParse( szcFn, pfErr ) )
		{
			Clear();
		}
		else
		{
			Mbnet().PrepareForTS();
			bResult = TRUE;
		}
	}
	catch ( GMException & )
	{
	}
	return bResult;
}

	//  Return the number of (pre-expansion) nodes in the model
int BNTS :: CNode ()
{
	if ( ! BValidNet() )
		return -1;
	return Mbnet().Vpgndd().size();
}

	//  Return our dense node index given a node name
int BNTS :: INode ( SZC szcNodeSymName )
{
	GOBJMBN * pgobj = Mbnet().Mpsymtbl().find( szcNodeSymName );
	if ( pgobj == NULL )
		return -1;
	ZSREF zsrNodeSymName = Mbnet().Mpsymtbl().intern( szcNodeSymName );
	return Mbnet().INode( zsrNodeSymName );
}
	//  Return TRUE if the state of information is impossible
BOOL BNTS :: BImpossible ()
{
	if ( ! BValidNet() )
		return FALSE;
	return Mbnet().InferEng().BImpossible();
}

	//  Return a property item string from the network
BOOL BNTS :: BGetPropItemStr (
	LTBNPROP & ltprop,
	SZC szcPropType,
	int index,
	ZSTR & zstr )
{
	ZSREF zsrPropName = Mbnet().Mpsymtbl().intern( szcPropType );
	PROPMBN * pprop = ltprop.PFind( zsrPropName );
	if ( pprop == NULL )
		return FALSE;		//  Not present in network property list
	if ( (pprop->FPropType() & fPropString) == 0 )
		return FALSE;		//  Not a string
	if ( index >= pprop->Count() )
		return FALSE;		//  Out of range
	zstr = pprop->Zsr( index );
	return true;
}

	//  Return a property item number from the network
BOOL BNTS :: BGetPropItemReal (
	LTBNPROP & ltprop,
	SZC szcPropType,
	int index,
	double & dbl )
{
	ZSREF zsrPropName = Mbnet().Mpsymtbl().intern( szcPropType );
	PROPMBN * pprop = ltprop.PFind( zsrPropName );
	if ( pprop == NULL )
		return FALSE;		//  Not present in network property list
	if ( (pprop->FPropType() & fPropString) != 0 )
		return FALSE;		// Not a number
	if ( index >= pprop->Count() )
		return FALSE;		//  Out of range
	dbl = pprop->Real(index);
	return true;
}

BOOL BNTS :: BNetPropItemStr ( SZC szcPropType, int index)
{
	return BGetPropItemStr( Mbnet().LtProp(),
							szcPropType,
							index,
							ZstrResult() );
}

BOOL BNTS :: BNetPropItemReal ( SZC szcPropType, int index, double & dbl )
{
	return BGetPropItemReal( Mbnet().LtProp(),
							 szcPropType, index,
							 dbl );
}

////////////////////////////////////////////////////////////////////
//  Operations involving the "Currrent Node": call NodeSetCurrent()
////////////////////////////////////////////////////////////////////
	//  Set the current node for other calls
BOOL BNTS :: BNodeSetCurrent( int inode )
{
	_inodeCurrent = inode;
	if ( ! BValidNode() )
	{
		_inodeCurrent = -1;
		return FALSE;
	}
	return TRUE;
}

	//	Get the current node
int BNTS :: INodeCurrent ()
{
	return _inodeCurrent;
}

	//	Return the label of the current node
ESTDLBL BNTS :: ELblNode ()
{
	GNODEMBND * pgndd = Pgndd();
	if ( pgndd == NULL )
		return ESTDLBL_other;	
	return Mbnet().MbRecom().ELbl( *pgndd );
}

	//  Return the number of discrete states in the current node
int BNTS :: INodeCst ()
{
	GNODEMBND * pgndd = Pgndd();
	if ( pgndd == NULL )
		return -1;	
	return pgndd->CState();
}

	//  Set the state of a node
BOOL BNTS :: BNodeSet ( int istate, bool bSet  )
{
	GNODEMBND * pgndd = Pgndd();
	if ( pgndd == NULL )
		return FALSE;	
	Mbnet().SetDirty();
	int cst = pgndd->CState();
	if ( cst <= istate )
		return FALSE;

	CLAMP clamp( true, istate, istate >= 0 );

	Mbnet().MbRecom().EnterEvidence( pgndd, clamp, bSet ) ;
	return TRUE;
}

	//  Return the state of a node
int  BNTS :: INodeState ()
{
	GNODEMBND * pgndd = Pgndd();
	if ( pgndd == NULL )
		return FALSE;	

	CLAMP clamp;

	Mbnet().InferEng().GetEvidence( pgndd, clamp ) ;
	return clamp.BActive()
		 ? clamp.Ist()
		 : -1;
}

	//	Return the name of a node's state
void BNTS :: NodeStateName ( int istate )
{
	ClearString();
	GNODEMBND * pgndd = Pgndd();
	if ( pgndd == NULL )
		return;	
	if ( istate >= pgndd->CState() )
		return;
	ZstrResult() = pgndd->VzsrStates()[istate];	
}

	//  Return the symbolic name of the node
void BNTS :: NodeSymName ()
{
	ClearString();
	GNODEMBND * pgndd = Pgndd();
	if ( pgndd == NULL )
		return;
	ZstrResult() = pgndd->ZsrefName();
}

	//  Return the full name of the node
void BNTS :: NodeFullName ()
{
	ClearString();
	GNODEMBND * pgndd = Pgndd();
	if ( pgndd == NULL )
		return;	

	ZstrResult() = pgndd->ZsFullName();		
}

GNODEMBND * BNTS :: Pgndd ()
{
	if ( ! BValidNode() )
		return NULL;	
	GNODEMBND * pgndd = Mbnet().Vpgndd()[_inodeCurrent];
	assert( pgndd );
	return pgndd;
}

	//  Return a property item string from the node
BOOL BNTS :: BNodePropItemStr ( SZC szcPropType, int index )
{
	GNODEMBND * pgndd = Pgndd();
	if ( pgndd == NULL )
		return FALSE;	

	return BGetPropItemStr( pgndd->LtProp(),
							szcPropType,
							index,
							ZstrResult() );
}

	//  Return a property item number from the node
BOOL BNTS :: BNodePropItemReal ( SZC szcPropType, int index, double & dbl )
{
	GNODEMBND * pgndd = Pgndd();
	if ( pgndd == NULL )
		return FALSE;	
	return BGetPropItemReal( pgndd->LtProp(), szcPropType, index, dbl );
}

	//  Return the belief for a node
void BNTS :: NodeBelief ()
{
	ClearArrays();

	GNODEMBND * pgndd = Pgndd();
	if ( pgndd == NULL )
		return;	
	int cState = pgndd->CState();
	MDVCPD mdvBel;
	Mbnet().InferEng().GetBelief( pgndd, mdvBel );
	assert( cState == mdvBel.size() );
	VREAL & vr = Mbnet()._vreal;
	vr.resize( cState );
	for ( int i = 0; i < cState; i++ )
	{
		vr[i] = mdvBel[i];
	}
}

	//  Return the recommended nodes and, optionally, their values
BOOL BNTS :: BGetRecommendations ()
{
	ClearArrays();

	if ( ! BValidNet() )
		return FALSE;

	if ( Mbnet().BDirty() )
	{
		Mbnet().SetDirty( false );
		//  Compute the recommendations
		try
		{
			Mbnet().MbRecom()();	
		}
		catch ( GMException & ex )
		{
			BOOL bResult = FALSE;
			switch ( ex.Ec() )
			{
				case EC_VOI_PROBDEF_ABNORMAL:
					// This is an expected condition
					bResult = TRUE;
					break;
				default:
					break;
			}
			return bResult;
		}
	}
	const VZSREF & vzsrNodes = Mbnet().MbRecom().VzsrefNodes();
	const VLREAL & vlrUtil = Mbnet().MbRecom().VlrValues();

	VREAL & vr = Mbnet()._vreal;
	VINT & vi = Mbnet()._vint;
	vr.resize( vzsrNodes.size() );
	vi.resize( vzsrNodes.size() );

	for ( int i = 0; i < vzsrNodes.size(); i++ )
	{
		int inode = Mbnet().INode( vzsrNodes[i] );
		assert( inode >= 0 ) ;
		vi[i] = inode;
		vr[i] = vlrUtil[i];
	}	
	return TRUE;
}

SZC BNTS :: SzcResult () const
{
	return Mbnet()._zstr.Szc();
}

const REAL * BNTS :: RgReal () const
{
	return & Mbnet()._vreal[0];
}

const int * BNTS :: RgInt () const
{
	return & Mbnet()._vint[0];
}

int BNTS :: CReal () const
{
	return Mbnet()._vreal.size();
}

int BNTS :: CInt () const
{
	return Mbnet()._vint.size();
}

// End of BNTS.CPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\apgtscfg.cpp ===
//
// MODULE: APGTSCFG.CPP
//
// PURPOSE: Old commment says "Reads in ini file configuration" but that's not what this does
//	>>> an up-to-date description would be nice.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.2		6/4/97		RWM		Local Version for Memphis
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//

//#include "windows.h"
#include "stdafx.h"
#include "time.h"

#include "apgts.h"
#include "ErrorEnums.h"
#include "bnts.h"
#include "BackupInfo.h"
#include "cachegen.h"
#include "apgtsinf.h"
#include "apgtscmd.h"
#include "apgtshtx.h"
#include "apgtscls.h"

#include "TSHOOT.h"

#include <memory.h>

#include "chmread.h"
//
//
CDBLoadConfiguration::CDBLoadConfiguration()
{
	m_cfg.api.pAPI = NULL;
	m_cfg.api.pTemplate = NULL;

	InitializeToDefaults();

	return;
}

VOID CDBLoadConfiguration::ResetTemplate()
{
	delete m_cfg.api.pTemplate;
	m_cfg.api.pTemplate = new CHTMLInputTemplate(m_cfg.api.szFilepath[BNOFF_HTI]);
	m_cfg.api.pTemplate->Initialize(m_cfg.api.szResPath, m_cfg.api.strFile[BNOFF_HTI]);
	return;
}
//
//
CDBLoadConfiguration::CDBLoadConfiguration(HMODULE hModule, LPCTSTR szValue)
{
	Initialize(hModule, szValue);
	return;
}
//
//
void CDBLoadConfiguration::Initialize(HMODULE hModule, LPCTSTR szValue)
{
	DWORD dwRErr;
	TCHAR temp[MAXBUF];

	_tcscpy(temp,_T(""));

	// do all setting of variables in constructor!
	InitializeToDefaults();

	ProcessEventReg(hModule);

	CreatePaths(szValue);

	InitializeSingleResourceData(szValue);

	dwRErr = CreateApi(temp);
	if (dwRErr) {
		ReportWFEvent(	_T("[apgtscfg]"), //Module Name
						_T("[CDBLoadConfiguration]"), //event
						_T("(A)"),
						temp,
						dwRErr ); 
	}
}

void CDBLoadConfiguration::SetValues(CHttpQuery &httpQ)
{
	int value;
	BCache *pAPI = m_cfg.api.pAPI;
	if(pAPI)
		if (httpQ.GetValue1(value))
			pAPI->AddValue(value);
	return;
}

//
//
CDBLoadConfiguration::~CDBLoadConfiguration()
{
	DWORD j;
	if (m_dwFilecount > 0)
		DestroyApi();

	if (m_cfg.pHandles != NULL) {
		for (j = 0; j < m_cfg.dwHandleCnt; j++) 
			if (m_cfg.pHandles[j] != NULL)
				CloseHandle(m_cfg.pHandles[j]);
		
		delete [] m_cfg.pHandles;
	}
}

// Call in constructor only!
//
VOID CDBLoadConfiguration::InitializeToDefaults()
{
	m_dwErr = 0;
	m_bncfgsz = MAXBNCFG;

	_tcscpy(m_szResourcePath, DEF_FULLRESOURCE);

	ClearCfg(0);
	m_cfg.pHandles = NULL;
	m_cfg.dwHandleCnt = 0;

	_tcscpy(m_nullstr, _T(""));

	m_dwFilecount = 0;
}

VOID CDBLoadConfiguration::InitializeSingleResourceData(LPCTSTR szValue)
{
	LoadSingleTS(szValue);
	InitializeFileTimeList();	// I don't know that this is used.
	return;
}

//
//
VOID CDBLoadConfiguration::ProcessEventReg(HMODULE hModule)
{
	HKEY hk;
	DWORD dwDisposition, dwType, dwValue, dwSize;
	TCHAR path[MAXBUF];
	BOOL bFixit = FALSE;

	// 1. check if have valid event info
	// 2. if not, create it as appropriate

	// check presence of event log info...

	_stprintf(path, _T("%s\\%s"), REG_EVT_PATH, REG_EVT_ITEM_STR);

	if (RegCreateKeyEx(	HKEY_LOCAL_MACHINE, 
						path, 
						0, 
						TS_REG_CLASS, 
						REG_OPTION_NON_VOLATILE, 
						KEY_READ | KEY_WRITE,
						NULL, 
						&hk, 
						&dwDisposition) == ERROR_SUCCESS) {
			
		if (dwDisposition == REG_CREATED_NEW_KEY) {
			// create entire registry layout for events
			CreateEvtMF(hk, hModule);
			CreateEvtTS(hk);	
		}
		else {
			// now make sure all registry elements present
			dwSize = sizeof (path) - 1;
			if (RegQueryValueEx(hk,
								REG_EVT_MF,
								0,
								&dwType,
								(LPBYTE) path,
								&dwSize) != ERROR_SUCCESS) {
				CreateEvtMF(hk, hModule);
			}
			dwSize = sizeof (DWORD);
			if (RegQueryValueEx(hk,
								REG_EVT_TS,
								0,
								&dwType,
								(LPBYTE) &dwValue,
								&dwSize) != ERROR_SUCCESS) {
				CreateEvtTS(hk);
			}
		}

		RegCloseKey(hk);
	}
}

//
//
VOID CDBLoadConfiguration::CreateEvtMF(HKEY hk, HMODULE hModule)
{
	TCHAR path[MAXBUF];
	DWORD len;

	if (hModule) {
		if ((len = GetModuleFileName(hModule, path, MAXBUF-1))!=0) {
			path[len] = _T('\0');
			if (RegSetValueEx(	hk,
								REG_EVT_MF,
								0,
								REG_EXPAND_SZ,
								(LPBYTE) path,
								len + sizeof(TCHAR)) == ERROR_SUCCESS) {
			}
		}
	}
}

//
//
VOID CDBLoadConfiguration::CreateEvtTS(HKEY hk)
{
	DWORD dwData;

	dwData = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | 
				EVENTLOG_INFORMATION_TYPE; 

	if (RegSetValueEx(	hk,
						REG_EVT_TS,
						0,
						REG_DWORD,
						(LPBYTE) &dwData,
						sizeof(DWORD)) == ERROR_SUCCESS) {
	}
}

//
// This may not actually be germane for Local Troubleshooter: probably
//	rather blindly carried over from Online TS.
// m_dir (which gives us a list of desired files) must already be filled in with file names
//	& paths before this is called.  this finishes initializing it.
VOID CDBLoadConfiguration::InitializeFileTimeList()
{
	HANDLE hSearch;
	DWORD j;

	// get a list of files we are interested in
	for (j=0;j<MAXBNFILES;j++) {
		m_dir.file[j].bExist = TRUE;
		m_dir.file[j].bChanged = FALSE;
		
		// only hti is independent
		if (j == BNOFF_HTI || j == BNOFF_BES)
			m_dir.file[j].bIndependent = TRUE;
		else
			m_dir.file[j].bIndependent = FALSE;
	
		hSearch = FindFirstFile(m_dir.file[j].szFilepath, &m_dir.file[j].FindData); 
		if (hSearch == INVALID_HANDLE_VALUE) {
			// file not found usually
			m_dir.file[j].bExist = FALSE;
		}
		else {
			FindClose(hSearch);
		}
	}
}

//
//
VOID CDBLoadConfiguration::ClearCfg(DWORD off)
{
	DWORD k;

	m_cfg.api.pAPI = NULL;
	m_cfg.api.pTemplate = NULL;
	m_cfg.api.waitcount = 0;

	for (k = 0; k < MAXBNFILES; k++) 
		_tcscpy(m_cfg.api.szFilepath[k], _T(""));
	_tcscpy(m_cfg.api.type, _T(""));
}

// Bring content of DSC/HTI files for one troubleshooter into internal memory structures
// OUTPUT *szErrInfo - info specific to error
// RETURN 0 on success
DWORD CDBLoadConfiguration::CreateApi(TCHAR *szErrInfo)
{
	DWORD j;
	DWORD dwRErr = 0, dwIErr = 0, dwTErr = 0;

	// get api count and create new objects
	m_cfg.dwApiCnt = m_dwFilecount;
	
	// (The following comment sure looks like its carried over from Online TS and has little
	//	relevance to Local TS.  This routine probably involves a lot of overkill JM 3/98)
	// create new api and other files
	// once these go live we can destroy the others
	// provided there are no users using them
	// copy over list file info
	for (j = 0; j < MAXBNFILES; j++)
	{
		_tcscpy(m_cfg.api.szFilepath[j], m_dir.file[j].szFilepath);
		m_cfg.api.strFile[j] = m_dir.file[j].strFile;
	}

	_tcscpy(m_cfg.api.szResPath, m_dir.szResPath);
	_tcscpy(m_cfg.api.type, m_dir.type);

	if (NULL != m_cfg.api.pAPI)
		delete m_cfg.api.pAPI;

	if ((m_cfg.api.pAPI = new BCache(	m_cfg.api.szFilepath[BNOFF_DSC],
										m_cfg.api.type,
										m_szResourcePath,
										m_cfg.api.strFile[BNOFF_DSC])) == NULL) {
		dwRErr = EV_GTS_ERROR_INFENGINE;
	}
	// 
	dwTErr = m_cfg.api.pAPI->Initialize(/*m_cfg.pWordExcept*/);
	if (dwTErr) {
		dwIErr = dwTErr;
		_tcscpy(szErrInfo, m_cfg.api.szFilepath[BNOFF_DSC]);
	}
	if (NULL != m_cfg.api.pTemplate)
		delete m_cfg.api.pTemplate;
	if ((m_cfg.api.pTemplate = new CHTMLInputTemplate(m_cfg.api.szFilepath[BNOFF_HTI])) == NULL) {
		dwRErr = EV_GTS_ERROR_TEMPLATE_CREATE;
	}

	dwTErr = m_cfg.api.pTemplate->Initialize(m_cfg.api.szResPath, m_cfg.api.strFile[BNOFF_HTI]);
	if (dwTErr) {
		dwIErr = dwTErr;
		_tcscpy(szErrInfo, m_cfg.api.szFilepath[BNOFF_HTI]);
	}

	if (!dwRErr)
		if (dwIErr)
			dwRErr = dwIErr;
		
	return dwRErr;
}

//
//
VOID CDBLoadConfiguration::DestroyApi()		
{
	DWORD i;

	for (i=0;i<m_cfg.dwApiCnt;i++) {

		if (m_cfg.api.pAPI)
			delete m_cfg.api.pAPI;
		
		m_cfg.api.pAPI = NULL;
		
		if (m_cfg.api.pTemplate)
			delete m_cfg.api.pTemplate;
		
		m_cfg.api.pTemplate = NULL;

	}
}	

//
//
BNCTL *CDBLoadConfiguration::GetAPI()
{
	return &m_cfg;
}

//
//
BOOL CDBLoadConfiguration::FindAPIFromValue(BNCTL *currcfg, 
											LPCTSTR type, 
											CHTMLInputTemplate **pIT, 
											/*CSearchForm **pBES,*/
											BCache **pAPI,
											DWORD *dwOff)
{
	*pIT = currcfg->api.pTemplate;
	*pAPI = currcfg->api.pAPI;
	*dwOff = 0;
	return TRUE;	
}

//
//
TCHAR *CDBLoadConfiguration::GetHtmFilePath(BNCTL *currcfg, DWORD i)
{
	if (i >= currcfg->dwApiCnt)
		return m_nullstr;
	
	return currcfg->api.szFilepath[BNOFF_HTM];
}

//
//
TCHAR *CDBLoadConfiguration::GetBinFilePath(BNCTL *currcfg, DWORD i)
{
	if (i >= currcfg->dwApiCnt)
		return m_nullstr;
	
	return currcfg->api.szFilepath[BNOFF_DSC];
}

//
//
TCHAR *CDBLoadConfiguration::GetHtiFilePath(BNCTL *currcfg, DWORD i)
{
	if (i >= currcfg->dwApiCnt)
		return m_nullstr;
	
	return currcfg->api.szFilepath[BNOFF_HTI];

}

//
//
//	RETURNS symbolic name of troubleshooter
TCHAR *CDBLoadConfiguration::GetTagStr(BNCTL *currcfg, DWORD i)
{
	if (i >= currcfg->dwApiCnt)
		return m_nullstr;
	
	return currcfg->api.type;
}

//
//
// RETURNS number of [instances of] troubleshooters.  Probably a dubious inheritance from 
//	Online TS: Local TS should have only one troubleshooting belief network.
DWORD CDBLoadConfiguration::GetFileCount(BNCTL *currcfg)
{
	return currcfg->dwApiCnt;
}

// Look in the registry for whether we are using DSC files or DSZ files.
void CDBLoadConfiguration::GetDSCExtension(CString &strDSCExtension, LPCTSTR szValue)
{
	HKEY hKey;
	CString strSubKey = TSREGKEY_TL;
	strSubKey += _T("\\");
	strSubKey += szValue;
	if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE,
			strSubKey,
			NULL,
			KEY_READ,
			&hKey))
	{
		strDSCExtension = DSC_DEFAULT;	// Default to DSZ
		return;
	}
	DWORD dwSize;
	DWORD dwType = REG_SZ;
	long lRes = RegQueryValueEx(hKey,
			TSLCL_FMAINEXT,
			NULL,
			&dwType,
			(BYTE *) strDSCExtension.GetBufferSetLength(10),
			&dwSize);
	strDSCExtension.ReleaseBuffer();
	if (ERROR_MORE_DATA == lRes)
	{
		lRes = RegQueryValueEx(hKey,
			TSLCL_FMAINEXT,
			NULL,
			&dwType,
			(BYTE *) strDSCExtension.GetBufferSetLength(dwSize + 2),
			&dwSize);
		strDSCExtension.ReleaseBuffer();
		if (ERROR_SUCCESS != lRes ||
			strDSCExtension.GetLength() < 1)
		{
			RegCloseKey(hKey);
			strDSCExtension = DSC_DEFAULT;
			return;
		}
	}
	else	// ERROR_SUCCESS is true or false
		if (ERROR_SUCCESS != lRes || strDSCExtension.GetLength() < 1)
		{
			RegCloseKey(hKey);
			strDSCExtension = DSC_DEFAULT;
			return;
		}
	RegCloseKey(hKey);
	if (_T('.') != strDSCExtension.GetAt(0))
		strDSCExtension = _T('.') + strDSCExtension;
	return;
}

//
// LoadSingleTS replaces ProcessLstFile when apgts is used in an
// ActiveX or OLE control.
VOID CDBLoadConfiguration::LoadSingleTS(LPCTSTR szValue)
{
	CString strRefedDSCExtension = _T("");
	ASSERT(1 == MAXBNCFG);
	if (m_dwFilecount >= m_bncfgsz) {
		// need to reallocate space
		DWORD newdirsz = (m_bncfgsz + MAXBNCFG) * sizeof (BNDIRCFG);
		DWORD newcfgsz = (m_bncfgsz + MAXBNCFG) * sizeof (BNAPICFG);

		ASSERT(0 == m_bncfgsz);
		ClearCfg(m_bncfgsz);

		m_bncfgsz += MAXBNCFG;
	}

	GetDSCExtension(strRefedDSCExtension, szValue);

	// No matter if we are using CHM or not - 
	//  this path will be "..\..\network.htm".
	// We are not using it directly ANYWAY
	_stprintf(m_dir.file[BNOFF_HTM].szFilepath, _T("%s%s.htm"), m_szResourcePath,szValue);

	if (IsUsingCHM())
	{
		m_dir.file[BNOFF_DSC].strFile = CString(szValue) + strRefedDSCExtension;
		_stprintf(m_dir.file[BNOFF_DSC].szFilepath, _T("%s%s"), m_szResourcePath,(LPCTSTR)m_strCHM);
	}
	else
	{
		_stprintf(m_dir.file[BNOFF_DSC].szFilepath, _T("%s%s"), m_szResourcePath,szValue);
		_tcscat(m_dir.file[BNOFF_DSC].szFilepath, (LPCTSTR) strRefedDSCExtension);
	}
	
	if (IsUsingCHM())
	{
		m_dir.file[BNOFF_HTI].strFile = CString(szValue) + HTI_DEFAULT;
		_stprintf(m_dir.file[BNOFF_HTI].szFilepath, _T("%s%s"), m_szResourcePath,(LPCTSTR)m_strCHM);
	}
	else
	{
		_stprintf(m_dir.file[BNOFF_HTI].szFilepath, _T("%s%s.hti"), m_szResourcePath,szValue);
	}

	_stprintf(m_dir.file[BNOFF_BES].szFilepath, _T("%s%s.bes"), m_szResourcePath,szValue);

	_tcscpy(m_dir.szResPath, m_szResourcePath);

	_tcscpy(m_dir.type, szValue);
	m_dwFilecount++;
	ASSERT(1 == m_dwFilecount);
	return;
}


//
//
BOOL CDBLoadConfiguration::CreatePaths(LPCTSTR szNetwork)
{
	int len;
	BOOL bDirChanged;
	
	// if reg entry not present, we need to add it
	bDirChanged = GetResourceDirFromReg(szNetwork);

	// a this point we are guaranteed to have len > 0 for each below

	// do our own validation (add backshash if not present)
	len = _tcslen(m_szResourcePath);
	if (len) {
		if (m_szResourcePath[len - 1] == _T('/'))
			m_szResourcePath[len - 1] = _T('\\');
		else if (m_szResourcePath[len-1] != _T('\\')) {
			m_szResourcePath[len] = _T('\\');
			m_szResourcePath[len+1] = _T('\0');
		}
	}

	return bDirChanged;
}

//
//
TCHAR *CDBLoadConfiguration::GetFullResource()
{
	return (m_szResourcePath);
}

//
//
VOID CDBLoadConfiguration::GetVrootPath(TCHAR *tobuf)
{
	_tcscpy(tobuf, _T(""));
}

// Find (or if it doesn't exist, create) a registry key giving path to resource directory.
// if returns true, then directory is new or changed
// if returns false, directory entry is same as before
// Yet another case of something which maybe overkill, left over from Online TS.
BOOL CDBLoadConfiguration::GetResourceDirFromReg(LPCTSTR szNetwork)
{
	HKEY hknew;
	DWORD dwType, dwSize, dwDisposition, len;
	TCHAR buf1[MAXBUF], buf2[MAXBUF];
	BOOL bDirChanged = TRUE;
	LONG lErr;
	CString tmp;

	// search for "Path" value in SOFTWARE\Microsoft\TShoot\TroubleshooterList\Network
	if (::GetNetworkRelatedResourceDirFromReg(szNetwork, &tmp))
	{
		if (::IsNetworkRelatedResourceDirCHM(tmp))
		{
			m_strCHM = ::ExtractCHM(tmp);
			_tcscpy(m_szResourcePath, ::ExtractResourceDir(tmp));
		}
		else
		{
			_tcscpy(m_szResourcePath, tmp);
		}
	}
	else
	{
		// create key if not present
		if (RegCreateKeyEx(	HKEY_LOCAL_MACHINE, 
							TSREGKEY_MAIN, 
							0, 
							TS_REG_CLASS, 
							REG_OPTION_NON_VOLATILE, 
							KEY_READ | KEY_WRITE,
							NULL, 
							&hknew, 
							&dwDisposition) == ERROR_SUCCESS) 
		{
			if (dwDisposition == REG_OPENED_EXISTING_KEY) 
			{
				// Get the current key value.
				dwSize = MAXBUF - 1;
				dwType = REG_SZ;
				if ((lErr = RegQueryValueEx(hknew,
									FULLRESOURCE_STR,
									0,
									&dwType,
									(LPBYTE) buf1,
									&dwSize)) == ERROR_SUCCESS) 
				{
					if (dwType == REG_EXPAND_SZ || dwType == REG_SZ) 
					{
						if (ExpandEnvironmentStrings(buf1, buf2, MAXBUF-1)) 
						{
							len = _tcslen(buf2);
							if (len) 
							{
								if (buf2[len-1] != _T('\\')) 
								{
									buf2[len] = _T('\\');
									buf2[len+1] = _T('\0');
								}
							}

							if (!_tcscmp(m_szResourcePath, buf2)) 
								bDirChanged = FALSE;
							else 
								_tcscpy(m_szResourcePath, buf2);
						}
						else 
						{
							ReportWFEvent(	_T("[apgtscfg]"), //Module Name
							_T("[GetResourceDirFromReg]"), //event
							_T(""),
							_T(""),
							EV_GTS_ERROR_CANT_GET_RES_PATH ); 
						}
					}
					else 
					{
						ReportWFEvent(	_T("[apgtscfg]"), //Module Name
						_T("[GetResourceDirFromReg]"), //event
						_T(""),
						_T(""),
						EV_GTS_ERROR_CANT_GET_RES_PATH ); 
					}
				}
				else 
				{
					_stprintf(buf1, _T("%ld"),lErr);
					ReportWFEvent(	_T("[apgtscfg]"), //Module Name
									_T("[GetResourceDirFromReg]"), //event
									buf1,
									_T(""),
									EV_GTS_ERROR_CANT_OPEN_SFT_3 );
				}
			}
			else
			{	// Created new key.  Don't have any resources.
				_stprintf(buf1, _T("%ld"),ERROR_REGISTRY_IO_FAILED);
				ReportWFEvent(	_T("[apgtscfg]"), //Module Name
								_T("[GetResourceDirFromReg]"), //event
								buf1,
								_T(""),
								EV_GTS_ERROR_CANT_GET_RES_PATH);
			}
			RegCloseKey(hknew);
		}
		else 
		{
			ReportWFEvent(	_T("[apgtscfg]"), //Module Name
							_T("[GetResourceDirFromReg]"), //event
							_T(""),
							_T(""),
							EV_GTS_ERROR_CANT_OPEN_SFT_2 ); 
		}					
	}
	return bDirChanged;
}

//
//
VOID CDBLoadConfiguration::BackslashIt(TCHAR *str)
{
	while (*str) {
		if (*str==_T('/'))
			*str=_T('\\');
		str = _tcsinc(str);
	}
}

VOID CDBLoadConfiguration::ResetNodes()
{
	m_cfg.api.pAPI->ResetNodes();
	return;
}

bool CDBLoadConfiguration::IsUsingCHM()
{
	return 0 != m_strCHM.GetLength();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\apgtscac.cpp ===
//
// MODULE: APGTSCAC.CPP
//
// PURPOSE: Belief network caching support classes
// Each CBNCacheItem object effectively corresponds to a possible state of the belief 
//	network, and provides a next recommended action. More specifically, data member 
//	m_CItem provides 
//	- an array of nodes and a corresponding array of their states.  Taken together, 
//		these represent a state of the network
//	- an array of nodes, which constitute the recommendations as to what to try next
//		based on this state of the network.  The first node in the list is the node we
//		will display; if the user says "don't want to try this now" we'd go on to the next, 
//		etc.
// These are collected into a CBNCache object, so if you get a hit on one of these network
//	states, you can get your recommendation without needing the overhead of hitting BNTS.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 10-2-96
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.2		6/4/97		RWM		Local Version for Memphis
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//

#include "stdafx.h"
#include "apgts.h"
#include "ErrorEnums.h"
//
//
CBNCacheItem::CBNCacheItem(const BN_CACHE_ITEM *pItem, CBNCacheItem* pcitNext)
{
	m_dwErr = 0;

	memcpy(&m_CItem, pItem, sizeof (BN_CACHE_ITEM));
	
	m_CItem.uName = (UINT *)malloc(m_CItem.uNodeCount * sizeof (UINT));
	m_CItem.uValue = (UINT *)malloc(m_CItem.uNodeCount * sizeof (UINT));
	m_CItem.uRec = (UINT *)malloc(m_CItem.uRecCount * sizeof (UINT));

	if (m_CItem.uName && m_CItem.uValue && m_CItem.uRec) {
		memcpy(m_CItem.uName, pItem->uName, m_CItem.uNodeCount * sizeof (UINT));
		memcpy(m_CItem.uValue, pItem->uValue, m_CItem.uNodeCount * sizeof (UINT));
		memcpy(m_CItem.uRec, pItem->uRec, m_CItem.uRecCount * sizeof (UINT));
	}
	else
		m_dwErr = EV_GTS_ERROR_CAC_ALLOC_MEM;

	m_pcitNext = pcitNext;
};

//
//
CBNCacheItem::~CBNCacheItem()
{
	if (m_CItem.uName)
		free(m_CItem.uName);
		
	if (m_CItem.uValue)
		free(m_CItem.uValue);
	
	if (m_CItem.uRec) 
		free(m_CItem.uRec);
};

//
//
DWORD CBNCacheItem::GetStatus()
{
	return m_dwErr;
}

//
//
CBNCache::CBNCache()
{
	m_pcit = NULL;
	m_dwErr = 0;
}

//
//
CBNCache::~CBNCache()
{
	CBNCacheItem *pcit, *pti;

	pcit = m_pcit;
	while (pcit) {
		pti = pcit;
		pcit = pcit->m_pcitNext;
		delete pti;
	}
}

//
//
DWORD CBNCache::GetStatus()
{
	return m_dwErr;
}

// NOTE: Must call FindCacheItem first and not call this 
// function to prevent duplicate records from going into cache
//
BOOL CBNCache::AddCacheItem(const BN_CACHE_ITEM *pList)
{
	CBNCacheItem *pcit = new CBNCacheItem(pList, m_pcit);

	if (pcit == NULL)
		m_dwErr = EV_GTS_ERROR_CAC_ALLOC_ITEM;
	else if (!m_dwErr)
		m_dwErr = pcit->GetStatus();

	return (m_pcit = pcit) != NULL;
}

// Find match, return false if not found, otherwise true and fills 
// structure with found item
// Also move matched up to top and remove last item if too many
//
BOOL CBNCache::FindCacheItem(const BN_CACHE_ITEM *pList, UINT& count, UINT Name[])
{
	UINT uSize;
	CBNCacheItem *pcit, *pcitfirst, *pcitlp;

	uSize = pList->uNodeCount * sizeof (UINT);

	pcitlp = pcitfirst = pcit = m_pcit;

	for (; pcit; pcit = pcit->m_pcitNext) 
	{
		if (pList->uNodeCount == pcit->m_CItem.uNodeCount) 
		{
			if (!memcmp(pList->uName, pcit->m_CItem.uName, uSize) &&
				!memcmp(pList->uValue, pcit->m_CItem.uValue, uSize)) 
			{
				// check not at top already
				if (pcit != pcitfirst) 
				{
					// remove from list
					while (pcitlp) {
						if (pcitlp->m_pcitNext == pcit) 
						{
							pcitlp->m_pcitNext = pcitlp->m_pcitNext->m_pcitNext;
							break;
						}
						pcitlp = pcitlp->m_pcitNext;
					}

					// move to top
					m_pcit = pcit;
					pcit->m_pcitNext = pcitfirst;
				}
				break;
			}
		}
	}

	// count items
	if (CountCacheItems() > MAXCACHESIZE) 
	{	
		// remove last item
		
		if ((pcitlp = m_pcit) != NULL) 
		{
			if (pcitlp->m_pcitNext) 
			{
				while (pcitlp) 
				{
					if (pcitlp->m_pcitNext->m_pcitNext == NULL) 
					{
						delete pcitlp->m_pcitNext;
						pcitlp->m_pcitNext = NULL;
						break;
					}
					pcitlp = pcitlp->m_pcitNext;
				}
			}
		}
	}

	if (pcit == NULL)
		return FALSE;
	
	count = pcit->m_CItem.uRecCount;
	memcpy(Name, pcit->m_CItem.uRec, count * sizeof (UINT));

	return TRUE;
}

// Get count of items in cache
//
UINT CBNCache::CountCacheItems() const
{
	UINT uCount = 0;

	for (CBNCacheItem* pcit = m_pcit; pcit; pcit = pcit->m_pcitNext, uCount++)
	{ 
		// do nothing: action is all in condition of for-loop
	}
	
	return uCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\apgts.h ===
//
// MODULE: APGTS.H
//
// PURPOSE: Main header file for DLL
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
//			further work by Richard Meadows (RWM), Joe Mabel, Oleg Kalosha
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.2		6/4/97		RWM		Local Version for Memphis
// V0.3		3/24/98		JM/OK+	Local Version for NT5
//

//#define __DEBUG_HTTPQUERY_ 1



//-----------------------
// !!! NOTE !!!
// THIS DEFINE IS USED TO CREATE "Single Thread" VERSION FOR DEVELOPMENT
// MAKE SURE THIS IS COMMENTED OUT FOR RELEASE VERSION!
//
// Purpose of Single Thread Version: To allow noncaching of DLL to allow easy
// update of dll w/o dealing with shutting down server/starting it up.
//
#define SINGLE_THREAD_VER
//-----------------------

// for belief networks
#define MAXBNCFG	1	// An allocation unit, not really relevant here in the Local Troubleshooter,
						// because (unlike the Online Troubleshooter) this is _not_ a server which 
						// handles multiple troubleshooting networks simultaneously.

//
#define MAXBUF	256 * 2	// length of text buffers used for filenames and other purposes
						// *2 is because we need a larger buffer for the MBCS strings.
#define STRBUFSIZE 258	// CString buffer size for calling BNTS functions.

#define CHOOSE_TS_PROBLEM_NODE	_T("TShootProblem")
#define TRY_TS_AT_MICROSOFT_SZ	_T("TShootGotoMicroSoft")
#define TRY_TS_AT_MICROSOFT_ID	2020

// Note: put no trailing slashes on this...
#define TSREGKEY_MAIN	_T("SOFTWARE\\Microsoft\\TShoot")
#define TSREGKEY_TL		_T("SOFTWARE\\Microsoft\\TShoot\\TroubleshooterList")
#define TSREGKEY_SFL	_T("SOFTWARE\\Microsoft\\TShoot\\SupportFileList")

#define FULLRESOURCE_STR	_T("FullPathToResource")
#define LOCALHOST_STR		_T("LocalHost")

#define TS_REG_CLASS		_T("Generic_Troubleshooter_DLL")

#define REG_EVT_PATH		_T("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application")
#define REG_EVT_MF			_T("EventMessageFile")
#define REG_EVT_TS			_T("TypesSupported")

#define REGSZ_TSTYPES		_T("TroubleShooterList")
#define FRIENDLY_NAME		_T("FName")
#define FRIENDLY_PATH	    _T("Path")

// reg class (optional)
#define TSLCL_REG_CLASS			_T("LOCALTS")

// value names under file type
#define TSLCL_FVERSION			_T("Version")
#define TSLCL_FMAINEXT			_T("FExtension")

// DSC file extensions.
#define DSC_COMPRESSED		_T(".dsz")
#define DSC_UNCOMPRESSED	_T(".dsc")
#define DSC_DEFAULT			_T(".dsz")
#define CHM_DEFAULT			_T(".chm")
#define HTI_DEFAULT			_T(".hti")


// max search terms to send to index server
#define MAX_TERMS_PER_SEARCH		8

// maximum cache for belief networks
#define MAXCACHESIZE				200

#define evtype(e) ( 1 << (3 - ((e >> 30))))

//------------- Growable string object ---------------//

#define CSTRALLOCGRAN	4096

//------------- Log File ---------------

#define LOGFILEPREFACE			_T("gt")
#define MAXLOGSBEFOREFLUSH		5
#define MAXLOGSIZE				1000

//------------- Generic Object list ---------------
// This really should have been a template class, but when it was first written that
// technology was not available.  VOID *m_tlist should really be a pointer to the type
// specified in this use of the template.
class COBList {
public:
	COBList(UINT incsize);
	~COBList();
	DWORD GetStatus();
	VOID *AddItemSpace(UINT itemsize);	// caller must pass in token size in bytes,
										// because this class doesn't know.
	VOID *GetList();
	UINT GetCount();
	VOID IncrementCount();

protected:
	UINT m_tokencount;			// number of tokens actually used.  Mostly managed from outside
								// the class by calls to IncrementCount().  Grows monotonically.
	UINT m_tokenlistsize;		// number of "chunks" we've allocated to the list of tokens
	UINT m_incsize;				// size of a chunk (number of tokens)
	VOID *m_tlist,		// points to array of "tokens" (e.g. WORD_TOKEN).  Type here really
						// ought to be argument to a template.
		 *m_memerror;	// after a memory reallocation failure, this takes on the old value
						// of m_tlist so the caller, aware of what the underlying type is,
						// can clean it up.
	DWORD m_dwErr;		// NOTE: once this is set nonzero, it can never be cleared, effectively
						// disabling AddItemSpace.
};

//------------- Word List Manager ---------------
//	Not currently used in Local TS.  Commented-out code here from Online TS.
/*

typedef struct _WORD_TOKEN {
	TCHAR *token;		// pointer to the keyword (or other) text
						// >> what else besides keywords are typical uses?
	UINT state;			// >>> (a guess JM 10/24/97:)state number: small integer indicating 
						//	state of a node.  *token is the name of this state.
	BOOL bDiscard;		// >>> what does it mean to "discard" a token?
	BOOL bKeyword;		// keyword >>> vs. what?
} WORD_TOKEN;

//
class CWordList {
public:
	CWordList(BOOL bSorted, BOOL bAddDuplicates, BOOL bExceptCheck);
	~CWordList();
	DWORD GetStatus();

	VOID ReadWordsFromFile(TCHAR *filepath);

	WORD_TOKEN *FindWord(TCHAR *token, UINT state, BOOL bDiscard);
	WORD_TOKEN *FindWordContained(TCHAR *token, UINT *puStartOff);

	BOOL AddWord(TCHAR *token, UINT state, BOOL bDiscard, BOOL bKeyword);
	VOID ScanInString(CWordList *pWL, const TCHAR *txtptr, UINT state, BOOL bDiscard);
	VOID ScanInKeywordString(CWordList *pWL, const TCHAR *txtptr, UINT state, BOOL bDiscard);
	BOOL ProcessToken(CWordList *pWL, TCHAR *token, UINT state, BOOL bDiscard, BOOL bKeyword);
	
	VOID SetOffset(UINT uOff, BOOL bSkipDiscard);
	UINT GetOffset();
	WORD_TOKEN *GetAtCurrOffset();
	VOID IncCurrOffset(BOOL bSkipDiscard);
	
	BOOL IsValidChar(int ch);
	BOOL IsTokenChar(INT ch);

	UINT CountNonDiscard();
	VOID OrderContents(UINT uMaxCount);

	VOID DumpContents(UINT nodeid);

protected:
	void CleanStr(TCHAR *str);
	VOID SkipDiscards();

protected:
	// The text associated with an item (indexed by i) in the list is 
	// *((static_cast<WORD_TOKEN *>(m_list->m_tlist))[i].token)
	// For simplicity, the following comments refer to that as "TOKEN" 
	COBList *m_list;
	DWORD m_dwErr;			// NOTE: once this is set nonzero, it can never be cleared.
	UINT m_uOff;			// an index into m_list->m_tlist.  "Current Offset"
	BOOL m_bSorted,			// if true, m_list->m_tlist is sorted by alphabetical order on 
							// TOKEN
		 m_bAddDuplicates,	// TRUE ==> may have two or more identical TOKEN values.
		 m_bExceptCheck;	// (>>> conjecture JM 10/28/97) do not allow words from 
							// ARTICLES.TXT in this list
};

*/
//------------- Node-Word List Manager ---------------
//	Not currently used in Local TS.  Commented-out code here from Online TS.
/*
typedef struct _WNODE_ELEM {
	UINT nodeid;
	CWordList *words;		// a word-list associated with this node, >>>but just what is
							// in this word list?
} WNODE_ELEM;

//
class CWNodeList {
public:
	CWNodeList();
	~CWNodeList();
	DWORD GetStatus();

	WNODE_ELEM *FindNode(UINT nodeid);
	CWordList *AddNode(UINT nodeid);

	UINT GetNodeCount();
	WNODE_ELEM *GetNodeAt(UINT uOffset);

	VOID DumpContents();

protected:
	COBList *m_list;
	DWORD m_dwErr;		// NOTE: once this is set nonzero, it can never be cleared.

};
*/

//------- cache classes ------------
//

typedef struct _BN_CACHE_ITEM {
	UINT uNodeCount,	// number of items in array pointed to by uName (& also uValue)
		 uRecCount;		// number of items in array pointed to by uRec
	UINT *uName;		// array of Node IDs from a single belief network. Typically not all
						//	the nodes in the belief network, just the ones on which we
						//	have state data from the user.
	UINT *uValue;		// array of States.  These are in 1-1 correspondence to *uName.
						//	uValue is a state # within the states of the corresponding node.
	UINT *uRec;			// array of Node IDs. Only the first one really matters because we will
						//	only give one recommendation at a time.  This is effectively an 
						//	output we give on a perfect match to the network state expressed
						//	by arrays *uName and *uValue.
} BN_CACHE_ITEM;

//
//

class CBNCacheItem
{
public:
	CBNCacheItem(const BN_CACHE_ITEM *, CBNCacheItem*);
	~CBNCacheItem();

	BN_CACHE_ITEM m_CItem;

	CBNCacheItem*	m_pcitNext;
	
	DWORD GetStatus();

protected:
	DWORD m_dwErr;	// NOTE: once this is set nonzero, it can never be cleared.
};

//
//

class CBNCache
{
public:
	CBNCache();
	~CBNCache();
	BOOL AddCacheItem(const BN_CACHE_ITEM *);
	BOOL FindCacheItem(const BN_CACHE_ITEM *pList, UINT& count, UINT Name[]);
	UINT CountCacheItems() const;
	DWORD GetStatus();
	
protected:

protected:
	CBNCacheItem*	m_pcit;		// points to most recently used cache item, which is head
								// of a singly linked list
	DWORD m_dwErr;				// NOTE: once this is set nonzero, it can never be cleared.
};


//------- index server search file -----------
//	Not currently used in Local TS.  Commented-out code here from Online TS.
/*
class CSearchForm {
public:
	CSearchForm(TCHAR *filepath);
	~CSearchForm();

	DWORD Initialize();
	DWORD Reload();

	TCHAR *GetEncodedSearchString();
	TCHAR *GetHTMLSearchString();

	static void ToURLString(TCHAR *ptr, TCHAR *tostr);
	BOOL IsAND();

protected:
	VOID Destroy();

	DWORD HTMLFormToURLEncoded(TCHAR *szStr, CString *pCOutStr);  // Note arg type is our CString, not MFC - JM 10/97
	static DWORD DecodeInputAttrib(TCHAR *str, TCHAR **ptrtype, TCHAR **ptrname, TCHAR **ptrvalue);
	
protected:
	CString 	// Note this is our CString, not MFC - 10/97
		*m_pCOutStr,	// URL encoded string derived from contents of BES file indicated by 
						// m_filepath, and sufficient to reconstruct that BES file
		*m_pCFormStr;	// Raw copy of entire contents of BES file indicated by m_filepath
	TCHAR m_filepath[MAXBUF];  // fully qualified filename of a BES file
	BOOL m_bIsAND;		// Normally TRUE.  Set FALSE if we encounter " OR" in the search string
};
*/

//------- property types -----------
//

// Node Properties ---------------------------------------
#define H_ST_NORM_TXT_STR	_T("HStNormTxt")	// text for radio button for "normal" state
												// (state 0)
#define H_ST_AB_TXT_STR		_T("HStAbTxt")		// text for radio button for "abnormal" state
												// (state 1)
#define H_ST_UKN_TXT_STR	_T("HStUknTxt")		// text for radio button for "no state" (e.g.
												// "I don't want to answer this right now"
												// (pseudo state 102)
#define H_NODE_HD_STR		_T("HNodeHd")		// Header text for this node
#define H_NODE_TXT_STR		_T("HNodeTxt")		// Body text for this node
#define H_NODE_DCT_STR		_T("HNodeDct")		// Special text to indicate that this node
												//	was sniffed as being in an abnormal 
												//	state.  Only relevant for a fixable node
												//	that can be sniffed.
#define H_PROB_TXT_STR		_T("HProbTxt")		// Only relevant to problem nodes.  Problem 
												//	text (e.g. "Gazonk is broken.")
#define H_PROB_SPECIAL_STR	_T("HProbSpecial")	// If this contains the string "hide", then
												//	this problem is never actually shown on a 
												//	problem page

// Network Properties -------------------------------------
#define H_PROB_HD_STR		_T("HProbHd")		// Header text for problem page

#define	HTK_BACK_BTN		_T("HTKBackBtn")	// Text for "BACK" button
#define	HTK_NEXT_BTN		_T("HTKNextBtn")	// Text for "NEXT" button
#define	HTK_START_BTN		_T("HTKStartBtn")	// Text for "START OVER" button

#define HX_SER_HD_STR		_T("HXSERHd")		// Header text for server page
#define HX_SER_TXT_STR		_T("HXSERTxt")		// Body text for server page
#define HX_SER_MS_STR		_T("HXSERMs")		// NOT CURRENTLY USED 3/98.  For service page,
												//	offers option of downloading a TS from
												//	Microsoft's site.
#define HX_SKIP_HD_STR		_T("HXSKIPHd")		// Header for "skip" page (e.g. "This 
												//	troubleshooter was unable to solve your
												//	problem.")
#define HX_SKIP_TXT_STR		_T("HXSKIPTxt")		// Text for "skip" page (e.g."Some questions 
												//	were skipped.  Try providing answers..."
#define HX_SKIP_MS_STR		_T("HXSKIPMs")		// NOT CURRENTLY USED 3/98.  For skip page,
												//	offers option of downloading a TS from
												//	Microsoft's site.
#define HX_SKIP_SK_STR		_T("HXSKIPSk")		// for "skip" page (e.g. "I want to see the 
												//	questions that I skipped.")

#define HX_IMP_HD_STR		_T("HXIMPHd")		// Header text for "impossible" page
#define HX_IMP_TXT_STR		_T("HXIMPTxt")		// Body text for "impossible" page

#define HX_FAIL_HD_STR		_T("HXFAILHd")		// Header text for "fail" page
#define HX_FAIL_TXT_STR		_T("HXFAILTxt")		// Body text for "fail" page
#define HX_FAIL_NORM_STR	_T("HXFAILNorm")	// NOT CURRENTLY USED 3/98.
#define HX_BYE_HD_STR		_T("HXBYEHd")		// Header text for "Bye" (success) page
#define HX_BYE_TXT_STR		_T("HXBYETxt")		// Body text for "Bye" (success) page
#define HX_SNIFF_AOK_HD_STR		_T("HXSnOkHd")	// Header text for "Sniff AOK" page (page 
												//	you hit when there is nothing at all to 
												//	recommend for a problem because sniffing
												//	says every single node on the path is OK)
												// If missing, "fail" page header should be
												//	used
#define HX_SNIFF_AOK_TXT_STR	_T("HXSnOkTxt")	// Body text for "Sniff AOK" page 
												// If missing, "fail" page body should be
												//	used



//------------- Event Handling ---------------

// event name (goes under application)

#define REG_EVT_ITEM_STR	_T("APGTS")

// event prototypes
VOID ReportWFEvent(LPTSTR string1,LPTSTR string2,LPTSTR string3,LPTSTR string4,DWORD eventID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\apgtscmd.h ===
//
// MODULE: APGTSCMD.CPP
//
// PURPOSE: Template string memory manager/allocator
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Victor Moore
//			further work by Roman Mach (RM), Richard Meadows (RWM), Joe Mabel, Oleg Kalosha
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			VM		Original
// V0.2		6/4/97		RWM		Local Version for Memphis
// V0.3		3/24/98		JM		Local Version for NT5//

class HTXCommand {
public:
	HTXCommand(UINT type, const TCHAR *idstr);
	virtual ~HTXCommand();
	Add( HTXCommand command);
	virtual HTXCommand *Execute(CString *cstr, CInfer *infer);
	virtual HTXCommand *GetElse();
	virtual HTXCommand *GetEndIf();
	virtual HTXCommand *GetEndFor();
	virtual void SetElse(HTXCommand *elseif);
	virtual void SetEndIf(HTXCommand *endif);
	virtual void SetEndFor(HTXCommand *endfor);
	virtual void GetResource(CString &str, const CString& chm);

	void SetStart(UINT pos);
	void SetEnd(UINT pos);
	UINT GetStart();
	UINT GetEnd();
	const TCHAR *GetIDStr();
	UINT ReadBeforeStr(UINT before, UINT after, LPCTSTR startstr);
	UINT ReadAfterStr(UINT before, UINT after, LPCTSTR startstr);
	TCHAR *GetBeforeStr();
	TCHAR *GetAfterStr();
	UINT GetBeforeLen();
	UINT GetAfterLen();
	UINT GetType();
	UINT GetStatus();
	HTXCommand *GetNext();
	void SetNext(HTXCommand *next);

protected:
	UINT m_type;			// ID which identifies this command (e.g. HTX_TYPEENDIF)
	BOOL m_error;			// can be set true on certain out-of-memory errors
							// once set, cannot be cleared
	const TCHAR *m_idstr;	// string which identifies this command (e.g. HTX_ENDIFSTR, "endif")
	// The next 2 are used in identical ways.  Might want to abstract an object here.
	TCHAR *m_beforehtmlstr;	// with m_beforelen, m_beforesize implements a "before" string,
	TCHAR *m_afterhtmlstr;	// with m_afterlen, m_aftersize implements an "after" string,

protected:
	UINT m_beforelen;	// Logical size in chars
	UINT m_afterlen;	// Logical size in chars
	UINT m_beforesize;	// Physical size in bytes
	UINT m_aftersize;	// Physical size in bytes
	UINT m_start;		// pointer into HTI file where the "after" text of this command begins
	UINT m_end;			// pointer into HTI file where the "after" text of this command ends
	HTXCommand *m_next; // link to next command (in textual sequence in file).
};

class HTXForCommand: public HTXCommand {
public:
	HTXForCommand(UINT type, TCHAR *idstr, UINT variable);
	~HTXForCommand();
	HTXCommand *Execute(CString *cstr, CInfer *infer);
	HTXCommand *GetEndFor();
	void SetEndFor(HTXCommand *endfor);


protected:
	UINT m_var_index;		// variable over whose range we iterate
	HTXCommand *m_endfor;	// associate the corresponding "endfor"
};

class HTXIfCommand: public HTXCommand {
public:
	HTXIfCommand(UINT type, TCHAR *idstr, UINT variable);
	~HTXIfCommand();
	HTXCommand *Execute(CString *cstr, CInfer *infer);
	HTXCommand *GetElse();
	HTXCommand *GetEndIf();
	void SetElse(HTXCommand *elseif);
	void SetEndIf(HTXCommand *endif);

protected:
	UINT m_var_index;		// conditional variable which determines whether "then" case
							// or "else" case appplies
	HTXCommand *m_endif;	// associate the corresponding "endif"
	HTXCommand *m_else;		// associate the corresponding "else", if any
};

class HTXDisplayCommand: public HTXCommand {
public:
	HTXDisplayCommand(UINT type, TCHAR *idstr, UINT variable);
	~HTXDisplayCommand();
	HTXCommand *Execute(CString *cstr, CInfer *infer);

protected:
	UINT m_var_index;		// ID of variable whose value will be displayed in the HTML
};

class HTXResourceCommand: public HTXCommand {
public:
	HTXResourceCommand(UINT type, TCHAR *idstr);
	virtual ~HTXResourceCommand();
	virtual HTXCommand *Execute(CString *cstr, CInfer *infer);
	virtual void GetResource(CString &str, const CString& chm);
	void GetResName(LPCTSTR var_name);

protected:
	UINT m_var_index;			// value to evaluate, e.g. PROBLEM_ASK_INDEX, 
								//	RECOMMENDATIONS_INDEX
	CString m_strFileName;		// file from which we will copy HTML
	CString m_strResource;		// in-memory copy of that file's contents
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\apgtscls.h ===
//
// MODULE: APGTSCLS.H
//
// PURPOSE: Class header file
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
//			further work by Richard Meadows (RWM), Joe Mabel, Oleg Kalosha
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.2		6/4/97		RWM		Local Version for Memphis
// V0.3		3/24/98		JM/OK+	Local Version for NT5
//

// names as part of name/value pairs to pass in to queries
#define C_TYPE			_T("type")		// name of the troubleshooting belief network
#define C_FIRST			_T("first")		// show "first" page (a list of loaded troubleshooters)
										// although useful in the Online Troubleshooter, which
										// has lots of troubleshooting networks loaded at once,
										// this is probably useless in the Local TS, except maybe
										// to show VERSIONSTR.).
#define C_SELECT		_T("select")	// UNSUPPORTED 3/98: Returns a page that has all of the 
										// troubleshooting belief networks
#define C_PRELOAD		_T("preload")	// relates to a 1997 prototype way of doing sniffing
										// with a separate OCX.  Probably should not be 
										// supported for 3/98 onwards.
#define C_ASK_LIBRARY	_T("asklibrary")	// says, in effect, "establish contact with the 
										// launch server & query it for what to do.


#define VERSIONSTR		_T("V3.0")		// >>> Typically, should be changed for each major release.

// no registry parameter can be larger than this value
#define ABS_MAX_REG_PARAM_VAL		10000

// these are settable in registry, defaults
// resource directory (configuration/support files):
#define DEF_FULLRESOURCE	_T("c:\\inetsrv\\scripts\\apgts\\resource")

// offsets for file types
#define BNOFF_HTM	0
#define BNOFF_DSC	1	// Are replacing bin with dsc.
#define BNOFF_HTI	2
#define BNOFF_BES	3

#define MAXBNFILES	4


// track a file for file change purposes
// >>> I suspect this is not ultimately relevant to Local TS.  This comes from an Online TS
//	consideration of updating when a new version of a TS belief NW is loaded. - JM
typedef struct _FILECTL {
	WIN32_FIND_DATA FindData;	// we really use this just for ftLastWriteTime.  Using the
								//	whole WIN32_FIND_DATA here makes some code a bit obscure.
	TCHAR szFilename[MAXBUF];	// just the filename (no path)
	TCHAR szFilepath[MAXBUF];	// full path name of file
	BOOL bChanged;				// TRUE ==> File exists & its date/time differs from that 
								//	indicated by FindData.ftLastWriteTime
	BOOL bExist;				// normally TRUE, set FALSE if we try to access the file
								//	& it isn't there.
	BOOL bIndependent;			// TRUE ==> this file is able to be changed independently of 
								//	any other file.  As of 10/97, this is strictly historical,
								//	but DSC files are arbitrarily considered dependent.
	CString strFile;			// file name (for example, LAN.hti), if "szFilepath"
								// member contains *.chm file
} FILECTL;

// In Online TS there is one of these for each instance of a TS Belief Network and
//	there may be multiple instances of one troubleshooter.  Probably overkill to isolate
//	as a separate struct for Local TS, but we inherited it.
typedef struct _BNAPICFG {
	BCache *pAPI;	
	CHTMLInputTemplate *pTemplate;	// object corresponding to HTI file
	DWORD waitcount;			// really a use count, >>> almost certainly irrelevant to 
								// Local TS.
	TCHAR type[MAXBUF];			// symbolic name of the Belief Network
	TCHAR szFilepath[MAXBNFILES][MAXBUF];	// first dimension corresponds to different files 
								// (DSC, HTI, BES) in the directory. Full filepath of each 
								// of these files .Index should be a BNOFF constant.
	TCHAR szResPath[MAXBUF];	// path to the monitored directory which contains the support
								// files.  Who knows why this is replicated here!
	CString strFile[MAXBNFILES];// file name (for example, LAN.hti), if "szFilepath"
								// member contains *.chm file
} BNAPICFG;

// In Online TS, one of these for API_A_OFF, one for API_B_OFF. Again, probably overkill 
//	for local TS.
typedef struct _BNCTL {
	HANDLE *pHandles;			// array of handles to mutexes. certainly irrelevant to Local TS
	DWORD dwHandleCnt;			// dimension of *pHandles
	BNAPICFG api;				// Note contrast to Online TS, where this is an array.
	DWORD dwApiCnt;				// Must be meaningless for Local TS: dimension of what's not 
								//	even an array
} BNCTL;

// track a directory for file change purposes.  Again, probably overkill for local TS.
typedef struct _BNDIRCFG {
	FILECTL file[MAXBNFILES];	// dimension corresponds to different files in the directory.
								//  Index should be a BNOFF constant
	BOOL bDependChg;			// Historically, TRUE ==> files are interdependent on an update
	TCHAR type[MAXBUF];			// symbolic name of the Belief Network
	TCHAR szResPath[MAXBUF];	// path to this directory.  SAME FOR ALL TROUBLEHOOTERS as
								// of 10/97.  Who knows why this is replicated here!
} BNDIRCFG;

//
//
#include "Rsstack.h"

class APGTSContext;
interface ILaunchTS;

class CHttpQuery {
public:
	CHttpQuery();
	~CHttpQuery();

	void RemoveAll(){m_State.RemoveAll();};
	void Debug();
	
	void Initialize(const VARIANT FAR& varCmds, const VARIANT FAR& varVals, short size);
	void SetFirst(CString &strCmd, CString &strVal);
	void FinishInit(BCache *pApi, const VARIANT FAR& varCmds, const VARIANT FAR& varVals);
	void FinishInitFromServ(BCache *pApi, ILaunchTS *pLaunchTS);
	BOOL StrIsDigit(LPCTSTR pSz);

	BOOL GetFirst(CString &strPut, CString &strValue);
	void SetStackDirection();
	BOOL GetNext(int &refedCmd, int &refedVal /* TCHAR *pPut, TCHAR *pValue */  );
	CString GetTroubleShooter();	// Gets the first Vals BSTR.
	CString GetFirstCmd();

	BOOL GetValue(int &Value, int index);
	BOOL GetValue1(int &Value);
	BOOL BackUp(BCache *pApi, APGTSContext *pCtx);
	void RemoveNodes(BCache *pApi);
	void AddNodes(BCache *pApi);

	int StatesFromServ(){return m_nStatesFromServ;};
	void RestoreStatesFromServ();

	CString GetSubmitString(BCache *pApi);

	CString& GetMachine();
	CString& GetPNPDevice();
	CString& GetDeviceInstance();
	CString& GetGuidClass();

	void PushNodesLastSniffed(const CArray<int, int>& arr);

protected:

	// The next 2 members are arrays of strings. See CHttpQuery::Initialize() for details of
	// the many conditions they must meet. Taken together, they constitute name/value 
	// pairs to set initial conditions for the troubleshooter.  The first pair indicates what 
	// troubleshooting belief network to load, the second indicates the problem node,
	// additional pairs indicate other nodes to be set.  All but the first are optional.
	VARIANT *m_pvarCmds;
	VARIANT *m_pvarVals;

	// The next 2 members are copies of the first pair in the above arrays.
	CString m_strCmd1;	// should always be "type"
	CString m_strVal1;	// name of the current troubleshooting belief network 

	// The next 4 parameters are machine, device, device instance id and class GUID
	CString m_strMachineID;
	CString m_strPNPDeviceID;
	CString m_strDeviceInstanceID;
	CString m_strGuidClass;

	int m_CurrentUse;		// >>> needs to be documented.
	int m_Size;				// clearly correlated to the number of name/value pairs that come 
							//	in from TSLaunchServ or from an HTML "get"; once 
							//	initialization is complete, one more than the number of 
							// CNodes in stack m_State.  Sometimes this is incremented
							// in synch with pushing onto the stack, sometimes not.  
							// >>> Is there any clean characterization of this variable?
							// >>> If anyone understands this better, please document. JM
	bool m_bReverseStack;  /* Richard writes in a 3/14/98 email: "I had to add reverse 
						   stack to make the thing work when launched from the device 
						   manager.  The theory is that the order of instantiations is 
						   not important.  What happens is the recommendations we get 
						   are different if the nodes are instantiated in reverse order."
						   >>> If you understand more about this, please document further. */
	UINT m_nStatesFromServ;	// the number of nodes (including the problem node) whose states
							// were set by TSLaunchServ.  This allows us to avoid showing a
							// BACK button when that would take us farther back than where 
							// we started.

	class CNode
	{
	public: 
		CNode() {cmd=0;val=0;sniffed=false;};
		int cmd;	// An IDH-style node number.  If this is an actual node, it's the
					//	"raw" node number + idhFirst, and val is the state.  If it's 
					//	<the count of nodes> + idhFirst, then val is the problem node.
					//	There's also something about a special value for TRY_TS_AT_MICROSOFT
					//	I (JM 3/98) believe that's something to do with an incomplete
					//	plan of being able to dynamically download troubleshooters
					//	from the net, but I could be wrong.
					//	>>> Maybe type should be IDH?
		int val;	// see documentation of cmd.
		bool sniffed; // indicates that the node was set as result of sniffing
					  // really UGLY that we have to spread this flag all over the place
					  // but the fact that multiple classes and data containers support
					  // the simple process of navigation is not less UGLY!!!
	};

	// Despite being a stack, there are times we access members other than
	//	by push and pop.  According to Richard, stack was originally set up here
	//	in support of BACK button, but m_bReverseStack was introduced because of a 
	//	situation (launching with problem node + other node(s) set) where 
	//	we needed to juggle things to pop problem node first.
	//	(JM 4/1/98)
	RSStack<CNode> m_State;

	void ThrowBadParams(CString &str);

	CNode m_aStatesFromServ[55];	// Keep around a copy of the states set on instructions
									//	from TS Launcher.
									// size is arbitrary, way larger than needed.
};

//
//
class CDBLoadConfiguration
{
public:
	CDBLoadConfiguration();
	CDBLoadConfiguration(HMODULE hModule, LPCTSTR szValue);
	~CDBLoadConfiguration();

	void Initialize(HMODULE hModule, LPCTSTR szValue);
	void SetValues(CHttpQuery &httpQ);
	VOID ResetNodes();
	VOID ResetTemplate();
	TCHAR *GetFullResource();
	VOID GetVrootPath(TCHAR *tobuf);

	TCHAR *GetHtmFilePath(BNCTL *currcfg, DWORD i);
	TCHAR *GetBinFilePath(BNCTL *currcfg, DWORD i);
	TCHAR *GetHtiFilePath(BNCTL *currcfg, DWORD i);

	TCHAR *GetTagStr(BNCTL *currcfg, DWORD i);
	DWORD GetFileCount(BNCTL *currcfg);

	BNCTL *GetAPI();
	BOOL FindAPIFromValue(	BNCTL *currcfg, \
							LPCTSTR type, \
							CHTMLInputTemplate **pIT, \
							/*CSearchForm **pBES,*/ \
							BCache **pAPI, \
							DWORD *dwOff);

	BOOL RescanRegistry(BOOL bChangeAllow);

	bool IsUsingCHM();

protected:
	// variables corresponding to the registry; comments refer to initial values
	TCHAR m_szResourcePath[MAXBUF];		// DEF_FULLRESOURCE: resource directory 

	CString m_strCHM;		// name of CHM file if any
	
	BNCTL m_cfg;			// In local TS, the one and only BNCTL (there are 2 in Online TS
							// as part of the reload strategy)
	BNDIRCFG m_dir;			// Similarly, for the sole instance of the sole TS belief network
	DWORD m_bncfgsz;		// a rather useless "dimension" of what is not an array in Local TS
	DWORD m_dwFilecount;	// Badly named.  Total number of instances of troubleshooters 
							//	mandated by APGTS.LST.  Proabably totally irrelvant in Local TS
	
	TCHAR m_nullstr[2];		// null string, here so if we have to return a string pointer 
							//	which is not allocated, we can point them here instead.
	DWORD m_dwErr;
	
protected:
	VOID GetDSCExtension(CString &strDSCExtension, LPCTSTR szValue);
	VOID InitializeToDefaults();
	VOID InitializeFileTimeList();
	DWORD CreateApi(TCHAR *szErrInfo);
	VOID DestroyApi();
	
	VOID LoadSingleTS(LPCTSTR szValue);	// Replaces ProcessLstFile.
	BOOL CreatePaths(LPCTSTR szNetwork);
	VOID BackslashIt(TCHAR *str);
	BOOL GetResourceDirFromReg(LPCTSTR szNetwork);

	VOID ProcessEventReg(HMODULE hModule);
	VOID CreateEvtMF(HKEY hk, HMODULE hModule);
	VOID CreateEvtTS(HKEY hk);

	VOID ClearCfg(DWORD off);
	VOID InitializeSingleResourceData(LPCTSTR szValue);  // Replaces InitializeMainResourceData when apgts is in an OLE Control.
};

//
//
typedef struct _EVAL_WORD_METRIC {
	DWORD dwVal;
	DWORD dwApiIdx;
} EVAL_WORD_METRIC;

//
//
class APGTSContext
{
public:
	APGTSContext();
	APGTSContext(	BNCTL *currcfg,
					CDBLoadConfiguration *pConf,
					CHttpQuery *pHttpQuery);
	~APGTSContext();

	void Initialize(BNCTL *currcfg,
					CDBLoadConfiguration *pConf,
					CHttpQuery *pHttpQuery);

	void DoContent(CHttpQuery *pQry);
	void RenderNext(CString &strPage);
	void Empty();
	void RemoveSkips();
	void ResetService();
	void BackUp(int nid, int state) {m_infer->BackUp(nid, state);};
	void ClearBackup() {m_infer->ClearBackup();};

	CSniffedNodeContainer* GetSniffedNodeContainer() {return m_infer ? m_infer->GetSniffedNodeContainer() : NULL;}

protected:
	void StartContent();

	DWORD ProcessCommands(LPCTSTR pszCmd, LPCTSTR pszValue);
	DWORD DoInference(LPCTSTR pszCmd, LPCTSTR pszValue, CHTMLInputTemplate *pInputTemplate, BCache *pAPI, DWORD dwOff);

	TCHAR *GetCookieValue(CHAR *pszName, CHAR *pszNameValue);
	TCHAR *asctimeCookie(struct tm *gmt);

	void DisplayFirstPage();

protected:
	DWORD m_dwErr;
	TCHAR m_vroot[MAXBUF];		// Local URL to this OCX
	TCHAR m_resptype[MAXBUF];	// HTTP response type e.g. "200 OK", "302 Object Moved"
	CString *m_pszheader;		// In Online TS, header for response file (indicates whether
								// we're sending HTML, setting a cookie, etc.)
								// Not sure how this is relevant to Local TS.
	BNCTL *m_currcfg;			// pointer to the BNCTL which we will use for this query
	CString *m_pCtxt;			// this is where we build the string to pass back (the newly
								//	constructed page)
	CHttpQuery *m_pQry;			// takes in raw URL-encoded string, gives us
								//	functions to get back scanned pairs.
	CDBLoadConfiguration *m_pConf;	// contains support-file data structures
	CInfer *m_infer;			// belief-network handler, unique to this request
	time_t m_aclock;			// time we build this object
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\apgtsctx.cpp ===
//
// MODULE: APGTSCTX.CPP
//
// PURPOSE: Implementation file for Thread Context
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.2		6/4/97		RWM		Local Version for Memphis
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//

//#include "windows.h"
#include "stdafx.h"
#include "time.h"

#include "apgts.h"
#include "ErrorEnums.h"
#include "bnts.h"
#include "BackupInfo.h"
#include "cachegen.h"
#include "apgtsinf.h"
#include "apgtscmd.h"
#include "apgtshtx.h"
#include "apgtscls.h"

#include "TSHOOT.h"

int idcomp(const void *elem1, const void *elem2);


//-----------------
//
APGTSContext::APGTSContext()
{
	m_pConf = NULL;
	m_dwErr = 0;
	m_infer = NULL;
	m_currcfg = NULL;
	_tcscpy(m_resptype, _T("200 OK"));

	m_pszheader = NULL;
	m_pCtxt = NULL;
	m_pQry = NULL;

	return;
}
//
//
APGTSContext::APGTSContext(	BNCTL *currcfg,
							CDBLoadConfiguration *pConf,
							CHttpQuery *pHttpQuery)
{
	m_infer = NULL;
	Initialize(currcfg, pConf, pHttpQuery);
	return;
}
//
//
void APGTSContext::Initialize(	BNCTL *currcfg,
								CDBLoadConfiguration *pConf,
								CHttpQuery *pHttpQuery)
{
	struct tm *newtime;
	TCHAR buf[MAXBUF+1];
	
	m_pConf = pConf;
	m_dwErr = 0;
	m_infer = NULL;
	m_currcfg = currcfg;
	_tcscpy(m_resptype, _T("200 OK"));

	if (m_pszheader)
		delete m_pszheader;
	m_pszheader = new CString();
	if (m_pCtxt)
		delete m_pCtxt;
	m_pCtxt = new CString();
	m_pQry = pHttpQuery;

	if (m_pszheader)
		*m_pszheader += _T("Content-Type: text/html\r\n");

	m_pConf->GetVrootPath(m_vroot);
		
	time( &m_aclock );
	newtime = localtime( &m_aclock );
	_tcscpy(buf,_tasctime(newtime));
	if (_tcslen(buf))
		buf[_tcslen(buf)-1] = _T('\0');// remove cr

	// get ip address to put into event log
	DWORD bufsize = MAXBUF - 1;

	if (!m_pCtxt || !m_pszheader) {
		m_dwErr = EV_GTS_ERROR_NO_STRING;
		return;
	}
	
	if (!m_pQry) {
		m_dwErr = EV_GTS_ERROR_NO_QUERY;
		return;
	}

	// create inference engine and related structures
	m_infer = new CInfer(m_pCtxt);

	if (!m_infer) {
		m_dwErr = EV_GTS_ERROR_NO_INFER;
		return;
	}

}

void APGTSContext::RemoveSkips()
{
	ASSERT(m_infer);
	if (m_infer)
		m_infer->RemoveSkips();
	return;
}

void APGTSContext::ResetService() 
{
	m_infer->ResetService();
	return;
}

void APGTSContext::RenderNext(CString &strPage)
{
	CString strTmp;
	strTmp.LoadString(IDS_ER_ERRORS_OCCURED);
	if (m_pszheader) {
		*m_pszheader += _T("\r\n");

	}

	if (m_pCtxt) {
		if (m_dwErr) 
			*m_pCtxt += strTmp;

		// write out CString here
		
		if (m_pCtxt->GetLength() > 0)
			strPage = m_pCtxt->GetBuffer(0);
	}
	else {
		strPage = strTmp;
	}
	return;
}

void APGTSContext::Empty()
{
	*m_pCtxt = _T("");
	return;
}
//
//
APGTSContext::~APGTSContext()
{
//	AfxMessageBox("Context");
	if (m_infer) 
		delete m_infer;
	if (m_pCtxt)
		delete m_pCtxt;	
	if (m_pszheader)
		delete m_pszheader;
}

// This must be called to process the data
//
//
//
void APGTSContext::DoContent(CHttpQuery *pQry)
{	
	CString strRefedCmd;
	CString strRefedValue;
	CString strTxt;
	ASSERT(NULL != pQry);
	m_pQry = pQry;

	if (m_pQry->GetFirst(strRefedCmd, strRefedValue)) {

		DWORD dwStat = ProcessCommands((LPCTSTR) strRefedCmd, (LPCTSTR) strRefedValue);

		if (dwStat != 0) {
			TCHAR temp[MAXCHAR];

			if (dwStat != EV_GTS_INF_FIRSTACC)
				m_dwErr = dwStat;

			_stprintf(temp, _T("%d"), 0); // used to put extended error here
			ReportWFEvent(	_T("[apgtscxt]"), //Module Name
							_T("[EndCommands]"), //event
							//m_pszQuery,
							NULL,
							temp,
							dwStat ); 
		}
	}
	else {
		strTxt.LoadString(IDS_ER_NO_INPUT_PARAMS);
		*m_pCtxt += strTxt;
		ReportWFEvent(	_T("[apgtscxt]"), //Module Name
						_T("[ProcessQuery]"), //event
						//m_ipstr,
						NULL,
						_T(""),
						EV_GTS_USER_NO_STRING ); 

	}
}

//
//
DWORD APGTSContext::ProcessCommands(LPCTSTR pszCmd, 
									LPCTSTR pszValue) 
{
	DWORD dwStat = 0;
	CString strTxt;

	// first command should be troubleshooter type
	if (!_tcscmp(pszCmd, C_TYPE) || !_tcscmp(pszCmd, C_PRELOAD)) {

		DWORD dwOff;
		CHTMLInputTemplate *pInputTemplate;
		//CSearchForm *pBESearch = NULL;
		BCache *pAPI;

		if (m_pConf->FindAPIFromValue(m_currcfg, pszValue, &pInputTemplate, /*&pBESearch, */ &pAPI, &dwOff)) {

			if ((dwStat = m_infer->Initialize(/*pBESearch*/)) != 0) {
				strTxt.LoadString(IDS_ER_MISSING_API);
				*m_pCtxt += strTxt;
			}
			else {
				dwStat = DoInference(pszCmd, pszValue, pInputTemplate, pAPI, dwOff);
			}
		}
		else {
			dwStat = EV_GTS_ERROR_INF_BADTYPECMD;
			strTxt.LoadString(IDS_ER_UNEXP_CMDA);
			*m_pCtxt += strTxt;
			*m_pCtxt += pszValue;
		}
	}
	else if (!_tcscmp(pszCmd, C_FIRST)) {

		DisplayFirstPage();

		dwStat = EV_GTS_INF_FIRSTACC;
	}
	else {
		dwStat = EV_GTS_ERROR_INF_BADCMD;
		strTxt.LoadString(IDS_ER_UNEXP_CMD);
		*m_pCtxt += strTxt;
		*m_pCtxt += pszCmd;
	}
	return (dwStat);
}

//
//
DWORD APGTSContext::DoInference(LPCTSTR pszCmd, 
								LPCTSTR pszValue, 
								CHTMLInputTemplate *pInputTemplate, 
								BCache *pAPI, 
								DWORD dwOff)
{
	DWORD dwCount = 0, dwStat = 0;
	BOOL bPreload = FALSE;
	CString strTxt;
	if (!_tcscmp(pszCmd, C_PRELOAD))
		bPreload = TRUE;
	pInputTemplate->SetInfer(m_infer, m_vroot);
	m_infer->SetBelief(pAPI);
	// set type troubleshooter type in template
	pInputTemplate->SetType(pszValue);
	m_infer->SetType(pszValue);
	int refedCmd, refedVal;
	BOOL bProbAsk = TRUE;
//	RSStack<CNode> InvertState;
	while (m_pQry->GetNext(refedCmd, refedVal)) 
	{
		dwCount++;	
		if (!m_infer->FSetNodeOfIdh(refedCmd, refedVal))
			dwStat = EV_GTS_ERROR_INF_NODE_SET;
	}
	// 
	if (0 == dwCount)
	{
		m_infer->SetProblemAsk();
		m_infer->ClearDoubleSkip();
	}
	else
	{
		m_infer->ClearProblemAsk();
	}

	if (!dwStat) {

		pInputTemplate->Print(dwCount, m_pCtxt);

		/*
		if (m_infer->IsService(m_pszheader))
		{
			strTxt.LoadString(IDS_I_OBJ_MOVED);
			_tcscpy(m_resptype, (LPCTSTR) strTxt);
		}
		*/
	}
	else {
		strTxt.LoadString(IDS_ER_SVR_BAD_DATA);
		*m_pCtxt += strTxt;
	}

	return dwStat;
}

//
//
void APGTSContext::DisplayFirstPage()
{
	DWORD i, apicount;
	CString strTxt;

	*m_pCtxt += _T("<html><head><title>");
	strTxt.LoadString(IDS_FP_TITLE);
	*m_pCtxt += strTxt;
	*m_pCtxt += _T("</title></head>\n");
	*m_pCtxt += _T("<body ");
	strTxt.LoadString(IDS_FP_BODY_ATTRIB);
	*m_pCtxt += strTxt;
	*m_pCtxt += _T(">\n<center><h1>");
	strTxt.LoadString(IDS_FP_HEADER);
	*m_pCtxt += strTxt;

	*m_pCtxt += VERSIONSTR;
		
	*m_pCtxt += _T("</h1></center>\n");

	*m_pCtxt = _T("<center>\n");

	apicount = m_pConf->GetFileCount(m_currcfg);

	if (!apicount) {
		strTxt.LoadString(IDS_ER_NO_API);
		*m_pCtxt += strTxt;
	}
	else {
		for (i=0;i<apicount;i++) {
			AfxFormatString1(strTxt, IDS_FORM_START, m_pConf->GetTagStr(m_currcfg, i));
			*m_pCtxt += strTxt;
			*m_pCtxt += _T("<INPUT TYPE=SUBMIT VALUE=\"");
			*m_pCtxt += m_pConf->GetTagStr(m_currcfg, i);
			*m_pCtxt += _T("\">\n");
			*m_pCtxt += _T("</FORM>\n");
		}
	}

	*m_pCtxt += _T("</center></body></html>\n");
}

// id compare in descending order
//
int idcomp(const void *elem1, const void *elem2)
{
	return(((EVAL_WORD_METRIC *)elem2)->dwVal - ((EVAL_WORD_METRIC *)elem1)->dwVal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\apgtsevt.h ===
//
// MODULE: APGTSEVT.MC
//
// PURPOSE: Event Logging Text Support File
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach(RM)
//			further work by Richard Meadows (RWM)
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.2		6/4/97		RWM		Local Version for Memphis
// V0.3		3/24/98		JM		Local Version for NT5
//
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: EV_GTS_PROCESS_START
//
// MessageText:
//
//  %1 %2 Starting Generic Troubleshooter %3
//
#define EV_GTS_PROCESS_START             ((DWORD)0x40000001L)

//
// MessageId: EV_GTS_PROCESS_STOP
//
// MessageText:
//
//  %1 %2 Stopping Generic Troubleshooter %3
//
#define EV_GTS_PROCESS_STOP              ((DWORD)0x40000002L)

//
// MessageId: EV_GTS_SERVER_BUSY
//
// MessageText:
//
//  %1 %2 Server has reached maximum queue size for requests
//
#define EV_GTS_SERVER_BUSY               ((DWORD)0x40000003L)

//
// MessageId: EV_GTS_USER_NO_STRING
//
// MessageText:
//
//  %1 %2 User did not enter parameters, Remote IP Address: %3
//
#define EV_GTS_USER_NO_STRING            ((DWORD)0x40000004L)

//
// MessageId: EV_GTS_DEP_FILES_UPDATED
//
// MessageText:
//
//  %1 %2 Reloaded Dependent Files %3 (%4)
//
#define EV_GTS_DEP_FILES_UPDATED         ((DWORD)0x40000005L)

//
// MessageId: EV_GTS_INDEP_FILES_UPDATED
//
// MessageText:
//
//  %1 %2 Reloaded Independent File %3 (%4)
//
#define EV_GTS_INDEP_FILES_UPDATED       ((DWORD)0x40000006L)

//
// MessageId: EV_GTS_ALL_FILES_UPDATED
//
// MessageText:
//
//  %1 %2 Reloaded ALL Files %3 (%4)
//
#define EV_GTS_ALL_FILES_UPDATED         ((DWORD)0x40000007L)

//
// MessageId: EV_GTS_SERVER_REG_CHG_MT
//
// MessageText:
//
//  %1 %2 Registry Parameter Change, Max Threads Changed, NOTE: Will not take effect until Web Server restarted. (From/To): %3
//
#define EV_GTS_SERVER_REG_CHG_MT         ((DWORD)0x40000008L)

//
// MessageId: EV_GTS_SERVER_REG_CHG_TPP
//
// MessageText:
//
//  %1 %2 Registry Parameter Change, Threads PP Changed, NOTE: Will not take effect until Web Server restarted. (From/To): %3
//
#define EV_GTS_SERVER_REG_CHG_TPP        ((DWORD)0x40000009L)

//
// MessageId: EV_GTS_SERVER_REG_CHG_MWQ
//
// MessageText:
//
//  %1 %2 Registry Parameter Change, Max Work Queue Items Changed (From/To): %3
//
#define EV_GTS_SERVER_REG_CHG_MWQ        ((DWORD)0x4000000AL)

//
// MessageId: EV_GTS_SERVER_REG_CHG_CET
//
// MessageText:
//
//  %1 %2 Registry Parameter Change, HTTP Cookie Expiration time Changed (From/To): %3
//
#define EV_GTS_SERVER_REG_CHG_CET        ((DWORD)0x4000000BL)

//
// MessageId: EV_GTS_INF_FIRSTACC
//
// MessageText:
//
//  %1 %2 User accessed the top level page, %3
//
#define EV_GTS_INF_FIRSTACC              ((DWORD)0x4000000CL)

//
// MessageId: EV_GTS_SERVER_REG_CHG_DIR
//
// MessageText:
//
//  %1 %2 Resource Directory Changed, %3
//
#define EV_GTS_SERVER_REG_CHG_DIR        ((DWORD)0x4000000DL)

//
// MessageId: EV_GTS_SERVER_REG_CHG_MWT
//
// MessageText:
//
//  %1 %2 Registry Parameter Change, Max Working Threads Changed (From/To): %3
//
#define EV_GTS_SERVER_REG_CHG_MWT        ((DWORD)0x4000000EL)

//
// MessageId: EV_GTS_CANT_PROC_REQ_MWTE
//
// MessageText:
//
//  %1 %2 Server has reached maximum thread count for requests, increase maximum working thread count
//
#define EV_GTS_CANT_PROC_REQ_MWTE        ((DWORD)0x4000000FL)

//
// MessageId: EV_GTS_SERVER_REG_CHG_VRP
//
// MessageText:
//
//  %1 %2 Registry Parameter Change, Vroot Changed, NOTE: Only used on first page. (From/To): %3
//
#define EV_GTS_SERVER_REG_CHG_VRP        ((DWORD)0x40000010L)

//
// MessageId: EV_GTS_SERVER_REG_CHG_RDT
//
// MessageText:
//
//  %1 %2 Registry Parameter Change, Reload Delay time Changed (From/To): %3
//
#define EV_GTS_SERVER_REG_CHG_RDT        ((DWORD)0x40000011L)

//
// MessageId: EV_GTS_USER_PAGE_MISSING
//
// MessageText:
//
//  %1 %2 Page missing in resource html file %3 %4
//
#define EV_GTS_USER_PAGE_MISSING         ((DWORD)0x800001F4L)

//
// MessageId: EV_GTS_USER_BAD_THRD_REQ
//
// MessageText:
//
//  %1 %2 Shutdown signal not processed by all threads
//
#define EV_GTS_USER_BAD_THRD_REQ         ((DWORD)0x800001F5L)

//
// MessageId: EV_GTS_USER_THRD_KILL
//
// MessageText:
//
//  %1 %2 At least one thread hard-terminated on signal timeout
//
#define EV_GTS_USER_THRD_KILL            ((DWORD)0x800001F6L)

//
// MessageId: EV_GTS_CANT_PROC_REQ_SS
//
// MessageText:
//
//  %1 %2 Can't process request, server shutting down
//
#define EV_GTS_CANT_PROC_REQ_SS          ((DWORD)0x800001F8L)

//
// MessageId: EV_GTS_USER_BAD_DATA
//
// MessageText:
//
//  %1 %2 Received non-html data, (Can be caused by reloading DLL with no data sent) Remote IP Address: %3
//
#define EV_GTS_USER_BAD_DATA             ((DWORD)0x800001F9L)

//
// MessageId: EV_GTS_ERROR_UNEXPECTED_WT
//
// MessageText:
//
//  %1 %2 An unexpected result occurred from waiting on semaphore: Result/GetLastError(): %3
//
#define EV_GTS_ERROR_UNEXPECTED_WT       ((DWORD)0x800001FAL)

//
// MessageId: EV_GTS_DEBUG
//
// MessageText:
//
//  %1 %2 %3 %4
//
#define EV_GTS_DEBUG                     ((DWORD)0x800003E7L)

//
// MessageId: EV_GTS_ERROR_EC
//
// MessageText:
//
//  %1 %2 Can't create extension object
//
#define EV_GTS_ERROR_EC                  ((DWORD)0xC00003E8L)

//
// MessageId: EV_GTS_ERROR_POOLQUEUE
//
// MessageText:
//
//  %1 %2 Can't create instance of pool queue object
//
#define EV_GTS_ERROR_POOLQUEUE           ((DWORD)0xC00003E9L)

//
// MessageId: EV_GTS_ERROR_INFENGINE
//
// MessageText:
//
//  %1 %2 Unable to create API, DX32 API object instance create failed %3
//
#define EV_GTS_ERROR_INFENGINE           ((DWORD)0xC00003EBL)

//
// MessageId: EV_GTS_ERROR_THREAD
//
// MessageText:
//
//  %1 %2 Can't create worker thread
//
#define EV_GTS_ERROR_THREAD              ((DWORD)0xC00003EDL)

//
// MessageId: EV_GTS_ERROR_TEMPLATE_CREATE
//
// MessageText:
//
//  %1 %2 Unable to create API, Input template object instance create failed %3
//
#define EV_GTS_ERROR_TEMPLATE_CREATE     ((DWORD)0xC00003EEL)

//
// MessageId: EV_GTS_ERROR_LOGS
//
// MessageText:
//
//  %1 %2 Can't create instance of log object
//
#define EV_GTS_ERROR_LOGS                ((DWORD)0xC00003EFL)

//
// MessageId: EV_GTS_ERROR_DIRNOTETHREAD
//
// MessageText:
//
//  %1 %2 Can't create directory notify thread
//
#define EV_GTS_ERROR_DIRNOTETHREAD       ((DWORD)0xC00003F0L)

//
// MessageId: EV_GTS_ERROR_MUTEX
//
// MessageText:
//
//  %1 %2 Can't create worker mutex
//
#define EV_GTS_ERROR_MUTEX               ((DWORD)0xC00003F2L)

//
// MessageId: EV_GTS_ERROR_WORK_ITEM
//
// MessageText:
//
//  %1 %2 Can't allocate memory for work queue item
//
#define EV_GTS_ERROR_WORK_ITEM           ((DWORD)0xC00003F3L)

//
// MessageId: EV_GTS_ERROR_CONFIG
//
// MessageText:
//
//  %1 %2 Can't create instance of configuration object
//
#define EV_GTS_ERROR_CONFIG              ((DWORD)0xC00003F4L)

//
// MessageId: EV_GTS_ERROR_NO_FILES
//
// MessageText:
//
//  %1 %2 Unable to create API, There are no files specified in the LST file %3
//
#define EV_GTS_ERROR_NO_FILES            ((DWORD)0xC00003F5L)

//
// MessageId: EV_GTS_ERROR_NO_THRD
//
// MessageText:
//
//  %1 %2 Internal Error: Thread Count is Zero
//
#define EV_GTS_ERROR_NO_THRD             ((DWORD)0xC00003F6L)

//
// MessageId: EV_GTS_ERROR_REG_NFT_CEVT
//
// MessageText:
//
//  %1 %2 Registry notification failed, Can't open key, Error: %3
//
#define EV_GTS_ERROR_REG_NFT_CEVT        ((DWORD)0xC00003F7L)

//
// MessageId: EV_GTS_ERROR_NO_QUEUE_ITEM
//
// MessageText:
//
//  %1 %2 Can't get queue item
//
#define EV_GTS_ERROR_NO_QUEUE_ITEM       ((DWORD)0xC00003F8L)

//
// MessageId: EV_GTS_ERROR_REG_NFT_OPKEY
//
// MessageText:
//
//  %1 %2 Registry notification failed, Can't open key to enable notification, Error: %3
//
#define EV_GTS_ERROR_REG_NFT_OPKEY       ((DWORD)0xC00003F9L)

//
// MessageId: EV_GTS_ERROR_REG_NFT_SETNTF
//
// MessageText:
//
//  %1 %2 Registry notification failed, Can't set notification on open key, Error: %3
//
#define EV_GTS_ERROR_REG_NFT_SETNTF      ((DWORD)0xC00003FAL)

//
// MessageId: EV_GTS_ERROR_WLIST_CREATE
//
// MessageText:
//
//  %1 %2 Can't create Word List object %3
//
#define EV_GTS_ERROR_WLIST_CREATE        ((DWORD)0xC00003FBL)

//
// MessageId: EV_GTS_ERROR_BESEARCH_CREATE
//
// MessageText:
//
//  %1 %2 Unable to create API, Backend search object instance create failed %3
//
#define EV_GTS_ERROR_BESEARCH_CREATE     ((DWORD)0xC00003FCL)

//
// MessageId: EV_GTS_ERROR_ITMPL_FILE
//
// MessageText:
//
//  %1 %2 Unable to create API, HTI Template File missing IF %3
//
#define EV_GTS_ERROR_ITMPL_FILE          ((DWORD)0xC000041AL)

//
// MessageId: EV_GTS_ERROR_ITMPL_MISTAG
//
// MessageText:
//
//  %1 %2 Unable to create API, HTI Template File missing TAG statement %3
//
#define EV_GTS_ERROR_ITMPL_MISTAG        ((DWORD)0xC000041BL)

//
// MessageId: EV_GTS_ERROR_ITMPL_BADSEEK
//
// MessageText:
//
//  %1 %2 Unable to create API, HTI Template File bad seek operation %3
//
#define EV_GTS_ERROR_ITMPL_BADSEEK       ((DWORD)0xC000041CL)

//
// MessageId: EV_GTS_ERROR_ITMPL_NOMEM
//
// MessageText:
//
//  %1 %2 Unable to create API, HTI Template File no memory for objects %3
//
#define EV_GTS_ERROR_ITMPL_NOMEM         ((DWORD)0xC000041FL)

//
// MessageId: EV_GTS_ERROR_ITMPL_IFMISTAG
//
// MessageText:
//
//  %1 %2 Unable to create API, HTI Template File missing IF tag %3
//
#define EV_GTS_ERROR_ITMPL_IFMISTAG      ((DWORD)0xC0000420L)

//
// MessageId: EV_GTS_ERROR_ITMPL_FORMISTAG
//
// MessageText:
//
//  %1 %2 Unable to create API, HTI Template File missing FOR tag %3
//
#define EV_GTS_ERROR_ITMPL_FORMISTAG     ((DWORD)0xC0000421L)

//
// MessageId: EV_GTS_ERROR_ITMPL_ENDMISTAG
//
// MessageText:
//
//  %1 %2 Unable to create API, HTI Template File missing END tag %3
//
#define EV_GTS_ERROR_ITMPL_ENDMISTAG     ((DWORD)0xC0000422L)

//
// MessageId: EV_GTS_ERROR_ITMPL_VARIABLE
//
// MessageText:
//
//  %1 %2 Unable to create API, HTI Template File missing display variable %3
//
#define EV_GTS_ERROR_ITMPL_VARIABLE      ((DWORD)0xC0000423L)

//
// MessageId: EV_GTS_ERROR_THREAD_TOKEN
//
// MessageText:
//
//  %1 %2 Can't open thread token
//
#define EV_GTS_ERROR_THREAD_TOKEN        ((DWORD)0xC000044CL)

//
// MessageId: EV_GTS_ERROR_NO_CONTEXT_OBJ
//
// MessageText:
//
//  %1 %2 Can't create context object
//
#define EV_GTS_ERROR_NO_CONTEXT_OBJ      ((DWORD)0xC000044DL)

//
// MessageId: EV_GTS_ERROR_IDX_FILE
//
// MessageText:
//
//  %1 %2 Unable to create API, Can't find/open HTM file %3
//
#define EV_GTS_ERROR_IDX_FILE            ((DWORD)0xC000047EL)

//
// MessageId: EV_GTS_ERROR_IDX_BUFMEM
//
// MessageText:
//
//  %1 %2 Unable to create API, Can't allocate space for HTM %3
//
#define EV_GTS_ERROR_IDX_BUFMEM          ((DWORD)0xC000047FL)

//
// MessageId: EV_GTS_ERROR_IDX_CORRUPT
//
// MessageText:
//
//  %1 %2 Unable to create API, Node number in HTM file is bad %3
//
#define EV_GTS_ERROR_IDX_CORRUPT         ((DWORD)0xC0000480L)

//
// MessageId: EV_GTS_ERROR_IDX_MISSING
//
// MessageText:
//
//  %1 %2 Unable to create API, Couldn't add node number from HTM file into list %3
//
#define EV_GTS_ERROR_IDX_MISSING         ((DWORD)0xC0000481L)

//
// MessageId: EV_GTS_ERROR_IDX_EXISTS
//
// MessageText:
//
//  %1 %2 Unable to create API, Internal error, node from HTM file already exists in list %3
//
#define EV_GTS_ERROR_IDX_EXISTS          ((DWORD)0xC0000482L)

//
// MessageId: EV_GTS_ERROR_IDX_NO_SEP
//
// MessageText:
//
//  %1 %2 Unable to create API, No initial separator in HTM file %3
//
#define EV_GTS_ERROR_IDX_NO_SEP          ((DWORD)0xC0000483L)

//
// MessageId: EV_GTS_ERROR_IDX_BAD_NUM
//
// MessageText:
//
//  %1 %2 Unable to create API, Bad initial node number in HTM file %3
//
#define EV_GTS_ERROR_IDX_BAD_NUM         ((DWORD)0xC0000484L)

//
// MessageId: EV_GTS_ERROR_IDX_NOT_PROB
//
// MessageText:
//
//  %1 %2 Unable to create API, Initial node number is not a problem list node in HTM file %3
//
#define EV_GTS_ERROR_IDX_NOT_PROB        ((DWORD)0xC0000485L)

//
// MessageId: EV_GTS_ERROR_IDX_BAD_PNUM
//
// MessageText:
//
//  %1 %2 Unable to create API, Bad problem number in problem list node in HTM file %3
//
#define EV_GTS_ERROR_IDX_BAD_PNUM        ((DWORD)0xC0000486L)

//
// MessageId: EV_GTS_ERROR_IDX_EXCEED_ARRAY
//
// MessageText:
//
//  %1 %2 Unable to create API, Exceeded maximum number of problem nodes for problem list in HTM file %3
//
#define EV_GTS_ERROR_IDX_EXCEED_ARRAY    ((DWORD)0xC0000487L)

//
// MessageId: EV_GTS_ERROR_IDX_READ_MODEL
//
// MessageText:
//
//  %1 %2 Unable to create API, API is unable to read model %3
//
#define EV_GTS_ERROR_IDX_READ_MODEL      ((DWORD)0xC0000488L)

//
// MessageId: EV_GTS_ERROR_IDX_ALLOC_LIST
//
// MessageText:
//
//  %1 %2 Unable to create API, API is unable to create list object (%3)
//
#define EV_GTS_ERROR_IDX_ALLOC_LIST      ((DWORD)0xC0000489L)

//
// MessageId: EV_GTS_ERROR_IDX_ALLOC_CACHE
//
// MessageText:
//
//  %1 %2 Unable to create API, API is unable to create cache object (%3)
//
#define EV_GTS_ERROR_IDX_ALLOC_CACHE     ((DWORD)0xC000048AL)

//
// MessageId: EV_GTS_ERROR_IDX_BAD_LIST_PTR
//
// MessageText:
//
//  %1 %2 Unable to create API, API received bad list pointer (%3)
//
#define EV_GTS_ERROR_IDX_BAD_LIST_PTR    ((DWORD)0xC000048BL)

//
// MessageId: EV_GTS_ERROR_NO_STRING
//
// MessageText:
//
//  %1 %2 Can't create string object, %3
//
#define EV_GTS_ERROR_NO_STRING           ((DWORD)0xC00004B0L)

//
// MessageId: EV_GTS_ERROR_NO_QUERY
//
// MessageText:
//
//  %1 %2 Can't create space for user query data, %3
//
#define EV_GTS_ERROR_NO_QUERY            ((DWORD)0xC00004B1L)

//
// MessageId: EV_GTS_ERROR_NO_CHAR
//
// MessageText:
//
//  %1 %2 Can't create query decoder object, %3
//
#define EV_GTS_ERROR_NO_CHAR             ((DWORD)0xC00004B2L)

//
// MessageId: EV_GTS_ERROR_NO_INFER
//
// MessageText:
//
//  %1 %2, Can't create inference object, %3
//
#define EV_GTS_ERROR_NO_INFER            ((DWORD)0xC00004B3L)

//
// MessageId: EV_GTS_ERROR_POOL_SEMA
//
// MessageText:
//
//  %1 %2 Can't create pool queue semaphore, %3
//
#define EV_GTS_ERROR_POOL_SEMA           ((DWORD)0xC00004E2L)

//
// MessageId: EV_GTS_ERROR_INF_BADPARAM
//
// MessageText:
//
//  %1 %2 User sent bad query string parameter, %3
//
#define EV_GTS_ERROR_INF_BADPARAM        ((DWORD)0xC0000514L)

//
// MessageId: EV_GTS_ERROR_INF_NODE_SET
//
// MessageText:
//
//  %1 %2 Can't Set Node, %3 Extended Error, (Inference Engine): %4
//
#define EV_GTS_ERROR_INF_NODE_SET        ((DWORD)0xC0000515L)

//
// MessageId: EV_GTS_ERROR_INF_NO_MEM
//
// MessageText:
//
//  %1 %2 Not enough memory for inference support objects, %3
//
#define EV_GTS_ERROR_INF_NO_MEM          ((DWORD)0xC0000516L)

//
// MessageId: EV_GTS_ERROR_INF_BADCMD
//
// MessageText:
//
//  %1 %2 User sent bad first command in query string, %3
//
#define EV_GTS_ERROR_INF_BADCMD          ((DWORD)0xC0000519L)

//
// MessageId: EV_GTS_ERROR_INF_BADTYPECMD
//
// MessageText:
//
//  %1 %2 User sent unknown type in query string, %3
//
#define EV_GTS_ERROR_INF_BADTYPECMD      ((DWORD)0xC000051AL)

//
// MessageId: EV_GTS_ERROR_LOG_FILE_MEM
//
// MessageText:
//
//  %1 %2 Can't create log file entry string object instance
//
#define EV_GTS_ERROR_LOG_FILE_MEM        ((DWORD)0xC0000546L)

//
// MessageId: EV_GTS_ERROR_LOG_FILE_OPEN
//
// MessageText:
//
//  %1 %2 Can't open log file for write/append
//
#define EV_GTS_ERROR_LOG_FILE_OPEN       ((DWORD)0xC0000547L)

//
// MessageId: EV_GTS_ERROR_WAIT_MULT_OBJ
//
// MessageText:
//
//  %1 %2 Error waiting for object, Return/GetLastError(): %3
//
#define EV_GTS_ERROR_WAIT_MULT_OBJ       ((DWORD)0xC0000578L)

//
// MessageId: EV_GTS_ERROR_WAIT_NEXT_NFT
//
// MessageText:
//
//  %1 %2 Error getting next file notification
//
#define EV_GTS_ERROR_WAIT_NEXT_NFT       ((DWORD)0xC0000579L)

//
// MessageId: EV_GTS_ERROR_DN_REL_MUTEX
//
// MessageText:
//
//  %1 %2 We don't own mutex, can't release
//
#define EV_GTS_ERROR_DN_REL_MUTEX        ((DWORD)0xC000057AL)

//
// MessageId: EV_GTS_ERROR_LST_FILE_MISSING
//
// MessageText:
//
//  %1 %2 Attempt to check LST file failed, it is not present in given directory %3
//
#define EV_GTS_ERROR_LST_FILE_MISSING    ((DWORD)0xC000057BL)

//
// MessageId: EV_GTS_ERROR_CANT_GET_RES_PATH
//
// MessageText:
//
//  %1 %2 Can't expand environment string for resource path
//
#define EV_GTS_ERROR_CANT_GET_RES_PATH   ((DWORD)0xC000057CL)

//
// MessageId: EV_GTS_ERROR_CANT_OPEN_SFT_1
//
// MessageText:
//
//  %1 %2 Can't open troubleshooter key
//
#define EV_GTS_ERROR_CANT_OPEN_SFT_1     ((DWORD)0xC000057DL)

//
// MessageId: EV_GTS_ERROR_CANT_OPEN_SFT_2
//
// MessageText:
//
//  %1 %2 Can't open generic troubleshooter key
//
#define EV_GTS_ERROR_CANT_OPEN_SFT_2     ((DWORD)0xC000057EL)

//
// MessageId: EV_GTS_ERROR_CANT_OPEN_SFT_3
//
// MessageText:
//
//  %1 %2 Can't query resource directory: Error = %3
//
#define EV_GTS_ERROR_CANT_OPEN_SFT_3     ((DWORD)0xC000057FL)

//
// MessageId: EV_GTS_ERROR_LST_FILE_OPEN
//
// MessageText:
//
//  %1 %2 Attempt to open LST file for reading failed: %3
//
#define EV_GTS_ERROR_LST_FILE_OPEN       ((DWORD)0xC0000580L)

//
// MessageId: EV_GTS_ERROR_CFG_OOMEM
//
// MessageText:
//
//  %1 %2 Fatal Error, can't allocate memory for config structure section %3
//
#define EV_GTS_ERROR_CFG_OOMEM           ((DWORD)0xC0000581L)

//
// MessageId: EV_GTS_ERROR_DIR_OOMEM
//
// MessageText:
//
//  %1 %2 Fatal Error, can't allocate memory for directory structure
//
#define EV_GTS_ERROR_DIR_OOMEM           ((DWORD)0xC0000582L)

//
// MessageId: EV_GTS_ERROR_LST_DIR_OOMEM
//
// MessageText:
//
//  %1 %2 Can't reallocate memory for list file %3 directory entries
//
#define EV_GTS_ERROR_LST_DIR_OOMEM       ((DWORD)0xC0000583L)

//
// MessageId: EV_GTS_ERROR_LST_CFG_OOMEM
//
// MessageText:
//
//  %1 %2 Can't reallocate memory for list file %3 config entries %4
//
#define EV_GTS_ERROR_LST_CFG_OOMEM       ((DWORD)0xC0000584L)

//
// MessageId: EV_GTS_ERROR_CANT_FILE_NOTIFY
//
// MessageText:
//
//  %1 %2 Can't perform file notification on directory, directory may not exist %3 (%4)
//
#define EV_GTS_ERROR_CANT_FILE_NOTIFY    ((DWORD)0xC0000585L)

//
// MessageId: EV_GTS_ERROR_BES_ALLOC_STR
//
// MessageText:
//
//  %1 %2 Can't allocate memory for backend search string objects %3 %4
//
#define EV_GTS_ERROR_BES_ALLOC_STR       ((DWORD)0xC00005DCL)

//
// MessageId: EV_GTS_ERROR_BES_GET_FSZ
//
// MessageText:
//
//  %1 %2 Can't get file size for backend search file %3 %4
//
#define EV_GTS_ERROR_BES_GET_FSZ         ((DWORD)0xC00005DDL)

//
// MessageId: EV_GTS_ERROR_BES_ALLOC_FILE
//
// MessageText:
//
//  %1 %2 Can't allocate memory for backend search file read %3 %4
//
#define EV_GTS_ERROR_BES_ALLOC_FILE      ((DWORD)0xC00005DEL)

//
// MessageId: EV_GTS_ERROR_BES_FILE_READ
//
// MessageText:
//
//  %1 %2 Can't read backend search file %3 %4
//
#define EV_GTS_ERROR_BES_FILE_READ       ((DWORD)0xC00005DFL)

//
// MessageId: EV_GTS_ERROR_BES_FILE_OPEN
//
// MessageText:
//
//  %1 %2 Can't open or find backend search file %3 %4
//
#define EV_GTS_ERROR_BES_FILE_OPEN       ((DWORD)0xC00005E0L)

//
// MessageId: EV_GTS_ERROR_BES_NO_STR
//
// MessageText:
//
//  %1 %2 Backend search file is empty (no content) %3 %4
//
#define EV_GTS_ERROR_BES_NO_STR          ((DWORD)0xC00005E1L)

//
// MessageId: EV_GTS_ERROR_BES_MISS_FORM
//
// MessageText:
//
//  %1 %2 Backend search file does not have FORM tag (make sure tag is all caps in file): <FORM %3 %4
//
#define EV_GTS_ERROR_BES_MISS_FORM       ((DWORD)0xC00005E2L)

//
// MessageId: EV_GTS_ERROR_BES_MISS_ACTION
//
// MessageText:
//
//  %1 %2 Backend search file does not have ACTION tag (make sure tag is all caps in file): ACTION=" %3 %4
//
#define EV_GTS_ERROR_BES_MISS_ACTION     ((DWORD)0xC00005E3L)

//
// MessageId: EV_GTS_ERROR_BES_MISS_AEND_Q
//
// MessageText:
//
//  %1 %2 Backend search file does not have end quote for ACTION tag  %3 %4
//
#define EV_GTS_ERROR_BES_MISS_AEND_Q     ((DWORD)0xC00005E4L)

//
// MessageId: EV_GTS_ERROR_BES_CLS_TAG
//
// MessageText:
//
//  %1 %2 Backend search file has tag that doesn't close with '>' %3 %4
//
#define EV_GTS_ERROR_BES_CLS_TAG         ((DWORD)0xC00005E5L)

//
// MessageId: EV_GTS_ERROR_BES_MISS_TYPE_TAG
//
// MessageText:
//
//  %1 %2 Backend search file does not have TYPE tag (make sure tag is all caps in file): TYPE= %3 %4
//
#define EV_GTS_ERROR_BES_MISS_TYPE_TAG   ((DWORD)0xC00005E6L)

//
// MessageId: EV_GTS_ERROR_BES_MISS_CT_TAG
//
// MessageText:
//
//  %1 %2 Backend search file is missing close tag '>' for TYPE tag %3 %4
//
#define EV_GTS_ERROR_BES_MISS_CT_TAG     ((DWORD)0xC00005E7L)

//
// MessageId: EV_GTS_ERROR_BES_MISS_CN_TAG
//
// MessageText:
//
//  %1 %2 Backend search file is missing close tag '>' for NAME tag %3 %4
//
#define EV_GTS_ERROR_BES_MISS_CN_TAG     ((DWORD)0xC00005E8L)

//
// MessageId: EV_GTS_ERROR_BES_MISS_CV_TAG
//
// MessageText:
//
//  %1 %2 Backend search file is missing close tag '>' for VALUE tag %3 %4
//
#define EV_GTS_ERROR_BES_MISS_CV_TAG     ((DWORD)0xC00005E9L)

//
// MessageId: EV_GTS_ERROR_CAC_ALLOC_MEM
//
// MessageText:
//
//  %1 %2 Can't allocate space for cache item internal structure
//
#define EV_GTS_ERROR_CAC_ALLOC_MEM       ((DWORD)0xC000060EL)

//
// MessageId: EV_GTS_ERROR_CAC_ALLOC_ITEM
//
// MessageText:
//
//  %1 %2 Cache can't allocate space for cache item
//
#define EV_GTS_ERROR_CAC_ALLOC_ITEM      ((DWORD)0xC000060FL)

//
// MessageId: EV_GTS_ERROR_WL_ALLOC_LIST
//
// MessageText:
//
//  %1 %2 Word list can't create list object
//
#define EV_GTS_ERROR_WL_ALLOC_LIST       ((DWORD)0xC0000640L)

//
// MessageId: EV_GTS_ERROR_WL_ALLOC_ADD_LI
//
// MessageText:
//
//  %1 %2 Word list can't allocate space for additional list item
//
#define EV_GTS_ERROR_WL_ALLOC_ADD_LI     ((DWORD)0xC0000641L)

//
// MessageId: EV_GTS_ERROR_WL_ALLOC_TOK
//
// MessageText:
//
//  %1 %2 Word list can't allocate space for token string
//
#define EV_GTS_ERROR_WL_ALLOC_TOK        ((DWORD)0xC0000642L)

//
// MessageId: EV_GTS_ERROR_NL_ALLOC_LIST
//
// MessageText:
//
//  %1 %2 Node list can't create list object
//
#define EV_GTS_ERROR_NL_ALLOC_LIST       ((DWORD)0xC0000672L)

//
// MessageId: EV_GTS_ERROR_NL_ALLOC_ADD_LI
//
// MessageText:
//
//  %1 %2 Node list can't allocate space for additional list item
//
#define EV_GTS_ERROR_NL_ALLOC_ADD_LI     ((DWORD)0xC0000673L)

//
// MessageId: EV_GTS_ERROR_NL_ALLOC_WL
//
// MessageText:
//
//  %1 %2 Node list can't create word list object
//
#define EV_GTS_ERROR_NL_ALLOC_WL         ((DWORD)0xC0000674L)

//
// MessageId: EV_GTS_ERROR_LIST_ALLOC
//
// MessageText:
//
//  %1 %2 List can't allocate space for items
//
#define EV_GTS_ERROR_LIST_ALLOC          ((DWORD)0xC00006A4L)

//
// MessageId: EV_GTS_ERROR_LIST_SZ
//
// MessageText:
//
//  %1 %2 List new size too big
//
#define EV_GTS_ERROR_LIST_SZ             ((DWORD)0xC00006A5L)

//
// MessageId: EV_GTS_ERROR_LIST_REALLOC
//
// MessageText:
//
//  %1 %2 List can't reallocate space for items
//
#define EV_GTS_ERROR_LIST_REALLOC        ((DWORD)0xC00006A6L)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\apgtsdtg.cpp ===
//
// MODULE: APGTSDTG.CPP
//
// PURPOSE: Wrapper for inference api
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
//
// ORIGINAL DATE: 8-2-96
//
// NOTES:
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.2		6/4/97		RWM		Local Version for Memphis
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//

//#include "windows.h"
#include "stdafx.h"

#include "time.h"

#include "apgts.h"
#include "ErrorEnums.h"
#include "bnts.h"
#include "BackupInfo.h"
#include "cachegen.h"
#include "apgtsinf.h"
#include "apgtscmd.h"
#include "apgtshtx.h"
#include "apgtscls.h"

#include <string.h>
#include <memory.h>

#include "CabUnCompress.h"
#include "crc.h"
#include "sniff.h"
#include "chmread.h"

BCache::BCache(TCHAR *binfile, TCHAR *tagstr, TCHAR *szResourcePath, const CString& strFile)
	  :	GTSAPI(binfile, tagstr, szResourcePath),
		CSniffedNodeContainer(),
		m_NodeState(30),
		m_strFile(strFile)
{
	SetBNTS(this);
		
	m_bNeedModel = TRUE;	// TRUE -> Need to read the model before querying the bnts library.
	m_bModelRead = FALSE;
	m_bDeleteModelFile = FALSE;
	m_strModelFile = _T("");

	m_CurNode = 0;

	m_pHttpQuery = NULL;

	m_strResult = _T("");

	m_NodeState.InitHashTable(47);

	m_bReverse = false;

	m_bRunWithKnownProblem = false;

	return;
}

BCache::~BCache()
{
	m_NodeState.RemoveAll();
	if (m_bDeleteModelFile)
	{
		DeleteFile((LPCTSTR) m_strModelFile);
		m_bDeleteModelFile = FALSE;
	}
	return;
}

//
//
GTSAPI::GTSAPI(TCHAR *binfile, TCHAR *tagstr, TCHAR *szResourcePath) :
m_CacheGen(TRUE, NULL, NULL)
{
//	InitializeCriticalSection( &m_csAPI );

	m_cnid = 0;
	m_dwErr = 0;
	m_pchHtml = NULL;
	m_currid = 0;
	m_pCache = NULL;

	_tcscpy(m_binfile,binfile);// full path
	_tcscpy(m_tagstr,tagstr);
	_tcscpy(m_szResourcePath,szResourcePath);
}

//
//
GTSAPI::~GTSAPI()
{
	Destroy();
}

void WideToMB(const WCHAR *szIn, CHAR *szOut)
{
	VERIFY(WideCharToMultiByte(CP_ACP,
						NULL,
						szIn,
						-1,
						szOut,
						MAXBUF,
						NULL, NULL));
	return;
}
#ifdef _UNICODE
// Temporary BNTS wrappers for unicode build with non unicode bnts.dll
BOOL GTSAPI::BMultiByteReadModel(LPCTSTR szcFn, LPCSTR szFnError)
{
	CHAR szFn[MAXBUF];
	WideToMB(szcFn, szFn);
	return BNTS::BReadModel(szFn, szFnError);
}

BOOL GTSAPI::BMultiByteNodePropItemStr(LPCTSTR szcPropType, int index)
{
	CHAR szPropType[MAXBUF];
	WideToMB(szcPropType, szPropType);
	return BNTS::BNodePropItemStr(szPropType, index);
}

BOOL GTSAPI::BMultiByteNetPropItemStr(LPCTSTR szcPropType, int index)
{
	CHAR szPropType[MAXBUF];
	WideToMB(szcPropType, szPropType);
	return BNTS::BNetPropItemStr(szPropType, index);
}

const WCHAR * GTSAPI::SzcMultiByteResult()
{
	int len = strlen(BNTS::SzcResult());
	int size = MultiByteToWideChar(CP_ACP,
						NULL,						
						BNTS::SzcResult(),
						len,
						NULL,
						0);
	MultiByteToWideChar(CP_ACP,
						NULL,
						BNTS::SzcResult(),
						len + 1,
						m_strResult.GetBufferSetLength(size),
						size);
	m_strResult.ReleaseBuffer();
	return (LPCTSTR) m_strResult;
}

int GTSAPI::IMultiByteNode(LPCTSTR szSymName)
{
	CHAR szMBSymName[MAXBUF];
	WideToMB(szSymName, szMBSymName);
	return BNTS::INode(szMBSymName);
}

#endif // _UNICODE

void BCache::ReadTheDscModel(int From)
{
	if (m_bNeedModel)
	{
			if (!BReadModel((LPCTSTR) m_strModelFile
		#ifdef _DEBUG
				, "BNTSError.log"
		#endif
				))
				ReportError((DLSTATTYPES) From);
		// Add the nodes that are already instantiated.
		if (m_pHttpQuery)
			m_pHttpQuery->AddNodes(this);
		m_bNeedModel = FALSE;

		if (m_bDeleteModelFile)
		{
			DeleteFile((LPCTSTR) m_strModelFile);
			m_bDeleteModelFile = FALSE;
		}
	}
}

VOID BCache::AddToCache(CString &strCacheFile, const CString& strCacheFileWithinCHM)
{
	if (m_CacheGen.ReadCacheFileHeader(strCacheFile, strCacheFileWithinCHM))
	{
		BOOL bErr;
		ASSERT(m_pCache);
		while (m_CacheGen.GetNextCacheEntryFromFile(bErr, m_pCache))
			;
		if (bErr)
		{
			delete m_pCache;
			m_pCache = new CBNCache();
			TRACE(_T("Errors occured while reading the cache file.\n"));
			ReadTheDscModel(TSERR_ENGINE_BNTS_READ_NCAB);
		}
	}
	return;
}

DWORD BCache::ReadModel()
{
	BOOL bDelete = FALSE;

	// this should be fixed eventually to not require a string compare
	// but maybe a flag check that gets passed in
	CString sFilename = m_binfile;
	CString strCacheFile;
	CString strCacheFileWithinCHM;

	if (m_strFile.GetLength())
	{
		// form Cache file path here assuming it is NOT in chm file
		strCacheFile = m_binfile;
		strCacheFileWithinCHM = m_strFile.Left(m_strFile.GetLength() - 4);
		strCacheFileWithinCHM += SZ_CACHE_NAME;
	}
	else
	{
		strCacheFile = sFilename.Left(sFilename.GetLength() - 4);
		strCacheFile += SZ_CACHE_NAME;
	}
	
	if (m_strFile.GetLength() || !sFilename.Right(4).CompareNoCase(DSC_COMPRESSED))
	{
		CCabUnCompress cab;
		CString strDirBuf;		
		if (!GetTempPath( MAX_PATH , strDirBuf.GetBufferSetLength(MAX_PATH + 1)))
		{
			strDirBuf.ReleaseBuffer();
			strDirBuf = m_szResourcePath;
		}
		else
		{
			strDirBuf.ReleaseBuffer();
		}
		if (!cab.ExtractCab(sFilename, strDirBuf, m_strFile))
		{
			if (NOT_A_CAB == cab.m_nError)
			{	// The file may be uncompressed already.
				bDelete = FALSE;
			}
			else
			{
				ReportError(TSERR_ENGINE_EXTRACT);
			}
		}
		else
		{	// Normal cab file expanded successfully.
			sFilename = strDirBuf;
			sFilename += cab.GetLastFile();
			DWORD dwAttribs = GetFileAttributes((LPCTSTR) sFilename);
			dwAttribs = dwAttribs & ~FILE_ATTRIBUTE_READONLY;
			SetFileAttributes((LPCTSTR) sFilename, dwAttribs);
			bDelete = TRUE;
		}
	}
/*
	if (!BReadModel(sFilename
#ifdef _DEBUG
		, "BNTSError.log"
#endif
		))
		ReportError(TSERR_ENGINE);
*/
	m_strModelFile = sFilename;
	m_bDeleteModelFile = bDelete;
	// Compare the crc value in the cache file with the crc of the dsc file.
	// If they match, fill the cache.	
	CCRC crc;
	try
	{
		if (crc.Decode(sFilename, strCacheFile, strCacheFileWithinCHM))	
			AddToCache(strCacheFile, strCacheFileWithinCHM);
		else
			ReadTheDscModel(TSERR_ENGINE_BNTS_READ_CACH);
	}
	catch(CGenException *p)
	{
		delete p;
		ReadTheDscModel(TSERR_ENGINE_BNTS_READ_GEN);
	}

//	if (bDelete)
//		DeleteFile(sFilename);


	m_probask = idhFirst + CNode();
	m_bModelRead = TRUE;
	return m_dwErr;
}

// Number of nodes whose states were set at program startup by TSLaunchServ.
UINT BCache::StatesFromServ()
{
	return m_pHttpQuery ? m_pHttpQuery->StatesFromServ() : 0;
}

// Number of nodes whose states are now set
UINT BCache::StatesNowSet()
{
	return (UINT)m_NodeState.GetCount();
}

//
//
DWORD BCache::Initialize(/*CWordList *pWXList*/)
{

	if (NULL != m_pCache)
		delete m_pCache;
	m_pCache = new CBNCache();
	if (!m_pCache)
		m_dwErr = EV_GTS_ERROR_IDX_ALLOC_CACHE;

	ResetNodes();

	if (!BValidNet())
		ReadModel();
	return m_dwErr;
}


// override the default function
//
// look for possible returns in the header file
//
int BCache::GTSGetRecommendations(CNID& cnid, NID rgnid[], bool bSniffed)
{
	BN_CACHE_ITEM SetupItem;
	SetupItem.uNodeCount = m_cnid;
	SetupItem.uName = m_rgnid;
	SetupItem.uValue = m_rgist;
	int state = SNIFF_INVALID_STATE;
	int label = SNIFF_INVALID_NODE_LABEL;

//AfxDebugBreak();

	// set initial non-sniffed value in array of sniffed states
	if (!bSniffed && !IsReverse())
		m_rgsniff[m_cnid-1] = 0;

	// flush array of sniffed nodes recently traversed
	if (!bSniffed)
		m_arrNidLastSniffed.RemoveAll();
	
	if (m_pCache->FindCacheItem(&SetupItem, cnid, rgnid))
	{
		if (GetState(*rgnid, &state))  // sniffer has this information and can answer what state this node has
		{
			if (NodeSet(*rgnid, state, false)) // set sniffed node current and set its state
			{
				SetAdditionalDataOnNodeSet(*rgnid);
				return GTSGetRecommendations(cnid, rgnid, true); // recursive call - hope BNTS will not recommend a node which is set
			}
		}
		else
		{
			return RECOMMEND_SUCCESS;
		}
	}
	
	if (m_bNeedModel)
	{
		ReadTheDscModel(TSERR_ENGINE_BNTS_REC);
	}

	if (BGetRecommendations())
	{	
		cnid = CInt();
		if (cnid > 0)
		{
			const int *pInt = RgInt();
			memcpy(rgnid, pInt, cnid * sizeof(pInt[0]));
				
			SetupItem.uNodeCount = m_cnid;
			SetupItem.uName = m_rgnid;
			SetupItem.uValue = m_rgist;			
			SetupItem.uRecCount = cnid;
			SetupItem.uRec = rgnid;			

			m_pCache->AddCacheItem(&SetupItem);			
			
			if (GetState(*rgnid, &state))  // sniffer has this information and can answer what state this node has
			{
				if (NodeSet(*rgnid, state, false)) // set sniffed node current and set its state
				{
					SetAdditionalDataOnNodeSet(*rgnid);
					return GTSGetRecommendations(cnid, rgnid, true); // recursive call - hope BNTS will not recommend a node which is set
				}
			}
			return RECOMMEND_SUCCESS;
		}
		else
		{
			rgnid[0] = nidService;
			cnid = 1;
			return RECOMMEND_NO_MORE_DATA;
		}
	}
	else
	{
		// the last node was sniffed and its state was set
		// after that we received FALSE from BGetRecommendation;
		// we unset this node (in order to be able to use BGetRecommendation later on);
		// we return value indicating that BNTS cannot give us any recommendations
		NodeSet(m_rgnid[m_cnid-1], -1, false);
		return RECOMMEND_NO_MORE_DATA;
	}

	return RECOMMEND_FAIL;
}

void BCache::SetAdditionalDataOnNodeSet(NID nid)
{
	m_rgsniff[m_cnid-1] = 1;
	m_arrNidLastSniffed.Add(nid);
}

BOOL InArray(UINT num, UINT aNums[], UINT max)
{
	UINT x = max;
	BOOL bRes = FALSE;
	for (UINT y = 0; y < x; y++)
	{
		if (aNums[y] == num)
		{
			bRes = TRUE;
			break;
		}
	}
	return bRes;
}

// RemoveRecommendations is called for nodes whos' state is less than 100.
void BCache::RemoveRecommendation(int Nid)
{
	VERIFY(BNodeSetCurrent(Nid));
	BNodeSet(-1, false);
	if (m_cnid)
		m_cnid--;
	return;
}

//
//
UINT GTSAPI::GetNodeList(NID **pNid, IST **pIst)
{
	*pNid = m_rgnid;
	*pIst = m_rgist;
	return m_cnid;
}

BOOL GTSAPI::BNodeSetCurrent(int node)
{
	return BNTS::BNodeSetCurrent(node);
}

//
//
BOOL BCache::NodeSet(NID nid, IST ist, bool bPrevious)
{
	BOOL bRes = FALSE;

	// shouldn't happen...but to be safe
	if (m_cnid >= MAX_NID)
		return FALSE;

	m_rgnid[m_cnid] = nid;
	m_rgist[m_cnid] = ist;

	if (false == bPrevious)
	{
		VERIFY(BNodeSetCurrent(nid));
		bRes = BNodeSet(ist, false);
		if (bRes &&	// bnts worked successfully
			-1 == GetIndexNodeInCache(nid) // this nid is not present in the cache
		   )
			m_cnid++;
	}
	else
	{
		bRes = TRUE;
	}
	return bRes;
}

//
//
int BCache::GetIndexNodeInCache(NID nid)
{
	for (unsigned int i = 0; i < m_cnid; i++)
		if (m_rgnid[i] == nid)
			return i;
	return -1;
}

//
//
VOID BCache::ResetNodes()
{
	for (UINT inid = 0; inid < m_cnid; inid++)
	{
		VERIFY(BNodeSetCurrent(m_rgnid[inid]));
		BNodeSet(-1, false);	// Nil value
	}
	m_cnid = 0;
}		

//
//
DWORD GTSAPI::GetStatus()
{
	return m_dwErr;
}

//
//
VOID GTSAPI::Destroy()
{
	if (m_pchHtml) {
		delete [] m_pchHtml;
		m_pchHtml = NULL;
	}

	/*
	if (m_pWNList) {
		
		if (!m_dwErr)
			m_dwErr = m_pWNList->GetStatus();
		
		delete m_pWNList;
		m_pWNList = NULL;
	}
	*/
	if (m_pCache) {
		if (!m_dwErr)
			m_dwErr = m_pCache->GetStatus();
		delete m_pCache;
		m_pCache = NULL;
	}
}

//
//
UINT GTSAPI::GetProblemArray(IDH **idh)
{
	*idh = m_idstore;
	return m_currid;
}

//
//
IDH GTSAPI::GetProblemAsk()
{
	return m_probask;
}

void GTSAPI::AddValue(int value)
{
	ASSERT(m_currid < MAXPROBID);
	m_idstore[m_currid++] = value;
	return;
}

BOOL BCache::CheckNode(int Node)
{
	BOOL bCached = m_CacheGen.IsNodePresent(Node);
	if (!bCached && m_bNeedModel)
	{
		ReadTheDscModel(TSERR_ENGINE_BNTS_CHECK);
	}	
	return bCached;
}

//-------------------------------------------------------------
// BNTS Overrides to replace the dsc file with our cache.
// Need to override everything but BReadModel and BGetRecommendations.

int BCache::CNode()
{
	int cNodes;
	if (FALSE == m_bNeedModel)
		cNodes = GTSAPI::CNode();
	else
		cNodes = m_CacheGen.GetNodeCount();
	return cNodes;
}

BOOL BCache::BImpossible()
{
	BOOL bImpossible = FALSE;
	if (FALSE == m_bNeedModel)
		bImpossible = GTSAPI::BImpossible();
	return bImpossible;
}

BOOL BCache::BNetPropItemStr(LPCTSTR szPropType, int index)
{
	BOOL bGoodIndex = FALSE;
	char sznPropType[MAX_SYM_NAME_BUF_LEN];
	int nPropLen = MAX_SYM_NAME_BUF_LEN;
	if (!GTSCacheGenerator::TcharToChar(sznPropType, szPropType, nPropLen))
		return FALSE;
	if (CheckNode(m_CurNode))
	{
		bGoodIndex = m_CacheGen.FindNetworkProperty(sznPropType, m_strResult, index);
		if (!bGoodIndex && !m_bNeedModel)
		{
			bGoodIndex = GTSAPI::BNetPropItemStr(szPropType, index);
			m_strResult = GTSAPI::SzcResult();
		}
	}
	else
	{
		bGoodIndex = GTSAPI::BNetPropItemStr(szPropType, index);
		m_strResult = GTSAPI::SzcResult();
	}
	return bGoodIndex;
}

BOOL BCache::BNodeSetCurrent(int node)
{
	BOOL bNodeSet = TRUE;
	if (CheckNode(node) && TRUE == m_bNeedModel)
	{
		m_CurNode = node;
	}
	else
	{
		bNodeSet = GTSAPI::BNodeSetCurrent(node);
		m_CurNode = node;
	}
	return bNodeSet;
}

int BCache::INode(LPCTSTR szNodeSymName)
{
	UINT index = 0;
	if (FALSE == m_bNeedModel)
		index = GTSAPI::INode(szNodeSymName);
	else
		if (!m_CacheGen.GetNodeIDFromSymName(szNodeSymName, index))
		{	// Have to have BNTS load the network and the the symbolic name.
			ReadTheDscModel(TSERR_ENGINE_CACHE_LOW);
			index = GTSAPI::INode(szNodeSymName);
		}
	return (signed int) index;
}

ESTDLBL BCache::ELblNode()
{
	UINT NodeLable;
	ESTDLBL Lable;
	if (FALSE == m_bNeedModel)
	{
		Lable = GTSAPI::ELblNode();
	}
	else
	{
		VERIFY(m_CacheGen.GetLabelOfNode(m_CurNode, NodeLable));
		Lable = (ESTDLBL) NodeLable;
	}
	return Lable;
}

int BCache::INodeCst()
{
	int cStates = 2;

	return cStates;
}

BOOL GTSAPI::BNodeSet(int state, bool bset)
{
	return BNTS::BNodeSet(state, bset);
}

BOOL BCache::BNodeSet(int istate, bool bSet)
{
	BOOL bNodeWasSet = TRUE;
	if (FALSE == m_bNeedModel)
		bNodeWasSet = GTSAPI::BNodeSet(istate, bSet);
	if (bNodeWasSet)
	{
		if (-1 != istate)
			m_NodeState.SetAt(m_CurNode, istate);
		else
			m_NodeState.RemoveKey(m_CurNode);
	}
	return bNodeWasSet;
}

int BCache::INodeState()
{	// This is ok.  See BNodeSet.
	int state;
	if (!m_NodeState.Lookup(m_CurNode, state))
		state = 0;
	return state;
}

void BCache::NodeStateName(int istate)
{
	if (FALSE == m_bNeedModel)
	{
		GTSAPI::NodeStateName(istate);
		m_strResult = GTSAPI::SzcResult();
	}
	else
	{
		BOOL bFound;
		switch(istate)
		{
		case 0:
			bFound = m_CacheGen.FindNodeProperty(m_CurNode, G_S0_NAME, m_strResult, 0);
			break;
		case 1:
			bFound = m_CacheGen.FindNodeProperty(m_CurNode, G_S1_NAME, m_strResult, 0);
			break;
		default:
			bFound = FALSE;
		}
		if (!bFound)
		{
			ASSERT(FALSE);
			m_strResult = _T("");
		}
	}
	return;
}

void BCache::NodeSymName()
{
	if (FALSE == m_bNeedModel)
	{
		GTSAPI::NodeSymName();
		m_strResult = GTSAPI::SzcResult();
	}
	else if (CheckNode(m_CurNode))
	{
		VERIFY(m_CacheGen.FindNodeProperty(m_CurNode, G_SYMBOLIC_NAME, m_strResult, 0));
	}
	return;
}

void BCache::NodeFullName()
{
	if (FALSE == m_bNeedModel)
	{
		GTSAPI::NodeFullName();
		m_strResult = GTSAPI::SzcResult();
	}
	else
	{
		VERIFY(m_CacheGen.FindNodeProperty(m_CurNode, G_FULL_NAME, m_strResult, 0));
	}
	return;
}

BOOL BCache::BNodePropItemStr(LPCTSTR szPropType, int index)
{
	BOOL bGoodIndex = FALSE;
	char sznPropType[MAX_SYM_NAME_BUF_LEN];
	int nPropTypeLen = MAX_SYM_NAME_BUF_LEN;
	if (!GTSCacheGenerator::TcharToChar(sznPropType, szPropType, nPropTypeLen))
		return FALSE;
	if (FALSE == m_bNeedModel)
	{
		bGoodIndex = GTSAPI::BNodePropItemStr(szPropType, index);
		m_strResult = GTSAPI::SzcResult();
	}
	else
	{
		bGoodIndex = m_CacheGen.FindNodeProperty(m_CurNode, sznPropType, m_strResult, index);
	}
	return bGoodIndex;
}

bool BCache::BValidNet()
{
	bool bValidNet;
	if (FALSE == m_bModelRead)	// Set to true in BCache::ReadModel.
		bValidNet = false;		// Causes the readmodel function to be called.
	else if (FALSE == m_bNeedModel)
		bValidNet = GTSAPI::BValidNet();
	else
		bValidNet = true;
	return bValidNet;
}

LPCTSTR BCache::SzcResult() const
{
	return (LPCTSTR) m_strResult;
}

const CArray<int, int>& BCache::GetArrLastSniffed()
{
	return m_arrNidLastSniffed;
}

int BCache::GetCountRecommendedNodes()
{
	return m_cnid;
}

int BCache::GetCountSniffedRecommendedNodes()
{
	for (unsigned int i = 0, j = 0; i < m_cnid; i++)
		if (m_rgsniff[i] == 1)
			j++;
	return j;
}

bool BCache::IsReverse()
{
	return m_bReverse;
}

void BCache::SetReverse(bool reverse)
{
	m_bReverse = reverse;
}

void BCache::SetRunWithKnownProblem(bool yes)
{
	m_bRunWithKnownProblem = yes;
}

bool BCache::IsRunWithKnownProblem()
{
	return m_bRunWithKnownProblem;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\apgtsfst.cpp ===
//
// MODULE:  APGTSFST.H
//
// PURPOSE:  Creates a list of available trouble shooters.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 6/4/96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//

#include "stdafx.h"
#include "TSHOOT.h"

#include "ErrorEnums.h"

#include "apgts.h"
#include "ErrorEnums.h"
#include "BasicException.h"
#include "apgtsfst.h"
#include "ErrorEnums.h"
#include "bnts.h"
#include "BackupInfo.h"
#include "cachegen.h"
#include "apgtsinf.h"
#include "apgtscmd.h"
#include "apgtshtx.h"

#include "apgtscls.h"

CFirstPage::CFirstPage()
{
	m_strFpResourcePath = _T("");
	m_bKeyOpen = FALSE;
	m_hKey = NULL;
	return;
}

CFirstPage::~CFirstPage()
{
	if (m_bKeyOpen)
		RegCloseKey(m_hKey);
	return;
}

void CFirstPage::OpenRegKeys()
{
	DWORD dwSize;
	DWORD dwType;
	long lErr;
	DWORD dwDisposition = 0;
	CString strRegKey;
	CString strBuf1;
	strRegKey.Format(_T("%s\\%s"), TSREGKEY_MAIN, REGSZ_TSTYPES);
	m_hKey = NULL;
	m_bKeyOpen = FALSE;
	// Find the resource directory.
	if (RegCreateKeyEx(	HKEY_LOCAL_MACHINE, 
						TSREGKEY_MAIN,
						0, 
						TS_REG_CLASS, 
						REG_OPTION_NON_VOLATILE, 
						KEY_READ | KEY_WRITE,
						NULL, 
						&m_hKey, 
						&dwDisposition) == ERROR_SUCCESS) 
	{
		m_bKeyOpen = TRUE;
		if (dwDisposition == REG_OPENED_EXISTING_KEY) 
		{
			dwSize = MAXBUF - 1;
			dwType = REG_SZ;
			
			if ((lErr = RegQueryValueEx(m_hKey,
								FULLRESOURCE_STR,
								0,
								&dwType,
								(LPBYTE) m_strFpResourcePath.GetBufferSetLength(MAXBUF),
								&dwSize)) == ERROR_SUCCESS)
			{
				int len;
				m_strFpResourcePath.ReleaseBuffer();
				if (0 < (len = m_strFpResourcePath.GetLength()))
				{
					if (m_strFpResourcePath.GetAt(len - 1) != _T('\\'))
						m_strFpResourcePath += _T('\\');
				}
				else
				{
					strBuf1.Format(_T("%ld"),lErr);
					ReportWFEvent(	_T("[apgtscfg]"), //Module Name
									_T("[GetResourceDirFromReg]"), //event
									(TCHAR*)(LPCTSTR) strBuf1,
									_T(""),
									EV_GTS_ERROR_CANT_OPEN_SFT_3 );
					CFirstPageException *pExc = new CFirstPageException;
					pExc->m_strError.LoadString(IDS_I_NO_TS1);
					throw pExc;
				}
			}
			else
			{
				strBuf1.Format(_T("%ld"),lErr);
				ReportWFEvent(	_T("[apgtscfg]"), //Module Name
								_T("[GetResourceDirFromReg]"), //event
								(TCHAR*)(LPCTSTR) strBuf1,
								_T(""),
								EV_GTS_ERROR_CANT_OPEN_SFT_3 );
				CFirstPageException *pExc = new CFirstPageException;
				pExc->m_strError.LoadString(IDS_I_NO_TS1);
				throw pExc;
			}
		}
		else
		{	// Created new key.  Don't have any resources.
			strBuf1.Format(_T("%ld"),ERROR_REGISTRY_IO_FAILED);
			ReportWFEvent(	_T("[apgtscfg]"), //Module Name
							_T("[GetResourceDirFromReg]"), //event
							(TCHAR*)(LPCTSTR) strBuf1,
							_T(""),
							EV_GTS_ERROR_CANT_GET_RES_PATH);
			CFirstPageException *pExc = new CFirstPageException;
			pExc->m_strError.LoadString(IDS_I_NO_TS1);
			throw pExc;
		}
	}
	else
	{
		ReportWFEvent(	_T("[apgtscfg]"), //Module Name
						_T("[GetResourceDirFromReg]"), //event
						_T(""),
						_T(""),
						EV_GTS_ERROR_CANT_OPEN_SFT_2 ); 
		CFirstPageException *pExc = new CFirstPageException;
		pExc->m_strError.LoadString(IDS_I_NO_TS1);
		throw pExc;
	}
	m_bKeyOpen = FALSE;
	// Open the key to the trouble shooter list.
	if (RegCreateKeyEx(	HKEY_LOCAL_MACHINE, 
						(LPCTSTR) strRegKey, 
						0, 
						TS_REG_CLASS, 
						REG_OPTION_NON_VOLATILE, 
						KEY_READ | KEY_WRITE,
						NULL, 
						&m_hKey, 
						&dwDisposition) == ERROR_SUCCESS) 
	{
		m_bKeyOpen = TRUE;
		if (dwDisposition == REG_OPENED_EXISTING_KEY) 
		{
		}
		else
		{	// Created new key.  Don't have any resources.
			strBuf1.Format(_T("%ld"),ERROR_REGISTRY_IO_FAILED);
			ReportWFEvent(	_T("[apgtscfg]"), //Module Name
							_T("[GetResourceDirFromReg]"), //event
							(TCHAR*)(LPCTSTR) strBuf1,
							_T(""),
							EV_GTS_ERROR_CANT_GET_RES_PATH);
			CFirstPageException *pExc = new CFirstPageException;
			pExc->m_strError.LoadString(IDS_I_NO_TS1);
			throw pExc;
		}
	}
	else
	{
		ReportWFEvent(	_T("[apgtscfg]"), //Module Name
						_T("[GetResourceDirFromReg]"), //event
						_T(""),
						_T(""),
						EV_GTS_ERROR_CANT_OPEN_SFT_2 ); 
		CFirstPageException *pExc = new CFirstPageException;
		pExc->m_strError.LoadString(IDS_I_NO_TS1);
		throw pExc;
	}
	return;
}

void CFirstPage::CloseRegKeys()
{
	RegCloseKey(m_hKey);
	m_hKey = NULL;
	return;
}

void CFirstPage::RenderFirst(CString &strOut, CString &strTShooter)
{
	CString strTemplate;
	OpenRegKeys();
	strOut = _T("");
	CInfer Infer(&strOut);
	strTemplate.Format(_T("%s%s.hti"), (LPCTSTR) m_strFpResourcePath, (LPCTSTR) strTShooter);
	CHTMLInputTemplate inputTemplate((LPCTSTR) strTemplate);
	Infer.LoadTShooters(m_hKey);
	CloseRegKeys();
	inputTemplate.Initialize(_T(""), _T(""));
	inputTemplate.SetType(_T("Unknown"));
	inputTemplate.SetInfer(&Infer, _T(""));
	inputTemplate.Print(1, &strOut);
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\apgtshdt.cpp ===
//
// MODULE: APGTSHDT.CPP
//
// PURPOSE: Methods for the various commands (classes). Commands are
//			Resposable for executing themseleves.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.15	8/15/96		VM		New htx format
// V0.2		6/4/97		RWM		Local Version for Memphis
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//
#include "stdafx.h"
//#include <windows.h>

#include <stdio.h> 
#include <stdlib.h>
#include <string.h>  
#include <stdarg.h>
#include <search.h>
#include <dos.h>
#include <ctype.h>
#include <limits.h>
#include <time.h>

#include "apgts.h"
#include "bnts.h"
#include "BackupInfo.h"
#include "cachegen.h"
#include "apgtsinf.h"
#include "apgtscmd.h"
#include "apgtshtx.h"

#include "ErrorEnums.h"

#include "chmread.h"
//
//
HTXCommand::HTXCommand(UINT type, const TCHAR *idstr)
{
	m_beforehtmlstr = NULL;
	m_afterhtmlstr = NULL;
	m_beforesize = 0;
	m_aftersize = 0;
	m_start = 0;
	m_end = 0;
	m_type = type;
	m_idstr = idstr;
	m_error = FALSE;
	m_next = NULL;
}

//
//
HTXCommand::~HTXCommand()
{
	if (m_beforehtmlstr != NULL) 
		free(m_beforehtmlstr);

	if (m_afterhtmlstr != NULL) 
		free(m_afterhtmlstr);	
}

//
//
void HTXCommand::SetStart(UINT pos)
{
	m_start = pos;
}

//
//
void HTXCommand::SetEnd(UINT pos)
{
	m_end = pos;
}

//
//
UINT HTXCommand::GetStart()
{
	return (m_start);
}

//
//
UINT HTXCommand::GetEnd()
{
	return (m_end);
}

//
//
UINT HTXCommand::GetType()
{
	return (m_type);
}

//
//
UINT HTXCommand::GetStatus()
{
	return (m_error);
}

//
//
const TCHAR *HTXCommand::GetIDStr()
{
	return (m_idstr);
}

//
//
UINT HTXCommand::GetBeforeLen()
{
	return (m_beforelen);
}

//
//
UINT HTXCommand::GetAfterLen()
{
	return (m_afterlen);
}

//
//
TCHAR *HTXCommand::GetBeforeStr()
{
	return (m_beforehtmlstr);
}

//
//
TCHAR *HTXCommand::GetAfterStr()
{
	return (m_afterhtmlstr);
}

//
//
UINT HTXCommand::ReadBeforeStr(UINT start, UINT end, LPCTSTR startstr)
{
	m_beforesize = (UINT) (end - start);
	
	ASSERT (m_beforesize >= 0);
	
	m_beforehtmlstr = (TCHAR *)malloc((m_beforesize + 1) * sizeof (TCHAR));
	if (m_beforehtmlstr == NULL) 
		return (m_error = TRUE);
	// copy data
	memcpy(m_beforehtmlstr, &startstr[start], m_beforesize * sizeof (TCHAR));

	m_beforehtmlstr[m_beforesize] = _T('\0');
	m_beforelen = _tcslen(m_beforehtmlstr);
	return (FALSE);
}

//
//
UINT HTXCommand::ReadAfterStr(UINT start, UINT end, LPCTSTR startstr)
{
	m_aftersize = (UINT) (end - start);
	
	ASSERT (m_aftersize >= 0);

	m_afterhtmlstr = (TCHAR *)malloc((m_aftersize + 1) * sizeof (TCHAR));
	if (m_afterhtmlstr == NULL) 
		return (m_error = TRUE);
	// copy data
	memcpy(m_afterhtmlstr, &startstr[start], m_aftersize * sizeof (TCHAR));

	m_afterhtmlstr[m_aftersize] = _T('\0');
	m_afterlen = _tcslen(m_afterhtmlstr);
	return (FALSE);
}

//
//
HTXCommand *HTXCommand::Execute(CString *cstr, CInfer *infer)
{
	*cstr += GetAfterStr();
	return( this);
}

HTXCommand *HTXCommand::GetNext()
{
	return(m_next);
}

void HTXCommand::SetNext(HTXCommand *next)
{
	m_next = next;
}


HTXIfCommand::HTXIfCommand(UINT type, TCHAR *idstr, UINT variable): HTXCommand(type, idstr)
{
	m_else = NULL;
	m_endif = NULL;
	m_var_index = variable;
}

HTXIfCommand::~HTXIfCommand()
{
	
}
//
// PURPOSE:		Will execute the 'if' command. When done it will return a pointer
//				to the 'endif' command.
//
HTXCommand *HTXIfCommand::Execute(CString *cstr, CInfer *infer)
{
	HTXCommand *cur_com;

	if ( infer->EvalData(m_var_index ) != NULL) {
		*cstr += GetAfterStr();
		//execute if commands
		cur_com = this->GetNext();
		while (cur_com->GetType() != HTX_TYPEELSE && 
			   cur_com->GetType() != HTX_TYPEENDIF) {
			cur_com = cur_com->Execute(cstr, infer);
			cur_com = cur_com->GetNext();
		}
	} else {
		if ((cur_com = this->GetElse()) != NULL) {
			while (cur_com->GetType() != HTX_TYPEENDIF) {
				cur_com = cur_com->Execute(cstr, infer);
				cur_com = cur_com->GetNext();
			}	
		}
	}
	cur_com = this->GetEndIf();
	cur_com->Execute(cstr, infer);
	return(cur_com);
}

HTXCommand *HTXCommand::GetElse()
{
	return(NULL);
}
HTXCommand *HTXCommand::GetEndIf()
{
	return(NULL);

}
HTXCommand *HTXCommand::GetEndFor()
{
	return(NULL);

}
void HTXCommand::SetElse(HTXCommand *elseif)
{
}

void HTXCommand::SetEndIf(HTXCommand *endifif)
{
}
void HTXCommand::SetEndFor(HTXCommand *endfor)
{
}
void HTXCommand::GetResource(CString &strResPath, const CString& strCHM)
{
}
//
//
HTXCommand *HTXIfCommand::GetEndIf()
{
	return(m_endif);
}

//
//
void HTXIfCommand::SetEndIf(HTXCommand *endif)
{
	m_endif = endif;
}

//
//
HTXCommand *HTXIfCommand::GetElse()
{
	return(m_else);
}

//
//
void HTXIfCommand::SetElse(HTXCommand *elseif)
{
	m_else = elseif;
}

HTXForCommand::HTXForCommand(UINT type, TCHAR *idstr, UINT variable): HTXCommand(type, idstr)
{
	m_endfor = NULL;
	m_var_index = variable;
}

HTXForCommand::~HTXForCommand()
{
}

//
// PURPOSE:		Executes the 'forany' command. when done it
//				will retrurn a pointer to the 'endfor' command.
//
HTXCommand *HTXForCommand::Execute(CString *cstr, CInfer *infer)
{
	HTXCommand *cur_com;
	
	if (!(infer->InitVar(m_var_index)) ){
		this->GetEndFor()->Execute(cstr,infer);
		return(this->GetEndFor());
	}

	cur_com = this;
	do  {
		*cstr += cur_com->GetAfterStr();
		cur_com = cur_com->GetNext();
		while (cur_com->GetType() != HTX_TYPEENDFOR) {
			cur_com = cur_com->Execute(cstr, infer);
			cur_com = cur_com->GetNext();
		}
		cur_com = this;
	} while (infer->NextVar(m_var_index));
	cur_com = this->GetEndFor();
	cur_com->Execute(cstr,infer);
	return(cur_com);
}

//
//
HTXCommand *HTXForCommand::GetEndFor()
{
	return(m_endfor);
}

//
//
void HTXForCommand::SetEndFor(HTXCommand *endfor)
{
	m_endfor = endfor;
}

HTXDisplayCommand::HTXDisplayCommand(UINT type, TCHAR *idstr, UINT variable): HTXCommand(type, idstr)
{
	m_var_index = variable;
}

HTXDisplayCommand::~HTXDisplayCommand()
{

}

HTXCommand *HTXDisplayCommand::Execute(CString *cstr, CInfer *infer)
{	
	TCHAR *pstr;

	if ((pstr=infer->EvalData(m_var_index))!= NULL)
		*cstr += pstr;
	*cstr += GetAfterStr();
	return(this);
}

HTXResourceCommand::HTXResourceCommand(UINT type, TCHAR *idstr)
: HTXCommand(type, idstr)
{
	m_strResource = _T("");
	m_strFileName = _T("");
	return;
}

HTXResourceCommand::~HTXResourceCommand()
{
	return;
}

void HTXResourceCommand::GetResName(LPCTSTR var_name)
{
	m_strFileName = &var_name[1];
	// Remove the > from the end.
	TCHAR EndChar[2];
	EndChar[0] = m_strFileName.GetAt(m_strFileName.GetLength() - 1);
	EndChar[1] = NULL;
	if (0 == _tcsncmp(_T(">") , EndChar, 1))
	{
		m_strFileName.GetBufferSetLength(m_strFileName.GetLength() - 1);
		m_strFileName.ReleaseBuffer();
	}
	return;
}

// strCHM contains CHM file name. Must be empty if resource file is not inside CHM.
void HTXResourceCommand::GetResource(CString& strResPath, const CString& strCHM)
{
	CString strFile;

	if (strCHM.GetLength())
	{
		char* tmp_buf =NULL;
		ULONG Bytes =0;

		strFile = strResPath + strCHM;
		// m_filename is CHM file path and name
		// and strFile - file name within CHM
		if (S_OK != ::ReadChmFile(strFile, m_strFileName, (void**)&tmp_buf, &Bytes))
		{
			// ERROR READING CHM
			return;
		}
		tmp_buf[Bytes] = NULL;
		m_strResource = tmp_buf;
	}
	else
	{
		FILE *pFile;
		CHAR szBuf[4097];
		size_t Bytes =0;

		strFile = strResPath + m_strFileName;
		if (NULL == (pFile = _tfopen((LPCTSTR) strFile, _T("rb"))))
			ReportError(TSERR_RES_MISSING);
		do
		{
			if((Bytes = fread(szBuf, 1, 4096, pFile)) > 0)
			{
				szBuf[Bytes] = NULL;
				m_strResource += szBuf;
			}
		} while (Bytes == 4096);
		if (!feof(pFile))
		{
			fclose(pFile);
			ReportError(TSERR_RES_MISSING);
		}
		fclose(pFile);
	}
	return;
}

HTXCommand *HTXResourceCommand::Execute(CString *cstr, CInfer *)
{	
	// Read the resource file into cstr.
	*cstr += m_strResource;
	*cstr += GetAfterStr();
	return(this);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\apgtshtx.h ===
//
// MODULE: APGTSHTX.H
//
// PURPOSE: HTX File Support header
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
//			further work by Roman Mach (RM), Richard Meadows (RWM), Joe Mabel, Oleg Kalosha
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.2		8/15/96		VM		New htx format
// V0.3		6/4/97		RWM		Local Version for Memphis
// V0.4		3/24/98		JM		Local Version for NT5
//


#define HTX_FILENAME		_T("gtstemp.hti")

#define HTX_MAXSTORE		4096

#define HTX_COMMAND_START	_T("<!GTS")
#define HTX_COMMAND_END		_T(">")
#define HTX_IFSTR			_T("if")
#define HTX_ELSESTR			_T("else")
#define HTX_ENDIFSTR		_T("endif")
#define HTX_FORANYSTR		_T("forany")
#define HTX_ENDFORSTR		_T("endfor")
#define HTX_DISPLAYSTR		_T("display")
#define HTX_RESOURCESTR		_T("resource")	// For adding include files from the resource directory.


// these are types detected
#define HTX_TYPEBEGIN		0		// apparently never used (12/97)
#define HTX_TYPEINSERT		1		// apparently never used (12/97)
#define HTX_TYPEREPEAT		2		// apparently never used (12/97)
#define HTX_TYPEEND			3		// apparently never used (12/97)

#define HTX_TYPEIF			4
#define HTX_TYPEELSE		5
#define HTX_TYPEENDIF		6
#define HTX_TYPEFORANY		7
#define HTX_TYPEENDFOR		8
#define HTX_TYPEDISPLAY		9
#define HTX_TYPESTART		10
#define HTX_TYPERESOURCE	11
// 
#define HTX_OFFSETMAX		10

#define DATA_PROBLEM_ASK		_T("$ProblemAsk")
#define DATA_RECOMMENDATIONS	_T("$Recommendations")
#define DATA_STATE				_T("$States")
#define DATA_QUESTIONS			_T("$Questions")
#define DATA_BACK				_T("$Back")
#define DATA_TROUBLE_SHOOTERS	_T("$TroubleShooters")		// Used to display the list of available trouble shooters.

// >>> code would be easier to follow if these related constants had a common prefix.
#define PROBLEM_ASK_INDEX		1
#define RECOMMENDATIONS_INDEX	2
#define STATE_INDEX				3
#define QUESTIONS_INDEX			4
#define BACK_INDEX				5
#define TROUBLE_SHOOTER_INDEX	6
#define RESOURCE_INDEX			7


// Gets data from htx file and builds html sections in memory
// This is only called once in dllmain
//
class CHTMLInputTemplate
{
public:
	CHTMLInputTemplate(const TCHAR *);
	~CHTMLInputTemplate();

	DWORD Reload();

	UINT GetCount();
	UINT GetStatus();
	Print(UINT nargs, CString *cstr);
	VOID SetInfer(CInfer *infer, TCHAR *vroot);
	HTXCommand *GetFirstCommand();
	void SetType(LPCTSTR type);
	void DumpContentsToStdout();
	DWORD Initialize(LPCTSTR szResPath, CString strFile);

protected:
	void ScanFile();
	UINT BuildInMem();
	UINT CheckVariable(TCHAR *var_name);
	VOID Destroy();
	HTXCommand *Pop();
	Push(HTXCommand *command);
	bool IsFileName(TCHAR *name);

protected:
	CString m_strResPath;	// path to HTI (CHM) file
	CString m_strFile;	    // filename of HTI file if m_filename is pointing to CHM file
	int m_cHeaderItems;		// (JM 10/25/97 not sure of this but looks like:) 
							// number of resource files we've copied into memory
							// & which we dump into the header of HTML file
	DWORD m_dwErr;

	TCHAR *m_startstr;		// pointer to the text of the whole HTI file
	TCHAR *m_chopstr;		// used only during initialization of this object.  Initially, 
							//	a copy of the whole HTI file, which gets chopped apart as we 
							//	look for various commands.
	DWORD m_dwSize;			// size of HTI file (so we know how big an array it needs in memory)

	HTXCommand *m_cur_command;	// as we build a singly linked list of commands (representing
								// a parse of the HTI file) this points
								// to the latest command added at the tail of the list.
	HTXCommand *m_command_start;	// points to first command in linked list of commands.
									// this basically corresponds to the first thing in the
									// HTI file.
	TCHAR m_filename[256];			// (path)name of HTI (or CHM) file
	// These next 2 members are for a stack which really ought to be an object 
	//	in its own right
	HTXCommand *m_command_stack[10];	// a stack to keep track of things like an
										// "if" waiting for an "else"/"endif" or a "for"
										// waiting for an "endfor"
	UINT m_cur_stack_count;				// top-of-stack index
	CInfer *m_infer;				// access to inference object so we can drive use of 
									//	inference object by this particular template.
	UINT m_problemAsk;				// apparently unused 10/97
	TCHAR m_tstype[30];				// This is the symbolic name XXX of the troubleshooter.
									//  In the FORM in the resulting HTML this is used
									//  in the context:
									// <INPUT TYPE=HIDDEN NAME="type" VALUE=XXX>
	TCHAR m_vroot[MAXBUF];			// >>> ??
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\apgtsfst.h ===
//
// MODULE:  APGTSFST.H
//
// PURPOSE:  Creates a list of available trouble shooters.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 6/4/96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		3/24/98		JM		Local Version for NT5
//

#ifndef __APGTSFST_H_
#define __APGTSFST_H_ 1

class CFirstPageException : public CBasicException
{
public:
	CFirstPageException(){m_strError=_T("");};
	~CFirstPageException(){};

	CString m_strError;
};

class CFirstPage
{
public:
	CFirstPage();
	~CFirstPage();

	void RenderFirst(CString &strOut, CString &strTS);

	CString m_strFpResourcePath;

protected:

	HKEY m_hKey;	// The key to the list of trouble shooters.
	BOOL m_bKeyOpen;

	void OpenRegKeys();
	void CloseRegKeys();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\apgtsinf.cpp ===
//
// MODULE: APGTSINF.CPP
//
// PURPOSE: Inference Engine Interface
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
// Modified By: Richard Meadows
//
// ORIGINAL DATE: 8-2-96
// Modified Date: 6-3-97
//
// NOTES:
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.2		6/4/97		RWM		Local Version for Memphis
// V0.3		04/09/98	JM/OK+	Local Version for NT5

//#include "windows.h"
#include "stdafx.h"
#include "time.h"

#include "apgts.h"
#include "ErrorEnums.h"
#include "bnts.h"
#include "BackupInfo.h"
#include "cachegen.h"
#include "apgtsinf.h"
#include "apgtscmd.h"
#include "apgtshtx.h"

#include "apgtscls.h"

#include "TSHOOT.h"

//-----------------
//

#define CelemArray(rgtype)		(sizeof(rgtype) / sizeof(rgtype[0]))

CInfer::CInfer(	CString *pCtxt)
{
	m_bHttp = FALSE;
	m_pCtxt = pCtxt;
	m_bService = FALSE;
	m_nidPreloadCheck = 0;

	m_pResult = new CString();
	m_pCtmp = new CString();
	m_pSearchStr = new CString();

	m_ilineStat    = 0;
	m_cnidSkip     = 0;
	m_fDone        = FALSE;
	m_ishowService = 0;
	m_idhQuestion  = 0;

//	m_cnid = CelemArray(m_rgnid);
	
	m_problemAsk = FALSE;
	m_problem[0] = '\0';

	m_cShooters = 0;
	m_iShooter = 0;
	m_aShooters.RemoveAll();
	m_SkippedTwice.InitHashTable(7);

	m_api = NULL;
}

//
//m_bFirstShooter
CInfer::~CInfer()
{
	if (m_pResult)
		delete m_pResult;	
	if (m_pCtmp)
		delete m_pCtmp;	
	if (m_pSearchStr)
		delete m_pSearchStr;
	m_SkippedTwice.RemoveAll();
}

//
//
DWORD CInfer::Initialize(/*CSearchForm *pBESearch*/)
{
//	m_pBESearch = pBESearch;
	CString strTxt;	
	if (m_pResult == NULL)
		return (EV_GTS_ERROR_INF_NO_MEM);
	m_max_rec = 0;
	return (0);
}

//
//
VOID CInfer::SetBelief(BCache *pAPI)
{
	m_api = pAPI;
//	m_api->ResetNodes();

	// save count of nodes
	m_acnid = m_api->CNode();

	// reset preload check
	m_nidPreloadCheck = 0;
}

//
//
/*
EC CInfer::GetExtendedError()
{
	return m_uInfErr;
}
*/

//
//
VOID	CInfer::AssertFailed(TSZC szcFile, UINT iline, TSZC szcCond, BOOL fFatal)
{
	CString strTxt;
	strTxt.LoadString(IDS_ER_ASSERT_FAILED);
	PrintString(_T("%s(%u): %s %s\n"), szcFile, iline, (LPCTSTR) strTxt, szcCond);
	//exit(1);
}

//
//
void CInfer::SetProblemAsk()
{
	m_problemAsk = TRUE;
}

//
//
void CInfer::ClearProblemAsk()
{
	m_problemAsk = FALSE;
}

/*
 * METHOD:	EvalData
 *
 * PURPOSE:	This is used by the template execution unit when it needs to evaluate
 *			a variable within a template. Variables are usually evaluated by a
 *			<! display ' tag. Returns a string with the text of the variable
 *			evaluated
 *
 */
TCHAR *CInfer::EvalData(UINT var_index)
{
	BOOL bSkipped;
	int val;
	*m_pCtmp = _T("");
//AfxDebugBreak();
	switch (var_index) {
	case PROBLEM_ASK_INDEX:
		if (m_problemAsk)  // we want to show first set of questions
			return(NULL);
		else
			return(m_problem);
		break;	
	case RECOMMENDATIONS_INDEX:
		FxGetNode(m_rgnid[m_cur_rec],FALSE, m_pCtmp);
		break;
	case STATE_INDEX:
		FxGetState(m_pCtmp);
		break;	
	case QUESTIONS_INDEX:
		{	
			UINT inid;

			if ( GetForcedRecommendation() != SNIFF_INVALID_NODE_ID )
			{
				// we already have a recommendation from a sniffer
				GetIdhPage(GetForcedRecommendation() + idhFirst, m_pCtmp);
			}
			else
			{
				if (m_problemAsk) // show first page (radio-button list of possible problems)
				{
					GetIdhProblemPage(m_api->GetProblemAsk(), m_pCtmp);
				}
				else
				{
					int RecommendRes = Finish(m_pCtmp);
					if ( RECOMMEND_SUCCESS == RecommendRes ) // Normal
					{	// The first node is the most likely.
						// Skip 102 nodes.
						for (inid=0; inid< m_cnid; inid++)
						{
							if (!(bSkipped = FSkip(m_question_rgnid[inid])) || (m_ishowService != 0))
							{
								// Do not show skipped nodes more that once.
								// Will end up in a endless loop.
								if (!m_SkippedTwice.Lookup(m_question_rgnid[inid], val))
								{
									if (bSkipped)							
										m_SkippedTwice.SetAt(m_question_rgnid[inid], 1);
									if (!m_api->IsReverse()) // we're moving forward
									{
										//
										// Check if this node is sniffed
										//
										int state = SNIFF_INVALID_STATE;
										int nid = m_question_rgnid[inid];
										if (m_api->GetState(nid, &state))  // node that we're about to display turbed out to be sniffed
										{
											if (m_api->NodeSet(nid, state, false)) // set sniffed node current and set its state
											{
												m_api->SetAdditionalDataOnNodeSet(nid);

												RecommendRes = m_api->GTSGetRecommendations(m_cnid, m_question_rgnid, true);
												if ( RECOMMEND_SUCCESS == RecommendRes )
												{
													// re-execute loop again
													inid = 0;
													continue;
												}
												else
												{
													goto NO_SUCCESS;
												}
											}
										}
										//
									}
									GetIdhPage(m_question_rgnid[inid]+ idhFirst ,m_pCtmp);
									return(m_pCtmp->GetBuffer(m_pCtmp->GetLength()));
								}
							}
						}
						if (m_cnidSkip != 0)
						{
							/*
							// Going to show the skipped nodes message only one time.
							// Otherwise, they will get stuck on the skipped nodes message page.
							if (m_cnidSkip > (unsigned) m_SkippedTwice.GetCount())
								GetSkippedNodesMsg(_T("Skipped Node"), m_pCtmp);
							else
								GetIdhPage(nidService + idhFirst, m_pCtmp);
							*/
							// Leave them in a better loop.
							m_SkippedTwice.RemoveAll();
							GetSkippedNodesMsg(_T("Skipped Node"), m_pCtmp);
						}
						else
						{
							GetIdhPage(nidService + idhFirst, m_pCtmp);
						}
					}
NO_SUCCESS:
					// recommendation error handling
					//
					if (RECOMMEND_IMPOSSIBLE == RecommendRes)
						GetImpossibleNodesMsg(_T("Impossible"), m_pCtmp);

					if (RECOMMEND_NO_MORE_DATA == RecommendRes)
						GetIdhPage(IDH_FAIL, m_pCtmp);
				}
			}
		}
		break;
	case TROUBLE_SHOOTER_INDEX:
		GetTS(m_pCtmp);
		break;
	default:
		return(_T(""));
	}
	return(m_pCtmp->GetBuffer(m_pCtmp->GetLength()));

}
/*
	GetTS is used when all of the registered trouble shooters are displayed.
*/
void CInfer::GetTS(CString *pCtmp)
{
	TShooter tShooter;
	tShooter = m_aShooters.GetAt(m_iShooter);
	if (m_iShooter < m_cShooters)
		AfxFormatString2(*pCtmp, IDS_FPA_TS_BUTTON, tShooter.m_szName,
							tShooter.m_szDisplayName);
	else
		*pCtmp = _T("");
	m_iShooter++;
}

/*
* METHOD:	InitVar
 *
 * PURPOSE:	This is called to initialize a variable in the template. It
 *			is mainly called by a 'forany' command.
 *
 * RETURNS		- flag indicating if variable is initialized
 *
 */
BOOL CInfer::InitVar(UINT var_index)
{
	switch( var_index) {
	case PROBLEM_ASK_INDEX:
		break;
	case RECOMMENDATIONS_INDEX:			
		m_cur_rec = 0;
		if (m_max_rec == m_cur_rec)
			return FALSE;
		break;
	case STATE_INDEX:
		FxInitState(m_rgnid[m_cur_rec]);
		break;	
	case QUESTIONS_INDEX:
		return m_api->GTSGetRecommendations(m_cnid,m_question_rgnid);
		break;
	case BACK_INDEX:
		return FALSE;
	case TROUBLE_SHOOTER_INDEX:
		m_iShooter = 0;
		return TRUE;
		break;

	default:
		return FALSE;
	}
	return TRUE;
}
/*
* METHOD:	NextVar
 *
 * PURPOSE:	Used by the 'forany' command to increment to the next variable in a
 *			variable list. Returns FALSE when their are no more variable
 *
 *
 */
BOOL CInfer::NextVar(UINT var_index)
{
	switch (var_index) {
	case PROBLEM_ASK_INDEX:
		return FALSE;

	case RECOMMENDATIONS_INDEX:
		m_cur_rec++;
		if (m_cur_rec < m_max_rec)
			return TRUE;
		else
			return FALSE;
		
		break;

	case STATE_INDEX:
		m_cur_ist++;	
		if (m_cur_ist <= m_cur_cst)
			return TRUE;
		else{
			return FALSE;
		}
		break;

	case QUESTIONS_INDEX:
		return FALSE; // only one set

	case BACK_INDEX:
		return FALSE;

	case TROUBLE_SHOOTER_INDEX:
		if (m_cShooters > m_iShooter)
			return TRUE;
		else
			return FALSE;
	default:
		return FALSE;
	}
	return TRUE;
}

/*
* METHOD:	FxGetNode
 *
 * PURPOSE:	This is used to get the '$Recommendation'. A Recommendation is
 *			basically the name of the node in a belief network.
 *
 */
BOOL CInfer::FxGetNode(NID nid, BOOL fStatus, CString *cstr) const
{
	BOOL bRet;
	CString strTemp;
	bRet = m_api->BNodeSetCurrent(nid);
	if (bRet)	
	{
		m_api->NodeFullName();
		strTemp = m_api->SzcResult();
		*cstr += strTemp;
	}
	return bRet;
}

/*
* METHOD:	FxGetState
 *
 * PURPOSE:	This will print out the label of the state of a node. This label
 *			corresponds to the possible choices of that node. NOTE: This
 *			routine requires that an InitState be called sometime before to
 *			setup some variables.
 *
 */
void CInfer::FxGetState(CString *cstr)
{
	CString strTemp;
	if (m_cur_ist > m_cur_cst)
		return;
	if (FSkip(m_rgnid[m_cur_rec]) ) // a 102 was selected
		m_cur_state_set = m_cur_cst;
	if (m_cur_ist == m_cur_cst)
	{
		WriteResult(m_rgnid[m_cur_rec] +idhFirst, 102, m_cur_ist == m_cur_state_set, _T("Unknown"), cstr);
		return;
	}
	ESTDLBL lbl;
	m_api->BNodeSetCurrent(m_rgnid[m_cur_rec]);
	lbl = m_api->ELblNode();
	if (lbl == ESTDLBL_fixobs || lbl == ESTDLBL_fixunobs)
	{
		if (!FSkip(m_rgnid[m_cur_rec]) )
			m_cur_state_set = 0;			
		m_cur_ist = 0;
		m_api->NodeStateName(m_cur_ist);
		strTemp = m_api->SzcResult();
		WriteResult(m_rgnid[m_cur_rec] +idhFirst, m_cur_ist, m_cur_ist == m_cur_state_set, (LPCTSTR) strTemp, cstr);
		m_cur_ist = m_cur_cst -1;
		return;
	}
	m_api->NodeStateName(m_cur_ist);
	strTemp = m_api->SzcResult();
	WriteResult(m_rgnid[m_cur_rec] +idhFirst, m_cur_ist, m_cur_ist == m_cur_state_set, (LPCTSTR) strTemp, cstr);
	return;
}

//
//
void CInfer::FxInitState(NID nid)
{
	UINT	cst;
	UINT	istSet = -1;

	m_api->BNodeSetCurrent(nid);
	cst = m_api->INodeCst();
	m_api->BNodeSetCurrent(nid);
	m_cur_state_set = m_api->INodeState();	
	m_cur_cst = cst;
	m_cur_ist = 0;
}

#define SZ_WORKED	_T("101")
#define SZ_FAILED	_T("0")
#define SZ_YES		_T("0")
#define SZ_NO		_T("1")
#define SZ_UNKNOWN	_T("102")
#define SZ_ANY		_T("103")
#define SZ_MICRO	_T("104")

#define SZ_CHECKED _T("CHECKED")

void inline CInfer::GetNextButton(CString &strNext)
{
	if (m_api->BNetPropItemStr(HTK_NEXT_BTN, 0))
		strNext = m_api->SzcResult();
	else
		strNext = _T("Next");
	return;
}

void inline CInfer::GetBackButton(CString &strBack)
{
	if (m_api->BNetPropItemStr(HTK_BACK_BTN, 0))
		strBack = m_api->SzcResult();
	else
		strBack = _T("Back");
	return;
}

void inline CInfer::GetStartButton(CString &strStart)
{
	if (m_api->BNetPropItemStr(HTK_START_BTN, 0))
		strStart = m_api->SzcResult();
	else
		strStart = _T("Start Over");
	return;
}

void CInfer::GetStd3ButtonEnList(CString *cstr, bool bIncludeBackButton, bool bIncludeNextButton, bool bIncludeStartButton)
{
	CString strBtnPart1 = "<INPUT class=\"standard\" ";
	CString strBack;
	CString strNext;
	CString strStart;
	GetBackButton(strBack);
	GetNextButton(strNext);
	GetStartButton(strStart);

#if 0	
	// just for debugging whether BACK button will show.
	char buf[256];
	*cstr += "<br>DEBUG bIncludeBackButton = ";
	*cstr += bIncludeBackButton ? "true. " : "false. ";
	*cstr += "<br>DEBUG m_api->StatesNowSet() = ";
	sprintf(buf, "%d", m_api->StatesNowSet());
	*cstr += buf;
	*cstr += "<br>m_api->StatesFromServ() = ";
	sprintf(buf, "%d", m_api->StatesFromServ());
	*cstr += buf;
	*cstr += "<br>m_cnidSkip = ";
	sprintf(buf, "%d", m_cnidSkip);
	*cstr += buf;
	*cstr += "<br>END DEBUG<br>";
#endif		

	*cstr += "</TABLE>\n<P><NOBR>";

	if (bIncludeBackButton)
	{
		*cstr += strBtnPart1;
		*cstr += "TYPE=BUTTON VALUE=";
		*cstr += "\"<&nbsp;&nbsp;";
		*cstr += strBack;
		*cstr += "&nbsp;\" onclick=\"previous()\">";
	}

	if (bIncludeNextButton)
	{
		*cstr += strBtnPart1;
		*cstr += "TYPE=SUBMIT VALUE=";
		*cstr += "\"&nbsp;";
		*cstr += strNext;
		*cstr += "&nbsp;&nbsp;>&nbsp;\">";
	}

	if (bIncludeStartButton)
	{
		*cstr += strBtnPart1;
		*cstr += "TYPE=BUTTON VALUE=";
		*cstr += "\"";
		*cstr += strStart;
		*cstr += "\" OnClick=\"starter()\"></NOBR><BR>\n";
	}

	return;
}

bool CInfer::BelongsOnProblemPage(int index)
{
	VERIFY(m_api->BNodeSetCurrent(index));

	if (m_api->ELblNode() != ESTDLBL_problem)
		return false;

	// It's a problem node.  Belongs unless H_PROB_SPECIAL_STR property contains
	//	the string "hide"
	if (m_api->BNodePropItemStr(H_PROB_SPECIAL_STR, 0))
		return (_tcsstr(m_api->SzcResult(), _T("hide")) == NULL);
	else
		return true;	// Doesn't even have an H_PROB_SPECIAL_STR
}

VOID CInfer::GetIdhProblemPage(IDH idh, CString *cstr)
{
	CString strTxt;
	CString strIdh;
	CString strNext;
	strIdh.Format(_T("%d"), idhFirst + m_api->CNode());
	AfxFormatString2(strTxt, IDS_HTM_IDH1, (LPCTSTR) strIdh, _T("ProblemAsk"));
	*cstr += strTxt;

//AfxDebugBreak();

	m_api->BNetPropItemStr(H_PROB_HD_STR, 0);
	AfxFormatString1(strTxt, IDS_HTM_HEADER1, m_api->SzcResult());
	*cstr += strTxt;

	strTxt.LoadString(IDS_HTM_ST_LIST1);
	*cstr += strTxt;
	for(int index = 0; index < m_api->CNode(); index++)
	{
		VERIFY(m_api->BNodeSetCurrent(index));
		if (BelongsOnProblemPage(index))
		{
			m_api->NodeSymName();
			AfxFormatString2(strTxt, IDS_HTM_RADIO1A, (LPCTSTR) strIdh, m_api->SzcResult());
			*cstr += strTxt;
			// If going back and this state was selected, write "Checked"
			if (m_Backup.Check(index))
				*cstr += SZ_CHECKED;
			VERIFY(m_api->BNodePropItemStr(H_PROB_TXT_STR, 0));
			AfxFormatString1(strTxt, IDS_HTM_RADIO1B, m_api->SzcResult());
			*cstr += strTxt;
		}
	}
	GetNextButton(strNext);
	AfxFormatString1(strTxt, IDS_HTM_EN_LIST1, (LPCTSTR) strNext);
	*cstr += strTxt;

	return;
}

//
//
VOID CInfer::GetFixRadios(LPCTSTR szIdh, CString *cstr)
{
	CString strTxt;
	AfxFormatString2(strTxt, IDS_HTM_RADIO2A, szIdh, SZ_WORKED);
	if (m_api->BNodePropItemStr(H_ST_NORM_TXT_STR, 0))
	{
		*cstr += strTxt;
		if (m_Backup.Check(1))
			*cstr += SZ_CHECKED;
		AfxFormatString1(strTxt, IDS_HTM_RADIO2B, m_api->SzcResult());
		*cstr += strTxt;
	}
	AfxFormatString2(strTxt, IDS_HTM_RADIO2A, szIdh, SZ_FAILED);
	if (m_api->BNodePropItemStr(H_ST_AB_TXT_STR, 0))
	{
		*cstr += strTxt;
		if (m_Backup.Check(0))
			*cstr += SZ_CHECKED;
		AfxFormatString1(strTxt, IDS_HTM_RADIO2B, m_api->SzcResult());
		*cstr += strTxt;
	}
	AfxFormatString2(strTxt, IDS_HTM_RADIO2A, szIdh, SZ_UNKNOWN);
	if (m_api->BNodePropItemStr(H_ST_UKN_TXT_STR, 0))
	{
		*cstr += strTxt;
		if (m_Backup.Check(102))
			*cstr += SZ_CHECKED;
		AfxFormatString1(strTxt, IDS_HTM_RADIO2B, m_api->SzcResult());
		*cstr += strTxt;
	}
	return;
}

VOID CInfer::GetInfoRadios(LPCTSTR szIdh, CString *cstr)
{
	CString strTxt;
	AfxFormatString2(strTxt, IDS_HTM_RADIO2A, szIdh, SZ_YES);
	if (m_api->BNodePropItemStr(H_ST_NORM_TXT_STR, 0))
	{
		*cstr += strTxt;
		if (m_Backup.Check(0))
			*cstr += SZ_CHECKED;
		AfxFormatString1(strTxt, IDS_HTM_RADIO2B, m_api->SzcResult());
		*cstr += strTxt;
	}

	AfxFormatString2(strTxt, IDS_HTM_RADIO2A, szIdh, SZ_NO);
	if (m_api->BNodePropItemStr(H_ST_AB_TXT_STR, 0))
	{
		*cstr += strTxt;
		if (m_Backup.Check(1))
			*cstr += SZ_CHECKED;
		AfxFormatString1(strTxt, IDS_HTM_RADIO2B, m_api->SzcResult());
		*cstr += strTxt;
	}

	AfxFormatString2(strTxt, IDS_HTM_RADIO2A, szIdh, SZ_UNKNOWN);
	if (m_api->BNodePropItemStr(H_ST_UKN_TXT_STR, 0))
	{
		*cstr += strTxt;
		if (m_Backup.Check(102))
			*cstr += SZ_CHECKED;
		AfxFormatString1(strTxt, IDS_HTM_RADIO2B, m_api->SzcResult());
		*cstr += strTxt;
	}
	return;
}

// GetPropItemStrs can not be used with the radio buttons.
// GetPropItemStrs should be used every where.
bool CInfer::GetNetPropItemStrs(TSZC item, UINT Res, CString *cstr)
{
	bool ret = false;
	CString strTxt;
	int x = 0;
	while (m_api->BNetPropItemStr(item, x))
	{
		AfxFormatString1(strTxt, Res, m_api->SzcResult());
		*cstr += strTxt;
		ret = true;
		x++;
	}
	return ret;
}
bool CInfer::GetNodePropItemStrs(TSZC item, UINT Res, CString *cstr)
{
	bool ret = false;
	CString strTxt;
	int x = 0;
	while (m_api->BNodePropItemStr(item, x))
	{
		AfxFormatString1(strTxt, Res, m_api->SzcResult());
		*cstr += strTxt;
		ret = true;
		x++;
	}
	return ret;
}

VOID CInfer::GetByeMsg(LPCTSTR szIdh, CString *cstr)
{
	CString strTxt;
	CString strBack;
	CString strStart;
	AfxFormatString2(strTxt, IDS_HTM_IDH3, szIdh, _T("IDH_BYE"));
	*cstr += strTxt;
	GetNetPropItemStrs(HX_BYE_HD_STR, IDS_HTM_HEADER3, cstr);
	GetNetPropItemStrs(HX_BYE_TXT_STR, IDS_HTM_BODY1, cstr);
	GetBackButton(strBack);
	GetStartButton(strStart);
	AfxFormatString2(strTxt, IDS_HTM_EN_BYE_MSG, (LPCTSTR) strBack, (LPCTSTR) strStart);
	*cstr += strTxt;
	return;
}

VOID CInfer::GetFailMsg(LPCTSTR szIdh, CString *cstr)
{
	CString strTxt;
	CString strBack;
	CString strStart;

	bool bSniffedAOK = false;	// set true in the case where we got here directly by
								//	sniffing (showing nothing but the problem page, or
								//	not even that).  $BUG  Unfortunately, we haven't yet got
								//	an algorithm to set this.

	AfxFormatString2(strTxt, IDS_HTM_IDH4, szIdh, _T("IDH_FAIL"));
	*cstr += strTxt;

	if (bSniffedAOK)
	{
		if (!GetNetPropItemStrs(HX_SNIFF_AOK_HD_STR, IDS_HTM_HEADER4, cstr))
			GetNetPropItemStrs(HX_FAIL_HD_STR, IDS_HTM_HEADER4, cstr);
		if (!GetNetPropItemStrs(HX_SNIFF_AOK_TXT_STR, IDS_HTM_BODY2, cstr))
			GetNetPropItemStrs(HX_FAIL_TXT_STR, IDS_HTM_BODY2, cstr);
	}
	else
	{
		GetNetPropItemStrs(HX_FAIL_HD_STR, IDS_HTM_HEADER4, cstr);
		GetNetPropItemStrs(HX_FAIL_TXT_STR, IDS_HTM_BODY2, cstr);
	}

	GetBackButton(strBack);
	GetStartButton(strStart);
	AfxFormatString2(strTxt, IDS_HTM_BACK_START, (LPCTSTR) strBack, (LPCTSTR) strStart);
	*cstr += strTxt;
	return;
}

VOID CInfer::GetServiceMsg(LPCTSTR szIdh, CString *cstr)
{
	CString strTxt;
	CString strBack;
	CString strNext;
	CString strStart;
	AfxFormatString2(strTxt, IDS_HTM_IDH5, szIdh, _T("SERVICE"));
	*cstr += strTxt;
	GetNetPropItemStrs(HX_SER_HD_STR, IDS_HTM_HEADER5, cstr);
	GetNetPropItemStrs(HX_SER_TXT_STR, IDS_HTM_BODY3, cstr);
/*
	strTxt.LoadString(IDS_HTM_ST_LIST2);
	*cstr += strTxt;
	AfxFormatString2(strTxt, IDS_HTM_RADIO2A, TRY_TS_AT_MICROSOFT_SZ, SZ_MICRO);
	if (m_api->BNetPropItemStr(HX_SER_MS_STR, 0))
	{
		*cstr += strTxt;
		AfxFormatString1(strTxt, IDS_HTM_RADIO2B, m_api->SzcResult());
		*cstr += strTxt;
	}
	GetStd3ButtonEnList(cstr, true, true, true);
*/
	GetBackButton(strBack);
	GetStartButton(strStart);
	AfxFormatString2(strTxt, IDS_HTM_BACK_START, (LPCTSTR) strBack, (LPCTSTR) strStart);
	*cstr += strTxt;
	return;
}

VOID CInfer::GetSkippedNodesMsg(LPCTSTR szIdh, CString *cstr)
{
	CString strTxt;
	AfxFormatString2(strTxt, IDS_HTM_IDH5, szIdh, _T("SERVICE"));
	*cstr += strTxt;
	GetNetPropItemStrs(HX_SKIP_HD_STR, IDS_HTM_HEADER5, cstr);
	GetNetPropItemStrs(HX_SKIP_TXT_STR, IDS_HTM_BODY3, cstr);
	strTxt.LoadString(IDS_HTM_ST_LIST2);
	*cstr += strTxt;
	AfxFormatString2(strTxt, IDS_HTM_RADIO2A, TRY_TS_AT_MICROSOFT_SZ, SZ_ANY);
	if (m_api->BNetPropItemStr(HX_SKIP_SK_STR, 0))
	{	// Did I skip something?
		*cstr += strTxt;
		AfxFormatString1(strTxt, IDS_HTM_RADIO2B, m_api->SzcResult());
		*cstr += strTxt;
	}
	GetStd3ButtonEnList(cstr, true, true, true);
	return;
}

VOID CInfer::GetImpossibleNodesMsg(LPCTSTR szIdh, CString *cstr)
{
	CString strTxt;
	CString strBack;
	CString strStart;
	AfxFormatString2(strTxt, IDS_HTM_IDH5, szIdh, _T("SERVICE"));
	*cstr += strTxt;
	GetNetPropItemStrs(HX_IMP_HD_STR, IDS_HTM_HEADER5, cstr);
	GetNetPropItemStrs(HX_IMP_TXT_STR, IDS_HTM_BODY3, cstr);
	GetBackButton(strBack);
	GetStartButton(strStart);
	AfxFormatString2(strTxt, IDS_EN_IMP, (LPCTSTR) strBack, (LPCTSTR) strStart);
	*cstr += strTxt;
	return;
}

VOID	CInfer::GetIdhPage(IDH idh, CString *cstr)
{
	CString strTxt;
	CString strIdh;
	CString str;
	
	str.Format(_T("%d"), idh);
	if (m_api->BNodeSetCurrent(idh - idhFirst))
	{
		m_api->NodeSymName();
		strIdh = m_api->SzcResult();
	}
	else
		strIdh = _T("");
	if (IDH_BYE == idh)
	{
		strIdh.Format(_T("%d"), idh);
		GetByeMsg((LPCTSTR) strIdh, cstr);
	}
	else if (IDH_FAIL == idh)
	{
		strIdh.Format(_T("%d"), idh);
		GetFailMsg((LPCTSTR) strIdh, cstr);
	}
	else if ((nidService + idhFirst)== idh)
	{
		strIdh.Format(_T("%d"), idh);
		GetServiceMsg((LPCTSTR) strIdh, cstr);
	}
	else
	{
		// normal node
		AfxFormatString2(strTxt, IDS_HTM_IDH2, (LPCTSTR) strIdh, (LPCTSTR) str);
		*cstr += strTxt;

		if (GetForcedRecommendation() + idhFirst == idh)
			GetNodePropItemStrs(H_NODE_DCT_STR, IDS_HTM_HEADER2, cstr);
		else
			GetNodePropItemStrs(H_NODE_HD_STR, IDS_HTM_HEADER2, cstr);

		GetNodePropItemStrs(H_NODE_TXT_STR, IDS_HTM_TEXT1, cstr);
		strTxt.LoadString(IDS_HTM_ST_LIST2);
		*cstr += strTxt;

		if (GetForcedRecommendation() + idhFirst != idh)
		{
			ESTDLBL lbl = m_api->ELblNode();
			if (ESTDLBL_fixobs == lbl || ESTDLBL_fixunobs == lbl || ESTDLBL_unfix == lbl)
				GetFixRadios((LPCTSTR) strIdh, cstr);
			else if (ESTDLBL_info == lbl)
				GetInfoRadios((LPCTSTR) strIdh, cstr);
		}

		// We only want to show a BACK button if at least one node has been set or skipped.
		//	This does not include nodes initiallly set on instructions from TSLaunchServ:
		//	the whole point is to avoid stepping "back" into things that were set by
		//	the launch server rather than by the user.
		{
			//DEBUG
			//AfxDebugBreak();
			int testNowSet = m_api->StatesNowSet();
			int testStatesFromServ = m_api->StatesFromServ();
		}

		// Suppress back button if we launched to a network with a problem node and
		//	no further nodes have been set.  It's not the problem page, but (as far as user
		//	is concerned) it's the first page.
		bool bIncludeBackButton =
			m_api->StatesNowSet() > m_api->StatesFromServ() || m_cnidSkip > 0;

		// We would like to suppress the back button in the similar scenario where
		//	sniffing takes us past the first recommendation.  For example:
		//	Launcher specifies problem.
		//	First recommendation for that problem is sniffed as "normal" (state = 0)
		//	Now the first node we show is even deeper into the chain.
		 bIncludeBackButton = bIncludeBackButton &&
								(m_api->IsRunWithKnownProblem() ?
								   (m_api->GetCountRecommendedNodes() >
									m_api->GetCountSniffedRecommendedNodes() + 1/*this is for the problem we've started with*/) :
									1);

		// We supress back button ALWAYS when we have sniffed foxobs node that worked
		//  we can be either on the problem page where we do not need back button
		//  or on problem resolution page from where we never go back
		 bIncludeBackButton = bIncludeBackButton &&
								m_api->GetSniffedFixobsThatWorked() == SNIFF_INVALID_NODE_ID;
		
		// We do not want to have a NEXT button when we are on the problem resolution page
		bool bIncludeNextButton = (GetForcedRecommendation() + idhFirst) != idh;

		GetStd3ButtonEnList(cstr, bIncludeBackButton, bIncludeNextButton, true);
	}
	return;
}

//
//
BOOL	CInfer::FSkip(NID nid) const
{
	for (UINT inid = 0; inid < m_cnidSkip; inid++)
	{
		if (m_rgnidSkip[inid] == nid)
		{
			return TRUE;
		}
	}
		
	return FALSE;		
}

void	CInfer::BackUp(int nid, int state)
{
	m_Backup.SetState(nid, state);	// This sets the radio button.
	// Is nid in the skip list?
	for (UINT inid = 0; inid < m_cnidSkip; inid++)
	{
		if (m_rgnidSkip[inid] == (unsigned) nid)
		{
			// Remove nid from the skip list.
			while(inid < (m_cnidSkip - 1))
			{
				m_rgnidSkip[inid] = m_rgnidSkip[inid + 1];
				inid++;
			}
			m_rgnidSkip[inid] = NULL;
			m_cnidSkip--;
		}
	}
//	if (m_cnidSkip < 0)
//		m_cnidSkip = 0;
	return;
}

//
//
VOID	CInfer::AddSkip(NID nid)
{
	if (!FSkip(nid))
	{
		if (m_cnidSkip < cnidMacSkip)
		{
			m_rgnidSkip[m_cnidSkip++] = nid;
		}
	}
}

VOID CInfer::RemoveSkips()
{
	for(UINT x = 0; x < m_cnidSkip; x++)
		m_rgnidSkip[x] = NULL;
	m_cnidSkip = 0;
	return;
}

//
//
VOID	CInfer::PrintMessage(TSZC szcFormat, ...) const
{
	va_list ptr;
	TCHAR formatbuf[1024];

	if (szcFormat) {
		_tcscpy(formatbuf,_T("<H4>"));

		va_start(ptr,szcFormat);
		_vstprintf(&formatbuf[4],szcFormat,ptr);
		va_end(ptr);
		_tcscat(formatbuf,_T("</H4>"));

		*m_pCtxt += formatbuf;
	}
}

//
//
VOID	CInfer::PrintString(TSZC szcFormat, ...) const
{
	va_list ptr;
	TCHAR formatbuf[1024];

	if (szcFormat) {
		va_start(ptr,szcFormat);
		_vstprintf(formatbuf,szcFormat,ptr);
		va_end(ptr);

		*m_pCtxt += formatbuf;
	}
}

// this data is now in CSniffedInfoContainer
/*
// This allows a higher level to say "don't go to the belief network for a recommendation,
//	I already know what to recommend."  Used in conjunction with a sniffer.
VOID CInfer::ForceRecommendation(IDH idh)
{
	m_idhSniffedRecommendation= idh;
}
*/

// Associate a state with a node.
// INPUT idh -	either (node ID + 1000) or one
//	of the special values IDH_BYE, IDH_FAIL, (nidService + 1000)
// INPUT ist -	index of a state for that node
// RETURNS >>> document?.
BOOL	CInfer::FSetNodeOfIdh(IDH idh, IST	ist)
{
	if (ist == 101)
	{
		m_fDone = TRUE;
		return TRUE;
	}

	if (ist == 103)	
	{
		m_ishowService++;
		return TRUE;
	}

	if (idh < idhFirst)
		return TRUE;

	if (idh > m_acnid + idhFirst && idh != IDH_SERVICE)
		return TRUE;

	if (ist == 102)
	{	//	"don't want to do this now"
		AddSkip(idh - idhFirst);
		SaveNID(idh - idhFirst);
		return TRUE;
	}

	if (idh == m_api->GetProblemAsk()) {
		// get data for problem
		IDH *idarray = NULL;		
		NID	nidProblem = nidNil;
		UINT iproblem = 0;
		UINT inid;

		UINT count = m_api->GetProblemArray(&idarray);

		for (inid = 0; inid < count; inid++) {
			if (ist == idarray[inid]) {
				
				nidProblem = ist - idhFirst;
				iproblem = ist;

				if (!m_api->NodeSet(idarray[inid] - idhFirst, ist == idarray[inid] ? 1 : 0,
								m_Backup.InReverse()))
					return FALSE;
				break;
			}
		}

		if (nidProblem == nidNil) {
			m_idhQuestion = IDH_SERVICE;
			return TRUE;
		}
		m_api->BNodeSetCurrent(nidProblem);
		m_api->NodeFullName();
		
		_stprintf(m_problem, _T("%s<INPUT TYPE=HIDDEN NAME=%u VALUE=%u>"), m_api->SzcResult(), idh, iproblem);
		m_firstNid = idh - idhFirst;
		m_firstSet = iproblem;
		return TRUE;
	}

	NID		nid = idh - idhFirst;

	if (nid != nidService)
		if (!m_api->NodeSet(nid, ist, m_Backup.InReverse()))
			return FALSE;

	SaveNID(nid);  // save this node id so we can print it at the end

	return TRUE;
}

//
//
void CInfer::SaveNID(UINT nid)
{
	m_rgnid[m_max_rec] = nid;
	m_max_rec++;
}

//
//
void	CInfer::WriteResult(UINT name, UINT value, BOOL bSet, TSZC szctype, CString *cstr) const
{
	TCHAR	ctemp[1024];
	TCHAR*	szFmtInput =  _T("<INPUT TYPE=RADIO NAME=%u VALUE=%u%s>%-16s ");
		
	_stprintf(ctemp, szFmtInput,
		name, value, bSet ? _T(" CHECKED") : _T(""), szctype);
	*cstr += ctemp;
}

//
//
int	CInfer::Finish(CString *cstr)
{
	CString strTxt;
	if (m_fDone)
	{
		GetIdhPage(IDH_BYE, cstr);
		// Reset the done flag so that the Previous button will work correctly.
		m_fDone = FALSE;
		return FALSE;
	}
	if (m_idhQuestion != 0)
	{
		GetIdhPage(m_idhQuestion, cstr);
		return FALSE;
	}
	if (m_api->BImpossible())
	{
		GetImpossibleNodesMsg(_T("Impossible"), cstr);
		return FALSE;
	}
	//
	// we've come down to ask recommendations
	//	
	int iRecommendRes = m_api->GTSGetRecommendations(m_cnid, m_question_rgnid);

	return iRecommendRes;
}

// ResetSevice is called when the start button is pressed.  CTSHOOTCtrl::ProblemPage()
void CInfer::ResetService()
{
	m_ishowService = 0;
	m_cnidSkip = 0;
	m_cnid = 0;
	return;
}
//
//
void CInfer::SetType(LPCTSTR type)
{
	_stprintf(m_tstype, _T("%s"),type);
}

//
//
void CInfer::LoadTShooters(HKEY hRegKey)
{
	long lRet;
	int x;
	HKEY hkeyShooter;
	TShooter tShooter;
	TShooter tsTemp;
	CString strKeyName = _T("");
	CString strKeyPath = _T("");
	CString strTSPath = _T("");
	CString strData = _T("");
	DWORD dwIndex = 0;
	DWORD dwKeySize = MAXBUF;
	FILETIME fileTime;
	DWORD dwDataSize = MAXBUF;
	DWORD dwType = REG_SZ;
	m_cShooters = 0;
	m_iShooter = 0;
	strKeyPath.Format(_T("%s\\%s"), TSREGKEY_MAIN, REGSZ_TSTYPES);
	while (ERROR_SUCCESS ==
				(lRet = RegEnumKeyEx(hRegKey,
								dwIndex, strKeyName.GetBufferSetLength(MAXBUF),
								&dwKeySize, NULL,
								NULL, NULL,
								&fileTime)))
	{
		strKeyName.ReleaseBuffer();
		strTSPath.Format(_T("%s\\%s"),(LPCTSTR) strKeyPath, (LPCTSTR) strKeyName);
		if ((lRet = RegOpenKeyEx(	HKEY_LOCAL_MACHINE,
									(LPCTSTR) strTSPath,
									NULL,
									KEY_READ,				
									&hkeyShooter)) == ERROR_SUCCESS)
		{
			if ((lRet = RegQueryValueEx(hkeyShooter,
								FRIENDLY_NAME,
								0,
								&dwType,
								(LPBYTE) strData.GetBufferSetLength(MAXBUF),
								&dwDataSize)) == ERROR_SUCCESS)
			{
				strData.ReleaseBuffer();
				m_cShooters++;
				_tcsncpy(tShooter.m_szName, (LPCTSTR) strKeyName, strKeyName.GetLength() + 1);
				_tcsncpy(tShooter.m_szDisplayName, (LPCTSTR) strData, strData.GetLength() + 1);
				x = (int)m_aShooters.GetSize();
				while (x > 0)
				{
					x--;
					tsTemp = m_aShooters.GetAt(x);
					if (_tcscmp(tsTemp.m_szDisplayName, tShooter.m_szDisplayName) < 0)
					{
						x++;
						break;
					}
				}
				m_aShooters.InsertAt(x, tShooter);
			}
			RegCloseKey(hkeyShooter);
		}
		dwIndex++;
		dwKeySize = MAXBUF;
		dwDataSize = MAXBUF;
		dwType = REG_SZ;
		strKeyName = _T("");
		strData = _T("");
	}
	ASSERT(ERROR_NO_MORE_ITEMS == lRet);
	return;
}

//
//
int	CInfer::GetForcedRecommendation()
{
	return m_api->GetSniffedFixobsThatWorked();
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\apgtsinf.h ===
//
// MODULE: APGTSINF.H
//
// PURPOSE: Inference support header
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
//			further work by Richard Meadows (RWM), Joe Mabel, Oleg Kalosha
// 
// ORIGINAL DATE: 8-2-96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.2		6/4/97		RWM		Local Version for Memphis
// V0.3		3/24/98		JM		Local Version for NT5

#include "ErrorEnums.h"
#include "sniff.h"

typedef unsigned int	   NID;	// numeric node ID in the form used by BNTS

//	Please Note: these values are mirrored in dtguiapi.bas, please keep in sync
const NID	nidNil     = 12346;
const NID	nidService = 12345;

#define	IDH_BYE        	  101	// success page
#define	IDH_FAIL       	  102	// "no more recommendations" page

typedef	UINT	IDH;		//	help index.  For values where a NID is defined,
							//	add idhFirst to get an IDH.  IDH_BYE & IDH_FAIL
							//	are also good IDHs.
const IDH	idhFirst = 1000;
#define IDH_FROM_NID(NID) (NID + idhFirst)

#define IDH_SERVICE IDH_FROM_NID(nidService)

#define MAXBUF	256 * 2

#define MAXPROBID		100		// allow for this many problem nodes in a network

enum { cnidMacSkip = 32 };		// max # of "skipped" nodes

typedef	TCHAR*			   TSZ;
typedef	const TCHAR*	   TSZC;// >>> why distinguished from TSZ?

typedef unsigned int	  CNID;	// a count of node IDs.								
typedef unsigned int	   IST;	// state number (associated with a node)
								//	0 - normal
								//	1 - abnormal
								//	102 - skipped

#define MAX_NID		64		// allow for this many nodes to be given states by user on the
							// way to solving the problem

void WideToMB(const WCHAR *szIn, CHAR *szOut);	// Converts Unicode chars to Multi Byte.

class GTSCacheGenerator;		// forward reference

class GTSAPI : public BNTS
{
#define SZ_CACHE_NAME _T(".tsc")
public:
	GTSAPI(TCHAR *binfile, TCHAR *tagstr, TCHAR *szResourcePath);
	virtual ~GTSAPI();
	BOOL BNodeSet(int state, bool bset);  // Old comment says "For debugging" but I doubt it.
										//	Maybe that's just why its public.  - JM 3/98
	void AddValue(int value);

	// Temporary BNTS wrappers for unicode build with non unicode bnts.dll
	CString m_strResult;
	BOOL BMultiByteReadModel(LPCTSTR szcFn, LPCSTR szcFnError);
	BOOL BReadModel (LPCTSTR szcFn, LPCSTR szcFnError = NULL)
	{
#ifndef _UNICODE
		return BNTS::BReadModel(szcFn, szcFnError);
#else
		return BMultiByteReadModel(szcFn, szcFnError);
#endif
	};
	BOOL BMultiByteNodePropItemStr(LPCTSTR szcPropType, int index);
	virtual BOOL BNodePropItemStr(TSZC szcPropType, int index)
	{
#ifndef _UNICODE
		return BNTS::BNodePropItemStr(szcPropType, index);
#else
		return BMultiByteNodePropItemStr(szcPropType, index);
#endif
	};
	BOOL BMultiByteNetPropItemStr(LPCTSTR szcPropType, int index);
	virtual BOOL BNetPropItemStr(TSZC szcPropType, int index)
	{
#ifndef _UNICODE
		return BNTS::BNetPropItemStr(szcPropType, index);
#else
		return BMultiByteNetPropItemStr(szcPropType, index);
#endif
	};
	LPCTSTR SzcMultiByteResult();
	virtual LPCTSTR SzcResult()
	{
#ifndef _UNICODE
		return BNTS::SzcResult();
#else
		return SzcMultiByteResult();
#endif
	};
	int IMultiByteNode(LPCTSTR szSymName);
	virtual int INode(LPCTSTR szSymName)
	{
#ifndef _UNICODE
		return BNTS::INode(szSymName);
#else
		return IMultiByteNode(szSymName);
#endif
	};


	// Temporary BNTS wrappers for debug build with release bnts.dll
	/*
	BOOL BNetPropItemStr(LPCTSTR szPropItem, int index, CString &str)
	{
		BOOL bRet;
		str.GetBuffer(STRBUFSIZE);
		bRet = BNTS::BNetPropItemStr(szPropItem, index, str);
		str.ReleaseBuffer();
		return bRet;
	};
	BOOL BNodePropItemStr(LPCTSTR szPropItem, int index, CString &str)
	{
		BOOL bRet;
		str.GetBuffer(STRBUFSIZE);
		bRet = BNTS::BNodePropItemStr(szPropItem, index, str);
		str.ReleaseBuffer();
		return bRet;
	};
	void NodeStateName(int index, CString &str)
	{		
		str.GetBuffer(STRBUFSIZE);
		BNTS::NodeStateName(index, str);
		str.ReleaseBuffer();
		return;
	};
	void NodeSymName(CString &str)
	{		
		str.GetBuffer(STRBUFSIZE);
		BNTS::NodeSymName(str);
		str.ReleaseBuffer();
		return;
	};
	void NodeFullName(CString &str)
	{		
		str.GetBuffer(STRBUFSIZE);
		BNTS::NodeFullName(str);
		str.ReleaseBuffer();
		return;
	};
		*/
	// Regular functions.

	//virtual BOOL	NodeSet(NID nid, IST ist);
	VOID	ResetNodes();

	DWORD	Reload(/*CWordList *pWXList*/);

	DWORD	GetStatus();
	
	UINT	GetProblemArray(IDH **idh);
	IDH		GetProblemAsk();

	UINT	GetNodeList(NID **pNid, IST **pIst);
	int		GTSGetRecommendations(CNID& cnid, NID rgnid[]);
	void	RemoveRecommendation(int Nid);

	VOID	GetSearchWords(/*CWordList *pWords*/);
	DWORD	EvalWord(TCHAR *token);

	//WNODE_ELEM *GetWNode(NID nid);

	BOOL BNodeSetCurrent(int node);


	VOID	ScanAPIKeyWords(/*CWordList *pWXList*/);

protected:
	VOID	Destroy();

protected:

	GTSCacheGenerator m_CacheGen;

	// These 2 arrays tie together nodes & their states
	NID		m_rgnid[MAX_NID];
	IST		m_rgist[MAX_NID];
	IST		m_rgsniff[MAX_NID]; // array of states, showing if the node was sniffed

	UINT	m_cnid;				// current size of m_rgnid, m_rgist; number of nodes to which
								// a state has been assigned.

	TCHAR	m_binfile[MAXBUF];	// name of DSC file (>>> full path or not?) 
								//	>>>should be renamed! DSC file replaced BIN file.
	TCHAR	m_tagstr[MAXBUF];
	TCHAR	m_szResourcePath[MAXBUF];	// full path of resource directory

	DWORD	m_dwErr;
	
	TCHAR*	m_pchHtml;
	
	IDH		m_idstore[MAXPROBID];	// problem node convenience array in the 
									// form of IDH values
	UINT	m_currid;				// Despite bad name, number of values in m_idstore
	IDH		m_probask;				// IDH value corresponding to ProblemAsk: number of nodes
									//	in the network + 1000
	
	CBNCache *m_pCache;				// cache for states of this network

};


////////////////////////////////////////////////////////////////////////////////////////
// BCache class declaration
//

// these are returns by GTSGetRecommendations member function
//
#define RECOMMEND_SUCCESS					1
#define RECOMMEND_FAIL						0
#define RECOMMEND_IMPOSSIBLE				99
#define RECOMMEND_NODE_WORKED				100
#define RECOMMEND_NO_MORE_DATA				101
//
#define NODE_ID_NONE				        -1  
//

class CHttpQuery;

class BCache : public GTSAPI, public CSniffedNodeContainer
{
public:
	BCache(TCHAR *binfile, TCHAR *tagstr, TCHAR *szResourcePath, const CString& strFile);
	~BCache();

	void SetHttpQuery(CHttpQuery *p) {m_pHttpQuery = p;return;};
	UINT StatesFromServ();
	UINT StatesNowSet();

	DWORD Initialize(/*CWordList *pWXList*/);
	DWORD ReadModel();
	void ReadCacheFile(LPCTSTR szCache);
																	   
	int GTSGetRecommendations(CNID& cnid, NID rgnid[], bool bSniffed =false);
	void RemoveRecommendation(int Nid);
	BOOL NodeSet(NID nid, IST ist, bool bPrevious);
	void ResetNodes();

	int CNode();
	BOOL BImpossible();
	BOOL BNetPropItemStr(LPCTSTR szPropType, int index);
	BOOL BNetPropItemReal(LPCTSTR szPropType, int index, double &dbl);

	BOOL BNodeSetCurrent(int node);
	int INode(LPCTSTR szNodeSymName);
	ESTDLBL ELblNode();
	int INodeCst();
	BOOL BNodeSet(int istate, bool bSet = true);
	int INodeState();
	void NodeStateName(int istate);
	void NodeSymName();
	void NodeFullName();
	BOOL BNodePropItemStr(LPCTSTR szPropType, int index);
	BOOL BNodePropItenReal(LPCTSTR szPropType, int index, double &dbl);
	void NodeBelief();
	bool BValidNet();
	bool BValidNode();
	void Clear();

	void RemoveStates() {m_NodeState.RemoveAll();};
	void RemoveNode(int Node) {VERIFY(m_NodeState.RemoveKey(Node));};

	LPCTSTR SzcResult() const;

	void ReadTheDscModel(int From = TSERR_ENGINE_BNTS_READ);

	const CArray<int, int>& GetArrLastSniffed();

	int GetCountRecommendedNodes();
	int GetCountSniffedRecommendedNodes();

	bool IsReverse();
	void SetReverse(bool);

	void SetRunWithKnownProblem(bool);
	bool IsRunWithKnownProblem();

	void SetAdditionalDataOnNodeSet(NID nid);

protected:
	int GetIndexNodeInCache(NID nid);


protected:
	CHttpQuery	*m_pHttpQuery;
	BOOL CheckNode(int Node);
	void AddToCache(CString &strCacheFile, const CString& strCacheFileWithinCHM);

	BOOL	m_bNeedModel;	// TRUE -> Need to read the model before querying the bnts library.
	BOOL	m_bModelRead;
	BOOL	m_bDeleteModelFile;
	CString	m_strModelFile;	// Filename of model file
	CString m_strFile;      // name of *.dsz or *.dsc file inside *.chm file 
							// (in this case network file is actually a *.chm file)
	int m_CurNode;
	CMap<int, int, int, int>m_NodeState;

	CString m_strResult;

	CArray<int, int> m_arrNidLastSniffed; // array in sniffed nodes traversed during last navigation

	bool m_bReverse; // indicated if the current movement is in the forward or reverse direction

	bool m_bRunWithKnownProblem; //indicates that the tshooter was started with known problem
};

typedef struct tag_TShooter
{
	TCHAR m_szName[MAXBUF];
	TCHAR m_szDisplayName[MAXBUF];
} TShooter;

//
//
class CInfer
{
	
  public:
	CInfer(	CString *pCtxt);
	~CInfer();

	void	ClearDoubleSkip() {m_SkippedTwice.RemoveAll();};
	VOID	AssertFailed(TSZC szcFile, UINT iline, TSZC szcCond, BOOL fFatal);
	DWORD	Initialize(/*CSearchForm *pBESearch*/);
	void	LoadTShooters(HKEY hRegKey);
	int		GetCount() {return m_acnid;};

	void	BackUp(int nid, int state);
	void	ClearBackup() {m_Backup.Clear();};

	void	WriteProblem();
	BOOL	FSetNodeOfIdh(IDH, IST);
	int		GetForcedRecommendation();
	int		Finish(CString *cstr);
	void	ResetService();
	VOID	PrintRecommendations();
	VOID	WriteOutLogs();
	VOID	SetBelief(BCache *pAPI);
	TCHAR	*EvalData(UINT var_index);
	BOOL	NextVar(UINT var_index);
	BOOL	InitVar(UINT var_index);
	void	SetProblemAsk();
	void	ClearProblemAsk();
	void	SetType(LPCTSTR type);
	BOOL	IsService(CString *cstr);

	VOID	RemoveSkips();

	CSniffedNodeContainer* GetSniffedNodeContainer() {return m_api;}
	
protected:

	void	GetBackButton(CString &strBack);
	void	GetNextButton(CString &strNext);
	void	GetStartButton(CString &strStart);
	void	GetStd3ButtonEnList(CString *cstr, bool bIncludeBackButton, bool bIncludeNextButton, bool bIncludeStartButton);

	bool	GetNetPropItemStrs(TSZC item, UINT Res, CString *cstr);
	bool	GetNodePropItemStrs(TSZC item, UINT Res, CString *cstr);
	VOID	GetByeMsg(LPCTSTR szIdh, CString *cstr);
	VOID	GetFailMsg(LPCTSTR szIdh, CString *cstr);
	VOID	GetServiceMsg(LPCTSTR szIdh, CString *cstr);
	VOID	GetSkippedNodesMsg(LPCTSTR szIdh, CString *cstr);
	VOID	GetImpossibleNodesMsg(LPCTSTR szIdh, CString *cstr);
	VOID	GetFixRadios(LPCTSTR szIdh, CString *cstr);
	VOID	GetInfoRadios(LPCTSTR szIdh, CString *cstr);
	VOID	PrintMessage(TSZC szcFormat, ...) const;
	VOID	PrintString(TSZC szcFormat, ...) const;
	void	WriteResult(UINT name, UINT value, BOOL bSet, TSZC szctype, CString *cstr) const;
	VOID	CloseTable();
	BOOL	FxGetNode(NID nid, BOOL fStatus, CString *cstr) const; 
	void	FxGetState(CString *cstr);
	void	FxInitState(NID nid);
	VOID	GetIdhPage(IDH idh, CString *cstr);	
	bool	BelongsOnProblemPage(int index);
	VOID	GetIdhProblemPage(IDH idh, CString *cstr);

	VOID	OutputBackend(CString *cstr) const;
	BOOL	DisplayTerms(/*CWordList *pWords, */CString *cstr, BOOL bText, BOOL bOr) const;

	VOID	AddBackendDebug(CString *cstr) const;

	void	GetTS(CString *pCtmp);

  private:
	VOID	AddSkip(NID nid);
	BOOL	FSkip(NID nid) const;
	void	SaveNID(UINT nid);
	
	
  private:
	CBackupInfo m_Backup;
	UINT	m_cnidSkip;					// count of elements in m_rgnidSkip
	NID		m_rgnidSkip[cnidMacSkip];	// nodes for which the user has been unable to give
										// a yes or no answer.
	UINT	m_ilineStat;
	BOOL	m_fDone;					// (>>> Not well-understood 11/04/97 JM)
										// Set TRUE when we write out service, fail, or 
										//	success page, but there's some scenario where 
										//	we clear it "so that the Previous button will work"
										//	on BYE page"

	UINT	m_ishowService;		// >>> (JM 12/97) I suspect this is the same as OnlineTS's
								//	BOOL	m_bAnythingElse;	which is documented as
										// Set TRUE if user wants to see if there is anything
										//  else they can try (obtained from a service node in the
										//  previous call to the DLL
	IDH		m_idhQuestion;		// >>> (JM 12/97) I suspect this is the same as OnlineTS's
								//	NID		m_nidAnythingElse;	which is documented as
										// Node to use if m_bAnythingElse is TRUE
	
  private:
	CString *m_pCtmp;			// (uses new) just a scratch buffer
	int m_cShooters;			// a count of troubleshooting belief networks.  JM strongly
								//	suspects 3/98 that in Local TS it never gets past 1.
								// >>> presumably count of m_aShooters, so why don't we just
								//	use GetCount(), anyway?.
	int m_iShooter;				// index of a troubleshooting belief network.    JM strongly
								//	suspects 3/98 that in Local TS it is always 0.
								// presumably index into m_aShooters.
	CMap<int, int, int, int>m_SkippedTwice;
	CArray<TShooter, TShooter &> m_aShooters;
	NID m_cnid;				// number of positions used in m_rgnid
	NID m_rgnid[64];		// node numbers of recommendations the user has visited
	NID m_question_rgnid[64]; // new recommendations.  We only care about the first 
							//	recommendation not already offered and skipped.
	UINT m_cur_rec;			// index into m_rgnid.  We use this to loop through as we write
							//	the "visited node table"
	UINT m_max_rec;			// number of defined values in m_question_rgnid
	UINT m_cur_rec_inid;

	// The next 3 variables deal with states of a single node N, typically m_rgnid[m_cur_rec]
	UINT m_cur_state_set;	// state value of node N
	UINT m_cur_cst;			// count of states of node N
	UINT m_cur_ist;			// index into states of node N, used to build a list of radio 
							//	buttons and log entries.

	UINT m_problemAsk;		// >>> A thinly disguised Boolean. >>>(I think) something to do with
							// whether we return data on the problem node (vs. state-dependent
							// data) JM 10/30//97
	TCHAR m_problem[200];	// once a problem is chosen, this is where we put the associated
							//	text description of the problem. Full text description plus
							//	a hidden data field.
	NID  m_firstNid;
	UINT m_firstSet;
	TCHAR m_tstype[30];		// symbolic name of troubleshooter
	//
	// now in the CSniffedContainer object
	/*
	IDH m_idhSniffedRecommendation;	// if a recommendation from a sniffer overrides normal
							// method of getting a recommendation, here's where we store it.
							// Otherwise, nidNil+idhFirst.
	*/
	
  protected:
   	TSZ		m_szFile;
	FILE*	m_pfile;
	BOOL	m_bHttp;
	CHAR	m_szTemp1[MAXBUF];
	CString *m_pCtxt;			// points to a buffer passed in to constructor.  This is where
								// we build the HTML to pass back to the user
	TCHAR	m_currdir[MAXBUF];
	CString	*m_pResult;			// A string to indicate (in the log) a FINAL result of a
								// Troubleshoot session.  e.g. ">Success", ">Nothing Else",
								//	">Anything Else?", ">Help Elsewhere"
	CString *m_pSearchStr;		// a string consisting of the search words implied by our node 
								//	choices, separated by "and" or "or" (depending on the 
								//	value of m_pBESearch->IsAND).  Used as part of Back End 
								//	Search redirection.  >>> Probably irrelevant to Local TS, 
								//	which doesn't use BES
	BCache	*m_api;				// cache for associated belief network
	BOOL	m_bService;
	NID		m_nidPreloadCheck;
	CNID	m_acnid;			// count of nodes at *m_api
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\apgtshtx.cpp ===
//
// MODULE: APGTSHTX.CPP
//
// PURPOSE: Template file decoder
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
//
// ORIGINAL DATE: 8-2-96
//
// NOTES:
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.15	8/15/96		VM		New htx format
// V0.2		6/4/97		RWM		Local Version for Memphis
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//
#include "stdafx.h"
//#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <search.h>
#include <dos.h>
#include <ctype.h>
#include <limits.h>
#include <time.h>

#include "apgts.h"
#include "ErrorEnums.h"
#include "bnts.h"
#include "BackupInfo.h"
#include "cachegen.h"
#include "apgtsinf.h"
#include "apgtscmd.h"
#include "apgtshtx.h"

#include "TSHOOT.h"

#include "chmread.h"
//
//
CHTMLInputTemplate::CHTMLInputTemplate(const TCHAR *filename)
{
	// initialize a few things
	m_dwErr = 0;
	m_cur_stack_count=0;
	m_command_start = NULL;
	_tcscpy(m_filename,filename);
	m_cHeaderItems = 0;
	m_infer = NULL;
	m_strResPath = _T("");
}

//
//
CHTMLInputTemplate::~CHTMLInputTemplate()
{
	Destroy();	
}

//
// must be locked to use
//
VOID CHTMLInputTemplate::SetInfer(CInfer *infer, TCHAR *vroot)
{
	m_infer = infer;
	_tcscpy(m_vroot, vroot);
}
//
//
DWORD CHTMLInputTemplate::Initialize(LPCTSTR szResPath, CString strFile)
{
	CHAR *filestr;

	m_dwErr = 0;
	m_strResPath = szResPath;
	m_strFile = strFile;

	if (strFile.GetLength())
	{
		// m_filename is CHM file path and name
		// and strFile - file name within CHM
		if (S_OK != ::ReadChmFile(m_filename, strFile, (void**)&filestr, &m_dwSize))
		{
			m_dwErr = EV_GTS_ERROR_ITMPL_ENDMISTAG;//fix!
			return m_dwErr;
		}
	}
	else
	{
		// m_filename is a free standing file
		DWORD nBytesRead;
		HANDLE hFile;
		BOOL bResult;
		hFile = CreateFile(	m_filename,
							GENERIC_READ,
							FILE_SHARE_READ,
							NULL,
							OPEN_EXISTING,
							FILE_ATTRIBUTE_NORMAL,
							NULL );

		if (hFile == INVALID_HANDLE_VALUE)
		{
			//???
			//ReportError(TSERR_RESOURCE);

			m_dwErr = EV_GTS_ERROR_ITMPL_ENDMISTAG;//fix!
			return m_dwErr;
		}

		m_dwSize = GetFileSize(hFile, NULL);
		filestr = (CHAR *)malloc(m_dwSize+1);
		
		if (!((m_dwSize != 0xFFFFFFFF) && (m_dwSize != 0)) || filestr == NULL)
		{
			CloseHandle(hFile);
			m_dwErr = EV_GTS_ERROR_ITMPL_ENDMISTAG;//fix!
			return m_dwErr;
		}

		bResult = ReadFile(hFile, filestr, m_dwSize, &nBytesRead, NULL);
		
		if(!(bResult && nBytesRead == m_dwSize))
		{
			CloseHandle(hFile);
			free(filestr);
			m_dwErr = EV_GTS_ERROR_ITMPL_ENDMISTAG;//fix!
			return m_dwErr;
		}

		CloseHandle(hFile);
		hFile = NULL;
	}

	filestr[m_dwSize] = '\0';

#ifdef _UNICODE
	WCHAR *wfilestr = (WCHAR *)malloc((m_dwSize + 1) * sizeof (WCHAR));
	WCHAR *wchopstr = (WCHAR *)malloc((m_dwSize + 1) * sizeof (WCHAR));
	MultiByteToWideChar( CP_ACP, 0, filestr, -1, wfilestr, m_dwSize );
	MultiByteToWideChar( CP_ACP, 0, filestr, -1, wchopstr, m_dwSize );
	m_startstr = wfilestr;
	m_chopstr = wchopstr;
#else
	m_startstr = filestr;
	m_chopstr = (CHAR *)malloc(m_dwSize+1);
	strcpy(m_chopstr, filestr);
#endif
	
	// get locations of start and end blocks
	ScanFile();

	// copy blocks into ram for speed
	BuildInMem();
	
	// free memory
	free(filestr);

#ifdef _UNICODE
	free(wfilestr);
#endif
	free(m_chopstr);

	return m_dwErr;
}

//
//
VOID CHTMLInputTemplate::Destroy()
{
	HTXCommand *command, *nextcommand;

	// free holders
	command = m_command_start;
	nextcommand = command;
	while (command != NULL) {
		nextcommand = command->GetNext();
		delete command;
		command = nextcommand;
	}
}

//
//
DWORD CHTMLInputTemplate::Reload()
{
	Destroy();
	return Initialize((LPCTSTR) m_strResPath, m_strFile);
}

//
//
void CHTMLInputTemplate::ScanFile()
{
	UINT start, end;
	TCHAR *ptr, *sptr, *eptr, var_name[30];
	HTXCommand *tmpCommand, *prevCommand;
	UINT var_index;

	sptr = m_chopstr;
	m_cur_command = new HTXCommand(HTX_TYPESTART,_T(""));
	end = start = 0;
	m_cur_command->SetStart(start);
	m_cur_command->SetEnd(end);
	
	m_command_start = m_cur_command;

	// this is bad: if the user does not terminate each command on a separate line
	// the file will misbehave, should at least write out a warning or something...

	sptr = _tcstok(sptr, _T("\r\n"));
	if (sptr)
	{
		do
		{
			if ((sptr = _tcsstr(sptr,HTX_COMMAND_START)) != NULL)
			{
				if ((ptr = _tcsstr(sptr,HTX_ENDIFSTR))!=NULL)
				{
					tmpCommand = new HTXCommand(HTX_TYPEENDIF,HTX_ENDIFSTR);
					prevCommand = Pop();
					if (prevCommand->GetType() != HTX_TYPEIF)
					{
						m_dwErr = EV_GTS_ERROR_ITMPL_IFMISTAG;
						break;
					}
					prevCommand->SetEndIf(tmpCommand);
				}
				else if ((ptr = _tcsstr(sptr,HTX_ENDFORSTR))!=NULL)
				{
					tmpCommand = new HTXCommand(HTX_TYPEENDFOR,HTX_ENDFORSTR);
					prevCommand = Pop();
					if (prevCommand->GetType() != HTX_TYPEFORANY)
					{
						m_dwErr = EV_GTS_ERROR_ITMPL_FORMISTAG;
						break;
					}
					prevCommand->SetEndFor(tmpCommand);
				}
				else if ((ptr = _tcsstr(sptr,HTX_ELSESTR))!=NULL)
				{
					tmpCommand = new HTXCommand(HTX_TYPEELSE,HTX_ELSESTR);
					prevCommand = Pop();
					if (prevCommand->GetType() != HTX_TYPEIF)
					{
						m_dwErr = EV_GTS_ERROR_ITMPL_IFMISTAG;
						break;
					}
					prevCommand->SetElse(tmpCommand);
					Push(prevCommand);
				}
				else if ((ptr = _tcsstr(sptr,HTX_IFSTR))!=NULL)
				{
					// get the variable
					ptr = _tcsninc(ptr, _tcslen(HTX_IFSTR));
					if( _stscanf(ptr,_T("%s"),var_name) <= 0)
							m_dwErr = EV_GTS_ERROR_ITMPL_IFMISTAG;
					if ((var_index = CheckVariable(var_name)) == FALSE )
					{
						m_dwErr = EV_GTS_ERROR_ITMPL_VARIABLE;
						break;
					}
					tmpCommand = new HTXIfCommand(HTX_TYPEIF,HTX_IFSTR,var_index);
					Push(tmpCommand);
				}
				else if ((ptr = _tcsstr(sptr,HTX_FORANYSTR))!=NULL)
				{
					// get variable
					ptr = _tcsninc(ptr, _tcslen(HTX_FORANYSTR));
					if( _stscanf(ptr,_T("%s"),var_name) <= 0)
							m_dwErr = EV_GTS_ERROR_ITMPL_FORMISTAG;
					if ((var_index = CheckVariable(var_name)) == FALSE )
					{
						m_dwErr = EV_GTS_ERROR_ITMPL_VARIABLE;
						break;
					}
					tmpCommand = new HTXForCommand(HTX_TYPEFORANY,HTX_FORANYSTR, var_index);
					Push(tmpCommand);
				}
				else if ((ptr = _tcsstr(sptr,HTX_DISPLAYSTR))!=NULL)
				{
					// get variable
					ptr = _tcsninc(ptr, _tcslen(HTX_DISPLAYSTR));
					if( _stscanf(ptr,_T("%s"),var_name) <= 0)
							m_dwErr = EV_GTS_ERROR_ITMPL_FORMISTAG;
					if ((var_index = CheckVariable(var_name)) == FALSE )
					{
						m_dwErr = EV_GTS_ERROR_ITMPL_VARIABLE;
						break;
					}
					tmpCommand = new HTXDisplayCommand(HTX_TYPEDISPLAY,HTX_DISPLAYSTR, var_index);
				}
				else if ((ptr = _tcsstr(sptr, HTX_RESOURCESTR)) != NULL)
				{
					ptr = _tcsninc(ptr, _tcslen(HTX_RESOURCESTR));
					if (_stscanf(ptr, _T("%s"), var_name) <= 0)
						m_dwErr = EV_GTS_ERROR_ITMPL_FORMISTAG;
					if ((var_index = CheckVariable(var_name)) == FALSE)
					{
						m_dwErr = EV_GTS_ERROR_ITMPL_VARIABLE;
						break;
					}
					m_cHeaderItems++;
					tmpCommand = new HTXResourceCommand(HTX_TYPERESOURCE, HTX_RESOURCESTR);
					((HTXResourceCommand *) tmpCommand)->GetResName(var_name);
				}
				else
					continue;

				// get the command terminator
				if ((eptr = _tcsstr(ptr,HTX_COMMAND_END)) == NULL)
				{
					m_dwErr = EV_GTS_ERROR_ITMPL_ENDMISTAG;
					eptr = ptr; // try to recover
				}
				eptr = _tcsninc(eptr, _tcslen(HTX_COMMAND_END));

				if (tmpCommand == NULL)
				{
					m_dwErr = EV_GTS_ERROR_ITMPL_NOMEM;
					return;
				}

				// Add command to command list
				if (m_command_start == NULL)
				{
					m_command_start = tmpCommand;
					m_cur_command = tmpCommand;
				}
				else
				{
					m_cur_command->SetNext(tmpCommand);
					m_cur_command = tmpCommand;
				}

				CString strCHM = ::ExtractCHM(m_filename);
				tmpCommand->GetResource(m_strResPath, strCHM);

				start = (UINT)(sptr - m_chopstr); // / sizeof (TCHAR);
				end = (UINT)(eptr - m_chopstr); // / sizeof (TCHAR);

				tmpCommand->SetStart(start);
				tmpCommand->SetEnd(end);
			}
		} while ((sptr = _tcstok(NULL, _T("\r\n"))) != NULL);
	}
	

	if (m_cur_stack_count > 0) // missing and endfor or an endif
		m_dwErr = EV_GTS_ERROR_ITMPL_ENDMISTAG;
}

/*
 * METHOD:	BuildInMem
 *
 * PURPOSE:	This method will read the HTML between commands (after) and associate
 *			it with the command. As a command is executed the HTML after the
 *			command is printed
 *
 */
UINT CHTMLInputTemplate::BuildInMem()
{
	HTXCommand *cur_com, *last_command;

	if (m_dwErr)
		return (TRUE);

	// copy strings from file to
	// note duplication of effort (before and after strings may be same string)
	cur_com = m_command_start;
	last_command = cur_com;
	while (cur_com != NULL) {			
	    if (cur_com->GetNext() == NULL) {
			if (cur_com->ReadAfterStr(cur_com->GetEnd(), m_dwSize, m_startstr))
				return (m_dwErr = EV_GTS_ERROR_ITMPL_NOMEM);
		}
		else {
			if (cur_com->ReadAfterStr(cur_com->GetEnd(), cur_com->GetNext()->GetStart(), m_startstr))
				return (m_dwErr = EV_GTS_ERROR_ITMPL_NOMEM);
		}
		last_command = cur_com;
		cur_com = cur_com->GetNext();
	}
	return (FALSE);
}

//
//
bool CHTMLInputTemplate::IsFileName(TCHAR *name)
{
	bool bFileName;
	if (name[0] != _T('$'))
		bFileName = false;
	else if (NULL == _tcsstr(name, _T(".")))
		bFileName = false;
	else
		bFileName = true;
	return bFileName;
}
/*
 * METHOD:	CheckVariable
 *
 * PURPOSE:	This routine will check to see if the variable name is a valid one
 *			and if it is will return a UINT that represents that variable.
 *			Integers are used in other routines when refering to a variable (for
 *			speed).
 *
 */

UINT CHTMLInputTemplate::CheckVariable(TCHAR *var_name)
{
	if (!_tcsncmp(DATA_PROBLEM_ASK,var_name, _tcslen(var_name))) {
		return (PROBLEM_ASK_INDEX);
	}
	else if (!_tcsncmp(DATA_RECOMMENDATIONS,var_name, _tcslen(var_name))) {
		return (RECOMMENDATIONS_INDEX);
	}
	else if (!_tcsncmp(DATA_QUESTIONS,var_name, _tcslen(var_name))) {
		return (QUESTIONS_INDEX);
	}
	else if (!_tcsncmp(DATA_STATE,var_name, _tcslen(var_name))) {
		return (STATE_INDEX);
	}
	else if (!_tcsncmp(DATA_BACK,var_name, _tcslen(var_name))) {
		return (BACK_INDEX);
	}
	else if (!_tcsncmp(DATA_TROUBLE_SHOOTERS, var_name, _tcslen(var_name))) {		
		return (TROUBLE_SHOOTER_INDEX);
	}
	else if (IsFileName(var_name)) {
		return (RESOURCE_INDEX);
	}
	else return (FALSE);
}




//
//
UINT CHTMLInputTemplate::GetStatus()
{
	return (m_dwErr);
}

CHTMLInputTemplate::Push(HTXCommand *command)
{
	if (m_cur_stack_count >9)
		return(FALSE);
	m_command_stack[m_cur_stack_count] = command;
	m_cur_stack_count++;
	return(TRUE);
}

HTXCommand *CHTMLInputTemplate::Pop()
{
	if (m_cur_stack_count <= 0)
		return(NULL);
	return(m_command_stack[--m_cur_stack_count]);
}

//
//
HTXCommand *CHTMLInputTemplate::GetFirstCommand()
{
	return(m_command_start);
}

/*
 * ROUTINE:	SetType
 *
 * PURPOSE:	This set the TroubleShooter Type in the template
 *			The type field is printed after the header information
 *			
 */
void CHTMLInputTemplate::SetType(LPCTSTR type)
{
	_stprintf(m_tstype, _T("%s"),type);
}
/*
 * ROUTINE:	Print
 *
 * PURPOSE: Prints out the Template. This functions executes the
 *			commands in the template and generates the output page.
 *
 */
CHTMLInputTemplate::Print(UINT nargs, CString *cstr)
{
	HTXCommand *cur_com;
	CString strTxt;

	if (m_dwErr){
		strTxt.LoadString(IDS__ER_HTX_PARSE);
		*cstr += strTxt;
		return(FALSE);
	}

	cur_com = m_command_start;  // get the start command
	cur_com = cur_com->Execute(cstr,m_infer);  // This prints the header

	if (m_cHeaderItems)
	{	// The first command prints script.  Don't start the form.
		int count = m_cHeaderItems;
		do
		{
			cur_com = cur_com->GetNext();
			cur_com = cur_com->Execute(cstr, m_infer);
			count--;
		} while (count > 0);
		AfxFormatString1(strTxt, IDS_FORM_START, m_tstype);
		*cstr += strTxt;
		cur_com = cur_com->GetNext();
	}
	else
	{
		AfxFormatString1(strTxt, IDS_FORM_START, m_tstype);
		*cstr += strTxt;
		cur_com = cur_com->GetNext();
	}
	while (cur_com != NULL) {
		cur_com = cur_com->Execute(cstr, m_infer);
		cur_com = cur_com->GetNext();
	}
	return(TRUE);
}
		
// for testing
//

void CHTMLInputTemplate::DumpContentsToStdout()
{
	HTXCommand *cur_com;

	cur_com = GetFirstCommand();
	while( cur_com != NULL){
		_tprintf(_T("(%d) before: [%s]\n"), cur_com->GetType(), cur_com->GetBeforeStr());
		_tprintf(_T("(%d) after: [%s]\n"), cur_com->GetType(), cur_com->GetAfterStr());
		_tprintf(_T("\n"));
		cur_com = cur_com->GetNext();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\backupinfo.h ===
//
// MODULE: BackupInfo.cpp
//
// PURPOSE: Contains infomation that is used when the previous button is selected.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 9/5/97
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.2		6/4/97		RM		Local Version for Memphis
// V0.3		3/24/98		JM		Local Version for NT5
//

#ifndef __BACKUPINFO_H_
#define __BACKUPINFO_H_ 1

class CBackupInfo
{
public:
	enum { INVALID_BNTS_STATE = 32000 };
public:
	CBackupInfo();

	bool Check(int State);
	void SetState(int Node, int State);
	bool InReverse() {return m_bBackingUp;};

	void Clear();

protected:

	bool m_bBackingUp;
	bool m_bProblemPage;

	int m_State;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\backupinfo.cpp ===
//
// MODULE: BackupInfo.cpp
//
// PURPOSE: Contains infomation that is used when the previous button is selected.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 9/5/97
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.2		6/4/97		RM		Local Version for Memphis
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//
#include "stdafx.h"
#include "BackupInfo.h"

CBackupInfo::CBackupInfo()
{
	Clear();
	return;
}

void CBackupInfo::Clear()
{
	m_bBackingUp = false;
	m_bProblemPage = true;
	m_State = 0;
	return;
}

bool CBackupInfo::Check(int State)
{
	bool bCheckIt;
	if (m_bBackingUp && m_State == State)
		bCheckIt = true;
	else
		bCheckIt = false;
	return bCheckIt;
}

void CBackupInfo::SetState(int Node, int State)
{
	m_bBackingUp = true;
	if (INVALID_BNTS_STATE == State)
	{
		m_bProblemPage = true;
		m_State = Node;
	}
	else
	{
		m_bProblemPage = false;
		m_State = State;
	}
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\basicexception.h ===
//
// MODULE: BASICEXCEPTION.H
//
// PURPOSE:  Exception that will be caught in ApgtsX2Ctrl::RunQuery.
//           This exception is thrown from most of the Trouble 
//           shooter functions.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 6/4/96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		3/24/98		JM		Local Version for NT5

#ifndef __BASICEXCEPTION_H_
#define __BASICEXCEPTION_H_ 1

class CBasicException
{
public:
	CBasicException();
	~CBasicException();

	DLSTATTYPES m_dwBErr;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\basicexception.cpp ===
//
// MODULE:  BASICEXCEPTION.CPP
//
// PURPOSE:  Exception that will be caught in ApgtsX2Ctrl::RunQuery.
//           This exception is thrown from most of the Trouble 
//           shooter functions.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 6/4/96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//
#include "stdafx.h"
#include "ErrorEnums.h"
#include "BasicException.h"

CBasicException::CBasicException()
{
	m_dwBErr = LTSC_OK;
	return;
}

CBasicException::~CBasicException()
{
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\apgtsqry.cpp ===
//
// MODULE: APGTSQRY.CPP
//
// PURPOSE: Implementation file for PTS Query Parser
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
//
// NOTES:
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.2		6/4/97		RWM		Local Version for Memphis
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//

//#include "windows.h"
#include "stdafx.h"

#include "time.h"

#include "apgts.h"
#include "bnts.h"
#include "BackupInfo.h"
#include "cachegen.h"
#include "apgtsinf.h"
#include "apgtscmd.h"
#include "apgtshtx.h"
#include "apgtscls.h"

#include "ErrorEnums.h"
#include "BasicException.h"
#include "HttpQueryException.h"
#include "Functions.h"

#include "BackupInfo.h"

#include <string.h>
#include <stdlib.h>

#include "LaunchServ.h"

//
//
CHttpQuery::CHttpQuery()
{
	m_pvarCmds = NULL;
	m_pvarVals = NULL;
	m_strCmd1 = _T("");
	m_strVal1 = _T("");
	m_CurrentUse = 0;
	m_Size = 0;
	m_bReverseStack = false;
	m_nStatesFromServ = 0;
}

//
//
CHttpQuery::~CHttpQuery()
{
}

void CHttpQuery::ThrowBadParams(CString &str)
{
	CHttpQueryException *pExc = new CHttpQueryException;
#ifndef __DEBUG_HTTPQUERY_
	pExc->m_strError = _T("Script Error");
#else
	pExc->m_strError = str;
#endif
	throw pExc;
	return;
}

void CHttpQuery::Initialize(const VARIANT FAR& varCmds, const VARIANT FAR& varVals, short size)
{
#ifdef __DEBUG_HTTPQUERY_
	AfxMessageBox(_T("Cmd Variant Types:\n\n") + DecodeVariantTypes(varCmds.vt), MB_ICONINFORMATION);
	AfxMessageBox(_T("Value Variant Types:\n\n") + DecodeVariantTypes(varVals.vt), MB_ICONINFORMATION);
#endif
	const VARIANT FAR *pVarCmds;
	const VARIANT FAR *pVarVals;
	if (VT_BYREF  == (VT_BYREF & varCmds.vt) &&
			VT_VARIANT == (VT_VARIANT & varCmds.vt))
	{
		if (VT_ARRAY == (VT_ARRAY & varCmds.vt))
			pVarCmds = &varCmds;
		else
			pVarCmds = varCmds.pvarVal;
	}
	else
	{
		pVarCmds = NULL;
		CString str = _T("Cmd parameters from VB were not a variant or not by ref.");
		ASSERT(FALSE);
		TRACE(_T("%s\n"), str);
		ThrowBadParams(str);
	}
	if (VT_BYREF  == (VT_BYREF & varVals.vt) &&
			VT_VARIANT == (VT_VARIANT & varVals.vt))
	{
		if (VT_ARRAY == (VT_ARRAY & varVals.vt))
			pVarVals = &varVals;
		else
			pVarVals = varVals.pvarVal;
	}
	else
	{
		pVarVals = NULL;
		CString str = _T("Cmd parameters from VB were not a variant or not by ref.");
		ASSERT(FALSE);
		TRACE(_T("%s\n"), str);
		ThrowBadParams(str);
	}
	if (VT_BYREF  != (VT_BYREF & pVarCmds->vt) ||
			VT_ARRAY != (VT_ARRAY & pVarCmds->vt) ||
			VT_VARIANT != (0xFFF & pVarCmds->vt))
	{
		CString str = _T("Wrong Cmd parameters passed from VB.");
		ASSERT(FALSE);
		TRACE(_T("%s\n"), str);
		ThrowBadParams(str);
	}
	if (VT_BYREF  != (VT_BYREF & pVarVals->vt) ||
			VT_ARRAY != (VT_ARRAY & pVarVals->vt) ||
			VT_VARIANT != (0xFFF & pVarVals->vt))
	{
		CString str = _T("Wrong Cmd parameters passed from VB.");
		ASSERT(FALSE);
		TRACE(_T("%s\n"), str);
		ThrowBadParams(str);
	}
#ifdef __DEBUG_HTTPQUERY_
	AfxMessageBox(_T("Cmd Variant Types:\n\n") + DecodeVariantTypes(pVarCmds->vt), MB_ICONINFORMATION);
	AfxMessageBox(_T("Value Variant Types:\n\n") + DecodeVariantTypes(pVarVals->vt), MB_ICONINFORMATION);
#endif
	SAFEARRAY *pArrCmds = *(pVarCmds->pparray);
	SAFEARRAY *pArrVals = *(pVarVals->pparray);
#ifdef __DEBUG_HTTPQUERY_
	CString strSafe;
	strSafe.Format("Cmd Safe Array\n\nDim: %d\nfeatures:\n%s\nSize of the Elements: %ld",
		pArrCmds->cDims, (LPCTSTR) DecodeSafeArray(pArrCmds->fFeatures),
		pArrCmds->cbElements);
	AfxMessageBox(strSafe, MB_ICONINFORMATION);
	strSafe.Format("Val Safe Array\n\nDim: %d\nfeatures:\n%s\nSize of the Elements: %ld",
		pArrVals->cDims, (LPCTSTR) DecodeSafeArray(pArrVals->fFeatures),
		pArrVals->cbElements);
	AfxMessageBox(strSafe, MB_ICONINFORMATION);
#endif	
	if (0 != pArrCmds->rgsabound[0].lLbound || 0 != pArrVals->rgsabound[0].lLbound)
	{
		CString str = _T("Wrong Cmd parameters passed from VB.  Lower bounds are wrong.");
		ASSERT(FALSE);
		TRACE(_T("%s\n"), str);
		ThrowBadParams(str);
	}
	if (pArrCmds->rgsabound[0].cElements != pArrVals->rgsabound[0].cElements)
	{
		CString str = _T("Wrong Cmd parameters passed from VB.  Cmds upperbound != Vals upperbound.");
		ASSERT(FALSE);
		TRACE(_T("%s\n"), str);
		ThrowBadParams(str);
	}
	m_Size = size;
#ifdef __DEBUG_HTTPQUERY_
	CString str;
	str.Format("Size:  %d", m_Size);
	AfxMessageBox(str, MB_ICONINFORMATION);
#endif
	m_pvarCmds = (VARIANT *) pArrCmds->pvData;
	m_pvarVals = (VARIANT *) pArrVals->pvData;
	if (0 != m_Size)
	{
		if (m_pvarCmds->vt != VT_BSTR || m_pvarVals->vt != VT_BSTR)
		{
			CString str;
			str.Format(_T("Wrong Cmd parameters passed from VB.  Array of unexpected type.\n\n")
				_T("Cmd Type: %s\nVal Type: %s"),
				(LPCTSTR) DecodeVariantTypes(m_pvarCmds->vt),
				(LPCTSTR) DecodeVariantTypes(m_pvarVals->vt));
			ASSERT(FALSE);
			TRACE(_T("%s\n"), str);
			ThrowBadParams(str);
		}
	}	
	CString strC = m_pvarCmds[0].bstrVal;
	CString strD = m_pvarVals[0].bstrVal;
	if (strC != m_strCmd1 || strD != m_strVal1)
		m_State.RemoveAll();
	m_strCmd1 = strC;
	m_strVal1 = strD;
	return;
}

BOOL CHttpQuery::StrIsDigit(LPCTSTR pSz)
{
	BOOL bRet = TRUE;
	while (*pSz)
	{
		if (!_istdigit(*pSz))
		{
			bRet = FALSE;
			break;
		}
		pSz = _tcsinc(pSz);
	}
	return bRet;
}

void CHttpQuery::FinishInit(BCache *pApi, const VARIANT FAR& varCmds, const VARIANT FAR& varVals)
{
	ASSERT(pApi);
	ASSERT(m_Size > 0);
	CNode node;
	CString str;
	if (!pApi)
		return;
	if (!pApi->BValidNet())
		pApi->ReadModel();
	m_bReverseStack = false;
	for (int x = 1; x < m_Size; x++)
	{		
		// Read the command.
		str = m_pvarCmds[x].bstrVal;
		if (StrIsDigit((LPCTSTR) str))
			node.cmd = _ttoi(str);
		else if (0 == _tcscmp(CHOOSE_TS_PROBLEM_NODE, (LPCTSTR) str))
			node.cmd = pApi->CNode() + idhFirst;
		else if (0 == _tcscmp(TRY_TS_AT_MICROSOFT_SZ, (LPCTSTR) str))
			node.cmd = TRY_TS_AT_MICROSOFT_ID;
		else
		{
			NID nid = pApi->INode((LPCTSTR) str);
			if (nid == -1)
			{
				// Invalid node name.  This also throws suspicion on anything further
				//	down the line.  Just break out of the loop.
				break;
			}
			node.cmd = nid + idhFirst;
		}
		// Read the value.
		str = m_pvarVals[x].bstrVal;
		if (StrIsDigit((LPCTSTR) str))
			node.val = _ttoi(str);
		else
		{
			NID nid = pApi->INode((LPCTSTR) str);
			if (nid == -1)
			{
				// Invalid node name.  This also throws suspicion on anything further
				//	down the line.  Just break out of the loop.
				break;
			}
			node.val = nid + idhFirst;
		}
		m_State.Push(node);
	}
	return;
}

void CHttpQuery::PushNodesLastSniffed(const CArray<int, int>& arr)
{
	for (int i = 0; i < arr.GetSize(); i++)
	{
		CNode node;
		node.cmd = idhFirst + arr[i];
		node.val = 0;
		node.sniffed = true;
		m_State.Push(node);
	}
}

void CHttpQuery::FinishInitFromServ(BCache *pApi, ILaunchTS *pLaunchTS)
{
	ASSERT(pApi);
	CNode node;
	CString str;
	HRESULT hRes;
	HRESULT hResNode;
	HRESULT hResState;
	OLECHAR *poleProblem;
	OLECHAR *poleNode;
	OLECHAR *poleState;
	OLECHAR *poleMachine;
	OLECHAR *polePNPDevice;
	OLECHAR *poleGuidClass;
	OLECHAR *poleDeviceInstance;

	///////////////////////////////////////////////////////////
	// obtaining Machine, PNPDevice, GuidClass, DeviceInstance
	//
	hRes = pLaunchTS->GetMachine(&poleMachine);

	if (S_FALSE == hRes || FAILED(hRes))
		return;
	m_strMachineID = poleMachine;
	::SysFreeString(poleMachine);
	
	hRes = pLaunchTS->GetPNPDevice(&polePNPDevice);
	if (S_FALSE == hRes || FAILED(hRes))
		return;
	m_strPNPDeviceID = polePNPDevice;
	::SysFreeString(polePNPDevice);

	hRes = pLaunchTS->GetGuidClass(&poleGuidClass);
	if (S_FALSE == hRes || FAILED(hRes))
		return;
	m_strGuidClass = poleGuidClass;
	::SysFreeString(poleGuidClass);
	
	hRes = pLaunchTS->GetDeviceInstance(&poleDeviceInstance);
	if (S_FALSE == hRes || FAILED(hRes))
		return;
	m_strDeviceInstanceID = poleDeviceInstance;
	::SysFreeString(poleDeviceInstance);
	//
	////////////////////////////////////////////////////////////

	if (!pApi)
		return;
	if (!pApi->BValidNet())
		pApi->ReadModel();
	m_Size = 1;	// I believe this accounts for the troubleshooting network name (JM 3/98)
	m_nStatesFromServ = 0;
	
	// The order that the nodes are set in the inference engine is important.
	// >>> I (JM 3/14/98) don't understand the rest of this comment:
	// Need the rest of the nodes inverted on the stack.
	// The buttons can not be inverted here.  When they are the back button
	// stops working.
	hRes = pLaunchTS->GetProblem(&poleProblem);
	if (S_FALSE == hRes || FAILED(hRes))
		return;
	str = poleProblem;
	SysFreeString(poleProblem);
	node.cmd = pApi->CNode() + idhFirst;	// Sets the problem state.
	if (StrIsDigit((LPCTSTR) str))
		node.val = _ttoi(str);
	else
	{
		NID nidProblem = pApi->INode((LPCTSTR) str);
		if (nidProblem == static_cast<NID>(-1))
		{
			// The specified problem node doesn't exist. Ignore it and any other nodes
			//	that follow.
			return;
		}

		pApi->SetRunWithKnownProblem(true);
		pApi->BNodeSetCurrent( nidProblem );
		if (pApi->ELblNode() != ESTDLBL_problem )
		{
			// The specified problem node exists, but it's not a problem node.
			//	Ignore it and any other nodes that follow.
			return;
		}

		IDH idhProblem = nidProblem + idhFirst;
		node.val = idhProblem;
	}
	m_State.Push(node);
	m_Size++;
	m_aStatesFromServ[m_nStatesFromServ] = node;
	m_nStatesFromServ++;

	int iAnyNode = 0;
	do
	{
		hResNode = pLaunchTS->GetNode((short)iAnyNode, &poleNode);
		if (FAILED(hResNode) || S_FALSE == hResNode)
			break;
		str = poleNode;
		SysFreeString(poleNode);
		if (StrIsDigit((LPCTSTR) str))
			node.cmd = _ttoi(str);
		else
			node.cmd = pApi->INode((LPCTSTR) str) + idhFirst;

		hResState = pLaunchTS->GetState((short)iAnyNode, &poleState);
		if (FAILED(hResState) || S_FALSE == hResState)
			break;;
		str = poleState;
		SysFreeString(poleNode);
		if (StrIsDigit((LPCTSTR) str))
			node.val = _ttoi(str);
		else
			node.val = pApi->INode((LPCTSTR) str) + idhFirst;
		m_State.Push(node);
		m_Size++;
		m_aStatesFromServ[m_nStatesFromServ] = node;
		m_nStatesFromServ++;
		iAnyNode++;
	} while (true);

	return;
}

// Restore states to where CHttpQuery::FinishInitFromServ() left them
void CHttpQuery::RestoreStatesFromServ()
{
	UINT i;

	for (i=0; i < m_nStatesFromServ; i++)
		m_State.Push(m_aStatesFromServ[i]);
}

//
//
BOOL CHttpQuery::GetFirst(CString &strPut, CString &strValue)
{
	BOOL bStatus = FALSE;	
	if (0 < m_Size)
	{
		bStatus = TRUE;
		strPut = m_strCmd1;
		strValue = m_strVal1;
		m_CurrentUse = 0;
	}
	m_CurrentUse++;
	return bStatus;
}

void CHttpQuery::SetFirst(CString &strCmd, CString &strVal)
{
	m_Size = 1;
	m_strCmd1 = strCmd;
	m_strVal1 = strVal;
	return;
}

//
//
BOOL CHttpQuery::GetNext(int &refedCmd, int &refedValue /*TCHAR *pCmd, TCHAR *pValue*/ )
{
	BOOL bStatus;
	CNode node;
	// The stack direction was made to be reversable
	// to support setting many nodes by an NT5 application using the TS Launcher.
	if (false == m_bReverseStack)	
		bStatus = m_State.GetAt(m_CurrentUse, node);
	else
		bStatus = m_State.GetAt(m_Size - m_CurrentUse, node);
	refedCmd = node.cmd;
	refedValue = node.val;
	m_CurrentUse++;
	return bStatus;
}

void CHttpQuery::SetStackDirection()
{
	if ((m_Size - m_CurrentUse) > 1)
		m_bReverseStack = true;
	else
		m_bReverseStack = false;
}
/*
BOOL CHttpQuery::GetValue(int &Value, int index)
{
	BOOL bRet = TRUE;
	CNode node;
	if (m_State.GetAt(index, node))
		Value = node.val;
	else
	{
		Value = NULL;
		bRet = FALSE;
	}
	return bRet;
}
*/
BOOL CHttpQuery::GetValue1(int &Value)
{
	BOOL bRet = TRUE;
	CNode node;
	if (false == m_bReverseStack)
	{
		if (m_State.GetAt(1, node))
		{
			Value = node.val;
		}
		else
		{
			Value = NULL;
			bRet = FALSE;
		}
	}
	else
	{
		if (m_State.GetAt(m_Size - 1, node))
		{
			Value = node.val;
		}
		else
		{
			Value = NULL;
			bRet = FALSE;
		}
	}
	return bRet;
}

CString CHttpQuery::GetTroubleShooter()
{
	CString str = m_pvarVals[0].bstrVal;
	return str;
}

CString CHttpQuery::GetFirstCmd()
{
	CString str = m_pvarCmds[0].bstrVal;
	return str;
}

BOOL CHttpQuery::BackUp(BCache *pApi, APGTSContext *pCtx)
{
	ASSERT(pApi);
	CNode node;
	BOOL bBack = FALSE;
	if (!m_State.Empty())
	{
		bBack = TRUE;
		node = m_State.Pop();
		if (!m_State.Empty())
		{	// Can not uninstantiate the problem page, it is not a real node.
			// Remove the node from the bnts network.
			if (node.val < 100)		
				pApi->RemoveRecommendation(node.cmd - idhFirst);
			if (node.sniffed) // skip all sniffed nodes by recursive call of the function
				return BackUp(pApi, pCtx);
			pCtx->BackUp(node.cmd - idhFirst, node.val);
		}
		else
		{
			pApi->RemoveRecommendation(node.val - idhFirst);
			pCtx->BackUp(node.val - idhFirst, CBackupInfo::INVALID_BNTS_STATE);
		}
	}
	return bBack;
}

void CHttpQuery::RemoveNodes(BCache *pApi)
{
	CNode node;
	while (!m_State.Empty())
	{
		node = m_State.Pop();
		if (!m_State.Empty())
		{
			//VERIFY(pApi->BNodeSetCurrent(node.cmd - idhFirst));
			//pApi->BNodeSet(-1, false);
			pApi->RemoveRecommendation(node.cmd - idhFirst);  // we need remove all data assosiated with previous path
		}
		else
		{
			//VERIFY(pApi->BNodeSetCurrent(node.val - idhFirst));
			//pApi->BNodeSet(-1, false);
			pApi->RemoveRecommendation(node.val - idhFirst);  // we need remove all data assosiated with previous path
		}
		
	}
	pApi->RemoveStates();
	return;
}

void CHttpQuery::AddNodes(BCache *pApi)
{
	CNode node;
	RSStack<CNode>state;
	if (m_State.PeakFirst(node))
	{
		do
		{
			state.Push(node);
		} while (m_State.PeakNext(node));
	}
	if (!state.Empty())
	{
		node = state.Pop();
		VERIFY(pApi->GTSAPI::BNodeSetCurrent(node.val - idhFirst));
		pApi->GTSAPI::BNodeSet(1, false);
	}
	while (!state.Empty())
	{
		node = state.Pop();
		if (node.val < 100)	// We never instantiate the I don't know nodes.
		{
			VERIFY(pApi->GTSAPI::BNodeSetCurrent(node.cmd - idhFirst));
			pApi->GTSAPI::BNodeSet(node.val, false);
		}
	}
	return;
}

CString CHttpQuery::GetSubmitString(BCache *pApi)
{
	ASSERT(NULL != pApi);
	CNode node;
	RSStack<CNode> stack;
	CString str;
	CString strGet = _T("");
	if (m_State.PeakFirst(node))
	{
		do
		{
			stack.Push(node);
		} while (m_State.PeakNext(node));
	}
	if (!stack.Empty())
	{
		node = stack.Pop();
		if (pApi->BNodeSetCurrent(node.val - idhFirst))
		{
			strGet += _T("&");
			strGet += CHOOSE_TS_PROBLEM_NODE;
			strGet += _T("=");
			pApi->NodeSymName();
			strGet += pApi->SzcResult();
		}
		while (!stack.Empty())
		{
			node = stack.Pop();
			if (pApi->BNodeSetCurrent(node.cmd - idhFirst))
			{
				strGet += _T("&");
				pApi->NodeSymName();
				strGet += pApi->SzcResult();				
				str.Format(_T("%d"), node.val);
				strGet += _T("=") + str;
			}
		}
	}
	return strGet;
}

void CHttpQuery::Debug()
{
	CNode node;
	RSStack<CNode>state;
	CString str;
	if (m_State.PeakFirst(node))
	{
		do
		{
			str.Format(_T("Cmd %d Val %d"), node.cmd, node.val);
			AfxMessageBox(str);
		} while (m_State.PeakNext(node));
	}
}

CString& CHttpQuery::GetMachine()
{
	return m_strMachineID;
}

CString& CHttpQuery::GetPNPDevice()
{
	return m_strPNPDeviceID;
}

CString& CHttpQuery::GetDeviceInstance()
{
	return m_strDeviceInstanceID;
}

CString& CHttpQuery::GetGuidClass()
{
	return m_strGuidClass;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\cabuncompress.h ===
//
// MODULE: CABUNCOMPRESS.H
//
// PURPOSE: Header for CAB support
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 8/7/97
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.2		8/7/97		RM		Local Version for Memphis
// V0.3		3/24/98		JM		Local Version for NT5
//

#ifndef __CABUNCOMPRESS_H_
#define __CABUNCOMPRESS_H_ 1

#include "fdi.h"

class CCabUnCompress
{
public:
#define NO_CAB_ERROR 0
#define NOT_A_CAB 1

public:
	CCabUnCompress();

	BOOL ExtractCab(CString &strCabFile, CString &strDestDir, const CString& strFile);
	CString GetLastFile();

	void ThrowGen();

	CString m_strError;
	int m_nError;

protected:

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\cabuncompress.cpp ===
//
// MODULE: CABUNCOMPRESS.CPP
//
// PURPOSE: CAB File Support Class
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 8/7/97
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.2		6/4/97		RM		Local Version for Memphis
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//

#include "stdafx.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>
#include <dos.h>
#include <sys/stat.h>

#include "CabUnCompress.h"

#include "chmread.h"
#include "apgts.h"

#ifdef _DEBUG
	#ifndef _UNICODE
	#define PRINT_OUT ::AfxTrace
	//#define PRINT_OUT 1 ? (void)0 : ::AfxTrace
	#else
	#define PRINT_OUT 1 ? (void)0 : ::AfxTrace
	#endif
#else
#define PRINT_OUT 1 ? (void)0 : ::AfxTrace
#endif

// Need this to compile unicode builds.
bool TcharToChar(char szOut[], LPCTSTR szIn, int &OutLen)
{
	int x = 0;
	while(NULL != szIn[x] && x < OutLen)
	{
		szOut[x] = (char) szIn[x];
		x++;
	}
	if (x < OutLen)
		szOut[x] = NULL;
	return x < OutLen;
}


// Call back functions needed to use the fdi library.

/*
 * Memory allocation function
 */
FNALLOC(mem_alloc)
{
	return malloc(cb);
}


/*
 * Memory free function
 */
FNFREE(mem_free)
{
	free(pv);
}


FNOPEN(file_open)
{
	return _open(pszFile, oflag, pmode);
}


FNREAD(file_read)
{
	return _read(hf, pv, cb);
}


FNWRITE(file_write)
{
	return _write(hf, pv, cb);
}


FNCLOSE(file_close)
{
	return _close(hf);
}


FNSEEK(file_seek)
{
	return _lseek(hf, dist, seektype);
}

/*
 * Function prototypes 
 */
BOOL	test_fdi(TCHAR *cabinet_file);
int		get_percentage(unsigned long a, unsigned long b);
TCHAR   *return_fdi_error_string(FDIERROR err);


/*
 * Destination directory for extracted files
 */
char	dest_dir[MAX_PATH];

// Last file to be extracted.
char	last_extracted[MAX_PATH];

FNFDINOTIFY(notification_function)
{
	switch (fdint)
	{
		case fdintCABINET_INFO: // general information about the cabinet
			PRINT_OUT(
				_T("fdintCABINET_INFO\n")
				_T("  next cabinet     = %s\n")
				_T("  next disk        = %s\n")
				_T("  cabinet path     = %s\n")
				_T("  cabinet set ID   = %d\n")
				_T("  cabinet # in set = %d (zero based)\n")
				_T("\n"),
				pfdin->psz1,
				pfdin->psz2,
				pfdin->psz3,
				pfdin->setID,
				pfdin->iCabinet);

			return 0;

		case fdintPARTIAL_FILE: // first file in cabinet is continuation
			PRINT_OUT(
				_T("fdintPARTIAL_FILE\n")
				_T("   name of continued file            = %s\n")
				_T("   name of cabinet where file starts = %s\n")
				_T("   name of disk where file starts    = %s\n"),
				pfdin->psz1,
				pfdin->psz2,
				pfdin->psz3);
			return 0;

		case fdintCOPY_FILE:	// file to be copied
		{
			int	handle;
			char destination[MAX_PATH];

			PRINT_OUT(
				_T("fdintCOPY_FILE\n")
				_T("  file name in cabinet = %s\n")
				_T("  uncompressed file size = %d\n")
				_T("  copy this file? (y/n): y"),
				pfdin->psz1,
				pfdin->cb);

			strcpy(last_extracted, pfdin->psz1);

			PRINT_OUT(_T("\n"));

			sprintf(
				destination, 
				"%s%s",
				dest_dir,
				pfdin->psz1
			);

			handle = file_open(
				destination,
				_O_BINARY | _O_CREAT | _O_TRUNC | _O_WRONLY | _O_SEQUENTIAL,
				_S_IREAD | _S_IWRITE 
			);

			return handle;
		}

		case fdintCLOSE_FILE_INFO:	// close the file, set relevant info
		{
			HANDLE handle;
			DWORD attrs;
			char destination[MAX_PATH];

 			PRINT_OUT(
				_T("fdintCLOSE_FILE_INFO\n")
				_T("   file name in cabinet = %s\n")
				_T("\n"),
				pfdin->psz1);

			sprintf(
				destination, 
				"%s%s",
				dest_dir,
				pfdin->psz1);

			file_close(pfdin->hf);

            /*
             * Set date/time
             *
             * Need Win32 type handle for to set date/time
             */
			handle = CreateFileA(
				destination,
				GENERIC_READ | GENERIC_WRITE,
				FILE_SHARE_READ,
				NULL,
				OPEN_EXISTING,
				FILE_ATTRIBUTE_NORMAL,
				NULL);

			if (handle != INVALID_HANDLE_VALUE)
			{
				FILETIME    datetime;

				if (TRUE == DosDateTimeToFileTime(
					pfdin->date,
					pfdin->time,
					&datetime))
				{
					FILETIME    local_filetime;

					if (TRUE == LocalFileTimeToFileTime(
						&datetime,
						&local_filetime))
					{
						(void) SetFileTime(
							handle,
							&local_filetime,
							NULL,
							&local_filetime);
					}
				}

				CloseHandle(handle);
			}

            /*
             * Mask out attribute bits other than readonly,
             * hidden, system, and archive, since the other
             * attribute bits are reserved for use by
             * the cabinet format.
             */
			attrs = pfdin->attribs;

			attrs &= (_A_RDONLY | _A_HIDDEN | _A_SYSTEM | _A_ARCH);

			(void) SetFileAttributesA(
				destination,
				attrs);

			return TRUE;
		}

		case fdintNEXT_CABINET:	// file continued to next cabinet
			PRINT_OUT(
				_T("fdintNEXT_CABINET\n")
				_T("   name of next cabinet where file continued = %s\n")
                _T("   name of next disk where file continued    = %s\n")
				_T("   cabinet path name                         = %s\n")
				_T("\n"),
				pfdin->psz1,
				pfdin->psz2,
				pfdin->psz3);
			return 0;
	}

	return 0;
}

TCHAR *return_fdi_error_string(FDIERROR err)
{
	switch (err)
	{
		case FDIERROR_NONE:
			return _T("No error");

		case FDIERROR_CABINET_NOT_FOUND:
			return _T("Cabinet not found");
			
		case FDIERROR_NOT_A_CABINET:
			return _T("Not a cabinet");
			
		case FDIERROR_UNKNOWN_CABINET_VERSION:
			return _T("Unknown cabinet version");
			
		case FDIERROR_CORRUPT_CABINET:
			return _T("Corrupt cabinet");
			
		case FDIERROR_ALLOC_FAIL:
			return _T("Memory allocation failed");
			
		case FDIERROR_BAD_COMPR_TYPE:
			return _T("Unknown compression type");
			
		case FDIERROR_MDI_FAIL:
			return _T("Failure decompressing data");
			
		case FDIERROR_TARGET_FILE:
			return _T("Failure writing to target file");
			
		case FDIERROR_RESERVE_MISMATCH:
			return _T("Cabinets in set have different RESERVE sizes");
			
		case FDIERROR_WRONG_CABINET:
			return _T("Cabinet returned on fdintNEXT_CABINET is incorrect");
			
		case FDIERROR_USER_ABORT:
			return _T("User aborted");
			
		default:
			return _T("Unknown error");
	}
}

CCabUnCompress::CCabUnCompress()
{
	m_strError = _T("");
	m_nError = NO_ERROR;
	return;
}

BOOL CCabUnCompress::ExtractCab(CString &strCabFile, CString &strDestDir, const CString& strFile)
{
	HFDI			hfdi;
	ERF				erf;
	FDICABINETINFO	fdici;
	int				hf;
	char			*p;
	char			cabinet_name[MAX_PATH];
	char			cabinet_path[MAX_PATH];
	bool            bUseCHM = strFile.GetLength() != 0;
	BOOL            bRet = FALSE;
	BOOL            bWasRenamed = FALSE;

	char sznCabFile[MAX_PATH];
	char sznDestDir[MAX_PATH * 3];
	int Len = MAX_PATH;
	TcharToChar(sznCabFile, (LPCTSTR) strCabFile, Len);
	Len = MAX_PATH * 3;
	TcharToChar(sznDestDir, (LPCTSTR) strDestDir, Len);


	ASSERT(strDestDir.GetLength() < MAX_PATH);
	strcpy(dest_dir, sznDestDir);

	hfdi = FDICreate(
		mem_alloc,
		mem_free,
		file_open,
		file_read,
		file_write,
		file_close,
		file_seek,
		cpu80386,
		&erf
	);

	if (hfdi == NULL)
	{
		m_strError.Format(_T("FDICreate() failed: code %d [%s]\n"),
			erf.erfOper, return_fdi_error_string(erf.erfOper));

		return FALSE;
	}

	if (bUseCHM)
	{
		/*
		 * If strCabFile is CHM file - extract data from *.dsz file inside CHM
		 *  and save this data in strDestDir directory as temperary file
		 * It means that we are copying *.dsz file in temp directory, then 
		 *  decode it to *.dsc file. 
		 * *.dsz file fill be removed in this function, *.dsc file will be renoved
		 *  later.
		 */

		// modify sznCabFile from path\*.chm to temp_path\network.dsz
		strcpy(sznCabFile, strDestDir);
		strcat(sznCabFile, strFile);

		hf = file_open(
			sznCabFile,
			_O_CREAT | _O_TRUNC | /*_O_TEMPORARY |*/
			_O_BINARY | _O_RDWR | _O_SEQUENTIAL ,
			_S_IREAD | _S_IWRITE 
		);
				
		if (hf != -1)
		{
			// write in temp file now
			void* buf =NULL;
			DWORD size =0;

			if (S_OK == ::ReadChmFile(strCabFile, strFile, &buf, &size))
			{
				int ret = _write(hf, buf, size);
				delete [] buf;
				if (-1 == ret)
				{
					FDIDestroy(hfdi);
					_close(hf);
					return FALSE;
				}
			}
			else
			{
				FDIDestroy(hfdi);
				_close(hf);
				return FALSE;
			}
		}
		else
		{
			FDIDestroy(hfdi);
			return FALSE;
		}

		_close(hf);
	}
	
	/*
	 * Is this file really a cabinet?
	 */
	hf = file_open(
		sznCabFile,
		_O_BINARY | _O_RDONLY | _O_SEQUENTIAL,
		0
	);

	if (hf == -1)
	{
		(void) FDIDestroy(hfdi);

		m_strError.Format(_T("Unable to open '%s' for input\n"), (LPCTSTR) strCabFile);
		return FALSE;
	}

	bRet = FDIIsCabinet(hfdi,
						hf,
						&fdici);

	_close(hf);
	
	if (FALSE == bRet)
	{
		/*
		 * No, it's not a cabinet!
		 */
		if (bUseCHM)
		{
			// But if we were using CHM -
			//  we have extracted this *.dsz (that has *.dsc format)
			//  in TEMP directory and all we heed - just rename it to
			//  *.dsc.
			// This would EMULATE case where we have *.dsz compressed.
			CString strUncompressedFile, strCabFile(sznCabFile);
			strUncompressedFile = strCabFile.Left(strCabFile.GetLength() - 4);
			strUncompressedFile += DSC_UNCOMPRESSED;
			remove(strUncompressedFile); // remove if exists
			if (0 != rename(strCabFile, strUncompressedFile))
			{
				FDIDestroy(hfdi);
				goto AWAY;
			}
			CString strJustUncompressedFileName = ::ExtractFileName(strUncompressedFile);
			strcpy(last_extracted, strJustUncompressedFileName);
			bWasRenamed = TRUE;
			bRet = TRUE;
		}
		else
		{
			m_strError.Format(
				_T("FDIIsCabinet() failed: '%s' is not a cabinet\n"),
				(LPCTSTR) strCabFile);
			m_nError = NOT_A_CAB;
		}
		(void) FDIDestroy(hfdi);
		goto AWAY;
	}
	else
	{
		PRINT_OUT(
			_T("Information on cabinet file '%s'\n")
			_T("   Total length of cabinet file : %d\n")
			_T("   Number of folders in cabinet : %d\n")
			_T("   Number of files in cabinet   : %d\n")
			_T("   Cabinet set ID               : %d\n")
			_T("   Cabinet number in set        : %d\n")
			_T("   RESERVE area in cabinet?     : %s\n")
			_T("   Chained to prev cabinet?     : %s\n")
			_T("   Chained to next cabinet?     : %s\n")
			_T("\n"),
			(LPCTSTR) strCabFile,
			fdici.cbCabinet,
			fdici.cFolders,
			fdici.cFiles,
			fdici.setID,
			fdici.iCabinet,
			fdici.fReserve == TRUE ? _T("yes") : _T("no"),
			fdici.hasprev == TRUE ? _T("yes") : _T("no"),
			fdici.hasnext == TRUE ? _T("yes") : _T("no")
		);
	}

	p = strchr(sznCabFile, '\\');

	if (p == NULL)
	{
		strcpy(cabinet_name, sznCabFile);
		strcpy(cabinet_path, "");
	}
	else
	{
		strcpy(cabinet_name, p+1);

		char *pCab = sznCabFile;

		strncpy(cabinet_path, sznCabFile, (int) (p-pCab)+1);
		cabinet_path[ (int) (p-pCab)+1 ] = 0;
	}

	if (TRUE != FDICopy(
		hfdi,
		cabinet_name,
		cabinet_path,
		0,
		notification_function,
		NULL,
		NULL))
	{
		m_strError.Format(
			_T("FDICopy() failed: code %d [%s]\n"),
			erf.erfOper, return_fdi_error_string(erf.erfOper));

		(void) FDIDestroy(hfdi);
		bRet = FALSE;
		goto AWAY;
	}

	if (FDIDestroy(hfdi) != TRUE)
	{
		m_strError.Format(
			_T("FDIDestroy() failed: code %d [%s]\n"),
			erf.erfOper, return_fdi_error_string(erf.erfOper));

		bRet = FALSE;
		goto AWAY;
	}

AWAY:
	if (bUseCHM && !bWasRenamed)
		remove(sznCabFile);

	return bRet;
}

CString CCabUnCompress::GetLastFile()
{
	CString str = last_extracted;
	return str;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\chmread.h ===
//
// MODULE: CHMREAD.H
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 7/1/98
//

#ifndef __CHMREAD_H_
#define __CHMREAD_H_

HRESULT ReadChmFile(LPCTSTR szFileName, LPCTSTR szStreamName, void** ppBuffer, DWORD* pdwRead);
bool GetNetworkRelatedResourceDirFromReg(CString network, CString* path);
bool IsNetworkRelatedResourceDirCHM(CString path);
CString ExtractResourceDir(CString path);
CString ExtractFileName(CString path);
CString ExtractCHM(CString path);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\cathelp.cpp ===
//=--------------------------------------------------------------------------=
// CatHelp.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the Component Category helper functions.
//
#include "stdafx.h"

#include "comcat.h"

// Helper function to create a component category and associated description
HRESULT CreateComponentCategory(CATID catid, WCHAR* catDescription)
	{

    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;

    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
	if (FAILED(hr))
		return hr;

    // Make sure the HKCR\Component Categories\{..catid...}
    // key is registered
    CATEGORYINFO catinfo;
    catinfo.catid = catid;
    catinfo.lcid = 0x0409 ; // english

	// Make sure the provided description is not too long.
	// Only copy the first 127 characters if it is
	int len = wcslen(catDescription);
	if (len>127)
		len = 127;
    wcsncpy(catinfo.szDescription, catDescription, len);
	// Make sure the description is null terminated
	catinfo.szDescription[len] = '\0';

    hr = pcr->RegisterCategories(1, &catinfo);
	pcr->Release();

	return hr;
	}

// Helper function to register a CLSID as belonging to a component category
HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
// Register your component categories information.
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Register this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();
  
	return hr;
	}

// Helper function to unregister a CLSID as belonging to a component category
HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
	{
    ICatRegister* pcr = NULL ;
    HRESULT hr = S_OK ;
    hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
    if (SUCCEEDED(hr))
    {
       // Unregister this category as being "implemented" by
       // the class.
       CATID rgcatid[1] ;
       rgcatid[0] = catid;
       hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
    }

    if (pcr != NULL)
        pcr->Release();
  
	return hr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\bnts.h ===
//
// MODULE:  BNTS.H
//
// PURPOSE: "read only" belief network API for Troubleshooters
//	bnts.h:  Definitions for the Belief Network Troubleshooting object.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Apparently originated at MSR
// 
// ORIGINAL DATE: unknown
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.3		3/24/98		JM		Local Version for NT5

#ifndef _BNTS_H_
#define _BNTS_H_

//  BN system inclusions
#include "enumstd.h"		// Standard enumeration declarations for the BN system

// 'BNTS_EXPORT' should only be defined in the project that builds the DLL
#ifdef	BNTS_EXPORT
	//  We're building the DLL (exporting the class)
	#define	BNTS_RESIDENT __declspec(dllexport)
#else
	//  We're using the DLL (importing the class)
	#define	BNTS_RESIDENT __declspec(dllimport)
#endif

//  Forward declaration of internal belief network class
class MBNETDSCTS;										//  the encapsulated BN class
class GNODEMBND;										//  Discrete nodes
class LTBNPROP;											//  Property list
class ZSTR;

typedef const char * SZC;								//  simple alias
typedef char * SZ;
typedef double REAL;

////////////////////////////////////////////////////////////////////////////////////////////
//
//	class BNTS: the belief network troubleshooter
//
////////////////////////////////////////////////////////////////////////////////////////////
class BNTS_RESIDENT BNTS
{	
  public:
	//  CTOR and DTOR
	BNTS ();
	~ BNTS ();

	////////////////////////////////////////////////////////////////////
	//  Model-level queries and functions
	////////////////////////////////////////////////////////////////////
		//  Load and process a DSC-based model
	BOOL BReadModel ( SZC szcFn, SZC szcFnError = NULL );
		//  Return the number of (pre-expansion) nodes in the model
	int CNode ();
		//  Return the recommended nodes and, optionally, their values
	BOOL BGetRecommendations ();
		//  Return TRUE if the state of information is impossible
	BOOL BImpossible ();
		//  Return a property item string from the network
	BOOL BNetPropItemStr ( SZC szcPropType, int index );
		//  Return a property item number from the network
	BOOL BNetPropItemReal ( SZC szcPropType, int index, double & dbl );

	////////////////////////////////////////////////////////////////////
	//  Operations involving the "Currrent Node": call NodeSetCurrent()
	////////////////////////////////////////////////////////////////////
		//  Set the current node for other calls
	BOOL BNodeSetCurrent( int inode );
		//	Get the current node
	int INodeCurrent ();
		//  Return the index of a node given its symbolic name
	int INode ( SZC szcNodeSymName );	
		//	Return the label of the current node
	ESTDLBL ELblNode ();
		//  Return the number of discrete states in the current node
	int INodeCst ();
		//  Set the state of a node; use -1 to uninstatiate
	BOOL BNodeSet ( int istate, bool bSet = true );
		//  Return the state of a node
	int  INodeState ();
		//	Return the name of a node's state
	void NodeStateName ( int istate );
		//  Return the symbolic name of the node
	void NodeSymName ();
		//  Return the full name of the node
	void NodeFullName ();
		//  Return a property item string from the node
	BOOL BNodePropItemStr ( SZC szcPropType, int index );
		//  Return a property item number from the node
	BOOL BNodePropItemReal ( SZC szcPropType, int index, double & dbl );
		//  Return the belief for a node
	void NodeBelief ();
		//  Return true if the network is loaded and correct
	bool BValidNet () const;
		//  Return true if the current node is set
	bool BValidNode () const;
		//  Discard the model and all components
	void Clear();

	////////////////////////////////////////////////////////////////////
	//  Accessors to the function result information	
	////////////////////////////////////////////////////////////////////
	SZC SzcResult () const;					//  String answer		
	const REAL * RgReal () const;			//  Array of reals		
	const int * RgInt () const;				//  Array of Integers	
	int CReal () const;						//  Count of reals		
	int CInt () const;						//  Count of integers

  protected:
	MBNETDSCTS * _pmbnet;			//  The T/S DSC belief network
	int _inodeCurrent;				//  The current node

  protected:
	MBNETDSCTS & Mbnet();
	const MBNETDSCTS & Mbnet() const;
	GNODEMBND * Pgndd ();
	BOOL BGetPropItemStr ( LTBNPROP & ltprop, 
						   SZC szcPropType, 
						   int index, 
						   ZSTR & zstr );
	BOOL BGetPropItemReal ( LTBNPROP & ltprop, 
							SZC szcPropType, 
							int index, 
							double & dbl );
	void ClearArrays ();
	void ClearString ();
	ZSTR & ZstrResult ();
};

#endif // _BNTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\cachegen.cpp ===
//
// MODULE: CACHEGEN.CPP
//
// PURPOSE: Cache File Generator and Reader for BN Networks
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
//
// ORIGINAL DATE: 8/7/97
//
// NOTES:
// 1.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.2		8/7/97		RM		Local Version for Memphis
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//

#include "stdafx.h"
#include <afxwin.h>
#include <afxtempl.h>

#include "apgts.h"
#include "bnts.h"
#include "cachegen.h"

#include "BackupInfo.h"
#include "apgtsinf.h"
#include "ChmRead.h"


int nodecomp(const void *elem1, const void *elem2);

//
//
GTSCacheGenerator::GTSCacheGenerator(BOOL bScanAll, const char *szLogFile, const char *szBNTSLogFile)
{
	m_fp = NULL;
	m_bScanAll = bScanAll;
	m_szBNTSLogFile = szBNTSLogFile;
	if (szLogFile != NULL)
		m_fp = fopen(szLogFile, "w");
	m_nCount = 0;
	m_nItemCount = 0;
	m_headposition = 0;
	m_filedata = NULL;
	m_netstartoffset = 0;
	m_nodeorder = NULL;
}

//
//
GTSCacheGenerator::~GTSCacheGenerator()
{
	if (m_fp)
		fclose(m_fp);
	if (m_filedata)
		free(m_filedata);
	if (m_nodeorder)
		free(m_nodeorder);

}

bool GTSCacheGenerator::TcharToChar(char szOut[], LPCTSTR szIn, int &OutLen)
{
	int x = 0;
	while(NULL != szIn[x] && x < OutLen)
	{
		szOut[x] = (char) szIn[x];
		x++;
	}
	if (x < OutLen)
		szOut[x] = NULL;
	return x < OutLen;
}
//
//
/*
void GTSCacheGenerator::LogOut(TCHAR *szcFormat, ...)
{
	va_list ptr;
	
	if (!m_fp)
		return;

	if (!szcFormat)
		return;

	va_start(ptr, szcFormat);
	vfprintf(m_fp, szcFormat, ptr);
	va_end(ptr);
}
*/

#ifdef _DEBUG
#define LogOut ::AfxTrace
//#define LogOut 1 ? (void)0 : ::AfxTrace
#else
#define LogOut 1 ? (void)0 : ::AfxTrace
#endif

//
//
int nodecomp(const void *elem1, const void *elem2)
{
	return (((GTS_NODE_ORDER *)elem1)->depth - ((GTS_NODE_ORDER *)elem2)->depth);
}

//
//
void GTSCacheGenerator::SaveNetItem(CPtrList *nsp, BNTS *bp, FILE *fp, LPCSTR name)
{
	GTS_NODE_ITEM *ni;

	if (!bp->BNetPropItemStr( name, 0 ))
		return;

	ni = new GTS_NODE_ITEM(name);

	int j = 0;
	while (bp->BNetPropItemStr( name, j++ ))
	{
		CString sTemp = bp->SzcResult();
		ni->sStringArr.Add(sTemp);
	}
	
	nsp->AddTail(ni);
}

//
//
BOOL GTSCacheGenerator::NodeTraverse(	FILE *fp,
										BNTS *bp,
										int depth,
										CArray<int,int> &newnodes,
										CArray<int,int> &newstates,
										int currnode,
										int currstate)
{
	BOOL bEnd = FALSE;
	int i, j;

	if (depth > 30)
	{
		LogOut(_T("Depth Exceeded\n"));
		return FALSE;
	}

	// uninstantiate
	UninstantiateAll(bp);

	newnodes.Add(currnode);
	newstates.Add(currstate);
	
	depth++;

	for (i=0;i<newnodes.GetSize();i++)
	{
		if (bp->BNodeSetCurrent(newnodes[i]))
		{
			bp->NodeSymName();

			CString sTemp = bp->SzcResult();

			LogOut(_T("%s"), sTemp);

			ESTDLBL albl = bp->ELblNode();

			if (albl == ESTDLBL_problem)
			{
				LogOut(_T("(prob)"));
			}
			else if (albl == ESTDLBL_info)
			{
				LogOut(_T("(info)"));
			}
			else if (albl == ESTDLBL_fixobs ||
					albl == ESTDLBL_fixunobs ||
					albl == ESTDLBL_unfix)
			{
				LogOut(_T("(fix)"));
			}
			else
			{
				LogOut(_T("(?)"));
			}
		}

		LogOut(_T("(%d=%d) "), newnodes[i], newstates[i]);
	}

	SetNodes( bp, newnodes, newstates );

	BOOL bRec = FALSE;

	if (!bp->BGetRecommendations())
	{
		bRec = TRUE;
	}
	else
	{
	}

	const int *rg = bp->RgInt();

	i = 0;

	if (bRec)
	{
		if (bp->BImpossible())
		{
			LogOut(_T("IMPOSSIBLE\n"));
		}
		else
		{
			LogOut(_T("RECOMMENDATION ERROR\n"));
		}
	}
	else
	{
		if (bp->BImpossible())
		{
			LogOut(_T("IMPOSSIBLE (Have Rec)\n"));
		}
		else
		{
			int reccount = bp->CInt();

			if (reccount)
			{
				int nodecount = (int)newstates.GetSize();

				if (nodecount)
				{
					
					BOOL bFound = FALSE;

					for (i=0;i<reccount;i++)
					{
						bFound = FALSE;

						for (j=0;j<nodecount;j++)
						{
							if (newnodes[j] == rg[i])
							{
								bFound = TRUE;
								break;
							}
						}

						if (!bFound)
							break;
					}
					
					if (!bFound)
					{
						LogOut(_T("RECOMMENDATION: "));

						if (bp->BNodeSetCurrent(rg[i]))
						{
							CString sTemp1 = "Error";
							CString sTemp2 = "Error";
							
							if (bp->BNodePropItemStr( "HNodeHd", 0 ))
								sTemp1 = bp->SzcResult();

							bp->NodeSymName();
							
							sTemp2 = bp->SzcResult();
							
							LogOut(_T("%s (%s) (Node: %d)"), sTemp1, sTemp2, rg[i]);

							if (m_nodeorder)
							{
								if (m_nodeorder[rg[i]].depth > depth)
									m_nodeorder[rg[i]].depth = depth;
							}

							UINT realcount = 0;
							for (j=0;j<nodecount;j++)
								if (newstates[j] != STATE_UNKNOWN)
									realcount++;

							fwrite(&realcount, sizeof (UINT), 1, fp);

							for (j=0;j<nodecount;j++)
								if (newstates[j] != STATE_UNKNOWN)
								{
									GTS_CACHE_NODE cnode;
									cnode.node = newnodes[j];
									cnode.state = newstates[j];

									fwrite(&cnode, sizeof (cnode), 1, fp);
								}

							// write to cache out file
							UINT ucount = reccount;
							fwrite(&ucount, sizeof (UINT), 1, fp);

							for (j=0;j<reccount;j++)
							{
								UINT rgval = rg[j];
								fwrite(&rgval, sizeof (UINT), 1, fp);
							}

							m_nCount++;
						}
						LogOut(_T("\n"));
					}
					else
					{
						LogOut(_T("NO RECOMMENDATIONS - ALL AVAILABLE MARKED AS UNKNOWN\n"));
						bEnd = TRUE;
					}
				}
				else
					LogOut(_T("STATE COUNT 0 - INTERNAL ERROR\n"));
			}
			else
				LogOut(_T("NO RECOMMENDATIONS\n"));
		}
	}

	LogOut(_T("\n"));


	// recommendations - let's figure out what to do with them

	// the first rec in the returned array will be array[1] in the set array
	// so we have to watch for that

	if (bp->CInt() && !bEnd)
	{
		// have rec
		CArray<int,int> states;

		int node = rg[i];

		if (bp->BNodeSetCurrent(node))
		{
			ESTDLBL albl = bp->ELblNode();
			
			if (albl == ESTDLBL_info)
			{
				states.Add(0);
				states.Add(1);
				if (m_bScanAll)
					states.Add(STATE_UNKNOWN);
			}
			else if (albl == ESTDLBL_fixobs ||
					albl == ESTDLBL_fixunobs ||
					albl == ESTDLBL_unfix)
			{
				states.Add(0);
				if (m_bScanAll)
					states.Add(STATE_UNKNOWN);
			}
			else
			{
				LogOut(_T("Unexpected Node Type\n"));
			}
		}
		else
			LogOut(_T("Can't set node current\n"));

		int count = (int)states.GetSize();

		for (i=0;i<count;i++)
		{
			if (!NodeTraverse( fp, bp, depth, newnodes, newstates, node, states[i] ))
				return FALSE;
		}
	}
	
	// done, remove references to our current node
	newnodes.RemoveAt(depth - 1);
	newstates.RemoveAt(depth - 1);

	return TRUE;
}


//
//
void GTSCacheGenerator::UninstantiateAll(BNTS *bp)
{
	int count = (int)m_oldnodes.GetSize();
	// uninstantiate all nodes
	if (!count)
		return;

	for (int j=0;j<count;j++)
	{
		if (bp->BNodeSetCurrent(m_oldnodes[j]))
		{
			if (bp->BNodeSet(-1))
			{
			}
			else
			{
				LogOut(_T("Can't uninstantiate node\n"));
			}
		}
		else
		{
			LogOut(_T("Can't set node %d to uninstantiate\n"), m_oldnodes[j]);
		}
	}
}

//
//
void GTSCacheGenerator::SetNodes(BNTS *bp, CArray<int,int> &nodes, CArray<int,int> &states)
{
	m_oldnodes.Copy(nodes);

	int count = (int)nodes.GetSize();
	
	if (!count)
		return;

	LogOut(_T("\nSetNodes:"));
	for (int j=0;j<count;j++)
	{
		if (bp->BNodeSetCurrent(nodes[j]))
		{
			if (states[j] != STATE_UNKNOWN)
			{
				LogOut(_T("(%d=%d)"), nodes[j], states[j]);

				if (bp->BNodeSet(states[j], false))
				{
				}
				else
				{
					LogOut(_T("Can't set node\n"));
				}
			}
			else
				LogOut(_T("(%d=X)"), nodes[j]);
		}
		else
			LogOut(_T("Can't set node %d\n"), nodes[j]);
	}

	LogOut(_T("\n"));
}

//
//
BOOL GTSCacheGenerator::ReadCacheFileHeader(CString &sCacheFilename, const CString& strCacheFileWithinCHM)
{
	GTS_CACHE_FILE_HEADER header;
	bool bUseCHM = strCacheFileWithinCHM.GetLength() != 0;

	if (bUseCHM)
	{
		DWORD size =0;
		if (S_OK != ::ReadChmFile(sCacheFilename, strCacheFileWithinCHM, (void**)&m_filedata, &size))
		{
			return FALSE;
		}
	}
	else
	{
		UINT size;
		// must be binary
		FILE *cfp = _tfopen(sCacheFilename, _T("rb"));
		if (cfp==NULL)
		{
			LogOut(_T("Error opening cache file for reading\n"));
			return FALSE;
		}

		// get file size
		if (fseek(cfp, 0, SEEK_END))
		{
			LogOut(_T("Can't set pos to end of file\n"));
			fclose(cfp);
			return FALSE;
		}

		fpos_t position;
		if (fgetpos(cfp, &position))
		{
			LogOut(_T("Can't get pos at end of file\n"));
			fclose(cfp);
			return FALSE;
		}

		size = (UINT) position;

		rewind(cfp);
		
		// allocate space for file
		m_filedata = (char *) malloc(size);
		if (m_filedata == NULL)
		{
			LogOut(_T("Error allocating memory\n"));
			fclose(cfp);
			return FALSE;
		}
		
		if (fread(m_filedata, size, 1, cfp) != 1)
		{
			LogOut(_T("Error reading file into memory\n"));
			fclose(cfp);
			return FALSE;
		}

		fclose(cfp);
	}

	memcpy(&header, m_filedata, sizeof(header));

	if (memcmp(header.signature, GTS_CACHE_SIG, sizeof (header.signature)) != 0)
	{
		LogOut(_T("Bad file signature!\n"));
		return FALSE;
	}

	if (!header.count)
	{
		LogOut(_T("No items in file!\n"));
		return FALSE;
	}

	m_netstartoffset = header.netoffset;

	LogOut(_T("ItemCount: %d\n"), header.count);

	m_nItemCount = header.count;

	m_cachepos = (GTS_CACHE_FILE_SETDATA *) (m_filedata + sizeof (GTS_CACHE_FILE_HEADER));

	return TRUE;
}

//
//
BOOL GTSCacheGenerator::FindNetworkProperty(LPCSTR szName, CString &sResult, int index)
{
	if (m_filedata == NULL)
		return FALSE;

	GTS_CACHE_PROP_NETSTART_BLK *netstart =
		(GTS_CACHE_PROP_NETSTART_BLK *)(m_filedata + m_netstartoffset);

	GTS_CACHE_PROP_STR_BLK *netstrblk =
			(GTS_CACHE_PROP_STR_BLK *) (m_filedata + netstart->netpropoffset);

	for (UINT i = 0; i < netstart->netpropcount; i++, netstrblk++)
	{
		LPCSTR szItem = (LPCSTR) (m_filedata + netstrblk->nameoffset);
		if (!strcmp(szName, szItem))
		{
			if (!index)
			{
				sResult = (LPCSTR) (m_filedata + netstrblk->stringoffset);
				return TRUE;
			}
			else
			{
				LPCSTR szStrArrItem = (LPCSTR) (m_filedata + netstrblk->stringoffset);
				int len = strlen(szStrArrItem);
				
				for (int j=0;(j < index) && len ;j++)
				{
					szStrArrItem += len + 1;
					len = strlen(szStrArrItem);
				}

				if (!len)
					return FALSE;

				sResult = szStrArrItem;
				return TRUE;
			}
		}
	}
	return FALSE;
}

//
//
BOOL GTSCacheGenerator::FindNodeProperty(UINT nodeid, LPCSTR szName, CString &sResult, int index)
{
	if (m_filedata == NULL)
		return FALSE;

	GTS_CACHE_PROP_NETSTART_BLK *netstart =
			(GTS_CACHE_PROP_NETSTART_BLK *)(m_filedata + m_netstartoffset);

	GTS_CACHE_PROP_NODEOFF_BLK *nodeblk =
			(GTS_CACHE_PROP_NODEOFF_BLK *) (m_filedata + m_netstartoffset + sizeof (GTS_CACHE_PROP_NETSTART_BLK));

	for (UINT i = 0; i < netstart->nodecountfile; i++, nodeblk++)
	{
		if (nodeid == nodeblk->nodeid)
		{
			GTS_CACHE_PROP_NODESTART_BLK *nodestart =
					(GTS_CACHE_PROP_NODESTART_BLK *)(m_filedata + nodeblk->nodeoffset);

			GTS_CACHE_PROP_STR_BLK *nodestr =
					(GTS_CACHE_PROP_STR_BLK *)(m_filedata + nodeblk->nodeoffset + sizeof (GTS_CACHE_PROP_NODESTART_BLK));

			// now try to find string
			for (UINT j=0;j<nodestart->nodestringcount;j++, nodestr++)
			{
				LPCSTR szItem = (LPCSTR) (m_filedata + nodestr->nameoffset);

				if (!strcmp(szName, szItem))
				{
					if (!index)
					{
						sResult = (LPCSTR) (m_filedata + nodestr->stringoffset);
						return TRUE;
					}
					else
					{
						LPCSTR szStrArrItem = (LPCSTR) (m_filedata + nodestr->stringoffset);
						int len = strlen(szStrArrItem);
						
						for (int j=0;(j < index) && len ;j++)
						{
							szStrArrItem += len + 1;
							len = strlen(szStrArrItem);
						}

						if (!len)
							return FALSE;

						sResult = szStrArrItem;
						return TRUE;
					}
				}
			}

			return FALSE;
		}
	}
	return FALSE;
}

//
//
BOOL GTSCacheGenerator::IsNodePresent(UINT nodeid)
{
	if (m_filedata == NULL)
		return FALSE;

	GTS_CACHE_PROP_NETSTART_BLK *netstart =
			(GTS_CACHE_PROP_NETSTART_BLK *)(m_filedata + m_netstartoffset);

	GTS_CACHE_PROP_NODEOFF_BLK *nodeblk =
			(GTS_CACHE_PROP_NODEOFF_BLK *) (m_filedata + m_netstartoffset + sizeof (GTS_CACHE_PROP_NETSTART_BLK));

	for (UINT i = 0; i < netstart->nodecountfile; i++, nodeblk++)
	{
		if (nodeid == nodeblk->nodeid)
			return TRUE;
	}
	return FALSE;
}

// returns the node count for the network, not what's in the file
//
int GTSCacheGenerator::GetNodeCount()
{
	if (m_filedata == NULL)
		return 0;

	GTS_CACHE_PROP_NETSTART_BLK *netstart =
			(GTS_CACHE_PROP_NETSTART_BLK *)(m_filedata + m_netstartoffset);

	return netstart->nodecountnetwork;
}

//
//
BOOL GTSCacheGenerator::GetNodeIDFromSymName(LPCTSTR szSymName, UINT &nodeid)
{
	char sznSymName[MAX_SYM_NAME_BUF_LEN];
	int nSymLen = MAX_SYM_NAME_BUF_LEN;
	if (m_filedata == NULL)
		return FALSE;

	if (!TcharToChar(sznSymName, szSymName, nSymLen))
		return FALSE;

	GTS_CACHE_PROP_NETSTART_BLK *netstart =
			(GTS_CACHE_PROP_NETSTART_BLK *)(m_filedata + m_netstartoffset);

	GTS_CACHE_PROP_NODEOFF_BLK *nodeblk =
			(GTS_CACHE_PROP_NODEOFF_BLK *) (m_filedata + m_netstartoffset + sizeof (GTS_CACHE_PROP_NETSTART_BLK));

	for (UINT i = 0; i < netstart->nodecountfile; i++, nodeblk++)
	{
		GTS_CACHE_PROP_NODESTART_BLK *nodestart =
				(GTS_CACHE_PROP_NODESTART_BLK *)(m_filedata + nodeblk->nodeoffset);

		GTS_CACHE_PROP_STR_BLK *nodestr =
				(GTS_CACHE_PROP_STR_BLK *)(m_filedata + nodeblk->nodeoffset + sizeof (GTS_CACHE_PROP_NODESTART_BLK));

		// now try to find string
		for (UINT j=0;j<nodestart->nodestringcount;j++, nodestr++)
		{
			LPCSTR szItem = (LPCSTR) (m_filedata + nodestr->nameoffset);

			if (!strcmp(G_SYMBOLIC_NAME, szItem))
			{
				if (!strcmp(sznSymName, (LPCSTR) (m_filedata + nodestr->stringoffset)))
				{
					nodeid = nodeblk->nodeid;
					return TRUE;
				}
				break;
			}
		}
	}
	return FALSE;
}

//
//
BOOL GTSCacheGenerator::GetLabelOfNode(UINT nodeid, UINT &lbl)
{
	if (m_filedata == NULL)
		return FALSE;

	GTS_CACHE_PROP_NETSTART_BLK *netstart =
			(GTS_CACHE_PROP_NETSTART_BLK *)(m_filedata + m_netstartoffset);

	GTS_CACHE_PROP_NODEOFF_BLK *nodeblk =
			(GTS_CACHE_PROP_NODEOFF_BLK *) (m_filedata + m_netstartoffset + sizeof (GTS_CACHE_PROP_NETSTART_BLK));

	for (UINT i = 0; i < netstart->nodecountfile; i++, nodeblk++)
	{
		if (nodeid == nodeblk->nodeid)
		{
			GTS_CACHE_PROP_NODESTART_BLK *nodestart =
					(GTS_CACHE_PROP_NODESTART_BLK *)(m_filedata + nodeblk->nodeoffset);

			lbl = nodestart->labelnode;
			return TRUE;
		}
	}
	return FALSE;
}

//
//
BOOL GTSCacheGenerator::GetNextCacheEntryFromFile(BOOL &bErr, CBNCache *pCache)
{
	BOOL bStat = FALSE;
	bErr = TRUE;

	if (m_filedata == NULL)
		return FALSE;

	if (!m_nItemCount)
	{
		bErr = FALSE;
		return FALSE;
	}

	m_nItemCount--;

	BN_CACHE_ITEM CacheItem;

	// initialize
	CacheItem.uNodeCount = 0;
	CacheItem.uRecCount = 0;
	CacheItem.uName = NULL;
	CacheItem.uValue = NULL;
	CacheItem.uRec = NULL;

	bStat = GetNCEFF(&CacheItem, pCache);

	// free allocated space as necessary
	if (CacheItem.uName)
		free(CacheItem.uName);
	if (CacheItem.uValue)
		free(CacheItem.uValue);
	if (CacheItem.uRec)
		free(CacheItem.uRec);

	if (!bStat)
	{
		bErr = TRUE;
		return FALSE;
	}
	
	bErr = FALSE;
	return TRUE;
}

//
//
BOOL GTSCacheGenerator::GetNCEFF(BN_CACHE_ITEM *pCacheItem, CBNCache *pCache)
{
	UINT j;
	UINT setcount;
	UINT reccount;

	GTS_CACHE_FILE_SETDATA *setp = m_cachepos;

	setcount = setp->count;

	if (!setcount || setcount > 1000)
	{
		LogOut(_T("Set Count out of bounds: %d\n"), setcount);
		return FALSE;
	}

	// initialize
	pCacheItem->uNodeCount = setcount;
	pCacheItem->uName = (UINT *)malloc(setcount * sizeof (UINT));
	pCacheItem->uValue = (UINT *)malloc(setcount * sizeof (UINT));

	LogOut(_T("Count: %d\n"), setcount);

	GTS_CACHE_NODE *cachenode = &setp->item[0];

	// second, read in node = state pairs
	for (j=0;j<setcount;j++, cachenode++)
	{
		pCacheItem->uName[j] = cachenode->node;
		pCacheItem->uValue[j] = cachenode->state;
		
		LogOut(_T("(%d,%d)"), cachenode->node, cachenode->state);

	}
	LogOut(_T("\n"));

	GTS_CACHE_FILE_RECDATA *recp = (GTS_CACHE_FILE_RECDATA *) cachenode;

	reccount = recp->count;

	if (!reccount || reccount > 1000)
	{
		LogOut(_T("Rec Count out of bounds: %d\n"), reccount);
		return FALSE;
	}

	pCacheItem->uRecCount = reccount;
	pCacheItem->uRec = (UINT *)malloc(reccount * sizeof (UINT));

	UINT *uitem = &recp->item[0];

	for (j=0;j<reccount;j++, uitem++)
	{
		pCacheItem->uRec[j] = *uitem;

		LogOut(_T("(%d)"), *uitem);
	}
	LogOut(_T("\n"));

	if (!pCache->AddCacheItem(pCacheItem))
	{
		LogOut(_T("Error Adding Item To Cache\n"));
		return FALSE;
	}

	m_cachepos = (GTS_CACHE_FILE_SETDATA *) uitem;

	// success!
	return TRUE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\cachegen.h ===
//
// MODULE: CACHEGEN.H
//
// PURPOSE: Cache Generator Header
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8/7/97
//
// NOTES: 
// 1. >>> Data members in this file could sure use documentation!  - JM
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.2		8/7/97		RM		Local Version for Memphis
// V0.3		3/24/98		JM		Local Version for NT5
//

#ifndef __CACHEGEN_H_
#define __CACHEGEN_H_ 1

typedef struct _GTS_CACHE_FILE_HEADER
{
	unsigned char signature[8];
	UINT crcdsc;
	UINT crcself;
	UINT count; // item count of node data (one item = a set node and rec node structure)
	UINT netoffset;
	unsigned char reserved[28];
} GTS_CACHE_FILE_HEADER;


// -- property data --
//

// property start block
typedef struct _GTS_CACHE_PROP_NETSTART_BLK
{
	UINT netpropoffset;
	UINT netpropcount;
	UINT nodecountnetwork;
	UINT nodecountfile;
} GTS_CACHE_PROP_NETSTART_BLK;

// node item offset block
typedef struct _GTS_CACHE_PROP_NODEOFF_BLK
{
	UINT nodeid;
	UINT nodeoffset;
} GTS_CACHE_PROP_NODEOFF_BLK;

// node item offset block
typedef struct _GTS_CACHE_PROP_NODESTART_BLK
{
	UINT labelnode;
	UINT nodestringcount;
} GTS_CACHE_PROP_NODESTART_BLK;

// node item offset block
typedef struct _GTS_CACHE_PROP_STR_BLK
{
	UINT nameoffset;
	UINT stringoffset;
} GTS_CACHE_PROP_STR_BLK;

#define G_SYMBOLIC_NAME	"GSN"
#define G_FULL_NAME		"GFN"
#define G_S0_NAME		"GS0"
#define G_S1_NAME		"GS1"


// node property support
/*
typedef struct _GTS_NODE_SUPPORT
{
	fpos_t ctlposition;
	fpos_t dataposition;
	UINT nodeid;
	ESTDLBL albl;
	CString sGSymName;
	CString sGFullName;
	CString sGState0Name;
	CString sGState1Name;
	CString sHProbTxt;
	CString sHNodeHd;
	CArray<CString,CString> sHNodeTxt;

} GTS_NODE_SUPPORT;
*/

class GTS_NODE_ITEM : public CObject
{
public:
	GTS_NODE_ITEM(CString sStringN) { sStringName = sStringN; };
	CString sStringName;
	CStringArray sStringArr;
	fpos_t ctlposition;
	fpos_t snameposition;
	fpos_t sdataposition;
};


class GTS_NODE_SUPPORT : public CObject
{
public:
	fpos_t ctlposition;
	fpos_t dataposition;
	UINT nodeid;
	UINT albl;
	CPtrList lData;
};

// -- recommendation data --
//
typedef struct _GTS_CACHE_NODE
{
	UINT node; // may be more than one UINT if count > 1
	UINT state; // may be more than one UINT if count > 1
} GTS_CACHE_NODE;

// reference structure for set node and rec node
typedef struct _GTS_CACHE_FILE_SETDATA
{
	UINT count;
	GTS_CACHE_NODE item[1]; // may be more than one UINT if count > 1
} GTS_CACHE_FILE_SETDATA;

// reference structure for rec node
typedef struct _GTS_CACHE_FILE_RECDATA
{
	UINT count;
	UINT item[1]; // may be more than one UINT if count > 1
} GTS_CACHE_FILE_RECDATA;

// -- node ordering structure
typedef struct _GTS_NODE_ORDER
{
	UINT nodeid;
	int depth;
} GTS_NODE_ORDER;


// cache item data
/*
typedef struct _BN_CACHE_ITEM {
	UINT uNodeCount, uRecCount;
	UINT *uName;
	UINT *uValue;
	UINT *uRec;
} BN_CACHE_ITEM;
*/

#define GTS_CACHE_SIG	"TSCACH02"

#define STATE_UNKNOWN	102
#define MAX_SYM_NAME_BUF_LEN 500

class GTSCacheGenerator
{
	friend class BCache;

public:
	GTSCacheGenerator(	BOOL bScanAll = FALSE, \
						const char *szLogFile = NULL, \
						const char *szBNTSLogFile = NULL);
	~GTSCacheGenerator();
	static bool TcharToChar(char szOut[], LPCTSTR szIn, int &OutLen);

	BOOL ReadCacheFileHeader(CString &sCacheFilename, const CString& strCacheFileWithinCHM);
	BOOL GetNextCacheEntryFromFile(BOOL &bErr, CBNCache *pCache);
	

	BOOL FindNetworkProperty(LPCSTR szName, CString &sResult, int index = 0);
	BOOL FindNodeProperty(UINT nodeid, LPCSTR szName, CString &sResult, int index = 0);
	BOOL IsNodePresent(UINT nodeid);
	int GetNodeCount();
	BOOL GetNodeIDFromSymName(LPCTSTR szSymName, UINT &nodeid);
	BOOL GetLabelOfNode(UINT nodeid, UINT &lbl);


protected:
	BOOL NodeTraverse(	FILE *fp, \
						BNTS *bp, \
						int depth, \
						CArray<int,int> &newnodes, \
						CArray<int,int> &newstates, \
						int currnode, \
						int currstate);
	void UninstantiateAll(BNTS *bp);
	void SetNodes(BNTS *bp, CArray<int,int> &nodes, CArray<int,int> &states);
	void LogOut(TCHAR *szcFormat, ...);
	BOOL GetNCEFF(BN_CACHE_ITEM *pCacheItem, CBNCache *pCache);

	void SaveNetItem(CPtrList *nsp, BNTS *bp, FILE *fp, LPCSTR name);

protected:
	BOOL m_bScanAll;
	UINT m_nCount;
	UINT m_nItemCount;
	CArray<int,int> m_oldnodes;
	const char *m_szBNTSLogFile;
	FILE *m_fp;
	fpos_t m_headposition;
	UINT m_netstartoffset;
	char *m_filedata;
	GTS_NODE_ORDER *m_nodeorder;
	GTS_CACHE_FILE_SETDATA *m_cachepos;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\chmread.cpp ===
//
// MODULE: CHMREAD.CPP
//
// PURPOSE: Template file decoder
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 07.01.98
//
//
#include "stdafx.h"

#include "fs.h"
#include "apgts.h"
#include "chmread.h"

#define CHM_READ_BUFFER_INITIAL_SIZE    1024

// reads ALL stream (ppBuffer is reallocated)
// IN: szStreamName - file name within CHM file
// IN: szFileName - full oath and name of CHM file
// OUT: ppBuffer - data read
HRESULT ReadChmFile(LPCTSTR szFileName, LPCTSTR szStreamName, void** ppBuffer, DWORD* pdwRead)
{
   HRESULT hr =S_OK;
   CFileSystem*    pFileSystem =NULL;
   CSubFileSystem* pSubFileSystem =NULL;
   int i =0;

   // Init ITSS.

   pFileSystem = new CFileSystem();
   if (! SUCCEEDED((hr = pFileSystem->Init())) )
   {
      delete pFileSystem;
      return hr;                       // Unable to init the ITSS store.
   }

   // attempt to open the .CHM file.

   if (! SUCCEEDED((hr = pFileSystem->Open(szFileName))) )
   {
      delete pFileSystem;
      return hr;                       // Unable to open and init the ITSS store.
   }

   while (true, ++i)
   {
	   ULONG read =0;
	   
	   // attempt to open the stream.
	   pSubFileSystem = new CSubFileSystem(pFileSystem);
	   if (! SUCCEEDED((hr = pSubFileSystem->OpenSub(szStreamName))) )
	   {
		  delete pSubFileSystem;
		  delete pFileSystem;
		  return hr;                       // Unable to open the specified stream.
	   }

	   // alloc
	   *ppBuffer = new char[i * CHM_READ_BUFFER_INITIAL_SIZE];
	   if (*ppBuffer == NULL)
	   {
		  delete pSubFileSystem;
		  delete pFileSystem;
		  return S_FALSE;      // THOUGH need to return error indicating disability to allocate memory
	   }
	   
	   // read.
	   hr = pSubFileSystem->ReadSub(*ppBuffer, i * CHM_READ_BUFFER_INITIAL_SIZE, &read);

	   if (read < ULONG(i * CHM_READ_BUFFER_INITIAL_SIZE))
	   {
		  *pdwRead = read;
		  break;
	   }
	   else
	   {
		  delete pSubFileSystem;
		  delete [] *ppBuffer;
	   }
   }

   delete pSubFileSystem;
   delete pFileSystem;
   return hr;
}

bool GetNetworkRelatedResourceDirFromReg(CString network, CString* path)
{
	HKEY hKey = 0;
	CString sub_key = CString(TSREGKEY_TL) + "\\" + network;

	if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
									  sub_key, 
									  NULL,
									  KEY_READ, 
									  &hKey))
	{
		DWORD dwType = REG_SZ;
		TCHAR buf[MAXBUF] = {_T('\0')};
		DWORD dwSize = MAXBUF - 1;

		if (ERROR_SUCCESS == RegQueryValueEx(hKey,
											 FRIENDLY_PATH,
											 NULL,
											 &dwType,
											 (LPBYTE)buf,
											 &dwSize))
		{
			*path = buf;
			return true;
		}
	}

	return false;
}

bool IsNetworkRelatedResourceDirCHM(CString path)
{
	path.TrimRight();
	CString extension = path.Right(4 * sizeof(TCHAR));
	return 0 == extension.CompareNoCase(CHM_DEFAULT);
}

CString ExtractResourceDir(CString path)
{
// For example, from string
// "d:\TShooter Projects\TShootLocal\http\lan_chm\lan.chm"
// need to extract "d:\TShooter Projects\TShootLocal\http\lan_chm"
	int index =0;
	CString strCHM = ExtractCHM(path);
	CString strRes;

	if (strCHM.GetLength())
	{
		index = path.Find(strCHM);
		if (index > 0 && path.GetAt(index-sizeof(_T('\\'))) == _T('\\'))
			strRes = path.Left(index-sizeof(_T('\\')));
		else if (index == 0)
			strRes = "";
	}

	return strRes;
}

CString ExtractFileName(CString path)
{
// Extracts file name (with extension)
	int index =0;

	if (-1 == (index = path.ReverseFind(_T('\\'))))
	{
		if (-1 == (index = path.ReverseFind(_T(':'))))
			index = 0;
		else
			index += sizeof(_T(':'));
	}
	else
		index += sizeof(_T('\\'));

	return (LPCTSTR)path + index;
}

CString ExtractCHM(CString path)
{
// For example, from string
// "d:\TShooter Projects\TShootLocal\http\lan_chm\lan.chm"
// need to extract "lan.chm"
	if (!IsNetworkRelatedResourceDirCHM(path))
		return "";
	return ExtractFileName(path);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\crccompute.cpp ===
//
// MODULE: CRCCOMPUTE.CPP
//
// PURPOSE: CRC Calculator
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach (based on existing CRC designs)
// 
// ORIGINAL DATE: 8/7/97
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.2		8/7/97		RM		Local Version for Memphis
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//

#include "stdafx.h"
#include "crc.h"

void CCRC::BuildCrcTable()
{
	DWORD dwX;
	int y;
	DWORD dwAccum;
	for (dwX = 0; dwX < 256; dwX++)
	{
		dwAccum = dwX << 24;
		for (y = 0; y < 8; y++)
		{
			if (dwAccum & 0x80000000)
				dwAccum = (dwAccum << 1) ^ POLYNOMIAL;
			else
				dwAccum <<= 1;
		}
		dwCrcTable[dwX] = dwAccum;
	}
	return;
}

DWORD CCRC::ComputeCRC(LPCSTR sznBuffer, DWORD dwBufSize, DWORD dwAccum)
{
	DWORD dwX;
	DWORD dwY;
	// DWORD dwAccum = 0xFFFFFFFF;
	for (dwX = 0; dwX < dwBufSize; dwX++)
	{
		dwY = ((dwAccum >> 24) ^ *sznBuffer++) & 0xFF;
		dwAccum = (dwAccum << 8) ^ dwCrcTable[dwY];
	}
	return dwAccum;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\crc.h ===
//
// MODULE: CRC.H
//
// PURPOSE: Header for CRC support
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 8/7/97
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.2		8/7/97		RM		Local Version for Memphis
// V0.3		3/24/98		JM		Local Version for NT5
//

#ifndef __CCRC_H_
#define __CCRC_H_ 1

#include "GenException.h"

inline CString GlobFormatMessage(DWORD dwLastError)
{
	CString strMessage;
	void *lpvMessage;
	FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
		NULL,
		dwLastError,
		MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
		(LPTSTR) &lpvMessage, 0, NULL);
	strMessage = (LPCTSTR) lpvMessage;
	LocalFree(lpvMessage);
	return strMessage;
}

class CCRC
{
	const DWORD POLYNOMIAL;
public:
	CCRC();
	
	DWORD DscEncode(LPCTSTR szDsc);
	void AppendCRC(LPCTSTR szCache, DWORD dwCRCValue);
	bool Decode(LPCTSTR szDsc, LPCTSTR szCache, const CString& strCacheFileWithinCHM);
	

protected:

	DWORD dwCrcTable[256];

	void BuildCrcTable();
	DWORD ComputeCRC(LPCSTR sznBuffer, DWORD dwBufSize, DWORD dwAccum);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\crc.cpp ===
//
// MODULE: CRC.CPP
//
// PURPOSE: Cache File CRC Calculator Class
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 8/7/97
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.2		8/7/97		RM		Local Version for Memphis
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//

#include "stdafx.h"
#include "crc.h"

#include <stdlib.h>
#include <memory.h>

#include "ChmRead.h"

CCRC::CCRC() : POLYNOMIAL(0x04C11DB7)
{
	dwCrcTable[0] = 0;
	BuildCrcTable();
	return;
}

DWORD CCRC::DscEncode(LPCTSTR szDsc)
{
	DWORD dwBytesRead;
	DWORD dwCRCValue;
	const int BUF_SIZE = 4096;
	char sznInputFileBuf[BUF_SIZE + 1];
	if (NULL == szDsc)
	{
		CGenException *pErr = new CGenException;
		pErr->m_OsError = 0;
		pErr->m_strError = _T("The dsc file was not specified.");
		throw pErr;
	}
	// Read the source file.
	HANDLE hFile = CreateFile(szDsc,
						GENERIC_READ,
						FILE_SHARE_READ,
						NULL,
						OPEN_EXISTING,
						FILE_FLAG_SEQUENTIAL_SCAN,
						NULL);
	if (INVALID_HANDLE_VALUE == hFile)
	{
		CString strErr;
		CGenException *pErr = new CGenException;
		pErr->m_OsError = GetLastError();
		strErr = GlobFormatMessage(pErr->m_OsError);
		pErr->m_strError.Format(_T("Dsc file, %s was not opened.\nReason: %s"),
				szDsc, (LPCTSTR) strErr);
		throw pErr;
	}
	// Get the crc.
	dwCRCValue = 0xFFFFFFFF;
	do
	{
		if (!ReadFile(hFile, (LPVOID) sznInputFileBuf, BUF_SIZE, &dwBytesRead, NULL))
		{
			CString strErr;
			CGenException *pErr = new CGenException;
			pErr->m_OsError = GetLastError();
			strErr = GlobFormatMessage(pErr->m_OsError);
			pErr->m_strError.Format(_T("The dsc file, %s could not be read.\nReason: %s"),
					szDsc, (LPCTSTR) strErr);
			CloseHandle(hFile);
			throw pErr;
		}
		sznInputFileBuf[dwBytesRead] = NULL;
		dwCRCValue = ComputeCRC(sznInputFileBuf, dwBytesRead, dwCRCValue);
	} while(BUF_SIZE == dwBytesRead);
	CloseHandle(hFile);
	return dwCRCValue;
}

void CCRC::AppendCRC(LPCTSTR szCache, DWORD dwCRCValue)
{
	DWORD dwBytesWritten;
	// Open the cache file.
	HANDLE hDestFile = CreateFile(szCache,
						GENERIC_WRITE,
						0,	// No Sharing.
						NULL,
						OPEN_EXISTING,
						FILE_FLAG_WRITE_THROUGH |
						FILE_FLAG_SEQUENTIAL_SCAN,
						NULL);
	if (INVALID_HANDLE_VALUE == hDestFile)
	{
		CString strErr;
		CGenException *pErr = new CGenException;
		pErr->m_OsError = GetLastError();
		strErr = GlobFormatMessage(pErr->m_OsError);
		pErr->m_strError.Format(_T("The cache file, %s could not be opened.\nReason: %s"),
			szCache, (LPCTSTR) strErr);
		throw pErr;
	}	
	if (0xFFFFFFFF == SetFilePointer(hDestFile, 0, NULL, FILE_END))
	{
		CString strErr;
		CGenException *pErr = new CGenException;
		pErr->m_OsError = GetLastError();
		strErr = GlobFormatMessage(pErr->m_OsError);
		pErr->m_strError.Format(_T("Seek to end of the cache file, %s failed.\nReason: %s"),
			szCache, (LPCTSTR) strErr);
		CloseHandle(hDestFile);
		throw pErr;
	}
	// Append crc value.
	if (!WriteFile(hDestFile, (LPVOID) &dwCRCValue, 4, &dwBytesWritten, NULL))
	{
		CString strErr;
		CGenException *pErr = new CGenException;
		pErr->m_OsError = GetLastError();
		strErr = GlobFormatMessage(pErr->m_OsError);
		pErr->m_strError.Format(_T("The crc value was not appened to cache file %s.\nReason: %s"),
						szCache, (LPCTSTR) strErr);
		CloseHandle(hDestFile);
		throw pErr;
	}
	CloseHandle(hDestFile);
	if (4 != dwBytesWritten)
	{
		CString strErr;
		CGenException *pErr = new CGenException;
		pErr->m_OsError = GetLastError();
		strErr = GlobFormatMessage(pErr->m_OsError);
		pErr->m_strError.Format(_T("%d bytes of the crc were not appended to the cache file %s.Reason: %s"),
						4 - dwBytesWritten, szCache, (LPCTSTR) strErr);		
		throw pErr;
	}
	return;
}

bool CCRC::Decode(LPCTSTR szDsc, LPCTSTR szCache, const CString& strCacheFileWithinCHM)
{
	DWORD dwDecodeFileCrc;
	DWORD dwComputedCrc;
	DWORD dwBytesRead;
	DWORD dwLen;
	char sznDecodeBytes[5] = {0};
	bool bRet = true;
	bool bUseCHM = strCacheFileWithinCHM.GetLength() != 0;

	if (NULL == szDsc)
	{
		CGenException *pErr = new CGenException;
		pErr->m_OsError = 0;
		pErr->m_strError = _T("The source file was not specified.");
		throw pErr;
	}
	if (NULL == szCache)
	{
		CGenException *pErr = new CGenException;
		pErr->m_OsError = 0;
		pErr->m_strError = _T("The destination file was not specified.");
		throw pErr;
	}

	if (bUseCHM)
	{
		void* buf =NULL;

		if (S_OK != ::ReadChmFile(szCache, strCacheFileWithinCHM, &buf, &dwBytesRead))
		{
			CGenException *pErr = new CGenException;
			pErr->m_OsError = 0;
			pErr->m_strError = _T("Can not read cache from the CHM file.");
			throw pErr;
		}
		
		if (dwBytesRead < 5)
			return false;

		memcpy(sznDecodeBytes, (char*)buf + dwBytesRead - 4, 4);
	}
	else
	{
		// Read the source file.
		HANDLE hDecodeFile = CreateFile(szCache,
							GENERIC_READ,
							FILE_SHARE_READ,
							NULL,
							OPEN_EXISTING,
							FILE_FLAG_SEQUENTIAL_SCAN,
							NULL);
		if (INVALID_HANDLE_VALUE == hDecodeFile)
		{	// Should continue as if the check sums did not match.
			return false;
		}
		// Return false if the file is shorter than 1 byte + crc length.
		dwLen = GetFileSize(hDecodeFile, NULL);
		if (0xFFFFFFFF == dwLen)
		{
			CGenException *pExc = new CGenException;
			pExc->m_OsError = GetLastError();
			pExc->m_strOsMsg = GlobFormatMessage(pExc->m_OsError);
			pExc->m_strError.Format(
					_T("Could not get the size of cache file %s.\nReason: %s"),
					szCache, (LPCTSTR) pExc->m_strOsMsg);
			CloseHandle(hDecodeFile);
			throw pExc;
		}
		if (dwLen < 5)
		{
			CloseHandle(hDecodeFile);
			return false;
		}
		// Seek to end and backup 4 bytes.
		if (0xFFFFFFFF == SetFilePointer(hDecodeFile, -4, NULL, FILE_END))
		{
			CString strErr;
			CGenException *pErr = new CGenException;
			pErr->m_OsError = GetLastError();
			strErr = GlobFormatMessage(pErr->m_OsError);
			pErr->m_strError.Format(_T("Seek to end of the cache file, %s failed.\nReason: %s"),
				szCache, (LPCTSTR) strErr);
			CloseHandle(hDecodeFile);
			throw pErr;
		}
		if (!ReadFile(hDecodeFile, (LPVOID) sznDecodeBytes, 4, &dwBytesRead, NULL))
		{
			CString strErr;
			CGenException *pErr = new CGenException;
			pErr->m_OsError = GetLastError();
			strErr = GlobFormatMessage(pErr->m_OsError);
			pErr->m_strError.Format(_T("The cache file, %s could not be read.\nReason: %s"),
					szDsc, (LPCTSTR) strErr);
			CloseHandle(hDecodeFile);
			throw pErr;
		}
		if (4 != dwBytesRead)
		{
			CString strErr;
			CGenException *pErr = new CGenException;
			pErr->m_OsError = GetLastError();
			strErr = GlobFormatMessage(pErr->m_OsError);
			pErr->m_strError.Format(_T("%d bytes of the cache file were not read.\nReason: %s"),
					4 - dwBytesRead, szDsc, (LPCTSTR) strErr);
			CloseHandle(hDecodeFile);
			throw pErr;
		}
		CloseHandle(hDecodeFile);
	}
	
	// Read the crc.
	sznDecodeBytes[4] = NULL;
	DWORD byte;
	byte = (BYTE) sznDecodeBytes[0];
	dwDecodeFileCrc = byte;
	byte = (BYTE) sznDecodeBytes[1];
	byte <<= 8;
	dwDecodeFileCrc |= byte;
	byte = (BYTE) sznDecodeBytes[2];
	byte <<= 16;
	dwDecodeFileCrc |= byte;
	byte = (BYTE) sznDecodeBytes[3];
	byte <<= 24;
	dwDecodeFileCrc |= byte;
	// Get the crc value.
	dwComputedCrc = DscEncode(szDsc);
	if (dwComputedCrc != dwDecodeFileCrc)
		bRet = false;
	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\dnldlist.cpp ===
//
// MODULE:  DNLDIST.CPP
//
// PURPOSE: Downloads and installs the latest trouble shooters.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 6/4/96
//
// NOTES: 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//

#include "stdafx.h"

#include "apgts.h"
#include "dnldlist.h"

//--------------------------------------------------------------------
//
CDnldObj::CDnldObj(CString &sType,
				   CString &sFilename, 
				   DWORD dwVersion, 
				   CString &sFriendlyName, 
				   CString &sKeyName)
{
	m_sType = sType;
	m_sFilename = sFilename;
	m_sKeyname = sKeyName;
	m_dwVersion = dwVersion;
	m_sFriendlyName = sFriendlyName;
	
	// force all ext entries to .DSZ
	m_sExt = DSC_COMPRESSED;
	//	int pos = sFilename.Find(_T('.'));
	//	if (pos != -1) 
	//		m_sExt = sFilename.Right(sFilename.GetLength() - pos);
};

//
//
CDnldObj::~CDnldObj()
{
}

//--------------------------------------------------------------------
//
CDnldObjList::CDnldObjList()
{
	m_pos = NULL;
	m_pDnld = NULL;
}

//
//
CDnldObjList::~CDnldObjList()
{
	RemoveAll();
}

//
//
void CDnldObjList::RemoveHead()
{
	if (this->IsEmpty())
		return;

	CDnldObj *pDnld = (CDnldObj *)CObList::RemoveHead();
	if (pDnld)
		delete pDnld;
}

//
//
void CDnldObjList::AddTail(CDnldObj *pDnld)
{
	if (!pDnld)
		return;

	CObList::AddTail(pDnld);
}

//
//
void CDnldObjList::RemoveAll()
{
	CDnldObj *pDnld;
	POSITION pos;

	if(!this->IsEmpty()) 
	{
		pos = this->GetHeadPosition();
		while(pos != NULL) 
		{
			pDnld = (CDnldObj *)this->GetNext(pos);
			delete pDnld;
		}
	}

	CObList::RemoveAll();
}

//
//
VOID CDnldObjList::SetFirstItem()
{
	m_pDnld = NULL;
	m_pos = this->GetHeadPosition();
}

//
//
BOOL CDnldObjList::FindNextItem()
{
	if(this->IsEmpty()) 
		return FALSE;

	if (m_pos == NULL)
		return FALSE;

	m_pDnld = (CDnldObj *)this->GetNext(m_pos);
	return (m_pDnld != NULL);
}	

//
//
const CString CDnldObjList::GetCurrFile()
{
	if (m_pDnld == NULL)
		return _T("");

	return m_pDnld->m_sFilename;
}

//
//
const CString CDnldObjList::GetCurrFileKey()
{
	if (m_pDnld == NULL)
		return _T("");

	return m_pDnld->m_sKeyname;
}

//
//
const CString CDnldObjList::GetCurrFriendly()
{
	if (m_pDnld == NULL)
		return _T("");

	return m_pDnld->m_sFriendlyName;
}

//
//
const CString CDnldObjList::GetCurrType()
{
	if (m_pDnld == NULL)
		return _T("");

	return m_pDnld->m_sType;
}

//
//
const CString CDnldObjList::GetCurrExt()
{
	if (m_pDnld == NULL)
		return _T("");

	return m_pDnld->m_sExt;
}

//
//
DWORD CDnldObjList::GetCurrVersion()
{
	if (m_pDnld == NULL)
		return 0;

	return m_pDnld->m_dwVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\dnldlist.h ===
//
// MODULE:  DNLDIST.H
//
// PURPOSE: Downloads and installs the latest trouble shooters.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 6/4/96
//
// NOTES: Not supported functionality 3/98
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		3/24/98		JM		Local Version for NT5
//
//
//
class CDnldObj : public CObject
{
public:
	CDnldObj(CString &sType, CString &sFilename, DWORD dwVersion, CString &sFriendlyName, CString &sKeyName);
	~CDnldObj();

	CString m_sType;
	CString m_sFilename;
	CString m_sKeyname;
	DWORD m_dwVersion;
	CString m_sFriendlyName;
	CString	m_sExt;
};

//
//
class CDnldObjList : public CObList
{
public:
	CDnldObjList();
	~CDnldObjList();

	void RemoveHead();
	void RemoveAll();
	void AddTail(CDnldObj *pDnld);

	VOID SetFirstItem();
	BOOL FindNextItem();

	const CString GetCurrFile();
	const CString GetCurrFileKey();
	const CString GetCurrFriendly();
	const CString GetCurrType();
	const CString GetCurrExt();
	DWORD CDnldObjList::GetCurrVersion();

protected:

	POSITION m_pos;
	CDnldObj *m_pDnld;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\download.cpp ===
//
// MODULE:  DOWNLOAD.CPP
//
// PURPOSE: Downloads and installs the latest trouble shooters.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 6/4/96
//
// NOTES: 
// 1. Based on PROGRESS.CPP from Microsoft Platform Preview SDK
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//

#include "stdafx.h"

class CTSHOOTCtrl;


#include "download.h"
#include "dnldlist.h"

#include "TSHOOT.h"
#include "time.h"

#include "apgts.h"
#include "ErrorEnums.h"
#include "BasicException.h"
#include "apgtsfst.h"
#include "ErrorEnums.h"
#include "bnts.h"
#include "BackupInfo.h"
#include "cachegen.h"
#include "apgtsinf.h"
#include "apgtscmd.h"
#include "apgtshtx.h"
#include "apgtscls.h"

#include "TSHOOTCtl.h"

// ===========================================================================
//                     CBindStatusCallback Implementation
// ===========================================================================

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::CBindStatusCallback
// ---------------------------------------------------------------------------
CBindStatusCallback::CBindStatusCallback(CTSHOOTCtrl *pEvent, DLITEMTYPES dwItem)
{
    m_pbinding = NULL;
    m_pstm = NULL;
    m_cRef = 1;

	m_pEvent = pEvent;
	m_data = NULL;
	m_datalen = 0;
	m_dwItem = dwItem;

}  // CBindStatusCallback

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::~CBindStatusCallback
// ---------------------------------------------------------------------------
CBindStatusCallback::~CBindStatusCallback()
{
	if (m_data)
		delete[] m_data;
}  // ~CBindStatusCallback

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::QueryInterface
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;

    if (riid==IID_IUnknown || riid==IID_IBindStatusCallback)
        {
        *ppv = this;
        AddRef();
        return S_OK;
        }
    return E_NOINTERFACE;
}  // CBindStatusCallback::QueryInterface

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnStartBinding
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::OnStartBinding(DWORD dwReserved, IBinding* pbinding)
{
    if (m_pbinding != NULL)
        m_pbinding->Release();
    m_pbinding = pbinding;
    if (m_pbinding != NULL)
	{
        m_pbinding->AddRef();
		//m_pEvent->StatusEventHelper(m_dwItem, LTSC_STARTBIND);
	}
    return S_OK;
}  // CBindStatusCallback::OnStartBinding

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::GetPriority
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::GetPriority(LONG* pnPriority)
{
	return E_NOTIMPL;
}  // CBindStatusCallback::GetPriority

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnLowResource
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::OnLowResource(DWORD dwReserved)
{
    return E_NOTIMPL;
}  // CBindStatusCallback::OnLowResource

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnProgress
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText)
{
	m_pEvent->ProgressEventHelper(m_dwItem, ulProgress, (ulProgress>ulProgressMax)?ulProgress:ulProgressMax);

    return(NOERROR);
}  // CBindStatusCallback::OnProgress

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnStopBinding
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::OnStopBinding(HRESULT hrStatus, LPCWSTR pszError)
{
    if (hrStatus)
		m_pEvent->StatusEventHelper(m_dwItem, LTSCERR_STOPBINDINT, hrStatus & 0xFFFF, TRUE);
	else 
	{
		DLSTATTYPES dwStat = m_pEvent->ProcessReceivedData(m_dwItem, m_data, m_datalen);

		if (dwStat == LTSC_OK)
			m_pEvent->StatusEventHelper(m_dwItem, LTSC_STOPBIND, 0, TRUE);
		else
			m_pEvent->StatusEventHelper(m_dwItem, LTSCERR_STOPBINDPROC, dwStat, TRUE);
	}


	if (m_pbinding)
	{
		m_pbinding->Release();
		m_pbinding = NULL;
	}

    return S_OK;
}  // CBindStatusCallback::OnStopBinding

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::GetBindInfo
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindInfo)
{
    *pgrfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_PULLDATA;
    *pgrfBINDF |= BINDF_GETNEWESTVERSION | BINDF_NOWRITECACHE;
    pbindInfo->cbSize = sizeof(BINDINFO);
    pbindInfo->szExtraInfo = NULL;
    memset(&pbindInfo->stgmedData, 0, sizeof(STGMEDIUM));
    pbindInfo->grfBindInfoF = 0;
    pbindInfo->dwBindVerb = BINDVERB_GET;
    pbindInfo->szCustomVerb = NULL;
    return S_OK;
}  // CBindStatusCallback::GetBindInfo

 

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnDataAvailable
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC* pfmtetc, STGMEDIUM* pstgmed)
{
	HRESULT hr=S_OK;
	DWORD dStrlength=0;

	//m_pEvent->StatusEventHelper(m_dwItem, LTSC_START);

	// Get the Stream passed
    if (BSCF_FIRSTDATANOTIFICATION & grfBSCF)
    {
        if (!m_pstm && pstgmed->tymed == TYMED_ISTREAM)
	    {
		    m_pstm = pstgmed->pstm;
            if (m_pstm)
                m_pstm->AddRef();
			//m_pEvent->StatusEventHelper(m_dwItem, LTSC_FIRST);
    	}
    }

    // If there is some data to be read then go ahead and read them
    if (m_pstm && dwSize)
	{
        DWORD dwActuallyRead = 0;            // Placeholder for amount read during this pull

		do 
		{
			TCHAR * pNewstr = new TCHAR[dwSize + 1 + m_datalen];
			
			if (pNewstr==NULL) 
			{
				hr = S_FALSE;
				break;
			}

			hr = m_pstm->Read(&pNewstr[m_datalen], dwSize, &dwActuallyRead);

			if (dwActuallyRead) 
			{
				pNewstr[m_datalen + dwActuallyRead] = 0;

				if (m_data && m_datalen) 
				{
					memcpy(pNewstr, m_data, m_datalen);
					delete[] m_data;
					m_data = NULL;
				}

				//m_pEvent->StatusEventHelper(m_dwItem, LTSC_RCVDATA);

				m_data = pNewstr;
				m_datalen += dwActuallyRead;
			}
			else
				delete[] pNewstr;

		} while (!(hr == E_PENDING || hr == S_FALSE) && SUCCEEDED(hr));
	}

	if (BSCF_LASTDATANOTIFICATION & grfBSCF)
	{
        if (m_pstm)
            m_pstm->Release();

		hr=S_OK;  // If it was the last data then we should return S_OK as we just finished reading everything
	
		//m_pEvent->StatusEventHelper(m_dwItem, LTSC_DATADONE);
	}

	//m_pEvent->StatusEventHelper(m_dwItem, LTSC_STOP);

    return hr;
}  // CBindStatusCallback::OnDataAvailable

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnObjectAvailable
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::OnObjectAvailable(REFIID riid, IUnknown* punk)
{
    return E_NOTIMPL;
}  // CBindStatusCallback::OnObjectAvailable


// ===========================================================================
//                           CDownload Implementation
// ===========================================================================

// ---------------------------------------------------------------------------
// %%Function: CDownload::CDownload
// ---------------------------------------------------------------------------
CDownload::CDownload()
{
    m_pmk = 0;
    m_pbc = 0;
    m_pbsc = 0;
}  // CDownload

// ---------------------------------------------------------------------------
// %%Function: CDownload::~CDownload
// ---------------------------------------------------------------------------
CDownload::~CDownload()
{
    if (m_pmk)
        m_pmk->Release();
    if (m_pbc)
        m_pbc->Release();
    if (m_pbsc)
        m_pbsc->Release();
}  // ~CDownload

// ---------------------------------------------------------------------------
// %%Function: CDownload::DoDownload
// ---------------------------------------------------------------------------
 HRESULT
CDownload::DoDownload(CTSHOOTCtrl *pEvent, LPCTSTR pURL, DLITEMTYPES dwItem)
{
    IStream* pstm = NULL;
    HRESULT hr;
#ifndef _UNICODE
	WCHAR rgwchPath[MAX_PATH];
    MultiByteToWideChar(CP_ACP, 0, pURL, -1, rgwchPath, MAX_PATH);
    hr = CreateURLMoniker(NULL, rgwchPath, &m_pmk);
#else
	hr = CreateURLMoniker(NULL, pURL, &m_pmk);
#endif
    if (FAILED(hr))
        goto LErrExit;

    m_pbsc = new CBindStatusCallback(pEvent, dwItem);
    if (m_pbsc == NULL)
        {
        hr = E_OUTOFMEMORY;
        goto LErrExit;
        }
    hr = CreateBindCtx(0, &m_pbc);
    if (FAILED(hr))
        goto LErrExit;
    hr = RegisterBindStatusCallback(m_pbc,
            m_pbsc,
            0,
            0L);
    if (FAILED(hr))
        goto LErrExit;
    hr = m_pmk->BindToStorage(m_pbc, 0, IID_IStream, (void**)&pstm);
    if (FAILED(hr))
        goto LErrExit;
    return hr;
	while (S_OK == m_pmk->IsRunning(m_pbc, NULL, NULL));
			Sleep(200);
LErrExit:
    if (m_pbc != NULL)
        {
        m_pbc->Release();
        m_pbc = NULL;
        }
    if (m_pbsc != NULL)
        {
        m_pbsc->Release();
        m_pbsc = NULL;
        }
    if (m_pmk != NULL)
        {
        m_pmk->Release();
        m_pmk = NULL;
        }
	if (pstm)
		{
		pstm->Release();
		pstm = NULL;
		}
    return hr;
}  // CDownload::DoDownload
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\download.h ===
//
// MODULE:  DOWNLOAD.H
//
// PURPOSE: Downloads and installs the latest trouble shooters.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 6/4/96
//
// NOTES: 
// 1. Based on PROGRESS.CPP from Microsoft Platform Preview SDK
// 2. Not supported functionality 3/98
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		3/24/98		JM		Local Version for NT5
//
#include "urlmon.h"
#include "wininet.h"
#include "resource.h"
#include "commctrl.h"

#define EDIT_BOX_LIMIT 0x7FFF    //  The Edit box limit

//
#include "ErrorEnums.h"
//
enum DLITEMTYPES {
	DLITEM_INI = 0,
	DLITEM_DSC = 1,
};


//
//
class CDownload {
  public:
    CDownload();
    ~CDownload();
    HRESULT DoDownload(CTSHOOTCtrl *pEvent, LPCTSTR pURL, DLITEMTYPES dwItem);

  private:
    IMoniker*            m_pmk;
    IBindCtx*            m_pbc;
    IBindStatusCallback* m_pbsc;
};

//
//
class CBindStatusCallback : public IBindStatusCallback {
  public:
    // IUnknown methods
    STDMETHODIMP    QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef()    { return m_cRef++; }
    STDMETHODIMP_(ULONG)    Release()   { if (--m_cRef == 0) { delete this; return 0; } return m_cRef; }

    // IBindStatusCallback methods
    STDMETHODIMP    OnStartBinding(DWORD dwReserved, IBinding* pbinding);
    STDMETHODIMP    GetPriority(LONG* pnPriority);
    STDMETHODIMP    OnLowResource(DWORD dwReserved);
    STDMETHODIMP    OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode,
                        LPCWSTR pwzStatusText);
    STDMETHODIMP    OnStopBinding(HRESULT hrResult, LPCWSTR szError);
    STDMETHODIMP    GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindinfo);
    STDMETHODIMP    OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pfmtetc,
                        STGMEDIUM* pstgmed);
    STDMETHODIMP    OnObjectAvailable(REFIID riid, IUnknown* punk);

    // constructors/destructors
    CBindStatusCallback(CTSHOOTCtrl *pEvent, DLITEMTYPES dwItem);
    ~CBindStatusCallback();

    // data members
    DWORD           m_cRef;
    IBinding*       m_pbinding;
	IStream*        m_pstm;

	CTSHOOTCtrl *m_pEvent;
	DLITEMTYPES m_dwItem;

	TCHAR *m_data;
	int m_datalen;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\errorenums.h ===
//
// MODULE: ERRORENUMS.H
//
// PURPOSE: Defines error messages that are returned by GetExtendedError.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 6/4/96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		3/24/98		JM		Local Version for NT5
//

// Error numbers for the ocx.

#ifndef __ERRORENUMS_H_RWM
#define __ERRORENUMS_H_RWM

// All of the error values in this file need to be unique.

// The original error messages from the server version.
#include "apgtsevt.h"

// Errors for the down load portion.
// These are hresults.

// GetExtendedError returns the lower 16 bits.

enum DLSTATTYPES {

	// normal
	LTSC_OK	=			0,
	LTSC_STARTBIND,		//1
	LTSC_RCVDATA,		//2
	LTSC_DATADONE,		//3
	LTSC_STOPBIND,		//4
	LTSC_NOMOREITEMS,	//5


	LTSC_START = 10,
	LTSC_STOP = 10,
	LTSC_FIRST = 20,

	// error
	LTSCERR_NOPATH =		1000,
	LTSCERR_NOMEM,			//1001
	LTSCERR_DNLD,			//1002
	LTSCERR_STOPBINDINT,	//1003
	LTSCERR_STOPBINDPROC,	//1004
	LTSCERR_UNSUPP,			//1005
	LTSCERR_NOITEMS,		//1006
	LTSCERR_UNKNATYPE,		//1007
	LTSCERR_DNLDNOTDONE,	//1008
	LTSCERR_FILEUPDATE,		//1009
	LTSCERR_BASEKQ,			//1010
	LTSCERR_NOBASEPATH,		//1011

	
	// extended error for debugging
	LTSCERR_PARAMMISS =		2000,
	LTSCERR_PARAMSLASH,		//2001
	LTSCERR_PARAMNODOT,		//2002
	LTSCERR_KEYOPEN,		//2003
	LTSCERR_KEYOPEN2,		//2004
	LTSCERR_KEYQUERY,		//2005
	LTSCERR_KEYCREATE,		//2006
	LTSCERR_KEYUNSUPP,		//2007
	LTSCERR_FILEWRITE,		//2008
	LTSCERR_KEYSET1,		//2009
	LTSCERR_KEYSET2,		//2010
	LTSCERR_KEYSET3,		//2011
	LTSCERR_BADTYPE,		//2012
	LTSCERR_CABWRITE,		//2013
	

	// Trouble Shooter Codes
	TSERR_SCRIPT				= ((DWORD)0xC0000800L),		// Parameters from VB not decoded.
	TSERR_ENGINE				= ((DWORD)0xC0000801L),		// DSC file could not be loaded.
	TSERR_ENGINE_BNTS			= ((DWORD)0xC0001801L),		// DSC file could not be loaded.  BNTS library did not understand it.
	TSERR_ENGINE_BNTS_REC		= ((DWORD)0xC0002801L),		// DSC file could not be loaded.  BNTS library did not understand it.
	TSERR_ENGINE_BNTS_READ		= ((DWORD)0xC0003801L),		// DSC file could not be loaded.  BNTS library did not understand it.
	TSERR_ENGINE_BNTS_READ_CAB	= ((DWORD)0xC0004801L),		// DSC file could not be loaded.  BNTS library did not understand it.
	TSERR_ENGINE_BNTS_READ_CACH	= ((DWORD)0xC0005801L),		// DSC file could not be loaded.  BNTS library did not understand it.
	TSERR_ENGINE_BNTS_READ_NCAB	= ((DWORD)0xC0006801L),		// DSC file could not be loaded.  BNTS library did not understand it.
	TSERR_ENGINE_BNTS_CHECK		= ((DWORD)0xC0007801L),		// DSC file could not be loaded.  BNTS library did not understand it.
	TSERR_ENGINE_BNTS_READ_GEN	= ((DWORD)0xC0008801L),		// DSC file could not be loaded.  BNTS library did not understand it.
	TSERR_ENGINE_EXTRACT		= ((DWORD)0xC0009801L),		// DSC file could not be loaded.  Cab file not extracted properly.
	TSERR_ENGINE_CACHE_LOW		= ((DWORD)0xC0009802L),		// Had a tsc cache miss while converting symoblic node names to numbers.

	TSERR_RESOURCE			= ((DWORD)0xC0000802L),		// HTI file or other resource not loaded.
	TSERR_RES_MISSING		= ((DWORD)0xC0000803L),		// An include file is missing.
	TSERR_AT_START			= ((DWORD)0xC0000804L),		// Can not backup from the problem page.
	TSERR_NOT_STARTED		= ((DWORD)0xC0000805L),		// Can not use the ProblemPage to start the trouble shooter.
	TSERR_LIB_STATE_INFO	= ((DWORD)0xC0000806L),		// Could not get an interface to the state info class.

};

// Throws a CBasicException.
void ReportError(DLSTATTYPES Error);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\enumstd.h ===
//
// MODULE:  ENUMSTD.H
//
// PURPOSE: enumerations relevant to belief networks
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Apparently originated at MSR
// 
// ORIGINAL DATE: unknown
//
// NOTES: 
// 1. included because we use ESTDLBL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.3		3/24/98		JM		Local Version for NT5

#ifndef _ENUMSTD_H_
#define _ENUMSTD_H_

////////////////////////////////////////////////////////////////////
//	Property flags
////////////////////////////////////////////////////////////////////
const UINT fPropString = 1;			//  Property is a string (!fPropString ==> real)
const UINT fPropArray = 2;			//	Property is an array (!fPropArray  ==> scalar)
const UINT fPropChoice = 4;			//	Property is an enumerated value
const UINT fPropStandard = 8;		//  Property is standard (stored in Registry)
const UINT fPropPersist = 16;		//  Property is persistent (stored in Registry)

////////////////////////////////////////////////////////////////////
//	Definitions to enable usage of "MS_" standard properties
////////////////////////////////////////////////////////////////////
enum ESTDPROP
{
	ESTDP_label,			//  Node troubleshooting label (choice)
	ESTDP_cost_fix,			//  Cost to fix	(real)
	ESTDP_cost_observe,		//  Cost to observe (real)
	ESTDP_category,			//  Category (string)
	ESTDP_normalState,		//  Index of troubleshooting "normal" state (int)
	ESTDP_max				//  End
};

enum ESTDLBL		//  VOI-relative node label
{
	ESTDLBL_other,
	ESTDLBL_hypo,
	ESTDLBL_info,
	ESTDLBL_problem,
	ESTDLBL_fixobs,
	ESTDLBL_fixunobs,
	ESTDLBL_unfix,
	ESTDLBL_config,
	ESTDLBL_max
};


#endif // _ENUMSTD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\fdi.h ===
/*
 *  FDI.H -- File Decompression Interface
 *
 *  Copyright (C) Microsoft Corporation 1993-1997
 *  All Rights Reserved.
 */

#ifdef  __cplusplus
extern "C" {
#endif

#ifndef INCLUDED_TYPES_FCI_FDI
#define INCLUDED_TYPES_FCI_FDI 1

#ifndef HUGE
#define HUGE
#endif

#ifndef FAR
#define FAR
#endif

#ifndef DIAMONDAPI
#define DIAMONDAPI __cdecl
#endif


//** Specify structure packing explicitly for clients of FDI
#pragma pack(4)

//** Don't redefine types defined in Win16 WINDOWS.H (_INC_WINDOWS)
//   or Win32 WINDOWS.H (_WINDOWS_)
//
#if !defined(_INC_WINDOWS) && !defined(_WINDOWS_)
typedef int            BOOL;     /* f */
typedef unsigned char  BYTE;     /* b */
typedef unsigned int   UINT;     /* ui */
typedef unsigned short USHORT;   /* us */
typedef unsigned long  ULONG;    /* ul */
#endif   // _INC_WINDOWS

typedef unsigned long  CHECKSUM; /* csum */

typedef unsigned long  UOFF;     /* uoff - uncompressed offset */
typedef unsigned long  COFF;     /* coff - cabinet file offset */


#ifndef TRUE
#define TRUE    1
#endif

#ifndef FALSE
#define FALSE   0
#endif

#ifndef NULL
#define NULL    0
#endif

#ifdef _DEBUG
// don't hide statics from map during debugging
#define STATIC      
#else // !DEBUG
#define STATIC static
#endif // !DEBUG

#define CB_MAX_CHUNK            32768U
#define CB_MAX_DISK         0x7ffffffL
#define CB_MAX_FILENAME            256
#define CB_MAX_CABINET_NAME        256
#define CB_MAX_CAB_PATH            256
#define CB_MAX_DISK_NAME           256

/***    tcompXXX - Compression types
 *
 *  These are passed to FCIAddFile(), and are also stored in the CFFOLDER
 *  structures in cabinet files.
 *
 *  NOTE: We reserve bits for the TYPE, QUANTUM_LEVEL, and QUANTUM_MEM
 *        to provide room for future expansion.  Since this value is stored
 *        in the CFDATA records in the cabinet file, we don't want to
 *        have to change the format for existing compression configurations
 *        if we add new ones in the future.  This will allows us to read
 *        old cabinet files in the future.
 */

typedef unsigned short TCOMP; /* tcomp */

#define tcompMASK_TYPE          0x000F  // Mask for compression type
#define tcompTYPE_NONE          0x0000  // No compression
#define tcompTYPE_MSZIP         0x0001  // MSZIP
#define tcompTYPE_QUANTUM       0x0002  // Quantum
#define tcompTYPE_LZX           0x0003  // LZX
#define tcompBAD                0x000F  // Unspecified compression type

#define tcompMASK_LZX_WINDOW    0x1F00  // Mask for LZX Compression Memory
#define tcompLZX_WINDOW_LO      0x0F00  // Lowest LZX Memory (15)
#define tcompLZX_WINDOW_HI      0x1500  // Highest LZX Memory (21)
#define tcompSHIFT_LZX_WINDOW        8  // Amount to shift over to get int

#define tcompMASK_QUANTUM_LEVEL 0x00F0  // Mask for Quantum Compression Level
#define tcompQUANTUM_LEVEL_LO   0x0010  // Lowest Quantum Level (1)
#define tcompQUANTUM_LEVEL_HI   0x0070  // Highest Quantum Level (7)
#define tcompSHIFT_QUANTUM_LEVEL     4  // Amount to shift over to get int

#define tcompMASK_QUANTUM_MEM   0x1F00  // Mask for Quantum Compression Memory
#define tcompQUANTUM_MEM_LO     0x0A00  // Lowest Quantum Memory (10)
#define tcompQUANTUM_MEM_HI     0x1500  // Highest Quantum Memory (21)
#define tcompSHIFT_QUANTUM_MEM       8  // Amount to shift over to get int

#define tcompMASK_RESERVED      0xE000  // Reserved bits (high 3 bits)



#define CompressionTypeFromTCOMP(tc) \
            ((tc) & tcompMASK_TYPE)

#define CompressionLevelFromTCOMP(tc) \
            (((tc) & tcompMASK_QUANTUM_LEVEL) >> tcompSHIFT_QUANTUM_LEVEL)

#define CompressionMemoryFromTCOMP(tc) \
            (((tc) & tcompMASK_QUANTUM_MEM) >> tcompSHIFT_QUANTUM_MEM)

#define TCOMPfromTypeLevelMemory(t,l,m)           \
            (((m) << tcompSHIFT_QUANTUM_MEM  ) |  \
             ((l) << tcompSHIFT_QUANTUM_LEVEL) |  \
             ( t                             ))

#define LZXCompressionWindowFromTCOMP(tc) \
            (((tc) & tcompMASK_LZX_WINDOW) >> tcompSHIFT_LZX_WINDOW)

#define TCOMPfromLZXWindow(w)      \
            (((w) << tcompSHIFT_LZX_WINDOW ) |  \
             ( tcompTYPE_LZX ))


//** Revert to default structure packing
#pragma pack()

#endif // !INCLUDED_TYPES_FCI_FDI

/*
 *  Concepts:
 *      A *cabinet* file contains one or more *folders*.  A folder contains
 *      one or more (pieces of) *files*.  A folder is by definition a
 *      decompression unit, i.e., to extract a file from a folder, all of
 *      the data from the start of the folder up through and including the
 *      desired file must be read and decompressed.
 *
 *      A folder can span one (or more) cabinet boundaries, and by implication
 *      a file can also span one (or more) cabinet boundaries.  Indeed, more
 *      than one file can span a cabinet boundary, since FCI concatenates
 *      files together into a single data stream before compressing (actually,
 *      at most one file will span any one cabinet boundary, but FCI does
 *      not know which file this is, since the mapping from uncompressed bytes
 *      to compressed bytes is pretty obscure.  Also, since FCI compresses
 *      in blocks of 32K (at present), any files with data in a 32K block that
 *      spans a cabinet boundary require FDI to read both cabinet files
 *      to get the two halves of the compressed block).
 *
 *  Overview:
 *      The File Decompression Interface is used to simplify the reading of
 *      cabinet files.  A setup program will proceed in a manner very
 *      similar to the pseudo code below.  An FDI context is created, the
 *      setup program calls FDICopy() for each cabinet to be processed.  For
 *      each file in the cabinet, FDICopy() calls a notification callback
 *      routine, asking the setup program if the file should be copied.
 *      This call-back approach is great because it allows the cabinet file
 *      to be read and decompressed in an optimal manner, and also makes FDI
 *      independent of the run-time environment -- FDI makes *no* C run-time
 *      calls whatsoever.  All memory allocation and file I/O functions are
 *      passed into FDI by the client.
 *
 *      main(...)
 *      {
 *          // Read INF file to construct list of desired files.   
 *          //  Ideally, these would be sorted in the same order as the
 *          //  files appear in the cabinets, so that you can just walk
 *          //  down the list in response to fdintCOPY_FILE notifications.
 *
 *          // Construct list of required cabinets. 
 *
 *          hfdi = FDICreate(...);          // Create FDI context
 *          For (cabinet in List of Cabinets) {
 *              FDICopy(hfdi,cabinet,fdiNotify,...);  // Process each cabinet
 *          }
 *          FDIDestroy(hfdi);
 *          ...
 *      }
 *
 *      // Notification callback function 
 *      fdiNotify(fdint,...)
 *      {
 *          If (User Aborted)               // Permit cancellation
 *              if (fdint == fdintCLOSE_FILE_INFO)
 *                  close open file
 *              return -1;
 *          switch (fdint) {
 *              case fdintCOPY_FILE:        // File to copy, maybe
 *                  // Check file against list of desired files 
 *                  if want to copy file
 *                      open destination file and return handle
 *                  else
 *                      return NULL;        // Skip file
 *              case fdintCLOSE_FILE_INFO:
 *                  close file
 *                  set date, time, and attributes
 *
 *              case fdintNEXT_CABINET:
 *                  if not an error callback
 *                      Tell FDI to use suggested directory name
 *                  else
 *                      Tell user what the problem was, and prompt
 *                          for a new disk and/or path.
 *                      if user aborts
 *                          Tell FDI to abort
 *                      else
 *                          return to FDI to try another cabinet
 *
 *              default:
 *                  return 0;               // more messages may be defined
 *              ...
 *      }
 *
 *  Error Handling Suggestions:
 *      Since you the client have passed in *all* of the functions that
 *      FDI uses to interact with the "outside" world, you are in prime
 *      position to understand and deal with errors.
 *
 *      The general philosophy of FDI is to pass all errors back up to
 *      the client.  FDI returns fairly generic error codes in the case
 *      where one of the callback functions (PFNOPEN, PFNREAD, etc.) fail,
 *      since it assumes that the callback function will save enough
 *      information in a static/global so that when FDICopy() returns
 *      fail, the client can examine this information and report enough
 *      detail about the problem that the user can take corrective action.
 *
 *      For very specific errors (CORRUPT_CABINET, for example), FDI returns
 *      very specific error codes.
 *
 *      THE BEST POLICY IS FOR YOUR CALLBACK ROUTINES TO AVOID RETURNING
 *      ERRORS TO FDI!
 *
 *      Examples:
 *          (1) If the disk is getting full, instead of returning an error
 *              from your PFNWRITE function, you should -- inside your
 *              PFNWRITE function -- put up a dialog telling the user to free
 *              some disk space.
 *          (2) When you get the fdintNEXT_CABINET notification, you should
 *              verify that the cabinet you return is the correct one (call
 *              FDIIsCabinet(), and make sure the setID matches the one for
 *              the current cabinet specified in the fdintCABINET_INFO, and
 *              that the disk number is one greater.
 *
 *              NOTE: FDI will continue to call fdintNEXT_CABINET until it
 *                    gets the cabinet it wants, or until you return -1
 *                    to abort the FDICopy() call.
 *
 *      The documentation below on the FDI error codes provides explicit
 *      guidance on how to avoid each error.
 *
 *      If you find you must return a failure to FDI from one of your
 *      callback functions, then FDICopy() frees all resources it allocated
 *      and closes all files.  If you can figure out how to overcome the
 *      problem, you can call FDICopy() again on the last cabinet, and
 *      skip any files that you already copied.  But, note that FDI does
 *      *not* maintain any state between FDICopy() calls, other than possibly
 *      memory allocated for the decompressor.
 *
 *      See FDIERROR for details on FDI error codes and recommended actions.
 *
 *
 *  Progress Indicator Suggestions:
 *      As above, all of the file I/O functions are supplied by you.  So,
 *      updating a progress indicator is very simple.  You keep track of
 *      the target files handles you have opened, along with the uncompressed
 *      size of the target file.  When you see writes to the handle of a
 *      target file, you use the write count to update your status!
 *      Since this method is available, there is no separate callback from
 *      FDI just for progess indication.
 */

#ifndef INCLUDED_FDI
#define INCLUDED_FDI    1

//** Specify structure packing explicitly for clients of FDI
#pragma pack(4)


/***    FDIERROR - Error codes returned in erf.erfOper field
 *
 *  In general, FDI will only fail if one of the passed in memory or
 *  file I/O functions fails.  Other errors are pretty unlikely, and are
 *  caused by corrupted cabinet files, passing in a file which is not a
 *  cabinet file, or cabinet files out of order.
 *
 *  Description:    Summary of error.
 *  Cause:          List of possible causes of this error.
 *  Response:       How client might respond to this error, or avoid it in
 *                  the first place.
 */
typedef enum {
    FDIERROR_NONE,
        // Description: No error
        // Cause:       Function was successfull.
        // Response:    Keep going!

    FDIERROR_CABINET_NOT_FOUND,
        // Description: Cabinet not found
        // Cause:       Bad file name or path passed to FDICopy(), or returned
        //              to fdintNEXT_CABINET.
        // Response:    To prevent this error, validate the existence of the
        //              the cabinet *before* passing the path to FDI.

    FDIERROR_NOT_A_CABINET,
        // Description: Cabinet file does not have the correct format
        // Cause:       File passed to to FDICopy(), or returned to
        //              fdintNEXT_CABINET, is too small to be a cabinet file,
        //              or does not have the cabinet signature in its first
        //              four bytes.
        // Response:    To prevent this error, call FDIIsCabinet() to check a
        //              cabinet before calling FDICopy() or returning the
        //              cabinet path to fdintNEXT_CABINET.

    FDIERROR_UNKNOWN_CABINET_VERSION,
        // Description: Cabinet file has an unknown version number.
        // Cause:       File passed to to FDICopy(), or returned to
        //              fdintNEXT_CABINET, has what looks like a cabinet file
        //              header, but the version of the cabinet file format
        //              is not one understood by this version of FDI.  The
        //              erf.erfType field is filled in with the version number
        //              found in the cabinet file.
        // Response:    To prevent this error, call FDIIsCabinet() to check a
        //              cabinet before calling FDICopy() or returning the
        //              cabinet path to fdintNEXT_CABINET.

    FDIERROR_CORRUPT_CABINET,
        // Description: Cabinet file is corrupt
        // Cause:       FDI returns this error any time it finds a problem
        //              with the logical format of a cabinet file, and any
        //              time one of the passed-in file I/O calls fails when
        //              operating on a cabinet (PFNOPEN, PFNSEEK, PFNREAD,
        //              or PFNCLOSE).  The client can distinguish these two
        //              cases based upon whether the last file I/O call
        //              failed or not.
        // Response:    Assuming this is not a real corruption problem in
        //              a cabinet file, the file I/O functions could attempt
        //              to do retries on failure (for example, if there is a
        //              temporary network connection problem).  If this does
        //              not work, and the file I/O call has to fail, then the
        //              FDI client will have to clean up and call the
        //              FDICopy() function again.

    FDIERROR_ALLOC_FAIL,
        // Description: Could not allocate enough memory
        // Cause:       FDI tried to allocate memory with the PFNALLOC
        //              function, but it failed.
        // Response:    If possible, PFNALLOC should take whatever steps
        //              are possible to allocate the memory requested.  If
        //              memory is not immediately available, it might post a
        //              dialog asking the user to free memory, for example.
        //              Note that the bulk of FDI's memory allocations are
        //              made at FDICreate() time and when the first cabinet
        //              file is opened during FDICopy().

    FDIERROR_BAD_COMPR_TYPE,
        // Description: Unknown compression type in a cabinet folder
        // Cause:       [Should never happen.]  A folder in a cabinet has an
        //              unknown compression type.  This is probably caused by
        //              a mismatch between the version of FCI.LIB used to
        //              create the cabinet and the FDI.LIB used to read the
        //              cabinet.
        // Response:    Abort.

    FDIERROR_MDI_FAIL,
        // Description: Failure decompressing data from a cabinet file
        // Cause:       The decompressor found an error in the data coming
        //              from the file cabinet.  The cabinet file was corrupted.
        //              [11-Apr-1994 bens When checksuming is turned on, this
        //              error should never occur.]
        // Response:    Probably should abort; only other choice is to cleanup
        //              and call FDICopy() again, and hope there was some
        //              intermittent data error that will not reoccur.

    FDIERROR_TARGET_FILE,
        // Description: Failure writing to target file
        // Cause:       FDI returns this error any time it gets an error back
        //              from one of the passed-in file I/O calls fails when
        //              writing to a file being extracted from a cabinet.
        // Response:    To avoid or minimize this error, the file I/O functions
        //              could attempt to avoid failing.  A common cause might
        //              be disk full -- in this case, the PFNWRITE function
        //              could have a check for free space, and put up a dialog
        //              asking the user to free some disk space.

    FDIERROR_RESERVE_MISMATCH,
        // Description: Cabinets in a set do not have the same RESERVE sizes
        // Cause:       [Should never happen]. FDI requires that the sizes of
        //              the per-cabinet, per-folder, and per-data block
        //              RESERVE sections be consistent across all the cabinets
        //              in a set.
        // Response:    Abort.

    FDIERROR_WRONG_CABINET,
        // Description: Cabinet returned on fdintNEXT_CABINET is incorrect
        // Cause:       NOTE: THIS ERROR IS NEVER RETURNED BY FDICopy()!
        //              Rather, FDICopy() keeps calling the fdintNEXT_CABINET
        //              callback until either the correct cabinet is specified,
        //              or you return ABORT.
        //              When FDICopy() is extracting a file that crosses a
        //              cabinet boundary, it calls fdintNEXT_CABINET to ask
        //              for the path to the next cabinet.  Not being very
        //              trusting, FDI then checks to make sure that the
        //              correct continuation cabinet was supplied!  It does
        //              this by checking the "setID" and "iCabinet" fields
        //              in the cabinet.  When MAKECAB.EXE creates a set of
        //              cabinets, it constructs the "setID" using the sum
        //              of the bytes of all the destination file names in
        //              the cabinet set.  FDI makes sure that the 16-bit
        //              setID of the continuation cabinet matches the
        //              cabinet file just processed.  FDI then checks that
        //              the cabinet number (iCabinet) is one more than the
        //              cabinet number for the cabinet just processed.
        // Response:    You need code in your fdintNEXT_CABINET (see below)
        //              handler to do retries if you get recalled with this
        //              error.  See the sample code (EXTRACT.C) to see how
        //              this should be handled.

    FDIERROR_USER_ABORT,
        // Description: FDI aborted.
        // Cause:       An FDI callback returnd -1 (usually).
        // Response:    Up to client.

} FDIERROR;

/***    ERF - Error structure
 *
 *  This structure returns error information from FCI/FDI.  The caller should
 *  not modify this structure.
 */
typedef struct {
    FDIERROR erfOper;            // FCI/FDI error code -- see FDIERROR_XXX
                                //  and FCIERR_XXX equates for details.

    int     erfType;            // Optional error value filled in by FCI/FDI.
                                // For FCI, this is usually the C run-time
                                // *errno* value.

    BOOL    fError;             // TRUE => error present
} ERF;      /* erf */
typedef ERF FAR *PERF;  /* perf */

/*
 * FAT file attribute flag used by FCI/FDI to indicate that
 * the filename in the CAB is a UTF string
 */
#ifndef _A_NAME_IS_UTF
#define _A_NAME_IS_UTF  0x80
#endif

/*
 * FAT file attribute flag used by FCI/FDI to indicate that
 * the file should be executed after extraction
 */
#ifndef _A_EXEC
#define _A_EXEC         0x40
#endif


/***    HFDI - Handle to an FDI context
 *
 *  FDICreate() creates this, and it must be passed to all other FDI
 *  functions.
 */
typedef void FAR *HFDI; /* hfdi */


/***    FDICABINETINFO - Information about a cabinet
 *
 */
typedef struct {
    long        cbCabinet;              // Total length of cabinet file
    USHORT      cFolders;               // Count of folders in cabinet
    USHORT      cFiles;                 // Count of files in cabinet
    USHORT      setID;                  // Cabinet set ID
    USHORT      iCabinet;               // Cabinet number in set (0 based)
    BOOL        fReserve;               // TRUE => RESERVE present in cabinet
    BOOL        hasprev;                // TRUE => Cabinet is chained prev
    BOOL        hasnext;                // TRUE => Cabinet is chained next
} FDICABINETINFO; /* fdici */
typedef FDICABINETINFO FAR *PFDICABINETINFO; /* pfdici */


/***    FDIDECRYPTTYPE - PFNFDIDECRYPT command types
 *
 */
typedef enum {
    fdidtNEW_CABINET,                   // New cabinet
    fdidtNEW_FOLDER,                    // New folder
    fdidtDECRYPT,                       // Decrypt a data block
} FDIDECRYPTTYPE; /* fdidt */


/***    FDIDECRYPT - Data for PFNFDIDECRYPT function
 *
 */
typedef struct {
    FDIDECRYPTTYPE    fdidt;            // Command type (selects union below)
    void FAR         *pvUser;           // Decryption context
    union {
        struct {                        // fdidtNEW_CABINET
            void FAR *pHeaderReserve;   // RESERVE section from CFHEADER
            USHORT    cbHeaderReserve;  // Size of pHeaderReserve
            USHORT    setID;            // Cabinet set ID
            int       iCabinet;         // Cabinet number in set (0 based)
        } cabinet;

        struct {                        // fdidtNEW_FOLDER
            void FAR *pFolderReserve;   // RESERVE section from CFFOLDER
            USHORT    cbFolderReserve;  // Size of pFolderReserve
            USHORT    iFolder;          // Folder number in cabinet (0 based)
        } folder;

        struct {                        // fdidtDECRYPT
            void FAR *pDataReserve;     // RESERVE section from CFDATA
            USHORT    cbDataReserve;    // Size of pDataReserve
            void FAR *pbData;           // Data buffer
            USHORT    cbData;           // Size of data buffer
            BOOL      fSplit;           // TRUE if this is a split data block
            USHORT    cbPartial;        // 0 if this is not a split block, or
                                        //  the first piece of a split block;
                                        // Greater than 0 if this is the
                                        //  second piece of a split block.
        } decrypt;
    };
} FDIDECRYPT; /* fdid */
typedef FDIDECRYPT FAR *PFDIDECRYPT; /* pfdid */


/***    FNALLOC - Memory Allocation
 *      FNFREE  - Memory Free
 *
 *  These are modeled after the C run-time routines malloc() and free()
 *  FDI expects error handling to be identical to these C run-time routines.
 *
 *  As long as you faithfully copy the semantics of malloc() and free(),
 *  you can supply any functions you like!
 *
 *  WARNING: You should never assume anything about the sequence of
 *           PFNALLOC and PFNFREE calls -- incremental releases of
 *           FDI may have radically different numbers of
 *           PFNALLOC calls and allocation sizes!
 */
//** Memory functions for FDI
typedef void HUGE * (FAR DIAMONDAPI *PFNALLOC)(ULONG cb); /* pfna */
#define FNALLOC(fn) void HUGE * FAR DIAMONDAPI fn(ULONG cb)

typedef void (FAR DIAMONDAPI *PFNFREE)(void HUGE *pv); /* pfnf */
#define FNFREE(fn) void FAR DIAMONDAPI fn(void HUGE *pv)


/***    PFNOPEN  - File I/O callbacks for FDI
 *      PFNREAD
 *      PFNWRITE
 *      PFNCLOSE
 *      PFNSEEK
 *
 *  These are modeled after the C run-time routines _open, _read,
 *  _write, _close, and _lseek.  The values for the PFNOPEN oflag
 *  and pmode calls are those defined for _open.  FDI expects error
 *  handling to be identical to these C run-time routines.
 *
 *  As long as you faithfully copy these aspects, you can supply
 *  any functions you like!
 *
 *  WARNING: You should never assume you know what file is being
 *           opened at any one point in time!  FDI will usually
 *           stick to opening cabinet files, but it is possible
 *           that in a future implementation it may open temporary
 *           files or open cabinet files in a different order.
 *
 *  Notes for Memory Mapped File fans:
 *      You can write wrapper routines to allow FDI to work on memory
 *      mapped files.  You'll have to create your own "handle" type so that
 *      you can store the base memory address of the file and the current
 *      seek position, and then you'll allocate and fill in one of these
 *      structures and return a pointer to it in response to the PFNOPEN
 *      call and the fdintCOPY_FILE call.  Your PFNREAD and PFNWRITE
 *      functions will do memcopy(), and update the seek position in your
 *      "handle" structure.  PFNSEEK will just change the seek position
 *      in your "handle" structure.
 */
//** File I/O functions for FDI
typedef int  (FAR DIAMONDAPI *PFNOPEN) (char FAR *pszFile, int oflag, int pmode);
typedef UINT (FAR DIAMONDAPI *PFNREAD) (int hf, void FAR *pv, UINT cb);
typedef UINT (FAR DIAMONDAPI *PFNWRITE)(int hf, void FAR *pv, UINT cb);
typedef int  (FAR DIAMONDAPI *PFNCLOSE)(int hf);
typedef long (FAR DIAMONDAPI *PFNSEEK) (int hf, long dist, int seektype);

#define FNOPEN(fn) int FAR DIAMONDAPI fn(char FAR *pszFile, int oflag, int pmode)
#define FNREAD(fn) UINT FAR DIAMONDAPI fn(int hf, void FAR *pv, UINT cb)
#define FNWRITE(fn) UINT FAR DIAMONDAPI fn(int hf, void FAR *pv, UINT cb)
#define FNCLOSE(fn) int FAR DIAMONDAPI fn(int hf)
#define FNSEEK(fn) long FAR DIAMONDAPI fn(int hf, long dist, int seektype)



/***    PFNFDIDECRYPT - FDI Decryption callback
 *
 *  If this function is passed on the FDICopy() call, then FDI calls it
 *  at various times to update the decryption state and to decrypt FCDATA
 *  blocks.
 *
 *  Common Entry Conditions:
 *      pfdid->fdidt  - Command type
 *      pfdid->pvUser - pvUser value from FDICopy() call
 *
 *  fdidtNEW_CABINET:   //** Notification of a new cabinet
 *      Entry:
 *        pfdid->cabinet.
 *          pHeaderReserve  - RESERVE section from CFHEADER
 *          cbHeaderReserve - Size of pHeaderReserve
 *          setID           - Cabinet set ID
 *          iCabinet        - Cabinet number in set (0 based)
 *      Exit-Success:
 *          returns anything but -1;
 *      Exit-Failure:
 *          returns -1; FDICopy() is aborted.
 *      Notes:
 *      (1) This call allows the decryption code to pick out any information
 *          from the cabinet header reserved area (placed there by DIACRYPT)
 *          needed to perform decryption.  If there is no such information,
 *          this call would presumably be ignored.
 *      (2) This call is made very soon after fdintCABINET_INFO.
 *
 *  fdidtNEW_FOLDER:    //** Notification of a new folder
 *      Entry:
 *        pfdid->folder.
 *          pFolderReserve  - RESERVE section from CFFOLDER
 *          cbFolderReserve - Size of pFolderReserve
 *          iFolder         - Folder number in cabinet (0 based)
 *      Exit-Success:
 *          returns anything but -1;
 *      Exit-Failure:
 *          returns -1; FDICopy() is aborted.
 *      Notes:
 *          This call allows the decryption code to pick out any information
 *          from the folder reserved area (placed there by DIACRYPT) needed
 *          to perform decryption.  If there is no such information, this
 *          call would presumably be ignored.
 *
 *  fdidtDECRYPT:       //** Decrypt a data buffer
 *      Entry:
 *        pfdid->folder.
 *          pDataReserve  - RESERVE section for this CFDATA block
 *          cbDataReserve - Size of pDataReserve
 *          pbData        - Data buffer
 *          cbData        - Size of data buffer
 *          fSplit        - TRUE if this is a split data block
 *          cbPartial     - 0 if this is not a split block, or the first
 *                              piece of a split block; Greater than 0 if
 *                              this is the second piece of a split block.
 *      Exit-Success:
 *          returns TRUE;
 *      Exit-Failure:
 *          returns FALSE; error during decrypt
 *          returns -1; FDICopy() is aborted.
 *      Notes:
 *          FCI will split CFDATA blocks across cabinet boundaries if
 *          necessary.  To provide maximum flexibility, FDI will call the
 *          fdidtDECRYPT function twice on such split blocks, once when
 *          the first portion is read, and again when the second portion
 *          is read.  And, of course, most data blocks will not be split.
 *          So, there are three cases:
 *
 *           1) fSplit == FALSE
 *              You have the entire data block, so decrypt it.
 *
 *           2) fSplit == TRUE, cbPartial == 0
 *              This is the first portion of a split data block, so cbData
 *              is the size of this portion.  You can either choose to decrypt
 *              this piece, or ignore this call and decrypt the full CFDATA
 *              block on the next (second) fdidtDECRYPT call.
 *
 *           3) fSplit == TRUE, cbPartial > 0
 *              This is the second portion of a split data block (indeed,
 *              cbPartial will have the same value as cbData did on the
 *              immediately preceeding fdidtDECRYPT call!).  If you decrypted
 *              the first portion on the first call, then you can decrypt the
 *              second portion now.  If you ignored the first call, then you
 *              can decrypt the entire buffer.
 *              NOTE: pbData points to the second portion of the split data
 *                    block in this case, *not* the entire data block.  If
 *                    you want to wait until the second piece to decrypt the
 *                    *entire* block, pbData-cbPartial is the address of the
 *                    start of the whole block, and cbData+cbPartial is its
 *                    size.
 */
typedef int (FAR DIAMONDAPI *PFNFDIDECRYPT)(PFDIDECRYPT pfdid); /* pfnfdid */
#define FNFDIDECRYPT(fn) int FAR DIAMONDAPI fn(PFDIDECRYPT pfdid)


/***    FDINOTIFICATION - Notification structure for PFNFDINOTIFY
 *
 *  See the FDINOTIFICATIONTYPE definition for information on usage and
 *  meaning of these fields.
 */
typedef struct {
// long fields
    long      cb;
    char FAR *psz1;
    char FAR *psz2;
    char FAR *psz3;                     // Points to a 256 character buffer
    void FAR *pv;                       // Value for client

// int fields
    int       hf;

// short fields
    USHORT    date;
    USHORT    time;
    USHORT    attribs;

    USHORT    setID;                    // Cabinet set ID
    USHORT    iCabinet;                 // Cabinet number (0-based)
    USHORT    iFolder;                  // Folder number (0-based)

    FDIERROR  fdie;
} FDINOTIFICATION, FAR *PFDINOTIFICATION;  /* fdin, pfdin */


/***    FDINOTIFICATIONTYPE - FDICopy notification types
 *
 *  The notification function for FDICopy can be called with the following
 *  values for the fdint parameter.  In all cases, the pfdin->pv field is
 *  filled in with the value of the pvUser argument passed in to FDICopy().
 *
 *  A typical sequence of calls will be something like this:
 *      fdintCABINET_INFO     // Info about the cabinet
 *      fdintENUMERATE        // Starting enumeration
 *      fdintPARTIAL_FILE     // Only if this is not the first cabinet, and
 *                            // one or more files were continued from the
 *                            // previous cabinet.
 *      ...
 *      fdintPARTIAL_FILE
 *      fdintCOPY_FILE        // The first file that starts in this cabinet
 *      ...
 *      fdintCOPY_FILE        // Now let's assume you want this file...
 *      // PFNWRITE called multiple times to write to this file.
 *      fdintCLOSE_FILE_INFO  // File done, set date/time/attributes
 *
 *      fdintCOPY_FILE        // Now let's assume you want this file...
 *      // PFNWRITE called multiple times to write to this file.
 *      fdintNEXT_CABINET     // File was continued to next cabinet!
 *      fdintCABINET_INFO     // Info about the new cabinet
 *      // PFNWRITE called multiple times to write to this file.
 *      fdintCLOSE_FILE_INFO  // File done, set date/time/attributes
 *      ...
 *      fdintENUMERATE        // Ending enumeration
 *
 *  fdintCABINET_INFO:
 *        Called exactly once for each cabinet opened by FDICopy(), including
 *        continuation cabinets opened due to file(s) spanning cabinet
 *        boundaries. Primarily intended to permit EXTRACT.EXE to
 *        automatically select the next cabinet in a cabinet sequence even if
 *        not copying files that span cabinet boundaries.
 *      Entry:
 *          pfdin->psz1     = name of next cabinet
 *          pfdin->psz2     = name of next disk
 *          pfdin->psz3     = cabinet path name
 *          pfdin->setID    = cabinet set ID (a random 16-bit number)
 *          pfdin->iCabinet = Cabinet number within cabinet set (0-based)
 *      Exit-Success:
 *          Return anything but -1
 *      Exit-Failure:
 *          Returns -1 => Abort FDICopy() call
 *      Notes:
 *          This call is made *every* time a new cabinet is examined by
 *          FDICopy().  So if "foo2.cab" is examined because a file is
 *          continued from "foo1.cab", and then you call FDICopy() again
 *          on "foo2.cab", you will get *two* fdintCABINET_INFO calls all
 *          told.
 *
 *  fdintCOPY_FILE:
 *        Called for each file that *starts* in the current cabinet, giving
 *        the client the opportunity to request that the file be copied or
 *        skipped.
 *      Entry:
 *          pfdin->psz1    = file name in cabinet
 *          pfdin->cb      = uncompressed size of file
 *          pfdin->date    = file date
 *          pfdin->time    = file time
 *          pfdin->attribs = file attributes
 *          pfdin->iFolder = file's folder index
 *      Exit-Success:
 *          Return non-zero file handle for destination file; FDI writes
 *          data to this file use the PFNWRITE function supplied to FDICreate,
 *          and then calls fdintCLOSE_FILE_INFO to close the file and set
 *          the date, time, and attributes.  NOTE: This file handle returned
 *          must also be closeable by the PFNCLOSE function supplied to
 *          FDICreate, since if an error occurs while writing to this handle,
 *          FDI will use the PFNCLOSE function to close the file so that the
 *          client may delete it.
 *      Exit-Failure:
 *          Returns 0  => Skip file, do not copy
 *          Returns -1 => Abort FDICopy() call
 *
 *  fdintCLOSE_FILE_INFO:
 *        Called after all of the data has been written to a target file.
 *        This function must close the file and set the file date, time,
 *        and attributes.
 *      Entry:
 *          pfdin->psz1    = file name in cabinet
 *          pfdin->hf      = file handle
 *          pfdin->date    = file date
 *          pfdin->time    = file time
 *          pfdin->attribs = file attributes
 *          pfdin->iFolder = file's folder index
 *          pfdin->cb      = Run After Extract (0 - don't run, 1 Run)
 *      Exit-Success:
 *          Returns TRUE
 *      Exit-Failure:
 *          Returns FALSE, or -1 to abort;
 *
 *              IMPORTANT NOTE IMPORTANT:
 *                  pfdin->cb is overloaded to no longer be the size of
 *                  the file but to be a binary indicated run or not
 *
 *              IMPORTANT NOTE:
 *                  FDI assumes that the target file was closed, even if this
 *                  callback returns failure.  FDI will NOT attempt to use
 *                  the PFNCLOSE function supplied on FDICreate() to close
 *                  the file!
 *
 *  fdintPARTIAL_FILE:
 *        Called for files at the front of the cabinet that are CONTINUED
 *        from a previous cabinet.  This callback occurs only when FDICopy is
 *        started on second or subsequent cabinet in a series that has files
 *        continued from a previous cabinet.
 *      Entry:
 *          pfdin->psz1 = file name of file CONTINUED from a PREVIOUS cabinet
 *          pfdin->psz2 = name of cabinet where file starts
 *          pfdin->psz3 = name of disk where file starts
 *      Exit-Success:
 *          Return anything other than -1; enumeration continues
 *      Exit-Failure:
 *          Returns -1 => Abort FDICopy() call
 *
 *  fdintENUMERATE:
 *        Called once after a call to FDICopy() starts scanning a CAB's
 *        CFFILE entries, and again when there are no more CFFILE entries.
 *        If CAB spanning occurs, an additional call will occur after the
 *        first spanned file is completed.  If the pfdin->iFolder value is
 *        changed from zero, additional calls will occur next time it reaches
 *        zero.  If iFolder is changed to zero, FDICopy will terminate, as if
 *        there were no more CFFILE entries.  Primarily intended to allow an
 *        application with it's own file list to help FDI advance quickly to
 *        a CFFILE entry of interest.  Can also be used to allow an
 *        application to determine the cb values for each file in the CAB.
 *      Entry:
 *        pfdin->cb        = current CFFILE position
 *        pfdin->iFolder   = number of files remaining
 *        pfdin->setID     = current CAB's setID value
 *      Exit-Don't Care:
 *        Don't change anything.
 *        Return anything but -1.
 *      Exit-Forcing a skip:
 *        pfdin->cb        = desired CFFILE position
 *        pfdin->iFolder   = desired # of files remaining
 *        Return anything but -1.
 *      Exit-Stop:
 *        pfdin->iFolder    = set to 0
 *        Return anything but -1.
 *      Exit-Failure:
 *        Return -1 => Abort FDICopy call ("user aborted".)
 *      Notes:
 *        This call can be ignored by applications which want normal file
 *        searching.  The application can adjust the supplied values to
 *        force FDICopy() to continue it's search at another location, or
 *        to force FDICopy() to terminate the search, by setting iFolder to 0.
 *        (FDICopy() will report no error when terminated this way.)
 *        FDI has no means to verify the supplied cb or iFolder values.
 *        Arbitrary values are likely to cause undesirable results.  An
 *        application should cross-check pfdin->setID to be certain the
 *        external database is in sync with the CAB.  Reverse-skips are OK
 *        (but may be inefficient) unless fdintNEXT_CABINET has been called.
 *
 *  fdintNEXT_CABINET:
 *        This function is *only* called when fdintCOPY_FILE was told to copy
 *        a file in the current cabinet that is continued to a subsequent
 *        cabinet file.  It is important that the cabinet path name (psz3)
 *        be validated before returning!  This function should ensure that
 *        the cabinet exists and is readable before returning.  So, this
 *        is the function that should, for example, issue a disk change
 *        prompt and make sure the cabinet file exists.
 *
 *        When this function returns to FDI, FDI will check that the setID
 *        and iCabinet match the expected values for the next cabinet.
 *        If not, FDI will continue to call this function until the correct
 *        cabinet file is specified, or until this function returns -1 to
 *        abort the FDICopy() function.  pfdin->fdie is set to
 *        FDIERROR_WRONG_CABINET to indicate this case.
 *
 *        If you *haven't* ensured that the cabinet file is present and
 *        readable, or the cabinet file has been damaged, pfdin->fdie will
 *        receive other appropriate error codes:
 *
 *              FDIERROR_CABINET_NOT_FOUND
 *              FDIERROR_NOT_A_CABINET
 *              FDIERROR_UNKNOWN_CABINET_VERSION
 *              FDIERROR_CORRUPT_CABINET
 *              FDIERROR_BAD_COMPR_TYPE
 *              FDIERROR_RESERVE_MISMATCH
 *              FDIERROR_WRONG_CABINET
 *
 *      Entry:
 *          pfdin->psz1 = name of next cabinet where current file is continued
 *          pfdin->psz2 = name of next disk where current file is continued
 *          pfdin->psz3 = cabinet path name; FDI concatenates psz3 with psz1
 *                          to produce the fully-qualified path for the cabinet
 *                          file.  The 256-byte buffer pointed at by psz3 may
 *                          be modified, but psz1 may not!
 *          pfdin->fdie = FDIERROR_WRONG_CABINET if the previous call to
 *                        fdintNEXT_CABINET specified a cabinet file that
 *                        did not match the setID/iCabinet that was expected.
 *      Exit-Success:
 *          Return anything but -1
 *      Exit-Failure:
 *          Returns -1 => Abort FDICopy() call
 *      Notes:
 *          This call is almost always made when a target file is open and
 *          being written to, and the next cabinet is needed to get more
 *          data for the file.
 */
typedef enum {
    fdintCABINET_INFO,              // General information about cabinet
    fdintPARTIAL_FILE,              // First file in cabinet is continuation
    fdintCOPY_FILE,                 // File to be copied
    fdintCLOSE_FILE_INFO,           // close the file, set relevant info
    fdintNEXT_CABINET,              // File continued to next cabinet
    fdintENUMERATE,                 // Enumeration status
} FDINOTIFICATIONTYPE; /* fdint */

typedef int (FAR DIAMONDAPI *PFNFDINOTIFY)(FDINOTIFICATIONTYPE fdint,
                                           PFDINOTIFICATION    pfdin); /* pfnfdin */

#define FNFDINOTIFY(fn) int FAR DIAMONDAPI fn(FDINOTIFICATIONTYPE fdint, \
                                              PFDINOTIFICATION    pfdin)


/*** cpuType values for FDICreate()
 *
 *  (Ignored by 32-bit FDI.)
 */
#define     cpuUNKNOWN         (-1)    /* FDI does detection */
#define     cpu80286           (0)     /* '286 opcodes only */
#define     cpu80386           (1)     /* '386 opcodes used */


/***    FDICreate - Create an FDI context
 *
 *  Entry:
 *      pfnalloc
 *      pfnfree
 *      pfnopen
 *      pfnread
 *      pfnwrite
 *      pfnclose
 *      pfnlseek
 *      cpuType  - Select CPU type (auto-detect, 286, or 386+)
 *                 NOTE: For the 32-bit FDI.LIB, this parameter is ignored!
 *      perf
 *
 *  Exit-Success:
 *      Returns non-NULL FDI context handle.
 *
 *  Exit-Failure:
 *      Returns NULL; perf filled in with error code
 *
 */
HFDI FAR DIAMONDAPI FDICreate(PFNALLOC pfnalloc,
                              PFNFREE  pfnfree,
                              PFNOPEN  pfnopen,
                              PFNREAD  pfnread,
                              PFNWRITE pfnwrite,
                              PFNCLOSE pfnclose,
                              PFNSEEK  pfnseek,
                              int      cpuType,
                              PERF     perf);


/***    FDIIsCabinet - Determines if file is a cabinet, returns info if it is
 *
 *  Entry:
 *      hfdi   - Handle to FDI context (created by FDICreate())
 *      hf     - File handle suitable for PFNREAD/PFNSEEK, positioned
 *               at offset 0 in the file to test.
 *      pfdici - Buffer to receive info about cabinet if it is one.
 *
 *  Exit-Success:
 *      Returns TRUE; file is a cabinet, pfdici filled in.
 *
 *  Exit-Failure:
 *      Returns FALSE, file is not a cabinet;  If an error occurred,
 *          perf (passed on FDICreate call!) filled in with error.
 */
BOOL FAR DIAMONDAPI FDIIsCabinet(HFDI            hfdi,
                                 int             hf,
                                 PFDICABINETINFO pfdici);


/***    FDICopy - extracts files from a cabinet
 *
 *  Entry:
 *      hfdi        - handle to FDI context (created by FDICreate())
 *      pszCabinet  - main name of cabinet file
 *      pszCabPath  - Path to cabinet file(s)
 *      flags       - Flags to modify behavior
 *      pfnfdin     - Notification function
 *      pfnfdid     - Decryption function (pass NULL if not used)
 *      pvUser      - User specified value to pass to notification function
 *
 *  Exit-Success:
 *      Returns TRUE;
 *
 *  Exit-Failure:
 *      Returns FALSE, perf (passed on FDICreate call!) filled in with
 *          error.
 *
 *  Notes:
 *  (1) If FDICopy() fails while a target file is being written out, then
 *      FDI will use the PFNCLOSE function to close the file handle for that
 *      target file that was returned from the fdintCOPY_FILE notification.
 *      The client application is then free to delete the target file, since
 *      it will not be in a valid state (since there was an error while
 *      writing it out).
 */
BOOL FAR DIAMONDAPI FDICopy(HFDI          hfdi,
                            char FAR     *pszCabinet,
                            char FAR     *pszCabPath,
                            int           flags,
                            PFNFDINOTIFY  pfnfdin,
                            PFNFDIDECRYPT pfnfdid,
                            void FAR     *pvUser);


/***    FDIDestroy - Destroy an FDI context
 *
 *  Entry:
 *      hfdi - handle to FDI context (created by FDICreate())
 *
 *  Exit-Success:
 *      Returns TRUE;
 *
 *  Exit-Failure:
 *      Returns FALSE;
 */
BOOL FAR DIAMONDAPI FDIDestroy(HFDI hfdi);


//** Revert to default structure packing
#pragma pack()

#endif // !INCLUDED_FDI

#ifdef  __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\genexception.h ===
//
//
// MODULE: GenException.h
//
// PURPOSE: Communicates Operating System error messages and a custom 
//			message accross function boundries.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 8/7/96
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		3/24/98		JM		Local Version for NT5
//

#ifndef __CGENEXCEPTION_H_
#define __CGENEXCEPTION_H_ 1

class CGenException
{
public:
	CGenException() {m_OsError=0;m_strOsMsg=_T("");m_strError=_T("");};

	long m_OsError;
	CString m_strOsMsg;
	CString m_strError;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\httpqueryexception.h ===
//
// MODULE: HTTPQUERYEXCEPTION.CPP
//
// PURPOSE: Execption that is thrown from the CHttpQuery class.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 6/4/96
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		3/24/98		JM		Local Version for NT5
//


#ifndef __HTTPQUERYEXCEPTION_H_
#define __HTTPQUERYEXCEPTION_H_ 1

class CHttpQueryException : public CBasicException
{
public:
	CHttpQueryException(){m_strError = _T("");m_dwBErr=TSERR_SCRIPT;};

	CString m_strError;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\fs.h ===
// Copyright  1997-1997  Microsoft Corporation.  All Rights Reserved.

#ifndef _FS_H_
#define _FS_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include <unknwn.h>
#include "msitstg.h"

#ifdef ReleaseObjPtr
#undef ReleaseObjPtr
#endif
#define ReleaseObjPtr(pObj) \
{                           \
  if( pObj )                \
  {                         \
    pObj->Release();        \
    pObj= NULL;             \
  }                         \
}

//
// Sub-File System
//
class CSubFileSystem
{

public:
   CSubFileSystem(class CFileSystem* pfs);
   ~CSubFileSystem();

   HRESULT CreateSub(PCSTR pszPathName);
   HRESULT CreateUncompressedSub(PCSTR pszPathName);
   HRESULT OpenSub(PCSTR pszPathName, DWORD dwAccess = (STGM_READ | STGM_SHARE_DENY_WRITE));
   ULONG WriteSub(const void* pData, int cb);
   ULONG SeekSub(int cb, int iOrigin);
   HRESULT CreateSystemFile(PCSTR pszPathName);
   HRESULT CreateUncompressedSystemFile(PCSTR pszPathName);
   HRESULT SetSize(unsigned uSize);
   HRESULT DeleteSub() ;

   inline HRESULT ReadSub(void* pData, ULONG cb, ULONG* pcbRead) {
      return m_pStream->Read(pData, cb, pcbRead);
   }

   inline ULONG GetUncompressedSize(void) { return SeekSub(0,2); }

   inline HRESULT Stat(STATSTG *pstatstg, DWORD grfStatFalg)
   {
      return m_pStream->Stat(pstatstg,grfStatFalg);
   }

   inline HRESULT CopyTo(IStream* pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER* pcbWritten)
   {
      return m_pStream->CopyTo(pstm, cb, pcbRead, pcbWritten);
   }

   inline IStream * GetStream(void)
   {
      return m_pStream;
   }

   inline IStorage* GetITStorageDocObj(void) const
   {
      return m_pStorage;
   }

private:
   class CFileSystem* m_pFS;
   IStorage*          m_pStorage;
   IStream*           m_pStream;
   char               m_szPathName[MAX_PATH]; // Needed for delete.
};

//
// File System
//
class CFileSystem
{
   friend class CSubFileSystem;

public:
   CFileSystem();
   ~CFileSystem();

   HRESULT Init(void);
   HRESULT Create( PCSTR pszPathName );
   HRESULT CreateUncompressed( PCSTR pszPathName );
   HRESULT Open( PCSTR pszPathName, DWORD dwAccess = (STGM_READ | STGM_SHARE_DENY_WRITE));
   HRESULT Compact(LPCSTR lpszFileName);
   HRESULT Close(void);

   inline HRESULT GetPathName( LPSTR pszPathName ) { strcpy(pszPathName, m_szPathName); return S_OK; }

   inline IITStorage* GetITStorageObj(void) const
   {
      return m_pITStorage;
   }

   inline IStorage* GetITStorageDocObj(void) const
   {
      return m_pStorage;
   }

private:
   IITStorage*   m_pITStorage;
   IStorage*     m_pStorage;
   char          m_szPathName[MAX_PATH];

};

#endif // _FS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\fs.cpp ===
// Copyright (C) 1997 Microsoft Corporation. All rights reserved.

#include "stdafx.h"

// to avoid linker error related to undefined GUIDs
#include "initguid.h"
#include "fs.h"

#pragma data_seg(".text", "CODE")

static const WCHAR txtwUncompressed[] =  L"uncompressed";

#pragma data_seg()

// returns poinder inside pszPath string that points to file name
// for example in "d:\Tshooter\http\lan.chm\lan.htm" it points
// to "lan.htm"
LPCSTR FindFilePortion(LPCSTR pszPath)
{
	int index =0;
	CString path(pszPath);

	if (-1 == (index = path.ReverseFind(_T('\\'))))
	{
		if (-1 == (index = path.ReverseFind(_T('/'))))
			index = 0;
		else
			index += sizeof(_T('/'));
	}
	else
		index += sizeof(_T('\\'));

	return pszPath + index;
}

CFileSystem::CFileSystem()
{
   m_pITStorage    = NULL;
   m_pStorage      = NULL;
   m_szPathName[0] = 0;
}

CFileSystem::~CFileSystem()
{
  ReleaseObjPtr(m_pStorage);
  ReleaseObjPtr(m_pITStorage);
}

HRESULT CFileSystem::Init(void)
{
   if (! m_pITStorage) {
      IClassFactory* pICFITStorage;

      HRESULT hr = CoGetClassObject(CLSID_ITStorage, CLSCTX_INPROC_SERVER, NULL, IID_IClassFactory, (void **) &pICFITStorage);

      if (!SUCCEEDED(hr)) 
         return hr;
      
      hr = pICFITStorage->CreateInstance(NULL, IID_ITStorage,(void **) &m_pITStorage);
      ReleaseObjPtr( pICFITStorage );

      if (!SUCCEEDED(hr)) 
         return hr;
      
   }
   return S_OK;
}

typedef struct tagITSControlData
{
   UINT cdwFollowing;          // Must be 6 or 13
   DWORD cdwITFS_Control;      // Must be 5
   DWORD dwMagicITS;           // Must be MAGIC_ITSFS_CONTROL (see below)
   DWORD dwVersionITS;         // Must be 1
   DWORD cbDirectoryBlock;     // Size in bytes of directory blocks (Default is 8192)
   DWORD cMinCacheEntries;     // Least upper bound on the number of directory blocks
                               // which we'll cache in memory. (Default is 20)
   DWORD fFlags;               // Control bit flags (see below).
                               // Default value is fDefaultIsCompression.
   UINT  cdwControlData;       // Must be 6
   DWORD dwLZXMagic;           // Must be LZX_MAGIC (see below)
   DWORD dwVersion;            // Must be 2
   DWORD dwMulResetBlock;      // Number of blocks between compression resets.  (Default: 4)
   DWORD dwMulWindowSize;      // Maximum number of blocks kept in data history (Default: 4)
   DWORD dwMulSecondPartition; // Granularity in blocks of sliding history(Default: 2)
   DWORD dwOptions;            // Option flags (Default: fOptimizeCodeStreams)
} ITCD;

HRESULT CFileSystem::Create( PCSTR pszPathName )
{
   HRESULT hr;
   ITCD itcd;

   if (! m_pITStorage || m_pStorage )
      return E_FAIL;

   itcd.cdwFollowing      = 13;
   itcd.cdwITFS_Control   = 5;
   itcd.dwMagicITS        = MAGIC_ITSFS_CONTROL;
   itcd.dwVersionITS      = 1;
   itcd.cbDirectoryBlock  = 4096;     // default = 8192
   itcd.cMinCacheEntries  = 10;       // default = 20
   itcd.fFlags            = 1;        // 0 == Uncompressed, 1 == Compressed.
   itcd.cdwControlData        = 6;
   itcd.dwLZXMagic            = LZX_MAGIC;
   itcd.dwVersion             = 2;
   itcd.dwMulResetBlock       = 2;    // Default = 4
   itcd.dwMulWindowSize       = 2;    // Default = 4
   itcd.dwMulSecondPartition  = 1;    // Default = 2
   itcd.dwOptions             = 0;    // Default = fOptimizeCodeStreams

   m_pITStorage->SetControlData(PITS_Control_Data(&itcd));

   WCHAR wsz[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, (PWSTR) wsz, MAX_PATH);
   hr = m_pITStorage->StgCreateDocfile( (LPCWSTR) wsz, STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT, 0, &m_pStorage);

   if (!SUCCEEDED(hr)) {
      return hr;
   }

   strcpy( (LPSTR) m_szPathName, pszPathName );

   return S_OK;
}

// NOTE: The below function is required for the ITIR full-text indexer to
//     initialize.  I'm working to find out why this is and what impact
//     the below has on the file system.
//
HRESULT CFileSystem::CreateUncompressed( PCSTR pszPathName )
{
   HRESULT hr;
   ITCD itcd;

   if (! m_pITStorage || m_pStorage )
      return E_FAIL;

   itcd.cdwFollowing      = 6;
   itcd.cdwITFS_Control   = 5;
   itcd.dwMagicITS        = MAGIC_ITSFS_CONTROL;
   itcd.dwVersionITS      = 1;
   itcd.cbDirectoryBlock  = 8192;     // default = 8192
   itcd.cMinCacheEntries  = 20;        // default = 20
   itcd.fFlags            = 0;        // 0 == Uncompressed, 1 == Compressed.

   m_pITStorage->SetControlData(PITS_Control_Data(&itcd));

   WCHAR wsz[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, (PWSTR) wsz, MAX_PATH);
   hr = m_pITStorage->StgCreateDocfile( (LPCWSTR) wsz, STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT, 0, &m_pStorage);

   if (!SUCCEEDED(hr)) {
      return hr;
   }

   strcpy( (LPSTR) m_szPathName, pszPathName );

   return S_OK;
}

HRESULT CFileSystem::Open(PCSTR pszPathName, DWORD dwAccess)
{
   HRESULT hr = S_OK;

   if (! m_pITStorage || m_pStorage )
      return E_FAIL;

   // force access modes
   if( (dwAccess & STGM_WRITE) || (dwAccess & STGM_READWRITE) ) {
     dwAccess &= ~STGM_WRITE;
     dwAccess |= STGM_READWRITE | STGM_SHARE_EXCLUSIVE;
   }
   else
     dwAccess |= STGM_SHARE_DENY_WRITE;

   WCHAR wsz[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, (PWSTR) wsz, MAX_PATH);
   hr = m_pITStorage->StgOpenStorage( (LPCWSTR) wsz, NULL, dwAccess, NULL, 0, &m_pStorage);

   if (!SUCCEEDED(hr)) {
      return hr;
   }

   strcpy( (LPSTR) m_szPathName, pszPathName );

   return hr;
}

HRESULT CFileSystem::Compact(LPCSTR pszPathName)
{
   WCHAR wszPathName[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, wszPathName, sizeof(wszPathName));
   m_pITStorage->Compact(wszPathName, COMPACT_DATA_AND_PATH);

   return S_OK;
}

HRESULT CFileSystem::Close()
{
   ReleaseObjPtr(m_pStorage);

   return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// Here are a set of "sub" file I/O calls.
//
//
CSubFileSystem::CSubFileSystem(CFileSystem* pFS)
{
   m_pFS = pFS;
   m_pStorage = NULL;
   m_pStream = NULL;
   m_szPathName[0] = 0;
}

CSubFileSystem::~CSubFileSystem()
{
   if ( m_pStorage && (m_pStorage != m_pFS->m_pStorage) )
      ReleaseObjPtr(m_pStorage);

   ReleaseObjPtr(m_pStream);
}

HRESULT CSubFileSystem::CreateSub(PCSTR pszPathName)
{
   PCSTR pszFilePortion;
   HRESULT hr;

   if ( m_pStorage || m_pStream )
      return E_FAIL;

   if ((pszFilePortion = FindFilePortion(pszPathName)) && pszFilePortion > pszPathName)
   {
      CHAR szPath[MAX_PATH];
      strcpy( szPath, pszPathName );
      szPath[(pszFilePortion - 1) - pszPathName] = '\0';

      WCHAR wszStorage[MAX_PATH];
      MultiByteToWideChar(CP_ACP, 0, szPath, -1, (PWSTR) wszStorage, MAX_PATH);

      hr = m_pFS->m_pStorage->OpenStorage(wszStorage, NULL, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, NULL, 0, &m_pStorage);
      if (!SUCCEEDED(hr) || !m_pStorage) // storage didn't exist, so create it
         hr = m_pFS->m_pStorage->CreateStorage(wszStorage, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStorage);
      if (!SUCCEEDED(hr))
      {
         return hr;
      }
   }
   else // no folder, so store the file in the root
   {
      m_pStorage = m_pFS->m_pStorage;
      pszFilePortion = pszPathName;
   }
   WCHAR wszStream[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszFilePortion, -1, (PWSTR) wszStream, MAX_PATH);
   hr = m_pStorage->CreateStream(wszStream, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStream);
   if (!SUCCEEDED(hr))
   {
      if (m_pStorage != m_pFS->m_pStorage)
         ReleaseObjPtr(m_pStorage);
      return hr;
   }

   // Needed for delete.
   strcpy( m_szPathName, pszFilePortion );

   return S_OK;
}

HRESULT CSubFileSystem::CreateUncompressedSub(PCSTR pszPathName)
{
   PCSTR pszFilePortion;
   HRESULT hr;
   IStorageITEx* pIStorageEx;

   if ( m_pStorage || m_pStream )
      return E_FAIL;

   if ((pszFilePortion = FindFilePortion(pszPathName)) && pszFilePortion > pszPathName)
   {
      CHAR szPath[MAX_PATH];
      strcpy( szPath, pszPathName );
      szPath[(pszFilePortion - 1) - pszPathName] = '\0';
      WCHAR wszStorage[MAX_PATH];
      MultiByteToWideChar(CP_ACP, 0, szPath, -1, (PWSTR) wszStorage, MAX_PATH);
      hr = m_pFS->m_pStorage->OpenStorage(wszStorage, NULL, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, NULL, 0, &m_pStorage);
      if (!SUCCEEDED(hr) || !m_pStorage) // storage didn't exist, so create it
         hr = m_pFS->m_pStorage->CreateStorage(wszStorage, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStorage);
      if (!SUCCEEDED(hr))
      {
         return hr;
      }
   }
   else // no folder, so store the file in the root
   {
      m_pStorage = m_pFS->m_pStorage;
      pszFilePortion = pszPathName;
   }

   if ( !(SUCCEEDED(hr = m_pStorage->QueryInterface(IID_IStorageITEx, (void**)&pIStorageEx))) )
      pIStorageEx = (IStorageITEx*)m_pStorage;  // BUGBUG the QI call above should work!

   WCHAR wszStream[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszFilePortion, -1, (PWSTR) wszStream, MAX_PATH);
   hr = pIStorageEx->CreateStreamITEx(wszStream, txtwUncompressed, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, (IStreamITEx**)&m_pStream);
   ReleaseObjPtr(pIStorageEx);
   if (!SUCCEEDED(hr))
   {
      if (m_pStorage != m_pFS->m_pStorage)
         ReleaseObjPtr(m_pStorage);
      return hr;
   }

   // Needed for delete.
   strcpy( m_szPathName, pszFilePortion );

   return S_OK;
}

HRESULT CSubFileSystem::CreateSystemFile(PCSTR pszPathName)
{
   m_pStorage = m_pFS->m_pStorage;
   WCHAR wszStream[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, (PWSTR) wszStream, MAX_PATH);
   HRESULT hr = m_pStorage->CreateStream(wszStream, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &m_pStream);
   if (!SUCCEEDED(hr))
   {
      return hr;
   }

   // Needed for delete.
   strcpy( m_szPathName, pszPathName );

   return S_OK;
}

HRESULT CSubFileSystem::CreateUncompressedSystemFile(PCSTR pszPathName)
{
   IStorageITEx* pIStorageEx;
   HRESULT hr;

   m_pStorage = m_pFS->m_pStorage;

   if ( !(SUCCEEDED(hr = m_pStorage->QueryInterface(IID_IStorageITEx, (void**)&pIStorageEx))) )
      pIStorageEx = (IStorageITEx*)m_pStorage;  // BUGBUG the QI call above should work!

   WCHAR wszStream[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszPathName, -1, (PWSTR) wszStream, MAX_PATH);
   hr = pIStorageEx->CreateStreamITEx(wszStream, txtwUncompressed, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, (IStreamITEx**)&m_pStream);
   ReleaseObjPtr(pIStorageEx);
   if (!SUCCEEDED(hr))
   {
      return hr;
   }

   // Needed for delete.
   strcpy( m_szPathName, pszPathName );

   return S_OK;
}

HRESULT CSubFileSystem::OpenSub(PCSTR pszPathName, DWORD dwAccess)
{
   PCSTR pszFilePortion;
   HRESULT hr;

   if ( m_pStorage || m_pStream )
      return E_FAIL;

   // force access modes
   if( (dwAccess & STGM_WRITE) || (dwAccess & STGM_READWRITE) ) {
     dwAccess &= ~STGM_WRITE;
     dwAccess |= STGM_READWRITE | STGM_SHARE_EXCLUSIVE;
   }
   else
     dwAccess |= STGM_SHARE_DENY_WRITE;

   if ((pszFilePortion = FindFilePortion(pszPathName)) &&
         pszFilePortion > pszPathName + 2) // +2 to support / && ./
   {
      CHAR szPath[MAX_PATH];
      strcpy( szPath, pszPathName );
      szPath[(pszFilePortion - 1) - pszPathName] = '\0';
      WCHAR wszStorage[MAX_PATH];
      MultiByteToWideChar(CP_ACP, 0, szPath, -1, (PWSTR) wszStorage, MAX_PATH);
      hr = m_pFS->m_pStorage->OpenStorage(wszStorage, NULL, dwAccess, NULL, 0, &m_pStorage);

      if (!SUCCEEDED(hr))
      {
         return hr;
      }
   }
   else // no folder, so store the file in the root
   {
      m_pStorage = m_pFS->m_pStorage ? m_pFS->m_pStorage : m_pFS->m_pStorage;
      pszFilePortion = pszPathName;
   }
   WCHAR wszStream[MAX_PATH];
   MultiByteToWideChar(CP_ACP, 0, pszFilePortion, -1, (PWSTR) wszStream, MAX_PATH);
   hr = m_pStorage->OpenStream(wszStream, NULL, dwAccess, 0, &m_pStream);
   if (!SUCCEEDED(hr))
   {
      if (m_pStorage != m_pFS->m_pStorage)
         ReleaseObjPtr(m_pStorage);
      return hr;
   }

   // Needed for delete.
   strcpy( m_szPathName, pszFilePortion );

   return S_OK;
}

ULONG CSubFileSystem::WriteSub(const void* pData, int cb)
{
   if ( !m_pStorage || !m_pStream )
      return (ULONG) -1;

   ULONG cbWritten;

   HRESULT hr = m_pStream->Write(pData, cb, &cbWritten);

   if (!SUCCEEDED(hr) || (cbWritten != (ULONG)cb) )
   {
      return (ULONG) -1;
   }
   // REVIEW: 30-May-1997  [ralphw] Why are we returning this? We fail if
   // we don't write cb bytes.
   return cbWritten;
}

/*
 * iOrigin:
 *    0 = Seek from beginning.
 *    1 = Seek from current.
 *    2 = Seek from end.
 */
ULONG CSubFileSystem::SeekSub(int cb, int iOrigin)
{
   LARGE_INTEGER liCount = {0,0};
   ULARGE_INTEGER liNewPos;

   if ( !m_pStorage || !m_pStream )
      return (ULONG) -1;

   liCount.LowPart = cb;
   HRESULT hr =  m_pStream->Seek(liCount, iOrigin, &liNewPos);

   if (!SUCCEEDED(hr) )
   {
      return (ULONG) -1;
   }
   return liNewPos.LowPart;
}

//
// Pre-allocate the size of the stream.
//

HRESULT CSubFileSystem::SetSize(unsigned uSize)
{
   ULARGE_INTEGER liSize = {0,0};
   HRESULT hr;

   if ( !m_pStorage || !m_pStream )
      return E_FAIL;

   liSize.LowPart = uSize;
   hr =  m_pStream->SetSize(liSize);

   if (!SUCCEEDED(hr) )
   {
      return (ULONG) -1;
   }
   return hr;
}

//
// Delete substorage.
//
HRESULT 
CSubFileSystem::DeleteSub()
{
    if (m_pStorage)
    {
        if (m_pStream)
        {
            // Release the stream.
            ReleaseObjPtr(m_pStream) ;
        }

        // Now delete the storage.
        WCHAR element[MAX_PATH];
        MultiByteToWideChar(CP_ACP, 0, m_szPathName, -1, (PWSTR) element, MAX_PATH);

        HRESULT hr = m_pStorage->DestroyElement(element) ;
        if (SUCCEEDED(hr))
        {
            // Get back to the constructor state.
            if ( m_pStorage && (m_pStorage != m_pFS->m_pStorage) )
            {
                ReleaseObjPtr(m_pStorage);
            }
            return S_OK ;
        }
    }
    return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\ocxglobals.cpp ===
// 
// MODULE: OcxGlobals.cpp
//
// PURPOSE: Global functions that are handy to have.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		04/09/98	JM/OK+	Local Version for NT5
///////////////////////

#include "stdafx.h"
#include "..\launcher\server\ComGlobals.h"

bool BSTRToTCHAR(LPTSTR szChar, BSTR bstr, int CharBufSize)
{
	int x = 0;
	while(x < CharBufSize)
	{
		szChar[x] = (TCHAR) bstr[x];
		if (NULL == szChar[x])
			break;
		x++;
	}
	return x < CharBufSize;
}

bool ReadRegSZ(HKEY hRootKey, LPCTSTR szKey, LPCTSTR szValue, LPTSTR szBuffer, DWORD *pdwBufSize)
{
	HKEY hKey;
	DWORD dwType = REG_SZ;
	DWORD dwBufSize = *pdwBufSize;
	LPTSTR szUnExpanded = new TCHAR[dwBufSize];
	if (NULL == szUnExpanded)
		return false;
	__try
	{
		if(ERROR_SUCCESS != RegOpenKeyEx(hRootKey, szKey, NULL, KEY_READ, &hKey))
		{
			////Delete before you return.
			if (NULL != szUnExpanded)
				delete [] szUnExpanded;

			return false;
		}
		if (ERROR_SUCCESS != RegQueryValueEx(hKey, szValue, NULL, &dwType, 
				(PBYTE) szUnExpanded, pdwBufSize))
		{
			RegCloseKey(hKey);
			return false;
		}			
		RegCloseKey(hKey);
		if (REG_EXPAND_SZ == dwType || dwType == REG_SZ)	// NT 5.0 beta bug requires all strings to be expanded.
		{
			DWORD dwBytesUsed;
			dwBytesUsed = ExpandEnvironmentStrings(szUnExpanded, szBuffer, dwBufSize);	// The value returned by ExpandEnviromentStrings is larger than the required size.
			if (0 == dwBytesUsed)
				return false;
			*pdwBufSize = dwBytesUsed;
			if (dwBytesUsed > dwBufSize)
				return false;
		}
		else
		{
			_tcsncpy(szBuffer, szUnExpanded, dwBufSize);
		}
	}
	__finally
	{
		if (NULL != szUnExpanded)
			delete [] szUnExpanded;
	}
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\functions.h ===
//
// MODULE: FUNCTIONS.H
//
// PURPOSE:  Decodes the the variant structures.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
/// 
// ORIGINAL DATE: 6/4/96
//
// NOTES: 
// 1.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		3/24/98		JM		Local Version for NT5
//

#ifndef __FUNCTIONS_H_
#define __FUNCTIONS_H_ 1

inline CString GlobFormatMessage(DWORD dwLastError)
{
	CString strMessage;
	void *lpvMessage;
	FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
		NULL,
		dwLastError,
		MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
		(LPTSTR) &lpvMessage, 0, NULL);
	strMessage = (LPCTSTR) lpvMessage;
	LocalFree(lpvMessage);
	return strMessage;
}

inline CString DecodeVariantTypes(VARTYPE vt)
{
	CString str = _T("");
	if (VT_EMPTY == vt)
		str = _T("Empty  ");
	else if(VT_ILLEGAL == vt)
		str = _T("ILLEGAL  ");
	else if(VT_ILLEGALMASKED == vt)
		str = _T("ILLEGALMASKED  ");
	else
	{
		if (VT_VECTOR == (VT_VECTOR & vt))
			str += _T("VECTOR  ");
		if (VT_ARRAY == (VT_ARRAY & vt))
			str += _T("ARRAY  ");
		if (VT_BYREF == (VT_BYREF & vt))
			str += _T("BYREF  ");
		if (VT_RESERVED == (VT_RESERVED & vt))
			str += _T("RESERVED  ");
		if (VT_TYPEMASK == (VT_TYPEMASK & vt))
			str += _T("TYPEMASK  ");
		vt &= 0xFFF;
		if (VT_NULL == vt)
			str += _T("Null  ");
		if (VT_I2 == vt)
			str += _T("I2  ");
		if (VT_I4 == vt)
			str += _T("I4  ");
		if (VT_R4 == vt)
			str += _T("R4  ");
		if (VT_R8 == vt)
			str += _T("R8  ");
		if (VT_CY == vt)
			str += _T("CY  ");
		if (VT_DATE == vt)
			str += _T("DATE  ");
		if (VT_BSTR == vt)
			str += _T("BSTR  ");
		if (VT_DISPATCH == vt)
			str += _T("DISPATCH  ");
		if (VT_ERROR == vt)
			str += _T("ERROR  ");
		if (VT_BOOL == vt)
			str += _T("BOOL  ");
		if (VT_VARIANT == vt)
			str += _T("VARIANT  ");
		if (VT_UNKNOWN == vt)
			str += _T("UNKNOWN  ");
		if (VT_DECIMAL == vt)
			str += _T("DECIMAL  ");
		if (VT_I1 == vt)
			str += _T("I1  ");
		if (VT_UI1 == vt)
			str += _T("UI1  ");
		if (VT_UI2 == vt)
			str += _T("UI2  ");
		if (VT_UI4 == vt)
			str += _T("UI4  ");
		if (VT_I8 == vt)
			str += _T("I8  ");
		if (VT_UI8 == vt)
			str += _T("UI8  ");
		if (VT_INT == vt)
			str += _T("INT  ");
		if (VT_UINT == vt)
			str += _T("UINT  ");
		if (VT_VOID == vt)
			str += _T("VOID  ");
		if (VT_HRESULT == vt)
			str += _T("HRESULT  ");
		if (VT_PTR == vt)
			str += _T("PTR  ");
		if (VT_SAFEARRAY == vt)
			str += _T("SAFEARRAY  ");
		if (VT_CARRAY == vt)
			str += _T("CARRAY  ");
		if (VT_USERDEFINED == vt)
			str += _T("USERDEFINED  ");
		if (VT_LPSTR == vt)
			str += _T("LPSTR  ");
		if (VT_LPWSTR == vt)
			str += _T("LPWSTR  ");
		if (VT_FILETIME == vt)
			str += _T("FILETIME  ");
		if (VT_BLOB == vt)
			str += _T("BLOB  ");
		if (VT_STREAM == vt)
			str += _T("STREAM  ");
		if (VT_STORAGE == vt)
			str += _T("STORAGE  ");
		if (VT_STREAMED_OBJECT == vt)
			str += _T("STREAMED_OBJECT  ");
		if (VT_STORED_OBJECT == vt)
			str += _T("STORED_OBJECT  ");
		if (VT_BLOB_OBJECT == vt)
			str += _T("BLOB_OBJECT  ");
		if (VT_CF == vt)
			str += _T("CF  ");
		if (VT_CLSID == vt)
			str += _T("CLSID  ");
	}
	return str;
}

inline CString DecodeSafeArray(unsigned short Features)
{
/*
#define FADF_AUTO		0x0001	// Array is allocated on the stack.
#define FADF_STATIC		0x0002	// Array is statically allocated.
#define FADF_EMBEDDED	0x0004	// Array is embedded in a structure.
#define FADF_FIXEDSIZE	0x0010	// Array may not be resized or 
								// reallocated.
#define FADF_BSTR		0x0100	// An array of BSTRs.
#define FADF_UNKNOWN		0x0200	// An array of IUnknown*.
#define FADF_DISPATCH	0x0400	// An array of IDispatch*.
#define FADF_VARIANT		0x0800	// An array of VARIANTs.
#define FADF_RESERVED	0xF0E8	// Bits reserved for future use.
*/
	CString str = _T("");
	if (FADF_AUTO == (FADF_AUTO & Features))
		str += _T("Array is allocated on the stack.\n");
	if (FADF_STATIC == (FADF_STATIC & Features))
		str += _T("Array is statically allocated.\n");
	if (FADF_EMBEDDED == (FADF_EMBEDDED & Features))
		str += _T("Array is embedded in a structure.\n");
	if (FADF_FIXEDSIZE == (FADF_FIXEDSIZE & Features))
		str += _T("Array may not be resized of reallocated.\n");
	if (FADF_BSTR == (FADF_BSTR & Features))
		str += _T("An array of BSTRs.\n");
	if (FADF_UNKNOWN == (FADF_UNKNOWN & Features))
		str += _T("An array of IUnknown.\n");
	if (FADF_DISPATCH == (FADF_DISPATCH & Features))
		str += _T("An array of IDispatch.\n");
	if (FADF_VARIANT == (FADF_VARIANT & Features))
		str += _T("An array of VARIANTS.\n");
	if (FADF_RESERVED == (FADF_RESERVED & Features))
		str+= _T("Array is using all of the reserved bits.\n");
	return str; 
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\msitstg.h ===
// MSITStg.h -- Interface declaration for IMSITStorage

#ifndef __MSITSTG_H__

#define __MSITSTG_H__

// Class ID for the ITSS File System:

DEFINE_GUID(CLSID_ITStorage, 
0x5d02926a, 0x212e, 0x11d0, 0x9d, 0xf9, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Inteface ID for the IITStorage interface:

DEFINE_GUID(IID_ITStorage, 
0x88cc31de, 0x27ab, 0x11d0, 0x9d, 0xf9, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the IITStorageEx interface:

DEFINE_GUID(IID_ITStorageEx, 
0xe74097b0, 0x292d, 0x11d1, 0xb6, 0x7e, 0x0, 0x0, 0xf8, 0x1, 0x49, 0xf6);

// Class ID for the FSStorage wrapper for the Win32 file system:

// {D54EEE56-AAAB-11d0-9E1D-00A0C922E6EC}
DEFINE_GUID(CLSID_IFSStorage, 
0xd54eee56, 0xaaab, 0x11d0, 0x9e, 0x1d, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the IFSStorage interface:

// {8BB2438A-A70C-11d0-9E1C-00A0C922E6EC}
DEFINE_GUID(IID_IFSStorage, 
0x8bb2438a, 0xa70c, 0x11d0, 0x9e, 0x1c, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the extended IStream interface

DEFINE_GUID(IID_IStreamITEx, 
0xeb19b681, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the extended IStorage interface

DEFINE_GUID(IID_IStorageITEx, 
0xeb19b680, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface IDs for the Data Space Manager used within an ITStorage object:

DEFINE_GUID(IID_IDataSpaceManager, 
0x7c01fd0f, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_IDataSpace, 
0x7c01fd0e, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_ITransformServices, 
0xa55895fc, 0x89e1, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_IKeyInstance, 
0x96af35ce, 0x88ec, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface IDs for the plug-in data transforms:

DEFINE_GUID(IID_ITransformFactory, 
0x7c01fd0c, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

DEFINE_GUID(IID_ITransformInstance, 
0xeb19b67e, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);

// Interface ID for the File Finder interface (used with URLs):

DEFINE_GUID(IID_IITFileFinder, 
0x77231260, 0x19c0, 0x11d1, 0xb6, 0x6e, 0x0, 0x0, 0xf8, 0x1, 0x49, 0xf6);

/*

The IITStorage interface parallels the API's defined for creating and
opening Docfiles. So if you have code that currently uses Docfiles for 
your storage mechanism, you can easily convert over to using ITS files 
instead. 

ITS files use a different on-disk structure to optimize them for very 
fast stream access and very low overhead. ITS files can manage thousands 
or millions of streams with very good access performance and very small 
directory space requirements. This makes ITS files ideal for CD-Roms and
for data collections that you'll download across the Internet. 

To make the conversion to ITS files you'll need to call CoCreateInstance 
with the class-id CLSID_ITStorage and the interface-id IID_ITStorage. You'll 
get back an interface pointer, say pItStg. Then you'll need to adjust the
places where your code creates or opens Docfiles. Instead of StgCreateDocfile
you'll call pItStg->StgCreateDocfile, and instead of StgOpenStorage, you'll
call pItStg->StgOpenStorage. In both cases you'll get back an IStorage 
interface pointer, say pIStg, which you can use just as you did before.

That's it. In general the rest of your code shouldn't have to change. There 
are some functional difference between ITS files and Docfiles -- ITS files
don't support STGM_TRANSACTED, for example. So if you have to have transacted 
file operations, you can't use ITS files -- at least for now. However in
almost all other respects ITS files interfaces can directly replace Docfile
interfaces.

Converting your data is also easy. Just open one of  your Docfiles using
StgOpenStorage, create a new ITS file via pItStg->StgCreateDocfile, and then
use the CopyTo interface to copy your data objects and their storage heirarchy
over to the ITS file:
    
    pStgDocfile->CopyTo(0, NULL, NULL, pStgITS);

In some cases you may want to exercise some control over the internal parameters
kept in an ITS file. You do this by calling SetControlData to give the IITStorage
interface a block of ITS control data. Then each subsequent call to StgCreateDocfile
will use that control data. The ITS control data determines, among other things,
the tradeoff between efficient random access to the stream data and minimizing the
size of an ITS file.  

The actual structure and interpretation of ITS control data is documented below.
(See the ITSFS_Control_Data data type). You can get default control data via the
DefaultControlData fuction. Note that DefaultControlData allocates the control
structure using IMalloc::Alloc as provided by CoGetMalloc and expects that your code will
deallocate the structure using the IMalloc::Free.

 */

// IID_IStreamITEx interface declaration:

DECLARE_INTERFACE_(IStreamITEx, IStream)
{
    // IStreamITEx methods
    
    STDMETHOD(SetDataSpaceName)(const WCHAR   * pwcsDataSpaceName) PURE;
    STDMETHOD(GetDataSpaceName)(       WCHAR **ppwcsDataSpaceName) PURE;

    STDMETHOD(Flush)() = 0;
};

// IID_IStorageITEx interface declaration:

DECLARE_INTERFACE_(IStorageITEx, IStorage)
{
    // IStorageITEx methods:

    STDMETHOD(GetCheckSum)(ULARGE_INTEGER *puli) PURE;
    STDMETHOD(CreateStreamITEx)(const WCHAR * pwcsName, const WCHAR *pwcsDataSpaceName, 
                            DWORD grfMode, DWORD reserved1, DWORD reserved2, 
                            IStreamITEx ** ppstm
                           ) PURE;
    STDMETHOD(OpenStreamITEx)(const WCHAR * pwcsName, void * reserved1, DWORD grfMode, 
                          DWORD reserved2, IStreamITEx ** ppstm) PURE;
};

// IStorageITEx::CreateStream lets you specify the data space in which a stream
// is to be created. Currently two dataspaces are supported:
//
//    L"Uncompressed" -- This dataspace applies no compression.
//    L"MSCompressed" -- This dataspace applies a default compression transform.


#pragma warning( disable : 4200)

// ITS_Control_Data is the generic structure of control data passed to the 
// IITStorage::SetControlData method or returned by the IITStorage::DefaultControlData
// method.

typedef struct _ITS_Control_Data
{
    UINT cdwControlData;     // Number of DWords to follow.
    UINT adwControlData[0];  // Actually this will be adwControlData[cdwControlData]

} ITS_Control_Data, *PITS_Control_Data;  


// ITSFS_Control_Data is the actual prefix structure of control data for IITStorage. 

typedef struct _ITSFS_Control_Data
{
    UINT cdwFollowing;     // Must be 6 or 13

    DWORD cdwITFS_Control; // Must be 5
    DWORD dwMagic;         // Must be MAGIC_ITSFS_CONTROL (see below)
    DWORD dwVersion;       // Must be 1
    DWORD cbDirectoryBlock;// Size in bytes of directory blocks (Default is 8192)
    DWORD cMinCacheEntries;// Least upper bound on the number of directory blocks
	                       // which we'll cache in memory. (Default is 20)
    DWORD fFlags;          // Control bit flags (see below). 
	                       // Default value is fDefaultIsCompression.

} ITSFS_Control_Data, *PITSFS_Control_Data;

// Signature value for ITSFS_Control_Data

const DWORD MAGIC_ITSFS_CONTROL    = 'I' | ('T' << 8) | ('S' << 16) | ('C' << 24);

// Bit flag definitions for ITSFS_Control_Data::fFlags

const DWORD fDefaultIsCompression  = 0x00000001;
const DWORD fDefaultIsUncompressed = 0x00000000;

// Note all other fFlags bits positions are reserved for future releases and should be 
// set to zero.

// When ITSFS_Control_Data::cdwFollowing is > 6, we assume that LZX_Control_Data follows
// immediately after. (See the XformControlData type below) LZX_Control_Data defines
// parameters which control the default compressed data space. 
//
// If ITSFS_Control_Data::cdwFollowing is 6, we use default values for the LZX
// control data.

typedef struct _LZX_Control_Data
{
    UINT  cdwControlData; // Must be 6

    DWORD dwLZXMagic;     // Must be LZX_MAGIC (see below)
    DWORD dwVersion;      // Must be 2
    DWORD dwMulResetBlock;// Number of blocks between compression resets.  (Default: 4)
    DWORD dwMulWindowSize;// Maximum number of blocks kept in data history (Default: 4)
    DWORD dwMulSecondPartition; // Granularity in blocks of sliding history(Default: 2)
    DWORD dwOptions;  // Option flags (Default: fOptimizeCodeStreams)

} LZX_Control_Data, *PLZX_Control_Data;

// Note: The block size for LZX compression is 32768 bytes.

const DWORD LZX_MAGIC           = 'L' | ('Z' << 8 ) | ('X' << 16) | ('C' << 24);

// Values for LZX_Control_Data::dwOptions

const DWORD fOptimizeCodeStreams = 0x00000001;

// Note that all other flag bit positions are reserved for future releases and should be
// set to zero.


// The second parameter for the IITStorage::Compact method below is an enueration
// which defines the level of compaction to do.

typedef enum ECompactionLev {COMPACT_DATA=0, COMPACT_DATA_AND_PATH} ;

DECLARE_INTERFACE_(IITStorage, IUnknown)
{
    // IITStorage methods

    STDMETHOD(StgCreateDocfile)(const WCHAR * pwcsName, DWORD grfMode, 
                                DWORD reserved, IStorage ** ppstgOpen
                               ) PURE;

    STDMETHOD(StgCreateDocfileOnILockBytes)(ILockBytes * plkbyt, DWORD grfMode,
                                            DWORD reserved, IStorage ** ppstgOpen
                                           ) PURE;

    STDMETHOD(StgIsStorageFile)(const WCHAR * pwcsName) PURE;

    STDMETHOD(StgIsStorageILockBytes)(ILockBytes * plkbyt) PURE;

    STDMETHOD(StgOpenStorage)(const WCHAR * pwcsName, IStorage * pstgPriority, 
                              DWORD grfMode, SNB snbExclude, DWORD reserved, 
                              IStorage ** ppstgOpen
                             ) PURE;

    STDMETHOD(StgOpenStorageOnILockBytes)
                  (ILockBytes * plkbyt, IStorage * pStgPriority, DWORD grfMode, 
                   SNB snbExclude, DWORD reserved, IStorage ** ppstgOpen
                  ) PURE;

    STDMETHOD(StgSetTimes)(WCHAR const * lpszName,  FILETIME const * pctime, 
                           FILETIME const * patime, FILETIME const * pmtime
                          ) PURE;

    STDMETHOD(SetControlData)(PITS_Control_Data pControlData) PURE;

    STDMETHOD(DefaultControlData)(PITS_Control_Data *ppControlData) PURE;
		
    STDMETHOD(Compact)(const WCHAR * pwcsName, ECompactionLev iLev) PURE;
};

DECLARE_INTERFACE_(IITStorageEx, IITStorage)
{
    STDMETHOD(StgCreateDocfileForLocale)
        (const WCHAR * pwcsName, DWORD grfMode, DWORD reserved, LCID lcid, 
         IStorage ** ppstgOpen
        ) PURE;

    STDMETHOD(StgCreateDocfileForLocaleOnILockBytes)
        (ILockBytes * plkbyt, DWORD grfMode, DWORD reserved, LCID lcid, 
         IStorage ** ppstgOpen
        ) PURE;

    STDMETHOD(QueryFileStampAndLocale)(const WCHAR *pwcsName, DWORD *pFileStamp, 
                                                              DWORD *pFileLocale) PURE;
    
    STDMETHOD(QueryLockByteStampAndLocale)(ILockBytes * plkbyt, DWORD *pFileStamp, 
                                                                DWORD *pFileLocale) PURE;
};

typedef IITStorage *PIITStorage;

DECLARE_INTERFACE_(IFSStorage, IUnknown)
{
    // IUnknown methods

    STDMETHOD(QueryInterface)  (THIS_ REFIID, VOID **) PURE;
    STDMETHOD_(ULONG, AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // IFSStorage methods

    STDMETHOD(FSCreateStorage)(const WCHAR * pwcsName, DWORD grfMode, IStorage **ppstgOpen) PURE;

    STDMETHOD(FSOpenStorage)(const WCHAR * pwcsName, DWORD grfMode, IStorage **ppstgOpen) PURE;

    STDMETHOD(FSCreateStream)(const WCHAR *pwcsName, DWORD grfMode, IStream **ppStrm) PURE;
    STDMETHOD(FSCreateTemporaryStream)(IStream **ppStrm) PURE;
    STDMETHOD(FSOpenStream  )(const WCHAR *pwcsName, DWORD grfMode, IStream **ppStrm) PURE;
    STDMETHOD(FSCreateLockBytes)(const WCHAR *pwcsName, DWORD grfMode, ILockBytes **ppLkb) PURE;
    STDMETHOD(FSCreateTemporaryLockBytes)(ILockBytes **ppLkb) PURE;
    STDMETHOD(FSOpenLockBytes  )(const WCHAR *pwcsName, DWORD grfMode, ILockBytes **ppLkb) PURE;

    STDMETHOD(FSStgSetTimes)(WCHAR const * lpszName,  FILETIME const * pctime, 
                             FILETIME const * patime, FILETIME const * pmtime
                            ) PURE;
};

typedef IFSStorage *PIFSStorage;

/*
**   Data Spaces -- What they are.

Within an ITS file we store information in one or more data spaces. A data space
is a container which holds the bits which represent a collection of streams. Each
data space has a name and an associated collection of transforms.

Those transforms take the raw data which you write to an ITS stream and map it into
a representation stream. When you read from an ITS stream they do the reverse mapping
to reconstruct your original data from the representation. 

When you first create an ITS file, it contains one data space named "Default_Space"
which applies the LZX data compression transform. By default all of the streams you
create will have their data representations stored in the default data space.

If LZX compression meets your needs, and you're not concerned about data enciphering,
you can skip over the following discussion. If, on the other hand, you want to 
create additional data spaces or transforms, read on.

To create a data space, you must first get a pointer to the IDataSpaceManager interface.
Just do a QueryInterface for IID_DataSpaceManager from any storage created by the 
IITStorage interface. Then you can call the CreateDataSpace function to define a new
data space. 

When you're defining a collection of data spaces, be sure that their names are distinct.
Defining two data spaces with the same name is an error. Data space names follow the
rules for stream names. That is, they must be less than 260 characters long, and may
not contain the characters '/'. '\', '|', ':', or any character less than 0x0020.

Data spaces are kept in a separate name space. So you don't have to worry about
colliding with a stream name or a storage name. As noted above, we have defined one
special data space ("Default_Space") where all data resides if you take no action.

You can redefine that default space simply by creating a new data space with the
name "Default_Space". This is the one case where a name collision is allowed. If 
you do redefine the default data space, any data in the old space will automatically
be transformed appropriately and moved into the new default data space.  

**   Importing Items

If you have defined additional data spaces, the next step is to define which streams
and storages you want to move into the new data spaces. You do that by means of the 
IDataSpace::Import function. For example suppose you've defined the dataspace 
*pMyDataSpace and you want to import the stream "Alpha" contained in the storage 
*pThatStorage:

    pMyDataSpace->Import(pThatStorage, "Alpha");

Similarly if you want to import the storage "HTML_Pages" from pThisStorage:

    pMyDataSpace->Import(pThisStorage, "HTML_Pages");

That will recursively import the "HTML_Pages" storage and all of the streams and 
storages contained within it. It also conditions those storages so that anything
you create within them will be automatically imported into pMyDataSpace. Note that
subsequent Import operations may alter that conditioning.

If you later decide that you want to move "Alpha" back into the default data
space:

    hr = pDataSpaceManager->OpenDataSpace(L"Default_Space", &pDefaultDataSpace);

    pDefaultDataSpace->Import(pThatStorage, "Alpha");

**  Data Space Transform Sets 

When you define a data space, you must specify a set of transforms to apply to 
the items you import into the space. A transform is an interface that converts
data to some other representation. For example the LZX transform converts your 
imported data into a more compact, compressed representation. Other transforms
might implement word or phrase based dictionary compression, or they might encipher 
your data, or they might just convert from one data format to another. You could, 
for example, construct a transform to store HTML data as a Rich Text stream.

When you define a data space with more than one transform, they are applied in 
order. For example let's suppose that your transform set consists of these three:

  1. A Dictionary compression transform

  2. The LXZ transform

  3. An data encryption transform

Whenever you write data into this space, it will first be compressed using the
dictionary compression methods, then LZX compression will be applied, and finally
your information will be encrypted. When you read data the process is reversed so
that the encryption transform supplies data to the LZX transform which in turn 
provides data for the dictionary compression transform.

You define the transform set via a vector of class ids (paclsidXform). Each class id
defines a location where an implementation of IID_Transform can be found. In addition
you'll supply corresponding control data for each transform (papxfcd). The number of 
transforms is defined by the cXforms parameter.

Note that it is legal to define a space with zero transforms. This is useful when
you've got items which are already compressed and which won't benefit from an
additional layer of compression overhead.

The control data for a transform defines how it will operate in a particular
data space. For example the control data for the LZX transform defines how
aggressively it will pursue compression, and it controls the tradeoff between
random access performance and the level of compression.

The actual structure and content of the control data is documented above.
(See the LZX_Control_Data data type.)

**  Transform Factories -- How they are organized; What they do

Transforms have two functional capabilities. They can return default
control data (DefaultControlData), and they can create
transform instances (CreateTransformInstance). When the ITSS code calls your 
CreateTransformInstance function, it will supply a storage medium (pXFSpan_Base)
where transformed data is to be stored along with the control data for the
instance and several other useful pieces of information. 

The CreateTransformInstance function has several parameters that you can use 
when you need to access global and/or instance data streams. They also support
the construction of encryption transforms. You can ignore those parameters if your
transform doesn't do encryption, uses only a single pass over the data, and doesn't
rely on any data beyond the data in the stream being transformed.

  -- The rclsidXForm and pwszDataSpace parameters, respectively, tell you the Class ID
  by which your code was located, and the name of the data space in which your instance
  will be working. These values are used with the ITransformServices interface.

  -- The pXformServices parameter points to an instance of the ITranformServices interface. 
  That interface gives you access to a couple of storages where you can keep global and
  instance data for your transform. It also gives you a way to contruct a temporary
  stream that is automatically deleted when you release it. That's very handy when 
  you get a seek operation into the middle of the transformed data followed by a write 
  operation.

  If you're implementing a multipass strategy, you can get access to those storages
  from code outside the transform by doing a QueryInterface from any ITS storage for 
  the interface IID_ITransformServices. You identify the storage in question by the
  transform's class id and possibly the name of the data space instance. 

  The per-transform-instance storage is also a convenient place to put the navigation
  data necessary to support fast seek operations.

  -- The pKeyManager parameter is an interface pointer used with encryption transforms.
  It supplies the read and write keys to use with your encryption transform. Those keys
  are set by the SetKeys interface of the ITransformServices interface. This allows you
  to separate your user interface code where people will enter passwords from the 
  transform implementations. This can be useful when you want the same keys to be used 
  for several different data spaces.  

**  Transform Instances -- How they are organized; What they do

A Transform Instance is an object which simulates a data medium which can be 
suballocated. Suballocated items are managed as data spans (ITransformedSpan).
You must supply a function to create a data span (CreateTransformedSpan), and
a function to open a data span (OpenTransformedSpan). Both of those functions 
return an ITransformedSpan interface when they succeed. In addition you must
supply the function SpaceSize to return the size of the entire untransformed
data image. That is, SpaceSize returns the highest limit offset (offset + size)
of any data span created within the instance. 

A span is identified by an ImageSpan structure which defines an offset and a size 
for the span. Both values are defined in untransformed space. For the Create function
this is an output parameter, while it is an input parameter for the Open function.
Note the interaction between the ImageSpan and the WriteAt member function of the
ITransformedSpan interface.

**  Transformed Data Spans -- How they are organized; What they do

A transformed Data Span (ITransformedSpan) has two member functions -- ReadAt and 
WriteAt. Those functions are very similar to the ReadAt and WriteAt functions of
the ILockBytes interface. The difference is that WriteAt includes an extra output
parameter (pImageSpan) for recording the current span parameters. The ReadAt function
doesn't include that parameter because read operations can never change the span's
size or move it to a different offset.

**  Implementation Strategies

This section describes a few scenarios that you may encounter as you construct a 
transform along with strategies for those situations. This is an open ended list 
which will expand as we gain more experience with transforms.

Many compression and encryption transforms are designed around sequential I/O. That is,
they expect to get the raw data from a sequence of write opeations with no intervening
seek operations. In many cases such transforms also write out the transformed data to 
the base stream in ascending order. Similarly they expect read requests to come to them
with no intervening seek operations. 

The key issue for those transforms is how do you implement random access and interleaved
read, write, and seek operations. 

Leaving aside write operations for the moment, let's consider a random sequence of reads
interleaved with seek operations. One solution might be to construct a table to map from
raw data offsets to transformed data offsets. You can store such a table in the instance
storage for the current data space. 

One complication is that many compression transforms use the raw data as a dictionary. 
That is, you can only start reading from the beginning of the transformed data. You can
deal with those transforms telling them to reset themselves periodically. That gives
you a collection of starting points spread fairly evenly throught the transformed 
data. When you do this you'll need to supply a control data parameter to control the
frequency of those reset points so that your clients can make an appropriate tradeoff
between compression efficiency and random access performance.

Now what about adding random write operations to the mix? The short answer here is that
you can't do this in the middle of transformed data. One strategy would be to reconstruct
the entire raw data into a temporary stream and do all your I/O to that stream until
release time. Then at release time you can transform the revised data sequentially.

A variation on that strategy is to keep track of which reset spans are modified and 
write the modified versions of those transformed spans to the end of the base stream.
This leaves a certain amount of dead space in your transformed data, but it allows
you to defer the sequential reconstruction work to a more convenient time. The down 
side  is that it requires you to manage yet more navigation data in the instance 
storage for the data space.

 */

interface IDataSpaceManager;
interface IDataSpace;
interface ITransformServices;
interface IKeyInstance;
interface ITransformFactory;
interface ITransformInstance;

typedef struct _XformControlData
{
    UINT  cdwControlData;    // Size of this structure in DWords
    UINT  adwControlData[0]; // Actually this will be UINT adwData[cdwData];

} XformControlData, *PXformControlData;

/*
// {7C01FD0F-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_IDataSpaceManager, 
0x7c01fd0f, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IDataSpaceManager : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE CreateDataSpace
        (const WCHAR *pwszDataSpace, UINT cXforms,
         const CLSID *paclsidXform, PXformControlData paxfcd,
         IDataSpace *pITDataSpace
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE OpenDataSpace
        (const WCHAR *pwszDataSpace, 
         IDataSpace *pITDataSpace
        ) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE DiscardDataSpace
        (const WCHAR *pwszDataSpace) = 0;

    virtual HRESULT STDMETHODCALLTYPE EnumDataSpaces
        (IEnumSTATSTG ** ppenum) = 0;
};


/*
// {7C01FD0E-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_IDataSpace, 
0x7c01fd0e, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IDataSpace : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE GetTransformInfo
        (PUINT pcXforms, PUINT pcdwXformControlData, 
         CLSID *paclsid, PXformControlData pxfcd
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Import
        (IStorage *pStg, const WCHAR * pwszElementName) = 0;

    virtual HRESULT STDMETHODCALLTYPE ImportSpace(IStorage **ppStg) = 0;
};

/*
// {7C01FD0C-7BAA-11d0-9E0C-00A0C922E6EC}
DEFINE_GUID(IID_ITransformFactory, 
0x7c01fd0c, 0x7baa, 0x11d0, 0x9e, 0xc, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformFactory : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE DefaultControlData
        (XformControlData **ppXFCD) = 0;

    virtual HRESULT STDMETHODCALLTYPE CreateTransformInstance
        (ITransformInstance *pXFormMedium,        // Container data span for transformed data
		 ULARGE_INTEGER      cbUntransformedSize, // Untransformed size of data
         PXformControlData   pXFCD,               // Control data for this instance
         const CLSID        *rclsidXForm,         // Transform Class ID
         const WCHAR        *pwszDataSpaceName,   // Data space name for this instance
         ITransformServices *pXformServices,      // Utility routines
         IKeyInstance       *pKeyManager,         // Interface to get enciphering keys
         ITransformInstance **ppTransformInstance // Out: Instance transform interface
        ) = 0;
};

typedef struct _ImageSpan
{
	ULARGE_INTEGER	uliHandle;
	ULARGE_INTEGER  uliSize;

} ImageSpan;

/*
// {EB19B67E-9360-11d0-9E16-00A0C922E6EC}
DEFINE_GUID(IID_ITransformInstance, 
0xeb19b67e, 0x9360, 0x11d0, 0x9e, 0x16, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformInstance : public IUnknown
{
public:

	virtual HRESULT STDMETHODCALLTYPE ReadAt 
	                    (ULARGE_INTEGER ulOffset, void *pv, ULONG cb, ULONG *pcbRead,
						 ImageSpan *pSpan
                        ) = 0;

	virtual HRESULT STDMETHODCALLTYPE WriteAt
	                    (ULARGE_INTEGER ulOffset, const void *pv, ULONG cb, ULONG *pcbWritten, 
						 ImageSpan *pSpan
                        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE Flush() = 0;

	virtual HRESULT STDMETHODCALLTYPE SpaceSize(ULARGE_INTEGER *puliSize) = 0;

	// Note: SpaceSize returns the high water mark for the space. That is, the largest
	//       limit value (uliOffset + uliSize) for any transformed lockbytes created within
	//       the base (*pXLKB).
};

/*
// {A55895FC-89E1-11d0-9E14-00A0C922E6EC}
DEFINE_GUID(IID_ITransformServices, 
0xa55895fc, 0x89e1, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface ITransformServices : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE PerTransformStorage
        (REFCLSID rclsidXForm, IStorage **ppStg) = 0;

    virtual HRESULT STDMETHODCALLTYPE PerTransformInstanceStorage
        (REFCLSID rclsidXForm, const WCHAR *pwszDataSpace, IStorage **ppStg) = 0;

    virtual HRESULT STDMETHODCALLTYPE SetKeys
        (REFCLSID rclsidXForm, const WCHAR *pwszDataSpace, 
         PBYTE pbReadKey,  UINT cbReadKey, 
         PBYTE pbWriteKey, UINT cbWriteKey
        ) = 0;

    virtual HRESULT STDMETHODCALLTYPE CreateTemporaryStream(IStream **ppStrm) = 0;
};

/*
// {96AF35CE-88EC-11d0-9E14-00A0C922E6EC}
DEFINE_GUID(IID_IKeyInstance, 
0x96af35ce, 0x88ec, 0x11d0, 0x9e, 0x14, 0x0, 0xa0, 0xc9, 0x22, 0xe6, 0xec);
 */

interface IKeyInstance : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE GetKeys
        (PBYTE *pbReadKey,  PUINT pcbReadKey,
         PBYTE *pbWriteKey, PUINT pcbWriteKey
        ) = 0;
};

/* 

  Streams stored in an ITS file may be accessed through URLs with
  the form:

      its: <File Path> :: <Stream Path>

  where <File Path> may be either a Win32 file path or a URL, and
  <Stream Path> is the path to a stream stored in the ITS file. 
  Each <Stream Path> must begin with '/'. 

  This means that you can copy a Win32 directory tree of HTML files
  and associated files into an ITS file and get to them through ITS
  URLs. If all the URL references within those HTML files are 
  relative, they will be resolved within the containing ITS file.

  The <File Path> portion of the URL may either be a complete path
  to the ITS file, or it may be just the file name. In the later case
  you may need to install auxillary information in the registry to
  help the ITSS code locate the file. Here are the rules:

  1. If you don't supply a complete path, ITSS looks in the current
     working directory for the file. 

  2. If the file isn't found in step 1. ITSS looks for a registry
     value in the ITSS_MAP section of HKEY_LOCAL_MACHINE. The value
     name must match the file name, and the value will be a string
     giving the complete file path to be used.

  3. If the file isn't found in steps 1 and 2, ITSS isolates the file's 
     extension (beginning with the last '.' character) and looks
     for a corresponding class id value in the ITSS_FINDER section 
     of HKEY_LOCAL_MACHINE. The name for the value will match the
     extension, and the value will be the class id for an object
     which implements the IID_IITFileFinder interface.

  4. If the file isn't found in steps 1 through 3, the URL reference
     fails.

 */

#define ITSS_MAP     "Software\\Microsoft\\Windows\\ITStorage\\Maps"
#define ITSS_FINDER  "Software\\Microsoft\\Windows\\ITStorage\\Finders"

interface IITFileFinder : public IUnknown
{
public:

    virtual HRESULT STDMETHODCALLTYPE FindThisFile(const WCHAR *pFileName, WCHAR **ppFullPath,
                                                   BOOL *pfRecordPathInRegistry
                                                  ) = 0;

// The FindThisFile method maps a file name into a complete file path. The file name
// is defined by *pFileName, and a pointer to the complete path is returned in 
// *ppFullPath. The returned path will be a string allocated in the IMalloc heap.
// The *pfRecordPathInRegistry result should be TRUE when we should record this mapping
// in the ITSS_MAP registry section and FALSE otherwise.

    
};


#endif // __MSITSTG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\ocxglobals.h ===
// 
// MODULE: ComGlobals.h
//
// PURPOSE: Global functions that are handy to have.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		3/24/98		JM		Local Version for NT5
///////////////////////

#ifndef __COMGLOBALS_H_
#define __COMGLOBALS_H_ 1

bool BSTRToTCHAR(LPTSTR szChar, BSTR bstr, int CharBufSize);

bool ReadRegSZ(HKEY hRootKey, LPCTSTR szKey, LPCTSTR szValue, LPTSTR szBuffer, DWORD *pdwBufSize);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TSHOOT.rc
//
#define IDS_TSHOOT                      1
#define IDD_ABOUTBOX_TSHOOT             1
#define IDB_TSHOOT                      1
#define IDI_ABOUTDLL                    1
#define IDS_TSHOOT_PPG                  2
#define IDS_TSHOOT_PPG_CAPTION          100
#define IDD_PROPPAGE_TSHOOT             100
#define IDS_ER_RELOADFAILED             201
#define IDS_ER_RELOADDEPFAILED          202
#define IDS_ER_RELOADIDEPFAILED         203
#define IDS_ER_RELOADIDEPFAILEDA        204
#define IDS_ER_ERRORS_OCCURED           205
#define IDS_ER_NO_INPUT_PARAMS          206
#define IDS_ER_UNEXP_CMD                207
#define IDS_I_OBJ_MOVED                 208
#define IDS_ER_SVR_BAD_DATA             209
#define IDS_FP_TITLE                    210
#define IDS_FP_BODY_ATTRIB              211
#define IDS_FP_HEADER                   212
#define IDS_ER_NO_API                   213
#define IDS__ER_HTX_PARSE               214
#define IDS_ER_MEM1                     215
#define IDS_ER_ASSERT_FAILED            216
#define IDS_I_NO_RESULT                 217
#define IDS_ER_MISSING_API              218
#define IDS_ER_UNEXP_CMDA               219
#define IDS_ER_GEN_HDR1                 220
#define IDS_ER_GEN_FDR1                 221
#define IDS_I_NO_TS1                    222
#define IDS_I_NO_TS2                    223
#define IDS_FPA_HEADER                  224
#define IDS_FPA_FOOTER                  225
#define IDS_FPA_BODY                    226
#define IDS_CONTROL_SCRIPT1             227
#define IDS_CONTROL_SCRIPT2             228
#define IDS_CONTROL_OBJECT              229
#define IDS_FORM_START                  230
#define IDS_FPA_TS_BUTTON               231
#define IDS_CONTROL_FRAME_SCRIPT1       232
#define IDS_CONTROL_FRAME_SCRIPT2       233
#define IDS_CONTROL_FRAME_SCRIPT3       234
#define IDS_HTM_IDH1                    235
#define IDS_HTM_HEADER1                 236
#define IDS_HTM_ST_LIST1                237
#define IDS_HTM_EN_LIST1                238
#define IDS_HTM_RADIO1A                 239
#define IDS_HTM_RADIO1B                 240
#define IDS_HTM_TEXT1                   241
#define IDS_HTM_RADIO2A                 242
#define IDS_HTM_RADIO2B                 243
#define IDS_HTM_EN_LIST2                244
#define IDS_HTM_EN_LIST2A               244
#define IDS_HTM_HEADER2                 245
#define IDS_HTM_IDH2                    246
#define IDS_HTM_BR1                     247
#define IDS_HTM_ST_LIST2                248
#define IDS_HTM_IDS_BYE                 249
#define IDS_HTM_IDS_FAIL                250
#define IDS_HTM_EN_LIST2B               250
#define IDS_HTM_IDH3                    251
#define IDS_HTM_IDH4                    252
#define IDS_HTM_IDH5                    253
#define IDS_HTM_HEADER3                 254
#define IDS_HTM_HEADER4                 255
#define IDS_HTM_HEADER5                 256
#define IDS_HTM_BODY2                   257
#define IDS_HTM_BODY1                   258
#define IDS_HTM_BODY3                   259
#define IDS_HTM_ST_LIST3                260
#define IDS_HTM_BACK_START              260
#define IDS_HTM_RADIO3A                 261
#define IDS_HTM_RADIO3B                 262
#define IDS_HTM_EN_LIST3                263
#define IDS_HTM_ST_LIST4                264
#define IDS_HTM_RADIO4A                 265
#define IDS_HTM_RADIO4B                 266
#define IDS_HTM_EN_LIST4                267
#define IDS_PROBLEM                     268
#define IDS_STRING269                   269
#define IDS_STRING270                   270
#define IDS_STRING271                   271
#define IDS_STRING272                   272
#define IDS_HTM_EN_BYE_MSG              273
#define IDS_EN_IMP                      274

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxctl.h>         // MFC support for OLE Controls

// Delete the two includes below if you do not wish to use the MFC
//  database classes
#ifndef _UNICODE
//#include <afxdb.h>			// MFC database classes
//#include <afxdao.h>			// MFC DAO database classes

#endif //_UNICODE

#include <afxtempl.h>
#include <afxole.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\rsstack.h ===
//
//
// MODULE: RSStack.h
//
// PURPOSE:  First in first out single linked list.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 8/7/96
//
// NOTES: 
// 1.	A stack of any structure.  Can be used for pointers, but
//		will cause a memory leak when the stack is destroyed with
//		objects on it.
//
// 2.	This file has no .cpp file. Every thing is inline, due to the
//		template class.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		3/24/98		JM		Local Version for NT5
//

#ifndef __RSSTACK_H_
#define __RSSTACK_H_ 1

template<class T>
class RSStack
{
public:
	RSStack();
 	virtual ~RSStack();
// Attributes
public:

private:
	typedef struct tagRSStackNode
	{
		T SItem;
		struct tagRSStackNode *pNext;
	} RSStackNode;

	RSStackNode *m_pTop;
	RSStackNode *m_pPeak;

// Operations
public:
/*	
	Push returns -1 when out of memory.
*/
int Push(T);
/*
	Pop returns the top T item.
*/
T Pop();
/*
	1 is the top most item in the stack.  Returns the T item at
	tdown index by copying the value to refedItem.  False is returned if 
	tdown is greater than the number of items in the stack.
*/
BOOL GetAt(int tdown, T &refedItem);
/*
	PeakFirst returns the top most item and initializes variables that are
	used by PeakNext.  PeakFirst returns false when the stack is empty.
*/
BOOL PeakFirst(T &refedItem);
/*
	Use PeakNext to quickly peak at all of the items on the stack.
	PeakNext returns false when it can not copy a T item to refedItem.
*/
BOOL PeakNext(T &refedItem);
/*
	Empty returns TRUE (Non-Zero) when the stack is empty.
*/
BOOL Empty();
/*
	RemoveAll throws away the contents of the stack.
*/
void RemoveAll();
};

template<class T>
inline RSStack<T>::RSStack()
{
	m_pTop = NULL;
	m_pPeak = NULL;
}

template<class T>
inline RSStack<T>::~RSStack()
{
	RSStackNode *pOld;
	while(m_pTop != NULL)
	{
		pOld = m_pTop;
		m_pTop = m_pTop->pNext;
		delete pOld;
	}
}

template<class T>
inline int RSStack<T>::Push(T Item)
{
	int Ret;
	RSStackNode *pNew = new RSStackNode;
	if(NULL == pNew)
	{
		Ret = -1;
	}
	else
	{
		Ret = 1;
		pNew->pNext = m_pTop;
		m_pTop = pNew;
		pNew->SItem = Item;
	}
	return Ret;
}

template<class T>
inline T RSStack<T>::Pop()
{
	T Ret;
	if(NULL != m_pTop)
	{
		RSStackNode *pOld = m_pTop;
		m_pTop = m_pTop->pNext;
		Ret = pOld->SItem;
		delete pOld;
	}
	return Ret;
}

template<class T>
inline BOOL RSStack<T>::Empty()
{
	BOOL bRet;
	if(NULL == m_pTop)
		bRet = TRUE;
	else
		bRet = FALSE;
	return bRet;
}

template<class T>
inline void RSStack<T>::RemoveAll()
{
	RSStackNode *pOld;
	while(m_pTop != NULL)
	{
		pOld = m_pTop;
		m_pTop = m_pTop->pNext;
		delete pOld;
	}
}

template<class T>
inline BOOL RSStack<T>::GetAt(int tdown, T &refedItem)
{
	BOOL bRet = FALSE;
	RSStackNode *pNode = m_pTop;
	while(pNode != NULL && tdown > 1)
	{
		pNode = pNode->pNext;
		tdown--;
	}
	if (pNode && 1 == tdown)
	{
		refedItem = pNode->SItem;
		bRet = TRUE;
	}
	return bRet;
}

template<class T>
inline BOOL RSStack<T>::PeakFirst(T &refedItem)
{
	BOOL bRet = FALSE;
	if (NULL != m_pTop)
	{
		m_pPeak = m_pTop;
		refedItem = m_pTop->SItem;
		bRet = TRUE;
	}
	return bRet;
}

template<class T>
inline BOOL RSStack<T>::PeakNext(T &refedItem)
{
	ASSERT(NULL != m_pPeak);
	BOOL bRet = FALSE;
	m_pPeak = m_pPeak->pNext;
	if (NULL != m_pPeak)
	{
		refedItem = m_pPeak->SItem;
		bRet = TRUE;
	}
	return bRet;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\sniff.cpp ===
//
// MODULE: SNIFF.CPP
//
// PURPOSE: sniffed data container
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 3-27-99
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.2		6/4/97		RWM		Local Version for Memphis
// V0.3		3/24/98		JM		Local Version for NT5

#include "stdafx.h"

#include "sniff.h"

#include "apgts.h"
#include "bnts.h"
#include "BackupInfo.h"
#include "cachegen.h"
#include "apgtsinf.h"

//////////////////////////////////////////////////////////////////////////////////////
// CSniffedNodeContainer class definition
//
CSniffedNodeContainer::CSniffedNodeContainer()
					 : m_pBNTS(NULL)
{
}

CSniffedNodeContainer::CSniffedNodeContainer(GTSAPI* bnts)
				     : m_pBNTS(bnts)
{
}

CSniffedNodeContainer::~CSniffedNodeContainer()
{
}

void CSniffedNodeContainer::SetBNTS(GTSAPI* bnts)
{
	m_pBNTS = bnts;
}

inline GTSAPI* CSniffedNodeContainer::GetBNTS()
{
	return m_pBNTS;
}

bool CSniffedNodeContainer::AddNode(CString name, int state)
{
	if (GetBNTS())
	{
		CSniffedNodeInfo info(name, state);
	
		// use GTSAPI:: since it should be unicode - compliant
		if (SNIFF_INVALID_NODE_ID != (info.m_iId = m_pBNTS->GTSAPI::INode(LPCTSTR(name))))
		{
			if (!HasNode(info.m_iId))
			{
				m_arrInfo.Add(info);
				return true;
			}
		}
	}

	return false;
}

bool CSniffedNodeContainer::ResetIds()
{
	CArray<CSniffedNodeInfo, CSniffedNodeInfo&> tmp;

	tmp.Copy(m_arrInfo);
	Flush();
	for (int i = 0; i < m_arrInfo.GetSize(); i++)
	{
		if (!AddNode(m_arrInfo[i].m_strName, m_arrInfo[i].m_iState))
		{
			m_arrInfo.Copy(tmp);
			return false;
		}
	}

	return true;
}

bool CSniffedNodeContainer::HasNode(int id)
{
	for (int i = 0; i < m_arrInfo.GetSize(); i++)
		if (m_arrInfo[i].m_iId == id)
				return true;
	return false;
}

bool CSniffedNodeContainer::GetState(int id, int* state)
{
	for (int i = 0; i < m_arrInfo.GetSize(); i++)
	{
		if (m_arrInfo[i].m_iId == id)
		{
				*state = m_arrInfo[i].m_iState;
				return true;
		}
	}
	return false;
}

inline
bool CSniffedNodeContainer::IsEmpty()
{
	return 0 == m_arrInfo.GetSize();
}

void CSniffedNodeContainer::Flush()
{
	m_arrInfo.RemoveAll();
}

CSniffedNodeInfo* CSniffedNodeContainer::GetInfo(int id)
{
	for (int i = 0; i < m_arrInfo.GetSize(); i++)
		if (m_arrInfo[i].m_iId == id)
				return &m_arrInfo[i];
	return NULL;
}

bool CSniffedNodeContainer::GetLabel(int id, int* label)
{
	for (int i = 0; i < m_arrInfo.GetSize(); i++)
	{
		if (m_arrInfo[i].m_iId == id)
		{
			if (SNIFF_INVALID_NODE_LABEL != m_arrInfo[i].m_iLabel)
			{
				*label = m_arrInfo[i].m_iLabel;
			}
			else
			{
				if (GetLabelFromBNTS(id, label))
				{
					// once we have got label from BNTS - save it
					m_arrInfo[i].m_iLabel = *label;
				}
				else
				{
					return false;
				}
			}
			return true;
		}
	}
	return false;
}

bool CSniffedNodeContainer::GetLabelFromBNTS(int node, int* label)
{
	// work strictly with BNTS class
	
	int old_node = m_pBNTS->BNTS::INodeCurrent();

	if (m_pBNTS->BNTS::BNodeSetCurrent(node))
	{	
		*label = m_pBNTS->BNTS::ELblNode();		
		m_pBNTS->BNTS::BNodeSetCurrent(old_node); // we do not check if successful - old_node might be -1
		return true;
	}

	return false;
}

int CSniffedNodeContainer::GetSniffedFixobsThatWorked()
{
	for (int i = 0; i < m_arrInfo.GetSize(); i++)
	{
		int label = SNIFF_INVALID_NODE_LABEL;

		if (GetLabel(m_arrInfo[i].m_iId, &label) && // fixobs node is set to 1 - WORKED!
			ESTDLBL_fixobs == label &&
			m_arrInfo[i].m_iState == 1
		   )
		   return m_arrInfo[i].m_iId;
	}

	return SNIFF_INVALID_NODE_ID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\sniff.h ===
//
// MODULE: SNIFF.H
//
// PURPOSE: sniffed data container
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Oleg Kalosha
// 
// ORIGINAL DATE: 3-27-99
//
// NOTES: 
// 1. Based on Print Troubleshooter DLL
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.2		6/4/97		RWM		Local Version for Memphis
// V0.3		3/24/98		JM		Local Version for NT5

#ifndef TSHOOT_SNIFF_H
#define TSHOOT_SNIFF_H


#define SNIFF_INVALID_NODE_ID      -1
#define SNIFF_INVALID_STATE        -1
#define SNIFF_INVALID_NODE_LABEL   -1

//////////////////////////////////////////////////////////////////////////////////////
// CSniffedNodeInfo struct
//

struct CSniffedNodeInfo
{
	CSniffedNodeInfo() 
								: m_iState(SNIFF_INVALID_STATE),
								  m_iId(SNIFF_INVALID_NODE_ID),
								  m_iLabel(SNIFF_INVALID_NODE_LABEL) 
	{}

	CSniffedNodeInfo(CString& name, int state) 
								: m_strName(name), 
								  m_iState(state), 
								  m_iId(SNIFF_INVALID_NODE_ID),
								  m_iLabel(SNIFF_INVALID_NODE_LABEL) 
	{}
	
	int  m_iId; // node id
	int  m_iState; // node state (sniffed)
	int  m_iLabel; // node label
	CString	 m_strName; // node symbolic name
};

//////////////////////////////////////////////////////////////////////////////////////
// CSniffedContainer class declaration
//
class GTSAPI;
class CSniffedNodeContainer
{
public:
	CSniffedNodeContainer();
	CSniffedNodeContainer(GTSAPI*);
	virtual ~CSniffedNodeContainer();

// interface
	GTSAPI* GetBNTS();
	void SetBNTS(GTSAPI* bnts);

	bool AddNode(CString name, int state);
	bool ResetIds(); // should be called if we (re)set BNTS
	bool HasNode(int id);
	CSniffedNodeInfo* GetInfo(int id);
	bool GetState(int id, int* state);
	bool GetLabel(int id, int* label);
	bool IsEmpty();
	void Flush();

	int  GetSniffedFixobsThatWorked();

protected:
	bool GetLabelFromBNTS(int node, int* label);

protected:
	GTSAPI*  m_pBNTS; // pointer to BNTS (or inherited class)
	CArray<CSniffedNodeInfo, CSniffedNodeInfo&> m_arrInfo; // data array
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\tshootppg.cpp ===
//
// MODULE: TSHOOTPPG.CPP
//
// PURPOSE: Implementation of the CTSHOOTPropPage property page class.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8/7/97
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.2		8/7/97		RM		Local Version for Memphis
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//

#include "stdafx.h"
#include "TSHOOT.h"
#include "TSHOOTPpg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CTSHOOTPropPage, COlePropertyPage)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CTSHOOTPropPage, COlePropertyPage)
	//{{AFX_MSG_MAP(CTSHOOTPropPage)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CTSHOOTPropPage, "TSHOOT.TSHOOTPropPage.1",
	0x4b106875, 0xdd36, 0x11d0, 0x8b, 0x44, 0, 0xa0, 0x24, 0xdd, 0x9e, 0xff)


/////////////////////////////////////////////////////////////////////////////
// CTSHOOTPropPage::CTSHOOTPropPageFactory::UpdateRegistry -
// Adds or removes system registry entries for CTSHOOTPropPage

BOOL CTSHOOTPropPage::CTSHOOTPropPageFactory::UpdateRegistry(BOOL bRegister)
{
	if (bRegister)
		return AfxOleRegisterPropertyPageClass(AfxGetInstanceHandle(),
			m_clsid, IDS_TSHOOT_PPG);
	else
		return AfxOleUnregisterClass(m_clsid, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// CTSHOOTPropPage::CTSHOOTPropPage - Constructor

CTSHOOTPropPage::CTSHOOTPropPage() :
	COlePropertyPage(IDD, IDS_TSHOOT_PPG_CAPTION)
{
	//{{AFX_DATA_INIT(CTSHOOTPropPage)
	// NOTE: ClassWizard will add member initialization here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_INIT
}


/////////////////////////////////////////////////////////////////////////////
// CTSHOOTPropPage::DoDataExchange - Moves data between page and properties

void CTSHOOTPropPage::DoDataExchange(CDataExchange* pDX)
{
	//{{AFX_DATA_MAP(CTSHOOTPropPage)
	// NOTE: ClassWizard will add DDP, DDX, and DDV calls here
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA_MAP
	DDP_PostProcessing(pDX);
}


/////////////////////////////////////////////////////////////////////////////
// CTSHOOTPropPage message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\tshoot.cpp ===
//
// MODULE: TSHOOT.CPP
//
// PURPOSE: Implementation of CTSHOOTApp and DLL registration.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8/7/97
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.2		8/7/97		RM		Local Version for Memphis
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//

#include "stdafx.h"
#include "TSHOOT.h"

#include "apgts.h"

#include "ErrorEnums.h"
#include "BasicException.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CTSHOOTApp NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
		{ 0x4b106871, 0xdd36, 0x11d0, { 0x8b, 0x44, 0, 0xa0, 0x24, 0xdd, 0x9e, 0xff } };
const WORD _wVerMajor = 1;
const WORD _wVerMinor = 0;


////////////////////////////////////////////////////////////////////////////
// CTSHOOTApp::InitInstance - DLL initialization

BOOL CTSHOOTApp::InitInstance()
{
	BOOL bInit = COleControlModule::InitInstance();

	if (bInit)
	{
		::AfxOleInit();
	}

	return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CTSHOOTApp::ExitInstance - DLL termination

int CTSHOOTApp::ExitInstance()
{
	// TODO: Add your own module termination code here.

	return COleControlModule::ExitInstance();
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	AFX_MANAGE_STATE(_afxModuleAddrThis);

	if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor))
		return ResultFromScode(SELFREG_E_TYPELIB);

	if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE))
		return ResultFromScode(SELFREG_E_CLASS);

	return NOERROR;
}

void ReportError(DLSTATTYPES Error)
{
	CBasicException *pBExc = new CBasicException;
	pBExc->m_dwBErr = Error;
	throw pBExc;
	return;
}
// ReportWFEvent (Based on Microsoft code)
//
// report an event to the NT event watcher
// pass 1, 2 or 3 strings
//
// no return value

VOID ReportWFEvent(LPTSTR string1,LPTSTR string2,LPTSTR string3,LPTSTR string4,DWORD eventID)
{
	CBasicException *pBExc = new CBasicException;
	pBExc->m_dwBErr = (DLSTATTYPES) eventID;
	throw pBExc;
	return;
/*
	HANDLE hEvent;
	PTSTR pszaStrings[4];
	WORD cStrings;

	cStrings = 0;
	if ((pszaStrings[0] = string1) && (string1[0])) cStrings++;
	if ((pszaStrings[1] = string2) && (string2[0])) cStrings++;
	if ((pszaStrings[2] = string3) && (string3[0])) cStrings++;
	if ((pszaStrings[3] = string4) && (string4[0])) cStrings++;
	if (cStrings == 0)
		return;
	
	hEvent = RegisterEventSource(
					NULL,		// server name for source (NULL means this computer)
					REG_EVT_ITEM_STR);		// source name for registered handle  
	if (hEvent) {
		ReportEvent(hEvent,					// handle returned by RegisterEventSource 
				    evtype(eventID),		// event type to log 
				    0,						// event category 
				    eventID,				// event identifier 
				    0,						// user security identifier (optional) 
				    cStrings,				// number of strings to merge with message  
				    0,						// size of binary data, in bytes
				    (LPCTSTR *)pszaStrings,	// array of strings to merge with message 
				    NULL);		 			// address of binary data 
		DeregisterEventSource(hEvent);
	} 
*/
}
/*
	Addbackslash appends a \ to null terminated strings that do
	not already have a \.
*/
void _addbackslash(LPTSTR sz)
{
	int len = _tcslen(sz);
	if (len && (0 == _tcsncmp(&sz[len - 1], _T("/"), 1)))
	{
		sz[len - 1] = _T('\\');
	}
	else if (len && (0 != _tcsncmp(&sz[len - 1], _T("\\"), 1)))
	{
		sz[len] = _T('\\');
		sz[len + 1] = NULL;
	}
	return;
}
void _addforwardslash(LPTSTR sz)
{
	int len = _tcslen(sz);
	if (len && (0 == _tcsncmp(&sz[len - 1], _T("\\"), 1)))
	{
		sz[len - 1] = _T('/');
	}
	else if (len && (0 != _tcsncmp(&sz[len - 1], _T("/"), 1)))
	{
		sz[len] = _T('/');
		sz[len + 1] = NULL;
	}
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\tshoot.h ===
// MODULE: TSHOOT.h : main header file for TSHOOT.DLL
//
// PURPOSE: Declaration of the CTSHOOTCtrl OLE control class.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8/7/97
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.2		8/7/97		RM		Local Version for Memphis
// V0.3		3/24/98		JM		Local Version for NT5
//

#if !defined( __AFXCTL_H__ )
	#error include 'afxctl.h' before including this file
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CTSHOOTApp : See TSHOOT.cpp for implementation.

class CTSHOOTApp : public COleControlModule
{
public:
	BOOL InitInstance();
	int ExitInstance();
};

extern const GUID CDECL _tlid;
extern const WORD _wVerMajor;
extern const WORD _wVerMinor;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\tshootctl.h ===
//
// MODULE: TSHOOTCTL.H
//
// PURPOSE: Declaration of the CTSHOOTCtrl OLE control class.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
//			further work by Richard Meadows (RWM), Joe Mabel
// 
// ORIGINAL DATE: 8/7/97
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.2		8/7/97		RM		Local Version for Memphis
// V0.3		3/24/98		JM		Local Version for NT5
//

// INI section header
#define TSINI_GROUP_STR			_T("[TSLocalDownload.V1]")

// file types (maps to sub key lists)
#define TSINI_TYPE_TS			_T("TS")
#define TSINI_TYPE_SF			_T("SF")

// parameter offset in INI
#define TSINI_OFFSET_TYPE		0
#define TSINI_OFFSET_FILENAME	1
#define TSINI_OFFSET_VERSION	2
#define TSINI_OFFSET_FRIENDLY	3
//
#define TSINI_LINE_PARAM_COUNT	4

/////////////////////////////////////////////////////////////////////////////
// CTSHOOTCtrl : See TSHOOTCtl.cpp for implementation.

// Roman Mach believes (3/14/98) that there is exactly one object of this type in the Local
//	Troubleshooter and that this object persists intact as we move from node to node within 
//	a troubleshooting belief network.  (This may not be strictly true if the "Download"  
//	feature is used.)  Since this class can be DYNCREATEd it's hard to verify this definitively.
class CTSHOOTCtrl : public COleControl
{
#define PRELOAD_LIBRARY _T("apgts.dll?preload=")
	DECLARE_DYNCREATE(CTSHOOTCtrl)

// Constructor
public:
	CTSHOOTCtrl();

	VOID StatusEventHelper(	DLITEMTYPES dwItem, 
							DLSTATTYPES dwStat, 
							DWORD dwExtended = 0, 
							BOOL bComplete = FALSE);
	
	VOID ProgressEventHelper( DLITEMTYPES dwItem, ULONG ulCurr, ULONG ulTotal );

	DLSTATTYPES ProcessReceivedData(DLITEMTYPES dwItem, TCHAR *pData, UINT uLen);
	
	const CString GetListPath();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTSHOOTCtrl)
	public:
	virtual void OnDraw(CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid);
	virtual void DoPropExchange(CPropExchange* pPX);
	virtual void OnResetState();
	//}}AFX_VIRTUAL

// Implementation
protected:
	~CTSHOOTCtrl();
	CString m_strCurShooter;
	APGTSContext m_apgts;
	CDBLoadConfiguration m_Conf;
	CHttpQuery m_httpQuery;

	DECLARE_OLECREATE_EX(CTSHOOTCtrl)    // Class factory and guid
	DECLARE_OLETYPELIB(CTSHOOTCtrl)      // GetTypeInfo
	DECLARE_PROPPAGEIDS(CTSHOOTCtrl)     // Property page IDs
	DECLARE_OLECTLTYPE(CTSHOOTCtrl)		// Type name and misc status

// Message maps
	//{{AFX_MSG(CTSHOOTCtrl)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Dispatch maps
	//{{AFX_DISPATCH(CTSHOOTCtrl)
	CString m_downloadURL;
	afx_msg void OnDownloadURLChanged();
	CString m_downloadListFilename;
	afx_msg void OnDownloadListFilenameChanged();
	afx_msg BSTR RunQuery(const VARIANT FAR& varCmds, const VARIANT FAR& varVals, short size);
	afx_msg bool SetSniffResult(const VARIANT FAR& varNodeName, const VARIANT FAR& varState);
	afx_msg long GetExtendedError();
	afx_msg BSTR GetCurrentFriendlyDownload();
	afx_msg BSTR GetCurrentFileDownload();
	afx_msg long DownloadAction(long dwActionType);
	afx_msg BSTR BackUp();
	afx_msg BSTR ProblemPage();
	afx_msg BSTR PreLoadURL(LPCTSTR szRoot);
	afx_msg BSTR Restart();
	afx_msg BSTR RunQuery2(LPCTSTR szTopic, LPCTSTR szCmd, LPCTSTR szVal);
	afx_msg void SetPair(LPCTSTR szName, LPCTSTR szValue);
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

	afx_msg void AboutBox();

// Event maps
	//{{AFX_EVENT(CTSHOOTCtrl)
	void FireBindProgress(LPCTSTR sFile, long ulCurr, long ulTotal)
		{FireEvent(eventidBindProgress,EVENT_PARAM(VTS_BSTR  VTS_I4  VTS_I4), sFile, ulCurr, ulTotal);}
	void FireBindStatus(long uItem, long uStat, long uExtended, BOOL bComplete)
		{FireEvent(eventidBindStatus,EVENT_PARAM(VTS_I4  VTS_I4  VTS_I4  VTS_BOOL), uItem, uStat, uExtended, bComplete);}
	void FireSniffing(LPCTSTR strMachine, LPCTSTR strPNPDevice, LPCTSTR strDeviceInstance, LPCTSTR strClassGuid)
		{FireEvent(eventidSniffing,EVENT_PARAM(VTS_BSTR  VTS_BSTR  VTS_BSTR  VTS_BSTR), strMachine, strPNPDevice, strDeviceInstance, strClassGuid);}
	//}}AFX_EVENT
	DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
	enum {
	//{{AFX_DISP_ID(CTSHOOTCtrl)
	dispidDownloadURL = 1L,
	dispidDownloadListFilename = 2L,
	dispidRunQuery = 3L,
	dispidSetSniffResult = 4L,
	dispidGetExtendedError = 5L,
	dispidGetCurrentFriendlyDownload = 6L,
	dispidGetCurrentFileDownload = 7L,
	dispidDownloadAction = 8L,
	dispidBackUp = 9L,
	dispidProblemPage = 10L,
	dispidPreLoadURL = 11L,
	dispidRestart = 12L,
	dispidRunQuery2 = 13L,
	dispidSetPair = 14L,
	eventidBindProgress = 1L,
	eventidBindStatus = 2L,
	eventidSniffing = 3L,
	//}}AFX_DISP_ID
	};

protected:
	DLSTATTYPES ProcessINI(TCHAR *pData);
	DLSTATTYPES ProcessDSC(TCHAR *pData, UINT uLen);
	BOOL FileRegCheck(CString &sType, CString &sFilename, CString &sKeyName, DWORD dwCurrVersion);
	DLSTATTYPES GetPathToFiles();

protected:
	BOOL m_bComplete;
	CDownload *m_download;
	CDnldObjList m_dnldList;
	DWORD m_dwExtendedErr;
	CString m_sBasePath;
	CSniffedNodeContainer* m_pSniffedContainer; // pointer to container to save results of sniffing
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\client\launchers.h ===
// 
// MODULE: Launchers.h
//
// PURPOSE: All of the functions here launch a troubleshooter or
//			do a query to find if a mapping exists.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

DWORD LaunchKnownTSA(ITShootATL *pITShootATL, const char * szNet, 
		const char * szProblemNode, DWORD nNode, 
		const char ** pszNode, DWORD* pVal);		// Launches to a known network.  Optionaly can set any node.
DWORD LaunchKnownTSW(ITShootATL *pITShootATL, const wchar_t * szNet, 
		const wchar_t * szProblemNode, DWORD nNode, 
		const wchar_t ** pszNode, DWORD* pVal);		// Launches to a known network.  Optionaly can set any node.


DWORD Launch(ITShootATL *pITShootATL, _bstr_t &bstrCallerName, 
				_bstr_t &bstrCallerVersion, _bstr_t &bstrAppProblem, short bLaunch);

DWORD LaunchDevice(ITShootATL *pITShootATL, _bstr_t &bstrCallerName, 
				_bstr_t &bstrCallerVersion, _bstr_t &bstrPNPDeviceID, 
				_bstr_t &bstrDeviceClassGUID, _bstr_t &bstrAppProblem, short bLaunch);

void SetStatusA(DWORD dwStaus, DWORD nChar, char szBuf[]);
void SetStatusW(DWORD dwStaus, DWORD nChar, wchar_t szBuf[]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\client\launchers.cpp ===
// 
// MODULE: Launchers.cpp
//
// PURPOSE: All of the functions here launch a troubleshooter or
//			do a query to find if a mapping exists.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#include <windows.h>
#include <windowsx.h>
#include <winnt.h>

#include "TSLError.h"
#include <TSLauncher.h>
#include "LaunchServ.h"

#include <comdef.h>
#include "Launchers.h"

#include "tsmfc.h"

#include <stdio.h>
#include <string.h>


// LaunchKnownTS:  Launches the trouble shooter to a specified 
// network, problem node, and can also set nodes.
DWORD LaunchKnownTSA(ITShootATL *pITShootATL, const char * szNet, 
		const char * szProblemNode, DWORD nNode, const char ** pszNode, DWORD* pVal)
{
	HRESULT hRes;
	CHAR szValue[512];
	DWORD dwResult = TSL_ERROR_GENERAL;
	hRes = pITShootATL->ReInit();
	// Set the network and problem node.
	_bstr_t bstrNet(szNet);
	_bstr_t bstrProblem(szProblemNode);
	hRes = pITShootATL->SpecifyProblem(bstrNet, bstrProblem, &dwResult);
	if (TSL_SERV_FAILED(hRes))
		return TSL_ERROR_OBJECT_GONE;
	if (TSLIsError(dwResult))
		return dwResult;
	// Set the nodes
	for (DWORD x = 0; x < nNode; x++)
	{
		sprintf(szValue, "%ld", pVal[x]);
		_bstr_t bstrNode(pszNode[x]);
		_bstr_t bstrVal(szValue);
		hRes = pITShootATL->SetNode(bstrNode, bstrVal, &dwResult);
		if (TSL_SERV_FAILED(hRes))
			return TSL_ERROR_OBJECT_GONE;
		if (TSLIsError(dwResult))
			return dwResult;
	}
	hRes = pITShootATL->LaunchKnown(&dwResult);
	if (TSL_SERV_FAILED(hRes))
		dwResult = TSL_ERROR_OBJECT_GONE;
	return dwResult;
}

DWORD LaunchKnownTSW(ITShootATL *pITShootATL, const wchar_t * szNet, 
		const wchar_t * szProblemNode, DWORD nNode, const wchar_t ** pszNode, DWORD* pVal)
{
	HRESULT hRes;
	WCHAR szValue[512];
	DWORD dwResult = TSL_ERROR_GENERAL;
	hRes = pITShootATL->ReInit();
	// Set the network and problem node.
	_bstr_t bstrNet(szNet);
	_bstr_t bstrProblem(szProblemNode);
	hRes = pITShootATL->SpecifyProblem(bstrNet, bstrProblem, &dwResult);
	if (TSL_SERV_FAILED(hRes))
		return TSL_ERROR_OBJECT_GONE;
	if (TSLIsError(dwResult))
		return dwResult;
	// Set the nodes
	for (DWORD x = 0; x < nNode; x++)
	{
		swprintf(szValue, L"%ld", pVal[x]);
		_bstr_t bstrNode(pszNode[x]);
		_bstr_t bstrVal(szValue);
		hRes = pITShootATL->SetNode(bstrNode, bstrVal, &dwResult);
		if (TSL_SERV_FAILED(hRes))
			return TSL_ERROR_OBJECT_GONE;
		if (TSLIsError(dwResult))
			return dwResult;
	}
	hRes = pITShootATL->LaunchKnown(&dwResult);
	if (TSL_SERV_FAILED(hRes))
		dwResult = TSL_ERROR_OBJECT_GONE;
	return dwResult;
}

DWORD Launch(ITShootATL *pITShootATL, _bstr_t &bstrCallerName, 
				_bstr_t &bstrCallerVersion, _bstr_t &bstrAppProblem, short bLaunch)
{
	HRESULT hRes;
	DWORD dwResult = TSL_ERROR_GENERAL;
	hRes = pITShootATL->Launch(bstrCallerName, bstrCallerVersion, bstrAppProblem, bLaunch, &dwResult);
	if (TSL_SERV_FAILED(hRes))
		dwResult = TSL_ERROR_OBJECT_GONE;
	return dwResult;
}

DWORD LaunchDevice(ITShootATL *pITShootATL, _bstr_t &bstrCallerName, 
				_bstr_t &bstrCallerVersion, _bstr_t &bstrPNPDeviceID, 
				_bstr_t &bstrDeviceClassGUID, _bstr_t &bstrAppProblem, short bLaunch)
{
	HRESULT hRes;
	DWORD dwResult = TSL_ERROR_GENERAL;
	hRes = pITShootATL->LaunchDevice(bstrCallerName, bstrCallerVersion, bstrPNPDeviceID,
							bstrDeviceClassGUID, bstrAppProblem, bLaunch, &dwResult);
	if (TSL_SERV_FAILED(hRes))
		dwResult = TSL_ERROR_OBJECT_GONE;
	return dwResult;
}

void SetStatusA(DWORD dwStatus, DWORD nChar, char szBuf[])
{
	AfxLoadStringA(dwStatus, szBuf, nChar);
	return;
}

void SetStatusW(DWORD dwStatus, DWORD nChar, wchar_t szBuf[])
{
	AfxLoadStringW(dwStatus, szBuf, nChar);
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\tshootppg.h ===
//
// MODULE: TSHOOTPPG.H
//
// PURPOSE: Declaration of the CTSHOOTPropPage property page class.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-284-7511 support@saltmine.com
//
// AUTHOR: Roman Mach
// 
// ORIGINAL DATE: 8/7/97
//
// NOTES: 
// 1. 
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.2		8/7/97		RM		Local Version for Memphis
// V0.3		3/24/98		JM		Local Version for NT5
//

////////////////////////////////////////////////////////////////////////////
// CTSHOOTPropPage : See TSHOOTPpg.cpp.cpp for implementation.

class CTSHOOTPropPage : public COlePropertyPage
{
	DECLARE_DYNCREATE(CTSHOOTPropPage)
	DECLARE_OLECREATE_EX(CTSHOOTPropPage)

// Constructor
public:
	CTSHOOTPropPage();

// Dialog Data
	//{{AFX_DATA(CTSHOOTPropPage)
	enum { IDD = IDD_PROPPAGE_TSHOOT };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

// Message maps
protected:
	//{{AFX_MSG(CTSHOOTPropPage)
		// NOTE - ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\control\tshootctl.cpp ===
// MODULE: TSHOOTCTL.CPP
//
// PURPOSE: Interface for the componet.
//
// PROJECT: Generic Troubleshooter DLL for Microsoft AnswerPoint
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Roman Mach
//
// ORIGINAL DATE: 6/4/96
//
// NOTES:
// 1. Based on Print Troubleshooter DLL.
// 2. Richard Meadows wrote the RunQuery, BackUp, Problem Page and
//	  PreLoadURL functions.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
// V0.3		04/09/98	JM/OK+	Local Version for NT5
//

#include "stdafx.h"
#include "ErrorEnums.h"

#include "cathelp.h"

#include "TSHOOT.h"

#include "time.h"

#include "apgts.h"
#include "ErrorEnums.h"
#include "BasicException.h"
#include "apgtsfst.h"

#include "ErrorEnums.h"

#include "CabUnCompress.h"

#include "bnts.h"
#include "BackupInfo.h"
#include "cachegen.h"
#include "apgtsinf.h"
#include "apgtscmd.h"
#include "apgtshtx.h"
#include "apgtscls.h"

#include "OcxGlobals.h"


class CTSHOOTCtrl;

#include "dnldlist.h"
#include "download.h"

#include "TSHOOTCtl.h"
#include "TSHOOTPpg.h"

#include "Functions.h"
#include "ErrorEnums.h"
#include "BasicException.h"
#include "HttpQueryException.h"

#include <stdlib.h>

#include "LaunchServ.h"
#include "LaunchServ_i.c"

// >>> test
#include "fstream.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


IMPLEMENT_DYNCREATE(CTSHOOTCtrl, COleControl)


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CTSHOOTCtrl, COleControl)
	//{{AFX_MSG_MAP(CTSHOOTCtrl)
	// NOTE - ClassWizard will add and remove message map entries
	//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
	ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CTSHOOTCtrl, COleControl)
	//{{AFX_DISPATCH_MAP(CTSHOOTCtrl)
	DISP_PROPERTY_NOTIFY(CTSHOOTCtrl, "DownloadURL", m_downloadURL, OnDownloadURLChanged, VT_BSTR)
	DISP_PROPERTY_NOTIFY(CTSHOOTCtrl, "DownloadListFilename", m_downloadListFilename, OnDownloadListFilenameChanged, VT_BSTR)
	DISP_FUNCTION(CTSHOOTCtrl, "RunQuery", RunQuery, VT_BSTR, VTS_VARIANT VTS_VARIANT VTS_I2)
	DISP_FUNCTION(CTSHOOTCtrl, "SetSniffResult", SetSniffResult, VT_BOOL, VTS_VARIANT VTS_VARIANT)
	DISP_FUNCTION(CTSHOOTCtrl, "GetExtendedError", GetExtendedError, VT_I4, VTS_NONE)
	DISP_FUNCTION(CTSHOOTCtrl, "GetCurrentFriendlyDownload", GetCurrentFriendlyDownload, VT_BSTR, VTS_NONE)
	DISP_FUNCTION(CTSHOOTCtrl, "GetCurrentFileDownload", GetCurrentFileDownload, VT_BSTR, VTS_NONE)
	DISP_FUNCTION(CTSHOOTCtrl, "DownloadAction", DownloadAction, VT_I4, VTS_I4)
	DISP_FUNCTION(CTSHOOTCtrl, "BackUp", BackUp, VT_BSTR, VTS_NONE)
	DISP_FUNCTION(CTSHOOTCtrl, "ProblemPage", ProblemPage, VT_BSTR, VTS_NONE)
	DISP_FUNCTION(CTSHOOTCtrl, "PreLoadURL", PreLoadURL, VT_BSTR, VTS_BSTR)
	DISP_FUNCTION(CTSHOOTCtrl, "Restart", Restart, VT_BSTR, VTS_NONE)
	DISP_FUNCTION(CTSHOOTCtrl, "RunQuery2", RunQuery2, VT_BSTR, VTS_BSTR VTS_BSTR VTS_BSTR)
	DISP_FUNCTION(CTSHOOTCtrl, "SetPair", SetPair, VT_EMPTY, VTS_BSTR VTS_BSTR)
	//}}AFX_DISPATCH_MAP
	DISP_FUNCTION_ID(CTSHOOTCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CTSHOOTCtrl, COleControl)
	//{{AFX_EVENT_MAP(CTSHOOTCtrl)
	EVENT_CUSTOM("BindProgress", FireBindProgress, VTS_BSTR  VTS_I4  VTS_I4)
	EVENT_CUSTOM("BindStatus", FireBindStatus, VTS_I4  VTS_I4  VTS_I4  VTS_BOOL)
	EVENT_CUSTOM("Sniffing", FireSniffing, VTS_BSTR  VTS_BSTR  VTS_BSTR  VTS_BSTR)
	//}}AFX_EVENT_MAP
END_EVENT_MAP()


/////////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  Remember to increase the count!
BEGIN_PROPPAGEIDS(CTSHOOTCtrl, 1)
	PROPPAGEID(CTSHOOTPropPage::guid)
END_PROPPAGEIDS(CTSHOOTCtrl)


/////////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CTSHOOTCtrl, "TSHOOT.TSHOOTCtrl.1",
	0x4b106874, 0xdd36, 0x11d0, 0x8b, 0x44, 0, 0xa0, 0x24, 0xdd, 0x9e, 0xff)


/////////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CTSHOOTCtrl, _tlid, _wVerMajor, _wVerMinor)


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DTSHOOT =
		{ 0x4b106872, 0xdd36, 0x11d0, { 0x8b, 0x44, 0, 0xa0, 0x24, 0xdd, 0x9e, 0xff } };
const IID BASED_CODE IID_DTSHOOTEvents =
		{ 0x4b106873, 0xdd36, 0x11d0, { 0x8b, 0x44, 0, 0xa0, 0x24, 0xdd, 0x9e, 0xff } };

const CATID CATID_SafeForScripting		= {0x7dd95801,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};
const CATID CATID_SafeForInitializing	= {0x7dd95802,0x9882,0x11cf,{0x9f,0xa9,0x00,0xaa,0x00,0x6c,0x42,0xc4}};

/////////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwTSHOOTOleMisc =
	OLEMISC_ACTIVATEWHENVISIBLE |
	OLEMISC_SETCLIENTSITEFIRST |
	OLEMISC_INSIDEOUT |
	OLEMISC_CANTLINKINSIDE |
	OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CTSHOOTCtrl, IDS_TSHOOT, _dwTSHOOTOleMisc)


/////////////////////////////////////////////////////////////////////////////
// CTSHOOTCtrl::CTSHOOTCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CTSHOOTCtrl

BOOL CTSHOOTCtrl::CTSHOOTCtrlFactory::UpdateRegistry(BOOL bRegister)
{
	// TODO: Verify that your control follows apartment-model threading rules.
	// Refer to MFC TechNote 64 for more information.
	// If your control does not conform to the apartment-model rules, then
	// you must modify the code below, changing the 6th parameter from
	// afxRegApartmentThreading to 0.

	HRESULT hr;
	BOOL bRes;
	if (bRegister)
	{
		bRes = AfxOleRegisterControlClass(
			AfxGetInstanceHandle(),
			m_clsid,
			m_lpszProgID,
			IDS_TSHOOT,
			IDB_TSHOOT,
			afxRegApartmentThreading,
			_dwTSHOOTOleMisc,
			_tlid,
			_wVerMajor,
			_wVerMinor);

		hr = CreateComponentCategory(CATID_SafeForScripting, L"Controls that are safely scriptable");
		ASSERT(SUCCEEDED(hr));
		hr = CreateComponentCategory(CATID_SafeForInitializing, L"Controls safely initializable from persistent data");
		ASSERT(SUCCEEDED(hr));
		hr = RegisterCLSIDInCategory(m_clsid, CATID_SafeForScripting);
		ASSERT(SUCCEEDED(hr));
		hr = RegisterCLSIDInCategory(m_clsid, CATID_SafeForInitializing);
		ASSERT(SUCCEEDED(hr));
	}
	else
	{
		hr = UnRegisterCLSIDInCategory(m_clsid, CATID_SafeForScripting);
		ASSERT(SUCCEEDED(hr));
		hr = UnRegisterCLSIDInCategory(m_clsid, CATID_SafeForInitializing);
		ASSERT(SUCCEEDED(hr));

		bRes = AfxOleUnregisterClass(m_clsid, m_lpszProgID);
	}
	return bRes;
}


/////////////////////////////////////////////////////////////////////////////
// CTSHOOTCtrl::CTSHOOTCtrl - Constructor

CTSHOOTCtrl::CTSHOOTCtrl()
{
	InitializeIIDs(&IID_DTSHOOT, &IID_DTSHOOTEvents);

	// TODO: Initialize your control's instance data here.
	m_strCurShooter = _T("");
	m_download = NULL;
	m_bComplete = TRUE;
	m_dwExtendedErr = LTSC_OK;
	m_pSniffedContainer = NULL;
}


/////////////////////////////////////////////////////////////////////////////
// CTSHOOTCtrl::~CTSHOOTCtrl - Destructor

CTSHOOTCtrl::~CTSHOOTCtrl()
{
	// TODO: Cleanup your control's instance data here.
}


/////////////////////////////////////////////////////////////////////////////
// CTSHOOTCtrl::OnDraw - Drawing function

void CTSHOOTCtrl::OnDraw(
			CDC* pdc, const CRect& rcBounds, const CRect& rcInvalid)
{
	// TODO: Replace the following code with your own drawing code.
	pdc->FillRect(rcBounds, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
	pdc->Ellipse(rcBounds);
}


/////////////////////////////////////////////////////////////////////////////
// CTSHOOTCtrl::DoPropExchange - Persistence support

void CTSHOOTCtrl::DoPropExchange(CPropExchange* pPX)
{
	ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
	COleControl::DoPropExchange(pPX);
}


/////////////////////////////////////////////////////////////////////////////
// CTSHOOTCtrl::OnResetState - Reset control to default state

void CTSHOOTCtrl::OnResetState()
{
	COleControl::OnResetState();  // Resets defaults found in DoPropExchange

	// TODO: Reset any other control state here.
}


/////////////////////////////////////////////////////////////////////////////
// CTSHOOTCtrl::AboutBox - Display an "About" box to the user

void CTSHOOTCtrl::AboutBox()
{
	CDialog dlgAbout(IDD_ABOUTBOX_TSHOOT);
	dlgAbout.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CTSHOOTCtrl message handlers

bool CTSHOOTCtrl::SetSniffResult(const VARIANT FAR& varNodeName, const VARIANT FAR& varNodeState)
{
	BSTR bstrNodeName = NULL;
	int iNodeState = 0;
	short sNodeNameLen = 0;
	TCHAR* tszNodeName = NULL;
	bool ret = true;

// >>> test
#ifdef _DEBUG
//	AfxDebugBreak();
#endif

	if (VT_BYREF == (VT_BYREF & varNodeName.vt) &&  // data type is VT_VARIANT | VT_BYREF
		VT_VARIANT == (VT_VARIANT & varNodeName.vt) // this means that data in VB script was passed as a variable
	   )
	{
		bstrNodeName = varNodeName.pvarVal->bstrVal;
	}
	else
	{
		if (VT_BSTR == (VT_BSTR & varNodeName.vt)) // data is of VT_BSTR type
												   // this means that data in VB script was passed as a constant
			bstrNodeName = varNodeName.bstrVal;
		else
			return false;
	}

	if (VT_BYREF == (VT_BYREF & varNodeState.vt) &&  // data type is VT_VARIANT | VT_BYREF
		VT_VARIANT == (VT_VARIANT & varNodeState.vt) // this means that data in VB script was passed as a variable
	   )
	{
		iNodeState = varNodeState.pvarVal->iVal;
	}
	else
	{
		if (VT_I2 == (VT_I2 & varNodeState.vt)) // data is of VT_I2 type
										        // this means that data in VB script was passed as a constant
			iNodeState = varNodeState.iVal;
		else
			return false;
	}
	
	sNodeNameLen = (short)::SysStringLen(bstrNodeName);
	tszNodeName = new TCHAR[sNodeNameLen+1];

	tszNodeName[sNodeNameLen] = 0;
    ::BSTRToTCHAR(tszNodeName, bstrNodeName, sNodeNameLen);

	//
	// implement set node state functionality here
	//
	if (m_pSniffedContainer)
	{
		ret = m_pSniffedContainer->AddNode(tszNodeName, iNodeState);
	}
	else
	{
		MessageBox(_T("Sniffed data will be lost!"));
		ret = false;
	}
	//

	delete [] tszNodeName;
	return ret;
}

BSTR CTSHOOTCtrl::RunQuery(const VARIANT FAR& varCmds, const VARIANT FAR& varVals, short size)
{
	CString strCmd1;
	CString strTxt;
	CString strResult = _T("");

	try
	{
		HMODULE hModule = AfxGetInstanceHandle();
		ASSERT(INVALID_HANDLE_VALUE != hModule);

		m_httpQuery.Initialize(varCmds, varVals, size);

		if (m_httpQuery.GetFirstCmd() == C_ASK_LIBRARY)
		{	
			// Added to support launching by the TS Launcher.
			// Get an ILaunchTS interface.
			HRESULT hRes;
			DWORD dwResult;
			ILaunchTS *pILaunchTS = NULL;
			CLSID clsidLaunchTS = CLSID_LaunchTS;
			IID iidLaunchTS = IID_ILaunchTS;

			// Get an interface on the launch server
			hRes = CoCreateInstance(clsidLaunchTS, NULL,
					CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER | CLSCTX_INPROC_SERVER,
					iidLaunchTS, (void **) &pILaunchTS);
			if (FAILED(hRes))
			{
				m_dwExtendedErr = TSERR_LIB_STATE_INFO;
				strResult = _T("LaunchServ interface not found.");
				return strResult.AllocSysString();
			}

			// Get all of the query values.
			hRes = pILaunchTS->GetShooterStates(&dwResult);
			if (FAILED(hRes))
			{
				m_dwExtendedErr = dwResult;
				strResult.Format(_T("<html>GetShooterStates Failed. %ld</html>"), dwResult);
				pILaunchTS->Release();			
				return strResult.AllocSysString();
			}

			// Run the query.
			OLECHAR *poleShooter;
			hRes = pILaunchTS->GetTroubleShooter(&poleShooter);
			if (FAILED(hRes))
			{
				m_dwExtendedErr = TSERR_LIB_STATE_INFO;
				strResult = _T("<html>GetTroubleShooter Failed. </html>");
				pILaunchTS->Release();
				return strResult.AllocSysString();
			}
			m_strCurShooter = poleShooter;

			// Ignoring, for now, any other information we may get from the launch server
			//	(e.g. problem node) set up m_httpQuery and other things as if we just had
			//	a request for this troubleshooting belief network.
			m_httpQuery.SetFirst(CString(C_TYPE), m_strCurShooter);
			SysFreeString(poleShooter);
			m_Conf.Initialize(hModule, (LPCTSTR) m_strCurShooter
								);	// CDBLoadConfiguration				
			m_apgts.Initialize(	m_Conf.GetAPI(),		// APGTSContext
								&m_Conf,
								&m_httpQuery);
			m_apgts.RemoveSkips();
			m_Conf.GetAPI()->api.pAPI->SetHttpQuery(&m_httpQuery);

			// sniffing
			m_Conf.GetAPI()->api.pAPI->ReadTheDscModel();
			m_pSniffedContainer = m_Conf.GetAPI()->api.pAPI;

			m_httpQuery.FinishInitFromServ(m_Conf.GetAPI()->api.pAPI, pILaunchTS);

			FireSniffing(m_httpQuery.GetMachine(),
						 m_httpQuery.GetPNPDevice(),
						 m_httpQuery.GetDeviceInstance(),
						 m_httpQuery.GetGuidClass());

			pILaunchTS->Release();
			pILaunchTS = NULL;

			m_httpQuery.SetStackDirection();
			m_Conf.SetValues(m_httpQuery);
			m_apgts.ClearBackup();

			m_Conf.GetAPI()->api.pAPI->SetReverse(false);
			m_apgts.DoContent(&m_httpQuery);

			// now add sniffed nodes that were automatically traversed
			// to the stack of navigated nodes - UGLY
			m_httpQuery.PushNodesLastSniffed(m_Conf.GetAPI()->api.pAPI->GetArrLastSniffed());

			// Now that we've done all the processing render the appropriate page.
			// This is the first page the user sees when launching a torubleshooter.
			m_apgts.RenderNext(strResult);
			m_apgts.Empty();
		}	
		else if (m_httpQuery.GetFirstCmd() == C_SELECT)
		{	// Unsupported function.
			// Returns a page that has all of the trouble shooters.
			try
			{
				CFirstPage firstPage;
				CString str = m_httpQuery.GetTroubleShooter();
				firstPage.RenderFirst(strResult, str);	// Here I am getting an hit file.
			}
			catch(CBasicException *pExc)
			{
				m_dwExtendedErr = pExc->m_dwBErr;
				strResult = _T("");
				delete pExc;
			}
		}
		else
		{	// Normal operation.
			if (m_httpQuery.GetTroubleShooter() != m_strCurShooter)
			{
				m_strCurShooter = m_httpQuery.GetTroubleShooter();
				m_Conf.Initialize(hModule, (LPCTSTR) m_strCurShooter
									);	// CDBLoadConfiguration				
				m_apgts.Initialize(	m_Conf.GetAPI(),		// APGTSContext
									&m_Conf,
									&m_httpQuery);
				m_apgts.RemoveSkips();
				m_Conf.GetAPI()->api.pAPI->SetHttpQuery(&m_httpQuery);

				// sniffing
				m_Conf.GetAPI()->api.pAPI->ReadTheDscModel();
				m_pSniffedContainer = m_Conf.GetAPI()->api.pAPI;
				FireSniffing(m_httpQuery.GetMachine(),
							 m_httpQuery.GetPNPDevice(),
							 m_httpQuery.GetDeviceInstance(),
							 m_httpQuery.GetGuidClass());
			}
			m_httpQuery.FinishInit(m_Conf.GetAPI()->api.pAPI, varCmds, varVals);
			
			m_httpQuery.SetStackDirection();
			m_Conf.SetValues(m_httpQuery);
			m_apgts.ClearBackup();

			m_Conf.GetAPI()->api.pAPI->SetReverse(false);
			m_apgts.DoContent(&m_httpQuery);

			// now add sniffed nodes that were automatically traversed
			// to the stack of navigated nodes - UGLY
			m_httpQuery.PushNodesLastSniffed(m_Conf.GetAPI()->api.pAPI->GetArrLastSniffed());

			// >>> test
			//static int step = 0;
			//char name[16] = {0};
			//sprintf(name, "next_step%d.htm", ++step);
			//ofstream file(name);
			m_apgts.RenderNext(strResult);
			//file << (LPCTSTR)strResult;
			m_apgts.Empty();
		}		
	}
	catch(COleException *pOExc)
	{
		m_dwExtendedErr = (DLSTATTYPES) pOExc->m_sc;
		pOExc->Delete();
		strResult = _T("");
	}
	catch(CBasicException *pExc)
	{
		m_dwExtendedErr = pExc->m_dwBErr;
		delete pExc;
		strResult = _T("");
	}
	unsigned short pErrorStr[2] = { NULL, NULL };
	if (strResult.GetLength() > 0)
	{
		return strResult.AllocSysString();
	}
	else
	{
		return SysAllocString((unsigned short *) pErrorStr);
	}
}

BSTR CTSHOOTCtrl::BackUp()
{
	BCache *pApi = m_Conf.GetAPI()->api.pAPI;
	CString strResult = _T("");
	if (m_httpQuery.BackUp(pApi, &m_apgts))
	{
		m_Conf.GetAPI()->api.pAPI->SetReverse(true);
		m_apgts.DoContent(&m_httpQuery);
		m_apgts.RenderNext(strResult);
		m_apgts.Empty();
	}
	else
		m_dwExtendedErr = TSERR_AT_START;
	return strResult.AllocSysString();
}
// Starter
// Historically (until March '98) this was called when the "Restart button" is pressed.
//	However, that assumed we would always want to go clear back to the problem page, which
//	is no longer policy now that the Launcher is introduced.
BSTR CTSHOOTCtrl::ProblemPage()
{
	BCache *pApi = m_Conf.GetAPI()->api.pAPI;
	CString strResult = _T("");
	if (m_strCurShooter.GetLength() > 0)
	{
		m_httpQuery.RemoveNodes(pApi);
		m_apgts.DoContent(&m_httpQuery);
		m_apgts.RenderNext(strResult);
		m_apgts.Empty();
	}	
	else
		m_dwExtendedErr = TSERR_NOT_STARTED;
	m_apgts.ResetService();
	return strResult.AllocSysString();
}

// Called when the "Restart button" is pressed.
//	If TS Launcher was not involved, go clear back to the problem page.
//	If TS Launcher is involved, go back to the page we launched to, which may or may not
//		be the problem page.
BSTR CTSHOOTCtrl::Restart()
{
	BCache *pApi = m_Conf.GetAPI()->api.pAPI;
	CString strResult;

// >>> test
#ifdef _DEBUG
//	AfxDebugBreak();
#endif

	// resniffing
	m_pSniffedContainer->Flush();
	FireSniffing(m_httpQuery.GetMachine(),
				 m_httpQuery.GetPNPDevice(),
				 m_httpQuery.GetDeviceInstance(),
				 m_httpQuery.GetGuidClass());

	if (m_strCurShooter.GetLength() > 0)
	{
		m_httpQuery.RemoveNodes(pApi);
		m_httpQuery.RestoreStatesFromServ();
		m_apgts.ClearBackup();
		m_apgts.DoContent(&m_httpQuery);
		m_apgts.RenderNext(strResult);
		m_apgts.Empty();
	}	
	else
		m_dwExtendedErr = TSERR_NOT_STARTED;

	return strResult.AllocSysString();
}


BSTR CTSHOOTCtrl::PreLoadURL(LPCTSTR szRoot)
{
	// SzRoot should look like one of these.
	// _T("http://www.microsoft.com/isapi/support/apgts/");
	// _T("http://localhost/isapi/support/apgts/");
	// _T("http://catbert.saltmine.com/scripts/apgts/");
	CString strResult;
	strResult = szRoot;
	strResult += PRELOAD_LIBRARY + m_strCurShooter +
		m_httpQuery.GetSubmitString(m_Conf.GetAPI()->api.pAPI);
	return strResult.AllocSysString();
}

const CString CTSHOOTCtrl::GetListPath()
{
	if (!m_downloadURL.GetLength() || !m_downloadListFilename.GetLength())
		return _T("");

	return m_downloadURL + m_downloadListFilename;
}

//
// Types:
//
// 0 = Get INI file contents and fill up list
//		Returns: 0 = ok, other = Error connecting
//
// 1 = Download and register DSC files based on list
//		Returns: 0 = ok, other = Error, typically no more data in list
//
// Notes:
// 1. This function starts downloading and calls BindStatus event
// as download progresses.
// 2. Type 0 must always be called after type 1 is finished to reset
// the list otherwise an error is returned
// 3. Keep dwActionType and DLITEMTYPES in sync
//
long CTSHOOTCtrl::DownloadAction(long dwActionType)
{
	DLITEMTYPES dwType;
	CString sURL;

	if (!GetListPath().GetLength())
		return LTSCERR_NOPATH;

	if (dwActionType == 0)
	{
		dwType = DLITEM_INI;
		sURL = GetListPath();
		// initialize to 'no error'
		m_dwExtendedErr = LTSC_OK;
		//m_bComplete = FALSE;
	}
	else if (dwActionType == 1)
	{
		//if (!m_bComplete)
		//	return LTSCERR_DNLDNOTDONE;

		dwType = DLITEM_DSC;
		sURL = m_downloadURL;

		if (!m_dnldList.FindNextItem())
			return LTSC_NOMOREITEMS;


		sURL += m_dnldList.GetCurrFile();
	}
	else
		return LTSCERR_UNKNATYPE;

	if (m_download == NULL)
		m_download = new CDownload();
	
	if (m_download == NULL)
		return LTSCERR_NOMEM;

	HRESULT hr = m_download->DoDownload( this, sURL, dwType);

	if (FAILED(hr))
		return LTSCERR_DNLD;

	return LTSC_OK;
}

void CTSHOOTCtrl::OnDownloadListFilenameChanged()
{
	SetModifiedFlag();
}

void CTSHOOTCtrl::OnDownloadURLChanged()
{
	SetModifiedFlag();
}

BSTR CTSHOOTCtrl::GetCurrentFileDownload()
{
	CString strResult = m_dnldList.GetCurrFile();

	return strResult.AllocSysString();
}

BSTR CTSHOOTCtrl::GetCurrentFriendlyDownload()
{
	CString strResult = m_dnldList.GetCurrFriendly();

	return strResult.AllocSysString();
}

long CTSHOOTCtrl::GetExtendedError()
{
	return (m_dwExtendedErr & 0x0000FFFF);
}

VOID CTSHOOTCtrl::StatusEventHelper(DLITEMTYPES dwItem,
										 DLSTATTYPES dwStat,
										 DWORD dwExtended,
										 BOOL bComplete)
{
	m_bComplete = bComplete;
	FireBindStatus(dwItem, dwStat, dwExtended, bComplete);
}

VOID CTSHOOTCtrl::ProgressEventHelper(	DLITEMTYPES dwItem, ULONG ulCurr, ULONG ulTotal )
{
	if (dwItem == DLITEM_INI)
		FireBindProgress(m_downloadListFilename, ulCurr, ulTotal);
	else
		FireBindProgress(m_dnldList.GetCurrFile(), ulCurr, ulTotal);
}

// Input data is null terminated for both binary and text data to simplify processing
//
DLSTATTYPES CTSHOOTCtrl::ProcessReceivedData(DLITEMTYPES dwItem, TCHAR *pData, UINT uLen)
{
	DLSTATTYPES dwStat = LTSC_OK;

	switch(dwItem)
	{
	case DLITEM_INI:
		// processing INI file
		dwStat = ProcessINI(pData);
		break;

	case DLITEM_DSC:
		// processing DSC file
		dwStat = ProcessDSC(pData, uLen);
		break;

	default:
		dwStat = LTSCERR_UNSUPP;
		break;
	}
	return dwStat;
}

// Returns true if we need to update this file
//
BOOL CTSHOOTCtrl::FileRegCheck(CString &sType,
									CString &sFilename,
									CString &sKeyName,
									DWORD dwCurrVersion)
{
	HKEY hk, hknew;
	BOOL bStat = FALSE;
	CString sMainKey;
	
	// figure out what our main key is for this file
	if (sType == TSINI_TYPE_TS)
		sMainKey = TSREGKEY_TL;
	else if (sType == TSINI_TYPE_SF)
		sMainKey = TSREGKEY_SFL;
	else
	{
		m_dwExtendedErr = LTSCERR_BADTYPE;
		return FALSE;
	}

	// first open the main key (try open all access now just in case of permissions problems)
	if (RegOpenKeyEx(	HKEY_LOCAL_MACHINE,
						sMainKey,
						0,
						KEY_ALL_ACCESS,
						&hk) == ERROR_SUCCESS)
	{
		CString sValueName;
		CString sValueClass;
		FILETIME ftLastWriteTime;
		
		DWORD count = 0;
		LONG ldStat = ERROR_SUCCESS;
		BOOL bFound = FALSE;

		while (ldStat == ERROR_SUCCESS)
		{
			LPTSTR lptname = sValueName.GetBuffer(MAX_PATH + 1);
			LPTSTR lptclass = sValueClass.GetBuffer(MAX_PATH + 1);
			
			DWORD namesize = MAX_PATH;
			DWORD classsize = MAX_PATH;
			
			ldStat = RegEnumKeyEx(	hk,
									count,
									lptname,
									&namesize,
									NULL,
									lptclass,
									&classsize,
									&ftLastWriteTime);

			sValueName.ReleaseBuffer();
			sValueClass.ReleaseBuffer();
			
			if (ldStat != ERROR_SUCCESS)
			{
				break;
			}

			if (!sValueName.CompareNoCase(sKeyName))
			{
				// open specific troubleshooter key data (read only)

				if (RegOpenKeyEx(	hk,
									sKeyName,
									0,
									KEY_ALL_ACCESS,
									&hknew) == ERROR_SUCCESS)
				{
					DWORD dwData, dwValue;
					BYTE szValue[MAXCHAR];
					//dwData = REG_DWORD;
					dwData = REG_SZ;
					DWORD dwSize = MAXCHAR;

					if (RegQueryValueEx(hknew,
										TSLCL_FVERSION,
										0,
										&dwData,
										szValue,
										&dwSize) == ERROR_SUCCESS)
					{
						dwValue = _ttoi((TCHAR *) szValue);
						if (dwValue < dwCurrVersion)
							bStat = TRUE;
						else
						{
							// check if file exists
							HANDLE hCurrFind;
							WIN32_FIND_DATA FindCurrData;
							CString sFullPath;

							sFullPath = m_sBasePath + _T("\\") + sFilename;

							hCurrFind = FindFirstFile(sFullPath, &FindCurrData);
							if (hCurrFind != INVALID_HANDLE_VALUE)
							{
								FindClose(hCurrFind);
							}
							else
								bStat = TRUE;
						}

					}
					else
						m_dwExtendedErr = LTSCERR_KEYQUERY;

					RegCloseKey(hknew);
				}
				else
					m_dwExtendedErr = LTSCERR_KEYOPEN2;

				// this is important: set this true to prevent default from trying to download
				// we wont download if we found the key but can't update
				bFound = TRUE;
				break;
			}
			count++;
		}

		if (!bFound)
		{
			bStat = TRUE;
		}

		RegCloseKey(hk);
	}
	else
		m_dwExtendedErr = LTSCERR_KEYOPEN;

	return bStat;
}

DLSTATTYPES CTSHOOTCtrl::ProcessINI(TCHAR *pData)
{
	BOOL bFoundHeader = FALSE;
	int dwCount = 0;
	int dwMaxLines = 10000;
	DLSTATTYPES dwStat = LTSC_OK;

	dwStat = GetPathToFiles();
	if (dwStat != LTSC_OK)
		return dwStat;

	m_dnldList.RemoveAll();

	CString sData = pData;
	
	int dwFullLen = sData.GetLength();

	// just to be safe...
	while (dwMaxLines--)
	{
		CString sFullString = sData.SpanExcluding(_T("\r\n"));
		int dwPartLen = sFullString.GetLength();

		if (!dwPartLen)
			break;

		dwFullLen -= dwPartLen;

		CString sSkipString1 = sData.Right(dwFullLen);
		CString sSkipString2 = sSkipString1.SpanIncluding(_T("\r\n"));

		dwFullLen -= sSkipString2.GetLength();

		sData = sSkipString1.Right(dwFullLen);

		sFullString.TrimLeft();
		sFullString.TrimRight();

		int dwLineLen = sFullString.GetLength();

		if (!dwLineLen)
			continue;

		if (sFullString[0] == _T(';'))
			continue;

		if (sFullString == TSINI_GROUP_STR)
		{
			bFoundHeader = TRUE;
			continue;
		}
		else if (sFullString[0] == _T('['))
		{
			bFoundHeader = FALSE;
			continue;
		}

		if (bFoundHeader)
		{	
			CString sParam[TSINI_LINE_PARAM_COUNT];
			int posstart = 0;

			// now break apart components
			for (int i=0;i<TSINI_LINE_PARAM_COUNT;i++)
			{
				int posend = sFullString.Find(_T(','));
				if (posend == -1 && i < (TSINI_LINE_PARAM_COUNT - 1))
				{
					m_dwExtendedErr = LTSCERR_PARAMMISS;
					break;
				}

				// so we don't find it next time
				if (posend != -1)
					sFullString.SetAt(posend, _T('.'));
				else
					posend = dwLineLen;

				sParam[i] = sFullString.Mid(posstart, posend - posstart);
				sParam[i].TrimLeft();
				sParam[i].TrimRight();

				posstart = posend + 1;
			}

			if (i==TSINI_LINE_PARAM_COUNT)
			{
				// add to object list if (1) version newer or (2) not in list yet
				CString sKeyName;
				DWORD dwVersion = _ttoi(sParam[TSINI_OFFSET_VERSION]);
				int pos;

				pos = sParam[TSINI_OFFSET_FILENAME].Find(_T('\\'));
				if (pos == -1)
				{
					pos = sParam[TSINI_OFFSET_FILENAME].Find(_T('.'));
					if (pos != -1)
					{
						if (sParam[TSINI_OFFSET_TYPE] == TSINI_TYPE_TS)
							sKeyName = sParam[TSINI_OFFSET_FILENAME].Left(pos);
						else {
							sKeyName = sParam[TSINI_OFFSET_FILENAME];
							//sKeyName.SetAt(pos, _T('_'));
						}

						// for now, check if we meet criteria
						// if yes, just add to list and download on a later iteration
						if (FileRegCheck(sParam[TSINI_OFFSET_TYPE], sParam[TSINI_OFFSET_FILENAME], sKeyName, dwVersion))
						{
							CDnldObj *pDnld = new CDnldObj(	sParam[TSINI_OFFSET_TYPE],
															sParam[TSINI_OFFSET_FILENAME],
															dwVersion,
															sParam[TSINI_OFFSET_FRIENDLY],
															sKeyName);

							if (pDnld)
							{
								m_dnldList.AddTail(pDnld);
								dwCount++;
							}
							else
							{
								dwStat = LTSCERR_NOMEM;
								break;
							}
						}
					}
					else
						m_dwExtendedErr = LTSCERR_PARAMNODOT;
				}
				else
					m_dwExtendedErr = LTSCERR_PARAMSLASH;
			}
		}
	}

	ASSERT(dwCount == m_dnldList.GetCount());

	if (!dwCount)
		dwStat = LTSCERR_NOITEMS;
	
	m_dnldList.SetFirstItem();

	return dwStat;
}

//
//
DLSTATTYPES CTSHOOTCtrl::GetPathToFiles()
{
	DLSTATTYPES dwStat = LTSC_OK;
	HKEY hk;
	
	if (RegOpenKeyEx(	HKEY_LOCAL_MACHINE,
						TSREGKEY_MAIN,
						0,
						KEY_READ,
						&hk) == ERROR_SUCCESS)
	{
		DWORD dwData = REG_SZ;
		DWORD dwSize = MAX_PATH;
		LPTSTR lptBuf = m_sBasePath.GetBuffer(MAX_PATH + 2);

		if (RegQueryValueEx(hk,
							FULLRESOURCE_STR,
							0,
							&dwData,
							(LPBYTE) lptBuf,
							&dwSize) != ERROR_SUCCESS)
		{
			dwStat = LTSCERR_BASEKQ;
		}

		m_sBasePath.ReleaseBuffer();

		RegCloseKey(hk);
	}
	else
		dwStat = LTSCERR_NOBASEPATH;
	return dwStat;
}


DLSTATTYPES CTSHOOTCtrl::ProcessDSC(TCHAR *pData, UINT uLen)
{
	DLSTATTYPES dwStat = LTSC_OK;
	HKEY hknew;
	DWORD dwDisposition;
	CString sMainKey;
	
	// we get here if we need to update this file
	// at this point we have the file downloaded and need to save it
	// we also need to create/update the necessary registry keys

	// since we know the entire key name, let's go ahead to create it
	if (m_dnldList.GetCurrType() == TSINI_TYPE_SF)
		sMainKey = TSREGKEY_SFL;
	else
		sMainKey = TSREGKEY_TL;

	sMainKey += _T("\\") + m_dnldList.GetCurrFileKey();

	// open specific troubleshooter key data
	if (RegCreateKeyEx(	HKEY_LOCAL_MACHINE,
						sMainKey,
						0,
						TSLCL_REG_CLASS,
						REG_OPTION_NON_VOLATILE,
						KEY_ALL_ACCESS,
						NULL,
						&hknew,
						&dwDisposition) == ERROR_SUCCESS)
	{
		if (dwDisposition == REG_CREATED_NEW_KEY || dwDisposition == REG_OPENED_EXISTING_KEY)
		{
			DWORD dwData = m_dnldList.GetCurrVersion();
			CString str;
			str.Format(_T("%d"), dwData);
			if (RegSetValueEx(	hknew,
								TSLCL_FVERSION,
								0,
								//REG_DWORD,
								REG_SZ,
								(LPBYTE) (LPCTSTR) str,
								str.GetLength() + sizeof(TCHAR)) != ERROR_SUCCESS)
			{
				dwStat = LTSCERR_FILEUPDATE;
				m_dwExtendedErr = LTSCERR_KEYSET1;
			}

			if (dwStat == LTSC_OK)
			{
				CString sTemp = m_dnldList.GetCurrFriendly();
				DWORD dwSize = sTemp.GetLength() + sizeof(TCHAR);
				LPCTSTR lpctFN = sTemp.GetBuffer(100);
				
				if (RegSetValueEx(	hknew,
									FRIENDLY_NAME,
									0,
									REG_SZ,
									(LPBYTE) lpctFN,
									dwSize) == ERROR_SUCCESS)
				{
					CFile sF;
					CFileException exc;
					CString sFullPath;

					sFullPath = m_sBasePath + _T("\\") + m_dnldList.GetCurrFile();

					if (sF.Open(sFullPath, CFile::modeCreate | CFile::modeWrite, &exc))
					{
						TRY
						{
							sF.Write(pData, uLen);
						}
						CATCH (CFileException, e)
						{
							dwStat = LTSCERR_FILEUPDATE;
							m_dwExtendedErr = LTSCERR_FILEWRITE;						
						}
						END_CATCH
						
						sF.Close();

						// uncompress if a cab file (be dumb, assume .cab really means a cab file)

						int pos = sFullPath.Find(_T('.'));
						if (pos != -1)
						{
							CString sTemp = sFullPath.Right(sFullPath.GetLength() - pos);
							if (!sTemp.CompareNoCase(_T(".cab")))
							{
								CCabUnCompress cab;
								CString strDestDir = m_sBasePath + "\\";
		
								if (!cab.ExtractCab(sFullPath, strDestDir, ""))
								{
									dwStat = LTSCERR_FILEUPDATE;
									m_dwExtendedErr = LTSCERR_CABWRITE;
								}

								TRY
								{
									CFile::Remove(sFullPath);
								}
								CATCH (CFileException, e)
								{
									// error is not very interesting
								}
								END_CATCH
							}
						}
					}
					else
					{		
						dwStat = LTSCERR_FILEUPDATE;
						m_dwExtendedErr = LTSCERR_FILEWRITE;
					}
				}
				else
				{
					dwStat = LTSCERR_FILEUPDATE;
					m_dwExtendedErr = LTSCERR_KEYSET2;
				}
				sTemp.ReleaseBuffer();
			}

			if (dwStat == LTSC_OK)
			{
				CString sTemp = m_dnldList.GetCurrExt();
				DWORD dwSize = sTemp.GetLength() + sizeof(TCHAR);
				LPCTSTR lpctFN = sTemp.GetBuffer(100);
				
				if (RegSetValueEx(	hknew,
									TSLCL_FMAINEXT,
									0,
									REG_SZ,
									(LPBYTE) lpctFN,
									dwSize) != ERROR_SUCCESS)
				{
					dwStat = LTSCERR_FILEUPDATE;
					m_dwExtendedErr = LTSCERR_KEYSET3;
				}
				sTemp.ReleaseBuffer();
			}
		}
		else
		{
			dwStat = LTSCERR_FILEUPDATE;
			m_dwExtendedErr = LTSCERR_KEYUNSUPP;
		}
	
		RegCloseKey(hknew);
	}
	else
	{
		dwStat = LTSCERR_FILEUPDATE;
		m_dwExtendedErr = LTSCERR_KEYCREATE;
	}
	return dwStat;
}

// Added 1/20/99 JM because RunQuery() can't be made to work with JScript, even though it
//	worked fine with VB Script.
// Simulates the form in which RunQuery() would normally get its arguments, then pass them
//	into RunQuery.
BSTR CTSHOOTCtrl::RunQuery2(LPCTSTR szTopic, LPCTSTR szCmd, LPCTSTR szVal)
{
	VARIANT varCommands;
	VARIANT varValues;
	VARIANT varCommandsWrap;
	VARIANT varValuesWrap;
	SAFEARRAY *psafearrayCmds;
	SAFEARRAY *psafearrayVals;

	VariantInit(&varCommands);
	VariantInit(&varValues);
	VariantInit(&varCommandsWrap);
	VariantInit(&varValuesWrap);

	SAFEARRAYBOUND sabCmd;
	sabCmd.cElements = 2;
	sabCmd.lLbound = 0;
	SAFEARRAYBOUND sabVal = sabCmd;

	V_VT(&varCommands) = VT_ARRAY | VT_BYREF | VT_VARIANT;
	V_VT(&varValues) = VT_ARRAY | VT_BYREF | VT_VARIANT;
	V_ARRAYREF(&varCommands) = &psafearrayCmds;
	V_ARRAYREF(&varValues) = &psafearrayVals;

	V_VT(&varCommandsWrap) = VT_BYREF | VT_VARIANT;
	V_VT(&varValuesWrap) = VT_BYREF | VT_VARIANT;

	V_VARIANTREF(&varCommandsWrap) = &varCommands;
	V_VARIANTREF(&varValuesWrap) = &varValues;

	// If first character in szCmd is a null, then there will be only one significant
	//	element in each of the arrays we are constructing below, otherwise 2.
	short size = (*szCmd) ? 2 : 1;

	CString strType(C_TYPE);
	BSTR bstrType = strType.AllocSysString();
	VARIANT varType;
	VariantInit(&varType);
	V_VT(&varType) = VT_BSTR;
	varType.bstrVal=bstrType;

	CString strTopic(szTopic);
	BSTR bstrTopic = strTopic.AllocSysString();
	VARIANT varTopic;
	VariantInit(&varTopic);
	V_VT(&varTopic) = VT_BSTR;
	varTopic.bstrVal=bstrTopic;

	CString strCmd(szCmd);
	BSTR bstrCmd = strCmd.AllocSysString();
	VARIANT varCmd;
	VariantInit(&varCmd);
	V_VT(&varCmd) = VT_BSTR;
	varCmd.bstrVal=bstrCmd;

	CString strVal(szVal);
	BSTR bstrVal = strVal.AllocSysString();
	VARIANT varVal;
	VariantInit(&varVal);
	V_VT(&varVal) = VT_BSTR;
	varVal.bstrVal=bstrVal;

	// create two vectors of BSTRs
	psafearrayCmds = SafeArrayCreate( VT_VARIANT, 1, &sabCmd);
	psafearrayVals = SafeArrayCreate( VT_VARIANT, 1, &sabVal);

	long i=0;
	SafeArrayPutElement(psafearrayCmds, &i, &varType);
	SafeArrayPutElement(psafearrayVals, &i, &varTopic);

	i=1;
	SafeArrayPutElement(psafearrayCmds, &i, &varCmd);
	SafeArrayPutElement(psafearrayVals, &i, &varVal);

	BSTR ret = RunQuery(varCommandsWrap, varValuesWrap, size);

	SafeArrayDestroy(psafearrayCmds);
	SafeArrayDestroy(psafearrayVals);

	SysFreeString(bstrType);
	SysFreeString(bstrTopic);
	SysFreeString(bstrCmd);
	SysFreeString(bstrVal);

	return ret;
}

// This function is a no-op and exist solely to allow us to write JScript that is
//	forward compatible to Local Troubleshooter version 3.1
void CTSHOOTCtrl::SetPair(LPCTSTR szName, LPCTSTR szValue)
{	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\client\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Status.rc
//
#define IDS_STRING1                     1
#define IDS_STRING2                     2
#define IDS_STRING3                     3
#define IDS_STRING4                     4
#define IDS_STRING5                     5
#define IDS_STRING6                     6
#define IDS_STRING7                     7
#define IDS_STRING8                     8
#define IDS_STRING9                     9
#define IDS_STRING10                    10
#define IDS_STRING11                    11
#define IDS_STRING1006                  1006
#define IDS_STRING1007                  1007
#define IDS_STRING1008                  1008
#define IDS_STRING1009                  1009
#define IDS_STRING1010                  1010
#define IDS_STRING1011                  1011
#define IDS_STRING1012                  1012
#define IDS_STRING1013                  1013
#define IDS_STRING1014                  1014
#define IDS_STRING1015                  1015
#define IDS_STRING1016                  1016
#define IDS_STRING1017                  1017
#define IDS_STRING4002                  4002
#define IDS_STRING4003                  4003
#define IDS_STRING4004                  4004
#define IDS_STRING4005                  4005
#define IDS_STRING4006                  4006
#define IDS_STRING4007                  4007
#define IDS_STRING4008                  4008
#define IDS_STRING4009                  4009
#define IDS_STRING4010                  4010

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\client\shortlist.cpp ===
// 
// MODULE: ShortList.cpp
//
// PURPOSE: A list of all of the handles that are currently open.
//			There is an instance of a COM interface for every open handle.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#include <windows.h>
#include <windowsx.h>
#include <winnt.h>
#include <ole2.h>
#include "ShortList.h"

CShortList::CShortList()
{
	m_pFirst = NULL;
	m_pLast = NULL;
	return;
}

CShortList::~CShortList()
{
	RemoveAll();
	return;
}
// Removes all of the items from the queue.  Releases all of the interfaces.  Deletes all of the items.
void CShortList::RemoveAll()
{
	CShortListItem *pDelItem;
	while (NULL != m_pFirst)
	{
		pDelItem = m_pFirst;
		m_pFirst = m_pFirst->m_pNext;
		pDelItem->m_pInterface->Release();
		delete pDelItem;
	}
	m_pFirst = NULL;
	m_pLast = NULL;
	return;
}
// Add:  Returns false only if there is no memory left.
bool CShortList::Add(HANDLE hItem, IUnknown *pInterface)
{
	bool bHaveMemory = true;
	CShortListItem *pItem = new CShortListItem;
	if (NULL == pItem)
	{
		bHaveMemory = false;
	}
	else
	{
		pItem->m_hSelf = hItem;
		pItem->m_pInterface = pInterface;
		if (NULL == m_pFirst)
		{
			m_pFirst = pItem;
			m_pLast = pItem;
		}
		else
		{	// Add the item to the end of the list.
			m_pLast->m_pNext = pItem;
			m_pLast = pItem;
		}
	}
	return bHaveMemory;
}
// Remove:  Removes the item from the queue, frees the item's memory and releases the interface.
// Returns false if the hItem is not found.
bool CShortList::Remove(HANDLE hItem)
{
	CShortListItem *pPrevious;
	CShortListItem *pItem;
	bool bItemFound = true;
	if (NULL == m_pFirst)
		return false;
	// Case 1 item.
	if (m_pLast == m_pFirst)
	{
		if (m_pFirst->m_hSelf == hItem)
		{
			m_pLast->m_pInterface->Release();
			delete m_pLast;
			m_pFirst = NULL;
			m_pLast = NULL;
		}
		else
		{
			bItemFound = false;
		}
	} // Case 2 items.
	else if (m_pFirst->m_pNext == m_pLast)
	{
		if (hItem == m_pFirst->m_hSelf)
		{
			m_pFirst->m_pInterface->Release();
			delete m_pFirst;
			m_pFirst = m_pLast;
		}
		else if (hItem == m_pLast->m_hSelf)
		{
			m_pLast->m_pInterface->Release();
			delete m_pLast;
			m_pLast = m_pFirst;
		}
		else
		{
			bItemFound = false;
		}
	} // Case 3 or more items.
	else if (NULL != m_pFirst)
	{	
		// Case First item in the list.
		if (hItem == m_pFirst->m_hSelf)
		{
			pItem = m_pFirst;
			m_pFirst = m_pFirst->m_pNext;
			pItem->m_pInterface->Release();
			delete pItem;
		}
		else
		{	// Look for the item in the list.
			pItem = m_pFirst;
			bItemFound = false;
			do
			{
				pPrevious = pItem;
				pItem = pItem->m_pNext;
				if (hItem == pItem->m_hSelf)
				{
					bItemFound = true;
					// Case last item.
					if (pItem == m_pLast)
					{
						pItem->m_pInterface->Release();
						delete pItem;
						m_pLast = pPrevious;
						m_pLast->m_pNext = NULL;
					}
					else
					{	// Some where in the middle.
						CShortListItem *pDelItem = pItem;
						pPrevious->m_pNext = pItem->m_pNext;
						pDelItem->m_pInterface->Release();
						delete pDelItem;
					}
					pItem = NULL;
				}
			} while (NULL != pItem);
		}
	}
	else
	{
		bItemFound = false;
	}
	return bItemFound;
}
// LookUp:  Returns a pointer to the interface or NULL if hItem is not in the list.
IUnknown *CShortList::LookUp(HANDLE hItem)
{
	IUnknown *pIAny = NULL;
	CShortListItem *pItem = m_pFirst;
	while(NULL != pItem)
	{
		if (hItem == pItem->m_hSelf)
		{
			pIAny = pItem->m_pInterface;
			break;
		}
		pItem = pItem->m_pNext;
	}
	return pIAny;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\client\properties.cpp ===
// 
// MODULE: Properties.cpp
//
// PURPOSE: State variables that are changed here are not
//			reset when TSLReInit is used.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#include <windows.h>
#include <windowsx.h>
#include <winnt.h>

#include "TSLError.h"
#include "LaunchServ.h"

#include <comdef.h>
#include "Properties.h"


DWORD MachineID(ITShootATL *pITShootATL, _bstr_t &bstrMachineID)
{
	HRESULT hRes;
	DWORD dwResult = TSL_ERROR_GENERAL;
	hRes = pITShootATL->MachineID(bstrMachineID, &dwResult);
	if (TSL_SERV_FAILED(hRes))
		dwResult = TSL_ERROR_OBJECT_GONE;
	return dwResult;
}

DWORD DeviceInstanceID(ITShootATL *pITShootATL, _bstr_t &bstrDeviceInstanceID)
{
	HRESULT hRes;
	DWORD dwResult = TSL_ERROR_GENERAL;
	hRes = pITShootATL->DeviceInstanceID(bstrDeviceInstanceID, &dwResult);
	if (TSL_SERV_FAILED(hRes))
		dwResult = TSL_ERROR_OBJECT_GONE;
	return dwResult;
}

DWORD PreferOnline(ITShootATL *pITShootATL, BOOL bPreferOnline)
{
	HRESULT hRes;
	DWORD dwResult = TSL_OK;
	hRes = pITShootATL->put_PreferOnline(bPreferOnline);
	if (TSL_SERV_FAILED(hRes))
		dwResult = TSL_ERROR_OBJECT_GONE;
	return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\client\shortlist.h ===
// 
// MODULE: ShortList.h
//
// PURPOSE: A list of all of the handles that are currently open.
//			There is an instance of a COM interface for every open handle.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

// Smart Struct
class CShortListItem
{
public:
	CShortListItem() {	m_hSelf = NULL; m_pInterface = NULL; 
						m_pNext = NULL; 
						return;};

	HANDLE m_hSelf;				// The items in the queue are indexed by the handle.
	IUnknown *m_pInterface;		// For now the ITShootATL interface pointers are the only thing TSLaunch needs to keep.
	CShortListItem *m_pNext;	// Points to the next item in the list.
};

class CShortList
{
public:
	CShortList();
	~CShortList();	// Frees the memory used by all of the items in the list and releases the interfaces.

	bool Add(HANDLE hItem, IUnknown *pInterface);	// Returns false only if there is no memory left.
												// and the new function did not throw an exception.
	bool Remove(HANDLE hItem);	// Removes the item from the queue frees the items memory and releases the interface.
	void RemoveAll();		// Removes all of the items from the queue.  Releases all of the interfaces.  Deletes all of the items.
	IUnknown *LookUp(HANDLE hItem);	// Returns a pointer to the interface or NULL if hItem is not in the list.

protected:

	CShortListItem *m_pFirst;
	CShortListItem *m_pLast;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\client\properties.h ===
// 
// MODULE: Properties.cpp
//
// PURPOSE: State variables that are changed here are not
//			reset when TSLReInit is used.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

DWORD MachineID(ITShootATL *pITShootATL, _bstr_t &bstrMachineID);

DWORD DeviceInstanceID(ITShootATL *pITShootATL, _bstr_t &bstrDeviceInstanceID);

DWORD PreferOnline(ITShootATL *pITShootATL, BOOL bPreferOnline);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\client\tslerror.h ===
// 
// MODULE: tslerror.h
//
// PURPOSE: Warning and error codes for the TSLauncher.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHORS: Joe Mabel and Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#define TSL_OK 0
#define TSL_ERROR_BAD_HANDLE            1	// Handle hTSL passed into function is bad.
#define TSL_ERROR_OUT_OF_MEMORY         2	// Out-of-memory detected
#define TSL_ERROR_OBJECT_GONE			3	// The LaunchServ returned a negative HRESULT.
#define TSL_ERROR_GENERAL               4	// Can't launch a troubleshooter.  There are 
											//	error statuses to be accessed by TSLStatus.
#define TSL_ERROR_NO_NETWORK            5	// Can't identify an appropriate troubleshooting 
											//	network.
#define TSL_ERROR_ILLFORMED_MACHINE_ID  6	// Machine ID is not correctly formed.  Sniffing 
											//	disabled.
#define TSL_ERROR_BAD_MACHINE_ID        7	// A machine ID was specified but can't be used.  
											//	Sniffing disabled.
#define TSL_ERROR_ILLFORMED_DEVINST_ID  8	// Device Instance ID is not correctly formed.
											//	Sniffing disabled.
#define TSL_ERROR_BAD_DEVINST_ID        9	// Device Instance ID was specified but can't be 
											//	used.  Sniffing disabled.
#define TSL_ERROR_UNKNOWN_APP		   10	// An unrecognized application was specified.
#define TSL_ERROR_UNKNOWN_VER		   11	// Unrecognized version (no such version 
											//	associated with application)
#define TSL_ERROR_ASSERTION	           13   // An assertion failed

// The next several errors could be thought of as "hard failures of mapping", but we do not 
//	treat them as hard errors because even if mapping fails totally, we may still be able to
//	launch to a generic troubleshooter.
#define TSL_ERROR_MAP_BAD_SEEK			101	 // failure while seeking in the mapping file.
// Although, at a low level, a bad seek just indicates seeking to an inappropriate file 
//	offset, in practice a bad seek would indicate a serious problem either in the mapping file 
//	or in the code: we should only be seeking to offsets which the contents of the mapping file
//	told us to seek to.
#define TSL_ERROR_MAP_BAD_READ			102	 // failure while reading from the mapping file.
// Although, at a low level, a bad read just indicates (for example) reading past EOF, in 
//	practice a bad read would indicate a serious problem either in the mapping file or in 
//	the code: we should only be reading (1) the header or (2) records which the contents of 
//	the mapping file told us to read.
#define TSL_ERROR_MAP_CANT_OPEN_MAP_FILE 103
#define TSL_ERROR_MAP_BAD_HEAD_MAP_FILE	 104	// failed to read even the header of the map file

// The next several errors should never be seen by applications.  They would mean that the
//	launch server is mis-using the mapping code.
#define TSM_STAT_NEED_VER_TO_SET_DEF_VER 111	// Trying to apply a version default, but you
												//	haven't yet successfully set a version
												//	as a basis to look up the default
#define TSM_STAT_NEED_APP_TO_SET_VER	112		// tried to look up version without previously
												// setting application
#define TSM_STAT_UID_NOT_FOUND			113		// a string could not be mapped to a UID.
												// In the existing TSMapClient class, 
												// this means that the name could not be found
												// in the region of the mapping file where 
												// it belongs (e.g. that a version string is
												// not in the list of versions for the
												// current application.)
												// This should always be turned into something
												// more specific before it is passed to
												// higher-level code.

#define TSL_MIN_WARNING 1000
#define TSL_WARNING_NO_PROBLEM_NODE  1004	// Can't identify an appropriate problem node.  
											//	Troubleshooting will proceed from "first page" 
											//	for this troubleshooting network.
#define TSL_WARNING_NO_NODE          1005	// A state value was specified for a nonexistent 
											//	node 
#define TSL_WARNING_NO_STATE         1006	// A non-existent state value was specified for an 
											//	otherwise valid node.
#define TSL_WARNING_LANGUAGE         1007	// Can't apply specified language to this 
											//	particular problem (no language-appropriate 
											//	troubleshooting network).  Successively default 
											//	to standard language of this machine and to 
											//	English.
#define TSL_WARNING_NO_ONLINE        1008	// Can't obey stated preference for Online 
											//	Troubleshooter
#define TSL_WARNING_ONLINE_ONLY      1009	// Can't obey stated preference against Online 
											//	Troubleshooter
#define TSL_WARNING_GENERAL          1010	// Can launch a troubleshooter, but there are 
											//	warnings to be accessed by TSLStatus.

#define TSL_WARNING_ILLFORMED_DEV_ID 1011	// Device ID is not correctly formed.
#define TSL_WARNING_BAD_DEV_ID       1012	// A correctly formed but invalid device ID
#define TSL_WARNING_ILLFORMED_CLASS_GUID 1013	// Device Class GUID is not correctly formed.
#define TSL_WARNING_BAD_CLASS_GUID       1014	// A correctly formed but invalid device Class GUID
#define TSL_WARNING_UNKNOWN_APPPROBLEM	 1015	// App problem passed in, but this problem 
											//	name is nowhere in the mapping file.
											//	Troubleshooting will proceed on the basis of
											//	device information, ignoring specified problem
#define TSL_WARNING_UNUSED_APPPROBLEM	 1016	// App problem passed in, and the name is
											//	recognized but can't be used in conjunction
											//	with the device information given.
											//	Troubleshooting will proceed on the basis of
											//	device information, ignoring specified problem

#define TSL_W_CONTAINER_WAIT_TIMED_OUT	1017	// The container did not respond within the time 
												//	out value specified in the go method.
#define TSL_WARNING_END_OF_VER_CHAIN	1018	// Should never be seen by the calling app.
											// Indicates that we are at the end of the chain
											// in applying default versions.

#define TSL_MAX_WARNING 1999

// the range 2000-2099 is reserved for internal use by the mapping code.
// statuses in this range should not ever be exposed outside of class TSMapRuntimeAbstract 
// and its subclasses.
#define TSL_MIN_RESERVED_FOR_MAPPING 2000
#define TSL_MAX_RESERVED_FOR_MAPPING 2099

// Errors generated by LaunchServ.  Need to start @ 4,000 to avoid confusion with
// codes returned by the local troubleshooter.
#define TSL_E_CONTAINER_REG		4000	// Could not find the path to hh.exe / iexplore.exe in the registry.
#define TSL_E_CONTAINER_NF		4001	// Found the path to the browser, but it is not at that location.
#define TSL_E_WEB_PAGE_REG		4002	// Could not find the path to the web page in the registry.
#define TSL_E_WEB_PAGE_NF		4003	// Found the path to the web page, but it is not at that location.
#define TSL_E_CREATE_PROC		4004	// Could not create the hh.exe / iexplore.exe process.
#define TSL_E_MEM_EXCESSIVE		4005	// An unexpected amount of memory is required.  i.e. a path name that is longer than MAX_PATH.
#define TSL_E_MAPPING_DB_REG	4006	// Could not find the path to the binary mapping file in the registry.
#define TSL_E_MAPPING_DB_NF		4007	// Found the path to the mapping file, but it is not at that location.
#define TSL_E_NETWORK_REG		4008	// Could not find the path to the network resources (DSZ files).
#define TSL_E_NETWORK_NF		4009	// Could not find a DSC or DSZ file with the network name.
#define TSL_E_NODE_EMP			4010	// A call to set node had a null node name or node state.
#define TSL_E_NO_DEFAULT_NET	4011	// The mapping class failed to get a network and there is not a default network defined in the registry.
#define TSL_E_SNIFF_SCRIPT_REG	4012	// Could not find the path to the sniff script in the registry.
#define TSL_E_COPY_SNIFF_SCRIPT	4013	// Could not create the hh.exe / iexplore.exe process.


inline bool TSLIsHardError(DWORD dwStatus)
{
	return (dwStatus == TSL_ERROR_BAD_HANDLE 
		|| dwStatus == TSL_ERROR_OUT_OF_MEMORY 
		|| dwStatus == TSL_ERROR_OBJECT_GONE);
}

inline bool TSLIsError(DWORD dwStatus) 
{
	return (TSL_OK != dwStatus && dwStatus < TSL_MIN_WARNING || dwStatus > TSL_MAX_WARNING);
}

inline bool TSLIsWarning(DWORD dwStatus) 
{
	return (dwStatus >= TSL_MIN_WARNING && dwStatus <= TSL_MAX_WARNING);
}

#define TSL_E_FAIL		-1
#define TSL_SERV_FAILED(hRes) (FAILED(hRes) && TSL_E_FAIL != hRes)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\client\tsmfc.h ===
// 
// MODULE: tsmfc.cpp
//
// PURPOSE: Imitate the MFC string resource functions that are not available 
//			in Win32 programs.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

int AfxLoadStringA(UINT nID, LPSTR lpszBuf, UINT nMaxBuf);
int AfxLoadStringW(UINT nID, LPWSTR lpszBuf, UINT nMaxBuf);

HINSTANCE AfxGetResourceHandle();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\client\tslauncher.cpp ===
// 
// MODULE: TSLaunchDLL.cpp
//
// PURPOSE: The functions that are exported by TSLauncher.dll.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHORS: Joe Mabel and Richard Meadows
// COMMENTS BY: Joe Mabel
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#include <windows.h>
#include <windowsx.h>
#include <winnt.h>
#include <ole2.h>
#include "TSLError.h"
#define __TSLAUNCHER	    1
#include <TSLauncher.h>
#include "ShortList.h"

#include "LaunchServ_i.c"
#include "LaunchServ.h"

#include <comdef.h>
#include "Properties.h"
#include "Launchers.h"

#include <objbase.h>

static int g_NextHandle = 1;
static CShortList g_unkList;
HINSTANCE g_hInst;

BOOL APIENTRY DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
	switch(fdwReason)
	{
	case DLL_PROCESS_ATTACH:
		g_hInst = hinstDLL;
		break;
	case DLL_PROCESS_DETACH :
	case DLL_THREAD_DETACH :
//		g_unkList.RemoveAll();		This causes an access violation if the list is not already empty.
		// Saltmine Creative should not be providing a library that uses a com object.
		// Saltmine Creative should be providing com objects and not this legacy dll.
		break;
	}
	return TRUE;
}

/* TSLOpen
	Returns a handle that should be passed into subsequent Troubleshooter Launcher calls 
	as hTSL.  Returns NULL handle on failure.  (Should only fail on out of memory, 
	probably will never arise.)
*/
HANDLE WINAPI TSLOpen()
{
	HRESULT hRes;
	CLSID clsidLaunchTS = CLSID_TShootATL;
	IID iidLaunchTS = IID_ITShootATL;
	HANDLE hResult = (HANDLE) g_NextHandle;
	ITShootATL *pITShootATL = NULL;
	hRes = CoCreateInstance(clsidLaunchTS, NULL, 
				CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER | CLSCTX_INPROC_SERVER, 
					iidLaunchTS, (void **) &pITShootATL);
	if (FAILED(hRes))
	{
		hResult = NULL;
	}
	else
	{
		if (g_unkList.Add(hResult, pITShootATL))
			g_NextHandle++;
		else
			hResult = NULL;
	}
	return hResult;
}

/* TSLClose
	Closes handle.  Returns TSL_OK (== 0) if handle was open, otherwise TSL_ERROR_BAD_HANDLE.
*/
DWORD WINAPI TSLClose (HANDLE hTSL)
{
	DWORD dwResult = TSL_OK;
	if (!g_unkList.Remove(hTSL))
		dwResult = TSL_ERROR_BAD_HANDLE;
	return dwResult;
}

/* TSLReInit
	Reinitializes handle.  Functionally the same as a TSLClose followed by TSLOpen, but more
	efficient.  Returns same handle as passed in, if handle was OK, otherwise NULL.
*/
HANDLE WINAPI TSLReInit (HANDLE hTSL)
{
	HRESULT hRes;
	HANDLE hResult = NULL;

	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{
		hRes = pITShootATL->ReInit();
		if (!FAILED(hRes))
			hResult = hTSL;
	}
	return hResult;
}

/* TSLLaunchKnownTS
	Launches to a known troubleshooting belief network and (optionally) problem node. 
	If you know the particular troubleshooting network and problem, use this call.  
	If setting network but not problem, pass in a NULL for szProblemNode.

	Also allows setting arbitrary nodes.  
	nNode gives the number of nodes to set. pszNode, pVal are 
	arrays (dimension nNode) of symbolic node names and corresponding values. 

   Returns one of:
	TSL_OK 
	TSL_ERROR_BAD_HANDLE
	TSL_ERROR_OUT_OF_MEMORY
	TSL_ERROR_GENERAL			launch failed, call TSLStatus
	TSL_WARNING_GENERAL			launch succeded, call TSLStatus for warnings
*/
DWORD WINAPI TSLLaunchKnownTSA(HANDLE hTSL, const char * szNet, 
		const char * szProblemNode, DWORD nNode, const char ** pszNode, DWORD* pVal)
{
	DWORD dwResult = TSL_ERROR_BAD_HANDLE;
	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{
		dwResult = LaunchKnownTSA(pITShootATL, szNet, szProblemNode, nNode, pszNode, pVal);
	}
	return dwResult;
}

DWORD WINAPI TSLLaunchKnownTSW(HANDLE hTSL, const wchar_t * szNet, 
		const wchar_t * szProblemNode, DWORD nNode, const wchar_t ** pszNode, DWORD* pVal)
{
	DWORD dwResult = TSL_ERROR_BAD_HANDLE;
	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{
		dwResult = LaunchKnownTSW(pITShootATL, szNet, szProblemNode, nNode, pszNode, pVal);
	}
	return dwResult;
}
/* TSLLaunch
	Launches to a troubleshooting belief network and (optionally) problem node based
	on application, version, and problem.
	If bLaunch is true, this just queries the mapping, but does not launch.
   Returns one of:
	TSL_OK 
	TSL_ERROR_BAD_HANDLE
	TSL_ERROR_OUT_OF_MEMORY
	TSL_ERROR_GENERAL			launch/query failed, call TSLStatus
	TSL_WARNING_GENERAL			launch/query succeeded, call TSLStatus for warnings
*/
DWORD WINAPI TSLLaunchA(HANDLE hTSL, const char * szCallerName, 
				const char * szCallerVersion, const char * szAppProblem, bool bLaunch)
{
	DWORD dwResult = TSL_ERROR_BAD_HANDLE;
	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{
		_bstr_t bstrCallerName(szCallerName);
		_bstr_t bstrCallerVersion(szCallerVersion);
		_bstr_t bstrAppProblem(szAppProblem);
		dwResult = Launch(pITShootATL, bstrCallerName, bstrCallerVersion, bstrAppProblem, bLaunch);
	}
	return dwResult;
}

DWORD WINAPI TSLLaunchW(HANDLE hTSL, const wchar_t * szCallerName, 
				const wchar_t * szCallerVersion, const wchar_t * szAppProblem, bool bLaunch)
{
	DWORD dwResult = TSL_ERROR_BAD_HANDLE;
	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{
		_bstr_t bstrCallerName(szCallerName);
		_bstr_t bstrCallerVersion(szCallerVersion);
		_bstr_t bstrAppProblem(szAppProblem);
		dwResult = Launch(pITShootATL, bstrCallerName, bstrCallerVersion, bstrAppProblem, bLaunch);
	}
	return dwResult;
}

/* TSLLaunchDevice
	Launches to a troubleshooting belief network and (optionally) problem node based
	on application, version, Plug & Play Device ID, Device Class GUID, and problem.
	If bLaunch is true, this just queries the mapping, but does not launch.
   Returns one of:
	TSL_OK 
	TSL_ERROR_BAD_HANDLE
	TSL_ERROR_OUT_OF_MEMORY
	TSL_ERROR_GENERAL			launch/query failed, call TSLStatus
	TSL_WARNING_GENERAL			launch/query succeded, call TSLStatus for warnings
*/
DWORD WINAPI TSLLaunchDeviceA(HANDLE hTSL, const char * szCallerName, 
				const char * szCallerVersion, const char * szPNPDeviceID, 
				const char * szDeviceClassGUID, const char * szAppProblem, bool bLaunch)
{
	DWORD dwResult = TSL_ERROR_BAD_HANDLE;
	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{
		_bstr_t bstrCallerName(szCallerName);
		_bstr_t bstrCallerVersion(szCallerVersion);
		_bstr_t bstrPNPDeviceID(szPNPDeviceID);
		_bstr_t bstrDeviceClassGUID(szDeviceClassGUID);
		_bstr_t bstrAppProblem(szAppProblem);

		dwResult = LaunchDevice(pITShootATL, bstrCallerName, bstrCallerVersion, 
								bstrPNPDeviceID, bstrDeviceClassGUID, 
								bstrAppProblem, bLaunch);
	}
	return dwResult;
}

DWORD WINAPI TSLLaunchDeviceW(HANDLE hTSL, const wchar_t * szCallerName, 
				const wchar_t * szCallerVersion, const wchar_t * szPNPDeviceID, 
				const wchar_t * szDeviceClassGUID, const wchar_t * szAppProblem, bool bLaunch) 
{
	DWORD dwResult = TSL_ERROR_BAD_HANDLE;
	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{
		_bstr_t bstrCallerName(szCallerName);
		_bstr_t bstrCallerVersion(szCallerVersion);
		_bstr_t bstrPNPDeviceID(szPNPDeviceID);
		_bstr_t bstrDeviceClassGUID(szDeviceClassGUID);
		_bstr_t bstrAppProblem(szAppProblem);

		dwResult = LaunchDevice(pITShootATL, bstrCallerName, bstrCallerVersion, 
								bstrPNPDeviceID, bstrDeviceClassGUID, 
								bstrAppProblem, bLaunch);
	}
	return dwResult;
}

/* Preferences ----------------------------------- */

/* TSLPreferOnline
	Specify a preference for or against online debugger.
   Returns one of:
	TSL_OK 
	TSL_ERROR_BAD_HANDLE
	TSL_ERROR_OUT_OF_MEMORY
*/
DWORD WINAPI TSLPreferOnline(HANDLE hTSL, BOOL bPreferOnline)
{
	DWORD dwResult = TSL_ERROR_BAD_HANDLE;
	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{
		dwResult = PreferOnline(pITShootATL, bPreferOnline);
	}
	return dwResult;
}


/* TSLLanguage 
	Specify language, using Unicode-style 3-letter language ID.  This overrides the system 
	default.
   Returns one of:
	TSL_OK 
	TSL_ERROR_BAD_HANDLE
	TSL_ERROR_OUT_OF_MEMORY
   Cannot return TSL_WARNING_LANGUAGE, because we will not know this till we try combining
	language and troubleshooting network.
*/
DWORD WINAPI TSLLanguageA(HANDLE hTSL, const char * szLanguage)
{
	DWORD dwResult = TSL_ERROR_BAD_HANDLE;
	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{

		dwResult = TSL_OK;
	}
	return dwResult;
}

DWORD WINAPI TSLLanguageW(HANDLE hTSL, const wchar_t * szLanguage)
{
	DWORD dwResult = TSL_ERROR_BAD_HANDLE;
	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{

		dwResult = TSL_OK;
	}
	return dwResult;
}


/* Sniffing ---------------------------- */
/* TSLMachineID
	Necessary to support sniffing on a remote machine.  
   Returns one of:
	TSL_OK 
	TSL_ERROR_BAD_HANDLE
	TSL_ERROR_OUT_OF_MEMORY
	TSL_ERROR_ILLFORMED_MACHINE_ID
	TSL_ERROR_BAD_MACHINE_ID
*/
DWORD WINAPI TSLMachineIDA(HANDLE hTSL, const char* szMachineID)
{
	DWORD dwResult = TSL_ERROR_BAD_HANDLE;
	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{
		_bstr_t bstrMachineID(szMachineID);
		dwResult = MachineID(pITShootATL, bstrMachineID);
	}
	return dwResult;
}

DWORD WINAPI TSLMachineIDW(HANDLE hTSL, const wchar_t* szMachineID)
{
	DWORD dwResult = TSL_ERROR_BAD_HANDLE;
	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{
		_bstr_t bstrMachineID(szMachineID);
		dwResult = MachineID(pITShootATL, bstrMachineID);
	}
	return dwResult;
}

/* TSLDeviceInstanceIDA
	Necessary to support sniffing.  For example, if there are two of the same card on a 
	machine, the Plug & Play ID is of limited use for sniffing.
   Returns one of:
	TSL_OK 
	TSL_ERROR_BAD_HANDLE
	TSL_ERROR_OUT_OF_MEMORY
	TSL_ERROR_ILLFORMED_DEVINST_ID
	TSL_ERROR_BAD_DEVINST_ID
*/
DWORD WINAPI TSLDeviceInstanceIDA(HANDLE hTSL, const char* szDeviceInstanceID)
{
	DWORD dwResult = TSL_ERROR_BAD_HANDLE;
	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{
		_bstr_t bstrDeviceInstanceID(szDeviceInstanceID);
		dwResult = DeviceInstanceID(pITShootATL, bstrDeviceInstanceID);
	}
	return dwResult;
}

DWORD WINAPI TSLDeviceInstanceIDW(HANDLE hTSL, const wchar_t* szDeviceInstanceID)
{
	DWORD dwResult = TSL_ERROR_BAD_HANDLE;
	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{
		_bstr_t bstrDeviceInstanceID(szDeviceInstanceID);
		dwResult = DeviceInstanceID(pITShootATL, bstrDeviceInstanceID);
	}
	return dwResult;
}

/* Status (after launch) ----------------------- */
/* TSLStatus
	After TSLGo (or after an event flag is returned by TSLGoAsynch) can return one status. 
	Repeated calls to this function allow any number of problems to be reported.  
	Should be called in a loop after TSLGo (or after an event flag is returned by TSLGoAsynch), 
	loop until it returns 0.

	Returns TSL_OK if all OK or if all problems are already reported.  nChar indicates size of 
	buffer szBuf in characters.  255 is recommended. if present, szBuf is used to return  
	a detailed error message.  The buffer will always return appropriate text. Typically, 
	it is just a text appropriate to the error/warning return.  In the case of 
	TSL_WARNING_NO_NODE or TSL_WARNING_NO_STATE, this text identifies what node has the 
	problem.  However, that is relevant only if there has been a call to TSLSetNodes.
*/
DWORD WINAPI TSLStatusA (HANDLE hTSL, DWORD nChar, char * szBuf)
{
	HRESULT hRes;
	DWORD dwResult = TSL_ERROR_BAD_HANDLE;
	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{
		dwResult = TSL_OK;
		hRes = pITShootATL->GetStatus(&dwResult);
		if (TSL_SERV_FAILED(hRes))
			return TSL_ERROR_OBJECT_GONE;
		SetStatusA(dwResult, nChar, szBuf);
	}
	return dwResult;
}

DWORD WINAPI TSLStatusW (HANDLE hTSL, DWORD nChar, wchar_t * szBuf)
{
	HRESULT hRes;
	DWORD dwResult = TSL_ERROR_BAD_HANDLE;
	ITShootATL *pITShootATL = (ITShootATL *) g_unkList.LookUp(hTSL);
	if (NULL != pITShootATL)
	{
		dwResult = TSL_OK;
		hRes = pITShootATL->GetStatus(&dwResult);
		if (TSL_SERV_FAILED(hRes))
			return TSL_ERROR_OBJECT_GONE;
		SetStatusW(dwResult, nChar, szBuf);
	}
	return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\client\tsmfc.cpp ===
// 
// MODULE: tsmfc.cpp
//
// PURPOSE: Imitate the MFC string resource functions that are not available 
//			in Win32 programs.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#include <windows.h>
#include "tsmfc.h"

int AfxLoadStringA(UINT nID, LPSTR lpszBuf, UINT nMaxBuf)
{
	LPCSTR lpszName = MAKEINTRESOURCEA((nID>>4)+1);
	HINSTANCE hInst;
	int nLen = 0;
	// Unlike MFC, this function call is guarenteed to work.
	// AfxGetResourceHandle gets the handle that was passed
	// to DllMain().
	hInst = AfxGetResourceHandle();
	if (::FindResourceA(hInst, lpszName, (LPCSTR)RT_STRING) != NULL)
		nLen = ::LoadStringA(hInst, nID, lpszBuf, nMaxBuf);
	return nLen;
}

int AfxLoadStringW(UINT nID, LPWSTR lpszBuf, UINT nMaxBuf)
{
	LPCWSTR lpszName = MAKEINTRESOURCEW((nID>>4)+1);
	HINSTANCE hInst;
	int nLen = 0;
	// Unlike MFC, this function call is guarenteed to work.
	// AfxGetResourceHandle gets the handle that was passed
	// to DllMain().
	hInst = AfxGetResourceHandle();
	if (::FindResourceW(hInst, lpszName, (LPCWSTR)RT_STRING) != NULL)
		nLen = ::LoadStringW(hInst, nID, lpszBuf, nMaxBuf);
	return nLen;
}

HINSTANCE AfxGetResourceHandle()
{
	extern HINSTANCE g_hInst;
	return g_hInst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\server\comglobals.cpp ===
// 
// MODULE: ComGlobals.cpp
//
// PURPOSE: Global functions that are handy to have.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#include "stdafx.h"
#include "ComGlobals.h"

bool BSTRToTCHAR(LPTSTR szChar, BSTR bstr, int CharBufSize)
{
	int x = 0;
	while(x < CharBufSize)
	{
		szChar[x] = (TCHAR) bstr[x];
		if (NULL == szChar[x])
			break;
		x++;
	}
	return x < CharBufSize;
}

bool ReadRegSZ(HKEY hRootKey, LPCTSTR szKey, LPCTSTR szValue, LPTSTR szBuffer, DWORD *pdwBufSize)
{
	HKEY hKey;
	DWORD dwType = REG_SZ;
	DWORD dwBufSize = *pdwBufSize;
	LPTSTR szUnExpanded = new TCHAR[dwBufSize];
	if (NULL == szUnExpanded)
		return false;
	__try
	{
		if(ERROR_SUCCESS != RegOpenKeyEx(hRootKey, szKey, NULL, KEY_READ, &hKey))
			return false;
		if (ERROR_SUCCESS != RegQueryValueEx(hKey, szValue, NULL, &dwType, 
				(PBYTE) szUnExpanded, pdwBufSize))
		{
			RegCloseKey(hKey);
			return false;
		}			
		RegCloseKey(hKey);
		if (REG_EXPAND_SZ == dwType || dwType == REG_SZ)	// NT 5.0 beta bug requires all strings to be expanded.
		{
			DWORD dwBytesUsed;
			dwBytesUsed = ExpandEnvironmentStrings(szUnExpanded, szBuffer, dwBufSize);	// The value returned by ExpandEnviromentStrings is larger than the required size.
			if (0 == dwBytesUsed)
				return false;
			*pdwBufSize = dwBytesUsed;
			if (dwBytesUsed > dwBufSize)
				return false;
		}
		else
		{
			_tcsncpy(szBuffer, szUnExpanded, dwBufSize);
		}
	}
	__finally
	{
		if (NULL != szUnExpanded)
			delete [] szUnExpanded;
	}
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\inc\tslauncher.h ===
// 
// MODULE: TSLaunchDLL.cpp
//
// PURPOSE: The functions that are exported by TSLauncher.dll.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#ifndef _TSLAUNCH_
#define _TSLAUNCH_ 1
 
#ifdef __TSLAUNCHER
#define DLLEXPORT_IMPORT __declspec(dllexport)
#else
#define DLLEXPORT_IMPORT __declspec(dllimport)
#endif


DLLEXPORT_IMPORT BOOL APIENTRY DllMain( HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);

/* TSLOpen
	Returns a handle that should be passed into subsequent Troubleshooter Launcher calls 
	as hTSL.  Returns NULL handle on failure.  (Should only fail on out of memory, 
	probably will never arise.)
*/
DLLEXPORT_IMPORT HANDLE WINAPI TSLOpen(void);

/* TSLClose
	Closes handle.  Returns TSL_OK (== 0) if handle was open, otherwise TSL_ERROR_BAD_HANDLE.
*/
DLLEXPORT_IMPORT DWORD WINAPI TSLClose (HANDLE hTSL);


/* TSLReInit
	Reinitializes handle.  Functionally the same as a TSLClose followed by TSLOpen, but more
	efficient.  Returns same handle as passed in, if handle was OK, otherwise NULL.
*/
DLLEXPORT_IMPORT HANDLE WINAPI TSLReInit (HANDLE hTSL);

/* TSLLaunchKnownTS
	Launches to a known troubleshooting belief network and (optionally) problem node. 
	If you know the particular troubleshooting network and problem, use this call.  
	If setting network but not problem, pass in a NULL for szProblemNode.

	Also allows setting arbitrary nodes.  
	nNode gives the number of nodes to set. pszNode, pVal are 
	arrays (dimension nNode) of symbolic node names and corresponding values. 

   Returns one of:
	TSL_OK 
	TSL_ERROR_BAD_HANDLE
	TSL_ERROR_OUT_OF_MEMORY
	TSL_ERROR_GENERAL			launch failed, call TSLStatus
	TSL_WARNING_GENERAL			launch succeded, call TSLStatus for warnings
*/
DLLEXPORT_IMPORT DWORD WINAPI TSLLaunchKnownTSA(HANDLE hTSL, const char * szNet, 
		const char * szProblemNode, DWORD nNode, const char ** pszNode, DWORD* pVal); 
DLLEXPORT_IMPORT DWORD WINAPI TSLLaunchKnownTSW(HANDLE hTSL, const wchar_t * szNet, 
		const wchar_t * szProblemNode, DWORD nNode, const wchar_t ** pszNode, DWORD* pVal); 
#ifdef UNICODE
	#define TSLLaunchKnownTS TSLLaunchKnownTSW
#else
	#define TSLLaunchKnownTS TSLLaunchKnownTSA
#endif

/* TSLLaunch
	Launches to a troubleshooting belief network and (optionally) problem node based
	on application, version, and problem.
	If bLaunch is true, this just queries the mapping, but does not launch.
   Returns one of:
	TSL_OK 
	TSL_ERROR_BAD_HANDLE
	TSL_ERROR_OUT_OF_MEMORY
	TSL_ERROR_GENERAL			launch/query failed, call TSLStatus
	TSL_WARNING_GENERAL			launch/query succeded, call TSLStatus for warnings
*/
DLLEXPORT_IMPORT DWORD WINAPI TSLLaunchA(HANDLE hTSL, const char * szCallerName, 
				const char * szCallerVersion, const char * szAppProblem, bool bLaunch); 
DLLEXPORT_IMPORT DWORD WINAPI TSLLaunchW(HANDLE hTSL, const wchar_t * szCallerName, 
				const wchar_t * szCallerVersion, const wchar_t * szAppProblem, bool bLaunch); 
#ifdef UNICODE
	#define TSLLaunch TSLLaunchW
#else
	#define TSLLaunch TSLLaunchA
#endif

/* TSLLaunchDevice
	Launches to a troubleshooting belief network and (optionally) problem node based
	on application, version, Plug & Play Device ID, Device Class GUID, and problem.
	If bLaunch is true, this just queries the mapping, but does not launch.
   Returns one of:
	TSL_OK 
	TSL_ERROR_BAD_HANDLE
	TSL_ERROR_OUT_OF_MEMORY
	TSL_ERROR_GENERAL			launch/query failed, call TSLStatus
	TSL_WARNING_GENERAL			launch/query succeded, call TSLStatus for warnings
*/
DLLEXPORT_IMPORT DWORD WINAPI TSLLaunchDeviceA(HANDLE hTSL, const char * szCallerName, 
				const char * szCallerVersion, const char * szPNPDeviceID, 
				const char * szDeviceClassGUID, const char * szAppProblem, bool bLaunch);
DLLEXPORT_IMPORT DWORD WINAPI TSLLaunchDeviceW(HANDLE hTSL, const wchar_t * szCallerName, 
				const wchar_t * szCallerVersion, const wchar_t * szPNPDeviceID, 
				const wchar_t * szDeviceClassGUID, const wchar_t * szAppProblem, bool bLaunch); 
#ifdef UNICODE
	#define TSLLaunchDevice TSLLaunchDeviceW
#else
	#define TSLLaunchDevice TSLLaunchDeviceA
#endif

				
/* Preferences ----------------------------------- */

/* TSLPreferOnline
	Specify a preference for or against online debugger.
   Returns one of:
	TSL_OK 
	TSL_ERROR_BAD_HANDLE
	TSL_ERROR_OUT_OF_MEMORY
*/
DLLEXPORT_IMPORT DWORD WINAPI TSLPreferOnline(HANDLE hTSL, BOOL bPreferOnline);

/* TSLLanguage 
	Specify language, using Unicode-style 3-letter language ID.  This overrides the system 
	default.
   Returns one of:
	TSL_OK 
	TSL_ERROR_BAD_HANDLE
	TSL_ERROR_OUT_OF_MEMORY
   Cannot return TSL_WARNING_LANGUAGE, because we will not know this till we try combining
	language and troubleshooting network.
*/
DLLEXPORT_IMPORT DWORD WINAPI TSLLanguageA(HANDLE hTSL, const char * szLanguage);
DLLEXPORT_IMPORT DWORD WINAPI TSLLanguageW(HANDLE hTSL, const wchar_t * szLanguage);
#ifdef UNICODE
	#define TSLLanguage TSLLanguageW
#else
	#define TSLLanguage TSLLanguageA
#endif

/* Sniffing ---------------------------- */
/* TSLMachineID
	Necessary to support sniffing on a remote machine.  
   Returns one of:
	TSL_OK 
	TSL_ERROR_BAD_HANDLE
	TSL_ERROR_OUT_OF_MEMORY
	TSL_ERROR_ILLFORMED_MACHINE_ID
	TSL_ERROR_BAD_MACHINE_ID
*/
DLLEXPORT_IMPORT DWORD WINAPI TSLMachineIDA(HANDLE hTSL, const char* szMachineID);
DLLEXPORT_IMPORT DWORD WINAPI TSLMachineIDW(HANDLE hTSL, const wchar_t* szMachineID);
#ifdef UNICODE
	#define TSLMachineID TSLMachineIDW
#else
	#define TSLMachineID TSLMachineIDA
#endif

/* TSLDeviceInstanceIDA
	Necessary to support sniffing.  For example, if there are two of the same card on a 
	machine, the Plug & Play ID is of limited use for sniffing.
   Returns one of:
	TSL_OK 
	TSL_ERROR_BAD_HANDLE
	TSL_ERROR_OUT_OF_MEMORY
	TSL_ERROR_ILLFORMED_DEVINST_ID
	TSL_ERROR_BAD_DEVINST_ID
*/
DLLEXPORT_IMPORT DWORD WINAPI TSLDeviceInstanceIDA(HANDLE hTSL, 
												   const char* szDeviceInstanceID);
DLLEXPORT_IMPORT DWORD WINAPI TSLDeviceInstanceIDW(HANDLE hTSL, 
												   const wchar_t* szDeviceInstanceID);
#ifdef UNICODE
	#define TSLDeviceInstanceID TSLDeviceInstanceIDW
#else
	#define TSLDeviceInstanceID TSLDeviceInstanceIDA
#endif

/* Status (after launch) ----------------------- */
/* TSLStatus
	After any of the TSLLaunch... functions return TSL_ERROR_GENERAL or TSL_WARNING_GENERAL,
	this function can return one status. 
	Repeated calls to this function allow any number of problems to be reported.  
	Should be called in a loop until it returns 0.

	Returns TSL_OK if all OK or if all problems are already reported.  nChar indicates size of 
	buffer szBuf in characters.  255 is recommended. If present, szBuf is used to return  
	a detailed error message.  The buffer will always return appropriate text. Typically, 
	it is just a text appropriate to the error/warning return.  In the case of 
	TSL_WARNING_NO_NODE or TSL_WARNING_NO_STATE, this text identifies what node has the 
	problem.  However, that is relevant only if there has been a call to TSLSetNodes.
*/
DLLEXPORT_IMPORT DWORD WINAPI TSLStatusA (HANDLE hTSL, DWORD nChar, char * szBuf);
DLLEXPORT_IMPORT DWORD WINAPI TSLStatusW (HANDLE hTSL, DWORD nChar, wchar_t * szBuf);

#ifdef UNICODE
	#define TSLStatus TSLStatusW
#else
	#define TSLStatus TSLStatusA
#endif

#endif _TSLAUNCH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\server\launch.cpp ===
// 
// MODULE: Launch.cpp
//
// PURPOSE: Starts the container that will query the LaunchServ for 
//			troubleshooter network and nodes.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#include "stdafx.h"
#include "StateInfo.h"

#include "RSSTACK.H"

#include "TSMapAbstract.h"
#include "TSMap.h"
#include "TSMapClient.h"

#include "Launch.h"
#include "ComGlobals.h"
#include "TSLError.h"
#include "Registry.h"

#include <rpc.h> 

#define LAUNCH_WAIT_TIMEOUT 60 * 1000   // One minute wait.

#define SZ_WEB_PAGE _T("asklibrary.htm") // name of hardcoded .htm file that contains troubleshooter OCX


// uncomment the following line to turn on Joe's hard-core debugging
//#define JDEBUG 1

#ifdef JDEBUG
#include <stdio.h>
// Convert TCHAR *szt to char *sz.  *sz should point to a big enough buffer
//	to contain an SNCS version of *szt.  count indicates the size of buffer *sz.
// returns sz (convenient for use in string functions).
static char* ToSBCS (char * const sz, const TCHAR * szt, size_t count)
{
	if (sz)
	{
		if (count != 0 && !szt)
			sz[0] = '\0';
		else
		{
			#ifdef  _UNICODE
				wcstombs( sz, szt, count );
			#else
				strcpy(sz, szt);
			#endif
		}
	}
	return sz;
}
#endif


CLaunch::CLaunch()
{
	InitFiles();
	InitRequest();
	m_lLaunchWaitTimeOut = LAUNCH_WAIT_TIMEOUT;
	m_bPreferOnline = false;
}

CLaunch::~CLaunch()
{
	if (m_pMap)
		delete(m_pMap);
}

// This initialization happens exactly once for the object.
// Once we've looked in the registry and found a file, it isn't going anywhere.
void CLaunch::InitFiles()
{
	DWORD dwBufSize;
	CRegKey reg;
	DWORD dwBytesUsed;

	m_bHaveMapPath = false;
	m_bHaveDefMapFile = false;
	m_bHaveDszPath = false;
	m_szLauncherResources[0] = NULL;
	m_szDefMapFile[0] = NULL;
	m_szLaunchMapFile[0] = NULL;
	m_szDszResPath[0] = NULL;
	m_szMapFile[0] = NULL;
	m_pMap = NULL;

	if (ERROR_SUCCESS == reg.Open(
				HKEY_LOCAL_MACHINE, SZ_LAUNCHER_ROOT))
	{
		dwBufSize = MAX_PATH;
		TCHAR szLauncherResources[MAX_PATH];
		if (ERROR_SUCCESS == reg.QueryValue(
			szLauncherResources, SZ_GLOBAL_LAUNCHER_RES, &dwBufSize))
		{
			if ('\\' != szLauncherResources[_tcslen(szLauncherResources) - 1])
				_tcscat(szLauncherResources, _T("\\"));

			dwBufSize = MAX_PATH;
			dwBytesUsed = ExpandEnvironmentStrings(szLauncherResources, m_szLauncherResources, dwBufSize);	// The value returned by ExpandEnviromentStrings is larger than the required size.

		}
		dwBufSize = MAX_PATH;
		TCHAR szDefMapFile[MAX_PATH];
		if (ERROR_SUCCESS == reg.QueryValue(
					szDefMapFile, SZ_GLOBAL_MAP_FILE, &dwBufSize))
		{
			WIN32_FIND_DATA data;
			HANDLE hFind;

			dwBufSize = MAX_PATH;
			dwBytesUsed = ExpandEnvironmentStrings(szDefMapFile, m_szDefMapFile, dwBufSize);	// The value returned by ExpandEnviromentStrings is larger than the required size.
			if (0 != dwBytesUsed)
			{
				m_bHaveMapPath = true;
				_tcscpy(m_szLaunchMapFile, m_szLauncherResources);
				_tcscat(m_szLaunchMapFile, m_szDefMapFile);
				hFind = FindFirstFile(m_szLaunchMapFile, &data);
				if (INVALID_HANDLE_VALUE != hFind)
				{
					m_bHaveDefMapFile = true;
					FindClose(hFind);
				}
				else
				{
					m_bHaveDefMapFile = false;
				}
			}
		}
		reg.Close();
	}
	// Need the TShoot.ocx resource path to verify that the networks exist.
	if (ERROR_SUCCESS == reg.Open(HKEY_LOCAL_MACHINE, SZ_TSHOOT_ROOT))
	{
		dwBufSize = MAX_PATH;
		TCHAR szDszResPath[MAX_PATH];
		if (ERROR_SUCCESS == reg.QueryValue(szDszResPath, SZ_TSHOOT_RES, &dwBufSize))
		{
			if ('\\' != szDszResPath[_tcslen(szDszResPath) - 1])
				_tcscat(szDszResPath, _T("\\"));
			
			dwBufSize = MAX_PATH;
			dwBytesUsed = ExpandEnvironmentStrings(szDszResPath, m_szDszResPath, dwBufSize);	// The value returned by ExpandEnviromentStrings is larger than the required size.
			if (0 == dwBytesUsed)
				m_bHaveDszPath = false;
			else
				m_bHaveDszPath = true;
		}
		reg.Close();
	}

	return;
}

// This initialization can happen more than once for the object.
// If we are going to use the same object to make a second request, there are things we
//	want to clean up.
void CLaunch::InitRequest()
{
	m_szAppName[0] = NULL;
	m_szAppVersion[0] = NULL;
	m_szAppProblem[0] = NULL;
	m_stkStatus.RemoveAll();
	m_Item.ReInit();
}

// >>> Why does this exist distinct from InitRequest()?
void CLaunch::ReInit()
{
	InitRequest();	
	return;
}

// >>> What exactly is the use of this? What is the distinction from InitRequest()?
void CLaunch::Clear()
{
	m_szAppName[0] = NULL;
	m_szAppVersion[0] = NULL;
	m_szAppProblem[0] = NULL;
	m_stkStatus.RemoveAll();
	m_Item.Clear();
	return;
}

// Verify that a given troubleshooting belief network exists.
bool CLaunch::VerifyNetworkExists(LPCTSTR szNetwork)
{
	bool bResult = true;
	if (NULL == szNetwork || NULL == szNetwork[0])
	{
		// Null name, don't even bother with a lookup.		
		m_stkStatus.Push(TSL_E_NETWORK_NF);
		bResult = false;
	}
	else
	{
		if (m_bHaveDszPath)
		{
			WIN32_FIND_DATA data;
			HANDLE hFind;
			TCHAR szDszFile[MAX_PATH];

			_tcscpy(szDszFile, m_szDszResPath);
			_tcscat(szDszFile, szNetwork);
			_tcscat(szDszFile, _T(".ds?"));
			
			hFind = FindFirstFile(szDszFile, &data);
			if (INVALID_HANDLE_VALUE == hFind)
			{
				m_stkStatus.Push(TSL_E_NETWORK_NF);
				bResult = false;
			}
			FindClose(hFind);
		}
		else
		{
			// we don't know what directory to look in.
			m_stkStatus.Push(TSL_E_NETWORK_REG);
			bResult = false;
		}
	}
	return bResult;
}

// Allows explicit specification of the troubleshooting network (and, optionally, 
//	problem node) to launch to.
// This is an alternative to determining network/node via a mapping.
// INPUT szNetwork
// INPUT szProblem: null pointer of null string ==> no problem node
//					any other value is symbolic name of problem node
bool CLaunch::SpecifyProblem(LPCTSTR szNetwork, LPCTSTR szProblem)
{
	bool bResult = true;
	if (!VerifyNetworkExists(szNetwork))	// Sets the network not found error.
	{
		bResult = false;
	}
	else
	{
		m_Item.SetNetwork(szNetwork);

		// Set problem node, if any.  OK if there is none.
		if (NULL != szProblem && NULL != szProblem[0])
			m_Item.SetProblem(szProblem);
	}
	return bResult;
}

// Allows explicit setting of a non-problem node.
// Obviously, node names only acquire meaning in the context of a belief network.
// INPUT szNode: symbolic node name
// INPUT szState: >>> not sure what is intended.  The corresponding value in TSLaunch API is
//	an integer state value.  Is this the decimal representation of that value or what? JM

bool CLaunch::SetNode(LPCTSTR szNode, LPCTSTR szState)
{
	bool bResult = true;
	if (NULL != szNode && NULL != szState)
	{
		m_Item.SetNode(szNode, szState);
	}
	else
	{
		m_stkStatus.Push(TSL_E_NODE_EMP);		
		bResult = false;
	}
	return bResult;
}

// Sets machine ID so that WBEM can sniff on a remote machine.
HRESULT CLaunch::MachineID(BSTR &bstrMachineID, DWORD *pdwResult)
{
	HRESULT hRes = S_OK;
	if (!BSTRToTCHAR(m_Item.m_szMachineID, bstrMachineID, CItem::GUID_LEN))
	{
		*pdwResult = TSL_E_MEM_EXCESSIVE;
		hRes = TSL_E_FAIL;
	}
	return hRes;
}

// Sets Device Instance ID so that WBEM can sniff correct device
HRESULT CLaunch::DeviceInstanceID(BSTR &bstrDeviceInstanceID, DWORD *pdwResult)
{
	HRESULT hRes = S_OK;
	if (!BSTRToTCHAR(m_Item.m_szDeviceInstanceID, bstrDeviceInstanceID, CItem::GUID_LEN))
	{
		*pdwResult = TSL_E_MEM_EXCESSIVE;
		hRes = TSL_E_FAIL;
	}
	return hRes;
}

void CLaunch::SetPreferOnline(short bPreferOnline)
{
	// The next line's ugly, but correct.  bPreferOnline is not necessarily a valid
	//	Boolean; we want to make sure we get a valid Boolean in	m_bPreferOnline.
	m_bPreferOnline = (0 != bPreferOnline);
	return;
}

// CheckMapFile:  Uses szAppName member to set szMapFile.  
// First, check the registry for an application-specific map file.  If we can't find one,
//	check for a default map file.  If that doesn't exist either, fail.
// INPUT szAppName
// OUTPUT szMapFile
bool CLaunch::CheckMapFile(TCHAR * szAppName, TCHAR szMapFile[MAX_PATH], DWORD *pdwResult)
{
	bool bHaveMapFile = false;

	if (NULL == szAppName || NULL == szAppName[0])
	{
		// Application name may not be null.
		m_stkStatus.Push(TSL_ERROR_UNKNOWN_APP);
		*pdwResult = TSL_ERROR_GENERAL;
		return false;
	}
	else
	{
		DWORD dwBufSize;
		CRegKey reg;
		if (ERROR_SUCCESS == reg.Open(HKEY_LOCAL_MACHINE, SZ_LAUNCHER_APP_ROOT))
		{
			dwBufSize = MAX_PATH;
			if (ERROR_SUCCESS == reg.Open(reg.m_hKey, szAppName))
			{
				if (ERROR_SUCCESS == reg.QueryValue(szMapFile, SZ_APPS_MAP_FILE, &dwBufSize))
					return true;
			}
		}
	}

	// Does a default map file exist?
	if (m_bHaveDefMapFile)
	{
		_tcscpy(szMapFile, m_szLaunchMapFile);
	}
	else
	{	// Either the registry setting is missing or the file is not 
		// where the registry says it is.
		if (m_bHaveMapPath)	// Have the registry entry.
			m_stkStatus.Push(TSL_E_MAPPING_DB_NF);
		else
			m_stkStatus.Push(TSL_E_MAPPING_DB_REG);
		*pdwResult = TSL_ERROR_GENERAL;
	}
	return m_bHaveDefMapFile;
}

// Uses the mapping classes to map Caller() and DeviceID() information, then copies the 
//	CItem to global memory.
// >> Why is this called TestPut()?
// Returns false when the mapping fails.
bool CLaunch::TestPut()
{
	extern CSMStateInfo g_StateInfo;
	DWORD dwResult;
	Map(&dwResult);
	if (TSL_OK != dwResult)
		return false;
	g_StateInfo.TestPut(m_Item);	// Copies m_Item to global memory.
	return true;
}

// Perform any necessary mapping, then launch the Local Troubleshooter.
bool CLaunch::Go(DWORD dwTimeOut, DWORD *pdwResult)
{
	DWORD dwRes;
	bool bResult = true;
	extern CSMStateInfo g_StateInfo;
	TCHAR szContainerPathName[MAX_PATH];  szContainerPathName[0] = 0;
	TCHAR szSniffScriptFile[MAX_PATH];    szSniffScriptFile[0] = 0;
	TCHAR szSniffStandardFile[MAX_PATH];  szSniffStandardFile[0] = 0;
	TCHAR szWebPage[MAX_PATH];            szWebPage[0] = 0;
	TCHAR szDefaultNetwork[SYM_LEN];      szDefaultNetwork[0] = 0;
	TCHAR *szCmd = NULL, *szNetwork = NULL;

	if (TSL_OK == (dwRes = GetContainerPathName(szContainerPathName)))
	{
		m_Item.SetContainerPathName(szContainerPathName);
		m_Item.SetSniffScriptFile(szSniffScriptFile);
	}
	else 
	{
		m_stkStatus.Push(dwRes);
		// if container is not found - no reason to continue
		*pdwResult = TSL_ERROR_GENERAL;
		return false;
	}

	if (!m_Item.NetworkSet())	
	{
		if (Map(&dwRes) &&
			TSL_OK == (dwRes = GetWebPage(szWebPage)) // get web page
		   )
		{
			m_Item.SetWebPage(szWebPage);
			// network and problem are set by Map function
			m_Item.SetLaunchRegime(launchMap);
		}
		else
		{
			m_stkStatus.Push(dwRes);
			if (TSL_OK == (dwRes = GetDefaultURL(szWebPage))) // get "DEFAULT PAGE",
												// actually a URL which might (for example)
												// refernce a page compiled into a .CHM file
			{
				m_Item.SetWebPage(szWebPage);
				m_Item.SetNetwork(NULL); // network are set to NULL in this case
				m_Item.SetProblem(NULL); // problem are set to NULL in this case
				m_Item.SetLaunchRegime(launchDefaultWebPage);
			}
			else
			{	
				if (TSL_OK == (dwRes = GetDefaultNetwork(szDefaultNetwork)) && // get default network 
					TSL_OK == (dwRes = GetWebPage(szWebPage)) // get web page
				   )  
				{
					m_Item.SetWebPage(szWebPage);
					m_Item.SetNetwork(szDefaultNetwork);
					m_Item.SetProblem(NULL); // problem is set to NULL in this case
					m_Item.SetLaunchRegime(launchDefaultNetwork);
				}
				else
				{
					// complete failure
					m_stkStatus.Push(dwRes);
					*pdwResult = TSL_ERROR_GENERAL;
					m_Item.SetLaunchRegime(launchIndefinite);
					return false; 
				}
			}
		}
	}							  
	else
	{
		if (TSL_OK == (dwRes = GetWebPage(szWebPage)))
		{
			m_Item.SetWebPage(szWebPage);
			// network is known, problem can be either known(set) or unknown(not set)
			m_Item.SetLaunchRegime(launchKnownNetwork);
		}
		else
		{
			// complete failure
			m_stkStatus.Push(dwRes);
			*pdwResult = TSL_ERROR_GENERAL;
			m_Item.SetLaunchRegime(launchIndefinite);
			return false; 
		}
	}
								  
	// set sniff script and standard file
	m_Item.GetNetwork(&szCmd, &szNetwork);
	if (TSL_OK == (dwRes = GetSniffScriptFile(szSniffScriptFile, szNetwork[0] ? szNetwork : NULL)) &&
		TSL_OK == (dwRes = GetSniffStandardFile(szSniffStandardFile))
	   )
	{
		m_Item.SetSniffScriptFile(szSniffScriptFile);
		m_Item.SetSniffStandardFile(szSniffStandardFile);
	}
	else
	{
		// can not find script file path - failure
		m_stkStatus.Push(dwRes);
		*pdwResult = TSL_ERROR_GENERAL;
		m_Item.SetLaunchRegime(launchIndefinite);
		return false; 
	}
    
	// parse warnings according to the launch regime
	//
	if (launchMap == m_Item.GetLaunchRegime() ||
		launchKnownNetwork == m_Item.GetLaunchRegime()
	   )
	{
		if (!m_Item.ProblemSet())
		{
				m_stkStatus.Push(TSL_WARNING_NO_PROBLEM_NODE);
				*pdwResult = TSL_WARNING_GENERAL;
		}
	}

	// parse launches according to the launch regime
	//
	if (launchMap == m_Item.GetLaunchRegime() ||
		launchDefaultNetwork == m_Item.GetLaunchRegime()
	   )
	{
		if (m_Item.NetworkSet())
		{

#ifdef JDEBUG
			HANDLE hDebugFile;
			char* szStart = "START\n";
			char* szEnd = "END\n";
			DWORD dwBytesWritten;

			hDebugFile = CreateFile(
				_T("jdebug.txt"),  
				GENERIC_WRITE, 
				FILE_SHARE_READ, 
				NULL, 
				CREATE_ALWAYS,
				FILE_ATTRIBUTE_NORMAL,
				NULL);
			WriteFile( 
				hDebugFile, 
				szStart, 
				strlen(szStart),
				&dwBytesWritten,
				NULL);
				
			TCHAR *sztCmd, *sztVal;
			char sz[200], szCmd[100], szVal[100];

			m_Item.GetNetwork(&sztCmd, &sztVal);

			ToSBCS (szCmd, sztCmd, 100);
			ToSBCS (szVal, sztVal, 100);

			sprintf(sz, "%s %s\n", szCmd, szVal);

			WriteFile( 
				hDebugFile, 
				sz, 
				strlen(sz),
				&dwBytesWritten,
				NULL);
				
			if (m_Item.ProblemSet())
			{
				m_Item.GetProblem(&sztCmd, &sztVal);

				ToSBCS (szCmd, sztCmd, 100);
				ToSBCS (szVal, sztVal, 100);

				sprintf(sz, "%s %s\n", szCmd, szVal);

				WriteFile( 
					hDebugFile, 
					sz, 
					strlen(sz),
					&dwBytesWritten,
					NULL);
			}

			WriteFile( 
				hDebugFile, 
				szEnd, 
				strlen(szEnd),
				&dwBytesWritten,
				NULL);
			CloseHandle(hDebugFile);
#endif
			bResult = g_StateInfo.GoGo(dwTimeOut, m_Item, pdwResult);
		}
		else
		{
			*pdwResult = TSL_ERROR_GENERAL;
			m_stkStatus.Push(TSL_ERROR_NO_NETWORK);
			bResult = false;
		}
	}

	if (launchKnownNetwork == m_Item.GetLaunchRegime() )
	{
		bResult = g_StateInfo.GoGo(dwTimeOut, m_Item, pdwResult);
	}

	if (launchDefaultWebPage == m_Item.GetLaunchRegime())
	{
		bResult = g_StateInfo.GoURL(m_Item, pdwResult);

	}	

	return bResult;
}

HRESULT CLaunch::LaunchKnown(DWORD * pdwResult)
{
	HRESULT hRes = S_OK;
	// Launch the shooter.
	if (!Go(m_lLaunchWaitTimeOut, pdwResult))
		hRes = TSL_E_FAIL;
	return hRes;
}

HRESULT CLaunch::Launch(BSTR bstrCallerName, BSTR bstrCallerVersion, 
								BSTR bstrAppProblem, short bLaunch, DWORD * pdwResult)
{
	HRESULT hRes = S_OK;
	Clear();
	if (!BSTRToTCHAR(m_szAppName, bstrCallerName, SYM_LEN))
	{
		*pdwResult = TSL_E_MEM_EXCESSIVE;
		return TSL_E_FAIL;
	}
	if (!BSTRToTCHAR(m_szAppVersion, bstrCallerVersion, SYM_LEN))
	{
		*pdwResult = TSL_E_MEM_EXCESSIVE;
		return TSL_E_FAIL;
	}
	if (!BSTRToTCHAR(m_szAppProblem, bstrAppProblem, SYM_LEN))
	{
		*pdwResult = TSL_E_MEM_EXCESSIVE;
		return TSL_E_FAIL;
	}
	if (bLaunch)
	{
		if (!Go(m_lLaunchWaitTimeOut, pdwResult))
			hRes = TSL_E_FAIL;
	}
	else
	{
		if (!Map(pdwResult))
			hRes = TSL_E_FAIL;
	}
	return hRes;
}

HRESULT CLaunch::LaunchDevice(BSTR bstrCallerName, BSTR bstrCallerVersion, BSTR bstrPNPDeviceID, 
							  BSTR bstrDeviceClassGUID, BSTR bstrAppProblem, short bLaunch, DWORD * pdwResult)
{
	HRESULT hRes;
	Clear();

	if (!BSTRToTCHAR(m_szAppName, bstrCallerName, SYM_LEN))
	{
		*pdwResult = TSL_E_MEM_EXCESSIVE;
		return TSL_E_FAIL;
	}
	if (!BSTRToTCHAR(m_szAppVersion, bstrCallerVersion, SYM_LEN))
	{
		*pdwResult = TSL_E_MEM_EXCESSIVE;
		return TSL_E_FAIL;
	}
	if (!BSTRToTCHAR(m_szAppProblem, bstrAppProblem, SYM_LEN))
	{
		*pdwResult = TSL_E_MEM_EXCESSIVE;
		return TSL_E_FAIL;
	}
	if (!BSTRToTCHAR(m_Item.m_szPNPDeviceID, bstrPNPDeviceID, CItem::GUID_LEN))
	{
		*pdwResult = TSL_E_MEM_EXCESSIVE;
		return TSL_E_FAIL;
	}
	if (!BSTRToTCHAR(m_Item.m_szGuidClass, bstrDeviceClassGUID, CItem::GUID_LEN))
	{
		*pdwResult = TSL_E_MEM_EXCESSIVE;
		return TSL_E_FAIL;
	}
	if (m_Item.m_szGuidClass[0])
	{
		// Device Class GUID is non-null.  Make sure it's a valid GUID.
		GUID guidClass;
#ifdef _UNICODE
		RPC_STATUS rpcstatus = UuidFromString(
			m_Item.m_szGuidClass, &guidClass );
#else
		RPC_STATUS rpcstatus = UuidFromString(
			(unsigned char *) m_Item.m_szGuidClass, &guidClass );
#endif
		if ( rpcstatus == RPC_S_INVALID_STRING_UUID)
		{
			m_stkStatus.Push(TSL_WARNING_ILLFORMED_CLASS_GUID);
		}
	}

	if (bLaunch)
	{
		if (!Go(m_lLaunchWaitTimeOut, pdwResult))
			hRes = TSL_E_FAIL;
	}
	else
	{
		if (!Map(pdwResult))
			hRes = TSL_E_FAIL;
	}
	return hRes;
}

DWORD CLaunch::GetStatus()
{
	DWORD dwStatus = TSL_OK;
	if (!m_stkStatus.Empty())
		dwStatus = m_stkStatus.Pop();
	return dwStatus;
}

// OUTPUT *szPathName = Name of application to launch to (either IE or HTML Help System)
// Returns:
//	TSL_OK - success
//	TSL_E_CONTAINER_REG - failure to find IE (Internet Explorer) in registry
//	TSL_E_CONTAINER_NF - IE isn't where registry says to find it.
int CLaunch::GetContainerPathName(TCHAR szPathName[MAX_PATH])
{
	DWORD dwPathNameLen = MAX_PATH;
	int tslaHaveContainer = TSL_OK;
#ifndef _HH_CHM
	// use IE instead of HTML Help System
	if (!ReadRegSZ(HKEY_LOCAL_MACHINE,
				SZ_CONTAINER_APP_KEY,
				SZ_CONTAINER_APP_VALUE, szPathName, &dwPathNameLen))
	{
		tslaHaveContainer = TSL_E_CONTAINER_REG;
	}
	else
	{	// Need to verify that the container exists.
		WIN32_FIND_DATA data;
		HANDLE hContainer = FindFirstFile(szPathName, &data);
		if (INVALID_HANDLE_VALUE == hContainer)
			tslaHaveContainer = TSL_E_CONTAINER_NF;
		else
			FindClose(hContainer);
	}
#else
	_tcscpy(szPathName, _T("hh.exe"));
#endif
	return tslaHaveContainer;
}

// OUTPUT *szWebPage = Name of web page to launch to 
// We always launch to the same web page.  The information passed in m_Item ditinguishes
//	what will actually show on the screen.
// Path is from registry.  We concatenate on a backslash and SZ_WEB_PAGE (== "asklibrary.htm")
// Returns:
//	TSL_OK - success
//	TSL_E_WEB_PAGE_REG - failure to find web page for this purpose in registry
//	TSL_E_MEM_EXCESSIVE - Web page name longer than we can handle
//	TSL_E_WEB_PAGE_NF - Web page isn't where registry says to find it.
int CLaunch::GetWebPage(TCHAR szWebPage[MAX_PATH])
{
	int tslaHavePage = TSL_OK;
	DWORD dwWebPageLen = MAX_PATH;
	if (!ReadRegSZ(HKEY_LOCAL_MACHINE,
				SZ_LAUNCHER_ROOT,
				SZ_GLOBAL_LAUNCHER_RES, 
				szWebPage, 
				&dwWebPageLen))
	{
		tslaHavePage = TSL_E_WEB_PAGE_REG;
	}
	else
	{
		int Len = _tcslen(szWebPage);
		dwWebPageLen = Len + 1 + _tcslen(SZ_WEB_PAGE); 
		if (dwWebPageLen > MAX_PATH)
		{
			tslaHavePage = TSL_E_MEM_EXCESSIVE;
		}
		else
		{
			if (szWebPage[Len - 1] != '\\')
				_tcscat(szWebPage, _T("\\"));
			_tcscat(szWebPage, SZ_WEB_PAGE);

			WIN32_FIND_DATA data;
			HANDLE hWebPage = FindFirstFile(szWebPage, &data);
			if (INVALID_HANDLE_VALUE == hWebPage)
				tslaHavePage = TSL_E_WEB_PAGE_NF;
			else
				FindClose(hWebPage);
		}
	}
	return tslaHavePage;
}

// OUTPUT *szSniffScriptFile = full path and file name either to "network"_sniff.htm file or null len string if file is not found
//	TSL_OK - success
//	TSL_E_SNIFF_SCRIPT_REG - failure to find file for this purpose in registry
int CLaunch::GetSniffScriptFile(TCHAR szSniffScriptFile[MAX_PATH], TCHAR* szNetwork)
{
	int tslaHavePage = TSL_OK;
	DWORD dwSniffScriptLen = MAX_PATH;
	TCHAR szSniffScriptPath[MAX_PATH] = {0};

	if (ReadRegSZ(HKEY_LOCAL_MACHINE,
			      SZ_TSHOOT_ROOT,
				  SZ_TSHOOT_RES, 
				  szSniffScriptPath, 
				  &dwSniffScriptLen))
	{
		int Len = _tcslen(szSniffScriptPath);

		dwSniffScriptLen = Len + 1 + (szNetwork ? _tcslen(szNetwork) + _tcslen(SZ_SNIFF_SCRIPT_APPENDIX) 
												: 0); 

		if (dwSniffScriptLen > MAX_PATH)
		{
			tslaHavePage = TSL_E_MEM_EXCESSIVE;
		}
		else
		{
			if (szSniffScriptPath[Len - 1] != '\\')
				_tcscat(szSniffScriptPath, _T("\\"));

			if (szNetwork)
			{
				TCHAR tmp[MAX_PATH] = {0};
				_tcscpy(tmp, szSniffScriptPath);
				_tcscat(tmp, szNetwork);
				_tcscat(tmp, SZ_SNIFF_SCRIPT_APPENDIX);

				WIN32_FIND_DATA data;
				HANDLE hSniffScript = FindFirstFile(tmp, &data);

				if (INVALID_HANDLE_VALUE == hSniffScript)
				{
					szSniffScriptFile[0] = 0;
				}
				else
				{
					_tcscpy(szSniffScriptFile, tmp);
					FindClose(hSniffScript);
				}
			}
			else
			{
				szSniffScriptFile[0] = 0;
			}
		}
	}
	else
	{
		tslaHavePage = TSL_E_SNIFF_SCRIPT_REG;
	}

	return tslaHavePage;
}

// OUTPUT *szSniffScriptFile = full path and file name of tssniffAsk.htm file no matter if it exists
//	TSL_OK - success
//	TSL_E_SNIFF_SCRIPT_REG - failure to find file for this purpose in registry
int CLaunch::GetSniffStandardFile(TCHAR szSniffStandardFile[MAX_PATH])
{
	int tslaHavePage = TSL_OK;
	DWORD dwSniffStandardLen = MAX_PATH;
	TCHAR szSniffStandardPath[MAX_PATH] = {0};

	if (ReadRegSZ(HKEY_LOCAL_MACHINE,
			      SZ_LAUNCHER_ROOT,
				  SZ_GLOBAL_LAUNCHER_RES, 
				  szSniffStandardPath, 
				  &dwSniffStandardLen))
	{
		int Len = _tcslen(szSniffStandardPath);

		dwSniffStandardLen = Len + 1 + _tcslen(SZ_SNIFF_SCRIPT_NAME);

		if (dwSniffStandardLen > MAX_PATH)
		{
			tslaHavePage = TSL_E_MEM_EXCESSIVE;
		}
		else
		{
			if (szSniffStandardPath[Len - 1] != '\\')
				_tcscat(szSniffStandardPath, _T("\\"));

			_tcscpy(szSniffStandardFile, szSniffStandardPath);
			_tcscat(szSniffStandardFile, SZ_SNIFF_SCRIPT_NAME);
		}
	}
	else
	{
		tslaHavePage = TSL_E_SNIFF_SCRIPT_REG;
	}

	return tslaHavePage;
}

// OUTPUT *szURL = URL to go to when mapping fails.  We get this from registry.
//	TSL_OK - success
//	TSL_E_WEB_PAGE_REG - failure to find web page for this purpose in registry
int CLaunch::GetDefaultURL(TCHAR szURL[MAX_PATH])
{
	int tslaHaveURL = TSL_OK;
	DWORD dwURLLen = MAX_PATH;
	if (!ReadRegSZ(HKEY_LOCAL_MACHINE,
				SZ_LAUNCHER_ROOT,
				SZ_DEFAULT_PAGE, 
				szURL, 
				&dwURLLen))
	{
		tslaHaveURL = TSL_E_WEB_PAGE_REG;
	}
	return tslaHaveURL;
}

// Returns TSL_OK and default network name in szDefaultNetwork
// if successful
int CLaunch::GetDefaultNetwork(TCHAR szDefaultNetwork[SYM_LEN])
{
	DWORD dwLen = SYM_LEN;

	if (ReadRegSZ(HKEY_LOCAL_MACHINE, SZ_LAUNCHER_ROOT, SZ_DEFAULT_NETWORK,
		     	  szDefaultNetwork, &dwLen))
		if (VerifyNetworkExists(szDefaultNetwork))

			return TSL_OK;

	return TSL_E_NO_DEFAULT_NET;
}

bool CLaunch::Map(DWORD *pdwResult)
{
	bool bOK = true;
	TCHAR szMapFile[MAX_PATH];
	TCHAR szNetwork[SYM_LEN];           szNetwork[0] = NULL;
	TCHAR szTShootProblem[SYM_LEN];     szTShootProblem[0] = NULL;

	bOK = CheckMapFile(m_szAppName, szMapFile, pdwResult);

	// bOK false at this point means either the registry setting is missing or the file 
	//	is not where the registry says it is.  PdwResult has already been set in CheckMapFile.

	if (bOK && _tcscmp(m_szMapFile, szMapFile))
	{
		// The mapping file we desire is _not_ already loaded
		if (m_pMap)
		{
			// we were using a different mapping file.  We have to get rid of it.
			delete m_pMap;
		}
		// else we weren't using a mapping file yet.

		m_pMap = new TSMapClient(szMapFile);
		if (TSL_OK != m_pMap->GetStatus())
		{
			*pdwResult = m_pMap->GetStatus();
			bOK = false;
		}
		else
		{
			// We've successfully init'd m_pMap on the basis of the new map file.
			// Indicate that it's loaded.
			_tcscpy(m_szMapFile, szMapFile);
		}
	}

	if (bOK)
    {
		DWORD dwRes;
		
		// Now perform mapping itself
		//		
		dwRes = m_pMap->FromAppVerDevAndClassToTS(m_szAppName, m_szAppVersion,
				m_Item.m_szPNPDeviceID, m_Item.m_szGuidClass, m_szAppProblem,
				szNetwork, szTShootProblem);

		// As documented for TSMapRuntimeAbstract::FromAppVerDevAndClassToTS(), there are two
		//	return values here which require that we check for further status details: TSL_OK
		//	(which means we found a mapping, but doesn't rule out warnings) and 
		//	TSL_ERROR_NO_NETWORK (which means we didn't find a mapping, and is typically 
		//	accompanied by further clarifications).
		if (TSL_OK == dwRes || TSL_ERROR_NO_NETWORK == dwRes)
		{
			DWORD dwStatus;
			while (0 != (dwStatus = m_pMap->MoreStatus()))
				m_stkStatus.Push(dwStatus);
		}

		if (TSL_OK != dwRes)
			m_stkStatus.Push(dwRes);	// save the precise error status

		if (TSLIsError(dwRes) )
			bOK = false;

		if (bOK)
		{
			// We have a network name.
			bOK = VerifyNetworkExists(szNetwork);
		}

		if (bOK)
		{
			// We have a network name and we've verified that the network exists.
			// Set the item's network and tshoot problem.
			m_Item.SetNetwork(szNetwork);
			m_Item.SetProblem(szTShootProblem);
		}
		else
			*pdwResult = TSL_ERROR_GENERAL;
	} 
	
    return bOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\server\comglobals.h ===
// 
// MODULE: ComGlobals.h
//
// PURPOSE: Global functions that are handy to have.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#ifndef __COMGLOBALS_H_
#define __COMGLOBALS_H_ 1

bool BSTRToTCHAR(LPTSTR szChar, BSTR bstr, int CharBufSize);

bool ReadRegSZ(HKEY hRootKey, LPCTSTR szKey, LPCTSTR szValue, LPTSTR szBuffer, DWORD *pdwBufSize);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\server\launchts.h ===
// 
// MODULE: LaunchTS.h
//
// PURPOSE: The interface that TSHOOT.OCX uses to get network and node information
//			from the LaunchServ.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#ifndef __LAUNCHTS_H_
#define __LAUNCHTS_H_

#include "resource.h"       // main symbols

#include "stdio.h"

/////////////////////////////////////////////////////////////////////////////
// CLaunchTS

class ATL_NO_VTABLE CLaunchTS : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CLaunchTS, &CLSID_LaunchTS>,
	public IObjectWithSiteImpl<CLaunchTS>,
	public IDispatchImpl<ILaunchTS, &IID_ILaunchTS, &LIBID_LAUNCHSERVLib>
{
public:
	CLaunchTS()
	{
		_stprintf(m_szEvent, _T("Event "));
		m_csThreadSafeBr.Init();
	}
	~CLaunchTS()
	{
		m_csThreadSafeBr.Term();
	}

DECLARE_REGISTRY_RESOURCEID(IDR_LAUNCHTS)

BEGIN_COM_MAP(CLaunchTS)
	COM_INTERFACE_ENTRY(ILaunchTS)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY_IMPL(IObjectWithSite)
END_COM_MAP()

	TCHAR m_szEvent[50];
	CItem m_refedLaunchState;		// Used only by the process that is created by the Go method.
	CComCriticalSection m_csThreadSafeBr;
// ILaunchTS
public:
	STDMETHOD(Test)();
	STDMETHOD(GetState)(/*[in]*/ short iNode, /*[out, retval]*/ BSTR *pbstrState);
	STDMETHOD(GetNode)(/*[in]*/ short iNode, /*[out, retval]*/ BSTR *pbstrNode);
	STDMETHOD(GetProblem)(/*[out, retval]*/ BSTR *pbstrProblem);
	STDMETHOD(GetTroubleShooter)(/*[out, retval]*/ BSTR *pbstrShooter);
	STDMETHOD(GetShooterStates)(/*[out, retval]*/ DWORD *pdwResult);
	STDMETHOD(GetMachine)(/*[out, retval]*/ BSTR *pbstrMachine);
	STDMETHOD(GetPNPDevice)(/*[out, retval]*/ BSTR *pbstr);
	STDMETHOD(GetGuidClass)(/*[out, retval]*/ BSTR *pbstr);
	STDMETHOD(GetDeviceInstance)(/*[out, retval]*/ BSTR *pbstr);
};

#endif //__LAUNCHTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\server\launchserv.cpp ===
// 
// MODULE: LaunchServ.cpp
//
// PURPOSE: Implementation of WinMain.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
// NOTES:  
// 1.	90% of this file was wrote by the ATL wizzard.
// 2.	This project is working fine without the proxy/stub dll.
//		The interfaces are using the IDispatch interface.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

// ATL Wizzard Note:
// 
// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f LaunchServps.mk in the project directory.
//

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "LaunchServ.h"

#include "LaunchServ_i.c"

#include "StateInfo.h"

#include "RSSTACK.h"
#include "TSLError.h"
#include "TSMapAbstract.h"
#include "TSMap.h"
#include "TSMapClient.h"
#include "Launch.h"

#include <stdio.h>
#include "LaunchTS.h"
#include "TShootATL.h"

CServiceModule _Module;
CSMStateInfo g_StateInfo;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_LaunchTS, CLaunchTS)
	OBJECT_ENTRY(CLSID_TShootATL, CTShootATL)
END_OBJECT_MAP()


LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
	while (*p1 != NULL)
	{
		LPCTSTR p = p2;
		while (*p != NULL)
		{
			if (*p1 == *p++)
				return p1+1;
		}
		p1++;
	}
	return NULL;
}

// Although some of these functions are big they are declared inline since they are only used once

inline HRESULT CServiceModule::RegisterServer(BOOL bRegTypeLib, BOOL bService)
{
	HRESULT hr = CoInitialize(NULL);
	if (FAILED(hr))
		return hr;

	// Remove any previous service since it may point to
	// the incorrect file
	Uninstall();

	// Add service entries
	UpdateRegistryFromResource(IDR_LaunchServ, TRUE);

	// Adjust the AppID for Local Server or Service
	CRegKey keyAppID;
	LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"));
	if (lRes != ERROR_SUCCESS)
		return lRes;

	CRegKey key;
	lRes = key.Open(keyAppID, _T("{131CC292-7634-11D1-8B6B-0060089BD8C4}"));
	if (lRes != ERROR_SUCCESS)
		return lRes;
	key.DeleteValue(_T("LocalService"));
	
	if (bService)
	{
		key.SetValue(_T("LaunchServ"), _T("LocalService"));
		key.SetValue(_T("-Service"), _T("ServiceParameters"));
		// Create service
		Install();
	}

	// Add object entries
	hr = CComModule::RegisterServer(bRegTypeLib);

	CoUninitialize();
	return hr;
}

inline HRESULT CServiceModule::UnregisterServer()
{
	HRESULT hr = CoInitialize(NULL);
	if (FAILED(hr))
		return hr;

	// Remove service entries
	UpdateRegistryFromResource(IDR_LaunchServ, FALSE);
	// Remove service
	Uninstall();
	// Remove object entries
	CComModule::UnregisterServer();

	CoUninitialize();
	return S_OK;
}

inline void CServiceModule::Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID)
{
	CComModule::Init(p, h);

	m_bService = TRUE;

	LoadString(h, nServiceNameID, m_szServiceName, sizeof(m_szServiceName) / sizeof(TCHAR));

    // set up the initial service status 
    m_hServiceStatus = NULL;
    m_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_status.dwCurrentState = SERVICE_STOPPED;
    m_status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    m_status.dwWin32ExitCode = 0;
    m_status.dwServiceSpecificExitCode = 0;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;
}

LONG CServiceModule::Unlock()
{
	LONG l = CComModule::Unlock();
	if (l == 0 && !m_bService)
		PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
	return l;
}

BOOL CServiceModule::IsInstalled()
{
    BOOL bResult = FALSE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM != NULL)
	{
        SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_QUERY_CONFIG);
        if (hService != NULL)
		{
            bResult = TRUE;
            ::CloseServiceHandle(hService);
        }
        ::CloseServiceHandle(hSCM);
    }
    return bResult;
}

inline BOOL CServiceModule::Install()
{
	if (IsInstalled())
		return TRUE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSCM == NULL)
	{
		MessageBox(NULL, _T("Couldn't open service manager"), m_szServiceName, MB_OK);
        return FALSE;
	}

    // Get the executable file path
    TCHAR szFilePath[_MAX_PATH];
    ::GetModuleFileName(NULL, szFilePath, _MAX_PATH);

    SC_HANDLE hService = ::CreateService(
		hSCM, m_szServiceName, m_szServiceName,
		SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS,
		SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL,
        szFilePath, NULL, NULL, _T("RPCSS\0"), NULL, NULL);

    if (hService == NULL)
	{
        ::CloseServiceHandle(hSCM);
		MessageBox(NULL, _T("Couldn't create service"), m_szServiceName, MB_OK);
		return FALSE;
    }

    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);
	return TRUE;
}

inline BOOL CServiceModule::Uninstall()
{
	if (!IsInstalled())
		return TRUE;

	SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

	if (hSCM == NULL)
	{
		MessageBox(NULL, _T("Couldn't open service manager"), m_szServiceName, MB_OK);
		return FALSE;
	}

	SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_STOP | DELETE);

	if (hService == NULL)
	{
		::CloseServiceHandle(hSCM);
		MessageBox(NULL, _T("Couldn't open service"), m_szServiceName, MB_OK);
		return FALSE;
	}
	SERVICE_STATUS status;
	::ControlService(hService, SERVICE_CONTROL_STOP, &status);

	BOOL bDelete = ::DeleteService(hService);
	::CloseServiceHandle(hService);
	::CloseServiceHandle(hSCM);

	if (bDelete)
		return TRUE;

	MessageBox(NULL, _T("Service could not be deleted"), m_szServiceName, MB_OK);
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////////////
// Logging functions
void CServiceModule::LogEvent(LPCTSTR pFormat, ...)
{
    TCHAR    chMsg[256];
    HANDLE  hEventSource;
    LPTSTR  lpszStrings[1];
	va_list	pArg;

	va_start(pArg, pFormat);
	_vstprintf(chMsg, pFormat, pArg);
	va_end(pArg);

    lpszStrings[0] = chMsg;

	if (m_bService)
	{
	    /* Get a handle to use with ReportEvent(). */
		hEventSource = RegisterEventSource(NULL, m_szServiceName);
	    if (hEventSource != NULL)
	    {
	        /* Write to event log. */
	        ReportEvent(hEventSource, EVENTLOG_INFORMATION_TYPE, 0, 0, NULL, 1, 0, (LPCTSTR*) &lpszStrings[0], NULL);
	        DeregisterEventSource(hEventSource);
	    }
	}
	else
	{
		// As we are not running as a service, just write the error to the console.
		_putts(chMsg);
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Service startup and registration
inline void CServiceModule::Start()
{
    SERVICE_TABLE_ENTRY st[] =
	{
        { m_szServiceName, _ServiceMain },
        { NULL, NULL }
    };
    if (m_bService && !::StartServiceCtrlDispatcher(st))
	{
		m_bService = FALSE;
	}
	if (m_bService == FALSE)
		Run();
}

inline void CServiceModule::ServiceMain(DWORD /* dwArgc */, LPTSTR* /* lpszArgv */)
{
    // Register the control request handler
    m_status.dwCurrentState = SERVICE_START_PENDING;
    m_hServiceStatus = RegisterServiceCtrlHandler(m_szServiceName, _Handler);
    if (m_hServiceStatus == NULL)
	{
        LogEvent(_T("Handler not installed"));
        return;
    }
    SetServiceStatus(SERVICE_START_PENDING);

    m_status.dwWin32ExitCode = S_OK;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;

    // When the Run function returns, the service has stopped.
    Run();

    SetServiceStatus(SERVICE_STOPPED);
	LogEvent(_T("Service stopped"));
}

inline void CServiceModule::Handler(DWORD dwOpcode)
{
	switch (dwOpcode)
	{
	case SERVICE_CONTROL_STOP:
		SetServiceStatus(SERVICE_STOP_PENDING);
		PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
		break;
	case SERVICE_CONTROL_PAUSE:
		break;
	case SERVICE_CONTROL_CONTINUE:
		break;
	case SERVICE_CONTROL_INTERROGATE:
		break;
	case SERVICE_CONTROL_SHUTDOWN:
		break;
	default:
		LogEvent(_T("Bad service request"));
	}
}

void WINAPI CServiceModule::_ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
{
	_Module.ServiceMain(dwArgc, lpszArgv);
}
void WINAPI CServiceModule::_Handler(DWORD dwOpcode)
{
	_Module.Handler(dwOpcode); 
}

void CServiceModule::SetServiceStatus(DWORD dwState)
{
	m_status.dwCurrentState = dwState;
	::SetServiceStatus(m_hServiceStatus, &m_status);
}

void CServiceModule::Run()
{
	HRESULT hr;

	_Module.dwThreadID = GetCurrentThreadId();

//	HRESULT hRes = CoInitialize(NULL);
//  If you are running on NT 4.0 or higher you can use the following call
//	instead to make the EXE free threaded.
//  This means that calls come in on a random RPC thread
	HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);

	_ASSERTE(SUCCEEDED(hr));

	// This provides a NULL DACL which will allow access to everyone.
	CSecurityDescriptor sd;
	sd.InitializeFromThreadToken();
	hr = CoInitializeSecurity(sd, -1, NULL, NULL,
		RPC_C_AUTHN_LEVEL_PKT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);
	_ASSERTE(SUCCEEDED(hr));

	hr = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER, REGCLS_MULTIPLEUSE);
	_ASSERTE(SUCCEEDED(hr));

	LogEvent(_T("Service started"));
    SetServiceStatus(SERVICE_RUNNING);

	MSG msg;
	while (GetMessage(&msg, 0, 0, 0))
		DispatchMessage(&msg);

	_Module.RevokeClassObjects();

	CoUninitialize();
}

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
	HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
	lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT
	_Module.Init(ObjectMap, hInstance, IDS_SERVICENAME);
	_Module.m_bService = TRUE;

	TCHAR szTokens[] = _T("-/");

	LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
	HRESULT hRes;
	TCHAR szMsg[50];
	bool bRegAttempt = false;
	bool bShowUsage = false;
	bool bSilent = false;
	while (lpszToken != NULL)
	{
		if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
		{
			bRegAttempt = true;
			_tcscpy(szMsg, _T("UnregServer "));
			hRes = _Module.UnregisterServer();
		}
		else if (lstrcmpi(lpszToken, _T("RegServer"))==0)	// Register as Local Server
		{
			bRegAttempt = true;
			_tcscpy(szMsg, _T("RegServer "));
			hRes = _Module.RegisterServer(TRUE, FALSE);
		}
		else if (lstrcmpi(lpszToken, _T("Service"))==0)		// Register as Service
		{
			bRegAttempt = true;
			_tcscpy(szMsg, _T("Service "));
			hRes = _Module.RegisterServer(TRUE, TRUE);
		}
		else if (lstrcmpi(lpszToken, _T("?"))==0)
		{
			bShowUsage = true;
		}
		else if (lstrcmpi(lpszToken, _T("h"))==0)
		{
			bShowUsage = true;
		}
		else if (_tcsncmp(lpszToken, _T("s"), 1)==0)
		{
			bSilent = true;
		}
		else if (_tcsncmp(lpszToken, _T("S"), 1)==0)
		{
			bSilent = true;
		}
		lpszToken = FindOneOf(lpszToken, szTokens);
	}

	if (true == bRegAttempt)
	{
		if (!FAILED(hRes) && false == bSilent)
		{
			_tcscat(szMsg, _T("Succeded"));
			MessageBox(NULL, szMsg, _Module.m_szServiceName, MB_OK | MB_ICONINFORMATION);
			return hRes;
		}
		else if (false == bSilent)
		{
			_tcscat(szMsg, _T("Failed"));
			MessageBox(NULL, szMsg, _Module.m_szServiceName, MB_OK | MB_ICONEXCLAMATION);
			return hRes;
		}
		else
		{
			return hRes;
		}
	}

	if (true == bShowUsage)
	{
		MessageBox(NULL, _T("Usage: <[/UnregServer] [/RegServer] [/Service]>"),
					_Module.m_szServiceName, MB_OK | MB_ICONINFORMATION);
		return S_OK;
	}

	// Are we Service or Local Server
	CRegKey keyAppID;
	LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"));
	if (lRes != ERROR_SUCCESS)
		return lRes;

	CRegKey key;
	lRes = key.Open(keyAppID, _T("{131CC292-7634-11D1-8B6B-0060089BD8C4}"));
	if (lRes != ERROR_SUCCESS)
		return lRes;

	TCHAR szValue[_MAX_PATH];
	DWORD dwLen = _MAX_PATH;
	lRes = key.QueryValue(szValue, _T("LocalService"), &dwLen);

	_Module.m_bService = FALSE;
	if (lRes == ERROR_SUCCESS)
		_Module.m_bService = TRUE;

	_Module.Start();

    // When we get here, the service has been stopped
    return _Module.m_status.dwWin32ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\server\launchts.cpp ===
// 
// MODULE: LaunchTS.cpp
//
// PURPOSE: The interface that TSHOOT.OCX uses to get network and node information
//			from the LaunchServ.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// COMMENTS BY: Joe Mabel
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#include "stdafx.h"
#include "LaunchServ.h"
#include "StateInfo.h"
#include "LaunchTS.h"

#include "ComGlobals.h"

extern CSMStateInfo g_StateInfo;

/////////////////////////////////////////////////////////////////////////////
// CLaunchTS - Created as a plain apartment model interface.

// This fills in m_refedLaunchState from TSLaunchServ's global memory.
//	The resulting values tell us what troubleshooting network to use and can 
//	indicate a problem node and even indicate states to set for other nodes.
STDMETHODIMP CLaunchTS::GetShooterStates(DWORD * pdwResult)
{
	HRESULT hRes;
	m_csThreadSafeBr.Lock();
	hRes = g_StateInfo.GetShooterStates(m_refedLaunchState, pdwResult);
	m_csThreadSafeBr.Unlock();
	return hRes;
}

// OUTPUT pbstrShooter is the name of the Troubleshooting network to launch to
//	Note that this string is allocated by this function
// Returns true if there is a Troubleshooting network to launch to
// Must be called after CLaunchTS::GetShooterStates, since it assumes
//	m_refedLaunchState contains good values
STDMETHODIMP CLaunchTS::GetTroubleShooter(BSTR * pbstrShooter)
{
	LPTSTR pszCmd;
	LPTSTR pszVal;
	m_csThreadSafeBr.Lock();
	if (!m_refedLaunchState.GetNetwork(&pszCmd, &pszVal))
	{
		m_csThreadSafeBr.Unlock();
		return S_FALSE;
	}
	*pbstrShooter = SysAllocString((BSTR) CComBSTR(pszVal));
	m_csThreadSafeBr.Unlock();
	return S_OK;
}

// OUTPUT pbstrProblem is the symbolic name of the selected problem node
//	Note that this string is allocated by this function
// Returns true if there is a selected problem node
// Must be called after CLaunchTS::GetShooterStates, since it assumes
//	m_refedLaunchState contains good values
STDMETHODIMP CLaunchTS::GetProblem(BSTR * pbstrProblem)
{
	LPTSTR pszCmd;
	LPTSTR pszVal;
	m_csThreadSafeBr.Lock();
	if (!m_refedLaunchState.GetProblem(&pszCmd, &pszVal))
	{
		m_csThreadSafeBr.Unlock();
		return S_FALSE;
	}
	*pbstrProblem = SysAllocString((BSTR) CComBSTR(pszVal));
	m_csThreadSafeBr.Unlock();
	return S_OK;
}

STDMETHODIMP CLaunchTS::GetMachine(BSTR * pbstrMachine)
{
	m_csThreadSafeBr.Lock();
	*pbstrMachine = ::SysAllocString((BSTR) CComBSTR(m_refedLaunchState.m_szMachineID));
	m_csThreadSafeBr.Unlock();
	return S_OK;
}

STDMETHODIMP CLaunchTS::GetPNPDevice(BSTR *pbstrPNPDevice)
{
	m_csThreadSafeBr.Lock();
	*pbstrPNPDevice = ::SysAllocString((BSTR) CComBSTR(m_refedLaunchState.m_szPNPDeviceID));
	m_csThreadSafeBr.Unlock();
	return S_OK;
}

STDMETHODIMP CLaunchTS::GetGuidClass(BSTR *pbstrGuidClass)
{
	m_csThreadSafeBr.Lock();
	*pbstrGuidClass = ::SysAllocString((BSTR) CComBSTR(m_refedLaunchState.m_szGuidClass));
	m_csThreadSafeBr.Unlock();
	return S_OK;
}

STDMETHODIMP CLaunchTS::GetDeviceInstance(BSTR *pbstrDeviceInstance)
{
	m_csThreadSafeBr.Lock();
	*pbstrDeviceInstance = ::SysAllocString((BSTR) CComBSTR(m_refedLaunchState.m_szDeviceInstanceID));
	m_csThreadSafeBr.Unlock();
	return S_OK;
}

// INPUT iNode - index of (non-problem) node.  Typically, this function should be called
//	in a loop where we first see if there is a pbstrNode value for iNode == 0 and then
//	increment iNode until we reach a value for which pbstrNode is undefined.
// OUTPUT pbstrNode is the symbolic name of a (non-problem) node whose state we want to set
//	Note that this string is allocated by this function
// Returns true if there is a selected problem node
// Must be called after CLaunchTS::GetShooterStates, since it assumes
//	m_refedLaunchState contains good values
STDMETHODIMP CLaunchTS::GetNode(short iNode, BSTR * pbstrNode)
{
	LPTSTR pszCmd;
	LPTSTR pszVal;
	m_csThreadSafeBr.Lock();
	if (!m_refedLaunchState.GetNodeState(iNode, &pszCmd, &pszVal))
	{
		m_csThreadSafeBr.Unlock();
		return S_FALSE;
	}
	*pbstrNode = SysAllocString((BSTR) CComBSTR(pszCmd));
	m_csThreadSafeBr.Unlock();
	return S_OK;
}

// see comments on CLaunchTS::GetNode; this returns the node state rather than
//	the symbolic node name
STDMETHODIMP CLaunchTS::GetState(short iNode, BSTR * pbstrState)
{
	LPTSTR pszCmd;
	LPTSTR pszVal;
	m_csThreadSafeBr.Lock();
	if (!m_refedLaunchState.GetNodeState(iNode, &pszCmd, &pszVal))
	{
		m_csThreadSafeBr.Unlock();
		return S_FALSE;
	}
	*pbstrState = SysAllocString((BSTR) CComBSTR(pszVal));
	m_csThreadSafeBr.Unlock();
	return S_OK;
}

// Test:  Used to get network and node information from the server without
// launching the browser.  Use the TShootATL::Test method before ILaunchTS::Test.
STDMETHODIMP CLaunchTS::Test()
{
	extern CSMStateInfo g_StateInfo;
	m_csThreadSafeBr.Lock();
	g_StateInfo.TestGet(m_refedLaunchState);
	m_csThreadSafeBr.Unlock();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\server\launch.h ===
// 
// MODULE: Launch.cpp
//
// PURPOSE: Starts the container that will query the LaunchServ for 
//			troubleshooter network and nodes.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

class TSMapClient;

class CLaunch
{
public:
	enum { SYM_LEN = CItem::SYM_LEN };
public:
	CLaunch();
	~CLaunch();
	void ReInit();	// 

	void Clear();	// Clears properties that are set by the launch functions.

	bool SetNode(LPCTSTR szNode, LPCTSTR szState);
	bool SpecifyProblem(LPCTSTR szNetwork, LPCTSTR szProblem);

	// Properties that are reset when ReInit is used.
	HRESULT MachineID(BSTR &bstrMachineID, DWORD *pdwResult);
	HRESULT DeviceInstanceID(BSTR &bstrDeviceInstanceID, DWORD *pdwResult);
	void SetPreferOnline(short bPreferOnline);

	// Launch functions.
	HRESULT LaunchKnown(DWORD * pdwResult);
	HRESULT Launch(BSTR bstrCallerName, BSTR bstrCallerVersion, BSTR bstrAppProblem, short bLaunch, DWORD * pdwResult);
	HRESULT LaunchDevice(BSTR bstrCallerName, BSTR bstrCallerVersion, BSTR bstrPNPDeviceID, BSTR bstrDeviceClassGUID, BSTR bstrAppProblem, short bLaunch, DWORD * pdwResult);

	DWORD GetStatus();	// Used to get the stats information that is saved durring a launch or query.

	// Testing function.
	bool TestPut();	// Uses the mapping classes to map Caller() and DeviceID() information, then copies the CItem to global memory.

	// These two properties are not reset by ReInit or Clear.
	long m_lLaunchWaitTimeOut;
	bool m_bPreferOnline;				// Keeps track of an application-program-indicated
										// preference for online troubleshooter.  As of 
										// 1/98, this preference is ignored.


protected:
	void InitFiles();
	void InitRequest();
	bool VerifyNetworkExists(LPCTSTR szNetwork);

	int GetContainerPathName(TCHAR szPathName[MAX_PATH]);
	int GetWebPage(TCHAR szWebPage[MAX_PATH]);
	int GetDefaultURL(TCHAR szURL[MAX_PATH]);
	int GetDefaultNetwork(TCHAR szDefaultNetwork[SYM_LEN]);
	int GetSniffScriptFile(TCHAR szSniffScriptFile[MAX_PATH], TCHAR* szNetwork);
	int GetSniffStandardFile(TCHAR szSniffStandardFile[MAX_PATH]);

protected:

	// Use szAppName to check the registry for an application specific map file.
	bool CheckMapFile(TCHAR * szAppName, TCHAR szMapFile[MAX_PATH], DWORD *pdwResult);
	
	bool Go(DWORD dwTimeOut, DWORD *pdwResult);

	bool Map(DWORD *pdwResult);

	bool m_bHaveMapPath;		// Set when the path and file name for the default mapping file is read from the registry.
	bool m_bHaveDefMapFile;		// Set when the path name for the default mapping file is verified.
	bool m_bHaveDszPath;		// Set when the path name for the network resources is found.

	CItem m_Item;

	TCHAR m_szAppName[SYM_LEN];
	TCHAR m_szAppVersion[SYM_LEN];
	TCHAR m_szAppProblem[SYM_LEN];

	TCHAR m_szLauncherResources[MAX_PATH];	// The folder where the map file is kept.
	TCHAR m_szDefMapFile[MAX_PATH];			// The file name without the path.
	TCHAR m_szLaunchMapFile[MAX_PATH];		// m_szLauncherResources + m_szDefMapFile.
	TCHAR m_szDszResPath[MAX_PATH];			// The folder where the network resource files are located.  (Need to check for the existance of dsz/dsc files).
	TCHAR m_szMapFile[MAX_PATH];			// map file.
	TSMapClient *m_pMap;					// pointer to a (client-machine-style) mapping object

	RSStack<DWORD> m_stkStatus;				// Status and Error codes that happened durring a launch or mapping.

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\server\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\server\registry.h ===
// 
// MODULE: Registry.h
//
// PURPOSE: All of the registry keys and values for the LaunchServ are 
//			defined here.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

// Registry Keys
#define SZ_LAUNCHER_ROOT		_T("SOFTWARE\\Microsoft\\TShoot\\Launcher")
#define SZ_LAUNCHER_APP_ROOT	_T("SOFTWARE\\Microsoft\\TShoot\\Launcher\\Applications")
#define SZ_TSHOOT_ROOT			_T("SOFTWARE\\Microsoft\\TShoot")
// Registry Values
#define SZ_GLOBAL_MAP_FILE		_T("MapFile")
#define SZ_GLOBAL_LAUNCHER_RES	_T("ResourcePath")	// The applications also use SZ_GLOBAL_LAUNCHER_RES for their map files.
#define SZ_APPS_MAP_FILE		_T("MapFile")
#define SZ_TSHOOT_RES			_T("FullPathToResource")
#define SZ_DEFAULT_NETWORK		_T("DefaultNetwork")	// The dsc network that will be used if the mapping fails.
#define SZ_DEFAULT_PAGE		    _T("DefaultPage")	// The default web page


// Define _HH_CHM for normal NT 5 release builds.
// Undefine _HH_CHM to use with iexplore.exe on NT 4.
#define _HH_CHM 1		// Don't need the full path to hh.exe, but iexplore.exe will not run without the full path.
// The container that will use the ILaunchTS interface.
#ifndef _HH_CHM
#define SZ_CONTAINER_APP_KEY	_T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE")
#define SZ_CONTAINER_APP_VALUE _T("")
#endif

// These are NOT in registry
// These are sniff related names
#define SZ_SNIFF_SCRIPT_NAME		_T("tssniffAsk.htm")
#define SZ_SNIFF_SCRIPT_APPENDIX    _T("_sniff.htm")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\server\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by LaunchServ.rc
//
#define IDS_SERVICENAME                 100
#define IDR_LaunchServ                  100
#define IDR_LAUNCHTS                    101
#define IDR_T3                          102
#define IDR_TSHOOTLAUNCH                103
#define IDR_TSHOOT                      104
#define IDR_TSHOOTATL                   105

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\server\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__131CC295_7634_11D1_8B6B_0060089BD8C4__INCLUDED_)
#define AFX_STDAFX_H__131CC295_7634_11D1_8B6B_0060089BD8C4__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#if !defined(_WIN32_WINNT) || (defined(_WIN32_WINNT) && (_WIN32_WINNT < 0x0400))
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

class CServiceModule : public CComModule
{
public:
	HRESULT RegisterServer(BOOL bRegTypeLib, BOOL bService);
	HRESULT UnregisterServer();
	void Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID);
    void Start();
	void ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    void Handler(DWORD dwOpcode);
    void Run();
    BOOL IsInstalled();
    BOOL Install();
    BOOL Uninstall();
	LONG Unlock();
	void LogEvent(LPCTSTR pszFormat, ...);
    void SetServiceStatus(DWORD dwState);
    void SetupAsLocalServer();

//Implementation
private:
	static void WINAPI _ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    static void WINAPI _Handler(DWORD dwOpcode);

// data members
public:
    TCHAR m_szServiceName[256];
    SERVICE_STATUS_HANDLE m_hServiceStatus;
    SERVICE_STATUS m_status;
	DWORD dwThreadID;
	BOOL m_bService;
};

extern CServiceModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__131CC295_7634_11D1_8B6B_0060089BD8C4__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\server\tshootatl.cpp ===
// 
// MODULE: TShootATL.cpp
//
// PURPOSE: The interface that device manager uses to launch troubleshooters.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#include "stdafx.h"
#include "LaunchServ.h"
#include "StateInfo.h"
#include "RSSTACK.H"
#include "Launch.h"

#include "TShootATL.h"

#include "TSLError.h"
#include "ComGlobals.h"

#include <atlimpl.cpp>

/////////////////////////////////////////////////////////////////////////////
// CTShootATL - Created as an internet explorer object with a dual interface


STDMETHODIMP CTShootATL::SpecifyProblem(BSTR bstrNetwork, BSTR bstrProblem, DWORD * pdwResult)
{
	HRESULT hRes = S_OK;
	*pdwResult = TSL_ERROR_GENERAL;
	TCHAR szProblem[CLaunch::SYM_LEN];
	TCHAR szNetwork[CLaunch::SYM_LEN];
	if (!BSTRToTCHAR(szNetwork, bstrNetwork, CLaunch::SYM_LEN))
	{
		*pdwResult = TSL_E_MEM_EXCESSIVE;
		return TSL_E_FAIL;
	}
	if (!BSTRToTCHAR(szProblem, bstrProblem, CLaunch::SYM_LEN))
	{
		*pdwResult = TSL_E_MEM_EXCESSIVE;
		return TSL_E_FAIL;
	}
	m_csThreadSafe.Lock();
	try
	{
		if (!m_Launcher.SpecifyProblem(szNetwork, szProblem))
		{
			*pdwResult = TSL_ERROR_GENERAL;
			hRes = TSL_E_FAIL;
		}
		else
		{
			*pdwResult = TSL_OK;
		}
	}
	catch(...)
	{
		m_csThreadSafe.Unlock();
		throw;
	}
	m_csThreadSafe.Unlock();
	return hRes;
}

STDMETHODIMP CTShootATL::SetNode(BSTR bstrName, BSTR bstrState, DWORD *pdwResult)
{
	HRESULT hRes = S_OK;
	*pdwResult = TSL_ERROR_GENERAL;
	TCHAR szName[CLaunch::SYM_LEN];
	TCHAR szState[CLaunch::SYM_LEN];
	if (!BSTRToTCHAR(szName, bstrName, CLaunch::SYM_LEN))
	{
		*pdwResult = TSL_E_MEM_EXCESSIVE;
		return TSL_E_FAIL;
	}
	if (!BSTRToTCHAR(szState, bstrState, CLaunch::SYM_LEN))
	{
		*pdwResult = TSL_E_MEM_EXCESSIVE;
		return TSL_E_FAIL;
	}
	m_csThreadSafe.Lock();
	try
	{
		if (!m_Launcher.SetNode(szName, szState))
		{
			*pdwResult = TSL_ERROR_GENERAL;
			hRes = TSL_E_FAIL;
		}
		else
		{
			*pdwResult = TSL_OK;
		}
	}
	catch(...)
	{
		m_csThreadSafe.Unlock();
		throw;
	}
	m_csThreadSafe.Unlock();
	return hRes;
}

STDMETHODIMP CTShootATL::Language(BSTR bstrLanguage, DWORD * pdwResult)
{
	HRESULT hRes = S_OK;
	*pdwResult = TSL_ERROR_GENERAL;
	m_csThreadSafe.Lock();
	try
	{
		//hRes =
	}
	catch(...)
	{
		m_csThreadSafe.Unlock();
		throw;
	}
	m_csThreadSafe.Unlock();
	return hRes;
}

STDMETHODIMP CTShootATL::MachineID(BSTR bstrMachineID, DWORD * pdwResult)
{
	HRESULT hRes = S_OK;
	*pdwResult = TSL_ERROR_GENERAL;
	m_csThreadSafe.Lock();
	try
	{
		hRes = m_Launcher.MachineID(bstrMachineID, pdwResult);
	}
	catch(...)
	{
		m_csThreadSafe.Unlock();
		throw;
	}
	m_csThreadSafe.Unlock();
	return hRes;
}
// Test:  Call Test after setting the device and caller information.
// Test will return S_OK if the mapping worked.  The result of the mapping
// can then be obtained through the ILaunchTS interface.  Use the Test method
// of ILaunchTS before calling the other ILaunchTS methods.
STDMETHODIMP CTShootATL::Test()
{
	HRESULT hRes;
	m_csThreadSafe.Lock();
	try
	{
		if (m_Launcher.TestPut())	// Does the mapping and copies the information to global memory.
			hRes = S_OK;
		else
			hRes = TSL_E_FAIL;
	}
	catch(...)
	{
		m_csThreadSafe.Unlock();
		throw;
	}
	m_csThreadSafe.Unlock();
	return hRes;
}

STDMETHODIMP CTShootATL::DeviceInstanceID(BSTR bstrDeviceInstanceID, DWORD * pdwResult)
{
	HRESULT hRes = S_OK;
	*pdwResult = TSL_ERROR_GENERAL;
	m_csThreadSafe.Lock();
	try
	{
		hRes = m_Launcher.DeviceInstanceID(bstrDeviceInstanceID, pdwResult);
	}
	catch(...)
	{
		m_csThreadSafe.Unlock();
		throw;
	}
	m_csThreadSafe.Unlock();
	return hRes;
}

STDMETHODIMP CTShootATL::ReInit()
{
	m_csThreadSafe.Lock();
	try
	{
		m_Launcher.ReInit();
	}
	catch(...)
	{
		m_csThreadSafe.Unlock();
		throw;
	}
	m_csThreadSafe.Unlock();
	return S_OK;
}

STDMETHODIMP CTShootATL::LaunchKnown(DWORD * pdwResult)
{
	HRESULT hRes;
	m_csThreadSafe.Lock();
	try
	{
		hRes = m_Launcher.LaunchKnown(pdwResult);
	}
	catch(...)
	{
		m_csThreadSafe.Unlock();
		throw;
	}
	m_csThreadSafe.Unlock();
	return hRes;
}

STDMETHODIMP CTShootATL::get_LaunchWaitTimeOut(long * pVal)
{
	HRESULT hRes = S_OK;
	m_csThreadSafe.Lock();
	try
	{
		*pVal = m_Launcher.m_lLaunchWaitTimeOut;
	}
	catch(...)
	{
		m_csThreadSafe.Unlock();
		throw;
	}
	m_csThreadSafe.Unlock();
	return hRes;
}

STDMETHODIMP CTShootATL::put_LaunchWaitTimeOut(long newVal)
{
	HRESULT hRes = S_OK;
	m_csThreadSafe.Lock();
	try
	{
		m_Launcher.m_lLaunchWaitTimeOut = newVal;
	}
	catch(...)
	{
		m_csThreadSafe.Unlock();
		throw;
	}
	m_csThreadSafe.Unlock();
	return hRes;
}

STDMETHODIMP CTShootATL::Launch(BSTR bstrCallerName, BSTR bstrCallerVersion, BSTR bstrAppProblem, short bLaunch, DWORD * pdwResult)
{
	HRESULT hRes;
	m_csThreadSafe.Lock();
	try
	{
		hRes = m_Launcher.Launch(bstrCallerName, bstrCallerVersion, bstrAppProblem, bLaunch, pdwResult);
	}
	catch(...)
	{
		m_csThreadSafe.Unlock();
		throw;
	}
	m_csThreadSafe.Unlock();
	return hRes;
}

STDMETHODIMP CTShootATL::LaunchDevice(BSTR bstrCallerName, BSTR bstrCallerVersion, BSTR bstrPNPDeviceID, BSTR bstrDeviceClassGUID, BSTR bstrAppProblem, short bLaunch, DWORD * pdwResult)
{
	HRESULT hRes;
	m_csThreadSafe.Lock();
	try
	{
		hRes = m_Launcher.LaunchDevice(bstrCallerName, bstrCallerVersion, bstrPNPDeviceID, bstrDeviceClassGUID, bstrAppProblem, bLaunch, pdwResult);
	}
	catch(...)
	{
		m_csThreadSafe.Unlock();
		throw;
	}
	m_csThreadSafe.Unlock();
	return hRes;
}

STDMETHODIMP CTShootATL::get_PreferOnline(BOOL * pVal)
{
	m_csThreadSafe.Lock();
	try
	{
		if (m_Launcher.m_bPreferOnline)
			*pVal = 1;
		else
			*pVal = 0;
	}
	catch(...)
	{
		m_csThreadSafe.Unlock();
		throw;
	}
	m_csThreadSafe.Unlock();	
	return S_OK;
}

STDMETHODIMP CTShootATL::put_PreferOnline(BOOL newVal)
{
	m_csThreadSafe.Lock();
	try
	{
		m_Launcher.m_bPreferOnline = (0 != newVal);
	}
	catch(...)
	{
		m_csThreadSafe.Unlock();
		throw;
	}
	m_csThreadSafe.Unlock();	
	return S_OK;
}

STDMETHODIMP CTShootATL::GetStatus(DWORD * pdwStatus)
{
	m_csThreadSafe.Lock();
	try
	{
		*pdwStatus = m_Launcher.GetStatus();
	}
	catch(...)
	{
		m_csThreadSafe.Unlock();
		throw;
	}
	m_csThreadSafe.Unlock();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\server\tshootatl.h ===
// 
// MODULE: TShootATL.cpp
//
// PURPOSE: The interface that device manager uses to launch troubleshooters.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#ifndef __TSHOOTATL_H_
#define __TSHOOTATL_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CTShootATL
class ATL_NO_VTABLE CTShootATL : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTShootATL, &CLSID_TShootATL>,
	public IObjectWithSiteImpl<CTShootATL>,
	public IDispatchImpl<ITShootATL, &IID_ITShootATL, &LIBID_LAUNCHSERVLib>
{
public:
	CTShootATL()
	{
		m_csThreadSafe.Init();
	}
	~CTShootATL()
	{
		m_csThreadSafe.Term();
	}

DECLARE_REGISTRY_RESOURCEID(IDR_TSHOOTATL)

BEGIN_COM_MAP(CTShootATL)
	COM_INTERFACE_ENTRY(ITShootATL)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY_IMPL(IObjectWithSite)
END_COM_MAP()

protected:
	CLaunch m_Launcher;		// The real implementation.
	CComCriticalSection m_csThreadSafe;	// For minimal thread safety.  I expect that the interface will be used by only one thread per CoCreateInstance call.

// ITShootATL
public:
	STDMETHOD(GetStatus)(/*[out, retval]*/ DWORD *pdwStatus);
	STDMETHOD(get_PreferOnline)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_PreferOnline)(/*[in]*/ BOOL newVal);
	STDMETHOD(LaunchDevice)(/*[in]*/ BSTR bstrCallerName, /*[in]*/ BSTR bstrCallerVersion, /*[in]*/ BSTR bstrPNPDeviceID, /*[in]*/ BSTR bstrDeviceClassGUID, /*[in]*/ BSTR bstrAppProblem, /*[in]*/ short bLaunch, /*[out, retval]*/ DWORD *pdwResult);
	STDMETHOD(Launch)(/*[in]*/ BSTR bstrCallerName, /*[in]*/ BSTR bstrCallerVersion, /*[in]*/ BSTR bstrAppProblem, /*[in]*/ short bLaunch, /*[out, retval]*/ DWORD *pdwResult);
	STDMETHOD(get_LaunchWaitTimeOut)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_LaunchWaitTimeOut)(/*[in]*/ long newVal);
	STDMETHOD(LaunchKnown)(/*[out, retval]*/ DWORD *pdwResult);
	STDMETHOD(ReInit)();
	STDMETHOD(DeviceInstanceID)(/*[in]*/BSTR bstrDeviceInstanceID, /*[out, retval]*/DWORD * pdwResult);
	STDMETHOD(Test)();
	STDMETHOD(MachineID)(/*[in]*/ BSTR bstrMachineID, /*[out, retval]*/ DWORD *pdwResult);
	STDMETHOD(Language)(/*[in]*/ BSTR bstrLanguage, /*[out, retval]*/ DWORD *pdwResult);
	STDMETHOD(SetNode)(/*[in]*/ BSTR bstrName, /*[in]*/ BSTR bstrState, /*[out, retval]*/ DWORD *pdwResult);
	STDMETHOD(SpecifyProblem)(/*[in]*/ BSTR bstrNetwork, /*[in]*/ BSTR bstrProblem, /*[out, retval]*/ DWORD *pdwResult);
};

#endif //__TSHOOTATL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\server\stateinfo.cpp ===
// 
// MODULE: StateInfo.cpp
//
// PURPOSE: Contains sniffing, network and node information.  Also is used
//			by the Launch module to start the container application.
//
//			Basically, this is how the Launch Server packages up info for the 
//			Local TShoot OCX, launches either IE or HTML Help System to a page 
//			containing the Local TShoot OCX, and handshakes with the Local TShoot OCX
//			to pass that information 
//
//			Note that CSMStateInfo::GetShooterStates() is called by the 
//			Local TShoot OCX to pick up the CItem object which contains
//			the packaged-up info.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// COMMENTS BY: Joe Mabel
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#include "stdafx.h"
#include "atlbase.h"
#include "StateInfo.h"

#include "TSLError.h"
#include "ComGlobals.h"

#include "Registry.h"

#include <stdio.h>
#include <string.h>
#include <memory.h>
//#include <fstream.h>
#include <strstrea.h>

////////////////////////////////////////////////////////
//	CItem : 
//	Data structure for pseudo HTTP "get" in launching Local Troubleshooters 
//

CItem::CItem()
{
	// initializing this is exactly the same as reinitializing.
	ReInit();
}

void CItem::ReInit()
{
	memset(m_aszCmds, NULL, SYM_LEN * NODE_COUNT);
	memset(m_aszVals, NULL, SYM_LEN * NODE_COUNT);
	m_cNodesSet = 0;
	_tcscpy(m_szProblemDef, _T("TShootProblem"));
	_tcscpy(m_szTypeDef, _T("type"));
	m_szPNPDeviceID[0] = NULL;
	m_szGuidClass[0] = NULL;
	m_szContainerPathName[0] = NULL;
	m_szWebPage[0] = NULL;
	m_szSniffScriptFile[0] = NULL;
    m_eLaunchRegime = launchIndefinite;
	m_szMachineID[0] = NULL;
	m_szDeviceInstanceID[0] = NULL;

#ifdef _DEBUG
	
//	There are some other things you need to comment out in GetShooterStates
//	to allow debugging this service from a tshoot.ocx debug sesstion.
/*	
	_tcscpy(m_aszCmds[0], m_szTypeDef);
	_tcscpy(m_aszVals[0], _T("ras"));
	_tcscpy(m_aszCmds[1],  m_szProblemDef);
	_tcscpy(m_aszVals[1], _T("CnntCnnctAftrDlngWthRS"));
	_tcscpy(m_aszCmds[2], _T("SoftwareCompression"));
	_tcscpy(m_aszVals[2], _T("0"));
	m_cNodesSet = 1;
*/
#endif
	return;
}

void CItem::Clear()
{
	memset(m_aszCmds, NULL, SYM_LEN * NODE_COUNT);
	memset(m_aszVals, NULL, SYM_LEN * NODE_COUNT);
	m_cNodesSet = 0;
	_tcscpy(m_szProblemDef, _T("TShootProblem"));
	_tcscpy(m_szTypeDef, _T("type"));
	m_szPNPDeviceID[0] = NULL;
	m_szGuidClass[0] = NULL;
	m_szContainerPathName[0] = NULL;
	m_szWebPage[0] = NULL;
	m_szSniffScriptFile[0] = NULL;
    m_eLaunchRegime = launchIndefinite;
	return;
}

// ----------- Routines to build command/value pairs ------------------
//	see documentation of m_aszCmds, m_aszVals for further explanation

void CItem::SetNetwork(LPCTSTR szNetwork)
{
	if (NULL != szNetwork && NULL != szNetwork[0])
	{
		_tcscpy(m_aszCmds[0], m_szTypeDef);
		_tcsncpy(m_aszVals[0], szNetwork, SYM_LEN);
	}
	else
	{
		m_aszCmds[0][0] = NULL;
		m_aszVals[0][0] = NULL;
	}
	return;
}

void CItem::SetProblem(LPCTSTR szProblem)
{
	if (NULL != szProblem && NULL != szProblem[0])
	{
		_tcscpy(m_aszCmds[1], m_szProblemDef);
		_tcsncpy(m_aszVals[1], szProblem, SYM_LEN);
	}
	else
	{
		m_aszCmds[1][0] = NULL;
		m_aszVals[1][0] = NULL;
	}
	return;
}

void CItem::SetNode(LPCTSTR szNode, LPCTSTR szState)
{
	if (NULL != szNode && NULL != szNode[0] 
	&& NULL != szState && NULL != szState[0])
	{
		_tcsncpy(m_aszCmds[m_cNodesSet + 2], szNode, SYM_LEN);
		_tcsncpy(m_aszVals[m_cNodesSet + 2], szState, SYM_LEN);
		m_cNodesSet++;
	}
	return;
}

// ----------- Routines to query command/value pairs ------------------
// See documentation of m_aszCmds, m_aszVals for further explanation

// returns true if network has been set
// On success, OUTPUT *pszCmd is "type", *pszVal is network name
bool CItem::GetNetwork(LPTSTR *pszCmd, LPTSTR *pszVal)
{
	*pszCmd = m_szTypeDef;
	*pszVal = m_aszVals[0];
	return *m_aszVals[0] != NULL;
}

// returns true if problem node has been set
// On success, OUTPUT *pszCmd is "TShootProblem", *pszVal is problem node's symbolic name
bool CItem::GetProblem(LPTSTR *pszCmd, LPTSTR *pszVal)
{
	*pszCmd = m_szProblemDef;
	*pszVal = m_aszVals[1];
	return *m_aszVals[1] != NULL;;
}

// output the iNodeC-th non-problem node for which a state has been set.
// On success, OUTPUT *pszCmd is symbolic node name, *pszVal is state
// returns true if at least iNodeC non-problem nodes have been set
bool CItem::GetNodeState(int iNodeC, LPTSTR *pszCmd, LPTSTR *pszVal)
{
	if (iNodeC >= m_cNodesSet)
		return false;
	*pszCmd = m_aszCmds[iNodeC + 2];
	*pszVal = m_aszVals[iNodeC + 2];
	return true;
}

// ----------- Routines to query whether we know a network ------------
// ----------- & problem node to launch to ----------------------------
// See documentation of m_aszCmds, m_aszVals for further explanation

// NetworkSet returns true if we know which troubleshooter to launch.
bool CItem::NetworkSet()
{
	return NULL != m_aszVals[0][0];
}
// ProblemSet returns true if we know which problem to choose.
bool CItem::ProblemSet()
{
	return NULL != m_aszVals[1][0];
}

// --------- Interface to other member variables recponsible for launching -----------

void CItem::SetLaunchRegime(ELaunchRegime eLaunchRegime)
{
	m_eLaunchRegime = eLaunchRegime;
}

void CItem::SetContainerPathName(TCHAR szContainerPathName[MAX_PATH])
{
	if (NULL != szContainerPathName && NULL != szContainerPathName[0])
		_tcscpy(m_szContainerPathName, szContainerPathName);
	else
		m_szContainerPathName[0] = NULL;
	return;
}

void CItem::SetWebPage(TCHAR szWebPage[MAX_PATH])
{
	if (NULL != szWebPage && NULL != szWebPage[0])
		_tcscpy(m_szWebPage, szWebPage);
	else
		m_szWebPage[0] = NULL;
	return;
}

void CItem::SetSniffScriptFile(TCHAR szSniffScriptFile[MAX_PATH])
{
	if (NULL != szSniffScriptFile && NULL != szSniffScriptFile[0])
		_tcscpy(m_szSniffScriptFile, szSniffScriptFile);
	else
		m_szSniffScriptFile[0] = NULL;
	return;
}

void CItem::SetSniffStandardFile(TCHAR szSniffStandardFile[MAX_PATH])
{
	if (NULL != szSniffStandardFile && NULL != szSniffStandardFile[0])
		_tcscpy(m_szSniffStandardFile, szSniffStandardFile);
	else
		m_szSniffStandardFile[0] = NULL;
	return;
}

ELaunchRegime CItem::GetLaunchRegime()
{
	return m_eLaunchRegime;
}

inline TCHAR* CItem::GetContainerPathName()
{
	return m_szContainerPathName;
}

inline TCHAR* CItem::GetWebPage()
{
	return m_szWebPage;
}

inline TCHAR* CItem::GetSniffScriptFile()
{
	return m_szSniffScriptFile;
}

inline TCHAR* CItem::GetSniffStandardFile()
{
	return m_szSniffStandardFile;
}

////////////////////////////////////////////////////////
//	CSMStateInfo : 
//	State information on MSBN Troubleshooters
//	

CSMStateInfo::CSMStateInfo()
{
	m_csGlobalMemory.Init();
	m_csSingleLaunch.Init();
	return;
}

CSMStateInfo::~CSMStateInfo()
{
	m_csGlobalMemory.Term();
	m_csSingleLaunch.Term();
	return;
}

// TestPut:  Simply copies item to m_Item.
void CSMStateInfo::TestPut(CItem &item)
{
	m_csGlobalMemory.Lock();
	m_Item = item;
	m_csGlobalMemory.Unlock();
	return;
}

// TestGet:  Simply copies m_Item to item.
void CSMStateInfo::TestGet(CItem &item)
{
	m_csGlobalMemory.Lock();
	item = m_Item;
	m_csGlobalMemory.Unlock();
	return;
}

// Copy the item to the global memory and launch a process based on the command.
// Copying the item to global memory is here because the item is what tells the 
//	launched local troubleshooter what belief network etc. it is being launched to.
//	Once we unlock global memory, the Local Troubleshooter OCX can read that item
//	and act on it.
BOOL CSMStateInfo::CreateContainer(CItem &item, LPTSTR szCommand)
{
	BOOL bOk = TRUE;
	HRESULT hRes = S_OK;
	STARTUPINFO startup;
	PROCESS_INFORMATION process;

	memset(&startup, NULL, sizeof(STARTUPINFO));
	startup.cb = sizeof(STARTUPINFO);
	startup.wShowWindow = SW_SHOWNORMAL;

	m_csGlobalMemory.Lock();
	m_Item = item;

	bOk = CreateProcess(NULL, szCommand, NULL, NULL, FALSE, 0, NULL, NULL,
						&startup, &process);
	CloseHandle(process.hThread);
	CloseHandle(process.hProcess);	

	m_csGlobalMemory.Unlock();
	return bOk;
}

//
// Copy network_sniff.htm to tssniffAsk.htm if the former exists
// Create (modify) tssniffAsk.htm to be a sniffing stub otherwise 
//
BOOL CSMStateInfo::CopySniffScriptFile(CItem &item)
{
	TCHAR* szSniffScriptFile = item.GetSniffScriptFile();
	TCHAR* szSniffStandardFile = item.GetSniffStandardFile();

	if (!*szSniffScriptFile) // no network specific sniff file
	{
		// szSniffScriptFile contains tssniffAsk.htm
		// it means that we have to form this file as an empty stub
		ostrstream fileSniffScript;

		HANDLE hFile = ::CreateFile(szSniffStandardFile, 
									GENERIC_WRITE, 
									0,
									NULL,			// no security attributes 
									CREATE_ALWAYS, 
									FILE_FLAG_RANDOM_ACCESS, 
									NULL			// handle to template file
  								   );

		if (hFile != INVALID_HANDLE_VALUE)
		{
			// form html file - part preceding script
			fileSniffScript << "<HTML>" << endl;
			fileSniffScript << "<HEAD>" << endl;
			fileSniffScript << "<TITLE>GTS LOCAL</TITLE>" << endl;
			fileSniffScript << "</HEAD>" << endl;
			fileSniffScript << "<SCRIPT LANGUAGE=\"VBSCRIPT\">" << endl;
			fileSniffScript << "<!--" << endl;
			
			// form global function
			fileSniffScript << "function PerformSniffing()" << endl;
			fileSniffScript << "end function" << endl;

			// form html file - part after script
			fileSniffScript << "-->" << endl;
			fileSniffScript << "</SCRIPT>" << endl;
			fileSniffScript << "<BODY BGCOLOR=\"#FFFFFF\">" << endl;
			fileSniffScript << "</BODY>" << endl;
			fileSniffScript << "</HTML>" << endl;
			fileSniffScript << ends;

			char* str = fileSniffScript.str();
			DWORD read;
			
			if (!::WriteFile(hFile, str, strlen(str), &read, NULL))
			{
				::CloseHandle(hFile);
				fileSniffScript.rdbuf()->freeze(0);
				return false;
			}

			::CloseHandle(hFile);
			fileSniffScript.rdbuf()->freeze(0);
			return true;
		}	
		else
		{
			return false;
		}
	}
	else
	{
		return ::CopyFile(szSniffScriptFile, szSniffStandardFile, false);
	}
}

// Find the container (HTML Help System or IE) and starting web page, launch, wait to
//	see if launch succeeded
bool CSMStateInfo::GoGo(DWORD dwTimeOut, CItem &item, DWORD *pdwResult)
{
	bool bResult = true;
	HANDLE hLaunchedEvent = NULL;
	TCHAR szProcess[MAX_PATH];
	TCHAR szWebPage[MAX_PATH];
	LPTSTR pszCommand = NULL;
	int CommandLen;
	DWORD dwError;
	int Count = 34;

	if (item.GetLaunchRegime() == launchIndefinite ||
		!item.GetContainerPathName()[0] ||
		!item.GetWebPage()[0]
	   )
	{
		*pdwResult = TSL_ERROR_ASSERTION;
		return false;
	}
	
	do
	{
		_stprintf(item.m_szEventName, _T("TSL_SHOOTER_Event_%ld"), Count);
		if (NULL == (hLaunchedEvent = CreateEvent (NULL, FALSE, FALSE, item.m_szEventName)))
		{
			dwError = GetLastError();
			if (ERROR_ALREADY_EXISTS != dwError)
			{
				*pdwResult = dwError;
				return false;
			}
		}		
	} while (NULL == hLaunchedEvent);
	
	// Get the path to internet explorer (or HTML Help System).
	_tcscpy(szProcess, item.GetContainerPathName());

	// Need to know the location and name of the
	// page that asks the service for the CItem
	// information.
	_tcscpy(szWebPage, item.GetWebPage());

	CommandLen = _tcslen(szProcess) + 1 + _tcslen(szWebPage) + 2;
	pszCommand = new TCHAR[CommandLen];
	if (NULL == pszCommand)
	{
		*pdwResult = TSL_ERROR_OUT_OF_MEMORY;
		return false;
	}
	_tcscpy(pszCommand, szProcess);
	_tcscat(pszCommand, _T(" "));
	_tcscat(pszCommand, szWebPage);

	m_csSingleLaunch.Lock();

	// copy to or create tssniffAsk.htm
	if (!CopySniffScriptFile(item))
	{
		*pdwResult = TSL_E_COPY_SNIFF_SCRIPT;
		return false;
	}

	// CreateContainer copies the item to the global memory and 
	// launches the command.
	if (!CreateContainer(item, pszCommand))
	{
		*pdwResult = TSL_E_CREATE_PROC;
		bResult = false;
	}
	else
	{
		if (WAIT_OBJECT_0 == WaitForSingleObject(hLaunchedEvent, dwTimeOut))
		{	// The container has the information.
			*pdwResult = TSL_OK;
		}
		else
		{	// Wait timed out.  Don't know if the operation will work or not work.
			*pdwResult = TSL_W_CONTAINER_WAIT_TIMED_OUT;
		}
	}
	m_csSingleLaunch.Unlock();

	delete [] pszCommand;

	CloseHandle(hLaunchedEvent);
	return bResult;
}

// Find the container (HTML Help System or IE) and start it up to a URL which is _not_
//	expected to contain Local Troubleshooter, just an arbitrary web page.  This should 
//	only be used when the launch as such can't work, and we are just trying to give them
//	somewhere to start troubleshooting, typically the home page which lists all 
//	trobleshooting belief networks.
bool CSMStateInfo::GoURL(CItem &item, DWORD *pdwResult)
{
	bool bResult = true;
	TCHAR szProcess[MAX_PATH];
	TCHAR szWebPage[MAX_PATH];
	LPTSTR pszCommand = NULL;
	int CommandLen;

	if (item.GetLaunchRegime() != launchDefaultWebPage ||
		!item.GetContainerPathName()[0] ||
		!item.GetWebPage()[0]
	   )
	{
		*pdwResult = TSL_ERROR_ASSERTION;
		return false;
	}
	
	// Get the path to internet explorer (or HTML Help System).
	_tcscpy(szProcess, item.GetContainerPathName());

	// Need to know the location and name of the
	// page that asks the service for the CItem
	// information.
	_tcscpy(szWebPage, item.GetWebPage());

	CommandLen = _tcslen(szProcess) + 1 + _tcslen(szWebPage) + 2;
	pszCommand = new TCHAR[CommandLen];
	if (NULL == pszCommand)
	{
		*pdwResult = TSL_ERROR_OUT_OF_MEMORY;
		return false;
	}
	_tcscpy(pszCommand, szProcess);
	_tcscat(pszCommand, _T(" "));
	_tcscat(pszCommand, szWebPage);
	
	// CreateContainer is overkill here, but perfectly OK.
	if (!CreateContainer(item, pszCommand))
	{
		*pdwResult = TSL_E_CREATE_PROC;
		bResult = false;
	}

	delete [] pszCommand;

	return bResult;
}

// This function is used by the Local Troubleshooter OCX, not by the Launcher.
// This is how the Local Troubleshooter knows what troubleshooting network to launch
//	to, as well as any nodes whose states are set.
// GetShooterStates returns the commands and the number of commands for
// the Tshoot.ocx.
// refLaunchState is a member of this instance of the LaunchTS interface.
// 
HRESULT CSMStateInfo::GetShooterStates(CItem &refLaunchState, DWORD *pdwResult)
{
	HANDLE hHaveItemEvent;
	// Get a copy of the launch info state stored in this instance.
	// Synchronize with the process that launched the service.

	m_csGlobalMemory.Lock();

	if (NULL == (hHaveItemEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, m_Item.m_szEventName)))
	{
		*pdwResult = GetLastError();
		m_csGlobalMemory.Unlock();
		return TSL_E_FAIL;
	}

	// Get a copy of the state before unlocking the global memory.
	refLaunchState = m_Item;
	// Let the other process continue running.

	SetEvent(hHaveItemEvent);
	m_csGlobalMemory.Unlock();
	CloseHandle(hHaveItemEvent);

	*pdwResult = 0;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\server\tsmap.h ===
// 
// MODULE: TSMap.h
//
// PURPOSE: Structures and other definitions for the Troubleshooter MAP file.
//			These use char rather than TCHAR because the file format is always strictly SBCS 
//			(Single Byte Character Set).
//			This should suffice for any values it is ever expected to contain, and saves space
//			considerably compared to Unicode, since the file is overwhelmingly text.
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			JM		Original
///////////////////////

#ifndef _TSMAP_
#define _TSMAP_

const char * const k_szMapFileSignature = const_cast < const char * > ("TSMAP");

#define BUFSIZE 256

typedef struct TSMAPFILEHEADER {
	char szMapFileSignature[6];	// Always k_szMapFileSignature
	char szVersion[6];				// null terminated numeric version number, a positive
									//	integer <= 99999. Current version: always "00001"
	char szRelease[40];			// string uniquely identifying this file.
									//	plan 1/2/98 is use GUID
	DWORD dwOffApp;					// offset where applications list starts
	DWORD dwLastOffApp;				// offset where applications list ends
	DWORD dwOffProb;				// offset where problem names list starts
	DWORD dwLastOffProb;			// offset where problem names list ends
	DWORD dwOffDevID;				// offset where device IDs list starts
	DWORD dwLastOffDevID;			// offset where device IDs list ends
	DWORD dwOffDevClass;			// offset where device class GUIDs list starts
	DWORD dwLastOffDevClass;		// offset where device class GUIDs list ends

} TSMAPFILEHEADER;

typedef struct UIDMAP {
	unsigned short cb;	// count of bytes in this record
	UID uid;
	char szMapped[BUFSIZE];
} UIDMAP;

typedef struct APPMAP {
	unsigned short cb;	// count of bytes in this record
	DWORD dwOffVer;				// offset where versions list starts
	DWORD dwLastOffVer;			// offset where versions list ends
	char szMapped[BUFSIZE];
} APPMAP;

typedef struct VERMAP {
	unsigned short cb;	// count of bytes in this record
	UID uid;	// this version's own UID
	UID uidDefault;	// UID of version to default to if no data for this version
	DWORD dwOffProbUID;				// offset where problem UID list starts
	DWORD dwLastOffProbUID;			// offset where problem UID list ends
	DWORD dwOffDevUID;				// offset where device UID list starts
	DWORD dwLastOffDevUID;			// offset where device UID list ends
	DWORD dwOffDevClassUID;			// offset where device class UID list starts
	DWORD dwLastOffDevClassUID;		// offset where device class UID list ends
	char szMapped[BUFSIZE];
} VERMAP;

typedef struct PROBMAP {
	unsigned short cb;			// count of bytes in this record
	UID uidProb;
	DWORD dwOffTSName;	// file offset of troubleshooting belief network name
	char szProblemNode[BUFSIZE];  // null-terminated symbolic node name (may be null)
} PROBMAP;

typedef struct DEVMAP {
	unsigned short cb;			// count of bytes in this record
	UID uidDev;
	UID uidProb;
	DWORD dwOffTSName;	// file offset of troubleshooting belief network name
	char szProblemNode[BUFSIZE];  // null-terminated symbolic node name (may be null)
} DEVMAP;

typedef struct DEVCLASSMAP {
	unsigned short cb;			// count of bytes in this record
	UID uidDevClass;
	UID uidProb;
	DWORD dwOffTSName;	// file offset of troubleshooting belief network name
	char szProblemNode[BUFSIZE];  // null-terminated symbolic node name (may be null)
} DEVCLASSMAP;

#endif //_TSMAP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\server\tslerror.h ===
// 
// MODULE: tslerror.h
//
// PURPOSE: Warning and error codes for the TSLauncher.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHORS: Joe Mabel and Richard Meadows
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

#define TSL_OK 0
#define TSL_ERROR_BAD_HANDLE            1	// Handle hTSL passed into function is bad.
#define TSL_ERROR_OUT_OF_MEMORY         2	// Out-of-memory detected
#define TSL_ERROR_OBJECT_GONE			3	// The LaunchServ returned a negative HRESULT.
#define TSL_ERROR_GENERAL               4	// Can't launch a troubleshooter.  There are 
											//	error statuses to be accessed by TSLStatus.
#define TSL_ERROR_NO_NETWORK            5	// Can't identify an appropriate troubleshooting 
											//	network.
#define TSL_ERROR_ILLFORMED_MACHINE_ID  6	// Machine ID is not correctly formed.  Sniffing 
											//	disabled.
#define TSL_ERROR_BAD_MACHINE_ID        7	// A machine ID was specified but can't be used.  
											//	Sniffing disabled.
#define TSL_ERROR_ILLFORMED_DEVINST_ID  8	// Device Instance ID is not correctly formed.
											//	Sniffing disabled.
#define TSL_ERROR_BAD_DEVINST_ID        9	// Device Instance ID was specified but can't be 
											//	used.  Sniffing disabled.
#define TSL_ERROR_UNKNOWN_APP		   10	// An unrecognized application was specified.
#define TSL_ERROR_UNKNOWN_VER		   11	// Unrecognized version (no such version 
											//	associated with application)
#define TSL_ERROR_ASSERTION	           13   // An assertion failed

// The next several errors could be thought of as "hard failures of mapping", but we do not 
//	treat them as hard errors because even if mapping fails totally, we may still be able to
//	launch to a generic troubleshooter.
#define TSL_ERROR_MAP_BAD_SEEK			101	 // failure while seeking in the mapping file.
// Although, at a low level, a bad seek just indicates seeking to an inappropriate file 
//	offset, in practice a bad seek would indicate a serious problem either in the mapping file 
//	or in the code: we should only be seeking to offsets which the contents of the mapping file
//	told us to seek to.
#define TSL_ERROR_MAP_BAD_READ			102	 // failure while reading from the mapping file.
// Although, at a low level, a bad read just indicates (for example) reading past EOF, in 
//	practice a bad read would indicate a serious problem either in the mapping file or in 
//	the code: we should only be reading (1) the header or (2) records which the contents of 
//	the mapping file told us to read.
#define TSL_ERROR_MAP_CANT_OPEN_MAP_FILE 103
#define TSL_ERROR_MAP_BAD_HEAD_MAP_FILE	 104	// failed to read even the header of the map file

// The next several errors should never be seen by applications.  They would mean that the
//	launch server is mis-using the mapping code.
#define TSM_STAT_NEED_VER_TO_SET_DEF_VER 111	// Trying to apply a version default, but you
												//	haven't yet successfully set a version
												//	as a basis to look up the default
#define TSM_STAT_NEED_APP_TO_SET_VER	112		// tried to look up version without previously
												// setting application
#define TSM_STAT_UID_NOT_FOUND			113		// a string could not be mapped to a UID.
												// In the existing TSMapClient class, 
												// this means that the name could not be found
												// in the region of the mapping file where 
												// it belongs (e.g. that a version string is
												// not in the list of versions for the
												// current application.)
												// This should always be turned into something
												// more specific before it is passed to
												// higher-level code.

#define TSL_MIN_WARNING 1000
#define TSL_WARNING_NO_PROBLEM_NODE  1004	// Can't identify an appropriate problem node.  
											//	Troubleshooting will proceed from "first page" 
											//	for this troubleshooting network.
#define TSL_WARNING_NO_NODE          1005	// A state value was specified for a nonexistent 
											//	node 
#define TSL_WARNING_NO_STATE         1006	// A non-existent state value was specified for an 
											//	otherwise valid node.
#define TSL_WARNING_LANGUAGE         1007	// Can't apply specified language to this 
											//	particular problem (no language-appropriate 
											//	troubleshooting network).  Successively default 
											//	to standard language of this machine and to 
											//	English.
#define TSL_WARNING_NO_ONLINE        1008	// Can't obey stated preference for Online 
											//	Troubleshooter
#define TSL_WARNING_ONLINE_ONLY      1009	// Can't obey stated preference against Online 
											//	Troubleshooter
#define TSL_WARNING_GENERAL          1010	// Can launch a troubleshooter, but there are 
											//	warnings to be accessed by TSLStatus.

#define TSL_WARNING_ILLFORMED_DEV_ID 1011	// Device ID is not correctly formed.
#define TSL_WARNING_BAD_DEV_ID       1012	// A correctly formed but invalid device ID
#define TSL_WARNING_ILLFORMED_CLASS_GUID 1013	// Device Class GUID is not correctly formed.
#define TSL_WARNING_BAD_CLASS_GUID       1014	// A correctly formed but invalid device Class GUID
#define TSL_WARNING_UNKNOWN_APPPROBLEM	 1015	// App problem passed in, but this problem 
											//	name is nowhere in the mapping file.
											//	Troubleshooting will proceed on the basis of
											//	device information, ignoring specified problem
#define TSL_WARNING_UNUSED_APPPROBLEM	 1016	// App problem passed in, and the name is
											//	recognized but can't be used in conjunction
											//	with the device information given.
											//	Troubleshooting will proceed on the basis of
											//	device information, ignoring specified problem

#define TSL_W_CONTAINER_WAIT_TIMED_OUT	1017	// The container did not respond within the time 
												//	out value specified in the go method.
#define TSL_WARNING_END_OF_VER_CHAIN	1018	// Should never be seen by the calling app.
											// Indicates that we are at the end of the chain
											// in applying default versions.

#define TSL_MAX_WARNING 1999

// the range 2000-2099 is reserved for internal use by the mapping code.
// statuses in this range should not ever be exposed outside of class TSMapRuntimeAbstract 
// and its subclasses.
#define TSL_MIN_RESERVED_FOR_MAPPING 2000
#define TSL_MAX_RESERVED_FOR_MAPPING 2099

// Errors generated by LaunchServ.  Need to start @ 4,000 to avoid confusion with
// codes returned by the local troubleshooter.
#define TSL_E_CONTAINER_REG		4000	// Could not find the path to hh.exe / iexplore.exe in the registry.
#define TSL_E_CONTAINER_NF		4001	// Found the path to the browser, but it is not at that location.
#define TSL_E_WEB_PAGE_REG		4002	// Could not find the path to the web page in the registry.
#define TSL_E_WEB_PAGE_NF		4003	// Found the path to the web page, but it is not at that location.
#define TSL_E_CREATE_PROC		4004	// Could not create the hh.exe / iexplore.exe process.
#define TSL_E_MEM_EXCESSIVE		4005	// An unexpected amount of memory is required.  i.e. a path name that is longer than MAX_PATH.
#define TSL_E_MAPPING_DB_REG	4006	// Could not find the path to the binary mapping file in the registry.
#define TSL_E_MAPPING_DB_NF		4007	// Found the path to the mapping file, but it is not at that location.
#define TSL_E_NETWORK_REG		4008	// Could not find the path to the network resources (DSZ files).
#define TSL_E_NETWORK_NF		4009	// Could not find a DSC or DSZ file with the network name.
#define TSL_E_NODE_EMP			4010	// A call to set node had a null node name or node state.
#define TSL_E_NO_DEFAULT_NET	4011	// The mapping class failed to get a network and there is not a default network defined in the registry.
#define TSL_E_SNIFF_SCRIPT_REG	4012	// Could not find the path to the sniff script in the registry.
#define TSL_E_COPY_SNIFF_SCRIPT	4013	// Could not create the hh.exe / iexplore.exe process.


inline bool TSLIsHardError(DWORD dwStatus)
{
	return (dwStatus == TSL_ERROR_BAD_HANDLE 
		|| dwStatus == TSL_ERROR_OUT_OF_MEMORY 
		|| dwStatus == TSL_ERROR_OBJECT_GONE);
}

inline bool TSLIsError(DWORD dwStatus) 
{
	return (TSL_OK != dwStatus && dwStatus < TSL_MIN_WARNING || dwStatus > TSL_MAX_WARNING);
}

inline bool TSLIsWarning(DWORD dwStatus) 
{
	return (dwStatus >= TSL_MIN_WARNING && dwStatus <= TSL_MAX_WARNING);
}

#define TSL_E_FAIL		-1
#define TSL_SERV_FAILED(hRes) (FAILED(hRes) && TSL_E_FAIL != hRes)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\server\rsstack.h ===
//
// MODULE: RSSTACK,H
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// 
// ORIGINAL DATE: 8/7/96
//
// NOTES: 
// 1.	A stack of any structure.  Can be used for pointers, but
//		will cause a memory leak when the stack is destroyed with
//		objects on it.
//
// 2.	This file has no .cpp file. Every thing is inline, due to the
//		template class.
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
//

#ifndef __RSSTACK_H_
#define __RSSTACK_H_ 1

template<class T>
class RSStack
{
public:
	RSStack();
 	virtual ~RSStack();
// Attributes
public:

private:
	typedef struct tagRSStackNode
	{
		T SItem;
		struct tagRSStackNode *pNext;
	} RSStackNode;

	RSStackNode *m_pTop;
	RSStackNode *m_pPeak;

// Operations
public:
/*	
	Push returns -1 when out of memory.
*/
int Push(T);
/*
	Pop returns the top T item.
*/
T Pop();
/*
	1 is the top most item in the stack.  Returns the T item at
	tdown index by copying the value to refedItem.  False is returned if 
	tdown is greater than the number of items in the stack.
*/
BOOL GetAt(int tdown, T &refedItem);
/*
	PeakFirst returns the top most item and initializes variables that are
	used by PeakNext.  PeakFirst returns false when the stack is empty.
*/
BOOL PeakFirst(T &refedItem);
/*
	Use PeakNext to quickly peak at all of the items on the stack.
	PeakNext returns false when it can not copy a T item to refedItem.
*/
BOOL PeakNext(T &refedItem);
/*
	Empty returns TRUE (Non-Zero) when the stack is empty.
*/
BOOL Empty();
/*
	RemoveAll throws away the contents of the stack.
*/
void RemoveAll();
};

template<class T>
inline RSStack<T>::RSStack()
{
	m_pTop = NULL;
	m_pPeak = NULL;
}

template<class T>
inline RSStack<T>::~RSStack()
{
	RSStackNode *pOld;
	while(m_pTop != NULL)
	{
		pOld = m_pTop;
		m_pTop = m_pTop->pNext;
		delete pOld;
	}
}

template<class T>
inline int RSStack<T>::Push(T Item)
{
	int Ret;
	RSStackNode *pNew = new RSStackNode;
	if(NULL == pNew)
	{
		Ret = -1;
	}
	else
	{
		Ret = 1;
		pNew->pNext = m_pTop;
		m_pTop = pNew;
		pNew->SItem = Item;
	}
	return Ret;
}

template<class T>
inline T RSStack<T>::Pop()
{
	T Ret;
	if(NULL != m_pTop)
	{
		RSStackNode *pOld = m_pTop;
		m_pTop = m_pTop->pNext;
		Ret = pOld->SItem;
		delete pOld;
	}
	return Ret;
}

template<class T>
inline BOOL RSStack<T>::Empty()
{
	BOOL bRet;
	if(NULL == m_pTop)
		bRet = TRUE;
	else
		bRet = FALSE;
	return bRet;
}

template<class T>
inline void RSStack<T>::RemoveAll()
{
	RSStackNode *pOld;
	while(m_pTop != NULL)
	{
		pOld = m_pTop;
		m_pTop = m_pTop->pNext;
		delete pOld;
	}
}

template<class T>
inline BOOL RSStack<T>::GetAt(int tdown, T &refedItem)
{
	BOOL bRet = FALSE;
	RSStackNode *pNode = m_pTop;
	while(pNode != NULL && tdown > 1)
	{
		pNode = pNode->pNext;
		tdown--;
	}
	if (pNode && 1 == tdown)
	{
		refedItem = pNode->SItem;
		bRet = TRUE;
	}
	return bRet;
}

template<class T>
inline BOOL RSStack<T>::PeakFirst(T &refedItem)
{
	BOOL bRet = FALSE;
	if (NULL != m_pTop)
	{
		m_pPeak = m_pTop;
		refedItem = m_pTop->SItem;
		bRet = TRUE;
	}
	return bRet;
}

template<class T>
inline BOOL RSStack<T>::PeakNext(T &refedItem)
{
	ASSERT(NULL != m_pPeak);
	BOOL bRet = FALSE;
	m_pPeak = m_pPeak->pNext;
	if (NULL != m_pPeak)
	{
		refedItem = m_pPeak->SItem;
		bRet = TRUE;
	}
	return bRet;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\server\stateinfo.h ===
// 
// MODULE: StateInfo.cpp
//
// PURPOSE: Contains sniffing, network and node information.  Also is used
//			by the Launch module to start the container application.
//
// PROJECT: Local Troubleshooter Launcher for the Device Manager
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Richard Meadows
// COMMENTS BY: Joe Mabel
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			RM		Original
///////////////////////

enum ELaunchRegime 
{
	launchIndefinite = 0, 
	launchMap, 
	launchDefaultWebPage, 
	launchDefaultNetwork,
	launchKnownNetwork
};

//  Basically, this is the structure to pass information to the launched 
//	Local Troubleshooter OCX
class CItem
{
public:
	enum { SYM_LEN = 512 };
	enum { NODE_COUNT = 55 };
	enum { GUID_LEN = 256 };		// this is used for other things besides GUIDs, so
									// don't shrink it just because GUIDs are smaller.
public:
	CItem();

	void ReInit();
	void Clear();

	void SetNetwork(LPCTSTR szNetwork);
	void SetProblem(LPCTSTR szProblem);
	void SetNode(LPCTSTR szNode, LPCTSTR szState);
	bool GetNetwork(LPTSTR *pszCmd, LPTSTR *pszVal);
	bool GetProblem(LPTSTR *szCmd, LPTSTR *szVal);
	bool GetNodeState(int iNodeC, LPTSTR *szCmd, LPTSTR *szVal);
	TCHAR m_szEventName[SYM_LEN];		// an arbitrary, unique event name related to this
										//	launch.

	// ProblemSet and NetworkSet are used to query the state of the item.
	bool ProblemSet();
	bool NetworkSet();	

    // Interface to other member variables recponsible for launching
	void SetLaunchRegime(ELaunchRegime eLaunchRegime);
	void SetContainerPathName(TCHAR szContainerPathName[MAX_PATH]);
	void SetWebPage(TCHAR m_szWebPage[MAX_PATH]);
	void SetSniffScriptFile(TCHAR szSniffScriptFile[MAX_PATH]);
	void SetSniffStandardFile(TCHAR szSniffStandardFile[MAX_PATH]);
	ELaunchRegime GetLaunchRegime();
	TCHAR* GetContainerPathName();
	TCHAR* GetWebPage();
	TCHAR* GetSniffScriptFile();
	TCHAR* GetSniffStandardFile();

	// Although the troubleshooting network & problem node are already specified, 
	//	this info is here for sniffing.  That is, the Troubleshooter OCX can get the 
	//	P&P device ID & use it for sniffing purposes.
	TCHAR m_szPNPDeviceID[GUID_LEN];	// Plug & Play Device ID
	TCHAR m_szGuidClass[GUID_LEN];		// Standard text representation of Device Class GUID
	TCHAR m_szMachineID[GUID_LEN];		// Machine name (in format like "\\holmes")
										// Needed so that we can sniff on a remote machine
	TCHAR m_szDeviceInstanceID[GUID_LEN];	// Needed so that we can sniff correct device

protected:

	TCHAR m_szProblemDef[SYM_LEN];		// "TShootProblem", typically used as m_aszCmds[1]
										//		so that m_aszVals[1] is the name of the 
										//		problem node
	TCHAR m_szTypeDef[SYM_LEN];			// "type", typically used as m_aszCmds[0]
										//		so that m_aszVals[0] is the name of the 
										//		troubleshooting belief network
	int m_cNodesSet;					// The number of nodes, other than the problem
										//		node, for which we've set states.

	// The next two arrays are used jointly.  m_aszCmds[i] and m_aszVals[i] are
	//	a name/value pair similar to what would be returned by an HTML form,
	//	although, in practice, the Local Troubleshooter OCX does the work that
	//	(on the Web) would be performed by server-side code.
	// Typically these arrays have m_cNodesSet+2 significant entries (with the first 
	//	2 locations indicating troubleshooting network and problem node).
	// Second dimension is just amount of space for each string.
	TCHAR m_aszCmds[NODE_COUNT][SYM_LEN];
	TCHAR m_aszVals[NODE_COUNT][SYM_LEN];

	TCHAR m_szContainerPathName[MAX_PATH]; // name (possibly full path) of executable intended to start
	TCHAR m_szWebPage[MAX_PATH]; // full path of web page file (possibly default) to start container with
	TCHAR m_szSniffScriptFile[MAX_PATH]; // contains full path and file name of "network"_sniff.htm file
	TCHAR m_szSniffStandardFile[MAX_PATH]; // contains full path and file name of tssniffAsk.htm file

	ELaunchRegime m_eLaunchRegime; // regime of launch
};

class CSMStateInfo
{
	enum { HANDLE_VAL = 1 };
public:		
	CSMStateInfo();
	~CSMStateInfo();
	
	/* Made for the ILaunchTS interface .  */
	HRESULT GetShooterStates(CItem &refLaunchState, DWORD *pdwResult);

	/* Made for the ITShootATL  interface . */
	bool GoGo(DWORD dwTimeOut, CItem &item, DWORD *pdwResult);
	bool GoURL(CItem &item, DWORD *pdwResult);

	/* Made to verify the mapping code. */
	// The ILaunchTS interface uses TestGet directly.
	// The ITShootATL interface uses TestPut indirectly through the CLaunch class.
	// CLaunch does the mapping and then calls TestPut.
	void TestPut(CItem &item);	// Simply copies item to m_Item.
	void TestGet(CItem &item);	// Simply copies m_Item to item.

protected:
	CComCriticalSection m_csGlobalMemory;	// Critical section to protect global
											// memory against simultaneous use by 
											// TSLaunch.DLL & Local Troubleshooter OCX
	CComCriticalSection m_csSingleLaunch;	// Critical section to prevent distinct
											// launches (say, by 2 different applications)
											// from overlapping dangerously.
	CItem m_Item;

	BOOL CreateContainer(CItem &item, LPTSTR szCommand);
	BOOL CopySniffScriptFile(CItem &item);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\about.h ===
// About.hxx : Declaration of CAboutImpl, the implementation
//	of the Snapin's ISnapinAbout interface.
//
// Copyright (c) 1998-1999 Microsoft Corporation

#pragma once		// MSINFO_ABOUT_H

#include "StdAfx.h"

#ifndef IDS_DESCRIPTION
#include "Resource.h"
#endif // IDS_DESCRIPTION

//	This hack is required because we may be building in an environment
//	which doesn't have a late enough version of rpcndr.h
#if		__RPCNDR_H_VERSION__ < 440
#define __RPCNDR_H_VERSION__ 440
#define MIDL_INTERFACE(x)	interface
#endif

#ifndef __mmc_h__
#include <mmc.h>
#endif // __mmc_h__

class CAboutImpl :
	public ISnapinAbout,
	public CComObjectRoot,
	public CComCoClass<CAboutImpl, &CLSID_About>
{
public:
	CAboutImpl() {}
	~CAboutImpl() {}

public:
	DECLARE_REGISTRY(CSystemInfo, _T("MSInfo.About.1"), _T("MSInfo.About"), IDS_DESCRIPTION, THREADFLAGS_BOTH)

	BEGIN_COM_MAP(CAboutImpl)
		COM_INTERFACE_ENTRY(ISnapinAbout)
	END_COM_MAP()

//	ISnapinAbout Interface Members
public:
	STDMETHOD(GetSnapinDescription)(LPOLESTR *lpDescription);
	STDMETHOD(GetProvider)(LPOLESTR *lpProvider);
	STDMETHOD(GetSnapinVersion)(LPOLESTR *lpVersion);
	STDMETHOD(GetSnapinImage)(HICON *hAppIcon);
	STDMETHOD(GetStaticFolderImage)(HBITMAP *hSmallImage,
									HBITMAP *hSmallImageOpen,
									HBITMAP *hLargeImage,
									COLORREF *cLargeMask);

private:
	HRESULT		LoadAboutString(UINT nID, LPOLESTR *lpAboutData);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\server\tsmapclient.cpp ===
// 
// MODULE: TSMapClient.cpp
//
// PURPOSE: Part of launching a Local Troubleshooter from an arbitrary NT5 application
//			Class TSMapClient is available at runtime for mapping from the application's 
//			way of naming a problem to the Troubleshooter's way.
//			Only a single thread should operate on any one object of class TSMapClient.  The object is not
//			threadsafe.
//			In addition to the overtly noted returns, many methods can return a preexisting error.
//			However, if the calling program has wishes to ignore an error and continue, we 
//			recommend an explicit call to inherited method ClearStatus().
//			Note that the mapping file is always strictly SBCS (Single Byte Character Set), but the
//			calls into this code may use Unicode. This file consequently mixes char and TCHAR.
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			JM		Original
///////////////////////


// TSMapClient
//
// AUTHOR: Joe Mabel

#include "stdafx.h"

#include "TSLError.h"
#include "RSSTACK.H"
#include "TSMapAbstract.h"
#include "TSMap.h"
#include "TSMapClient.h"

// uncomment the following line to turn on Joe's hard-core debugging
//#define KDEBUG 1
#ifdef KDEBUG
static HANDLE hDebugFile = INVALID_HANDLE_VALUE;
static DWORD dwBytesWritten;
#include <stdio.h>
#endif


// because the null string is a perfectly valid value for some strings, we reserve an 
//	arbitrary implausible value so we don't get a false cache match on startup.
const char * const szBogus = "**BOGUS**";

// Convert TCHAR *szt to char *sz.  *sz should point to a big enough buffer
//	to contain an SNCS version of *szt.  count indicates the size of buffer *sz.
// returns sz (convenient for use in string functions).
static char* ToSBCS (char * const sz, const TCHAR * szt, size_t count)
{
	if (sz)
	{
		if (count != 0 && !szt)
			sz[0] = '\0';
		else
		{
			#ifdef  _UNICODE
				wcstombs( sz, szt, count );
			#else
				strcpy(sz, szt);
			#endif
		}
	}
	return sz;
}

// Convert char *sz to TCHAR *szt.  *szt should point to a big enough buffer
//	to contain a TCHAR* version of *sz (twice as big if its Unicode).  
//	count indicates the size of buffer *szt.
// returns szt (convenient for use in string functions).
static TCHAR* FromSBCS (TCHAR * const szt, const char * const sz, size_t count)
{
	if (szt)
	{
		if (count != 0 && !sz)
			szt[0] = _T('\0');
		else
		{
			#ifdef  _UNICODE
				mbstowcs( szt, sz, count);
			#else
				strcpy(szt, sz);
			#endif
		}
	}
	return szt;
}

TSMapClient::TSMapClient(const TCHAR * const sztMapFile)
{
	TSMapRuntimeAbstract::TSMapRuntimeAbstract();
	_tcscpy(m_sztMapFile, sztMapFile);
	m_hMapFile = INVALID_HANDLE_VALUE;

	// >>> 1/16/98 we are setting these false until we can arrange to use the same'
	//	collating sequence in SQL Server & in this code.
	m_bAppAlphaOrder = false;
	m_bVerAlphaOrder = false;
	m_bDevIDAlphaOrder = false;
	m_bDevClassGUIDAlphaOrder = false;
	m_bProbAlphaOrder = false;

	Initialize();
	ClearAll();
}

TSMapClient::~TSMapClient()
{
	if (m_hMapFile != INVALID_HANDLE_VALUE)
		CloseHandle(m_hMapFile);
}

// If not already initialized, open the mapping file & read the header
// Note that this is not thread-safe.  Only a single thread should use a given TSMapClient
//	object.
// Return m_dwStatus, which can also be obtained via GetStatus(), inherited from the 
//	parent class.
// Typically, on entry m_dwStatus should be 0 and will be left alone if there are no errors
// Can set m_dwStatus to any of the following values:
//	TSL_ERROR_MAP_CANT_OPEN_MAP_FILE
//	TSL_ERROR_MAP_BAD_HEAD_MAP_FILE
DWORD TSMapClient::Initialize()
{
	static bool bInit = false;
	DWORD dwStatus = 0;

	if (!bInit)
	{
		m_hMapFile = CreateFile( 
			m_sztMapFile, 
			GENERIC_READ, 
			FILE_SHARE_READ,
			NULL,			// no security attributes 
			OPEN_EXISTING, 
			FILE_FLAG_RANDOM_ACCESS, 
			NULL			// handle to template file
			);

		if (m_hMapFile == INVALID_HANDLE_VALUE)
		{
			dwStatus = TSL_ERROR_MAP_CANT_OPEN_MAP_FILE;
		}
		else
		{
			DWORD dwBytesRead;

			if (!Read( &m_header, sizeof(m_header), &dwBytesRead))
				dwStatus = TSL_ERROR_MAP_BAD_HEAD_MAP_FILE;
		}

		if (dwStatus)
			m_dwStatus = dwStatus;
		else
			bInit = true;
	}

	return m_dwStatus;
}

// This function sets us back to a starting state, but has no effect on the mapping
//	file.  It should succeed unless we've encountered a "hard" error, which would indicate
//	a bug either in the code or in the mapping file.  Note that it wipes out the caching.
//	If you want ot leave caching intact, just call inherited method ClearStatus().
// Return m_dwStatus, which can also be obtained via GetStatus(), inherited from the 
//	parent class.  returned value is either 0 or a _preexisting_ hard error we can't clear.
DWORD TSMapClient::ClearAll ()
{
	if (!HardMappingError(m_dwStatus))
	{
		ClearStatus();
		TSMapRuntimeAbstract::ClearAll();

		strcpy(m_szApp, szBogus);
		strcpy(m_appmap.szMapped, szBogus);
		strcpy(m_szVer, szBogus);
		strcpy(m_vermap.szMapped, szBogus);
		strcpy(m_szDevID, szBogus);
		m_uidDev = uidNil;
		strcpy(m_szDevClassGUID, szBogus);
		m_uidDevClass = uidNil;
		strcpy(m_szProb, szBogus);
		m_uidProb = uidNil;
	}

	return m_dwStatus;
}

// Get information about an application (input sztApp) from the mapping file into m_appmap
// Return m_dwStatus, which can also be obtained via GetStatus(), inherited from the 
//	parent class.  
// RETURNS: 0 or TSL_ERROR_UNKNOWN_APP.
// Can also return hard errors:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
// (or preexisting hard error)
DWORD TSMapClient::SetApp (const TCHAR * const sztApp)
{
	char szApp[BUFSIZE];
	bool bFound = false;

	ToSBCS (szApp, sztApp, BUFSIZE);

	if (HardMappingError(m_dwStatus))
		return m_dwStatus;
	else
		ClearStatus();

	if ( strcmp(szApp, m_szApp) )
	{
		// it's not already in the cache; let's try to load it.
		int cmp = 1;		// in alpha order, it's still ahead
		DWORD dwPosition;
		bool bFirstTime = true;

		dwPosition = m_header.dwOffApp;

		while ( 
			!m_dwStatus 
		 && !bFound 
		 && dwPosition < m_header.dwLastOffApp
		 && ! (cmp < 0 && m_bAppAlphaOrder) )
		{
			if (ReadAppMap (m_appmap, dwPosition, bFirstTime) )
			{
				cmp = strcmp(szApp, m_appmap.szMapped);
				bFound = ( cmp == 0 );
			}

			bFirstTime = false;
		}

		if (bFound)
		{
			strcpy( m_szApp, szApp );
			// Different application invalidates the version
			strcpy( m_szVer, szBogus );
		}
		else
			m_dwStatus = TSL_ERROR_UNKNOWN_APP;
	}

	return m_dwStatus;
}

// Get information about a version (input sztVer) from the mapping file into m_vermap.
//	A version makes sense only in the context of an application. 
//	The null string is a valid input value and corresponds to leaving version blank.
// Return m_dwStatus, which can also be obtained via GetStatus(), inherited from the 
//	parent class.
// RETURNS:
//	0 - OK
//	TSM_STAT_NEED_APP_TO_SET_VER
//	TSL_ERROR_UNKNOWN_VER
// Can also return hard errors:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
// (or preexisting hard error)
DWORD TSMapClient::SetVer (const TCHAR * const sztVer)
{
	char szVer[BUFSIZE];
	bool bFound = false;

	ToSBCS (szVer, sztVer, BUFSIZE);

	if (HardMappingError(m_dwStatus))
		return m_dwStatus;
	else
		ClearStatus();

	if ( !strcmp(m_szApp, szBogus) )
	{
		m_dwStatus = TSM_STAT_NEED_APP_TO_SET_VER;
		return m_dwStatus;
	}

	if (strcmp(m_szVer, szVer) )
	{
		// it's not already in the cache; let's try to load it.
		int cmp = 1;		// in alpha order, it's still ahead
		DWORD dwPosition;
		bool bFirstTime = true;

		dwPosition = m_appmap.dwOffVer;

		while ( 
			!m_dwStatus 
		 && !bFound 
		 && dwPosition < m_appmap.dwLastOffVer
		 && ! (cmp < 0 && m_bVerAlphaOrder) )
		{
			if (ReadVerMap (m_vermap, dwPosition, bFirstTime) )
			{
				cmp = strcmp(szVer, m_vermap.szMapped);
				bFound = ( cmp == 0 );
			}

			bFirstTime = false;
		}

		if (bFound)
			strcpy( m_szVer, szVer );
		else
			m_dwStatus = TSL_ERROR_UNKNOWN_VER;
	}

	return m_dwStatus;
}

// INPUT sztProb should be either a problem name or represent a number < 2**16.  In the
//	former case, we look up the UID in the mapping file.  In the latter
//	case, we just translate it to a number to get a problem UID.
//	The null string is a valid input value and corresponds to leaving version blank.  Only
//	makes sense if there is a device (or device class) specified before we try to launch.
// Sets m_uidProb, m_szProb
// Return m_dwStatus, which can also be obtained via GetStatus(), inherited from the 
//	parent class.
// RETURNS:
//	0 - OK
//	TSL_WARNING_UNKNOWN_APPPROBLEM - This is not necessarily bad, and results in setting
//		m_uidProb = uidNil
// Can also return hard errors:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
// (or preexisting hard error)
DWORD TSMapClient::SetProb (const TCHAR * const sztProb)
{
	char szProb[BUFSIZE];
	bool bIsNumber = true;

	ToSBCS (szProb, sztProb, BUFSIZE);

	if (HardMappingError(m_dwStatus))
		return m_dwStatus;
	else
		ClearStatus();

	// Null string is not a number; any string with a non-digit in it is not a number
	if (szProb[0] == '\0')
		bIsNumber = false;
	else
	{
		int i = 0;
		while (szProb[i] != '\0')
			if (! isdigit(szProb[i]))
			{
				bIsNumber = false;
				break;
			}
			else
				i++;
	}

	if (bIsNumber)
		m_uidProb = atoi(szProb);
	else if ( strcmp(szProb, m_szProb) )
	{
		// it's not already in the cache; let's try to load it.
		m_uidProb = GetGenericMapToUID(sztProb, 
			m_header.dwOffProb, m_header.dwLastOffProb, m_bProbAlphaOrder);

		if (m_dwStatus == TSM_STAT_UID_NOT_FOUND)
			m_dwStatus = TSL_WARNING_UNKNOWN_APPPROBLEM;

		if (m_uidProb != uidNil)
			strcpy( m_szProb, szProb );
	}

	return m_dwStatus;
}

// Get information about a device (input sztDevID) from the mapping file into m_appmap.
//	The null string is a valid input value and corresponds to no specified device.
//	Except for Device Manager, this is typical usage.
// Sets m_uidDev, m_szDev
// Return m_dwStatus, which can also be obtained via GetStatus(), inherited from the 
//	parent class.
// RETURNS:
//	0 - OK
//	TSL_WARNING_BAD_DEV_ID -  This is not necessarily bad, and results in setting
//		m_uidDev = uidNil
// Can also return hard errors:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
// (or preexisting hard error)
DWORD TSMapClient::SetDevID (const TCHAR * const sztDevID)
{
	char szDevID[BUFSIZE];

	ToSBCS (szDevID, sztDevID, BUFSIZE);

	if (HardMappingError(m_dwStatus))
		return m_dwStatus;
	else
		ClearStatus();

	if ( strcmp(szDevID, m_szDevID) )
	{
		// it's not already in the cache; let's try to load it.
		m_uidDev = GetGenericMapToUID (sztDevID, 
			m_header.dwOffDevID, m_header.dwLastOffDevID, m_bDevIDAlphaOrder);

		if (m_dwStatus == TSM_STAT_UID_NOT_FOUND)
			m_dwStatus = TSL_WARNING_BAD_DEV_ID;

		if (m_uidDev != uidNil)
			strcpy( m_szDevID, szDevID );
	}

	return m_dwStatus;
}

// Get information about a device class (input sztDevClassGUID) from the mapping file 
//	into m_appmap.
//	The null string is a valid input value and corresponds to no specified device.
//	Except for Device Manager, this is typical usage.
// Sets m_uidDevClass, m_szDevClass
// Return m_dwStatus, which can also be obtained via GetStatus(), inherited from the 
//	parent class.
// RETURNS:
//	0 - OK
//	TSL_WARNING_BAD_CLASS_GUID - This is not necessarily bad, and results in setting
//		m_uidDevClass = uidNil
// Can also return hard errors:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
// (or preexisting hard error)
DWORD TSMapClient::SetDevClassGUID (const TCHAR * const sztDevClassGUID)
{
	char szDevClassGUID[BUFSIZE];

	ToSBCS (szDevClassGUID, sztDevClassGUID, BUFSIZE);

	if (HardMappingError(m_dwStatus))
		return m_dwStatus;
	else
		ClearStatus();

	if ( strcmp(szDevClassGUID, m_szDevClassGUID) )
	{
		// it's not already in the cache; let's try to load it.
		m_uidDevClass = GetGenericMapToUID (sztDevClassGUID, 
			m_header.dwOffDevClass, m_header.dwLastOffDevClass, m_bDevClassGUIDAlphaOrder);

		if (m_dwStatus == TSM_STAT_UID_NOT_FOUND)
			m_dwStatus = TSL_WARNING_BAD_CLASS_GUID;

		if (m_uidDevClass != uidNil)
			strcpy( m_szDevClassGUID, szDevClassGUID );
	}

	return m_dwStatus;
}

// Set troubleshooter (& possibly problem node) on the basis of application, version,
//	problem (ignoring device information).  This is achieved by a lookup in the mapping file
//	on the basis of previously set member values of this object.
// "TSBN" means "Troubleshooter Belief Network" 
// On INPUT, sztTSBN, sztNode must both point to buffers allowing BUFSIZE characters
// OUTPUT: *sztTSBN, *sztNode filled in.  If *sztNode is blank, that means launch to 
//	the problem page of the TSBN with no problem selected.
// Return m_dwStatus, which can also be obtained via GetStatus(), inherited from the 
//	parent class.
// RETURNS:
//	0 - OK
//	TSL_ERROR_NO_NETWORK - Mapping failed
// Can also return hard errors:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
// (or preexisting hard error)
DWORD TSMapClient::FromProbToTS (TCHAR * const sztTSBN, TCHAR * const sztNode )
{
	char szTSBN[BUFSIZE];
	char szNode[BUFSIZE];

	FromSBCS (sztTSBN, "", BUFSIZE);
	FromSBCS (sztNode, "", BUFSIZE);

	if (HardMappingError(m_dwStatus))
		return m_dwStatus;
	else
		ClearStatus();

	if ( m_uidProb == uidNil )
	{
		// Can't do this if m_uidProb is NIL
		m_dwStatus = TSL_ERROR_NO_NETWORK;
		return m_dwStatus;
	}

	DWORD dwPosition;
	bool bFirstTime = true;
	bool bFound = false;
	PROBMAP probmap;

	dwPosition = m_vermap.dwOffProbUID;

	while ( 
		!m_dwStatus 
	 && !bFound 
	 && dwPosition < m_vermap.dwLastOffProbUID )
	{
		if ( ReadProbMap (probmap, dwPosition, bFirstTime) )
		{
			bFound = ( probmap.uidProb == m_uidProb );
		}

		if (probmap.uidProb > m_uidProb)
			break; // we're past it.  No hit.

		bFirstTime = false;
	}

	if (bFound)
	{
		strcpy( szNode, probmap.szProblemNode );
		if (! ReadString (szTSBN, BUFSIZE, probmap.dwOffTSName, TRUE) )
		{
			m_dwStatus = TSL_ERROR_NO_NETWORK;
		}
	}
	else
		m_dwStatus = TSL_ERROR_NO_NETWORK;

	FromSBCS (sztTSBN, szTSBN, BUFSIZE);
	FromSBCS (sztNode, szNode, BUFSIZE);

	return m_dwStatus;
}

// Set troubleshooter (& possibly problem node) on the basis of application, version, device
//	and (optionally) problem.  This is achieved by a lookup in the mapping file on the basis 
//	of previously set member values of this object.
// "TSBN" means "Troubleshooter Belief Network" 
// On INPUT, sztTSBN, sztNode must both point to buffers allowing BUFSIZE characters
// OUTPUT: *sztTSBN, *sztNode filled in.  If *sztNode is blank, that means launch to 
//	the problem page of the TSBN with no problem selected.
// Return m_dwStatus, which can also be obtained via GetStatus(), inherited from the 
//	parent class.
// RETURNS:
//	0 - OK
//	TSL_ERROR_NO_NETWORK - Mapping failed
// Can also return hard errors:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
// (or preexisting hard error)
DWORD TSMapClient::FromDevToTS (TCHAR * const sztTSBN, TCHAR * const sztNode )
{
	char szTSBN[BUFSIZE];
	char szNode[BUFSIZE];

	FromSBCS (sztTSBN, "", BUFSIZE);
	FromSBCS (sztNode, "", BUFSIZE);

	if (HardMappingError(m_dwStatus))
		return m_dwStatus;
	else
		ClearStatus();

	if ( m_uidDev == uidNil )
	{
		// Can't do this if m_uidDev is NIL
		m_dwStatus = TSL_ERROR_NO_NETWORK;
		return m_dwStatus;
	}

	DWORD dwPosition;
	bool bFirstTime = true;
	bool bFoundDev = false;
	bool bFoundProb = false;
	DEVMAP devmap;

	dwPosition = m_vermap.dwOffDevUID;

	// Look in the version-specific list of device-mappings, till we find the right device.
	while ( 
		!m_dwStatus 
	 && !bFoundDev
	 && dwPosition < m_vermap.dwLastOffDevUID )
	{
		if ( ReadDevMap (devmap, dwPosition, bFirstTime) )
		{
			bFoundDev = ( devmap.uidDev == m_uidDev );
		}

		if (devmap.uidDev > m_uidDev)
			break; // we're past it.  No hit.

		bFirstTime = false;
	}

	if ( bFoundDev )
	{
		// The very first one might be the right problem, or we might have to scan through
		//	several mappings for this device before we get the right problem.
		bFoundProb = ( devmap.uidDev == m_uidDev && devmap.uidProb == m_uidProb );
		while ( 
			!m_dwStatus 
		 && !bFoundProb
		 && dwPosition < m_vermap.dwLastOffDevUID )
		{
			if ( ReadDevMap (devmap, dwPosition ) )
			{
				bFoundProb = ( devmap.uidDev == m_uidDev && devmap.uidProb == m_uidProb );
			}

			if ( devmap.uidDev > m_uidDev || devmap.uidProb > m_uidProb )
				break; // we're past it.  No hit.
		}
	}

	if (bFoundProb)
	{
		strcpy( szNode, devmap.szProblemNode );
		if (! ReadString (szTSBN, BUFSIZE, devmap.dwOffTSName, TRUE) )
		{
			m_dwStatus = TSL_ERROR_NO_NETWORK;
		}
	}
	else
		m_dwStatus = TSL_ERROR_NO_NETWORK;

	FromSBCS (sztTSBN, szTSBN, BUFSIZE);
	FromSBCS (sztNode, szNode, BUFSIZE);

	return m_dwStatus;
}

// Set troubleshooter (& possibly problem node) on the basis of application, version, device
//	class and (optionally) problem.  This is achieved by a lookup in the mapping file on 
//	the basis of previously set member values of this object.
// "TSBN" means "Troubleshooter Belief Network" 
// On INPUT, sztTSBN, sztNode must both point to buffers allowing BUFSIZE characters
// OUTPUT: *sztTSBN, *sztNode filled in.  If *sztNode is blank, that means launch to 
//	the problem page of the TSBN with no problem selected.
// Return m_dwStatus, which can also be obtained via GetStatus(), inherited from the 
//	parent class.
// RETURNS:
//	0 - OK
//	TSL_ERROR_NO_NETWORK - Mapping failed
// Can also return hard errors:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
// (or preexisting hard error)
// >>> There is probably some way to share common code with FromDevToTS()
DWORD TSMapClient::FromDevClassToTS (TCHAR * const sztTSBN, TCHAR * const sztNode )
{
	char szTSBN[BUFSIZE];
	char szNode[BUFSIZE];

	FromSBCS (sztTSBN, "", BUFSIZE);
	FromSBCS (sztNode, "", BUFSIZE);

	if (HardMappingError(m_dwStatus))
		return m_dwStatus;
	else
		ClearStatus();

#ifdef KDEBUG
	char* szStart = "START\n";
	char* szEnd = "END\n";
	char sz[150];
	hDebugFile = CreateFile(
		(m_uidProb == uidNil) ? _T("k0debug.txt") : _T("k1debug.txt"),  
		GENERIC_WRITE, 
		FILE_SHARE_READ, 
		NULL, 
		CREATE_ALWAYS,
		FILE_ATTRIBUTE_NORMAL,
		NULL);
	WriteFile( 
		hDebugFile, 
		szStart, 
		strlen(szStart),
		&dwBytesWritten,
		NULL);
	sprintf (sz, "look for DevClassUID %d, ProbUID %d\n", m_uidDevClass, m_uidProb);
	WriteFile( 
		hDebugFile, 
		sz, 
		strlen(sz),
		&dwBytesWritten,
		NULL);
#endif

	if ( m_uidDevClass == uidNil )
	{
		// Can't do this if m_uidDevClass is NIL
		m_dwStatus = TSL_ERROR_NO_NETWORK;
		return m_dwStatus;
	}

	DWORD dwPosition;
	bool bFirstTime = true;
	bool bFoundDevClass = false;
	bool bFoundProb = false;
	DEVCLASSMAP devclassmap;

	dwPosition = m_vermap.dwOffDevClassUID;

	// Look in the version-specific list of device-class-mappings, till we find the right device class.
	while ( 
		!m_dwStatus 
	 && !bFoundDevClass
	 && dwPosition < m_vermap.dwLastOffDevClassUID )
	{
		if ( ReadDevClassMap (devclassmap, dwPosition, bFirstTime) )
		{
			bFoundDevClass = ( devclassmap.uidDevClass == m_uidDevClass );
		}

		if (devclassmap.uidDevClass > m_uidDevClass)
			break; // we're past it.  No hit.

		bFirstTime = false;
	}

	if ( bFoundDevClass )
	{
#ifdef KDEBUG
	sprintf (sz, "found DevClassUID %d w/ ProbUID %d\n", m_uidDevClass, devclassmap.uidProb);
	WriteFile( 
		hDebugFile, 
		sz, 
		strlen(sz),
		&dwBytesWritten,
		NULL);
#endif
		// The very first one might be the right problem, or we might have to scan through
		//	several mappings for this device class before we get the right problem.
		bFoundProb = ( devclassmap.uidDevClass == m_uidDevClass && devclassmap.uidProb == m_uidProb );
		while ( 
			!m_dwStatus 
		 && !bFoundProb
		 && dwPosition < m_vermap.dwLastOffDevClassUID )
		{
			if ( ReadDevClassMap (devclassmap, dwPosition) )
			{
				bFoundProb = ( devclassmap.uidDevClass == m_uidDevClass && devclassmap.uidProb == m_uidProb );
			}

			if ( devclassmap.uidDevClass > m_uidDevClass || devclassmap.uidProb > m_uidProb )
				break; // we're past it.  No hit.

#ifdef KDEBUG
			sprintf (sz, "found DevClassUID %d w/ ProbUID %d\n", m_uidDevClass, devclassmap.uidProb);
			WriteFile( 
				hDebugFile, 
				sz, 
				strlen(sz),
				&dwBytesWritten,
				NULL);
#endif

		}
	}

	if (bFoundProb)
	{
#ifdef KDEBUG
			sprintf (sz, "found right problem");
			WriteFile( 
				hDebugFile, 
				sz, 
				strlen(sz),
				&dwBytesWritten,
				NULL);
#endif
		strcpy( szNode, devclassmap.szProblemNode );
		if (! ReadString (szTSBN, BUFSIZE, devclassmap.dwOffTSName, TRUE) )
		{
			m_dwStatus = TSL_ERROR_NO_NETWORK;
#ifdef KDEBUG
			sprintf (sz, ", but can't read its name\n");
			WriteFile( 
				hDebugFile, 
				sz, 
				strlen(sz),
				&dwBytesWritten,
				NULL);
#endif
		}
		else
		{
#ifdef KDEBUG
			sprintf (sz, ": net [%s] node [%s]\n", szTSBN, szNode);
			WriteFile( 
				hDebugFile, 
				sz, 
				strlen(sz),
				&dwBytesWritten,
				NULL);
#endif
		}
	}
	else
	{
		m_dwStatus = TSL_ERROR_NO_NETWORK;
#ifdef KDEBUG
		sprintf (sz, "No match");
		WriteFile( 
			hDebugFile, 
			sz, 
			strlen(sz),
			&dwBytesWritten,
			NULL);
#endif
	}

	FromSBCS (sztTSBN, szTSBN, BUFSIZE);
	FromSBCS (sztNode, szNode, BUFSIZE);

	return m_dwStatus;
#ifdef KDEBUG
	CloseHandle(hDebugFile);
	hDebugFile = INVALID_HANDLE_VALUE;
#endif
}

// To be used after we have failed to find a mapping for the currently selected version.
//	Each version can specify a version to try as a default, including the "blank" version,
//	which is distinct from "no version".
// The last version in a chain of defaults will "default" to uidNil: "no version".
// Return m_dwStatus, which can also be obtained via GetStatus(), inherited from the 
//	parent class.  
// RETURNS:
//	0 - OK
//	TSL_WARNING_END_OF_VER_CHAIN - OK, but there's nothing to default to.
//	TSM_STAT_NEED_APP_TO_SET_VER
//	TSM_STAT_NEED_VER_TO_SET_VER - there was no version set, so no basis for a default
//	TSL_ERROR_UNKNOWN_VER
// Can also return hard errors:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
// (or preexisting hard error)
DWORD TSMapClient::ApplyDefaultVer()
{
	bool bFound = false;

	if (HardMappingError(m_dwStatus))
		return m_dwStatus;
	else
		ClearStatus();

	if ( !strcmp(m_szApp, szBogus) )
	{
		m_dwStatus = TSM_STAT_NEED_APP_TO_SET_VER;
		return m_dwStatus;
	}

	if ( !strcmp(m_szVer, szBogus) )
	{
		m_dwStatus = TSM_STAT_NEED_VER_TO_SET_DEF_VER;
		return m_dwStatus;
	}
	
	DWORD dwPosition;
	bool bFirstTime = true;
	UID uidDefault = m_vermap.uidDefault;

	if (uidDefault == uidNil)
	{
		m_dwStatus =  TSL_WARNING_END_OF_VER_CHAIN;
		return m_dwStatus;
	}

	dwPosition = m_appmap.dwOffVer;

	while ( 
		!m_dwStatus 
	 && !bFound 
	 && dwPosition < m_appmap.dwLastOffVer )
	{
		if (ReadVerMap (m_vermap, dwPosition, bFirstTime) )
		{
			bFound = ( m_vermap.uid == uidDefault );
		}

		bFirstTime = false;
	}

	if (bFound)		
		strcpy( m_szVer, m_vermap.szMapped );
	else
		m_dwStatus = TSL_ERROR_UNKNOWN_VER;

	return m_dwStatus;
}

// Within a particular range of the mapping file, read UIDMAP records to try to map from 
//	input sztName to a UID.
// Return resulting UID, including possibly UidNil
// Sets m_dwStatus, which can be obtained via GetStatus(), inherited from the parent class.
// Can set m_dwStatus to:
//	0 - OK
//	TSM_STAT_UID_NOT_FOUND
// Can also set m_dwStatus to hard errors:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
// (or may be left reflecting a preexisting hard error)
UID TSMapClient::GetGenericMapToUID (const TCHAR * const sztName, 
						DWORD dwOffFirst, DWORD dwOffLast,
						bool bAlphaOrder)
{
	char szName[BUFSIZE];
	DWORD dwPosition;
	UIDMAP uidmap;
	bool bFirstTime = true;
	bool bFound = false;

	ToSBCS (szName, sztName, BUFSIZE);

	if (HardMappingError(m_dwStatus))
		return m_dwStatus;
	else
		ClearStatus();

	dwPosition = dwOffFirst;

	while ( !m_dwStatus && !bFound && dwPosition < dwOffLast)
	{
		if (ReadUIDMap (uidmap, dwPosition, bFirstTime) )
		{
			int cmp = strcmp(szName, uidmap.szMapped);
			bFound = ( cmp == 0 );
			if ( cmp < 0 && bAlphaOrder )
				// relying here on alphabetical order; we've passed what we're looking for
				break;
		}
		else
		{
			m_dwStatus = TSM_STAT_UID_NOT_FOUND;
		}

		bFirstTime = false;
	}

	if (bFound)
		return uidmap.uid;
	else
	{
		m_dwStatus = TSM_STAT_UID_NOT_FOUND;
		return uidNil;
	}
}


// ------------------- utility functions ------------------------ 
// I/O, wrapped the way we are using it.

// SetFilePointerAbsolute sets map file to a location & returns that location if successful
//	returns -1 and sets m_dwStatus on failure
// Sets m_dwStatus, which can be obtained via GetStatus(), inherited from the parent class.
// Although, in theory, a bad seek just indicates a bad dwMoveTo value, in practice
//	a bad seek would indicate a serious problem either in the mapping file or in the calling
//	function: we should only be seeking to offsets which the contents of the mapping file
//	told us to seek to.
// RETURNS:
//	0 - OK
//	TSL_ERROR_MAP_BAD_SEEK
DWORD TSMapClient::SetFilePointerAbsolute( DWORD dwMoveTo )
{
	DWORD dwPosition = SetFilePointer(m_hMapFile, dwMoveTo, NULL, FILE_BEGIN);

	if( dwPosition != dwMoveTo)
	{
		// >>> could call GetLastError, but what do we do with it?
		m_dwStatus= TSL_ERROR_MAP_BAD_SEEK;
		dwPosition = -1;
	}

	return dwPosition;
}

// Low-level read n bytes.  Calls Win32 function ReadFile.
// Read from map file into lpBuffer
//	returns true if requested # of bytes are read
//	Returns false and sets m_dwStatus on failure
// Although, in theory, a bad read just indicates (for example) reading past EOF, in practice
//	a bad read would indicate a serious problem either in the mapping file or in the calling
//	function: we should only be reading (1) the header or (2) records which the contents of 
//	the mapping file told us to read.
// RETURNS:
//	0 - OK
//	TSL_ERROR_MAP_BAD_READ
//	TSL_ERROR_MAP_BAD_SEEK
bool TSMapClient::Read(LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpdwBytesRead)
{
	if (! ReadFile( m_hMapFile, lpBuffer, nNumberOfBytesToRead, lpdwBytesRead, NULL)
	|| *lpdwBytesRead != nNumberOfBytesToRead )
	{
		// >>> On ReadFile returning false, could call GetLastError, 
		//	but what do we do with it?
		m_dwStatus= TSL_ERROR_MAP_BAD_READ;
		return false;
	}
	return true;
}

// Read a single UIDMAP from the mapping file (maps text to a UID)
// If INPUT bSetPosition == true, use INPUT dwPosition to position the file before reading.
//	Otherwise, dwPosition is assumed to be the correct file position at time of input.
// OUTPUT uidmap
// RETURNS true on success
// On failure, returns false & sets m_dwStatus:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
bool TSMapClient::ReadUIDMap (UIDMAP &uidmap, DWORD &dwPosition, bool bSetPosition)
{
	if (! bSetPosition || (SetFilePointerAbsolute(dwPosition) != -1) )
	{
		DWORD dwBytesRead;
		BOOL ret;

		// First just read the byte count, then the rest
		ret = Read( &uidmap, sizeof(short), &dwBytesRead);
		if ( ret )
		{
			// The first argument below may be a bit confusing. We take a pointer to
			//	the byte count (a short*) then increment it to point immediately past the
			//	byte count.  Note that "+1" adds not "1 byte" but "1*sizeof(short)".
			ret = Read( (&(uidmap.cb))+1, uidmap.cb - sizeof(short), &dwBytesRead);
			if ( ret )
			{
				dwPosition += uidmap.cb;
				return true;
			}
		}
	} 

	return false;
}

// Read a single APPMAP from the mapping file (contains info about an application)
// If INPUT bSetPosition == true, use INPUT dwPosition to position the file before reading.
//	Otherwise, dwPosition is assumed to be the correct file position at time of input.
// OUTPUT appmap
// RETURNS true on success
// On failure, returns false & sets m_dwStatus:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
bool TSMapClient::ReadAppMap (APPMAP &appmap, DWORD &dwPosition, bool bSetPosition)
{
	if (! bSetPosition || (SetFilePointerAbsolute(dwPosition) != -1) )
	{
		DWORD dwBytesRead;
		BOOL ret;

		// First just read the byte count, then the rest
		ret = Read( &appmap, sizeof(short), &dwBytesRead);
		if ( ret )
		{
			// The first argument below may be a bit confusing. We take a pointer to
			//	the byte count (a short*) then increment it to point immediately past the
			//	byte count.  Note that "+1" adds not "1 byte" but "1*sizeof(short)".
			ret = Read( (&(appmap.cb))+1, appmap.cb - sizeof(short), &dwBytesRead);
			if ( ret )
			{
				dwPosition += appmap.cb;
				return true;
			}
		}
	} 

	return false;
}

// Read a single VERMAP from the mapping file (contains info about a version)
// If INPUT bSetPosition == true, use INPUT dwPosition to position the file before reading.
//	Otherwise, dwPosition is assumed to be the correct file position at time of input.
// OUTPUT vermap
// RETURNS true on success
// On failure, returns false & sets m_dwStatus:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
bool TSMapClient::ReadVerMap (VERMAP &vermap, DWORD &dwPosition, bool bSetPosition)
{
	if (! bSetPosition || (SetFilePointerAbsolute(dwPosition) != -1) )
	{
		DWORD dwBytesRead;
		BOOL ret;

		// First just read the byte count, then the rest
		ret = Read( &vermap, sizeof(short), &dwBytesRead);
		if ( ret )
		{
			// The first argument below may be a bit confusing. We take a pointer to
			//	the byte count (a short*) then increment it to point immediately past the
			//	byte count.  Note that "+1" adds not "1 byte" but "1*sizeof(short)".
			ret = Read( (&(vermap.cb))+1, vermap.cb - sizeof(short), &dwBytesRead);
			if ( ret )
			{
				dwPosition += vermap.cb;
				return true;
			}
		}
	} 

	return false;
}

// Read a single PROBMAP from the mapping file (contains a mapping for use by FromProbToTS())
// If INPUT bSetPosition == true, use INPUT dwPosition to position the file before reading.
//	Otherwise, dwPosition is assumed to be the correct file position at time of input.
// OUTPUT vermap
// RETURNS true on success
// On failure, returns false & sets m_dwStatus:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
bool TSMapClient::ReadProbMap (PROBMAP &probmap, DWORD &dwPosition, bool bSetPosition)
{
	if (! bSetPosition || (SetFilePointerAbsolute(dwPosition) != -1) )
	{
		DWORD dwBytesRead;
		BOOL ret;

		// First just read the byte count, then the rest
		ret = Read( &probmap, sizeof(short), &dwBytesRead);
		if ( ret )
		{
			// The first argument below may be a bit confusing. We take a pointer to
			//	the byte count (a short*) then increment it to point immediately past the
			//	byte count.  Note that "+1" adds not "1 byte" but "1*sizeof(short)".
			ret = Read( (&(probmap.cb))+1, probmap.cb - sizeof(short), &dwBytesRead);
			if ( ret )
			{
				dwPosition += probmap.cb;
				return true;
			}
		}
	} 

	return false;
}

// Read a single DEVMAP from the mapping file (contains a mapping for use by FromDevToTS())
// If INPUT bSetPosition == true, use INPUT dwPosition to position the file before reading.
//	Otherwise, dwPosition is assumed to be the correct file position at time of input.
// OUTPUT vermap
// RETURNS true on success
// On failure, returns false & sets m_dwStatus:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
bool TSMapClient::ReadDevMap (DEVMAP &devmap, DWORD &dwPosition, bool bSetPosition)
{
	if (! bSetPosition || (SetFilePointerAbsolute(dwPosition) != -1) )
	{
		DWORD dwBytesRead;
		BOOL ret;

		// First just read the byte count, then the rest
		ret = Read( &devmap, sizeof(short), &dwBytesRead);
		if ( ret )
		{
			// The first argument below may be a bit confusing. We take a pointer to
			//	the byte count (a short*) then increment it to point immediately past the
			//	byte count.  Note that "+1" adds not "1 byte" but "1*sizeof(short)".
			ret = Read( (&(devmap.cb))+1, devmap.cb - sizeof(short), &dwBytesRead);
			if ( ret )
			{
				dwPosition += devmap.cb;
				return true;
			}
		}
	} 

	return false;
}

// Read a single DEVCLASSMAP from the mapping file (contains a mapping for use by 
//	FromDevClassToTS())
// If INPUT bSetPosition == true, use INPUT dwPosition to position the file before reading.
//	Otherwise, dwPosition is assumed to be the correct file position at time of input.
// OUTPUT vermap
// RETURNS true on success
// On failure, returns false & sets m_dwStatus:
//	TSL_ERROR_MAP_BAD_SEEK
//	TSL_ERROR_MAP_BAD_READ
bool TSMapClient::ReadDevClassMap (DEVCLASSMAP &devclassmap, DWORD &dwPosition, bool bSetPosition)
{
	if (! bSetPosition || (SetFilePointerAbsolute(dwPosition) != -1) )
	{
		DWORD dwBytesRead;
		BOOL ret;

		// First just read the byte count, then the rest
		ret = Read( &devclassmap, sizeof(short), &dwBytesRead);
		if ( ret )
		{
			// The first argument below may be a bit confusing. We take a pointer to
			//	the byte count (a short*) then increment it to point immediately past the
			//	byte count.  Note that "+1" adds not "1 byte" but "1*sizeof(short)".
			ret = Read( (&(devclassmap.cb))+1, devclassmap.cb - sizeof(short), &dwBytesRead);
			if ( ret )
			{
				dwPosition += devclassmap.cb;
				return true;
			}
		}
	} 

	return false;
}

// Low-level read a null-terminated string.  Calls Win32 function ReadFile.
// If INPUT bSetPosition == true, use INPUT dwPosition to position the file before reading.
//	Otherwise, dwPosition is assumed to be the correct file position at time of input.
// INPUT chMax is maximum # of bytes (not necessarily characters) to read.  The last character
//	will not actually be read: a null character will always be imposed.
// OUTPUT vermap
// RETURNS true on success
// On failure, returns false & sets m_dwStatus:
//	TSL_ERROR_MAP_BAD_SEEK
// Note that on completion the file position is unreliable.  It is based on the size of the 
//	buffer passed in, not the actual string.
bool TSMapClient::ReadString (char * sz, DWORD cbMax, DWORD &dwPosition, bool bSetPosition)
{
	DWORD dwBytesRead;



	if (! bSetPosition || (SetFilePointerAbsolute(dwPosition) != -1) )
	{
		if (cbMax == 0)
			return true;

		if ( cbMax == 1 || ReadFile( m_hMapFile, sz, cbMax-1, &dwBytesRead, NULL) )
		{
			sz[cbMax-1] = '\0';
			return true;
		}
	} 

	return false;
}

// Once one of these errors has occurred, we consider recovery impossible, except by closing
//	this object and opening a new one.
// Although, in theory, a bad seek or read just indicates bad arguments
//	to the relevant function, in practice a bad seek or read would indicate 
//	a serious problem either in the mapping file or in the calling
//	function: beyond the header, we should only be seeking to and reading 
//	from offsets which the contents of the mapping file old us to seek/read.
bool TSMapClient::HardMappingError (DWORD dwStatus)
{
	if (TSMapRuntimeAbstract::HardMappingError(dwStatus))
		return true;
	else
		switch (dwStatus)
		{
			case TSL_ERROR_MAP_BAD_SEEK:
			case TSL_ERROR_MAP_BAD_READ:
			case TSL_ERROR_MAP_CANT_OPEN_MAP_FILE:
			case TSL_ERROR_MAP_BAD_HEAD_MAP_FILE:
				return true;
			default:
				return false;
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\server\tsmapabstract.cpp ===
// 
// MODULE: TSMapAbstract.cpp
//
// PURPOSE: Part of launching a Local Troubleshooter from an arbitrary NT5 application
//			Data types and abstract classes for mapping from the application's way of naming 
//			a problem to the Troubleshooter's way.
//			Implements the few concrete methods of abstract base class TSMapRuntimeAbstract.
//
// COMPANY: Saltmine Creative, Inc. (206)-633-4743 support@saltmine.com
//
// AUTHOR: Joe Mabel
// 
// ORIGINAL DATE: 2-26-98
//
//
// Version	Date		By		Comments
//--------------------------------------------------------------------
// V0.1		-			JM		Original
///////////////////////


#include "stdafx.h"
#include "TSLError.h"
#include "RSSTACK.H"
#include "TSMapAbstract.h"

TSMapRuntimeAbstract::TSMapRuntimeAbstract()
{
	m_dwStatus= 0;
}

TSMapRuntimeAbstract::~TSMapRuntimeAbstract()
{
}

DWORD TSMapRuntimeAbstract::ClearAll()
{
	m_stkStatus.RemoveAll();
	return 0;
}

// Given application, version, & problem, return troubleshooter & (optionally) problem node
// In order to succeed:
//	- application must be an application known in the mapping file
//	- version must be a known version of that application (including an empty string for
//		the "blank version"
//	- problem must be the name or number of a defined problem either for that application 
//		and version or for that application and some version down the chain of version 
//		defaults.
// May return 
//	0 (OK) 
//	TSL_ERROR_UNKNOWN_APP
//	TSL_ERROR_UNKNOWN_VER
//	TSL_WARNING_UNKNOWN_APPPROBLEM - couldn't find a UID for this problem, so we can't 
//		do this mapping
//	TSL_ERROR_NO_NETWORK - even after applying all default versions, there is no mapping.
//	May also return a hard mapping error specific to the implementation of the concrete class
DWORD TSMapRuntimeAbstract::FromAppVerProbToTS (
	const TCHAR * const szApp, const TCHAR * const szVer, const TCHAR * const szProb, 
	TCHAR * const szTSBN, TCHAR * const szNode)
{
	if ( SetApp (szApp) == 0 && SetVer (szVer) == 0 && SetProb (szProb) == 0)
	{
		while ( FromProbToTS (szTSBN, szNode) == TSL_ERROR_NO_NETWORK
		&& ApplyDefaultVer() == 0 )
		{
			// do nothing; it's all in the while-condition
		}
	}

	return m_dwStatus;
}

// Given application, version, device ID & (optionally) problem, return troubleshooter 
//	& (independently optional) problem node 
// In order to succeed:
//	- application & version as in TSMapRuntimeAbstract::FromAppVerProbToTS
//	- the Device ID/Problem pair must be defined either for that application and version 
//		or for that application and some version down the chain of version defaults.
//		The szProb may be an empty string, meaning we want the mapping for this device and
//		no specified problem.
// May return 
//	0 (OK) 
//	TSL_ERROR_UNKNOWN_APP
//	TSL_ERROR_UNKNOWN_VER
//	TSL_WARNING_UNKNOWN_APPPROBLEM - couldn't find a UID for this problem, so we can't 
//		do this mapping.  Note that there if there are any defined mappings independent of
//		problem, there will be a UID for the null string as a problem name.  That will 
//		not yield a warning.  That's just dandy.
//	TSL_WARNING_BAD_DEV_ID - couldn't find a UID for this device, so we can't 
//			do this mapping 
//	TSL_ERROR_NO_NETWORK - even after applying all default versions, there is no mapping.
//	May also return a hard mapping error specific to the implementation of the concrete class
DWORD TSMapRuntimeAbstract::FromAppVerDevIDToTS (
		const TCHAR * const szApp, const TCHAR * const szVer, 
		const TCHAR * const szDevID, const TCHAR * const szProb, 
		TCHAR * const szTSBN, TCHAR * const szNode)
{
	if ( SetApp (szApp) == 0 && SetVer (szVer) == 0 
	&& SetDevID (szDevID) == 0 && SetProb (szProb) == 0 )
	{
		while ( FromDevToTS (szTSBN, szNode) == TSL_ERROR_NO_NETWORK
		&& ApplyDefaultVer() == 0 )
		{
			// do nothing; it's all in the while-condition
		}
	}

	return m_dwStatus;
}

// Given application, version, Device Class GUID & (optionally) problem, return troubleshooter 
//	& (independently optional) problem node 
// In order to succeed:
//	- application & version as in TSMapRuntimeAbstract::FromAppVerProbToTS
//	- the Device Class GUID/Problem pair must be defined either for that application and version 
//		or for that application and some version down the chain of version defaults.
//		The szProb may be an empty string, meaning we want the mapping for this device and
//		no specified problem.
// May return 
//	0 (OK) 
//	TSL_ERROR_UNKNOWN_APP
//	TSL_ERROR_UNKNOWN_VER
//	TSL_WARNING_UNKNOWN_APPPROBLEM - couldn't find a UID for this problem, so we can't 
//		do this mapping.  Note that there if there are any defined mappings independent of
//		problem, there will be a UID for the null string as a problem name.  That will 
//		not yield a warning.  That's just dandy.
//	TSL_WARNING_BAD_CLASS_GUID - couldn't find a UID for this Device Class GUID, so we can't 
//			do this mapping 
//	TSL_ERROR_NO_NETWORK - even after applying all default versions, there is no mapping.
//	May also return a hard mapping error specific to the implementation of the concrete class
DWORD TSMapRuntimeAbstract::FromAppVerDevClassGUIDToTS (
		const TCHAR * const szApp, const TCHAR * const szVer, 
		const TCHAR * const szDevClassGUID, const TCHAR * const szProb, 
		TCHAR * const szTSBN, TCHAR * const szNode)
{
	if ( SetApp (szApp) == 0 && SetVer (szVer) == 0 
	&& SetDevClassGUID (szDevClassGUID) == 0 && SetProb (szProb) == 0 )
	{
		while ( FromDevClassToTS (szTSBN, szNode) == TSL_ERROR_NO_NETWORK
		&& ApplyDefaultVer() == 0 )
		{
			// do nothing; it's all in the while-condition
		}
	}

	return m_dwStatus;
}

// Given application, version, & at least one of
//	- problem
//	- device ID
//	- device class GUID
//	return troubleshooter & (optionally) problem node
// In order to succeed:
//	- application must be an application known in the mapping file
//	- version must be a known version of that application (including an empty string for
//		the "blank version"
//	- There must be a mapping defined either for this problem, device ID, or device class 
//		GUID alone, or for the combination of the problem & either the device ID or the
//		device class GUID, in conjunction with either that application and version 
//		or for that application and some version down the chain of version defaults.
// If there is more than one possible match, the algorithm dictates the following 
//	priorities:
//	  If there is an szProblem :
//		1. szProblem with no associated device information (the "standard" mapping) 
//		2. szProblem and szDeviceID
//		3. szProblem and pguidClass
//		4. szDeviceID with no associated problem
//		5. pguidClass with no associated problem
//	  Otherwise
//		1. szDeviceID with no associated problem
//		2. pguidClass with no associated problem
//	  Within each of these groupings, we follow up version defaults before we try the 
//		next grouping.
// May return 
//	0 (OK) 
//	TSL_ERROR_UNKNOWN_APP
//	TSL_ERROR_UNKNOWN_VER
//	TSL_ERROR_NO_NETWORK - even after applying all default versions, there is no mapping.
//	May also return a hard mapping error specific to the implementation of the concrete class
// In the case where we return 0 (OK) or TSL_ERROR_NO_NETWORK, the caller will want to consult
//	MoreStatus() for more detailed errors/warnings.  In the other cases, the returned status
//	overwhelms any possible interest in other errors/warnings.
DWORD TSMapRuntimeAbstract::FromAppVerDevAndClassToTS (
		const TCHAR * const szApp, const TCHAR * const szVer, 
		const TCHAR * const szDevID, const TCHAR * const szDevClassGUID, 
		const TCHAR * const szProb, 
		TCHAR * const szTSBN, TCHAR * const szNode)
{
	UID uidProb = uidNil;

	// keep some status info around so we don't ever notify of the same problem twice
	bool bBadProb = false;
	bool bCantUseProb = false;
	bool bBadDev = false;
	bool bBadDevClass = false;

	if (! HardMappingError (m_dwStatus) )
		ClearAll();

	if (! m_dwStatus)
	{
		if (szProb && *szProb)
		{
			// try problem name without device info.
			m_dwStatus = FromAppVerProbToTS (szApp, szVer, szProb, szTSBN, szNode);
			bBadProb = (m_dwStatus == TSL_WARNING_UNKNOWN_APPPROBLEM);

			if (DifferentMappingCouldWork (m_dwStatus))
			{
				// try the device ID + problem
				m_dwStatus = FromAppVerDevIDToTS (szApp, szVer, szDevID, szProb, 
													szTSBN, szNode);
				bBadDev = (m_dwStatus == TSL_WARNING_BAD_DEV_ID);
			}

			if (DifferentMappingCouldWork (m_dwStatus))
			{
				// try the device class GUID + problem
				m_dwStatus = FromAppVerDevClassGUIDToTS (szApp, szVer, szDevClassGUID, szProb, 
													szTSBN, szNode);
				bBadDevClass = (m_dwStatus == TSL_WARNING_BAD_CLASS_GUID);
			}

			// If we're still trying to map it, we couldn't make use of the problem name
			bCantUseProb = (DifferentMappingCouldWork(m_dwStatus));
		}
		else
			m_dwStatus = TSL_ERROR_NO_NETWORK;

		if (DifferentMappingCouldWork (m_dwStatus))
		{
			// try the device ID alone
			m_dwStatus = FromAppVerDevIDToTS (szApp, szVer, szDevID, NULL, szTSBN, szNode);
			bBadDev |= (m_dwStatus == TSL_WARNING_BAD_DEV_ID);
		}

		if (DifferentMappingCouldWork (m_dwStatus))
		{
			// try the device class GUID alone
			m_dwStatus = FromAppVerDevClassGUIDToTS (szApp, szVer, szDevClassGUID, NULL, 
												szTSBN, szNode);
			bBadDevClass |= (m_dwStatus == TSL_WARNING_BAD_CLASS_GUID);
		}

		if (DifferentMappingCouldWork(m_dwStatus))
			m_dwStatus = TSL_ERROR_NO_NETWORK;

	}

	if (bBadProb 
	&& AddMoreStatus(TSL_WARNING_UNKNOWN_APPPROBLEM) == TSL_ERROR_OUT_OF_MEMORY)
		m_dwStatus = TSL_ERROR_OUT_OF_MEMORY;

	if (bCantUseProb && !bBadProb
	&& AddMoreStatus(TSL_WARNING_UNUSED_APPPROBLEM) == TSL_ERROR_OUT_OF_MEMORY)
		m_dwStatus = TSL_ERROR_OUT_OF_MEMORY;

	if (bBadDev 
	&& AddMoreStatus(TSL_WARNING_BAD_DEV_ID) == TSL_ERROR_OUT_OF_MEMORY)
		m_dwStatus = TSL_ERROR_OUT_OF_MEMORY;

	if (bBadDevClass
	&& AddMoreStatus(TSL_WARNING_BAD_CLASS_GUID) == TSL_ERROR_OUT_OF_MEMORY)
		m_dwStatus = TSL_ERROR_OUT_OF_MEMORY;

	return m_dwStatus;
}

// certain statuses are "basically healthy" returns, meaning, "no, this particular mapping
//	doesn't exist, but there's nothing here to rule out the possibility of another mapping."
//	Those return true on this function.  
//	Note that dwStatus == 0 (OK) returns false because
//	if we already had a successful mapping, we don't want to try another.
bool TSMapRuntimeAbstract::DifferentMappingCouldWork (DWORD dwStatus)
{
	switch (dwStatus)
	{
		case TSL_ERROR_NO_NETWORK:
		case TSL_WARNING_BAD_DEV_ID:
		case TSL_WARNING_BAD_CLASS_GUID:
		case TSL_WARNING_UNKNOWN_APPPROBLEM:
		case TSM_STAT_UID_NOT_FOUND:
		case TSL_WARNING_END_OF_VER_CHAIN:
			return true;
		default:
			return false;
	}
}

bool TSMapRuntimeAbstract::HardMappingError (DWORD dwStatus)
{
	return (dwStatus == TSL_ERROR_OUT_OF_MEMORY);
}

// Add this status to the list of warnings.
// Normally returns 0, but can theoretically return TSL_ERROR_OUT_OF_MEMORY
inline DWORD TSMapRuntimeAbstract::AddMoreStatus(DWORD dwStatus)
{
	if (m_stkStatus.Push(dwStatus) == -1)
		return TSL_ERROR_OUT_OF_MEMORY;
	else
		return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\msinfo\about.cpp ===
// About.cpp
//
// The About window implementation.
//
// Copyright (c) 1998-1999 Microsoft Corporation

#include "StdAfx.h"
#include <ntverp.h>
#include "About.h"
#include "resrc1.h"

/*
 * LoadAboutString - Retrieves the string enumerated nResourceID from
 *		the StringTable in resource file MSInfo.rc, returning an
 *		allocated pointer in pAboutData.
 *
 * Return codes:
 *		E_POINTER - Invalid pAboutData pointer.
 *		E_OUTOFMEMORY - Failed CoTaskMemAlloc
 *		S_OK - Successful completion.
 *
 * Notes:
 *		The memory pointed to by lpAboutData will need to be freed with
 *		CoMemTaskFree.
 *
 * History:	a-jsari		8/26/97		Initial version
 */
HRESULT CAboutImpl::LoadAboutString(UINT nResourceID, LPOLESTR *pAboutData)
{
    if (pAboutData == NULL)
        return E_POINTER;

    CString s;

    // Needed for Loadstring
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    s.LoadString(nResourceID);
    *pAboutData = reinterpret_cast<LPOLESTR>
            (CoTaskMemAlloc((s.GetLength() + 1)* sizeof(wchar_t)));

    if (*pAboutData == NULL)
        return E_OUTOFMEMORY;

	USES_CONVERSION;

    wcscpy(*pAboutData, OLESTR_FROM_CSTRING(s));

    return S_OK;
}

/*
 * GetSnapinDescription - Return an allocated pointer to the Resource file
 *		String Table's IDS_DESCRIPTION string in lpDescription.
 *
 * Return codes:
 *		E_POINTER - Invalid lpAboutData pointer.
 *		E_OUTOFMEMORY - Failed CoTaskMemAlloc
 *		S_OK - Successful completion.
 *
 * Notes:
 *		The memory pointed to by lpDescription will need to be freed with
 *		CoMemTaskFree.
 *
 * History:	a-jsari		8/26/97		Initial version.
 */
STDMETHODIMP CAboutImpl::GetSnapinDescription(LPOLESTR *lpDescription)
{
	return LoadAboutString(IDS_ROOT_NODE_DESCRIPTION, lpDescription);
}

/*
 * GetProvider - Return an allocated pointer to the Resource file
 *		String Table's IDS_DESCRIPTION string in lpProvider.
 *
 * Return codes:
 *		E_POINTER - Invalid lpAboutData pointer.
 *		E_OUTOFMEMORY - Failed CoTaskMemAlloc
 *		S_OK - Successful completion.
 *
 * Notes:
 *		The memory pointed to by lpProvider will need to be freed with
 *		CoMemTaskFree.
 *
 * History:	a-jsari		8/26/97		Initial version.
 */
STDMETHODIMP CAboutImpl::GetProvider(LPOLESTR *lpProvider)
{
	return LoadAboutString(IDS_COMPANY, lpProvider);
}

/*
 * GetSnapinVersion - Return an allocated pointer to the Resource file
 *		String Table's IDS_VERSION string in lpVersion.
 *
 * Return codes:
 *		E_POINTER - Invalid lpAboutData pointer.
 *		E_OUTOFMEMORY - Failed CoTaskMemAlloc
 *		S_OK - Successful completion.
 *
 * Notes:
 *		The memory pointed to by lpVersion will need to be freed with
 *		CoMemTaskFree.
 *
 * History:	a-jsari		8/26/97		Initial version.
 */
STDMETHODIMP CAboutImpl::GetSnapinVersion(LPOLESTR *lpVersion)
{
	ASSERT(lpVersion != NULL);
	USES_CONVERSION;
	LPTSTR szVersion = A2T(VER_PRODUCTVERSION_STRING);
	*lpVersion = (LPOLESTR)::CoTaskMemAlloc((::_tcslen(szVersion) + 1) * sizeof(TCHAR));
	if (*lpVersion == NULL) return E_OUTOFMEMORY;
	::_tcscpy(*lpVersion, szVersion);
	return S_OK;
}

/*
 * GetSnapinImage - Takes the Application Icon resource and puts it in
 *		hAppIcon.
 *
 *	Return Codes:
 *		E_POINTER - Invalid hAppIcon pointer.
 *		E_FAIL - Failed LoadIcon.
 *		S_OK - Successful completion
 *
 * History:	a-jsari		8/26/97		Initial version.
 */
STDMETHODIMP CAboutImpl::GetSnapinImage(HICON *hAppIcon)
{
	if (hAppIcon == NULL)
		return E_POINTER;

	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	*hAppIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDI_MSINFO));

	ASSERT(*hAppIcon != NULL);
	return (*hAppIcon != NULL) ? S_OK : E_FAIL;
}

/*
 * GetStaticFolderImage - Returns pointers to the
 *
 * Return Codes:
 *		E_POINTER - Invalid hSmallImage, hSmallImageOpen, hLargeImage, or cLargeMask
 *				pointer.
 *		S_OK - Always
 *
 * History:	a-jsari		8/26/97		Initial version.
 */
STDMETHODIMP CAboutImpl::GetStaticFolderImage(HBITMAP *hSmallImage,
											  HBITMAP *hSmallImageOpen,
											  HBITMAP *hLargeImage,
											  COLORREF *cLargeMask)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());	
	HINSTANCE hInst = ::AfxGetInstanceHandle();

	if (hSmallImage == NULL || hSmallImageOpen == NULL || hLargeImage == NULL || cLargeMask == NULL)
		return E_POINTER;

	HBITMAP hSmall = (HBITMAP) LoadBitmap(hInst, MAKEINTRESOURCE(IDB_ICON16));

	if (hSmall)
		*hSmallImage	 = hSmall;

	hSmall = (HBITMAP) LoadBitmap(hInst, MAKEINTRESOURCE(IDB_ICON16));
	
	if (hSmall)
		*hSmallImageOpen = hSmall;

	HBITMAP hNormal = (HBITMAP) LoadBitmap(hInst, MAKEINTRESOURCE(IDB_ICON32));

	if (hNormal)
		*hLargeImage = hNormal;

	*cLargeMask = RGB(255,0,255); // background mask

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\troubleshoot\launcher\server\tsmapclient.h ===
// 
// MODULE: TSMapClient.cpp
//
// PURPOSE: Part of launching a Local Troubleshoote