Out parm for error
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Invoke");

    HRESULT hr = GetTypeInfoPtrs();         // Ensure TypeInfo ptrs are OK
    if(hr != NOERROR)
        return hr;
        
    if(IsZombie())
        return CO_E_RELEASED;

    IDispatch * pDispatch;
    ITypeInfo * pTypeInfo;

    if((DWORD)dispidMember <= 0x2ff)        // Include default (0), selection,
    {                                       //  and range DISPIDs
        pTypeInfo = g_pTypeInfoSel;
        pDispatch = this;
        AddRef();                           // Compensate for Release() below
    }
    else if((DWORD)dispidMember <= 0x3ff)   // 0x300 to 0x3ff: DISPIDs
    {                                       //  reserved for ITextFont
        pTypeInfo = g_pTypeInfoFont;
        hr = GetFont((ITextFont**)&pDispatch);
    }
    else if((DWORD)dispidMember <= 0x4ff)   // 0x400 to 0x4ff: DISPIDs
    {                                       //  reserved for ITextPara
        pTypeInfo = g_pTypeInfoPara;
        hr = GetPara((ITextPara **)&pDispatch);
    }
    else                                    // dispidMember is negative or
        return DISP_E_MEMBERNOTFOUND;       //  > 0x4ff, i.e., not TOM

    if(hr != NOERROR)                       // Couldn't instantiate ITextFont
        return hr;                          //  or ITextPara

    hr = pTypeInfo->Invoke(pDispatch, dispidMember, wFlags,
                             pdispparams, pvarResult, pexcepinfo, puArgError);
#ifndef PEGASUS
    pDispatch->Release();
#endif
    return hr;
}


//----------------------- ITextRange Methods/Properties ------------------------

/*
 *  CTxtRange::CanEdit (pB)
 *
 *  @mfunc
 *      Set *<p pB> = tomTrue iff this range can be edited and
 *      pB isn't NULL
 *
 *  @rdesc
 *      HRESULT = (can edit) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::CanEdit (
    long * pB)          //@parm Out parm to receive boolean value
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::CanEdit");

    if(IsZombie())
        return CO_E_RELEASED;

    CCallMgr    callmgr(GetPed());
    return IsTrue(!WriteAccessDenied(), pB);
}

/*
 *  CTxtRange::CanPaste (pVar, long Format, pB)
 *
 *  @mfunc
 *      Set *<p pB> = tomTrue iff the data object <p pVar>->punkVal can be
 *      pasted into this range and pB isn't NULL.  If <p pVar> is NULL,
 *      use the clipboard instead.
 *
 *  @rdesc
 *      HRESULT = (can paste) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::CanPaste (
    VARIANT *   pVar,       //@parm Data object to paste
    long        Format,     //@parm Desired clipboard format
    long *      pB)         //@parm Out parm to receive boolean value
{
#ifndef PEGASUS
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::CanPaste");

    if(IsZombie())
        return CO_E_RELEASED;

    CCallMgr        callmgr(GetPed());
    HRESULT         hr;
    IDataObject *   pdo = NULL;             // Default clipboard

    if(pVar && pVar->vt == VT_UNKNOWN)
        pVar->punkVal->QueryInterface(IID_IDataObject, (void **)&pdo);

    hr = IsTrue(!WriteAccessDenied() &&
                (GetPed()->GetDTE()->CanPaste(pdo, (CLIPFORMAT)Format,
                 RECO_PASTE)), pB);
    if(pdo)
        pdo->Release();

    return hr;
#else
    return 0;
#endif
}

/*
 *  ITextRange::ChangeCase (long Type)
 *
 *  @mfunc
 *      Change the case of letters in this range according to Type:
 *
 *      tomSentenceCase = 0: capitalize first letter of each sentence
 *      tomLowerCase    = 1: change all letters to lower case
 *      tomUpperCase    = 2: change all letters to upper case
 *      tomTitleCase    = 3: capitalize the first letter of each word
 *      tomToggleCase   = 4: toggle the case of each letter
 *  
 *  @rdesc
 *      HRESULT = (WriteAccessDenied) ? E_ACCESSDENIED :
 *                (if change) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::ChangeCase (
    long Type)      //@parm Type of case change. Default value: tomLower
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::ChangeCase");

    if(IsZombie())
        return CO_E_RELEASED;

    CCallMgr callmgr(GetPed());

    if(WriteAccessDenied())
        return E_ACCESSDENIED;

    IUndoBuilder *  publdr;
    CGenUndoBuilder undobldr(GetPed(), UB_AUTOCOMMIT, &publdr);
    LONG            cpMin, cpMax;
    LONG            cch = GetRange(cpMin, cpMax);
    CRchTxtPtr      rtp(*this);

    undobldr.StopGroupTyping();

    rtp.SetCp(cpMin);
    return (rtp.ChangeCase(cch, Type, publdr)) ? NOERROR : S_FALSE;
}

/*
 *  CTxtRange::Collapse (bStart)
 *
 *  @mfunc
 *      Collapse this range into a degenerate point either at the
 *      the start (<p bStart> is nonzero or the end (<p bStart> = 0)
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::Collapse (
    long bStart)            //@parm Flag specifying end to collapse at
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Collapse");

    if(IsZombie())
        return CO_E_RELEASED;

    CCallMgr callmgr(GetPed());

    if(!_cch)                           // Already collapsed
        return S_FALSE;                 // Signal that no change occurred
        
    Collapser(bStart);
    Update(TRUE);                       // Update selection
    return NOERROR;                     // Signal that change occurred
}

/*
 *  CTxtRange::Copy (pVar)
 *
 *  @mfunc
 *      Copy the plain and/or rich text to a data object and return the
 *      object ptr in <p pVar>.  If <p pVar> is null, copy to the clipboard.
 *
 *  @rdesc
 *      HRESULT = (if success) ? NOERROR : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtRange::Copy (
    VARIANT * pVar)             //@parm Out parm for data object
{
#ifndef PEGASUS
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Copy");

    if(IsZombie())
        return CO_E_RELEASED;

    CLightDTEngine * pldte = &GetPed()->_ldte;

    if(pVar && pVar->vt == (VT_UNKNOWN | VT_BYREF))
    {
        return pldte->RangeToDataObject(this, SF_TEXT | SF_RTF,
                                    (IDataObject **)pVar->ppunkVal);
    }
    return pldte->CopyRangeToClipboard(this);
#else
    return 0;
#endif
}

/*
 *  CTxtRange::Cut (pVar)
 *
 *  @mfunc
 *      Cut the plain and/or rich text to a data object and return the
 *      object ptr in <p pVar>.  If <p pVar> is null,
 *      cut to the clipboard.
 *
 *  @rdesc
 *      HRESULT = (if success) ? NOERROR : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtRange::Cut (
    VARIANT * pVar)     //@parm Out parm for data object
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Cut");

    if(IsZombie())
        return CO_E_RELEASED;

    CCallMgr callmgr(GetPed());

    if(WriteAccessDenied())
        return E_ACCESSDENIED;

    HRESULT hr = Copy(pVar);

    Replacer(0, NULL);
    return hr;
}

/*
 *  CTxtRange::Delete (Unit, Count, pDelta)
 *
 *  @mfunc
 *      If this range is nondegenerate, delete it along with |Count| - 1 Units
 *      in the direction specified by the sign of Count.  If this range is
 *      degenerate, delete Count Units.
 *
 *  @rdesc
 *      HRESULT = (WriteAccessDenied) ? E_ACCESSDENIED :
 *                (all requested Units deleted) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::Delete (
    long    Unit,           //@parm Unit to use
    long    Count,          //@parm Number of chars to delete
    long *  pDelta)         //@parm Out parm to receive count of units deleted
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Delete");

    if(pDelta)
        *pDelta = 0;
    
    if(IsZombie())
        return CO_E_RELEASED;

    CCallMgr callmgr(GetPed());

    if(WriteAccessDenied())
        return E_ACCESSDENIED;

    LONG    cchSave = _cch;                 // Remember initial count
    LONG    cchText = GetAdjustedTextLength();
    LONG    CountOrg = Count;
    LONG    cpMin, cpMost;
    LONG    cUnit = 0;                      // Default no Units
    MOVES   Mode = (Count >= 0) ? MOVE_END : MOVE_START;

    GetRange(cpMin, cpMost);
    if(cpMost > cchText)                    // Can't delete final CR. To get
    {                                       //  *pDelta right, handle here
        Set(cpMin, cpMin - cchText);        // Backup before CR & set active
        if(Count > 0)                       //  end at cpMin since there's
        {                                   //  nothing to delete forward
            Count = 0;
            if(!_cch)                       // Only collapsed selection of
                Mode = MOVE_IP;             //  final CR: set up nothing
        }                                   //  deleted (MOVE_IP = 0)
    }
    if(Count)
    {
        if((_cch ^ Mode) < 0)               // Be sure active end is in
            FlipRange();                    //  deletion direction
        if(cchSave)                         // Deleting nondegenerate range
            Count -= Mode;                  //  counts as one unit
        if(Mover(Unit, Count, &cUnit, Mode) // Try to expand range for
            == E_INVALIDARG)                //  remaining Count Units
        {
            if(pDelta)
                *pDelta = 0;
            return E_INVALIDARG;
        }
        if(GetCp() > cchText && cUnit > 0)  // Range includes final CR, which
        {                                   //  cannot be deleted. Reduce
            if(Unit == tomCharacter)        //  counts for some Units
                cUnit -= GetTextLength() - cchText;
            else if(Unit == tomWord)
                cUnit--;                    // An EOP qualifies as a tomWord
        }
    }

    if(cchSave)                             // Deleting nondegenerate range
        cUnit += Mode;                      //  counts as a Unit

    if(pDelta)
        *pDelta = cUnit;

    if(_cch)                                // Mover() may have changed _cch
    {                                       
        IUndoBuilder *  publdr;
        CGenUndoBuilder undobldr(GetPed(), UB_AUTOCOMMIT, &publdr);

        if (publdr)
        {
            publdr->StopGroupTyping();
            publdr->SetNameID(UID_DELETE);
        }

        // FUTURE (murrays): the cchSave case should set up undo to
        // restore the original range, not the extended range resulting
        // when |CountOrg| > 1.  This could be done using two calls to
        // ReplaceRange(), one to delete the original range and one to
        // delete the rest
        SELRR selrr = !_fSel || cchSave ? SELRR_REMEMBERRANGE :
                      CountOrg > 0      ? SELRR_REMEMBERCPMIN :
                                          SELRR_REMEMBERENDIP;

        ReplaceRange(0, NULL, publdr, selrr);

        if (cUnit == CountOrg ||            // Delete(Unit,0,0)
            cUnit == 1 && !CountOrg)        //  deletes one "Unit", namely
        {                                   //  what's selected
            return NOERROR;                 // Signal everything deleted as
        }                                   //  requested
    }
    else if(cchSave)                        // Collapsed selection of final CR
    {                                       //  but didn't delete anything
        Update(TRUE);                       // Selection highlighting changed
    }
    return S_FALSE;                         // Less deleted than requested
}

/*
 *  CTxtRange::EndOf (Unit, Extend, pDelta)
 *
 *  @mfunc
 *      Move this range end(s) to end of the first overlapping Unit in
 *      the range.
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR :
 *                (if Unit supported) ? S_FALSE : E_NOTIMPL
 */
STDMETHODIMP CTxtRange::EndOf (
    long    Unit,           //@parm Unit to use
    long    Extend,         //@parm If true, leave other end alone
    long *  pDelta)         //@parm Count of chars that End is moved
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::EndOf");

    CCallMgr    callmgr(GetPed());
    LONG        cpMost;

    HRESULT hr = Expander (Unit, Extend, pDelta, NULL, &cpMost);
    if(hr == NOERROR)
        Update(TRUE);                   // Update selection

    return hr;
}

/*
 *  CTxtRange::Expand (Unit, pDelta)
 *
 *  @mfunc
 *      Expand this range so that any partial Units it contains are
 *      completely contained.  If this range consists of one or more full
 *      Units, no change is made.  If this range is an insertion point at
 *      the beginning or within a Unit, Expand() expands this range to include
 *      that Unit.  If this range is an insertion point at the end of the
 *      story, Expand() tries to set this range to include the last Unit in
 *      the story.  The active end is always cpMost except for the last case.
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR :
 *                (if Unit supported) ? S_FALSE : E_NOTIMPL
 */
STDMETHODIMP CTxtRange::Expand (
    long    Unit,           //@parm Unit to expand range to
    long *  pDelta)         //@parm Out parm to receive count of chars added
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Expand");

    CCallMgr callmgr(GetPed());
    LONG     cpMin, cpMost;

    HRESULT hr = Expander (Unit, TRUE, pDelta, &cpMin, &cpMost);
    if(hr == NOERROR)
        Update(TRUE);                   // Update selection

    return hr;
}

/*
 *  CTxtRange::FindText (bstr, cch, Flags, pLength)
 *
 *  @mfunc
 *      If this range isn't an insertion point already, convert it into an
 *      insertion point at its End if <p cch> <gt> 0 and at its Start if
 *      <p cch> <lt> 0.  Then search up to <p cch> characters of the range
 *      looking for the string <p bstr> subject to the compare flags
 *      <p Flags>.  If <p cch> <gt> 0, the search is forward and if <p cch>
 *      <lt> 0 the search is backward.  If the string is found, the range
 *      limits are changed to be those of the matched string and *<p pLength>
 *      is set equal to the length of the string. If the string isn't found,
 *      the range remains unchanged and *<p pLength> is set equal to 0.
 *
 *  @rdesc
 *      HRESULT = (if <p bstr> found) ? NOERROR : S_FALSE
 *
 *  @devnote
 *      Argument validation of the three Find methods is done by the helper
 *      function CTxtRange::Finder(bstr, cch, dwFlags, pDelta, fExtend, fFlip)
 */
STDMETHODIMP CTxtRange::FindText (
    BSTR    bstr,       //@parm String to find
    long    Count,      //@parm Max count of chars to search
    long    Flags,      //@parm Flags governing compares
    long *  pDelta)     //@parm Out parm to receive count of chars moved
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::FindText");

    return Finder(bstr, Count, Flags, pDelta, MOVE_IP);
}

/*
 *  CTxtRange::FindTextEnd (bstr, cch, Flags, pLength)
 *
 *  @mfunc
 *      Starting from this range's End, search up to <p cch> characters
 *      looking for the string <p bstr> subject to the compare flags
 *      <p Flags>.  If <p cch> <gt> 0, the search is forward and if <p cch>
 *      <lt> 0 the search is backward.  If the string is found, the range
 *      limits are changed to be those of the matched string and *<p pLength>
 *      is set equal to the length of the string. If the string isn't found,
 *      the range remains unchanged and *<p pLength> is set equal to 0.
 *
 *  @rdesc
 *      HRESULT = (if <p bstr> found) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::FindTextEnd (
    BSTR    bstr,       //@parm String to find
    long    Count,      //@parm Max count of chars to search
    long    Flags,      //@parm Flags governing compares
    long *  pDelta)     //@parm Out parm to receive count of chars moved
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::FindTextEnd");

    return Finder(bstr, Count, Flags, pDelta, MOVE_END);
}

/*
 *  CTxtRange::FindTextStart (bstr, cch, Flags, pDelta)
 *
 *  @mfunc
 *      Starting from this range's Start, search up to <p cch> characters
 *      looking for the string <p bstr> subject to the compare flags
 *      <p Flags>.  If <p cch> <gt> 0, the search is forward and if <p cch>
 *      <lt> 0 the search is backward.  If the string is found, the range
 *      limits are changed to be those of the matched string and *<p pLength>
 *      is set equal to the length of the string. If the string isn't found,
 *      the range remains unchanged and *<p pLength> is set equal to 0.
 *
 *  @rdesc
 *      HRESULT = (if <p bstr> found) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::FindTextStart (
    BSTR    bstr,       //@parm String to find
    long    Count,      //@parm Max count of chars to search
    long    Flags,      //@parm Flags governing compares
    long *  pDelta)     //@parm Out parm to receive count of chars moved
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::FindTextStart");

    return Finder(bstr, Count, Flags, pDelta, MOVE_START);
}

/*
 *  CTxtRange::GetChar (pChar)
 *
 *  @mfunc
 *      Set *<p pChar> equal to the character at cpFirst
 *
 *  @rdesc
 *      HRESULT = (<p pChar>) NOERROR ? E_INVALIDARG
 *
 *  @devnote
 *      This method is very handy for walking a range character by character
 *      from the Start. Accordingly, it's desirable that the active end
 *      is at the Start. We set this up for a range, since the API doesn't
 *      care which range end is active.  But we can't do this for a selection,
 *      since the selection API depends on the active end.
 */
STDMETHODIMP CTxtRange::GetChar (
    long * pChar)           //@parm Out parm for char
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetChar");

    HRESULT hr = GetLong(0, pChar);
    if(hr != NOERROR)
        return hr;

    if(_cch > 0)                            // Active end at cpMost (End)
    {
        if(_fSel)
        {
            CTxtPtr tp(_rpTX);              // For selection, can't change
            tp.AdvanceCp(-_cch);            //  active end
            *pChar = (long)(tp.GetChar());
            return NOERROR;
        }
        FlipRange();                        // For range, it's more efficient
    }                                       //  to work from cpFirst and API
    *(DWORD *)pChar = _rpTX.GetChar();      //  doesn't expose RichEdit active
                                            //  end
    return NOERROR;
}

/*
 *  CTxtRange::GetDuplicate (ppRange)
 *
 *  @mfunc
 *      Get a clone of this range object.  For example, you may want to
 *      create an insertion point to traverse a range, so you clone the
 *      range and then set the clone's cpLim equal to its cpFirst. A range
 *      is characterized by its cpFirst, cpLim, and the story it belongs to.
 *
 *  @rdesc
 *      HRESULT = (if success) ? NOERROR :
 *                (<p ppRange>) ? E_OUTOFMEMORY : E_INVALIDARG
 *
 *  @comm
 *      Even if this range is a selection, the clone returned is still only
 *      a range.
 */
STDMETHODIMP CTxtRange::GetDuplicate (
    ITextRange ** ppRange)      //@parm Out parm to receive duplicate of range
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetDuplicate");

    HRESULT hr = GetLong(NULL, (LONG *)ppRange);
    if(hr != NOERROR)
        return hr;

    ITextRange *prg = new CTxtRange(*this);
    if(prg)
    {
        *ppRange = prg;
        prg->AddRef();
        return NOERROR;
    }
    return E_OUTOFMEMORY;
}

/*
 *  ITextRange::GetEmbeddedObject (ppV)
 *
 *  @mfunc
 *      Property get method that gets a ptr to the object at cpFirst
 *
 *  @rdesc
 *      HRESULT = (!ppV) ? E_INVALIDARG :
 *                (object found) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::GetEmbeddedObject (
    IUnknown **ppV)         //@parm Out parm to receive embedded object
{
    HRESULT hr = GetLong(NULL, (LONG *)ppV);
    if(hr != NOERROR)
        return hr;
    
    if(GetObjectCount())
    {
        COleObject *pobj = GetPed()->_pobjmgr->GetObjectFromCp(GetCpMin());

        if(pobj && (*ppV = pobj->GetIUnknown()) != NULL)
        {
            (*ppV)->AddRef();
            return NOERROR;
        }
    }
    return S_FALSE;
}

/*
 *  CTxtRange::GetEnd (pcpLim)
 *
 *  @mfunc
 *      Get this range's End (cpMost) cp
 *
 *  @rdesc
 *      HRESULT = (<p pcpLim>) ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::GetEnd (
    long * pcpLim)          //@parm Out parm to receive End cp value
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetEnd");

    return GetLong(GetCpMost(), pcpLim);
}

/*
 *  CTxtRange::GetFont (ppFont)
 *
 *  @mfunc
 *      Get an ITextFont object with the character attributes of this range     
 *
 *  @rdesc
 *      HRESULT = <p ppFont> ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::GetFont (
    ITextFont ** ppFont)    //@parm Out parm to receive ITextFont object
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetFont");

    HRESULT hr = GetLong(NULL, (LONG *)ppFont);
    if(hr != NOERROR)
        return hr;

    *ppFont = (ITextFont *) new CTxtFont(this);
    return *ppFont ? NOERROR : E_OUTOFMEMORY;
}

/*
 *  CTxtRange::GetFormattedText (ppRange)
 *
 *  @mfunc
 *      Retrieves an ITextRange with this range's formatted text.
 *      If <p ppRange> is NULL, the clipboard is the target.
 *
 *  @rdesc
 *      HRESULT = (if success)  ? NOERROR :
 *                (<p ppRange>) ? E_OUTOFMEMORY : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::GetFormattedText (
    ITextRange ** ppRange)      //@parm Out parm to receive formatted text
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetFormattedText");

    return GetDuplicate(ppRange);
}

/*
 *  CTxtRange::GetIndex (Unit, pIndex)
 *
 *  @mfunc
 *      Set *<p pIndex> equal to the Unit number at this range's cpFirst
 *
 *  @rdesc
 *      HRESULT = (!<p pIndex>) ? E_INVALIDARG :
 *                (Unit not implemented) ? E_NOTIMPL :
 *                (Unit available) ? NOERROR : S_FALSE
 *  @future
 *      implement tomWindow?
 */
STDMETHODIMP CTxtRange::GetIndex (
    long    Unit,           //@parm Unit to index
    long *  pIndex)         //@parm Out parm to receive index value
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetIndex");

    HRESULT hr = GetLong(0, pIndex);
    if(hr != NOERROR)
        return hr;

    LONG      cp;
    LONG      cUnit = tomBackward;
    CTxtRange rg(*this);

    hr = rg.Expander(Unit, FALSE, NULL,         // Go to Start of Unit; else
                             &cp, NULL);        //  UnitCounter gives 1 extra
    if(FAILED(hr))
        return hr;                              // Unit not recognized

    LONG cch = rg.UnitCounter(Unit, cUnit, 0);
    
    if(cch == tomForward)                       // UnitCounter() doesn't know
        return E_NOTIMPL;                       //  Unit

    if(cch == tomBackward)                      // Unit not in story
        return S_FALSE;

    *pIndex = -cUnit + 1;                       // Make count positive and
                                                //  1-based
    return NOERROR;
}

/*
 *  CTxtRange::GetPara (ppPara)
 *
 *  @mfunc
 *      Get an ITextPara object with the paragraph attributes of this range     
 *
 *  @rdesc
 *      HRESULT = <p ppPara> ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::GetPara (
    ITextPara ** ppPara)    //@parm Out parm to receive ITextPara object
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetPara");

    HRESULT hr = GetLong(NULL, (LONG *)ppPara);
    if(hr != NOERROR)
        return hr;

    *ppPara = (ITextPara *) new CTxtPara(this);
    return *ppPara ? NOERROR : E_OUTOFMEMORY;
}

/*
 *  CTxtRange::GetPoint (px, py, Type)
 *
 *  @mfunc
 *      Get point for selection Start or End and intraline position
 *      as determined by <p Type>.
 *
 *  @rdesc
 *      HRESULT = (!<p px> or !<p py>) ? E_INVALIDARG :
 *                (if success) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::GetPoint (
    long    Type,       //@parm Type of point
    long *  px,         //@parm Out parm for x coordinate
    long *  py)         //@parm Out parm for y coordinate
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::GetPoint");

    if(!px || !py)
        return E_INVALIDARG;

    *px = *py = 0;

    if(IsZombie())
        return CO_E_RELEASED;

    LONG        ili;
    BOOL        fAtEnd = _cch > 0;              // Default value for IP
    POINT       pt;
    CRchTxtPtr  rtp(*this);                     // Default active end
    CTxtEdit *  ped = GetPed();
    CDisplay *  pdp = ped->_pdp;                // Save indirections

    if(!pdp || !ped->fInplaceActive())
        return E_FAIL;                          // No display or not active
                                                // then we can do nothing.
    if(fAtEnd ^ !(Type & tomStart))             // Move tp to active end
        rtp.Advance(-_cch);

    ili = pdp->PointFromTp(rtp, NULL, fAtEnd, pt, NULL, Type & 0x1f);

    RECT rcView;                                // Verify return value makes
                                                // sense since PointFromTp
    pdp->GetViewRect(rcView, NULL);             // may return values outside
                                                // client rect
    rcView.bottom++;                            // Enlarge Rect to include
    rcView.right++;                             // bottom and right edges
    if(ili >= 0 && PtInRect(&rcView, pt))       // Function succeeded
    {
        // Caller wants screen coordinates?
        if ( !(Type & tomClientCoord) )
            ped->TxClientToScreen(&pt); 

        *px = pt.x;
        *py = pt.y;
        return NOERROR;
    }
    return S_FALSE;                             // Function failed
}

/*
 *  CTxtRange::GetStart (pcpFirst)
 *
 *  @mfunc
 *      Get this range's Start (cpMin) cp
 *
 *  @rdesc
 *      HRESULT = (<p pcpFirst>) ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::GetStart (
    long * pcpFirst)        //@parm Out parm to receive Start cp value
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetStart");

    return GetLong(GetCpMin(), pcpFirst);
}

/*
 *  CTxtRange::GetStoryLength (pcch)
 *
 *  @mfunc
 *      Set *<p pcch> = count of chars in this range's story
 *
 *  @rdesc
 *      HRESULT = (<p pcch>) ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::GetStoryLength (
    long * pcch)        //@parm Out parm to get length of this range's story
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetStoryLength");

    return GetLong(GetTextLength(), pcch);
}

/*
 *  ITextRange::GetStoryType (pValue)
 *
 *  @mfunc
 *      Property get method that gets the type of this range's
 *      story.
 *
 *  @rdesc
 *      HRESULT = (pValue) NOERROR ? E_INVALIDARG
 */
STDMETHODIMP CTxtRange::GetStoryType (
    long *pValue)       //@parm Out parm to get type of this range's story
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetStoryType");

    return GetLong(tomUnknownStory, pValue);
}

/*
 *  CTxtRange::GetText (pbstr)
 *
 *  @mfunc
 *      Get plain text in this range. The Text property is the default
 *      property for ITextRange.
 *
 *  @rdesc
 *      HRESULT = (if success) ? NOERROR :
 *                (!<p pbstr>) ? E_INVALIDARG : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtRange::GetText (
    BSTR * pbstr)               //@parm Out parm to receive bstr
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetText");

    HRESULT hr = GetLong(NULL, (LONG *)pbstr);
    if(hr != NOERROR)
        return hr;

    if(!GetCch())
        return NOERROR;
        
    LONG cpMin, cpMost;
    LONG cch = GetRange(cpMin, cpMost);

    *pbstr = SysAllocStringLen(NULL, cch);
    if(!*pbstr)
        return E_OUTOFMEMORY;

    CTxtPtr tp(_rpTX);
    tp.SetCp(cpMin);
    tp.GetText( cch, (TCHAR*) * pbstr );
    return NOERROR;
}

/*
 *  CTxtRange::InRange (pRange, pB)
 *
 *  @mfunc
 *      Returns *<p pB> = tomTrue iff this range points within or at the same
 *      text as <p pRange> does
 *
 *  @rdesc
 *      HRESULT = (within range) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::InRange (
    ITextRange * pRange,        //@parm ITextRange to compare with
    long *       pB)            //@parm Out parm for comparison result
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::InRange");

    return IsTrue(Comparer(pRange), pB);
}


/*
 *  CTxtRange::InStory (pRange, pB)
 *
 *  @mfunc
 *      Return *pB = tomTrue iff this range's story is the same as
 *      <p pRange>'s
 *
 *  @rdesc
 *      HRESULT = (in story) ? NOERROR : S_FALSE
 *
 *  @future
 *      If RichEdit acquires the ability to have multiple stories and
 *      therefore ranges get a _story member, then compare that member
 *      instead of calling _rpTX.SameRuns().
 */
STDMETHODIMP CTxtRange::InStory (
    ITextRange *pRange,     //@parm ITextRange to query for private interface
    long *      pB)         //@parm Out parm to receive tomBool result
{
#ifndef PEGASUS
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::InStory");

    return IsTrue(IsSameVtables(this, pRange) &&        // Same vtables,
        _rpTX.SameRuns(&((CTxtRange *)pRange)->_rpTX),  //  same Runs
        pB);
#else
    return 0;
#endif
}

/*
 *  CTxtRange::IsEqual (pRange, pB)
 *
 *  @mfunc
 *      Returns *<p pB> = tomTrue iff this range points at the same text (cp's
 *      and story) as <p pRange> does and pB isn't NULL.
 *
 *  @rdesc
 *      HRESULT = (equal objects) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::IsEqual (
    ITextRange * pRange,        //@parm ITextRange to compare with
    long *       pB)            //@parm Out parm for comparison result
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::IsEqual");

    return IsTrue(Comparer(pRange) < 0, pB);
}

/*
 *  CTxtRange::Move (Unit, Count, pDelta)
 *
 *  @mfunc
 *      Move end(s) <p Count> <p Unit>'s, returning *<p pDelta> = # units
 *      actually moved. In general, this method converts a range into an
 *      insertion point if it isn't already, and moves the insertion point.
 *      If <p Count> <gt> 0, motion is forward toward the end of the story;
 *      if <p Count> <lt> 0, motion is backward toward the beginning.
 *      <p Count> = 0 moves cpFirst to the beginning of the <p Unit>
 *      containing cpFirst.
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR :
 *                (if Unit supported) ? S_FALSE : E_NOTIMPL
 *  @devnote
 *      Argument validation of the three Move methods is done by the helper
 *      function CTxtRange::Mover(Unit, Count, pDelta, Mode)
 */
STDMETHODIMP CTxtRange::Move (
    long    Unit,           //@parm Unit to use
    long    Count,          //@parm Number of Units to move
    long *  pDelta)         //@parm Out parm to receive actual count of
                            //      Units end is moved
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Move");
    CCallMgr    callmgr(GetPed());

    return Mover(Unit, Count, pDelta, MOVE_IP);
}

/*
 *  CTxtRange::MoveEnd (Unit, Count, pDelta)
 *
 *  @mfunc
 *      Move End end <p Count> <p Unit>'s, returning *<p pDelta> = # units
 *      actually moved
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR :
 *                (if Unit supported) ? S_FALSE : E_NOTIMPL
 */
STDMETHODIMP CTxtRange::MoveEnd (
    long    Unit,           //@parm Unit to use
    long    Count,          //@parm Number of Units to move
    long *  pDelta)         //@parm Out parm to receive actual count of
                            //      Units end is moved
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::MoveEnd");
    CCallMgr    callmgr(GetPed());

    return Mover(Unit, Count, pDelta, MOVE_END);
}

/*
 *  CTxtRange::MoveEndUntil (Cset, Count, pDelta)
 *
 *  @mfunc
 *      Move the End just past all contiguous characters that are not found
 *      in the set of characters specified by the VARIANT <p Cset> parameter.
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR :
 *                (if <p Cset> valid) ? S_FALSE : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::MoveEndUntil (
    VARIANT * Cset,             //@parm Character match set to use
    long      Count,            //@parm Max number of characters to move past
    long *    pDelta)           //@parm Out parm to receive actual count of
                                //      characters end is moved
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::MoveEndUntil");

    return Matcher(Cset, Count, pDelta, MOVE_END, MATCH_UNTIL);
}

/*
 *  CTxtRange::MoveEndWhile (Cset, Count, pDelta)
 *
 *  @mfunc
 *      Move the End just past all contiguous characters that are found in
 *      the set of characters specified by the VARIANT <p Cset> parameter.
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR :
 *                (if <p Cset> valid) ? S_FALSE : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::MoveEndWhile (
    VARIANT * Cset,             //@parm Character match set to use
    long      Count,            //@parm Max number of characters to move past
    long *    pDelta)           //@parm Out parm to receive actual count of
                                //      characters end is moved
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::MoveEndWhile");

    return Matcher(Cset, Count, pDelta, MOVE_END, MATCH_WHILE);
}

/*
 *  CTxtRange::MoveStart (Unit, Count, pDelta)
 *
 *  @mfunc
 *      Move Start end <p Count> <p Unit>'s, returning *<p pDelta> = # units
 *      actually moved
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR :
 *                (if Unit supported) ? S_FALSE : E_NOTIMPL
 */
STDMETHODIMP CTxtRange::MoveStart (
    long    Unit,           //@parm Unit to use
    long    Count,          //@parm Number of Units to move
    long *  pDelta)         //@parm Out parm to receive actual count of
                            //      Units end is moved
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::MoveStart");
    CCallMgr    callmgr(GetPed());

    return Mover(Unit, Count, pDelta, MOVE_START);
}

/*
 *  CTxtRange::MoveStartUntil (Cset, Count, pDelta)
 *
 *  @mfunc
 *      Move the Start just past all contiguous characters that are not found
 *      in the set of characters specified by the VARIANT <p Cset> parameter.
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR :
 *                (if <p Cset> valid) ? S_FALSE : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::MoveStartUntil (
    VARIANT * Cset,             //@parm Character match set to use
    long      Count,            //@parm Max number of characters to move past
    long *    pDelta)           //@parm Out parm to receive actual count of
                                //      characters end is moved
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::MoveStartUntil");

    return Matcher(Cset, Count, pDelta, MOVE_START, MATCH_UNTIL);
}

/*
 *  CTxtRange::MoveStartWhile (Cset, Count, pDelta)
 *
 *  @mfunc
 *      Move the Start just past all contiguous characters that are found in
 *      the set of characters specified by the VARIANT <p Cset> parameter.
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR :
 *                (if <p Cset> valid) ? S_FALSE : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::MoveStartWhile (
    VARIANT * Cset,             //@parm Character match set to use
    long      Count,            //@parm Max number of characters to move past
    long *    pDelta)           //@parm Out parm to receive actual count of
                                //      characters end is moved
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::MoveStartWhile");

    return Matcher(Cset, Count, pDelta, MOVE_START, MATCH_WHILE);
}

/*
 *  CTxtRange::MoveUntil (Cset,Count, pDelta)
 *
 *  @mfunc
 *      Convert this range into an insertion point if it isn't already,
 *      and keep moving the insertion point until encountering any
 *      character in the set of characters specified by the VARIANT cset
 *      parameter.
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR :
 *                (if <p Cset> valid) ? S_FALSE : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::MoveUntil (
    VARIANT * Cset,             //@parm Character match set to use
    long      Count,            //@parm Max number of characters to move past
    long *    pDelta)           //@parm Out parm to receive actual count of
                                //      characters end is moved
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::MoveUntil");
                            
    return Matcher(Cset, Count, pDelta, MOVE_IP, MATCH_UNTIL);
}

/*
 *  CTxtRange::MoveWhile (Cset, Count, pDelta)
 *
 *  @mfunc
 *      Convert this range into an insertion point if it isn't already,
 *      and keep moving the insertion point so long as (while) the
 *      characters past by are found in set of characters specified by
 *      the VARIANT cset parameter.  Such a contiguous set of characters
 *      is known as a span of characters.  The magnitude of the <p Count>
 *      parameter gives the maximum number of characters to move past and
 *      the sign of <p Count> specifies the direction to move in.
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR :
 *                (if <p Cset> valid) ? S_FALSE : E_INVALIDARG
 *
 *  @devnote
 *      Argument validation of the MoveWhile and MoveUntil methods is done by
 *      the helper CTxtRange::Matcher (Cset, Count, pDelta, fExtend, fSpan)
 */
STDMETHODIMP CTxtRange::MoveWhile (
    VARIANT * Cset,             //@parm Character match set to use
    long      Count,            //@parm Max number of characters to move past
    long *    pDelta)           //@parm Out parm to receive actual count of
                                //      characters end is moved
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::MoveWhile");
                            
    return Matcher(Cset, Count, pDelta, MOVE_IP, MATCH_WHILE);
}

/*
 *  CTxtRange::Paste (pVar, ClipboardFormat)
 *
 *  @mfunc
 *      Paste the data object <p pVar> into this range.  If
 *      <p pVar> is null, paste from the clipboard.
 *
 *  @rdesc
 *      HRESULT = (WriteAccessDenied) ? E_ACCESSDENIED :
 *                (if success) ? NOERROR : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtRange::Paste (
    VARIANT *pVar,              //@parm Data object to paste
    long     ClipboardFormat)   //@parm Desired clipboard format
{
#ifndef PEGASUS
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Paste");

    if(IsZombie())
        return CO_E_RELEASED;

    CCallMgr        callmgr(GetPed());
    HRESULT         hr;
    IDataObject *   pdo = NULL;         // Default clipboard
    IUndoBuilder *  publdr;
    CGenUndoBuilder undobldr(GetPed(), UB_AUTOCOMMIT, &publdr);

    if(WriteAccessDenied())
        return E_ACCESSDENIED;

    if(pVar)
        if (pVar->vt == VT_UNKNOWN)
            pVar->punkVal->QueryInterface(IID_IDataObject, (void **)&pdo);
        else if (pVar->vt == (VT_UNKNOWN | VT_BYREF))
            pdo = (IDataObject *)(*pVar->ppunkVal);

    hr = GetPed()->PasteDataObjectToRange (pdo, this,
        (WORD)ClipboardFormat, NULL, publdr, PDOR_NONE);

    if(pdo && pVar->vt == VT_UNKNOWN)
        pdo->Release();
    Update(TRUE);                       // Update selection
    return hr;
#else
    return 0;
#endif
}

/*
 *  ITextRange::ScrollIntoView(long Code)
 *
 *  @mfunc
 *      Method that scrolls this range into view according to the
 *      code Code defined below.
 *
 *  @rdesc
 *      HRESULT = (if success) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::ScrollIntoView (
    long Code)          //@parm Scroll code
{
#ifndef PEGASUS
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::ScrollIntoView");

    // Check for invalid bits
    if (Code & ~(tomStart + tomEnd + TA_LEFT + TA_TOP + TA_BOTTOM +
                TA_CENTER + TA_STARTOFLINE + TA_ENDOFLINE + TA_LOGICAL))
        return E_INVALIDARG;

    // Validate parameter
    long lCode = tomEnd;
    if (Code & tomStart)
        lCode = tomStart;

    Code &= ~tomStart;

    if(IsZombie())
        return CO_E_RELEASED;

    // Get local copy of ped to save some indirections.
    CTxtEdit *ped = GetPed();

    if (!ped->fInplaceActive())
    {
        // If the control is not active, we can't get the information
        // because no one knows what our client rect is.
        return E_FAIL;
    }

    // Get a local copy of display to save some indirections.
    CDisplay *pdp = ped->_pdp;

    if (pdp->IsFrozen())
    {
        return E_FAIL;
    }

    LONG cpStart;
    LONG cpForEnd;

    GetRange(cpStart, cpForEnd);

    // Get the view rectangle so we can compute the absolute x/y
    RECT rcView;
    pdp->GetViewRect(rcView, NULL);

    // Set up tp for PointFromTp call
    CRchTxtPtr rtp(*this);

    if(_cch > 0)
        rtp.Advance(-_cch);

    // Values used for making returned point locations absolute since
    // PointFromTp adjusts the point returned to be relative to the
    // display.
    const LONG xScrollAdj = pdp->GetXScroll() - rcView.left;
    const LONG yScrollAdj = pdp->GetYScroll() - rcView.top;

    // Get the left/top for the start
    BOOL     taMask = Code & TA_STARTOFLINE; //set beginning of line flag
    BOOL     fAtEnd = _cch ? TRUE : !rtp._rpTX.IsAfterEOP();
    POINT    ptStart;
    CLinePtr rpStart(pdp);
    LONG     iliStart = pdp->PointFromTp(rtp, NULL, _cch ? FALSE : fAtEnd,
                                         ptStart, &rpStart, (lCode == tomStart && Code) ?  Code :
                                         TA_TOP + TA_LEFT);
    ptStart.x += xScrollAdj;
    ptStart.y += yScrollAdj;

    // Get the right/bottom for the end
    rtp.SetCp(cpForEnd);

    POINT    ptEnd;
    CLinePtr rpEnd(pdp);
    LONG     iliEnd = pdp->PointFromTp(rtp, NULL, fAtEnd, ptEnd, &rpEnd,
                                       (lCode == tomEnd && Code) ?  Code :
                                       TA_BOTTOM + TA_RIGHT);
    ptEnd.x += xScrollAdj;
    ptEnd.y += yScrollAdj;

    //
    // Calculate the yScroll
    //

    // The basic idea is to display both the start and the end if possible. But
    // if it is not possible then display the requested end based on the input
    // parameter.

    LONG yHeightView = pdp->GetViewHeight();
    LONG yScroll;

    if (tomStart == lCode)
    {
        // Scroll the Start cp to the top of the view
        yScroll = ptStart.y;
    }
    else
    {
        // Scroll the End cp to the bottom of the view
        yScroll = ptEnd.y - yHeightView;
    }

    //
    // Calculate the X Scroll
    //

    // Default scroll to beginning of the line
    LONG xScroll = 0;

    // Make view local to save a number of indirections
    LONG xWidthView = pdp->GetViewWidth();

    if (iliStart == iliEnd)
    {
        // Entire selection is on the same line so we want to display as
        // much of it as is possible.
        LONG xWidthSel = ptEnd.x - ptStart.x;

        if (xWidthSel > xWidthView)
        {
            // Selection length is greater than display width
            if (tomStart == lCode)
            {
                // Show Start requested - just start from beginning
                // of selection
                xScroll = ptStart.x;
            }
            else
            {
                // Show end requested - show as much of selection as
                // possible, ending with last character in the
                // selection.
                xScroll = ptEnd.x - xWidthView;
            }
        }
        else if (xWidthSel < 0)
        {
            xWidthSel = -xWidthSel;
            if (xWidthSel > xWidthView)
            {
                if (tomStart == lCode)
                {
                    // Show Requested Start;
                    xScroll = max(0, ptStart.x - xWidthView);       
                }
                else
                {
                    xScroll = max(0, ptEnd.x - xWidthView);
                }
            }
            else if (ptEnd.x > xWidthView || ptStart.x > xWidthView)
            {
                // Check mask if position is outside the boundaries
                if (taMask)
                    xScroll = ptStart.x - xWidthView;
                else
                    xScroll = ptEnd.x - xWidthView;
            }       
        }
        else if (ptEnd.x > xWidthView || ptStart.x > xWidthView)
        {
            // Check mask if position is outside the boundaries
            if (taMask)
                xScroll = ptStart.x - xWidthView;
            else
                xScroll = ptEnd.x - xWidthView;
        }
    }   
    else
    {
        // Multiline selection. Display as much as possible of the requested
        // end's line.

        // Calc width of line
        LONG xWidthLine = (tomStart == lCode)
            ? rpStart->_xWidth + rpStart->_xLeft
            : rpEnd->_xWidth + rpEnd->_xLeft;


        // If line width is less than or equal to view, start at
        // 0 otherwise we need to adjust starting position to
        // show as much of the requested end's selection line
        // as possible.
        if(xWidthLine > xWidthView)
        {
            if(tomStart == lCode)
            {
                // Start end to be displayed

                if(xWidthLine - ptStart.x > xWidthView)
                {
                    // Selection is bigger than view, so start at beginning
                    // and display as much as possible.
                    xScroll = ptStart.x;
                }
                else
                {
                    // Remember that this is a multiline selection so the
                    // selection on this line goes from ptStart.x to the
                    // end of line. Since the selection width is less than
                    // the width of the view, we just back up the width
                    // of view to show the entire selection.
                    xScroll = xWidthLine - xWidthView;
                }
            }
            else
            {
                // Show the end of the selection. In the multiline case,
                // this goes from the beginning of the line to End. So
                // we only have to adjust if the End is beyond the view.
                if(ptEnd.x > xWidthView)
                {
                    // End beyond the view. Show as much as possible
                    // of the selection.
                    xScroll = ptEnd.x - xWidthView;
                }
            }
        }
    }

    // Do the scroll
    pdp->ScrollView(xScroll, yScroll, FALSE, FALSE);

    return S_OK;
#else
    return 0;
#endif
}

/*
 *  CTxtRange::Select ()
 *
 *  @mfunc
 *      Copy this range's cp's and story ptr to the active selection.
 *
 *  @rdesc
 *      HRESULT = (if selection exists) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::Select ()
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Select");

    if(IsZombie())
        return CO_E_RELEASED;

    CTxtSelection *pSel = GetPed()->GetSel();
    if(pSel)
    {
        LONG cpMin, cpMost;
        GetRange(cpMin, cpMost);
        pSel->SetRange(cpMin, cpMost);
        return NOERROR;
    }
    return S_FALSE;
}

/*
 *  CTxtRange::SetChar (Char)
 *
 *  @mfunc
 *      Set char at cpFirst = <p Char>
 *
 *  @rdesc
 *      HRESULT = (WriteAccessDenied) ? E_ACCESSDENIED :
 *                (char stored) ? NOERROR : S_FALSE
 *
 *  @devnote
 *      Special cases could be much faster, e.g., just overtype the plain-
 *      text backing store unless at EOD or EOR.  Code below uses a cloned
 *      range to handle all cases easily and preserve undo capability.
 */
STDMETHODIMP CTxtRange::SetChar (
    long Char)              //@parm New value for char at cpFirst
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetChar");
    
    if(IsZombie())
        return CO_E_RELEASED;

    CTxtEdit *      ped = GetPed();
    CCallMgr        callmgr(ped);
    TCHAR           ch = (TCHAR)Char;           // Avoid endian problems
    CTxtRange       rg(*this);
    IUndoBuilder *  publdr;
    CGenUndoBuilder undobldr(ped, UB_AUTOCOMMIT, &publdr);
    CFreezeDisplay  fd(ped->_pdp);

    if(WriteAccessDenied())
        return E_ACCESSDENIED;

    if(!ped->_pdp->IsMultiLine() && IsEOP(Char))// EOPs are not allowed in
        return FALSE;                           //  single-line edit controls

    undobldr.StopGroupTyping();

    rg.Collapser(tomStart);                     // Collapse at cpMin
    rg.SetExtend(TRUE);                         // Setup to select
    rg.Advance(1);                              // Try to select char at IP
    ped->OrCharFlags(GetCharFlags(ch), publdr);
    if(rg.ReplaceRange(1, &ch, publdr, SELRR_REMEMBERRANGE))
    {
        Update(TRUE);                           // Update selection
        return NOERROR;
    }
    return S_FALSE;
}

/*
 *  CTxtRange::SetEnd (cp)
 *
 *  @mfunc
 *      Set this range's End cp
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR : S_FALSE
 *
 *  @comm
 *      Note that setting this range's cpMost to <p cp> also sets cpMin to
 *      <p cp> if <p cp> < cpMin.
 */
STDMETHODIMP CTxtRange::SetEnd (
    long cp)                            //@parm Desired new End cp
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetEnd");

    if(IsZombie())
        return CO_E_RELEASED;

    LONG cpMin = GetCpMin();

    ValidateCp(cp);
    return SetRange(min(cpMin, cp), cp);        // Active end is End
}

/*
 *  CTxtRange::SetFont (pFont)
 *
 *  @mfunc
 *      Set this range's character attributes to those given by <p pFont>.
 *      This method is a "character format painter".
 *
 *  @rdesc
 *      HRESULT = (!pFont) ? E_INVALIDARG :
 *                (if success) ? NOERROR :
 *                (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtRange::SetFont (
    ITextFont * pFont)  //@parm Font object with desired character formatting
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetFont");

    if(!pFont)
        return E_INVALIDARG;
    
    if(IsZombie())
        return CO_E_RELEASED;

    ITextFont *pFontApply = (ITextFont *) new CTxtFont(this);

    if(!pFontApply)
        return E_OUTOFMEMORY;

    HRESULT hr;
    if(*(LONG *)pFontApply == *(LONG *)pFont)       // If same vtable, use
        hr = CharFormatSetter(&((CTxtFont *)pFont)->_CF, //  its copy
                    ((CTxtFont *)pFont)->_dwMask);
    else                                            // Else copy
        hr = pFontApply->SetDuplicate(pFont);       //  to clone and apply

    pFontApply->Release();
    return hr;
}

/*
 *  CTxtRange::SetFormattedText (pRange)
 *
 *  @mfunc
 *      Replace this range's text with formatted text given by <p pRange>.
 *      If <p pRange> is NULL, paste from the clipboard.
 *
 *  @rdesc
 *      HRESULT = (WriteAccessDenied) ? E_ACCESSDENIED :
 *                (if success) ? NOERROR : E_OUTOFMEMORY
 *
 *  @FUTURE
 *      Do this more efficiently if pRange points at a RichEdit range. This
 *      would also help with RichEdit D&D to RichEdit targets
 */
STDMETHODIMP CTxtRange::SetFormattedText (
    ITextRange * pRange)        //@parm Formatted text to replace this
                                // range's text
{
#ifndef PEGASUS
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetFormattedText");

    if(IsZombie())
        return CO_E_RELEASED;

    CCallMgr    callmgr(GetPed());
    LONG        cpMin = GetCpMin();
    HRESULT     hr;
    IUnknown *  pdo = NULL;
    VARIANT     vr;

    if(!pRange)
        return NOERROR;                 // Nothing to paste

    if(WriteAccessDenied())
        return E_ACCESSDENIED;

    VariantInit(&vr);
    vr.vt = VT_UNKNOWN | VT_BYREF;
    vr.ppunkVal = &pdo;

    hr = pRange->Copy(&vr);
    if(hr == NOERROR)
    {
        hr = Paste(&vr, 0);
        pdo->Release();                 // Release the data object
        _cch = GetCp() - cpMin;         // Select the new text
    }
    return hr;
#else
    return 0;
#endif
}

/*
 *  CTxtRange::SetIndex (Unit, Index, Extend)
 *
 *  @mfunc
 *      If <p Extend> is zero, convert this range into an insertion point
 *      at the start of the <p Index>th <p Unit> in the current story. If
 *      <p Extend> is nonzero, set this range to consist of this unit. The
 *      start of the story corresponds to <p Index> = 0 for all units.
 *
 *      Positive indices are 1-based and index relative to the beginning of
 *      the story.  Negative indices are -1-based and index relative to the
 *      end of the story.  So an index of 1 refers to the first Unit in the
 *      story and an index of -1 refers to the last Unit in the story.
 *
 *  @rdesc
 *      HRESULT = (invalid index) ? E_INVALIDARG :
 *                (Unit not supported) ? E_NOTIMPL :
 *                (change) ? NOERROR : S_FALSE
 *
 *  @devnote
 *      Currently moves out <p Index> <p Unit>s from the start of the story.
 *      Might be faster to move from current position, but would need to know
 *      the current index.
 */
STDMETHODIMP CTxtRange::SetIndex (
    long    Unit,           //@parm Unit to index
    long    Index,          //@parm Index value to use
    long    Extend)         //@parm if nonzero, set range to <p Unit>
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetIndex");
    
    if(IsZombie())
        return CO_E_RELEASED;

    if(!Index)
        return E_INVALIDARG;

    CCallMgr    callmgr(GetPed());

    LONG      cchText = GetTextLength();
    CTxtRange rg(GetPed());                     // Create IP at cp = 0

    if(Index > 0)                               // Index going forward First
        Index--;                                //  Unit is at start of story
    else                                        // Index from end of story
        rg.Set(cchText, cchText);               //  selecting whole story

    LONG    cUnit;
    HRESULT hr = rg.Mover(Unit, Index, &cUnit, MOVE_END);
    if(FAILED(hr))
        return hr;

    if(Index != cUnit || rg.GetCp() == cchText) // No such index in story
        return E_INVALIDARG;

    rg._cch = 0;                                // Collapse at active end
                                                //  namely at cpMost
    LONG cpMin, cpMost;
    if(Extend)                                  // Select Index'th Unit
        rg.Expander(Unit, TRUE, NULL, &cpMin, &cpMost);

    if(Set(rg.GetCp(), rg._cch))                // Something changed
    {
        Update(TRUE);
        return NOERROR;
    }
    return S_FALSE;
}

/*
 *  CTxtRange::SetPara (pPara)
 *
 *  @mfunc
 *      Set this range's paragraph attributes to those given by <p pPara>
 *      This method is a "Paragraph format painter".
 *
 *  @rdesc
 *      HRESULT = (!pPara) ? E_INVALIDARG :
 *                (if success) ? NOERROR :
 *                (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtRange::SetPara (
    ITextPara * pPara)      //@parm Paragraph object with desired paragraph
{                           //      formatting
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetPara");

    if(!pPara)
        return E_INVALIDARG;

    if(IsZombie())
        return CO_E_RELEASED;

    ITextPara * pParaApply = (ITextPara *) new CTxtPara(this);

    if(!pParaApply)
        return E_OUTOFMEMORY;

    HRESULT hr;

    if(*(LONG *)pParaApply == *(LONG *)pPara)       // If same vtable, use
    {                                               //  its _PF
        hr = ParaFormatSetter(&((CTxtPara *)pPara)->_PF,
                    ((CTxtPara *)pPara)->_dwMask);
    }
    else                                            // Else copy
       hr = pParaApply->SetDuplicate(pPara);        //  to clone and apply

    pParaApply->Release();
    return hr;
}

/*
 *  CTxtRange::SetPoint (x, y, Type, Extend)
 *
 *  @mfunc
 *      Select text at or up through (depending on <p Extend>) the point
 *      (<p x>, <p y>).
 *
 *  @rdesc
 *      HRESULT = NOERROR
 */
STDMETHODIMP CTxtRange::SetPoint (
    long    x,          //@parm Horizontal coord of point to select
    long    y,          //@parm Vertical   coord of point to select
    long    Type,       //@parm Defines the end to extend if Extend != 0.
    long    Extend)     //@parm Whether to extend selection to point
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetPoint");

    if(IsZombie())
        return CO_E_RELEASED;

    // Copy the ped locally once to save some indirections
    CTxtEdit *ped = GetPed();
    CCallMgr  callmgr(ped);

    if(Type != tomStart && Type != tomEnd)
        return E_INVALIDARG;

    if(!ped->fInplaceActive())
    {
        // If we aren't inplace active we can't get a DC to
        // calculate the cp.
        return OLE_E_NOT_INPLACEACTIVE;
    }

    // Convert (x, y) from screen coordinates to client coordinates
    POINT pt = {x, y};
    // Caller specifies screen coordinates?
    if ( !(Type & tomClientCoord) )
        if(!ped->TxScreenToClient(&pt))
            return E_FAIL;          // It is unexpected for this to happen

    // Get cp for (x, y)
    LONG cpSel = ped->_pdp->CpFromPoint(pt, NULL, NULL, NULL, TRUE);
    if(cpSel == -1)
        return E_FAIL;          // It is highly unexpected for this to fail

    // Extend range as requested
    LONG cchForSel = 0;
    if(Extend)
    {
        LONG cpMin, cpMost;
        GetRange(cpMin, cpMost);
        if(Type == tomStart)
            cchForSel = cpSel - cpMin;
        else
            cchForSel = cpSel - cpMost;
    }

    // Update range
    Set(cpSel, cchForSel);
    return S_OK;
}

/*
 *  CTxtRange::SetRange (cp1, cp2)
 *
 *  @mfunc
 *      Set this range's ends
 *
 *  @rdesc
 *      HRESULT = (cp1 > cp2) ? E_INVALIDARG
 *              : (if change) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::SetRange (
    long cp1,       //@parm Char position for Start end
    long cp2)       //@parm Char position for End end
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetRange");

    if(IsZombie())
        return CO_E_RELEASED;

    CCallMgr    callmgr(GetPed());
    LONG cpMin, cpMost;                 // Save starting cp's for
                                        //  change determination
    GetRange(cpMin, cpMost);
    ValidateCp(cp1);
    ValidateCp(cp2);

    Set(cp2, cp2 - cp1);
    GetRange(cp1, cp2);                 // See if either range end changed
    if(cp1 != cpMin || cp2 != cpMost)   //  (independent of active end)
    {
        Update(TRUE);                   // Update selection
        return NOERROR;
    }
    return S_FALSE;
}

/*
 *  CTxtRange::SetStart (cp)
 *
 *  @mfunc
 *      Set this range's Start cp
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR : S_FALSE
 *
 *  @comm
 *      Note that setting this range's cpMin to <p cp> also sets cpMost to
 *      <p cp> if <p cp> > cpMost.
 */
STDMETHODIMP CTxtRange::SetStart (
    long cp)                            //@parm Desired new Start cp
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetStart");
    
    if(IsZombie())
        return CO_E_RELEASED;

    LONG cpMost = GetCpMost();

    ValidateCp(cp);
    return SetRange(max(cpMost, cp), cp);       // Active end is Start
}

/*
 *  CTxtRange::SetText (bstr)
 *
 *  @mfunc
 *      Replace text in this range by that given by <p bstr>.  If <p bstr>
 *      is NULL, delete text in range.
 *
 *  @rdesc
 *      HRESULT = (WriteAccessDenied) ? E_ACCESSDENIED :
 *                (if success) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::SetText (
    BSTR bstr)          //@parm Text to replace text in this range by
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetText");

    if(IsZombie())
        return CO_E_RELEASED;

    CCallMgr callmgr(GetPed());

    if(WriteAccessDenied())
        return E_ACCESSDENIED;

    LONG cchNew = bstr ? SysStringLen(bstr) : 0;
    _cch = Replacer(cchNew, (TCHAR *)bstr, RR_ITMZ_UNICODEBIDI);    // Select the new text

    _TEST_INVARIANT_

    GetPed()->TxSetMaxToMaxText();

    return _cch == cchNew ? NOERROR : S_FALSE;
}

/*
 *  CTxtRange::StartOf (Unit, Extend, pDelta)
 *
 *  @mfunc
 *      Move this range end(s) to start of the first overlapping Unit in
 *      the range.
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR :
 *                (if <p Unit> valid) ? S_FALSE : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::StartOf (
    long    Unit,           //@parm Unit to use
    long    Extend,         //@parm If true, leave other end alone
    long *  pDelta)         //@parm Out parm to get count of chars that
                            //      StartOf moved
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::StartOf");

    CCallMgr callmgr(GetPed());
    LONG     cpMin;
    HRESULT  hr = Expander (Unit, Extend, pDelta, &cpMin, NULL);

    if(hr == NOERROR)
        Update(TRUE);                   // Update selection

    return hr;
}


//---------------------- CTxtRange ITextSelection stubs -----------------------------

// Dummy CTxtRange routines to simplify CTxtSelection inheritance hierarchy

STDMETHODIMP CTxtRange::GetFlags (long * pFlags)
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetFlags");
    return E_NOTIMPL;
}

STDMETHODIMP CTxtRange::SetFlags (long Flags)
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetFlags");
    return E_NOTIMPL;
}

STDMETHODIMP CTxtRange::GetType (long * pType)
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetType");
    return E_NOTIMPL;
}

STDMETHODIMP CTxtRange::MoveLeft (long Unit, long Count, long Extend, long * pDelta)
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Left");
    return E_NOTIMPL;
}

STDMETHODIMP CTxtRange::MoveRight (long Unit, long Count, long Extend, long * pDelta)
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Right");
    return E_NOTIMPL;
}

STDMETHODIMP CTxtRange::MoveUp (long Unit, long Count, long Extend, long * pDelta)
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Up");
    return E_NOTIMPL;
}

STDMETHODIMP CTxtRange::MoveDown (long Unit, long Count, long Extend, long * pDelta)
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Down");
    return E_NOTIMPL;
}

STDMETHODIMP CTxtRange::HomeKey (long Unit, long Extend, long * pDelta)
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::HomeKey");
    return E_NOTIMPL;
}

STDMETHODIMP CTxtRange::EndKey (long Unit, long Extend, long * pDelta)
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::EndKey");
    return E_NOTIMPL;
}

STDMETHODIMP CTxtRange::TypeText (BSTR bstr)
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::TypeText");
    return E_NOTIMPL;
}


//--------------------- ITextRange Private Helper Methods -----------------------------

/*
 *  @doc INTERNAL
 *
 *  CTxtRange::Collapser (bStart)
 *
 *  @mfunc
 *      Internal routine to collapse this range into a degenerate point
 *      either at the the start (<p bStart> is nonzero or the end
 *      (<p bStart> = 0)
 */
void CTxtRange::Collapser (
    long bStart)            //@parm Flag specifying end to collapse at
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEEXTERN, "CTxtRange::Collapser");

    if(bStart)                          // Collapse to Start
    {
        if(_cch > 0)
            FlipRange();                // Move active end to range Start
    }
    else                                // Collapse to End
    {
        if(_cch < 0)
            FlipRange();                // Move active end to range End

        const LONG cchText = GetAdjustedTextLength();

        if(GetCp() > cchText)           // IP can't follow final CR
            Set(cchText, 0);            //  so move it before
    }
    if(_cch)
        _fMoveBack = bStart != 0;
    _cch = 0;                           // Collapse this range
    _fSelHasEOP = FALSE;                // Insertion points don't have
    _fSelHasCell = FALSE;               //  EOPs or Cells

    if(_fSel)                           // Notify if selection changed
        GetPed()->GetCallMgr()->SetSelectionChanged();

    Update_iFormat(-1);                 // Make sure format is up to date
}

/*
 *  CTxtRange::Comparer(pRange)
 *
 *  @mfunc
 *      helper function for CTxtRange::InRange() and IsEqual()
 *
 *  @rdesc
 *      0 if not same story or if this range isn't contained by <p pRange>;
 *      -1 if ranges are equal; 1 if this range wholely contained in
 *      <p pRange>.
 *
 *  @comm
 *      Note that if this range is degenerate and *pRange is nondegenerate,
 *      this range is not included in *pRange if it's located at pRange's
 *      End position.
 */
LONG CTxtRange::Comparer (
    ITextRange * pRange)        //@parm ITextRange to compare with
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtRange::Comparer");

    LONG    cpMin, cpMost;
    LONG    Start, End;

    if(InStory(pRange, NULL) != NOERROR)    // If this range doesn't point at
        return 0;                           //  same story as pRange's,
                                            //  return 0
    GetRange(cpMin, cpMost);                // Get this range's cp's
    pRange->GetStart(&Start);               // Get pRange's cp's
    pRange->GetEnd(&End);
    if(cpMin == Start && cpMost == End)     // Exact match
        return -1;
    return cpMin >= Start && cpMost <= End && cpMin < End;
}

/*
 *  CTxtRange::Expander (Unit, fExtend, pDelta, pcpMin, pcpMost)
 *
 *  @mfunc
 *      Helper function that expands this range so that partial Units it
 *      contains are completely contained according to the out parameters
 *      pcpMin and pcpMost.  If pcpMin is not NULL, the range is expanded to
 *      the beginning of the Unit.  Similarly, if pcpMost is not NULL, the
 *      range is expanded to the end of the Unit. <p pDelta> is an out
 *      parameter that receives the number of chars added to the range.
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR :
 *                (if Unit valid) ? S_FALSE : E_INVALIDARG
 *
 *  @devnote
 *      Used by ITextRange::Expand(), StartOf(), and EndOf(). Both pcpMin and
 *      pcpMost are nonNULL for Expand().  pcpMin is NULL for EndOf() and
 *      pcpMost is NULL for StartOf().
 *
 *  @future
 *      Discontiguous Units. Expander should expand only to end of Unit,
 *      rather than to start of next Unit.
 */
HRESULT CTxtRange::Expander (
    long    Unit,       //@parm Unit to expand range to
    BOOL    fExtend,    //@parm Expand this range if TRUE
    LONG *  pDelta,     //@parm Out parm that receives chars added
    LONG *  pcpMin,     //@parm Out parm that receives new cpMin
    LONG *  pcpMost)    //@parm Out parm that receives new cpMost
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtRange::Expander");
    
    if(IsZombie())
        return CO_E_RELEASED;

    LONG    cch = 0;                        // Default no chars added
    LONG    cchRange;
    LONG    cchAdjustedText = GetAdjustedTextLength();
    LONG    cchText = GetTextLength();
    LONG    cp;
    LONG    cpMin, cpMost;
    BOOL    fUnitFound = TRUE;              // Most Units can be found
    LONG    cchCollapse;
    CDisplay *pdp;                          //  but tomObject maybe not

    GetRange(cpMin, cpMost);                // Save starting cp's
    if(pcpMin)                              // Default no change
    {
        *pcpMin = cpMin;
        AssertSz(!pcpMost || fExtend,
            "CTxtRange::Expander should extend if both pcpMin and pcpMost != 0");
    }
    if(pcpMost)
        *pcpMost = cpMost;
    if(pDelta)
        *pDelta = 0;

    if(Unit < 0)
    {
        // Valid attribute Units are high bit plus any combo of CFE_xxx.
        // CFE_REVISED is most significant value currently defined.
        if(Unit & ~(2*CFM_REVISED - 1 + 0x80000000))
            return E_NOTIMPL;
        FindAttributes(pcpMin, pcpMost, Unit);
    }
    else
    {
        switch(Unit)                        // Calculate new cp's
        {
        case tomObject:
            fUnitFound = FindObject(pcpMin, pcpMost);
            break;

        case tomCharacter:
            if (pcpMost && cpMin == cpMost &&// EndOf/Expand insertion point
                cpMost < cchText &&         //  with at least 1 more char
                (!cpMost || pcpMin))        //  at beginning of story or
            {                               //  Expand(), then
                (*pcpMost)++;               //  expand by one char
            }
            break;

        case tomCharFormat:
            _rpCF.FindRun (pcpMin, pcpMost, cpMin, _cch, cchText);
            break;

        case tomParaFormat:
            _rpPF.FindRun (pcpMin, pcpMost, cpMin, _cch, cchText);
            break;

        case tomWord:
            FindWord (pcpMin, pcpMost, FW_INCLUDE_TRAILING_WHITESPACE);
            break;

        case tomSentence:
            FindSentence (pcpMin, pcpMost);
            break;

        case tomCell:
            FindCell (pcpMin, pcpMost);
            break;

        case tomRow:
            _rpPF.AdjustForward();
            if(InTable())                   // In our simple table model,
                goto para;                  //  each row is a single para
            break;                          

        case tomLine:
            pdp = GetPed()->_pdp;
            if(pdp)                         // If this story has a display
            {                               //  use line array
                CLinePtr rp(pdp);
                cp = GetCp();
                pdp->WaitForRecalc(cp, -1);
                rp.RpSetCp(cp, FALSE);
                rp.FindRun (pcpMin, pcpMost, cpMin, _cch, cchText);
                break;
            }                               // Else fall thru to tomPara

        case tomParagraph:
    para:   FindParagraph(pcpMin, pcpMost);
            break;

        case tomWindow:
            fUnitFound = FindVisibleRange(pcpMin, pcpMost);
            break;

        case tomStory:
            if(pcpMin)
                *pcpMin = 0;
            if(pcpMost)
                *pcpMost = cchText;
            break;

        default:
            return E_NOTIMPL;
        }
    }
    if(!fUnitFound)
        return S_FALSE;

    cchCollapse = !fExtend && _cch;         // Collapse counts as a char
                                            // Note: Expand() has fExtend = 0
    if(pcpMin)
    {
        cch = cpMin - *pcpMin;              // Default positive cch for Expand
        cpMin = *pcpMin;
    }

    if(pcpMost)                             // EndOf() and Expand()
    {
        if(!fExtend)                        // Will be IP if not already
        {
            if(cpMost > cchAdjustedText)    // If we collapse (EndOf only),
                cchCollapse = -cchCollapse; //  it'll be before the final CR
            else
                *pcpMost = min(*pcpMost, cchAdjustedText);
        }
        cch += *pcpMost - cpMost;
        cp = cpMost = *pcpMost;
    }
    else                                    // StartOf()
    {
        cch = -cch;                         // Invert count
        cp = cpMin;                         // Active end at cpMin
        cchCollapse = -cchCollapse;         // Backward collapses count as -1
    }

    cch += cchCollapse;                     // Collapse counts as a char
    if(cch)                                 // One or both ends changed
    {
        cchRange = cpMost - cpMin;          // cch for EndOf() and Expand()
        if(!pcpMost)                        // Make negative for StartOf()
            cchRange = -cchRange;
        if(!fExtend)                        // We're not expanding (EndOf()
            cchRange = 0;                   //  or StartOf() call)
        if(Set(cp, cchRange))               // Set active end and signed cch
        {                                   // Something changed
            if(pDelta)                      // Report cch if caller cares
                *pDelta = cch;
            return NOERROR;
        }
    }
    
    return S_FALSE;                         // Report Unit found but no change
}

/*
 *  CTxtRange::Finder (bstr, Count, dwFlags, pDelta, Mode)
 *
 *  @mfunc
 *      Helper find function that moves active end up to <p cch> characters
 *      subject to compare flags <p Flags> and the <p Mode>, which has the
 *      following possible values:
 *
 *      1:  set this range's cpMost = cpMost of matched string
 *      0:  set this range's cp's equal to those of matched string
 *      -1: set this range's cpMin = cpMin of matched string
 *
 *      Return *<p pDelta> = # characters past.
 *
 *  @rdesc
 *      HRESULT = (if <p bstr> found) ? NOERROR : S_FALSE
 *
 *  @devnote
 *      Used by ITextRange::FindText(), FindTextStart() and FindTextEnd()
 */
HRESULT CTxtRange::Finder (
    BSTR    bstr,       //@parm String to find
    long    Count,      //@parm Max count of chars to search
    long    Flags,      //@parm Flags governing compares
    LONG *  pDelta,     //@parm Out parm to receive count of chars moved
    MOVES   Mode)       //@parm Governs setting of range wrt matched string
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtRange::Finder");

    if(!bstr)
        return S_FALSE;

    if(IsZombie())
        return CO_E_RELEASED;

    CCallMgr    callmgr(GetPed());

    LONG        cpMin, cpMost;
    LONG        cch = GetRange(cpMin, cpMost);  // Get this range's cp's
    LONG        cchBstr = SysStringLen(bstr);
    LONG        cchSave = _cch;
    LONG        cp, cpMatch, cpSave;
    LONG        cpStart = cpMost;               // Default Start cp to range
    CRchTxtPtr  rtp(*this);                     //  End

    if(Mode == MOVE_IP)                         // FindText(): Count = 0 is
    {                                           //  treated specially: if IP,
        if(!Count)                              //  compare string at IP; else
            Count = cch ? cch : cchBstr;        //  confine search to range
        if(Count > 0)                           // Forward searches start from
            cpStart = cpMin;                    //  beginning of range
    }
    else                                        // FindTextStart() or
    {                                           //   FindTextEnd()
        if(!Count)                              // Compare string at IP; else
            Count = cch ? -Mode*cch : cchBstr;  //  confine search to range
        if(Mode < 0)                            // Find from Start
            cpStart = cpMin;
    }

    cpSave = cpStart;                           // Save starting cp
    cp = cpStart + Count;                       // cp = limiting cp. Can be on
    cp = max(cp, 0);                            //  either side of cpStart
    Flags &= ~FR_DOWN;                          // Default search backward
    if(Count >= 0)                              // It's forward, so set
        Flags |= FR_DOWN;                       //  downward search bit

find:
    rtp.SetCp(cpStart);                         // Move to start of search
    cpMatch = rtp.FindText(cp, Flags, bstr, cchBstr);
    if (Mode == MOVE_IP && cpMatch == cpMin &&  // Ordinary Find matched
        rtp.GetCp() == cpMost)                  //  current range
    {
        Assert(cpStart == cpSave);              // (Can't loop twice)
        cpStart += Count > 0 ? 1 : -1;          // Move over one char
        goto find;                              //  and try again
    }

    if(cpMatch < 0)                             // Match failed
    {
        if(pDelta)                              // Return match string length
            *pDelta = 0;                        //  = 0
        return S_FALSE;                         // Signal no match
    }


    // Match succeeded: set new cp and cch for range, update selection (if
    // this range is a selection), send notifications, and return NOERROR

    cp = rtp.GetCp();                           // cp = cpMost of match string
    if(pDelta)                                  // Return match string length
        *pDelta = cchBstr;                      //  if caller wants to know

    cch = cp - cpMatch;                         // Default to select matched
                                                //  string (for MOVE_IP)
    if(Mode != MOVE_IP)                         // MOVE_START or MOVE_END
    {
        if(Mode == MOVE_START)                  // MOVE_START moves to start
            cp = cpMatch;                       //  of matched string
        cch = cp - cpSave;                      // Distance end moved
        if(!cchSave && (Mode ^ cch) < 0)        // If crossed ends of initial
            cch = 0;                            //  IP, use an IP
        else if(cchSave)                        // Initially nondegenerate
        {                                       //  range
            if((cchSave ^ Mode) < 0)            // If wrong end is active,
                cchSave = -cchSave;             //  fake a FlipRange to get
            cch += cchSave;                     //  new length
            if((cch ^ cchSave) < 0)             // If ends would cross,
                cch = 0;                        //  convert to insertion point
        }
    }
    if ((cp != GetCp() || cch != _cch)          // Active end and/or length of
        && Set(cp, cch))                        //  range changed
    {                                           // Use the new values
        Update(TRUE);                           // Update selection
    }
    return NOERROR;
}

/*
 *  CTxtRange::Matcher (Cset, Count, pDelta, fExtend, Match)
 *
 *  @mfunc
 *      Helper function to move active end up to <p cch> characters past
 *      all contiguous characters that are (<p Match> ? in : not in) the cset
 *      *<p pvar>.  If <p fExtend>, extend the range to include the characters
 *      past by. Return *<p pDelta> = # characters past by.
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR :
 *                (if <p Cset> valid) ? S_FALSE : E_INVALIDARG
 */
HRESULT CTxtRange::Matcher (
    VARIANT *   Cset,       //@parm Character match set
    long        Count,      //@parm Max cch to match
    long *      pDelta,     //@parm Out parm for cch moved
    MOVES       Mode,       //@parm MOVE_START (-1), MOVE_IP (0), MOVE_END (1)
    MATCHES     Match)      //@parm MATCH_WHILE spans Cset; else break on Cset
{
#ifndef PEGASUS
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtRange::Matcher");

    // This (and other) code assumes the following conditions:
    Assert(MOVE_START == -1 && MOVE_IP == 0 && MOVE_END == 1);
    Assert(MATCH_UNTIL == 0 && MATCH_WHILE == 1);
    Assert(sizeof(WORD) == 2);                      // 16-bit WORDs

    if(!Cset)
        return E_INVALIDARG;

    if(IsZombie())
        return CO_E_RELEASED;

    CCallMgr    callmgr(GetPed());
    LONG    cch;                                    // For cch moved
    TCHAR   ch;                                     // Current char
    LONG    count = Count;                          // Count down variable
    LONG    cpSave;                                 // To save initial cp
    WORD    ctype;                                  // CT_TYPEx info for ch
    long    Delta;                                  // Value for *pDelta
    BOOL    fInCset;                                // TRUE iff ch in Cset
    UINT    i, j;                                   // Handy indices
    LONG    iDir = (Count > 0) ? 1 : -1;            // Count increment
    long    lVal = Cset->lVal;
    TCHAR * pch;                                    // Used to walk BSTR Cset
    CTxtPtr tp(_rpTX);                              // tp to walk text with
    LONG    vt = Cset->vt;

    if(pDelta)                                      // Default neither motion
        *pDelta = 0;                                //  nor match

    if (Mode == MOVE_IP && (_cch ^ Count) < 0 ||    // Wrong active end:
        Mode != MOVE_IP && (_cch ^ Mode)  < 0)
    {
        tp.AdvanceCp(-_cch);                        //  go to other end
    }
    cpSave = tp.GetCp();                            // Save cp for checks

    if(Count > 0)                                   // If matching forward,
    {                                               //  get current char
        ch = tp.GetChar();
        count--;                                    // One less char to match
    }
    else                                            // If matching backward,
        ch = tp.NextCharCount(count);               //  start at previous char
                                                    
    if(!ch)                                         // At one end or other, so
        return S_FALSE;                             //  signal no match


    // Process built-in and explicit character sets
    if(vt & VT_BYREF)                               // VB passes VT_BYREF
    {                                               //  unless args are
        lVal = *Cset->plVal;                        //  enclosed in ()'s
        vt &= ~ VT_BYREF;
    }

    if(vt == VT_I2)                                 // Should be VT_I4, but
        lVal &= 0xffff;                             //  facilitate common cases

    // Built-in char set: either Unicode range or CT_CTYPEx
    if(vt == VT_I4 || vt == VT_I2)
    {
        i = lVal & 0xffff;                          // First code or CT mask
        j = lVal >> 16;                             // Size of range
        if(lVal < 0)                                // Unicode range Cset
        {                                           //  (sign bit is set)
            j &= 0x7fff;                            // Kill sign bit
            while (((BOOL)Match ^ (ch - i > j)) &&      // ch in range or not
                   (ch = tp.NextCharCount(count)))  // Another char available
                   ;                                // Note: count is passed
        }                                           //  by reference
        else                                        // CT_CTYPEx Cset
        {                                           // CT_CTYPEx is given by
            if(!j)                                  //  upper WORD of lVal
                j = CT_CTYPE1;                      // 0 defaults to CT_CTYPE1
            do
            {
                ctype = 0;                          // For each char, get
                                                    //  string type info
                W32->GetStringTypeEx(0, j, &ch, 1, &ctype);

                // Loop (up to |Count| - 1 times) as long as the characters
                // encountered are in the Cset (Match = MATCH_WHILE (=1)),
                // or as long as they are not  (Match = MATCH_UNTIL (=0)).

                fInCset = (j == CT_CTYPE2)          // CT_CTYPE2 values are
                        ? (ctype == i)              //  mutually exclusive;
                        : (ctype & i) != 0;         //  others can be combos

            } while ((Match ^ fInCset) == 0 &&
                     (ch = tp.NextCharCount(count)) != 0);
        }                                           // End of built-in Csets
    }                                               // End of Cset VT_I4

    // Explicit char set given by chars in Cset->bstrVal
    else if (Cset->vt == VT_BSTR)
    {
        //REVIEW (keithcu) What is going on here?
        if((DWORD_PTR)Cset->bstrVal < 0xfffff)      // Don't get fooled by
            return E_INVALIDARG;                    //  invalid vt values
        j = SysStringLen(Cset->bstrVal);
        do
        {                                           // Set i = 0 if ch isn't
            pch = Cset->bstrVal;                //  in set; this stops
            for(i = j;                              //  movement
                i && (ch != *pch++);                
                i--) ;
        
        // If we are doing a MATCH_WHILE routine then we only
        // continue while i > 0 becuase this indicates that we
        // found the char at the current cp in the CSet.  If
        // we were doing a MATCH_UNTIL then we should quit when
        // i != 0 becuase the current char was in the CSet.
        } while((Match == (i ? MATCH_WHILE : MATCH_UNTIL)) &&
            (ch = tp.NextCharCount(count)));        // Break if no more chars
    }                                               //  or ch not in set
    else
        return E_INVALIDARG;

    /* If MoveWhile, leave tp immediately after last matched char going
     * forward and at that char going backward (helps to think of tp
     * pointing in between chars).  If MoveUntil, leave tp at the char
     * going forward and just after that char going backward.
     *
     * E.g.: the code
     *
     *      r.MoveUntil   (C1_DIGIT, tomForward, NULL)
     *      r.MoveEndWhile(C1_DIGIT, tomForward, NULL)
     *
     * breaks at the first digit and selects the number going forward.
     * Similarly
     *
     *      r.MoveUntil     (C1_DIGIT, tomBackward, NULL)
     *      r.MoveStartWhile(C1_DIGIT, tomBackward, NULL)
     *
     * selects the number going backward.
     */
    count = (Match == MATCH_WHILE && !ch)           // If MoveWhile, move past
          ? iDir : 0;                               //  last matched char
    if(Count < 0)
        count++;
    tp.AdvanceCp(count);

    Delta = cch = 0;                                // Suppress motion unless
    if(Match == MATCH_WHILE || ch)                  //  match occurred
    {
        Delta = cch = tp.GetCp() - cpSave;          // Calculate distance moved
        if(Match == MATCH_UNTIL)                    // For MoveUntil methods,
            Delta += iDir;                          //  match counts as a char
    }

    if(pDelta)                                      // Report motion to caller
        *pDelta = Delta;                            //  if it wants to know

    // Handle cases for which range is changed
    if(cch || (Delta && _cch && Mode == MOVE_IP))
    {
        if (Mode == MOVE_IP ||                      // If move IP or asked to
            !_cch && (Mode ^ Count) < 0)            //  cross ends of initial
        {                                           //  IP, use an IP
            cch = 0;
        }
        else if(_cch)                               // Initially nondegenerate
        {                                           //  range
            if((_cch ^ Mode) < 0)                   // If wrong end is active,
                _cch = -_cch;                       //  fake a FlipRange (will
            cch += _cch;                            //  set cp shortly)
            if((cch ^ _cch) < 0)                    // If ends crossed, convert
                cch = 0;                            //  to insertion point
        }
        if(Set(tp.GetCp(), cch))                    // Set new range cp and cch
        {
            Update(TRUE);                           // Update selection
            return NOERROR;                         // Signal match occurred
        }
        return S_FALSE;
    }

    // No change in range. Return NOERROR iff match occurred for MOVE_UNTIL
    return Delta ? NOERROR : S_FALSE;
#else
    return 0;
#endif
}

/*
 *  CTxtRange::Mover (Unit, Count, pDelta, Mode)
 *
 *  @mfunc
 *      Helper function to move end(s) <p Count> <p Unit>s, which end(s)
 *      depending on Mode = MOVE_IP, MOVE_START, and MOVE_END.  Collapsing
 *      the range by using MOVE_IP counts as a Unit.
 *
 *      Extends range from End if <p Mode> = MOVE_END and from Start if
 *      <p Mode> = MOVE_START; else (MOVE_IP) it collapses range to Start if
 *      <p Count> <lt>= 0 and to End if <p Count> <gt> 0.
 *
 *      Sets *<p pDelta> = count of Units moved
 *
 *      Used by ITextRange::Delete(), Move(), MoveStart(), MoveEnd(),
 *      and SetIndex()
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR :
 *                (if <p Unit> valid) ? S_FALSE : E_INVALIDARG
 */
HRESULT CTxtRange::Mover (
    long    Unit,       //@parm Unit to use for moving active end
    long    Count,      //@parm Count of units to move active end
    long *  pDelta,     //@parm Out parm for count of units moved
    MOVES   Mode)       //@parm MOVE_START (-1), MOVE_IP (0), MOVE_END (1)
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtRange::Mover");

    if(pDelta)
        *pDelta = 0;                            // Default no units moved

    if(IsZombie())
        return CO_E_RELEASED;

    LONG      cch;
    LONG      cchAdj = GetAdjustedTextLength();
    LONG      cchMax = 0;                       // Default full story limits
    LONG      cp;
    LONG      cpMost = GetCpMost();
    LONG      cUnitCollapse = 0;
    HRESULT   hr = NOERROR;
    CTxtRange rg(*this);                        // Use a copy to look around

    if(pDelta)
        *pDelta = 0;                            // Default no units moved

    if(_cch && Count)                           // Nondegenerate range
    {
        if(Mode == MOVE_IP)                     // Insertion point: will
        {                                       //  collapse range if Unit is
            if((Count ^ rg._cch) < 0)           //  defined. Go to correct end
                rg.FlipRange();
            if(Count > 0)
            {
                if(cpMost > cchAdj)
                {
                    cUnitCollapse = -1;         // Collapse before final CR
                    Count = 0;                  // No more motion
                }
                else
                {   //               Extend pDelta pcpMin pcpMost
                    hr = rg.Expander(Unit, FALSE, NULL, NULL, &cp);
                    cUnitCollapse = 1;          // Collapse counts as a Unit
                    Count--;                    // One less Unit to count
                }
            }
            else
            {
                hr = rg.Expander(Unit, FALSE, NULL, &cp, NULL);
                cUnitCollapse = -1;
                Count++;
            }
            if(FAILED(hr))
                return hr;
        }
        else if((Mode ^ rg._cch) < 0)           // MOVE_START or MOVE_END
            rg.FlipRange();                     // Go to Start or End
    }

    if(Count > 0 && Mode != MOVE_END)           // Moving IP or Start forward
    {
        cchMax = cchAdj - rg.GetCp();           // Can't pass final CR
        if(cchMax <= 0)                         // Already at or past it
        {                                       // Only count comes from
            Count = cUnitCollapse;              //  possible collapse
            cp = cchAdj;                        // Put active end at cchAdj
            cch = (Mode == MOVE_START && cpMost > cchAdj)
                ? cp - cpMost : 0;
            goto set;
        }
    }

    cch = rg.UnitCounter(Unit, Count, cchMax);  // Count off Count Units

    if(cch == tomForward)                       // Unit not implemented
        return E_NOTIMPL;
    
    if(cch == tomBackward)                      // Unit not available, e.g.,
        return S_FALSE;                         //  tomObject and no objects

    Count += cUnitCollapse;                     // Add a Unit if collapse
    if(!Count)                                  // Nothing changed, so quit
        return S_FALSE;

    if (Mode == MOVE_IP ||                      // MOVE_IP or
        !_cch && (Mode ^ Count) < 0)            //  initial IP end cross
    {
        cch = 0;                                // New range is degenerate
    }
    else if(_cch)                               // MOVE_START or MOVE_END
    {                                           //  with nondegenerate range
        if((_cch ^ Mode) < 0)                   // Make _cch correspond to end
            _cch = -_cch;                       //  that moved
        cch += _cch;                            // Possible new range length
        if((cch ^ _cch) < 0)                    // Nondegenerate end cross
            cch = 0;                            // Use IP
    }
    cp = rg.GetCp();

set:
    if(Set(cp, cch))                            // Attempt to set new range
    {                                           // Something changed
        if(pDelta)                              // Report count of units
            *pDelta = Count;                    //  advanced
        Update(TRUE);                           // Update selection
        return NOERROR;
    }
    return S_FALSE;
}

/*
 *
 *  CTxtRange::Replacer (cchNew, *pch)
 *  
 *  @mfunc
 *      Replace this range's using CHARFORMAT _iFormat and updating other
 *      text runs as needed.
 *
 *      Same as CTxtRange::CleanseAndReplaceRange(cchNew, *pch, publdr),
 *      except creates its own undo builder.
 *  
 *  @rdesc
 *      cch of text actually pasted
 *  
 *  @devnote
 *      moves this text pointer to end of replaced text and
 *      may move text block and formatting arrays
 */
LONG CTxtRange::Replacer (
    LONG            cchNew,     //@parm Length of replacement text
    TCHAR const *   pch,        //@parm Replacement text
    DWORD           dwFlags)    //@parm ReplaceRange flags
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtRange::Replacer");

    IUndoBuilder *  publdr;
    CGenUndoBuilder undobldr(GetPed(), UB_AUTOCOMMIT, &publdr);

    undobldr.StopGroupTyping();

    // Note: we don't check the limit on text here. Right now, this
    // is only called by Delete and SetText so this is OK. However,
    // we might want to reinvestigate this latter if this is called
    // by anything else.
    return CleanseAndReplaceRange(cchNew, pch, FALSE, publdr, NULL, NULL, dwFlags);
}

/*
 *  CTxtRange::CharFormatSetter (pCF)
 *
 *  @mfunc
 *      Helper function that's the same as CTxtRange::SetCharFormat(), but
 *      adds undo building, and notification.
 *
 *  @rdesc
 *      HRESULT = (if success) ? NOERROR : S_FALSE
 *                (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
HRESULT CTxtRange::CharFormatSetter (
    const CCharFormat *pCF, //@parm CCharFormat to fill with results
    DWORD         dwMask)   //@parm CHARFORMAT2 mask
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtRange::CharFormatSetter");

    if(IsZombie())
        return CO_E_RELEASED;

    CTxtEdit *ped = GetPed();
    CCallMgr        callmgr(ped);
    IUndoBuilder *  publdr;
    CGenUndoBuilder undobldr(ped, UB_AUTOCOMMIT, &publdr);

    if(WriteAccessDenied())
        return E_ACCESSDENIED;

    undobldr.StopGroupTyping();
    return SetCharFormat(pCF, FALSE, publdr, dwMask, 0);
}

/*
 *  CTxtRange::ParaFormatSetter (pPF, dwMask)
 *
 *  @mfunc
 *      Helper function that's the same as CTxtRange::SetParaFormat(), but
 *      adds protection checking, undo building, and notification.
 *
 *  @rdesc
 *      HRESULT = (if success) ? NOERROR : S_FALSE
 *                (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
HRESULT CTxtRange::ParaFormatSetter (
    const CParaFormat *pPF, //@parm CParaFormat to fill with results
    DWORD           dwMask) //@parm Mask to use
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtRange::ParaFormatSetter");

    if(IsZombie())
        return CO_E_RELEASED;

    CTxtEdit *ped = GetPed();
    CCallMgr        callmgr(ped);
    IUndoBuilder *  publdr;
    CGenUndoBuilder undobldr(ped, UB_AUTOCOMMIT, &publdr);

    if(WriteAccessDenied())
        return E_ACCESSDENIED;

    undobldr.StopGroupTyping();
    // In RichEdit 3.0, we don't support setting tables
    if(GetPF()->InTable())
        dwMask &= ~PFM_TABSTOPS;
    return SetParaFormat(pPF, publdr, dwMask & ~PFM_TABLE);
}

/*
 *  CTxtRange::WriteAccessDenied()
 *
 *  @mfunc
 *      Returns TRUE iff at least part of the range is protected and the
 *      owner chooses to enforce it
 *
 *  @rdesc
 *      TRUE iff write access to range is denied
 */
BOOL CTxtRange::WriteAccessDenied ()
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtRange::WriteAccessDenied");

    int       iProt;
    CTxtEdit *ped = GetPed();

    if (ped && ped->TxGetReadOnly() ||
        ((iProt = IsProtected(-1)) == PROTECTED_YES ||
        (iProt == PROTECTED_ASK && ped->IsProtectionCheckingEnabled() &&
         ped->QueryUseProtection(this, 0, 0, 0))))
    // N.B.  the preceding if statement assumes that IsProtected returns a tri-value
    {
        return TRUE;
    }

    return FALSE;
}

/*
 *  CTxtRange::IsTrue (f, pB)
 *
 *  @mfunc
 *      Return *<p pB> = tomTrue iff <p f> is nonzero and pB isn't NULL
 *
 *  @rdesc
 *      HRESULT = (f) ? NOERROR : S_FALSE
 */
HRESULT CTxtRange::IsTrue(BOOL f, long *pB)
{
    if(pB)
        *pB = tomFalse;
    
    if(IsZombie())
        return CO_E_RELEASED;

    if(f)
    {
        if(pB)
            *pB = tomTrue;
        return NOERROR;
    }

    return S_FALSE;
}

/*
 *  CTxtRange::GetLong (lValue, pLong)
 *
 *  @mfunc
 *      Return *pLong = lValue provided pLong isn't NULL and this range
 *      isn't a zombie
 *
 *  @rdesc
 *      HRESULT = (zombie) ? CO_E_RELEASED :
 *                (pLong) ? NOERROR : E_INVALIDARG
 */
HRESULT CTxtRange::GetLong (
    LONG lValue,        //@parm Long value to return
    long *pLong)        //@parm Out parm to receive long value
{
    if(IsZombie())
        return CO_E_RELEASED;   
    
    _TEST_INVARIANT_

    if(!pLong)
        return E_INVALIDARG;

    *pLong = lValue;



    return NOERROR;
}

/*
 *  IsSameVtables (punk1, punk2)
 *
 *  @mfunc
 *      Returns true if punk1 has same vtable as punk2
 *
 *  @rdesc
 *      TRUE iff punk1 has same vtable as punk2
 */
BOOL IsSameVtables(IUnknown *punk1, IUnknown *punk2)
{
    return punk1 && punk2 && *(long *)punk1 == *(long *)punk2;
}

/*
 *  FPPTS_TO_TWIPS (x)
 *
 *  @mfunc
 *      Returns 20*x, i.e., the number of twips corresponding to
 *      x given in floating-point points.  The value is rounded.
 *
 *  @rdesc
 *      x converted to twips
 */
long FPPTS_TO_TWIPS(
    float x)
{
    return 20*x + ((x >= 0) ? 0.5 : -0.5);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\tomfmt.cpp ===
/*
 *	@doc TOM
 *
 *	@module	tomfmt.cpp - Implement the CTxtFont and CTxtPara Classes |
 *	
 *		This module contains the implementation of the TOM ITextFont and
 *		ITextPara interfaces
 *
 *	History: <nl>
 *		11/8/95 - MurrayS: created
 *		5/96	- MurrayS: added zombie protection
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_tomfmt.h"
#include "_font.h"

ASSERTDATA

#define tomFloatUndefined	((float)(int)tomUndefined)

// Alignment translation vectors
const BYTE g_rgREtoTOMAlign[] =				// RichEdit to TOM
{
	// TODO: generalize TOM to handle new LineServices options
	tomAlignLeft, tomAlignLeft, tomAlignRight, tomAlignCenter, tomAlignJustify,
	tomAlignInterLetter, tomAlignScaled, tomAlignGlyphs, tomAlignSnapGrid
};

const BYTE g_rgTOMtoREAlign[] =				// TOM to RichEdit
{
	PFA_LEFT, PFA_CENTER, PFA_RIGHT, PFA_FULL_INTERWORD,
	PFA_FULL_INTERLETTER, PFA_FULL_SCALED, PFA_FULL_GLYPHS,
	PFA_SNAP_GRID
};

/*
 *	QueryInterface(riid, riid1, punk, ppv, fZombie)
 *
 *	@func
 *		QueryInterface punk for the ref IDs riid1, IID_IDispatch, and
 *		IID_IUnknown
 *
 *	@rdesc
 *		HRESULT = (!ppv) ? E_INVALIDARG :
 *				  (interface found) ? NOERROR : E_NOINTERFACE
 */
HRESULT QueryInterface (
	REFIID	  riid,		//@parm Reference to requested interface ID
	REFIID	  riid1,	//@parm Query for this, IDispatch, IUnknown
	IUnknown *punk,		//@parm Interface to query
	void **	  ppv,		//@parm Out parm to receive interface ptr
	BOOL	  fZombie)	//@parm If true, return CO_E_RELEASED
{
	if(!ppv)
		return E_INVALIDARG;

	*ppv = NULL;

	if(fZombie)							// Check for range zombie
		return CO_E_RELEASED;

	Assert(punk);

#ifndef PEGASUS
	if( IsEqualIID(riid, IID_IUnknown)   ||
		IsEqualIID(riid, IID_IDispatch)  ||
		IsEqualIID(riid, riid1) )
	{
		*ppv = punk;
		punk->AddRef();
		return NOERROR;
	}
#endif
	return E_NOINTERFACE;
}

//------------------------------- CTxtFont -------------------------------------

/*
 *	CTxtFont::CTxtFont(prg)
 *
 *	@mfunc
 *		Constructor
 */
CTxtFont::CTxtFont(CTxtRange *prg) : CTxtFormat(prg)
{
	Assert(!_dwMask);		// We assume that object is zeroed (new'd)
}


//------------------------- CTxtFont IUnknown Methods -------------------------------------

/*	CTxtFont::IUnknown methods
 *
 *		See tomDoc.cpp for comments
 */
STDMETHODIMP CTxtFont::QueryInterface (REFIID riid, void **ppv)
{
#ifndef PEGASUS
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::QueryInterface");

	return ::QueryInterface(riid, IID_ITextFont, this, ppv, IsZombie());
#else
	return 0;
#endif
}

STDMETHODIMP_(ULONG) CTxtFont::AddRef()
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::AddRef");

 	return ++_cRefs;
}

STDMETHODIMP_(ULONG) CTxtFont::Release()
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::Release");

	_cRefs--;

	if(!_cRefs)
	{
		delete this;
		return 0;
	}
	return _cRefs;
}


//------------------------- CTxtFont IDispatch Methods -------------------------------------

/*
 *	CTxtFont::GetTypeInfoCount(pcTypeInfo)
 *
 *	@mfunc
 *		Get the number of TYPEINFO elements (1)
 *
 *	@rdesc
 *		HRESULT = (pcTypeInfo) ? NOERROR : E_INVALIDARG;
 */
STDMETHODIMP CTxtFont::GetTypeInfoCount (
	UINT * pcTypeInfo)			//@parm Out parm to receive type-info count
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetTypeInfoCount");

	if(!pcTypeInfo)
		return E_INVALIDARG;

	*pcTypeInfo = 1;
	return NOERROR;
}

/*
 *	CTxtFont::GetTypeInfo(iTypeInfo, lcid, ppTypeInfo)
 *
 *	@mfunc
 *		Return ptr to type information object for ITextFont interface
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CTxtFont::GetTypeInfo (
	UINT		iTypeInfo,		//@parm Index of type info to return
	LCID		lcid,			//@parm Local ID of type info
	ITypeInfo **ppTypeInfo)		//@parm Out parm to receive type info
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetTypeInfo");

	return ::GetTypeInfo(iTypeInfo, g_pTypeInfoFont, ppTypeInfo);
}

/*
 *	CTxtFont::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid)
 *
 *	@mfunc
 *		Get DISPIDs for ITextFont methods and properties
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CTxtFont::GetIDsOfNames (
	REFIID		riid,			//@parm Interface ID to interpret names for
	OLECHAR **	rgszNames,		//@parm Array of names to be mapped
	UINT		cNames,			//@parm Count of names to be mapped
	LCID		lcid,			//@parm Local ID to use for interpretation
	DISPID *	rgdispid)		//@parm Out parm to receive name mappings
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetIDsOfNames");

	HRESULT hr = GetTypeInfoPtrs();				// Ensure TypeInfo ptrs are OK
	if(hr != NOERROR)
		return hr;
		
	return g_pTypeInfoFont->GetIDsOfNames(rgszNames, cNames, rgdispid);
}

/*
 *	CTxtFont::Invoke(dispidMember, riid, lcid, wFlags, pdispparams,
 *					  pvarResult, pexcepinfo, puArgError)
 *	@mfunc
 *		Invoke methods for the ITextFont interface
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CTxtFont::Invoke (
	DISPID		dispidMember,	//@parm Identifies member function
	REFIID		riid,			//@parm Pointer to interface ID
	LCID		lcid,			//@parm Locale ID for interpretation
	USHORT		wFlags,			//@parm Flags describing context of call
	DISPPARAMS *pdispparams,	//@parm Ptr to method arguments
	VARIANT *	pvarResult,		//@parm Out parm for result (if not NULL)
	EXCEPINFO * pexcepinfo,		//@parm Out parm for exception info
	UINT *		puArgError)		//@parm Out parm for error
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::Invoke");

	HRESULT hr = GetTypeInfoPtrs();				// Ensure TypeInfo ptrs are OK
	if(hr != NOERROR)
		return hr;

	if(IsZombie())
		return CO_E_RELEASED;
				
	return g_pTypeInfoFont->Invoke(this, dispidMember, wFlags,
							 pdispparams, pvarResult, pexcepinfo, puArgError);
}


//--------------------------- ITextFont Methods -------------------------------------

/*
 *	ITextFont::CanChange(long * pbCanChange) 
 *
 *	@mfunc
 *		Method that sets *pbCanChange = tomTrue if and only if the
 *		font can be changed.
 *
 *	@rdesc
 *		HRESULT = (can change char format) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtFont::CanChange (
	long *pbCanChange)		//@parm Out parm to receive boolean value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::CanChange");

	return CTxtFormat::CanChange(pbCanChange, CharFormat);
}

/*
 *	ITextFont::GetAllCaps(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the AllCaps state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetAllCaps (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetAllCaps");

	return EffectGetter(pValue, CFM_ALLCAPS);
}

/*
 *	ITextFont::GetAnimation(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the animation type as defined
 *		in the table below.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetAnimation (
	long *pValue)		//@parm Out parm to receive animation type
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetAnimation");

	return GetParameter((long *)&_CF._bAnimation, CFM_ANIMATION, 1, pValue);
}

/*
 *	ITextFont::GetBackColor(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the background color.  The
 *		value is a Win32 COLORREF.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetBackColor (
	long *pValue)		//@parm Out parm to receive COLORREF value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetBackColor");

	HRESULT hr = EffectGetter(pValue, CFE_AUTOBACKCOLOR);

	if(hr != NOERROR || *pValue == tomUndefined)
		return hr;

	*pValue = (*pValue == tomFalse) ? _CF._crBackColor : tomAutoColor;
	return NOERROR;
}

/*
 *	ITextFont::GetBold(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the bold state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetBold (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetBold");

	return EffectGetter(pValue, CFM_BOLD);
}

/*
 *	ITextFont::GetDuplicate(ITextFont **ppFont) 
 *
 *	@mfunc
 *		Property get method that gets a clone of this character
 *		format object.
 *
 *	@rdesc
 *		HRESULT = (!ppFont) ? E_INVALIDARG :
 *				  (if success) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtFont::GetDuplicate (
	ITextFont **ppFont)		//@parm Out parm to receive font clone
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetDuplicate");

	if(!ppFont)
		return E_INVALIDARG;

	*ppFont = NULL;

	if(IsZombie())
		return CO_E_RELEASED;

	CTxtFont *pFont = new CTxtFont(NULL);
	if(!pFont)
		return E_OUTOFMEMORY;

	if(_prg)
		UpdateFormat();

	pFont->_CF		= _CF;
	pFont->_dwMask  = _dwMask;
	*ppFont = pFont;
	return NOERROR;
}

/*
 *	ITextFont::GetEmboss(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the embossed state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetEmboss (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetEmboss");

	return EffectGetter(pValue, CFM_EMBOSS);
}

/*
 *	ITextFont::GetForeColor(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the foreground color.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetForeColor (
	long *pValue)		//@parm Out parm to receive COLORREF value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetForeColor");

	HRESULT hr = EffectGetter(pValue, CFE_AUTOCOLOR);

	if(hr != NOERROR || *pValue == tomUndefined)
		return hr;

	*pValue = (*pValue == tomFalse) ? _CF._crTextColor : tomAutoColor;
	return NOERROR;
}

/*
 *	ITextFont::GetHidden(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the hidden state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetHidden (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetHidden");

	return EffectGetter(pValue, CFM_HIDDEN);
}

/*
 *	ITextFont::GetEngrave(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the imprint state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetEngrave (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetEngrave");

	return EffectGetter(pValue, CFM_IMPRINT);
}

/*
 *	ITextFont::GetItalic(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the italic state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetItalic (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetItalic");

	return EffectGetter(pValue, CFM_ITALIC);
}

/*
 *	ITextFont::GetKerning(float * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the minimum kerning size,
 *		which is given in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 *
 *	@comm
 *		A kerning size of 0 turns off kerning, but an arbitrarily small
 *		value turns it on, e.g., 1.0, which is too small to see, let alone
 *		kern!
 */
STDMETHODIMP CTxtFont::GetKerning (
	float *pValue)		//@parm Out parm to receive minimum kerning size
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetKerning");

	return GetParameter((long *)&_CF._wKerning, CFM_KERNING, -2, (long *)pValue);
}

/*
 *	ITextFont::GetLanguageID(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the language ID (more
 *		generally LCID).
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetLanguageID (
	long *pValue)		//@parm Out parm to receive LCID value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetLanguageID");

	if (!pValue)
		return E_INVALIDARG;

	if ((*pValue & 0xF0000000) == tomCharset) 
	{
		UpdateFormat();

		// Sepcial case to get charset and pitchandfamily
		*pValue = (_CF._bPitchAndFamily << 8) + _CF._bCharSet;
		return NOERROR;
	}
	return GetParameter((long *)&_CF._lcid, CFM_LCID, 4, pValue);
}

/*
 *	ITextFont::GetName(BSTR *pbstr) 
 *
 *	@mfunc
 *		Property get method that gets the font name.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : 
 *				  (can allocate bstr) ? NOERROR : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::GetName (
	BSTR *pbstr)	//@parm Out parm to receive font name bstr
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetName");

	if(!pbstr)
		return E_INVALIDARG;

	*pbstr = NULL;

	HRESULT hr = UpdateFormat();			// If live Font object, update
											//  _CF to current _prg values
	if(hr != NOERROR)						// Attached to zombied range
		return hr;

	*pbstr = SysAllocString(GetFontName(_CF._iFont));

	return *pbstr ? NOERROR : E_OUTOFMEMORY;
}

/*
 *	ITextFont::GetOutline(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the outline state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetOutline (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetOutline");

	return EffectGetter(pValue, CFM_OUTLINE);
}

/*
 *	ITextFont::GetPosition(float *pValue) 
 *
 *	@mfunc
 *		Property get method that gets the character position
 *		relative to the baseline. The value is given in floating-point
 *		points.
 *
 *	@rdesc
 *		HRESULT =  (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetPosition (
	float *pValue)		//@parm Out parm to receive relative vertical position
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetPosition");

	return GetParameter((long *)&_CF._yOffset, CFM_OFFSET, -2, (long *)pValue);
}

/*
 *	ITextFont::GetProtected(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the protected state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetProtected (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetProtected");

	return EffectGetter(pValue, CFM_PROTECTED);
}

/*
 *	ITextFont::GetShadow(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the shadow state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetShadow (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetShadow");

	return EffectGetter(pValue, CFM_SHADOW);
}

/*
 *	ITextFont::GetSize(float * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the font size, which is given
 *		in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetSize (
	float *pValue)		//@parm Out parm to receive font size
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetSize");

	return GetParameter((long *)&_CF._yHeight, CFM_SIZE, -2, (long *)pValue);
}

/*
 *	ITextFont::GetSmallCaps(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the SmallCaps state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetSmallCaps (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetSmallCaps");

	return EffectGetter(pValue, CFM_SMALLCAPS);
}

/*
 *	ITextFont::GetSpacing(float * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the intercharacter spacing,
 *		which is given in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetSpacing (
	float *pValue)		//@parm Out parm to receive intercharacter spacing
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetSpacing");

	return GetParameter((long *)&_CF._sSpacing, CFM_SPACING, -2, (long *)pValue);
}

/*
 *	ITextFont::GetStrikeThrough(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the strikeout state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetStrikeThrough (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetStrikeThrough");

	return EffectGetter(pValue, CFM_STRIKEOUT);
}

/*
 *	ITextFont::GetStyle(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the character style handle for
 *		the characters in a range.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtFont::GetStyle (
	long *pValue)		//@parm Out parm to receive character style handle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetStyle");

	return GetParameter((long *)&_CF._sStyle, CFM_STYLE, 2, pValue);
}

/*
 *	ITextFont::GetSubscript(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the subscript state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetSubscript (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetSubscript");

	return EffectGetter(pValue, CFE_SUBSCRIPT);
}

/*
 *	ITextFont::GetSuperscript(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the superscript state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetSuperscript (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetSuperscript");

	return EffectGetter(pValue, CFE_SUPERSCRIPT);
}

/*
 *	ITextFont::GetUnderline(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the underline style.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetUnderline (
	long *pValue)		//@parm Out parm to receive underline style
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetUnderline");

	if(!pValue)
		return E_INVALIDARG;

	HRESULT hr = UpdateFormat();			// If live Font object, update
											//  _CF to current _prg values
	*pValue = 0;							// Default no underline

	if(!(_dwMask & CFM_UNDERLINE))			// It's a NINCH
		*pValue = tomUndefined;

	else if(_CF._dwEffects & CFM_UNDERLINE)
		*pValue = (LONG)_CF._bUnderlineType ? (LONG)_CF._bUnderlineType : tomTrue;

	return hr;
}

/*
 *	ITextFont::GetWeight(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the font weight for
 *		the characters in a range.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtFont::GetWeight (
	long *pValue)		//@parm Out parm to receive character style handle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetWeight");

	return GetParameter((long *)&_CF._wWeight, CFM_WEIGHT, 2, pValue);
}

/*
 *	ITextFont::IsEqual(ITextFont * pFont, long * pB) 
 *
 *	@mfunc
 *		Method that sets *<p pB> = tomTrue if this text font has the
 *		same properties as *<p pFont>.  For this to be true, *<p pFont> has to
 *		belong to the same TOM engine as the present one. The IsEqual()
 *		method should ignore entries for which either font object has a
 *		tomUndefined value.
 *
 *	@rdesc
 *		HRESULT = (equal objects) ? NOERROR : S_FALSE
 *
 *	@devnote
 *		This implementation assumes that all properties are defined and that
 *		pFont belongs to RichEdit.  It would be nice to generalize this so
 *		that undefined properties are ignored in the comparison and so that
 *		pFont could belong to a different TOM engine.  This would help in
 *		using RichEdit Find dialogs to search for rich text in Word using
 *		TOM.
 */
STDMETHODIMP CTxtFont::IsEqual (
	ITextFont *	pFont,		//@parm ITextFont to compare to
	long *		pB)			//@parm Out parm to receive comparison result
{
#ifndef PEGASUS
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::IsEqual");

	if(pB)
		*pB = tomFalse;

	if(!IsSameVtables(this, pFont))
		return S_FALSE;

	HRESULT hr = UpdateFormat();			// Update _CFs in case they are
	if(hr != NOERROR)						//  attached to ranges
		return hr;

	CTxtFont *pF = (CTxtFont *)pFont;
	hr = pF->UpdateFormat();
	if(hr != NOERROR)
		return hr;

	// Ignore differences in CharSet, since TOM thinks all CharSets are Unicode!
	DWORD dwIgnore = (DWORD)(~CFM_CHARSET);

	if(!(_CF._dwEffects & CFE_UNDERLINE))	// If not underlining, ignore
		dwIgnore &= ~CFM_UNDERLINETYPE;		//  differences in underline type

	DWORD dwMask = pF->_dwMask & dwIgnore;

	if((_dwMask ^ dwMask) & dwIgnore)		// The masks have to be the same
		return S_FALSE;						//  for equality

	if(dwMask & _CF.Delta(&(pF->_CF),FALSE))// Any difference?
		return S_FALSE;						// Yes. *pB set equal to tomFalse above

	if(pB)
		*pB = tomTrue;

	return NOERROR;
#else
	return 0;
#endif
}			

/*
 *	ITextFont::Reset(long Value) 
 *
 *	@mfunc
 *		Method that resets the character formatting to the default
 *		values to 1) those defined by the RTF \plain control word (Value =
 *		tomDefault), and 2) all undefined values (Value = tomUndefined).
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::Reset (
	long Value)		//@parm Kind of reset (tomDefault or tomUndefined)
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::Reset");

	HRESULT hr = CanChange(NULL);

	if(hr != NOERROR)								// Takes care of zombie
		return hr;									//  and protection

	if(Value == tomDefault)
	{
		if(_prg)
		{
			_CF = *_prg->GetPed()->GetCharFormat(-1);
			FormatSetter(CFM_ALL2);
		}
		else
			_CF.InitDefault(0);
		_dwMask = CFM_ALL2;
	}

	else if(Value == tomUndefined && !_prg)		// Only applicable
		_dwMask = 0;							//  for clones

	else if((Value | 1) == tomApplyLater)		// Set-method optimization
	{
		_fApplyLater = Value & 1;
		if(!_fApplyLater)						// Apply now
			FormatSetter(_dwMask);
	}
	else if((Value | 1) == tomCacheParms)		// Get-method optimization
	{
		_fCacheParms = FALSE;
		if(Value & 1)							// Cache parms now, but
		{										//  don't update on gets
			UpdateFormat();							
			_fCacheParms = TRUE;
		}
	}
	else
		return E_INVALIDARG;

	return NOERROR;
}

/*
 *	ITextFont::SetAllCaps(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the AllCaps state according to
 *		the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetAllCaps (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetAllCaps");

	return EffectSetter(Value, CFM_ALLCAPS | CFM_SMALLCAPS, CFE_ALLCAPS);
}

/*
 *	ITextFont::SetAnimation(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the animation type
 *
 *	@rdesc
 *		HRESULT = (Value defined) ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtFont::SetAnimation (
	long Value)		//@parm New animation type
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetAnimation");

	if(Value == tomUndefined)
		return NOERROR;

	if((unsigned)Value > tomAnimationMax)
		return E_INVALIDARG;

	return SetParameter((long *)&_CF._bAnimation, CFM_ANIMATION, 1, Value);
}

/*
 *	ITextFont::SetBackColor(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the background color according
 *		to the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 *	@devnote
 *		Legal values are tomUndefined, tomAutoColor (both negative) and
 *		in principle any positive values.  Currently wingdi.h only defines
 *		high bytes = 0, 1, 2, 4.  But more values might happen, so we only
 *		rule out negative values other than tomUndefined and tomAutoColor.
 */
STDMETHODIMP CTxtFont::SetBackColor (
	long Value )		//@parm New COLORREF value to use
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetBackColor");

	if(Value == tomUndefined)					// NINCH
		return NOERROR;

	_CF._dwEffects |= CFE_AUTOBACKCOLOR;		// Default AutoBackColor
	if(Value != tomAutoColor)
	{
		if(Value < 0)
			return E_INVALIDARG;
		_CF._dwEffects &= ~CFE_AUTOBACKCOLOR;	// Turn off AutoBackColor
		_CF._crBackColor = (COLORREF)Value;		// Use new BackColor
	}
	
	return FormatSetter(CFM_BACKCOLOR);
}

/*
 *	ITextFont::SetBold(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the bold state according to
 *		the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetBold (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetBold");

	return EffectSetter(Value, CFM_BOLD, CFE_BOLD);
}

/*
 *	ITextFont::SetDuplicate(ITextFont *pFont) 
 *
 *	@mfunc
 *		Property put method that sets this text font character
 *		formatting to that given by pFont.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetDuplicate(
	ITextFont *pFont) 		//@parm Font object to apply to this font object
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetDuplicate");

	DWORD		dwMask = 0;
	BSTR		bstr;
	CTxtRange *	prg;
	long		Value;
	float		x;

	if(IsZombie())							// Check for range zombie
		return CO_E_RELEASED;

	if(IsSameVtables(this, pFont))			// If pFont belongs to this TOM
	{										//  engine, can cast and copy
		((CTxtFont *)pFont)->UpdateFormat();
		_CF = ((CTxtFont *)pFont)->_CF;
		dwMask = ((CTxtFont *)pFont)->_dwMask;// Use this mask in case this 			
	}										//  font is active
	else
	{										// Need to call pFont for all font
		prg = _prg;							//  properties
		_prg = NULL;						// Be sure it's a clone during
											//  transfer
		pFont->GetStyle(&Value);
		SetStyle(Value);

		pFont->GetAllCaps(&Value);
		SetAllCaps(Value);

		pFont->GetAnimation(&Value);
		SetAnimation(Value);

		pFont->GetBackColor(&Value);
		SetBackColor(Value);

		pFont->GetBold(&Value);
		SetBold(Value);

		pFont->GetEmboss(&Value);
		SetEmboss(Value);

		pFont->GetForeColor(&Value);
		SetForeColor(Value);

		pFont->GetHidden(&Value);
		SetHidden(Value);

		pFont->GetEngrave(&Value);
		SetEngrave(Value);

		pFont->GetItalic(&Value);
		SetItalic(Value);

		pFont->GetKerning(&x);
		SetKerning(x);

		pFont->GetLanguageID(&Value);
		SetLanguageID(Value);

		pFont->GetName(&bstr);
		SetName(bstr);
		SysFreeString(bstr);

		pFont->GetOutline(&Value);
		SetOutline(Value);

		pFont->GetPosition(&x);
		SetPosition(x);

		pFont->GetProtected(&Value);
		SetProtected(Value);

		pFont->GetShadow(&Value);
		SetShadow(Value);

		pFont->GetSize(&x);
		SetSize(x);

		pFont->GetSmallCaps(&Value);
		SetSmallCaps(Value);

		pFont->GetSpacing(&x);
		SetSpacing(x);

		pFont->GetStrikeThrough(&Value);
		SetStrikeThrough(Value);

		pFont->GetSubscript(&Value);
		SetSubscript(Value);

		pFont->GetSuperscript(&Value);
		SetSuperscript(Value);

		pFont->GetUnderline(&Value);
		SetUnderline(Value);

		_prg = prg;							// Restore original value
	}
	return FormatSetter(dwMask);			// Apply it unless !_prg
}

/*
 *	ITextFont::SetEmboss(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the embossed state according
 *		to the value given by Value
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetEmboss (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetEmboss");

	return EffectSetter(Value, CFM_EMBOSS, CFE_EMBOSS);
}

/*
 *	ITextFont::SetForeColor(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the foreground color according
 *		to the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetForeColor (
	long Value )		//@parm New COLORREF value to use
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetForeColor");

	if(Value == tomUndefined)					// NINCH
		return NOERROR;

	_CF._dwEffects |= CFE_AUTOCOLOR;			// Default AutoColor
	if(Value != tomAutoColor)
	{
		if(Value < 0)
			return E_INVALIDARG;
		_CF._dwEffects &= ~CFE_AUTOCOLOR;		// Turn off AutoColor
		_CF._crTextColor = (COLORREF)Value;		// Use new TextColor
	}
	
	return FormatSetter(CFM_COLOR);
}

/*
 *	ITextFont::SetHidden(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the hidden state according to
 *		the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetHidden (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetHidden");

	return EffectSetter(Value, CFM_HIDDEN, CFE_HIDDEN);
}

/*
 *	ITextFont::SetEngrave(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the imprint state according to
 *		the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetEngrave (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetEngrave");

	return EffectSetter(Value, CFM_IMPRINT, CFE_IMPRINT);
}

/*
 *	ITextFont::SetItalic(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the italic state according to
 *		the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetItalic (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetItalic");

	return EffectSetter(Value, CFM_ITALIC, CFE_ITALIC);
}

/*
 *	ITextFont::SetKerning(float Value) 
 *
 *	@mfunc
 *		Property set method that sets the minimum kerning size,
 *		which is given in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (Value < 0) ? E_INVALIDARG :
 *				  (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetKerning (
	float Value)		//@parm New value of minimum kerning size
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetKerning");

	return SetParameter((long *)&_CF._wKerning, CFM_KERNING, -2, *(long *)&Value);
}

/*
 *	ITextFont::SetLanguageID(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the language ID (more
 *		generally LCID) according to the value given by Value.  See
 *		GetLanguageID() for more information.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetLanguageID (
	long Value)		//@parm New LCID to use
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetLanguageID");

	if ((Value & 0xF0000000) == tomCharset) 
	{
		// Sepcial case to set charset and pitchandfamily
		_CF._bCharSet = (BYTE)Value;
		_CF._bPitchAndFamily = (BYTE)(Value >> 8);
		return FormatSetter(CFM_CHARSET);
	}
	return SetParameter((long *)&_CF._lcid, CFM_LCID, 4, Value);
}

/*
 *	ITextFont::SetName(BSTR Name) 
 *
 *	@mfunc
 *		Property put method that sets the font name to Name.
 *
 *	@rdesc
 *		HRESULT = (Name too long) ? E_INVALIDARG : 
 *				  (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetName(
	BSTR Name)		//@parm New font name
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetName");

	LONG cch = SysStringLen(Name);

	if(cch > LF_FACESIZE)
		return E_INVALIDARG;

	if(!cch)									// NINCH
		return NOERROR;

	_CF._iFont = GetFontNameIndex(Name);
	_CF._bCharSet = GetFirstAvailCharSet(GetFontSignatureFromFace(_CF._iFont));

	return FormatSetter(CFM_FACE + CFM_CHARSET);
}

/*
 *	ITextFont::SetOutline(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the outline state according to
 *		the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetOutline (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetOutline");

	return EffectSetter(Value, CFM_OUTLINE, CFE_OUTLINE);
}

/*
 *	ITextFont::SetPosition(float Value) 
 *
 *	@mfunc
 *		Property set method that sets the character position
 *		relative to the baseline. The value is given in floating-point
 *		points.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetPosition (
	float Value)		//@parm New value of relative vertical position
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetPosition");

	return SetParameter((long *)&_CF._yOffset, CFM_OFFSET, -2, *(long *)&Value);
}

/*
 *	ITextFont::SetProtected(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the protected state according
 *		to the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtFont::SetProtected (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetProtected");

	return EffectSetter(Value, CFM_PROTECTED, CFE_PROTECTED);
}

/*
 *	ITextFont::SetShadow(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the shadow state according to
 *		the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetShadow (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetShadow");

	return EffectSetter(Value, CFM_SHADOW, CFE_SHADOW);
}

/*
 *	ITextFont::SetSize(float Value) 
 *
 *	@mfunc
 *		Property put method that sets the font size = Value (in
 *		floating-point points).
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetSize (
	float Value)		//@parm New font size to use
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetSize");

	return SetParameter((long *)&_CF._yHeight, CFM_SIZE, -2, *(long *)&Value);
}

/*
 *	ITextFont::SetSmallCaps(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the SmallCaps state according
 *		to the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetSmallCaps (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetSmallCaps");

	return EffectSetter(Value, CFM_ALLCAPS | CFM_SMALLCAPS, CFE_SMALLCAPS);
}

/*
 *	ITextFont::SetSpacing(float Value) 
 *
 *	@mfunc
 *		Property set method that sets the intercharacter spacing,
 *		which is given in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetSpacing (
	float Value)		//@parm New value of intercharacter spacing
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetSpacing");

	return SetParameter((long *)&_CF._sSpacing, CFM_SPACING, -2, *(long *)&Value);
}

/*
 *	ITextFont::SetStrikeThrough(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the StrikeThrough state
 *		according to the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetStrikeThrough (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetStrikeThrough");

	return EffectSetter(Value, CFM_STRIKEOUT, CFE_STRIKEOUT);
}

/*
 *	ITextFont::SetStyle(long Value)
 *
 *	@mfunc
 *		Property put method that sets the character style handle for
 *		the characters in a range.  See GetStyle() for further discussion.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetStyle (
	long Value)		//@parm New character style handle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetStyle");

	if(Value == tomUndefined)
		return NOERROR;

	if(Value < -32768 || Value > 32767)
		return E_INVALIDARG;

	return SetParameter((long *)&_CF._sStyle, CFM_STYLE, 2, Value);
}

/*
 *	ITextFont::SetSubscript(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the subscript state according
 *		to the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetSubscript (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetSubscript");

	return EffectSetter(Value, CFM_SUBSCRIPT | CFM_SUPERSCRIPT, CFE_SUBSCRIPT);
}

/*
 *	ITextFont::SetSuperscript(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the superscript state
 *		according to the value given by Value
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetSuperscript (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetSuperscript");

	return EffectSetter(Value, CFM_SUBSCRIPT | CFM_SUPERSCRIPT, CFE_SUPERSCRIPT);
}

/*
 *	ITextFont::SetUnderline(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the underline style according
 *		to the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetUnderline (
	long Value)		//@parm New value of underline type
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetUnderline");

	_CF._bUnderlineType = 0;					// Default no underline type
	if(Value < 0)								// tomTrue, tomUndefined, or
		return EffectSetter(Value, CFM_UNDERLINETYPE | CFM_UNDERLINE, CFE_UNDERLINE);

	if(Value > 255)								// Illegal underline type
		return E_INVALIDARG;

	_CF._bUnderlineType = (BYTE)Value;
	_CF._dwEffects &= ~CFM_UNDERLINE;			// Default underlining is off
	if(Value)
		_CF._dwEffects |= CFM_UNDERLINE;		// It's on
	
	return FormatSetter(CFM_UNDERLINETYPE + CFM_UNDERLINE);
}

/*
 *	ITextFont::SetWeight(long Value)
 *
 *	@mfunc
 *		Property put method that sets the font weight for
 *		the characters in a range.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetWeight (
	long Value)		//@parm New character style handle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetWeight");

	if(Value == tomUndefined)					// NINCH
		return NOERROR;

	if((unsigned)Value > 900)					// Valid values satisfy:
		return E_INVALIDARG;					//  0 <= Value <= 900

	return SetParameter((long *)&_CF._wWeight, CFM_WEIGHT, 2, Value);
}


//------------------------------- CTxtPara ------------------------------------

/*
 *	CTxtPara::CTxtPara(prg)
 *
 *	@mfunc
 *		Constructor
 */
CTxtPara::CTxtPara(CTxtRange *prg) : CTxtFormat(prg)
{
	Assert(!_dwMask && !_PF._dwBorderColor); // We assume that object is zeroed (new'd)
	_PF._iTabs = -1;
}

/*
 *	CTxtPara::~CTxtPara()
 *
 *	@mfunc
 *		Destructor
 */
CTxtPara::~CTxtPara()
{
	Assert(_PF._iTabs == -1);
}


//------------------------- CTxtPara IUnknown Methods -------------------------------------

/*	CTxtPara::IUnknown methods
 *
 *		See tomdoc.cpp for comments
 */
STDMETHODIMP CTxtPara::QueryInterface (REFIID riid, void **ppv)
{
#ifndef PEGASUS
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::QueryInterface");

	return ::QueryInterface(riid, IID_ITextPara, this, ppv, IsZombie());
#else
	return 0;
#endif
}

STDMETHODIMP_(ULONG) CTxtPara::AddRef()
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::AddRef");

 	return ++_cRefs;
}

STDMETHODIMP_(ULONG) CTxtPara::Release()
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::Release");

	_cRefs--;

	if(!_cRefs)
	{
		delete this;
		return 0;
	}
	return _cRefs;
}


//------------------------- CTxtPara IDispatch Methods -------------------------------------

/*
 *	CTxtPara::GetTypeInfoCount(pcTypeInfo)
 *
 *	@mfunc
 *		Get the number of TYPEINFO elements (1)
 *
 *	@rdesc
 *		HRESULT = (pcTypeInfo) ? NOERROR : E_INVALIDARG;
 */
STDMETHODIMP CTxtPara::GetTypeInfoCount (
	UINT * pcTypeInfo)			//@parm Out parm to receive type-info count
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetTypeInfoCount");

	if(!pcTypeInfo)
		return E_INVALIDARG;

	*pcTypeInfo = 1;
	return NOERROR;
}

/*
 *	CTxtPara::GetTypeInfo(iTypeInfo, lcid, ppTypeInfo)
 *
 *	@mfunc
 *		Return ptr to type information object for ITextPara interface
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CTxtPara::GetTypeInfo (
	UINT		iTypeInfo,		//@parm Index of type info to return
	LCID		lcid,			//@parm Local ID of type info
	ITypeInfo **ppTypeInfo)		//@parm Out parm to receive type info
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetTypeInfo");

	return ::GetTypeInfo(iTypeInfo, g_pTypeInfoPara, ppTypeInfo);
}

/*
 *	CTxtPara::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid)
 *
 *	@mfunc
 *		Get DISPIDs for ITextPara methods and properties
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CTxtPara::GetIDsOfNames (
	REFIID		riid,			//@parm Interface ID to interpret names for
	OLECHAR **	rgszNames,		//@parm Array of names to be mapped
	UINT		cNames,			//@parm Count of names to be mapped
	LCID		lcid,			//@parm Local ID to use for interpretation
	DISPID *	rgdispid)		//@parm Out parm to receive name mappings
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetIDsOfNames");

	HRESULT hr = GetTypeInfoPtrs();				// Ensure TypeInfo ptrs are OK
	if(hr != NOERROR)
		return hr;
		
	return g_pTypeInfoPara->GetIDsOfNames(rgszNames, cNames, rgdispid);
}

/*
 *	CTxtPara::Invoke(dispidMember, riid, lcid, wFlags, pdispparams,
 *					  pvarResult, pexcepinfo, puArgError)
 *	@mfunc
 *		Invoke methods for the ITextPara interface
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CTxtPara::Invoke (
	DISPID		dispidMember,	//@parm Identifies member function
	REFIID		riid,			//@parm Pointer to interface ID
	LCID		lcid,			//@parm Locale ID for interpretation
	USHORT		wFlags,			//@parm Flags describing context of call
	DISPPARAMS *pdispparams,	//@parm Ptr to method arguments
	VARIANT *	pvarResult,		//@parm Out parm for result (if not NULL)
	EXCEPINFO * pexcepinfo,		//@parm Out parm for exception info
	UINT *		puArgError)		//@parm Out parm for error
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::Invoke");

	HRESULT hr = GetTypeInfoPtrs();				// Ensure TypeInfo ptrs are OK
	if(hr != NOERROR)
		return hr;
		
	if(IsZombie())
		return CO_E_RELEASED;
				
	return g_pTypeInfoPara->Invoke(this, dispidMember, wFlags,
							 pdispparams, pvarResult, pexcepinfo, puArgError);
}

//------------------------ CTxtPara ITextPara Methods -------------------------------------

/*
 *	ITextPara::AddTab(float tbPos, long tbAlign, long tbLeader) 
 *
 *	@mfunc
 *		Method that adds a tab at the displacement tbPos, with type
 *		tbAlign, and leader style tbLeader.  The displacement is given in
 *		floating-point points.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::AddTab (
	float	tbPos,			//@parm New tab displacement
	long	tbAlign,		//@parm New tab type
	long	tbLeader)		//@parm New tab style
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::AddTab");

	HRESULT hr = UpdateFormat();			// If live Para object, update
											//  _PF to current _prg values
	if(hr != NOERROR)
		return hr;							// Must be a zombie

	//This doesn't seem correct because it doesn't ever look at whether or not
	//we are in a table.
	hr = _PF.AddTab(FPPTS_TO_TWIPS(tbPos), tbAlign, tbLeader, FALSE, &_rgxTabs[0]);
	if(hr != NOERROR)
		return hr;

	return FormatSetter(PFM_TABSTOPS);
}

/*
 *	ITextPara::CanChange(long * pbCanChange) 
 *
 *	@mfunc
 *		Method that sets *pbCanChange = tomTrue if and only if the
 *		paragraph formatting can be changed.
 *
 *	@rdesc
 *		HRESULT = (can change char format) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtPara::CanChange (
	long *pbCanChange)		//@parm Out parm to receive boolean value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::CanChange");

	return CTxtFormat::CanChange(pbCanChange, ParaFormat);
}

/*
 *	ITextPara::ClearAllTabs() 
 *
 *	@mfunc
 *		Method that clears all tabs, reverting to equally spaced
 *		tabs with the default tab spacing.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::ClearAllTabs() 
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::ClearAllTabs");

	_PF._bTabCount = 0;						// Signal to use default tab
	return FormatSetter(PFM_TABSTOPS);
}

/*
 *	ITextPara::DeleteTab(tbPos) 
 *
 *	@mfunc
 *		Delete any tab at the displacement tbPos.  This displacement is
 *		given in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::DeleteTab (
	float tbPos)		//@parm Displacement at which tab should be deleted
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::DeleteTab");

	HRESULT hr = UpdateFormat();			// If live Para object, update
											//  _PF to current _prg values
	if(hr != NOERROR)
		return hr;							// Must be a zombie

	hr = _PF.DeleteTab(FPPTS_TO_TWIPS(tbPos), &_rgxTabs[0]);
	return hr != NOERROR ? hr : FormatSetter(PFM_TABSTOPS);
}

/*
 *	ITextPara::GetAlignment(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the current paragraph
 *		alignment value
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetAlignment (
	long *pValue)		//@parm Out parm to receive paragraph alignment
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetAlignment");

	if(!pValue)
		return E_INVALIDARG;

	HRESULT hr = UpdateFormat();			// If live Para object, update
											//  _PF to current _prg values
	if(_PF._bAlignment > ARRAY_SIZE(g_rgREtoTOMAlign))	// Fix bogus value since
		_PF._bAlignment = 0;				//  array lookup can't use it

	*pValue = (_dwMask & PFM_ALIGNMENT)
			? (LONG)g_rgREtoTOMAlign[_PF._bAlignment] : tomUndefined;

	return hr;
}

/*
 *	ITextPara::GetHyphenation(long *pValue)
 *
 *	@mfunc
 *		Property get method that gets the tomBool for whether to
 *		suppress hyphenation for the paragraph in a range.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetHyphenation (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetHyphenation");

	if(!pValue)
		return E_INVALIDARG;

	HRESULT hr = EffectGetter(pValue, PFM_DONOTHYPHEN);

	//Oh well, Word inverted meaning after we shipped...
	if(*pValue == tomTrue)
		*pValue = tomFalse;

	else if(*pValue == tomFalse)
		*pValue = tomTrue;

	return hr;
}

/*
 *	ITextPara::GetDuplicate(ITextPara **ppPara) 
 *
 *	@mfunc
 *		Property get method that gets a clone of this text paragraph
 *		format object.
 *
 *	@rdesc
 *		HRESULT = (!ppPara) ? E_INVALIDARG : 
 *				  (if success) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtPara::GetDuplicate (
	ITextPara **ppPara)		//@parm Out parm to receive ITextPara clone
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetDuplicate");

	if(!ppPara)
		return E_INVALIDARG;

	*ppPara = NULL;

	if(IsZombie())
		return CO_E_RELEASED;
				
	CTxtPara *pPara = new CTxtPara(NULL);	// NULL creates a clone
	if(!pPara)								//  (its _prg is NULL)
		return E_OUTOFMEMORY;

	if(_prg)
		UpdateFormat();

	*pPara  = *this;						// Copy value of this object
	pPara->_prg = NULL;						// It's not attached to a rg
	*ppPara = pPara;						// Return ptr to clone
	return NOERROR;
}

/*
 *	ITextPara::GetFirstLineIndent(float * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the amount used to indent the
 *		first line of a paragraph relative to the left indent, which is used
 *		for subsequent lines.  The amount is given in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetFirstLineIndent (
	float *pValue)		//@parm Out parm to receive first-line indent
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetFirstLineIndent");

	HRESULT hr = GetParameter(&_PF._dxOffset, PFM_OFFSET, -4, (long *)pValue);
	if(hr == NOERROR && *pValue != tomFloatUndefined)
		*pValue = -*pValue;						// Defined as negative of
	return hr;									//  RichEdit dxOffset
}

/*
 *	ITextPara::GetKeepTogether(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the tomBool for whether to
 *		keep the lines in a range together.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetKeepTogether (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetKeepTogether");

	return EffectGetter(pValue, PFM_KEEP);
}

/*
 *	ITextPara::GetKeepWithNext(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the tomBool for whether to
 *		keep the paragraphs in this range together.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetKeepWithNext (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetKeepWithNext");

	return EffectGetter(pValue, PFM_KEEPNEXT);
}

#define	PFM_LEFTINDENT (PFM_STARTINDENT + PFM_OFFSET)

/*
 *	ITextPara::GetLeftIndent(float * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the amount used to indent all
 *		but the first line of a paragraph.  The amount is given in
 *		floating-point points and is relative to the left margin.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 *
 *	@devnote
 *		For the TOM left indent to be defined, both the RichEdit start
 *		indent and the offset must be defined (see XOR and AND in *pValue
 *		code).
 */
STDMETHODIMP CTxtPara::GetLeftIndent (
	float *pValue)		//@parm Out parm to receive left indent
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetLeftIndent");

	if(!pValue)
		return E_INVALIDARG;

	HRESULT hr = UpdateFormat();			// If live Para object, update
											//  _PF to current _prg values
	*pValue = ((_dwMask ^ PFM_LEFTINDENT) & PFM_LEFTINDENT)
			? tomFloatUndefined
			: TWIPS_TO_FPPTS(_PF._dxStartIndent + _PF._dxOffset);

	return hr;
}

/*
 *	ITextPara::GetLineSpacing(float * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the line spacing value, which
 *		is given in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetLineSpacing (
	float *pValue)		//@parm Out parm to receive line spacing
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetLineSpacing");

	return GetParameter(&_PF._dyLineSpacing, PFM_LINESPACING, -4,
						(long *)pValue);
}

/*
 *	ITextPara::GetLineSpacingRule(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the line-spacing rule for this range
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetLineSpacingRule (
	long *pValue)		//@parm Out parm to receive line spacing rule
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetLineSpacingRule");

	return GetParameter((long *)&_PF._bLineSpacingRule, PFM_LINESPACING,
						1, pValue);
}

/*
 *	ITextPara::GetListAlignment(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the kind of bullet/numbering text
 *		alignment to use with paragraphs.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetListAlignment(
	long * pValue)		//@parm Out parm to receive numbering alignment
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetListAlignment");

	HRESULT hr = GetParameter((long *)&_PF._wNumberingStyle,
								PFM_NUMBERINGSTYLE, 2, pValue);
	if(hr == NOERROR && *pValue != tomUndefined)
		*pValue &= 3;						// Kill all but alignment bits

	return hr;
}

/*
 *	ITextPara::GetListLevelIndex(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the list level index to use
 *		with paragraphs.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetListLevelIndex(
	long * pValue)		//@parm Out parm to receive list level index
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetListLevelIndex");

	HRESULT hr = GetParameter((long *)&_PF._wNumberingStyle,
								PFM_NUMBERINGSTYLE, 2, pValue);
	if(hr == NOERROR)
		*pValue = (*pValue >> 4) & 0xf;		// Kill all but list level index
	return hr;
}

/*
 *	ITextPara::GetListStart(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the numbering start value to use
 *		with paragraphs.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetListStart(
	long * pValue)			//@parm Out parm to receive numbering start value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetListSpace");

	return GetParameter((long *)&_PF._wNumberingStart, PFM_NUMBERINGSTART, 2,
						pValue);
}

/*
 *	ITextPara::GetListTab(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the distance between the first indent
 *		and the start of text on the first line.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetListTab(
	float * pValue)			//@parm Out parm to receive list tab to text
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetListTab");

	return GetParameter((long *)&_PF._wNumberingTab, PFM_NUMBERINGTAB, -2,
						(long *)pValue);
}

/*
 *	ITextPara::GetListType(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the type of list to use
 *		with paragraphs.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 *
 *	@devnote
 *		TOM's values are:
 *
 *		List Type		Value	Meaning
 *		tomNoList			0		Turn off paragraph numbering
 *		tomListBullet		1		default is bullet
 *		tomNumberAsArabic	2		0, 1, 2, ...
 *		tomNumberAsLCLetter	3		a, b, c, ...
 *		tomNumberAsUCLetter	4		A, B, C, ...
 *		tomNumberAsLCRoman	5		i, ii, iii, ...
 *		tomNumberAsUCRoman	6		I, II, III, ...
 *		tomNumberAsSequence	7		ListStart is 1st Unicode to use
 *
 *		Nibble 2 of _PF._wNumberingStyle says whether to number with trailing
 *		parenthesis, both parentheses, follow by period, or leave plain. This
 *		This nibble needs to be returned in nibble 4 of *pValue.
 */
STDMETHODIMP CTxtPara::GetListType (
	long *pValue)		//@parm Out parm to receive type of list
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetListType");

	HRESULT hr = GetParameter((long *)&_PF._wNumbering,
								PFM_NUMBERING, 2, pValue);

	// OR in Number style bits (see note above)
	if(hr == NOERROR && *pValue != tomUndefined) 
		*pValue |= (_PF._wNumberingStyle << 8) & 0xf0000;
	return hr;
}

/*
 *	ITextPara::GetNoLineNumber(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the tomBool for whether to
 *		suppress line numbering for the paragraphs in a range.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetNoLineNumber (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetNoLineNumber");

	return EffectGetter(pValue, PFM_NOLINENUMBER);
}

/*
 *	ITextPara::GetPageBreakBefore(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the tomBool for whether to
 *		eject the page before the paragraphs in this range.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetPageBreakBefore (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetPageBreakBefore");

	return EffectGetter(pValue, PFM_PAGEBREAKBEFORE);
}

/*
 *	ITextPara::GetRightIndent(float * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the amount used to indent the
 *		right margin of a paragraph relative to the right margin.  The
 *		amount is given in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetRightIndent (
	float *pValue)		//@parm Out parm to receive right indent
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetRightIndent");

	return GetParameter(&_PF._dxRightIndent, PFM_RIGHTINDENT, -4,
						(long *)pValue);
}

/*
 *	ITextPara::GetSpaceAfter(float * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the amount used to space vertically
 *		after a paragraph.  The amount is given in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetSpaceAfter (
	float *pValue)		//@parm Out parm to receive space-after value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetSpaceAfter");

	return GetParameter(&_PF._dySpaceAfter, PFM_SPACEAFTER, -4,
						(long *)pValue);
}

/*
 *	ITextPara::GetSpaceBefore(float * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the amount used to space vertically
 *		before starting a paragraph.  The amount is given in floating-point
 *		points.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetSpaceBefore (
	float *pValue)		//@parm Out parm to receive space-before value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetSpaceBefore");

	return GetParameter(&_PF._dySpaceBefore, PFM_SPACEBEFORE, -4,
						(long *)pValue);
}

/*
 *	ITextPara::GetStyle(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the style handle for the
 *		paragraphs in this range.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetStyle (
	long *	pValue)		//@parm Out parm to receive paragraph style handle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetStyle");

	return GetParameter((long *)&_PF._sStyle, PFM_STYLE, 2, pValue);
}

/*
 *	ITextPara::GetTab(long iTab, float *ptbPos, long *ptAlign, long *ptbLeader) 
 *
 *	@mfunc
 *		Method that gets tab parameters for the iTab th tab, that
 *		is, set *ptbPos, *ptbAlign, and *ptbLeader equal to the iTab th
 *		tab's displacement, alignment, and leader style, respectively. 
 *		iTab has special values defined in the table below.  The
 *		displacement is given in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (!pdxptab || !ptbt || !pstyle || no iTab tab) ?
 *				  E_INVALIDARG : (exists) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtPara::GetTab (
	long	iTab,			//@parm Index of tab to retrieve info for
	float *	ptbPos,			//@parm Out parm to receive tab displacement
	long *	ptbAlign,		//@parm Out parm to receive tab type
	long *	ptbLeader)		//@parm Out parm to receive tab style
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetTab");

	if(!ptbPos || !ptbAlign || !ptbLeader)
		return E_INVALIDARG;

	*ptbAlign = *ptbLeader = 0;

	HRESULT hr = UpdateFormat();			// If live Para object, update
											//  _PF to current _prg values
	if(!(_dwMask & PFM_TABSTOPS))			// Tabs are undefined (more than
	{										//  one set of definitions)
		*ptbPos = tomFloatUndefined;
		return hr;
	}

	LONG dxTab = 0;							// Default 0 in case GetTab fails

	if(iTab < 0 && iTab >= tomTabBack)		// Save *ptbPos if it's supposed
		dxTab = FPPTS_TO_TWIPS(*ptbPos);	//  be used (in general might get
											//  floating-point error)
	hr = _PF.GetTab(iTab, &dxTab, ptbAlign, ptbLeader, &_rgxTabs[0]);
	*ptbPos = TWIPS_TO_FPPTS(dxTab);

	return (hr == NOERROR && !dxTab) ? S_FALSE : hr;
}

/*
 *	ITextPara::GetTabCount(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the tab count.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetTabCount (
	long *	pValue)		//@parm Out parm to receive tab count
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetTabCount");

	return GetParameter((long *)&_PF._bTabCount, PFM_TABSTOPS, 1, pValue);
}

/*
 *	ITextPara::GetWidowControl(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the tomBool for whether to
 *		control widows and orphans for the paragraphs in a range.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetWidowControl (
	long *	pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetWidowControl");

	return EffectGetter(pValue, PFM_NOWIDOWCONTROL);
}

/*
 *	ITextPara::IsEqual(ITextPara * pPara, long * pB) 
 *
 *	@mfunc
 *		Method that sets pB = tomTrue if this range has the same
 *		properties as *pPara. The IsEqual() method ignores entries for which
 *		either para object has a tomUndefined value.
 *
 *	@rdesc
 *		HRESULT = (equal objects) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtPara::IsEqual (
	ITextPara *	pPara,		//@parm ITextPara to compare to
	long *		pB)			//@parm Out parm to receive comparison result
{
#ifndef PEGASUS	
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::IsEqual");

	if(pB)
		*pB = tomFalse;

	if(!IsSameVtables(this, pPara))
		return S_FALSE;

	HRESULT hr = UpdateFormat();			// Update _PFs in case they are
	if(hr != NOERROR)						//  attached to ranges
		return hr;

	CTxtPara *pP = (CTxtPara *)pPara;
	hr = pP->UpdateFormat();
	if(hr != NOERROR)
		return hr;

	CParaFormat *pPF = &(pP->_PF); 
	DWORD		 dwMask = pP->_dwMask;		// Save mask

	if(_dwMask != dwMask)					// The two have to be the same
		return S_FALSE;						//  for equality

	if((dwMask & PFM_TABSTOPS) && _PF._bTabCount)
	{
		_PF._iTabs = GetTabsCache()->Cache(&_rgxTabs[0], _PF._bTabCount);
		if(pP != this)						// If comparing to self,
		{									//  don't AddRef twice
			pP->_PF._iTabs = GetTabsCache()->Cache(&pP->_rgxTabs[0],
												   pPF->_bTabCount);
		}
	}
	if(dwMask & _PF.Delta(pPF, FALSE))		// Any difference?
		hr = S_FALSE;						// Yes. *pB set equal to tomFalse above
	else if(pB)
		*pB = tomTrue;

	CheckTabsAddRef();
	pP->CheckTabsAddRef();

#endif
	return hr;
}

/*
 *	ITextPara::Reset(long Value) 
 *
 *	@mfunc
 *		Method that resets the paragraph formatting to the default
 *		values to 1) those defined by the RTF \pard control word (Value =
 *		tomDefault), and 2) all undefined values (Value = tomUndefined). 
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::Reset (
	long Value)		//@parm Kind of reset (tomDefault or tomUndefined)
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::Reset");

	Assert(tomApplyLater == tomApplyNow + 1);

	HRESULT hr = CanChange(NULL);

	if(hr != NOERROR)								// Takes care of zombie
		return hr;									//  and protection

	if(Value == tomDefault)
	{
		if(_prg)
		{
			_PF = *_prg->GetPed()->GetParaFormat(-1);
			if(_PF._iTabs != -1)
			{
				const LONG *prgxTabs = _PF.GetTabs();
				_PF._iTabs = -1;
				for(LONG i = 0; i < _PF._bTabCount; i++)
					_rgxTabs[i] = prgxTabs[i];
			}
			FormatSetter(PFM_ALL2);
		}
		else
			_PF.InitDefault(0);
		_dwMask = PFM_ALL2;
	}
	else if(Value == tomUndefined && 			// Only applicable for clones
		(!_prg || _fApplyLater))				//  or delayed application
	{
		_dwMask = 0;							
	}
	else if((Value | 1) == tomApplyLater)		// Set-method optimization
	{
		_fApplyLater = Value & 1;
		if(!_fApplyLater)						// Apply now
			FormatSetter(_dwMask);
	}
	else if((Value | 1) == tomCacheParms)		// Get-method optimization
	{
		_fCacheParms = FALSE;
		if(Value & 1)							// Cache parms now, but
		{										//  don't update on gets
			UpdateFormat();							
			_fCacheParms = TRUE;
		}
	}
	else
		return E_INVALIDARG;

	return NOERROR;
}

/*
 *	ITextPara::SetAlignment(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the paragraph alignment to Value
 *
 *	@rdesc
 *		HRESULT = (Value > 3) ? E_INVALIDARG : 
 *				  (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetAlignment (
	long Value)		//@parm New paragraph alignment
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetAlignment");

	if(Value == tomUndefined)					// NINCH
		return NOERROR;

	if((DWORD)Value >= ARRAY_SIZE(g_rgTOMtoREAlign))
		return E_INVALIDARG;

	_PF._bAlignment = g_rgTOMtoREAlign[Value];
	
	return FormatSetter(PFM_ALIGNMENT);
}

/*
 *	ITextPara::SetHyphenation(long Value)
 *
 *	@mfunc
 *		Property put method that sets the tomBool that controls the
 *		suppression of hyphenation for the paragraphs in the range.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetHyphenation (
	long Value)		//@parm New tomBool for suppressing hyphenation
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetHyphenation");

	if(Value == tomTrue)			// Invert meaning for RichEdit
		Value = tomFalse;			// Word inverted it late in the game...

	else if (Value == tomFalse)
		Value = tomTrue;

	return EffectSetter(Value, PFM_DONOTHYPHEN);
}

/*
 *	ITextPara::SetDuplicate(ITextPara *pPara) 
 *
 *	@mfunc
 *		Property put method that applies the paragraph formatting of pPara
 *		to this para object.  Note that tomUndefined values in pPara have
 *		no effect (NINCH - NoInputNoCHange).
 *
 *	@rdesc
 *		HRESULT = (!pPara) ? E_INVALIDARG : 
 *				  (if success) ? NOERROR :
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetDuplicate (
	ITextPara *pPara)		//@parm New paragraph formatting
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetDuplicate");

	DWORD		dwMask = 0;
	long		iTab;
	CTxtRange *	prg;
	long		tbAlign;
	long		tbLeader;
	float		tbPos;
	long		Value;
	float		x, y, z;

	if(IsZombie())							// Check for range zombie
		return CO_E_RELEASED;

	if(IsSameVtables(this, pPara))			// If pPara belongs to this TOM
	{										//  engine, cast and copy
		((CTxtPara *)pPara)->UpdateFormat();// Since this TOM engine, can
		_PF = ((CTxtPara *)pPara)->_PF;		//  cast to a CTxtPara
		dwMask = ((CTxtPara *)pPara)->_dwMask;// Use this mask in case this 			
	}										//  para is active
	else
	{										// Need to call pFont for all para
		prg = _prg;							//  properties
		_prg = NULL;						// Turn into clone during transfer

		pPara->GetStyle(&Value);
		SetStyle(Value);

		pPara->GetAlignment(&Value);
		SetAlignment(Value);

		pPara->GetHyphenation(&Value);
		SetHyphenation(Value);

		pPara->GetKeepTogether(&Value);
		SetKeepTogether(Value);

		pPara->GetKeepWithNext(&Value);
		SetKeepWithNext(Value);

		pPara->GetFirstLineIndent(&x);
		pPara->GetLeftIndent (&y);
		pPara->GetRightIndent(&z);
		SetIndents(x, y, z);

		pPara->GetLineSpacingRule(&Value);
		pPara->GetLineSpacing(&y);
		SetLineSpacing(Value, y);

		pPara->GetNoLineNumber(&Value);
		SetNoLineNumber(Value);

		pPara->GetListAlignment(&Value);
		SetListAlignment(Value);

		pPara->GetListLevelIndex(&Value);
		SetListLevelIndex(Value);

		pPara->GetListStart(&Value);
		SetListStart(Value);

		pPara->GetListTab(&x);
		SetListTab(x);

		pPara->GetListType(&Value);
		SetListType(Value);

		pPara->GetPageBreakBefore(&Value);
		SetPageBreakBefore(Value);

		pPara->GetSpaceBefore(&y);
		SetSpaceBefore(y);

		pPara->GetSpaceAfter(&y);
		SetSpaceAfter(y);

		pPara->GetWidowControl(&Value);
		SetWidowControl(Value);

		ClearAllTabs();
		pPara->GetTabCount(&Value);
		for(iTab = 0; iTab < Value; iTab++)
		{
			pPara->GetTab(iTab, &tbPos, &tbAlign, &tbLeader);
			AddTab(tbPos, tbAlign, tbLeader);
		}
		_prg = prg;							// Restore original value
	}
	return FormatSetter(dwMask);			// Apply it unless !_prg
}

/*
 *	ITextPara::SetKeepTogether(long Value)
 *
 *	@mfunc
 *		Property put method that sets the tomBool that controls
 *		whether to keep the lines in a range together.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetKeepTogether (
	long Value)		//@parm New tomBool for keeping lines together
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetKeepTogether");

	return EffectSetter(Value, PFM_KEEP);
}

/*
 *	ITextPara::SetKeepWithNext(long Value)
 *
 *	@mfunc
 *		Property put method that sets the tomBool that controls
 *		whether to keep the paragraphs in a range together.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetKeepWithNext (
	long Value)		//@parm New tomBool for keeping paragraphs together
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetKeepWithNext");

	return EffectSetter(Value, PFM_KEEPNEXT);
}

/*
 *	ITextPara::SetIndents(float First, float Left, float Right) 
 *
 *	@mfunc
 *		Method that sets the left indent of all but the first line
 *		of a paragraph equal to Left and sets the displacement of the first
 *		line of a paragraph relative to the left indent equal to First.  The
 *		left indent value is relative to the left margin. You can also set
 *		the right indent by giving the optional Right parameter a value (the
 *		(default is tomUndefined).  All indents are given in floating-point
 *		points.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_INVALIDARG
 */
STDMETHODIMP CTxtPara::SetIndents (
	float First,	//@parm New first indent (1st-line offset relative to left indent)
	float Left,		//@parm New left indent (left offset of all but 1st line)
	float Right)	//@parm New right indent (right offset of all lines)
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetIndents");

	DWORD	dwMask	= 0;
	LONG	j = (First != tomFloatUndefined) + (Left == tomFloatUndefined);

	if(IsZombie())
		return CO_E_RELEASED;

	if(j < 2)										// At least First or Left
	{												//  defined
		if(j == 1)									// Only one defined: need
			UpdateFormat();							//  current _PF._dxOffset

		if(First != tomFloatUndefined)
		{
			j = FPPTS_TO_TWIPS(First);				
	 		if(Left == tomFloatUndefined)			
			{
				_PF._dxStartIndent += _PF._dxOffset	// Cancel current offset
					+ j;							//  and add in new one
			}
			_PF._dxOffset = -j;						// Offset for all but 1st
			dwMask = PFM_OFFSET + PFM_STARTINDENT;	//  line
		} 
 		if(Left != tomFloatUndefined)
		{
			_PF._dxStartIndent =  FPPTS_TO_TWIPS(Left) - _PF._dxOffset;
			dwMask |= PFM_STARTINDENT;
		}
	}

	if(Right != tomFloatUndefined)
	{
		_PF._dxRightIndent = FPPTS_TO_TWIPS(Right);
		dwMask |= PFM_RIGHTINDENT;
	}

	return dwMask ? FormatSetter(dwMask) : NOERROR;
}

/*
 *	ITextPara::SetLineSpacing(long Rule, float Spacing) 
 *
 *	@mfunc
 *		Method that sets the paragraph line spacing rule to Rule and
 *		the line spacing to Spacing. If the line spacing rule treats the
 *		Spacing value as a linear dimension, then that dimension is given in
 *		floating-point points.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetLineSpacing (
	long	Rule,		//@parm Value of new line-spacing rule
	float	Spacing)	//@parm Value of new line spacing
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetLineSpacing");

 	LONG j = (Rule == tomUndefined) + (Spacing == tomFloatUndefined);

	if(j == 2)
		return NOERROR;

	if(j == 1 || (DWORD)Rule > 5 || Spacing < 0)
		return E_INVALIDARG;

	_PF._bLineSpacingRule = (BYTE)Rule;			// Default as if both are OK
	_PF._dyLineSpacing	 = (SHORT)FPPTS_TO_TWIPS(Spacing);

	return FormatSetter(PFM_LINESPACING);
}

/*
 *	ITextPara::SetListAlignment (long Value) 
 *
 *	@mfunc
 *		Property put method that sets the kind of List alignment to be
 *		used for paragraphs.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetListAlignment(
	long Value)		//@parm Value of new list alignment
{
	if(Value == tomUndefined)
		return NOERROR;

	if((unsigned)Value > tomAlignRight)
		return E_INVALIDARG;

	long	Style;
	HRESULT hr = GetParameter((long *)&_PF._wNumberingStyle,
								PFM_NUMBERINGSTYLE, 2, &Style);
	if(hr != NOERROR)
		return hr;

	return SetParameter((long *)&_PF._wNumberingStyle, PFM_NUMBERINGSTYLE,
						2, (Style & ~3) | (Value & 3));
}

/*
 *	ITextPara::SetListLevelIndex (long Value) 
 *
 *	@mfunc
 *		Property put method that sets the kind of list level index to be
 *		used for paragraphs.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetListLevelIndex(
	long Value)
{
	if(Value == tomUndefined)
		return NOERROR;

	if((unsigned)Value > 15)
		return E_INVALIDARG;

	long	Style;
	HRESULT hr = GetParameter((long *)&_PF._wNumberingStyle,
								PFM_NUMBERINGSTYLE, 2, &Style);
	if(hr != NOERROR)
		return hr;

	return SetParameter((long *)&_PF._wNumberingStyle, PFM_NUMBERINGSTYLE,
						2, (Style & ~0xf0) | (Value << 4));
}

/*
 *	ITextPara::SetListStart (long Value) 
 *
 *	@mfunc
 *		Property put method that sets the starting number to use for
 *		paragraph numbering
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetListStart(
	long Value)		//@parm New numbering start value
{
	if(Value == tomUndefined)
		return NOERROR;

	if(Value < 0)
		return E_INVALIDARG;

	return SetParameter((long *)&_PF._wNumberingStart, PFM_NUMBERINGSTART,
						2, Value);
}

/*
 *	ITextPara::SetListTab (long Value) 
 *
 *	@mfunc
 *		Property put method that sets the distance between the first indent
 *		and the start of text on the first line.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetListTab(
	float Value)		//@parm New numbering tab value
{
	if(Value == tomFloatUndefined)
		return NOERROR;

	if(Value < 0)
		return E_INVALIDARG;

	return SetParameter((long *)&_PF._wNumberingTab, PFM_NUMBERINGTAB,
						-2, *(long *)&Value);
}

/*
 *	ITextPara::SetListType (long Value) 
 *
 *	@mfunc
 *		Property put method that sets the kind of List to be
 *		used for paragraphs.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetListType (
	long Value)		//@parm New List code
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetListType");

	if(Value == tomUndefined)
		return NOERROR;

	if((unsigned)Value > 0xf0000)
		return E_INVALIDARG;

	long	Style;
	HRESULT hr = GetParameter((long *)&_PF._wNumberingStyle,
								PFM_NUMBERINGSTYLE, 2, &Style);
	if(hr != NOERROR)
		return hr;

	_PF._wNumbering		= (WORD)Value;
	_PF._wNumberingStyle = (WORD)((Style & ~0xf00) | ((Value >> 8) & 0xf00));

	return FormatSetter(PFM_NUMBERING | PFM_NUMBERINGSTYLE);
}

/*
 *	ITextPara::SetNoLineNumber (long Value)
 *
 *	@mfunc
 *		Property put method that sets the tomBool that controls
 *		whether to suppress the numbering of paragraphs in a range.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetNoLineNumber (
	long Value)		//@parm New tomBool for suppressing line numbering
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetNoLineNumber");

	return EffectSetter(Value, PFM_NOLINENUMBER);
}

/*
 *	ITextPara::SetPageBreakBefore (long Value)
 *
 *	@mfunc
 *		Property put method that sets the tomBool that controls
 *		whether to eject the page before each paragraph in a range.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetPageBreakBefore (
	long Value)		//@parm New tomBool for ejecting page before paragraphs
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetPageBreakBefore");

	return EffectSetter(Value, PFM_PAGEBREAKBEFORE);
}

/*
 *	ITextPara::SetRightIndent (float Value) 
 *
 *	@mfunc
 *		Property put method that sets the amount to indent the right
 *		margin of paragraph equal to Value, which is given in floating-point
 *		points.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetRightIndent (
	float Value)		//@parm New right indent
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetRightIndent");

	return SetParameter(&_PF._dxRightIndent, PFM_RIGHTINDENT, -4,
						*(long *)&Value);
}

/*
 *	ITextPara::SetSpaceAfter(float Value) 
 *
 *	@mfunc
 *		Property put method that sets the amount to space vertically
 *		after finishing a paragraph equal to Value, which is given in
 *		floating-point points.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetSpaceAfter (
	float Value)		//@parm New space-after value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetSpaceAfter");

	if(Value == tomFloatUndefined)
		return NOERROR;

	if(Value < 0)
		return E_INVALIDARG;

	return SetParameter(&_PF._dySpaceAfter, PFM_SPACEAFTER, -4,
						*(long *)&Value);
}

/*
 *	ITextPara::SetSpaceBefore(float Value) 
 *
 *	@mfunc
 *		Property put method that sets the amount to space vertically
 *		before starting a paragraph equal to Value, which is given in
 *		floating-point points.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetSpaceBefore (
	float Value)		//@parm New space-before value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetSpaceBefore");

	if(Value == tomFloatUndefined)
		return NOERROR;

	if(Value < 0)
		return E_INVALIDARG;

	return SetParameter(&_PF._dySpaceBefore, PFM_SPACEBEFORE, -4,
						*(long *)&Value);
}

/*
 *	ITextPara::SetStyle(long Value)
 *
 *	@mfunc
 *		Property put method that sets the paragraph style handle for
 *		the paragraphs in a range.  See GetStyle() for further discussion.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetStyle (
	long Value)		//@parm New paragraph style handle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetStyle");

 	if(Value == tomUndefined)
		return NOERROR;

	if(Value < -32768 || Value > 32767)
		return E_INVALIDARG;

	return SetParameter((long *)&_PF._sStyle, PFM_STYLE, 2, Value);
}

/*
 *	ITextPara::SetWidowControl(long Value)
 *
 *	@mfunc
 *		Property put method that sets the tomBool that controls the
 *		suppression of widows and orphans.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetWidowControl (
	long Value)		//@parm New tomBool for suppressing widows and orphans
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetWidowControl");

	return EffectSetter(Value, PFM_NOWIDOWCONTROL);
}


//----------------------------- CTxtFont Helpers -------------------------------------

/*
 *	@doc INTERNAL
 *
 *	CTxtFont::EffectGetter (ptomBool, dwMask)
 *
 *	@mfunc
 *		Set *<p ptomBool> = state of bit given by the bit mask <p dwMask>
 *
 *	@rdesc
 *		HRESULT = (!<p ptomBool>) ? E_INVALIDARG : NOERROR
 */
HRESULT CTxtFont::EffectGetter (
	long *	ptomBool,		//@parm Out parm to receive tomBool
	DWORD	dwMask) 		//@parm Bit mask identifying effect to retrieve
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtFont::EffectGetter");

	if(!ptomBool)
		return E_INVALIDARG;

	HRESULT hr = UpdateFormat();			// If live Font object, update
											//  _CF to current _prg values
	*ptomBool = !(_dwMask		& dwMask) ? tomUndefined :
				(_CF._dwEffects & dwMask) ? tomTrue : tomFalse;
	
	return hr;
}

/*
 *	CTxtFont::EffectSetter (Value, dwMask, dwEffect)
 *
 *	@mfunc
 *		Mask off this range's effect bits identified by <p dwMask> and set
 *		effect bit given by <p dwEffect> equal to value given by <p Value>
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 */
HRESULT CTxtFont::EffectSetter (
	long 	Value,		//@parm Value to set effect bit to
	DWORD	dwMask, 	//@parm Bit mask identifying effect(s) to turn off
	DWORD	dwEffect)	//@parm Effect bit to set
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtFont::EffectSetter");

	if(Value == tomUndefined)					// Do nothing (NINCH)
		return NOERROR;

	if(Value == tomToggle)
	{
		if(_prg)								// If live Font object, update
		{										//  _CF.dwEffects for toggling
			if(_prg->IsZombie())
				return CO_E_RELEASED;

			LONG iFormat = _prg->_iFormat;		// Default iFormat for IP
			LONG cch	 = _prg->GetCch();

			if(cch)								// Range is nondegenerate
			{
				CFormatRunPtr rp(_prg->_rpCF);
				if(cch > 0)						// Get iFormat at cpFirst
					rp.AdvanceCp(-cch);
				iFormat = rp.GetFormat();
			}
			_CF._dwEffects = _prg->GetPed()->GetCharFormat(iFormat)->_dwEffects;
		}
		_CF._dwEffects ^= dwEffect;			// Toggle effect(s)
		if (dwMask != dwEffect)
		{
			// Need to turn off other bits that are not being toggle
			DWORD	dwTurnOff = dwMask ^ dwEffect;
			_CF._dwEffects &= ~dwTurnOff;
		}
	}
	else
	{
		_CF._dwEffects &= ~dwMask;				// Default effect(s) off
		if(Value)
		{
			if(Value != tomTrue)
				return E_INVALIDARG;
			_CF._dwEffects |= dwEffect;			// Turn an effect on
		}
	}
	return FormatSetter(dwMask);
}

/*
 *	CTxtFont::FormatSetter (dwMask)
 *
 *	@mfunc
 *		Set this CCharFormat or _prg's with mask <p dwMask>
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
HRESULT CTxtFont::FormatSetter (
	DWORD	 dwMask)	//@parm Mask for value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtFont::FormatSetter");

	if(_prg && !_fApplyLater)
	{
		 HRESULT hr = _prg->CharFormatSetter(&_CF, dwMask);
		 if(hr != NOERROR)
			 return hr;
	}
	_dwMask |= dwMask;						// Collect data in font clone
	return NOERROR;
}

/*
 *	CTxtFont::GetParameter (pParm, dwMask, Type, pValue)
 *
 *	@mfunc
 *		If _prg is defined (not clone), update _CF to range value.
 *		Set *pValue = *pParm unless NINCHed, in which case set it to
 *		Type < 0 ? tomFloatUndefined : tomUndefined.  |Type| gives
 *		the byte length of the pParm field.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 */
HRESULT	CTxtFont::GetParameter (
	long *	pParm,		//@parm Address of _CF member to get
	DWORD	dwMask,		//@parm _CF member mask for NINCH checking
	long	Type,		//@parm # bytes of parameter or 0 for float
	long *	pValue)		//@parm Out parm to receive value
{
	UpdateFormat();							// If live Font object, update
											//  _CF to current _prg values
	return CTxtFormat::GetParameter(pParm, _dwMask & dwMask, Type, pValue);
}

/*
 *	CTxtFont::SetParameter (pParm, dwMask, Type, Value)
 *
 *	@mfunc
 *		Set parameter at address pParm with mask big dwMask to the value
 *		Value performing type conversions indicated by Type
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 */
HRESULT	CTxtFont::SetParameter (
	long *	pParm,		//@parm Address of _CF member to get
	DWORD	dwMask,		//@parm _CF member mask for NINCH checking
	long	Type,		//@parm # bytes of parameter or 0 for float
	long 	Value)		//@parm Out parm to receive value
{
	HRESULT hr = CTxtFormat::SetParameter(pParm, Type, Value);
	return hr == NOERROR ? FormatSetter(dwMask) : hr;	
}

/*
 *	CTxtFont::UpdateFormat ()
 *
 *	@mfunc
 *		Update format if this font object is attached to a live range.
 *		Set _dwMask = 0 if attached to zombied range.
 *
 *	@rdesc
 *		HRESULT = (attached to zombied range)
 *				? CO_E_RELEASED : NOERROR
 */
HRESULT CTxtFont::UpdateFormat ()
{
	if(_prg && !_fCacheParms)
	{
		if(_prg->IsZombie())
		{
			_dwMask = 0;					// Nothing defined
			return CO_E_RELEASED;
		}
		_dwMask = _prg->GetCharFormat(&_CF);
	}
	return NOERROR;
}


//----------------------------- CTxtPara Helpers -------------------------------------

/*
 *	@doc INTERNAL
 *
 *	CTxtPara::EffectGetter (ptomBool, dwMask)
 *
 *	@mfunc
 *		Set *<p ptomBool> = state of bit given by the bit mask <p dwMask>
 *
 *	@rdesc
 *		HRESULT = (!<p ptomBool>) ? E_INVALIDARG : NOERROR
 */
HRESULT CTxtPara::EffectGetter (
	long *	ptomBool,		//@parm Out parm to receive tomBool
	DWORD	dwMask) 		//@parm Bit mask identifying effect to retrieve
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtPara::EffectGetter");

	if(!ptomBool)
		return E_INVALIDARG;

	HRESULT hr = UpdateFormat();			// If live Para object, update
											//  _PF to current _prg values
	*ptomBool = !(_dwMask & dwMask) ? tomUndefined :
				(_PF._wEffects & (dwMask >> 16)) ? tomTrue : tomFalse;
	return hr;
}

/*
 *	CTxtPara::EffectSetter (Value, dwMask)
 *
 *	@mfunc
 *		Set this range's effect bit as given by <p dwMask> equal to value
 *		given by <p Value>
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 *
 *	@devnote
 *		Note that the mask bits for paragraph effects are in the high word
 *		of _dwMask, but the effects are stored in the WORD _wEffects.
 */
HRESULT CTxtPara::EffectSetter (
	long 	Value,		//@parm Value to set effect bit to
	DWORD	dwMask) 	//@parm Bit mask identifying effect to set
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtPara::EffectSetter");

	if(Value == tomUndefined)					// Do nothing (NINCH)
		return NOERROR;

	DWORD dwEffects = _PF._wEffects << 16;		// Move effects over to where
												//  mask is
	if(Value == tomToggle)
	{
		if(_prg)								// If live Para object, update
		{										//  _PF._wEffects for toggling
			if(_prg->IsZombie())
				return CO_E_RELEASED;

			_dwMask = _prg->GetParaFormat(&_PF);
			dwEffects = _PF._wEffects << 16;
			_PF._iTabs = -1;					// No interest in TABs here
		}
		if(_dwMask & dwMask)					// Effect is defined:
			dwEffects ^=  dwMask;				//  toggle it
		else									// Effect is NINCHed
			dwEffects &= ~dwMask;				// Turn it all off
	}
	else
	{
		dwEffects &= ~dwMask;					// Default effect off
		if(Value)
		{
			if(Value != tomTrue)
				return E_INVALIDARG;
			dwEffects |= dwMask;				// Turn it on
		}
	}

	_PF._wEffects = (WORD)(dwEffects >> 16);
	return FormatSetter(dwMask);
}

/*
 *	CTxtPara::FormatSetter (dwMask)
 *
 *	@mfunc
 *		Set this CParaFormat or _prg's with mask <p dwMask>
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 */
HRESULT CTxtPara::FormatSetter (
	DWORD	 dwMask)	//@parm Mask for value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtPara::FormatSetter");

	AssertSz(_PF._iTabs < 0,
		"CTxtPara::FormatSetter: illegal tabs index");

	if(_prg && !_fApplyLater)
	{
		if(dwMask & PFM_TABSTOPS)
			_PF._iTabs = GetTabsCache()->Cache(&_rgxTabs[0], _PF._bTabCount);

		HRESULT hr = _prg->ParaFormatSetter(&_PF, dwMask);
		CheckTabsAddRef();
		if(hr != NOERROR)
			return hr;
	}
	_dwMask |= dwMask;							// Collect data in para clone
	return NOERROR;
}

/*
 *	CTxtPara::GetParameter (pParm, dwMask, Type, pValue)
 *
 *	@mfunc
 *		If _prg is defined (not clone), update _PF to range value.
 *		Set *pValue = *pParm unless NINCHed, in which case set it to
 *		Type < 0 ? tomFloatUndefined : tomUndefined.  |Type| gives
 *		the byte length of the pParm field.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 */
HRESULT	CTxtPara::GetParameter (
	long *	pParm,		//@parm Address of _PF member to get
	DWORD	dwMask,		//@parm _PF member mask for NINCH checking
	long	Type,		//@parm # bytes of parameter or 0 for float
	long *	pValue)		//@parm Out parm to receive value
{
	UpdateFormat();							// If live Para object, update
											//  _PF to current _prg values
	return CTxtFormat::GetParameter(pParm, _dwMask & dwMask, Type, pValue);
}

/*
 *	CTxtPara::SetParameter (pParm, dwMask, Type, Value)
 *
 *	@mfunc
 *		Set parameter at address pParm with mask big dwMask to the value
 *		Value performing type conversions indicated by Type
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 */
HRESULT	CTxtPara::SetParameter (
	long *	pParm,		//@parm Address of _PF member to get
	DWORD	dwMask,		//@parm _PF member mask for NINCH checking
	long	Type,		//@parm # bytes of parameter or 0 for float
	long 	Value)		//@parm Out parm to receive value
{
	HRESULT hr = CTxtFormat::SetParameter(pParm, Type, Value);
	return hr == NOERROR ? FormatSetter(dwMask) : hr;	
}

/*
 *	CTxtPara::CheckTabsAddRef ()
 *
 *	@mfunc
 *		Release Tabs reference
 */
void CTxtPara::CheckTabsAddRef()
{
	if(_PF._iTabs >= 0)
	{
		GetTabsCache()->Release(_PF._iTabs);
		_PF._iTabs = -1;
	}
}

/*
 *	CTxtPara::UpdateFormat ()
 *
 *	@mfunc
 *		Update format if this para object is attached to a live range.
 *		Set _dwMask = 0 if attached to zombied range.
 *
 *	@rdesc
 *		HRESULT = (attached to zombied range)
 *				? CO_E_RELEASED : NOERROR
 */
HRESULT CTxtPara::UpdateFormat ()
{
	if(_prg && !_fCacheParms)
	{
		if(_prg->IsZombie())
		{
			_dwMask = 0;					// Nothing defined
			return CO_E_RELEASED;
		}
		_dwMask = _prg->GetParaFormat(&_PF);
		if(_PF._iTabs >= 0)
		{
			CopyMemory(_rgxTabs, GetTabsCache()->Deref(_PF._iTabs),
					   _PF._bTabCount*sizeof(LONG));
			_PF._iTabs = -1;
		}
	}
	return NOERROR;
}

//---------------------------- CTxtFormat Methods --------------------------------

/*
 *	CTxtFormat::CTxtFormat(prg)
 *
 *	@mfunc
 *		Constructor
 */
CTxtFormat::CTxtFormat(CTxtRange *prg)
{
	_cRefs	= 1;
	_prg	= prg;					// NULL for clone
	if(prg)
		prg->AddRef();
}

/*
 *	CTxtFormat::~CTxtFormat()
 *
 *	@mfunc
 *		Destructor
 */
CTxtFormat::~CTxtFormat()
{
	if(_prg)
		_prg->Release();
}

/*
 *	CTxtFormat::CanChange (pbCanChange)
 *
 *	@func
 *		Set *<p pbCanChange> = tomTRUE iff this format object can be changed
 *
 *	@rdesc
 *		HRESULT = (can change format) ? NOERROR : S_FALSE
 *
 *	@devnote
 *		This method is shared by ITextFont and ITextPara.  If pRange is NULL,
 *		the object is a clone, i.e., unattached to a CTxtRange
 */
HRESULT CTxtFormat::CanChange (
	long *pbCanChange,		//@parm Out parm to receive boolean value
	BOOL fPara)				//@parm If TRUE, formatting is paragraphs
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFormat::CanChange");

	LONG fCanChange = tomTrue;
	
	if(_prg)
	{
		HRESULT hr = _prg->CanEdit(pbCanChange);
		if(hr != NOERROR)						// S_FALSE or CO_E_RELEASED
			return hr;

		if(!_prg->GetPed()->IsRich() && fPara)
			fCanChange = tomFalse;
	}
	if(pbCanChange)
		*pbCanChange = fCanChange;

	return fCanChange ? NOERROR : S_FALSE;
}

/*
 *	CTxtFormat::GetParameter (pParm, fDefined, Type, pValue)
 *
 *	@mfunc
 *		Set *pValue = *pLong unless NINCHed. Perform conversions specified by
 *		Type.  If Type > 0, it is treated as length of an unsigned integer,
 *		i.e., 1, 2, or 4 bytes.  If it is negative, the output is a float
 *		and the input has a length given by |Type|, so -2 converts a WORD
 *		into a float, unless dwMask = CFM_SPACING, in which case it converts
 *		a short into a float.  -4 converts a long into a float.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 */
HRESULT	CTxtFormat::GetParameter (
	long *	pParm,		//@parm Ptr to _CF or _PF member to get
	DWORD	dwMask,		//@parm Nonzero iff defined
	long	Type,		//@parm # bytes of integer parameter or 0 for float
	long *	pValue)		//@parm Out parm to receive value
{
	if(!pValue)
		return E_INVALIDARG;

	Assert(pParm && sizeof(long) == 4 && sizeof(float) == 4);

	HRESULT hr = NOERROR;

	if(IsZombie())							// Check if attached to zombied
	{										//  range
		dwMask = 0;							// Nothing defined
		hr = CO_E_RELEASED;					// Setup return for following if
	}

	if(!dwMask)								// Parameter isn't defined
	{
		if(Type < 0)
			*(float *)pValue = tomFloatUndefined;
		else
			*pValue = tomUndefined;
		return hr;
	}

	long Value = *pParm;					// Default long value (Type = 4)
	switch(Type)							// Handle other cases
	{
	case 1:									// BYTE quantity
		Value &= 0xff;
		break;

	case 2:									// WORD quantity
		Value &= 0xffff;
		if(dwMask & (CFM_STYLE | PFM_STYLE))
			Value = *(SHORT *)pParm;		// Styles need sign extension
		break;

	case -2:								// float from WORD or SHORT
		Value &= 0xffff;					// Kill stuff above 16-bit data
		if(dwMask & (CFM_SPACING | CFM_SIZE	// Need sign extension for these
						| CFM_OFFSET))		//  (in high word, so don't
		{									//   conflict with PFM_xxx)
			Value = *(SHORT *)pParm;		// Fall thru to case -4
		}

	case -4:								// float value
		*(float *)&Value = TWIPS_TO_FPPTS(Value);
	}

	*pValue = Value;						// In all cases, return in a long
	return NOERROR;
}

/*
 *	CTxtFormat::SetParameter (pParm, fDefined, Type, Value)
 *
 *	@mfunc
 *		Set *pParm = Value unless NINCHed. Perform conversions specified by
 *		Type.  If Type > 0, it is treated as length of an unsigned integer,
 *		i.e., 1, 2, or 4 bytes.  If it is negative, the output is a float
 *		and the input has a length given by |Type|, so -2 converts a WORD
 *		into a float, unless dwMask = CFM_SPACING, in which case it converts
 *		a short into a float.  -4 converts a long into a float.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 */
HRESULT	CTxtFormat::SetParameter (
	long *	pParm,		//@parm Ptr to _CF or _PF member to set
	long	Type,		//@parm # bytes of integer parameter or < 0 for float
	long 	Value)		//@parm New value for *pParm
{
	Assert(pParm);

	if(IsZombie())									// Check if attached to
		return CO_E_RELEASED;						//  zombied range

	if(Type > 0 && Value == tomUndefined)			// Undefined parameter
		return NOERROR;								// NINCH

	if(Type < 0)									// Value is a float
	{
		if(*(float *)&Value == tomFloatUndefined)	// Undefined parameter
			return NOERROR;							// NINCH
		Type = -Type;
		Value = FPPTS_TO_TWIPS(*(float *)&Value);	// Convert to a long
	}

	if(Type == 1)
	{
		if((DWORD)Value > 255)
			return E_INVALIDARG;
		*(BYTE *)pParm = (BYTE)Value;
	}
	else if(Type == 2)
	{
		if(Value < -32768 || Value > 65535)
			return E_INVALIDARG;					// Doesn't fit in 16 bits
		*(WORD *)pParm = (WORD)Value;
	}
	else
		*pParm = Value;

	return NOERROR;
}

/*
 *	CTxtFormat::IsTrue (f, pB)
 *
 *	@mfunc
 *		Return *<p pB> = tomTrue iff <p f> is nonzero and pB isn't NULL
 *
 *	@rdesc
 *		HRESULT = (f) ? NOERROR : S_FALSE
 */
HRESULT CTxtFormat::IsTrue(BOOL f, long *pB)
{
	if(pB)
		*pB = tomFalse;

	if(IsZombie())									// Check if attached to
		return CO_E_RELEASED;						//  zombied range

	if(f)
	{
		if(pB)
			*pB = tomTrue;
		return NOERROR;
	}

	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\tomdoc.cpp ===
/*
 *	@doc TOM
 *
 *	@module tomdoc.cpp - Implement the ITextDocument interface on CTxtEdit |
 *	
 *		This module contains the implementation of the TOM ITextDocument
 *		class as well as the global TOM type-info routines
 *
 *	History: <nl>
 *		sep-95	MurrayS: stubs and auto-doc created <nl>
 *		nov-95	MurrayS: upgrade to top-level TOM interface
 *		dec-95	MurrayS: implemented file I/O methods
 *
 *	@future
 *		1. Implement Begin/EndEditCollection
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_range.h"
#include "_edit.h"
#include "_disp.h"
#include "_rtfconv.h"
#include "_select.h"
#include "_font.h"

ASSERTDATA

// TOM Type Info HRESULT and pointers
HRESULT		g_hrGetTypeInfo = NOERROR;
ITypeInfo *	g_pTypeInfoDoc;
ITypeInfo *	g_pTypeInfoSel;
ITypeInfo *	g_pTypeInfoFont;
ITypeInfo *	g_pTypeInfoPara;
ITypeLib  *	g_pTypeLib;

BYTE szUTF8BOM[] = {0xEF, 0xBB, 0xBF};		// UTF-8 for 0xFEFF

//------------------------ Global TOM Type Info Methods -----------------------------

/*
 *	GetTypeInfoPtrs()
 *
 *	@func
 *		Ensure that global TOM ITypeInfo ptrs are valid (else g_pTypeInfoDoc
 *		is NULL).  Return NOERROR immediately if g_pTypeInfoDoc is not NULL,
 *		i.e., type info ptrs are already valid.
 *
 *	@rdesc
 *		HRESULT = (success) ? NOERROR
 *				: (HRESULT from LoadTypeLib or GetTypeInfoOfGuid)
 *
 *	@comm
 *		This routine should be called by any routine that uses the global
 *		type info ptrs, e.g., IDispatch::GetTypeInfo(), GetIDsOfNames, and
 *		Invoke.  That way if noone is using the type library info, it doesn't
 *		have to be loaded.
 *
 */
HRESULT GetTypeInfoPtrs()
{
	HRESULT	hr;
	CLock	lock;							// Only one thread at a time...

	if(g_pTypeInfoDoc)						// Type info ptrs already valid
		return NOERROR;

	if(g_hrGetTypeInfo != NOERROR)			// Tried to get before and failed
		return g_hrGetTypeInfo;

	if (LoadRegTypeLib(LIBID_tom, 1, 0, LANG_NEUTRAL, &g_pTypeLib) != NOERROR)
	{
		hr = LoadTypeLib(OLESTR("RICHED20.DLL"), &g_pTypeLib);
		if(hr != NOERROR)
			goto err;
	}

	// Get ITypeInfo pointers with g_pTypeInfoDoc last
	hr = g_pTypeLib->GetTypeInfoOfGuid(IID_ITextSelection, &g_pTypeInfoSel);
	if(hr == NOERROR)
	{
	    g_pTypeLib->GetTypeInfoOfGuid(IID_ITextFont,	 &g_pTypeInfoFont);
		g_pTypeLib->GetTypeInfoOfGuid(IID_ITextPara,	 &g_pTypeInfoPara);
		g_pTypeLib->GetTypeInfoOfGuid(IID_ITextDocument, &g_pTypeInfoDoc);

		if(g_pTypeInfoFont && g_pTypeInfoPara && g_pTypeInfoDoc)
			return NOERROR;					// Got 'em all
	}
	hr = E_FAIL;

err:
	Assert("Error getting type info pointers");

	g_pTypeInfoDoc	= NULL;					// Type info ptrs not valid
	g_hrGetTypeInfo	= hr;					// Save HRESULT in case called
	return hr;								//  again
}

/*
 *	ReleaseTypeInfoPtrs()
 *
 *	@func
 *		Release TOM type info ptrs in case they have been defined.
 *		Called when RichEdit dll is being unloaded.
 */
void ReleaseTypeInfoPtrs()
{
	if(g_pTypeInfoDoc)
	{
		g_pTypeInfoDoc->Release();
		g_pTypeInfoSel->Release();
		g_pTypeInfoFont->Release();
		g_pTypeInfoPara->Release();
	}
	if(g_pTypeLib)
		g_pTypeLib->Release();
}

/*
 *	GetTypeInfo(iTypeInfo, &pTypeInfo, ppTypeInfo)
 *
 *	@func
 *		IDispatch helper function to check parameter validity and set
 *		*ppTypeInfo = pTypeInfo if OK
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT GetTypeInfo(
	UINT		iTypeInfo,		//@parm Index of type info to return
	ITypeInfo *&pTypeInfo,		//@parm Address of desired type info ptr
	ITypeInfo **ppTypeInfo)		//@parm Out parm to receive type info
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetTypeInfo");

	if(!ppTypeInfo)
		return E_INVALIDARG;

	*ppTypeInfo = NULL;

	if(iTypeInfo > 1)
		return DISP_E_BADINDEX;

	HRESULT hr = GetTypeInfoPtrs();				// Ensure TypeInfo ptrs are OK
	if(hr == NOERROR)
	{
		*ppTypeInfo = pTypeInfo;				// Have to use reference in
		pTypeInfo->AddRef();					//  case defined in this call
	}
	return hr;
}

/*
 *	MyRead(hfile, pbBuffer, cb, pcb)
 *
 *	@func
 *		Callback function for converting a file into an editstream for
 *		input.
 *
 *	@rdesc
 *		(DWORD)HRESULT
 */
DWORD CALLBACK MyRead(DWORD_PTR hfile, BYTE *pbBuffer, long cb, long *pcb)
{
	if(!hfile)								// No handle defined
		return (DWORD)E_FAIL;

	Assert(pcb);
	*pcb = 0;

	if(!ReadFile((HANDLE)hfile, (void *)pbBuffer, (DWORD)cb, (DWORD *)pcb, NULL))
		return HRESULT_FROM_WIN32(GetLastError());

	return (DWORD)NOERROR;
}

/*
 *	MyWrite(hfile, pbBuffer, cb, pcb)
 *
 *	@func
 *		Callback function for converting a file into an editstream for
 *		output.
 *
 *	@rdesc
 *		(DWORD)HRESULT
 */
DWORD CALLBACK MyWrite(DWORD_PTR hfile, BYTE *pbBuffer, long cb, long *pcb)
{
	if(!hfile)								// No handle defined
		return (DWORD)E_FAIL;

	Assert(pcb);
	*pcb = 0;

	if(!WriteFile((HANDLE)hfile, (void *)pbBuffer, (DWORD)cb, (DWORD *)pcb, NULL))
		return HRESULT_FROM_WIN32(GetLastError());

	return (DWORD)(*pcb ? NOERROR : E_FAIL);
}


//-----------------CTxtEdit IUnknown methods: see textserv.cpp -----------------------------


//------------------------ CTxtEdit IDispatch methods -------------------------

/*
 *	CTxtEdit::GetTypeInfoCount(pcTypeInfo)
 *
 *	@mfunc
 *		Get the number of TYPEINFO elements (1)
 *
 *	@rdesc
 *		HRESULT = (pcTypeInfo) ? NOERROR : E_INVALIDARG;
 */
STDMETHODIMP CTxtEdit::GetTypeInfoCount(
	UINT *pcTypeInfo)	//@parm Out parm to receive count
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetTypeInfoCount");

	if(!pcTypeInfo)
		return E_INVALIDARG;

	*pcTypeInfo = 1;
	return NOERROR;
}

/*
 *	CTxtEdit::GetTypeInfo(iTypeInfo, lcid, ppTypeInfo)
 *
 *	@mfunc
 *		Return ptr to type information object for ITextDocument interface
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CTxtEdit::GetTypeInfo(
	UINT		iTypeInfo,		//@parm Index of type info to return
	LCID		lcid,			//@parm Local ID of type info
	ITypeInfo **ppTypeInfo)		//@parm Out parm to receive type info
 {
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetTypeInfo");

	return ::GetTypeInfo(iTypeInfo, g_pTypeInfoDoc, ppTypeInfo);
}

/*
 *	CTxtEdit::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid)
 *
 *	@mfunc
 *		Get DISPIDs for all TOM methods and properties
 *
 *	@rdesc
 *		HRESULT
 *
 *	@devnote
 *		This routine tries to find DISPIDs using the type information for
 *		ITextDocument. If that fails, it asks the selection to find the
 *		DISPIDs.
 */
STDMETHODIMP CTxtEdit::GetIDsOfNames(
	REFIID		riid,			//@parm Interface ID to interpret names for
	OLECHAR **	rgszNames,		//@parm Array of names to be mapped
	UINT		cNames,			//@parm Count of names to be mapped
	LCID		lcid,			//@parm Local ID to use for interpretation
	DISPID *	rgdispid)		//@parm Out parm to receive name mappings
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetIDsOfNames");

	HRESULT hr = GetTypeInfoPtrs();				// Ensure TypeInfo ptrs are OK
	if(hr != NOERROR)
		return hr;
		
	hr = g_pTypeInfoDoc->GetIDsOfNames(rgszNames, cNames, rgdispid);

	if(hr == NOERROR)							// Succeeded in finding an
		return NOERROR;							//  ITextDocument method

	IDispatch *pSel = (IDispatch *)GetSel();	// See if the selection knows
												//  the desired method
	if(!pSel)
		return hr;								// No selection

	return pSel->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
}

/*
 *	CTxtEdit::Invoke(dispidMember, riid, lcid, wFlags, pdispparams,
 *					  pvarResult, pexcepinfo, puArgError)
 *	@mfunc
 *		Invoke members for all TOM DISPIDs, i.e., for ITextDocument,
 *		ITextSelection, ITextRange, ITextFont, and ITextPara.  TOM DISPIDs
 *		for all but ITextDocument are delegated to the selection object.
 *
 *	@rdesc
 *		HRESULT
 *
 *	@devnote
 *		This routine trys to invoke ITextDocument members if the DISPID is
 *		in the range 0 thru 0xff.  It trys to invoke ITextSelection members if
 *		the DISPID is in the range 0x100 thru 0x4ff (this includes
 *		ITextSelection, ITextRange, ITextFont, and ITextPara).  It returns
 *		E_MEMBERNOTFOUND for DISPIDs outside these ranges.
 */
STDMETHODIMP CTxtEdit::Invoke(
	DISPID		dispidMember,	//@parm Identifies member function
	REFIID		riid,			//@parm Pointer to interface ID
	LCID		lcid,			//@parm Locale ID for interpretation
	USHORT		wFlags,			//@parm Flags describing context of call
	DISPPARAMS *pdispparams,	//@parm Ptr to method arguments
	VARIANT *	pvarResult,		//@parm Out parm for result (if not NULL)
	EXCEPINFO * pexcepinfo,		//@parm Out parm for exception info
	UINT *		puArgError)		//@parm Out parm for error
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::Invoke");

	HRESULT hr = GetTypeInfoPtrs();				// Ensure TypeInfo ptrs are OK
	if(hr != NOERROR)
		return hr;
		
	if((DWORD)dispidMember < 0x100)				// ITextDocment method
		return g_pTypeInfoDoc->Invoke((IDispatch *)this, dispidMember, wFlags,
							 pdispparams, pvarResult, pexcepinfo, puArgError);

	IDispatch *pSel = (IDispatch *)GetSel();	// See if the selection has
												//  the desired method
	if(pSel && (DWORD)dispidMember <= 0x4ff)
		return pSel->Invoke(dispidMember, riid, lcid, wFlags,
							 pdispparams, pvarResult, pexcepinfo, puArgError);

	return DISP_E_MEMBERNOTFOUND;
}


//--------------------- ITextDocument Methods/Properties -----------------------

/*
 *	ITextDocument::BeginEditCollection()
 *
 *	@mfunc
 *		Method that turns on undo grouping
 *
 *	@rdesc
 *		HRESULT = (undo enabled) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtEdit::BeginEditCollection ()
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::BeginEditCollection");

	return E_NOTIMPL;
}

/*
 *	ITextDocument::EndEditCollection() 
 *
 *	@mfunc
 *		Method that turns off undo grouping
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
STDMETHODIMP CTxtEdit::EndEditCollection () 
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::EndEditCollection");

	return E_NOTIMPL;
}

/*
 *	ITextDocument::Freeze(long *pValue) 
 *
 *	@mfunc
 *		Method to increment the freeze count. If this count is nonzero,
 *		screen updating is disabled.  This allows a sequence of editing
 *		operations to be performed without the performance loss and
 *		flicker of screen updating.  See Unfreeze() to decrement the
 *		freeze count.
 *
 *	@rdesc
 *		HRESULT = (screen updating disabled) ? NOERROR : S_FALSE
 *
 *	@todo
 *		What about APIs like EM_LINEFROMCHAR that don't yet know how to
 *		react to a frozen display?
 */
STDMETHODIMP CTxtEdit::Freeze (
	long *pCount)		//@parm Out parm to receive updated freeze count
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::Freeze");

	if(_pdp)
	{
		_pdp->Freeze();
		if(_pdp->IsFrozen())
			_cFreeze++;
		else
			_cFreeze = 0;
	}

	if(pCount)
		*pCount = _cFreeze;

	return _cFreeze ? NOERROR : S_FALSE;
}

/*
 *	ITextDocument::GetDefaultTabStop (pValue) 
 *
 *	@mfunc
 *		Property get method that gets the default tab stop to be
 *		used whenever the explicit tabs don't extend far enough.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtEdit::GetDefaultTabStop (
	float *	pValue)		//@parm Out parm to receive default tab stop
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetDefaultTabStop");

	if(!pValue)
		return E_INVALIDARG;
                                                                        
	const LONG lTab = GetDefaultTab();

	*pValue = TWIPS_TO_FPPTS(lTab);

	return NOERROR;
}

/*
 *	CTxtEdit::GetName (pName)
 *
 *	@mfunc
 *		Retrieve ITextDocument filename
 *
 *	@rdesc
 *		HRESULT = (!<p pName>) ? E_INVALIDARG :
 *				  (no name) ? S_FALSE :
 *				  (if not enough RAM) ? E_OUTOFMEMORY : NOERROR
 */
STDMETHODIMP CTxtEdit::GetName (
	BSTR * pName)		//@parm Out parm to receive filename
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetName");

	if(!pName)
		return E_INVALIDARG;

	*pName = NULL;
	if(!_pDocInfo || !_pDocInfo->pName)
		return S_FALSE;

	*pName = SysAllocString(_pDocInfo->pName);
	
	return *pName ? NOERROR : E_OUTOFMEMORY;
}

/*
 *	ITextDocument::GetSaved (pValue) 
 *
 *	@mfunc
 *		Property get method that gets whether this instance has been
 *		saved, i.e., no changes since last save
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 *
 *	@comm
 *		Next time to aid C/C++ clients, we ought to make pValue optional
 *		and return S_FALSE if doc isn't saved, i.e., like our other
 *		boolean properties (see, e.g., ITextRange::IsEqual())
 */
STDMETHODIMP CTxtEdit::GetSaved (
	long *	pValue)		//@parm Out parm to receive Saved property
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetSaved");

	if(!pValue)
		return E_INVALIDARG;

	*pValue = _fSaved ? tomTrue : tomFalse;
	return NOERROR;
}

/*
 *	ITextDocument::GetSelection (ITextSelection **ppSel) 
 *
 *	@mfunc
 *		Property get method that gets the active selection. 
 *
 *	@rdesc
 *		HRESULT = (!ppSel) ? E_INVALIDARG :
 *				  (if active selection exists) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtEdit::GetSelection (
	ITextSelection **ppSel)	//@parm Out parm to receive selection pointer
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetSelection");

	if(!ppSel)
		return E_INVALIDARG;

	CTxtSelection *psel = GetSel();

	*ppSel = (ITextSelection *)psel;

	if( psel )
	{
		(*ppSel)->AddRef();
		return NOERROR;
	}

	return S_FALSE;
}

/*
 *	CTxtEdit::GetStoryCount(pCount)
 *
 *	@mfunc
 *		Get count of stories in this document.
 *
 *	@rdesc
 *		HRESULT = (!<p pCount>) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtEdit::GetStoryCount (
	LONG *pCount)		//@parm Out parm to receive count of stories
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetStoryCount");

	if(!pCount)
		return E_INVALIDARG;

	*pCount = 1;
	return NOERROR;
}

/*
 *	ITextDocument::GetStoryRanges(ITextStoryRanges **ppStories) 
 *
 *	@mfunc
 *		Property get method that gets the story collection object
 *		used to enumerate the stories in a document.  Only invoke this
 *		method if GetStoryCount() returns a value greater than one.
 *
 *	@rdesc
 *		HRESULT = (if Stories collection exists) ? NOERROR : E_NOTIMPL
 */
STDMETHODIMP CTxtEdit::GetStoryRanges (
	ITextStoryRanges **ppStories) 	//@parm Out parm to receive stories ptr
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetStoryRanges");

	return E_NOTIMPL;
}

/*
 *	ITextDocument::New() 
 *
 *	@mfunc
 *		Method that closes the current document and opens a document
 *		with a default name.  If changes have been made in the current
 *		document since the last save and document file information exists,
 *		the current document is saved.
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
STDMETHODIMP CTxtEdit::New ()
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::New");

	CloseFile(TRUE);	 					// Save and close file
	return SetText(NULL, 0, 1200);
}

/*
 *	ITextDocument::Open(pVar, Flags, CodePage)
 *
 *	@mfunc
 *		Method that opens the document specified by pVar.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : E_OUTOFMEMORY
 *
 *	@future
 *		Handle IStream
 */
STDMETHODIMP CTxtEdit::Open (
	VARIANT *	pVar,		//@parm Filename or IStream
	long		Flags,		//@parm Read/write, create, and share flags
	long		CodePage)	//@parm Code page to use
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::Open");

	LONG		cb;								// Byte count for RTF check
	EDITSTREAM	es		= {0, NOERROR, MyRead};
	BOOL		fReplaceSel = Flags & tomPasteFile;
	HCURSOR		hcur;
	LRESULT		lres;
	TCHAR		szType[10];

	if(!pVar || CodePage && CodePage != 1200 && !IsValidCodePage(CodePage))
		return E_INVALIDARG;					// IsValidCodePage(0) fails
												//  even tho CP_ACP = 0 (!)
	if((Flags & 0xf) >= tomHTML)				// RichEdit only handles auto,
		return E_NOTIMPL;						//  plain text, & RTF formats

	if(!fReplaceSel)							// If not replacing selection,
		New();									//  save current file and
												//  delete current text
	CDocInfo * pDocInfo = GetDocInfo();
	if(!pDocInfo)
		return E_OUTOFMEMORY;

	pDocInfo->wFlags = (WORD)(Flags & ~0xf0);	// Save flags (w/o creation)

	// Process access, share, and create flags
	DWORD dwAccess = (Flags & tomReadOnly)
		? GENERIC_READ : (GENERIC_READ | GENERIC_WRITE);

	DWORD dwShare = FILE_SHARE_READ | FILE_SHARE_WRITE;
	if(Flags & tomShareDenyRead)
		dwShare &= ~FILE_SHARE_READ;

	if(Flags & tomShareDenyWrite)
		dwShare &= ~FILE_SHARE_WRITE;

	DWORD dwCreate = (Flags >> 4) & 0xf;
	if(!dwCreate)								// Flags nibble 2 must contain
		dwCreate = OPEN_ALWAYS;					//  CreateFile's dwCreate

	if(pVar->vt == VT_BSTR && SysStringLen(pVar->bstrVal))
	{
		es.dwCookie = (DWORD_PTR)CreateFile(pVar->bstrVal, dwAccess, dwShare,
							 NULL, dwCreate, FILE_ATTRIBUTE_NORMAL, NULL);
		if((HANDLE)es.dwCookie == INVALID_HANDLE_VALUE)
			return HRESULT_FROM_WIN32(GetLastError());

		if(!fReplaceSel)						// If not replacing selection,
		{										//  allocate new pName
			pDocInfo->pName = SysAllocString(pVar->bstrVal);
			if (!pDocInfo->pName)
				return E_OUTOFMEMORY;
			pDocInfo->hFile = (HANDLE)es.dwCookie;
			pDocInfo->wFlags |= tomTruncateExisting;	// Setup Saves
		}
	}
	else
	{
		// FUTURE: check for IStream; if not, then fail
		return E_INVALIDARG;
	}

	Flags &= 0xf;								// Isolate conversion flags

	// Get first few bytes of file to check for RTF and Unicode BOM
	(*es.pfnCallback)(es.dwCookie, (LPBYTE)szType, 10, &cb);

	Flags = (!Flags || Flags == tomRTF) && IsRTF((char *)szType)
		  ? tomRTF : tomText;

	LONG j = 0;									// Default rewind to 0
	if (Flags == tomRTF)						// RTF
		Flags = SF_RTF;							// Setup EM_STREAMIN for RTF
	else
	{											// If it starts with
		Flags = SF_TEXT;						// Setup EM_STREAMIN for text
		if(cb > 1 && *(WORD *)szType == BOM)	//  Unicode byte-order mark
		{										//  (BOM) file is Unicode, so
			Flags = SF_TEXT | SF_UNICODE;		//  use Unicode code page and
			j = 2;								//  bypass the BOM. FUTURE:
		}										//  handle big endian too
		else if(cb > 2 && W32->IsUTF8BOM((BYTE *)szType))
		{
			Flags = SF_TEXT | SF_USECODEPAGE | (CP_UTF8 << 16);
			j = 3;
		}
		else if(CodePage == 1200)
			Flags = SF_TEXT | SF_UNICODE;

		else if(CodePage)
			Flags = SF_TEXT | SF_USECODEPAGE | (CodePage << 16);
	}

	SetFilePointer((HANDLE)es.dwCookie, j, NULL, FILE_BEGIN);	// Rewind

	if(fReplaceSel)
		Flags |= SFF_SELECTION;

	Flags |= SFF_KEEPDOCINFO;

	hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
	TxSendMessage(EM_STREAMIN, Flags, (LPARAM)&es, &lres);
	SetCursor(hcur);

	if(dwShare == (FILE_SHARE_READ | FILE_SHARE_WRITE) || fReplaceSel)
	{											// Full sharing or replaced
		CloseHandle((HANDLE)es.dwCookie);		//  selection, so close file
		if(!fReplaceSel)						// If replacing selection,
			pDocInfo->hFile = NULL;				//  leave _pDocInfo->hFile
	}
	_fSaved = fReplaceSel ? FALSE : TRUE;		// No changes yet unless
	return (HRESULT)es.dwError;
}

/*
 *	ITextDocument::Range(long cpFirst, long cpLim, ITextRange **ppRange)  
 *
 *	@mfunc
 *		Method that gets a text range on the active story of the document
 *
 *	@rdesc
 *		HRESULT = (!ppRange) ? E_INVALIDARG : 
 *				  (if success) ? NOERROR : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtEdit::Range (
	long cpFirst, 				//@parm	Non active end of new range
	long cpLim, 				//@parm Active end of new range
	ITextRange ** ppRange)		//@parm Out parm to receive range
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::Range");

	if(!ppRange)
		return E_INVALIDARG;

	*ppRange = new CTxtRange(this, cpFirst, cpFirst - cpLim);
	
	if( *ppRange )
	{
		(*ppRange)->AddRef();		// CTxtRange() doesn't AddRef() because
		return NOERROR;				//  it's used internally for things
	}								//  besides TOM

	return E_OUTOFMEMORY;
}

/*
 *	ITextDocument::RangeFromPoint(long x, long y, ITextRange **ppRange) 
 *
 *	@mfunc
 *		Method that gets the degenerate range corresponding (at or nearest)
 *		to the point with the screen coordinates x and y.
 *
 *	@rdesc
 *		HRESULT = (!ppRange) ? E_INVALIDARG :
 *				  (if out of RAM) ? E_OUTOFMEMORY :
 *				  (if range exists) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtEdit::RangeFromPoint (
	long	x,				//@parm Horizontal coord of point to use
	long	y,				//@parm	Vertical   coord of point to use
	ITextRange **ppRange)	//@parm Out parm to receive range
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::RangeFromPoint");

	if(!ppRange)
		return E_INVALIDARG;

	*ppRange = (ITextRange *) new CTxtRange(this, 0, 0);

	if(!*ppRange)
		return E_OUTOFMEMORY;

	(*ppRange)->AddRef();				// CTxtRange() doesn't AddRef()
	return (*ppRange)->SetPoint(x, y, 0, 0);
}

/*
 *	ITextDocument::Redo(long Count, long *pCount) 
 *
 *	@mfunc
 *		Method to perform the redo operation Count times
 *
 *	@rdesc
 *		HRESULT = (if Count redos performed) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtEdit::Redo (
	long	Count,		//@parm Number of redo operations to perform
	long *	pCount)		//@parm Number of redo operations performed
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::Redo");
	CCallMgr	callmgr(this);

	LONG i = 0;


	if (_predo && _fUseUndo)
	{
		// Freeze the display during the execution of the anti-events
		CFreezeDisplay fd(_pdp);

		for ( ; i < Count; i++)
			PopAndExecuteAntiEvent(_predo, 0);
	}

	if(pCount)
		*pCount = i;

	return i == Count ? NOERROR : S_FALSE;
}

/*
 *	ITextDocument::Save(pVar, Flags, CodePage) 
 *
 *	@mfunc
 *		Method that saves this ITextDocument to the target pVar,
 *		which is a VARIANT that can be a filename, an IStream, or NULL.  If
 *		NULL, the filename given by this document's name is used.  It that,
 *		in turn, is NULL, the method fails.  If pVar specifies a filename,
 *		that name should replace the current Name property.
 *
 *	@rdesc
 *		HRESULT = (!pVar) ? E_INVALIDARG : 
 *				  (if success) ? NOERROR : E_FAIL
 *
 *	@devnote
 *		This routine can be called with NULL arguments
 */
STDMETHODIMP CTxtEdit::Save (
	VARIANT *	pVar,		//@parm Save target (filename or IStream)
	long		Flags,		//@parm Read/write, create, and share flags
	long		CodePage)	//@parm Code page to use
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::Save");

	LONG		cb;			// Byte count for writing Unicode BOM
	EDITSTREAM	es		= {0, NOERROR, MyWrite};
	BOOL		fChange	= FALSE;				// No doc info change yet
	HCURSOR		hcur;
	CDocInfo *	pDocInfo = GetDocInfo();
	WORD		wBOM = BOM;

	if(CodePage && CodePage != 1200 && !IsValidCodePage(CodePage) ||
	   (DWORD)Flags > 0x1fff || Flags & tomReadOnly)
	{
		return E_INVALIDARG;
	}
	if((Flags & 0xf) >= tomHTML)				// RichEdit only handles auto,
		return E_NOTIMPL;						//  plain text, & RTF formats

	if(!pDocInfo)								// Doc info doesn't exist
		return E_OUTOFMEMORY;

	if (pVar && pVar->vt == VT_BSTR &&			// Filename string
		pVar->bstrVal &&
		SysStringLen(pVar->bstrVal) &&			// NonNULL filename specified
		(!pDocInfo->pName ||
		 OLEstrcmp(pVar->bstrVal, pDocInfo->pName)))
	{											// Filename differs
		fChange = TRUE;							// Force write to new file
		CloseFile(FALSE);						// Close current file; no save
		pDocInfo->pName = SysAllocString(pVar->bstrVal);
		if(!pDocInfo->pName)
			return E_OUTOFMEMORY;
		pDocInfo->wFlags &= ~0xf0;				// Kill previous create mode
	}

	DWORD flags = pDocInfo->wFlags;
	if(!(Flags & 0xF))							// If convert flags are 0,									
		Flags |= flags & 0xF;					//  use values in doc info
	if(!(Flags & 0xF0))							// If create flags are 0,									
		Flags |= flags & 0xF0;					//  use values in doc info
	if(!(Flags & 0xF00))						// If share flags are 0,									
		Flags |= flags & 0xF00;					//  use values in doc info
	if(!CodePage)								// If code page is 0,
		CodePage = pDocInfo->wCpg;				//  use code page in doc info

	if((DWORD)Flags != flags ||					// If flags or code page	
	   (WORD)CodePage != pDocInfo->wCpg)		//  changed, force write
	{
		fChange = TRUE;
	}
	pDocInfo->wFlags = (WORD)Flags;				// Save flags

	// Yikes, nowhere to save.  bail-out now
	if(!_pDocInfo->pName)
		return E_FAIL;

	if(_fSaved && !fChange)						// No changes, so assume
		return NOERROR;							//  saved file is up to date

	DWORD dwShare = FILE_SHARE_READ | FILE_SHARE_WRITE;
	if(Flags & tomShareDenyRead)
		dwShare &= ~FILE_SHARE_READ;

	if(Flags & tomShareDenyWrite)
		dwShare &= ~FILE_SHARE_WRITE;

	DWORD dwCreate = (Flags >> 4) & 0xF;
	if(!dwCreate)
		dwCreate = CREATE_NEW;

	if(pDocInfo->hFile)
	{
		CloseHandle(pDocInfo->hFile);			// Close current file handle
		pDocInfo->hFile = NULL;
	}

	es.dwCookie = (DWORD_PTR)CreateFile(pDocInfo->pName, GENERIC_READ | GENERIC_WRITE, dwShare, NULL,
							dwCreate, FILE_ATTRIBUTE_NORMAL, NULL);
	if((HANDLE)es.dwCookie == INVALID_HANDLE_VALUE)
		return HRESULT_FROM_WIN32(GetLastError());

	pDocInfo->hFile = (HANDLE)es.dwCookie;

	Flags &= 0xF;								// Isolate conversion flags
	if(Flags == tomRTF)							// RTF
		Flags = SF_RTF;							// Setup EM_STREAMOUT for RTF
	else
	{											
		Flags = SF_TEXT;						// Setup EM_STREAMOUT for text
		if(CodePage == 1200 || CodePage == CP_UTF8)// If Unicode, start file with
		{										//  Unicode byte order mark
			LONG  j;
			BYTE *pb;							// FUTURE: generalize to handle
												//  big endian
			if(CodePage == CP_UTF8)
			{
				j = 3;
				pb = szUTF8BOM;
			}
			else
			{
				Flags = SF_TEXT | SF_UNICODE;
				j = 2;
				pb = (BYTE *)&wBOM;
			}
			(*es.pfnCallback)(es.dwCookie, pb, j, &cb);
		}
	}
	if(CodePage && CodePage != 1200)
		Flags |= SF_USECODEPAGE | (CodePage << 16);

	hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
	TxSendMessage(EM_STREAMOUT, Flags, (LPARAM)&es, NULL);
	SetCursor(hcur);

	if(dwShare == (FILE_SHARE_READ | FILE_SHARE_WRITE))
	{											// Full sharing, so close
		CloseHandle(pDocInfo->hFile);			//  current file handle
		pDocInfo->hFile = NULL;
	}
	_fSaved = TRUE;								// File is saved
	return (HRESULT)es.dwError;
}

/*
 *	ITextDocument::SetDefaultTabStop (Value) 
 *
 *	@mfunc
 *		Property set method that sets the default tab stop to be
 *		used whenever the explicit tabs don't extend far enough.
 *
 *	@rdesc
 *		HRESULT = (Value < 0) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtEdit::SetDefaultTabStop (
	float Value)		//@parm Out parm to receive default tab stop
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::SetDefaultTabStop");

	if(Value <= 0)
		return E_INVALIDARG;

	CDocInfo *pDocInfo = GetDocInfo();

	if(!pDocInfo)								// Doc info doesn't exist
		return E_OUTOFMEMORY;

	pDocInfo->dwDefaultTabStop = FPPTS_TO_TWIPS(Value);
	return NOERROR;
}

/*
 *	ITextDocument::SetSaved (Value) 
 *
 *	@mfunc
 *		Property set method that sets whether this instance has been
 *		saved, i.e., no changes since last save
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
STDMETHODIMP CTxtEdit::SetSaved (
	long	Value)		//@parm New value of Saved property
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::SetSaved");

	_fSaved = Value ? TRUE : FALSE;
	return NOERROR;
}

/*
 *	ITextDocument::Undo(Count, *pCount) 
 *
 *	@mfunc
 *		Method to perform the undo operation Count times or to control
 *		the nature of undo processing. Count = 0 stops undo processing
 *		and discards any saved undo states.  Count = -1 turns on undo
 *		processing with the default undo limit.  Count = tomSuspend
 *		suspends undo processing, but doesn't discard saved undo states,
 *		and Count = tomResume resumes undo processing with the undo states
 *		active when Count = tomSuspend was given.
 *
 *	@rdesc
 *		HRESULT = (if Count undos performed) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtEdit::Undo (
	long	Count,		//@parm Count of undo operations to perform
						//		0 stops undo processing
						//		-1 turns restores it
	long *	pCount)		//@parm Number of undo operations performed
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::Undo");
	CCallMgr callmgr(this);

	LONG i = 0;

	if(_pundo && _fUseUndo)
	{
		// Freeze display during execution of anti-events
		CFreezeDisplay fd(_pdp);

		for ( ; i < Count; i++)					// Note: for Count <= 0,
			PopAndExecuteAntiEvent(_pundo, 0);	//  loop does nothing
	}

	if(pCount)
		*pCount = i;

	if(Count <= 0)							
		i = HandleSetUndoLimit(Count);

	return i == Count ? NOERROR : S_FALSE;
}

/*
 *	ITextDocument::Unfreeze(pCount) 
 *
 *	@mfunc
 *		Method to decrement freeze count.  If this count goes to zero,
 *		screen updating is enabled.  This method cannot decrement the
 *		count below zero.
 *
 *	@rdesc
 *		HRESULT = (screen updating enabled) ? NOERROR : S_FALSE
 *
 *	@devnote
 *		The display maintains its own private reference count which may
 *		temporarily exceed the reference count of this method.  So even
 *		if this method indicates that the display is unfrozen, it may be
 *		for a while longer.
 */
STDMETHODIMP CTxtEdit::Unfreeze (
	long *pCount)		//@parm Out parm to receive updated freeze count
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::Unfreeze");

	if(_cFreeze)
	{
		AssertSz(_pdp && _pdp->IsFrozen(),
			"CTxtEdit::Unfreeze: screen not frozen but expected to be");
		_cFreeze--;
		_pdp->Thaw();
	}

	if(pCount)
		*pCount = _cFreeze;

	return _cFreeze ? S_FALSE : NOERROR;
}

//----------------------- ITextDocument2 Methods -----------------------
/*
 *	ITextDocument2::AttachMsgFilter(pFilter) 
 *
 *	@mfunc
 *		Method to attach a new message filter to the edit instance.
 *      All window messages received by the edit instance will be forwarded
 *      to the message filter.  The message filter must be bound to the document
 *		before it can be used (Refer to the ITextMessageFilter API).
 *
 *	@rdesc
 *		HRESULT = filter succesfully attached ? NOERROR : QI failure.
 */
STDMETHODIMP CTxtEdit::AttachMsgFilter (
	IUnknown *pFilter)		//@parm the IUnknown for the new message filter
{
	ITextMsgFilter *pMsgFilter = NULL;

	HRESULT hr = pFilter->QueryInterface(IID_ITextMsgFilter, (void **)&pMsgFilter);
	if (SUCCEEDED(hr))
	{
		if (_pMsgFilter)
			_pMsgFilter->AttachMsgFilter(pMsgFilter);
		else
			_pMsgFilter = pMsgFilter;
	}
	return hr;
}

/*
 *	ITextDocument2::GetEffectColor(Index, pcr)
 *
 *	@mfunc
 *		Method to retrieve the COLORREF color used in special attribute
 *		displays.  The first 15 values are for special underline colors 1 - 15.
 *      Later we may define indices for other effects, e.g., URLs, strikeout.
 *		If an index between 1 and 15 hasn't been defined by an appropriate
 *		call to ITextDocument2:SetEffectColor(), the corresponding WORD
 *		default color value given by g_Colors[] is returned.
 *
 *	@rdesc
 *		HRESULT = (valid active color index)
 *				? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtEdit::GetEffectColor(
	long	  Index,		//@parm Which special color to get
	COLORREF *pcr)			//@parm Out parm for color
{
	if(!pcr)
		return E_INVALIDARG;

	if(!IN_RANGE(1, Index, 15))
	{
		*pcr = (COLORREF)tomUndefined;
		return E_INVALIDARG;
	}

	*pcr = g_Colors[Index];

	CDocInfo *pDoc = GetDocInfo();
	if(!pDoc)
		return E_OUTOFMEMORY;
	
	Index--;
	if (Index < pDoc->cColor &&
		pDoc->prgColor[Index] != (COLORREF)tomUndefined)
	{
		*pcr = pDoc->prgColor[Index];
	}
	return NOERROR;
}

/*
 *	ITextDocument2::SetEffectColor(Index, cr) 
 *
 *	@mfunc
 *		Method to save the Index'th special document color.  Indices
 *      1 - 15 are defined for underlining.  Later we may define
 *		indices for other effects, e.g., URLs, strikeout.
 *
 *	@rdesc
 *		HRESULT = (valid index)
 *				? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtEdit::SetEffectColor(
	long	 Index,			//@parm Which special color to set
	COLORREF cr)			//@parm Color to use
{
	CDocInfo *pDoc = GetDocInfo();
	if(!pDoc)
		return E_OUTOFMEMORY;

	Index--;
	if(!IN_RANGE(0, Index, 14))
		return E_INVALIDARG;

	if(Index >= pDoc->cColor)
	{
		LONG	  cColor   = (Index + 4) & ~3;		// Round up to 4
		COLORREF *prgColor = (COLORREF *)PvReAlloc(pDoc->prgColor,
												  cColor*sizeof(COLORREF));
		if(!prgColor)
			return E_OUTOFMEMORY;

		for(LONG i = pDoc->cColor; i < cColor; i++)
			prgColor[i] = (COLORREF)tomUndefined;

		pDoc->cColor   = (char)cColor;
		pDoc->prgColor = prgColor;
	}
	pDoc->prgColor[Index] = cr;	
	return NOERROR;
}

/*
 *	ITextDocument2::SetCaretType(CaretType) 
 *
 *	@mfunc
 *		Method to sllow programmatic control over the caret type.
 *      The form of the control is TBD as is its interaction with
 *      existing formatting (e.g. font size and italics).
 *
 *	@rdesc
 *		HRESULT = caret type is one we understand ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtEdit::SetCaretType(
	long CaretType)		//@parm specification of caret type to use
{
	// For now, just care about Korean block craet.
	if (CaretType == tomKoreanBlockCaret)
		_fKoreanBlockCaret = TRUE;
	else if (CaretType == tomNormalCaret)
		_fKoreanBlockCaret = FALSE;
	else
		return E_INVALIDARG;

	if (_psel && _psel->IsCaretShown() && _fFocus)
	{
		_psel->CreateCaret();
		TxShowCaret(TRUE);
	}
	return NOERROR;
}

/*
 *	ITextDocument2::GetCaretType(pCaretType)
 *
 *	@mfunc
 *		Method to retrieve the previously set caret type.
 *      TBD.  Can one get it without setting it?
 *
 *	@rdesc
 *		HRESULT = caret info OK ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtEdit::GetCaretType(
	long *pCaretType)		//@parm current caret type specification
{
	if (!pCaretType)
		return E_INVALIDARG;

	*pCaretType = _fKoreanBlockCaret ? tomKoreanBlockCaret : tomNormalCaret;
	return NOERROR;
}

/*
 *	ITextDocument2::GetImmContext(pContext) 
 *
 *	@mfunc
 *		Method to retrieve the IMM context from our host.
 *
 *	@rdesc
 *		HRESULT = ImmContext available ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtEdit::GetImmContext(
	long *pContext)		//@parm Imm context
{
	if (!pContext)
		return E_INVALIDARG;

	*pContext = 0;

	if (!_fInOurHost)
	{
		// ask host for Imm Context
		HIMC hIMC = TxImmGetContext();
		
		*pContext = (long) hIMC;			
	}
	
	return *pContext ? NOERROR : S_FALSE;
}

/*
 *	ITextDocument2::ReleaseImmContext(Context) 
 *
 *	@mfunc
 *		Method to release the IMM context.
 *
 *	@rdesc
 *		HRESULT = ImmContext available ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtEdit::ReleaseImmContext(
	long Context)		//@parm Imm context to be release
{
	if (!_fInOurHost)
	{
		// ask host to release Imm Context
		TxImmReleaseContext((HIMC)Context);
		
		return NOERROR;			
	}
	
	return S_FALSE;
}

/*
 *	ITextDocument2::GetPreferredFont(cp, lCodePage, lOption, lCurCodePage, lCurFontSize,
 *		,pFontName, pPitchAndFamily, pNewFontSize) 
 *
 *	@mfunc
 *		Method to retrieve the preferred font name and pitch and family at a 
 *		given cp and codepage.
 *
 *	@rdesc
 *		HRESULT = FontName available ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtEdit::GetPreferredFont(
	long cp,				//@parm cp
	long lCodepage,			//@parm codepage preferred
	long lOption,			//@parm option for matching current font
	long lCurCodePage,		//@parm current codepage
	long lCurFontSize,		//@parm current font size
	BSTR *pFontName,		//@parm preferred fontname
	long *pPitchAndFamily,	//@parm pitch and family 
	long *plNewFontSize)	//@parm new font size preferred 
{
	if (!pFontName || !IN_RANGE(IGNORE_CURRENT_FONT, lOption, MATCH_FONT_SIG))
		return E_INVALIDARG;

	if (!IsAutoFont())		// EXIT if auto font is turned off
		return S_FALSE;

	CRchTxtPtr	rtp(this, 0);
	CCFRunPtr	rp(rtp);
	short		iFont;
	short		yHeight;
	BYTE		bPitchAndFamily;
	BYTE		bCharset = ANSI_CHARSET;

	rp.AdvanceCp(cp);
	if (rp.GetPreferredFontInfo(
			lCodepage,
			bCharset,
			iFont,
			yHeight,
			bPitchAndFamily,
			-1,
			lOption))
	{
		if (*pFontName)
			wcscpy(*pFontName, GetFontName((LONG)iFont));
		else
		{
			*pFontName = SysAllocString(GetFontName((LONG)iFont));
			if (!*pFontName)
				return E_OUTOFMEMORY;
		}

		if (pPitchAndFamily)
			*pPitchAndFamily = bPitchAndFamily;

		// Calc the new font size if needed
		if (plNewFontSize)
		{
			*plNewFontSize = lCurFontSize;
			if (_fAutoFontSizeAdjust && lCodepage != lCurCodePage)
				*plNewFontSize = yHeight / TWIPS_PER_POINT;			// Set the preferred size
		}

		return S_OK;
	}

	return E_FAIL;
}

/*
 *	ITextDocument2::GetNotificationMode( long *plMode ) 
 *
 *	@mfunc
 *		Method to retrieve the current notification mode.
 *
 *	@rdesc
 *		HRESULT = notification mode available ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtEdit::GetNotificationMode(
	long *plMode)		//@parm current notification mode
{
	if (!plMode)
		return E_INVALIDARG;

	*plMode = _fSuppressNotify ? tomFalse : tomTrue;

	return NOERROR;
}

/*
 *	ITextDocument2::SetNotificationMode(lMode) 
 *
 *	@mfunc
 *		Method to set the current notification mode.
 *
 *	@rdesc
 *		HRESULT = notification mode set ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtEdit::SetNotificationMode(
	long lMode)		//@parm new notification mode
{
	if (lMode == tomFalse)
		_fSuppressNotify = 1;
	else if  (lMode == tomTrue)
		_fSuppressNotify = 0;
	else
		return E_INVALIDARG;

	return NOERROR;
}

/*
 *	ITextDocument2::GetClientRect(Type, pLeft, pTop,pRight, pBottom ) 
 *
 *	@mfunc
 *		Method to retrieve the client rect and inset adjustment.
 *
 *	@rdesc
 *		HRESULT = notification mode set ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtEdit::GetClientRect(
	long Type,				//@parm option
	long *pLeft,			//@parm left
	long *pTop,				//@parm top
	long *pRight,			//@parm right
	long *pBottom)			//@parm bottom
{
	if (!pLeft || !pTop || !pRight || !pBottom)
		return E_INVALIDARG;
	
	RECT rcArea;
	TxGetClientRect(&rcArea); 
	
	if ( Type & tomIncludeInset )
	{
		// Ajdust veiw inset
		RECT rcInset;
		TxGetViewInset( &rcInset, NULL );
		rcArea.right 	-= rcInset.right;
		rcArea.bottom 	-= rcInset.bottom;
		rcArea.left 	+= rcInset.left;
		rcArea.top 		+= rcInset.top;
	}

	// Caller wants screen coordinates?
	if ( !(Type & tomClientCoord) )
	{
		POINT	ptTopLeft = {rcArea.left, rcArea.top};
		POINT	ptBottomRight = {rcArea.right, rcArea.bottom};

		if (!TxClientToScreen(&ptTopLeft) ||
			!TxClientToScreen(&ptBottomRight))
			return E_FAIL;			// It is unexpected for this to happen

		*pLeft		= ptTopLeft.x;
		*pTop		= ptTopLeft.y;
		*pRight		= ptBottomRight.x;
		*pBottom	= ptBottomRight.y;
	}
	else
	{
		*pLeft		= rcArea.left;
		*pTop		= rcArea.top;
		*pRight		= rcArea.right;
		*pBottom	= rcArea.bottom;
	}

	return NOERROR;
}

/*
 *	ITextDocument2::GetSelectionEx(ppSel) 
 *
 *	@mfunc
 *		Method to retrieve selection.
 *
 *	@rdesc
 *		HRESULT = selection ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtEdit::GetSelectionEx(
	ITextSelection **ppSel)			//@parm  Get Selection object
{	
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetSelectionEx");

	if (_fInPlaceActive)
		return GetSelection (ppSel);

	Assert("Getting selection while not active");

	if(!ppSel)
		return E_INVALIDARG;

	*ppSel = NULL;
	return S_FALSE;
}

/*
 *	ITextDocument2::GetWindow(phWnd) 
 *
 *	@mfunc
 *		Method to get the host window
 *
 *	@rdesc
 *		HRESULT = NOERROR if host return hWnd
 */
STDMETHODIMP CTxtEdit::GetWindow(
	long *phWnd)				//@parm hWnd
{
	if (!phWnd)
		return E_INVALIDARG;

	return TxGetWindow((HWND *)phWnd);
}

/*
 *	ITextDocument2::GetFEFlags(pFEFlags) 
 *
 *	@mfunc
 *		Method to get Host FE flags
 *
 *	@rdesc
 *		HRESULT = NOERROR if host returns FE Flags
 */
STDMETHODIMP CTxtEdit::GetFEFlags(
	long *pFEFlags)			//@parm FE Flags
{
	return TxGetFEFlags(pFEFlags);
}

/*
 *	ITextDocument2::UpdateWindow(void) 
 *
 *	@mfunc
 *		Method to update the RE window
 *
 *	@rdesc
 *		HRESULT = NOERROR 
 */
STDMETHODIMP CTxtEdit::UpdateWindow(void)
{
	TxUpdateWindow();
	return NOERROR;
}

/*
 *	ITextDocument2::CheckTextLimit(long cch, long *pcch) 
 *
 *	@mfunc
 *		Method to check if the count of characters to be added would
 *		exceed max. text limit.  If number of characters exced is return
 *		in pcch
 *
 *	@rdesc
 *		HRESULT = NOERROR 
 */
STDMETHODIMP CTxtEdit::CheckTextLimit(
	long cch,			//@parm count of characters to be added			
	long *pcch)			//@parm return the number of characters exced text limit
{
	if(!pcch)
		return E_INVALIDARG;

	if (_psel)
	{
		*pcch = 0;
		_psel->CheckTextLength(cch, pcch);
		return NOERROR;
	}
	
	return S_FALSE; 
}

/*
 *	ITextDocument2::IMEInProgress(lMode) 
 *
 *	@mfunc
 *		Method for IME message filter to inform client that IME composition
 *		is in progress.
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
STDMETHODIMP CTxtEdit::IMEInProgress(
	long lMode)		//@parm current IME composition status
{
	if (lMode == tomFalse)
		_fIMEInProgress = 0;
	else if  (lMode == tomTrue)
		_fIMEInProgress = 1;

	return NOERROR;
}

/*
 *	ITextDocument2::SysBeep(void) 
 *
 *	@mfunc
 *		Method to generate system beep.
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
STDMETHODIMP CTxtEdit::SysBeep(void)
{	
	Beep();
	return NOERROR;
}

/*
 *	ITextDocument2::Update(lMode) 
 *
 *	@mfunc
 *		Method for update the selection or caret.  If lMode is tomTrue, then
 *		scroll the caret into view.
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
STDMETHODIMP CTxtEdit::Update(
	long lMode)		//@parm current IME composition status
{
	if (!_psel)
		return S_FALSE;

	_psel->Update(lMode == tomTrue ? TRUE : FALSE);

	return NOERROR;
}

/*
 *	ITextDocument2::Notify(lNotify) 
 *
 *	@mfunc
 *		Method for notifying the host for certain IME events
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
STDMETHODIMP CTxtEdit::Notify(
	long lNotify)		//@parm Notification code
{
	TxNotify(lNotify, NULL);

	return NOERROR;
}

//----------------------- ITextDocument Helper Functions -----------------------
/*
 *	CTxtEdit::CloseFile (bSave)
 *
 *	@mfunc
 *		Method that closes the current document. If changes have been made
 *		in the current document since the last save and document file
 *		information exists, the current document is saved.
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
HRESULT CTxtEdit::CloseFile (
	BOOL bSave)
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::Close");

	CDocInfo *pDocInfo = _pDocInfo;

	if(pDocInfo)
	{
		if(bSave)									// Save current file if
			Save(NULL, 0, 0);						//  any changes made
	
		// FUTURE(BradO):  This code is very similar to the destructor code.
		// We have a problem here in that some of the CDocInfo information
		// should persist from Open to Close to Open (ex. default tab stop)
		// mixed with other per-Open/Close info.  A better job of abstracting
		// these two types of info would really clean up this code.

		if(pDocInfo->pName)
		{
			SysFreeString(pDocInfo->pName);			// Free filename BSTR
			pDocInfo->pName = NULL;
		}

		if(pDocInfo->hFile)
		{
			CloseHandle(pDocInfo->hFile);			// Close file if open
			pDocInfo->hFile = NULL;
		}
		pDocInfo->wFlags = 0;
		pDocInfo->wCpg = 0;

		pDocInfo->lcid = 0;
		pDocInfo->lcidfe = 0;

		if(pDocInfo->lpstrLeadingPunct)
		{
			FreePv(pDocInfo->lpstrLeadingPunct);
			pDocInfo->lpstrLeadingPunct = NULL;
		}

		if(pDocInfo->lpstrFollowingPunct)
		{
			FreePv(pDocInfo->lpstrFollowingPunct);
			pDocInfo->lpstrFollowingPunct = NULL;
		}
	}
	return NOERROR;
}

/*
 *	CTxtEdit::SetDefaultLCID (lcid) 
 *
 *	@mfunc
 *		Property set method that sets the default LCID
 *
 *	@rdesc
 *		HRESULT = NOERROR
 *
 *	@comm
 *		This property should be part of TOM
 */
HRESULT CTxtEdit::SetDefaultLCID (
	LCID lcid)		//@parm New default LCID value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::SetDefaultLCID");

	CDocInfo *pDocInfo = GetDocInfo();

	if(!pDocInfo)								// Doc info doesn't exist
		return E_OUTOFMEMORY;

	pDocInfo->lcid = lcid;
	return NOERROR;
}

/*
 *	CTxtEdit::GetDefaultLCID (pLCID) 
 *
 *	@mfunc
 *		Property get method that gets the default LCID
 *
 *	@rdesc
 *		HRESULT = (!pLCID) ? E_INVALIDARG : NOERROR
 */
HRESULT CTxtEdit::GetDefaultLCID (
	LCID *pLCID)		//@parm Out parm with default LCID value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetDefaultLCID");

	if(!pLCID)
		return E_INVALIDARG;

	CDocInfo *pDocInfo = GetDocInfo();

	if(!pDocInfo)								// Doc info doesn't exist
		return E_OUTOFMEMORY;

	*pLCID = _pDocInfo->lcid;
	return NOERROR;
}

/*
 *	CTxtEdit::SetDefaultLCIDFE (lcid) 
 *
 *	@mfunc
 *		Property set method that sets the default FE LCID
 *
 *	@rdesc
 *		HRESULT = NOERROR
 *
 *	@comm
 *		This property should be part of TOM
 */
HRESULT CTxtEdit::SetDefaultLCIDFE (
	LCID lcid)		//@parm New default LCID value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::SetDefaultLCIDFE");

	CDocInfo *pDocInfo = GetDocInfo();

	if(!pDocInfo)								// Doc info doesn't exist
		return E_OUTOFMEMORY;

	pDocInfo->lcidfe = lcid;
	return NOERROR;
}

/*
 *	CTxtEdit::GetDefaultLCIDFE (pLCID) 
 *
 *	@mfunc
 *		Property get method that gets the default FE LCID
 *
 *	@rdesc
 *		HRESULT = (!pLCID) ? E_INVALIDARG : NOERROR
 */
HRESULT CTxtEdit::GetDefaultLCIDFE (
	LCID *pLCID)		//@parm Out parm with default LCID value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetDefaultLCID");

	if(!pLCID)
		return E_INVALIDARG;

	CDocInfo *pDocInfo = GetDocInfo();

	if(!pDocInfo)								// Doc info doesn't exist
		return E_OUTOFMEMORY;

	*pLCID = _pDocInfo->lcidfe;
	return NOERROR;
}

/*
 *	CTxtEdit::SetDocumentType(bDocType) 
 *
 *	@mfunc
 *		Property set method that sets the document's type (none-\ltrdoc-\rtldoc)
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
HRESULT CTxtEdit::SetDocumentType (
	LONG DocType)		//@parm New document-type value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::SetDocumentType");

	CDocInfo *pDocInfo = GetDocInfo();

	if(!pDocInfo)								// Doc info doesn't exist
		return E_OUTOFMEMORY;

	pDocInfo->bDocType = (BYTE)DocType;
	return NOERROR;
}

/*
 *	CTxtEdit::GetDocumentType (pDocType) 
 *
 *	@mfunc
 *		Property get method that gets the document type
 *
 *	@rdesc
 *		HRESULT = (!pDocType) ? E_INVALIDARG : NOERROR
 */
HRESULT CTxtEdit::GetDocumentType (
	LONG *pDocType)		//@parm Out parm with document type value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetDocumentType");

	if(!pDocType)
		return E_INVALIDARG;

	CDocInfo *pDocInfo = GetDocInfo();

	if(!pDocInfo)								// Doc info doesn't exist
		return E_OUTOFMEMORY;

	*pDocType = _pDocInfo->bDocType;
	return NOERROR;
}

/*
 *	CTxtEdit::GetLeadingPunct (plpstrLeadingPunct)
 *
 *	@mfunc
 *		Retrieve leading kinsoku punctuation for document
 *
 *	@rdesc
 *		HRESULT = (!<p plpstrLeadingPunct>) ? E_INVALIDARG :
 *				  (no leading punct) ? S_FALSE :
 *				  (if not enough RAM) ? E_OUTOFMEMORY : NOERROR
 */
HRESULT CTxtEdit::GetLeadingPunct (
	LPSTR * plpstrLeadingPunct)		//@parm Out parm to receive leading 
								//	kinsoku punctuation
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetLeadingPunct");

	if(!plpstrLeadingPunct)
		return E_INVALIDARG;

	*plpstrLeadingPunct = NULL;
	if(!_pDocInfo || !_pDocInfo->lpstrLeadingPunct)
		return S_FALSE;

	*plpstrLeadingPunct = _pDocInfo->lpstrLeadingPunct;
	
	return NOERROR;
}

/*
 *	CTxtEdit::SetLeadingPunct (lpstrLeadingPunct)
 *
 *	@mfunc
 *		Set leading kinsoku punctuation for document
 *
 *	@rdesc
 *		HRESULT = (if not enough RAM) ? E_OUTOFMEMORY : NOERROR
 */
HRESULT CTxtEdit::SetLeadingPunct (
	LPSTR lpstrLeadingPunct)	//@parm In parm containing leading 
								//	kinsoku punctuation
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::SetLeadingPunct");

	CDocInfo *pDocInfo = GetDocInfo();

	if(!pDocInfo)
		return E_OUTOFMEMORY;

	if(pDocInfo->lpstrLeadingPunct)
		FreePv(pDocInfo->lpstrLeadingPunct);

	if(lpstrLeadingPunct && *lpstrLeadingPunct)
		pDocInfo->lpstrLeadingPunct = lpstrLeadingPunct;
	else
	{
		pDocInfo->lpstrLeadingPunct = NULL;
		return E_INVALIDARG;
	}
	return NOERROR;
}

/*
 *	CTxtEdit::GetFollowingPunct (plpstrFollowingPunct)
 *
 *	@mfunc
 *		Retrieve following kinsoku punctuation for document
 *
 *	@rdesc
 *		HRESULT = (!<p plpstrFollowingPunct>) ? E_INVALIDARG :
 *				  (no following punct) ? S_FALSE :
 *				  (if not enough RAM) ? E_OUTOFMEMORY : NOERROR
 */
HRESULT CTxtEdit::GetFollowingPunct (
	LPSTR * plpstrFollowingPunct)		//@parm Out parm to receive following 
								//	kinsoku punctuation
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetFollowingPunct");

	if(!plpstrFollowingPunct)
		return E_INVALIDARG;

	*plpstrFollowingPunct = NULL;
	if(!_pDocInfo || !_pDocInfo->lpstrFollowingPunct)
		return S_FALSE;

	*plpstrFollowingPunct = _pDocInfo->lpstrFollowingPunct;
	
	return NOERROR;
}

/*
 *	CTxtEdit::SetFollowingPunct (lpstrFollowingPunct)
 *
 *	@mfunc
 *		Set following kinsoku punctuation for document
 *
 *	@rdesc
 *		HRESULT = (if not enough RAM) ? E_OUTOFMEMORY : NOERROR
 */
HRESULT CTxtEdit::SetFollowingPunct (
	LPSTR lpstrFollowingPunct)		//@parm In parm containing following 
									//	kinsoku punctuation
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::SetFollowingPunct");

	CDocInfo *pDocInfo = GetDocInfo();

	if(!pDocInfo)
		return E_OUTOFMEMORY;

	if(pDocInfo->lpstrFollowingPunct)
		FreePv(pDocInfo->lpstrFollowingPunct);

	if(lpstrFollowingPunct && *lpstrFollowingPunct)
		pDocInfo->lpstrFollowingPunct = lpstrFollowingPunct;
	else
	{
		pDocInfo->lpstrFollowingPunct = NULL;
		return E_INVALIDARG;
	}
	return NOERROR;
}

/*
 *	CTxtEdit::InitDocInfo()
 *
 *	@mfunc	constructor for the docinfo class
 */
HRESULT CTxtEdit::InitDocInfo()
{
	_wZoomNumerator = _wZoomDenominator = 0;
	if(_pDocInfo)
	{
		_pDocInfo->InitDocInfo();
		return NOERROR;
	}

	return GetDocInfo() ? NOERROR : E_OUTOFMEMORY;
}


//----------------------- CDocInfo related Functions -----------------------
/*
 *	CDocInfo::InitDocInfo()
 *
 *	@mfunc	constructor for the docinfo class
 */
void CDocInfo::InitDocInfo()
{
	wCpg = (WORD)GetACP();
	lcid = GetSystemDefaultLCID();

	if(IsFELCID(lcid))
	{
		lcidfe = lcid;
		lcid = MAKELCID(sLanguageEnglishUS, SORT_DEFAULT);
	}

	dwDefaultTabStop = lDefaultTab;
	bDocType = 0;
}

/*
 *	CDocInfo::~CDocInfo
 *
 *	@mfunc	desctructor for the docinfo class
 */
CDocInfo::~CDocInfo()
{
	if( pName )
	{
		SysFreeString(pName);
		pName = NULL;
	}

	if( hFile )
	{
		CloseHandle(hFile);
		hFile = NULL;
	}

	FreePv(lpstrLeadingPunct);
	lpstrLeadingPunct = NULL;

	FreePv(lpstrFollowingPunct);
	lpstrFollowingPunct = NULL;

	FreePv(prgColor);
	prgColor = NULL;
}

/*
 *	CTxtEdit::GetDocInfo ()
 *
 *	@mfunc
 *		If _pDocInfo is NULL, equate it to a new CDocInfo.  In either case
 *		return _pDocInfo
 *
 *	@rdesc
 *		CTxtEdit::_pDocInfo, the ptr to the CDocInfo object
 */
CDocInfo * CTxtEdit::GetDocInfo()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetDocInfo");

	if (!_pDocInfo)
		_pDocInfo = new CDocInfo();

	// It is the caller's responsiblity to notice that an error occurred
	// in the allocation of the CDocInfo object.
	return _pDocInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\uspi.cpp ===
/*
 *		Uniscribe interface (& related classes) class implementation
 *		
 *		File:    uspi.cpp
 * 		Create:  Jan 10, 1998
 *		Author:  Worachai Chaoweeraprasit (wchao)
 *
 *		Copyright (c) 1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_font.h"
#include "_frunptr.h"
#include "_select.h"
#include "_measure.h"
#include "_uspi.h"

CUniscribe* 	g_pusp = NULL;
int				g_cMaxScript = 0x100;


// initial dummy script properties (= SCRIPT_UNDEFINED)
static const SCRIPT_PROPERTIES 	g_propUndef 	= { LANG_NEUTRAL, FALSE, FALSE, FALSE, FALSE, 0 };
static const SCRIPT_PROPERTIES*	g_pPropUndef[1]	= { &g_propUndef };

CUniscribe::CUniscribe ()
{
	// Initialize digit substitution info
	ApplyDigitSubstitution(W32->GetDigitSubstitutionMode());

	// Get maximum number of scripts supported
	ScriptGetProperties(NULL, &g_cMaxScript);
}

// Test the OS if it does any complex script.
// REVIEW (keithcu) What if it only supports indic, but not the other ones?
BOOL IsSupportedOS()
{
	BOOL	fSupport = !OnWin95FE();
	int		rguCodePage[] = {1255, 1256, 874};
	BYTE	rgbch[] = {0xe0, 0xd3, 0xa1};
	WCHAR	rgwch[] = {0x05d0, 0x0633, 0x0e01};
	WCHAR	wch;
	int	   	i = 0;

	if (fSupport)
	{
		for (;i < 3; i++)
		{
			if (MBTWC(rguCodePage[i], 0, (LPCSTR)&rgbch[i], 1, (LPWSTR)&wch, 1, NULL) > 0 &&
				wch == rgwch[i])
				break;			// support either Arabic, Hebrew or Thai
		}
	}
	return fSupport && i < 3;
}

// Prepare information for digit substitution
// return: Native digit script (shapine engine) ID.
//
WORD CUniscribe::ApplyDigitSubstitution(BYTE bDigitSubstMode)
{
	_wesNationalDigit = 0;

	// Remember national digits script ID if substitution mode is not None
	if (bDigitSubstMode != DIGITS_NOTIMPL && bDigitSubstMode != DIGITS_NONE)
	{
		WCHAR			chZero = 0x0030;
		int				cItems;
		SCRIPT_ITEM		si[2];
		SCRIPT_CONTROL	sc = {0};
		SCRIPT_STATE	ss = {0};

		// force national digit mode
		sc.uDefaultLanguage   = GetNationalDigitLanguage(GetThreadLocale());
		ss.fDigitSubstitute   = TRUE;
		sc.fContextDigits     = FALSE;

		if (SUCCEEDED(ScriptItemize(&chZero, 1, 2, &sc, &ss, (SCRIPT_ITEM*)&si, (int*)&cItems)))
			_wesNationalDigit = si[0].a.eScript;
	}
	return _wesNationalDigit;
}


// Some locales may have its own traditional (native) digit and national standard digit
// recognised by a standard body and adopted by NLSAPI. The example is that Nepali(India)
// has its own digit but the India standard uses Hindi digit as the national digit.
//
DWORD CUniscribe::GetNationalDigitLanguage(LCID lcid)
{
	DWORD	dwDigitLang = PRIMARYLANGID(LANGIDFROMLCID(lcid));

	if (W32->OnWinNT5())
	{
		WCHAR	rgwstrDigit[20];

		if (GetLocaleInfoW(lcid, LOCALE_SNATIVEDIGITS, rgwstrDigit, sizeof(rgwstrDigit)))
		{
			// Steal this from Uniscribe (build 0231)

			switch (rgwstrDigit[1])
			{
				case 0x0661: dwDigitLang = LANG_ARABIC;    break;
				case 0x06F1: dwDigitLang = LANG_FARSI;     break;
				case 0x0e51: dwDigitLang = LANG_THAI;      break;
				case 0x0967: dwDigitLang = LANG_HINDI;     break;
				case 0x09e7: dwDigitLang = LANG_BENGALI;   break;
				case 0x0a67: dwDigitLang = LANG_PUNJABI;   break;
				case 0x0ae7: dwDigitLang = LANG_GUJARATI;  break;
				case 0x0b67: dwDigitLang = LANG_ORIYA;     break;
				case 0x0be7: dwDigitLang = LANG_TAMIL;     break;
				case 0x0c67: dwDigitLang = LANG_TELUGU;    break;
				case 0x0ce7: dwDigitLang = LANG_KANNADA;   break;
				case 0x0d67: dwDigitLang = LANG_MALAYALAM; break;
				case 0x0f21: dwDigitLang = LANG_TIBETAN;   break;
				case 0x0ed1: dwDigitLang = LANG_LAO;       break;
			}
		}
	}

	return dwDigitLang;
}


CUniscribe::~CUniscribe ()
{
	if (_pFSM)
	{
		delete _pFSM;
	}
}


/***** High level services *****/


// Tokenize string and run Unicode Bidi algorithm if requested.
// return : =<0 - error
//			>0  - number of complex script tokens
//
int CUniscribe::ItemizeString (
	USP_CLIENT* pc,					// in: Working structure
	WORD		uInitLevel,			// in: Initial Bidi level
	int*        pcItems,			// out: Count of items generated
	WCHAR*		pwchString,			// in: Input string
	int			cch,				// in: Number of character to itemize
	BOOL        fUnicodeBiDi,		// in: TRUE - Use UnicodeBidi
	WORD		wLangId)			// in: (optional) Dominant language preference
{
	Assert (pc && pc->si && pcItems && pwchString && cch > 0 && cch <= pc->si->cchString);

	USP_CLIENT_SI*  pc_si = pc->si;
	SCRIPT_ITEM*    psi = pc_si->psi;
	SCRIPT_CONTROL	sc = {0};
	SCRIPT_STATE	ss = {0};
	SCRIPT_CONTROL*	psc;
	SCRIPT_STATE*	pss;
	HRESULT         hr;
	int             cItems = 0;

	if (fUnicodeBiDi)
	{
		psc = &sc;
		pss = &ss;

		if (wLangId == LANG_NEUTRAL)
			wLangId = PRIMARYLANGID(LANGIDFROMLCID(GetThreadLocale()));

		// (preitemize:) set up initial state
		psc->uDefaultLanguage = wLangId;
		
		// For Arabic Office's compatibility.
		// We enable fArabicNumContext if the dominant language is Arabic.
		//
		if (psc->uDefaultLanguage == LANG_ARABIC)
			pss->fArabicNumContext = uInitLevel & 1;

		pss->uBidiLevel         = uInitLevel;
		// Leave digit substitution to None since we do it ourself.
		// pss->fDigitSubstitute   = FALSE;
		// psc->fContextDigits     = FALSE;
	}
	else
	{
		psc = NULL;
		pss = NULL;
	}

	// begin real work
	hr = ScriptItemize(pwchString, cch, cch+1, psc, pss, psi, (int*)&cItems);

	return SUCCEEDED(hr) ? *pcItems = cItems : 0;
}


// Produce a shaped string (glyph array), taking care of font association and measurer's CF update
//
// Success can require 3 calls to Shape():
// 1. Returns E_PENDING (script cache doesn't contain the glyphing information)
// 2. Return USP_E_SCRIPT_NOT_IN_FONT --the HFONT doesn't contain the script needed to do the glyphing
// 3. Hopefully success, but may return again if the fallback font doesn't exist, but we quit anyway.
int CUniscribe::ShapeString (
	PLSRUN					plsrun,		// in: The first run to be shaped
	SCRIPT_ANALYSIS*        psa, 		// in: Analysis of the run to be shaped
	CMeasurer*              pme, 		// in: Measurer points to start cp of the run
	const WCHAR*            pwch, 		// in: String to be shaped
	int                     cch,		// in: Count of chars
	WORD*&                  pwgi, 		// out: Reference to glyph indices array
	WORD*                   pwlc, 		// out: Logical cluster array
	SCRIPT_VISATTR*&        psva)		// out: Reference to glyph's attribute array
{
	AssertSz (plsrun && psa && pme && pwch, "ShapeString failed: Invalid params");

	HRESULT     hr = S_OK;
	HRESULT		hrLastError = S_OK;
	HDC         hdc = NULL;
	HFONT		hOrgFont = NULL;
	int         cGlyphs;
	int			cchAdd = 0;
	CCcs	    *pccsSave = pme->Check_pccs();
	int			nAttempt = 8;	// Maximum attempt to realloc glyph buffer to shape a string

	// make sure that we have proper font cache ready to use
	if (!pme->_pccs)
		return 0;
	
	if (psa->fNoGlyphIndex)
		// If no glyph processing, hdc must be around.
        hdc = PrepareShapeDC(pme, E_PENDING, hOrgFont);

	// prepare glyph buffer
	if (!CacheAllocGlyphBuffers(cch, cGlyphs, pwgi, psva))
		return 0;

	do
	{
		hr = ScriptShape(hdc, &pme->_pccs->_sc, pwch, cch, cGlyphs, psa, pwgi, pwlc, psva, &cGlyphs);

		if (SUCCEEDED(hr))
			break;

		// Error handling...

		switch (hr)
		{
			case E_PENDING:
			case USP_E_SCRIPT_NOT_IN_FONT:

				if (hr == hrLastError)
					nAttempt = 0;		// We encounter the same error twice.
				else
				{
					hdc = PrepareShapeDC(pme, hr, hOrgFont);
					hrLastError = hr;
				}
				break;

			case E_OUTOFMEMORY:

				// (#6773)Indic shaping engine could produce glyphs more than we could hold.
				//
				cchAdd += 16;
				if (CacheAllocGlyphBuffers(cch + cchAdd, cGlyphs, pwgi, psva))
				{
					nAttempt--;
					break;
				}
				
			default:
				nAttempt = 0;
				//AssertSz(FALSE, "Shaping fails with invalid error or we run out of memory.");
				break;
		}

	} while (nAttempt > 0);


	// restore hdc's original font
	if (hdc && hOrgFont)
		SelectObject(hdc, hOrgFont);

	if (pme->_pccs != pccsSave)
		plsrun->SetFallback(SUCCEEDED(hr));

	return SUCCEEDED(hr) ? cGlyphs : 0;
}

// Place a string and take care of font association and measurer's CF update
//
// This is called right after ShapeString.
int CUniscribe::PlaceString(
	PLSRUN					plsrun,		// in: The first run to be shaped
	SCRIPT_ANALYSIS*        psa, 		// in: Analysis of the run to be shaped
	CMeasurer*              pme,        // in: Measurer points to start cp of the run
	const WORD*             pcwgi,      // in: Glyph indices array
	int                     cgi,		// in: Count of input glyphs
	const SCRIPT_VISATTR*   psva, 		// in: Glyph's attribute array
	int*                    pgdx,		// out: Glyph's advanced width array
	GOFFSET*                pgduv,		// out: Glyph's offset array
	ABC*                    pABC)       // out: Run's dimension
{
	AssertSz (plsrun && psa && pme && pcwgi, "PlaceString failed: Invalid params");

	HRESULT     hr = S_OK;
	HRESULT		hrLastError = S_OK;
	HDC         hdc = NULL;
	HFONT		hOrgFont = NULL;
	int			nAttempt = 1;

	pme->Check_pccs();
	pme->ApplyFontCache(plsrun->IsFallback());

	// make sure that we have proper font cache ready to use
	if (!pme->_pccs)
		return 0;

	if (psa->fNoGlyphIndex)
		// If no glyph processing, hdc must be around.
        hdc = PrepareShapeDC(pme, E_PENDING, hOrgFont);

	do
	{
		hr = ScriptPlace(hdc, &pme->_pccs->_sc, pcwgi, cgi, psva, psa, pgdx, pgduv, pABC);

		if (SUCCEEDED(hr))
			break;

		// Error handling...

		switch (hr)
		{
			case E_PENDING:

				if (hr == hrLastError)
					nAttempt = 0;		// We encounter the same error twice.
				else
				{
					hdc = PrepareShapeDC(pme, hr, hOrgFont);
					hrLastError = hr;
				}
				break;

			default:
				nAttempt = 0;
				//AssertSz(FALSE, "Placing fails with invalid error.");
				break;
		}

	} while (nAttempt > 0);


	// restore hdc's original font
	if (hdc && hOrgFont)
		SelectObject(hdc, hOrgFont);

	return SUCCEEDED(hr) ? cgi : 0;
}

// Placing given string results in logical width array,
// the result array would be used to record WMF metafile.
//
int CUniscribe::PlaceMetafileString (
	PLSRUN					plsrun,		// in: The first run to be shaped
	CMeasurer*              pme,        // in: Measurer points to start cp of the run
	const WCHAR*			pwch,		// in: Input codepoint string
	int						cch,		// in: Character count
	PINT*					ppiDx)		// out: Pointer to logical widths array
{
	AssertSz (pme && pwch && ppiDx, "PlaceMetafileString failed: Invalid params");

	if (W32->OnWinNT4() || W32->OnWin9xThai())
	{
		// MET NT40 has bug in lpdx justification so i doesnt playback the lpdx very nicely.
		// Thai Win9x simply cannot handle fancy lpdx values generated by Uniscribe.
		// We workaround both cases here by metafiling no lpdx and let the system reconstructs
		// it from scratch during playback time.

		// =FUTURE= If we do line justification. We need more sophisticated work here
		// basically to reconstruct the OS preferred type of lpdx.
		//
		*ppiDx = NULL;
		return cch;
	}

	HRESULT     	hr = S_OK;
	PUSP_CLIENT		pc = NULL;
	int*			piDx;			// result logical width array
	int				cgi = 0;
	BYTE			pbBufIn[MAX_CLIENT_BUF];
	SCRIPT_ANALYSIS	sa = plsrun->_a;
	BOOL			fVisualGlyphDx = sa.fRTL && W32->OnWin9x() && W32->OnBiDiOS();


	// Get static buffer for logical widths array
	if (!(piDx = GetWidthBuffer(cch)))
		return 0;

	CreateClientStruc(pbBufIn, MAX_CLIENT_BUF, &pc, cch, cli_ShapePlace);
	if (!pc)
		return 0;

	PUSP_CLIENT_SSP	pcssp = pc->ssp;
		
	if (fVisualGlyphDx)
		sa.fLogicalOrder = FALSE;	// shaping result in visual order

	// Shape string
	if (cgi = ShapeString(plsrun, &sa, pme, pwch, (int)cch, pcssp->pwgi, pcssp->pcluster, pcssp->psva))
	{
		// then place it...
		if (cgi == PlaceString(plsrun, &sa, pme, pcssp->pwgi, cgi, pcssp->psva, pcssp->pidx, pcssp->pgoffset, NULL))
		{
			if (fVisualGlyphDx)
			{
				// Workaround BiDi Win9x's lpdx handling
				// It assumes ExtTextOut's dx array is glyph width in visual order

				Assert (cgi <= cch); // glyph count never exceeds character count in BiDi
				CopyMemory (piDx, pcssp->pidx, min(cgi, cch)*sizeof(int));
			}
			else
			{
				// Map visual glyph widths to logical widths
				hr = ScriptGetLogicalWidths(&sa, cch, cgi, pcssp->pidx, pcssp->pcluster, pcssp->psva, piDx);
			}
		}
	}

	// result
	*ppiDx = piDx;

	if (pc && pbBufIn != (BYTE*)pc)
		FreePv(pc);

	return SUCCEEDED(hr) ? cgi : 0;
}



/***** Helper functions *****/


// Retrieve the BidiLevel FSM
const CBiDiFSM* CUniscribe::GetFSM ()
{
	if (!_pFSM)
	{
		_pFSM = new CBiDiFSM(this);
		if (_pFSM && !_pFSM->Init())
		{
			delete _pFSM;
		}
	}
	return _pFSM;
}


// Prepare the shapeable font ready to dc for a given script
//
// USP_E_SCRIPT_NOT_IN_FONT - complex scripts font association
// E_PENDING 				- prepare dc with current font selected
//
HDC CUniscribe::PrepareShapeDC (
    CMeasurer*		pme,        // in: Measurer points to start cp of the run
    HRESULT			hrReq,      // in: Error code to react
	HFONT&			hOrgFont)	// in/out: Original font of the shape DC
{
    Assert (pme);
	
	HDC		hdc = NULL;
	HFONT	hOldFont;

	switch (hrReq)
	{
		case USP_E_SCRIPT_NOT_IN_FONT:
			{
				pme->ApplyFontCache(fTrue);
#ifdef DEBUG
				if (pme->_pccs)
					Tracef(TRCSEVWARN, "USP_E_SCRIPT_NOT_IN_FONT: charset %d applied", pme->_pccs->_bCharSet);
#endif
			}
			
		default:
			if (pme->_pccs)
			{
				hdc = pme->_pccs->_hdc;
				hOldFont = (HFONT)SelectObject(hdc, pme->_pccs->_hfont);

				if (!hOrgFont)
					hOrgFont = hOldFont;
			}
	}

    return hdc;
}

const SCRIPT_PROPERTIES* CUniscribe::GeteProp (WORD eScript)
{
	if (!_ppProp)
	{
		if (!SUCCEEDED(ScriptGetProperties(&_ppProp, NULL)) || !_ppProp)
			_ppProp = g_pPropUndef;
	}
	if (_ppProp == g_pPropUndef || eScript >= (WORD)g_cMaxScript)
		eScript = 0;

	return _ppProp[eScript];
}

// Figure proper charset to use for complex script.
// The resulted charset can be either actual or virtual (internal) GDI charset used by given script
BOOL CUniscribe::GetComplexCharSet(
	const SCRIPT_PROPERTIES* 	psp,				// Uniscribe script's properties 			
	BYTE						bCharSetDefault,	// -1 format's charset
	BYTE&						bCharSetOut)		// out: Charset to use
{
	Assert(psp);

	BYTE	bCharSet = !psp->fCDM ? psp->bCharSet : GetCDMCharSet(bCharSetDefault);
	BOOL 	fr = psp->fComplex && !psp->fControl;

	if (fr)
	{
		bCharSetOut = 	IN_RANGE(ANSI_CHARSET, bCharSet, DEFAULT_CHARSET) ?
						GetCharSet(ConvertLanguageIDtoCodePage(psp->langid), NULL) :
						bCharSet;
	}
	return fr;
}

// Figure out the charset to use for CDM run
//
BYTE CUniscribe::GetCDMCharSet(BYTE bCharSetDefault)
{
	if (!_bCharSetCDM)
	{

		_bCharSetCDM = (bCharSetDefault == VIETNAMESE_CHARSET ||
						W32->GetPreferredKbd(VIET_INDEX) ||
						GetCharSet(GetLocaleCodePage(), NULL) == VIETNAMESE_CHARSET ||
						GetCharSet(GetACP(), NULL) == VIETNAMESE_CHARSET) ? VIETNAMESE_CHARSET : DEFAULT_CHARSET;
	}
	return _bCharSetCDM;
}

BYTE CUniscribe::GetRtlCharSet(CTxtEdit* ped)
{
	if (!_bCharSetRtl)
	{
		// First, try default charset
		DWORD	dwCharFlags;
		BYTE	bCharSet = ped->GetCharFormat(-1)->_bCharSet;

		if (!IN_RANGE(HEBREW_CHARSET, bCharSet, ARABIC_CHARSET))
		{
			// then the system charset
			bCharSet = GetCharSet(GetACP(), NULL);
	
			if (!IN_RANGE(HEBREW_CHARSET, bCharSet, ARABIC_CHARSET))
			{
				// then the content
				dwCharFlags = ped->GetCharFlags() & (fARABIC | fHEBREW);

				if (dwCharFlags == fARABIC)
					bCharSet = ARABIC_CHARSET;
				else if(dwCharFlags == fHEBREW)
					bCharSet = HEBREW_CHARSET;
				else
				{
					// and last chance with the first found loaded Bidi kbd
					if (W32->GetPreferredKbd(HEBREW_INDEX))
						bCharSet = HEBREW_CHARSET;
					else
						// Even if we cant find Arabic, we have to assume it here.
						bCharSet = ARABIC_CHARSET;
				}
			}
		}
		Assert(IsBiDiCharSet(bCharSet));
		_bCharSetRtl = bCharSet;
	}
	return _bCharSetRtl;
}


// Substitute digit shaper in plsrun if needed
//
void CUniscribe::SubstituteDigitShaper (
	PLSRUN		plsrun,
	CMeasurer*	pme)
{
	Assert(plsrun && pme);

	CTxtEdit*	ped = pme->GetPed();
	WORD		wScript;

	if (GeteProp(plsrun->_a.eScript)->fNumeric)
	{
		wScript = plsrun->_pCF->_wScript;		// reset it before

		switch (W32->GetDigitSubstitutionMode())
		{
		case DIGITS_CTX:
			{
				if (ped->IsRich())
				{
					// Context mode simply means the charset of the kbd for richtext.
					if (!IsBiDiCharSet(ped->GetCharFormat(pme->_rpCF.GetFormat())->_bCharSet))
						break;
				}
				else
				{
					// Digit follows directionality of preceding run for plain text
					CFormatRunPtr	rp(pme->_rpCF);
					Assert(rp.IsValid());

					if (rp.PrevRun())
					{
						if (!IsBiDiCharSet(ped->GetCharFormat(rp.GetFormat())->_bCharSet))
							break;
					}
					else
					{
						// No preceding run, looking for the paragraph direction
						if (!pme->Get_pPF()->IsRtlPara())
							break;
					}
				}
				// otherwise, fall thru...
			}
		case DIGITS_NATIONAL:
			wScript = _wesNationalDigit;
		default:
			break;
		}

		// Update all linked runs
		while (plsrun)
		{
			plsrun->_a.eScript = wScript;		// assign proper shaping engine to digits
			plsrun = plsrun->_pNext;
		}
	}
}
	

/***** Uniscribe entry point *****/


// memory allocator
//
BOOL CUniscribe::CreateClientStruc (
	BYTE*           pbBufIn,
	LONG            cbBufIn,
	PUSP_CLIENT*    ppc,
	LONG            cchString,
	DWORD           dwMask)
{
	Assert(ppc && pbBufIn);

	if (!ppc)
		return FALSE;

	*ppc = NULL;

	if (cchString == 0)
		cchString = 1;		// simplify caller's logic

	LONG        i;
	LONG        cbSize;
	PBYTE       pbBlock;

	// ScriptItemize's
	//
	PVOID       pvString;
	PVOID       pvsi;

	// ScriptBreak's
	//
	PVOID       pvsla;

	// ScriptShape & Place's
	//
	PVOID       pvwgi;
	PVOID		pvsva;
	PVOID		pvcluster;
	PVOID		pvidx;
	PVOID		pvgoffset;

	// subtable ptrs
	//
	PUSP_CLIENT_SI      pc_si;
	PUSP_CLIENT_SB      pc_sb;
	PUSP_CLIENT_SSP		pc_ssp;


#define RQ_COUNT    	12

	BUF_REQ     brq[RQ_COUNT] =
	{
		// table and subtable blocks
		//
		{ sizeof(USP_CLIENT),                                                             1, (void**)ppc},
		{ sizeof(USP_CLIENT_SI),    dwMask & cli_Itemize    ? 1                         : 0, (void**)&pc_si},
		{ sizeof(USP_CLIENT_SB),    dwMask & cli_Break      ? 1                         : 0, (void**)&pc_sb},
		{ sizeof(USP_CLIENT_SSP),   dwMask & cli_ShapePlace ? 1                         : 0, (void**)&pc_ssp},

		// data blocks
		//
		{ sizeof(WCHAR),            dwMask & cli_string     ? cchString + 1             : 0, &pvString},
		{ sizeof(SCRIPT_ITEM),      dwMask & cli_psi        ? cchString + 1             : 0, &pvsi},
		{ sizeof(SCRIPT_LOGATTR),   dwMask & cli_psla       ? cchString + 1             : 0, &pvsla},
		{ sizeof(WORD),				dwMask & cli_pwgi       ? GLYPH_COUNT(cchString+1)	: 0, &pvwgi},
		{ sizeof(SCRIPT_VISATTR),   dwMask & cli_psva       ? GLYPH_COUNT(cchString+1)	: 0, &pvsva},
		{ sizeof(WORD),				dwMask & cli_pcluster   ? cchString + 1				: 0, &pvcluster},
		{ sizeof(int),				dwMask & cli_pidx       ? GLYPH_COUNT(cchString+1)	: 0, &pvidx},
		{ sizeof(GOFFSET),			dwMask & cli_pgoffset   ? GLYPH_COUNT(cchString+1)	: 0, &pvgoffset},
	};

	// count total buffer size in byte (WORD aligned)
	//
	for (i=0, cbSize=0; i < RQ_COUNT; i++)
	{
		cbSize += ALIGN(brq[i].size * brq[i].c);
	}

	// allocate the whole buffer at once
	//
	if (cbSize > cbBufIn)
	{
		pbBlock = (PBYTE)PvAlloc(cbSize, 0);
	}
	else
	{
		pbBlock = pbBufIn;
	}

	if (!pbBlock)
	{
		//
		// memory management failed!
		//
		TRACEERRORSZ("Allocation failed in CreateClientStruc!\n");
		*ppc = NULL;
		return FALSE;
	}

	
	// clear the main table
	ZeroMemory (pbBlock, sizeof(USP_CLIENT));


	// assign ptrs in buffer request structure
	//
	for (i=0; i < RQ_COUNT; i++)
	{
		if (brq[i].c > 0)
		{
			*brq[i].ppv = pbBlock;
			pbBlock += ALIGN(brq[i].size * brq[i].c);
		}
		else
		{
			*brq[i].ppv = NULL;
		}
	}

	Assert(((PBYTE)(*ppc)+cbSize == pbBlock));

	// fill in data block ptrs in subtable
	//
	if (pc_si)
	{
		pc_si->pwchString   = (WCHAR*)          pvString;
		pc_si->cchString    =                   cchString;
		pc_si->psi          = (SCRIPT_ITEM*)    pvsi;
	}

	if (pc_sb)
	{
		pc_sb->psla         = (SCRIPT_LOGATTR*) pvsla;
	}

	if (pc_ssp)
	{
		pc_ssp->pwgi		= (WORD*) 			pvwgi;
		pc_ssp->psva		= (SCRIPT_VISATTR*)	pvsva;
		pc_ssp->pcluster	= (WORD*) 			pvcluster;
		pc_ssp->pidx		= (int*)			pvidx;
		pc_ssp->pgoffset	= (GOFFSET*)		pvgoffset;
	}

	// fill in subtable ptrs in header table
	//
	(*ppc)->si              = (PUSP_CLIENT_SI)  pc_si;
	(*ppc)->sb              = (PUSP_CLIENT_SB)  pc_sb;
	(*ppc)->ssp             = (PUSP_CLIENT_SSP) pc_ssp;

	return TRUE;
}


///////	CBidiFSM class implementation
//
//		Create: Worachai Chaoweeraprasit(wchao), Jan 29, 1998
//

CBiDiFSM::~CBiDiFSM ()
{
	FreePv(_pStart);
}


INPUT_CLASS CBiDiFSM::InputClass (
	const CCharFormat*	pcCF,
	CTxtPtr*			ptp,
	LONG				cchRun) const
{
	if (!_pusp->IsValid() || !pcCF || pcCF->_wScript == SCRIPT_WHITE)
		return chGround;

	const SCRIPT_PROPERTIES* psp = _pusp->GeteProp(pcCF->_wScript);
	BYTE 	bCharSet = pcCF->_bCharSet;

	if (psp->fControl)
	{
		if (cchRun == 1)
			switch (ptp->GetChar())				// single-char run
			{
				case LTRMARK: return chLTR;		// \ltrmark
				case RTLMARK: return chRTL;		// \rtlmark
			}
		return chGround;
	}

	if (IsSymbolOrOEM(bCharSet) || IsFECharSet(bCharSet) || pcCF->_dwEffects & CFE_RUNISDBCS)
		return chLTR;

	if (psp->fNumeric)
		// Numeric digits
		return IsBiDiCharSet(psp->bCharSet) || IsBiDiCharSet(bCharSet) ? digitRTL : digitLTR;

	// RTL if it's RTL script or its format charset is RTL and NOT a simplified script
	return IsBiDiCharSet(psp->bCharSet) || pcCF->_wScript && IsBiDiCharSet(bCharSet) ? chRTL : chLTR;
}

// The FSM generates run's embedding level based on given base level and puts it
// in CFormatRun. LsFetchRun is the client using this result.
//
#ifdef DEBUG
//#define DEBUG_LEVEL
#endif

#ifdef DEBUG_LEVEL
void DebugLevel (CBiDiFSMCell* pCell)
{
	Tracef(TRCSEVNONE, "%d,", pCell->_level._value);
}
#else
#define DebugLevel(x)
#endif

HRESULT CBiDiFSM::RunFSM (
	CRchTxtPtr*			prtp,				// in: text pointer to start run
	LONG				cRuns,				// in: number of FSM run
	LONG				cRunsStart,			// in: number of start run
	BYTE				bBaseLevel) const	// in: base level
{
	Assert (prtp->_rpCF.IsValid() && cRuns > 0);

	CRchTxtPtr				rtp(*prtp);
	const CCharFormat*      pCF;
	LONG					cchRun;
	LONG					cRunsAll = cRuns + cRunsStart;
	CBiDiFSMCell*           pCell;
	USHORT                  ucState = bBaseLevel ? S_X * NUM_FSM_INPUTS : 0;
	BOOL					fNext = TRUE;


	// loop thru FSM
	for (; fNext && cRunsAll > 0; cRunsAll--, fNext = !!rtp.Advance(cchRun))
	{
		cchRun = rtp.GetCchLeftRunCF();
	
		pCF = rtp.GetPed()->GetCharFormat(rtp._rpCF.GetFormat());
	
		ucState += InputClass(pCF, &rtp._rpTX, cchRun);

		pCell = &_pStart[ucState];

		// set level to FSM runs
		if (cRunsAll <= cRuns)
			rtp._rpCF.SetLevel (pCell->_level);

		DebugLevel(pCell);

		ucState = pCell->_uNext;	// next state
	}

	return S_OK;
}

// Construct the BiDi embedding level FSM (FSM details see bidifsm2.html)
// :FSM's size = NUM_FSM_INPUTS * NUM_FSM_STATES * sizeof(CBiDiFSMCell) = 6*5*4 = 120 bytes
//
BOOL CBiDiFSM::Init()
{
	CBiDiFSMCell*   pCell;
	int             i;

	// Build the Bidi FSM

	_nState = NUM_FSM_STATES;
	_nInput = NUM_FSM_INPUTS;

	pCell = (CBiDiFSMCell*)PvAlloc(NUM_FSM_STATES * NUM_FSM_INPUTS * sizeof(CBiDiFSMCell), 0);

	if (!pCell)
		return FALSE;	// unable to create FSM!

	_pStart = pCell;


	CBiDiLevel		lvlZero		= {0,0};
	CBiDiLevel		lvlOne  	= {1,0};
	CBiDiLevel		lvlTwo  	= {2,0};
	CBiDiLevel		lvlTwoStart	= {2,1};


	// State A(0): LTR char in LTR para
	//
	for (i=0; i < NUM_FSM_INPUTS; i++, pCell++)
	{
		switch (i)
		{
			case chLTR:
				SetFSMCell(pCell, &lvlZero, 0); break;
			case chRTL:
				SetFSMCell(pCell, &lvlOne, S_B * NUM_FSM_INPUTS); break;
			case digitLTR:
				SetFSMCell(pCell, &lvlZero, 0); break;
			case digitRTL:
				SetFSMCell(pCell, &lvlTwo, S_C * NUM_FSM_INPUTS); break;
			case chGround:
				SetFSMCell(pCell, &lvlZero, 0); break;
		}
	}
	// State B(1): RTL char in LTR para
	//
	for (i=0; i < NUM_FSM_INPUTS; i++, pCell++)
	{
		switch (i)
		{
			case chLTR:
				SetFSMCell(pCell, &lvlZero, 0); break;
			case chRTL:
				SetFSMCell(pCell, &lvlOne, S_B * NUM_FSM_INPUTS); break;
			case digitLTR:
				SetFSMCell(pCell, &lvlZero, 0); break;
			case digitRTL:
				SetFSMCell(pCell, &lvlTwo, S_C * NUM_FSM_INPUTS); break;
			case chGround:
				SetFSMCell(pCell, &lvlZero, 0); break;
		}
	}
	// State C(2): RTL number run in LTR para
	//
	for (i=0; i < NUM_FSM_INPUTS; i++, pCell++)
	{
		switch (i)
		{
			case chLTR:
				SetFSMCell(pCell, &lvlZero, 0); break;
			case chRTL:
				SetFSMCell(pCell, &lvlOne, S_B * NUM_FSM_INPUTS); break;
			case digitLTR:
				SetFSMCell(pCell, &lvlZero, 0); break;
			case digitRTL:
				SetFSMCell(pCell, &lvlTwo, S_C * NUM_FSM_INPUTS); break;
			case chGround:
				SetFSMCell(pCell, &lvlZero, 0); break;
		}
	}
	// State X(1): RTL char in RTL para
	//
	for (i=0; i < NUM_FSM_INPUTS; i++, pCell++)
	{
		switch (i)
		{
			case chLTR:
				SetFSMCell(pCell, &lvlTwo, S_Y * NUM_FSM_INPUTS); break;
			case chRTL:
				SetFSMCell(pCell, &lvlOne, S_X * NUM_FSM_INPUTS); break;
			case digitLTR:
				SetFSMCell(pCell, &lvlTwo, S_Y * NUM_FSM_INPUTS); break;
			case digitRTL:
				SetFSMCell(pCell, &lvlTwo, S_Z * NUM_FSM_INPUTS); break;
			case chGround:
				SetFSMCell(pCell, &lvlOne, S_X * NUM_FSM_INPUTS); break;
		}
	}
	// State Y(2): LTR char in RTL para
	//
	for (i=0; i < NUM_FSM_INPUTS; i++, pCell++)
	{
		switch (i)
		{
			case chLTR:
				SetFSMCell(pCell, &lvlTwo, S_Y * NUM_FSM_INPUTS); break;
			case chRTL:
				SetFSMCell(pCell, &lvlOne, S_X * NUM_FSM_INPUTS); break;
			case digitLTR:
				SetFSMCell(pCell, &lvlTwo, S_Y * NUM_FSM_INPUTS); break;
			case digitRTL:
				SetFSMCell(pCell, &lvlTwoStart, S_Z * NUM_FSM_INPUTS); break;
			case chGround:
				SetFSMCell(pCell, &lvlOne, S_X * NUM_FSM_INPUTS); break;
		}
	}
	// State Z(2): RTL number in RTL para
	//
	for (i=0; i < NUM_FSM_INPUTS; i++, pCell++)
	{
		switch (i)
		{
			case chLTR:
				SetFSMCell(pCell, &lvlTwoStart, S_Y * NUM_FSM_INPUTS); break;
			case chRTL:
				SetFSMCell(pCell, &lvlOne, S_X * NUM_FSM_INPUTS); break;
			case digitLTR:
				SetFSMCell(pCell, &lvlTwoStart, S_Y * NUM_FSM_INPUTS); break;
			case digitRTL:
				SetFSMCell(pCell, &lvlTwo, S_Z * NUM_FSM_INPUTS); break;
			case chGround:
				SetFSMCell(pCell, &lvlOne, S_X * NUM_FSM_INPUTS); break;
		}
	}

	AssertSz(&pCell[-(NUM_FSM_STATES * NUM_FSM_INPUTS)] == _pStart, "Bidi FSM incomplete constructed!");

	return TRUE;
}


///////	CCallbackBufferBase class implementation
//

void* CBufferBase::GetPtr(int cel)
{
	if (_cElem < cel)
	{
		cel += celAdvance;

		_p = PvReAlloc(_p, cel * _cbElem);
		if (!_p)
			return NULL;
		ZeroMemory(_p, cel * _cbElem);
		_cElem = cel;
	}
	return _p;
}

void CBufferBase::Release()
{
	if (_p)
		FreePv(_p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\txtbrk.cpp ===
/*
 *		Text Breaker & Bit stream break array class implementation
 *		
 *		File:    txtbrk.cpp
 * 		Create:  Mar 29, 1998
 *		Author:  Worachai Chaoweeraprasit (wchao)
 *
 *		Copyright (c) 1998, Microsoft Corporation. All rights reserved.
 */


//#include "stdafx.h"
//#include "Array.h"

#include "_common.h"

#ifndef BITVIEW
#include "_frunptr.h"
#include "_range.h"
#include "_notmgr.h"
#endif
#include "_txtbrk.h"

CBreakArray::CBreakArray()
{
	_ibGap = 0;
	_cbGap = 0;
	_cbSize = 0;
	_cbBreak = 0;
}

inline ITEM* CBreakArray::Elem(LONG iel) const
{
	Assert(iel < Count());
	return iel < Count() ? CArray<ITEM>::Elem(iel) : NULL;
}

void CBreakArray::CheckArray ()
{
	if (!IsValid())
	{
		// Add the first element. This is required to be a sentinel.
		Add(1, NULL);
	}
}

// Remove <cchOld> and insert <cchNew> break items at <cp>
LONG CBreakArray::ReplaceBreak (
	LONG	cp, 				// insertion cp
	LONG	cchOld,				// number of break item to be deleted
	LONG	cchNew)				// number of break item to be inserted
{
	PUSH_STATE(cp, cchNew, REPLACER);

	if (!cchOld && cchNew)
		return VALIDATE(InsertBreak (cp, cchNew));
	if (cchOld && !cchNew)
		return VALIDATE(RemoveBreak (cp, cchOld));

	LONG	cRep = 0;		// number of new break inserted after replacing

	if (cchOld > cchNew)
	{
		cRep = RemoveBreak(cp+cchNew, cchOld-cchNew);
		ClearBreak(cp, cchNew);
	}
	else if (cchOld < cchNew)
	{
		cRep = InsertBreak(cp+cchOld, cchNew-cchOld);
		ClearBreak(cp, cchOld);
	}
	else if (cchNew)
    {
		ClearBreak(cp, cchNew);
	}
	return VALIDATE(cRep);
}


// Add <cch> break items at <cp>
// note: This routine assumes there is no gap left in the bit array
LONG CBreakArray::AddBreak(
	LONG	cp,
	LONG	cch)
{
	Assert (cp == _cbBreak);
	LONG	cchAdd = min(cch, _cbSize - _cbBreak);
	LONG	c;

	_cbBreak += cchAdd;
	cch -= cchAdd;
	if (cch > 0)
	{
		cp += cchAdd;
		c = (cch + RSIZE-1)/RSIZE;
		Insert (cp / RSIZE, c);
		_cbSize += c * RSIZE;
		_cbBreak += cch;
		cchAdd += cch;
	}
	return cchAdd;
}


// Insert <cch> break items at <cp>
// <detail see: bitrun.html>
LONG CBreakArray::InsertBreak (
	LONG	cp, 				// insertion point cp
	LONG	cch)				// number of break item to be inserted
{
	LONG	cIns = 0;			// number of break inserted
	ITEM	*peli, *pelj;
	LONG	cchSave = cch;

	PUSH_STATE(cp, cch, INSERTER);

	// Make sure we establish the array
	CheckArray();

	if (cp == _ibGap)
	{
		// The insertion takes place at the gap,
		// reposition and shrink the gap down
		for (cIns=0 ; cch > 0 && cIns < _cbGap; cIns++, cch--, cp++)
		{
			peli = Elem(cp / RSIZE);
			*peli &= ~(1<<(cp % RSIZE));
		}
		_cbGap -= cIns;
		_ibGap += cIns;
		_cbBreak += cIns;
	}
	else
	{
		// The insertion point is outside the gap,
		// Collapse the gap and go as normal.
		CollapseGap();
	}
	
	if (cch <= 0)
		return VALIDATE(cIns);

	if (cp == _cbBreak)
		return VALIDATE(cIns + AddBreak(cp, cch));

	Assert (_cbGap == 0 && cp < _cbBreak);

	LONG	cit = (cch+RSIZE-1) / RSIZE;
	LONG	i = cp / RSIZE;
	LONG	j;
	ITEM	uh, ul;				// H: high-mask after cp, L: low-mask before cp

	// Insert items
	Insert (i+1, cit);
	cIns += (cit * RSIZE);

	// Get the [i]
	peli = Elem(i);

	// Create the high/low mask & keep the masked values
	ul = MASK_LOW (-1, cp % RSIZE);
	uh = ~ul;
	ul &= *peli;
	uh &= *peli;

	// Reference the [j]
	j = i + cit;

	// Move L to [i]; move H to [j]
	*peli = ul;
	pelj = Elem(j);
	Assert (pelj);
	*pelj = uh;

	// Calculate gap position
	_ibGap = cp + (cch / RSIZE) * RSIZE;
	_cbGap = cit*RSIZE - cch;

	Assert(_cbGap < RSIZE && cIns - _cbGap == cchSave);

	_cbSize += (cIns - cchSave + cch);
	_cbBreak += cch;

	return VALIDATE(cIns - _cbGap);
}

// Remove <cch> break items at <cp>
// <detail see: bitrun.html>
LONG CBreakArray::RemoveBreak (
	LONG	cp, 				// deletion point cp
	LONG	cch)				// number of break item to be deleted
{
	Assert (IsValid() && cp + cch <= _cbBreak);

	PUSH_STATE(cp, cch, REMOVER);

	LONG	i = cp / RSIZE;
	LONG	j;
	LONG	cDel = 0;			// number of break deleted

	if (cp == _ibGap)
	{
		// The deletion takes place at the gap,
		// reposition and expand the gap
		cDel = cch;
		_cbGap += cch;
		_cbBreak -= cch;
		cch = 0;

		// Optimise the gap size:
		// Keep the gap small so we dont spend much time collapsing it.
		j = (_ibGap+_cbGap) / RSIZE - i - 1;
		if (j > 0)
		{
			Remove(i+1, j);
			_cbGap -= j * RSIZE;
			_cbSize -= j * RSIZE;
		}
	}
	else
	{
		// The deletion point is outside the gap,
		// Collapse the gap and go as normal.
		CollapseGap();
	}

	if (!cch)
		return VALIDATE(-cDel);

	LONG	cit = cch / RSIZE;
	ITEM	uh, ul;				// H: high-mask after cp, L: low-mask before cp
	ITEM	*peli, *pelj;

	j = (cp+cch) / RSIZE;

	// Get the [i] and [j]
	peli = Elem(i);
	pelj = Elem(j);

	// Create the high/low mask & keep the masked values
	ul = MASK_LOW (-1, cp % RSIZE);
	uh = ~MASK_LOW (-1, (cp+cch) % RSIZE);
	ul &= *peli;
	uh &= pelj ? *pelj : 0;

	// Remove <cch/RSIZE> items
	if (cit)
	{
		Remove(i, cit);
		cDel += (cit * RSIZE);
	}

	// Zero [i]
	peli = Elem(i);
	*peli = 0;

	// Reference the (new) [j]
	j -= cit;

	// Move H to [j]
	pelj = Elem(j);
	if (pelj)
		*pelj = uh;

	// Or L to [i]
	*peli |= ul;


	// Calculate gap position
	_ibGap = cp;
	_cbGap = cch % RSIZE;

	Assert(_cbGap < RSIZE && cDel + _cbGap == cch);

	_cbSize -= cDel;
	_cbBreak -= cch;

	return VALIDATE(-cDel - _cbGap);
}


// Determine if we can break between char[cp-1] and [cp]
BOOL CBreakArray::GetBreak (LONG cp)
{
	if (!IsValid() || cp >= _cbBreak)
		return FALSE;

	cp += cp < _ibGap ? 0 : _cbGap;

	if (cp / RSIZE < Count() - 1)
		return GetAt(cp / RSIZE) & (1<<(cp % RSIZE));
	return FALSE;
}

// Set break at cp, so it's breakable between char[cp-1] and [cp]
void CBreakArray::SetBreak (LONG cp, BOOL fOn)
{
	if (cp >= _cbBreak)
		return;

	CheckArray();

	cp += cp < _ibGap ? 0 : _cbGap;

	ITEM	*pel = Elem(cp / RSIZE);
	*pel = fOn ? *pel | (1<<(cp % RSIZE)) : *pel & ~(1<<(cp % RSIZE));
}

// Clear break in range <cch> start at position <cp>
void CBreakArray::ClearBreak (
	LONG	cp,
	LONG	cch)
{
	if (!cch)
		return;

	Assert (cch > 0 && cp < _cbBreak);
	CheckArray();

	cp += cp < _ibGap ? 0 : _cbGap;
	cch += cp < _ibGap && cp + cch > _ibGap ? _cbGap : 0;

	LONG 	i = cp / RSIZE;
	LONG	j = (cp+cch) / RSIZE;
	ITEM	uMaskl, uMaskh;
	ITEM	*pel;

	uMaskl = MASK_LOW(-1, cp % RSIZE);
	uMaskh = ~MASK_LOW(-1, (cp+cch) % RSIZE);

	if (i==j)
	{
		uMaskl |= uMaskh;
		uMaskh = uMaskl;
	}

	// clear first item
	pel = Elem(i);
	*pel &= uMaskl;
	
	if (uMaskh != (ITEM)-1)
	{
		// clear last item
		pel = Elem(j);
		*pel &= uMaskh;
	}

	// clear items in between
	i++;
	while (i < j)
	{
		pel = Elem(i);
		*pel = 0;
		i++;
	}
}

// Collapse the gap down to 0 using bit shifting
// (using the 'bits remove with shifting' algorithm)
//
LONG CBreakArray::CollapseGap ()
{
#ifdef BITVIEW
	_cCollapse++;
#endif
	if (_cbGap == 0)
		return 0;		// No gap

	PUSH_STATE(0, 0, COLLAPSER);

	LONG	cit = _cbGap / RSIZE;
	LONG	i = _ibGap / RSIZE;
	LONG	j = (_ibGap+_cbGap) / RSIZE;
	LONG	cDel = 0;			// number of break deleted
	ITEM	uh, ul;				// H: high-mask after cp, L: low-mask before cp
	ITEM	*peli, *pelj;

	Assert (IsValid());

	// Get the [i] and [j]
	peli = Elem(i);
	pelj = Elem(j);

	// Create the high/low mask & keep the masked values
	ul = MASK_LOW (-1, _ibGap % RSIZE);
	uh = ~MASK_LOW (-1, (_ibGap+_cbGap) % RSIZE);
	ul &= *peli;
	uh &= pelj ? *pelj : 0;

	// Remove items
	if (cit)
	{
		Remove(i, cit);
		cDel += (cit * RSIZE);
		_cbSize -= cDel;
		if (!_cbSize)
			return VALIDATE(cDel);
	}

	// Zero [i]
	peli = Elem(i);
	*peli = 0;

	// Reference the (new) [j]
	j -= cit;

	cit = Count() - 1;

	// Move H to [j]
	pelj = Elem(j);
	if (pelj)
		*pelj = uh;

	// Shifting bits down <cit-i> items starting@[i]
	ShDn(i, cit-i, _cbGap % RSIZE);
	cDel += (_cbGap % RSIZE);

	// Or L to [i]
	*peli |= ul;

	Assert (cit > 0 && cDel == _cbGap);

	_cbGap = 0;

	if (_cbSize - _cbBreak > RSIZE)
	{
		// The last item was shifted til empty.
		// No need to keep it around.
		Remove(cit-1, 1);
		_cbSize -= RSIZE;
	}

	return VALIDATE(0);
}

// Shifting <cel> dword n bits UPWARD
void CBreakArray::ShUp (LONG iel, LONG cel, LONG n)
{
	if (n < RSIZE)
	{
		ITEM	*pel;
		ITEM	uo;				// shifting overflow
		ITEM	ua = 0;			// shifting addendum
		ITEM	uMask = MASK_HIGH(-1, n);
	
		while (cel > 0)
		{
			pel = Elem(iel);
			Assert (pel);
			uo = (*pel & uMask) >> (RSIZE-n);
			*pel = (*pel << n) | ua;
			ua = uo;
			iel++;
			cel--;
		}
	}
}

// Shifting <cel> dword n bits DOWNWARD
void CBreakArray::ShDn (LONG iel, LONG cel, LONG n)
{
	if (n < RSIZE)
	{
		ITEM	*pel;
		ITEM	uo;				// shifting overflow
		ITEM	ua = 0;			// shifting addendum
		ITEM	uMask = MASK_LOW(-1, n);
	
		iel += cel-1;
		while (cel > 0)
		{
			pel = Elem(iel);
			Assert (pel);
			uo = (*pel & uMask) << (RSIZE-n);
			*pel = (*pel >> n) | ua;
			ua = uo;
			iel--;
			cel--;
		}
	}
}

#ifdef BVDEBUG
LONG CBreakArray::Validate (LONG cchRet)
{										
	Assert(_cbSize >= 0 && (Count() - 1)*RSIZE == _cbSize);
	Assert(_cbBreak - _s.cbBreak == cchRet);
	return cchRet;
}										

void CBreakArray::PushState (LONG cp, LONG cch, LONG who)
{
	_s.who = who;
	_s.ibGap = _ibGap;
	_s.cbGap = _cbGap;
	_s.cbSize = _cbSize;
	_s.cbBreak = _cbBreak;
	_s.cp = cp;
	_s.cch = cch;
}
#endif

#ifdef BITVIEW
LONG CBreakArray::SetCollapseCount ()
{
	LONG cc = _cCollapse;
	_cCollapse = 0;
	return cc;
}
#endif


#ifndef BITVIEW

/////// CTxtBreaker class implementation
//		
//
CTxtBreaker::CTxtBreaker(
	CTxtEdit*	ped)
{
	// Register ourself in the notification list
	// so we get notified when backing store changed.

	CNotifyMgr *pnm = ped->GetNotifyMgr();
	if(pnm)
		pnm->Add((ITxNotify *)this);

	_ped = ped;
}

CTxtBreaker::~CTxtBreaker()
{
	CNotifyMgr *pnm = _ped->GetNotifyMgr();

	if(pnm)
		pnm->Remove((ITxNotify *)this);

	// Clear break arrays
	if (_pbrkWord)
	{
		_pbrkWord->Clear(AF_DELETEMEM);
		delete _pbrkWord;
	}
	if (_pbrkChar)
	{
		_pbrkChar->Clear(AF_DELETEMEM);
		delete _pbrkChar;
	}
}

// Adding the breaker
// return TRUE means we plug something in.
BOOL CTxtBreaker::AddBreaker(
	UINT		brkUnit)
{
	BOOL		fr = FALSE;
	CUniscribe* pusp = _ped->Getusp();

	if (pusp && pusp->IsValid())
	{
		// Initialize proper bit mask used to test breaking bits
		if (!_pbrkWord && (brkUnit & BRK_WORD))
		{
			_pbrkWord = new CBreakArray();
			Assert(_pbrkWord);
			if (_pbrkWord)
				fr = TRUE;
		}
		if (!_pbrkChar && (brkUnit & BRK_CLUSTER))
		{
			_pbrkChar = new CBreakArray();
			Assert(_pbrkChar);
			if (_pbrkChar)
				fr = TRUE;
		}
	}
	return fr;
}

// <devnote:> The "cluster" break array actually contains invert logic.
// This is for speed since it's likely to be a sparse array.
CTxtBreaker::CanBreakCp(
	BREAK_UNIT	brk, 	// kind of break
	LONG		cp)		// given cp
{
	Assert (brk != BRK_BOTH);
	if (brk == BRK_WORD && _pbrkWord)
		return _pbrkWord->GetBreak(cp);
	if (brk == BRK_CLUSTER && _pbrkChar)
		return !_pbrkChar->GetBreak(cp);
	return FALSE;
}

void CTxtBreaker::OnPreReplaceRange (
	LONG	cp,
	LONG	cchDel,
	LONG	cchNew,
	LONG	cpFormatMin,
	LONG	cpFormatMax)
{
#ifdef DEBUG
	if (_pbrkWord)
		Assert (_pbrkWord->GetCchBreak() == _ped->GetTextLength());
	if (_pbrkChar)
		Assert (_pbrkChar->GetCchBreak() == _ped->GetTextLength());
#endif
}


// Sync up the breaking result of each available breaker.
void CTxtBreaker::Refresh()
{
	CBreakArray*	pbrk = _pbrkWord;
	LONG			len = _ped->GetTextLength();

	for (int i=0; i<2; i++)
	{
		if (pbrk && pbrk->GetCchBreak())
		{
			// (temporarily) collapse the breaking result
			pbrk->RemoveBreak(0, len);
		}
		pbrk = _pbrkChar;
	}
	// Now announce the new coming text of the whole document.
	// (we recalculate both results at once here since the ScriptBreak returns
	// both kind of information in one call. No need to slow thing down by making 2 calls.)
	OnPostReplaceRange(0, 0, len, 0, 0);
}

	
// This method gets called once backing store changed.
// Produce correct breaking positions for the text range effected by the change.
//
void CTxtBreaker::OnPostReplaceRange (
	LONG	cp,
	LONG	cchDel,
	LONG	cchNew,
	LONG	cpFormatMin,
	LONG	cpFormatMax)
{
	if (!cchDel && !cchNew)
		return;

#ifdef DEBUG
	LONG	cchbrkw = _pbrkWord ? _pbrkWord->GetCchBreak() : 0;
	LONG	cchbrkc = _pbrkChar ? _pbrkChar->GetCchBreak() : 0;
#endif

	CTxtPtr			tp(_ped, cp);
	LONG			cpBreak = cp > 0 ? cp - 1 : 0;
	CBreakArray*	pSyncObj = NULL;		// Break object to retrieve sync point
	LONG			cBrks = 1, cBrksSave;
	BOOL			fStop = TRUE;			// default: looking for stop
	LONG			cpStart, cpEnd;

	
	// Figure a boundary limited by whitespaces
	tp.FindWhiteSpaceBound(cchNew, cpStart, cpEnd);


	Assert (_pbrkWord || _pbrkChar);

	// Use wordbreak array (if available) to figure sync point,
	// otherwise use cluster break array
	if (_pbrkWord)
	{
		pSyncObj = _pbrkWord;
		cBrks = CWORD_TILLSYNC;
	}
	else if (_pbrkChar)
	{
		pSyncObj = _pbrkChar;
		cBrks = CCLUSTER_TILLSYNC;
		
		// for perf reason, we kept cluster breaks in invert logic.
		// Logic TRUE in the array means "NOT A CLUSTER BREAK". The array is
		// like a sparse metric full of 0.
		fStop = FALSE;
	}

	// Figure sync point so we can go from there.
	cBrksSave = cBrks;
	while (pSyncObj && cpBreak > cpStart)
	{
		if (pSyncObj->GetBreak(cpBreak) == fStop)
			if (!cBrks--)
				break;
		cpBreak--;
	}

	cpStart = cpBreak;
	tp.SetCp(cpStart);

	cBrks = cBrksSave;

	// adjust the end boundary to the state of break array.
	cpEnd -= cchNew - cchDel;
	cpBreak = cp + cchDel;
	while (pSyncObj && cpBreak < cpEnd)
	{
		if (pSyncObj->GetBreak(cpBreak) == fStop)
			if (!cBrks--)
				break;
		cpBreak++;
	}
	cpEnd = cpBreak;

	// adjust the end boundary back to the state of the backing store.
	cpEnd -= cchDel - cchNew;

	Assert (cpStart >= 0 && cpEnd >= 0 && cpStart <= cpEnd);

	if (cpStart == cpEnd)
	{
		// This is deletion process
		if (_pbrkWord)
			_pbrkWord->ReplaceBreak(cp, cchDel, 0);
		if (_pbrkChar)
			_pbrkChar->ReplaceBreak(cp, cchDel, 0);
	}
	else
	{
		CUniscribe*					pusp;
		const SCRIPT_PROPERTIES*	psp;
		SCRIPT_ITEM*				pi;
		SCRIPT_LOGATTR*				pl;
		PUSP_CLIENT					pc = NULL;
		BYTE						pbBufIn[MAX_CLIENT_BUF];
		WCHAR*						pwchString;
		LONG						cchString = cpEnd - cpStart;
		int							cItems;

		// Now with the minimum range, we begin itemize and break the word/clusters.
		// :The process is per item basis.
	
		// prepare Uniscribe
		pusp = _ped->Getusp();
		if (!pusp)
		{
			// No Uniscribe instance allowed to be created.
			// We failed badly!
			Assert (FALSE);
			return;
		}
	
		// allocate temp buffer for itemization
		pusp->CreateClientStruc(pbBufIn, MAX_CLIENT_BUF, &pc, cchString, cli_Itemize | cli_Break);
		if (!pc)
			// nom!
			return;
	
		Assert (tp.GetCp() == cpStart);
	
		tp.GetText(cchString, pc->si->pwchString);

		if (pusp->ItemizeString (pc, 0, &cItems, pc->si->pwchString, cchString, 0) > 0)
		{
			// Prepare room in the break array(s) to put the break results
			if (_pbrkWord)
				_pbrkWord->ReplaceBreak (cp, cchDel, cchNew);
			if (_pbrkChar)
				_pbrkChar->ReplaceBreak (cp, cchDel, cchNew);
	
			// Initial working pointers
			pi = pc->si->psi;
			pwchString = pc->si->pwchString;
			pl = pc->sb->psla;
	
			for (int i=0; i < cItems; i++)
			{
				psp = pusp->GeteProp(pi[i].a.eScript);
				if (psp->fComplex &&
					(psp->fNeedsWordBreaking || psp->fNeedsCaretInfo))
				{
					// Break only the item needing text break
					if ( ScriptBreak(&pwchString[pi[i].iCharPos], pi[i+1].iCharPos - pi[i].iCharPos,
									&pi[i].a, pl) != S_OK )
					{
						TRACEWARNSZ ("Calling ScriptBreak FAILED!");
						break;
					}
					// Fill in the breaking result
					cp = cpStart + pi[i].iCharPos;
					for (int j = pi[i+1].iCharPos - pi[i].iCharPos - 1; j >= 0; j--)
					{
						if (_pbrkWord)
							_pbrkWord->SetBreak(cp+j, pl[j].fWordStop);
						if (_pbrkChar)
							_pbrkChar->SetBreak(cp+j, !pl[j].fCharStop);
					}
				}
				else
				{
					// Note: ClearBreak is faster than ZeroMemory the CArray::ArInsert()
					if (_pbrkWord)
						_pbrkWord->ClearBreak(cpStart + pi[i].iCharPos, pi[i+1].iCharPos - pi[i].iCharPos);
					if (_pbrkChar)
						_pbrkChar->ClearBreak(cpStart + pi[i].iCharPos, pi[i+1].iCharPos - pi[i].iCharPos);
				}
			}
		}
	
		if (pc && pbBufIn != (BYTE*)pc)
			delete pc;
	}

#ifdef DEBUG
	if (_pbrkWord)
		Assert (_pbrkWord->GetCchBreak() - cchbrkw == cchNew - cchDel);
	if (_pbrkChar)
		Assert (_pbrkChar->GetCchBreak() - cchbrkc == cchNew - cchDel);
#endif
}

#endif	// !BITVIEW
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\urlsup.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module	URLSUP.CPP	URL detection support |
 *
 *	Author:	alexgo 4/3/96
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_urlsup.h"
#include "_m_undo.h"
#include "_select.h"
#include "_clasfyc.h"

ASSERTDATA

// Arrays for URL detection.  The first array is the protocols
// we support, followed by the "size" of the array.
// NB!! Do _not_ modify these arrays without first making sure
// that the code in ::IsURL is updated appropriately.


/*
FUTURE (keithcu)
We should generalize our support to recognize URLs of the following type:

Maybe we should do autocorrect so that:
keithcu@microsoft.com converts to mailto:keithcu@microsoft.com
Should we put this code in PutChar rather than here?

What about URLs of the form "seattle.sidewalk.com"? Word doesn't support this yet.
It is hard because do you look for the .com? What happens when .com, .edu, .gov,
etc. aren't the only suffixes anymore?

What about the interaction with notifications?
We should add support for purple text. CFE_LINKVISITED
*/

//Includes both types of URLs
const int MAXURLHDRSIZE	= 9;

//Most of these can just be passed right to the client--but some need a prefix.
//Can we automatically add that tag when it needs it?
const LPCWSTR rgszURL[] = {
	L"http:",
	L"file:",
	L"mailto:",
	L"ftp:",
	L"https:",
	L"gopher:",
	L"nntp:",
	L"prospero:",
	L"telnet:",
	L"news:",
	L"wais:",
	L"outlook:"
};
const char rgcchURL[] = {
	5,
	5,
	7,
	4,
	6,
	7,
	5,
	9,
	7,
	5,
	5,
	8
};

#define NUMURLHDR		sizeof(rgcchURL)

//
//The XXX. URLs
//
const LPCWSTR rgszDOTURL[] = {
	L"www.",
	L"ftp.",
};

const char rgcchDOTURL[] = {
	4,
	4,
};

#define NUMDOTURLHDR		sizeof(rgcchDOTURL)


inline BOOL IsURLWhiteSpace(WCHAR ch)
{
	if (IsWhiteSpace(ch))
		return TRUE;

	// See RAID 6304.  MSKK doesn't want CJK in URLs.  We do what we did in 2.0
	if ( ch >= 0x03000 && !IsKorean(ch) )
		return TRUE;

	INT iset = GetKinsokuClass(ch);
	return iset == 10 || (iset == 14 && ch != WCH_EMBEDDING);
}

/*
 *	CDetectURL::CDetectURL (ped)
 *
 *	@mfunc	constructor; registers this class in the notification manager.
 *
 *	@rdesc	void
 */
CDetectURL::CDetectURL(
	CTxtEdit *ped)		//@parm edit context to use
{
	CNotifyMgr *pnm = ped->GetNotifyMgr();
	if(pnm)
		pnm->Add((ITxNotify *)this);

	_ped = ped;
}

/*
 *	CDetectURL::~CDetectURL
 *
 *	@mfunc	destructor; removes ths class from the notification manager
 */
CDetectURL::~CDetectURL()
{
	CNotifyMgr *pnm = _ped->GetNotifyMgr();

	if(pnm)
		pnm->Remove((ITxNotify *)this);
}

//
//	ITxNotify	methods
//

/*
 *	CDetectURL::OnPreRelaceRange(cp, cchDel, cchNew, cpFormatMin, cpFormatMax)
 *
 *	@mfunc	called before a change is made
 */
void CDetectURL::OnPreReplaceRange(
	LONG cp,			//@parm start of changes
	LONG cchDel,		//@parm #of chars deleted
	LONG cchNew,		//@parm #of chars added
	LONG cpFormatMin,	//@parm min cp of formatting change
	LONG cpFormatMax)	//@parm max cp of formatting change
{
	; // don't need to do anything here
}

/*
 *	CDetectURL::OnPostReplaceRange(cp, cchDel, cchNew, cpFormatMin, cpFormatMax)
 *
 *	@mfunc	called after a change has been made to the backing store.  We
 *			simply need to accumulate all such changes
 */
void CDetectURL::OnPostReplaceRange(
	LONG cp,			//@parm start of changes
	LONG cchDel,		//@parm #of chars deleted
	LONG cchNew,		//@parm #of chars added
	LONG cpFormatMin,	//@parm min cp of formatting change
	LONG cpFormatMax)	//@parm max cp of formatting change
{
	// We don't need to worry about format changes; just data changes
	// to the backing store

	if(cp != CP_INFINITE)
	{
		Assert(cp != CONVERT_TO_PLAIN);
		_adc.UpdateRecalcRegion(cp, cchDel, cchNew);
	}
}

/*
 *	CDetectURL::Zombie ()
 *
 *	@mfunc
 *		Turn this object into a zombie
 */
void CDetectURL::Zombie ()
{
}

/*
 *	CDetectURL::ScanAndUpdate(publdr)
 *
 *	@mfunc	scans the affect text, detecting new URL's and removing old ones.
 *
 *	@comm	The algorithm we use is straightforward: <nl>
 *
 *			1. find the update region and expand out to whitespace in either
 *			direction. <nl>
 *
 *			2. Scan through region word by word (where word is contiguous
 *			non-whitespace). 
 *			
 *			3. Strip these words off punctuation marks. This may be a bit 
 *			tricky as some of the punctuation may be part of the URL itself.
 *			We assume that generally it's not, and if it is, one has to enclose
 *			the URL in quotes, brackets or such. We stop stripping the 
 *			punctuation off the end as soon as we find the matching bracket.
 *			
 *			4. If it's a URL, enable the effects, if it's
 *			incorrectly labelled as a URL, disabled the effects.
 *
 *			Note that this algorithm will only remove
 */
void CDetectURL::ScanAndUpdate(
	IUndoBuilder *publdr)	//@parm undo context to use
{
	LONG		cpStart, cpEnd, cp;
	CTxtSelection *psel = _ped->GetSel();
	CTxtRange	rg(*psel);
	BOOL		fCleanedThisURL;
	BOOL		fCleanedSomeURL = FALSE;

	// Clear away some unnecessary features of the range that will
	// just slow us down.
	rg.SetIgnoreFormatUpdate(TRUE);
	rg._rpPF.SetToNull();
		
	if(!GetScanRegion(cpStart, cpEnd))
		return;

	rg.Set(cpStart, 0);

	while((cp = rg.GetCp()) < cpEnd)
	{
		Assert(rg.GetCch() == 0);
		
		LONG cchAdvance; 

		ExpandToURL(rg, cchAdvance);

		if(rg.GetCch() == 0)
			break;

		if(IsURL(rg))
		{
			SetURLEffects(rg, publdr);

			LONG cpNew = rg.GetCp() - rg.GetCch();

			// Anything before detected URL did not really belong to it
			if (rg.GetCp() > cp)
			{
				rg.Set(cp, cp - rg.GetCp());
				CheckAndCleanBogusURL(rg, fCleanedThisURL, publdr);
				fCleanedSomeURL |= fCleanedThisURL;
			}

			// Collapse to end of URL range so that ExpandToURL will
			// find next candidate.
			rg.Set(cpNew, 0);

			// skip to the end of word; this can't be another URL!
			cp = cpNew;
			cchAdvance = -MoveByDelimiters(rg._rpTX, 1, URL_STOPATWHITESPACE, 0);
		}

		if(cchAdvance)
		{	
			rg.Set(cp, cchAdvance);
			CheckAndCleanBogusURL(rg, fCleanedThisURL, publdr);
			fCleanedSomeURL |= fCleanedThisURL;

			// Collapse to end of scanned range so that ExpandToURL will
			// find next candidate.
			rg.Set(cp - cchAdvance, 0);
		}
	}

	// If we cleaned some URL, we might need to reset the default format
	if(fCleanedSomeURL && !psel->GetCch())
		psel->Update_iFormat(-1);
}

//
//	PRIVATE methods
//

/*
 *	CDetectURL::GetScanRegion (&rcpStart, &rcpEnd)
 *
 *	@mfunc	Gets the region of text to scan for new URLs by expanding the
 *			changed region to be bounded by whitespace
 *
 *	@rdesc	BOOL
 */
BOOL CDetectURL::GetScanRegion(
	LONG&	rcpStart,		//@parm where to put start of range
	LONG&	rcpEnd)			//@parm where to put end of range
{
	LONG		cp, cch;
	LONG		cchExpand;
	WCHAR		chBracket;
	CRchTxtPtr	rtp(_ped, 0);

	_adc.GetUpdateRegion(&cp, NULL, &cch);

	if(cp == CP_INFINITE)
		return FALSE;

	// First find start of region
	rtp.SetCp(cp);
	rcpStart = cp;
	rcpEnd = cp + cch;
	
	// Now let's see if we need to expand to the nearest quotation mark
	// we do if we have quotes in our region or we have the LINK bit set
	// on either side of the region that we might need or not need to clear
	BOOL fExpandToBrackets = (rcpEnd - rcpStart ? 
						      GetAngleBracket(rtp._rpTX, rcpEnd - rcpStart) : 0);

	BOOL fKeepGoing = TRUE;	
	while(fKeepGoing)
	{
		fKeepGoing = FALSE;

		// Expand left to the entire word
		rtp.SetCp(rcpStart);
		rcpStart += MoveByDelimiters(rtp._rpTX, -1, URL_STOPATWHITESPACE, 0);

		// Now the other end
		rtp.SetCp(rcpEnd);
		rcpEnd += MoveByDelimiters(rtp._rpTX, 1, URL_STOPATWHITESPACE, 0);

		// If we have LINK formatting around, we'll need to expand to nearest quotes
		rtp.SetCp(rcpStart);
		rtp._rpCF.AdjustBackward();
		fExpandToBrackets = fExpandToBrackets ||
						(_ped->GetCharFormat(rtp._rpCF.GetFormat())->_dwEffects & CFE_LINK);

		rtp.SetCp(rcpEnd);
		rtp._rpCF.AdjustForward();
		fExpandToBrackets = fExpandToBrackets || 
						(_ped->GetCharFormat(rtp._rpCF.GetFormat())->_dwEffects & CFE_LINK);

		if (fExpandToBrackets)
		// We have to expand to nearest angle brackets in both directions
		{
			rtp.SetCp(rcpStart);
			chBracket = LEFTANGLEBRACKET;
			cchExpand = MoveByDelimiters(rtp._rpTX, -1, URL_STOPATCHAR, &chBracket);
		
			// Did we really hit a bracket?	
			if(chBracket == LEFTANGLEBRACKET)
			{
				rcpStart += cchExpand;
				fKeepGoing = TRUE;
			}

			// Same thing, different direction
			rtp.SetCp(rcpEnd);
			chBracket = RIGHTANGLEBRACKET;
			cchExpand =  MoveByDelimiters(rtp._rpTX, 1, URL_STOPATCHAR, &chBracket);

			if(chBracket == RIGHTANGLEBRACKET)
			{
				rcpEnd += cchExpand;
				fKeepGoing = TRUE;
			}
			fExpandToBrackets = FALSE;
		}
	}
		
	LONG cchAdj = _ped->GetAdjustedTextLength();
	if(rcpEnd > cchAdj)
		rcpEnd = cchAdj;

	return TRUE;
}

/*
 *	CDetectURL::ExpandToURL(&rg, &cchAdvance)
 *
 *	@mfunc	skips white space and sets the range to the very next
 *			block of non-white space text. Strips this block off
 *			punctuation marks
 */
void CDetectURL::ExpandToURL(
	CTxtRange&	rg,	//@parm range to move
	LONG &cchAdvance//@parm how much to advance to the next URL from the current cp		
							)	
{
	LONG cp;
	LONG cch;

	Assert(rg.GetCch() == 0);

	cp = rg.GetCp();

	// Skip white space first, record the advance
	cp  -= (cchAdvance = -MoveByDelimiters(rg._rpTX, 1, 
							URL_EATWHITESPACE|URL_STOPATNONWHITESPACE, 0));
	rg.Set(cp, 0);

	// Strip off punctuation marks
	WCHAR chStopChar = URL_INVALID_DELIMITER;

	// Skip all punctuation from the beginning of the word
	LONG cchHead = MoveByDelimiters(rg._rpTX, 1, 
							URL_STOPATWHITESPACE|URL_STOPATNONPUNCT, 
							&chStopChar);

	// Now skip up to white space (i.e. expand to the end of the word).
	cch = MoveByDelimiters(rg._rpTX, 1, URL_STOPATWHITESPACE|URL_EATNONWHITESPACE, 0);
	
	// This is how much we want to advance to start loking for the next URL
	// if this does not turn out to be one: one word
	// We increment/decrement  the advance so we can accumulate changes in there
	cchAdvance -= cch;
	WCHAR chLeftDelimiter = chStopChar;

	// Check if anything left; if not, it's not interesting -- just return
	Assert(cchHead <= cch);
	if(cch == cchHead)
	{
		rg.Set(cp, -cch);
		return;
	}

	// Set to the end of range
	rg.Set(cp + cch, 0);
		
	//  Get the space after so we always clear white space between words
	//	cchAdvance -= MoveByDelimiters(rg._rpTX, 1, 
	//						URL_EATWHITESPACE|URL_STOPATNONWHITESPACE, 0);

	// and go back while skipping punctuation marks and not finding a match
	// to the left-side encloser

	chStopChar = BraceMatch(chStopChar);
	LONG cchTail = MoveByDelimiters(rg._rpTX, -1, 
							URL_STOPATWHITESPACE|URL_STOPATNONPUNCT|URL_STOPATCHAR, 
							&chStopChar);

	// Something should be left of the word, assert that
	Assert(cch - cchHead + cchTail > 0);

	if(chLeftDelimiter == LEFTANGLEBRACKET)
	{ 
		//If we stopped at a quote: go forward looking for the enclosing
		//quote, even if there are spaces.

		// move to the beginning
		rg.Set(cp + cchHead, 0);
		chStopChar = RIGHTANGLEBRACKET;
		if(GetAngleBracket(rg._rpTX) < 0) // closing bracket
		{
			LONG cchExtend = MoveByDelimiters(rg._rpTX, 1, URL_STOPATCHAR, &chStopChar);
			Assert(cchExtend <= URL_MAX_SIZE);

			// did we really get the closing bracket?
			if(chStopChar == RIGHTANGLEBRACKET)
			{
				rg.Set(cp + cchHead, -(cchExtend - 1));
				return;
			}
		}
		// Otherwise the quotes did not work out; fall through to
		// the general case
	}
	rg.Set(cp + cchHead, -(cch - cchHead + cchTail));
	return;
}

/*
 *	CDetectURL::IsURL(&rg)
 *
 *	@mfunc	if the range is over a URL, return TRUE.  We assume
 *			that the range has been preset to cover a block of non-white
 *			space text.
 *			
 *
 *	@rdesc	TRUE/FALSE
 */
BOOL CDetectURL::IsURL(
	CTxtRange&	rg)		//@parm Range of text to check
{
	LONG i, j;
	TCHAR szBuf[MAXURLHDRSIZE + 1];
	LONG cch, rgcch;
	
	// make sure the active end is cpMin
	Assert(rg.GetCch() < 0);
	
	cch = rg._rpTX.GetText(MAXURLHDRSIZE, szBuf);
	szBuf[cch] = L'\0';
	rgcch = -rg.GetCch();

	//First, see if the word contains '\\' because that is a UNC
	//convention and its cheap to check.
	if (szBuf[0] == L'\\' && szBuf[1] == L'\\' && rgcch > 2)
		return TRUE;

	// Scan the buffer to see if we have one of ':.' since
	// all URLs must contain that.  wcsnicmp is a fairly expensive
	// call to be making frequently.
	for(i = 0; i < cch; i++)
	{
		switch (szBuf[i])
		{
		default:
			break;

		case '.':
		for(j = 0; j < NUMDOTURLHDR; j++)
		{
			// The strings must match _and_ we must have at least
			// one more character
			if(W32->wcsnicmp(szBuf, rgszDOTURL[j], rgcchDOTURL[j]) == 0)
				return rgcch > rgcchDOTURL[j];
		}
		return FALSE;

		case ':':
			for(j = 0; j < NUMURLHDR; j++)
			{
				if(W32->wcsnicmp(szBuf, rgszURL[j], rgcchURL[j]) == 0)
					return rgcch > rgcchURL[j];
			}
		return FALSE;
		}
	}
	return FALSE;
}

/*
 *	CDetectURL::SetURLEffects
 *
 *	@mfunc	sets URL effects for the given range.
 *
 *	@comm	The URL effects currently are blue text, underline, with 
 *			CFE_LINK.
 */
void CDetectURL::SetURLEffects(
	CTxtRange&	rg,			//@parm Range on which to set the effects
	IUndoBuilder *publdr)	//@parm Undo context to use
{
	CCharFormat CF;

	CF._dwEffects = CFE_LINK;

	// NB!  The undo system should have already figured out what should
	// happen with the selection by now.  We just want to modify the
	// formatting and not worry where the selection should go on undo/redo.
	rg.SetCharFormat(&CF, SCF_IGNORESELAE, publdr, CFM_LINK, CFM2_CHARFORMAT);
}

/*
 *	CDetectURL::CheckAndCleanBogusURL(rg, fDidClean, publdr)
 *
 *	@mfunc	checks the given range to see if it has CFE_LINK set,
 *			and if so, removes is.  We assume that the range is already
 *			_not_ a well-formed URL string.
 */
void CDetectURL::CheckAndCleanBogusURL(
	CTxtRange&	rg,			//@parm range to use
	BOOL	   &fDidClean,	//@parm return TRUE if we actually did some cleaning
	IUndoBuilder *publdr)	//@parm undo context to use
{
	LONG cch = -rg.GetCch();
	Assert(cch > 0);

	CCharFormat CF;
	CFormatRunPtr rp(rg._rpCF);

	fDidClean = FALSE;

	// If there are no format runs, nothing to do
	if(!rp.IsValid())
		return;

	rp.AdjustForward();
	// Run through the format runs in this range; if there is no
	// link bit set, then just return.
	while(cch > 0)
	{
		if(_ped->GetCharFormat(rp.GetFormat())->_dwEffects & CFE_LINK)
			break;

		cch -= rp.GetCchLeft();
		rp.NextRun();
	}

	// If there is no link bit set on any part of the range, just return	
	if(cch <= 0)
		return;

	// Uh-oh, it's a bogus link.  Turn off the link bit.
	fDidClean = TRUE;

	CF._dwEffects = 0;

	// NB!  The undo system should have already figured out what should
	// happen with the selection by now.  We just want to modify the
	// formatting and not worry where the selection should go on undo/redo.
	rg.SetCharFormat(&CF, SCF_IGNORESELAE, publdr, CFM_LINK, CFM2_CHARFORMAT);
}

/*
 *	CDetectURL::MoveByDelimiters(&tpRef, iDir, grfDelimeters, pchStopChar)
 *
 *	@mfunc	returns the signed number of characters until the next delimiter 
 *			character in the given direction.
 *
 *	@rdesc	signed number of characters until next delimite
 */
LONG CDetectURL::MoveByDelimiters(
	const CTxtPtr&	tpRef,		//@parm cp/tp to start looking from
	LONG iDir,					//@parm Direction to look, must be 1 or -1
	DWORD grfDelimiters,		//@parm Eat or stop at different types of
								// characters. Use one of URL_EATWHITESPACE,
								// URL_EATNONWHITESPACE, URL_STOPATWHITESPACE
								// URL_STOPATNONWHITESPACE, URL_STOPATPUNCT,
								// URL_STOPATNONPUNCT ot URL_STOPATCHAR
	WCHAR *pchStopChar)			// @parm Out: delimiter we stopped at
								// In: additional char that stops us
								// when URL_STOPATCHAR is specified
{
	LONG	cch = 0;
	LONG	cchMax = (grfDelimiters & URL_EATWHITESPACE)	// Use huge # if
				   ? tomForward : URL_MAX_SIZE;				//  eating whitesp
	LONG	cchvalid = 0;
	WCHAR chScanned = URL_INVALID_DELIMITER;
	LONG	i;
	const WCHAR *pch;
	CTxtPtr	tp(tpRef);

	// Determine the scan mode: do we stop at white space, at punctuation, 
	// at a stop character? 
	BOOL fWhiteSpace	= (0 != (grfDelimiters & URL_STOPATWHITESPACE));
	BOOL fNonWhiteSpace = (0 != (grfDelimiters & URL_STOPATNONWHITESPACE));
	BOOL fPunct			= (0 != (grfDelimiters & URL_STOPATPUNCT));
	BOOL fNonPunct		= (0 != (grfDelimiters & URL_STOPATNONPUNCT));
	BOOL fStopChar		= (0 != (grfDelimiters & URL_STOPATCHAR));

	Assert(iDir == 1 || iDir == -1);
	Assert(fWhiteSpace || fNonWhiteSpace || (!fPunct && !fNonPunct));
	Assert(!fStopChar || NULL != pchStopChar);

	// Break anyway if we scanned more than URL_MAX_SIZE chars
	for (LONG cchScanned = 0; cchScanned < cchMax;)
	{
		// Get the text
		if(iDir == 1)
		{
			i = 0;
			pch = tp.GetPch(cchvalid);
		}
		else
		{
			i = -1;
			pch = tp.GetPchReverse(cchvalid);
			// This is a bit odd, but basically compensates for	the
			// backwards loop running one-off from the forwards loop
			cchvalid++;
		}

		if(!pch)
			goto exit;

		// Loop until we hit a character within criteria.  Note that for
		// our purposes, the embedding character counts as whitespace.

		while(abs(i) < cchvalid  && cchScanned < cchMax
			&& (IsURLWhiteSpace(pch[i]) ? !fWhiteSpace : !fNonWhiteSpace)
			&& (IsURLDelimiter(pch[i]) ? !fPunct : !fNonPunct)
			&& !(fStopChar && (*pchStopChar == chScanned) && (chScanned != URL_INVALID_DELIMITER))
			&& ((chScanned != CR && chScanned != LF) || fNonWhiteSpace))
		{	
			chScanned = pch[i];
			i += iDir;
			++cchScanned;
		}

		// If we're going backwards, i will be off by one; adjust
		if(iDir == -1)
		{
			Assert(i < 0 && cchvalid > 0);
			i++;
			cchvalid--;
		}

		cch += i;
		if(abs(i) < cchvalid)
			break;
		tp.AdvanceCp(i);
	}

exit:	
	// Stop char parameter is present, fill it in
	// with the last character scanned and accepted
	if (pchStopChar)
		*pchStopChar = chScanned;

	return cch; 
}

/*
 *	CDetectURL::BraceMatch (chEnclosing)
 *
 *	@mfunc	returns the matching bracket to the one passed in.
 *			if the symbol passed in is not a bracket it returns 
 *			URL_INVALID_DELIMITER
 *
 *	@rdesc	returns bracket that matches chEnclosing
 */
WCHAR CDetectURL::BraceMatch(
	WCHAR chEnclosing)
{	
	// We're matching "standard" roman braces only. Thus only them may be used
	// to enclose URLs. This should be fine (after all, only Latin letters are allowed
	// inside URLs, right?).
	// I hope that the compiler converts this into some efficient code
	switch(chEnclosing)
	{
	case(TEXT('\"')): 
	case(TEXT('\'')): return chEnclosing;
	case(TEXT('(')): return TEXT(')');
	case(TEXT('<')): return TEXT('>');
	case(TEXT('[')): return TEXT(']');
	case(TEXT('{')): return TEXT('}');
	default: return URL_INVALID_DELIMITER;
	}
}

/*
 *	CDetectURL::GetAngleBracket	(&tpRef, cchMax)
 *
 *	@mfunc	Goes forward as long as the current paragraph 
 *			or URL_SCOPE_MAX not finding quotation marks and counts 
 *			those quotation marks
 *			returns their parity
 *
 *	@rdesc	LONG
 */
LONG CDetectURL::GetAngleBracket(
	CTxtPtr &tpRef,
	LONG	 cchMax)
{	
	CTxtPtr	tp(tpRef);
	LONG	cchvalid = 0;
	const WCHAR *pch;

	Assert (cchMax >= 0);

	if(!cchMax)
		cchMax = URL_MAX_SCOPE;

	// Break anyway if we scanned more than cchLimit chars
	for (LONG cchScanned = 0; cchScanned < cchMax; NULL)
	{
		pch = tp.GetPch(cchvalid);

		if(!cchvalid)
			return 0;
		
		for (LONG i = 0; (i < cchvalid); ++i)
		{
			if(pch[i] == CR || pch[i] == LF || cchScanned >= cchMax)
				return 0;

			if(pch[i] == LEFTANGLEBRACKET)
				return 1;

			if(pch[i] == RIGHTANGLEBRACKET)
				return -1;
			++cchScanned;
		}
		tp.AdvanceCp(i);
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\util.cpp ===
/*
 *	UTIL.C
 *
 *	Purpose:
 *		Implementation of various useful utility functions
 *
 *	Author:
 *		alexgo (4/25/95)
 */

#include "_common.h"
#include "_rtfconv.h"

ASSERTDATA

// Author revision color table
const COLORREF rgcrRevisions[] =
{
        RGB(0, 0, 255),
        RGB(0, 128, 0),
        RGB(255, 0, 0),
        RGB(0, 128, 128),
        RGB(128, 0, 128),
        RGB(0, 0, 128),
        RGB(128, 0, 0),
        RGB(255, 0, 255)
};

#if REVMASK != 7
#pragma message ("WARNING, Revision mask not equal to table!");
#endif 



/*
 *	DuplicateHGlobal
 *
 *	Purpose:
 *		duplicates the passed in hglobal
 */

HGLOBAL DuplicateHGlobal( HGLOBAL hglobal )
{
	TRACEBEGIN(TRCSUBSYSUTIL, TRCSCOPEINTERN, "DuplicateHGlobal");

	UINT	flags;
	DWORD	size;
	HGLOBAL hNew;
	BYTE *	pSrc;
	BYTE *	pDest;

	if( hglobal == NULL )
	{
		return NULL;
	}

	flags = GlobalFlags(hglobal);
	size = GlobalSize(hglobal);
	hNew = GlobalAlloc(flags, size);

	if( hNew )
	{
		pDest = (BYTE *)GlobalLock(hNew);
		pSrc = (BYTE *)GlobalLock(hglobal);

		if( pDest == NULL || pSrc == NULL )
		{
			GlobalUnlock(hNew);
			GlobalUnlock(hglobal);
			GlobalFree(hNew);

			return NULL;
		}

		memcpy(pDest, pSrc, size);

		GlobalUnlock(hNew);
		GlobalUnlock(hglobal);
	}

	return hNew;
}

/*
 *	CountMatchingBits (*pA, *pB, n)
 *
 *	@mfunc
 *		Count matching bit fields
 *
 *	@comm
 *		This is used to help decide how good the match is between
 *		code page bit fields. Mainly for KB/font switching support.
 *
 *	Author:
 *		Jon Matousek
 */
INT CountMatchingBits(
	const DWORD *pA,	//@parm Array A to be matched
	const DWORD *pB,	//@parm Array B to be matched
	INT			 n)		//@parm # DWORDs to be matched
{
	TRACEBEGIN(TRCSUBSYSUTIL, TRCSCOPEINTERN, "CountMatchingBits");
							//0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
	static INT	bitCount[] = {0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4 };
	INT			c = 0;				// Bit count to return
	DWORD		matchBits;			// Next DWORD match

	while(n--)
	{
		//matchBits = ~(*pA++ ^ *pB++);			// 1 and 0's
		matchBits = *pA++ & *pB++;				// 1 only
		for( ; matchBits; matchBits >>= 4)		// Early out
			c += bitCount[matchBits & 15];
	}
	return c;
}

//
//	Object Stabilization classes
//

//+-------------------------------------------------------------------------
//
//  Member:		CSafeRefCount::CSafeRefCount
//
//  Synopsis: 	constructor for the safe ref count class
//
//  Effects:
//
//  Arguments:	none
//
//  Requires: 	
//
//  Returns: 	none
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 				28-Jul-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

CSafeRefCount::CSafeRefCount()
{
	m_cRefs = 0;
	m_cNest = 0;
	m_fInDelete = FALSE;
    m_fForceZombie = FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CSafeRefCount::CSafeRefCount (virtual)
//
//  Synopsis:	
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 				28-Jul-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

CSafeRefCount::~CSafeRefCount()
{
	Assert(m_cRefs == 0 && m_cNest == 0 && m_fInDelete == TRUE);
}

//+-------------------------------------------------------------------------
//
//  Member: 	CSafeRefCount::SafeAddRef
//
//  Synopsis:	increments the reference count on the object
//
//  Effects:
//
//  Arguments: 	none
//
//  Requires:
//
//  Returns: 	ULONG -- the reference count after the increment
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:	increments the reference count.
//
//  History:    dd-mmm-yy Author    Comment
//   			28-Jul-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

ULONG CSafeRefCount::SafeAddRef()
{
	m_cRefs++;

	//AssertSz(m_fInDelete == FALSE, "AddRef called on deleted object!");

	// this *could* be really bad.  If we are deleting the object,
	// it means that during the destructor, somebody made an outgoing
	// call eventually ended up with another addref to ourselves
	// (even though	all pointers to us had been 'Released').
	//
	// this is usually caused by code like the following:
	//	m_pFoo->Release();
	//	m_pFoo = NULL;
	//
	// If the the Release may cause Foo to be deleted, which may cause
	// the object to get re-entered during Foo's destructor.  However,
	// 'this' object has not yet set m_pFoo to NULL, so it may
	// try to continue to use m_pFoo.
	//
	// However, the May '94 aggregation rules REQUIRE this behaviour
	// In your destructor, you have to addref the outer unknown before
	// releasing cached interface pointers on your aggregatee.  We
	// can't put an assert here because we do this all the time now.
	//

	return m_cRefs;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CSafeRefCount::SafeRelease
//
//  Synopsis:	decrements the reference count on the object
//
//  Effects: 	May delete the object!
//
//  Arguments:
//
//  Requires:
//
//  Returns:	ULONG -- the reference count after decrement
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm: 	decrements the reference count.  If the reference count
//				is zero AND the nest count is zero AND we are not currently
//				trying to delete our object, then it is safe to delete.
//
//  History:    dd-mmm-yy Author    Comment
//				28-Jul-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

ULONG CSafeRefCount::SafeRelease()
{
	ULONG	cRefs;

	if( m_cRefs > 0 )
	{
		cRefs = --m_cRefs;

		if( m_cRefs == 0 && m_cNest == 0 && m_fInDelete == FALSE )
		{
			m_fInDelete = TRUE;
			delete this;
		}
	}
	else
	{
 		// somebody is releasing a non-addrefed pointer!!
		AssertSz(0, "Release called on a non-addref'ed pointer!\n");

		cRefs = 0;
	}

	return cRefs;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CSafeRefCount::IncrementNestCount
//
//  Synopsis: 	increments the nesting count of the object
//
//  Effects:
//
//  Arguments: 	none
//
//  Requires:
//
//  Returns: 	ULONG; the nesting count after increment
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 				28-Jul-94 alexgo    author
//
//  Notes:	The nesting count is the count of how many times an
//		an object has been re-entered.  For example, suppose
//		somebody calls pFoo->Bar1(), which makes some calls that
//		eventually call pFoo->Bar2();.  On entrace to Bar2, the
//		nest count of the object should be 2 (since the invocation
//		of Bar1 is still on the stack above us).
//
//		It is important to keep track of the nest count so we do
//		not accidentally delete ourselves during a nested invocation.
//		If we did, then when the stack unwinds to the original
//		top level call, it could try to access a non-existent member
//		variable and crash.
//
//--------------------------------------------------------------------------

ULONG CSafeRefCount::IncrementNestCount()
{

#ifdef DEBUG
	if( m_fInDelete )
	{
		TRACEWARNSZ("WARNING: CSafeRefCount, object "
			"re-entered during delete!\n");
	}
#endif

	m_cNest++;

	return m_cNest;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CSafeRefCount::DecrementNestCount
//
//  Synopsis: 	decrements the nesting count and deletes the object
//				(if necessary)
//
//  Effects: 	may delete 'this' object!
//
//  Arguments: 	none
//
//  Requires:
//
//  Returns:	ULONG, the nesting count after decrement
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:	decrements the nesting count.  If the nesting count is zero
//				AND the reference count is zero AND we are not currently
//				trying to delete ourselves, then delete 'this' object
//
//  History:    dd-mmm-yy Author    Comment
//				28-Jul-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

ULONG CSafeRefCount::DecrementNestCount()
{
	ULONG	cNest;

	if( m_cNest > 0 )
	{
		cNest = --m_cNest;

		if( m_cRefs == 0 && m_cNest == 0 && m_fInDelete == FALSE )
		{
			m_fInDelete = TRUE;
			delete this;
		}
	}
	else
	{
 		// somebody forget to increment the nest count!!
		AssertSz(0, "Unbalanced nest count!!");

		cNest = 0;
	}

	return cNest;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CSafeRefCount::IsZombie
//
//  Synopsis: 	determines whether or not the object is in a zombie state
//				(i.e. all references gone, but we are still on the stack
//				somewhere).
//
//  Effects:
//
//  Arguments:	none
//
//  Requires:
//
//  Returns: 	TRUE if in a zombie state
//				FALSE otherwise
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:  If we are in the middle of a delete, or if the ref count
//				is zero and the nest count is greater than zero, then we
//				are a zombie
//
//  History:    dd-mmm-yy Author    Comment
// 				28-Jul-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL CSafeRefCount::IsZombie()
{
	BOOL	fIsZombie;

	if( (m_cRefs == 0 && m_cNest > 0) || m_fInDelete == TRUE
	    || m_fForceZombie == TRUE)
	{
		fIsZombie = TRUE;
	}
	else
	{
		fIsZombie = FALSE;
	}

	return fIsZombie;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CSafeRefCount::Zombie
//
//  Synopsis: 	Forces the object into a zombie state.  This is called
//              when the object is still around but shouldn't be. It
//              flags us so we behave safely while we are in this state.
//
//  Effects:
//
//  Arguments:	none
//
//  Requires:
//
//  Returns:    none
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:
//
//  Notes:
//
//--------------------------------------------------------------------------

VOID CSafeRefCount::Zombie()
{
    m_fForceZombie = TRUE;
}

/* OleStdSwitchDisplayAspect
**
**	@mfunc
**    Switch the currently cached display aspect between DVASPECT_ICON
**    and DVASPECT_CONTENT.
**
**    NOTE: when setting up icon aspect, any currently cached content
**    cache is discarded and any advise connections for content aspect
**    are broken.
**
**	@rdesc
**      S_OK -- new display aspect setup successfully
**      E_INVALIDARG -- IOleCache interface is NOT supported (this is
**                  required).
**      <other SCODE> -- any SCODE that can be returned by
**                  IOleCache::Cache method.
**      NOTE: if an error occurs then the current display aspect and
**            cache contents unchanged.
*/
HRESULT OleStdSwitchDisplayAspect(
		LPOLEOBJECT             lpOleObj,
		LPDWORD                 lpdwCurAspect,
		DWORD                   dwNewAspect,
		HGLOBAL                 hMetaPict,
		BOOL                    fDeleteOldAspect,
		BOOL                    fSetupViewAdvise,
		LPADVISESINK            lpAdviseSink,
		BOOL FAR*               lpfMustUpdate)
{
#ifndef PEGASUS
   LPOLECACHE      lpOleCache = NULL;
   LPVIEWOBJECT    lpViewObj = NULL;
   LPENUMSTATDATA  lpEnumStatData = NULL;
   STATDATA        StatData;
   FORMATETC       FmtEtc;
   STGMEDIUM       Medium;
   DWORD           dwAdvf;
   DWORD           dwNewConnection;
   DWORD           dwOldAspect = *lpdwCurAspect;
   HRESULT         hrErr;

   if (lpfMustUpdate)
      *lpfMustUpdate = FALSE;

   if (hrErr =
	   lpOleObj->QueryInterface(IID_IOleCache, (void**)&lpOleCache))
   {
	   return hrErr;
   }

   // Setup new cache with the new aspect
   FmtEtc.cfFormat = 0;     // whatever is needed to draw
   FmtEtc.ptd      = NULL;
   FmtEtc.dwAspect = dwNewAspect;
   FmtEtc.lindex   = -1;
   FmtEtc.tymed    = TYMED_NULL;

   /* NOTE: if we are setting up Icon aspect with a custom icon
   **    then we do not want DataAdvise notifications to ever change
   **    the contents of the data cache. thus we set up a NODATA
   **    advise connection. otherwise we set up a standard DataAdvise
   **    connection.
   */
   if (dwNewAspect == DVASPECT_ICON && hMetaPict)
      dwAdvf = ADVF_NODATA;
   else
      dwAdvf = ADVF_PRIMEFIRST;

   hrErr = lpOleCache->Cache(
         (LPFORMATETC)&FmtEtc,
         dwAdvf,
         (LPDWORD)&dwNewConnection
   );

   if (! SUCCEEDED(hrErr)) {
      lpOleCache->Release();
      return hrErr;
   }

   *lpdwCurAspect = dwNewAspect;

   /* NOTE: if we are setting up Icon aspect with a custom icon,
   **    then stuff the icon into the cache. otherwise the cache must
   **    be forced to be updated. set the *lpfMustUpdate flag to tell
   **    caller to force the object to Run so that the cache will be
   **    updated.
   */
   if (dwNewAspect == DVASPECT_ICON && hMetaPict) {

      FmtEtc.cfFormat = CF_METAFILEPICT;
      FmtEtc.ptd      = NULL;
      FmtEtc.dwAspect = DVASPECT_ICON;
      FmtEtc.lindex   = -1;
      FmtEtc.tymed    = TYMED_MFPICT;

      Medium.tymed            = TYMED_MFPICT;
      Medium.hGlobal        = hMetaPict;
      Medium.pUnkForRelease   = NULL;

      hrErr = lpOleCache->SetData(
            (LPFORMATETC)&FmtEtc,
            (LPSTGMEDIUM)&Medium,
            FALSE   /* fRelease */
      );
   } else {
      if (lpfMustUpdate)
         *lpfMustUpdate = TRUE;
   }

   if (fSetupViewAdvise && lpAdviseSink) {
      /* NOTE: re-establish the ViewAdvise connection */
      lpOleObj->QueryInterface(IID_IViewObject, (void**)&lpViewObj);

      if (lpViewObj) {

         lpViewObj->SetAdvise(
               dwNewAspect,
               0,
               lpAdviseSink
         );

         lpViewObj->Release();
      }
   }

   /* NOTE: remove any existing caches that are set up for the old
   **    display aspect. It WOULD be possible to retain the caches set
   **    up for the old aspect, but this would increase the storage
   **    space required for the object and possibly require additional
   **    overhead to maintain the unused cachaes. For these reasons the
   **    strategy to delete the previous caches is prefered. if it is a
   **    requirement to quickly switch between Icon and Content
   **    display, then it would be better to keep both aspect caches.
   */

   if (fDeleteOldAspect) {
      hrErr = lpOleCache->EnumCache(
            (LPENUMSTATDATA FAR*)&lpEnumStatData
      );

      while(hrErr == NOERROR) {
         hrErr = lpEnumStatData->Next(
               1,
               (LPSTATDATA)&StatData,
               NULL
         );
         if (hrErr != NOERROR)
            break;              // DONE! no more caches.

         if (StatData.formatetc.dwAspect == dwOldAspect) {

            // Remove previous cache with old aspect
            lpOleCache->Uncache(StatData.dwConnection);
         }
      }

      if (lpEnumStatData)
         lpEnumStatData->Release();
   }

   if (lpOleCache)
      lpOleCache->Release();
#endif
   return NOERROR;
}

/*
 *	ObjectReadSiteFlags
 *
 *	@mfunc
 *		Read the dwFlags, dwUser, & dvaspect bytes from a container
 *		specific stream.
 *
 *	Arguments:
 *		preobj			The REOBJ in which to copy the flags.
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT ObjectReadSiteFlags(REOBJECT * preobj)
{
	HRESULT hr = NOERROR;
#ifndef PEGASUS
	LPSTREAM pstm = NULL;
	OLECHAR StreamName[] = OLESTR("RichEditFlags");


	// Make sure we have a storage to read from
	if (!preobj->pstg)
		return E_INVALIDARG;

	// Open the stream
	if (hr = preobj->pstg->OpenStream(StreamName, 0, STGM_READ |
										STGM_SHARE_EXCLUSIVE, 0, &pstm))
	{
		goto Cleanup;
	}

	if ((hr = pstm->Read(&preobj->dwFlags,
							sizeof(preobj->dwFlags), NULL)) ||
		(hr = pstm->Read(&preobj->dwUser,
							 sizeof(preobj->dwUser), NULL)) ||
		(hr = pstm->Read(&preobj->dvaspect,
								 sizeof(preobj->dvaspect), NULL)))
	{
		goto Cleanup;
	}

Cleanup:
	if (pstm)
		pstm->Release();
#endif
	return hr;
}

//Used for EnumMetafileCheckIcon & FIsIconMetafilePict
typedef	struct _walkmetafile
{
	BOOL	fAND;
	BOOL	fPastIcon;
	BOOL 	fHasIcon;
} WALKMETAFILE;

static CHAR szIconOnly[] = "IconOnly";

/*
 * EnumMetafileCheckIcon
 *
 * @mfunc
 *	Stripped down version of EnumMetafileExtractIcon and
 *	EnumMetafileExtractIconSource from the OLE2UI library.
 *
 *  EnumMetaFile callback function that walks a metafile looking for
 *  StretchBlt (3.1) and BitBlt (3.0) records.  We expect to see two
 *  of them, the first being the AND mask and the second being the XOR
 *  data. 
 *
 *	Once we find the icon, we confirm this find by looking for the "IconOnly"
 *	comment block found in standard OLE iconic metafiles.
 *
 *  Arguments:
 *		hDC             HDC into which the metafile should be played.
 *		phTable         HANDLETABLE FAR * providing handles selected into the DC.
 *		pMFR            METARECORD FAR * giving the enumerated record.
 *		pIE             LPICONEXTRACT providing the destination buffer and length.
 *
 * @rdesc
 *  int             0 to stop enumeration, 1 to continue.
 */

int CALLBACK EnumMetafileCheckIcon(HDC hdc, HANDLETABLE *phTable,
											METARECORD *pMFR, int cObj,
											LPARAM lparam)
{
#ifndef PEGASUS
	WALKMETAFILE *		pwmf = (WALKMETAFILE *) lparam;

	switch (pMFR->rdFunction)
	{
	case META_DIBBITBLT:			// Win30
	case META_DIBSTRETCHBLT:		// Win31
		// If this is the first pass (pIE->fAND==TRUE) then save the memory
		// of the AND bits for the next pass.

		if (pwmf->fAND)
			pwmf->fAND = FALSE;
		else
			pwmf->fPastIcon = TRUE;
		break;

	case META_ESCAPE:
		if (pwmf->fPastIcon &&
			pMFR->rdParm[0] == MFCOMMENT &&
			!lstrcmpiA(szIconOnly, (LPSTR)&pMFR->rdParm[2]))
		{
			pwmf->fHasIcon = TRUE;
			return 0;
		}
		break;
	}
#endif
	return 1;
}

/*
 *	FIsIconMetafilePict
 *
 *	@mfunc
 *		Detect whether the metafile contains an iconic presentation. We do this
 *		by getting a screen DC and walking the metafile records until we find
 *		the landmarks denoting an icon.
 *
 *		Arguments:
 *			hmfp			The metafile to test
 *
 *	@rdesc
 *		BOOL			TRUE if the metafile contains an iconic view
 */
BOOL FIsIconMetafilePict(HGLOBAL hmfp)
{
#ifndef PEGASUS
	LPMETAFILEPICT	pmfp;
	WALKMETAFILE	wmf = { 0 };
	HDC				hdc;

	wmf.fAND = TRUE;
	if (!hmfp || !(pmfp = (LPMETAFILEPICT)GlobalLock(hmfp)))
		goto CleanUp;

	// We get information back in the ICONEXTRACT structure.
	hdc = GetDC(NULL);
	EnumMetaFile(hdc, pmfp->hMF, EnumMetafileCheckIcon, (LPARAM) &wmf);
	ReleaseDC(NULL, hdc);
	GlobalUnlock(hmfp);

CleanUp:
	return wmf.fHasIcon;
#else
	return TRUE;
#endif
}

/*
 * AllocObjectDescriptor
 *
 * Purpose:
 *  Allocated and fills an OBJECTDESCRIPTOR structure.
 *
 * Parameters:
 *  clsID           CLSID to store.
 *  dwAspect        DWORD with the display aspect
 *  pszl            LPSIZEL (optional) if the object is being scaled in
 *                  its container, then the container should pass the
 *                  extents that it is using to display the object.
 *  ptl             POINTL from upper-left corner of object where
 *                  mouse went down for use with Drag & Drop.
 *  dwMisc          DWORD containing MiscStatus flags
 *  pszName         LPTSTR naming the object to copy
 *  pszSrc          LPTSTR identifying the source of the object.
 *
 * Return Value:
 *  HBGLOBAL         Handle to OBJECTDESCRIPTOR structure.
 */

/*
 * AllocObjectDescriptor
 *
 * Purpose:
 *  Allocated and fills an OBJECTDESCRIPTOR structure.
 *
 * Parameters:
 *  clsID           CLSID to store.
 *  dwAspect        DWORD with the display aspect
 *  pszl            LPSIZEL (optional) if the object is being scaled in
 *                  its container, then the container should pass the
 *                  extents that it is using to display the object.
 *  ptl             POINTL from upper-left corner of object where
 *                  mouse went down for use with Drag & Drop.
 *  dwMisc          DWORD containing MiscStatus flags
 *  pszName         LPTSTR naming the object to copy
 *  pszSrc          LPTSTR identifying the source of the object.
 *
 * Return Value:
 *  HBGLOBAL         Handle to OBJECTDESCRIPTOR structure.
 */
static HGLOBAL AllocObjectDescriptor(
	CLSID clsID,
	DWORD dwAspect,
	SIZEL szl,
	POINTL ptl,
	DWORD dwMisc,
	LPTSTR pszName,
	LPTSTR pszSrc)
{
#ifndef PEGASUS
    HGLOBAL              hMem=NULL;
    LPOBJECTDESCRIPTOR   pOD;
    DWORD                cb, cbStruct;
    DWORD                cchName, cchSrc;

	cchName=wcslen(pszName)+1;

    if (NULL!=pszSrc)
        cchSrc=wcslen(pszSrc)+1;
    else
        {
        cchSrc=cchName;
        pszSrc=pszName;
        }

    /*
     * Note:  CFSTR_OBJECTDESCRIPTOR is an ANSI structure.
     * That means strings in it must be ANSI.  OLE will do
     * internal conversions back to Unicode as necessary,
     * but we have to put ANSI strings in it ourselves.
     */
    cbStruct=sizeof(OBJECTDESCRIPTOR);
    cb=cbStruct+(sizeof(WCHAR)*(cchName+cchSrc));   //HACK

    hMem=GlobalAlloc(GHND, cb);

    if (NULL==hMem)
        return NULL;

    pOD=(LPOBJECTDESCRIPTOR)GlobalLock(hMem);

    pOD->cbSize=cb;
    pOD->clsid=clsID;
    pOD->dwDrawAspect=dwAspect;
    pOD->sizel=szl;
    pOD->pointl=ptl;
    pOD->dwStatus=dwMisc;

    if (pszName)
        {
        pOD->dwFullUserTypeName=cbStruct;
       wcscpy((LPTSTR)((LPBYTE)pOD+pOD->dwFullUserTypeName)
            , pszName);
        }
    else
        pOD->dwFullUserTypeName=0;  //No string

    if (pszSrc)
        {
        pOD->dwSrcOfCopy=cbStruct+(cchName*sizeof(WCHAR));

        wcscpy((LPTSTR)((LPBYTE)pOD+pOD->dwSrcOfCopy), pszSrc);
        }
    else
        pOD->dwSrcOfCopy=0;  //No string

    GlobalUnlock(hMem);
    return hMem;
#else
	return NULL;
#endif
}

HGLOBAL OleGetObjectDescriptorDataFromOleObject(
	LPOLEOBJECT pObj,
	DWORD       dwAspect,
	POINTL      ptl,
	LPSIZEL     pszl
)
{
#ifndef PEGASUS
    CLSID           clsID;
    LPTSTR          pszName=NULL;
    LPTSTR          pszSrc=NULL;
   BOOL            fLink=FALSE;
    IOleLink       *pLink;
    TCHAR           szName[512];
    DWORD           dwMisc=0;
    SIZEL           szl = {0,0};
    HGLOBAL         hMem;
    HRESULT         hr;
    
    
    if (SUCCEEDED(pObj->QueryInterface(IID_IOleLink
        , (void **)&pLink)))
        fLink=TRUE;

    if (FAILED(pObj->GetUserClassID(&clsID)))
		ZeroMemory(&clsID, sizeof(CLSID));

    //Get user string, expand to "Linked %s" if this is link
    pObj->GetUserType(USERCLASSTYPE_FULL, &pszName);
    if (fLink && NULL!=pszName)
	{
		// NB!! we do these two lines of code below instead
		// wcscat because we don't use wcscat anywhere else
		// in the product at the moment.  The string "Linked "
		// should never change either.
		wcscpy(szName, TEXT("Linked "));
		wcscpy(&(szName[7]), pszName);
	}
    else if (pszName)
       wcscpy(szName, pszName);
	else
		szName[0] = 0;
 
	CoTaskMemFree(pszName);

   /*
     * Get the source name of this object using either the
     * link display name (for link) or a moniker display
     * name.
     */

    if (fLink)
		{
        hr=pLink->GetSourceDisplayName(&pszSrc);
		}
    else
        {
        IMoniker   *pmk;

        hr=pObj->GetMoniker(OLEGETMONIKER_TEMPFORUSER
            , OLEWHICHMK_OBJFULL, &pmk);

        if (SUCCEEDED(hr))
            {
            IBindCtx  *pbc;
            CreateBindCtx(0, &pbc);

            pmk->GetDisplayName(pbc, NULL, &pszSrc);
            pbc->Release();
            pmk->Release();
            }
        }

    if (fLink)
        pLink->Release();

    //Get MiscStatus bits
    hr=pObj->GetMiscStatus(dwAspect, &dwMisc);

    if (pszl)
    {
        szl.cx = pszl->cx;
        szl.cy = pszl->cy;
    }
    //Get OBJECTDESCRIPTOR
    hMem=AllocObjectDescriptor(clsID, dwAspect, szl, ptl, dwMisc, szName, pszSrc);

    CoTaskMemFree(pszSrc);

    return hMem;
#else
	return NULL;
#endif
}

/*
 * OleStdGetMetafilePictFromOleObject()
 *
 * @mfunc:
 *  Generate a MetafilePict from the OLE object.
 *  Parameters:
 *		lpOleObj        LPOLEOBJECT pointer to OLE Object 
 *		dwDrawAspect    DWORD   Display Aspect of object
 *		lpSizelHim      SIZEL   (optional) If the object is being scaled in its
 *                  container, then the container should pass the extents 
 *                  that it is using to display the object. 
 *                  May be NULL if the object is NOT being scaled. in this
 *                  case, IViewObject2::GetExtent will be called to get the
 *                  extents from the object.
 *  ptd             TARGETDEVICE FAR*   (optional) target device to render
 *                  metafile for. May be NULL.
 *
 * @rdesc
 *    HANDLE    -- handle of allocated METAFILEPICT
 */
HANDLE OleStdGetMetafilePictFromOleObject(
        LPOLEOBJECT         lpOleObj,
        DWORD               dwDrawAspect,
        LPSIZEL             lpSizelHim,
        DVTARGETDEVICE FAR* ptd
)
{
#ifndef PEGASUS
    LPVIEWOBJECT2 lpViewObj2 = NULL;
    HDC hDC;
    HMETAFILE hmf;
    HANDLE hMetaPict;
    LPMETAFILEPICT lpPict;
    RECT rcHim;
    RECTL rclHim;
    SIZEL sizelHim;
    HRESULT hrErr;
    SIZE size;
    POINT point;
	LPOLECACHE polecache = NULL;
	LPDATAOBJECT pdataobj = NULL;
	FORMATETC fetc;
	STGMEDIUM med;

	// First try the easy way,
	// pull out the cache's version of things.
	ZeroMemory(&fetc, sizeof(FORMATETC));
	fetc.dwAspect = dwDrawAspect;
	fetc.cfFormat = CF_METAFILEPICT;
	fetc.lindex = -1;
	fetc.tymed = TYMED_MFPICT;
	ZeroMemory(&med, sizeof(STGMEDIUM));
	hMetaPict = NULL;

	if (!lpOleObj->QueryInterface(IID_IOleCache, (void **)&polecache) &&
		!polecache->QueryInterface(IID_IDataObject, (void **)&pdataobj) &&
		!pdataobj->GetData(&fetc, &med))
	{
		hMetaPict = OleDuplicateData(med.hGlobal, CF_METAFILEPICT, 0);
		ReleaseStgMedium(&med);
	}

	if (pdataobj)
	{
		pdataobj->Release();
	}

	if (polecache)
	{
		polecache->Release();
	}

	// If all this failed, fall back to the hard way and draw the object
	// into a metafile.
	if (hMetaPict)
		return hMetaPict;

    if (lpOleObj->QueryInterface(IID_IViewObject2, (void **)&lpViewObj2))
        return NULL;

    // Get SIZEL
    if (lpSizelHim) {
        // Use extents passed by the caller
        sizelHim = *lpSizelHim;
    } else {
        // Get the current extents from the object
        hrErr = lpViewObj2->GetExtent(
					dwDrawAspect,
					-1,     /*lindex*/
					ptd,    /*ptd*/
					(LPSIZEL)&sizelHim);
        if (hrErr != NOERROR)
            sizelHim.cx = sizelHim.cy = 0;
    }

    hDC = CreateMetaFileA(NULL);

    rclHim.left     = 0;
    rclHim.top      = 0;
    rclHim.right    = sizelHim.cx;
    rclHim.bottom   = sizelHim.cy;

    rcHim.left      = (int)rclHim.left;
    rcHim.top       = (int)rclHim.top;
    rcHim.right     = (int)rclHim.right;
    rcHim.bottom    = (int)rclHim.bottom;

    SetWindowOrgEx(hDC, rcHim.left, rcHim.top, &point);
    SetWindowExtEx(hDC, rcHim.right-rcHim.left, rcHim.bottom-rcHim.top,&size);

    hrErr = lpViewObj2->Draw(
            dwDrawAspect,
            -1,
            NULL,
            ptd,
            NULL,
            hDC,
            (LPRECTL)&rclHim,
            (LPRECTL)&rclHim,
            NULL,
            0
    );

    lpViewObj2->Release();

    hmf = CloseMetaFile(hDC);

    if (hrErr != NOERROR) {
		TRACEERRORHR(hrErr);
		hMetaPict = NULL;
    }
	else
	{
    	hMetaPict = GlobalAlloc(GHND|GMEM_SHARE, sizeof(METAFILEPICT));

    	if (hMetaPict && (lpPict = (LPMETAFILEPICT)GlobalLock(hMetaPict))){
        	lpPict->hMF  = hmf;
        	lpPict->xExt = (int)sizelHim.cx ;
        	lpPict->yExt = (int)sizelHim.cy ;
        	lpPict->mm   = MM_ANISOTROPIC;
        	GlobalUnlock(hMetaPict);
    	}
	}

	if (!hMetaPict)
		DeleteMetaFile(hmf);

    return hMetaPict;
#else
	return NULL;
#endif
}

/*
 * OleUIDrawShading
 *
 * Purpose:
 *  Shade the object when it is in in-place editing. Borders are drawn
 *  on the Object rectangle. The right and bottom edge of the rectangle
 *  are excluded in the drawing.
 *
 * Parameters:
 *  lpRect      Dimensions of Container Object
 *  hdc         HDC for drawing
 *
 * Return Value: null
 *
 */
void OleUIDrawShading(LPRECT lpRect, HDC hdc)
{
#ifndef PEGASUS
    HBRUSH  hbr;
    HBRUSH  hbrOld;
    HBITMAP hbm;
    RECT    rc;
    WORD    wHatchBmp[] = {0x11, 0x22, 0x44, 0x88, 0x11, 0x22, 0x44, 0x88};
    COLORREF cvText;
    COLORREF cvBk;

    hbm = CreateBitmap(8, 8, 1, 1, wHatchBmp);
    hbr = CreatePatternBrush(hbm);
    hbrOld = (HBRUSH)SelectObject(hdc, hbr);

    rc = *lpRect;

    cvText = SetTextColor(hdc, RGB(255, 255, 255));
    cvBk = SetBkColor(hdc, RGB(0, 0, 0));
    PatBlt(hdc, rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top,
            0x00A000C9L /* DPa */ );

    SetTextColor(hdc, cvText);
    SetBkColor(hdc, cvBk);
    SelectObject(hdc, hbrOld);
    DeleteObject(hbr);
    DeleteObject(hbm);
#endif
}



/*
 *	OleSaveSiteFlags
 *
 *	Purpose:
 *		Save the dwFlags and dwUser bytes into a container specific stream
 *
 *	Arguments:
 *		pstg			The storage to save to
 *		pobsite			The site from where to copy the flags
 *
 *	Returns:
 *		None.
 */
VOID OleSaveSiteFlags(LPSTORAGE pstg, DWORD dwFlags, DWORD dwUser, DWORD dvAspect)
{
#ifndef PEGASUS
	HRESULT hr;
	LPSTREAM pstm = NULL;
	static const OLECHAR szSiteFlagsStm[] = OLESTR("RichEditFlags");

	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "OleSaveSiteFlags");

	// Create/overwrite the stream
	AssertSz(pstg, "Invalid storage");
	if (hr = pstg->CreateStream(szSiteFlagsStm, STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
							    0, 0, &pstm))
	{
		TraceError("OleSaveSiteFlags", GetScode(hr));
		goto Cleanup;
	}

	//$ FUTURE: Put a version stamp

	// Write out the values
	//$ BUG: byte order
	if ((hr = pstm->Write(&dwFlags, sizeof(dwFlags), NULL)) ||
		(hr = pstm->Write(&dwUser, sizeof(dwUser), NULL)) ||
		(hr = pstm->Write(&dvAspect, sizeof(dvAspect), NULL)))
	{
		TraceError("OleSaveSiteFlags", GetScode(hr));
		//$ FUTURE: Wipe the data to make this operation all or nothing
		goto Cleanup;
	}

Cleanup:
    if (pstm)
        pstm->Release();
#endif	
}



/*
 *	AppendString ( szInput, szAppendStr, dBuffSize, dByteUsed )
 *
 *	Purpose:
 *		Append new string to original string. Check for size of buffer
 *	and re-allocate a large buffer is necessary
 *
 *	Arguments:
 *		szInput			Original String 
 *		szAppendStr		String to be appended to szInput 
 *		dBuffSize		Byte size of the buffer for szInput
 *		dByteUsed		Byte used in the buffer for szInput
 *
 *	Returns:
 *		INT		The error code
 */
INT AppendString( 
	BYTE ** szInput, 
	BYTE * szAppendStr,
	int	* dBuffSize,
	int * dByteUsed)
{
	BYTE	*pch;
	int		cchAppendStr;

	pch = *szInput;

	// check if we have enough space to append the new string
	cchAppendStr = strlen( (char *)szAppendStr );
	
	if ( cchAppendStr + *dByteUsed >= *dBuffSize )
	{
		// re-alloc a bigger buffer
		int cchNewSize = *dBuffSize + cchAppendStr + 32;
		
		pch = (BYTE *)PvReAlloc( *szInput, cchNewSize );
	
		if ( !pch )
		{
			return ( ecNoMemory );
		}

		*dBuffSize = cchNewSize;
		*szInput = pch;
	}

	pch += *dByteUsed;
	*dByteUsed += cchAppendStr;

	while (*pch++ = *szAppendStr++);	
	
	return ecNoError;
}

/*
 *	CTempBuf::Init
 *
 *	@mfunc	Set object to its initial state using the stack buffer
 *
 */
void CTempBuf::Init()
{
	_pv = (void *) &_chBuf[0];
	_cb = MAX_STACK_BUF;
}

/*
 *	CTempBuf::FreeBuf
 *
 *	@mfunc	Free an allocated buffer if there is one
 *
 */
void CTempBuf::FreeBuf()
{
	if (_pv != &_chBuf[0])
	{
		delete _pv;
	}
}

/*
 *	CTempBuf::GetBuf
 *
 *	@mfunc	Get a buffer for temporary use
 *
 *	@rdesc	Pointer to buffer if one could be allocated otherwise NULL.
 *
 *
 */
void *CTempBuf::GetBuf(
	LONG cb)				//@parm Size of buffer needed in bytes
{
	if (_cb >= cb)
	{
		// Currently allocated buffer is big enough so use it
		return _pv;
	}

	// Free our current buffer
	FreeBuf();

	// Allocate a new buffer if we can
	_pv = new BYTE[cb];

	if (NULL == _pv)
	{
		// Could not allocate a buffer so reset to our initial state and
		// return NULL.
		Init();
		return NULL;
	}

	// Store the size of our new buffer.
	_cb = cb;

	// Returnt he pointer to the buffer.
	return _pv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\w32sys.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	w32sys.cpp - thin layer over Win32 services
 *	
 *	History: <nl>
 *		1/22/97 joseogl Created
 *
 *	Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
 */

// This prevents the "W32->" prefix from being prepended to our identifiers.

#define W32SYS_CPP

#include "_common.h"
#include "_host.h"
#include "_font.h"
#include "_edit.h"
#include <malloc.h>

// Include the appropriate implementation.
#if defined(PEGASUS)
#include "w32wince.cpp"
#else
#include "w32win32.cpp"
#endif

ASSERTDATA

/*
 *	@struct CPGCHAR |
 *		Locally used variable that contains code-page and char-set info
 */
typedef struct _cpgcharset
{
	INT			nCodePage;				// @field Code page
	BYTE		bCharSet;				// @field Character set
	DWORD		dwFontSig;				// @field Font signature bits
} CPGCHAR;

static const CPGCHAR rgCpgCharSet[NCHARSETS] =
{
	{1252,	ANSI_CHARSET,			fLATIN1>>8}, // fLATIN1 has 3 bits
	{0,		DEFAULT_CHARSET,		0x00000000}, // Not reliably implemented...
	{CP_SYMBOL,SYMBOL_CHARSET,		0x00004000}, // No trans, except WORD -> BYTE
	{437,	PC437_CHARSET,			0x00000000}, // United States IBM
	{850,	OEM_CHARSET,			0x00000400}, // IBM Multilingual
	{1250,	EASTEUROPE_CHARSET,		0x00000002}, // Eastern Europe
	{1255,	HEBREW_CHARSET,			0x00000020}, // Hebrew
	{1256,  ARABIC_CHARSET,			0x00000040}, // Arabic
	{932,	SHIFTJIS_CHARSET,		0x00020000}, // Japanese
	{1251,	RUSSIAN_CHARSET,		0x00000004}, // Russian
	{936,	GB2312_CHARSET,			0x00040000}, // PRC
	{949,	HANGEUL_CHARSET,		0x00080000}, // Hangul
	{1361,	JOHAB_CHARSET,			0x00000000}, // JOHAB
	{950,	CHINESEBIG5_CHARSET,	0x00100000}, // Chinese
	{1253,	GREEK_CHARSET,			0x00000008}, // Greek
	{1254,	TURKISH_CHARSET,		0x00000010}, // Turkish
	{1257,	BALTIC_CHARSET,			0x00000080}, // Estonia, Lithuania, Latvia
	{1258,	VIETNAMESE_CHARSET,		0x00000100}, // Vietnamese
	{874,	THAI_CHARSET,			0x00010000}, // Thai
	{CP_DEVANAGARI,DEVANAGARI_CHARSET,0x00200000}, // Devanagari
	{CP_TAMIL, TAMIL_CHARSET,		0x00400000}, // Tamil
	{CP_GEORGIAN, GEORGIAN_CHARSET,	0x00800000}, // Georgian
	{CP_ARMENIAN, ARMENIAN_CHARSET,	0x00000200}, // Armenian
	{10000,	MAC_CHARSET,			0x00000000}	 // Most popular Mac (English, etc.)
};

#define cCpgCharSet ARRAY_SIZE(rgCpgCharSet)

#define	LANG_TAIWAN	 MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL)

const WORD CodePageTable[] = {
/* CodePage		  PLID	primary language
   ------------------------------------- */
	   0,		// 00 -	undefined
	1256,		// 01 - Arabic
	1251,		// 02 - Bulgarian
	1252,		// 03 - Catalan
	 950,		// 04 - Taiwan (Hong Kong, PRC, and Singapore are 936)
	1250,		// 05 - Czech
	1252,		// 06 - Danish
	1252,		// 07 - German
	1253,		// 08 - Greek
	1252,		// 09 - English
	1252,		// 0a - Spanish
	1252,		// 0b - Finnish
	1252,		// 0c - French
	1255,		// 0d - Hebrew
	1250,		// 0e - Hungarian
	1252,		// 0f - Icelandic
	1252,		// 10 - Italian
	 932,		// 11 - Japan
	 949,		// 12 - Korea
	1252,		// 13 - Dutch
	1252,		// 14 - Norwegian
	1250,		// 15 - Polish
	1252,		// 16 - Portuguese
	   0,		// 17 -	Rhaeto-Romanic
	1250,		// 18 - Romanian
	1251,		// 19 - Russian
	1250,		// 1a -	Croatian
	1250,		// 1b - Slovak
	1250,		// 1c -	Albanian
	1252,		// 1d - Swedish
	 874,		// 1e - Thai
	1254,		// 1f - Turkish
	1256,		// 20 -	Urdu
	1252,		// 21 - Indonesian
	1251,		// 22 - Ukranian
	1251,		// 23 - Byelorussian
	1250,		// 24 -	Slovenian
	1257,		// 25 - Estonia
	1257,		// 26 - Latvian
	1257,		// 27 - Lithuanian
	   0,		// 28 -	Tajik - Tajikistan (undefined)
	1256,		// 29 - Farsi
	1258,		// 2a -	Vietnanese
	CP_ARMENIAN,// 2b -	Armenian (Unicode only)
	1254,		// 2c -	Azeri (Latin, can be Cyrillic...)
	1252,		// 2d - Basque
	   0,		// 2e - Sorbian
	1251,		// 2f - FYRO Macedonian
	1252,		// 30 - Sutu
	1252,		// 31 - Tsonga
	1252,		// 32 - Tswana
	1252,		// 33 - Venda
	1252,		// 34 - Xhosa
	1252,		// 35 - Zulu
	1252,		// 36 - Africaans
	CP_GEORGIAN,// 37 - Georgian (Unicode only)
	1252,		// 38 - Faerose
	CP_DEVANAGARI,// 39 - Hindi (Indic)
	1252,		// 3a - Maltese
	1252,		// 3b - Sami
	1252,		// 3c - Gaelic
	1255,		// 3d - Yiddish
	1252,		// 3e - Malaysian
	1251,		// 3f - Kazakh
	1252,		// 40 -	Kirghiz
	1252,		// 41 - Swahili
	1252,		// 42 - Turkmen
	1254,		// 43 - Uzbek (Latin, can be Cyrillic...)
	1251		// 44 - Tatar
				// 45 - Bengali (Indic)
				// 46 - Punjabi(Gurmukhi) (Indic)
				// 47 - Gujarati (Indic)
				// 48 - Oriya (Indic)
				// 49 - Tamil (Indic)
				// 4a - Telugu (Indic)
				// 4b - Kannada (Indic)
				// 4c - Malayalam (Indic)
				// 4d - Assamese (Indic)
				// 4e - Marathi (Indic)
				// 4f - Sanskrit (Indic)
				// 50*  Mongolian - Mongolia
				// 51*  Tibetan - Tibet
				// 52*  Welsh - Wales
				// 53*  Khmer - Cambodia
				// 54*  Lao - Lao
				// 55*  Burmese - Mayanmar
				// 56*  Gallego - Portugal
				// 57 - Konkani (Indic)
				// 58*  Manipuri (Indic)
				// 59*  Sindhi (Indic)
				// 5a
				// 5b
				// 5c
				// 5d
				// 5e
				// 5f
				// 60*  Kashmiri
				// 61*  Nepali - Nepal
				// 62*  Frisian - Netherlands
				// 63*  Pashto - Afghanistan
};

#define nCodePageTable	ARRAY_SIZE(CodePageTable)
#define lidAzeriCyrillic 0x82C
#define lidSerbianCyrillic 0xC1A
#define lidUzbekCyrillic 0x843

// Our interface pointer
CW32System *W32;

CW32System::CW32System( )
{
	if(GetVersion(&_dwPlatformId, &_dwMajorVersion, &_dwMinorVersion))
	{
		_fHaveAIMM = FALSE;
		_fHaveIMMEShare = FALSE;
		_fHaveIMMProcs = FALSE;
		_pIMEShare = NULL;
		_icr3DDarkShadow = COLOR_WINDOWFRAME;
		if(_dwMajorVersion >= VERS4)
			_icr3DDarkShadow = COLOR_3DDKSHADOW;
	}

	_syslcid = GetSystemDefaultLCID();
	_ACP = ::GetACP();

    // BUG FIX #6089
    // we need this for backward compatibility of mouse wheel
    _MSMouseRoller = RegisterWindowMessageA(MSH_MOUSEWHEEL);

	// Register private messages for MSIME98	
	_MSIMEMouseMsg = RegisterWindowMessageA("MSIMEMouseOperation");
	_MSIMEDocFeedMsg = RegisterWindowMessageA("MSIMEDocumentFeed");	
	_MSIMEQueryPositionMsg = RegisterWindowMessageA("MSIMEQueryPosition");	
	_MSIMEServiceMsg = RegisterWindowMessageA("MSIMEService");

	// get MSIME Reconvert private messages unless we are running in NT5
	if (_dwPlatformId == VER_PLATFORM_WIN32_WINDOWS ||
		(_dwPlatformId == VER_PLATFORM_WIN32_NT && _dwMajorVersion <= 4))
	{
		_MSIMEReconvertMsg = RegisterWindowMessageA("MSIMEReconvert");
		_MSIMEReconvertRequestMsg = RegisterWindowMessageA("MSIMEReconvertRequest");

	}
	else
	{
		_MSIMEReconvertMsg = 0;			// private message for reconversion
		_MSIMEReconvertRequestMsg = 0;	// private message for reconversion request
	}
}

CW32System::~CW32System()
{
	FreeIME();	
	FreeOle();
	if (_hdcScreen)
		DeleteDC(_hdcScreen);
}

///////////////////////////////  Memory  and CRT utility functions  /////////////////////////////////
extern "C" {

#ifdef NOCRTOBJS

// Havinf these functions defined here helps eliminate the dependency on the CRT
// Some function definitions copied from CRT sources.
// Typically, it is better to get the objs for these objects from the CRT
// without dragging in the whole thing.

/***
*int memcmp(buf1, buf2, count) - compare memory for lexical order
*
*Purpose:
*       Compares count bytes of memory starting at buf1 and buf2
*       and find if equal or which one is first in lexical order.
*
*Entry:
*       void *buf1, *buf2 - pointers to memory sections to compare
*       size_t count - length of sections to compare
*
*Exit:
*       returns < 0 if buf1 < buf2
*       returns  0  if buf1 == buf2
*       returns > 0 if buf1 > buf2
*
*Exceptions:
*
*******************************************************************************/

int __cdecl memcmp (
        const void * buf1,
        const void * buf2,
        size_t count
        )
{
        if (!count)
                return(0);

        while ( --count && *(char *)buf1 == *(char *)buf2 ) {
                buf1 = (char *)buf1 + 1;
                buf2 = (char *)buf2 + 1;
        }

        return( *((unsigned char *)buf1) - *((unsigned char *)buf2) );
}

/***
*char *memset(dst, val, count) - sets "count" bytes at "dst" to "val"
*
*Purpose:
*       Sets the first "count" bytes of the memory starting
*       at "dst" to the character value "val".
*
*Entry:
*       void *dst - pointer to memory to fill with val
*       int val   - value to put in dst bytes
*       size_t count - number of bytes of dst to fill
*
*Exit:
*       returns dst, with filled bytes
*
*Exceptions:
*
*******************************************************************************/

void * __cdecl memset (
        void *dst,
        int val,
        size_t count
        )
{
        void *start = dst;

        while (count--) {
                *(char *)dst = (char)val;
                dst = (char *)dst + 1;
        }

        return(start);
}

/***
*memcpy - Copy source buffer to destination buffer
*
*Purpose:
*       memcpy() copies a source memory buffer to a destination memory buffer.
*       This routine does NOT recognize overlapping buffers, and thus can lead
*       to propogation.
*
*       For cases where propogation must be avoided, memmove() must be used.
*
*Entry:
*       void *dst = pointer to destination buffer
*       const void *src = pointer to source buffer
*       size_t count = number of bytes to copy
*
*Exit:
*       Returns a pointer to the destination buffer
*
*Exceptions:
*******************************************************************************/

void * __cdecl memcpy (
        void * dst,
        const void * src,
        size_t count
        )
{
        void * ret = dst;

        /*
         * copy from lower addresses to higher addresses
         */
        while (count--) {
                *(char *)dst = *(char *)src;
                dst = (char *)dst + 1;
                src = (char *)src + 1;
        }

        return(ret);
}

void * __cdecl memmove(void *dst, const void *src, size_t count)
{
	void * ret = dst;

	if (dst <= src || (char *)dst >= ((char *)src + count)) {
		/*
         * Non-Overlapping Buffers
         * copy from lower addresses to higher addresses
         */
         while (count--) {
			*(char *)dst = *(char *)src;
            dst = (char *)dst + 1;
            src = (char *)src + 1;
         }
	}
    else
	{
		/*
         * Overlapping Buffers
         * copy from higher addresses to lower addresses
         */
        dst = (char *)dst + count - 1;
        src = (char *)src + count - 1;

        while (count--) {
			*(char *)dst = *(char *)src;
            dst = (char *)dst - 1;
            src = (char *)src - 1;
        }
	}

	return(ret);
}

/***
*strlen - return the length of a null-terminated string
*
*Purpose:
*       Finds the length in bytes of the given string, not including
*       the final null character.
*
*Entry:
*       const char * str - string whose length is to be computed
*
*Exit:
*       length of the string "str", exclusive of the final null byte
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl strlen (
        const char * str
        )
{
        const char *eos = str;

        while( *eos++ ) ;

        return( (int)(eos - str - 1) );
}

#endif

#ifdef DEBUG

// These functions are only used for RTF logging

/***
*strcmp - compare two strings, returning less than, equal to, or greater than
*
*Purpose:
*       STRCMP compares two strings and returns an integer
*       to indicate whether the first is less than the second, the two are
*       equal, or whether the first is greater than the second.
*
*       Comparison is done byte by byte on an UNSIGNED basis, which is to
*       say that Null (0) is less than any other character (1-255).
*
*Entry:
*       const char * src - string for left-hand side of comparison
*       const char * dst - string for right-hand side of comparison
*
*Exit:
*       returns -1 if src <  dst
*       returns  0 if src == dst
*       returns +1 if src >  dst
*
*Exceptions:
*
*******************************************************************************/

int __cdecl strcmp (
        const char * src,
        const char * dst
        )
{
        int ret = 0 ;

        while( ! (ret = *(unsigned char *)src - *(unsigned char *)dst) && *dst)
                ++src, ++dst;

        if ( ret < 0 )
                ret = -1 ;
        else if ( ret > 0 )
                ret = 1 ;

        return( ret );
}

/***
*char *strcat(dst, src) - concatenate (append) one string to another
*
*Purpose:
*       Concatenates src onto the end of dest.  Assumes enough
*       space in dest.
*
*Entry:
*       char *dst - string to which "src" is to be appended
*       const char *src - string to be appended to the end of "dst"
*
*Exit:
*       The address of "dst"
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl strcat (
        char * dst,
        const char * src
        )
{
        char * cp = dst;

        while( *cp )
                cp++;                   /* find end of dst */

        while( *cp++ = *src++ ) ;       /* Copy src to end of dst */

        return( dst );                  /* return dst */

}

#endif

// This function in the runtime traps virtial base calls
int __cdecl _purecall()
{
	MessageBox(NULL,TEXT("Fatal Error : Vrtual base call in RichEdit"),NULL, MB_OK);
	PostQuitMessage (0);
	return 0;
}

// To avoid brionging in floating point lib
extern int _fltused = 1;

} // end of extern "C" block

size_t CW32System::wcslen(const wchar_t *wcs)
{
        const wchar_t *eos = wcs;

        while( *eos++ ) ;

        return( (size_t)(eos - wcs - 1) );
}

wchar_t * CW32System::wcscpy(wchar_t * dst, const wchar_t * src)
{
        wchar_t * cp = dst;

        while( *cp++ = *src++ )
                ;               /* Copy src over dst */

        return( dst );
}

int CW32System::wcscmp(const wchar_t * src, const wchar_t * dst)
{
	int ret = 0;

	while( ! (ret = (int)(*src - *dst)) && *dst)
		++src, ++dst;

	if ( ret < 0 )
		ret = -1 ;
	else if ( ret > 0 )
		ret = 1 ;

	return( ret );
}

int CW32System::wcsicmp(const wchar_t * src, const wchar_t * dst)
{
	int ret = 0;
	wchar_t s,d;
	
	do
	{
		s = ((*src <= L'Z') && (*dst >= L'A'))
			? *src - L'A' + L'a'
			: *src;
		d = ((*dst <= L'Z') && (*dst >= L'A'))
			? *dst - L'A' + L'a'
			: *dst;
		src++;
		dst++;
	} while (!(ret = (int)(s - d)) && d);

	if ( ret < 0 )
		ret = -1 ;
	else if ( ret > 0 )
		ret = 1 ;

	return( ret );
}

wchar_t * CW32System::wcsncpy (wchar_t * dest, const wchar_t * source, size_t count)
{
	wchar_t *start = dest;
	
	while (count && (*dest++ = *source++))	  /* copy string */
		count--;
	
	if (count)								/* pad out with zeroes */
		while (--count)
			*dest++ = L'\0';
		
	return(start);
}

int CW32System::wcsnicmp (const wchar_t * first, const wchar_t * last, size_t count)
{
	wchar_t f,l;
	int result = 0;
	
	if ( count ) {
		do {
			f = ((*first <= L'Z') && (*first >= L'A'))
				? *first - L'A' + L'a'
				: *first;
			l = ((*last <= L'Z') && (*last >= L'A'))
				? *last - L'A' + L'a'
				: *last;
			first++;
			last++;
		} while ( (--count) && f && (f == l) );
		result = (int)(f - l);
	}
	return result;
}

unsigned long CW32System::strtoul(const char *nptr)
{
	const char *p;
	char c;
	unsigned long number;
	unsigned digval;
	unsigned long maxval;
	
	p = nptr;                       /* p is our scanning pointer */
	number = 0;                     /* start with zero */
	
	c = *p++;                       /* read char */
	while ( c == ' ' || c == '\t' )
		c = *p++;               /* skip whitespace */
	
	if (c == '-') {
		return 0;
	}
		
	/* if our number exceeds this, we will overflow on multiply */
	maxval = ULONG_MAX / 10;
	
	for (;;) {      /* exit in middle of loop */
		/* convert c to value */
		digval = (unsigned char) c;
		if ( digval >= '0' && digval <= '9' )
			digval = c - '0';
		else
			return number;
		
		/* we now need to compute number = number * base + digval,
		but we need to know if overflow occured.  This requires
		a tricky pre-check. */
		
		if (number < maxval || (number == maxval &&
			(unsigned long)digval <= ULONG_MAX % 10)) {
			/* we won't overflow, go ahead and multiply */
			number = number * 10 + digval;
		}
		else
			return 0;
		
		c = *p++;               /* read next digit */
	}
}


// CW32System static members
BOOL	CW32System::_fLRMorRLM;
BOOL	CW32System::_fHaveIMMProcs;
BOOL	CW32System::_fHaveIMMEShare;
BOOL	CW32System::_fHaveAIMM;
UINT	CW32System::_fRegisteredXBox;
DWORD	CW32System::_dwPlatformId;
LCID	CW32System::_syslcid;
DWORD	CW32System::_dwMajorVersion;
DWORD	CW32System::_dwMinorVersion;
INT		CW32System::_icr3DDarkShadow;
UINT	CW32System::_MSIMEMouseMsg;	
UINT	CW32System::_MSIMEReconvertMsg;
UINT	CW32System::_MSIMEReconvertRequestMsg;	
UINT	CW32System::_MSIMEDocFeedMsg;
UINT	CW32System::_MSIMEQueryPositionMsg;
UINT	CW32System::_MSIMEServiceMsg;
UINT	CW32System::_MSMouseRoller;
HDC		CW32System::_hdcScreen;
CIMEShare* CW32System::_pIMEShare;

// CW32System static system parameter members
BOOL	CW32System::_fSysParamsOk;
BOOL 	CW32System::_fUsePalette;
INT 	CW32System::_xWidthSys;
INT 	CW32System::_yHeightSys;
INT		CW32System::_ySysFontLeading;
LONG 	CW32System::_xPerInchScreenDC;
LONG 	CW32System::_yPerInchScreenDC;
INT		CW32System::_cxBorder;
INT		CW32System::_cyBorder;
INT		CW32System::_cxVScroll;
INT		CW32System::_cyHScroll;
LONG 	CW32System::_dxSelBar;
INT		CW32System::_cxDoubleClk;
INT		CW32System::_cyDoubleClk;	
INT		CW32System::_DCT;
WORD	CW32System::_nScrollInset;
WORD	CW32System::_nScrollDelay;
WORD	CW32System::_nScrollInterval;
WORD	CW32System::_nScrollHAmount;
WORD	CW32System::_nScrollVAmount;
WORD	CW32System::_nDragDelay;
WORD	CW32System::_nDragMinDist;
WORD	CW32System::_wDeadKey;
WORD	CW32System::_wKeyboardFlags;
WORD	CW32System::_wNumKeyPad;
WORD	CW32System::_fFEFontInfo;
BYTE	CW32System::_bDigitSubstMode;
BYTE	CW32System::_bSysCharSet;
HCURSOR CW32System::_hcurSizeNS;
HCURSOR CW32System::_hcurSizeWE;
HCURSOR CW32System::_hcurSizeNWSE;
HCURSOR CW32System::_hcurSizeNESW;
LONG	CW32System::_cLineScroll;
HFONT	CW32System::_hSystemFont;
HKL		CW32System::_hklCurrent;
HKL		CW32System::_hkl[NCHARSETS];
INT		CW32System::_sysiniflags;
UINT	CW32System::_ACP;

DWORD	CW32System::_cRefs;


/*
 *  CW32System::MbcsFromUnicode(pstr, cch, pwstr, cwch, codepage, flags)
 *
 *  @mfunc
 *		Converts a string to MBCS from Unicode. If cwch equals -1, the string
 *		is assumed to be NULL terminated.  -1 is supplied as a default argument.
 *
 *	@rdesc
 *		If [pstr] is NULL or [cch] is 0, 0 is returned.  Otherwise, the number
 *		of characters converted, including the terminating NULL, is returned
 *		(note that converting the empty string will return 1).  If the
 *		conversion fails, 0 is returned.
 *
 *	@devnote
 *		Modifies pstr
 */
int CW32System::MbcsFromUnicode(
	LPSTR	pstr,		//@parm Buffer for MBCS string
	int		cch,		//@parm Size of MBCS buffer, incl space for NULL terminator
	LPCWSTR pwstr,		//@parm Unicode string to convert
	int		cwch,		//@parm # chars in Unicode string, incl NULL terminator
	UINT	codepage,	//@parm Code page to use (CP_ACP is default)
	UN_FLAGS flags)		//@parm Indicates if WCH_EMBEDDING should be handled specially
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CW32System::MbcsFromUnicode");

	LONG			i;
	LPWSTR			pwstrtemp;
	CTempWcharBuf	twcb;

    Assert(cch >= 0 && pwstr && (cwch == -1 || cwch > 0));

    if(!pstr || !cch)
        return 0;

	// If we have to convert WCH_EMBEDDINGs, scan through and turn
	// them into spaces.  This is necessary for richedit1.0 compatibity,
	// as WideCharToMultiByte will turn WCH_EMBEDDING into a '?'
	if(flags == UN_CONVERT_WCH_EMBEDDING)
	{
		if(cwch == -1)
			cwch = wcslen(pwstr) + 1;

		pwstrtemp = twcb.GetBuf(cwch);
		if(pwstrtemp)
		{
			for(i = 0; i < cwch; i++)
			{
				pwstrtemp[i] = pwstr[i];

				if(pwstr[i] == WCH_EMBEDDING)
					pwstrtemp[i] = L' ';
			}
			pwstr = pwstrtemp;
		}
	}
    return WCTMB(codepage, 0, pwstr, cwch, pstr, cch, NULL, NULL, NULL);
}

/*
 *  CW32System::UnicodeFromMbcs(pwstr, cwch, pstr, cch,	uiCodePage)
 *
 *	@mfunc
 *		Converts a string to Unicode from MBCS.  If cch equals -1, the string
 *		is assumed to be NULL terminated.  -1 is supplied as a default
 *		argument.
 *
 *	@rdesc
 *		If [pwstr] is NULL or [cwch] is 0, 0 is returned.  Otherwise,
 *		the number of characters converted, including the terminating
 *		NULL, is returned (note that converting the empty string will
 *		return 1).  If the conversion fails, 0 is returned.
 *
 *	@devnote
 *		Modifies:   [pwstr]
 */
int CW32System::UnicodeFromMbcs(
	LPWSTR	pwstr,		//@parm Buffer for Unicode string
	int		cwch,		//@parm Size of Unicode buffer, incl space for NULL terminator
	LPCSTR	pstr,		//@parm MBCS string to convert
	int		cch,		//@parm # chars in MBCS string, incl NULL terminator
	UINT	uiCodePage)	//@parm Code page to use (CP_ACP is default)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CW32System::UnicodeFromMbcs");

    Assert(pstr && cwch >= 0 && (cch == -1 || cch >= 0));

    if(!pwstr || !cwch)
        return 0;

	if(cch >= 3 && IsUTF8BOM((BYTE *)pstr))
	{
		uiCodePage = CP_UTF8;				// UTF-8 BOM file
		cch -= 3;							// Eat the BOM
		pstr += 3;
	}
    return MBTWC(uiCodePage, 0, pstr, cch, pwstr, cwch, NULL);
}

/*
 *	CW32System::TextHGlobalAtoW (hglobalA)
 *
 *	@func
 *		translates a unicode string contained in an hglobal and
 *		wraps the ansi version in another hglobal
 *
 *	@devnote
 *		does *not* free the incoming hglobal
 */
HGLOBAL	CW32System::TextHGlobalAtoW(HGLOBAL hglobalA)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CW32System::TextHGlobalAtoW");

	if(!hglobalA)
		return NULL;

	HGLOBAL hnew;
	LPSTR	pstr = (LPSTR)GlobalLock(hglobalA);
	DWORD	dwSize = GlobalSize(hglobalA);
	LONG	cbSize = (dwSize + 1) * sizeof(WCHAR);
	
    hnew = GlobalAlloc(GMEM_FIXED, cbSize);
	if(hnew)
	{
		LPWSTR pwstr = (LPWSTR)GlobalLock(hnew);
		UnicodeFromMbcs(pwstr, dwSize + 1, pstr);
		GlobalUnlock(hnew);		
	}
	GlobalUnlock(hglobalA);
	return hnew;
}

/*
 *	CW32System::TextHGlobalWtoA(hglobalW)
 *
 *	@func
 *		converts a unicode text hglobal into a newly allocated
 *		allocated hglobal with ANSI data
 *
 *	@devnote
 *		does *NOT* free the incoming hglobal
 */
HGLOBAL CW32System::TextHGlobalWtoA(
	HGLOBAL hglobalW )
{
	TRACEBEGIN(TRCSUBSYSUTIL, TRCSCOPEINTERN, "CW32System::TextHGlobalWtoA");

	if(!hglobalW)
		return NULL;

	HGLOBAL hnew = NULL;
	LPWSTR 	pwstr = (LPWSTR)GlobalLock(hglobalW);
	DWORD	dwSize = GlobalSize(hglobalW);
	LONG	cbSize = (dwSize * 2) * sizeof(CHAR);
	hnew = GlobalAlloc(GMEM_FIXED, cbSize);

	if( hnew )
	{
		LPSTR pstr = (LPSTR)GlobalLock(hnew);
		MbcsFromUnicode(pstr, cbSize, pwstr );
		GlobalUnlock(hnew);
	}
	GlobalUnlock(hglobalW);
	return hnew;
}	

/*
 *	CW32System::ConvertLanguageIDtoCodePage (lid)
 *
 *	@mfunc		Maps a language ID to a Code Page
 *
 *	@rdesc		returns Code Page
 *
 *	@devnote:
 *		This routine takes advantage of the fact that except for Chinese,
 *		the code page is determined uniquely by the primary language ID,
 *		which is given by the low-order 10 bits of the lcid.
 *
 *		The WORD CodePageTable could be replaced by a BYTE with the addition
 *		of a couple of if's and the BYTE table replaced by a nibble table
 *		with the addition of a shift and a mask.  Since the table is only
 *		96 bytes long, it seems that the simplicity of using actual code page
 *		values is worth the extra bytes.
 */
UINT CW32System::ConvertLanguageIDtoCodePage(
	WORD lid)				//@parm Language ID to map to code page
{
	UINT j = PRIMARYLANGID(lid);			// j = primary language (PLID)

	if(j >= LANG_CROATIAN)					// PLID = 0x1a
	{
		if (lid == lidSerbianCyrillic ||	// Special case for LID = 0xc1a
			lid == lidAzeriCyrillic	  ||
			lid == lidUzbekCyrillic)
		{
			return 1251;					// Use Cyrillic code page
		}

		if(j >= nCodePageTable)				// Most languages above table
		{									//  take 1252
			if (j == 0x57 || j == 0x61 || IN_RANGE(0x4e, j, 0x4f))
				return CP_DEVANAGARI;	

			if (j == 0x49)
				return CP_TAMIL;

			return 1252;
		}
	}

	j = CodePageTable[j];					// Translate PLID to code page

	if(j != 950 || lid == LANG_TAIWAN)		// All but China (except for Taiwan)
		return j;

	return 936;								// Hong Kong SAR, Singapore, and PRC
}

/*
 *	CW32System::GetLocaleLCID ()
 *
 *	@mfunc		Maps an LCID for thread to a Code Page
 *
 *	@rdesc		returns Code Page
 */
LCID CW32System::GetLocaleLCID()
{
	return GetThreadLocale();
}

/*
 *	CW32System::GetLocaleCodePage ()
 *
 *	@mfunc		Maps an LCID for thread to a Code Page
 *
 *	@rdesc		returns Code Page
 */
UINT CW32System::GetLocaleCodePage()
{
#ifdef DEBUG
	UINT cpg = W32->DebugDefaultCpg();
	if (cpg)
		return cpg;
#endif
	return W32->ConvertLanguageIDtoCodePage(GetThreadLocale());
}

/*
 *	CW32System::GetKeyboardLCID ()
 *
 *	@mfunc		Gets LCID for keyboard active on current thread
 *
 *	@rdesc		returns Code Page
 */
LCID CW32System::GetKeyboardLCID(DWORD dwMakeAPICall)
{
	return (WORD)GetKeyboardLayout(dwMakeAPICall);
}

/*
 *	CW32System::GetKeyboardCodePage ()
 *
 *	@mfunc		Gets Code Page for keyboard active on current thread
 *
 *	@rdesc		returns Code Page
 */
UINT CW32System::GetKeyboardCodePage(DWORD dwMakeAPICall)
{
	return W32->ConvertLanguageIDtoCodePage((WORD)GetKeyboardLayout(dwMakeAPICall));
}

/*
 *	CW32System::InitKeyboardFlags ()
 *
 *	@mfunc
 *		Initializes keyboard flags. Used when control gains focus. Note that
 *		Win95 doesn't support VK_RSHIFT, so if either shift key is pressed
 *		when focus is regained, it'll be assumed to be the left shift.
 */
void CW32System::InitKeyboardFlags()
{
	_wKeyboardFlags = 0;
	if(GetKeyState(VK_SHIFT) < 0)
		SetKeyboardFlag(GetKeyState(VK_RSHIFT) < 0 ? RSHIFT : LSHIFT);
}

/*
 *	CW32System::GetKeyboardFlag (dwKeyMask, wKey)
 *
 *	@mfunc
 *		Return whether wKey is depressed. Check with OS for agreement.
 *		If OS says it isn't depressed, reset our internal flags. In
 *		any event, return TRUE/FALSE in agreement with the system (bad
 *		client may have eaten keystrokes, thereby destabilizing our
 *		internal keyboard state.
 *
 *	@rdesc
 *		TRUE iff wKey is depressed
 */
BOOL CW32System::GetKeyboardFlag (
	WORD dwKeyMask,	//@parm _wKeyboardFlags mask like ALT, CTRL, or SHIFT
	WORD wKey)		//@parm VK_xxx like VK_MENU, VK_CONTROL, or VK_SHIFT
{
	BOOL fFlag = (GetKeyboardFlags() & dwKeyMask) != 0;

	if(fFlag ^ ((GetKeyState(wKey) & 0x8000) != 0))
	{	
		// System doesn't agree with our internal state
		// (bad client ate a WM_KEYDOWN)
		if(fFlag)
		{
			ResetKeyboardFlag(dwKeyMask);
			return FALSE;					
		}
		// Don't set an internal _wKeyboardFlag since we check for it
		// anyhow and client might not send WM_KEYUP either
		return TRUE;
	}							
	return fFlag;
}

/*
 *	CW32System::IsAlef(ch)
 *
 *	@func
 *		Used to determine if base character is a Arabic-type Alef.
 *
 *	@rdesc
 *		TRUE iff the base character is an Arabic-type Alef.
 *
 *	@comm
 *		AlefWithMaddaAbove, AlefWithHamzaAbove, AlefWithHamzaBelow,
 *		and Alef are valid matches.
 */
BOOL CW32System::IsAlef(
	TCHAR ch)
{
	return IN_RANGE(0x622, ch, 0x627) && ch != 0x624 && ch != 0x626;
}

/*
 *	CW32System::IsBiDiLcid(lcid)
 *
 *	@func
 *		Return TRUE if lcid corresponds to an RTL language
 *
 *	@rdesc
 *		TRUE if lcid corresponds to an RTL language
 */
BOOL CW32System::IsBiDiLcid(
	LCID lcid)
{
	return
		PRIMARYLANGID(lcid) == LANG_ARABIC ||
		PRIMARYLANGID(lcid) == LANG_HEBREW ||
		PRIMARYLANGID(lcid) == LANG_URDU ||
		PRIMARYLANGID(lcid) == LANG_FARSI;
}

/*
 *	CW32System::IsIndicLcid(lcid)
 *
 *	@func
 *		Return TRUE if lcid corresponds to an Indic language
 *
 *	@rdesc
 *		TRUE if lcid corresponds to an Indic language
 */
BOOL CW32System::IsIndicLcid(
	LCID lcid)
{
	WORD	wLangId = PRIMARYLANGID(lcid);
	
	return
		wLangId == LANG_HINDI 	||
		wLangId == LANG_KONKANI ||
		wLangId == LANG_NEPALI 	||
		IN_RANGE(LANG_BENGALI, wLangId, LANG_SANSKRIT);
}

/*
 *	CW32System::IsIndicKbdInstalled()
 *
 *	@func
 *		Return TRUE if any Indic kbd installed
 */
bool CW32System::IsIndicKbdInstalled()
{
	for (int i = INDIC_FIRSTINDEX; i <= INDIC_LASTINDEX; i++)
		if (_hkl[i] != 0)
			return true;
	return false;
}

/*
 *	CW32System::IsComplexScriptLcid(lcid)
 *
 *	@func
 *		Return TRUE if lcid corresponds to any complex script locales
 *
 */
BOOL CW32System::IsComplexScriptLcid(
	LCID lcid)
{
	return	IsBiDiLcid(lcid) ||
			PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_THAI ||
			PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_VIETNAMESE ||
			IsIndicLcid(lcid);
}

/*
 *	CW32System::IsBiDiDiacritic(ch)
 *
 *	@func	Used to determine if character is a Arabic or Hebrew diacritic.
 *
 *  @rdesc  TRUE iff character is a diacritic
 */
BOOL CW32System::IsBiDiDiacritic(
	TCHAR ch)
{
	return IN_RANGE(0x64B, ch, 0x670) && (ch <= 0x652 || ch == 0x670) ||	// Arabic
		   IN_RANGE(0x591, ch, 0x5C4) && (ch != 0x5A2 && ch != 0x5BA &&		// Hebrew
				ch != 0x5BE && ch != 0x5C0 && ch != 0x5C3);					
}


/*
 *	CW32System::IsVietCdmSequenceValid(ch1, ch2)
 *
 *	@mfunc
 *		Check if ch2 can follow ch1 in case ch2 is a combining diacritic mark (CDM).
 *		Main use is for Vietnamese users (Chau Vu provides the logic below).
 *
 *	@rdesc
 *		TRUE if ch2 can follow ch1
 */
BOOL CW32System::IsVietCdmSequenceValid(
	WCHAR ch1,
	WCHAR ch2)
{
	if (!IN_RANGE(0x300, ch2, 0x323) ||		// Fast out
		!IN_RANGE(0x300, ch2, 0x301) && ch2 != 0x303 && ch2 != 0x309 && ch2 != 0x323)
	{
		return TRUE;						// Not Vietnamese tone mark
	}
	//									  		
	static const BYTE vowels[] = {0xF4, 0xEA, 0xE2, 'y', 'u', 'o', 'i', 'e', 'a'};

	for(int i = ARRAY_SIZE(vowels); i--; )
		if((ch1 | 0x20) == vowels[i])		// Vietnamese tone mark follows
			return TRUE;					//  vowel

	return IN_RANGE(0x102, ch1, 0x103) ||	// A-breve, a-breve
		   IN_RANGE(0x1A0, ch1, 0x1A1) ||	// O-horn,  o-horn
		   IN_RANGE(0x1AF, ch1, 0x1B0);		// U-horn,  u-horn
}

/*
 *  CW32System::IsFELCID(lcid)
 *
 *	@mfunc
 *		Returns TRUE iff lcid is for a East Asian country/region.
 *
 *	@rdesc
 *		TRUE iff lcid is for a East Asian country/region.
 */
bool CW32System::IsFELCID(
	LCID lcid)
{
	switch(PRIMARYLANGID(LANGIDFROMLCID(lcid)))
	{
		case LANG_CHINESE:
		case LANG_JAPANESE:
		case LANG_KOREAN:
			return true;
	}
	return false;
}

/*
 *  CW32System::IsFECharSet(bCharSet)
 *
 *	@mfunc
 *		Returns TRUE iff charset may be for a East Asian country/region.
 *
 *	@rdesc
 *		TRUE iff charset may be for a East Asian country/region.
 *
 */
BOOL CW32System::IsFECharSet(
	BYTE bCharSet)
{
	switch(bCharSet)
	{
		case CHINESEBIG5_CHARSET:
		case SHIFTJIS_CHARSET:
		case HANGEUL_CHARSET:
		case JOHAB_CHARSET:
		case GB2312_CHARSET:
			return TRUE;
	}

	return FALSE;
}

/*
 *  CW32System::Is8BitCodePage(CodePage)
 *
 *	@mfunc
 *		Returns TRUE iff the codepage is 8-bit
 */
BOOL CW32System::Is8BitCodePage(
	unsigned CodePage)
{
	if(!CodePage)
		CodePage = GetACP();

	return IN_RANGE(1250, CodePage, 1258) || CodePage == 874;
}

/*
 *  CW32System::IsFECodePageFont(dwFontCodePageSig)
 *
 *	@mfunc
 *		Returns TRUE iff the font codepage signature reveals only East Asian support
 */
BOOL CW32System::IsFECodePageFont(
	DWORD dwFontCodePageSig)
{
	DWORD	dwFE 	= 0x001e0000;	// Shift-JIS + PRC + Hangeul + Taiwan
	DWORD	dwOthers = 0x000101fc;	// The rest of the world except for Latin-1 and Latin-2

	return (dwFontCodePageSig & dwFE) && !(dwFontCodePageSig & dwOthers);
}

/*
 *  CW32System::IsRTLChar(ch)
 *
 *	@mfunc
 *		Returns TRUE iff ch Arabic or Hebrew
 *
 *	@rdesc
 *		TRUE iff ch is Arabic or Hebrew
 */
BOOL IsRTLChar(
	TCHAR	ch)
{
	// Remark: what about Arabic Presentation Forms?
	//  (0xFB50 - 0xFDFF, 0xFE70 - 0xFEFF)

	return IN_RANGE(0x590, ch, 0x6FF) || ch == RTLMARK;
}

/*
 *  CW32System::IsRTLCharSet(bCharSet)
 *
 *	@mfunc
 *		Returns TRUE iff charset is Arabic or Hebrew
 *
 *	@rdesc
 *		TRUE iff charset may be for Arabic or Hebrew
 */
BOOL CW32System::IsRTLCharSet(
	BYTE bCharSet)
{
	return IN_RANGE(HEBREW_CHARSET, bCharSet, ARABIC_CHARSET);
}

/*
 *	CW32System::IsZWG(ch, bCharSet)
 *
 *	@mfunc
 *		Determines whether a single-byte character is a zero-width glyph
 *		or not. Requires a charset.
 *
 *	@rdesc
 *		TRUE if the character is a zero-width glyph, FALSE otherwise.
 */
BOOL CW32System::IsZWG(
	char ch,
	BYTE bCharSet)
{
	if(IN_RANGE(0x9D, ch, 0x9E))
		return bCharSet == ARABIC_CHARSET;

	if(IN_RANGE(0xFD, ch, 0xFE))
		return IN_RANGE(HEBREW_CHARSET, bCharSet, ARABIC_CHARSET);

	return FALSE;
}

typedef struct {
	WCHAR codepoint;
	WORD  CharFlags;
	BYTE  runlength;
} Data_125X;

/*
 *  CW32System::GetCharFlags125x(ch)
 *
 *	@mfunc
 *		Returns char flags for ch as defined in rgCpgCharSet for 125x
 *		codepages. Bit 0: 1252, bit 1: 1250, bit 2: 1251, else bit x:
 *		125x (for 1253 - 1258).
 *
 *	@rdesc
 *		125x char flags for ch
 */
DWORD CW32System::GetCharFlags125x(
	WCHAR	ch)			//@parm Char to examine
{
	static const WORD rgCpgMask[] = {
		0x1FF,		// 0xA0
		0x131,		// 0xA1
		0x1F1,		// 0xA2
		0x1F9,		// 0xA3
		0x1DF,		// 0xA4
		0x179,		// 0xA5
		0x1FF,		// 0xA6
		0x1FF,		// 0xA7
		0x1FB,		// 0xA8
		0x1FF,		// 0xA9
		0x111,		// 0xAA
		0x1FF,		// 0xAB
		0x1FF,		// 0xAC
		0x1FF,		// 0xAD
		0x1FF,		// 0xAE
		0x1F1,		// 0xAF
		0x1FF,		// 0xB0
		0x1FF,		// 0xB1
		0x1F9,		// 0xB2
		0x1F9,		// 0xB3
		0x1F3,		// 0xB4
		0x1FF,		// 0xB5
		0x1FF,		// 0xB6
		0x1FF,		// 0xB7
		0x1F3,		// 0xB8
		0x1F1,		// 0xB9
		0x111,		// 0xBA
		0x1FF,		// 0xBB
		0x1F1,		// 0xBC
		0x1F9,		// 0xBD
		0x1F1,		// 0xBE
		0x131,		// 0xBF
		0x111,		// 0xC0
		0x113,		// 0xC1
		0x113,		// 0xC2
		0x011,		// 0xC3
		0x193,		// 0xC4
		0x191,		// 0xC5
		0x191,		// 0xC6
		0x113,		// 0xC7
		0x111,		// 0xC8
		0x193,		// 0xC9
		0x111,		// 0xCA
		0x113,		// 0xCB
		0x011,		// 0xCC
		0x113,		// 0xCD
		0x113,		// 0xCE
		0x111,		// 0xCF
		0x001,		// 0xD0
		0x111,		// 0xD1
		0x011,		// 0xD2
		0x193,		// 0xD3
		0x113,		// 0xD4
		0x091,		// 0xD5
		0x193,		// 0xD6
		0x1F3,		// 0xD7
		0x191,		// 0xD8
		0x111,		// 0xD9
		0x113,		// 0xDA
		0x111,		// 0xDB
		0x193,		// 0xDC
		0x003,		// 0xDD
		0x001,		// 0xDE
		0x193,		// 0xDF
		0x151,		// 0xE0
		0x113,		// 0xE1
		0x153,		// 0xE2
		0x011,		// 0xE3
		0x193,		// 0xE4
		0x191,		// 0xE5
		0x191,		// 0xE6
		0x153,		// 0xE7
		0x151,		// 0xE8
		0x1D3,		// 0xE9
		0x151,		// 0xEA
		0x153,		// 0xEB
		0x011,		// 0xEC
		0x113,		// 0xED
		0x153,		// 0xEE
		0x151,		// 0xEF
		0x001,		// 0xF0
		0x111,		// 0xF1
		0x011,		// 0xF2
		0x193,		// 0xF3
		0x153,		// 0xF4
		0x091,		// 0xF5
		0x193,		// 0xF6
		0x1F3,		// 0xF7
		0x191,		// 0xF8
		0x151,		// 0xF9
		0x113,		// 0xFA
		0x151,		// 0xFB
		0x1D3,		// 0xFC
		0x003,		// 0xFD
		0x001,		// 0xFE
		0x111		// 0xFF
	};
	static const Data_125X Table_125X[] = {
		{ 0x100, 0x080,  2},
		{ 0x102, 0x102,  2},
		{ 0x104, 0x082,  4},
		{ 0x10c, 0x082,  2},
		{ 0x10e, 0x002,  2},
		{ 0x110, 0x102,  2},
		{ 0x112, 0x080,  2},
		{ 0x116, 0x080,  2},
		{ 0x118, 0x082,  2},
		{ 0x11a, 0x002,  2},
		{ 0x11e, 0x010,  2},
		{ 0x122, 0x080,  2},
		{ 0x12a, 0x080,  2},
		{ 0x12e, 0x080,  2},
		{ 0x130, 0x010,  2},
		{ 0x136, 0x080,  2},
		{ 0x139, 0x002,  2},
		{ 0x13b, 0x080,  2},
		{ 0x13d, 0x002,  2},
		{ 0x141, 0x082,  4},
		{ 0x145, 0x080,  2},
		{ 0x147, 0x002,  2},
		{ 0x14c, 0x080,  2},
		{ 0x150, 0x002,  2},
		{ 0x152, 0x151,  2},
		{ 0x154, 0x002,  2},
		{ 0x156, 0x080,  2},
		{ 0x158, 0x002,  2},
		{ 0x15a, 0x082,  2},
		{ 0x15e, 0x012,  2},
		{ 0x160, 0x093,  2},
		{ 0x162, 0x002,  4},
		{ 0x16a, 0x080,  2},
		{ 0x16e, 0x002,  4},
		{ 0x172, 0x080,  2},
		{ 0x178, 0x111,  1},
		{ 0x179, 0x082,  4},
		{ 0x17d, 0x083,  2},
		{ 0x192, 0x179,  1},
		{ 0x1A0, 0x100,  2},
		{ 0x1AF, 0x100,  2},
		{ 0x2c6, 0x171,  1},
		{ 0x2c7, 0x082,  1},
		{ 0x2d8, 0x002,  1},
		{ 0x2d9, 0x082,  1},
		{ 0x2db, 0x082,  1},
		{ 0x2dc, 0x131,  1},
		{ 0x2dd, 0x002,  1},
		{ 0x300, 0x100,  2},
		{ 0x303, 0x100,  1},
		{ 0x309, 0x100,  1},
		{ 0x323, 0x100,  1},
		{ 0x384, 0x008,  3},
		{ 0x388, 0x008,  3},
		{ 0x38c, 0x008,  1},
		{ 0x38e, 0x008, 20},
		{ 0x3a3, 0x008, 44},
		{ 0x401, 0x004, 12},
		{ 0x40e, 0x004, 66},
		{ 0x451, 0x004, 12},
		{ 0x45e, 0x004,  2},
		{ 0x490, 0x004,  2},
		{ 0x5b0, 0x020, 20},
		{ 0x5d0, 0x020, 27},
		{ 0x5F0, 0x020,  5},
		{ 0x60c, 0x040,  1},
		{ 0x61b, 0x040,  1},
		{ 0x61f, 0x040,  1},
		{ 0x621, 0x040, 26},
		{ 0x640, 0x040, 19},
		{ 0x679, 0x040,  1},
		{ 0x67e, 0x040,  1},
		{ 0x686, 0x040,  1},
		{ 0x688, 0x040,  1},
		{ 0x691, 0x040,  1},
		{ 0x698, 0x040,  1},
		{ 0x6a9, 0x040,  1},
		{ 0x6af, 0x040,  1},
		{ 0x6ba, 0x040,  1},
		{ 0x6be, 0x040,  1},
		{ 0x6c1, 0x040,  1},
		{ 0x6d2, 0x040,  1},
		{0x200c, 0x040,  2},
		{0x200e, 0x060,  2},
		{0x2013, 0x1ff,  2},
		{0x2015, 0x008,  1},
		{0x2018, 0x1ff,  3},
		{0x201c, 0x1ff,  3},
		{0x2020, 0x1ff,  3},
		{0x2026, 0x1ff,  1},
		{0x2030, 0x1ff,  1},
		{0x2039, 0x1ff,  2},
		{0x20AA, 0x020,  1},
		{0x20AB, 0x100,  1},
		{0x20AC, 0x1ff,  1},
		{0x2116, 0x004,  1},
		{0x2122, 0x1ff,  1}
	};

	// Easy check for ASCII
	if(ch <= 0x7f)
		return 0x1ff00;

	// Easy check for missing codes
	if(ch > 0x2122)
		return 0;

	if(IN_RANGE(0xA0, ch, 0xFF))
		return rgCpgMask[ch - 0xA0] << 8;

	// Perform binary search to find entry in table
	int low = 0;
	int high = ARRAY_SIZE(Table_125X) - 1;
	int middle;
	int midval;
	int runlength;
	
	while(low <= high)
	{
		middle = (high + low) / 2;
		midval = Table_125X[middle].codepoint;
		if(midval > ch)
			high = middle - 1;
		else
			low = middle + 1;
	
		runlength = Table_125X[middle].runlength;
		if(ch >= midval && ch <= midval + runlength - 1)
			return Table_125X[middle].CharFlags << 8;
	}
	return 0;
}

/*
 *	CW32System::IsUTF8BOM(pstr)
 *
 *	@mfunc
 *		Return TRUE if pstr points at a UTF-8 BOM
 *
 *	@rdesc
 *		TRUE iff pstr points at a UTF-8 BOM
 */
BOOL CW32System::IsUTF8BOM(
	BYTE *pstr)
{
	BYTE *pstrUtf8BOM = szUTF8BOM;

	for(LONG i = 3; i--; )
		if(*pstr++ != *pstrUtf8BOM++)
			return FALSE;
	return TRUE;
}

/*
 *	CW32System::GetTrailBytesCount(ach, cpg)
 *
 *	@mfunc
 *		Returns number of trail bytes iff the byte ach is a lead byte for the code page cpg.
 *
 *	@rdesc
 *		count of trail bytes if ach is lead byte for cpg
 *
 *	@comm
 *		This is needed to support CP_UTF8 as well as DBC.
 *		This function potentially doesn't support as many code pages as the
 *		Win32 IsDBCSLeadByte() function (and it might not be as up-to-date).
 *		An AssertSz() is included to compare the results when the code page
 *		is supported by the system.
 *
 *		Reference: \\sparrow\sysnls\cptable\win95. See code-page txt files
 *		in subdirectories windows\txt and others\txt.
 */
int CW32System::GetTrailBytesCount(BYTE ach, UINT cpg)
{

	if(ach < 0x81)									// Smallest known lead
		return 0;									//  byte = 0x81:
													//  early out
	
	BOOL	bDBLeadByte = FALSE;					// Variable to check
													//  result with system
													//  ifdef DEBUG

	if (cpg == CP_UTF8)
	{
		int	cTrailBytes = 0;						// Number of trail bytes for CP_UTF8(0 - 3)
		
		if (ach >= 0x0F0)							// Handle 4-byte form for 16 UTF-16 planes
			cTrailBytes = 3;						// above the BMP) expect:
													// 11110bbb 10bbbbbb 10bbbbbb 10bbbbbb
		else if (ach >= 0x0E0)						// Need at least 3 bytes of form
			cTrailBytes = 2;						// 1110bbbb 10bbbbbb 10bbbbbb
		else if (ach >= 0x0C0)						// Need at least 2 bytes of form
			cTrailBytes = 1;						// 110bbbbb 10bbbbbb

		return cTrailBytes;
	}
	else if(cpg > 950)								
	{
		if(cpg < 1361)								// E.g., the 125x's are
			return 0;								//  SBCSs: early out

		else if(cpg == 1361)								// Korean Johab
			bDBLeadByte = IN_RANGE(0x84, ach, 0xd3) ||		// 0x84 <= ach <= 0xd3
				   IN_RANGE(0xd8, ach, 0xde) ||				// 0xd8 <= ach <= 0xde
				   IN_RANGE(0xe0, ach, 0xf9);				// 0xe0 <= ach <= 0xf9

		else if(cpg == 10001)						// Mac Japanese
			goto JIS;

		else if(cpg == 10002)						// Mac Trad Chinese (Big5)
			bDBLeadByte = ach <= 0xfe;

		else if(cpg == 10003)						// Mac Korean
			bDBLeadByte = IN_RANGE(0xa1, ach, 0xac) ||		// 0xa1 <= ach <= 0xac
				   IN_RANGE(0xb0, ach, 0xc8) ||		// 0xb0 <= ach <= 0xc8
				   IN_RANGE(0xca, ach, 0xfd);		// 0xca <= ach <= 0xfd

		else if(cpg == 10008)						// Mac Simplified Chinese
			bDBLeadByte = IN_RANGE(0xa1, ach, 0xa9) ||		// 0xa1 <= ach <= 0xa9
				   IN_RANGE(0xb0, ach, 0xf7);		// 0xb0 <= ach <= 0xf7
	}
	else if (cpg >= 932)							// cpg <= 950
	{
		if(cpg == 950 || cpg == 949 || cpg == 936)	// Chinese (Taiwan, HK),
			bDBLeadByte = ach <= 0xfe;						//  Korean Ext Wansung,
													//  PRC GBK: 0x81 - 0xfe
		else if(cpg == 932)							// Japanese
JIS:		bDBLeadByte = ach <= 0x9f || IN_RANGE(0xe0, ach, 0xfc);
	}

	#ifdef DEBUG
	TCHAR	ch;
	static	BYTE asz[2] = {0xe0, 0xe0};				// All code pages above

	// if cpg == 0, fRet will FALSE but IsDBCSLeadByteEx may succeed.
	if ( cpg && cpg != CP_SYMBOL && cpg != CP_UTF8)
	{
		// If system supports cpg, then fRet should agree with system result
		AssertSz(MultiByteToWideChar(cpg, 0, (char *)asz, 2, &ch, 1) <= 0 ||
			bDBLeadByte == IsDBCSLeadByteEx(cpg, ach),
			"bDBLeadByte differs from IsDBCSLeadByteEx()");
	}
	#endif

	return bDBLeadByte ? 1 : 0;
}

/*
 *	CW32System::GetGdiCharSet(bCharSet)
 *
 *	@func
 *		Map CHARFORMAT charset to GDI charset (charset used in CreateFont)
 */
BYTE CW32System::GetGdiCharSet(BYTE	bCharSet)
{
	return IsPrivateCharSet(bCharSet) ? DEFAULT_CHARSET : bCharSet;
}

/*
 *	CW32System::GetCharSet(nCP, pScriptIndex)
 *
 *	@func
 *		Get character set for code page <p nCP>. Also returns script index
 *		in *pScriptIndex
 *
 *	@rdesc
 *		CharSet for code page <p nCP>
 */
BYTE CW32System::GetCharSet(
	INT  nCP,				//@parm Code page or index
	int *pScriptIndex)		//@parm Out parm to receive index
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "GetCharSet");

	if(nCP < NCHARSETS)					// nCP is already an index
	{
		nCP = max(nCP, 0);
		if(pScriptIndex)
			*pScriptIndex = nCP;
		return rgCpgCharSet[nCP].bCharSet;
	}

	const CPGCHAR *	pcpgchar = rgCpgCharSet;

	for (int i = 0; i < cCpgCharSet; i++, ++pcpgchar)
	{
		if(pcpgchar->nCodePage == nCP)
			break;
	}
	if(i == cCpgCharSet)
		i = -1;

	if (pScriptIndex)
		*pScriptIndex = i;

	return i >= 0 ? pcpgchar->bCharSet : 0;
}

/*
 *	CW32System::MatchFECharSet(dwCharInfo, dwFontSig)
 *
 *	@func
 *		Get a FE character set for a FE char
 *
 *	@rdesc
 *		CharSet
 */
BYTE CW32System::MatchFECharSet(
	DWORD  dwCharInfo,		//@parm Char Info
	DWORD  dwFontSig)		//@parm Font Signature
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CW32System::MatchFECharSet");

	// Convert Font Signature to our internal char info
	dwFontSig = (dwFontSig << 8) & ~0x00ffff;

	// Get rid of lower word
	dwCharInfo &= ~0x00ffff;

	if (dwCharInfo & dwFontSig & (fKANA | fCHINESE | fHANGUL | fBIG5)) // Perfect match
		goto Exit;											

	if (!(dwFontSig & (fKANA | fCHINESE | fHANGUL | fBIG5)))	// Not a FE font
		goto Exit;

	if (dwCharInfo & (fCHINESE | fBIG5))
	{
		if (dwFontSig & fBIG5)
			return CHINESEBIG5_CHARSET;
		if (dwFontSig & fHANGUL)
			return HANGEUL_CHARSET;
		if (dwFontSig & fKANA)
			return SHIFTJIS_CHARSET;
	}

Exit:
	return GetCharSet(W32->ScriptIndexFromFontSig(dwCharInfo >> 8), NULL);
}

/*
 *	CW32System::GetCodePage(bCharSet)
 *
 *	@func
 *		Get code page for character set <p bCharSet>
 *
 *	@rdesc
 *		Code page for character set <p bCharSet>
 */
INT CW32System::GetCodePage(
	BYTE bCharSet)		//@parm CharSet
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "GetCodePage");

	const CPGCHAR *pcpgchar = rgCpgCharSet;

	for (int i = 0; i < cCpgCharSet ; i++, ++pcpgchar)
	{
		if (pcpgchar->bCharSet == bCharSet)
			return pcpgchar->nCodePage;
	}
	return 0;
}

/*
 *	CW32System::GetFontSig(wCharSet)
 *
 *	@func
 *		Get font signature bits for character set <p wCharSet>. If
 *		wCharSet > 256, treat as a codepage
 *
 *	@rdesc
 *		Font signature mask for character set (or codepage) <p bCharSet>
 */
DWORD CW32System::GetFontSig(
	WORD wCharSet)
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CW32System::GetFontSig");

	const CPGCHAR *	pcpgchar = rgCpgCharSet;
	BOOL fCodePage = wCharSet > 255;

	for (int i = 0; i < cCpgCharSet; i++)
	{
		if(wCharSet == (WORD)(fCodePage ? pcpgchar->nCodePage : pcpgchar->bCharSet))
			return pcpgchar->dwFontSig;
		++pcpgchar;
	}
	return 0;
}

/*
 *	CW32System::GetFirstAvailCharSet(DWORD dwFontSig)
 *
 *	@func
 *		Get first available charset from font signature bits
 */
BYTE CW32System::GetFirstAvailCharSet(
	DWORD dwFontSig)
{
	const CPGCHAR *	pcpgchar = rgCpgCharSet;

	for (int i = 0; i < cCpgCharSet; i++)
	{
		if(pcpgchar->dwFontSig & dwFontSig)
			return pcpgchar->bCharSet;
		++pcpgchar;
	}
	return ANSI_CHARSET;
}

/*
 *	CW32System::GetFontSigFromScript(iScript)
 *
 *	@func
 *		Get font signature bits for script <p iScript>
 *
 *	@rdesc
 *		Font signature mask for script <p iScript>
 */
DWORD CW32System::GetFontSigFromScript(
	int iScript)
{
	return rgCpgCharSet[iScript].dwFontSig;
}

/*
 *	CW32System::ScriptIndexFromFontSig(dwFontSig)
 *
 *	@func
 *		Get script index from font signature
 *
 *	@rdesc
 *		Script index from font signature <p dwFontSig>
 *
 *	@devnote
 *		Linear search
 */
LONG CW32System::ScriptIndexFromFontSig(
	DWORD dwFontSig)
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CW32System::ScriptIndexFromFontSig");

	const CPGCHAR *pcpgchar = rgCpgCharSet;

	for (int i = 0; i < cCpgCharSet; i++, ++pcpgchar)
	{
		if(pcpgchar->dwFontSig == dwFontSig)
			return i;
	}
	return -1;								// Not found
}

/*
 *	CW32System::ScriptIndexFromCharSet(bCharSet)
 *
 *	@func
 *		Get script index from bCharSet
 *
 *	@rdesc
 *		Script index character set <p bCharSet>
 *
 *	@devnote
 *		Linear search
 */
LONG CW32System::ScriptIndexFromCharSet(
	BYTE bCharSet)
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CW32System::ScriptIndexFromCharSet");

	const CPGCHAR *pcpgchar = rgCpgCharSet;

	for (int i = 0; i < cCpgCharSet; i++, ++pcpgchar)
	{
		if(pcpgchar->bCharSet == bCharSet)
			return i;
	}
	return -1;								// Not found
}

/*
 *	CW32System::IsCharSetValid(bCharSet)
 *
 *	@func
 *		Return TRUE iff <p bCharSet> is a valid character set index
 *
 *	@rdesc
 *		TRUE iff <p bCharSet> is a valid character set index
 */
BOOL CW32System::IsCharSetValid(
	BYTE bCharSet)		//@parm CharSet
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CW32System::IsCharSetValid");

	return ScriptIndexFromCharSet(bCharSet) >= 0;
}

/*
 *	CW32System::GetScreenDC(void)
 *
 *	@mfunc
 *	Returns you a default screen DC which richedit caches for its lifetime.
 *
 *	Note, you need to serialize access to DCs, so make sure its used in the
 *	renderer and measurer or otherwise protected by a CLock.
 *
 *	@rdesc
 *		Screen HDC if succeeded.
 */
HDC	CW32System::GetScreenDC()
{
	if (!_hdcScreen)
		_hdcScreen = CreateIC(L"DISPLAY", NULL, NULL, NULL);;

	//Verify DC validity
	Assert(GetDeviceCaps(_hdcScreen, LOGPIXELSX));

	return _hdcScreen;
}

/*
 *	CW32System::GetTextMetrics(hdc, &lf, &tm)
 *
 *	@mfunc
 *		CreateFontIndirect(lf), select into hdc, and get TEXTMETRICS
 *
 *	@rdesc
 *		TRUE if succeeded and selected facename is same as lf.lfFaceName
 */
BOOL CW32System::GetTextMetrics(
	HDC			hdc,
	LOGFONT &	lf,
	TEXTMETRIC &tm)
{
	HFONT hfont = CreateFontIndirect(&lf);
	if(!hfont)
		return FALSE;

	HFONT hfontOld = SelectFont(hdc, hfont);
	WCHAR szFaceName[LF_FACESIZE + 1];

	BOOL  fRet = GetTextFace(hdc, LF_FACESIZE, szFaceName) &&
				 !wcsicmp(lf.lfFaceName, szFaceName) &&
				  W32->GetTextMetrics(hdc, &tm);

	SelectFont(hdc, hfontOld);
	DeleteObject(hfont);
	return fRet;
}

/*
 *	CW32System::ValidateStreamWparam(wparam)
 *
 *	@mfunc
 *		Examine lparam to see if hiword is a valid codepage. If not set it
 *		to 0 and turn off SF_USECODEPAGE flag
 *
 *	@rdesc
 *		Validated lparam
 */
WPARAM CW32System::ValidateStreamWparam(
	WPARAM wparam)		//@parm EM_STREAMIN/OUT wparam
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CW32System::ValidateStreamWparam");

	if ((wparam & SF_USECODEPAGE) && !IsValidCodePage(HIWORD(wparam)) &&
		HIWORD(wparam) != CP_UTF8)
	{
		// Invalid codepage, so reset codepage parameters
		wparam &= 0xFFFF & ~SF_USECODEPAGE;
	}
	return wparam;
}

/*
 *	CW32System::MECharClass(ch)
 *
 *	@func
 *		return ME character type for purposes of CharSet stamping.  Values
 *		are:
 *
 *		0: Arabic (specific RTL)
 *		1: Hebrew (specific RTL)
 *		2: RTL (generic RTL, e.g., RTL mark)
 *		3: LTR
 *		4: EOP or start/end of text
 *		5: ASCII digit
 *		6: punctuation and neutrals
 *
 *	@rdesc
 *		ME character class
 */
CC CW32System::MECharClass(
	TCHAR	ch)
{
	AssertSz(CC_NEUTRAL > CC_ASCIIDIGIT && CC_ASCIIDIGIT > CC_EOP &&
			 CC_EOP > CC_LTR && CC_LTR > CC_RTL && CC_RTL > CC_ARABIC,
		"CW32System::MECharClass: invalid CC values");

	// Work down Unicode values from large to small. Use nested if
	// statements to reduce the number executed.

	// Remark: what about Arabic Presentation Forms?
	//  (0xFB50 - 0xFDFF, 0xFE70 - 0xFEFF)

	if(ch >= 0x700)
	{
		if(IN_RANGE(ENQUAD, ch, RTLMARK))
		{								// ENQUAD thru RTLMARK
			if(ch == RTLMARK)			// Maybe add more Unicode general
				return CC_RTL;			//  punctuation?

			if(IN_RANGE(ZWNJ, ch, ZWJ))	// ZWNJ & ZWJ are handled as Arabic,
				return CC_ARABIC;		//  even though they actually shouldn't
										//  affect layout.
			if(ch < ZWNJ)
				return CC_NEUTRAL;		// Various blanks are neutral
		}
		return CC_LTR;
	}

	if(ch >= 0x40)
	{
		if(ch >= 0x590)
			return (ch >= 0x600) ? CC_ARABIC : CC_HEBREW;

		if(IN_RANGE(0x7B, (ch | 0x20), 0x7F) || ch == 0x60 || ch == 0x40)
			return CC_NEUTRAL;			// [\]^_{|}~`@

		return CC_LTR;
	}

	if(ch >= 0x20)
	{
		if(IN_RANGE(0x30, ch, 0x39))
			return CC_ASCIIDIGIT;

		return CC_NEUTRAL;
	}

	Assert(ch < 0x20);
	if((1 << ch) & 0x00003201) /* IsASCIIEOP(ch) || ch == TAB || !ch */
		return CC_EOP;
		
	return CC_LTR;	
}

/*
 *	CW32System::ScriptIndexFromChar (ch)
 *
 *	@mfunc
 *		Returns index into CharSet/CodePage table rgCpgCharSet corresponding
 *		to the Unicode character ch provided such an assignment is
 *		reasonably unambiguous, that is, the currently assigned Unicode
 *		characters in various ranges have Windows code-page equivalents.
 *		Ambiguous or impossible assignments return UNKNOWN_INDEX, which
 *		means that the character can only be represented by Unicode in this
 *		simple model.  Note that the UNKNOWN_INDEX, HAN_INDEX, and FE_INDEX
 *		are negative values, i.e., they imply further processing to figure
 *		out what (if any) charset index to use.  Other indices may also
 *		require run processing, such as the blank in BiDi text.  We need
 *		to mark our right-to-left runs with an Arabic or Hebrew char set,
 *		while we mark left-to-right runs with a left-to-right char set.
 *
 *		If the index has the FE_FLAG bit set, then the character is some kind
 *		of FE "DBCS" character, like a Han, Kana, or Hangul character.
 *		FE_INDEX, HAN_INDEX, HANGUL_INDEX, and SHIFTJIS_INDEX all have this
 *		flag set.
 *
 *	@rdesc
 *		Script index in low word, and possible some extra flags, like
 *		FE_FLAG in high word
 */
LONG CW32System::ScriptIndexFromChar(
	TCHAR ch)		//@parm Unicode character to examine
{
	if(ch < 256)
		return ANSI_INDEX;

	if(ch < 0x700)
	{
		if(ch >= 0x600)
			return ARABIC_INDEX;

		if(ch > 0x590)
			return HEBREW_INDEX;

		if(ch < 0x500)
		{
			if(ch >= 0x400)
				return RUSSIAN_INDEX;

			if(ch >= 0x370)
				return GREEK_INDEX;
		}
	}
	else if(ch < 0x2500)
	{	
		if(IN_RANGE(0xE00, ch, 0xE7F))	// Thai
			return THAI_INDEX;
	}
	else if(ch < 0xAC00)
	{
		if(ch >= 0x3400)				// CJK Ideographs
			return HAN_INDEX;

		if(ch >= 0x3100)
			return FE_INDEX;

		if(ch > 0x3040)					// Katakana and Hiragana
			return SHIFTJIS_INDEX;

		if(ch >= 0x3000)
			return FE_INDEX;
	}
	else if(ch < 0xD800)
		return HANGUL_INDEX;

	else if(ch > 0xFF00)
	{
		if(ch < 0xFF65)					// Fullwidth ASCII and halfwidth
			return HAN_INDEX;			//  CJK punctuation

		if(ch < 0xFFA0)					// Halfwidth Katakana
			return SHIFTJIS_INDEX;

		if(ch < 0xFFE0)					// Halfwidth Jamo
			return HANGUL_INDEX;

		if(ch < 0xFFEF)					// Fullwidth punctuation and currency
			return HAN_INDEX;			//  signs; halfwidth forms, arrows
	}									//  and shapes
	return UNKNOWN_INDEX;
}

/*
 *	CW32System::MBTWC (CodePage, dwFlags, pstrMB, cchMB, pstrWC, cchWC, pfNoCodePage)
 *
 *	@mfunc
 *		Convert MultiByte (MB) string pstrMB of length cchMB to WideChar (WC)
 *		string pstrWC of length cchWC according to the flags dwFlags and code
 *		page CodePage.  If CodePage = SYMBOL_CODEPAGE
 *		(usually for SYMBOL_CHARSET strings),
 *		convert each byte in pstrMB to a wide char with a zero high byte
 *		and a low byte equal to the MultiByte string byte, i.e., no
 *		translation other than a zero extend into the high byte.  Else call
 *		the Win32 MultiByteToWideChar() function.
 *
 *	@rdesc
 *		Count of characters converted
 */
int CW32System::MBTWC(
	INT		CodePage,	//@parm Code page to use for conversion
	DWORD	dwFlags,	//@parm Flags to guide conversion
	LPCSTR	pstrMB,		//@parm MultiByte string to convert to WideChar
	int		cchMB,		//@parm Count of chars (bytes) in pstrMB or -1
	LPWSTR	pstrWC,		//@parm WideChar string to receive converted chars
	int		cchWC,		//@parm Max count for pstrWC or 0 to get cch needed
	LPBOOL 	pfNoCodePage) //@parm Out parm to receive whether code page is on system
{
	BOOL	fNoCodePage = FALSE;			// Default code page is on OS
	int		cch = -1;

	if(CodePage == CP_UTF8)
	{
		DWORD ch,ch1;

		for(cch = 0; cchMB--; )
		{
			ch = ch1 = *(BYTE *)pstrMB++;
			Assert(ch < 256);
			if(ch > 127 && cchMB && IN_RANGE(0x80, *(BYTE *)pstrMB, 0xBF))
			{
				// Need at least 2 bytes of form 110bbbbb 10bbbbbb
				ch1 = ((ch1 & 0x1F) << 6) + (*pstrMB++ & 0x3F);
				cchMB--;
				if(ch >= 0xE0 && cchMB && IN_RANGE(0x80, *(BYTE *)pstrMB, 0xBF))
				{
					// Need at least 3 bytes of form 1110bbbb 10bbbbbb 10bbbbbb
					ch1 = (ch1 << 6) + (*pstrMB++ & 0x3F);
					cchMB--;
					if (ch >= 0xF0 && cchMB && IN_RANGE(0x80, *(BYTE *)pstrMB, 0xBF))
					{
						// Handle 4-byte form for 16 UTF-16 planes above the
						// BMP) expect: 11110bbb 10bbbbbb 10bbbbbb 10bbbbbb
						ch1 = ((ch1 & 0x7FFF) << 6) + (*(BYTE *)pstrMB++ & 0x3F)
							- 0x10000;			// Subtract offset for BMP
						if(ch1 <= 0xFFFFF)		// Fits in 20 bits
						{
							cch++;				// Two 16-bit surrogate codes
							if(cch < cchWC)
								*pstrWC++ = UTF16_LEAD + (ch1 >> 10);
							ch1 = (ch1 & 0x3FF) + UTF16_TRAIL;
							cchMB--;
						}
						else ch1 = '?';
					}
				}
			}
			cch++;
			if(cch < cchWC)
				*pstrWC++ = ch1;
			if(!ch)
				break;
		}
	}
	else if(CodePage != CP_SYMBOL)			// Not SYMBOL_CHARSET
	{
		fNoCodePage = TRUE;					// Default codepage isn't on OS
		if(CodePage >= 0)					// Might be..
		{
			cch = MultiByteToWideChar(
				CodePage, dwFlags, pstrMB, cchMB, pstrWC, cchWC);
			if(cch > 0)
				fNoCodePage = FALSE;		// Codepage is on OS
		}
	}
	if(pfNoCodePage)
		*pfNoCodePage = fNoCodePage;

	if(cch <= 0)
	{			
		// SYMBOL_CHARSET or conversion failed: bytes -> words with
		//  high bytes of 0.  Return count for full conversion

		if(cchWC <= 0)					
			return cchMB >= 0 ? cchMB : (strlen(pstrMB) + 1);

		int cchMBMax = cchMB;

		if(cchMB < 0)					// If negative, use NULL termination
			cchMBMax = tomForward;			//  of pstrMB

		cchMBMax = min(cchMBMax, cchWC);

		for(cch = 0; (cchMB < 0 ? *pstrMB : 1) && cch < cchMBMax; cch++)
		{
			*pstrWC++ = (unsigned char)*pstrMB++;
		}
		
		// NULL-terminate the WC string if the MB string was NULL-terminated,
		// and if there is room in the WC buffer.
		if(cchMB < 0 && cch < cchWC)
		{
			*pstrWC = 0;
			cch++;
		}
	}
	return cch;
}

/*
 *	CW32System::WCTMB (CodePage, dwFlags, pstrWC, cchWC, pstrMB, cchMB,
 *					   pchDefault, pfUsedDef, pfNoCodePage, fTestCodePage)
 *
 *	@mfunc
 *		Convert WideChar (WC) string pstrWC of length cchWC to MultiByte (MB)
 *		string pstrMB of length cchMB according to the flags dwFlags and code
 *		page CodePage.  If CodePage = SYMBOL_CODEPAGE
 *		(usually for SYMBOL_CHARSET strings),
 *		convert each character in pstrWC to a byte, discarding the high byte.
 *		Else call the Win32 WideCharToMultiByte() function.
 *
 *	@rdesc
 *		Count of bytes stored in target string pstrMB
 */
int CW32System::WCTMB(
	INT		CodePage,	//@parm Code page to use for conversion
	DWORD	dwFlags,	//@parm Flags to guide conversion
	LPCWSTR	pstrWC,		//@parm WideChar string to convert
	int		cchWC,		//@parm Count for pstrWC or -1 to use NULL termination
	LPSTR	pstrMB,		//@parm MultiByte string to receive converted chars
	int		cchMB,		//@parm Count of chars (bytes) in pstrMB or 0
	LPCSTR	pchDefault,	//@parm Default char to use if conversion fails
	LPBOOL	pfUsedDef,	//@parm Out parm to receive whether default char used
	LPBOOL 	pfNoCodePage, //@parm Out parm to receive whether code page is on system
	BOOL	fTestCodePage)//@parm Test CodePage could handle the pstrWC
{
	int		cch = -1;						// No chars converted yet
	BOOL	fNoCodePage = FALSE;			// Default code page is on OS

	if(pfUsedDef)							// Default that all chars can be
		*pfUsedDef = FALSE;					//  converted

#ifndef WC_NO_BEST_FIT_CHARS
#define WC_NO_BEST_FIT_CHARS	0x400
#endif

	if (_dwPlatformId == VER_PLATFORM_WIN32_NT &&
		_dwMajorVersion > 4 && !dwFlags)
	{
		dwFlags = WC_NO_BEST_FIT_CHARS;
	}

	if(CodePage == CP_UTF8)					// Convert to UTF8 since OS
	{										// doesn't (pre NT 5.0)
		unsigned ch;
		cch = 0;							// No converted bytes yet
		while(cchWC--)
		{
			ch = *pstrWC++;					// Get Unicode char
			if(ch <= 127)					// It's ASCII
			{
				cch++;
				if(cch < cchMB)
					*pstrMB++ = ch;			// One more converted byte
				if(!ch)						// Quit on NULL termination
					break;
				continue;
			}
			if(ch <= 0x7FF)					// Need 2 bytes of form:
			{								//  110bbbbb 10bbbbbb
				cch += 2;
				if(cch < cchMB)				// Store lead byte
					*pstrMB++ = 0xC0 + (ch >> 6);
			}
			else if(IN_RANGE(UTF16_LEAD, ch, 0xDBFF))
			{								// Unicode surrogate pair
				cch += 4;					// Need 4 bytes of form:
				if(cch < cchMB)				//  11110bbb 10bbbbbb 10bbbbbb
				{							//  10bbbbbb
					AssertSz(IN_RANGE(UTF16_TRAIL, *pstrWC, 0xDFFF),
						"CW32System::WCTMB: illegal surrogate pair");
					cchWC--;
					ch = ((ch & 0x3FF) << 10) + (*pstrWC++ & 0x3FF) + 0x10000;
					*pstrMB++ = 0xF0 + (ch >> 18);
					*pstrMB++ = 0x80 + (ch >> 12 & 0x3F);
					*pstrMB++ = 0x80 + (ch >> 6  & 0x3F);
				}
			}
			else							// Need 3 bytes of form:
			{								//  1110bbbb 10bbbbbb
				cch += 3;					//  10bbbbbb
				if(cch < cchMB)				// Store lead byte followed by
				{							//  first trail byte
					*pstrMB++ = 0xE0 + (ch >> 12);
					*pstrMB++ = 0x80 + (ch >> 6 & 0x3F);
				}
			}
			if(cch < cchMB)					// Store final UTF-8 byte
				*pstrMB++ = 0x80 + (ch & 0x3F);
		}
	}
	else if(CodePage != CP_SYMBOL)
	{
		fNoCodePage = TRUE;					// Default codepage not on OS
		if(CodePage >= 0)					// Might be...
		{
			cch = WideCharToMultiByte(CodePage, dwFlags,
					pstrWC, cchWC, pstrMB, cchMB, pchDefault, pfUsedDef);
			if(cch > 0)
				fNoCodePage = FALSE;		// Found codepage on system
		}
	}
	if(pfNoCodePage)
		*pfNoCodePage = fNoCodePage;

	// Early exit if we are just testing for CodePage
	if (fTestCodePage)
		return cch;

	// SYMBOL_CHARSET, fIsDBCS or conversion failed: low bytes of words ->
	//  bytes
	if(cch <= 0)
	{									
		// Return multibyte count for full conversion. cchWC is correct for
		// single-byte charsets like the 125x's
		if(cchMB <= 0)
		{
			return cchWC >= 0 ? cchWC : wcslen(pstrWC);
		}

		char chDefault = 0;
		BOOL fUseDefaultChar = (pfUsedDef || pchDefault) && CodePage != CP_SYMBOL;

		if(fUseDefaultChar)
		{
			// determine a default char for our home-grown conversion
			if(pchDefault)
			{
				chDefault = *pchDefault;
			}
			else
			{
				static char chSysDef = 0;
				static BOOL fGotSysDef = FALSE;

				// 0x2022 is a math symbol with no conversion to ANSI
				const WCHAR szCantConvert[] = { 0x2022 };
				BOOL fUsedDef;

				if(!fGotSysDef)
				{
					fGotSysDef = TRUE;

					if(!(WideCharToMultiByte
							(CP_ACP, 0, szCantConvert, 1, &chSysDef, 1, NULL,
										&fUsedDef) == 1 && fUsedDef))
					{
						AssertSz(0, "WCTMB():  Unable to determine what the "
									"system uses as its default replacement "
									"character.");
						chSysDef = '?';
					}
				}
				chDefault = chSysDef;
			}
		}

		int cchWCMax = cchWC;

		// If negative, use NULL termination of pstrMB
		if(cchWC < 0)
		{
			cchWCMax = tomForward;
		}

		cchWCMax = min(cchWCMax, cchMB);

		for(cch = 0; (cchWC < 0 ? *pstrWC : 1) && cch < cchWCMax; cch++)
		{
			// TODO(BradO):  Should this be 0x7F in some conversion cases?
			if(fUseDefaultChar && *pstrWC > 0xFF)
			{
				if(pfUsedDef)
				{
					*pfUsedDef = TRUE;
				}
				*pstrMB = chDefault;
			}
			else
			{
				*pstrMB = (BYTE)*pstrWC;
			}
			pstrMB++;
			pstrWC++;
		}

		if(cchWC < 0 && cch < cchMB)
		{
			*pstrMB = 0;
			cch++;
		}
	}
	return cch;
}
/*
 *	CW32System::VerifyFEString(cpg, pstrWC, cchWC, fTestInputCpg)
 *
 *	@mfunc
 *		Verify if the input cpg can handle the pstrWC.
 *		If not, select another FE cpg.
 *
 *	@rdesc
 *		New CodePage for the pstrWC
 */
#define NUMBER_OF_CHARS	64
	
int CW32System::VerifyFEString(
	INT		cpg,			//@parm cpg to format the pstrWC
	LPCWSTR	pstrWC,			//@parm WideChar string to test
	int		cchWC,			//@parm Count for pstrWC
	BOOL	fTestInputCpg)	//@parm test the input cpg only
{
	if (cchWC <=0)
		return cpg;

	int				cpgNew = cpg;
	BOOL			fUsedDef;
	int				cchMB = cchWC * sizeof(WCHAR);
	CTempCharBuf	tcb;
	char			*pstrMB = tcb.GetBuf(cchMB);
	CTempWcharBuf	twcb;
	WCHAR			*pstrWchar = twcb.GetBuf(cchWC);						
	static			int	aiCpg[4] =
		{ CP_JAPAN, CP_KOREAN, CP_CHINESE_TRAD, CP_CHINESE_SIM };	

	if (pstrMB)
	{
		int	cchConverted = WCTMB(cpg, 0, pstrWC, cchWC, pstrMB, cchMB, NULL,
				&fUsedDef, NULL, TRUE);

		if (cchConverted > 0 && !fUsedDef && IsFEFontInSystem(cpg))	
		{
			cchConverted = MBTWC(cpg, 0, pstrMB, cchConverted, pstrWchar, cchWC, NULL);

			if (cchConverted == cchWC && memcmp(pstrWC, pstrWchar, cchMB) == 0)			
				goto Exit;					// Found it
		}		
		
		if (fTestInputCpg)				// Only need to test the input cpg			
			cpgNew = -1;				// Indicate cpg doesn't support the string
		else
		{
			// If no conversion or if the default character is used or
			// no such FE font in system,
			// it means that this cpg may not be the right choice.
			// Let's try other FE cpg.
			for (int i=0; i < 4; i++)
			{
				if (cpg != aiCpg[i])
				{
					cchConverted = WCTMB(aiCpg[i], 0, pstrWC, cchWC, pstrMB, cchMB, NULL,
						&fUsedDef, NULL, TRUE);

					if (cchConverted > 0 && !fUsedDef && IsFEFontInSystem(aiCpg[i]))	
					{
						cchConverted = MBTWC(aiCpg[i], 0, pstrMB, cchConverted, pstrWchar, cchWC, NULL);

						if (cchConverted == cchWC && memcmp(pstrWC, pstrWchar, cchMB) == 0)	
						{
							cpgNew = aiCpg[i];	// Found it
							break;
						}
					}
				}
			}
		}
	}			

Exit:

	return cpgNew;
}

int __cdecl CW32System::sprintf(char * buff, char *fmt, ...)
{
	va_list	marker;

	va_start(marker, fmt);
	int cb = W32->WvsprintfA(0x07FFFFFFF, buff, fmt, marker);
	va_end(marker);

	return cb;
}

//NOTE: Keep this at the end because we want any allocations in w32sys.cpp to be validated
//just like the rest of RichEdit.
///////////////////////////////  Memory mamagement  /////////////////////////////////

#ifdef DEBUG
#undef PvAlloc
#undef PvReAlloc
#undef FreePv
#undef new

MST vrgmst[100];

typedef struct tagPVH //PV Header
{
	char	*szFile;
	int		line;
	tagPVH	*ppvhNext;
	int		cbAlloc;	//On Win'95, the size returned is not the size allocated.
	int		magicPvh;	//Should be last
} PVH;
#define cbPvh (sizeof(PVH))

typedef struct //PV Tail
{
	int		magicPvt; //Must be first
} PVT;

#define cbPvt (sizeof(PVT))
#define cbPvDebug (cbPvh + cbPvt)

void *vpHead = 0;

/*
 *	CW32System::UpdateMst(void)
 *
 *	@mfunc Fills up the vrgmst structure with summary information about our memory
 *	usage.
 *
 *	@rdesc
 *		void
 */
void UpdateMst(void)
{
	W32->ZeroMemory(vrgmst, sizeof(vrgmst));

	PVH		*ppvh;
	MST		*pmst;

	ppvh = (PVH*) vpHead;

	while (ppvh != 0)
	{
		pmst = vrgmst;

		//Look for entry in list...
		while (pmst->szFile)
		{
			if (strcmp(pmst->szFile, ppvh->szFile) == 0)
			{
				pmst->cbAlloc += ppvh->cbAlloc;
				break;
			}
			pmst++;
		}

		if (pmst->szFile == 0)
		{
			pmst->szFile = ppvh->szFile;
			pmst->cbAlloc = ppvh->cbAlloc;
		}

		ppvh = ppvh->ppvhNext;
	}
}

/*
 *	PvDebugValidate(void)
 *
 *	@func Verifies the the node is proper.  Pass in a pointer to the users data
 *	(after the header node.)
 *
 *	@rdesc
 *		void
 */
void PvDebugValidate(void *pv)
{
	PVH	*ppvh;
	PVT *ppvt;

	ppvh = (PVH*) ((char*) pv - cbPvh);
	ppvt = (PVT*) ((char*) pv + ppvh->cbAlloc);

	AssertSz(ppvh->magicPvh == 0x12345678, "PvDebugValidate: header bytes are corrupt");
	AssertSz(ppvt->magicPvt == 0xfedcba98, "PvDebugValidate: tail bytes are corrupt");
}

/*
 *	CW32System::PvSet(pv, szFile, line)
 *
 *	@mfunc Sets a different module and line number for
 *
 *	@rdesc
 *		void
 */
void CW32System::PvSet(void *pv, char *szFile, int line)
{
	if (pv == 0)
		return;

	PvDebugValidate(pv);
	PVH *ppvh = (PVH*) ((char*) pv - cbPvh);

	ppvh->szFile = szFile;
	ppvh->line = line;
}
/*
 *	CW32System::PvAllocDebug(cb, uiMemFlags, szFile, line)
 *
 *	@mfunc Allocates a generic (void*) pointer. This is a debug only routine which
 *	tracks the allocation.
 *
 *	@rdesc
 *		void
 */
void* CW32System::PvAllocDebug(ULONG cb, UINT uiMemFlags, char *szFile, int line)
{
	void	*pv;

	pv = PvAlloc(cb + cbPvDebug, uiMemFlags);
	if (!pv)
		return 0;

	PVH	*ppvh;
	PVT *ppvt;

	ppvt = (PVT*) ((char*) pv + cb + cbPvh);
	ppvh = (PVH*) pv;

	ZeroMemory(ppvh, sizeof(PVH));
	ppvh->magicPvh = 0x12345678;
	ppvt->magicPvt = 0xfedcba98;
	ppvh->szFile = szFile;
	ppvh->line = line;
	ppvh->cbAlloc = cb;

	ppvh->ppvhNext = (PVH*) vpHead;
	vpHead = pv;

	return (char*) pv + cbPvh;
}

/*
 *	CW32System::PvReAllocDebug(pv, cb, szFile, line)
 *
 *	@mfunc ReAllocates a generic (void*) pointer. This is a debug only routine which
 *	tracks the allocation.
 *
 *	@rdesc
 *		void
 */
void* CW32System::PvReAllocDebug(void *pv, ULONG cb, char *szFile, int line)
{
	void	*pvNew;
	PVH	*ppvh, *ppvhHead, *ppvhTail;
	PVT *ppvt;
	ppvh = (PVH*) ((char*) pv - cbPvh);

	if (!pv)
		return PvAllocDebug(cb, 0, szFile, line);

	PvDebugValidate(pv);

	pvNew = PvReAlloc((char*) pv - cbPvh, cb + cbPvDebug);

	if (!pvNew)
		return 0;

	ppvt = (PVT*) ((char*) pvNew + cb + cbPvh);
	ppvh = (PVH*) pvNew;
	ppvh->cbAlloc = cb;

	//Put the new trailer bytes in.
	ppvt->magicPvt = 0xfedcba98;

	//Make the pointer list up to date again
	if (pv != pvNew)
	{
		ppvhTail = 0;
		ppvhHead = (PVH*) vpHead;

		while ((char*)ppvhHead != (char*)pv - cbPvh)
		{
			AssertSz(ppvhHead, "entry not found in list.");
			ppvhTail = ppvhHead;
			ppvhHead = (PVH*) ppvhHead->ppvhNext;
		}

		if (ppvhTail == 0)
			vpHead = pvNew;
		else
			ppvhTail->ppvhNext = (PVH*) pvNew;
	}

	return (char*) pvNew + cbPvh;
}

/*
 *	CW32System::FreePvDebug(pv)
 *
 *	@mfunc Returns a pointer when you are done with it.
 *
 *	@rdesc
 *		void
 */
void CW32System::FreePvDebug(void *pv)
{
	if (!pv)
		return;

	PvDebugValidate(pv);

	PVH	*ppvhHead, *ppvhTail, *ppvh;

	AssertSz(vpHead, "Deleting from empty free list.");

	ppvh = (PVH*) ((char*) pv - cbPvh);
	
	//Search and remove the entry from the list
	ppvhTail = 0;
	ppvhHead = (PVH*) vpHead;

	while ((char*) ppvhHead != ((char*) pv - cbPvh))
	{
		AssertSz(ppvhHead, "entry not found in list.");
		ppvhTail = ppvhHead;
		ppvhHead = (PVH*) ppvhHead->ppvhNext;
	}

	if (ppvhTail == 0)
		vpHead = ppvhHead->ppvhNext;
	else
		ppvhTail->ppvhNext = ppvhHead->ppvhNext;

	FreePv((char*) pv - cbPvh);
}

/*
 *	CatchLeaks(void)
 *
 *	@func Displays any memory leaks in a dialog box.
 *
 *	@rdesc
 *		void
 */
void CatchLeaks(void)
{
	PVH		*ppvh;
	char szLeak[512];

	ppvh = (PVH*) vpHead;
	while (ppvh != 0)
	{
		wsprintfA(szLeak, "Memory Leak of %d bytes: -- File: %s, Line: %d", ppvh->cbAlloc, ppvh->szFile, ppvh->line);
	    if (NULL != pfnAssert)
		{
			// if we have an assert hook, give the user a chance to process the leak message
			if (pfnAssert(szLeak, ppvh->szFile, &ppvh->line))
			{
				// hook returned true, show the message box
				MessageBoxA(NULL, szLeak, "", MB_OK);				
			}
		}
		else
		{
			MessageBoxA(NULL, szLeak, "", MB_OK);
		}
		ppvh = ppvh->ppvhNext;
	}
}

void* _cdecl operator new (size_t size, char *szFile, int line)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "new");

	return W32->PvAllocDebug(size, GMEM_ZEROINIT, szFile, line);
}

void _cdecl operator delete (void* pv)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "delete");

	W32->FreePvDebug(pv);
}

#else //DEBUG

void* _cdecl operator new (size_t size)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "new");

	return W32->PvAlloc(size, GMEM_ZEROINIT);
}

void _cdecl operator delete (void* pv)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "delete");

	W32->FreePv(pv);
}

#endif //DEBUG


/*
 *	PvAlloc (cbBuf, uiMemFlags)
 *
 *	@mfunc	memory allocation.  Similar to GlobalAlloc.
 *
 *	@comm	The only flag of interest is GMEM_ZEROINIT, which
 *			specifies that memory should be zeroed after allocation.
 */
PVOID CW32System::PvAlloc(
	ULONG	cbBuf, 			//@parm	Count of bytes to allocate
	UINT	uiMemFlags)		//@parm Flags controlling allocation
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "PvAlloc");
	
	void * pv = LocalAlloc(LMEM_FIXED, cbBuf);

	if( pv && (uiMemFlags & GMEM_ZEROINIT) )
		ZeroMemory(pv, cbBuf);
	
	return pv;
}

/*
 *	PvReAlloc	(pvBuf, cbBuf)
 *
 *	@mfunc	memory reallocation.
 *
 */
PVOID CW32System::PvReAlloc(
	PVOID	pvBuf, 		//@parm Buffer to reallocate
	DWORD	cbBuf)		//@parm New size of buffer
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "PvReAlloc");

	if(pvBuf)
		return LocalReAlloc(pvBuf, cbBuf, LMEM_MOVEABLE);

	return LocalAlloc(LMEM_FIXED, cbBuf);
}

/*
 *	FreePv (pvBuf)
 *
 *	@mfunc	frees memory
 *
 *	@rdesc	void
 */
void CW32System::FreePv(
	PVOID pvBuf)		//@parm Buffer to free
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "FreePv");

	if(pvBuf)
		LocalFree(pvBuf);
}


/*
 *	Mirroring API (only in BiDi Win98 and NT5 upward)
 *
 *	@mfunc	Get/Set DC mirroring effect
 *
 */

DWORD WINAPI GetLayoutStub(HDC hdc)
{
	return 0;
}

DWORD WINAPI SetLayoutStub(HDC hdc, DWORD dwLayout)
{
	return 0;
}

DWORD WINAPI GetLayoutInit(HDC hdc)
{
	CLock		lock;
	HINSTANCE	hMod = ::GetModuleHandleA("GDI32.DLL");
	Assert(hMod);

	W32->_pfnGetLayout = (PFN_GETLAYOUT)GetProcAddress(hMod, "GetLayout");

	if (!W32->_pfnGetLayout)
		W32->_pfnGetLayout = &GetLayoutStub;

	return W32->_pfnGetLayout(hdc);
}

DWORD WINAPI SetLayoutInit(HDC hdc, DWORD dwLayout)
{
	CLock		lock;
	HINSTANCE	hMod = ::GetModuleHandleA("GDI32.DLL");
	Assert(hMod);

	W32->_pfnSetLayout = (PFN_SETLAYOUT)GetProcAddress(hMod, "SetLayout");

	if (!W32->_pfnSetLayout)
		W32->_pfnSetLayout = &SetLayoutStub;

	return W32->_pfnSetLayout(hdc, dwLayout);
}

PFN_GETLAYOUT	CW32System::_pfnGetLayout = &GetLayoutInit;
PFN_SETLAYOUT	CW32System::_pfnSetLayout = &SetLayoutInit;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\winresrc.h ===
/*++ BUILD Version: 0001     Increment this if a change has global effects

Copyright (c) 1990-1996  Microsoft Corporation

Module Name:

    winresrc.h

Abstract:

    This module defines the 32-Bit Windows resource codes.

Revision History:

--*/

#ifndef _WINRESRC_
#define _WINRESRC_



/*
 * ShowWindow() Commands
 */
#define SW_HIDE             0
#define SW_SHOWNORMAL       1
#define SW_NORMAL           1
#define SW_SHOWMINIMIZED    2
#define SW_SHOWMAXIMIZED    3
#define SW_MAXIMIZE         3
#define SW_SHOWNOACTIVATE   4
#define SW_SHOW             5
#define SW_MINIMIZE         6
#define SW_SHOWMINNOACTIVE  7
#define SW_SHOWNA           8
#define SW_RESTORE          9
#define SW_SHOWDEFAULT      10
#define SW_MAX              10

/*
 * Old ShowWindow() Commands
 */
#define HIDE_WINDOW         0
#define SHOW_OPENWINDOW     1
#define SHOW_ICONWINDOW     2
#define SHOW_FULLSCREEN     3
#define SHOW_OPENNOACTIVATE 4

/*
 * Identifiers for the WM_SHOWWINDOW message
 */
#define SW_PARENTCLOSING    1
#define SW_OTHERZOOM        2
#define SW_PARENTOPENING    3
#define SW_OTHERUNZOOM      4


/*
 * Virtual Keys, Standard Set
 */
#define VK_LBUTTON        0x01
#define VK_RBUTTON        0x02
#define VK_CANCEL         0x03
#define VK_MBUTTON        0x04    /* NOT contiguous with L & RBUTTON */

#define VK_BACK           0x08
#define VK_TAB            0x09

#define VK_CLEAR          0x0C
#define VK_RETURN         0x0D

#define VK_SHIFT          0x10
#define VK_CONTROL        0x11
#define VK_MENU           0x12
#define VK_PAUSE          0x13
#define VK_CAPITAL        0x14


#define VK_ESCAPE         0x1B

#define VK_SPACE          0x20
#define VK_PRIOR          0x21
#define VK_NEXT           0x22
#define VK_END            0x23
#define VK_HOME           0x24
#define VK_LEFT           0x25
#define VK_UP             0x26
#define VK_RIGHT          0x27
#define VK_DOWN           0x28
#define VK_SELECT         0x29
#define VK_PRINT          0x2A
#define VK_EXECUTE        0x2B
#define VK_SNAPSHOT       0x2C
#define VK_INSERT         0x2D
#define VK_DELETE         0x2E
#define VK_HELP           0x2F

/* VK_0 thru VK_9 are the same as ASCII '0' thru '9' (0x30 - 0x39) */
/* VK_A thru VK_Z are the same as ASCII 'A' thru 'Z' (0x41 - 0x5A) */

#define VK_LWIN           0x5B
#define VK_RWIN           0x5C
#define VK_APPS           0x5D

#define VK_NUMPAD0        0x60
#define VK_NUMPAD1        0x61
#define VK_NUMPAD2        0x62
#define VK_NUMPAD3        0x63
#define VK_NUMPAD4        0x64
#define VK_NUMPAD5        0x65
#define VK_NUMPAD6        0x66
#define VK_NUMPAD7        0x67
#define VK_NUMPAD8        0x68
#define VK_NUMPAD9        0x69
#define VK_MULTIPLY       0x6A
#define VK_ADD            0x6B
#define VK_SEPARATOR      0x6C
#define VK_SUBTRACT       0x6D
#define VK_DECIMAL        0x6E
#define VK_DIVIDE         0x6F
#define VK_F1             0x70
#define VK_F2             0x71
#define VK_F3             0x72
#define VK_F4             0x73
#define VK_F5             0x74
#define VK_F6             0x75
#define VK_F7             0x76
#define VK_F8             0x77
#define VK_F9             0x78
#define VK_F10            0x79
#define VK_F11            0x7A
#define VK_F12            0x7B
#define VK_F13            0x7C
#define VK_F14            0x7D
#define VK_F15            0x7E
#define VK_F16            0x7F
#define VK_F17            0x80
#define VK_F18            0x81
#define VK_F19            0x82
#define VK_F20            0x83
#define VK_F21            0x84
#define VK_F22            0x85
#define VK_F23            0x86
#define VK_F24            0x87

#define VK_NUMLOCK        0x90
#define VK_SCROLL         0x91

/*
 * VK_L* & VK_R* - left and right Alt, Ctrl and Shift virtual keys.
 * Used only as parameters to GetAsyncKeyState() and GetKeyState().
 * No other API or message will distinguish left and right keys in this way.
 */
#define VK_LSHIFT         0xA0
#define VK_RSHIFT         0xA1
#define VK_LCONTROL       0xA2
#define VK_RCONTROL       0xA3
#define VK_LMENU          0xA4
#define VK_RMENU          0xA5

#if(WINVER >= 0x0400)
#define VK_PROCESSKEY     0xE5
#endif /* WINVER >= 0x0400 */

#define VK_ATTN           0xF6
#define VK_CRSEL          0xF7
#define VK_EXSEL          0xF8
#define VK_EREOF          0xF9
#define VK_PLAY           0xFA
#define VK_ZOOM           0xFB
#define VK_NONAME         0xFC
#define VK_PA1            0xFD
#define VK_OEM_CLEAR      0xFE


/*
 * Window Messages
 */

#define WM_NULL                         0x0000
#define WM_CREATE                       0x0001
#define WM_DESTROY                      0x0002
#define WM_MOVE                         0x0003
#define WM_SIZE                         0x0005

#define WM_ACTIVATE                     0x0006
/*
 * WM_ACTIVATE state values
 */
#define     WA_INACTIVE     0
#define     WA_ACTIVE       1
#define     WA_CLICKACTIVE  2

#define WM_SETFOCUS                     0x0007
#define WM_KILLFOCUS                    0x0008
#define WM_ENABLE                       0x000A
#define WM_SETREDRAW                    0x000B
#define WM_SETTEXT                      0x000C
#define WM_GETTEXT                      0x000D
#define WM_GETTEXTLENGTH                0x000E
#define WM_PAINT                        0x000F
#define WM_CLOSE                        0x0010
#define WM_QUERYENDSESSION              0x0011
#define WM_QUIT                         0x0012
#define WM_QUERYOPEN                    0x0013
#define WM_ERASEBKGND                   0x0014
#define WM_SYSCOLORCHANGE               0x0015
#define WM_ENDSESSION                   0x0016
#define WM_SHOWWINDOW                   0x0018
#define WM_WININICHANGE                 0x001A
#if(WINVER >= 0x0400)
#define WM_SETTINGCHANGE                WM_WININICHANGE
#endif /* WINVER >= 0x0400 */


#define WM_DEVMODECHANGE                0x001B
#define WM_ACTIVATEAPP                  0x001C
#define WM_FONTCHANGE                   0x001D
#define WM_TIMECHANGE                   0x001E
#define WM_CANCELMODE                   0x001F
#define WM_SETCURSOR                    0x0020
#define WM_MOUSEACTIVATE                0x0021
#define WM_CHILDACTIVATE                0x0022
#define WM_QUEUESYNC                    0x0023

#define WM_GETMINMAXINFO                0x0024
#define WM_PAINTICON                    0x0026
#define WM_ICONERASEBKGND               0x0027
#define WM_NEXTDLGCTL                   0x0028
#define WM_SPOOLERSTATUS                0x002A
#define WM_DRAWITEM                     0x002B
#define WM_MEASUREITEM                  0x002C
#define WM_DELETEITEM                   0x002D
#define WM_VKEYTOITEM                   0x002E
#define WM_CHARTOITEM                   0x002F
#define WM_SETFONT                      0x0030
#define WM_GETFONT                      0x0031
#define WM_SETHOTKEY                    0x0032
#define WM_GETHOTKEY                    0x0033
#define WM_QUERYDRAGICON                0x0037
#define WM_COMPAREITEM                  0x0039

#define WM_COMPACTING                   0x0041
#define WM_COMMNOTIFY                   0x0044  /* no longer suported */
#define WM_WINDOWPOSCHANGING            0x0046
#define WM_WINDOWPOSCHANGED             0x0047

#define WM_POWER                        0x0048
/*
 * wParam for WM_POWER window message and DRV_POWER driver notification
 */
#define PWR_OK              1
#define PWR_FAIL            (-1)
#define PWR_SUSPENDREQUEST  1
#define PWR_SUSPENDRESUME   2
#define PWR_CRITICALRESUME  3

#define WM_COPYDATA                     0x004A
#define WM_CANCELJOURNAL                0x004B


#if(WINVER >= 0x0400)
#define WM_NOTIFY                       0x004E
#define WM_INPUTLANGCHANGEREQUEST       0x0050
#define WM_INPUTLANGCHANGE              0x0051
#define WM_TCARD                        0x0052
#define WM_HELP                         0x0053
#define WM_USERCHANGED                  0x0054
#define WM_NOTIFYFORMAT                 0x0055

#define NFR_ANSI                             1
#define NFR_UNICODE                          2
#define NF_QUERY                             3
#define NF_REQUERY                           4

#define WM_CONTEXTMENU                  0x007B
#define WM_STYLECHANGING                0x007C
#define WM_STYLECHANGED                 0x007D
#define WM_DISPLAYCHANGE                0x007E
#define WM_GETICON                      0x007F
#define WM_SETICON                      0x0080
#endif /* WINVER >= 0x0400 */


#define WM_NCCREATE                     0x0081
#define WM_NCDESTROY                    0x0082
#define WM_NCCALCSIZE                   0x0083
#define WM_NCHITTEST                    0x0084
#define WM_NCPAINT                      0x0085
#define WM_NCACTIVATE                   0x0086
#define WM_GETDLGCODE                   0x0087

#define WM_NCMOUSEMOVE                  0x00A0
#define WM_NCLBUTTONDOWN                0x00A1
#define WM_NCLBUTTONUP                  0x00A2
#define WM_NCLBUTTONDBLCLK              0x00A3
#define WM_NCRBUTTONDOWN                0x00A4
#define WM_NCRBUTTONUP                  0x00A5
#define WM_NCRBUTTONDBLCLK              0x00A6
#define WM_NCMBUTTONDOWN                0x00A7
#define WM_NCMBUTTONUP                  0x00A8
#define WM_NCMBUTTONDBLCLK              0x00A9

#define WM_KEYFIRST                     0x0100
#define WM_KEYDOWN                      0x0100
#define WM_KEYUP                        0x0101
#define WM_CHAR                         0x0102
#define WM_DEADCHAR                     0x0103
#define WM_SYSKEYDOWN                   0x0104
#define WM_SYSKEYUP                     0x0105
#define WM_SYSCHAR                      0x0106
#define WM_SYSDEADCHAR                  0x0107
#define WM_KEYLAST                      0x0108

#if(WINVER >= 0x0400)
#define WM_IME_STARTCOMPOSITION         0x010D
#define WM_IME_ENDCOMPOSITION           0x010E
#define WM_IME_COMPOSITION              0x010F
#define WM_IME_KEYLAST                  0x010F
#endif /* WINVER >= 0x0400 */

#define WM_INITDIALOG                   0x0110
#define WM_COMMAND                      0x0111
#define WM_SYSCOMMAND                   0x0112
#define WM_TIMER                        0x0113
#define WM_HSCROLL                      0x0114
#define WM_VSCROLL                      0x0115
#define WM_INITMENU                     0x0116
#define WM_INITMENUPOPUP                0x0117
#define WM_MENUSELECT                   0x011F
#define WM_MENUCHAR                     0x0120
#define WM_ENTERIDLE                    0x0121

#define WM_CTLCOLORMSGBOX               0x0132
#define WM_CTLCOLOREDIT                 0x0133
#define WM_CTLCOLORLISTBOX              0x0134
#define WM_CTLCOLORBTN                  0x0135
#define WM_CTLCOLORDLG                  0x0136
#define WM_CTLCOLORSCROLLBAR            0x0137
#define WM_CTLCOLORSTATIC               0x0138



#define WM_MOUSEFIRST                   0x0200
#define WM_MOUSEMOVE                    0x0200
#define WM_LBUTTONDOWN                  0x0201
#define WM_LBUTTONUP                    0x0202
#define WM_LBUTTONDBLCLK                0x0203
#define WM_RBUTTONDOWN                  0x0204
#define WM_RBUTTONUP                    0x0205
#define WM_RBUTTONDBLCLK                0x0206
#define WM_MBUTTONDOWN                  0x0207
#define WM_MBUTTONUP                    0x0208
#define WM_MBUTTONDBLCLK                0x0209
#if(_WIN32_WINNT >= 0x0400)
#define WM_MOUSEWHEEL                   0x020A
#endif /* _WIN32_WINNT >= 0x0400 */
#if (_WIN32_WINNT < 0x0400)
#define WM_MOUSELAST                    0x0209
#else
#define WM_MOUSELAST                    0x020A
#endif /* if (_WIN32_WINNT < 0x0400) */

#if(_WIN32_WINNT >= 0x0400)
#define WHEEL_DELTA                     120     /* Value for rolling one detent */
#endif /* _WIN32_WINNT >= 0x0400 */
#if(_WIN32_WINNT >= 0x0400)
#define WHEEL_PAGESCROLL                (UINT_MAX) /* Scroll one page */
#endif /* _WIN32_WINNT >= 0x0400 */

#define WM_PARENTNOTIFY                 0x0210
#define MENULOOP_WINDOW                 0
#define MENULOOP_POPUP                  1
#define WM_ENTERMENULOOP                0x0211
#define WM_EXITMENULOOP                 0x0212

#if(WINVER >= 0x0400)
#define WM_NEXTMENU                     0x0213
#define WM_SIZING                       0x0214
#define WM_CAPTURECHANGED               0x0215
#define WM_MOVING                       0x0216
#define WM_POWERBROADCAST               0x0218
#define WM_DEVICECHANGE                 0x0219

#define WM_IME_SETCONTEXT               0x0281
#define WM_IME_NOTIFY                   0x0282
#define WM_IME_CONTROL                  0x0283
#define WM_IME_COMPOSITIONFULL          0x0284
#define WM_IME_SELECT                   0x0285
#define WM_IME_CHAR                     0x0286
#define WM_IME_KEYDOWN                  0x0290
#define WM_IME_KEYUP                    0x0291
#endif /* WINVER >= 0x0400 */

#define WM_MDICREATE                    0x0220
#define WM_MDIDESTROY                   0x0221
#define WM_MDIACTIVATE                  0x0222
#define WM_MDIRESTORE                   0x0223
#define WM_MDINEXT                      0x0224
#define WM_MDIMAXIMIZE                  0x0225
#define WM_MDITILE                      0x0226
#define WM_MDICASCADE                   0x0227
#define WM_MDIICONARRANGE               0x0228
#define WM_MDIGETACTIVE                 0x0229



#define WM_MDISETMENU                   0x0230
#define WM_ENTERSIZEMOVE                0x0231
#define WM_EXITSIZEMOVE                 0x0232
#define WM_DROPFILES                    0x0233
#define WM_MDIREFRESHMENU               0x0234


#if(_WIN32_WINNT >= 0x0400)
#define WM_MOUSEHOVER                   0x02A1
#define WM_MOUSELEAVE                   0x02A3
#endif /* _WIN32_WINNT >= 0x0400 */

#define WM_CUT                          0x0300
#define WM_COPY                         0x0301
#define WM_PASTE                        0x0302
#define WM_CLEAR                        0x0303
#define WM_UNDO                         0x0304
#define WM_RENDERFORMAT                 0x0305
#define WM_RENDERALLFORMATS             0x0306
#define WM_DESTROYCLIPBOARD             0x0307
#define WM_DRAWCLIPBOARD                0x0308
#define WM_PAINTCLIPBOARD               0x0309
#define WM_VSCROLLCLIPBOARD             0x030A
#define WM_SIZECLIPBOARD                0x030B
#define WM_ASKCBFORMATNAME              0x030C
#define WM_CHANGECBCHAIN                0x030D
#define WM_HSCROLLCLIPBOARD             0x030E
#define WM_QUERYNEWPALETTE              0x030F
#define WM_PALETTEISCHANGING            0x0310
#define WM_PALETTECHANGED               0x0311
#define WM_HOTKEY                       0x0312

#if(WINVER >= 0x0400)
#define WM_PRINT                        0x0317
#define WM_PRINTCLIENT                  0x0318

#define WM_HANDHELDFIRST                0x0358
#define WM_HANDHELDLAST                 0x035F

#define WM_AFXFIRST                     0x0360
#define WM_AFXLAST                      0x037F
#endif /* WINVER >= 0x0400 */

#define WM_PENWINFIRST                  0x0380
#define WM_PENWINLAST                   0x038F




#if(WINVER >= 0x0400)
#define WM_APP                          0x8000
#endif /* WINVER >= 0x0400 */






/*
 * NOTE: All Message Numbers below 0x0400 are RESERVED.
 *
 * Private Window Messages Start Here:
 */
#define WM_USER                         0x0400

#if(WINVER >= 0x0400)

/*  wParam for WM_SIZING message  */
#define WMSZ_LEFT           1
#define WMSZ_RIGHT          2
#define WMSZ_TOP            3
#define WMSZ_TOPLEFT        4
#define WMSZ_TOPRIGHT       5
#define WMSZ_BOTTOM         6
#define WMSZ_BOTTOMLEFT     7
#define WMSZ_BOTTOMRIGHT    8
#endif /* WINVER >= 0x0400 */

#ifndef NONCMESSAGES

/*
 * WM_SYNCTASK Commands
 */
#define ST_BEGINSWP         0
#define ST_ENDSWP           1

/*
 * WM_NCHITTEST and MOUSEHOOKSTRUCT Mouse Position Codes
 */
#define HTERROR             (-2)
#define HTTRANSPARENT       (-1)
#define HTNOWHERE           0
#define HTCLIENT            1
#define HTCAPTION           2
#define HTSYSMENU           3
#define HTGROWBOX           4
#define HTSIZE              HTGROWBOX
#define HTMENU              5
#define HTHSCROLL           6
#define HTVSCROLL           7
#define HTMINBUTTON         8
#define HTMAXBUTTON         9
#define HTLEFT              10
#define HTRIGHT             11
#define HTTOP               12
#define HTTOPLEFT           13
#define HTTOPRIGHT          14
#define HTBOTTOM            15
#define HTBOTTOMLEFT        16
#define HTBOTTOMRIGHT       17
#define HTBORDER            18
#define HTREDUCE            HTMINBUTTON
#define HTZOOM              HTMAXBUTTON
#define HTSIZEFIRST         HTLEFT
#define HTSIZELAST          HTBOTTOMRIGHT
#if(WINVER >= 0x0400)
#define HTOBJECT            19
#define HTCLOSE             20
#define HTHELP              21
#endif /* WINVER >= 0x0400 */

/*
 * SendMessageTimeout values
 */
#define SMTO_NORMAL         0x0000
#define SMTO_BLOCK          0x0001
#define SMTO_ABORTIFHUNG    0x0002

#endif /* !NONCMESSAGES */

/*
 * WM_MOUSEACTIVATE Return Codes
 */
#define MA_ACTIVATE         1
#define MA_ACTIVATEANDEAT   2
#define MA_NOACTIVATE       3
#define MA_NOACTIVATEANDEAT 4

/*
 * WM_SETICON / WM_GETICON Type Codes
 */
#define ICON_SMALL          0
#define ICON_BIG            1


/*
 * WM_SIZE message wParam values
 */
#define SIZE_RESTORED       0
#define SIZE_MINIMIZED      1
#define SIZE_MAXIMIZED      2
#define SIZE_MAXSHOW        3
#define SIZE_MAXHIDE        4

/*
 * Obsolete constant names
 */
#define SIZENORMAL          SIZE_RESTORED
#define SIZEICONIC          SIZE_MINIMIZED
#define SIZEFULLSCREEN      SIZE_MAXIMIZED
#define SIZEZOOMSHOW        SIZE_MAXSHOW
#define SIZEZOOMHIDE        SIZE_MAXHIDE

/*
 * WM_NCCALCSIZE "window valid rect" return values
 */
#define WVR_ALIGNTOP        0x0010
#define WVR_ALIGNLEFT       0x0020
#define WVR_ALIGNBOTTOM     0x0040
#define WVR_ALIGNRIGHT      0x0080
#define WVR_HREDRAW         0x0100
#define WVR_VREDRAW         0x0200
#define WVR_REDRAW         (WVR_HREDRAW | \
                            WVR_VREDRAW)
#define WVR_VALIDRECTS      0x0400


#ifndef NOKEYSTATES

/*
 * Key State Masks for Mouse Messages
 */
#define MK_LBUTTON          0x0001
#define MK_RBUTTON          0x0002
#define MK_SHIFT            0x0004
#define MK_CONTROL          0x0008
#define MK_MBUTTON          0x0010

#endif /* !NOKEYSTATES */

#if(_WIN32_WINNT >= 0x0400)
#ifndef NOTRACKMOUSEEVENT

#define TME_HOVER       0x00000001
#define TME_LEAVE       0x00000002
#define TME_QUERY       0x40000000
#define TME_CANCEL      0x80000000


#define HOVER_DEFAULT   0xFFFFFFFF

#endif /* !NOTRACKMOUSEEVENT */
#endif /* _WIN32_WINNT >= 0x0400 */


/*
 * Window Styles
 */
#define WS_OVERLAPPED       0x00000000L
#define WS_POPUP            0x80000000L
#define WS_CHILD            0x40000000L
#define WS_MINIMIZE         0x20000000L
#define WS_VISIBLE          0x10000000L
#define WS_DISABLED         0x08000000L
#define WS_CLIPSIBLINGS     0x04000000L
#define WS_CLIPCHILDREN     0x02000000L
#define WS_MAXIMIZE         0x01000000L
#define WS_CAPTION          0x00C00000L     /* WS_BORDER | WS_DLGFRAME  */
#define WS_BORDER           0x00800000L
#define WS_DLGFRAME         0x00400000L
#define WS_VSCROLL          0x00200000L
#define WS_HSCROLL          0x00100000L
#define WS_SYSMENU          0x00080000L
#define WS_THICKFRAME       0x00040000L
#define WS_GROUP            0x00020000L
#define WS_TABSTOP          0x00010000L

#define WS_MINIMIZEBOX      0x00020000L
#define WS_MAXIMIZEBOX      0x00010000L

#define WS_TILED            WS_OVERLAPPED
#define WS_ICONIC           WS_MINIMIZE
#define WS_SIZEBOX          WS_THICKFRAME
#define WS_TILEDWINDOW      WS_OVERLAPPEDWINDOW

/*
 * Common Window Styles
 */
#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED     | \
                             WS_CAPTION        | \
                             WS_SYSMENU        | \
                             WS_THICKFRAME     | \
                             WS_MINIMIZEBOX    | \
                             WS_MAXIMIZEBOX)

#define WS_POPUPWINDOW      (WS_POPUP          | \
                             WS_BORDER         | \
                             WS_SYSMENU)

#define WS_CHILDWINDOW      (WS_CHILD)

/*
 * Extended Window Styles
 */
#define WS_EX_DLGMODALFRAME     0x00000001L
#define WS_EX_NOPARENTNOTIFY    0x00000004L
#define WS_EX_TOPMOST           0x00000008L
#define WS_EX_ACCEPTFILES       0x00000010L
#define WS_EX_TRANSPARENT       0x00000020L
#if(WINVER >= 0x0400)
#define WS_EX_MDICHILD          0x00000040L
#define WS_EX_TOOLWINDOW        0x00000080L
#define WS_EX_WINDOWEDGE        0x00000100L
#define WS_EX_CLIENTEDGE        0x00000200L
#define WS_EX_CONTEXTHELP       0x00000400L

#define WS_EX_RIGHT             0x00001000L
#define WS_EX_LEFT              0x00000000L
#define WS_EX_RTLREADING        0x00002000L
#define WS_EX_LTRREADING        0x00000000L
#define WS_EX_LEFTSCROLLBAR     0x00004000L
#define WS_EX_RIGHTSCROLLBAR    0x00000000L

#define WS_EX_CONTROLPARENT     0x00010000L
#define WS_EX_STATICEDGE        0x00020000L
#define WS_EX_APPWINDOW         0x00040000L


#define WS_EX_OVERLAPPEDWINDOW  (WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE)
#define WS_EX_PALETTEWINDOW     (WS_EX_WINDOWEDGE | WS_EX_TOOLWINDOW | WS_EX_TOPMOST)

#endif /* WINVER >= 0x0400 */



/*
 * Class styles
 */
#define CS_VREDRAW          0x0001
#define CS_HREDRAW          0x0002
#define CS_KEYCVTWINDOW     0x0004
#define CS_DBLCLKS          0x0008
#define CS_OWNDC            0x0020
#define CS_CLASSDC          0x0040
#define CS_PARENTDC         0x0080
#define CS_NOKEYCVT         0x0100
#define CS_NOCLOSE          0x0200
#define CS_SAVEBITS         0x0800
#define CS_BYTEALIGNCLIENT  0x1000
#define CS_BYTEALIGNWINDOW  0x2000
#define CS_GLOBALCLASS      0x4000

#if(WINVER >= 0x0400)
#define CS_IME              0x00010000
#endif /* WINVER >= 0x0400 */



/*
 * Predefined Clipboard Formats
 */
#define CF_TEXT             1
#define CF_BITMAP           2
#define CF_METAFILEPICT     3
#define CF_SYLK             4
#define CF_DIF              5
#define CF_TIFF             6
#define CF_OEMTEXT          7
#define CF_DIB              8
#define CF_PALETTE          9
#define CF_PENDATA          10
#define CF_RIFF             11
#define CF_WAVE             12
#define CF_UNICODETEXT      13
#define CF_ENHMETAFILE      14
#if(WINVER >= 0x0400)
#define CF_HDROP            15
#define CF_LOCALE           16
#define CF_MAX              17
#endif /* WINVER >= 0x0400 */

#define CF_OWNERDISPLAY     0x0080
#define CF_DSPTEXT          0x0081
#define CF_DSPBITMAP        0x0082
#define CF_DSPMETAFILEPICT  0x0083
#define CF_DSPENHMETAFILE   0x008E

/*
 * "Private" formats don't get GlobalFree()'d
 */
#define CF_PRIVATEFIRST     0x0200
#define CF_PRIVATELAST      0x02FF

/*
 * "GDIOBJ" formats do get DeleteObject()'d
 */
#define CF_GDIOBJFIRST      0x0300
#define CF_GDIOBJLAST       0x03FF


/* ;win40  -- A lot of MF_* flags have been renamed as MFT_* and MFS_* flags */
/*
 * Menu flags for Add/Check/EnableMenuItem()
 */
#define MF_INSERT           0x00000000L
#define MF_CHANGE           0x00000080L
#define MF_APPEND           0x00000100L
#define MF_DELETE           0x00000200L
#define MF_REMOVE           0x00001000L

#define MF_BYCOMMAND        0x00000000L
#define MF_BYPOSITION       0x00000400L

#define MF_SEPARATOR        0x00000800L

#define MF_ENABLED          0x00000000L
#define MF_GRAYED           0x00000001L
#define MF_DISABLED         0x00000002L

#define MF_UNCHECKED        0x00000000L
#define MF_CHECKED          0x00000008L
#define MF_USECHECKBITMAPS  0x00000200L

#define MF_STRING           0x00000000L
#define MF_BITMAP           0x00000004L
#define MF_OWNERDRAW        0x00000100L

#define MF_POPUP            0x00000010L
#define MF_MENUBARBREAK     0x00000020L
#define MF_MENUBREAK        0x00000040L

#define MF_UNHILITE         0x00000000L
#define MF_HILITE           0x00000080L

#if(WINVER >= 0x0400)
#define MF_DEFAULT          0x00001000L
#endif /* WINVER >= 0x0400 */
#define MF_SYSMENU          0x00002000L
#define MF_HELP             0x00004000L
#if(WINVER >= 0x0400)
#define MF_RIGHTJUSTIFY     0x00004000L
#endif /* WINVER >= 0x0400 */

#define MF_MOUSESELECT      0x00008000L
#if(WINVER >= 0x0400)
#define MF_END              0x00000080L  /* Obsolete -- only used by old RES files */
#endif /* WINVER >= 0x0400 */


#if(WINVER >= 0x0400)
#define MFT_STRING          MF_STRING
#define MFT_BITMAP          MF_BITMAP
#define MFT_MENUBARBREAK    MF_MENUBARBREAK
#define MFT_MENUBREAK       MF_MENUBREAK
#define MFT_OWNERDRAW       MF_OWNERDRAW
#define MFT_RADIOCHECK      0x00000200L
#define MFT_SEPARATOR       MF_SEPARATOR
#define MFT_RIGHTORDER      0x00002000L
#define MFT_RIGHTJUSTIFY    MF_RIGHTJUSTIFY

/* Menu flags for Add/Check/EnableMenuItem() */
#define MFS_GRAYED          0x00000003L
#define MFS_DISABLED        MFS_GRAYED
#define MFS_CHECKED         MF_CHECKED
#define MFS_HILITE          MF_HILITE
#define MFS_ENABLED         MF_ENABLED
#define MFS_UNCHECKED       MF_UNCHECKED
#define MFS_UNHILITE        MF_UNHILITE
#define MFS_DEFAULT         MF_DEFAULT



#endif /* WINVER >= 0x0400 */

#define MF_END             0x00000080L          
/*
 * System Menu Command Values
 */
#define SC_SIZE         0xF000
#define SC_MOVE         0xF010
#define SC_MINIMIZE     0xF020
#define SC_MAXIMIZE     0xF030
#define SC_NEXTWINDOW   0xF040
#define SC_PREVWINDOW   0xF050
#define SC_CLOSE        0xF060
#define SC_VSCROLL      0xF070
#define SC_HSCROLL      0xF080
#define SC_MOUSEMENU    0xF090
#define SC_KEYMENU      0xF100
#define SC_ARRANGE      0xF110
#define SC_RESTORE      0xF120
#define SC_TASKLIST     0xF130
#define SC_SCREENSAVE   0xF140
#define SC_HOTKEY       0xF150
#if(WINVER >= 0x0400)
#define SC_DEFAULT      0xF160
#define SC_MONITORPOWER 0xF170
#define SC_CONTEXTHELP  0xF180
#define SC_SEPARATOR    0xF00F
#endif /* WINVER >= 0x0400 */
/*
 * Obsolete names
 */
#define SC_ICON         SC_MINIMIZE
#define SC_ZOOM         SC_MAXIMIZE


/*
 * OEM Resource Ordinal Numbers
 */
#define OBM_CLOSE           32754
#define OBM_UPARROW         32753
#define OBM_DNARROW         32752
#define OBM_RGARROW         32751
#define OBM_LFARROW         32750
#define OBM_REDUCE          32749
#define OBM_ZOOM            32748
#define OBM_RESTORE         32747
#define OBM_REDUCED         32746
#define OBM_ZOOMD           32745
#define OBM_RESTORED        32744
#define OBM_UPARROWD        32743
#define OBM_DNARROWD        32742
#define OBM_RGARROWD        32741
#define OBM_LFARROWD        32740
#define OBM_MNARROW         32739
#define OBM_COMBO           32738
#define OBM_UPARROWI        32737
#define OBM_DNARROWI        32736
#define OBM_RGARROWI        32735
#define OBM_LFARROWI        32734

#define OBM_OLD_CLOSE       32767
#define OBM_SIZE            32766
#define OBM_OLD_UPARROW     32765
#define OBM_OLD_DNARROW     32764
#define OBM_OLD_RGARROW     32763
#define OBM_OLD_LFARROW     32762
#define OBM_BTSIZE          32761
#define OBM_CHECK           32760
#define OBM_CHECKBOXES      32759
#define OBM_BTNCORNERS      32758
#define OBM_OLD_REDUCE      32757
#define OBM_OLD_ZOOM        32756
#define OBM_OLD_RESTORE     32755

#define OCR_NORMAL          32512
#define OCR_IBEAM           32513
#define OCR_WAIT            32514
#define OCR_CROSS           32515
#define OCR_UP              32516
#define OCR_SIZE            32640   /* OBSOLETE: use OCR_SIZEALL */
#define OCR_ICON            32641   /* OBSOLETE: use OCR_NORMAL */
#define OCR_SIZENWSE        32642
#define OCR_SIZENESW        32643
#define OCR_SIZEWE          32644
#define OCR_SIZENS          32645
#define OCR_SIZEALL         32646
#define OCR_ICOCUR          32647   /* OBSOLETE: use OIC_WINLOGO */
#define OCR_NO              32648
#if(WINVER >= 0x0400)
#define OCR_APPSTARTING     32650
#endif /* WINVER >= 0x0400 */



#define OIC_SAMPLE          32512
#define OIC_HAND            32513
#define OIC_QUES            32514
#define OIC_BANG            32515
#define OIC_NOTE            32516
#if(WINVER >= 0x0400)
#define OIC_WINLOGO         32517
#define OIC_WARNING         OIC_BANG
#define OIC_ERROR           OIC_HAND
#define OIC_INFORMATION     OIC_NOTE
#endif /* WINVER >= 0x0400 */


/*
 * Standard Icon IDs
 */
#ifdef RC_INVOKED
#define IDI_APPLICATION     32512
#define IDI_HAND            32513
#define IDI_QUESTION        32514
#define IDI_EXCLAMATION     32515
#define IDI_ASTERISK        32516
#if(WINVER >= 0x0400)
#define IDI_WINLOGO         32517
#endif /* WINVER >= 0x0400 */
#else
#define IDI_APPLICATION     MAKEINTRESOURCE(32512)
#define IDI_HAND            MAKEINTRESOURCE(32513)
#define IDI_QUESTION        MAKEINTRESOURCE(32514)
#define IDI_EXCLAMATION     MAKEINTRESOURCE(32515)
#define IDI_ASTERISK        MAKEINTRESOURCE(32516)
#if(WINVER >= 0x0400)
#define IDI_WINLOGO         MAKEINTRESOURCE(32517)
#endif /* WINVER >= 0x0400 */
#endif /* RC_INVOKED */

#if(WINVER >= 0x0400)
#define IDI_WARNING     IDI_EXCLAMATION
#define IDI_ERROR       IDI_HAND
#define IDI_INFORMATION IDI_ASTERISK
#endif /* WINVER >= 0x0400 */


/*
 * Dialog Box Command IDs
 */
#define IDOK                1
#define IDCANCEL            2
#define IDABORT             3
#define IDRETRY             4
#define IDIGNORE            5
#define IDYES               6
#define IDNO                7
#if(WINVER >= 0x0400)
#define IDCLOSE         8
#define IDHELP          9
#endif /* WINVER >= 0x0400 */


/*
 * Edit Control Styles
 */
#define ES_LEFT             0x0000L
#define ES_CENTER           0x0001L
#define ES_RIGHT            0x0002L
#define ES_MULTILINE        0x0004L
#define ES_UPPERCASE        0x0008L
#define ES_LOWERCASE        0x0010L
#define ES_PASSWORD         0x0020L
#define ES_AUTOVSCROLL      0x0040L
#define ES_AUTOHSCROLL      0x0080L
#define ES_NOHIDESEL        0x0100L
#define ES_OEMCONVERT       0x0400L
#define ES_READONLY         0x0800L
#define ES_WANTRETURN       0x1000L
#if(WINVER >= 0x0400)
#define ES_NUMBER           0x2000L
#endif /* WINVER >= 0x0400 */


/*
 * Edit Control Messages
 */
#define EM_GETSEL               0x00B0
#define EM_SETSEL               0x00B1
#define EM_GETRECT              0x00B2
#define EM_SETRECT              0x00B3
#define EM_SETRECTNP            0x00B4
#define EM_SCROLL               0x00B5
#define EM_LINESCROLL           0x00B6
#define EM_SCROLLCARET          0x00B7
#define EM_GETMODIFY            0x00B8
#define EM_SETMODIFY            0x00B9
#define EM_GETLINECOUNT         0x00BA
#define EM_LINEINDEX            0x00BB
#define EM_SETHANDLE            0x00BC
#define EM_GETHANDLE            0x00BD
#define EM_GETTHUMB             0x00BE
#define EM_LINELENGTH           0x00C1
#define EM_REPLACESEL           0x00C2
#define EM_GETLINE              0x00C4
#define EM_LIMITTEXT            0x00C5
#define EM_CANUNDO              0x00C6
#define EM_UNDO                 0x00C7
#define EM_FMTLINES             0x00C8
#define EM_LINEFROMCHAR         0x00C9
#define EM_SETTABSTOPS          0x00CB
#define EM_SETPASSWORDCHAR      0x00CC
#define EM_EMPTYUNDOBUFFER      0x00CD
#define EM_GETFIRSTVISIBLELINE  0x00CE
#define EM_SETREADONLY          0x00CF
#define EM_SETWORDBREAKPROC     0x00D0
#define EM_GETWORDBREAKPROC     0x00D1
#define EM_GETPASSWORDCHAR      0x00D2
#if(WINVER >= 0x0400)
#define EM_SETMARGINS           0x00D3
#define EM_GETMARGINS           0x00D4
#define EM_SETLIMITTEXT         EM_LIMITTEXT   /* ;win40 Name change */
#define EM_GETLIMITTEXT         0x00D5
#define EM_POSFROMCHAR          0x00D6
#define EM_CHARFROMPOS          0x00D7
#endif /* WINVER >= 0x0400 */



/*
 * Button Control Styles
 */
#define BS_PUSHBUTTON       0x00000000L
#define BS_DEFPUSHBUTTON    0x00000001L
#define BS_CHECKBOX         0x00000002L
#define BS_AUTOCHECKBOX     0x00000003L
#define BS_RADIOBUTTON      0x00000004L
#define BS_3STATE           0x00000005L
#define BS_AUTO3STATE       0x00000006L
#define BS_GROUPBOX         0x00000007L
#define BS_USERBUTTON       0x00000008L
#define BS_AUTORADIOBUTTON  0x00000009L
#define BS_OWNERDRAW        0x0000000BL
#define BS_LEFTTEXT         0x00000020L
#if(WINVER >= 0x0400)
#define BS_TEXT             0x00000000L
#define BS_ICON             0x00000040L
#define BS_BITMAP           0x00000080L
#define BS_LEFT             0x00000100L
#define BS_RIGHT            0x00000200L
#define BS_CENTER           0x00000300L
#define BS_TOP              0x00000400L
#define BS_BOTTOM           0x00000800L
#define BS_VCENTER          0x00000C00L
#define BS_PUSHLIKE         0x00001000L
#define BS_MULTILINE        0x00002000L
#define BS_NOTIFY           0x00004000L
#define BS_FLAT             0x00008000L
#define BS_RIGHTBUTTON      BS_LEFTTEXT
#endif /* WINVER >= 0x0400 */


/*
 * User Button Notification Codes
 */
#define BN_CLICKED          0
#define BN_PAINT            1
#define BN_HILITE           2
#define BN_UNHILITE         3
#define BN_DISABLE          4
#define BN_DOUBLECLICKED    5
#if(WINVER >= 0x0400)
#define BN_PUSHED           BN_HILITE
#define BN_UNPUSHED         BN_UNHILITE
#define BN_DBLCLK           BN_DOUBLECLICKED
#define BN_SETFOCUS         6
#define BN_KILLFOCUS        7
#endif /* WINVER >= 0x0400 */

/*
 * Button Control Messages
 */
#define BM_GETCHECK        0x00F0
#define BM_SETCHECK        0x00F1
#define BM_GETSTATE        0x00F2
#define BM_SETSTATE        0x00F3
#define BM_SETSTYLE        0x00F4
#if(WINVER >= 0x0400)
#define BM_CLICK           0x00F5
#define BM_GETIMAGE        0x00F6
#define BM_SETIMAGE        0x00F7

#define BST_UNCHECKED      0x0000
#define BST_CHECKED        0x0001
#define BST_INDETERMINATE  0x0002
#define BST_PUSHED         0x0004
#define BST_FOCUS          0x0008
#endif /* WINVER >= 0x0400 */

/*
 * Static Control Constants
 */
#define SS_LEFT             0x00000000L
#define SS_CENTER           0x00000001L
#define SS_RIGHT            0x00000002L
#define SS_ICON             0x00000003L
#define SS_BLACKRECT        0x00000004L
#define SS_GRAYRECT         0x00000005L
#define SS_WHITERECT        0x00000006L
#define SS_BLACKFRAME       0x00000007L
#define SS_GRAYFRAME        0x00000008L
#define SS_WHITEFRAME       0x00000009L
#define SS_USERITEM         0x0000000AL
#define SS_SIMPLE           0x0000000BL
#define SS_LEFTNOWORDWRAP   0x0000000CL
#if(WINVER >= 0x0400)
#define SS_OWNERDRAW        0x0000000DL
#define SS_BITMAP           0x0000000EL
#define SS_ENHMETAFILE      0x0000000FL
#define SS_ETCHEDHORZ       0x00000010L
#define SS_ETCHEDVERT       0x00000011L
#define SS_ETCHEDFRAME      0x00000012L
#define SS_TYPEMASK         0x0000001FL
#endif /* WINVER >= 0x0400 */
#define SS_NOPREFIX         0x00000080L /* Don't do "&" character translation */
#if(WINVER >= 0x0400)
#define SS_NOTIFY           0x00000100L
#define SS_CENTERIMAGE      0x00000200L
#define SS_RIGHTJUST        0x00000400L
#define SS_REALSIZEIMAGE    0x00000800L
#define SS_SUNKEN           0x00001000L
#define SS_ENDELLIPSIS      0x00004000L
#define SS_PATHELLIPSIS     0x00008000L
#define SS_WORDELLIPSIS     0x0000C000L
#define SS_ELLIPSISMASK     0x0000C000L
#endif /* WINVER >= 0x0400 */


/*
 * Dialog Styles
 */
#define DS_ABSALIGN         0x01L
#define DS_SYSMODAL         0x02L
#define DS_LOCALEDIT        0x20L   /* Edit items get Local storage. */
#define DS_SETFONT          0x40L   /* User specified font for Dlg controls */
#define DS_MODALFRAME       0x80L   /* Can be combined with WS_CAPTION  */
#define DS_NOIDLEMSG        0x100L  /* WM_ENTERIDLE message will not be sent */
#define DS_SETFOREGROUND    0x200L  /* not in win3.1 */



#if(WINVER >= 0x0400)
#define DS_3DLOOK           0x0004L
#define DS_FIXEDSYS         0x0008L
#define DS_NOFAILCREATE     0x0010L
#define DS_CONTROL          0x0400L
#define DS_CENTER           0x0800L
#define DS_CENTERMOUSE      0x1000L
#define DS_CONTEXTHELP      0x2000L


#endif /* WINVER >= 0x0400 */


/*
 * Listbox Styles
 */
#define LBS_NOTIFY            0x0001L
#define LBS_SORT              0x0002L
#define LBS_NOREDRAW          0x0004L
#define LBS_MULTIPLESEL       0x0008L
#define LBS_OWNERDRAWFIXED    0x0010L
#define LBS_OWNERDRAWVARIABLE 0x0020L
#define LBS_HASSTRINGS        0x0040L
#define LBS_USETABSTOPS       0x0080L
#define LBS_NOINTEGRALHEIGHT  0x0100L
#define LBS_MULTICOLUMN       0x0200L
#define LBS_WANTKEYBOARDINPUT 0x0400L
#define LBS_EXTENDEDSEL       0x0800L
#define LBS_DISABLENOSCROLL   0x1000L
#define LBS_NODATA            0x2000L
#if(WINVER >= 0x0400)
#define LBS_NOSEL             0x4000L
#endif /* WINVER >= 0x0400 */
#define LBS_STANDARD          (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)


/*
 * Combo Box styles
 */
#define CBS_SIMPLE            0x0001L
#define CBS_DROPDOWN          0x0002L
#define CBS_DROPDOWNLIST      0x0003L
#define CBS_OWNERDRAWFIXED    0x0010L
#define CBS_OWNERDRAWVARIABLE 0x0020L
#define CBS_AUTOHSCROLL       0x0040L
#define CBS_OEMCONVERT        0x0080L
#define CBS_SORT              0x0100L
#define CBS_HASSTRINGS        0x0200L
#define CBS_NOINTEGRALHEIGHT  0x0400L
#define CBS_DISABLENOSCROLL   0x0800L
#if(WINVER >= 0x0400)
#define CBS_UPPERCASE           0x2000L
#define CBS_LOWERCASE           0x4000L
#endif /* WINVER >= 0x0400 */


/*
 * Scroll Bar Styles
 */
#define SBS_HORZ                    0x0000L
#define SBS_VERT                    0x0001L
#define SBS_TOPALIGN                0x0002L
#define SBS_LEFTALIGN               0x0002L
#define SBS_BOTTOMALIGN             0x0004L
#define SBS_RIGHTALIGN              0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN     0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX                 0x0008L
#if(WINVER >= 0x0400)
#define SBS_SIZEGRIP                0x0010L
#endif /* WINVER >= 0x0400 */


/*
 * Commands to pass to WinHelp()
 */
#define HELP_CONTEXT      0x0001L  /* Display topic in ulTopic */
#define HELP_QUIT         0x0002L  /* Terminate help */
#define HELP_INDEX        0x0003L  /* Display index */
#define HELP_CONTENTS     0x0003L
#define HELP_HELPONHELP   0x0004L  /* Display help on using help */
#define HELP_SETINDEX     0x0005L  /* Set current Index for multi index help */
#define HELP_SETCONTENTS  0x0005L
#define HELP_CONTEXTPOPUP 0x0008L
#define HELP_FORCEFILE    0x0009L
#define HELP_KEY          0x0101L  /* Display topic for keyword in offabData */
#define HELP_COMMAND      0x0102L
#define HELP_PARTIALKEY   0x0105L
#define HELP_MULTIKEY     0x0201L
#define HELP_SETWINPOS    0x0203L
#if(WINVER >= 0x0400)
#define HELP_CONTEXTMENU  0x000a
#define HELP_FINDER       0x000b
#define HELP_WM_HELP      0x000c
#define HELP_SETPOPUP_POS 0x000d

#define HELP_TCARD              0x8000
#define HELP_TCARD_DATA         0x0010
#define HELP_TCARD_OTHER_CALLER 0x0011

// These are in winhelp.h in Win95.
#define IDH_NO_HELP                     28440
#define IDH_MISSING_CONTEXT             28441 // Control doesn't have matching help context
#define IDH_GENERIC_HELP_BUTTON         28442 // Property sheet help button
#define IDH_OK                          28443
#define IDH_CANCEL                      28444
#define IDH_HELP                        28445

#endif /* WINVER >= 0x0400 */







#define HDS_HORZ                0x00000000
#define HDS_BUTTONS             0x00000002
#define HDS_HIDDEN              0x00000008


#define TTS_ALWAYSTIP           0x01
#define TTS_NOPREFIX            0x02


#define SBARS_SIZEGRIP          0x0100


#define TBS_AUTOTICKS           0x0001
#define TBS_VERT                0x0002
#define TBS_HORZ                0x0000
#define TBS_TOP                 0x0004
#define TBS_BOTTOM              0x0000
#define TBS_LEFT                0x0004
#define TBS_RIGHT               0x0000
#define TBS_BOTH                0x0008
#define TBS_NOTICKS             0x0010
#define TBS_ENABLESELRANGE      0x0020
#define TBS_FIXEDLENGTH         0x0040
#define TBS_NOTHUMB             0x0080


#define UDS_WRAP                0x0001
#define UDS_SETBUDDYINT         0x0002
#define UDS_ALIGNRIGHT          0x0004
#define UDS_ALIGNLEFT           0x0008
#define UDS_AUTOBUDDY           0x0010
#define UDS_ARROWKEYS           0x0020
#define UDS_HORZ                0x0040
#define UDS_NOTHOUSANDS         0x0080


//====== COMMON CONTROL STYLES ================================================

#define CCS_TOP                 0x00000001L
#define CCS_NOMOVEY             0x00000002L
#define CCS_BOTTOM              0x00000003L
#define CCS_NORESIZE            0x00000004L
#define CCS_NOPARENTALIGN       0x00000008L
#define CCS_ADJUSTABLE          0x00000020L
#define CCS_NODIVIDER           0x00000040L


#define LVS_ICON                0x0000
#define LVS_REPORT              0x0001
#define LVS_SMALLICON           0x0002
#define LVS_LIST                0x0003
#define LVS_TYPEMASK            0x0003
#define LVS_SINGLESEL           0x0004
#define LVS_SHOWSELALWAYS       0x0008
#define LVS_SORTASCENDING       0x0010
#define LVS_SORTDESCENDING      0x0020
#define LVS_SHAREIMAGELISTS     0x0040
#define LVS_NOLABELWRAP         0x0080
#define LVS_AUTOARRANGE         0x0100
#define LVS_EDITLABELS          0x0200
#define LVS_OWNERDATA           0x1000
#define LVS_NOSCROLL            0x2000

#define LVS_TYPESTYLEMASK       0xfc00

#define LVS_ALIGNTOP            0x0000
#define LVS_ALIGNLEFT           0x0800
#define LVS_ALIGNMASK           0x0c00

#define LVS_OWNERDRAWFIXED      0x0400
#define LVS_NOCOLUMNHEADER      0x4000
#define LVS_NOSORTHEADER        0x8000


#define TVS_HASBUTTONS          0x0001
#define TVS_HASLINES            0x0002
#define TVS_LINESATROOT         0x0004
#define TVS_EDITLABELS          0x0008
#define TVS_DISABLEDRAGDROP     0x0010
#define TVS_SHOWSELALWAYS       0x0020


#define TCS_FORCEICONLEFT       0x0010
#define TCS_FORCELABELLEFT      0x0020
#define TCS_TABS                0x0000
#define TCS_BUTTONS             0x0100
#define TCS_SINGLELINE          0x0000
#define TCS_MULTILINE           0x0200
#define TCS_RIGHTJUSTIFY        0x0000
#define TCS_FIXEDWIDTH          0x0400
#define TCS_RAGGEDRIGHT         0x0800
#define TCS_FOCUSONBUTTONDOWN   0x1000
#define TCS_OWNERDRAWFIXED      0x2000
#define TCS_TOOLTIPS            0x4000
#define TCS_FOCUSNEVER          0x8000


#define ACS_CENTER              0x0001
#define ACS_TRANSPARENT         0x0002
#define ACS_AUTOPLAY            0x0004









#define WM_DDE_FIRST	    0x03E0
#define WM_DDE_INITIATE     (WM_DDE_FIRST)
#define WM_DDE_TERMINATE    (WM_DDE_FIRST+1)
#define WM_DDE_ADVISE	    (WM_DDE_FIRST+2)
#define WM_DDE_UNADVISE     (WM_DDE_FIRST+3)
#define WM_DDE_ACK	        (WM_DDE_FIRST+4)
#define WM_DDE_DATA	        (WM_DDE_FIRST+5)
#define WM_DDE_REQUEST	    (WM_DDE_FIRST+6)
#define WM_DDE_POKE	        (WM_DDE_FIRST+7)
#define WM_DDE_EXECUTE	    (WM_DDE_FIRST+8)
#define WM_DDE_LAST	        (WM_DDE_FIRST+8)





#ifdef  UNICODE                     
#define __TEXT(quote) L##quote      
#else   /* UNICODE */               
#define __TEXT(quote) quote         
#endif /* UNICODE */                
#define TEXT(quote) __TEXT(quote)   

//
//  Language IDs.
//
//  The following two combinations of primary language ID and
//  sublanguage ID have special semantics:
//
//    Primary Language ID   Sublanguage ID      Result
//    -------------------   ---------------     ------------------------
//    LANG_NEUTRAL          SUBLANG_NEUTRAL     Language neutral
//    LANG_NEUTRAL          SUBLANG_DEFAULT     User default language
//    LANG_NEUTRAL          SUBLANG_SYS_DEFAULT System default language
//

//
//  Primary language IDs.
//

#define LANG_NEUTRAL                     0x00

#define LANG_AFRIKAANS                   0x36
#define LANG_ALBANIAN                    0x1c
#define LANG_ARABIC                      0x01
#define LANG_BASQUE                      0x2d
#define LANG_BELARUSIAN                  0x23
#define LANG_BULGARIAN                   0x02
#define LANG_CATALAN                     0x03
#define LANG_CHINESE                     0x04
#define LANG_CROATIAN                    0x1a
#define LANG_CZECH                       0x05
#define LANG_DANISH                      0x06
#define LANG_DUTCH                       0x13
#define LANG_ENGLISH                     0x09
#define LANG_ESTONIAN                    0x25
#define LANG_FAEROESE                    0x38
#define LANG_FARSI                       0x29
#define LANG_FINNISH                     0x0b
#define LANG_FRENCH                      0x0c
#define LANG_GERMAN                      0x07
#define LANG_GREEK                       0x08
#define LANG_HEBREW                      0x0d
#define LANG_HUNGARIAN                   0x0e
#define LANG_ICELANDIC                   0x0f
#define LANG_INDONESIAN                  0x21
#define LANG_ITALIAN                     0x10
#define LANG_JAPANESE                    0x11
#define LANG_KOREAN                      0x12
#define LANG_LATVIAN                     0x26
#define LANG_LITHUANIAN                  0x27
#define LANG_NORWEGIAN                   0x14
#define LANG_POLISH                      0x15
#define LANG_PORTUGUESE                  0x16
#define LANG_ROMANIAN                    0x18
#define LANG_RUSSIAN                     0x19
#define LANG_SERBIAN                     0x1a
#define LANG_SLOVAK                      0x1b
#define LANG_SLOVENIAN                   0x24
#define LANG_SPANISH                     0x0a
#define LANG_SWEDISH                     0x1d
#define LANG_THAI                        0x1e
#define LANG_TURKISH                     0x1f
#define LANG_UKRAINIAN                   0x22
#define LANG_VIETNAMESE                  0x2a

//
//  Sublanguage IDs.
//
//  The name immediately following SUBLANG_ dictates which primary
//  language ID that sublanguage ID can be combined with to form a
//  valid language ID.
//

#define SUBLANG_NEUTRAL                  0x00    // language neutral
#define SUBLANG_DEFAULT                  0x01    // user default
#define SUBLANG_SYS_DEFAULT              0x02    // system default

#define SUBLANG_ARABIC_SAUDI_ARABIA      0x01    // Arabic (Saudi Arabia)
#define SUBLANG_ARABIC_IRAQ              0x02    // Arabic (Iraq)
#define SUBLANG_ARABIC_EGYPT             0x03    // Arabic (Egypt)
#define SUBLANG_ARABIC_LIBYA             0x04    // Arabic (Libya)
#define SUBLANG_ARABIC_ALGERIA           0x05    // Arabic (Algeria)
#define SUBLANG_ARABIC_MOROCCO           0x06    // Arabic (Morocco)
#define SUBLANG_ARABIC_TUNISIA           0x07    // Arabic (Tunisia)
#define SUBLANG_ARABIC_OMAN              0x08    // Arabic (Oman)
#define SUBLANG_ARABIC_YEMEN             0x09    // Arabic (Yemen)
#define SUBLANG_ARABIC_SYRIA             0x0a    // Arabic (Syria)
#define SUBLANG_ARABIC_JORDAN            0x0b    // Arabic (Jordan)
#define SUBLANG_ARABIC_LEBANON           0x0c    // Arabic (Lebanon)
#define SUBLANG_ARABIC_KUWAIT            0x0d    // Arabic (Kuwait)
#define SUBLANG_ARABIC_UAE               0x0e    // Arabic (U.A.E)
#define SUBLANG_ARABIC_BAHRAIN           0x0f    // Arabic (Bahrain)
#define SUBLANG_ARABIC_QATAR             0x10    // Arabic (Qatar)
#define SUBLANG_CHINESE_TRADITIONAL      0x01    // Chinese (Taiwan)
#define SUBLANG_CHINESE_SIMPLIFIED       0x02    // Chinese (PR China)
#define SUBLANG_CHINESE_HONGKONG         0x03    // Chinese (Hong Kong SAR)
#define SUBLANG_CHINESE_SINGAPORE        0x04    // Chinese (Singapore)
#define SUBLANG_DUTCH                    0x01    // Dutch
#define SUBLANG_DUTCH_BELGIAN            0x02    // Dutch (Belgian)
#define SUBLANG_ENGLISH_US               0x01    // English (USA)
#define SUBLANG_ENGLISH_UK               0x02    // English (UK)
#define SUBLANG_ENGLISH_AUS              0x03    // English (Australian)
#define SUBLANG_ENGLISH_CAN              0x04    // English (Canadian)
#define SUBLANG_ENGLISH_NZ               0x05    // English (New Zealand)
#define SUBLANG_ENGLISH_EIRE             0x06    // English (Irish)
#define SUBLANG_ENGLISH_SOUTH_AFRICA     0x07    // English (South Africa)
#define SUBLANG_ENGLISH_JAMAICA          0x08    // English (Jamaica)
#define SUBLANG_ENGLISH_CARIBBEAN        0x09    // English (Caribbean)
#define SUBLANG_ENGLISH_BELIZE           0x0a    // English (Belize)
#define SUBLANG_ENGLISH_TRINIDAD         0x0b    // English (Trinidad)
#define SUBLANG_FRENCH                   0x01    // French
#define SUBLANG_FRENCH_BELGIAN           0x02    // French (Belgian)
#define SUBLANG_FRENCH_CANADIAN          0x03    // French (Canadian)
#define SUBLANG_FRENCH_SWISS             0x04    // French (Swiss)
#define SUBLANG_FRENCH_LUXEMBOURG        0x05    // French (Luxembourg)
#define SUBLANG_GERMAN                   0x01    // German
#define SUBLANG_GERMAN_SWISS             0x02    // German (Swiss)
#define SUBLANG_GERMAN_AUSTRIAN          0x03    // German (Austrian)
#define SUBLANG_GERMAN_LUXEMBOURG        0x04    // German (Luxembourg)
#define SUBLANG_GERMAN_LIECHTENSTEIN     0x05    // German (Liechtenstein)
#define SUBLANG_ITALIAN                  0x01    // Italian
#define SUBLANG_ITALIAN_SWISS            0x02    // Italian (Swiss)
#define SUBLANG_KOREAN                   0x01    // Korean (Extended Wansung)
#define SUBLANG_KOREAN_JOHAB             0x02    // Korean (Johab)
#define SUBLANG_NORWEGIAN_BOKMAL         0x01    // Norwegian (Bokmal)
#define SUBLANG_NORWEGIAN_NYNORSK        0x02    // Norwegian (Nynorsk)
#define SUBLANG_PORTUGUESE               0x02    // Portuguese
#define SUBLANG_PORTUGUESE_BRAZILIAN     0x01    // Portuguese (Brazilian)
#define SUBLANG_SERBIAN_LATIN            0x02    // Serbian (Latin)
#define SUBLANG_SERBIAN_CYRILLIC         0x03    // Serbian (Cyrillic)
#define SUBLANG_SPANISH                  0x01    // Spanish (Castilian)
#define SUBLANG_SPANISH_MEXICAN          0x02    // Spanish (Mexican)
#define SUBLANG_SPANISH_MODERN           0x03    // Spanish (Modern)
#define SUBLANG_SPANISH_GUATEMALA        0x04    // Spanish (Guatemala)
#define SUBLANG_SPANISH_COSTA_RICA       0x05    // Spanish (Costa Rica)
#define SUBLANG_SPANISH_PANAMA           0x06    // Spanish (Panama)
#define SUBLANG_SPANISH_DOMINICAN_REPUBLIC 0x07  // Spanish (Dominican Republic)
#define SUBLANG_SPANISH_VENEZUELA        0x08    // Spanish (Venezuela)
#define SUBLANG_SPANISH_COLOMBIA         0x09    // Spanish (Colombia)
#define SUBLANG_SPANISH_PERU             0x0a    // Spanish (Peru)
#define SUBLANG_SPANISH_ARGENTINA        0x0b    // Spanish (Argentina)
#define SUBLANG_SPANISH_ECUADOR          0x0c    // Spanish (Ecuador)
#define SUBLANG_SPANISH_CHILE            0x0d    // Spanish (Chile)
#define SUBLANG_SPANISH_URUGUAY          0x0e    // Spanish (Uruguay)
#define SUBLANG_SPANISH_PARAGUAY         0x0f    // Spanish (Paraguay)
#define SUBLANG_SPANISH_BOLIVIA          0x10    // Spanish (Bolivia)
#define SUBLANG_SPANISH_EL_SALVADOR      0x11    // Spanish (El Salvador)
#define SUBLANG_SPANISH_HONDURAS         0x12    // Spanish (Honduras)
#define SUBLANG_SPANISH_NICARAGUA        0x13    // Spanish (Nicaragua)
#define SUBLANG_SPANISH_PUERTO_RICO      0x14    // Spanish (Puerto Rico)
#define SUBLANG_SWEDISH                  0x01    // Swedish
#define SUBLANG_SWEDISH_FINLAND          0x02    // Swedish (Finland)

//
//  Sorting IDs.
//

#define SORT_DEFAULT                     0x0     // sorting default

#define SORT_JAPANESE_XJIS               0x0     // Japanese XJIS order
#define SORT_JAPANESE_UNICODE            0x1     // Japanese Unicode order

#define SORT_CHINESE_BIG5                0x0     // Chinese BIG5 order
#define SORT_CHINESE_PRCP                0x0     // PRC Chinese Phonetic order
#define SORT_CHINESE_UNICODE             0x1     // Chinese Unicode order
#define SORT_CHINESE_PRC                 0x2     // PRC Chinese Stroke Count order

#define SORT_KOREAN_KSC                  0x0     // Korean KSC order
#define SORT_KOREAN_UNICODE              0x1     // Korean Unicode order

#define SORT_GERMAN_PHONE_BOOK           0x1     // German Phone Book order

#ifndef UNDER_CE
#include <dlgs.h>
#include <winver.h>
#endif

#endif /* _WINRESRC_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\uuid.cpp ===
/*	
 *	UUID.C
 *
 *	Purpose:
 *		provide definitions for locally used GUID's
 *
 *	Copyright (c) 1995-1996, Microsoft Corporation. All rights reserved.
 */
#include "_common.h"

//set these two GUIDs up for export in our file

#undef IID_RichEditOle
#undef IID_IRichEditOleCallback
DEFINE_GUID(IID_IRichEditOle,         0x00020D00, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IRichEditOleCallback, 0x00020D03, 0, 0, 0xC0,0,0,0,0,0,0,0x46);

#undef DEFINE_GUID
#undef DEFINE_OLEGUID

#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    const IID name \
        = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#define DEFINE_OLEGUID(name, l, w1, w2) \
    DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)


DEFINE_OLEGUID(IID_IDispatch,				0x00020400, 0, 0);
DEFINE_OLEGUID(IID_IUnknown,				0x00000000, 0, 0);
DEFINE_OLEGUID(IID_IEnumFORMATETC,          0x00000103, 0, 0);
DEFINE_OLEGUID(IID_IDataObject,             0x0000010e, 0, 0);
DEFINE_OLEGUID(IID_IDropSource,             0x00000121, 0, 0);
DEFINE_OLEGUID(IID_IDropTarget,             0x00000122, 0, 0);
DEFINE_OLEGUID(IID_IViewObject,	 			0x0000010d, 0, 0);
DEFINE_OLEGUID(IID_IViewObject2,			0x00000127, 0, 0);
DEFINE_OLEGUID(IID_IAdviseSink,				0x0000010f, 0, 0);
DEFINE_OLEGUID(IID_IOleClientSite, 			0x00000118, 0, 0);
DEFINE_OLEGUID(IID_IOleWindow,				0x00000114, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceSite,			0x00000119, 0, 0);
DEFINE_OLEGUID(IID_IOleLink,	 			0x0000011d, 0, 0);
DEFINE_OLEGUID(IID_IOleCache,	 			0x0000011e, 0, 0);
DEFINE_OLEGUID(IID_IOleObject, 				0x00000112, 0, 0);
DEFINE_OLEGUID(IID_IPersistStorage,			0x0000010a, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceObject,	   	0x00000113, 0, 0);
DEFINE_GUID(IID_IRichEditOle,				0x00020D00, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IRichEditOleCallback,		0x00020D03, 0, 0, 0xC0,0,0,0,0,0,0,0x46);

DEFINE_OLEGUID(CLSID_Picture_EnhMetafile,	0x00000319, 0, 0);
DEFINE_OLEGUID(CLSID_StaticMetafile,		0x00000315, 0, 0);
DEFINE_OLEGUID(CLSID_StaticDib,				0x00000316, 0, 0); 			


// REMARK: presumably TOM should have official MS GUIDs
// To make pre-compiled headers work better, we just copy the
// guid definitions here.  Make sure they don't change!

DEFINE_GUID(LIBID_tom,			0x8CC497C9,	0xA1DF,0x11ce,0x80,0x98,0x00,0xAA,
											0x00,0x47,0xBE,0x5D);
DEFINE_GUID(IID_ITextDocument,	0x8CC497C0,	0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,
											0x00,0x47,0xBE,0x5D);
DEFINE_GUID(IID_ITextSelection,	0x8CC497C1,	0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,
											0x00,0x47,0xBE,0x5D);
DEFINE_GUID(IID_ITextRange,		0x8CC497C2,	0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,
											0x00,0x47,0xBE,0x5D);
DEFINE_GUID(IID_ITextFont,		0x8CC497C3,	0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,
											0x00,0x47,0xBE,0x5D);
DEFINE_GUID(IID_ITextPara,		0x8CC497C4,	0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,
											0x00,0x47,0xBE,0x5D);
DEFINE_GUID(IID_ITextMsgFilter,	0xA3787420, 0x4267,0x11D1,0x88,0x3A,0x3C,0x8B,
											0x00,0xC1,0x00,0x00);
DEFINE_GUID(IID_ITextDocument2,	0x01C25500,	0x4268,0x11D1,0x88,0x3A,0x3C,0x8B,
											0x00,0xC1,0x00,0x00);


// Accessibility stuff
// We need to define this as EXTERN_C since the DEFINE_GUID macro removes the EXTERN_C
//
EXTERN_C DEFINE_GUID(IID_IAccessible,		0x618736e0, 0x3c3d, 0x11cf, 0x81, 0x0c, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
EXTERN_C DEFINE_GUID(LIBID_Accessibility,	0x1ea4dbf0, 0x3c3b, 0x11cf, 0x81, 0x0c, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);											
EXTERN_C DEFINE_OLEGUID(IID_IEnumVARIANT,	0x00020404, 0x0000, 0x0000);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\win2mac.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       win2mac.cpp
//
//  Contents:   All functions that are not implemented for the Macintosh
//              Stubs are coded so that we can link cleanly.
//
//----------------------------------------------------------------------------

#ifndef PEGASUS
#include "_common.h"
#include <mbstring.h>
#include "stdio.h"

#if defined(MACPORT) && defined(UNICODE)

#include <macname1.h>
#include <quickdraw.h>
#include <macname2.h>

AssertData

//----------------------------------------------------------------------------
//
//	Mac wrapper functions  
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Function:   MacCLSIDFromProgID
//
//----------------------------------------------------------------------------
#undef CLSIDFromProgID
STDAPI MacCLSIDFromProgID (LPCWSTR lpszProgID, LPCLSID lpclsid)
{
	CStrIn str(lpszProgID);
	return CLSIDFromProgID((LPOLESTR)str, lpclsid);
}

//----------------------------------------------------------------------------
//
//  Function:   MacCoTaskMemAlloc
//
//----------------------------------------------------------------------------
STDAPI_(LPVOID) MacCoTaskMemAlloc(ULONG cb)
{
	IMalloc		*pIMalloc = NULL;
	HRESULT		hr;
	HGLOBAL		pMem = NULL;

	hr = CoGetMalloc ( MEMCTX_TASK, &pIMalloc);
	if (hr)
	{
		goto Cleanup; 
	}

	pMem = pIMalloc->Alloc(cb);

Cleanup:
	if(	pIMalloc )
		pIMalloc->Release();
    return (LPVOID)pMem;

}

//----------------------------------------------------------------------------
//
//  Function:   MacCoTaskMemFree
//
//----------------------------------------------------------------------------
STDAPI_(void)   MacCoTaskMemFree(LPVOID pv)
{
	IMalloc		*pIMalloc = NULL;
	HRESULT		hr;
	HGLOBAL		pMem = NULL;

	hr = CoGetMalloc ( MEMCTX_TASK, &pIMalloc);
	if (hr)
	{
		goto Cleanup; 
	}
	pIMalloc->Free(pv);

Cleanup:
	if(	pIMalloc )
		pIMalloc->Release();

}
//----------------------------------------------------------------------------
//
//  Function:   MacCoTaskMemRealloc
//
//----------------------------------------------------------------------------
STDAPI_(LPVOID) MacCoTaskMemRealloc(LPVOID pv, ULONG cb)
{
	IMalloc		*pIMalloc = NULL;
	HRESULT		hr;
	HGLOBAL		pMem = NULL;

	hr = CoGetMalloc ( MEMCTX_TASK, &pIMalloc);
	if (hr)
	{
		goto Cleanup; 
	}

	pMem = pIMalloc->Realloc(pv,cb);

Cleanup:
	if(	pIMalloc )
		pIMalloc->Release();
    return (LPVOID)pMem;

}

//----------------------------------------------------------------------------
//
//  Function:   MacGetCurrentObject
//
//----------------------------------------------------------------------------
HGDIOBJ WINAPI MacGetCurrentObject(HDC	hdc,   // handle of device context
                                   UINT uObjectType)  // object-type identifier
{
    // GetCurrentObject is not supported under wlm, so we always simulate failure
    // by returning NULL
    return NULL;
}

//----------------------------------------------------------------------------
// NOTE WELL: GetDoubleClickTime() maps to GetDblTime() in the VC++ 4.0 header
//			  file MSDEV\MAC\INCLUDE\MACOS\EVENTS.H. The only problem is that
//			  GetDblTime() returns the count in "Ticks" (1/60th second) and
//			  we want milliseconds (0.001 sec). This should be fixed when the
//			  bug in the VC4 header file is fixed. - DAS 1/16/96
//----------------------------------------------------------------------------
UINT MacGetDoubleClickTime()
{
	return MulDiv(100,GetDblTime(),6);
}

//----------------------------------------------------------------------------
//
//  Function:   MacGetMetaFileBitsEx
//
//----------------------------------------------------------------------------
UINT WINAPI MacGetMetaFileBitsEx(HMETAFILE  hmf,    UINT  nSize,    LPVOID  lpvData   )
{
    Assert (0 && "GetMetaFileBitsEx is not implemented for Macintosh");

    return NULL;
}

//----------------------------------------------------------------------------
//
//  Function:   MacIsValidCodePage
//
//----------------------------------------------------------------------------
WINBASEAPI BOOL WINAPI MacIsValidCodePage(UINT  CodePage)
{
    return TRUE;
}

//----------------------------------------------------------------------------
//
//  Function:   MacOleDraw
//
//----------------------------------------------------------------------------
#undef OleDraw
STDAPI MacOleDraw(
    IUnknown * pUnk,	//Points to the view object to be drawn
    DWORD dwAspect,		//Specifies how the object is to be represented
    HDC hdcDraw,		//Identifies the device context on which to draw
    LPCRECT lprcBounds	//Specifies the rectangle in which the object is drawn
   )	
{
    Rect rect;
	HRESULT ret;
    GrafPtr grafptr = CheckoutPort(hdcDraw, CA_NONE);
    Assert(grafptr);

    rect.top    = lprcBounds->top;
    rect.bottom = lprcBounds->bottom;
    rect.left   = lprcBounds->left;
    rect.right  = lprcBounds->right;

	ret = OleDraw(pUnk, dwAspect, grafptr,  &rect);

    CheckinPort(hdcDraw, CA_ALL);
	return ret;
}	

//----------------------------------------------------------------------------
//
//  Function:   MacProgIDFromCLSID
//
//----------------------------------------------------------------------------
#undef ProgIDFromCLSID
STDAPI MacProgIDFromCLSID (REFCLSID clsid, LPWSTR FAR* lplpszProgID)
{
	CStrIn str(*lplpszProgID);
	return ProgIDFromCLSID(clsid, (LPSTR FAR*)&str);
}

//-------------------------------------------------------------------------
//
//  Function:   MacRichEditWndProc
//
//  Synopsis:   This is the Mac WndProc callback function.  
//
//  Arguments:  HWND hwnd, 
//				UINT msg, 
//				WPARAM wparam,
//				LPARAM lparam
//
//  Returns:    LRESULT
//
//  Notes:		The function processes the messages, then often calls
//				the normal PC callback function (RichEditANSIWndProc);
//				
//
//-------------------------------------------------------------------------
LRESULT  CALLBACK MacRichEditWndProc(
		HWND hwnd, 
		UINT msg, 
		WPARAM wparam,
		LPARAM lparam)
{
	TRACEBEGINPARAM(TRCSUBSYSHOST, TRCSCOPEINTERN, "MacRichEditWndProc", msg);


	switch( msg )
	{
	
		
		case WM_MACINTOSH:
		{
			if (LOWORD(wparam) == WLM_SETMENUBAR)     
				return TRUE;	// dont change the menu bar
		}
		break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_LBUTTONDBLCLK:
		{
			MacSimulateMouseButtons(msg,wparam);
		}
		break;

 		case WM_KEYDOWN:
 		case WM_KEYUP:
		{
			MacSimulateKey(msg,wparam);
		}
		break;

		case WM_SIZE:
		//case WM_SETFOCUS:
		//case WM_SYSCOLORCHANGE:
		//case WM_MOVE:
		//case WM_MACINTOSH:
		{
			return DefWindowProc(hwnd, msg, wparam, lparam);
		}
		break;

		case WM_CHAR:
		{
			return RichEditWndProc(hwnd, msg, wparam, lparam);
		}
		break;
		default:
			return RichEditANSIWndProc(hwnd, msg, wparam, lparam);

	}
	return RichEditANSIWndProc(hwnd, msg, wparam, lparam);
}

//----------------------------------------------------------------------------
//
//  Function:   MacSelectPalette
//
//----------------------------------------------------------------------------
HPALETTE WINAPI MacSelectPalette(HDC hdc, HPALETTE hpal, BOOL bForceBackground)
{
	if (hpal)
		return ::SelectPalette(hdc,hpal,bForceBackground);
	else
		return NULL;
}

//----------------------------------------------------------------------------
//
//  Function:   MacportSetCursor
//
//----------------------------------------------------------------------------
HCURSOR MacportSetCursor(HCURSOR  hCursor)
{
    if (hCursor)
		return SetCursor(hCursor);
	else
	{
		ObscureCursor();
		return NULL;
	}
}
//----------------------------------------------------------------------------
//
//  Function:   MacSetMetaFileBitsEx
//
//----------------------------------------------------------------------------
HMETAFILE WINAPI MacSetMetaFileBitsEx(UINT  nSize,CONST BYTE *  lpData )
{
    Assert (0 && "SetMetaFileBitsEx is not implemented for Macintosh");
	
    return NULL;

}

//-------------------------------------------------------------------------
//
//  Function:   MacSimulateKey
//
//  Synopsis:   Simulates menu enabler keys for the mac
//
//  Arguments:  [msg]
//              [wParam]
//
//  Returns:    UINT
//
//  Notes:      The key is changed to accommodate the mac.
//				
//
//-------------------------------------------------------------------------

UINT MacSimulateKey (UINT& msg, WPARAM& wParam)
{
    BYTE rgbKeyState[256];

    GetKeyboardState(rgbKeyState);

	if (rgbKeyState[VK_CONTROL])        
	{
		rgbKeyState[VK_CONTROL] = 0;   
	}

	SetKeyboardState(rgbKeyState);
    
    return msg;
}

//-------------------------------------------------------------------------
//
//  Function:   MacSimulateMouseButtons
//
//  Synopsis:   Simulates the right and middle mouse Windows buttons.
//
//  Arguments:  [msg]
//              [wParam]
//
//  Returns:    UINT
//
//  Notes:      The right mouse is simulated by CTRL (or COMMAND) click.  The
//              middle mouse is simulated by SHIFT click.  Because CTRL is already
//              in use the CTRL click is simulated using the OPTION key.
//
//              The command key is used the same as the control key because
//              WLM likes to pick up the CTRL mouse as a user break.  This makes
//              debugging the right mouse simulation very difficult.
//
//-------------------------------------------------------------------------

//-------------------------------------------------------------------------
typedef struct tagUISim    
	{
    UINT msg;
    UINT wParam;
    BYTE control;	// Value for VK_CONTROL key state
    BYTE menu;		// Value for VK_MENU key state
    } UISim;
//-------------------------------------------------------------------------

UINT MacSimulateMouseButtons (UINT& msg, WPARAM& wParam)
{
    BYTE rgbKeyState[256];
    WORD stateIndex = 0;

    UISim UISim[] =                                                //  8    4     2     1
    {                                                                    // cmd shift ctrl option
        WM_LBUTTONDOWN, MK_LBUTTON,                       0x00, 0x00,    //  -    -     -     -
        WM_LBUTTONDOWN, MK_LBUTTON|MK_CONTROL,            0x80, 0x00,    //  -    -     -     x
        WM_RBUTTONDOWN, MK_RBUTTON,                       0x00, 0x00,    //  -    -     x     -
        WM_RBUTTONDOWN, MK_RBUTTON|MK_CONTROL,            0x80, 0x00,    //  -    -     x     x
        WM_MBUTTONDOWN, MK_MBUTTON,                       0x00, 0x00,    //  -    x     -     -
        WM_MBUTTONDOWN, MK_MBUTTON|MK_CONTROL,            0x80, 0x00,    //  -    x     -     x
        WM_RBUTTONDOWN, MK_RBUTTON|MK_MBUTTON,            0x00, 0x00,    //  -    x     x     -
        WM_RBUTTONDOWN, MK_RBUTTON|MK_MBUTTON|MK_CONTROL, 0x80, 0x00,    //  -    x     x     x
        WM_LBUTTONDOWN, MK_LBUTTON,                       0x00, 0x10,    //  x    -     -     -
        WM_LBUTTONDOWN, MK_LBUTTON|MK_CONTROL,            0x80, 0x10,    //  x    -     -     x
        WM_RBUTTONDOWN, MK_RBUTTON,                       0x00, 0x10,    //  x    -     x     -
        WM_RBUTTONDOWN, MK_RBUTTON|MK_CONTROL,            0x80, 0x10,    //  x    -     x     x
        WM_MBUTTONDOWN, MK_MBUTTON,                       0x00, 0x10,    //  x    x     -     -
        WM_MBUTTONDOWN, MK_MBUTTON|MK_CONTROL,            0x80, 0x10,    //  x    x     -     x
        WM_RBUTTONDOWN, MK_RBUTTON|MK_MBUTTON,            0x00, 0x10,    //  x    x     x     -
        WM_RBUTTONDOWN, MK_RBUTTON|MK_MBUTTON|MK_CONTROL, 0x80, 0x10     //  x    x     x     x
    };



		// Determine which keys were pressed, and clean out the state variables

		GetKeyboardState(rgbKeyState);

		if (rgbKeyState[VK_OPTION])
		{
		   rgbKeyState[VK_OPTION] = 0;     // Clear key state
		   stateIndex |= 0x01;             // Set option key bit in index
		}

		if (rgbKeyState[VK_CONTROL])
		{
			rgbKeyState[VK_CONTROL] = 0;    // Clear key state
			stateIndex |= 0x02;             // Set control key bit in index
		}

		if (rgbKeyState[VK_COMMAND])        // Use command key like control key due to WLM debug issues
		{
			rgbKeyState[VK_COMMAND] = 0;    // Clear key state
			stateIndex |= 0x08;             // Set command key bit in index
		}

		if (rgbKeyState[VK_SHIFT])
		{
			rgbKeyState[VK_SHIFT] = 0;      // Clear key state
		    stateIndex |= 0x04;             // Set shift key bit in index
		}

		// Now set the return values

		if (stateIndex)         // Only do this is the mouse is being simulated
		{
		   msg     = (msg - WM_LBUTTONDOWN) + UISim[stateIndex].msg;
		   wParam  = UISim[stateIndex].wParam;

		   rgbKeyState[VK_CONTROL] = UISim[stateIndex].control;
		   rgbKeyState[VK_MENU] = UISim[stateIndex].menu;
		   SetKeyboardState(rgbKeyState);
		}
    return msg;
}

//----------------------------------------------------------------------------
//
//  Function:   MacSysAllocStringLen
//
//----------------------------------------------------------------------------
STDAPI_(BSTR) MacSysAllocStringLen(LPCWSTR  lpStringW, UINT lenChars)
{

	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "SysAllocStringLenMac");

	int		lenStrBytes;
	LPSTR	lpStringMB;

	if ((lpStringW) && (*lpStringW != NULL))
		{
		lenStrBytes = MsoWideCharToMultiByte(CP_ACP,0,lpStringW,lenChars,NULL,NULL,NULL,NULL);
		lpStringMB = (LPSTR)CoTaskMemAlloc( lenStrBytes + sizeof(INT) );
		memcpy(lpStringMB, &lenStrBytes, sizeof(INT));	//copy BSTR lenghth in integer before BSTR
		lpStringMB += sizeof(INT);
		MsoWideCharToMultiByte(CP_ACP,0,lpStringW,lenChars,lpStringMB,lenStrBytes,NULL,NULL);
	}
	else
	{
		// note that in every case so far used on RichEdit the first parm is NULL
		// so no way to determine how big to make the buffer
		// therefore making it the lenghth of a unicode buffer - max size it could be for mbcs 

		lenStrBytes = lenChars*sizeof(WCHAR);
	
		lpStringMB = (LPSTR)CoTaskMemAlloc( lenStrBytes + sizeof(INT) );
		// not sure if this should be lenChars or lenStrBytes
		// note that lenStrBytes is wchar lenghth - the max length it could be for mbcs 
		// memcpy(lpStringMB, &lenStrBytes, sizeof(INT));	//copy BSTR lenghth in integer before BSTR
		memcpy(lpStringMB, &lenChars, sizeof(INT));	//copy BSTR lenghth in integer before BSTR
		lpStringMB += sizeof(INT);
	}
	return	(BSTR)lpStringMB;
}

//----------------------------------------------------------------------------
//
//  Function:   MacWordSwapLong
//
//----------------------------------------------------------------------------
ULONG MacWordSwapLong ( ULONG ul)
{

    WORD w1,w2;

    w1 = (WORD)ul;
    w2 = (WORD)(ul>>16);

    return (((ULONG)w1)<<16) | w2;
}



#endif	//MACPORT

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\w32win32.cpp ===
/*
 *	Unicode <--> MultiByte conversions, OLE, and other system functions
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */
#include <objbase.h>	// CoCreateInstance define
#include "aimm.h"		// AIMM i/f
#include "aimm_i.c"		// AIMM CLSID etc

#include "_font.h"
#include "_uspi.h"
#define MAX_HKLS 256			// It will be a while before we have more KBs

static HINSTANCE g_hOleAut32 = NULL;
static HINSTANCE g_hOle32 = NULL;

#ifndef NOACCESSIBILITY 
static HINSTANCE g_hAcc = NULL;
static HINSTANCE g_hUser32 = NULL;
#endif

class CIMM32_PROC
{
public:
	void *ImmGetCompositionStringA;
	void *ImmGetCompositionStringW;
	void *ImmGetContext;
	void *ImmSetCompositionFontA;
	void *ImmSetCompositionWindow;
	void *ImmReleaseContext;
	void *ImmGetProperty;
	void *ImmGetCandidateWindow;
	void *ImmSetCandidateWindow;
	void *ImmNotifyIME;
	void *ImmAssociateContext;
	void *ImmGetVirtualKey;
	void *ImmEscapeA;
	void *ImmEscapeW;
	void *ImmGetOpenStatus;
	void *ImmSetOpenStatus;
	void *ImmGetConversionStatus;
	void *ImmSetConversionStatus;
	void *ImmGetDefaultIMEWnd;
	void *ImmSetCompositionStringW;
};
static CIMM32_PROC	g_IMM32Proc;

class CIMESHARE_PROC
{
public:
	void *FSupportSty;
	void *PIMEStyleFromAttr;
	void *PColorStyleTextFromIMEStyle;
	void *PColorStyleBackFromIMEStyle;
	void *FBoldIMEStyle;
	void *FItalicIMEStyle;
	void *FUlIMEStyle;
	void *IdUlIMEStyle;
	void *RGBFromIMEColorStyle;
};
static CIMESHARE_PROC	g_IMEShareProc;

class COLEAUT32_PROC
{
public:
	void *LoadRegTypeLib;
	void *LoadTypeLib;
	void *LoadTypeLibEx;
	void *SysAllocString;
	void *SysAllocStringLen;
	void *SysFreeString;
	void *SysStringLen;
	void *VariantInit;
};
static COLEAUT32_PROC	g_OleAut32Proc;

class COLE32_PROC
{
public:
	void *OleCreateFromData;
	void *CoTaskMemFree;
	void *CreateBindCtx;
	void *OleDuplicateData;
	void *CoTreatAsClass;
	void *ProgIDFromCLSID;
	void *OleConvertIStorageToOLESTREAM;
	void *OleConvertIStorageToOLESTREAMEx;
	void *OleSave;
	void *StgCreateDocfileOnILockBytes;
	void *CreateILockBytesOnHGlobal;
	void *OleCreateLinkToFile;
	void *CoTaskMemAlloc;
	void *CoTaskMemRealloc;
	void *OleInitialize;
	void *OleUninitialize;
	void *OleSetClipboard;
	void *OleFlushClipboard;
	void *OleIsCurrentClipboard;
	void *DoDragDrop;
	void *OleGetClipboard;
	void *RegisterDragDrop;
	void *OleCreateLinkFromData;
	void *OleCreateStaticFromData;
	void *OleDraw;
	void *OleSetContainedObject;
	void *CoDisconnectObject;
	void *WriteFmtUserTypeStg;
	void *WriteClassStg;
	void *SetConvertStg;
	void *ReadFmtUserTypeStg;
	void *ReadClassStg;
	void *OleRun;
	void *RevokeDragDrop;
	void *CreateStreamOnHGlobal;
	void *GetHGlobalFromStream;
	void *OleCreateDefaultHandler;
	void *CLSIDFromProgID;
	void *OleConvertOLESTREAMToIStorage;
	void *OleLoad;
	void *ReleaseStgMedium;
	void *CoCreateInstance;
};
static COLE32_PROC	g_Ole32Proc;

class CConvertStr
{
public:
    operator char *();

protected:
    CConvertStr();
    ~CConvertStr();
    void Free();

    LPSTR   _pstr;
    char    _ach[MAX_PATH * 2];
};

inline CConvertStr::operator char *()
{
    return _pstr;
}

inline CConvertStr::CConvertStr()
{
    _pstr = NULL;
}

inline CConvertStr::~CConvertStr()
{
    Free();
}

class CStrIn : public CConvertStr
{
public:
    CStrIn(LPCWSTR pwstr, UINT CodePage = CP_ACP);
    CStrIn(LPCWSTR pwstr, int cwch, UINT CodePage = CP_ACP);
    int strlen();

protected:
    CStrIn();
    void Init(LPCWSTR pwstr, int cwch, UINT CodePage = CP_ACP);

    int _cchLen;
};

inline CStrIn::CStrIn()
{
}

inline int CStrIn::strlen()
{
    return _cchLen;
}

class CStrOut : public CConvertStr
{
public:
    CStrOut(LPWSTR pwstr, int cwchBuf);
    ~CStrOut();

    int     BufSize();
    int     Convert();

private:
    LPWSTR  _pwstr;
    int     _cwchBuf;
};

inline int CStrOut::BufSize()
{
    return _cwchBuf * 2;
}

//
//	Multi-Byte ---> Unicode conversion
//

class CStrOutW : public CConvertStrW
{
public:
    CStrOutW(LPSTR pstr, int cchBuf, UINT uiCodePage);
    ~CStrOutW();

    int     BufSize();
    int     Convert();

private:

    LPSTR  	_pstr;
    int     _cchBuf;
	UINT	_uiCodePage;
};

inline int CStrOutW::BufSize()
{
    return _cchBuf;
}

DWORD CW32System::AddRef()
{
	return ++_cRefs;
}

DWORD CW32System::Release()
{
	DWORD culRefs =	--_cRefs;

	if(culRefs == 0)
	{
		FreeIME();
		if (g_hOle32)
		{
			EnterCriticalSection(&g_CriticalSection);
			OleUninitialize();
			FreeLibrary(g_hOle32);
			g_hOle32 = NULL;
			memset(&g_Ole32Proc, 0, sizeof(g_Ole32Proc));
 			LeaveCriticalSection(&g_CriticalSection);
		}
	}
	return culRefs;
}

ATOM WINAPI CW32System::RegisterREClass(
	const WNDCLASSW *lpWndClass,
	const char *szAnsiClassName,
	WNDPROC AnsiWndProc
)
{
	WNDCLASSA wc;
	ATOM atom;

	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "RegisterREClass");
	// First register the normal window class.
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
	{
		atom = ::RegisterClass(lpWndClass); 
		if (!atom && GetLastError() == ERROR_CLASS_ALREADY_EXISTS)
			atom = FindAtom(lpWndClass->lpszClassName);
	}
	else
	{
		// On WIndows 95 we need to convert the window class name.
		CStrIn strMenuName(lpWndClass->lpszMenuName);
		CStrIn strClassName(lpWndClass->lpszClassName);
		Assert(sizeof(wc) == sizeof(*lpWndClass));
		memcpy(&wc, lpWndClass, sizeof(wc));
		wc.lpszMenuName = strMenuName;
		wc.lpszClassName = strClassName;
		
		atom = ::RegisterClassA(&wc);		
		if (!atom && GetLastError() == ERROR_CLASS_ALREADY_EXISTS)
			atom = FindAtomA(wc.lpszClassName);
	}
	
	if (!atom || !szAnsiClassName)
		return atom;		

	// Now REgister the ANSI window class name i.e. RICHEDIT20A
	wc.style = lpWndClass->style;
	wc.cbClsExtra = lpWndClass->cbClsExtra;
	wc.cbWndExtra = lpWndClass->cbWndExtra;
	wc.hInstance = lpWndClass->hInstance;
	wc.hIcon = lpWndClass->hIcon;
	wc.hCursor = lpWndClass->hIcon;
	wc.hbrBackground = lpWndClass->hbrBackground;
	wc.lpszMenuName = NULL;
	wc.lpfnWndProc = AnsiWndProc;
	wc.lpszClassName = szAnsiClassName;

	atom = ::RegisterClassA(&wc);
	if (!atom && GetLastError() == ERROR_CLASS_ALREADY_EXISTS)
		atom = FindAtomA(szAnsiClassName);
		
	return atom;
}

LONG ValidateTextRange(TEXTRANGE *pstrg);

LRESULT CW32System::ANSIWndProc(
	HWND	hwnd,
	UINT	msg,
	WPARAM	wparam,
	LPARAM	lparam,
	BOOL	fIs10Mode)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "RichEditANSIWndProc");

	#ifdef DEBUG
	Tracef(TRCSEVINFO, "hwnd %lx, msg %lx, wparam %lx, lparam %lx", hwnd, msg, wparam, lparam);
	#endif	// DEBUG

	LRESULT	lres;

	switch( msg )
	{

	case EM_REPLACESEL:
	case WM_SETTEXT:
	{	
		SETTEXTEX st = {ST_CHECKPROTECTION, 0};
		if(msg == EM_REPLACESEL)
		{
			st.flags = wparam ? ST_CHECKPROTECTION | ST_SELECTION | ST_KEEPUNDO | ST_10REPLACESEL
							  :	ST_CHECKPROTECTION | ST_SELECTION | ST_10REPLACESEL;
		}
		else if (fIs10Mode)
			st.flags |= ST_10WM_SETTEXT;		// 1.0 Mode WM_SETTEXT

		return RichEditWndProc(hwnd, EM_SETTEXTEX, (WPARAM)&st, lparam);
	}

	case EM_FINDTEXT:
	case EM_FINDTEXTEX:
		{
			// We cheat a little here because FINDTEXT and FINDTEXTEX overlap
			// with the exception of the extra out param chrgText in FINDTEXTEX
			FINDTEXTEXW ftexw;
			FINDTEXTA *pfta = (FINDTEXTA *)lparam;
			CStrInW strinw(pfta->lpstrText, W32->GetKeyboardCodePage());

			ftexw.chrg = pfta->chrg;
			ftexw.lpstrText = (WCHAR *)strinw;

			lres = RichEditWndProc(hwnd, msg, wparam, (LPARAM)&ftexw);
			
			if(msg == EM_FINDTEXTEX)
			{
				// In the FINDTEXTEX case, the extra field in the
				// FINDTEXTEX data structure is an out parameter indicating
				// the range where the text was found.  Update the 'real'
				// [in, out] parameter accordingly.	
				((FINDTEXTEXA *)lparam)->chrgText = ftexw.chrgText;
			}
			return lres;
		}
		break;				

	case EM_GETSELTEXT:
		{
			GETTEXTEX gt;
			const char chDefault = ' ';

			gt.cb = (unsigned)-1;			// Client claims to have enuf room		
			gt.flags = GT_SELECTION;		// Get selected text
			gt.codepage = (unsigned)-1;		// Use default CCharFormat codepage
			gt.lpDefaultChar = &chDefault;	// Translate other chars into blanks
			gt.lpUsedDefChar = NULL;

			return RichEditWndProc(hwnd, EM_GETTEXTEX, (WPARAM)&gt, lparam);
		}
		break;

	// case WM_GETTEXT:	Handled by Ansi filter

	// case WM_GETTEXTLENGTH: Handled by Ansi filter

	case EM_GETTEXTRANGE:
		{
			TEXTRANGEA *ptrg = (TEXTRANGEA *)lparam;

            LONG clInBuffer = ValidateTextRange((TEXTRANGEW *) ptrg);

            // If size is -1, this means that the size required is the total
            // size of the the text.
            if(-1 == clInBuffer)
            {
                // We can get this length either by digging the data out of the
                // various structures below us or we can take advantage of the
                // WM_GETTEXTLENGTH message. The first might be slightly 
                // faster but the second definitely save code size. So we
                // will go with the second.
                clInBuffer = SendMessage(hwnd, WM_GETTEXTLENGTH, 0, 0);
            }

            if(0 == clInBuffer)
            {
                // The buffer was invalid for some reason or there was not data
                // to copy. In any case, we are done.
                return 0;
            }

            // Verify that the output buffer is big enough.
            if(IsBadWritePtr(ptrg->lpstrText, clInBuffer + 1))
            {
                // Not enough space so don't copy any
                return 0;
            }

			// For EM_GETTEXTRANGE case, we again don't know how big the
			// incoming buffer is, only that it should be *at least* as
			// great as cpMax - cpMin in the text range structure.  We also
			// know that anything *bigger* than (cpMax - cpMin)*2 bytes is
			// uncessary.  So we'll just assume that it's "big enough"
			// and let WideCharToMultiByte scribble as much as it needs.
			// Memory shortages are the caller's responsibility (courtesy
			// of the RichEdit 1.0 design).
			
			CStrOutW stroutw(ptrg->lpstrText, (clInBuffer + 1) * sizeof(WCHAR), 
							 RichEditWndProc(hwnd, EM_GETCODEPAGE, 0, 0));
			TEXTRANGEW trgw;
			trgw.chrg = ptrg->chrg;
			trgw.lpstrText = (WCHAR *)stroutw;

			RichEditWndProc(hwnd, EM_GETTEXTRANGE, wparam, (LPARAM)&trgw);
			
			return stroutw.Convert();	// Return count of BYTEs converted
		}

	case EM_GETLINE:
		{
			// The size is indicated by the first word of the memory pointed
			// to by lparam
			WORD size = *(WORD *)lparam;
			CStrOutW stroutw((char *)lparam, (DWORD)size,
							 RichEditWndProc(hwnd, EM_GETCODEPAGE, 0, 0));
			WCHAR *pwsz = (WCHAR *)stroutw;
			*(WORD *)pwsz = size;

			lres = RichEditWndProc(hwnd, msg, wparam, (LPARAM)pwsz);

			if (lres < size)
				*(pwsz+lres) = L'\0';		// EM_GETLINE does not return NULL-terminated string.
			LONG cach = stroutw.Convert();
			// Note: should probably return cach for 3.0 too, i.e.,
			// just like EM_GETTEXTRANGE above
			return fIs10Mode ? cach : lres;	// If 1.0, return count of BYTEs converted
		}

#ifdef DEBUG
	case WM_NCCREATE:
	case WM_CREATE:
		// These messages should be handled higher up so let everyone
		// know we got to the wrong place!
		AssertSz(FALSE, "CW32System::ANSIWndProc got WM_CREATE or WM_NCCREATE");
		break;

#endif // DEBUG

	}
	return RichEditWndProc(hwnd, msg, wparam, lparam);
}

// Note that AnsiFilter could be refined so that we could get rid
// of the ANSI window proc.
void CW32System::AnsiFilter(
	UINT &	msg,
	WPARAM &wparam,
	LPARAM lparam,
	void *pvoid,
	BOOL f10Mode
)
{
	GETTEXTEX *pgt;
	GETTEXTLENGTHEX *pgtl;
	WM_CHAR_INFO *pwmci;
	bool fAltNumPad = (GetKeyboardFlags() & ALTNUMPAD) != 0;
	UINT cpg = GetKeyboardCodePage(0xFFFFFFFF);

	switch (msg)
	{
		case WM_CHAR:
			pwmci = (WM_CHAR_INFO *) pvoid;
			pwmci->_fTrailByte = false;
			pwmci->_fLeadByte = false;
			pwmci->_fIMEChar = false;
			if (pwmci->_fAccumulate) {
				// We could do some validation here.
				pwmci->_fTrailByte = true;
				return;
			}
			// WM_CHAR > 256 on Win95; assumed to be Unicode

			if(fAltNumPad)
			{
				DWORD Number = GetKeyPadNumber();
				if(Number >= 256 || GetKeyboardFlags() & ALT0)
				{
					wparam = Number;
					if(!IN_RANGE(1250, cpg, 1258))	// Use 1252 for DBCS
						cpg = 1252;					//  codepages
				}
			}

			if(IN_RANGE(128, wparam, 255))
			{							
				bool fShift = (GetKeyboardFlags() & SHIFT) != 0;
				bool fCtrl  = (GetKeyboardFlags() & CTRL)  != 0;

				// If fAltNumPad is set, wparam is HiAnsi
				// If Shift + Alt + Ctrl, it is repeat event from Win3.1 IME
				if ((!fAltNumPad || (fShift && fCtrl)) && GetTrailBytesCount((BYTE) wparam, cpg))
				{
					pwmci->_fLeadByte = true;
					return;
				}
				WPARAM	wparamNew = 0;
				switch ( cpg )
				{				
					case CP_JAPAN:
						// for Japanese codepage, need to translate SBC if KANA mode is on					 
						if ((GetKeyState(VK_KANA) & 1) || f10Mode)		
							break;
						// If not in KANA mode, then fall thru to use 1252 codepage...
					case CP_KOREAN:
					case CP_CHINESE_TRAD:
					case CP_CHINESE_SIM:
						// use English codepage since there is no HiAnsi conversion for
						// FE systems
						cpg = 1252;
						break;				
				}

				if (cpg == 1252 && !IN_RANGE(0x80, wparam, 0x9f))
					return;

				// Convert single byte WM_CHAR messages to Unicode
				if(UnicodeFromMbcs((LPWSTR)&wparamNew, 1, (char *)&wparam, 1,
					cpg) == 1 )
				{
					wparam = wparamNew;
					if (fAltNumPad)
						SetKeyPadNumber(wparam);
				}
			}
			else if(lparam == 1 && _dwPlatformId == VER_PLATFORM_WIN32_NT &&
				wparam > 256 && !fAltNumPad)
			{		
				// On WinNT s/w generated WM_CHAR, this should be WM_IME_CHAR message
				// for some Chinese Level 2 IME.
				if ( cpg == CP_CHINESE_SIM || cpg == CP_CHINESE_TRAD )
				{
					BYTE	bTrailByte = wparam >> 8;
					BYTE	bLeadByte = wparam;
					wparam =  (bLeadByte << 8) | bTrailByte;
					pwmci->_fIMEChar = true;
				}
			}
			return;

		case WM_GETTEXT:
			// EVIL HACK ALERT: on Win95, WM_GETTEXT should always be treated
			// as an ANSI message.
			pgt = (GETTEXTEX *) pvoid;
			pgt->cb = wparam;
			pgt->flags = GT_USECRLF;
			pgt->codepage = 0;
			pgt->lpDefaultChar = NULL;
			pgt->lpUsedDefChar = NULL;
			msg = EM_GETTEXTEX;
			wparam = (WPARAM) pgt;
			return;

		case WM_GETTEXTLENGTH:
			// EVIL HACK ALERT: on Win95, WM_GETEXTLENGTH should always
			// be treated an ANSI message because some old apps will send
			// this message to arbitrary windows (e.g., accessibility aps)
			pgtl = (GETTEXTLENGTHEX *) pvoid;
			pgtl->flags = GTL_NUMBYTES | GTL_PRECISE | GTL_USECRLF;
			pgtl->codepage = 0;
			msg = EM_GETTEXTLENGTHEX;
			wparam = (WPARAM) pgtl;
			return;
	}
}


HGLOBAL WINAPI CW32System::GlobalAlloc( UINT uFlags, DWORD dwBytes )
{
	return ::GlobalAlloc( uFlags, dwBytes );
}

HGLOBAL WINAPI CW32System::GlobalFree( HGLOBAL hMem )
{
	return hMem ? ::GlobalFree( hMem ) : NULL;
}

UINT WINAPI CW32System::GlobalFlags( HGLOBAL hMem )
{
	return ::GlobalFlags( hMem );
}

HGLOBAL WINAPI CW32System::GlobalReAlloc( HGLOBAL hMem, DWORD dwBytes, UINT uFlags )
{
	return ::GlobalReAlloc( hMem, dwBytes, uFlags );
}

DWORD WINAPI CW32System::GlobalSize( HGLOBAL hMem )
{
	return ::GlobalSize( hMem );
}

LPVOID WINAPI CW32System::GlobalLock( HGLOBAL hMem )
{
	return ::GlobalLock( hMem );
}

HGLOBAL WINAPI CW32System::GlobalHandle( LPCVOID pMem )
{
	return ::GlobalHandle( pMem );
}

BOOL WINAPI CW32System::GlobalUnlock( HGLOBAL hMem )
{
	return ::GlobalUnlock( hMem );
}

/*
 *	CW32System::CheckChangeKeyboardLayout (bCharSet)
 *
 *	@mfunc
 *		Change keyboard for new charset, or charset at new character position.
 *
 *	@rdesc
 *		Keyboard hkl selected. 0 if failed to find keyboard
 *
 *	@comm
 *		Using only the currently loaded KBs, locate one that will support
 *		bCharSet. This is called anytime a character format	change occurs,
 *		or the caret position changes.
 *
 *	@devnote
 *		The current KB is preferred. If a previous association was made,
 *		see if the KB is still loaded in the system and if so use it.
 *		Otherwise, locate a suitable KB, preferring KB's that have
 *		the same charset ID as their default, preferred charset. If no
 *		match can be found, nothing changes.
 */
HKL CW32System::CheckChangeKeyboardLayout(
	BYTE bCharSet)
{
	return ActivateKeyboard(ScriptIndexFromCharSet(bCharSet));
}

HKL CW32System::GetKeyboardLayout (
	DWORD dwThreadID)
{
	if(dwThreadID == 0x0FFFFFFFF)
		RefreshKeyboardLayout();

	return _hklCurrent;
}

/*
 *	CW32System::RefreshKeyboardLayout ()
 *
 *	@mfunc
 *		Update _hklCurrent with current keyboard layout and update
 *		entry for corresponding script.
 */
void CW32System::RefreshKeyboardLayout ()
{
	INT iScript;

	_hklCurrent = ::GetKeyboardLayout(0);
	GetCharSet(ConvertLanguageIDtoCodePage(PRIMARYLANGID(_hklCurrent)), &iScript);
	SetPreferredKbd(iScript, _hklCurrent);
}

/*
 *	CW32System::ActivateKeyboard (iScript)
 *
 *	@mfunc
 *		Change keyboard to that for iScript
 *
 *	@rdesc
 *		Keyboard hkl selected. 0 if no keyboard assigned to iScript
 */
HKL CW32System::ActivateKeyboard(
	LONG iScript)
{
	HKL hkl = 0;
	if((unsigned)iScript < NCHARSETS)
	{
		hkl = GetPreferredKbd(iScript);

		if(hkl && hkl != _hklCurrent && ActivateKeyboardLayout(hkl, 0))
			_hklCurrent = hkl;
	}
	return hkl;
}

/*
 *	CW32System::FindDirectionalKeyboard (fRTL)
 *
 *	@mfunc
 *		Find first keyboard with direction given by fRTL
 *
 *	@rdesc
 *		HKL of keyboard selected. 0 if no keyboard for direction given by fRTL
 */
HKL CW32System::FindDirectionalKeyboard(
	BOOL fRTL)
{
	Assert(ARABIC_INDEX == (HEBREW_INDEX | 1));
	int iKB;

	if(fRTL)
	{
		GetCharSet(GetACP(), &iKB);
		if(!IN_RANGE(HEBREW_INDEX, iKB, ARABIC_INDEX))
			iKB = _hkl[HEBREW_INDEX] ? HEBREW_INDEX :
				  _hkl[ARABIC_INDEX] ? ARABIC_INDEX : -1;
	}
	else
		for(iKB = 0;
			iKB < NCHARSETS && (!_hkl[iKB] || IN_RANGE(HEBREW_INDEX, iKB, ARABIC_INDEX));
			iKB++)
				;
	return ActivateKeyboard(iKB);
}

enum DLL_ENUM{
	DLL_OLEAUT32,
	DLL_OLE32,
	
#ifndef NOACCESSIBILITY 
	DLL_ACC,
	DLL_USER32
#endif
};

static void SetProcAddr(
	void * & pfunc,
	DLL_ENUM which,
	char *	 fname )
{
	HINSTANCE hdll = NULL;
	EnterCriticalSection(&g_CriticalSection);
	if (pfunc == NULL)
	{
		switch (which)
		{
		case DLL_OLEAUT32:
			if (g_hOleAut32 == NULL)
				g_hOleAut32 = W32->LoadLibrary(L"oleaut32.dll" );

			hdll = g_hOleAut32;
			break;

		case DLL_OLE32:
			if (g_hOle32 == NULL)
			{
				g_hOle32 = W32->LoadLibrary(L"ole32.dll");
				CW32System::OleInitialize(NULL);
			}
			hdll = g_hOle32;
			break;

#ifndef NOACCESSIBILITY 
		case DLL_ACC:
			if (g_hAcc == NULL)
				g_hAcc = W32->LoadLibrary(L"oleacc.dll");
			hdll = g_hAcc;
			break;

		case DLL_USER32:
			if (g_hUser32 == NULL)
				g_hUser32 = W32->LoadLibrary(L"user32.dll");
			hdll = g_hUser32;
			break;
#endif			
		}
        Assert(hdll != NULL || which == DLL_USER32);
		pfunc = GetProcAddress( hdll, fname );
	}
	AssertSz(pfunc != NULL || which == DLL_USER32, fname);
 	LeaveCriticalSection(&g_CriticalSection);
}

void CW32System::FreeOle()
{
	if (g_hOleAut32 || g_hOle32) {
		EnterCriticalSection(&g_CriticalSection);
		if (g_hOleAut32 != NULL && FreeLibrary(g_hOleAut32)) {
			g_hOleAut32 = NULL;
			memset(&g_OleAut32Proc, 0, sizeof(g_OleAut32Proc));
		}
		if (g_hOle32 != NULL && FreeLibrary(g_hOle32)) {
			g_hOle32 = NULL;
			memset(&g_Ole32Proc, 0, sizeof(g_Ole32Proc));
		}
 		LeaveCriticalSection(&g_CriticalSection);
	}
}

enum IME_DLL_ENUM{
	DLL_IMM32,
	DLL_IMESHARE
};

static HINSTANCE hIMM32 = NULL;
static HINSTANCE hIMEShare = NULL;

static void SetIMEProcAddr( void * &pfunc, IME_DLL_ENUM which, char * fname )
{
	HINSTANCE hdll = NULL;
	EnterCriticalSection(&g_CriticalSection);
	if (pfunc == NULL)
	{
		switch (which) {
		case DLL_IMM32 :
			if (hIMM32 == NULL)
				hIMM32 = W32->LoadLibrary(L"imm32.dll" );
			Assert( hIMM32 != NULL );
			hdll = hIMM32;
			break;
		case DLL_IMESHARE :
			if (hIMEShare == NULL)
				hIMEShare = W32->LoadLibrary(L"imeshare.dll" );
			else if (hIMEShare == (HINSTANCE)INVALID_HANDLE_VALUE)
				goto Exit;

			hdll = hIMEShare;

			// set to invalid handle if we have tried loading it.
			// this is to avoid loading it again and again in case
			// imeshare.dll is not in the system.
			if (hIMEShare == NULL)
				hIMEShare = (HINSTANCE)INVALID_HANDLE_VALUE;

			break;
		}
		if (hdll)
		{
			pfunc = GetProcAddress( hdll, fname );
			Assert(pfunc != NULL );
		}
	}
Exit:
 	LeaveCriticalSection(&g_CriticalSection);
}

static IActiveIMMApp *pAIMM = (IActiveIMMApp *) NULL;

typedef IMESHAREAPI void (IMECDECL*FEND_CAST)(void);
void CW32System::FreeIME()
{
	if (hIMM32 || hIMEShare || pAIMM) {
		EnterCriticalSection(&g_CriticalSection);
		if (hIMM32 != NULL && FreeLibrary(hIMM32)) {
			hIMM32 = NULL;
			memset(&g_IMM32Proc, 0, sizeof(g_IMM32Proc));
		}
		if (hIMEShare != NULL && hIMEShare != (HINSTANCE)INVALID_HANDLE_VALUE) {
			// clean up IMMShare before leaving
			if ( _pIMEShare )
			{
				_pIMEShare->FDeleteIMEShare();
				_pIMEShare = NULL;
			}
			else
			{
				// This is old IMEShare, end it the old way
				void *pEndIMEShareFunc;
				pEndIMEShareFunc = GetProcAddress( hIMEShare, "EndIMEShare" );
				if (pEndIMEShareFunc)
				{
					( (FEND_CAST)pEndIMEShareFunc)();
				}
			}
			FreeLibrary(hIMEShare);
			hIMEShare = NULL;
			memset(&g_IMEShareProc, 0, sizeof(g_IMEShareProc));
		}
		if (pAIMM != (IActiveIMMApp *)NULL && pAIMM != (IActiveIMMApp *)INVALID_HANDLE_VALUE)
		{
			pAIMM->Release();
			pAIMM = (IActiveIMMApp *)NULL;
		}
		_fHaveAIMM = FALSE;
		_fHaveIMMEShare = FALSE;
		_fHaveIMMProcs = FALSE;
 		LeaveCriticalSection(&g_CriticalSection);
	}
}


// return TRUE if we load AIMM
BOOL CW32System::LoadAIMM()
{
	HRESULT	hResult;

	// return if AIMM has been loaded
	if (_fHaveAIMM)
		return TRUE;

	if (pAIMM == (IActiveIMMApp *)INVALID_HANDLE_VALUE)
		return FALSE;

	EnterCriticalSection(&g_CriticalSection);

	// load if it has not been loaded
	// Try with new W2K/COM+ CLSCTX_NO_CODE_DOWNLOAD flag
	hResult = CW32System::CoCreateInstance(CLSID_CActiveIMM,
		NULL, CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD, IID_IActiveIMMApp, (LPVOID *)&pAIMM);

	if (hResult == E_INVALIDARG)	// Try again if CLSCTX_NO_CODE_DOWNLOAD not support
		hResult = CW32System::CoCreateInstance(CLSID_CActiveIMM,
			NULL, CLSCTX_INPROC_SERVER, IID_IActiveIMMApp, (LPVOID *)&pAIMM);

	_fHaveAIMM = TRUE;
	if (FAILED(hResult))
	{	
		_fHaveAIMM = FALSE;
		pAIMM = (IActiveIMMApp *)INVALID_HANDLE_VALUE;	
	}
	LeaveCriticalSection(&g_CriticalSection);

	return _fHaveAIMM;
}

// Return the Aimm object and AddRef()
BOOL CW32System::GetAimmObject(IUnknown **ppAimm)
{

	*ppAimm = NULL;

	if (pAIMM != NULL && pAIMM != (IActiveIMMApp *)INVALID_HANDLE_VALUE)
	{
		pAIMM->AddRef();
		*ppAimm = pAIMM;
		return TRUE;
	}

	return FALSE;
}


// return TRUE if we have IMEShare in system
// else return FALSE

typedef IMESHAREAPI BOOL (IMECDECL*FINIT_CAST)(void);
typedef IMESHAREAPI CIMEShare *  (IMECDECL*FPIME_CAST)(void);
BOOL CW32System::HaveIMEShare()
{
	// return if IMEShare has been loaded
	if (_fHaveIMMEShare)
		return TRUE;

	if (hIMEShare == (HINSTANCE)INVALID_HANDLE_VALUE)
		return FALSE;

	EnterCriticalSection(&g_CriticalSection);

	// load if it has not been loaded
	hIMEShare = W32->LoadLibrary(L"imeshare.dll");
	
	_fHaveIMMEShare = TRUE;
	// load fail, setup INVALID_HANDLE_VALUE
	if (hIMEShare == NULL)
	{
		hIMEShare = (HINSTANCE)INVALID_HANDLE_VALUE;
		_fHaveIMMEShare = FALSE;
	}
	else
	{
		// get the new IMEshare object and init the DLL
		void *pPIMEShareCreate;
		pPIMEShareCreate = GetProcAddress( hIMEShare, "PIMEShareCreate" );

		if (pPIMEShareCreate)
		{
			_pIMEShare = ( (FPIME_CAST)pPIMEShareCreate) ();
			
			if ( _pIMEShare == NULL )
				_fHaveIMMEShare = FALSE;
			else
			{
				// Setup underline styles that RE supports
				for (int i = IMESTY_UL_MIN; i <= IMESTY_UL_MAX; i++)
				{
					if (i == 2004 || i == 2007 || i == 2008 ||
						i == 2009 || i == 2010)			// Obsolete styles
						continue;
    
					_pIMEShare->FSupportSty(i, i);
				}
			}
		}
		else
		{
			// This is old IMEShare, init it the old way
			void *pInitFunc;
			pInitFunc = GetProcAddress( hIMEShare, "FInitIMEShare" );
			if (pInitFunc)
			{
				_fHaveIMMEShare = ( (FINIT_CAST)pInitFunc)();
			}
			else
				// init failed, forget it
				_fHaveIMMEShare = FALSE;
		}

		if (_fHaveIMMEShare == FALSE)
		{
			// Init failed, forget it
			FreeLibrary(hIMEShare);
			hIMEShare = (HINSTANCE)INVALID_HANDLE_VALUE;
		}
	}
	
	LeaveCriticalSection(&g_CriticalSection);

	return _fHaveIMMEShare;
}

BOOL CW32System::getIMEShareObject(CIMEShare **ppIMEShare)
{
	*ppIMEShare = _pIMEShare;

	return (_pIMEShare != NULL);
}

HRESULT CW32System::AIMMDefWndProc(HWND hWnd, UINT msg, WPARAM wparam, LPARAM lparam, LRESULT *plres)
{
	if (pAIMM != NULL && pAIMM != (IActiveIMMApp *)INVALID_HANDLE_VALUE)
	{
		HRESULT hResult;
		LRESULT	localLRes;

		hResult = pAIMM->OnDefWindowProc(hWnd, msg, wparam, lparam, &localLRes);

		if (hResult == S_OK)
		{
			*plres = localLRes;
			return S_OK;
		}
	}
	return S_FALSE;
}

HRESULT CW32System::AIMMGetCodePage(HKL hKL, UINT *uCodePage)
{
	if (pAIMM != NULL && pAIMM != (IActiveIMMApp *)INVALID_HANDLE_VALUE)
	{
		HRESULT hResult;
		hResult = pAIMM->GetCodePageA(hKL, uCodePage);

		if (SUCCEEDED(hResult))
			return S_OK;
	}
	return S_FALSE;
}

HRESULT CW32System::AIMMActivate(BOOL fRestoreLayout)
{
	if (pAIMM != NULL && pAIMM != (IActiveIMMApp *)INVALID_HANDLE_VALUE)
	{
		HRESULT hResult;
		hResult = pAIMM->Activate(fRestoreLayout);

		if (SUCCEEDED(hResult))
			return S_OK;
	}
	return S_FALSE;
}

HRESULT CW32System::AIMMDeactivate(void)
{
	if (pAIMM != NULL && pAIMM != (IActiveIMMApp *)INVALID_HANDLE_VALUE)
	{
		HRESULT hResult;
		hResult = pAIMM->Deactivate();

		if (SUCCEEDED(hResult))
			return S_OK;
	}
	return S_FALSE;
}

HRESULT CW32System::AIMMFilterClientWindows(ATOM *aaClassList, UINT uSize)
{
	if (pAIMM != NULL && pAIMM != (IActiveIMMApp *)INVALID_HANDLE_VALUE)
	{
		HRESULT hResult;
		hResult = pAIMM->FilterClientWindows(aaClassList, uSize);

		if (SUCCEEDED(hResult))
			return S_OK;
	}
	return S_FALSE;
}

#define RE_OLEAUTAPI(name) 		DECLSPEC_IMPORT HRESULT (STDAPICALLTYPE *name)
#define RE_OLEAUTAPI_(type, name) 	DECLSPEC_IMPORT type (STDAPICALLTYPE *name)

typedef RE_OLEAUTAPI(LRTL_CAST)(REFGUID, WORD, WORD, LCID, ITypeLib **);
HRESULT CW32System::LoadRegTypeLib (
	REFGUID rguid,
	WORD wmajor,
	WORD wminor,
	LCID lcid,
	ITypeLib ** pptlib
)
{
	if (g_OleAut32Proc.LoadRegTypeLib == NULL)
		SetProcAddr( g_OleAut32Proc.LoadRegTypeLib, DLL_OLEAUT32, "LoadRegTypeLib" );
	return ((LRTL_CAST)g_OleAut32Proc.LoadRegTypeLib)(rguid, wmajor, wminor, lcid, pptlib);
}

typedef RE_OLEAUTAPI(LTL_CAST)(const OLECHAR *, ITypeLib **);
HRESULT CW32System::LoadTypeLib ( const OLECHAR *szfile, ITypeLib **pptlib )
{
	if (g_OleAut32Proc.LoadTypeLib == NULL)
		SetProcAddr( g_OleAut32Proc.LoadTypeLib, DLL_OLEAUT32, "LoadTypeLib" );
	return ((LTL_CAST)g_OleAut32Proc.LoadTypeLib)(szfile, pptlib);
}

typedef RE_OLEAUTAPI(LTLEX_CAST)(const OLECHAR *, REGKIND, ITypeLib **);
HRESULT CW32System::LoadTypeLibEx ( const OLECHAR *szfile, REGKIND regkind, ITypeLib **pptlib )
{
	if (g_OleAut32Proc.LoadTypeLibEx == NULL)
		SetProcAddr( g_OleAut32Proc.LoadTypeLibEx, DLL_OLEAUT32, "LoadTypeLibEx" );

	return ((LTLEX_CAST)g_OleAut32Proc.LoadTypeLibEx)(szfile, regkind, pptlib);
}

typedef RE_OLEAUTAPI_(BSTR, SAS_CAST)(const OLECHAR *);
BSTR CW32System::SysAllocString ( const OLECHAR * sz )
{
	if (g_OleAut32Proc.SysAllocString == NULL)
		SetProcAddr( g_OleAut32Proc.SysAllocString, DLL_OLEAUT32, "SysAllocString" );
	return ((SAS_CAST)g_OleAut32Proc.SysAllocString)(sz);
}

typedef RE_OLEAUTAPI_(BSTR, SASL_CAST)(const OLECHAR *, UINT);
BSTR CW32System::SysAllocStringLen ( const OLECHAR *pch, UINT cch )
{
	if (g_OleAut32Proc.SysAllocStringLen == NULL)
		SetProcAddr( g_OleAut32Proc.SysAllocStringLen, DLL_OLEAUT32, "SysAllocStringLen" );
	return ((SASL_CAST)g_OleAut32Proc.SysAllocStringLen)(pch, cch);
}

typedef RE_OLEAUTAPI_(void, SFS_CAST)(BSTR);
void CW32System::SysFreeString ( BSTR bstr )
{
	if (g_OleAut32Proc.SysFreeString == NULL)
		SetProcAddr( g_OleAut32Proc.SysFreeString, DLL_OLEAUT32, "SysFreeString" );
	((SFS_CAST)g_OleAut32Proc.SysFreeString)(bstr);
}

typedef RE_OLEAUTAPI_(UINT, SSL_CAST)(BSTR);
UINT CW32System::SysStringLen ( BSTR bstr )
{
	if (g_OleAut32Proc.SysStringLen == NULL)
		SetProcAddr( g_OleAut32Proc.SysStringLen, DLL_OLEAUT32, "SysStringLen" );
	return ((SSL_CAST)g_OleAut32Proc.SysStringLen)(bstr);
}

typedef RE_OLEAUTAPI_(void, VI_CAST)(VARIANTARG *);
void CW32System::VariantInit ( VARIANTARG * pvarg )
{
	if (g_OleAut32Proc.VariantInit == NULL)
		SetProcAddr( g_OleAut32Proc.VariantInit, DLL_OLEAUT32, "VariantInit" );
	((VI_CAST)g_OleAut32Proc.VariantInit)(pvarg);
}

#define RE_OLE32API(name)		DECLSPEC_IMPORT	HRESULT (STDAPICALLTYPE *name)
#define RE_OLE32API_(type, name) DECLSPEC_IMPORT type (STDAPICALLTYPE *name)

typedef RE_OLE32API(OCFD_CAST)(LPDATAOBJECT, REFIID, DWORD, 
							   LPFORMATETC, LPOLECLIENTSITE,
							   LPSTORAGE, void **);
HRESULT CW32System::OleCreateFromData (
	LPDATAOBJECT pDataObj,
	REFIID riid,
	DWORD renderopt,
	LPFORMATETC pfetc,
	LPOLECLIENTSITE pClientSite,
	LPSTORAGE pStg,
	void **ppvObj
)
{
	if (g_Ole32Proc.OleCreateFromData == NULL)
		SetProcAddr( g_Ole32Proc.OleCreateFromData, DLL_OLE32, "OleCreateFromData" );
	return ((OCFD_CAST)g_Ole32Proc.OleCreateFromData)(pDataObj, riid, renderopt, pfetc, pClientSite, pStg, ppvObj);
}

typedef RE_OLE32API_(void, CTMF_CAST)(LPVOID);
void CW32System::CoTaskMemFree ( LPVOID pv )
{
	if (g_Ole32Proc.CoTaskMemFree == NULL)
		SetProcAddr( g_Ole32Proc.CoTaskMemFree, DLL_OLE32, "CoTaskMemFree" );
	((CTMF_CAST)g_Ole32Proc.CoTaskMemFree)(pv);
}

typedef RE_OLE32API(CBC_CAST)(DWORD, LPBC *);
HRESULT CW32System::CreateBindCtx ( DWORD reserved, LPBC * ppbc )
{
	if (g_Ole32Proc.CreateBindCtx == NULL)
		SetProcAddr( g_Ole32Proc.CreateBindCtx, DLL_OLE32, "CreateBindCtx" );
	return ((CBC_CAST)g_Ole32Proc.CreateBindCtx)(reserved, ppbc);
}

typedef RE_OLE32API_(HANDLE, ODD_CAST)(HANDLE, CLIPFORMAT, UINT);
HANDLE CW32System::OleDuplicateData ( HANDLE hSrc, CLIPFORMAT cfFormat, UINT uFlags )
{
	if (g_Ole32Proc.OleDuplicateData == NULL)
		SetProcAddr( g_Ole32Proc.OleDuplicateData, DLL_OLE32, "OleDuplicateData" );
	return ((ODD_CAST)g_Ole32Proc.OleDuplicateData)(hSrc, cfFormat, uFlags);
}

typedef RE_OLE32API(CTAC_CAST)(REFCLSID, REFCLSID);
HRESULT CW32System::CoTreatAsClass ( REFCLSID clsidold, REFCLSID clsidnew )
{
	if (g_Ole32Proc.CoTreatAsClass == NULL)
		SetProcAddr( g_Ole32Proc.CoTreatAsClass, DLL_OLE32, "CoTreatAsClass" );
	return ((CTAC_CAST)g_Ole32Proc.CoTreatAsClass)(clsidold, clsidnew);
}

typedef RE_OLE32API(PIFC_CAST)(REFCLSID, LPOLESTR *);
HRESULT CW32System::ProgIDFromCLSID ( REFCLSID clsid, LPOLESTR * lplpszProgId )
{
	if (g_Ole32Proc.ProgIDFromCLSID == NULL)
		SetProcAddr( g_Ole32Proc.ProgIDFromCLSID, DLL_OLE32, "ProgIDFromCLSID" );
	return ((PIFC_CAST)g_Ole32Proc.ProgIDFromCLSID)(clsid, lplpszProgId);
}

typedef RE_OLE32API(OCITO_CAST)(LPSTORAGE, LPOLESTREAM);
HRESULT CW32System::OleConvertIStorageToOLESTREAM ( LPSTORAGE pstg, LPOLESTREAM lpolestream)
{
	if (g_Ole32Proc.OleConvertIStorageToOLESTREAM == NULL)
		SetProcAddr( g_Ole32Proc.OleConvertIStorageToOLESTREAM, DLL_OLE32, "OleConvertIStorageToOLESTREAM" );
	return ((OCITO_CAST)g_Ole32Proc.OleConvertIStorageToOLESTREAM)(pstg, lpolestream);
}

typedef RE_OLE32API(OCITOX_CAST)(LPSTORAGE, CLIPFORMAT, LONG, LONG, DWORD, LPSTGMEDIUM, LPOLESTREAM);
HRESULT CW32System::OleConvertIStorageToOLESTREAMEx (
	LPSTORAGE pstg,
	CLIPFORMAT cf,
	LONG lwidth,
	LONG lheight,
	DWORD dwsize,
	LPSTGMEDIUM pmedium,
	LPOLESTREAM lpolestream
)
{
	if (g_Ole32Proc.OleConvertIStorageToOLESTREAMEx == NULL)
		SetProcAddr( g_Ole32Proc.OleConvertIStorageToOLESTREAMEx, DLL_OLE32, "OleConvertIStorageToOLESTREAMEx" );
	return ((OCITOX_CAST)g_Ole32Proc.OleConvertIStorageToOLESTREAMEx)
		(pstg,cf, lwidth, lheight, dwsize, pmedium, lpolestream);
}

typedef RE_OLE32API(OS_CAST)(LPPERSISTSTORAGE, LPSTORAGE, BOOL);
HRESULT CW32System::OleSave ( LPPERSISTSTORAGE pPS, LPSTORAGE pstg, BOOL fSameAsLoad )
{
	if (g_Ole32Proc.OleSave == NULL)
		SetProcAddr( g_Ole32Proc.OleSave, DLL_OLE32, "OleSave" );
	return ((OS_CAST)g_Ole32Proc.OleSave)(pPS, pstg, fSameAsLoad);
}

typedef RE_OLE32API(SCDOI_CAST)(ILockBytes *, DWORD, DWORD, IStorage **);
HRESULT CW32System::StgCreateDocfileOnILockBytes (
	ILockBytes *plkbyt,
	DWORD grfmode,
	DWORD res,
	IStorage **ppstg
)
{
	if (g_Ole32Proc.StgCreateDocfileOnILockBytes == NULL)
		SetProcAddr( g_Ole32Proc.StgCreateDocfileOnILockBytes, DLL_OLE32, "StgCreateDocfileOnILockBytes" );
	return ((SCDOI_CAST)g_Ole32Proc.StgCreateDocfileOnILockBytes)(plkbyt, grfmode, res, ppstg);
}

typedef RE_OLE32API(CIOH_CAST)(HGLOBAL, BOOL, ILockBytes **);
HRESULT CW32System::CreateILockBytesOnHGlobal ( HGLOBAL hGlobal, BOOL fDel, ILockBytes **pplkbyt )
{
	if (g_Ole32Proc.CreateILockBytesOnHGlobal == NULL)
		SetProcAddr( g_Ole32Proc.CreateILockBytesOnHGlobal, DLL_OLE32, "CreateILockBytesOnHGlobal" );
	return ((CIOH_CAST)g_Ole32Proc.CreateILockBytesOnHGlobal)(hGlobal, fDel, pplkbyt);
}

typedef RE_OLE32API(OCLTF_CAST)(LPCOLESTR, REFIID, DWORD, LPFORMATETC,
								LPOLECLIENTSITE, LPSTORAGE, void **);
HRESULT CW32System::OleCreateLinkToFile( 
	LPCOLESTR pstr,
	REFIID rid,
	DWORD renderopt,
	LPFORMATETC pfetc,
	LPOLECLIENTSITE psite,
	LPSTORAGE pstg, 
	void **ppstg
)
{
	if (g_Ole32Proc.OleCreateLinkToFile == NULL)
		SetProcAddr( g_Ole32Proc.OleCreateLinkToFile, DLL_OLE32, "OleCreateLinkToFile" );
	return ((OCLTF_CAST)g_Ole32Proc.OleCreateLinkToFile)(pstr, rid, renderopt, pfetc, psite, pstg, ppstg);
}

typedef RE_OLE32API_(LPVOID, CTMA_CAST)(ULONG);
LPVOID CW32System::CoTaskMemAlloc ( ULONG cb )
{
	if (g_Ole32Proc.CoTaskMemAlloc == NULL)
		SetProcAddr( g_Ole32Proc.CoTaskMemAlloc, DLL_OLE32, "CoTaskMemAlloc" );
	return ((CTMA_CAST)g_Ole32Proc.CoTaskMemAlloc)(cb);
}

typedef RE_OLE32API_(LPVOID, CTMR_CAST)(LPVOID, ULONG);
LPVOID CW32System::CoTaskMemRealloc ( LPVOID pv, ULONG cv)
{
	if (g_Ole32Proc.CoTaskMemRealloc == NULL)
		SetProcAddr( g_Ole32Proc.CoTaskMemRealloc, DLL_OLE32, "CoTaskMemRealloc" );
	return ((CTMR_CAST)g_Ole32Proc.CoTaskMemRealloc)(pv, cv);
}

typedef RE_OLE32API(OI_CAST)(LPVOID);
HRESULT CW32System::OleInitialize ( LPVOID pvres )
{
	if (g_Ole32Proc.OleInitialize == NULL)
		SetProcAddr( g_Ole32Proc.OleInitialize, DLL_OLE32, "OleInitialize" );
	return ((OI_CAST)g_Ole32Proc.OleInitialize)(pvres);
}

typedef RE_OLE32API_(void, OUI_CAST)( void );
void CW32System::OleUninitialize ( void )
{
	if (g_Ole32Proc.OleUninitialize == NULL)
		SetProcAddr( g_Ole32Proc.OleUninitialize, DLL_OLE32, "OleUninitialize" );
	((OUI_CAST)g_Ole32Proc.OleUninitialize)();
}

typedef RE_OLE32API(OSC_CAST)(IDataObject *);
HRESULT CW32System::OleSetClipboard ( IDataObject *pdo )
{
	if (g_Ole32Proc.OleSetClipboard == NULL)
		SetProcAddr( g_Ole32Proc.OleSetClipboard, DLL_OLE32, "OleSetClipboard" );
	return ((OSC_CAST)g_Ole32Proc.OleSetClipboard)(pdo);
}

typedef RE_OLE32API(OFC_CAST)(void);
HRESULT CW32System::OleFlushClipboard ( void )
{
	if (g_Ole32Proc.OleFlushClipboard == NULL)
		SetProcAddr( g_Ole32Proc.OleFlushClipboard, DLL_OLE32, "OleFlushClipboard" );
	return ((OFC_CAST)g_Ole32Proc.OleFlushClipboard)();
}

typedef RE_OLE32API(OICC_CAST)(IDataObject *);
HRESULT CW32System::OleIsCurrentClipboard ( IDataObject *pdo )
{
	if (g_Ole32Proc.OleIsCurrentClipboard == NULL)
		SetProcAddr( g_Ole32Proc.OleIsCurrentClipboard, DLL_OLE32, "OleIsCurrentClipboard" );
	return ((OICC_CAST)g_Ole32Proc.OleIsCurrentClipboard)(pdo);
}

typedef RE_OLE32API(DDD_CAST)(IDataObject *, IDropSource *,
			DWORD, DWORD *);
HRESULT CW32System::DoDragDrop ( IDataObject *pdo, IDropSource *pds, DWORD dweffect, DWORD *pdweffect )
{
	if (g_Ole32Proc.DoDragDrop == NULL)
		SetProcAddr( g_Ole32Proc.DoDragDrop, DLL_OLE32, "DoDragDrop" );
	return ((DDD_CAST)g_Ole32Proc.DoDragDrop)(pdo, pds, dweffect, pdweffect);
}

typedef RE_OLE32API(OGC_CAST)(IDataObject **);
HRESULT CW32System::OleGetClipboard ( IDataObject **ppdo )
{
	if (g_Ole32Proc.OleGetClipboard == NULL)
		SetProcAddr( g_Ole32Proc.OleGetClipboard, DLL_OLE32, "OleGetClipboard" );
	return ((OGC_CAST)g_Ole32Proc.OleGetClipboard)(ppdo);
}

typedef RE_OLE32API(RDD_CAST)(HWND, IDropTarget *);
HRESULT CW32System::RegisterDragDrop ( HWND hwnd, IDropTarget *pdt )
{
	if (g_Ole32Proc.RegisterDragDrop == NULL)
		SetProcAddr( g_Ole32Proc.RegisterDragDrop, DLL_OLE32, "RegisterDragDrop" );
	return ((RDD_CAST)g_Ole32Proc.RegisterDragDrop)(hwnd, pdt);
}

typedef RE_OLE32API(OCLFD_CAST)(IDataObject *, REFIID, DWORD,
								LPFORMATETC, IOleClientSite *,
								IStorage *, void **);
HRESULT CW32System::OleCreateLinkFromData (
	IDataObject *pdo,
	REFIID rid,
	DWORD renderopt,
	LPFORMATETC pfetc,
	IOleClientSite *psite,
	IStorage *pstg,
	void **ppv
)
{
	if (g_Ole32Proc.OleCreateLinkFromData == NULL)
		SetProcAddr( g_Ole32Proc.OleCreateLinkFromData, DLL_OLE32, "OleCreateLinkFromData" );
	return ((OCLFD_CAST)g_Ole32Proc.OleCreateLinkFromData)
		(pdo, rid, renderopt, pfetc, psite, pstg, ppv);
}

typedef RE_OLE32API(OCSFD_CAST)(IDataObject *, REFIID, DWORD,
								LPFORMATETC, IOleClientSite *,
								IStorage *, void **);
HRESULT CW32System::OleCreateStaticFromData (
	IDataObject *pdo,
	REFIID rid,
	DWORD renderopt,
	LPFORMATETC pfetc,
	IOleClientSite *psite,
	IStorage *pstg,
	void **ppv
)
{
	if (g_Ole32Proc.OleCreateStaticFromData == NULL)
		SetProcAddr( g_Ole32Proc.OleCreateStaticFromData, DLL_OLE32, "OleCreateStaticFromData" );
	return ((OCSFD_CAST)g_Ole32Proc.OleCreateStaticFromData)
		(pdo, rid, renderopt, pfetc, psite, pstg, ppv);
}

typedef RE_OLE32API(OD_CAST)(IUnknown *, DWORD, HDC, LPCRECT);
HRESULT CW32System::OleDraw ( IUnknown *punk, DWORD dwAspect, HDC hdc, LPCRECT prect )
{
	if (g_Ole32Proc.OleDraw == NULL)
		SetProcAddr( g_Ole32Proc.OleDraw, DLL_OLE32, "OleDraw" );
	return ((OD_CAST)g_Ole32Proc.OleDraw)(punk, dwAspect, hdc, prect);
}

typedef RE_OLE32API(OSCO_CAST)(IUnknown *, BOOL);
HRESULT CW32System::OleSetContainedObject ( IUnknown *punk, BOOL fContained )
{
	if (g_Ole32Proc.OleSetContainedObject == NULL)
		SetProcAddr( g_Ole32Proc.OleSetContainedObject, DLL_OLE32, "OleSetContainedObject" );
	return ((OSCO_CAST)g_Ole32Proc.OleSetContainedObject)(punk, fContained);
}

typedef RE_OLE32API(CDO_CAST)(IUnknown *, DWORD);
HRESULT CW32System::CoDisconnectObject ( IUnknown *punk, DWORD dwres )
{
	if (g_Ole32Proc.CoDisconnectObject == NULL)
		SetProcAddr( g_Ole32Proc.CoDisconnectObject, DLL_OLE32, "CoDisconnectObject" );
	return ((CDO_CAST)g_Ole32Proc.CoDisconnectObject)(punk, dwres);
}

typedef RE_OLE32API(WFUTS_CAST)(IStorage *, CLIPFORMAT, LPOLESTR);
HRESULT CW32System::WriteFmtUserTypeStg ( IStorage *pstg, CLIPFORMAT cf, LPOLESTR pstr)
{
	if (g_Ole32Proc.WriteFmtUserTypeStg == NULL)
		SetProcAddr( g_Ole32Proc.WriteFmtUserTypeStg, DLL_OLE32, "WriteFmtUserTypeStg" );
	return ((WFUTS_CAST)g_Ole32Proc.WriteFmtUserTypeStg)(pstg, cf, pstr);
}

typedef RE_OLE32API(WCS_CAST)(IStorage *, REFCLSID);
HRESULT CW32System::WriteClassStg ( IStorage *pstg, REFCLSID rid )
{
	if (g_Ole32Proc.WriteClassStg == NULL)
		SetProcAddr( g_Ole32Proc.WriteClassStg, DLL_OLE32, "WriteClassStg" );
	return ((WCS_CAST)g_Ole32Proc.WriteClassStg)(pstg, rid);
}

typedef RE_OLE32API(SCS_CAST)(IStorage *, BOOL);
HRESULT CW32System::SetConvertStg ( IStorage *pstg, BOOL fConv )
{
	if (g_Ole32Proc.SetConvertStg == NULL)
		SetProcAddr( g_Ole32Proc.SetConvertStg, DLL_OLE32, "SetConvertStg" );
	return ((SCS_CAST)g_Ole32Proc.SetConvertStg)(pstg, fConv);
}

typedef RE_OLE32API(RFUTS_CAST)(IStorage *, CLIPFORMAT *, LPOLESTR *);
HRESULT CW32System::ReadFmtUserTypeStg ( IStorage *pstg, CLIPFORMAT *pcf, LPOLESTR *pstr )
{
	if (g_Ole32Proc.ReadFmtUserTypeStg == NULL)
		SetProcAddr( g_Ole32Proc.ReadFmtUserTypeStg, DLL_OLE32, "ReadFmtUserTypeStg" );
	return ((RFUTS_CAST)g_Ole32Proc.ReadFmtUserTypeStg)(pstg, pcf, pstr);
}

typedef RE_OLE32API(RCS_CAST)(IStorage *, CLSID *);
HRESULT CW32System::ReadClassStg ( IStorage *pstg, CLSID *pclsid )
{
	if (g_Ole32Proc.ReadClassStg == NULL)
		SetProcAddr( g_Ole32Proc.ReadClassStg, DLL_OLE32, "ReadClassStg" );
	return ((RCS_CAST)g_Ole32Proc.ReadClassStg)(pstg, pclsid);
}

typedef RE_OLE32API(OR_CAST)(IUnknown *);
HRESULT CW32System::OleRun ( IUnknown *punk )
{
	if (g_Ole32Proc.OleRun == NULL)
		SetProcAddr( g_Ole32Proc.OleRun, DLL_OLE32, "OleRun" );
	return ((OR_CAST)g_Ole32Proc.OleRun)(punk);
}

typedef RE_OLE32API(RevDD_CAST)(HWND);
HRESULT CW32System::RevokeDragDrop ( HWND hwnd )
{
	if (g_Ole32Proc.RevokeDragDrop == NULL)
		SetProcAddr( g_Ole32Proc.RevokeDragDrop, DLL_OLE32, "RevokeDragDrop" );
	return ((RevDD_CAST)g_Ole32Proc.RevokeDragDrop)(hwnd);
}

typedef RE_OLE32API(CSOH_CAST)(HGLOBAL, BOOL, IStream **);
HRESULT CW32System::CreateStreamOnHGlobal ( HGLOBAL hglobal, BOOL fDel, IStream **ppstrm )
{
	if (g_Ole32Proc.CreateStreamOnHGlobal == NULL)
		SetProcAddr( g_Ole32Proc.CreateStreamOnHGlobal, DLL_OLE32, "CreateStreamOnHGlobal" );
	return ((CSOH_CAST)g_Ole32Proc.CreateStreamOnHGlobal)(hglobal, fDel, ppstrm);
}

typedef RE_OLE32API(GHFS_CAST)(IStream *, HGLOBAL *);
HRESULT CW32System::GetHGlobalFromStream ( IStream *pstrm, HGLOBAL *phglobal )
{
	if (g_Ole32Proc.GetHGlobalFromStream == NULL)
		SetProcAddr( g_Ole32Proc.GetHGlobalFromStream, DLL_OLE32, "GetHGlobalFromStream" );
	return ((GHFS_CAST)g_Ole32Proc.GetHGlobalFromStream)(pstrm, phglobal);
}

typedef RE_OLE32API(OCDH_CAST)(REFCLSID, IUnknown *, REFIID, void **);
HRESULT CW32System::OleCreateDefaultHandler (
	REFCLSID clsid,
	IUnknown *punk,
	REFIID riid,
	void **ppv
)
{
	if (g_Ole32Proc.OleCreateDefaultHandler == NULL)
		SetProcAddr( g_Ole32Proc.OleCreateDefaultHandler, DLL_OLE32, "OleCreateDefaultHandler" );
	return ((OCDH_CAST)g_Ole32Proc.OleCreateDefaultHandler)(clsid, punk, riid, ppv);
}

typedef RE_OLE32API(CFPI_CAST)(LPCOLESTR, LPCLSID);
HRESULT CW32System::CLSIDFromProgID ( LPCOLESTR pstr, LPCLSID pclsid )
{
	if (g_Ole32Proc.CLSIDFromProgID == NULL)
		SetProcAddr( g_Ole32Proc.CLSIDFromProgID, DLL_OLE32, "CLSIDFromProgID" );
	return ((CFPI_CAST)g_Ole32Proc.CLSIDFromProgID)(pstr, pclsid);
}

typedef RE_OLE32API(OCOTI_CAST)(LPOLESTREAM, IStorage *, 
								const DVTARGETDEVICE *);
HRESULT CW32System::OleConvertOLESTREAMToIStorage (
	LPOLESTREAM pstrm,
	IStorage *pstg,
	const DVTARGETDEVICE *ptd
)
{
	if (g_Ole32Proc.OleConvertOLESTREAMToIStorage == NULL)
		SetProcAddr( g_Ole32Proc.OleConvertOLESTREAMToIStorage, DLL_OLE32, "OleConvertOLESTREAMToIStorage" );
	return ((OCOTI_CAST)g_Ole32Proc.OleConvertOLESTREAMToIStorage)(pstrm, pstg, ptd);
}

typedef RE_OLE32API(OL_CAST)(IStorage *, REFIID, IOleClientSite *, void **);
HRESULT CW32System::OleLoad ( 
	IStorage *pstg,
	REFIID riid,
	IOleClientSite *psite,
	void **ppv
)
{
	if (g_Ole32Proc.OleLoad == NULL)
		SetProcAddr( g_Ole32Proc.OleLoad, DLL_OLE32, "OleLoad" );
	return ((OL_CAST)g_Ole32Proc.OleLoad)(pstg, riid, psite, ppv);
}

typedef RE_OLE32API(RSM_CAST)(LPSTGMEDIUM);
HRESULT CW32System::ReleaseStgMedium ( LPSTGMEDIUM pmedium )
{
	if (g_Ole32Proc.ReleaseStgMedium == NULL)
		SetProcAddr( g_Ole32Proc.ReleaseStgMedium, DLL_OLE32, "ReleaseStgMedium" );
	return ((RSM_CAST)g_Ole32Proc.ReleaseStgMedium)(pmedium);
}

typedef RE_OLE32API(CCI_CAST)(REFCLSID, LPUNKNOWN, DWORD, REFIID, LPVOID);
HRESULT CW32System::CoCreateInstance (REFCLSID rclsid, LPUNKNOWN pUnknown,
		DWORD dwClsContext, REFIID riid, LPVOID *ppv)
{
	if (g_Ole32Proc.CoCreateInstance == NULL)
		SetProcAddr( g_Ole32Proc.CoCreateInstance, DLL_OLE32, "CoCreateInstance" );
	return ((CCI_CAST)g_Ole32Proc.CoCreateInstance)(rclsid, pUnknown, dwClsContext, riid, ppv);
}

BOOL CW32System::ImmInitialize( void )
{
	// MAC Only function.
	return FALSE;
}

void CW32System::ImmTerminate( void )
{
	// MAC only function.
	return;
}

#ifndef NOACCESSIBILITY

typedef HRESULT (WINAPI *ACC_VC_CAST)(VARIANTARG FAR*, VARIANTARG FAR*);
HRESULT CW32System::VariantCopy(VARIANTARG FAR*  pvargDest, VARIANTARG FAR*  pvargSrc)
{
    static void *pVariantCopy = NULL;
	if (pVariantCopy == NULL)
		SetProcAddr( pVariantCopy, DLL_OLEAUT32, "VariantCopy" );
	if (pVariantCopy)
		return ((ACC_VC_CAST)pVariantCopy)(pvargDest, pvargSrc);

    return (E_NOINTERFACE);
}

typedef LRESULT (WINAPI *ACC_LFO_CAST)(REFIID, WPARAM, LPUNKNOWN);
LRESULT CW32System::LResultFromObject(REFIID riid, WPARAM wParam, LPUNKNOWN punk)
{
	static void *pLResultFromObject = NULL;
	if (pLResultFromObject == NULL)
		SetProcAddr( pLResultFromObject, DLL_ACC, "LresultFromObject" );
	if (pLResultFromObject)
		return ((ACC_LFO_CAST)pLResultFromObject)(riid, wParam, punk);
	return E_NOINTERFACE;
}

typedef HRESULT (WINAPI *ACC_AOFW_CAST)(HWND, DWORD, REFIID, void **);
HRESULT CW32System::AccessibleObjectFromWindow (HWND hWnd, DWORD dwID, REFIID riidInterface, void ** ppvObject)
{
    static void *pAccessibleObjectFromWindow = NULL;
	if (pAccessibleObjectFromWindow == NULL)
		SetProcAddr( pAccessibleObjectFromWindow, DLL_ACC, "AccessibleObjectFromWindow" );
	if (pAccessibleObjectFromWindow)
		return ((ACC_AOFW_CAST)pAccessibleObjectFromWindow)(hWnd, dwID, riidInterface, ppvObject);
    return (E_NOINTERFACE);
}

typedef BOOL (WINAPI *ACC_BI_CAST)(BOOL);
BOOL CW32System::BlockInput (BOOL fBlock)
{
    static void *pBlockInput = NULL;
	if (pBlockInput == NULL)
		SetProcAddr( pBlockInput, DLL_USER32, "BlockInput" );
	if (pBlockInput)
		return ((ACC_BI_CAST)pBlockInput)(fBlock);

    return FALSE;
}

typedef UINT (WINAPI *ACC_SI_CAST)(UINT, LPINPUT, int);
UINT CW32System::SendInput (UINT nInputs, LPINPUT pInputs, int cbSize)
{
    static void *pSendInput = NULL;
	if (pSendInput == NULL)
		SetProcAddr( pSendInput, DLL_USER32, "SendInput" );
	if (pSendInput)
		return ((ACC_SI_CAST)pSendInput)(nInputs, pInputs, cbSize);

    return 0;
}

typedef VOID (WINAPI *ACC_NWE_CAST)(DWORD, HWND, LONG, LONG);
VOID CW32System::NotifyWinEvent(DWORD dwEvent, HWND hWnd, LONG lObjectType, LONG lObjectId)
{
	static void *pNotfiyWinEvent = NULL;
	if (pNotfiyWinEvent == INVALID_HANDLE_VALUE)
		return;

	if (pNotfiyWinEvent == NULL)
		SetProcAddr( pNotfiyWinEvent, DLL_USER32, "NotifyWinEvent" );
	if (pNotfiyWinEvent)
		((ACC_NWE_CAST)pNotfiyWinEvent)(dwEvent, hWnd, lObjectType, lObjectId);
	else 
		pNotfiyWinEvent = INVALID_HANDLE_VALUE;

}

#endif

typedef LONG (WINAPI*IGCSA_CAST)(HIMC, DWORD, LPVOID, DWORD);
LONG CW32System::ImmGetCompositionStringA ( 
	HIMC hIMC, 
	DWORD dwIndex, 
	LPVOID lpBuf, 
	DWORD dwBufLen,
	BOOL bAimmActivated)
{	
	if (bAimmActivated)
	{
		HRESULT hResult;
		LONG	lCopied = 0;
	
		hResult = pAIMM->GetCompositionStringA(hIMC, dwIndex, dwBufLen, &lCopied, lpBuf);
				
		return (SUCCEEDED(hResult) ? lCopied : 0);
	}

	if (g_IMM32Proc.ImmGetCompositionStringA == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmGetCompositionStringA, DLL_IMM32, "ImmGetCompositionStringA" );
	return ((IGCSA_CAST)g_IMM32Proc.ImmGetCompositionStringA)(hIMC, dwIndex, lpBuf, dwBufLen);
}

typedef LONG (WINAPI*IGCSW_CAST)(HIMC, DWORD, LPVOID, DWORD);
LONG CW32System::ImmGetCompositionStringW ( 
	HIMC hIMC, 
	DWORD dwIndex, 
	LPVOID lpBuf, 
	DWORD dwBufLen,
	BOOL bAimmActivated)
{	
	if (bAimmActivated)
	{
		HRESULT hResult;
		LONG	lCopied = 0;
	
		hResult = pAIMM->GetCompositionStringW(hIMC, dwIndex, dwBufLen, &lCopied, lpBuf);
				
		return (SUCCEEDED(hResult) ? lCopied : 0);
	}

	if (g_IMM32Proc.ImmGetCompositionStringW == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmGetCompositionStringW, DLL_IMM32, "ImmGetCompositionStringW" );
	return ((IGCSW_CAST)g_IMM32Proc.ImmGetCompositionStringW)(hIMC, dwIndex, lpBuf, dwBufLen);
}

typedef HIMC (WINAPI*IGC_CAST)(HWND);
HIMC CW32System::ImmGetContext ( HWND hWnd )
{
	if (IsAIMMLoaded())
	{
		HRESULT hResult;
		HIMC	hIMC = 0;
	
		hResult = pAIMM->GetContext(hWnd, &hIMC);
				
		return (SUCCEEDED(hResult) ? hIMC : 0);
	}

	if (g_IMM32Proc.ImmGetContext == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmGetContext, DLL_IMM32, "ImmGetContext" );
	return ((IGC_CAST)g_IMM32Proc.ImmGetContext)(hWnd);
}

typedef BOOL (WINAPI*ISCFA_CAST)(HIMC, LPLOGFONTA);
BOOL CW32System::ImmSetCompositionFontA ( 
	HIMC hIMC, 
	LPLOGFONTA lpLogFontA,
	BOOL bAimmActivated)
{
	if (bAimmActivated)
	{
		HRESULT hResult;
	
		hResult = pAIMM->SetCompositionFontA(hIMC, lpLogFontA);
				
		return (SUCCEEDED(hResult));
	}

	if (g_IMM32Proc.ImmSetCompositionFontA == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmSetCompositionFontA, DLL_IMM32, "ImmSetCompositionFontA" );
	return ((ISCFA_CAST)g_IMM32Proc.ImmSetCompositionFontA)(hIMC, lpLogFontA);
}

typedef BOOL (WINAPI*ISCW_CAST)(HIMC, LPCOMPOSITIONFORM);
BOOL CW32System::ImmSetCompositionWindow ( 
	HIMC hIMC, 
	LPCOMPOSITIONFORM lpCompForm,
	BOOL bAimmActivated)
{
	if (bAimmActivated)
	{
		HRESULT hResult;
	
		hResult = pAIMM->SetCompositionWindow(hIMC, lpCompForm);
				
		return (SUCCEEDED(hResult));
	}

	if (g_IMM32Proc.ImmSetCompositionWindow == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmSetCompositionWindow, DLL_IMM32, "ImmSetCompositionWindow" );
	return ((ISCW_CAST)g_IMM32Proc.ImmSetCompositionWindow)(hIMC, lpCompForm);
}

typedef BOOL (WINAPI*IRC_CAST)(HWND, HIMC);
BOOL CW32System::ImmReleaseContext ( 
	HWND hWnd, 
	HIMC hIMC)
{
	if (IsAIMMLoaded())
	{
		HRESULT hResult;
	
		hResult = pAIMM->ReleaseContext(hWnd, hIMC);
				
		return (SUCCEEDED(hResult));
	}

	if (g_IMM32Proc.ImmReleaseContext == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmReleaseContext, DLL_IMM32, "ImmReleaseContext" );
	return ((IRC_CAST)g_IMM32Proc.ImmReleaseContext)(hWnd, hIMC);
}

typedef DWORD (WINAPI*IGP_CAST)(HKL, DWORD);
DWORD CW32System::ImmGetProperty ( 
	HKL hKL, 
	DWORD dwIndex,
	BOOL bAimmActivated)
{
	if (bAimmActivated)
	{
		HRESULT hResult;
		DWORD	dwProperties=0;
	
		hResult = pAIMM->GetProperty(hKL, dwIndex, &dwProperties);
				
		return (SUCCEEDED(hResult) ? dwProperties : 0);
	}

	if (g_IMM32Proc.ImmGetProperty == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmGetProperty, DLL_IMM32, "ImmGetProperty" );
	return ((IGP_CAST)g_IMM32Proc.ImmGetProperty)(hKL, dwIndex);
}

typedef BOOL (WINAPI*IGCW_CAST)(HIMC, DWORD, LPCANDIDATEFORM);
BOOL CW32System::ImmGetCandidateWindow ( 
	HIMC hIMC, 
	DWORD dwIndex, 
	LPCANDIDATEFORM lpCandidate,
	BOOL bAimmActivated)
{
	if (bAimmActivated)
	{
		HRESULT hResult;
	
		hResult = pAIMM->GetCandidateWindow(hIMC, dwIndex, lpCandidate);
				
		return (SUCCEEDED(hResult));
	}

	if (g_IMM32Proc.ImmGetCandidateWindow == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmGetCandidateWindow, DLL_IMM32, "ImmGetCandidateWindow" );
	return ((IGCW_CAST)g_IMM32Proc.ImmGetCandidateWindow)(hIMC, dwIndex, lpCandidate);
}

typedef BOOL (WINAPI*ISCAW_CAST)(HIMC, LPCANDIDATEFORM);
BOOL CW32System::ImmSetCandidateWindow ( 
	HIMC hIMC, 
	LPCANDIDATEFORM lpCandidate ,
	BOOL bAimmActivated)
{
	if (bAimmActivated)
	{
		HRESULT hResult;
	
		hResult = pAIMM->SetCandidateWindow(hIMC, lpCandidate);
				
		return (SUCCEEDED(hResult));
	}

	if (g_IMM32Proc.ImmSetCandidateWindow == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmSetCandidateWindow, DLL_IMM32, "ImmSetCandidateWindow" );
	return ((ISCAW_CAST)g_IMM32Proc.ImmSetCandidateWindow)(hIMC, lpCandidate);
}

typedef BOOL (WINAPI*INIME_CAST)(HIMC, DWORD, DWORD, DWORD);
BOOL CW32System::ImmNotifyIME ( 
	HIMC hIMC, 
	DWORD dwAction, 
	DWORD dwIndex, 
	DWORD dwValue,
	BOOL bAimmActivated)
{
	if (bAimmActivated)
	{
		HRESULT hResult;
	
		hResult = pAIMM->NotifyIME(hIMC, dwAction, dwIndex, dwValue);
				
		return (SUCCEEDED(hResult));
	}

	if (g_IMM32Proc.ImmNotifyIME == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmNotifyIME, DLL_IMM32, "ImmNotifyIME" );
	return ((INIME_CAST)g_IMM32Proc.ImmNotifyIME)(hIMC, dwAction, dwIndex, dwValue);
}

typedef HIMC (WINAPI*IAC_CAST)(HWND, HIMC);
HIMC CW32System::ImmAssociateContext ( 
	HWND hWnd, 
	HIMC hIMC,
	BOOL bAimmActivated)
{
	if (bAimmActivated)
	{
		HRESULT hResult;
		HIMC	hPreviousIMC=0;

		hResult = pAIMM->AssociateContext(hWnd, hIMC, &hPreviousIMC);
				
		return (SUCCEEDED(hResult) ? hPreviousIMC : 0);
	}

	if (g_IMM32Proc.ImmAssociateContext == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmAssociateContext, DLL_IMM32, "ImmAssociateContext" );
	return ((IAC_CAST)g_IMM32Proc.ImmAssociateContext)(hWnd, hIMC);
}

typedef UINT (WINAPI*IGVK_CAST)(HWND);
UINT CW32System::ImmGetVirtualKey ( 
	HWND hWnd,
	BOOL bAimmActivated)
{
	if (bAimmActivated)
	{
		HRESULT hResult;
		UINT	uVirtualKey=0;

		hResult = pAIMM->GetVirtualKey(hWnd, &uVirtualKey);
				
		return (SUCCEEDED(hResult) ? uVirtualKey : 0);
	}

	if (g_IMM32Proc.ImmGetVirtualKey == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmGetVirtualKey, DLL_IMM32, "ImmGetVirtualKey" );
	return ((IGVK_CAST)g_IMM32Proc.ImmGetVirtualKey)(hWnd);
}

// NOTE: We only use ImmEscape for IME_ESC_HANJA_MODE.
// Need to fix up if other methods are used.
typedef HIMC (WINAPI*IES_CAST)(HKL, HIMC, UINT, LPVOID );
HIMC CW32System::ImmEscape ( 
	HKL hKL, 
	HIMC hIMC, 
	UINT uEscape, 
	LPVOID lpData,
	BOOL bAimmActivated)
{
	char		szaHangeul[3] = {0, 0, 0};

	// Aimm only support A version..
	if (!OnWin9x() && !bAimmActivated)
		goto USE_W_VERSION;

	if (MbcsFromUnicode(szaHangeul, sizeof(szaHangeul),
		(LPCWSTR)lpData, 1, CP_KOREAN, UN_NOOBJECTS) <= 0)
		return FALSE;

	if (bAimmActivated)
	{
		HRESULT hResult;
		LRESULT lResult=0;

		hResult = pAIMM->EscapeA(hKL, hIMC, uEscape, (LPVOID)szaHangeul, &lResult);
				
		return (SUCCEEDED(hResult) ? (HIMC)lResult : 0);
	}

	if (g_IMM32Proc.ImmEscapeA == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmEscapeA, DLL_IMM32, "ImmEscapeA" );
	return ((IES_CAST)g_IMM32Proc.ImmEscapeA)(hKL, hIMC, uEscape, (LPVOID)szaHangeul);

USE_W_VERSION:
	if (g_IMM32Proc.ImmEscapeW == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmEscapeW, DLL_IMM32, "ImmEscapeW" );
	return ((IES_CAST)g_IMM32Proc.ImmEscapeW)(hKL, hIMC, uEscape, lpData);
}

typedef BOOL (WINAPI*IGOS_CAST)(HIMC);
BOOL CW32System::ImmGetOpenStatus ( 
	HIMC hIMC,
	BOOL bAimmActivated)
{
	if (bAimmActivated)
	{
		HRESULT hResult;
		
		// AIMM is returning S_OK for OpenStatus == TRUE.
		hResult = pAIMM->GetOpenStatus(hIMC);
				
		return (hResult == S_OK);
	}

	if (g_IMM32Proc.ImmGetOpenStatus == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmGetOpenStatus, DLL_IMM32, "ImmGetOpenStatus" );
	return ((IGOS_CAST)g_IMM32Proc.ImmGetOpenStatus)(hIMC);
}

typedef BOOL (WINAPI*ISOS_CAST)(HIMC, BOOL);
BOOL CW32System::ImmSetOpenStatus ( 
	HIMC hIMC, 
	BOOL fOpen,
	BOOL bAimmActivated)
{
	if (bAimmActivated)
	{
		HRESULT hResult;

		hResult = pAIMM->SetOpenStatus(hIMC, fOpen);
				
		return (SUCCEEDED(hResult));
	}

	if (g_IMM32Proc.ImmSetOpenStatus == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmSetOpenStatus, DLL_IMM32, "ImmSetOpenStatus" );
	return ((ISOS_CAST)g_IMM32Proc.ImmSetOpenStatus)(hIMC, fOpen);
}

typedef BOOL (WINAPI*IGCS_CAST)(HIMC , LPDWORD , LPDWORD );
BOOL CW32System::ImmGetConversionStatus ( 
	HIMC hIMC, 
	LPDWORD pdwConversion, 
	LPDWORD pdwSentence,
	BOOL bAimmActivated)
{
	if (bAimmActivated)
	{
		HRESULT hResult;

		hResult = pAIMM->GetConversionStatus(hIMC, pdwConversion, pdwSentence);
				
		return (SUCCEEDED(hResult));
	}

	if (g_IMM32Proc.ImmGetConversionStatus == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmGetConversionStatus, DLL_IMM32, "ImmGetConversionStatus" );
	return ((IGCS_CAST)g_IMM32Proc.ImmGetConversionStatus)(hIMC, pdwConversion, pdwSentence);
}

typedef BOOL (WINAPI*ISCS_CAST)(HIMC , DWORD , DWORD );
BOOL CW32System::ImmSetConversionStatus ( 
	HIMC hIMC, 
	DWORD dwConversion, 
	DWORD dwSentence,
	BOOL bAimmActivated)
{
	if (bAimmActivated)
	{
		HRESULT hResult;

		hResult = pAIMM->SetConversionStatus(hIMC, dwConversion, dwSentence);
				
		return (SUCCEEDED(hResult));
	}

	if (g_IMM32Proc.ImmSetConversionStatus == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmSetConversionStatus, DLL_IMM32, "ImmSetConversionStatus" );
	return ((ISCS_CAST)g_IMM32Proc.ImmSetConversionStatus)(hIMC, dwConversion, dwSentence);
}

typedef HWND (WINAPI*IGDW_CAST)( HWND );
HWND CW32System::ImmGetDefaultIMEWnd (  
	HWND hWnd,
	BOOL bAimmActivated)
{
	if (bAimmActivated)
	{
		HRESULT hResult;
		HWND	hIMEWnd;

		hResult = pAIMM->GetDefaultIMEWnd(hWnd, &hIMEWnd);
				
		return SUCCEEDED(hResult) ? hIMEWnd : NULL;
	}

	if (g_IMM32Proc.ImmGetDefaultIMEWnd == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmGetDefaultIMEWnd, DLL_IMM32, "ImmGetDefaultIMEWnd" );
	return ((IGDW_CAST)g_IMM32Proc.ImmGetDefaultIMEWnd)(hWnd);
}

typedef BOOL (WINAPI*ISCSW_CAST)(HIMC, DWORD, LPVOID, DWORD, LPVOID, DWORD);
BOOL CW32System::ImmSetCompositionStringW ( 
	HIMC hIMC, 
	DWORD dwIndex, 
	LPVOID lpBuf, 
	DWORD dwBufLen,
	LPVOID lpRead,
	DWORD dwReadLen)
{
	if (g_IMM32Proc.ImmSetCompositionStringW == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmSetCompositionStringW, DLL_IMM32, "ImmSetCompositionStringW" );
	return ((ISCSW_CAST)g_IMM32Proc.ImmSetCompositionStringW)(hIMC, dwIndex, lpBuf, dwBufLen, lpRead, dwReadLen);
}

typedef IMESHAREAPI BOOL (*FSS_CAST)(UINT, UINT);
BOOL CW32System::FSupportSty ( UINT uSty, UINT uStyAltered)
{
	if (g_IMEShareProc.FSupportSty == NULL)
		SetIMEProcAddr( g_IMEShareProc.FSupportSty, DLL_IMESHARE, "FSupportSty" );
	return ((FSS_CAST)g_IMEShareProc.FSupportSty)(uSty, uStyAltered);
}

typedef IMESHAREAPI const IMESTYLE * (IMECDECL*PISFA_CAST)(const UINT);
const IMESTYLE * CW32System::PIMEStyleFromAttr ( const UINT uAttr)
{
	if (g_IMEShareProc.PIMEStyleFromAttr == NULL)
		SetIMEProcAddr( g_IMEShareProc.PIMEStyleFromAttr, DLL_IMESHARE, "PIMEStyleFromAttr" );
	return ((PISFA_CAST)g_IMEShareProc.PIMEStyleFromAttr)( uAttr );
}

typedef IMESHAREAPI const IMECOLORSTY * (IMECDECL*PCSTFIS_CAST)(const IMESTYLE *);
const IMECOLORSTY * CW32System::PColorStyleTextFromIMEStyle ( const IMESTYLE * pIMEStyle)
{
	if (g_IMEShareProc.PColorStyleTextFromIMEStyle == NULL)
		SetIMEProcAddr( g_IMEShareProc.PColorStyleTextFromIMEStyle, DLL_IMESHARE, "PColorStyleTextFromIMEStyle" );
	return ((PCSTFIS_CAST)g_IMEShareProc.PColorStyleTextFromIMEStyle)( pIMEStyle );
}

typedef IMESHAREAPI const IMECOLORSTY * (IMECDECL*PCSBFIS_CAST)(const IMESTYLE *);
const IMECOLORSTY * CW32System::PColorStyleBackFromIMEStyle ( const IMESTYLE * pIMEStyle)
{
	if (g_IMEShareProc.PColorStyleBackFromIMEStyle == NULL)
		SetIMEProcAddr( g_IMEShareProc.PColorStyleBackFromIMEStyle, DLL_IMESHARE, "PColorStyleBackFromIMEStyle" );
	return ((PCSBFIS_CAST)g_IMEShareProc.PColorStyleBackFromIMEStyle)( pIMEStyle );
}

typedef IMESHAREAPI BOOL (IMECDECL*FBIS_CAST)(const IMESTYLE *);
BOOL CW32System::FBoldIMEStyle ( const IMESTYLE * pIMEStyle)
{
	if (g_IMEShareProc.FBoldIMEStyle == NULL)
		SetIMEProcAddr( g_IMEShareProc.FBoldIMEStyle, DLL_IMESHARE, "FBoldIMEStyle" );
	return ((FBIS_CAST)g_IMEShareProc.FBoldIMEStyle)( pIMEStyle );
}

typedef IMESHAREAPI BOOL (IMECDECL*FIIS_CAST)(const IMESTYLE * );
BOOL CW32System::FItalicIMEStyle ( const IMESTYLE * pIMEStyle)
{
	if (g_IMEShareProc.FItalicIMEStyle == NULL)
		SetIMEProcAddr( g_IMEShareProc.FItalicIMEStyle, DLL_IMESHARE, "FItalicIMEStyle" );
	return ((FIIS_CAST)g_IMEShareProc.FItalicIMEStyle)( pIMEStyle );
}

typedef IMESHAREAPI BOOL (IMECDECL*FUIS_CAST)(const IMESTYLE *);
BOOL CW32System::FUlIMEStyle ( const IMESTYLE * pIMEStyle)
{
	if (g_IMEShareProc.FUlIMEStyle == NULL)
		SetIMEProcAddr( g_IMEShareProc.FUlIMEStyle, DLL_IMESHARE, "FUlIMEStyle" );
	return ((FUIS_CAST)g_IMEShareProc.FUlIMEStyle)( pIMEStyle );
}

typedef IMESHAREAPI UINT (IMECDECL*IUIS_CAST)(const IMESTYLE *);
UINT CW32System::IdUlIMEStyle ( const IMESTYLE * pIMEStyle)
{
	if (g_IMEShareProc.IdUlIMEStyle == NULL)
		SetIMEProcAddr( g_IMEShareProc.IdUlIMEStyle, DLL_IMESHARE, "IdUlIMEStyle" );
	return ((IUIS_CAST)g_IMEShareProc.IdUlIMEStyle)( pIMEStyle );;
}

typedef IMESHAREAPI COLORREF (IMECDECL*RFICS_CAST)(const IMECOLORSTY *);
COLORREF CW32System::RGBFromIMEColorStyle ( const IMECOLORSTY * pColorStyle )
{
	if (g_IMEShareProc.RGBFromIMEColorStyle == NULL)
		SetIMEProcAddr( g_IMEShareProc.RGBFromIMEColorStyle, DLL_IMESHARE, "RGBFromIMEColorStyle" );
	return ((RFICS_CAST)g_IMEShareProc.RGBFromIMEColorStyle)( pColorStyle );
}

CONVERTMODE WINAPI CW32System::DetermineConvertMode( HDC hdc, BYTE tmCharSet )
{
	CONVERTMODE cm = CVT_NONE;

	// Some fonts have problems under Win95 with the GetCharWidthW call; this
	// is a simple heuristic to determine if this problem exists.
	if (OnWin9x())
	{
		INT		widthA, widthW;
		BOOL	fResA, fResW;

		// FE font on Non-FE Win95 cannot use
		// GetCharWidthW and ExtTextOutW
		if(IsFECharSet(tmCharSet) && OnWin95FE())
			// always use ANSI call for DBC fonts.
			cm = CVT_WCTMB;
		else
		{
			fResA = GetCharWidthA( hdc, ' ', ' ', &widthA );
			fResW = GetCharWidthW( hdc, L' ', L' ', &widthW );
			if ( fResA && fResW && widthA != widthW )
				cm = CVT_WCTMB;
			else
			{
				fResA = GetCharWidthA( hdc, 'a', 'a', &widthA );
				fResW = GetCharWidthW( hdc, L'a', L'a', &widthW );
				if ( fResA && fResW && widthA != widthW )
					cm = CVT_WCTMB;
			}
		}
	}
	return cm;
}

void WINAPI CW32System::CalcUnderlineInfo(HDC hdc, CCcs *pcccs, TEXTMETRIC *ptm )
{
	OUTLINETEXTMETRICA *potm;
	unsigned cb;
	CTempBuf tb;

	if (ptm->tmPitchAndFamily & TMPF_TRUETYPE)
	{
		cb = GetOutlineTextMetricsA(hdc, 0, NULL);

		if ((cb != 0) 
			&& ((potm = (OUTLINETEXTMETRICA *) tb.GetBuf(cb)) != NULL)
			&& GetOutlineTextMetricsA(hdc, cb, potm))
		{
			pcccs->_dyULOffset = -potm->otmsUnderscorePosition;
			pcccs->_dyULWidth = (short) max(1, potm->otmsUnderscoreSize);
			pcccs->_dySOOffset = -potm->otmsStrikeoutPosition;
			pcccs->_dySOWidth = (short) max(1, (int)potm->otmsStrikeoutSize);
			return;
		}
	}

	// Default calculation of size of underline
	SHORT dyDescent = pcccs->_yDescent;

	if (0 == dyDescent)
	{
		dyDescent = pcccs->_yHeight >> 3;
	}

	pcccs->_dyULWidth = (short) max(1, dyDescent / 4);
	pcccs->_dyULOffset = (dyDescent - 3 * pcccs->_dyULWidth + 1) / 2;

	if ((0 == pcccs->_dyULOffset) && (dyDescent > 1))
	{
		pcccs->_dyULOffset = 1;
	}

	pcccs->_dySOOffset = -ptm->tmAscent / 3;
	pcccs->_dySOWidth = pcccs->_dyULWidth;

	return;
}

BOOL WINAPI CW32System::ShowScrollBar( HWND hWnd, int wBar, BOOL bShow, LONG )
{
	return ::ShowScrollBar( hWnd, wBar, bShow );
}

BOOL WINAPI CW32System::EnableScrollBar( HWND hWnd, UINT wSBflags, UINT wArrows )
{
	return ::EnableScrollBar( hWnd, wSBflags, wArrows );
}

/*
 * 	ReExtTextOutW(uiCodePage, hdc, x, y, fuOptions, lprc, lpString, cch ,lpDx, uiCodePage)
 *
 *	@mfunc
 *		Patch around the Win95 FE bug and MetaFile problem.		
 *
 *	@rdesc
 *		Returns whatever ExtTextOut returns
 */
BOOL ReExtTextOutW(
    HDC hdc,					//@parm handle to device context 
    int xp,						//@parm x-coordinate of reference point 
    int yp,						//@parm y-coordinate of reference point 
    UINT fuOptions,				//@parm text-output options 
    CONST RECT *lprect,			//@parm optional clipping and/or opaquing rectangle 
    const WCHAR *lpwchString,	//@parm points to string 
    UINT cchCount,				//@parm number of characters in string 
    CONST INT *lpDx,			//@parm Ptr to array of intercharacter spacing values
	UINT uiCodePage)			//@parm CodePage for converting to Ansi
{
	// This is a portion of Word code adapted for our needs. 
	// This is a work around for Win95FE bugs that cause GPFs in GDI if multiple
	// characters above Unicode 0x7F are passed to ExtTextOutW.

	// Also, when uiCodePage is non-zero, we want to output all characters using
	// ExtTextOutA - each character at a time.

	Assert(lpDx);
	int		cch;
	const WCHAR *lpwchT = lpwchString;
	const WCHAR *lpwchStart = lpwchT;
	const WCHAR *lpwchEnd = lpwchString + cchCount;

	CONST int *lpdxpCur;
	BOOL	fRet = 0;

	while (lpwchT < lpwchEnd)
	{
		// characters less than 0x007F do not need special treatment
		// we output then in contiguous runs
		if (*lpwchT > 0x007F || uiCodePage)
		{
			if ((cch = lpwchT - lpwchStart) > 0)
			{
				lpdxpCur = lpDx + (lpwchStart - lpwchString);

				// Output the run of chars less than 0x7F
				fRet = ExtTextOutW(hdc, xp, yp, fuOptions, lprect, lpwchStart, cch, lpdxpCur);
				if (!fRet)
					return fRet;

				fuOptions &= ~ETO_OPAQUE; // Don't erase mutliple times!!!

				// Advance
				while (cch--)
					xp += *lpdxpCur++;
					
				lpwchStart = lpwchT;
			}

			// Output chars above 0x7F one at a time to prevent Win95 FE GPF
			lpdxpCur = lpDx + (lpwchStart - lpwchString);
			if (uiCodePage)
			{

				// Need to convert to Ansi and use ExtTextOutA
				char	chAnsi[2];
				
				int	cbConv = WideCharToMultiByte(uiCodePage, 0, lpwchStart, 1, 
					chAnsi, 2, NULL, NULL);
				
				if (cbConv <= 0)
				{
					chAnsi[0] = '?';
					cbConv = 1;
				}

				fRet = ExtTextOutA(hdc, xp, yp, fuOptions, lprect, chAnsi, cbConv, lpdxpCur);
			}
			else
				fRet = ExtTextOutW(hdc, xp, yp, fuOptions, lprect, lpwchStart, 1, lpdxpCur);

			if (!fRet)
				return fRet;

			fuOptions &= ~ETO_OPAQUE; // Don't erase multiple times!!!

			// Advance
			if (lpdxpCur)
				xp += *lpdxpCur;

			lpwchStart++;
		}

		lpwchT++;
	}

	// output the final run; also, if we were called with cchCount == 0,
	// make a call here to erase the rectangle
	if ((cch = lpwchT - lpwchStart) > 0 || !cchCount)
		fRet = ExtTextOutW(hdc, xp, yp, fuOptions, lprect, lpwchStart, cch, lpDx + (lpwchStart - lpwchString));
	
	return fRet;	
}

void WINAPI CW32System::REExtTextOut(
	CONVERTMODE cm,
	UINT uiCodePage,
	HDC hdc,
	int x,
	int y,
	UINT fuOptions,
	CONST RECT *lprc,
	const WCHAR *lpString,
	UINT cch,
	CONST INT *lpDx,
	BOOL  FEFontOnNonFEWin9x
)
{
	bool	fConvert = false;
	BOOL	fForceGdiFont = FALSE;
	HFONT	hfont = NULL, hfontCur = NULL;

	// In order to get the EURO character to print, we need to force the
	// printer to use the glyphs inside GDI
	if(lpString[0] == EURO && 
	   (GetDeviceCaps(hdc, TECHNOLOGY) != DT_RASDISPLAY || W32->IsEnhancedMetafileDC(hdc)))
	{
		fForceGdiFont = TRUE;
		hfontCur = SelectFont(hdc, GetStockObject(ANSI_VAR_FONT));
		LOGFONT lf;
		GetObject(hfontCur, sizeof(LOGFONT), &lf);
		lf.lfOutPrecision = OnWin9x() ? OUT_TT_ONLY_PRECIS : OUT_SCREEN_OUTLINE_PRECIS;
		hfont = CreateFontIndirect(&lf);
		SelectObject(hdc, hfont);
	}

	if(OnWin9x())
	{
		// To get around some Win95 printer device problems with ExtTextOutW,
		// use ExtTextOutA if string is ASCII or if it's 1252 and any
		// nonASCII chars are between 0xA0 and 0xFF.
		for(UINT i = 0;
			i < cch &&
			(lpString[i] <= 0x7F ||
			 IN_RANGE(0xA0, lpString[i], 0xFF) && uiCodePage == 1252);
			i++)
				;
		if(i == cch) 				// All ASCII or ANSI: setup to truncate
		{							//  to low byte and use ExtTextOutA
			cm = CVT_LOWBYTE;
			fConvert = true;
		}
	}

	if (fConvert || !FEFontOnNonFEWin9x && cm != CVT_NONE)		
	{
		if (cm == CVT_WCTMB)
		{
			if (IsFECodePage(uiCodePage))
			{
				if (OnWinNTNonFE() || (OnWin9x() && !OnWin95()))
				{
					// On NonFE NT4 and Win98, we need to textout each char using
					// ExtTextOutA
					ReExtTextOutW(hdc, x, y, fuOptions, lprc, lpString, cch, lpDx, uiCodePage);
					goto LExit;
				}
			}			
		}

		// Need to convert and use ExtTextOutA
		CTempCharBuf tcb;
		CTempBuf	 tDx;
		
		// Double the buffer size 
		int cbString = (cm == CVT_LOWBYTE) ? cch : cch * 2;
			
		// String buffer for converted string - allocate on the stack 
		char *psz = tcb.GetBuf(cbString);
		INT	 *pTempDx = NULL;
		
		if (NULL == psz)
		{
			// Could not allocate buffer
			goto LExit;
		}
			
		int cbConv = 0;
			
		if(cm == CVT_WCTMB)
		{
			cbConv = WideCharToMultiByte(uiCodePage, 0, lpString, cch, 
				psz, cbString, NULL, NULL);
				
			if(!cbConv)
			{
				// The conversion failed for one reason or another.  We should
				// make every effort to use WCTMB before we fall back to
				// taking the low-byte of every wchar (below), otherwise we
				// risk dropping the high-bytes and displaying garbage.
					
				// Use the cpg from the font, since the uiCodePage passed is
				//	the requested codepage and the font-mapper may very well
				//	have mapped to a different one.
				TEXTMETRIC tm;
					
				uiCodePage = (GetTextMetrics(hdc, &tm) && 
					tm.tmCharSet != DEFAULT_CHARSET &&
					(UINT)GetCodePage(tm.tmCharSet) != uiCodePage) ?
					GetCodePage(tm.tmCharSet) : 1252;
					
				cbConv = WideCharToMultiByte(uiCodePage, 0, lpString, cch, 
					psz, cbString, NULL, NULL);
			}

			if (cbConv > 0 && lpDx)
			{
				pTempDx = (INT *)tDx.GetBuf(cbConv * sizeof(INT));
				
				if (pTempDx)
				{
					// Repack lpDx to handle DBC
					INT		*pDx = pTempDx;
					CONST INT*pInputDx = lpDx;
					char	*pTempChar = psz;
					INT		cNumBytes = cbConv;

					while (cNumBytes > 0)
					{
						cNumBytes--;

						if (GetTrailBytesCount(*pTempChar++, uiCodePage))
						{
							*pDx++ = *pInputDx++;						
							*pDx++ = 0;
							cNumBytes--;
							pTempChar++;
						}
						else
							*pDx++ = *pInputDx++;
					}
				}
			}
		}
		else
		{
			Assert(cm == CVT_LOWBYTE);
			// drop through and convert using only low-bytes of WCHAR's
		}
			
			// WCTMB failed OR cm == CVT_LOWBYTE
		if(!cbConv)							// Convert WCHARs to CHARs
		{									
			// FUTURE:  We come here for both SYMBOL_CHARSET fonts and for
			// DBCS bytes stuffed into wchar's (one byte per wchar) when
			// the requested code page is not installed on the machine and
			// the MBTWC fails. Instead, we could have another conversion
			// mode that collects each DBCS char as a single wchar and then
			// remaps to a DBCS string for ExtTextOutA. This would allow us
			// to display text if the system has the right font even tho it
			// doesn't have the right cpg.
				
			// If we are converting this WCHAR buffer in this manner
			// (by taking only the low-byte's of the WCHAR's), it is 
			// because:
			// 	1) cm == CVT_LOWBYTE
			//	2) WCTMB above failed for some reason or another.  It may
			// 		be the case that the string is entirely ASCII in which
			//		case dropping the high-bytes is not a big deal (otherwise
			//		we assert).
		
			cbConv = cch;
				
			while(cch--)
			{
#ifdef DEBUG
				if (uiCodePage != CP_SYMBOL && lpString[cch] > 0xFF)
					Tracef(TRCSEVWARN, "Non-zero high-byte WCHAR: %x", lpString[cch]);
#endif
				psz[cch] = lpString[cch];
			}
		}		
		::ExtTextOutA(hdc, x, y, fuOptions, lprc, psz, cbConv, pTempDx ? pTempDx : lpDx);
		goto LExit;
	}

	if (OnWin9xFE() || FEFontOnNonFEWin9x)
		ReExtTextOutW(hdc, x, y, fuOptions, lprc, lpString, cch, lpDx, 0);
	else
		::ExtTextOutW(hdc, x, y, fuOptions, lprc, lpString, cch, lpDx);	

LExit:
	if (fForceGdiFont)
	{
		SelectObject(hdc, hfontCur);
		SideAssert(DeleteObject(hfont));
	}
}

void WINAPI CW32System::REGetCharWidth(
	HDC		hdc,
	WCHAR	ch,
	SHORT *	pWidth,
	UINT	cpg,	
	SHORT	xOverhang,
	INT		iDefWidth)
{
	BOOL	fForceGdiFont = FALSE;
	HFONT	hfont = NULL, hfontCur = NULL;
	int		iwidth;

	*pWidth = 0;
	if ((cpg == CP_SYMBOL || ch <= 127) && ::GetCharWidthA(hdc, ch, ch, &iwidth))
	{
		*pWidth = (SHORT)iwidth;
		goto Done;
	}

	if(ch == EURO && (GetDeviceCaps(hdc, TECHNOLOGY) != DT_RASDISPLAY || W32->IsEnhancedMetafileDC(hdc)))
	{
		fForceGdiFont = TRUE;
		hfontCur = SelectFont(hdc, GetStockObject(ANSI_VAR_FONT));
		LOGFONT lf;
		GetObject(hfontCur, sizeof(LOGFONT), &lf);
		lf.lfOutPrecision = OnWin9x() ? OUT_TT_ONLY_PRECIS : OUT_SCREEN_OUTLINE_PRECIS;
		hfont = CreateFontIndirect(&lf);
		SelectObject(hdc, hfont);
	}

	// For most workarounds, we will use the workarounds on all the OSs.
	// We only use specific workaround is MBTWC conversion is needed.

	// This is a workaround for Win95 FE bugs
	// FUTURE (keithcu) This logic could be simplified.
	if (OnWin95() && !IN_RANGE(0x80, ch, 0xFF) &&			// Not high ANSI?
		(cpg == CP_CHINESE_TRAD || cpg == CP_CHINESE_SIM))	// Chinese CodePage?
	{
		int numOfDBCS = 0;
		::GetCharWidthW(hdc, 0x4e00, 0x4e00, &iwidth);
		*pWidth = (SHORT)iwidth;
		if (IN_RANGE(0x4e00, ch, 0x9fff))
			goto Done;
			
		// Use WCTMB heuristic
		char	ansiChar[2];
		BOOL	bDefCharUsed = FALSE;
		numOfDBCS = ::WideCharToMultiByte( cpg, 0, &ch, 1, ansiChar, 2, NULL, &bDefCharUsed);

		WORD wDBCS = (BYTE)ansiChar[0];
		
		if (2 == numOfDBCS)
			wDBCS = (BYTE)ansiChar[0] << 8 | (BYTE)ansiChar[1];
		
		if (numOfDBCS > 0 && ::GetCharWidthA( hdc, wDBCS, wDBCS, &iwidth))
		{
			*pWidth = (SHORT)iwidth;
			goto Done;
		}
	}

	//Win '95 GPFs if you pass in 0xFFFF
	if (ch == 0xFFFF)
		ch = 0xFFFE;

	if (::GetCharWidthW(hdc, ch, ch, &iwidth))
		*pWidth = (SHORT)iwidth;

	if(fForceGdiFont)
	{
		SelectObject(hdc, hfontCur);
		SideAssert(DeleteObject(hfont));
	}

Done:
	*pWidth	-= xOverhang;
	if (0 >= *pWidth)
	{
		// Sometimes GetCharWidth will return a zero length for small
		// characters. When this happens we will use the default width
		// for the font if that is non-zero otherwise we just us 1 because
		// this is the smallest valid value.

		// This code can also be triggered if the overhang is bigger than the
		// width returned by the OS call to get the character width.		
		if (0 == iDefWidth)
			*pWidth = 1;
		else
			*pWidth = (SHORT)iDefWidth;
	}
}

BOOL WINAPI CW32System::IsEnhancedMetafileDC( HDC hDC )
{
	BOOL	fEMFDC = FALSE;
	DWORD	dwObjectType;
	
	dwObjectType = ::GetObjectType( hDC );

	if ( OBJ_ENHMETADC == dwObjectType || OBJ_ENHMETAFILE == dwObjectType )
		fEMFDC = TRUE;
	else if ( OnWin95() && OBJ_DC == dwObjectType )
	{
		// HACK Alert,  Enhanced Metafile DC does not support any Escape function
		// and shoudl return 0.
		int	iEscapeFuction = QUERYESCSUPPORT;

		if ( Escape( hDC, QUERYESCSUPPORT, sizeof(int), (LPCSTR)&iEscapeFuction, NULL) == 0 )
			fEMFDC = TRUE;
	}	

	return fEMFDC;
}


HPALETTE WINAPI CW32System::ManagePalette(
	HDC hdc,
	CONST LOGPALETTE *plogpal,
	HPALETTE &hpalOld,
	HPALETTE &hpalNew
)
{
	if (hpalNew == NULL)
	{
		hpalNew = ::CreatePalette(plogpal);
		if (hpalNew != NULL)
		{
			hpalOld = ::SelectPalette(hdc, hpalNew, TRUE);
			::RealizePalette(hdc);
		}
	}
	else
	{
		// A new palette was created previously and we are restoring the old one
		::SelectPalette(hdc, hpalOld, TRUE);
		::RealizePalette(hdc);
		DeleteObject(hpalNew);
		hpalNew = NULL;
	}
	return hpalNew;
}

int WINAPI CW32System::GetMapMode(HDC hdc)
{
	return ::GetMapMode(hdc);
}

BOOL WINAPI CW32System::WinLPtoDP(HDC hdc, LPPOINT lppoints, int nCount)
{
	return ::LPtoDP(hdc, lppoints, nCount);
}

long WINAPI CW32System::WvsprintfA( LONG cbBuf, LPSTR szBuf, LPCSTR szFmt, va_list arglist )
{
	LONG cb;
	cb = ::wvsprintfA( szBuf, szFmt, arglist );
	Assert(cb < cbBuf);
	return cb;
}

int WINAPI CW32System::MulDiv(int nNumber, int nNumerator, int nDenominator)
{
	if ((nNumerator && nNumerator == nDenominator) || (nDenominator && !nNumber))
		return nNumber;
	return ::MulDiv(nNumber, nNumerator, nDenominator);
}

/*
 *	GetFacePriorityCharSet(WCHAR* szFaceName)
 *
 *	@func
 *		return charset *really* supported by given facename
 */
int CALLBACK GetFacePriCharSetProc (
	ENUMLOGFONTEX	*lpelfe,
	NEWTEXTMETRIC	*lpntm,
	int				iFontType,
	LPARAM			lParam)
{
	Assert (lParam);
	*(BYTE*)lParam = lpntm->tmCharSet;
	return 0;
}

void CW32System::GetFacePriCharSet(HDC hdc, LOGFONT* plf)
{
	::EnumFontFamiliesEx(hdc, plf, (FONTENUMPROC)GetFacePriCharSetProc, (LPARAM)&plf->lfCharSet, 0);
}


/*
 *	CW32System::ReadRegDigitSubstitionMode(void)
 *
 *	@mfunc
 *		Get the digit substitution mode (available on BiDi/Thai platforms)
 *
 *	@rdesc
 *		0 - Context (digit shape follows preceding run or CHARFORMAT's charset
 *		1 - None (digits always show as European digit shape)
 *		2 - National (digits always show as user locale's native shape)
 */
BYTE CW32System::ReadRegDigitSubstitutionMode()
{
	HKEY	hk;
	DWORD	keyDataType;
	DWORD	dwDataSize;
	BYTE	rgbValue[2];
	BYTE	bDigitMode;

	bDigitMode = DIGITS_NOTIMPL;			// assume "Not Implemented"

	// Perform platform check before reading registry
	if (!OnWin9xFE() && !OnWinNTFE() && 
		 IsComplexScriptLcid(GetThreadLocale()))
	{
		if(RegOpenKeyExA(HKEY_CURRENT_USER,
						"Control Panel\\International",
						0,		// reserved
						KEY_QUERY_VALUE,
						&hk) == ERROR_SUCCESS)
		{
			dwDataSize = 2;
			if (RegQueryValueExA(hk,
								"NumShape",
								NULL,		// reserved
								&keyDataType,
								(LPBYTE) &rgbValue,
								&dwDataSize) == ERROR_SUCCESS)
			{
				if (rgbValue[0] > 0x2f)
					bDigitMode = rgbValue[0] - 0x30 + 1;
				if (bDigitMode > DIGITS_NATIONAL)
					bDigitMode = DIGITS_NONE;
			}
			RegCloseKey(hk);
		}
	}
	return bDigitMode;
}

#ifdef DEBUG
/*
 *	TestGetCharFlags125x(iFirst, iLast)
 *
 *	@func
 *		Unit test function for GetCharFlags125x(). Assert if GetCharFlags125x()
 *		claims that any char in	Unicode range iFirst thru iLast 1) should
 *		roundtrip multibyte conversion using a codepage in the range 1250-1258
 *		when it	doesn't, or 2) shouldn't roundtrip when it does.
 */
BOOL TestGetCharFlags125x(
	int iFirst, 
	int iLast) 
{
	LONG	cch  = iLast - iFirst + 1;
	LONG	i;
	Assert(cch <= 0x700 - 0xA0);

	char 	rgach[0x700 - 0xA0];
	WCHAR	rgch [0x700 - 0xA0];
	WCHAR *	pch;

	for(i = iFirst, pch = rgch; i <= iLast;  pch++, i++)
		*pch = (WCHAR)i;

	for(int CodePage = 1250; CodePage <= 1258; CodePage++)
	{
		if(cch != WideCharToMultiByte(CodePage, 0, rgch, cch, rgach, cch, "\0", NULL) ||
		   cch != MultiByteToWideChar(CodePage, 0, rgach, cch, rgch, cch))
		{
			continue;				// Missing code page
		}
		//							 1250 1251 1252 1253  1254  1255  1256  1257   1258
		const static WORD rgMask[] = {0x2, 0x4, 0x1, 0x8, 0x10, 0x20, 0x40, 0x80, 0x100};

		DWORD dwMask = rgMask[CodePage - 1250] << 8;

		for(i = iFirst, pch = rgch; i <= iLast; pch++, i++)
		{
			AssertSz(!((*pch != (WCHAR)i) ^ !(W32->GetCharFlags125x(i) & dwMask)),
				"GetCharFlags125x() failure");
			*pch = (WCHAR)i;	// Restore value
		}
	}
	return TRUE;				// Above AssertSz() reports any errors
}
#endif

/*
 *	CW32System::InitSysParams(fUpdate)
 *
 *	@mfunc
 *		This method is used to initialize certain system wide parameters that
 *      that are used in richedit.  This can also be used as an update method
 *      if we ever handle system parameter change notifications.  The update
 *		parameter id provided for this purpose.	Also note that if we ever support
 *		SysParam updating, we may have to protect access with locks.
 */
void CW32System::InitSysParams(BOOL fUpdate)
{
	TRACEBEGIN(TRCSUBSYSUTIL, TRCSCOPEINTERN, "CW32System::InitSysParams");
	CLock lock;


	if (!_fSysParamsOk || fUpdate)
	{
		_fSysParamsOk = TRUE;
		
		const LONG dxSelBarDefaultSize = 8;
		HDC hdc = GetScreenDC();
		HFONT hfontOld;
		TEXTMETRIC tm;

		_xPerInchScreenDC = GetDeviceCaps(hdc, LOGPIXELSX); 
		if (_xPerInchScreenDC == 0)
			_xPerInchScreenDC = 0x60;
		_yPerInchScreenDC = GetDeviceCaps(hdc, LOGPIXELSY);
		if (_yPerInchScreenDC == 0)
			_yPerInchScreenDC = 0x60;
		int cPalette = GetDeviceCaps(hdc, SIZEPALETTE);

		// 256 colors is where we seem to need to use the palette.
		if (256 == cPalette)
		{
			_fUsePalette = TRUE;
		}

		// calculate a himetric selection bar for the window's host.
		_dxSelBar = W32->DXtoHimetricX(dxSelBarDefaultSize, _xPerInchScreenDC);

		RefreshKeyboardLayout();
		_hSystemFont = (HFONT)GetStockObject(SYSTEM_FONT);
		hfontOld = SelectFont(hdc, _hSystemFont);
		if(hfontOld)
		{
			W32->GetTextMetrics(hdc, &tm);
			_xWidthSys = (INT) tm.tmAveCharWidth;
			_yHeightSys = (INT) tm.tmHeight;
			_ySysFontLeading = (INT) tm.tmInternalLeading;
			_bSysCharSet = tm.tmCharSet;

			SelectFont(hdc, hfontOld);
		}

		_nScrollInset = (WORD)GetProfileIntA("windows", "ScrollInset",
			DD_DEFSCROLLINSET);
		_nDragDelay = (WORD)GetProfileIntA("windows", "DragDelay",
			DD_DEFDRAGDELAY);
		_nDragMinDist = (WORD)GetProfileIntA("windows", "DragMinDist",
			DD_DEFDRAGMINDIST);
		_nScrollDelay = (WORD)GetProfileIntA("windows", "ScrollDelay",
			DD_DEFSCROLLDELAY);
		_nScrollInterval = (WORD)GetProfileIntA("windows", "ScrollInterval",
			DD_DEFSCROLLINTERVAL);
	    _nScrollVAmount = (WORD)(GetYPerInchScreenDC()*DEFSCROLLVAMOUNT)/100;
	    _nScrollHAmount = (GetXPerInchScreenDC()*DEFSCROLLHAMOUNT)/100;

		_cxBorder	= GetSystemMetrics(SM_CXBORDER);	// Unsizable window border
		_cyBorder	= GetSystemMetrics(SM_CYBORDER);	//  widths
		_cxVScroll	= GetSystemMetrics(SM_CXVSCROLL);	//  dimensions
		_cyHScroll	= GetSystemMetrics(SM_CYHSCROLL);	//

		_cxDoubleClk	= GetSystemMetrics(SM_CXDOUBLECLK);
		_cyDoubleClk	= GetSystemMetrics(SM_CYDOUBLECLK);
		_DCT			= GetDoubleClickTime();
		_sysiniflags	= ::GetProfileIntA("richedit30", "flags", 0);

#ifdef DEBUG
		if(OnWinNT5() && (_sysiniflags & SYSINI_DEBUGGCF125X))
		{
			TestGetCharFlags125x(0xA0, 0x6FF);
			TestGetCharFlags125x(0x2000, 0x2122);
		}
#endif

		_bDigitSubstMode = ReadRegDigitSubstitutionMode();
		if (g_pusp)
			g_pusp->ApplyDigitSubstitution(_bDigitSubstMode);
	}
}

/*
 *	CW32System::GetSizeCursor(void)
 *
 *	@mfunc
 *		Get the sizing cursor (double arrow) specified by
 *		the resource id.  If the cursors are not loaded
 *		load them and cache them.
 *		parameters:
 *			idcur - cursor resource id.
 *
 *	@rdesc
 *		Handle to cursor or null if failure. Returns NULL if
 *		idcur is null.
 */
HCURSOR CW32System::GetSizeCursor(
	LPTSTR idcur)
{
	if(!idcur )
		return NULL;

	//If any cursor isn't loaded, try loading it.
	if(!_hcurSizeNS)
		_hcurSizeNS = LoadCursor(NULL, IDC_SIZENS);

	if(!_hcurSizeWE)
		_hcurSizeWE = LoadCursor(NULL, IDC_SIZEWE);

	if(!_hcurSizeNWSE)
		_hcurSizeNWSE = LoadCursor(NULL, IDC_SIZENWSE);

	if(!_hcurSizeNESW)
		_hcurSizeNESW = LoadCursor(NULL, IDC_SIZENESW);
	
	//Return cursor corresponding to id passed in.
	if(idcur == IDC_SIZENS && _hcurSizeNS)
		return _hcurSizeNS;

	if(idcur == IDC_SIZEWE && _hcurSizeWE)
		return _hcurSizeWE;

	if(idcur == IDC_SIZENWSE && _hcurSizeNWSE)
		return _hcurSizeNWSE;

	if(idcur == IDC_SIZENESW && _hcurSizeNESW)
		return _hcurSizeNESW;

	AssertSz(FALSE, "Failure loading sizing cursor.");

	return NULL;
}

/*
 *	CW32System:GetRollerLineScrollCount()
 *
 *	@mfunc	returns the number of lines to scroll with a roller mouse wheel.
 *			-1 means scroll by pages
 *
 *	@devnote We have to do different things for different platforms; NT4.0 has
 *			built in support for this functionality.
 */

/* excerpt from new winuser.h for calls to SystemParametersInfo */
#ifndef SPI_GETWHEELSCROLLLINES
#define SPI_GETWHEELSCROLLLINES   104
#endif

LONG CW32System::GetRollerLineScrollCount()
{
	if( _cLineScroll == 0 )
	{
#ifndef _WIN64
		HKEY hdlKey;
		DWORD keyDataType;
		CHAR charData[128];
		DWORD  dwDataBufSize;

		 // Fall back Value
		_cLineScroll = 0;

		// Read registry directly for Windows 95 & WinNT3.51, if WinNT 4.0 
		// and above then use SystemParametersInfo
		if((OnWin95()) || (_dwPlatformId == VER_PLATFORM_WIN32_NT) && (_dwMajorVersion < 4))
		{
			// Read registry directly
			if ( RegOpenKeyExA(HKEY_CURRENT_USER, 
						"Control Panel\\Desktop", 
						0,
						KEY_QUERY_VALUE,
						&hdlKey) == ERROR_SUCCESS )
			{
				dwDataBufSize = sizeof(charData);
				if ( RegQueryValueExA(hdlKey, 
							  "WheelScrollLines",
							  NULL,  // reserved
							  &keyDataType,
							  (LPBYTE) &charData,
							  &dwDataBufSize) == ERROR_SUCCESS )
				{
					_cLineScroll = W32->strtoul( charData );   //String representation
				}
			}			
			else
			{
			    // We didn't find line scroll count in the registery.  Check for a Mouse
			    // Wheel window and query the window how many lines to scroll
			    static UINT idWheelSupport = RegisterWindowMessageA(MSH_WHEELSUPPORT);
			    static UINT idScrollLine = RegisterWindowMessageA(MSH_SCROLL_LINES);
			    HWND hwndMsWheel = FindWindowA(MSH_WHEELMODULE_CLASS, MSH_WHEELMODULE_TITLE);
			    if (hwndMsWheel && SendMessageA(hwndMsWheel, idWheelSupport, 0, 0))
			        _cLineScroll = SendMessageA(hwndMsWheel, idScrollLine, 0, 0);
			}
			RegCloseKey(hdlKey);
		}
		else if ( (_dwPlatformId == VER_PLATFORM_WIN32_NT) &&
             (_dwMajorVersion >= 4) || OnWin9x())
#endif //_WIN64     
		{
			//call this function if on NT4 or Win98 (NOTE: it isn't sufficient to use
			//OnWin9x() to determine if we are on a win98 system but since the 
			//previous if stmt checks to see if we are in a win95 system OnWin9x
			//can be use)
			SystemParametersInfoA(SPI_GETWHEELSCROLLLINES, 0, &_cLineScroll, 0);
		}
	}

	return _cLineScroll;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::CStrIn
//
//  Synopsis:   Inits the class.
//
//  NOTE:       Don't inline these functions or you'll increase code size
//              by pushing -1 on the stack for each call.
//
//----------------------------------------------------------------------------

CStrIn::CStrIn(LPCWSTR pwstr, UINT CodePage)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrIn::CStrIn");

    Init(pwstr, -1, CodePage);
}

CStrIn::CStrIn(LPCWSTR pwstr, int cwch, UINT CodePage)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrIn::CStrIn");

    Init(pwstr, cwch, CodePage);
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::Init
//
//  Synopsis:   Converts a LPWSTR function argument to a LPSTR.
//
//  Arguments:  [pwstr] -- The function argument.  May be NULL or an atom
//                              (HIWORD(pwstr) == 0).
//
//              [cwch]  -- The number of characters in the string to
//                          convert.  If -1, the string is assumed to be
//                          NULL terminated and its length is calculated.
//
//  Modifies:   [this]
//
//----------------------------------------------------------------------------

void
CStrIn::Init(
	LPCWSTR pwstr,
	int		cwch,
	UINT	CodePage)	//@parm Code page to use (CP_ACP is default)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrIn::Init");

    int cchBufReq;

    _cchLen = 0;

    // Check if string is NULL or an atom.
    if (HIWORD((DWORD_PTR)pwstr) == 0)
    {
        _pstr = (LPSTR) pwstr;
        return;
    }

    Assert(cwch == -1 || cwch > 0);

    //
    // Convert string to preallocated buffer, and return if successful.
    //

    _cchLen = W32->MbcsFromUnicode(_ach, ARRAY_SIZE(_ach), pwstr, cwch, CodePage);

    if (_cchLen > 0)
    {
        if(_ach[_cchLen-1] == 0)
            _cchLen--;                // account for terminator
        _pstr = _ach;
        return;
    }

    //
    // Alloc space on heap for buffer.
    //

    TRACEINFOSZ("CStrIn: Allocating buffer for wrapped function argument.");

    cchBufReq = WideCharToMultiByte(
            CP_ACP, 0, pwstr, cwch, NULL, 0,  NULL, NULL);

    Assert(cchBufReq > 0);
    _pstr = new char[cchBufReq];
    if (!_pstr)
    {
        // On failure, the argument will point to the empty string.
        TRACEINFOSZ("CStrIn: No heap space for wrapped function argument.");
        _ach[0] = 0;
        _pstr = _ach;
        return;
    }

    Assert(HIWORD((DWORD_PTR)_pstr));
    _cchLen = -1 + W32->MbcsFromUnicode(_pstr, cchBufReq, pwstr, cwch);

    Assert(_cchLen >= 0);
}



//+---------------------------------------------------------------------------
//
//  Class:      CStrInMulti (CStrIn)
//
//  Purpose:    Converts multiple strings which are terminated by two NULLs,
//              e.g. "Foo\0Bar\0\0"
//
//----------------------------------------------------------------------------

class CStrInMulti : public CStrIn
{
public:
    CStrInMulti(LPCWSTR pwstr, UINT CodePage);
};



//+---------------------------------------------------------------------------
//
//  Member:     CStrInMulti::CStrInMulti
//
//  Synopsis:   Converts mulitple LPWSTRs to a multiple LPSTRs.
//
//  Arguments:  [pwstr] -- The strings to convert.
//
//  Modifies:   [this]
//
//----------------------------------------------------------------------------

CStrInMulti::CStrInMulti(
	LPCWSTR pwstr,
	UINT CodePage)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrInMulti::CStrInMulti");

    LPCWSTR pwstrT;

    // We don't handle atoms because we don't need to.
    Assert(HIWORD((DWORD_PTR)pwstr));

    //
    // Count number of characters to convert.
    //

    pwstrT = pwstr;
    if (pwstr)
    {
        do {
            while (*pwstrT++)
                ;

        } while (*pwstrT++);
    }

    Init(pwstr, pwstrT - pwstr, CodePage);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::CStrOut
//
//  Synopsis:   Allocates enough space for an out buffer.
//
//  Arguments:  [pwstr]   -- The Unicode buffer to convert to when destroyed.
//                              May be NULL.
//
//              [cwchBuf] -- The size of the buffer in characters.
//
//  Modifies:   [this].
//
//----------------------------------------------------------------------------

CStrOut::CStrOut(LPWSTR pwstr, int cwchBuf)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrOut::CStrOut");

    Assert(cwchBuf >= 0);

    _pwstr = pwstr;
    _cwchBuf = cwchBuf;

    if (!pwstr)
    {
        Assert(cwchBuf == 0);
        _pstr = NULL;
        return;
    }

    Assert(HIWORD((DWORD_PTR)pwstr));

    // Initialize buffer in case Windows API returns an error.
    _ach[0] = 0;

    // Use preallocated buffer if big enough.
    if (cwchBuf * 2 <= ARRAY_SIZE(_ach))
    {
        _pstr = _ach;
        return;
    }

    // Allocate buffer.
    TRACEINFOSZ("CStrOut: Allocating buffer for wrapped function argument.");
    _pstr = new char[cwchBuf * 2];
    if (!_pstr)
    {
        //
        // On failure, the argument will point to a zero-sized buffer initialized
        // to the empty string.  This should cause the Windows API to fail.
        //

        TRACEINFOSZ("CStrOut: No heap space for wrapped function argument.");
        Assert(cwchBuf > 0);
        _pwstr[0] = 0;
        _cwchBuf = 0;
        _pstr = _ach;
        return;
    }

    Assert(HIWORD((DWORD_PTR)_pstr));
    _pstr[0] = 0;
}



//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::Convert
//
//  Synopsis:   Converts the buffer from MBCS to Unicode.
//
//----------------------------------------------------------------------------

int
CStrOut::Convert()
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrOut::Convert");

    int cch;

    if (!_pstr)
        return 0;

    cch = MultiByteToWideChar(CP_ACP, 0, _pstr, -1, _pwstr, _cwchBuf);
    Assert(cch > 0 || _cwchBuf == 0);

    Free();

	if (cch > 0 && cch <= _cwchBuf && _pwstr[cch-1] == L'\0')
		cch--;

    return cch;
}



//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::~CStrOut
//
//  Synopsis:   Converts the buffer from MBCS to Unicode.
//
//  Note:       Don't inline this function, or you'll increase code size as
//              both Convert() and CConvertStr::~CConvertStr will be called
//              inline.
//
//----------------------------------------------------------------------------

CStrOut::~CStrOut()
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrOut::~CStrOut");

    Convert();
}


//
//	MultiByte --> UNICODE routins
//

//+---------------------------------------------------------------------------
//
//  Member:     CConvertStr::Free
//
//  Synopsis:   Frees string if alloc'd and initializes to NULL.
//
//----------------------------------------------------------------------------

void
CConvertStr::Free()
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CConvertStr::Free");

    if (_pstr != _ach && HIWORD((DWORD_PTR)_pstr) != 0)
    {
        delete [] _pstr;
    }

    _pstr = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConvertStrW::Free
//
//  Synopsis:   Frees string if alloc'd and initializes to NULL.
//
//----------------------------------------------------------------------------

void
CConvertStrW::Free()
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CConvertStrW::Free");

    if (_pwstr != _awch && HIWORD((DWORD_PTR)_pwstr) != 0 )
    {
        delete [] _pwstr;
    }

    _pwstr = NULL;
}



//+---------------------------------------------------------------------------
//
//  Member:     CStrInW::CStrInW
//
//  Synopsis:   Inits the class.
//
//  NOTE:       Don't inline these functions or you'll increase code size
//              by pushing -1 on the stack for each call.
//
//----------------------------------------------------------------------------

CStrInW::CStrInW(LPCSTR pstr)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrInW::CStrInW");

    Init(pstr, -1, CP_ACP);
}

CStrInW::CStrInW(LPCSTR pstr, UINT uiCodePage)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrInW::CStrInW");

    Init(pstr, -1, uiCodePage);
}

CStrInW::CStrInW(LPCSTR pstr, int cch, UINT uiCodePage)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrInW::CStrInW");

    Init(pstr, cch, uiCodePage);
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrInW::Init
//
//  Synopsis:   Converts a LPSTR function argument to a LPWSTR.
//
//  Arguments:  [pstr] -- The function argument.  May be NULL or an atom
//                              (HIWORD(pwstr) == 0).
//
//              [cch]  -- The number of characters in the string to
//                          convert.  If -1, the string is assumed to be
//                          NULL terminated and its length is calculated.
//
//  Modifies:   [this]
//
//----------------------------------------------------------------------------

void
CStrInW::Init(LPCSTR pstr, int cch, UINT uiCodePage)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrInW::Init");

    int cchBufReq;

    _cwchLen = 0;

    // Check if string is NULL or an atom.
    if (HIWORD((DWORD_PTR)pstr) == 0)
    {
        _pwstr = (LPWSTR) pstr;
        return;
    }

    Assert(cch == -1 || cch > 0);

    //
    // Convert string to preallocated buffer, and return if successful.
    //

    _cwchLen = MultiByteToWideChar(
            uiCodePage, 0, pstr, cch, _awch, ARRAY_SIZE(_awch));

    if (_cwchLen > 0)
    {
        if(_awch[_cwchLen-1] == 0)
            _cwchLen--;                // account for terminator
        _pwstr = _awch;
        return;
    }

    //
    // Alloc space on heap for buffer.
    //

    TRACEINFOSZ("CStrInW: Allocating buffer for wrapped function argument.");

    cchBufReq = MultiByteToWideChar(
            CP_ACP, 0, pstr, cch, NULL, 0);

    Assert(cchBufReq > 0);
    _pwstr = new WCHAR[cchBufReq];
    if (!_pwstr)
    {
        // On failure, the argument will point to the empty string.
        TRACEINFOSZ("CStrInW: No heap space for wrapped function argument.");
        _awch[0] = 0;
        _pwstr = _awch;
        return;
    }

    Assert(HIWORD((DWORD_PTR)_pwstr));
    _cwchLen = -1 + MultiByteToWideChar(
            uiCodePage, 0, pstr, cch, _pwstr, cchBufReq);
    Assert(_cwchLen >= 0);
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrOutW::CStrOutW
//
//  Synopsis:   Allocates enough space for an out buffer.
//
//  Arguments:  [pstr]   -- The ansi buffer to convert to when destroyed.
//                              May be NULL.
//
//              [cchBuf] -- The size of the buffer in characters.
//
//  Modifies:   [this].
//
//----------------------------------------------------------------------------

CStrOutW::CStrOutW(LPSTR pstr, int cchBuf, UINT uiCodePage)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrOutW::CStrOutW");

    Assert(cchBuf >= 0);

    _pstr = pstr;
    _cchBuf = cchBuf;
	_uiCodePage = uiCodePage;

    if (!pstr)
    {
        Assert(cchBuf == 0);
        _pwstr = NULL;
        return;
    }

    Assert(HIWORD((DWORD_PTR)pstr));

    // Initialize buffer in case Windows API returns an error.
    _awch[0] = 0;

    // Use preallocated buffer if big enough.
    if (cchBuf <= ARRAY_SIZE(_awch))
    {
        _pwstr = _awch;
        return;
    }

    // Allocate buffer.
    TRACEINFOSZ("CStrOutW: Allocating buffer for wrapped function argument.");
    _pwstr = new WCHAR[cchBuf * 2];
    if (!_pwstr)
    {
        //
        // On failure, the argument will point to a zero-sized buffer initialized
        // to the empty string.  This should cause the Windows API to fail.
        //

        TRACEINFOSZ("CStrOutW: No heap space for wrapped function argument.");
        Assert(cchBuf > 0);
        _pstr[0] = 0;
        _cchBuf = 0;
        _pwstr = _awch;
        return;
    }

    Assert(HIWORD((DWORD_PTR)_pwstr));
    _pwstr[0] = 0;
}



//+---------------------------------------------------------------------------
//
//  Member:     CStrOutW::Convert
//
//  Synopsis:   Converts the buffer from Unicode to MBCS
//
//----------------------------------------------------------------------------

int
CStrOutW::Convert()
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrOutW::Convert");

    int cch;

    if (!_pwstr)
        return 0;

	int cchBuf = _cchBuf;

	cch = W32->MbcsFromUnicode(_pstr, cchBuf, _pwstr, -1, _uiCodePage);
    
	Free();
	if (cch > 0 && cch <= _cchBuf && _pstr[cch-1] == '\0')
		cch--;

    return cch;
}



//+---------------------------------------------------------------------------
//
//  Member:     CStrOutW::~CStrOutW
//
//  Synopsis:   Converts the buffer from Unicode to MBCS.
//
//  Note:       Don't inline this function, or you'll increase code size as
//              both Convert() and CConvertStr::~CConvertStr will be called
//              inline.
//
//----------------------------------------------------------------------------

CStrOutW::~CStrOutW()
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrOutW::~CStrOutW");

    Convert();
}

BOOL CW32System::GetVersion(
	DWORD *pdwPlatformId,
	DWORD *pdwMajorVersion,
	DWORD *pdwMinorVersion
)
{
	OSVERSIONINFOA osv;
	osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
	*pdwPlatformId = 0;
	*pdwMajorVersion = 0;
	if (::GetVersionExA(&osv))
	{
		*pdwPlatformId = osv.dwPlatformId;
		*pdwMajorVersion = osv.dwMajorVersion;
		*pdwMinorVersion = osv.dwMinorVersion;
		return TRUE;
	}
	return FALSE;
}

BOOL CW32System::GetStringTypes(
	LCID	lcid,
	LPCTSTR lpSrcStr,
	int		cchSrc,
	LPWORD	lpCharType1,
	LPWORD	lpCharType3)
{
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
	{
		if(::GetStringTypeExW(lcid, CT_CTYPE1, lpSrcStr, cchSrc, lpCharType1))
			return ::GetStringTypeExW(lcid, CT_CTYPE3, lpSrcStr, cchSrc, lpCharType3);
		return FALSE;
	}

    CStrIn  str(lpSrcStr, cchSrc, ConvertLanguageIDtoCodePage(lcid));
	LONG	cch = str.strlen();

	if(::GetStringTypeExA(lcid, CT_CTYPE1, str, cch, lpCharType1))
		return ::GetStringTypeExA(lcid, CT_CTYPE3, str, cch, lpCharType3);
	return FALSE;
}

BOOL WINAPI CW32System::GetStringTypeEx(
	LCID	lcid,
	DWORD	dwInfoType,
	LPCTSTR lpSrcStr,
	int		cchSrc,
	LPWORD	lpCharType
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetStringTypeEx");
	
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::GetStringTypeExW(lcid, dwInfoType, lpSrcStr, cchSrc, lpCharType);   

    CStrIn  str(lpSrcStr, cchSrc);
    return GetStringTypeExA(lcid, dwInfoType, str, str.strlen(), lpCharType);   
}

typedef LPSTR (CALLBACK *FnCharChangeCase)(LPSTR);

static LPWSTR CharChangeCase(LPWSTR pwstr, FnCharChangeCase pfn)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CharChangeCaseWrap");

    if (HIWORD((DWORD_PTR)pwstr) == 0)
    {
        LPSTR   pstr=0;
		int		retCode;
		char	DBChar[3];

        retCode = W32->MbcsFromUnicode((LPSTR) &pstr, sizeof(pstr), (LPWSTR) &pwstr, 1);
        Assert(HIWORD((DWORD_PTR)pstr) == 0);
		if (retCode == 2)
		{
			// This is a DBC, use string
			DWORD	iTemp = (DWORD)((DWORD_PTR)pstr);
			DBChar[0] = char(iTemp & 0x0ff);
			DBChar[1] = char(iTemp >> 8);
			DBChar[2] = 0;
			pstr = (*pfn)(DBChar);
			W32->UnicodeFromMbcs((LPWSTR) &pwstr, sizeof(pwstr) / sizeof(WCHAR), (LPSTR)DBChar, 2);
		}
		else
		{
			pstr = (*pfn)(pstr);
			W32->UnicodeFromMbcs((LPWSTR) &pwstr, sizeof(pwstr) / sizeof(WCHAR), (LPSTR) &pstr);
		}
		Assert(HIWORD((DWORD_PTR)pwstr) == 0);
	}
    else
    {
        CStrOut strOut(pwstr, W32->wcslen(pwstr));
        W32->MbcsFromUnicode(strOut, strOut.BufSize(), pwstr);
        (*pfn)(strOut);
    }
    return pwstr;
}

LPWSTR WINAPI CW32System::CharLower(LPWSTR pwstr)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CharLower");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::CharLowerW(pwstr);
    return CharChangeCase(pwstr, CharLowerA);
}

DWORD WINAPI CW32System::CharLowerBuff(LPWSTR pwstr, DWORD cchLength)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CharLowerBuff");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::CharLowerBuffW(pwstr, cchLength);
	LPWSTR lpBuffer = pwstr;
	for (DWORD pos = 0; pos < cchLength; pos++, lpBuffer++)
		*lpBuffer =  (WCHAR)CharChangeCase((LPWSTR)*lpBuffer, CharLowerA);
	return pos;
}

DWORD WINAPI CW32System::CharUpperBuff(LPWSTR pwstr, DWORD cchLength)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CharUpperBuff");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::CharUpperBuffW(pwstr, cchLength);
	LPWSTR lpBuffer = pwstr;
	for (DWORD pos = 0; pos < cchLength; pos++, lpBuffer++)
		*lpBuffer =  (WCHAR)CharChangeCase((LPWSTR)*lpBuffer, CharUpperA);
	return pos;
}

typedef HDC (CALLBACK *FnCreateHDCA)(LPCSTR, LPCSTR, LPCSTR, CONST DEVMODEA *);

static HDC WINAPI CreateHDCAux(
	LPCWSTR             lpszDriver,
	LPCWSTR             lpszDevice,
	LPCWSTR             lpszOutput,
	CONST DEVMODEW *    lpInitData,
	FnCreateHDCA        pfn
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CreateHDCWrap");

    DEVMODEA    devmode;
    CStrIn      strDriver(lpszDriver);
    CStrIn      strDevice(lpszDevice);
    CStrIn      strOutput(lpszOutput);

	if ( lpInitData )
	{
		// converting DEVMODEW to DEVMODEA

		int byteCount;

		// copying the data between the two strings members
		byteCount = (char *)&(devmode.dmFormName) 
			- (char *)&(devmode.dmSpecVersion);
	    memcpy(&(devmode.dmSpecVersion), 
			&(lpInitData->dmSpecVersion), 
			byteCount);

		// copying the data after the second string member
 		byteCount = (char *)((char *)&devmode + sizeof(DEVMODEA)) 
			- (char *)&(devmode.dmLogPixels);
	    memcpy(&(devmode.dmLogPixels), 
			&(lpInitData->dmLogPixels), 
			byteCount);

		// converting the two strings members
		W32->MbcsFromUnicode((CHAR *)devmode.dmDeviceName, CCHDEVICENAME, lpInitData->dmDeviceName);
		W32->MbcsFromUnicode((CHAR *)devmode.dmFormName, CCHFORMNAME, lpInitData->dmFormName);
	}

    return (*pfn)(strDriver, strDevice, strOutput, 
		lpInitData ? &devmode : NULL);
}

HDC WINAPI CW32System::CreateIC(
        LPCWSTR             lpszDriver,
        LPCWSTR             lpszDevice,
        LPCWSTR             lpszOutput,
        CONST DEVMODEW *    lpInitData)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CreateIC");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::CreateICW( lpszDriver, lpszDevice, lpszOutput, lpInitData );
    return CreateHDCAux(lpszDriver, lpszDevice, lpszOutput, lpInitData, CreateICA);
}

HANDLE WINAPI CW32System::CreateFile(
	LPCWSTR                 lpFileName,
	DWORD                   dwDesiredAccess,
	DWORD                   dwShareMode,
	LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
	DWORD                   dwCreationDisposition,
	DWORD                   dwFlagsAndAttributes,
	HANDLE                  hTemplateFile
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CreateFile");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::CreateFileW(lpFileName,
							dwDesiredAccess,
							dwShareMode,
							lpSecurityAttributes,
							dwCreationDisposition,
							dwFlagsAndAttributes,
							hTemplateFile);

    CStrIn  str(lpFileName);
    return ::CreateFileA(
            str,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile);
}

HFONT WINAPI CW32System::CreateFontIndirect(CONST LOGFONTW * plfw)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CreateFontIndirect");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::CreateFontIndirectW(plfw);
    LOGFONTA  lfa;
    HFONT     hFont;

    memcpy(&lfa, plfw, offsetof(LOGFONTA, lfFaceName));
    MbcsFromUnicode(lfa.lfFaceName, ARRAY_SIZE(lfa.lfFaceName), plfw->lfFaceName,
		-1, CP_ACP, UN_NOOBJECTS);
    hFont = ::CreateFontIndirectA(&lfa);
    return hFont;
}

int WINAPI CW32System::CompareString ( 
	LCID  Locale,			// locale identifier 
	DWORD  dwCmpFlags,		// comparison-style options 
	LPCWSTR  lpString1,		// pointer to first string 
	int  cch1,			// size, in bytes or characters, of first string 
	LPCWSTR  lpString2,		// pointer to second string 
	int  cch2 			// size, in bytes or characters, of second string  
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CompareString");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::CompareStringW(Locale, dwCmpFlags, lpString1, cch1, lpString2, cch2);

    CStrIn      str1(lpString1, cch1);
    CStrIn      str2(lpString2, cch2);

	return CompareStringA(
		Locale,
		dwCmpFlags,
		str1,
		str1.strlen(),
		str2,
		str2.strlen()
		);
}

LRESULT WINAPI CW32System::DefWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "DefWindowProcWrap");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::DefWindowProcW(hWnd, msg, wParam, lParam);
	return ::DefWindowProcA(hWnd, msg, wParam, lParam);
}

int WINAPI CW32System::GetObject(HGDIOBJ hgdiObj, int cbBuffer, LPVOID lpvObj)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetObject");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::GetObjectW( hgdiObj, cbBuffer, lpvObj);

    int nRet;

    if(cbBuffer != sizeof(LOGFONTW) || !lpvObj)
    {
        nRet = ::GetObjectA(hgdiObj, cbBuffer, lpvObj);
        if(nRet == sizeof(LOGFONTA))
        {
            nRet = sizeof(LOGFONTW);
        }
    }
    else
    {
        LOGFONTA lfa;

        nRet = ::GetObjectA(hgdiObj, sizeof(lfa), &lfa);

        if(nRet > 0)
        {
            memcpy(lpvObj, &lfa, offsetof(LOGFONTW, lfFaceName));
            UnicodeFromMbcs(((LOGFONTW*)lpvObj)->lfFaceName, ARRAY_SIZE(((LOGFONTW*)lpvObj)->lfFaceName),
                            lfa.lfFaceName, -1);
            nRet = sizeof(LOGFONTW);
        }
    }

    return nRet;
}

DWORD APIENTRY CW32System::GetProfileSection(
	LPCWSTR lpAppName,
	LPWSTR lpReturnedString,
	DWORD nSize
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetProfileSection");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::GetProfileSectionW( lpAppName, lpReturnedString, nSize );

	CStrIn 	strAppName(lpAppName);

	// we can't use CStrOut here, since the returned string contains a set of
	// strings delimited by single-NULL's and terminated by a double-NULL
	char *pszReturnedString;

	pszReturnedString = new char[nSize];
	Assert(pszReturnedString);

	DWORD cch = ::GetProfileSectionA(strAppName, pszReturnedString, nSize);

	if(cch)
	{
		cch = MultiByteToWideChar(CP_ACP, 0, pszReturnedString, cch, 
								lpReturnedString, nSize);
	}

	delete pszReturnedString;
	return cch;
}

BOOL APIENTRY CW32System::GetTextExtentPoint32(
	HDC     hdc,
	LPCWSTR pwsz,
	int     cb,
	LPSIZE  pSize
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetTextExtentPoint32");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::GetTextExtentPoint32W( hdc, pwsz, cb, pSize );
     CStrIn str(pwsz);
     return ::GetTextExtentPoint32A(hdc, str, cb, pSize);
}

int WINAPI CW32System::GetTextFace(
        HDC    hdc,
        int    cch,
        LPWSTR lpFaceName
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetTextFace");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::GetTextFaceW( hdc, cch, lpFaceName );
    CStrOut str(lpFaceName, cch);
    ::GetTextFaceA(hdc, str.BufSize(), str);
    return str.Convert();
}

BOOL WINAPI CW32System::GetTextMetrics(HDC hdc, LPTEXTMETRICW lptm)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetTextMetrics");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::GetTextMetricsW( hdc, lptm);

   BOOL         ret;
   TEXTMETRICA  tm;

   ret = ::GetTextMetricsA(hdc, &tm);

    if (ret)
    {
        lptm->tmHeight              = tm.tmHeight;
        lptm->tmAscent              = tm.tmAscent;
        lptm->tmDescent             = tm.tmDescent;
        lptm->tmInternalLeading     = tm.tmInternalLeading;
        lptm->tmExternalLeading     = tm.tmExternalLeading;
        lptm->tmAveCharWidth        = tm.tmAveCharWidth;
        lptm->tmMaxCharWidth        = tm.tmMaxCharWidth;
        lptm->tmWeight              = tm.tmWeight;
        lptm->tmOverhang            = tm.tmOverhang;
        lptm->tmDigitizedAspectX    = tm.tmDigitizedAspectX;
        lptm->tmDigitizedAspectY    = tm.tmDigitizedAspectY;
        lptm->tmItalic              = tm.tmItalic;
        lptm->tmUnderlined          = tm.tmUnderlined;
        lptm->tmStruckOut           = tm.tmStruckOut;
        lptm->tmPitchAndFamily      = tm.tmPitchAndFamily;
        lptm->tmCharSet             = tm.tmCharSet;

        UnicodeFromMbcs(&lptm->tmFirstChar, 1, (LPSTR) &tm.tmFirstChar, 1);
        UnicodeFromMbcs(&lptm->tmLastChar, 1, (LPSTR) &tm.tmLastChar, 1);
        UnicodeFromMbcs(&lptm->tmDefaultChar, 1, (LPSTR) &tm.tmDefaultChar, 1);
        UnicodeFromMbcs(&lptm->tmBreakChar, 1, (LPSTR) &tm.tmBreakChar, 1);
    }

    return ret;
}

LONG WINAPI CW32System::GetWindowLong(HWND hWnd, int nIndex)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetWindowLong");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::GetWindowLongW(hWnd, nIndex);
	return ::GetWindowLongA(hWnd, nIndex);
}

LONG_PTR WINAPI CW32System::GetWindowLongPtr(HWND hWnd, int nIndex)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetWindowLongPtr");
#ifdef _WIN64
	return GetWindowLongPtrW(hWnd, nIndex);
#else
	return GetWindowLong(hWnd, nIndex);
#endif
}

DWORD WINAPI CW32System::GetClassLong(HWND hWnd, int nIndex)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetClassLong");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::GetClassLongW(hWnd, nIndex);
	return ::GetClassLongA(hWnd, nIndex);
}

HBITMAP WINAPI CW32System::LoadBitmap(HINSTANCE hInstance, LPCWSTR lpBitmapName)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "LoadBitmap");
    Assert(HIWORD((DWORD_PTR)lpBitmapName) == 0);
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::LoadBitmapW(hInstance, lpBitmapName);
    return ::LoadBitmapA(hInstance, (LPCSTR) lpBitmapName);
}

HCURSOR WINAPI CW32System::LoadCursor(HINSTANCE hInstance, LPCWSTR lpCursorName)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "LoadCursor");
    Assert(HIWORD((DWORD_PTR)lpCursorName) == 0);
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::LoadCursorW(hInstance, lpCursorName);
    return ::LoadCursorA(hInstance, (LPCSTR) lpCursorName);
}

HINSTANCE WINAPI CW32System::LoadLibrary(LPCWSTR lpLibFileName)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "LoadLibrary");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::LoadLibraryW(lpLibFileName);
    CStrIn  str(lpLibFileName);
    return ::LoadLibraryA(str);
}

LRESULT WINAPI CW32System::SendMessage(
	HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "SendMessage");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId && ::IsWindowUnicode(hWnd))
		return ::SendMessageW(hWnd, Msg, wParam, lParam);

	// We never need Ansi to Unicode translation in our use of SendMessage
	// Our list boxes always use Unicode.
    switch (Msg)
    {
	// We don't want to translate these!
	// case LB_ADDSTRING:
    // case LB_INSERTSTRING:
    // case CB_ADDSTRING:
    // case CB_SELECTSTRING:
    // case CB_INSERTSTRING:
    // case LB_GETTEXT:
    // case CB_GETLBTEXT:

    case WM_GETTEXT:
		{
		   CStrOut str((LPWSTR)lParam, (int)wParam);
			::SendMessageA(hWnd, Msg, str.BufSize(), (LPARAM)(LPSTR)str);
			return str.Convert();
		}
		break;

    case WM_SETTEXT:
    case EM_REPLACESEL:
        Assert(FALSE);		// We never send these.  Dead code?
		break;

    case EM_SETPASSWORDCHAR:
        Assert(FALSE);		// We never send these.  Dead code?
		break;
    }
	return ::SendMessageA(hWnd, Msg, wParam, lParam);
}

LONG WINAPI CW32System::SetWindowLong(HWND hWnd, int nIndex, LONG dwNewLong)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "SetWindowLong");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::SetWindowLongW(hWnd, nIndex, dwNewLong);
    return ::SetWindowLongA(hWnd, nIndex, dwNewLong);
}

LONG WINAPI CW32System::SetWindowLongPtr(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "SetWindowLongPtr");
#ifdef _WIN64
	return ::SetWindowLongPtrW(hWnd, nIndex, dwNewLong);
#else
	return SetWindowLong(hWnd, nIndex, dwNewLong);
#endif
}

BOOL WINAPI CW32System::PostMessage(
	HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "PostMessage");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::PostMessageW(hWnd, Msg, wParam, lParam);
    return ::PostMessageA(hWnd, Msg, wParam, lParam);
}

BOOL WINAPI CW32System::UnregisterClass(LPCWSTR lpClassName, HINSTANCE hInstance)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "UnregisterClass");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::UnregisterClassW( lpClassName, hInstance);
    CStrIn  str(lpClassName);
    return ::UnregisterClassA(str, hInstance);
}

int WINAPI CW32System::lstrcmp(LPCWSTR lpString1, LPCWSTR lpString2)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "lstrcmp");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::lstrcmpW(lpString1, lpString2);
    return W32->wcscmp(lpString1, lpString2);
}

int WINAPI CW32System::lstrcmpi(LPCWSTR lpString1, LPCWSTR lpString2)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "lstrcmpi");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::lstrcmpiW(lpString1, lpString2);

	// Fall back on the simple minded CRT algortihm
	// The CRT actually has two paths.  This is the simple one
	const wchar_t * dst = lpString1;
    const wchar_t * src = lpString2;
	wchar_t f,l;
	
	do	{
		f = ((*dst <= L'Z') && (*dst >= L'A'))
			? *dst + L'a' - L'A'
			: *dst;
		l = ((*src <= L'Z') && (*src >= L'A'))
			? *src + L'a' - L'A'
			: *src;
		dst++;
		src++;
	} while ( (f) && (f == l) );
	
	return (int)(f - l);
}

BOOL WINAPI CW32System::PeekMessage(
	LPMSG   lpMsg,
    HWND    hWnd,
    UINT    wMsgFilterMin,
    UINT    wMsgFilterMax,
    UINT    wRemoveMsg
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "PeekMessage");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::PeekMessageW(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
    return ::PeekMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
}

DWORD WINAPI CW32System::GetModuleFileName(
	HMODULE hModule,
	LPWSTR lpFilename,
	DWORD nSize
)
{
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::GetModuleFileNameW(hModule, lpFilename, nSize);
    CStrOut  strout(lpFilename, nSize);
    DWORD res = ::GetModuleFileNameA(hModule, strout, nSize);
	strout.Convert();
	return res; 
}


// The high bits of _yHeightUI & _yHeightOther are being used to check if
// font is installed in the system
#define NEED_TO_CHECK_FONT 0x080
struct PreferredFontInfo
{
	BYTE _bPitchAndFamilyUI;
	BYTE _yHeightUI;
	SHORT _iFontUI;
	BYTE _bPitchAndFamilyOther;
	BYTE _yHeightOther;
	SHORT _iFontOther;
};

PreferredFontInfo g_pfinfo[NCHARSETS];

void CW32System::InitPreferredFontInfo()
{
	// For UI case, we will use Word9 UI fonts
	// For Non-UI case, we will use Word9 default email fonts
	
	short iFont;
	UINT  uSysDefCodePage = GetSystemDefaultCodePage();

	// Japanese Init
	static const WCHAR lpUIJapanFontName[] = L"MS UI Gothic";
	static const WCHAR lpOthJapanFontName[]
		= {0xFF2D,0xFF33,0x0020,0xFF30,0x30B4,0x30B7,0x30C3,0x30AF, 0};
	static const WCHAR lpOthJapanFontNameEUC[] = L"MS PGothic";

	iFont = GetFontNameIndex( lpUIJapanFontName );
	SetPreferredFontInfo( CP_JAPAN, true, iFont, 9 | NEED_TO_CHECK_FONT, 17 );
	if (uSysDefCodePage == CP_JAPAN)
		iFont = GetFontNameIndex( lpOthJapanFontName );
	else
		iFont = GetFontNameIndex( lpOthJapanFontNameEUC );
	SetPreferredFontInfo( CP_JAPAN, false, iFont, 10 | NEED_TO_CHECK_FONT, 17 );

	// Korean Init
	static const WCHAR lpUIKoreanFontName[] = {0xAD74, 0xB9BC, 0};
	static const WCHAR lpUIKoreanFontNameEUC[] = L"Gulim";
	
	if (uSysDefCodePage == CP_KOREAN)
		iFont = GetFontNameIndex( lpUIKoreanFontName );		
	else
		iFont = GetFontNameIndex( lpUIKoreanFontNameEUC );

	SetPreferredFontInfo( CP_KOREAN, true, iFont, 9 | NEED_TO_CHECK_FONT, 49 );
	SetPreferredFontInfo( CP_KOREAN, false, iFont, 9 | NEED_TO_CHECK_FONT, 49 );

	// Traditional Chinese Init
	static const WCHAR lpUITChineseFontName[]	= {0x65B0, 0x7D30, 0x660E, 0x9AD4, 0};
	static const WCHAR lpUITChineseFontNameEUC[] = L"PMingLiU";
	iFont = GetFontNameIndex(uSysDefCodePage == CP_CHINESE_TRAD
							 ? lpUITChineseFontName : lpUITChineseFontNameEUC);
	SetPreferredFontInfo( CP_CHINESE_TRAD, true, iFont, 9 | NEED_TO_CHECK_FONT, 54 );
	SetPreferredFontInfo( CP_CHINESE_TRAD, false, iFont, 9 | NEED_TO_CHECK_FONT, 54 );

	// Simplified Chinese Init
	static const WCHAR lpUISChineseFontName[] = {0x5B8B, 0x4F53, 0};
	static const WCHAR lpUISChineseFontNameEUC[] = L"SimSun";
	iFont = GetFontNameIndex(uSysDefCodePage == CP_CHINESE_SIM
							 ? lpUISChineseFontName : lpUISChineseFontNameEUC);
	SetPreferredFontInfo( CP_CHINESE_SIM, true,  iFont,  9 | NEED_TO_CHECK_FONT, 54 );
	SetPreferredFontInfo( CP_CHINESE_SIM, false, iFont, 10 | NEED_TO_CHECK_FONT, 54 );

	// English Init
	iFont = GetFontNameIndex( szTahoma );
	SetPreferredFontInfo(1252, true, iFont, 8, DEFAULT_PITCH | FF_SWISS );
	iFont = GetFontNameIndex( szArial );
	SetPreferredFontInfo(1252, false, iFont, 10, DEFAULT_PITCH | FF_SWISS );

	// SYMBOL_CHARSET
	iFont = GetFontNameIndex( szWingdings );
	SetPreferredFontInfo(CP_SYMBOL, true,  iFont, 8,  DEFAULT_PITCH | FF_DONTCARE);
	SetPreferredFontInfo(CP_SYMBOL, false, iFont, 10, DEFAULT_PITCH | FF_DONTCARE);
	
	// Vietnamese Init
	iFont = GetFontNameIndex( szTahoma );
	SetPreferredFontInfo(1258, true, iFont, 8, DEFAULT_PITCH | FF_SWISS );
	iFont = GetFontNameIndex( szArial );
	SetPreferredFontInfo(1258, false, iFont, 10, DEFAULT_PITCH | FF_SWISS );

	// Thai Init
	if (OnWinNT5())
		iFont = GetFontNameIndex( szMicrosSansSerif );
	else 
		iFont = GetFontNameIndex( szTahoma );

	SetPreferredFontInfo(874, true, iFont, 8, DEFAULT_PITCH | FF_SWISS );
	iFont = GetFontNameIndex( szCordiaNew );
	SetPreferredFontInfo(874, false, iFont, 14, DEFAULT_PITCH | FF_SWISS );

	// Devanagari Init
	iFont = GetFontNameIndex( szMangal );
	SetPreferredFontInfo(CP_DEVANAGARI, true, iFont, 8, DEFAULT_PITCH | FF_SWISS );
	SetPreferredFontInfo(CP_DEVANAGARI, false, iFont, 10, DEFAULT_PITCH | FF_SWISS );

	// Tamil Init
	iFont = GetFontNameIndex( szLatha );
	SetPreferredFontInfo(CP_TAMIL, true, iFont, 8, DEFAULT_PITCH | FF_SWISS );
	SetPreferredFontInfo(CP_TAMIL, false, iFont, 10, DEFAULT_PITCH | FF_SWISS );

	// Georgian and Armenian Init
	if(OnWinNT5())
	{
		iFont = GetFontNameIndex(szArialUnicode);
		SetPreferredFontInfo(CP_GEORGIAN, true,  iFont,  8, DEFAULT_PITCH | FF_SWISS);
		SetPreferredFontInfo(CP_GEORGIAN, false, iFont, 10, DEFAULT_PITCH | FF_SWISS);
		SetPreferredFontInfo(CP_ARMENIAN, true,  iFont,  8, DEFAULT_PITCH | FF_SWISS);
		SetPreferredFontInfo(CP_ARMENIAN, false, iFont, 10, DEFAULT_PITCH | FF_SWISS);
	}
	_fFEFontInfo = FEDATA_NOT_INIT;

	// Check installed keyboard layouts
	CheckInstalledKeyboards();
}

void CW32System::CheckInstalledKeyboards()
{
	HKL	 rghkl[MAX_HKLS];
    INT	 cLayouts = ::GetKeyboardLayoutList(MAX_HKLS, rghkl);		 	
	LONG cpg;
	INT  iScript;

	for(INT i = 0; i < cLayouts; i++)
  	{
		cpg = ConvertLanguageIDtoCodePage(PRIMARYLANGID(rghkl[i]));
		GetCharSet(cpg, &iScript);			// Get script index
 		if(iScript >= 0)
			SetPreferredKbd(iScript, rghkl[i]);
   	}
}

bool CW32System::SetPreferredFontInfo(
	int cpg,
	bool fUIFont,
	SHORT iFont,
	BYTE yHeight,
	BYTE bPitchAndFamily
)
{
	int iPFI;
	CLock lock;

	GetCharSet(	cpg, &iPFI );

	if (iPFI == -1)
		return false;

	if (fUIFont)
	{
		g_pfinfo[iPFI]._bPitchAndFamilyUI = bPitchAndFamily;
		g_pfinfo[iPFI]._yHeightUI = yHeight;
		g_pfinfo[iPFI]._iFontUI = iFont;
	}
	else
	{
		g_pfinfo[iPFI]._bPitchAndFamilyOther = bPitchAndFamily;
		g_pfinfo[iPFI]._yHeightOther = yHeight;
		g_pfinfo[iPFI]._iFontOther = iFont;
	}
	SetFontLegitimateSize(iFont, fUIFont, yHeight & ~NEED_TO_CHECK_FONT, cpg);

	return true;
}

bool CW32System::GetPreferredFontInfo(
	int cpg,
	bool fUIFont,
	SHORT& iFont,
	BYTE& yHeight,
	BYTE& bPitchAndFamily
)
{
	int iPFI;

	if (GetCharSet(	cpg, &iPFI ) && (iPFI == -1))
		return false;

	if (g_pfinfo[iPFI]._iFontUI == 0)
	{
		/* No entry.  Try default */
		iPFI = 0;
	}

	if (fUIFont)
	{
		bPitchAndFamily = g_pfinfo[iPFI]._bPitchAndFamilyUI;
		yHeight = g_pfinfo[iPFI]._yHeightUI;
		iFont = g_pfinfo[iPFI]._iFontUI;
	}
	else
	{
		bPitchAndFamily = g_pfinfo[iPFI]._bPitchAndFamilyOther;
		yHeight = g_pfinfo[iPFI]._yHeightOther;
		iFont = g_pfinfo[iPFI]._iFontOther;
	}
	
	if (yHeight & NEED_TO_CHECK_FONT)
	{
		// Check if the preferred font is installed in the system.
		CLock lock;

		HDC hDC = GetScreenDC();

		// Turn off the checkfont bit
		yHeight &= ~NEED_TO_CHECK_FONT;

		if (fUIFont)
			g_pfinfo[iPFI]._yHeightUI &= ~NEED_TO_CHECK_FONT;
		else
			g_pfinfo[iPFI]._yHeightOther &= ~NEED_TO_CHECK_FONT;
		
		if (hDC)
		{
			const short *pFontIndex = fUIFont ? &g_pfinfo[iPFI]._iFontUI : &g_pfinfo[iPFI]._iFontOther;
			if (IsFontAvail( hDC, cpg, fUIFont, (short *)pFontIndex))
				iFont = *pFontIndex;
				
		}
	}

	return true;
}

/*
 *	CW32System::GetPreferredFontHeight(
 *		bool	fUIFont,
 *		BYTE	bOrgCharSet, 
 *		BYTE	bNewCharSet, 
 *		SHORT	yOrgHeight)
 *
 *
 *	@mfunc
 *		called when we need the default font size when changing from one charset to another.
 *
 *	@rdesc
 *		The preferred default font size in TWIP if the Original height is same as the
 *		original charset default font size.  Otherwise, it will return the Original height.
 *
 */
SHORT  CW32System::GetPreferredFontHeight(	
	bool	fUIFont,
	BYTE	bOrgCharSet, 
	BYTE	bNewCharSet, 
	SHORT	yOrgHeight
)
{
	BYTE	yOrgPreferredHeight;
	LONG	idxOrgFont = ScriptIndexFromCharSet(bOrgCharSet);
	LONG	idxNewFont = ScriptIndexFromCharSet(bNewCharSet);

	// No entry, forget it
	if (idxOrgFont == -1 || idxNewFont == -1)
		return yOrgHeight;

	yOrgPreferredHeight = fUIFont ? 
		g_pfinfo[idxOrgFont]._yHeightUI : g_pfinfo[idxOrgFont]._yHeightOther;
			
	// Get New Preferred Height
	if (yOrgPreferredHeight && yOrgPreferredHeight == yOrgHeight/TWIPS_PER_POINT)
	{
		BYTE yNewHeight = (fUIFont ? 
			g_pfinfo[idxNewFont]._yHeightUI : g_pfinfo[idxNewFont]._yHeightOther);

		if (yNewHeight)
			return yNewHeight * TWIPS_PER_POINT;
	}
		
	return yOrgHeight;
}

/*
 *	CW32System::CheckInstalledFEFonts()
 *
 *
 *	@mfunc
 *		called when building FE fonts installed and User default LCID info
 *
 *	@devnote
 *		This information is necessary when we want to classify Chinese characters
 *		and Full-width characters.
 *
 */
void CW32System::CheckInstalledFEFonts()
{
	UINT	uUserCodepage;
	CLock	cLock;
	HDC hDC = GetScreenDC();

	_fFEFontInfo = 0;
	
	uUserCodepage = ConvertLanguageIDtoCodePage(::GetUserDefaultLCID());
	if (!IsFECodePage(uUserCodepage))
		uUserCodepage = GetACP();

	switch (uUserCodepage)
	{
		case CP_JAPAN:
			_fFEFontInfo |= (FEUSER_LCID | FEUSER_CP_JPN | JPN_FONT_AVAILABLE);
			break;

		case CP_KOREAN:
			_fFEFontInfo |= (FEUSER_LCID | FEUSER_CP_KOR | KOR_FONT_AVAILABLE);
			break;

		case CP_CHINESE_TRAD:
			_fFEFontInfo |= (FEUSER_LCID | FEUSER_CP_BIG5 | BIG5_FONT_AVAILABLE);
			break;

		case CP_CHINESE_SIM:
			_fFEFontInfo |= (FEUSER_LCID | FEUSER_CP_GB | GB_FONT_AVAILABLE);
			break;
	}

	if (hDC)
	{
		if (!(_fFEFontInfo & JPN_FONT_AVAILABLE) && IsFontAvail(hDC, CP_JAPAN))
			_fFEFontInfo |= JPN_FONT_AVAILABLE;

		if (!(_fFEFontInfo & KOR_FONT_AVAILABLE) && IsFontAvail(hDC, CP_KOREAN))
			_fFEFontInfo |= KOR_FONT_AVAILABLE;

		if (!(_fFEFontInfo & BIG5_FONT_AVAILABLE) && IsFontAvail(hDC, CP_CHINESE_TRAD))
			_fFEFontInfo |= BIG5_FONT_AVAILABLE;

		if (!(_fFEFontInfo & GB_FONT_AVAILABLE) && IsFontAvail(hDC, CP_CHINESE_SIM))
			_fFEFontInfo |= GB_FONT_AVAILABLE;
	}

}
/*
 *	CW32System::IsFEFontInSystem( cpg )
 *
 *
 *	@mfunc
 *		check if there is any FE font installed for the given codepage
 *
 *	@devnote
 *		This information is necessary when we want to classify Chinese characters
 *		and Full-width characters.
 *
 */
bool CW32System::IsFEFontInSystem(int cpg)
{
	int fFontExist = 0;

	if (_fFEFontInfo == FEDATA_NOT_INIT)
	{
		CLock	Lock;

		// Look for FE fonts in the system
		CheckInstalledFEFonts();
	}

	// Check if font for the codepage is in the system	
	switch (cpg)
	{
	case CP_JAPAN:
		fFontExist = _fFEFontInfo & JPN_FONT_AVAILABLE;
		break;
		
	case CP_KOREAN:
		fFontExist = _fFEFontInfo & KOR_FONT_AVAILABLE;
		break;

	case CP_CHINESE_TRAD:
		fFontExist = _fFEFontInfo & BIG5_FONT_AVAILABLE;
		break;

	case CP_CHINESE_SIM:
		fFontExist = _fFEFontInfo & GB_FONT_AVAILABLE;
		break;
	}
	
	return (fFontExist != 0);
}

/*
 *	CW32System::IsFontAvail( HDC hDC, int cpg, bool	fUIFont, short *piFontIndex )
 *
 *
 *	@mfunc
 *		called when checking if a font (UI or non-UI) is installed for a given codepage
 *
 *	@devnote
 *		We will try to create the font and verify the charset of the font
 *		actually created.  If the fontname index is supplied, we will check
 *		if the requested font is installed. If the name from GDI is different,
 *		the GDI font index will be returned in piFontIndex.
 *
 *	@rdesc
 *		true if a font that supports the given codepage is available.
 */
bool CW32System::IsFontAvail(
	HDC		hDC,				//@parm	Screen hDC
	int		cpg,				//@parm cpg	
	bool	fUIFont,			//@parm UI font?
	short	*piFontIndex)		//@parm Font Name Index (default = NULL)
{
	LOGFONTW	lf;
	HFONT		hfont;
	bool		retCode = false;
	int			iPFI;
	BYTE		bCharSet;

	if ((bCharSet = GetCharSet(cpg, &iPFI)) && (iPFI == -1))
		return false;

	ZeroMemory(&lf, sizeof(lf));
    
	// We want GDI to find a font that will support this charset 
	// Unspecified entries in LOGFONT will be either default or don't care.
	lf.lfCharSet = bCharSet; 
	
	if (fUIFont)
	{
		lf.lfHeight = g_pfinfo[iPFI]._yHeightUI;
		lf.lfPitchAndFamily = g_pfinfo[iPFI]._bPitchAndFamilyUI;
		wcscpy(lf.lfFaceName, GetFontName((LONG)(g_pfinfo[iPFI]._iFontUI)));
	}
	else
	{
		lf.lfHeight = g_pfinfo[iPFI]._yHeightOther;
		lf.lfPitchAndFamily = g_pfinfo[iPFI]._bPitchAndFamilyOther;
		wcscpy(lf.lfFaceName, GetFontName((LONG)(g_pfinfo[iPFI]._iFontOther)));
	}

	hfont = CreateFontIndirect(&lf);
    
	if(hfont)
    {
		TEXTMETRIC tm;

		HFONT hfontOld = SelectFont(hDC, hfont);
					
		if (GetTextMetrics(hDC, &tm) && tm.tmCharSet == bCharSet)
		{
			retCode = true;

			if (piFontIndex)
			{
				const WCHAR	*pszFontName = GetFontName(*piFontIndex);

				if (pszFontName)
				{ 
					WCHAR szNewFaceName[LF_FACESIZE];
					
					// Check if GDI gives us the same font name
					szNewFaceName[0] = L'\0';
					GetTextFace(hDC, LF_FACESIZE, szNewFaceName);
					if (szNewFaceName[0] && wcsicmp(pszFontName, szNewFaceName))
						*piFontIndex = GetFontNameIndex(szNewFaceName);	// Different name					
				}
			}
		}

		SelectFont(hDC, hfontOld);
		DeleteObject(hfont);
	}

	return retCode;
}

/*
 *	CW32System::GetFEFontInfo( void  )
 *
 *
 *	@mfunc
 *		called when classifying Chinese characters and Full-width characters
 *
 *	@devnote
 *		Chinese characters and Full-width characters can be in any
 *		of the four FE codepages.  We want to classfy them according to the 
 *		User default LCID and which FE fonts are installed in the system.
 *
 *	@rdesc
 *		Codepage for the character.
 */
UINT CW32System::GetFEFontInfo()
{
	int	iDefUserCodepage = -1;

	if (_fFEFontInfo == FEDATA_NOT_INIT)
	{
		CLock	Lock;

		// Check if FE fonts are available in the system
		CheckInstalledFEFonts();
	}

	if (_fFEFontInfo & FEUSER_LCID)
		iDefUserCodepage = (_fFEFontInfo & FEUSER_CODEPAGE);

	if (iDefUserCodepage == FEUSER_CP_BIG5)
		return CP_CHINESE_TRAD;

	if (iDefUserCodepage == FEUSER_CP_GB)
		return CP_CHINESE_SIM;	
	
	if (iDefUserCodepage == FEUSER_CP_JPN)
		return CP_JAPAN;

	if (iDefUserCodepage == FEUSER_CP_KOR)		
		return CP_KOREAN;

	// Check which font is available and return the corresponding codepage
	// We check for Simplified Chinese first since it contains more Chinese
	// characters than Traditional Chinese.
	if (_fFEFontInfo & GB_FONT_AVAILABLE)
		return CP_CHINESE_SIM;

	if (_fFEFontInfo & BIG5_FONT_AVAILABLE)
		return CP_CHINESE_TRAD;

	if (_fFEFontInfo & JPN_FONT_AVAILABLE)
		return CP_JAPAN;

	if (_fFEFontInfo & KOR_FONT_AVAILABLE)
		return CP_KOREAN;

	return CP_CHINESE_SIM;				// Well, no FE font, tough luck.
}

/*
 *	CW32System::IsDiacriticOrKashida(ch, wC3Type)
 *
 *	@mfunc
 *		Return TRUE if ch or wC3Type reveals that ch is a nonspacing
 *		diacritic or a kashida. Because Win9x GetStringTypeExW isn't
 *		implemented, we use range checks for Win9x.
 *
 *	@rdesc
 *		True if ch or wC3Type reveals that ch is a nonspacing diacritic
 */
BOOL CW32System::IsDiacriticOrKashida(
	WCHAR ch,		//@parm On Win9x, check ranges for ch
	WORD  wC3Type)	//@parm On WinNT, use C3-type check
{
	if(VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId && wC3Type)
		return wC3Type & (C3_DIACRITIC | C3_NONSPACING | C3_VOWELMARK | C3_KASHIDA);

	if(!IN_RANGE(0x300, ch, 0xe50))		// Combining diacritics of interest
		return FALSE;					//  fall in this range

	return IN_RANGE(0x300, ch, 0x36F) || IsDiacritic(ch) || IsBiDiKashida(ch);
}

/*
 *	CW32System::IsDiacritic(ch)
 *
 *	@mfunc
 *		Return TRUE if ch falls in BiDi, Thai, Devanagari or Tamil diacritic range.
 */
BOOL CW32System::IsDiacritic(
	WCHAR ch)
{
	// BiDi
	if (IsBiDiDiacritic(ch))
		return TRUE;

	// Thai
	if (IN_RANGE(0xe31, ch, 0xe4e))
		return 	IN_RANGE(0x0e47, ch, 0x0e4e) || IN_RANGE(0x0e34, ch, 0x0e3a) || ch == 0x0e31;

	// Devanagari
	if (IN_RANGE(0x0902, ch, 0x0963))
		return 	IN_RANGE(0x0941, ch, 0x0948) || IN_RANGE(0x0951, ch, 0x0954) || ch == 0x094d ||		
				IN_RANGE(0x0962, ch, 0x0963) || IN_RANGE(0x0901, ch, 0x0902) || ch == 0x093c;

	// Tamil
	if (IN_RANGE(0x0b82, ch, 0x0bcd))
		return 	ch == 0x0bcd || ch == 0x0bc0 || ch == 0x0b82;

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_antievt.h ===
/*
 *	@doc INTERNAL
 *
 *	@module _ANTIEVT.H |
 *
 *
 *	Purpose:
 *		Class declarations for common anti-event objects
 *
 *	Author:
 *		alexgo  3/25/95
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#ifndef __ANTIEVT_H__
#define __ANTIEVT_H__

#include "_frunptr.h"

class CTxtEdit;
class CAntiEventDispenser;
class COleObject;


/*
 *	CBaseAE
 *
 *	@class
 *		Base anti-event that manages a linked list of anti-events
 *
 */
class CBaseAE : public IAntiEvent
{
//@access Public Methods
public:
	virtual void Destroy();						//@cmember Destroy
												//@cmember Undo			
	virtual HRESULT Undo( CTxtEdit *ped, IUndoBuilder *publdr );
	virtual HRESULT MergeData( DWORD dwDataType, void *pdata);	//@cmember
												// Merges undo data into the
												// current context.
	virtual void OnCommit( CTxtEdit *ped );		//@cmember Called when AE is
												// committed to undo stack
	virtual	void SetNext( IAntiEvent *pNext );	//@cmember	Sets next AE
	virtual IAntiEvent *GetNext();				//@cmember	Gets next AE

//@access Protected Methods
protected:
	// CBaseAE should only exist as a parent class
	CBaseAE();									//@cmember Constructor
	~CBaseAE(){;}

//@access Private Methods and Data
private:
	IAntiEvent *	_pnext;						//@cmember Pointer to the next
												//AntiEvent
};

/*
 *	CReplaceRangeAE
 *
 *	@class
 *		an anti-event object than undoes a CTxtPtr::ReplaceRange
 *		operation
 *
 *	@base	public | CBaseAE
 */
class CReplaceRangeAE: public CBaseAE
{
//@access Public Methods
public:
	// IAntiEvent methods
	virtual void Destroy();						//@cmember Destroy
												//@cmember Undo
	virtual HRESULT Undo( CTxtEdit *ped, IUndoBuilder *publdr);		
	virtual HRESULT MergeData( DWORD dwDataType, void *pdata);	//@cmember
												// Merges undo data into the
												// current context

//@access Private methods and data
private:
												//@cmember Constructor
	CReplaceRangeAE(LONG cpMin, LONG cpMax, LONG cchDel, TCHAR *pchDel,
			IAntiEvent *paeCF, IAntiEvent *paePF);
	~CReplaceRangeAE();							//@cmember Destructor

	LONG		_cpMin;							//@cmember cp delete start
	LONG		_cpMax;							//@cmember cp delete end
	LONG		_cchDel;						//@cmember #of chars to insert
	TCHAR *		_pchDel;						//@cmember chars to insert
	IAntiEvent *_paeCF;							//@cmember charformat AE
	IAntiEvent *_paePF;							//@cmember par format AE

	friend class CAntiEventDispenser;
};

/*
 *	CReplaceFormattingAE
 *
 *	@class
 *		an anti-event object than undoes replacing multiple char formats
 *
 *	@base	public |  CBaseAE
 */
class CReplaceFormattingAE: public CBaseAE
{
//@access	Public methods
public:
	//
	// IAntiEvent methods
	//
	virtual void Destroy( void );				//@cmember Destroy
												//@cmember Undo
	virtual HRESULT Undo( CTxtEdit *ped, IUndoBuilder *publdr);

//@access	Private Methods and Data
private:
												//@cmember Constructor
	CReplaceFormattingAE(CTxtEdit* ped, CFormatRunPtr &rp, LONG cch, IFormatCache *pf, BOOL fPara);

	~CReplaceFormattingAE();					//@cmember Destuctor

	LONG		_cp;							//@cmember cp where formatting
												// should start
	LONG		_cRuns;							//@cmember # of format runs
	CFormatRun  *_prgRuns;						//@cmember format runs
	BOOL		_fPara;							//@cmember if TRUE, then
												// formatting is paragraph fmt

	friend class CAntiEventDispenser;
};

/*
 *	CReplaceObjectAE
 *
 *	@class
 *		an anti-event object that undoes the deletion of an object
 *
 *	@base public | CBaseAE
 */
class CReplaceObjectAE : public CBaseAE
{
//@access	Public methods
public:
	//
	//	IAntiEvent methods
	//
	virtual void Destroy(void);					//@cmember Destroy
												//@cmember Undo
	virtual HRESULT Undo(CTxtEdit *ped, IUndoBuilder *publdr);
	virtual void OnCommit(CTxtEdit *ped);		//@cmember called when
												// committed
private:
	CReplaceObjectAE(COleObject *pobj);			//@cmember Constructor
	~CReplaceObjectAE();						//@cmember Destructor

	COleObject *	_pobj;						//@cmember pointer to the
												// deleted object
	BOOL			_fUndoInvoked;				//@cmember undo was invoked
												// on this object.
	
	friend class CAntiEventDispenser;
};

/*
 *	CResizeObjectAE
 *
 *	@class
 *		an anti-event object that undoes the resizing of an object
 *
 *	@base public | CBaseAE
 */
class CResizeObjectAE : public CBaseAE
{
//@access	Public methods
public:
	//
	//	IAntiEvent methods
	//
	virtual void Destroy(void);					//@cmember Destroy
												//@cmember Undo
	virtual HRESULT Undo(CTxtEdit *ped, IUndoBuilder *publdr);
	virtual void OnCommit(CTxtEdit *ped);		//@cmember called when
												// committed
private:
	CResizeObjectAE(COleObject *pobj,			//@cmember Constructor
		            RECT rcPos);				
	~CResizeObjectAE();							//@cmember Destructor

	COleObject *	_pobj;						//@cmember pointer to the
												// deleted object
	RECT			_rcPos;						//@cmember The old object
												// position/size rectangle
	BOOL			_fUndoInvoked;				//@cmember undo was invoked
												// on this object.
	
	friend class CAntiEventDispenser;
};

/*
 *  CSelectionAE
 *
 *  @class
 *      an anti-event object to restore a selection
 *
 *  @base public | CBaseAE
 */
class CSelectionAE : public CBaseAE
{
//@access   Public methods
public:
    //
    //  IAntiEvent methods
    //
    virtual void Destroy(void);                 //@cmember Destroy
                                                //@cmember Undo
    virtual HRESULT Undo(CTxtEdit *ped, IUndoBuilder *publdr);
    virtual HRESULT MergeData( DWORD dwDataType, void *pdata);  //@cmember
                                                // Merges undo data into the
                                                // current context

private:
                                                //@cmember Constructor
    CSelectionAE(LONG cp, LONG cch, LONG cpNext, LONG cchNext);
    ~CSelectionAE();                            //@cmember Destructor

    LONG        _cp;                            //@cmember Active end
    LONG        _cch;                           //@cmember Signed extension
	LONG		_cpNext;						//@cmember Next active end
	LONG		_cchNext;						//@cmember Next extension

    friend class CAntiEventDispenser;
};

/*
 *	CAntiEventDispenser
 *
 *	@class
 *		creates anti events and caches them intelligently to provide
 *		for efficient multi-level undo
 */
class CAntiEventDispenser
{
//@access	Public methods
public:
	// no memory mgmt routines; the dispenser is global

												//@cmember text antievent
	IAntiEvent * CreateReplaceRangeAE( CTxtEdit *ped, LONG cpMin,
					LONG cpMax, LONG cchDel, TCHAR *pchDel,
					IAntiEvent *paeCF, IAntiEvent *paePF );
												//@cmember formatting AE
	IAntiEvent * CreateReplaceFormattingAE( CTxtEdit *ped,
					CFormatRunPtr &rp, LONG cch,
					IFormatCache *pf, BOOL fPara );
												//@cmember Object AE
	IAntiEvent * CreateReplaceObjectAE(CTxtEdit *ped, COleObject *pobj);
												//@cmember Object AE
	IAntiEvent * CreateResizeObjectAE(CTxtEdit *ped, COleObject *pobj, RECT rcPos);
												//@cmember Selection AE
	IAntiEvent * CreateSelectionAE(CTxtEdit *ped, LONG cp, LONG cch,
					LONG cpNext, LONG cchNext);

private:

	// FUTURE (alexgo): we'll want to maintain an allocation cache of
	// anti-events
};

// NB!! Global variable.

extern class CAntiEventDispenser gAEDispenser;

#endif // !__ANTIEVNT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_array.h ===
/*	@doc INTERNAL
 *
 *	@module _ARRAY.H  Generic Array Class |
 *	
 *	This module declares a generic array class for constant sized
 *	elements (although the elements themselves may be of any size).
 *
 *	Original Author: <nl>
 *		Christian Fortini
 *
 *	History: <nl>
 *		6/25/95	alexgo	Cleanup and Commenting
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#ifndef _ARRAY_H
#define _ARRAY_H

class CFormatRunPtr;

/*
 *	ArrayFlag
 *
 *	@enum	Defines flags used with the array class
 */
enum tagArrayFlag
{
	AF_KEEPMEM		= 1,	//@emem Don't delete any memory 
	AF_DELETEMEM	= 2,	//@emem Delete as much memory as possible
};

//@type ArrayFlag | flags controlling the usage of generic arrays 
//(and specifically how memory is handled)
typedef enum tagArrayFlag ArrayFlag;


/*
 *	CArrayBase
 *	
 * 	@class	The CArrayBase class implements a generic array class.  It should
 *	never be used directly; use the type-safe template, <c CArray>, instead.
 *
 *	@devnote There are exactly two legal states for an array: empty or not.
 *	If an array is empty, the following must be true:
 *
 *		<md CArrayBase::_prgel> == NULL; <nl>
 *		<md CArrayBase::_cel> == 0; <nl>
 *		<md CArrayBase::_celMax> == 0;
 *
 *	Otherwise, the following must be true:
 *
 *		<md CArrayBase::_prgel> != NULL; <nl>
 *		<md CArrayBase::_cel> <lt>= <md CArrayBase::_celMax>; <nl>
 *		<md CArrayBase::_celMax> <gt> 0;
 *
 *	
 *	An array starts empty, transitions to not-empty as elements are inserted
 *  and will transistion back to empty if all of the array elements are 
 *	removed.
 *
 */
class CArrayBase
{
//@access Public Methods
public:

#ifdef DEBUG
	BOOL	Invariant() const;		//@cmember Validates state consistentency
	void*	Elem(LONG iel) const;	//@cmember Get ptr to <p iel>'th run
#else
	void*	Elem(LONG iel) const {return _prgel + iel*_cbElem;}
#endif
	
	CArrayBase (LONG cbElem);		//@cmember Constructor
	~CArrayBase () {Clear(AF_DELETEMEM);}

	void 	Clear (ArrayFlag flag);	//@cmember Delete all runs in array
	LONG 	Count() const {return _cel;}//@cmember Get count of runs in array
									//@cmember Remove <p celFree> runs from
									// array, starting at run <p ielFirst>
	void 	Remove(LONG ielFirst, LONG celFree);
									//@cmember Replace runs <p iel> through
									// <p iel+cel-1> with runs from <p par>
	BOOL	Replace (LONG iel, LONG cel, CArrayBase *par);
	
	LONG 	Size() const {return _cbElem;}//@cmember Get size of a run			

//@access Protected Methods
protected:
	void* 	ArAdd (LONG cel, LONG *pielIns);	//@cmember Add <p cel> runs
	void* 	ArInsert(LONG iel, LONG celIns);	//@cmember Insert <p celIns>
												// runs

//@access Protected Data
protected:
	char*	_prgel;		//@cmember Pointer to actual array data
	LONG 	_cel;	  	//@cmember Count of used entries in array
	LONG	_celMax;	//@cmember Count of allocated entries in array
	LONG	_cbElem;	//@cmember Byte count of an individual array element
};

/*
 *	CArray
 *
 *	@class
 *		An inline template class providing type-safe access to CArrayBase
 *
 *	@tcarg class | ELEM | the class or struct to be used as array elements
 */

template <class ELEM> 
class CArray : public CArrayBase
{
//@access Public Methods
public:
	
	CArray ()								//@cmember Constructor
		: CArrayBase(sizeof(ELEM))
	{}
	
	ELEM *	Elem(LONG iel) const			//@cmember Get ptr to <p iel>'th
	{										// element
		return (ELEM *)CArrayBase::Elem(iel);
	}
	
	ELEM& 	GetAt(LONG iel) const			//@cmember Get <p iel>'th element
	{
		return *(ELEM *)CArrayBase::Elem(iel);
	}
	
	ELEM* 	Add (LONG cel, LONG *pielIns)	//@cmember Adds <p cel> elements						
	{										// to end of array
		return (ELEM*)ArAdd(cel, pielIns);
	}

	ELEM* 	Insert (LONG iel, LONG celIns)	//@cmember Insert <p celIns>
	{										// elements at index <p iel>
		return (ELEM*)ArInsert(iel, celIns);
	}

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\w32wince.cpp ===
// Windows CE implementations of W32 Interfaces.

// The following function is needed only because a Windows CE dll must have at least one export

__declspec(dllexport) void Useless( void )
{
	return;
}

LONG ValidateTextRange(TEXTRANGE *pstrg);

ATOM WINAPI CW32System::RegisterREClass(
	const WNDCLASSW *lpWndClass,
	const char *szAnsiClassName,
	WNDPROC AnsiWndProc
)
{
	// On Windows CE we don't do anything with ANSI window class
	return ::RegisterClass(lpWndClass);
}

LRESULT CW32System::ANSIWndProc( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
	// Should never be used in WinCE
	#pragma message ("Review : Incomplete")
	return 0;
}

HGLOBAL WINAPI CW32System::GlobalAlloc( UINT uFlags, DWORD dwBytes )
{
#ifdef TARGET_NT
	return ::GlobalAlloc( uFlags, dwBytes);
#else
	return LocalAlloc( uFlags & GMEM_ZEROINIT, dwBytes );
#endif
}

HGLOBAL WINAPI CW32System::GlobalFree( HGLOBAL hMem )
{
#ifdef TARGET_NT
	return ::GlobalFree( hMem );
#else
	return LocalFree( hMem );
#endif
}

UINT WINAPI CW32System::GlobalFlags( HGLOBAL hMem )
{
#ifdef TARGET_NT
	return ::GlobalFlags( hMem );
#else
	return LocalFlags( hMem );
#endif
}

HGLOBAL WINAPI CW32System::GlobalReAlloc( HGLOBAL hMem, DWORD dwBytes, UINT uFlags )
{
#ifdef TARGET_NT
	return ::GlobalReAlloc(hMem, dwBytes, uFlags);
#else
	return LocalReAlloc( hMem, dwBytes, uFlags );
#endif
}

DWORD WINAPI CW32System::GlobalSize( HGLOBAL hMem )
{
#ifdef TARGET_NT
	return ::GlobalSize( hMem );
#else
	return LocalSize( hMem );
#endif
}

LPVOID WINAPI CW32System::GlobalLock( HGLOBAL hMem )
{
#ifdef TARGET_NT
	return ::GlobalLock( hMem );
#else
	return LocalLock( hMem );
#endif
}

HGLOBAL WINAPI CW32System::GlobalHandle( LPCVOID pMem )
{
#ifdef TARGET_NT
	return ::GlobalHandle( pMem );
#else
	return LocalHandle( pMem );
#endif
}

BOOL WINAPI CW32System::GlobalUnlock( HGLOBAL hMem )
{
#ifdef TARGET_NT
	return ::GlobalUnlock( hMem );
#else
	return LocalUnlock( hMem );
#endif
}

BOOL WINAPI CW32System::REGetCharWidth(
	HDC hdc,
	UINT iChar,
	LPINT pAns,
	UINT		// For Windows CE the code page is not used
				//  as the A version is not called.
)
{
	int i;
	SIZE size;
    TCHAR buff[2];

	buff[0] = iChar;
	buff[1] = 0;

    if (GetTextExtentExPoint(hdc, buff, 1, 32000, &i, (LPINT)pAns, &size))
	{
		// pWidthData->width	-= xOverhang;		// Don't need since we use
													//  GetTextExtentPoint32()
		return TRUE;
	}

    return FALSE;
}

BOOL WINAPI CW32System::REExtTextOut(
	CONVERTMODE cm,
	UINT uiCodePage,
	HDC hdc,
	int x,
	int y,
	UINT fuOptions,
	CONST RECT *lprc,
	const WCHAR *lpString,
	UINT cbCount,
	CONST INT *lpDx,
	BOOL  FEFontOnNonFEWin95
)
{
	#pragma message ("Review : Incomplete")
	return ExtTextOut(hdc, x, y, fuOptions, lprc, lpString, cbCount, lpDx);
}

CONVERTMODE WINAPI CW32System::DetermineConvertMode( BYTE tmCharSet )
{
	#pragma message ("Review : Incomplete")
	return CVT_NONE;
}

void WINAPI CW32System::CalcUnderlineInfo( CCcs *pcccs, TEXTMETRIC *ptm )
{
	// Default calculation of size of underline
	// Implements a heuristic in the absence of better font information.
	SHORT dyDescent = pcccs->_yDescent;

	if (0 == dyDescent)
	{
		dyDescent = pcccs->_yHeight >> 3;
	}

	pcccs->_dyULWidth = max(1, dyDescent / 4);
	pcccs->_dyULOffset = (dyDescent - 3 * pcccs->_dyULWidth + 1) / 2;

	if ((0 == pcccs->_dyULOffset) && (dyDescent > 1))
	{
		pcccs->_dyULOffset = 1;
	}

	pcccs->_dySOOffset = -ptm->tmAscent / 3;
	pcccs->_dySOWidth = pcccs->_dyULWidth;

	return;
}

BOOL WINAPI CW32System::ShowScrollBar( HWND hWnd, int wBar, BOOL bShow, LONG nMax )
{
	SCROLLINFO si;
	Assert(wBar == SB_VERT || wBar == SB_HORZ);
	W32->ZeroMemory(&si, sizeof(SCROLLINFO));
	
	si.cbSize = sizeof(SCROLLINFO);
	si.fMask = SIF_RANGE | SIF_DISABLENOSCROLL;
	if (bShow)
	{
		si.nMax = nMax;
	}
	::SetScrollInfo(hWnd, wBar, &si, TRUE);
	return TRUE;
}

BOOL WINAPI CW32System::EnableScrollBar( HWND hWnd, UINT wSBflags, UINT wArrows )
{
	BOOL fEnable = TRUE;
	BOOL fApi;
	SCROLLINFO si;

	Assert (wSBflags == SB_VERT || wSBflags == SB_HORZ);
	if (wArrows == ESB_DISABLE_BOTH)
	{
		fEnable = FALSE;
	}
	// Get the current scroll range
	W32->ZeroMemory(&si, sizeof(SCROLLINFO));
	si.cbSize = sizeof(SCROLLINFO);
	si.fMask = SIF_RANGE;
	fApi = ::GetScrollInfo(hWnd, wSBflags, &si);
	if (fApi && !fEnable)
	{
		si.fMask = SIF_RANGE | SIF_DISABLENOSCROLL;
		si.nMin = 0;
		si.nMax = 0;
	}
	if (fApi) ::SetScrollInfo(hWnd, wSBflags, &si, TRUE);
	return fApi ? TRUE : FALSE;
}

BOOL WINAPI CW32System::IsEnhancedMetafileDC( HDC )
{
	// No enhanced metafile
	return FALSE;
}

UINT WINAPI CW32System::GetTextAlign(HDC hdc)
{
	// Review :: SHould we set last error?
	return GDI_ERROR;
}

UINT WINAPI CW32System::SetTextAlign(HDC hdc, UINT uAlign)
{
	// Review :: SHould we set last error?
	return GDI_ERROR;
}

UINT WINAPI CW32System::InvertRect(HDC hdc, CONST RECT *prc)
{
    HBITMAP hbm, hbmOld;
    HDC     hdcMem;
    int     nHeight, nWidth;

    nWidth = prc->right-prc->left;
    nHeight = prc->bottom-prc->top;

    hdcMem = CreateCompatibleDC(hdc);
    hbm = CreateCompatibleBitmap(hdc, nWidth, nHeight);
    hbmOld = (HBITMAP) SelectObject(hdcMem, hbm);

    BitBlt(hdcMem, 0, 0, nWidth, nHeight, hdc, prc->left, prc->top,
            SRCCOPY);

    FillRect(hdc, prc, (HBRUSH)GetStockObject(WHITE_BRUSH));

    BitBlt(hdc, prc->left, prc->top, nWidth,
                nHeight, hdcMem, 0, 0, SRCINVERT);

    SelectObject(hdcMem, hbmOld);
    DeleteDC(hdcMem);
    DeleteObject(hbm);
    return TRUE;
}

HPALETTE WINAPI CW32System::ManagePalette(
	HDC,
	CONST LOGPALETTE *,
	HPALETTE &,
	HPALETTE &
)
{
	// No op for Windows CE
	return NULL;
}

int WINAPI CW32System::GetMapMode(HDC)
{
	// Only MM Text supported on Win CE
	return MM_TEXT;
}

BOOL WINAPI CW32System::WinLPtoDP(HDC, LPPOINT, int)
{
	// This is not available on Win CE
	return 0;
}

long WINAPI CW32System::WvsprintfA( LONG cbBuf, LPSTR pszBuf, LPCSTR pszFmt, va_list arglist )
{
	WCHAR wszBuf[64];
	WCHAR wszFmt[64];
	WCHAR *pwszBuf = wszBuf;
	WCHAR *pwszFmt = wszFmt;
	Assert(cbBuf < 64);
	while (*pszFmt)
	{
		*pwszFmt++ = *pszFmt++;
		if (*(pwszFmt - 1) == '%')
		{
			Assert(*pszFmt == 's' || *pszFmt == 'd' || *pszFmt == '0' || *pszFmt == 'c');
			if (*pszFmt == 's')
			{
				*pwszFmt++ = 'h';
			}
		}
	}
	*pwszFmt = 0;
	LONG cw = wvsprintf( wszBuf, wszFmt, arglist );
	while (*pszBuf++ = *pwszBuf++);
	Assert(cw < cbBuf);
	return cw;
}

int WINAPI CW32System::MulDiv(int nNumber, int nNumerator, int nDenominator)
{
	// Special handling for Win CE
	// Must be careful to not cause divide by zero
	// Note that overflow on the multiplication is not handled
	// Hopefully that is not a problem for RichEdit use
	// Added Guy's fix up for rounding.

	// Conservative check to see if multiplication will overflow.
	if (IN_RANGE(_I16_MIN, nNumber, _I16_MAX) &&
		IN_RANGE(_I16_MIN, nNumerator, _I16_MAX))
	{
		return nDenominator ? ((nNumber * nNumerator) + (nDenominator / 2)) / nDenominator  : -1;
	}

	__int64 NNumber = nNumber;
	__int64 NNumerator = nNumerator;
	__int64 NDenominator = nDenominator;

	return NDenominator ? ((NNumber * NNumerator) + (NDenominator / 2)) / NDenominator  : -1;
}

void CW32System::GetFacePriCharSet(HDC hdc, LOGFONT* plf)
{
	plf->lfCharSet = 0;
}

void CW32System::CheckChangeKeyboardLayout ( CTxtSelection *psel, BOOL fChangedFont )
{
	#pragma message ("Review : Incomplete")
	return;
}

void CW32System::CheckChangeFont (
	CTxtSelection *psel,
	CTxtEdit * const ped,
	BOOL fEnableReassign,	// @parm Do we enable CTRL key?
	const WORD lcID,		// @parm LCID from WM_ message
	UINT cpg  				// @parm code page to use (could be ANSI for far east with IME off)
)
{
	#pragma message ("Review : Incomplete")
	return;
}

HKL CW32System::GetKeyboardLayout ( DWORD )
{
	#pragma message ("Review : Incomplete")
	return NULL;
}

HRESULT CW32System::LoadRegTypeLib ( REFGUID, WORD, WORD, LCID, ITypeLib ** )
{
	return E_NOTIMPL;
}

HRESULT CW32System::LoadTypeLib ( const OLECHAR *, ITypeLib ** )
{
	return E_NOTIMPL;
}

BSTR CW32System::SysAllocString ( const OLECHAR * )
{
	#pragma message ("Review : Incomplete")
	return NULL;
}

BSTR CW32System::SysAllocStringLen ( const OLECHAR *, UINT )
{
	#pragma message ("Review : Incomplete")
	return NULL;
}

void CW32System::SysFreeString ( BSTR )
{
	#pragma message ("Review : Incomplete")
	return;
}

UINT CW32System::SysStringLen ( BSTR )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

void CW32System::VariantInit ( VARIANTARG * )
{
	#pragma message ("Review : Incomplete")
	return;
}

HRESULT CW32System::OleCreateFromData ( LPDATAOBJECT, REFIID, DWORD, LPFORMATETC, LPOLECLIENTSITE, LPSTORAGE, void ** )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

void CW32System::CoTaskMemFree ( LPVOID )
{
	#pragma message ("Review : Incomplete")
	return;
}

HRESULT CW32System::CreateBindCtx ( DWORD, LPBC * )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HANDLE CW32System::OleDuplicateData ( HANDLE, CLIPFORMAT, UINT )
{
	#pragma message ("Review : Incomplete")
	return NULL;
}

HRESULT CW32System::CoTreatAsClass ( REFCLSID, REFCLSID )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::ProgIDFromCLSID ( REFCLSID, LPOLESTR * )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::OleConvertIStorageToOLESTREAM ( LPSTORAGE, LPOLESTREAM )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::OleConvertIStorageToOLESTREAMEx ( LPSTORAGE, CLIPFORMAT, LONG, LONG, DWORD, LPSTGMEDIUM, LPOLESTREAM )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::OleSave ( LPPERSISTSTORAGE, LPSTORAGE, BOOL )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::StgCreateDocfileOnILockBytes ( ILockBytes *, DWORD, DWORD, IStorage ** )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::CreateILockBytesOnHGlobal ( HGLOBAL, BOOL, ILockBytes ** )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::OleCreateLinkToFile ( LPCOLESTR, REFIID, DWORD, LPFORMATETC, LPOLECLIENTSITE, LPSTORAGE, void ** )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

LPVOID CW32System::CoTaskMemAlloc ( ULONG )
{
	#pragma message ("Review : Incomplete")
	return NULL;
}

LPVOID CW32System::CoTaskMemRealloc ( LPVOID, ULONG )
{
	#pragma message ("Review : Incomplete")
	return NULL;
}

HRESULT CW32System::OleInitialize ( LPVOID )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

void CW32System::OleUninitialize ( )
{
	#pragma message ("Review : Incomplete")
	return;
}

HRESULT CW32System::OleSetClipboard ( IDataObject * )
{
	return E_NOTIMPL;
}

HRESULT CW32System::OleFlushClipboard ( )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::OleIsCurrentClipboard ( IDataObject * )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::DoDragDrop ( IDataObject *, IDropSource *, DWORD, DWORD * )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::OleGetClipboard ( IDataObject ** )
{
	return E_NOTIMPL;
}

HRESULT CW32System::RegisterDragDrop ( HWND, IDropTarget * )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::OleCreateLinkFromData ( IDataObject *, REFIID, DWORD, LPFORMATETC, IOleClientSite *, IStorage *, void ** )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::OleCreateStaticFromData ( IDataObject *, REFIID, DWORD, LPFORMATETC, IOleClientSite *, IStorage *, void ** )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::OleDraw ( IUnknown *, DWORD, HDC, LPCRECT )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::OleSetContainedObject ( IUnknown *, BOOL )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::CoDisconnectObject ( IUnknown *, DWORD )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::WriteFmtUserTypeStg ( IStorage *, CLIPFORMAT, LPOLESTR )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::WriteClassStg ( IStorage *, REFCLSID )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::SetConvertStg ( IStorage *, BOOL )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::ReadFmtUserTypeStg ( IStorage *, CLIPFORMAT *, LPOLESTR * )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::ReadClassStg ( IStorage *pstg, CLSID * )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::OleRun ( IUnknown * )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::RevokeDragDrop ( HWND )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::CreateStreamOnHGlobal ( HGLOBAL, BOOL, IStream ** )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::GetHGlobalFromStream ( IStream *pstm, HGLOBAL * )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::OleCreateDefaultHandler ( REFCLSID, IUnknown *, REFIID, void ** )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::CLSIDFromProgID ( LPCOLESTR, LPCLSID )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::OleConvertOLESTREAMToIStorage ( LPOLESTREAM, IStorage *, const DVTARGETDEVICE * )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::OleLoad ( IStorage *, REFIID, IOleClientSite *, void ** )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::ReleaseStgMedium ( LPSTGMEDIUM pstgmed)
{
	#pragma message ("Review : Incomplete")

	// we don't use anything other than TYMED_HGLOBAL currently.
	if (pstgmed && (pstgmed->tymed == TYMED_HGLOBAL)) {
		::LocalFree(pstgmed->hGlobal);
	}

	return 0;
}

HRESULT CW32System::CoCreateInstance (REFCLSID rclsid, LPUNKNOWN pUnknown,
		DWORD dwClsContext, REFIID riid, LPVOID *ppv)
{
	#pragma message ("Review : Incomplete")
	return S_FALSE;
}

void CW32System::FreeOle()
{
	#pragma message ("Review : Incomplete")
}

void CW32System::FreeIME()
{
	#pragma message ("Review : Incomplete")
}

BOOL CW32System::HaveAIMM()
{
	#pragma message ("Review : Incomplete")
	return FALSE;
}

BOOL CW32System::HaveIMEShare()
{
	#pragma message ("Review : Incomplete")
	return FALSE;
}

BOOL CW32System::getIMEShareObject(CIMEShare **ppIMEShare)
{
	#pragma message ("Review : Incomplete")
	return FALSE;
}

LRESULT CW32System::AIMMDefWndProc(HWND hWnd, UINT msg, WPARAM wparam, LPARAM lparam, LRESULT *plres)
{
	#pragma message ("Review : Incomplete")
	return S_FALSE;
}

LRESULT CW32System::AIMMGetCodePage(HKL hKL, UINT *uCodePage)
{
	#pragma message ("Review : Incomplete")
	return S_FALSE;
}

LRESULT CW32System::AIMMActivate(BOOL fRestoreLayout)
{
	#pragma message ("Review : Incomplete")
	return S_FALSE;
}

LRESULT CW32System::AIMMDeactivate(void)
{
	#pragma message ("Review : Incomplete")
	return S_FALSE;
}

LRESULT CW32System::AIMMFilterClientWindows(ATOM *aaClassList, UINT uSize)
{
	#pragma message ("Review : Incomplete")
	return S_FALSE;
}

BOOL CW32System::ImmInitialize( void )
{
	#pragma message ("Review : Incomplete")
	return FALSE;
}

void CW32System::ImmTerminate( void )
{
	#pragma message ("Review : Incomplete")
	return;
}

LONG CW32System::ImmGetCompositionStringA ( HIMC, DWORD, LPVOID, DWORD )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HIMC CW32System::ImmGetContext ( HWND )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

BOOL CW32System::ImmSetCompositionFontA ( HIMC, LPLOGFONTA )
{
	#pragma message ("Review : Incomplete")
	return FALSE;
}

BOOL CW32System::ImmSetCompositionWindow ( HIMC, LPCOMPOSITIONFORM )
{
	#pragma message ("Review : Incomplete")
	return FALSE;
}

BOOL CW32System::ImmReleaseContext ( HWND, HIMC )
{
	#pragma message ("Review : Incomplete")
	return FALSE;
}

DWORD CW32System::ImmGetProperty ( HKL, DWORD )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

BOOL CW32System::ImmGetCandidateWindow ( HIMC, DWORD, LPCANDIDATEFORM )
{
	#pragma message ("Review : Incomplete")
	return FALSE;
}

BOOL CW32System::ImmSetCandidateWindow ( HIMC, LPCANDIDATEFORM )
{
	#pragma message ("Review : Incomplete")
	return FALSE;
}

BOOL CW32System::ImmNotifyIME ( HIMC, DWORD, DWORD, DWORD )
{
	#pragma message ("Review : Incomplete")
	return FALSE;
}

HIMC CW32System::ImmAssociateContext ( HWND, HIMC )
{
	#pragma message ("Review : Incomplete")
	return NULL;
}

UINT CW32System::ImmGetVirtualKey ( HWND )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HIMC CW32System::ImmEscape ( HKL, HIMC, UINT, LPVOID )
{
	#pragma message ("Review : Incomplete")
	return NULL;
}

LONG CW32System::ImmGetOpenStatus ( HIMC )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

BOOL CW32System::ImmGetConversionStatus ( HIMC, LPDWORD, LPDWORD )
{
	#pragma message ("Review : Incomplete")
	return FALSE;
}

HWND CW32System::ImmGetDefaultIMEWnd ( HWND )
{
	#pragma message ("Review : Incomplete")
	return NULL;
}

BOOL CW32System::FSupportSty ( UINT, UINT )
{
	#pragma message ("Review : Incomplete")
	return FALSE;
}

const IMESTYLE * CW32System::PIMEStyleFromAttr ( const UINT )
{
	#pragma message ("Review : Incomplete")
	return NULL;
}

const IMECOLORSTY * CW32System::PColorStyleTextFromIMEStyle ( const IMESTYLE * )
{
	#pragma message ("Review : Incomplete")
	return NULL;
}

const IMECOLORSTY * CW32System::PColorStyleBackFromIMEStyle ( const IMESTYLE * )
{
	#pragma message ("Review : Incomplete")
	return NULL;
}

BOOL CW32System::FBoldIMEStyle ( const IMESTYLE * )
{
	#pragma message ("Review : Incomplete")
	return FALSE;
}

BOOL CW32System::FItalicIMEStyle ( const IMESTYLE * )
{
	#pragma message ("Review : Incomplete")
	return FALSE;
}

BOOL CW32System::FUlIMEStyle ( const IMESTYLE * )
{
	#pragma message ("Review : Incomplete")
	return FALSE;
}

UINT CW32System::IdUlIMEStyle ( const IMESTYLE * )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

COLORREF CW32System::RGBFromIMEColorStyle ( const IMECOLORSTY * )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

BOOL CW32System::GetVersion(
	DWORD *pdwPlatformId,
	DWORD *pdwMajorVersion
)
{
	OSVERSIONINFO osv;
	osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	*pdwPlatformId = 0;
	*pdwMajorVersion = 0;
	if (GetVersionEx(&osv))
	{
		*pdwPlatformId = osv.dwPlatformId;
		*pdwMajorVersion = osv.dwMajorVersion;
		return TRUE;
	}
	return FALSE;
}

BOOL WINAPI CW32System::GetStringTypeEx(
	LCID lcid,
	DWORD dwInfoType,
	LPCTSTR lpSrcStr,
	int cchSrc,
	LPWORD lpCharType
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetStringTypeEx");
	return ::GetStringTypeExW(lcid, dwInfoType, lpSrcStr, cchSrc, lpCharType);   
}

LPWSTR WINAPI CW32System::CharLower(LPWSTR pwstr)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CharLowerWrap");
    return ::CharLowerW(pwstr);
}

DWORD WINAPI CW32System::CharLowerBuff(LPWSTR pwstr, DWORD cchLength)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CharLowerBuffWrap");
	return ::CharLowerBuffW(pwstr, cchLength);
}

DWORD WINAPI CW32System::CharUpperBuff(LPWSTR pwstr, DWORD cchLength)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CharUpperBuffWrap");
	return ::CharUpperBuffW(pwstr, cchLength);
}

HDC WINAPI CW32System::CreateIC(
        LPCWSTR             lpszDriver,
        LPCWSTR             lpszDevice,
        LPCWSTR             lpszOutput,
        CONST DEVMODEW *    lpInitData)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CreateIC");
	return ::CreateDCW( lpszDriver, lpszDevice, lpszOutput, lpInitData);
}

HANDLE WINAPI CW32System::CreateFile(
	LPCWSTR                 lpFileName,
	DWORD                   dwDesiredAccess,
	DWORD                   dwShareMode,
	LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
	DWORD                   dwCreationDisposition,
	DWORD                   dwFlagsAndAttributes,
	HANDLE                  hTemplateFile
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CreateFile");
	return ::CreateFileW(lpFileName,
						dwDesiredAccess,
						dwShareMode,
						lpSecurityAttributes,
						dwCreationDisposition,
						dwFlagsAndAttributes,
						hTemplateFile);
}

HFONT WINAPI CW32System::CreateFontIndirect(CONST LOGFONTW * plfw)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CreateFontIndirect");
	return ::CreateFontIndirectW(plfw);
}

int WINAPI CW32System::CompareString ( 
	LCID  Locale,			// locale identifier 
	DWORD  dwCmpFlags,		// comparison-style options 
	LPCWSTR  lpString1,		// pointer to first string 
	int  cchCount1,			// size, in bytes or characters, of first string 
	LPCWSTR  lpString2,		// pointer to second string 
	int  cchCount2 			// size, in bytes or characters, of second string  
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CompareString");
	return ::CompareStringW(Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
}

LRESULT WINAPI CW32System::DefWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "DefWindowProc");
	return ::DefWindowProcW(hWnd, msg, wParam, lParam);
}

int WINAPI CW32System::GetObject(HGDIOBJ hgdiObj, int cbBuffer, LPVOID lpvObj)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetObject");
	return ::GetObjectW( hgdiObj, cbBuffer, lpvObj );
}

DWORD APIENTRY CW32System::GetProfileSection(
	LPCWSTR ,
	LPWSTR ,
	DWORD
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetProfileSection");
	// Not available on Win CE
	return 0;
}

int WINAPI CW32System::GetTextFace(
        HDC    hdc,
        int    cch,
        LPWSTR lpFaceName
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetTextFaceWrap");
	return ::GetTextFaceW( hdc, cch, lpFaceName );
}

BOOL WINAPI CW32System::GetTextMetrics(HDC hdc, LPTEXTMETRICW lptm)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetTextMetrics");
	return ::GetTextMetricsW( hdc, lptm);
}

LONG WINAPI CW32System::GetWindowLong(HWND hWnd, int nIndex)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetWindowLong");
    return ::GetWindowLongW(hWnd, nIndex);
}

DWORD WINAPI CW32System::GetClassLong(HWND hWnd, int nIndex)
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HBITMAP WINAPI CW32System::LoadBitmap(HINSTANCE hInstance, LPCWSTR lpBitmapName)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "LoadBitmap");
    Assert(HIWORD(lpBitmapName) == 0);
    return ::LoadBitmapW(hInstance, lpBitmapName);
}

HCURSOR WINAPI CW32System::LoadCursor(HINSTANCE hInstance, LPCWSTR lpCursorName)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "LoadCursor");
    Assert(HIWORD(lpCursorName) == 0);
 	
	return (HCURSOR)lpCursorName;
}

HINSTANCE WINAPI CW32System::LoadLibrary(LPCWSTR lpLibFileName)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "LoadLibrary");
    return ::LoadLibraryW(lpLibFileName);
}

LRESULT WINAPI CW32System::SendMessage(
	HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "SendMessage");
    return ::SendMessageW(hWnd, Msg, wParam, lParam);
}

LONG WINAPI CW32System::SetWindowLong(HWND hWnd, int nIndex, LONG dwNewLong)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "SetWindowLongWrap");
    return ::SetWindowLongW(hWnd, nIndex, dwNewLong);
}

BOOL WINAPI CW32System::PostMessage(
	HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "PostMessage");
	return ::PostMessageW(hWnd, Msg, wParam, lParam);
}

BOOL WINAPI CW32System::UnregisterClass(LPCWSTR lpClassName, HINSTANCE hInstance)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "UnregisterClass");
	return ::UnregisterClassW( lpClassName, hInstance);
}

int WINAPI CW32System::lstrcmp(LPCWSTR lpString1, LPCWSTR lpString2)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "lstrcmp");
	return ::lstrcmpW(lpString1, lpString2);
}

int WINAPI CW32System::lstrcmpi(LPCWSTR lpString1, LPCWSTR lpString2)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "lstrcmpi");
	return ::lstrcmpiW(lpString1, lpString2);
}

BOOL WINAPI CW32System::PeekMessage(
	LPMSG   lpMsg,
    HWND    hWnd,
    UINT    wMsgFilterMin,
    UINT    wMsgFilterMax,
    UINT    wRemoveMsg
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "PeekMessage");
    return ::PeekMessageW(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
}

DWORD WINAPI CW32System::GetModuleFileName(
	HMODULE hModule,
	LPWSTR lpFilename,
	DWORD nSize
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetModuleFileName");
	// On Windows CE we will always be known as riched20.dll
	CopyMemory(lpFilename, TEXT("riched20.dll"), sizeof(TEXT("riched20.dll")));
	return sizeof(TEXT("riched20.dll"))/sizeof(WCHAR) - 1;
}

BOOL WINAPI CW32System::GetCursorPos(
	POINT *ppt
)
{
	DWORD	dw;
	
	dw = GetMessagePos();
	ppt->x = LOWORD(dw);
	ppt->y = HIWORD(dw);
	return TRUE;
}

#pragma message("JMO : Need to add Win CE version of InitSysParam!")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_callmgr.h ===
/*
 *
 *	@doc	INTERNAL
 *
 *	@module	_CALLMGR.H	CCallMgr declaration |
 *
 *	Purpose:  The call manager controls various aspects of
 *		a client call chain, including re-entrancy management,
 *		undo contexts, and change notifications.
 *
 *	Author:	<nl>
 *		alexgo 2/8/96
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */
#ifndef _CALLMGR_H
#define _CALLMGR_H

class CTxtEdit;
class CCallMgr;

#include "textserv.h"

enum CompName
{
	COMP_UNDOBUILDER	= 1,	// currently, these two are only compatible
	COMP_REDOBUILDER	= 2,	// with CGenUndoBuilder undo contexts
	COMP_UNDOGUARD		= 3,
	COMP_SELPHASEADJUSTER = 4
};

/*
 *	IReEntrantComponent
 *
 *	@class	A base class/interface for objects that want to work with the call
 *			manager for special re-entrancy requirements.
 *
 *			This class is similar in spirit to ITxNotify, thus, it contains
 *			private data only accessible to CCallMgr
 */
class IReEntrantComponent
{
	friend class CCallMgr;

//@access	Public Data
public:
	virtual void OnEnterContext() = 0;		//@cmember Called when a 
											// context is entered
//@access	Private Data
private:
	CompName				_idName;		//@cmember Name for this component
	IReEntrantComponent *	_pnext;			//@cmember Next one in list
};
		
/*
 *
 *	CCallMgr
 *
 *	@class	A stack-based class to handle re-entrancy and notification
 *			management.  CCallMgr's are created on the stack on every
 *			important entry point.  If one already exists (i.e. the
 *			edit control has been re-entered), the Call Manager will 
 *			adjust appropriately.
 */

class CCallMgr
{
	friend class CGenUndoBuilder;

//@access	Public Methods
public:
	// Notification Methods
	void SetChangeEvent(CHANGETYPE fType);	//@cmember Something changed
	void ClearChangeEvent();				//@cmember Ignore change
											//@cmember Did something change?
	BOOL GetChangeEvent()	{return _pPrevcallmgr ? 
								_pPrevcallmgr->GetChangeEvent() : _fChange;}
	BOOL GetMaxText()		{return _pPrevcallmgr ? 
								_pPrevcallmgr->GetMaxText() : _fMaxText;}
	BOOL GetOutOfMemory()	{return _pPrevcallmgr ? 
								_pPrevcallmgr->GetOutOfMemory() : _fOutOfMemory;}
	void SetNewUndo();						//@cmember New undo action added
	void SetNewRedo();						//@cmember New redo action added
	void SetMaxText();						//@cmember Max text length reached
	void SetSelectionChanged();				//@cmember Selection changed
	void SetOutOfMemory();					//@cmember Out of memory hit
	void SetInProtected(BOOL f);			//@cmember Set if in protected
											//		 notification callback
	BOOL GetInProtected();					//@cmember Get InProtected flag

	// SubSystem Management methods
											//@cmember Register a component
											// for this call context
	void RegisterComponent(IReEntrantComponent *pcomp, CompName name);
											//@cmember Revoke a component from
											//		this call context
	void RevokeComponent(IReEntrantComponent *pcomp);
	
	IReEntrantComponent *GetComponent(CompName name);//@cmember Get registered
											//		component by name

	// General Methods
	BOOL IsReEntered() { return !!_pPrevcallmgr;} //@cmember Return TRUE if
											//		in a re-entrant state
	BOOL IsZombie() { return !_ped;}		//@cmember Zombie call

	// Constructor/Destructor
	CCallMgr(CTxtEdit *ped);				//@cmember constructor
	~CCallMgr();							//@cmember destructor


//@access	Private Methods and data
private:

	void SendAllNotifications();			//@cmember Flush any cached 
											// notifications 
	void NotifyEnterContext();				//@cmember Notify registered 
											// components of a new context.

	CTxtEdit *		_ped;					//@cmember Current edit context
	CCallMgr *		_pPrevcallmgr;			//@cmember Next highest call mgr
	IReEntrantComponent *_pcomplist;		//@cmember List of components
											// registered for this call context

	unsigned long	_fTextChanged	:1;		//@cmember Text changed
	unsigned long	_fChange		:1;		//@cmember Generic change
	unsigned long	_fNewUndo		:1;		//@cmember New undo action added
	unsigned long	_fNewRedo		:1;		//@cmember New redo action added
	unsigned long	_fMaxText		:1;		//@cmember Max text length reached
	unsigned long	_fSelChanged	:1;		//@cmember Selection changed
	unsigned long	_fOutOfMemory	:1;		//@cmember Out of memory

	unsigned long	_fInProtected	:1;		//@cmember if in EN_PROTECTED not.
};

#endif // _CALLMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_clasfyc.h ===
/*
 *	@doc
 *
 *	@module _clasfyc.H -- character classification |
 *	
 *	Authors: <nl>
 *		Jon Matousek
 *
 *	Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
 */

#ifndef _CLASFYC_H
#define _CLASFYC_H

extern const INT g_cKinsokuCategories;

void BatchClassify(const WCHAR *ch, INT cch, WORD *pcType3,
				   INT *kinsokuClassifications, WORD *pwRes);
BOOL CanBreak(INT class1, INT class2);
WORD ClassifyChar(TCHAR ch);
INT	 GetKinsokuClass(WCHAR ch);
BOOL InitKinsokuClassify();
BOOL IsSameClass(WORD currType1, WORD startType1,
				 WORD currType3, WORD startType3);
BOOL IsURLDelimiter(WCHAR ch);
void UninitKinsokuClassify();

#define MAX_CLASSIFY_CHARS (256L)

#define	brkclsQuote			0
#define	brkclsOpen			1
#define	brkclsClose			2
#define	brkclsGlueA			3
#define	brkclsExclaInterr	4
#define	brkclsSlash			6
#define	brkclsInseparable	7
#define	brkclsPrefix		8
#define	brkclsPostfix		9
#define	brkclsNoStartIdeo	10
#define	brkclsIdeographic	11
#define	brkclsNumeral		12
#define	brkclsSpaceN		14
#define	brkclsAlpha			15

// Korean Unicode ranges
#define IsKoreanJamo(ch)	IN_RANGE(0x1100, ch, 0x11FF)
#define IsKorean(ch)		IN_RANGE(0xAC00, ch, 0xD7FF)

// Thai Unicode range
#define IsThai(ch)			IN_RANGE(0x0E00, ch, 0x0E7F)

// -FUTURE- This should be moved to richedit.h
#define WBF_KOREAN			0x0080
#define WBF_WORDBREAKAFTER	0x0400		// Break word after this character (for language such as Thai)



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_cmsgflt.h ===
// Forward declarations
class CIme;

class CTextMsgFilter : public ITextMsgFilter
{
public :
	HRESULT STDMETHODCALLTYPE QueryInterface( 
		REFIID riid,
		void **ppvObject);
	ULONG STDMETHODCALLTYPE AddRef( void);
	ULONG STDMETHODCALLTYPE Release( void);
	HRESULT STDMETHODCALLTYPE AttachDocument( HWND hwnd, ITextDocument2 *pTextDoc);
	HRESULT STDMETHODCALLTYPE HandleMessage( 
		UINT *pmsg,
        WPARAM *pwparam,
		LPARAM *plparam,
		LRESULT *plres);
	HRESULT STDMETHODCALLTYPE AttachMsgFilter( ITextMsgFilter *pMsgFilter);

	~CTextMsgFilter();

	BOOL	IsIMEComposition()	{ return (_ime != NULL);};
	BOOL	GetTxSelection();

	CIme	*_ime;					// non-NULL when IME composition active
	HWND	_hwnd;	
	UINT	_uKeyBoardCodePage;		// current keyboard codepage
	UINT	_uSystemCodePage;		// system codepage

	WORD	_fIMECancelComplete		:1;		// If aborting IME, cancel comp string, else complete
	WORD	_fUnicodeIME			:1;		// TRUE if Unicode IME
	WORD	_fIMEAlwaysNotify		:1;		// Send Notification during IME undetermined string
	WORD	_fHangulToHanja			:1;		// TRUE during Hangul to Hanja conversion
	WORD	_fOvertypeMode			:1;		// TRUE if overtype mode is on. 
	WORD	_fMSIME					:1;		// TRUE if MSIME98 or later
	WORD	_fUsingAIMM				:1;		// TRUE if AIMM is activated
	WORD	_fUnicodeWindow			:1;		// TRUE if Unicode Window
	WORD	_fForceEnable			:1;		// TRUE if Force Enable on Focus
	WORD	_fForceActivate			:1;		// TRUE if Force Activate on Focus
	WORD	_fForceRemember			:1;		// TRUE if Force Remember
	WORD	_fIMEEnable				:1;		// TRUE if IME was enable before
	WORD	_fRE10Mode				:1;		// TRUE if running in RE1.0 Mode

	// Support for SETIMEOPTIONS:
	DWORD	_fIMEConversion;				// for Force Remember use
	DWORD	_fIMESentence;					// for Force Remember use
	HKL		_fIMEHKL;						// for Force Remember use

	long	_cpReconvertStart;				// use during reconversion
	long	_cpReconvertEnd;				// use during reconversion
	long	_lFEFlags;						// For FE setting (ES_NOIME, ES_SELFIME)	

	COMPCOLOR			_crComp[4];			// Support 1.0 mode composition color
	ITextDocument2		*_pTextDoc;	
	ITextSelection		*_pTextSel;	

private:
	ULONG				_crefs;

	ITextMsgFilter *	_pFilter;

	HIMC				_hIMCContext;

	// private methods 
	HRESULT	OnWMChar(
		UINT *pmsg,
        WPARAM *pwparam,
		LPARAM *plparam,
		LRESULT *plres);

	HRESULT	OnWMIMEChar(
		UINT *pmsg,
        WPARAM *pwparam,
		LPARAM *plparam,
		LRESULT *plres);

	HRESULT	OnIMEReconvert( 
		UINT *pmsg,
        WPARAM *pwparam,
		LPARAM *plparam,
		LRESULT *plres,
		BOOL	fUnicode);

	BOOL CheckIMEChange(
		LPRECONVERTSTRING	lpRCS,
		long				cpParaStart, 
		long				cpParaEnd,
		long				cpMin,
		long				cpMax,
		BOOL				fUnicode);

	HRESULT	OnIMEQueryPos( 
		UINT *pmsg,
        WPARAM *pwparam,
		LPARAM *plparam,
		LRESULT *plres,
		BOOL	fUnicode);

	void CheckIMEType( HKL hKL );

	HRESULT InputFEChar( WCHAR wchFEChar );

	void	OnSetFocus();
	void	OnKillFocus();

	LRESULT	OnSetIMEOptions(WPARAM wparam, LPARAM lparam);
	LRESULT	OnGetIMEOptions();
	void	SetupIMEOptions();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_cbhost.h ===
/*	@doc INTERNAL
 *
 *	@module _CBHOST.H  Combobox Host for Window's Rich Edit Control |
 *	
 *
 *	Original Author: <nl>
 *		Jerry Kim
 *
 *	History: <nl>
 *		01/30/98	v-jerrki	created
 */
#ifndef _CBHOST_H
#define _CBHOST_H

#include "_host.h"
#define CB_LISTBOXID	1000
#define CB_EDITBOXID	1001

#define ITEM_MSG_DRAWLIST	1
#define ITEM_MSG_DRAWCOMBO	2
#define ITEM_MSG_DELETE		3


class CCmbBxWinHost : public CTxtWinHost
{
friend LRESULT CALLBACK RichComboBoxWndProc(HWND, UINT, WPARAM, LPARAM);

public:
	typedef enum {						// enumeration determining type of combo box
		kSimple = 1,
		kDropDown = 2,
		kDropDownList = 3
	} Combotype;

#ifndef ACCESSIBILITY
public:
	// -----------------------------
	//	IUnknown interface
	// -----------------------------
    virtual HRESULT 		WINAPI QueryInterface(REFIID riid, void **ppvObject);
#endif
	
public:
	unsigned int	_fRightAlign:1;		// Determines if the combo box should be right aligned
	unsigned int 	_fListVisible:1;	// Determines if list is visible
	unsigned int	_fOwnerDraw:1;		// owner draw combo box
	unsigned int	_fFocus:1;			// do we have the focus?
	unsigned int 	_fMousedown:1;		// if the left button was down
	unsigned int	_fVisible:1;		// window is visible
	unsigned int	_fEnabled:1;		// window is enabled
	unsigned int	_fNoIntegralHeight:1; // no integral height
	unsigned int	_fCapture:1;		// determines if the combo box has mouse cursor captured or not
	unsigned int 	_fResizing:1;		// flag to indicate we are resizing the window
	unsigned int	_fExtendedUI:1;		// flag indicating if extended ui is used
	unsigned int	_fLBCBMessage:1;	// flag indicating the message is LBCB_TRACKING
	unsigned int	_fIgnoreChange:1;	// flag indicating there was an internal change of text in
										// the edit control
	unsigned int	_fIgnoreUpdate:1;	// flag indicating if we should ignore the update flag, we need
										// this flag because there will be cases where updateWindow is
										// needed but we don't want to fire the notification

	HWND			_hwndList;			// window handle of listbox
	HCURSOR			_hcurOld;			// handle to the mouse cursor
	
protected:
	RECT			_rcWindow;			// rect of window which the combo box was created with
	RECT			_rcButton;			// rect of button
	RECT			_rcList;			// rect of listbox

										// we have to have a minimum inset for either the right or left
										// to account for the button for the combo box
	int				_dxRInset;			// minimum right inset
	int				_dxLInset;			// minimum left inset

	int				_dxROffset;			// indents for right and left these values should be used
	int 			_dxLOffset;			// with _dxRInset/_dxLInset to properly calculate the indents

	int				_dyFont;			// Height of the current font, may not necessarily be the system font
	int				_dyEdit;			// height of items

	int				_cyCombo;			// Height of the combo box
	int				_cxCombo;			// Width of the combo box
	int				_cyList;			// Height of the listbox

	long			_nCursor;			// last selected cursor -2 by default
	BOOL			_bSelOk;			// used to help in determining what kind of notification to give

	UINT			_idCtrl;			// ID of control	
	Combotype		_cbType;			// current combo box style
	CLstBxWinHost*	_plbHost;			// pointer to listbox host

protected:

	// Draws the combo button
	void DrawButton(HDC hdc, BOOL bDown);

	// Sets the edit controls text to item of the list box
	void AutoUpdateEdit(int i);

	// Hilite the edit control
	void HiliteEdit(BOOL bSelect);

	// resizes the list box
	void SetDropSize(RECT* prc);

	// set the edit size
	void SetSizeEdit(int nLeft, int nTop, int nRight, int nBottom);

public:
	// Constructor / Destructor
	CCmbBxWinHost();
	virtual ~CCmbBxWinHost();

	// initialization function
	virtual BOOL Init(HWND,	const CREATESTRUCT *);

	// Window creation/destruction
	static 	LRESULT OnNCCreate(HWND hwnd, const CREATESTRUCT *pcs);
	static 	void OnNCDestroy(CCmbBxWinHost *ped);
	virtual LRESULT OnCreate(const CREATESTRUCT *pcs);

	// Edit control Text helper functions
	LRESULT GetEditText(LPTSTR szStr, int nSize);
	LRESULT GetTextLength();

	// Draws the focus rect for the edit control
	void DrawEditFocus(HDC);

	// Sets the text in the edit control to the text of the current item in the
	// list box
	void UpdateEditBox();

	// selects the item which has the same text string as the edit control
	int UpdateListBox(BOOL);

	// hides the listbox
	BOOL HideListBox(BOOL, BOOL);

	// shows the list box
	void ShowListBox(BOOL);

	// Used as a way for the listbox to communicate to the combo box about a selection
	void SetSelectionInfo(BOOL bOk, int nIdx);

	// Update the window but don't send the notification
	void UpdateCbWindow()
	{
		_fIgnoreUpdate = 1;
		TxViewChange(TRUE);
		_fIgnoreUpdate = 0;
	}
	
	/////////////////////////////// message handlers /////////////////////////////////

	// Richedit message
	LRESULT OnSetTextEx(WPARAM wparam, LPARAM lparam);
	 
	// Keyboard messages
	virtual LRESULT	OnKeyDown(WORD vKey, DWORD dwFlags);
	virtual LRESULT	OnChar(WORD vKey, DWORD dwFlags);
	virtual LRESULT OnSyskeyDown(WORD vKey, DWORD dwFlags);

	// mouse messages
	LRESULT OnLButtonUp(WPARAM wparam, LPARAM lparam);
	LRESULT OnMouseMove(WPARAM wparam, LPARAM lparam);
	LRESULT OnMouseWheel(WPARAM wparam, LPARAM lparam);
	LRESULT OnSetCursor(WPARAM wparam, LPARAM lparam);
	LRESULT OnLButtonDown(WPARAM wparam, LPARAM lparam);

	// focus messages
	LRESULT OnSetFocus(WPARAM wparam, LPARAM lparam);
	LRESULT OnKillFocus(WPARAM wparam, LPARAM lparam);
	LRESULT OnCaptureChanged(WPARAM wparam, LPARAM lparam);

	// window messages
	LRESULT OnPaint(WPARAM, LPARAM);
	HRESULT OnCommand(WPARAM wparam, LPARAM lparam);	
	LRESULT OnSize(WPARAM wparam, LPARAM lparam);
	LRESULT OnGetDlgCode(WPARAM wparam, LPARAM lparam);
	LRESULT OnEnable(WPARAM wparam, LPARAM lparam);

	//@cmember Notify host of events
	virtual HRESULT	TxNotify(DWORD iNotify, void *pv);

	//@cmember Changes the mouse cursor
	virtual HCURSOR	 TxSetCursor2(HCURSOR hcur, BOOL bText) 
	{ return (hcur) ? ::SetCursor(hcur) : ::GetCursor();}

	///////////////////////// combo box message handlers ////////////////////////////
	// Calculates the rect's and height's of all the controls
	BOOL CbCalcControlRects(RECT* prc, BOOL bCalcChange);	

	// Retrieves the item height for either the edit or list box
	LRESULT CbGetItemHeight(BOOL bEdit);

	// sets the item height for either the edit or list box
	LRESULT CbSetItemHeight(BOOL bEdit, int nHeight);	

	// sets extendedUI mode
	LRESULT CbSetExtendedUI(BOOL bExtendedUI);

	// retrieves the current extendedUI mode
	LRESULT CbGetExtendedUI() const {return _fExtendedUI;}

	// forwards the WM_DRAWITEM, WM_DELETEITEM messages to the parent window
	LRESULT CbMessageItemHandler(HDC, int, WPARAM, LPARAM);

#ifndef NOACCESSIBILITY
	////////////////////////// IAccessible Methods /////////////////////////////////
	HRESULT	InitTypeInfo();
	
    STDMETHOD(get_accParent)(IDispatch **ppdispParent);    
    STDMETHOD(get_accChildCount)(long *pcountChildren);    
    STDMETHOD(get_accChild)(VARIANT varChild, IDispatch **ppdispChild);    
    STDMETHOD(get_accName)(VARIANT varChild, BSTR *pszName);    
    STDMETHOD(get_accValue)(VARIANT varChild, BSTR *pszValue);
    STDMETHOD(get_accRole)(VARIANT varChild, VARIANT *pvarRole);    
    STDMETHOD(get_accState)(VARIANT varChild, VARIANT *pvarState);     
    STDMETHOD(get_accKeyboardShortcut)(VARIANT varChild, BSTR *pszKeyboardShortcut);    
    STDMETHOD(get_accFocus)(VARIANT *pvarChild);    
    STDMETHOD(get_accSelection)(VARIANT *pvarChildren);    
    STDMETHOD(get_accDefaultAction)(VARIANT varChild, BSTR *pszDefaultAction);    
    STDMETHOD(accSelect)(long flagsSelect, VARIANT varChild);    
    STDMETHOD(accLocation)(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild);    
    STDMETHOD(accNavigate)(long navDir, VARIANT varStart, VARIANT *pvarEndUpAt);    
    STDMETHOD(accHitTest)(long xLeft, long yTop, VARIANT *pvarChild);    
    STDMETHOD(accDoDefaultAction)(VARIANT varChild);
#endif // NOACCESSIBILITY

};


#endif // _CBHOST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_common.h ===
/*
 *	_COMMON.H
 *	
 *	Purpose:
 *		RICHEDIT private common definitions
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _COMMON_H
#define _COMMON_H

// REVIEW macro.
//
#define __LINE(l)   #l
#define __LINE_(l)  __LINE(l)
#define _LINE_      __LINE_(__LINE__)
#define REVIEW  __FILE__ "("  __LINE_(__LINE__) ") : "

#pragma message ("Compiling Common.H")

#ifdef NT
	#ifndef WINNT
	#define WINNT
	#endif
#endif

#define _UNICODE

#ifndef STRICT
#define STRICT
#endif

#define NOSHELLDEBUG			//disables asserts in shell.h

#include <limits.h>
#if defined(DEBUG) && !defined(PEGASUS)
#include <stdio.h>
#endif

#define WINVER 0x0500

#include <windows.h>
#include <windowsx.h>
#include <winable.h>

#ifndef MACPORT
#include "imm.h"
#else
#include <tchar.h>
#include "wlmimm.h"
#endif	//MACPORT

/*
 *	Types
 */
#include <ourtypes.h>

// for the benefit of the outside world, richedit.h uses cpMax instead
// of cpMost. I highly prefer cpMost
#ifdef cpMax
#error "cpMax hack won't work"
#endif

#define cpMax cpMost
#include <richedit.h>
#include <richole.h>
#undef cpMax

#include "_debug.h"

// Return TRUE if LF <= ch <= CR. NB: ch must be unsigned;
// TCHAR and unsigned short give wrong results!
#define IN_RANGE(n1, b, n2)		((unsigned)((b) - (n1)) <= unsigned((n2) - (n1)))

#define IsASCIIDigit(b)		IN_RANGE('0', b, '9')
#define IsASCIIEOP(ch)		IN_RANGE(LF, ch, CR)
#define IsZerowidthCharacter(ch) IN_RANGE(ZWSP, ch, RTLMARK)


// disable
//         4710 : function not inlined
//         4512 : assignment operator not generated
//         4201 : nameless struct union
//         4100 : unreferenced formal;
//		   4706 : assignment within conditional expression (oould be bad, but common)
//		   4127 : conditional expression is constant (if (1))
//		   4242 : truncation warning
//         4244 : truncation warning

#pragma warning (disable : 4710 4512 4201 4100 4127 4706 4242 4244)

#pragma warning(3:4121)   // structure is sensitive to alignment
#pragma warning(3:4130)   // logical operation on address of string constant
#pragma warning(3:4132)   // const object should be initialized
#pragma warning(3:4509)   // use of SEH with destructor

// Our Win32 wrapper class
#include "_w32sys.h"

#include "resource.h"

// Use explicit ASCII values for LF and CR, since MAC compilers
// interchange values of '\r' and '\n'
#define	LF			10
#define	CR			13
#define FF			12
#define TAB			TEXT('\t')
//#define CELL		7
#define CELL		TAB
#define EURO		0x20AC
#define VT			TEXT('\v')
#define	PS			0x2029
#define SOFTHYPHEN	0xAD

#define BOM			0xFEFF
#define BULLET		0x2022
#define EMDASH		0x2014
#define EMSPACE		0x2003
#define ENDASH		0x2013
#define	ENQUAD		0x2000
#define ENSPACE		0x2002
#define KASHIDA		0x0640
#define LDBLQUOTE	0x201c
#define LQUOTE		0x2018
#define LTRMARK		0x200E
#define RDBLQUOTE	0x201D
#define RQUOTE		0x2019
#define RTLMARK		0x200F
#define SOFTHYPHEN	0xAD
#define	UTF16		0xDC00
#define	UTF16_LEAD	0xD800
#define	UTF16_TRAIL	0xDC00
#define ZWSP		0x200B
#define ZWJ			0x200D
#define ZWNJ		0x200C


/*
 *	IsEOP(ch)
 *
 *	@func
 *		Used to determine if ch is an EOP char, i.e., CR, LF, VT, FF, PS, or
 *		LS (Unicode paragraph/line separator). For speed, this function is
 *		inlined.
 *
 *	@rdesc
 *		TRUE if ch is an end-of-paragraph char
 */
__inline BOOL IsEOP(unsigned ch)
{
	return IN_RANGE(LF, ch, CR) || (ch | 1) == PS;
}

BOOL	IsRTF(char *pstr);

#include <tom.h>
#define CP_INFINITE tomForward

#include "zmouse.h"
#include "stddef.h"
#include "_util.h"

#ifdef DEBUG
#define EM_DBGPED (WM_USER + 150)
#endif

#define EM_GETCODEPAGE	(WM_USER + 151)

// MIN

#ifdef min
#undef min
#endif
#define __min(a,b)    (((a) < (b)) ? (a) : (b))

inline int     min(int     v1, int     v2)	{return __min(v1, v2);}
inline UINT    min(UINT    v1, UINT    v2)	{return __min(v1, v2);}
inline float   min(float   v1, float   v2)	{return __min(v1, v2);}
inline double  min(double  v1, double  v2)	{return __min(v1, v2);}
inline __int64 min(__int64 v1, __int64 v2)	{return __min(v1, v2);}

// MAX

#ifdef max
#undef max
#endif
#define __max(a,b)    (((a) > (b)) ? (a) : (b))

inline int     max(int     v1, int     v2)	{return __max(v1, v2);}
inline UINT    max(UINT    v1, UINT    v2)	{return __max(v1, v2);}
inline float   max(float   v1, float   v2)	{return __max(v1, v2);}
inline double  max(double  v1, double  v2)	{return __max(v1, v2);}
inline __int64 max(__int64 v1, __int64 v2)	{return __max(v1, v2);}

// ABS

#ifdef abs
#undef abs
#endif
#define __abs(a)    (((a) < 0) ? 0 - (a) : (a))

#pragma function(abs)
inline int __cdecl abs(int	   v)	{return __abs(v);}
// The abs val of a UINT is just that number. If we were to pass the value on to
// the __abs macro we'd get a warning because (a) < 0 will always be false. This
// fix allows us to compile cleanly *and* keep the same behavior as before.
inline UINT    abs(UINT    v)	{return v;}
inline float   abs(float   v)	{return __abs(v);}
inline double  abs(double  v)   {return __abs(v);}
inline __int64 abs(__int64 v)	{return __abs(v);}

#define ARRAY_SIZE(x)   (sizeof(x) / sizeof(x[0]))

#include "_cfpf.h"

// Interesting OS versions
#define VERS4		4

// conversions between byte and character counts
#define CbOfCch(_x) ((_x) * 2)
#define CchOfCb(_x) ((_x) / 2)

#define cKinsokuCategories	16

#define OLEstrcmp	wcscmp
#define OLEstrcpy	wcscpy
#define OLEsprintf	wsprintf
#define OLEstrlen	wcslen

// index (window long) of the PED
#define ibPed 0

#define RETID_BGND_RECALC	0x01af
#define RETID_AUTOSCROLL	0x01b0
#define RETID_SMOOTHSCROLL	0x01b1
#define RETID_DRAGDROP		0x01b2
#define RETID_MAGELLANTRACK	0x01b3

// Count of characters in CRLF marker
#define cchCRLF 2
#define cchCR	1

// RichEdit 1.0 uses a CRLF for an EOD marker
#define	CCH_EOD_10			2
// RichEdit 2.0 uses a simple CR for the EOD marker
#define CCH_EOD_20			1

extern const TCHAR szCRLF[];
extern const TCHAR szCR[];

extern HINSTANCE hinstRE;		// DLL instance

#include <shellapi.h>

#ifndef MACPORT
  #ifdef DUAL_FORMATETC
  #undef DUAL_FORMATETC
  #endif
  #define DUAL_FORMATETC FORMATETC
#endif

#include "WIN2MAC.h"

extern "C"
{
	LRESULT CALLBACK RichEditWndProc(HWND, UINT, WPARAM, LPARAM);
	LRESULT CALLBACK RichEditANSIWndProc(HWND, UINT, WPARAM, LPARAM);
}

// Multi-Threading support
extern CRITICAL_SECTION g_CriticalSection;

// a class to simplify critical section management
class CLock
{
public:
	CLock()
	{
		EnterCriticalSection(&g_CriticalSection);
	}
	~CLock()
	{
		LeaveCriticalSection(&g_CriticalSection);
	}
};

enum HITTEST
{
	HT_Undefined = 0,	// Hit hasn't been determined
	HT_Nothing,
	HT_OutlineSymbol,
	HT_LeftOfText,
	HT_BulletArea,
	HT_RightOfText,

	HT_Text,			// All hits are in text from HT_Text on so
	HT_Link,			//  if(hit >= HT_Text) identifies text of some kind
	HT_Italic,
	HT_Object
};

#define ST_CHECKPROTECTION		0x8000
#define ST_10REPLACESEL			0x10000000
#define ST_10WM_SETTEXT			0x20000000

/* REListbox1.0 Window Class. */
// For Windows CE to avaoid possible conflicts on WIn95.
#define CELISTBOX_CLASSA	"REListBoxCEA"
#define CELISTBOX_CLASSW	L"REListBoxCEW"

#ifndef MACPORT
#define LISTBOX_CLASSW		L"REListBox20W"
#define COMBOBOX_CLASSW		L"REComboBox20W"
#else	/*----------------------MACPORT */
#define LISTBOX_CLASSW		TEXT("REListBox20W")	/* MACPORT change */
#define COMBOBOX_CLASSW		TEXT("REComboBox20W")	/* MACPORT change */
#endif /* MACPORT  */

#ifdef DEBUG
//Debug api for dumping CTxtStory arrays.
extern "C" {
extern void DumpDoc(void *);
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_coleobj.h ===
/*
 *	@doc	INTERNAL
 *
 *	@module	_COLEOBJ.H		The OLE Object management class | 
 *
 *	Author:	alexgo 10/24/95
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef __COLEOBJ_H__
#define __COLEOBJ_H__

#include "_notmgr.h"

#ifdef LINESERVICES
extern "C" {
#include "plsdnode.h"
}
#endif

class CDisplay;
class CDevDesc;
class CTxtEdit;
class IUndoBuilder;

/* 
 *	COleObject
 *
 *	@class	This class manages an individual OLE object embedding.
 *
 */

class COleObject :  public IOleClientSite, public IOleInPlaceSite, 
					public IAdviseSink, public CSafeRefCount, public ITxNotify
{
//@access Public methods
public:
	//
	// IUnknown methods
	//

	STDMETHOD(QueryInterface)(REFIID riid, void **pv);
	STDMETHOD_(ULONG, AddRef)(void);
	STDMETHOD_(ULONG, Release)(void);
	
	//
	// IOleClientSite methods
	//
	
	STDMETHOD(SaveObject)(void);
	STDMETHOD(GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker,
							IMoniker **ppmk);
	STDMETHOD(GetContainer)(IOleContainer **ppContainer);
	STDMETHOD(ShowObject)(void);
	STDMETHOD(OnShowWindow)(BOOL fShow);
	STDMETHOD(RequestNewObjectLayout)(void);

	//
	//	IOleInPlaceSite methods
	//
	STDMETHOD(GetWindow)(HWND *phwnd);
	STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode);
	STDMETHOD(CanInPlaceActivate)(void);
	STDMETHOD(OnInPlaceActivate)(void);
	STDMETHOD(OnUIActivate)(void);
	STDMETHOD(GetWindowContext)(IOleInPlaceFrame **ppFrame,
							IOleInPlaceUIWindow **ppDoc, LPRECT lprcPosRect,
							LPRECT lprcClipRect, 
							LPOLEINPLACEFRAMEINFO lpFrameInfo);
	STDMETHOD(Scroll)(SIZE scrollExtant);
	STDMETHOD(OnUIDeactivate)(BOOL fUndoable);
	STDMETHOD(OnInPlaceDeactivate)(void);
	STDMETHOD(DiscardUndoState)(void);
	STDMETHOD(DeactivateAndUndo)(void);
	STDMETHOD(OnPosRectChange)(LPCRECT lprcPosRect);

	//
	// IAdviseSink methods
	//

	STDMETHOD_(void, OnDataChange)(FORMATETC *pfetc, STGMEDIUM *pmedium);
	STDMETHOD_(void, OnViewChange)(DWORD dwAspect, LONG lindex);
	STDMETHOD_(void, OnRename)(IMoniker *pmk);
	STDMETHOD_(void, OnSave)(void);
	STDMETHOD_(void, OnClose)(void);

	//
	//	ITxNotify methods
	//
    virtual void    OnPreReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
                        LONG cpFormatMin, LONG cpFormatMax);
    virtual void    OnPostReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
                        LONG cpFormatMin, LONG cpFormatMax);
	virtual void	Zombie();

	//
	//	internal public methods
	//

			COleObject(CTxtEdit *ped);	//@cmember Constructor
	LONG	GetCp()		{return _cp;}	//@cmember Get cp for this object
	CTxtEdit *GetPed()	{return _ped;}	//@cmember Get ped for this object
										//@cmember Fill out the REOBJECT struct
	HRESULT	GetObjectData(REOBJECT *preobj, DWORD dwFlags);
	BOOL	IsLink();					//@cmember returns TRUE if the object
										// is a link object.
										//@cmember Initialize from the given
										// object data
	HRESULT InitFromREOBJECT(LONG cp, REOBJECT *preobj);
										//@cmember Measures the object (no outgoing calls)
	void MeasureObj(long dypInch, long dxpInch, LONG & xWidth, LONG & yAscent, LONG & yDescent, SHORT yDescentFont);
										//@cmember Draws the object
	void	DrawObj(const CDisplay *pdp, long dypInch, long dxpInch, HDC hdc, BOOL fMetafile, POINT *ppt, RECT *prcRender,
					LONG yBaselineLine, LONG yDescentMaxCur);
										//@cmember Handle the object being
										// deleted from the backing store
	void	Delete(IUndoBuilder *publdr);
	void	Restore();					//@cmember restore an object into
										// the backing store
										//@cmember Force a close on the
										// object
	void	Close(DWORD dwSaveOption);
										//@cmember Zombie the object.
    void    MakeZombie(void);
										//@cmember Activate the object
	BOOL	ActivateObj(UINT uiMsg,	WPARAM wParam, LPARAM lParam);
	HRESULT	DeActivateObj(void);		//@cmember Aeactivate the object
										//@cmember Set individual selection
										//state of object

	RECT *	GetPosRect()				//@cmember return the position rect
				{ return &_rcPos; }

	void ResetPosRect(LONG *pAdjust = NULL);

	void FetchObjectExtents(void);//@cmember Gets the size of the object
									//@cmember return REO_SELECTED state
	BOOL	GetREOSELECTED(void) {return (_pi.dwFlags & REO_SELECTED);}
										//@cmember set REO_SELECTED state
	void	SetREOSELECTED(BOOL fSelect);
								//@cmember checks for hits on frame handles
	LPTSTR	CheckForHandleHit(const POINT &pt);
								//@cmember handle object resize
	BOOL    HandleResize(const POINT &pt);
								//@cmember sets object size
	void    Resize(const RECT &rcNew);
								//@cmember update _sizel
	void	ResetSizel(const SIZEL &sizel)
						{_sizel = sizel;}
								//@cmember called when object position changes
	void    OnReposition( LONG dx, LONG dy );
								//@cmember gets objects IUnknown
	IUnknown *	GetIUnknown(void) {return _punkobj;}
								//@cmember converts to the specified class
	HRESULT	Convert(REFCLSID rclsidNew, LPCSTR lpstrUserTypeNew);
								//@cmember activate as the specified class
	HRESULT	ActivateAs(REFCLSID rclsid, REFCLSID rclsidAs);
								//@cmember set aspect to use
	void	SetDvaspect(DWORD dvaspect);
								//@cmember get current aspect
	DWORD	GetDvaspect()
				{ return _pi.dvaspect; }
								//@cmember see IPersistStore::HandsOffStorage
	void	HandsOffStorage(void);
								//@cmember see IPersistStore::SaveCompleted
	void	SaveCompleted(LPSTORAGE lpstg);
								//@cmember set REO_LINKAVAILABLE flag
	HRESULT SetLinkAvailable(BOOL fAvailable);
								//@cmember Used for textize support
	LONG	WriteTextInfoToEditStream(EDITSTREAM *pes);
								//@cmember Scroll this object if appropriate
	void	ScrollObject(LONG dx, LONG dy, LPCRECT prcScroll);

								//@cmember guard the position rectangle
								// from bad updates
	void	EnableGuardPosRect()	{_fGuardPosRect = TRUE;}
								//@cmember clear the guard bit
	void	DisableGuardPosRect()	{_fGuardPosRect = FALSE;}
								//@cmember set the _hdata member
	void    SetHdata(HGLOBAL hg)	{_hdata = hg;}
								//@cmember get the _hdata member

	void	GetSizel(SIZEL &sizel)	{sizel = _sizel;}
								//&cmember gets the _sizel member

	DWORD	GetFlags()	{return  _pi.dwFlags;}
								//&cmember gets the _sizel member
	DWORD	GetUser()	{return  _pi.dwUser;}
								//&cmember gets the _sizel member
	DWORD	GetAspect()	{return  _pi.dvaspect;}
								//&cmember gets the _sizel member

	// For internal use without reentering undo system.
	STDMETHOD(SafeSaveObject)(void);

	HGLOBAL GetHdata()				{return _hdata;}
	struct ImageInfo
	{
		LONG	xScale, yScale;		// @field scaling percentage along axes
		SHORT	xExtGoal, yExtGoal;	// @field desired dimensions in twips for pictures
		SHORT	cBytesPerLine;		// @field # bytes per raster line, if bitmap
	};
								//@cmember set the _pimageinfo member
	void    SetImageInfo(struct ImageInfo *pim)	{_pimageinfo = pim;}
								//@cmember get the _pimageinfo member
	ImageInfo *GetImageInfo()				{return _pimageinfo;}

#ifdef DEBUG
	void    DbgDump(DWORD id);
#endif
	BOOL	GetViewChanged()	{return _fViewChange;}
	void	ResetViewChanged()	{_fViewChange = FALSE;}

//@access Private methods and data
private:
	virtual ~COleObject();		//@cmember Destructor

	void SavePrivateState(void);//@cmember Saves private information
	HRESULT ConnectObject(void);//@cmember setup advises, etc.
	void DisconnectObject(void);//@cmember tear down advises, etc.
	void CleanupState(void);	//@cmember cleans up our member data, etc.
								//@cmember draws frame around object
	void DrawFrame(const CDisplay *pdp, HDC hdc, RECT* prc);
								//@cmember helper to draw frame handles
	void DrawHandle(HDC hdc, int x, int y);
								//@cmember helper to check for hit on a handle
	void CreateDib(HDC hdc);
								//@cmember helper to create DIB for WinCE bitmaps
	void DrawDib(HDC hdc, RECT *prc);
								//@cmember helper to draw WinCE bitmaps
	BOOL InHandle(int x, int y, const POINT &pt);
								//@cmember to restablish rectangle position
	enum { SE_NOTACTIVATING, SE_ACTIVATING };  // used by SetExtent to indicate
												// the context of the SetExtent call
								//@cmember Attempts to set object extents
	HRESULT SetExtent(int iActivating);

	CTxtEdit *		_ped;		//@cmember edit context for this object
	IUnknown *		_punkobj;	//@cmember pointer to the objects IUnknown.
	IStorage *		_pstg;		//@cmember storage for the object
	RECT	 		_rcPos	;	//@cmember position rect in client coords
	SIZEL			_sizel;		//@cmember cached "real" size of the object
	LONG			_cp;		//@cmember position of this object
	DWORD			_dwConn;	//@cmember advise connection cookie
	HGLOBAL			_hdata;
	HBITMAP			_hdib;
	ImageInfo *		_pimageinfo;

	struct PersistedInfo
	{
		DWORD	dwFlags;		//@cmember see richole.h
		DWORD	dwUser;			//@cmember user defined
		DWORD	dvaspect;		//@cmember from the DVASPECT enumeration
	};

	PersistedInfo	_pi;

	SHORT	_dxyFrame;			//@cmember Object frame width
	DWORD	_fInPlaceActive:1;	//@cmember inplace active?
	DWORD	_fInUndo:1;			//@cmember in the undo stack?
	DWORD	_fIsWordArt2:1;		//@cmember Is this object a WordArt 2.0
								// object? (need to do hacks for it)
	DWORD 	_fIsPaintBrush:1;	//@cmember Is this object a PaintBrush
								// object? (need to do hacks for it)
	DWORD	_fPBUseLocalSizel:1;	
								//@cmember Signals that SetExtent
								// for a PaintBrush object failed and that
								// _sizel is an accurate indication of object size
	DWORD   _fDraw:1;			//@cmember Should object be drawn?
	DWORD	_fSetExtent:1;		//@cmember Does SetExtent need to be called
								   //when activating.
	DWORD	_fGuardPosRect:1;	//@cmember Guards position rect from updating
	DWORD	_fDeactivateCalled:1;//@cmember Whether deactivate has been called.
	DWORD	_fAspectChanged:1;	//@cmember Forces FetchObjectExtents to call through when aspect changes
	DWORD	_fViewChange:1;		//@cmember flag to indicate size of object changed

	DWORD	_fActivateCalled:1;	//@member Are we in the middle of the activation sequence?

#ifdef LINESERVICES
public:
	PLSDNODE _plsdnTop;			//@cmember Ptr to LS display node
#endif
};

#endif // __COLEOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_cfpf.h ===
/*
 *	@doc 	INTERNAL
 *
 *	@module _CFPF.H	-- RichEdit CCharFormat and CParaFormat Classes |
 *
 *	These classes are derived from the RichEdit 1.0 CHARFORMAT and PARAFORMAT
 *	structures and are the RichEdit 2.0 internal versions of these structures.
 *	Member functions (like Copy()) that use external (API) CHARFORMATs and
 *	PARAFORMATs need to check the <p cbSize> value to see what members are
 *	defined.  Default values that yield RichEdit 1.0 behavior should be stored
 *	for RichEdit 1.0 format structures, e.g., so that the renderer doesn't do
 *	anomalous things with random RichEdit 2.0 format values.  Generally the
 *	appropriate default value is 0.
 *
 *	All character and paragraph format measurements are in twips.  Undefined
 *	mask and effect bits are reserved and must be 0 to be compatible with
 *	future versions.
 *
 *	Effects that appear with an asterisk (*) are stored, but won't be
 *	displayed by RichEdit 2.0.  They are place holders for TOM and/or Word
 *	compatibility.
 *
 *	Note: these structures are much bigger than they need to be for internal
 *	use especially if we use SHORTs instead of LONGs for dimensions and
 *	the tab and font info are accessed via ptrs.  Nevertheless, in view of our
 *	tight delivery schedule, RichEdit 2.0 uses the classes below.
 *
 *	History:
 *		9/1995	-- MurrayS: Created
 *		11/1995 -- MurrayS: Extended to full Word97 FormatFont/Format/Para
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#ifndef _CFPF_H
#define _CFPF_H

#define	TABS

SHORT	Get16BitTwips(LONG dy);
LONG	GetUsableFontHeight(LONG ySrcHeight, LONG lPointChange);
BOOL	IsValidCharFormatW(const CHARFORMATW *	pCF);
BOOL	IsValidCharFormatA(const CHARFORMATA *	pCFA);
BOOL	IsValidParaFormat (const PARAFORMAT *	pPF);

// CParaFormat Style enums and defines (maybe move to richedit.h?)
enum STYLES
{
	STYLE_NORMAL	= -1,
	STYLE_HEADING_1	= -2,
	STYLE_HEADING_9	= -10
};

#define	NHSTYLES				9			// # of heading styles
#define	STYLE_COMMAND			0x8000
#define TWIPS_PER_POINT			20

#define IsHeadingStyle(Style)	(Style <= STYLE_HEADING_1 && \
								 Style >= STYLE_HEADING_9)
#define IsKnownStyle(Style)		(IsHeadingStyle(Style) || Style == STYLE_NORMAL)
#define IsStyleCommand(Style)	((Style & 0xFF00) == STYLE_COMMAND)

#define CCHMAXNUMTOSTR			13			// Enuf for 4 billion + parens + null term

typedef struct _styleformat
{
	BYTE	bEffects;
	BYTE	bHeight;
} STYLEFORMAT;

/*
 *	Tab Structure Template
 *
 *	To help keep the size of the tab array small, we use the two high nibbles
 *	of the tab LONG entries in rgxTabs[] to give the tab type and tab leader
 *	(style) values.  The measurer and renderer need to ignore (or implement)
 *	these nibbles.  We also need to be sure that the compiler does something
 *	rational with this idea...
 */

typedef struct tagTab
{
	DWORD	tbPos		: 24;	// 24-bit unsigned tab displacement
	DWORD	tbAlign		: 4;	// 4-bit tab type  (see enum PFTABTYPE)
	DWORD	tbLeader	: 4;	// 4-bit tab style (see enum PFTABSTYLE)
} TABTEMPLATE;

enum PFTABTYPE					// Same as tomAlignLeft, tomAlignCenter,
{								//  tomAlignRight, tomAlignDecimal, tomAlignBar
	PFT_LEFT = 0,				// ordinary tab
	PFT_CENTER,					// center tab
	PFT_RIGHT,					// right-justified tab
	PFT_DECIMAL,				// decimal tab
	PFT_BAR						// Word bar tab (vertical bar)
};

enum PFTABSTYLE					// Same as tomSpaces, tomDots, tomDashes,
{								//  tomLines
	PFTL_NONE = 0,				// no leader
	PFTL_DOTS,					// dotted
	PFTL_DASH,					// dashed
	PFTL_UNDERLINE,				// underlined
	PFTL_THICK,					// thick line
	PFTL_EQUAL					// double line
};

#define PFT_DEFAULT		0xff000000

// Effect flags beyond CHARFORMAT2. Go in high word of CCharFormat::_dwEffects
// which aren't used in CHARFORMAT2 (except for CFE_AUTOCOLOR: 0x40000000,
// CFE_AUTOBACKCOLOR: 0x04000000, CFE_SUBSCRIPT: 0x00010000, and
// CFE_SUPERSCRIPT: 0x00020000), since they overlap	with noneffect parms.
// Use corresponding high-word bits in dwMask2 to access.  Be careful not
// to define new effects that conflict with CFE_AUTOCOLOR, CFE_AUTOBACKCOLOR,
// CFE_SUBSCRIPT, or CFE_SUPERSCRIPT.

//		CFE_SUBSCRIPT		0x00010000			// Defined in richedit.h
//		CFE_SUPERSCRIPT		0x00020000			// Defined in richedit.h
#define CFM2_RUNISDBCS		0x00040000			// Says run is DBCS put 
#define CFE_RUNISDBCS		CFM2_RUNISDBCS		//  into Unicode buffer

#define CFM2_FACENAMEISDBCS	0x00080000			// Says szFaceName is DBCS 
#define CFE_FACENAMEISDBCS	CFM2_FACENAMEISDBCS	//  put into Unicode buffer

#define CFM2_TRUETYPEONLY	0x00100000			// Says that font matching
#define CFE_TRUETYPEONLY	CFM2_TRUETYPEONLY	//  CF should be TrueType

#define	CFM2_DELETED		0x00200000			// Says text was deleted
#define	CFE_DELETED			CFM2_DELETED		//  (roundtrips \deleted)

//		CFE_AUTOBACKCOLOR	0x04000000			// Defined in richedit.h
//		CFE_AUTOCOLOR		0x40000000			// Defined in richedit.h

#define CFM2_CHARFORMAT		0x00008000			// Noneffect mask flags
#define CFM2_USABLEFONT 	0x00004000			// EM_SETFONTSIZE functionality
#define CFM2_SCRIPT			0x00002000			// Uniscribe's script ID
#define	CFM2_NOCHARSETCHECK	0x00001000			// Suppress CharSet check
#define CFM2_HOLDITEMIZE	0x00000800			// Hold off Itemization
#define CFM2_ADJUSTFONTSIZE	0x00000400			// Font size adjustment (SAMECHARSET case only)
#define CFM2_UIFONT			0x00000200			// UI Font (SAMECHARSET case only)
#define CFM2_MATCHFONT		0x00000100			// Match font to charset

/*
 *	CCharFormat
 *
 *	@class
 *		Collects character format methods along with data members
 *		corresponding to CHARFORMAT2.  Only 10 DWORDs are used, whereas
 *		CHARFORMAT2 has 30.  Some bits in the high word of _dwEffects
 *		are used for additional effects, since only CFE_AUTOCOLOR,
 *		CFE_AUTOBACKCOLOR, CFE_SUBSCRIPT, and CFE_SUPERSCRIPT are used
 *		by CHARFORMAT2 (the associated mask bits for the others are used
 *		for noneffect parameters, such as yHeight).
 *
 *	@devnote
 *		Could add extra data for round tripping more RTF info. This data
 *		wouldn't be exposed at the API level (other than via RTF).
 *		The order below is optimized for transfer to CHARFORMAT and for
 *		early out on font lookup, i.e., the most common 2 DWORDs are the
 *		first 2.
 */

class CCharFormat
{
public:
	DWORD		_dwEffects;			// CFE_xxx effects
	BYTE		_bCharSet;			// CharSet
	BYTE		_bPitchAndFamily;	// Pitch and Family
	SHORT		_iFont;				// Index into FONTNAME table
	SHORT		_yHeight;			// Font height
	SHORT		_yOffset;			// Vertical offset from baseline
	COLORREF	_crTextColor;		// Foreground color

	WORD		_wWeight;			// Font weight (LOGFONT value)
	SHORT		_sSpacing;			// Amount to space between letters
	COLORREF	_crBackColor;		// Background color
	LCID		_lcid;				// Locale ID
	SHORT		_sStyle;			// Style handle
	WORD		_wKerning;			// Twip size above which to kern char pair
	BYTE		_bUnderlineType;	// Underline type
	BYTE		_bAnimation;		// Animated text like marching ants 
	BYTE		_bRevAuthor;		// Revision author index
	BYTE		_bReserved;			// Need to 0 this before storing in array
	WORD		_wScript;			// Uniscribe's script ID
	WORD		_wCodePageSave;		// Previous codepage for SYMBOL_CHARSET

	CCharFormat() {}
													//@cmember Apply *<p pCF>
	HRESULT	Apply (const CCharFormat *pCF,			//  to this CCharFormat
				   DWORD dwMask, DWORD dwMask2);
	void	ApplyDefaultStyle (LONG Style);

	BOOL	Compare	(const CCharFormat *pCF) const;	//@cmember Compare this CF
													//  to *<p pCF>
	DWORD	Delta (CCharFormat *pCF,				//@cmember Get difference
				   BOOL fCHARFORMAT) const;			//  mask between this and
													//  *<p pCF>
	BOOL	fSetStyle(DWORD dwMask, DWORD dwMask2) const;
	void	Get (CHARFORMAT2 *pCF, UINT CodePage) const;//@cmember Copies this to
													//	CHARFORMAT pCF
	HRESULT	InitDefault (HFONT hfont);				//@cmember Initialize using
													//  font info from <p hfont>
	void	Set(const CHARFORMAT2 *pCF, UINT CodePage);//@cmember Copy *<p pCF> 
													//  to this CF
};

// NB: don't define the following bit some other way in richedit.h unless you
// implement some other way to say that only PARAFORMAT parms are specified
#define PFM_PARAFORMAT	0x20000000					// Only PARAFORMAT parms used

/*
 *	CParaFormat
 *
 *	@class
 *		Collects related paragraph formatting methods and data
 *
 *	@devnote
 *		Could add extra data for round tripping more RTF and TOM info
 */
class CParaFormat
{
public:
	WORD	_wNumbering;
	WORD	_wEffects;
	LONG	_dxStartIndent;
	LONG	_dxRightIndent;
	LONG	_dxOffset;
	BYTE	_bAlignment;
	BYTE	_bTabCount;
	SHORT	_iTabs;					// Tabs index in CTabs cache
 	LONG	_dySpaceBefore;			// Vertical spacing before para
	LONG	_dySpaceAfter;			// Vertical spacing after para
	LONG	_dyLineSpacing;			// Line spacing depending on Rule	
	SHORT	_sStyle;				// Style handle						
	BYTE	_bLineSpacingRule;		// Rule for line spacing (see tom.doc)
	BYTE	_bOutlineLevel;			// Outline Level					
	WORD	_wShadingWeight;		// Shading in hundredths of a per cent
	WORD	_wShadingStyle;			// Byte 0: style, nib 2: cfpat, 3: cbpat
	WORD	_wNumberingStart;		// Starting value for numbering		
	WORD	_wNumberingStyle;		// Alignment, Roman/Arabic, (), ), ., etc.
	WORD	_wNumberingTab;			// Space bet 1st indent and 1st-line text
	WORD	_wBorderSpace;			// Border-text spaces (nbl/bdr in pts)
	WORD	_wBorderWidth;			// Pen widths (nbl/bdr in half twips)	
	WORD	_wBorders;				// Border styles (nibble/border)	
	DWORD	_dwBorderColor;			// Colors/attribs

	CParaFormat() {}
													//@cmember Add tab at
	HRESULT	AddTab (LONG tabPos, LONG tabType,		// position <p tabPos>
					LONG tabStyle, BOOL fInTable,
					LONG *prgxTabs);
	HRESULT	Apply(const CParaFormat *pPF, DWORD dwMask);//@cmember Apply *<p pPF>
													//  to this CParaFormat
	void	ApplyDefaultStyle (LONG Style);
	HRESULT	DeleteTab(LONG tabPos, LONG *prgxTabs);	//@cmember Delete tab at
													//  <p tabPos>
	DWORD	Delta (CParaFormat *pPF,				//@cmember Set difference
				   BOOL fPARAFORMAT) const;			//  mask between this and
													//  *<p pPF>
	BOOL	fSetStyle(DWORD dwMask) const;
	void	Get (PARAFORMAT2 *pPF2) const;			//@cmember Copy this PF to
													//  *<p pPF>
	char	GetOutlineLevel(){return _bOutlineLevel;}
													//@cmember Get tab position
	HRESULT	GetTab (long iTab, long *pdxptab,		// type, and style
					long *ptbt, long *pstyle,
					const LONG *prgxTabs) const;
	
	const LONG *GetTabs () const;					//@cmember Get ptr to tab array
	BOOL	HandleStyle(LONG Mode);					//@cmember Handle sStyle
													//@cmember Initialize this
	HRESULT	InitDefault (WORD wDefEffects);			//  PF to default values

	BOOL	IsRtlPara() const		{return _wEffects & PFE_RTLPARA;}
	BOOL	InTable() const			{return (_wEffects & PFE_TABLE) != 0;}
	BOOL	IsListNumbered() const	{return IN_RANGE(tomListNumberAsArabic,
												 _wNumbering,
												 tomListNumberAsSequence);}
	BOOL	IsNumberSuppressed() const
					{return (_wNumberingStyle & 0xF00) == PFNS_NONUMBER;}

	LONG	NumToStr(TCHAR *pch, LONG n, DWORD grf = 0) const;
													//@cmember Copy *<p pPF>
	void	Set (const PARAFORMAT2 *pPF2);			//  to this PF
	LONG	UpdateNumber (LONG n, const CParaFormat *pPF) const;

#ifdef DEBUG

	void	ValidateTabs();

#endif // DEBUG
};													 

#define fRtfWrite	 0x1
#define fIndicDigits 0x2

#define	GetTabPos(tab)		((tab) & 0xffffff)
#define	GetTabAlign(tab)	(((tab) >> 24) & 0xf)
#define	GetTabLdr(tab)		((tab) >> 28)

/*
 *	CTabs
 *
 *	@class
 *		CFixArray element for tab and cell arrays
 */
class CTabs
{
public:
	LONG _cTab;					// Count of tabs
	LONG *_prgxTabs;			// Ptr to tab array
};

#endif

/*	FUTURE: Possible Table Storage Layout:
 *
 *	A table could be stored as a sequence of paragraphs with special
 *	characteristics. Each table row starts with a table-row paragraph whose
 *	properties identify the row properties: alignment, StartIndent, line
 *	spacing, line spacing rule, PFE_KEEP and PFE_RTLPARA bits, and border
 *	info, which all work the same way for the row that they work for an
 *	ordinary paragraph.  The offset	field gives the half-gap space between
 *	cells in the row.  A table-row paragraph is identified by the PFM_TABLE
 *	mask field equal to PFE_ROWSTART.
 */


BOOL IsValidTwip(LONG dl);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_devstk.h ===
/*
 *	_DEVSTK.H
 *	
 *	Purpose:
 *		CDevState - handle access to device descriptor
 *	
 *	Authors:
 *		Rick Sailor
 */

#ifndef _DEVSTK_H_
#define _DEVSTK_H_


class CTxtEdit;
class CDrawInfo;

// device descriptor
class CDevState
{
public:
						CDevState(CTxtEdit * ped);

						~CDevState();

    					BOOL    IsValid() const;

						BOOL 	IsMetafile() const;

						BOOL	SetDrawInfo(
									DWORD dwDrawAspect,
									LONG lindex,
									const DVTARGETDEVICE *_ptd,
									HDC hdcDraw,
									HDC hicTargetDev);

						BOOL	SetDC(HDC hdc);

	void 				ResetDrawInfo();

	HDC					GetTargetDD();

	HDC	 				GetRenderDD();

	void				ReleaseDC();

	BOOL				SameDrawAndTargetDevice();

	LONG				ConvertXToTarget(LONG xPixels);

	LONG				ConvertXToDraw(LONG xPixels);

	LONG				ConvertYToDraw(LONG yPixels);

protected:

	CTxtEdit * 			_ped;        // used to GetDC and ReleaseDC

	CDrawInfo *			_pdd;

	HDC					_hicMainTarget;
	
};

#ifndef DEBUG
#include	<_devstki.h>
#endif // DEBUG


#endif // _DEVSTK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_debug.h ===
/*
 *	_DEBUG.H
 *	
 *	Purpose:
 *		RICHEDIT debugging support--commented out in ship builds
 *
 *	History: <nl>
 *		7/29/98	KeithCu Wrote it stealing much from Rich Arneson's code
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _DEBUG_H
#define _DEBUG_H

#define DllExport __declspec(dllexport)

#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)

#define	ASSERTDATA		static char _szFile[] = __FILE__;

BOOL WINAPI DebugMain (HINSTANCE hDLL, DWORD dwReason, LPVOID lpReserved);

#else	// DEBUG

#define	ASSERTDATA

#define DebugMain(hDll, dwReason, lpReserved)

#endif	// DEBUG, else


#if !defined(MACPORT) && (defined(DEBUG) || defined(_RELEASE_ASSERTS_))

//This is the buffer length used for building messages
#define MAXDEBUGSTRLEN (MAX_PATH + MAX_PATH)

#ifndef _RELEASE_ASSERTS_
//The following constants are used to specify and interpret
//packed values in the DWORD flags parameter passed to TraceMsg.
//Each of these is held in a 4-bit field in the DWORD.

//Subsystem field values
#define TRCSUBSYSNONE   0x0
#define TRCSUBSYSDISP   0x1
#define TRCSUBSYSWRAP   0x2
#define TRCSUBSYSEDIT   0x3
#define TRCSUBSYSTS     0x4
#define TRCSUBSYSTOM    0x5
#define TRCSUBSYSOLE    0x6
#define TRCSUBSYSBACK   0x7
#define TRCSUBSYSSEL    0x8
#define TRCSUBSYSHOST   0x9
#define TRCSUBSYSDTE    0xa
#define TRCSUBSYSUNDO   0xb
#define TRCSUBSYSRANG   0xc
#define TRCSUBSYSUTIL   0xd
#define TRCSUBSYSNOTM   0xe
#define TRCSUBSYSRTFR   0xf
#define TRCSUBSYSRTFW   0x10
#define TRCSUBSYSPRT    0x11
#define TRCSUBSYSFE     0x12
#define TRCSUBSYSFONT	0x13

//Severity field values
#define TRCSEVNONE      0x0
#define TRCSEVWARN      0x1
#define TRCSEVERR       0x2
#define TRCSEVASSERT    0x3
#define TRCSEVINFO      0x4
#define TRCSEVMEM       0x5

//Scope field values
#define TRCSCOPENONE    0x0
#define TRCSCOPEEXTERN  0x1
#define TRCSCOPEINTERN  0x2

//Data field values
#define TRCDATANONE     0x0
#define TRCDATAHRESULT  0x1
#define TRCDATASTRING   0x2
#define TRCDATAPARAM    0x3
#define TRCDATADEFAULT  0x4

#endif //!_RELEASE_ASSERTS_

//Debug option flags.  See the macros in this header for setting and testing
//these option flags.
#define OPTUSEDEFAULTS  0x00000001  //Use defaults from win.ini 
                                    //(used only with InitDebugServices).
#define OPTLOGGINGON    0x00000008  //Logging of trace output
#define OPTVERBOSEON    0x00000010  //Subsys, Scope & PID/TID
#define OPTINFOON       0x00000020  //Informational messages
#define OPTTRACEON      0x00000040  //All function tracing on
#define OPTTRACEEXT     0x00000080  //Function tracing only for external functions
#define OPTMEMORYON     0x00000100  //Memory alloc/free tracing on

//no tracing for release with asserts
#ifndef _RELEASE_ASSERTS_
//The following options allow tracing to be enabled for one or more
//specific subsystems.  If OPTTRACEON is set, these will have no effect.
//if OPTTRACEEXT is set, they will enable tracing for all functions in
//the designated subsystem in addition to external functions.
//The SETOPT and ISOPTSET macros should be used for setting and checking
//these options.  INITDEBUGSERVICES can also be used.
#define OPTTRACEDISP    0x00001000  //Function tracing for Display subsystem
#define OPTTRACEWRAP    0x00002000  //Function tracing for Wrapper subsystem
#define OPTTRACEEDIT    0x00004000  //Function tracing for Edit subsystem
#define OPTTRACETS      0x00008000  //Function tracing for TextServices subsystem
#define OPTTRACETOM     0x00010000  //Function tracing for TOM subsystem
#define OPTTRACEOLE     0x00020000  //Function tracing for OLE support subsystem
#define OPTTRACEBACK    0x00040000  //Function tracing for Backing Store subsystem
#define OPTTRACESEL     0x00080000  //Function tracing for Selection subsystem
#define OPTTRACEHOST    0x00100000  //Function tracing for WinHost subsystem
#define OPTTRACEDTE     0x00200000  //Function tracing for DataXfer subsystem
#define OPTTRACEUNDO    0x00400000  //Function tracing for Muli-undo subsystem
#define OPTTRACERANG    0x00800000  //Function tracing for Range subsystem
#define OPTTRACEUTIL    0x01000000  //Function tracing for Utility subsystem
#define OPTTRACENOTM    0x02000000  //Function tracing for Notification Mgr subsystem
#define OPTTRACERTFR    0x04000000  //Function tracing for RTF reader subsystem
#define OPTTRACERTFW    0x08000000  //Function tracing for RTF writer subsystem
#define OPTTRACEPRT     0x10000000  //Function tracing for Printing subsystem
#define OPTTRACEFE      0x20000000  //Function tracing for Far East subsystem
#define OPTTRACEFONT    0x40000000  //Function tracing for Font Cache

//Union for handling tracing flags
//This union is used to decode the
//packed DWORD passed to TraceMsg.
typedef union
{
    struct
    {
        unsigned uData2         :4;
        unsigned uData1         :4;
        unsigned uScope         :4;
        unsigned uSeverity      :4;
        unsigned uSubSystem     :8;
        unsigned uUnused1       :4;
        unsigned uUnused2       :4;
    }       fields;
    DWORD   dw;
} TrcFlags;


//Exported classes and functions.
//Generally, these should not be used directly by the user.
//They should be used via the macros defined in this header.
//This helps to ensure that the parameter lists are well
//formed and keeps references to them from showing up in
//in non-debug builds.

//This class is used to implement the function Entry/Exit
//tracing. By declaring it on the stack at the beginning
//of a function, Entry and Exit messages are automatically
//generated by the constructor and destructor.
class CTrace
{
    public:
        CTrace(DWORD, DWORD, DWORD, LPSTR);
        ~CTrace();

    private:
        TrcFlags trcf;
        char szFileName[MAXDEBUGSTRLEN];
        char szFuncName[80];
};

extern DWORD dwDebugOptions;
extern void SetLogging(BOOL);
void Tracef(DWORD, LPSTR szFmt, ...);
void TraceError(LPSTR sz, LONG sc);

#endif //!_RELEASE_ASSERTS_


typedef BOOL (CALLBACK * PFNASSERTHOOK)(LPSTR, LPSTR, int*);
typedef BOOL (CALLBACK * PFNTRACEHOOK)(DWORD*, DWORD*, DWORD*, LPSTR, int*);
extern PFNTRACEHOOK pfnTrace;
extern PFNASSERTHOOK pfnAssert;
void AssertSzFn(LPSTR, LPSTR, int);
void TraceMsg(DWORD, DWORD, DWORD, LPSTR, int);
DllExport void WINAPI InitDebugServices(DWORD, PFNASSERTHOOK, PFNTRACEHOOK);


//Assert based on boolean f.
#define Assert(f)           AssertSz((f), NULL)

//Assert based on boolean f in debug, resolve to f in non-debug.
#define SideAssert(f)       AssertSz((f), NULL)

//Assert based on boolean f and use string sz in assert message.
#define AssertSz(f, sz)     (!(f) ? AssertSzFn(sz, __FILE__, __LINE__) : 0);

//Set an assert or trace hook function.  The function specified will be called
//before the default functionality executes. Pointers to all parameters are passed
//to the hook to allow it to modify them.  If the hook function returns false,
//default functionality is terminated.  If the hook function returns true, default
//functionality continues with the potentially modified parameters.  pfn can
//be NULL (default functionality only).
#define SETASSERTFN(pfn)      (pfnAssert = (pfn))    

//The following macros provide access to the debug services in this dll.
//Assert macros pop a dialog.  Trace macros output to debug output and
//logfile if enabled.

//Macro for InitDebugServices
#define INITDEBUGSERVICES(f, pfnA, pfnT) InitDebugServices(f, pfnA, pfnT)

//This is a utility macro for internal use.  The user should not need this.
#define MAKEFLAGS(ss, sv, sc, d1, d2) ((ss << 16) + (sv << 12) + (sc << 8)\
            + (d1 << 4) + (d2))

#ifndef _RELEASE_ASSERTS_
//Assert only on debug builds, not on _RELEASE_ASSERTS_ builds
//This is for asserts that contain debug only code
#ifndef AssertNr
#define AssertNr(f)         AssertSz((f), NULL)
#endif

#ifndef AssertNrSz
#define AssertNrSz(f, sz)     (!(f) ? AssertSzFn(sz, __FILE__, __LINE__) : 0);
#endif


//Macro for TraceError
#define TRACEERRSZSC(sz, sc) TraceError(sz, sc)

//Warning based on GetLastError or default message if no last error.
#define TRACEWARN           TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVWARN,\
                                TRCSCOPENONE, TRCDATADEFAULT, TRCDATANONE),\
                                (DWORD)0, (DWORD)0, __FILE__, __LINE__)
//Error based on GetLastError or default message if no last error.
#define TRACEERROR          TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVERR,\
                                TRCSCOPENONE, TRCDATADEFAULT, TRCDATANONE),\
                                (DWORD)0, (DWORD)0, __FILE__, __LINE__)

//Warning based on HRESULT hr
#define TRACEWARNHR(hr)     TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVWARN,\
                                TRCSCOPENONE, TRCDATAHRESULT, TRCDATANONE),\
                                (DWORD)(hr), (DWORD)0, __FILE__, __LINE__)

//Test for a failure HR && warn
#define TESTANDTRACEHR(hr)	if( hr < 0 ) { TRACEWARNHR(hr); }

//Error based on HRESULT hr
#define TRACEERRORHR(hr)    TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVERR,\
                                TRCSCOPENONE, TRCDATAHRESULT, TRCDATANONE),\
                                (DWORD)(hr), (DWORD)0, __FILE__, __LINE__)

//Warning using string sz
#define TRACEWARNSZ(sz)     TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVWARN,\
                                TRCSCOPENONE, TRCDATASTRING, TRCDATANONE),\
                                (DWORD)(DWORD_PTR)(sz), (DWORD)0, __FILE__, __LINE__)

//Trace based on Assert, user passes file name and line
#define TRACEASSERT(szFile, iLine)     TraceMsg (MAKEFLAGS(TRCSUBSYSNONE,\
												TRCSEVASSERT, TRCSCOPENONE,\
												TRCDATANONE, TRCDATANONE),\
												(DWORD)0, (DWORD)0, szFile, iLine)

//Trace based on Assert, user passes file name and line
#define TRACEASSERTSZ(sz, szFile, iLine)     TraceMsg (MAKEFLAGS(TRCSUBSYSNONE,\
												TRCSEVASSERT, TRCSCOPENONE,\
												TRCDATASTRING, TRCDATANONE),\
												(DWORD)(DWORD_PTR)sz, (DWORD)0, szFile, iLine)
//Error using string sz
#define TRACEERRORSZ(sz)    TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVERR,\
                                TRCSCOPENONE, TRCDATASTRING, TRCDATANONE),\
                                (DWORD)(DWORD_PTR)(sz), (DWORD)0, __FILE__, __LINE__)

//Error using string sz
#define TRACEINFOSZ(sz)     TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVINFO,\
                                TRCSCOPENONE, TRCDATASTRING, TRCDATANONE),\
                                (DWORD)(DWORD_PTR)(sz), (DWORD)0, __FILE__, __LINE__)

//Initiate tracing.  This declares an instance of the CTtrace class
//on the stack.  Subsystem (ss), Scope (sc), and the function name
//(sz) must be specifed.  ss and sc are specified using the macros
//defined in this header (i.e. - TRCSUBSYSTOM, TRCSCOPEEXTERN, etc.).
//sz can be a static string.
#define TRACEBEGIN(ss, sc, sz)  CTrace trc(MAKEFLAGS((ss), TRCSEVNONE,\
                                    (sc), TRCDATASTRING, TRCDATANONE),\
                                    (DWORD)(DWORD_PTR)(sz), (DWORD)0, __FILE__)

//Same as TRACEBEGIN but it takes the additional param which is interpreted
//by TraceMsg as a Text Message request.
#define TRACEBEGINPARAM(ss, sc, sz, param) \
                                CTrace trc(MAKEFLAGS((ss), TRCSEVNONE,\
                                    (sc), TRCDATASTRING, TRCDATAPARAM),\
                                    (DWORD)(DWORD_PTR)(sz), (DWORD)(param), __FILE__)

//Set logging to on (f = TRUE) or off (f = FALSE)
#define SETLOGGING(f)       SetLogging(f)

//Set output of process & thread IDs to on (f = TRUE) or off (f = FALSE)
#define SETVERBOSE(f)       ((f) ? (dwDebugOptions |= OPTVERBOSEON) :\
                            (dwDebugOptions &= ~OPTVERBOSEON))

//Set information messages to on (f = TRUE) or off (f = FALSE)
#define SETINFO(f)          ((f) ? (dwDebugOptions |= OPTINFOON) :\
                            (dwDebugOptions &= ~OPTINFOON))

//Set information messages to on (f = TRUE) or off (f = FALSE)
#define SETMEMORY(f)          ((f) ? (dwDebugOptions |= OPTMEMORYON) :\
                            (dwDebugOptions &= ~OPTMEMORYON))

//Set tracing for all functions to on (f = TRUE) or off (f = FALSE).
//If this is set to "on", external and subsystem level tracing
//has no effect since all function traces are enabled. If it is off,
//external and subsystem level tracing remain in whatever state they
//have been set to.
#define SETTRACING(f)       ((f) ? (dwDebugOptions |= OPTTRACEON) :\
                            (dwDebugOptions &= ~OPTTRACEON))

//Set tracing for EXTERNAL scope calls only to on (f = TRUE)
//or off (f = FALSE).  This is only effective if OPTTRACEON has not
//been set.
#define SETTRACEEXT(f)      ((f) ? (dwDebugOptions |= OPTTRACEEXT) :\
                            (dwDebugOptions &= ~OPTTRACEEXT))

//This macro turns all function tracing off.
#define SETALLTRACEOFF      (dwDebugOptions &= ~(OPTTRACEEXT | OPTTRACEON | 0xfffff000))

//This macro sets a given option or options (if they are or'ed together)
//to on (f = TRUE), or off (f = FALSE).  It cannot be used to set logging.
#define SETOPT(opt, f)      ((f) ? (dwDebugOptions |= (opt)) :\
                            (dwDebugOptions &= (~(opt))))
                             
//This macro determines the state of a given option.
#define ISOPTSET(opt)       ((opt) & dwDebugOptions)

//Set an assert or trace hook function.  The function specified will be called
//before the default functionality executes. Pointers to all parameters are passed
//to the hook to allow it to modify them.  If the hook function returns false,
//default functionality is terminated.  If the hook function returns true, default
//functionality continues with the potentially modified parameters.  pfn can
//be NULL (default functionality only).
#define SETTRACEFN(pfn)      (pfnTrace = (pfn))    

//The following option tests are explicitly defined for convenience.
#define fLogging            (OPTLOGGINGON & dwDebugOptions)
#define fVerbose            (OPTVERBOSEON & dwDebugOptions)
#define fInfo               (OPTINFOON & dwDebugOptions)
#define fTrace              (OPTTRACEON & dwDebugOptions)
#define fTraceExt           (OPTTRACEEXT & dwDebugOptions)


#else //_RELEASE_ASSERTS_
//Functions not used by release build with asserts
#ifndef AssertNr
#define AssertNr(f)
#endif
#ifndef AssertNrSz
#define AssertNrSz(f, sz)
#endif
#define Tracef	;/##/
#define TRACEERRSZSC(sz, sc)
#define TRACEWARN
#define TRACEERROR
#define TRACEWARNHR(hr)
#define TESTANDTRACEHR(hr)
#define TRACEERRORHR(hr)
#define TRACEWARNSZ(sz)
#define TRACEASSERT(szFile, iLine)
#define TRACEASSERTSZ(sz, szFile, iLine)
#define TRACEERRORSZ(sz)
#define TRACEINFOSZ(sz)
#define TRACEBEGIN(ss, sc, sz)
#define TRACEBEGINPARAM(ss, sc, sz, param)
#define SETLOGGING(f)
#define SETVERBOSE(f)
#define SETINFO(f)
#define SETMEMORY(f)
#define SETTRACING(f)
#define SETTRACEEXT(f)
#define SETALLTRACEOFF
#define SETOPT(opt, f)
#define ISOPTSET(opt)
#define SETTRACEFN(pfn)

#define TraceError(_sz, _sc)  // MACPORT ADDED THIS - TraceError


#endif //_RELEASE_ASSERTS_

#else //DEBUG,_RELEASE_ASSERTS_

#define Tracef	;/##/
#define INITDEBUGSERVICES(f, pfnA, pfnT)
#define TRACEERRSZSC(sz, sc)
#ifndef Assert
#define Assert(f)
#endif
#ifndef SideAssert
#define SideAssert(f) (f)
#endif
#ifndef AssertSz
#define AssertSz(f, sz)
#endif
#ifndef AssertNr
#define AssertNr(f)
#endif
#ifndef AssertNrSz
#define AssertNrSz(f, sz)
#endif
#define TRACEWARN
#define TRACEERROR
#define TRACEWARNHR(hr)
#define TESTANDTRACEHR(hr)
#define TRACEERRORHR(hr)
#define TRACEWARNSZ(sz)
#define TRACEASSERT(szFile, iLine)
#define TRACEASSERTSZ(sz, szFile, iLine)
#define TRACEERRORSZ(sz)
#define TRACEINFOSZ(sz)
#define TRACEBEGIN(ss, sc, sz)
#define TRACEBEGINPARAM(ss, sc, sz, param)
#define SETLOGGING(f)
#define SETVERBOSE(f)
#define SETINFO(f)
#define SETMEMORY(f)
#define SETTRACING(f)
#define SETTRACEEXT(f)
#define SETALLTRACEOFF
#define SETOPT(opt, f)
#define ISOPTSET(opt)
#define SETASSERTFN(pfn)
#define SETTRACEFN(pfn)

#define AssertSzFn(sz, __FILE__, __LINE__)  // MACPORT ADDED THIS - Dbug32AssertSzFn
#define TraceError(_sz, _sc)  // MACPORT ADDED THIS - TraceError

#endif

#endif //DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_dispprt.h ===
/*
 *  _DISPPRT.H
 *  
 *  Purpose:
 *      CDisplayPrinter class. Multi-line display for printing.
 *  
 *  Authors:
 *      Original RichEdit code: David R. Fulmer
 *      Christian Fortini
 *      Jon Matousek
 */

#ifndef _DISPPRT_H
#define _DISPPRT_H

#include "_dispml.h"


class CDisplayPrinter : public CDisplayML
{
public:
					CDisplayPrinter (
						CTxtEdit* ped, 
						HDC hdc, 
						LONG x, 
						LONG y, 
						SPrintControl prtcon);

    virtual BOOL    IsMain() const { return FALSE; }

	inline RECT 	GetPrintView( void ) { return rcPrintView; }
	inline void 	SetPrintView( const RECT & rc ) { rcPrintView = rc; }

	inline RECT		GetPrintPage(void) { return _rcPrintPage;}
	inline void		SetPrintPage(const RECT &rc) {_rcPrintPage = rc;}

    // Format range support
    LONG    		FormatRange(LONG cpFirst, LONG cpMost, BOOL fWidowOrphanControl);

	// Natural size calculation
	virtual HRESULT	GetNaturalSize(
						HDC hdcDraw,
						HDC hicTarget,
						DWORD dwMode,
						LONG *pwidth,
						LONG *pheight);

	virtual BOOL	IsPrinter() const;

	void			SetPrintDimensions(RECT *prc);


protected:

	RECT			rcPrintView;	// for supporting client driven printer banding.
	RECT			_rcPrintPage;	// the entire page size

	SPrintControl	_prtcon;		// Control print behavior
	LONG			_cpForNumber;	// cp of cached number.
	WORD			_wNumber;		// Cached value of paragraph number
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_devstki.h ===
INLINE	CDevDesc::CDevDesc(CTxtEdit * ped) : _ped(ped), _pdd(NULL)
{
	// Header does the work
}

INLINE BOOL CDevDesc::IsValid() const         
{
	return _pdd != NULL;
}

INLINE HDC CDevDesc::GetRenderDC()
{
	HDC hdc = NULL;

	if (NULL == _pdd)
	{
		// We don't already have on so try to get one. This is only valid when
		// we are inplace active.
		SetDrawInfo(
			DVA_ASPECT
			-1,
			NULL,
			NULL,
			hicTarget);
	}

	if (_pdd != NULL)
	{
		hdc = _pdd->GetDC();
	}

	return hdc;
}

INLINE HDC CDevDesc::GetTargetDC()
{
	if (_pdd != NULL)
	{
		return _pdd->GetTargetDC();
	}

	if (NULL != _hicMainTarget)
	{
		return _hicMainTarget;
	}

	return GetRenderDC();
}

INLINE void	CDevDesc::ResetDrawInfo()
{
	// We shouldn't reset 
	Assert
	CDrawInfo *pdd = _pdd;
	_pdd = _pdd->Pop();
	delete pdd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_dispml.h ===
/*
 *  _DISPML.H
 *  
 *  Purpose:
 *      CDisplayML class. Multi-line display.
 *  
 *  Authors:
 *      Original RichEdit code: David R. Fulmer
 *      Christian Fortini
 *      Murray Sargent
 */

#ifndef _DISPML_H
#define _DISPML_H

#include "_disp.h"


class CDisplayML : public CDisplay, public CLineArray
{
public: 

#ifdef DEBUG
	BOOL	Invariant(void) const;
#endif 

    friend class CLinePtr;
    friend class CLed;
	friend BOOL CTxtEdit::OnDisplayBand(const RECT *prc, BOOL fPrintFromDraw);
	friend class CDisplayPrinter;

private:
    LONG _cpCalcMax;        // last cp for which line breaks have been calc'd + 1
    LONG _yCalcMax;         // height of calculated lines
    LONG _cpWait;           // cp WaitForRecalc() is waiting for (or < 0)
    LONG _yWait;            // y WaitForRecalc() is waiting for (or < 0)

    LONG  _yScroll;         // vertical scroll position of visible view
    LONG  _dyFirstVisible;  // offset from top of view to first visible line
    LONG  _iliFirstVisible; // index of first visible line

    LONG _xWidthMax;        // max width of this display (in log unit)
    LONG _yHeightMax;       // max height of this display (-1 for infinite)
    LONG _xWidth;           // width of longest calculated line
    LONG _yHeight;          // sum of heights of calculated lines
    LONG _cpMin;            // first character in display

    CDevDesc *_pddTarget;     // target device (if any).

	unsigned long _fInRecalcScrollBars:1;	// we're trying to recalc scroll
											// bars
    
private:
    // Helpers
            void    InitVars();
			void 	RecalcScrollBars();
			LONG	ConvertScrollToYPos(LONG yPos);
			LONG	GetMaxYScroll() const;
			BOOL	CreateEmptyLine();
			LONG	CalcScrollHeight(LONG yHeight) const;
			void	RebindFirstVisible();

    // Line breaking
            BOOL    RecalcLines(BOOL fWait = FALSE);
            BOOL    RecalcLines(const CRchTxtPtr &tpFirst, LONG cchOld, LONG cchNew,
                        BOOL fBackground, BOOL fWait, CLed *pled);
            BOOL    RecalcSingleLine(CLed *pled);
            LONG    CalcDisplayWidth();

    // Rendering
    virtual void    Render(const RECT &rcView, const RECT &rcRender);

    // Scrolling and scroller bars
            void    DeferUpdateScrollBar();
            BOOL    DoDeferredUpdateScrollBar();
    virtual BOOL    UpdateScrollBar(INT nBar, BOOL fUpdateRange = FALSE );

protected:

	virtual LONG	GetMaxXScroll() const;

public:
 	virtual	LONG	ConvertYPosToScrollPos(LONG yPos);

           CDisplayML (CTxtEdit* ped);
    virtual CDisplayML::~CDisplayML();

    virtual BOOL    Init();

    // Device context management
    virtual BOOL    SetMainTargetDC(HDC hdc, LONG xWidthMax);
    virtual BOOL    SetTargetDC(HDC hdc, LONG dxpInch = -1, LONG dypInch = -1);

    // Getting properties
    virtual void    InitLinePtr ( CLinePtr & );
    virtual const	CDevDesc*     GetDdTarget() const       {return _pddTarget;}
    
    virtual BOOL    IsMain() const							{return TRUE;}
			BOOL	IsInOutlineView() const					{return _ped->IsInOutlineView();}
	
    // maximum height and width
    virtual LONG    GetMaxWidth() const                     {return _xWidthMax;}
    virtual LONG    GetMaxHeight() const                    {return 0;}
	virtual LONG	GetMaxPixelWidth() const;

    // Width, height and line count (of all text)
    virtual LONG    GetWidth() const                        {return _xWidth;}
    virtual LONG    GetHeight() const                       {return _yHeight;}
	virtual LONG	GetResizeHeight() const;
    virtual LONG    LineCount() const;

    // Visible view properties
    virtual LONG    GetCliVisible(
						LONG *pcpMostVisible = NULL,
						BOOL fLastCharOfLastVisible = FALSE) const;

    virtual LONG    GetFirstVisibleLine() const             {return _iliFirstVisible;}
    
    // Line info
    virtual LONG    GetLineText(LONG ili, TCHAR *pchBuff, LONG cchMost);
    virtual LONG    CpFromLine(LONG ili, LONG *pyLine = NULL);
			LONG    YposFromLine(LONG ili);
    virtual LONG    LineFromYpos(LONG yPos, LONG *pyLine = NULL, LONG *pcpFirst = NULL);
    virtual LONG    LineFromCp(LONG cp, BOOL fAtEnd) ;

    // Point <-> cp conversion
    virtual LONG    CpFromPoint(
    					POINT pt, 
						const RECT *prcClient,
    					CRchTxtPtr * const ptp, 
    					CLinePtr * const prp, 
    					BOOL fAllowEOL,
						HITTEST *pHit = NULL,
						CDispDim *pdispdim = NULL,
						LONG *pcpActual = NULL);

    virtual LONG    PointFromTp (
						const CRchTxtPtr &tp, 
						const RECT *prcClient,
						BOOL fAtEnd,	
						POINT &pt,
						CLinePtr * const prp, 
						UINT taMode,
						CDispDim *pdispdim = NULL);

    // Line break recalc
			BOOL    StartBackgroundRecalc();
    virtual VOID    StepBackgroundRecalc();
    virtual BOOL    RecalcView(BOOL fUpdateScrollBars, RECT* prc = NULL);
    virtual BOOL    WaitForRecalc(LONG cpMax, LONG yMax);
    virtual BOOL    WaitForRecalcIli(LONG ili);
    virtual BOOL    WaitForRecalcView();

    // Complete updating (recalc + rendering)
    virtual BOOL    UpdateView(const CRchTxtPtr &tpFirst, LONG cchOld, LONG cchNew);

    // Scrolling 
    virtual LRESULT VScroll(WORD wCode, LONG xPos);
    virtual VOID    LineScroll(LONG cli, LONG cch);
	virtual VOID	FractionalScrollView ( LONG yDelta );
	virtual VOID	ScrollToLineStart(LONG iDirection);
	virtual LONG	CalcYLineScrollDelta ( LONG cli, BOOL fFractionalFirst );
    virtual BOOL    ScrollView(LONG xScroll, LONG yScroll, BOOL fTracking, BOOL fFractionalScroll);
    virtual LONG    GetYScroll() const;
    virtual LONG    GetScrollRange(INT nBar) const;
	virtual	LONG	AdjustToDisplayLastLine(LONG yBase,	LONG yScroll);

    // Selection 
    virtual BOOL    InvertRange(LONG cp, LONG cch, SELDISPLAYACTION selAction);

	// Natural size calculation
	virtual HRESULT	GetNaturalSize(
						HDC hdcDraw,
						HDC hicTarget,
						DWORD dwMode,
						LONG *pwidth,
						LONG *pheight);

    // Misc. methods
            void    FindParagraph(LONG cpMin, LONG cpMost, LONG *pcpMin, LONG *pcpMost);

	virtual CDisplay *Clone() const;

#ifdef DEBUG
            void    CheckLineArray() const;
            void    DumpLines(LONG iliFirst, LONG cli);
            void    CheckView();
			BOOL	VerifyFirstVisible(LONG *pHeight = NULL);
#endif
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_devdsc.h ===
/*
 *	_DEVDSC.H
 *	
 *	Purpose:
 *		CDevDesc (Device Descriptor) class
 *	
 *	Authors:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 */

#ifndef _DEVDSC_H
#define _DEVDSC_H


class CTxtEdit;

// device descriptor
class CDevDesc
{
	friend class CMeasurer;
protected:
	CTxtEdit * _ped;        // used to GetDC and ReleaseDC
	
	HDC 	_hdc;			// hdc for rendering device
	BOOL	_fMetafile;		// Is this device a metafile.

	SHORT	_dxpInch;		// device units per horizontal "inch"
	SHORT	_dypInch;		// device units per vertical "inch"

	HDC		GetScreenDC () const;
	void	ReleaseScreenDC (HDC hdc) const;

public:
	CDevDesc(CTxtEdit * ped)
	{
		_fMetafile = FALSE;
		_ped = ped;
		_dxpInch = 0;
		_hdc = NULL;
		_dypInch = 0;
	}

    // Test validity of device descriptor 
    // (whether SetDC has been properly called)
    BOOL    IsValid() const         {return _dxpInch != 0 && _dypInch != 0;}

	BOOL 	IsMetafile() const
	{
		if(!_hdc)
			return FALSE;

		return _fMetafile;
	}

	
	BOOL	SetDC(HDC hdc, LONG dxpInch = -1, LONG dypInch = -1);

	void	SetMetafileDC(
				HDC hdcMetafile, 
				LONG xMeasurePerInch,
				LONG yMeasurePerInch);

	void 	ResetDC() { SetDC(NULL); }

	//REVIEW (keithcu) GetScreenDC/ReleaseScreenDC needed?
	HDC	 	GetDC() const
	{
		if(_hdc)
			return _hdc;
		return GetScreenDC();
	}

	void	ReleaseDC(HDC hdc) const
	{
		if(!_hdc)
			ReleaseScreenDC(hdc);
	}

	// Methods for converting between pixels and himetric
	LONG 	HimetricXtoDX(LONG xHimetric) const { return W32->HimetricXtoDX(xHimetric, _dxpInch); }
	LONG 	HimetricYtoDY(LONG yHimetric) const { return W32->HimetricYtoDY(yHimetric, _dypInch); }
	LONG	DXtoHimetricX(LONG dx)  const { return W32->DXtoHimetricX(dx, _dxpInch); }
	LONG	DYtoHimetricY(LONG dy) const { return W32->DYtoHimetricY(dy, _dypInch); }

	LONG 	DXtoLX(LONG x) const;
	LONG 	DYtoLY(LONG y) const;
	void 	DPtoLP(POINT &ptDest, const POINT &ptSrc) const;
	void 	DRtoLR(RECT &rcDest, const RECT &rcSrc) const;
	
#ifdef DEBUG
	LONG	LXtoDX(LONG x) const;
	LONG	LYtoDY(LONG y) const;
#else
	LONG	LXtoDX(LONG x) const	{return ((x * _dxpInch) + LX_PER_INCH / 2) / LX_PER_INCH;}
	LONG	LYtoDY(LONG y) const	{return ((y * _dypInch) + LY_PER_INCH / 2) / LY_PER_INCH;}
#endif
	void 	LPtoDP(POINT &ptDest, const POINT &ptSrc) const;
	void 	LRtoDR(RECT &rcDest, const RECT &rcSrc) const;

	BOOL 	SameDevice(const CDevDesc *pdd) const
	{
		return (_dxpInch == pdd->_dxpInch) && (_dypInch == pdd->_dypInch)
			? TRUE : FALSE;
	}

	LONG	ConvertXToDev(LONG x, const CDevDesc *pdd) const
	{
		return MulDiv(x, _dxpInch, pdd->_dxpInch);
	}

	LONG	ConvertYToDev(LONG y, const CDevDesc *pdd) const
	{
		return MulDiv(y, _dypInch, pdd->_dxpInch);
	}

	// Assignment
	CDevDesc& 	operator = (const CDevDesc& dd)
	{
		_hdc = dd._hdc;
		_dxpInch = dd._dxpInch;
		_dypInch = dd._dypInch;
		return *this;
	}

	// Compares two device descriptors
	BOOL 	operator == (const CDevDesc& dd) const
	{
		return 	_hdc == dd._hdc;
	}

	BOOL 	operator != (const CDevDesc& dd) const
	{
		return !(*this == dd);
	}

	LONG	GetDxpInch() const
	{
		AssertSz(_dxpInch != 0, "CDevDesc::GetDxpInch_dxpInch is 0");
		return _dxpInch;
	}

	LONG	GetDypInch() const
	{
		AssertSz(_dypInch != 0, "CDevDesc::GetDypInch _dypInch is 0");
		return _dypInch;
	}
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_dfreeze.h ===
/*	@doc INTERNAL
 *
 *	@module _DFREEZE.H  Classes handle freezing the display |
 *	
 *	This module declares class used by logic to handle freezing the display
 *
 *	History: <nl>
 *		2/8/96	ricksa	Created
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#ifndef _DFREEZE_H
#define _DFREEZE_H

/*
 *	CAccumDisplayChanges
 *	
 * 	@class	This class is used to accumulate of all update to the display so
 *			so that at a later time the display can ask to be updated to 
 *			reflect all the previous updates.
 */
class CAccumDisplayChanges
{
//@access Public Methods
public:
				CAccumDisplayChanges();		//@cmember Constructor

				~CAccumDisplayChanges();	//@cmember Destructor

	void		AddRef();					//@cmember Add a reference

	LONG		Release();					//@cmember Release a reference

	void		UpdateRecalcRegion(			//@cmember Update the region 
					LONG cp,				// for recalc
					LONG cchDel,
					LONG cchNew);

	void		GetUpdateRegion(			//@cmember Get the update 
					LONG *pcpStart,			// region
					LONG *pcchNew,
					LONG *pcchDel,
					BOOL *pfUpdateCaret = NULL,
					BOOL *pfScrollIntoView = NULL,
					BOOL *pfRedisplayOnThaw = NULL);

	void		SaveUpdateCaret(			//@cmember Save update
					BOOL fScrollIntoView);	// caret state

	void		SetNeedRedisplayOnThaw(BOOL fNeedRedisplay)
	{
		_fNeedRedisplay = fNeedRedisplay;
	}
//@access Private Data
private:

	LONG		_cRefs;						//@cmember Reference count

	LONG		_cpMin;						//@cmember Min cp of change w.r.t.
											// original text array

	LONG		_cpMax;						//@cmember Max cp of change w.r.t.
											// original text array

	LONG		_delta;						//@cmember net # of chars changed

	BOOL		_fUpdateCaret:1;			//@cmember Whether update
											// caret required

	BOOL		_fScrollIntoView:1;			//@cmember first parm to 

	BOOL		_fNeedRedisplay:1;			//@cmember redisplay entire control on thaw
};

/*
 *	CAccumDisplayChanges::CAccumDisplayChanges()
 *
 *	@mfunc
 *		Initialize object for accumulating display changes
 */
inline CAccumDisplayChanges::CAccumDisplayChanges() 
	: _cRefs(1), _cpMin(CP_INFINITE), _fUpdateCaret(FALSE)
{
	// Header does all the work
}

/*
 *	CAccumDisplayChanges::~CAccumDisplayChanges()
 *
 *	@mfunc
 *		Free object
 *
 *	@devnote:
 *		This only serves a purpose in debug mode
 *
 */
inline CAccumDisplayChanges::~CAccumDisplayChanges()
{
	// Nothing to clean up
}

/*
 *	CAccumDisplayChanges::~CAccumDisplayChanges()
 *
 *	@mfunc
 *		Add another reference to this object
 */
inline void CAccumDisplayChanges::AddRef()
{
	++_cRefs;
}

/*
 *	CAccumDisplayChanges::Release()
 *
 *	@mfunc
 *		Release a reference to this object
 *
 *	@rdesc
 *		0 - no more references
 *		~0 - there are still outstanding references
 *
 *	@devnote:
 *		If 0 is returned the information should be retrieved from
 *		this object and passed on to the display so that it can
 *		update itself.
 *
 */
inline LONG CAccumDisplayChanges::Release()
{
	// When the reference count is 0, it is time to update the display.
	return --_cRefs;	
}

/*
 *	CAccumDisplayChanges::SaveUpdateCaret()
 *
 *	@mfunc
 *		Save parameters for update caret
 */
inline void CAccumDisplayChanges::SaveUpdateCaret(
	BOOL fScrollIntoView)		//@parm First parm for UpdateCaret
{
	_fUpdateCaret = TRUE;

	if (!_fScrollIntoView)
		_fScrollIntoView = fScrollIntoView;
}

#endif // _DFREEZE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_doc.h ===
/*
 *  @doc INTERNAL
 *
 *  @module _DOC.H  CTxtStory declaration |
 *  
 *  Purpose:
 *      Encapsulate the plain-text document data (text blocks, cchText)
 *  
 *  Original Authors: <nl>
 *      Christian Fortini <nl>
 *      Murray Sargent <nl>
 *
 *  History: <nl>
 *      6/25/95 alexgo  commented and cleaned up
 *
 */

#ifndef _DOC_H
#define _DOC_H

#include "_array.h"

#define cbBlockCombine  CbOfCch(3072)
#define cbBlockMost     CbOfCch(49152)
#define cbBlockInitial  CbOfCch(4096)
#define cchGapInitial   128
#define cchBlkCombmGapI (CchOfCb(cbBlockCombine) - cchGapInitial)
#define cchBlkInitmGapI (CchOfCb(cbBlockInitial) - cchGapInitial)

#define cchBlkInsertmGapI   (CchOfCb(cbBlockInitial)*5 - cchGapInitial)

class CDisplay;
class CTxtPtr;
class CTxtArray;

/*
 *  CTxtRun
 *
 *  @class  Formalizes a run of text. A range of text with same attribute,
 * (see CFmtDesc) or within the same line (see CLine), etc. Runs are kept
 * in arrays (see CArray) and are pointed to by CRunPtr's of various kinds.
 * In general the character position of a run is computed by summing the
 * length of all preceding runs, altho it may be possible to start from
 * some other cp, e.g., for CLines, from CDisplay::_cpFirstVisible.
 */

class CTxtRun
{
//@access Public Methods and Data
public:
    CTxtRun()   {_cch = 0;}         //@cmember Constructor
    LONG _cch;                      //@cmember Count of characters in run
};

/*
 *  CTxtBlk
 *
 *  @class  A text block; a chunk of UNICODE text with a buffer gap to allow
 *  for easy insertions and deletions.
 *
 *  @base   protected | CTxtRun
 *
 *  @devnote    A text block may have four states: <nl>
 *      NULL:   No data allocated for the block <nl>
 *              <md CTxtBlk::_pch> == NULL  <nl>
 *              <md CTxtRun::_cch> == 0     <nl>
 *              <md CTxtBlk::_ibGap> == 0   <nl>
 *              <md CTxtBlk::_cbBlock> == 0 <nl>
 *
 *      empty:  All of the available space is a buffer gap <nl>
 *              <md CTxtBlk::_pch> != NULL  <nl>
 *              <md CTxtRun::_cch> == 0     <nl>
 *              <md CTxtBlk::_ibGap> == 0   <nl>
 *              <md CTxtBlk::_cbBlock> <gt>= 0  <nl>
 *
 *      normal: There is both data and a buffer gap <nl>
 *              <md CTxtBlk::_pch> != NULL  <nl>
 *              <md CTxtRun::_cch> != 0     <nl>
 *              <md CTxtBlk::_ibGap> != 0   <nl>
 *              <md CTxtBlk::_cbBlock> <gt>= 0  <nl>
 *      
 *      full:   The buffer gap is of zero size <nl>
 *              <md CTxtBlk::_pch> != NULL  <nl>
 *              <md CTxtRun::_cch> <gt>= 0  <nl>
 *              <md CTxtBlk::_ibGap> <gt> 0 <nl>
 *              <md CTxtBlk::_cbBlock> == _cch * sizeof(WCHAR) <nl>
 *
 *  The position of the buffer gap is given by _ibGap.  With _cch and _cbBlock,
 *  it's possible to figure out the *size* of the gap by simply calculating:
 *  <nl>
 *      size = _cbBlock - (_cch * sizeof(character))
 *
 */

class CTxtBlk : public CTxtRun
{
    friend class CTxtPtr;
    friend class CTxtArray;

//@access Protected Methods
protected:
                                    //@cmember  Constructor
    CTxtBlk()   {InitBlock(0);}
                                    //@cmember  Destructor
    ~CTxtBlk()  {FreeBlock();}

                                    //@cmember  Initializes the block to the
                                    //# of bytes given by <p cb>    
    BOOL    InitBlock(LONG cb);
                                    //@cmember  Sets a block to the NULL state
    VOID    FreeBlock();
                                    //@cmember  Moves the buffer gap in a
                                    //block 
    VOID    MoveGap(LONG ichGap);
                                    //@cmember  Resizes a block to <p cbNew>
                                    //bytes
    BOOL    ResizeBlock(LONG cbNew);

//@access Private Data
private:
                                    //@cmember  Pointer to the text data
    WCHAR   *_pch;          
                                    //@cmember  BYTE offset of the gap
    LONG    _ibGap;         
                                    //@cmember  size of the block in bytes
    LONG    _cbBlock;       
};


/*
 *  CTxtArray
 *
 *  @class  A dynamic array of <c CTxtBlk> classes
 *
 *  @base public | CArray<lt>CTxtBlk<gt>
 */
class CTxtArray : public CArray<CTxtBlk>
{
    friend class CTxtPtr;
    friend class CTxtStory;

//@access   Public methods
public:
#ifdef DEBUG
                                    //@cmember  Invariant support
    BOOL Invariant() const;
#endif  // DEBUG
                                    //@cmember  Constructor
    CTxtArray();
                                    //@cmember  Destructor
    ~CTxtArray();
                                    //@cmember  Gets the total number of
                                    //characters in the array.
    LONG    CalcTextLength() const;

    // Get access to cached CCharFormat and CParaFormat structures
    const CCharFormat*  GetCharFormat(LONG iCF);
    const CParaFormat*  GetParaFormat(LONG iPF);

    LONG    Get_iCF()           {return _iCF;}
    LONG    Get_iPF()           {return _iPF;}
    void    Set_iCF(LONG iCF)   {_iCF = (SHORT)iCF;}
    void    Set_iPF(LONG iPF)   {_iPF = (SHORT)iPF;}

//@access Private methods
private:
                                    //@cmember  Adds cb blocks
    BOOL    AddBlock(LONG itbNew, LONG cb);
                                    //@cmember  Removes ctbDel blocks
    void    RemoveBlocks(LONG itbFirst, LONG ctbDel);
                                    //@cmember  Combines blocks adjacent to itb
    void    CombineBlocks(LONG itb);
                                    //@cmember  Splits a block
    BOOL    SplitBlock(LONG itb, LONG ichSplit, LONG cchFirst,
                LONG cchLast, BOOL fStreaming);
                                    //@cmember  Shrinks all blocks to minimal
                                    //          size
    void    ShrinkBlocks();     
                                    //@cmember  Copies chunk of text into
                                    //          location given
    LONG    GetChunk(TCHAR **ppch, LONG cch, TCHAR *pchChunk, LONG cchCopy) const;

    LONG    _cchText;               //@cmember Total text character count
    SHORT   _iCF;                   //@cmember Default CCharFormat index
    SHORT   _iPF;
};


class CBiDiLevel
{
public:
    BOOL operator == (const CBiDiLevel& level) const
    {
        return _value == level._value && _fStart == level._fStart;
    }
    BOOL operator != (const CBiDiLevel& level) const
    {
        return _value != level._value || _fStart != level._fStart;
    }

    BYTE    _value;             // embedding level (0..15)
    BYTE    _fStart :1;         // start a new level e.g. "{{abc}{123}}"
};

/*
 *  CFormatRun
 *
 *  @class  A run of like formatted text, where the format is indicated by an
 *  and index into a format table
 *
 *  @base   protected | CTxtRun
 */
class CFormatRun : public CTxtRun
{
//@access   Public Methods
public:
    friend class CFormatRunPtr;
    friend class CTxtRange;
    friend class CRchTxtPtr;

    BOOL SameFormat(CFormatRun* pRun)
    {
        return  _iFormat == pRun->_iFormat &&
                _level._value == pRun->_level._value &&
                _level._fStart == pRun->_level._fStart;
    }

    short   _iFormat;           //@cmember index of CHARFORMAT/PARAFORMAT struct
    CBiDiLevel _level;          //@cmember BiDi level
};

//@type CFormatRuns | An array of CFormatRun classes
typedef CArray<CFormatRun> CFormatRuns;


/*
 *  CTxtStory
 *
 *  @class
 *      The text "Document".  Maintains the state information related to the
 *      actual data of a document (such as text, formatting information, etc.)
 */

class CTxtStory
{
    friend class CTxtPtr;
    friend class CRchTxtPtr;
    friend class CReplaceFormattingAE;

//@access Public Methods
public:
    CTxtStory();                //@cmember  Constructor
    ~CTxtStory();               //@cmember  Destructor

                                //@cmember  Get total text length
    LONG GetTextLength() const
        {return _TxtArray._cchText;}

                                //@cmember  Get Paragraph Formatting runs
    CFormatRuns *GetPFRuns()    {return _pPFRuns;}
                                //@cmember  Get Character Formatting runs
    CFormatRuns *GetCFRuns()    {return _pCFRuns;}
                                
    void DeleteFormatRuns();    //@cmember  Converts to plain text from rich

    const CCharFormat*  GetCharFormat(LONG iCF)
                            {return _TxtArray.GetCharFormat(iCF);}
    const CParaFormat*  GetParaFormat(LONG iPF)
                            {return _TxtArray.GetParaFormat(iPF);}

    LONG Get_iCF()          {return _TxtArray.Get_iCF();}
    LONG Get_iPF()          {return _TxtArray.Get_iPF();}
    void Set_iCF(LONG iCF)  {_TxtArray.Set_iCF(iCF);}
    void Set_iPF(LONG iPF)  {_TxtArray.Set_iPF(iPF);}

#ifdef DEBUG
    void DbgDumpStory(void);    // Debug story dump member
#endif

//@access   Private Data
private:
    CTxtArray       _TxtArray;  //@cmember  Plain-text runs
    CFormatRuns *   _pCFRuns;   //@cmember  Ptr to Character-Formatting runs
    CFormatRuns *   _pPFRuns;   //@cmember  Ptr to Paragraph-Formatting runs
};

#endif      // ifndef _DOC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_disp.h ===
/*
 *  _DISP.H
 *  
 *  Purpose:
 *		DISP class
 *  
 *  Authors:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _DISP_H
#define _DISP_H

#include "_devdsc.h"
#include "_line.h"
#include "_edit.h"

class CDisplay;
class CLed;
class CLinePtr;
class CTxtStory;
class CTxtEdit;
class CRchTxtPtr;
class CTxtRange;
class CTxtSelection;

#define INVALID_ZOOM_DENOMINATOR 0

// Auto scroll timing
#define cmsecScrollDelay	500
#define cmsecScrollInterval	50


class CDrawInfo;

// ============================  CLed  ====================================
// Line Edit Descriptor - describes impact of an edit on line breaks

class CLed
{
public:
	LONG _cpFirst;			// cp of first affected line
	LONG _iliFirst;			// index of first affected line
	LONG _yFirst;			// y offset of first affected line

	LONG _cpMatchOld;		// pre-edit cp of first matched line
	LONG _iliMatchOld;		// pre-edit index of first matched line
	LONG _yMatchOld;		// pre-edit y offset of first matched line

	LONG _cpMatchNew;		// post-edit cp of first matched line
	LONG _iliMatchNew;		// post-edit index of first matched line
	LONG _yMatchNew;		// post-edit y offset of bottom of first matched line
	LONG _yMatchNewTop;		// post-edit y offset of top of first matched line

public:
	CLed();
	
	void	SetMax(const CDisplay * const pdp);
};

inline CLed::CLed()
{
#ifdef DEBUG
	// We set this invalid so that we can assert on it in debug builds.
	_yMatchNewTop = -1;

#endif // DEBUG
}

// An enumeration describing the various display actions we can perform on the selection
enum SELDISPLAYACTION
{
	selSetHiLite,
	selSetNormal,
	selUpdateHiLite,
	selUpdateNormal
};

class CDispDim
{
public:
	CDispDim(){ZeroMemory(this, sizeof(*this));}
	LONG	dx;
	DWORD	lstflow;
};

// Forward declaration to prevent recursion of definitions
class CAccumDisplayChanges;

// ==========================  CDisplay  ====================================
// Display - keeps track of line breaks for a device.
// All measurements are in pixels on rendering device,
// EXCEPT xWidthMax and yHeightMax, which are in twips.

class CDisplay : public CDevDesc, public ITxNotify
{
	friend class CLinePtr;
	friend class CLed;

#ifdef DEBUG
public:
	BOOL Invariant ( void ) const;
private:
#endif

public:
	// Average char width of system font
	static INT GetXWidthSys() { return W32->GetXWidthSys(); }

	// Height of system font
	static INT GetYHeightSys() { return W32->GetYHeightSys(); }

private:
	static DWORD _dwTimeScrollNext; // time for next scroll step
	static DWORD _dwScrollLast;	// last scroll action
	
	CDrawInfo *	 _pdi;			// Draw info parameters

protected:
	CAccumDisplayChanges *_padc;	// Accumulated display changes if frozen

	DWORD	_fBgndRecalc		:1; // Background recalc is running
	DWORD	_fDeferUpdateScrollBar:1; // Currently deferring updating scroll bars
	DWORD	_fHScrollEnabled	:1; // Horizontal scrolling enabled
	DWORD	_fInBkgndRecalc		:1; // Avoid reentrant background recalc
	DWORD	_fLineRecalcErr		:1; // Error occured during background recalc
	DWORD	_fNoUpdateView		:1; // Don't update visible view
	DWORD	_fWordWrap			:1; // Word wrap text
	DWORD	_fNeedRecalc		:1; // Recalc line is needed
	DWORD	_fRecalcDone		:1; // Is line recalc done ?
	DWORD	_fViewChanged		:1; // Visible view rect has changed since last Draw
	DWORD	_fUpdateScrollBarDeferred:1;// scroll bars need to be updated
	DWORD	_fVScrollEnabled	:1; // vertical scrolling enabled
	DWORD	_fUpdateCaret		:1; // Whether Draw needs to update cursor
	DWORD	_fActive			:1; // Whether this display is active
	DWORD	_fRectInvalid		:1; // Entire client rectangle has been 
									// invalidated. Used only in SL. Put
									// here, as usual, to save space
	DWORD	_fSmoothVScroll		:1;	// Timer for smooth scrolling installed
	DWORD	_fFinishSmoothVScroll:1;// TRUE if we're winding down the current smooth scroll
	DWORD	_fMultiLine			:1;	// TRUE iff this CDisplay is multiline

	SHORT   _xWidthView;	  		// View rect width
	LONG	_yHeightView;	 		// View rect height
	LONG	_yHeightClient;   		// Height of client rect unmodified by inset.

	LONG	_xScroll;		 		// Horizontal scroll position of visible view

	LONG	_lTempZoomDenominator;	// Zoom for GetNaturalSize
	LONG	_cpFirstVisible;		// cp at start of first visible line

 	// Smooth scroll support.
	int		_smoothYDelta;			// Current # pixels * 1000 to smooth scroll by
	int		_continuedSmoothYDelta;	// At end of 1 smooth scroll cycle, start new with this
	int		_nextSmoothVScroll;		// Fractional amount not yet smooth scrolled
	int		_totalSmoothVScroll;	// Remaining # of device units to smooth scroll
	int		_continuedSmoothVScroll;// At end of 1 smooth scroll cycle, start new with this

private:
	void 	UpdateViewRectState(const RECT *prcClient);	

protected:
	LONG	GetSelBarInPixels();
	
	friend class CLinePtr;

	LONG			SetClientHeight(LONG yNewClientHeight);
	virtual void	InitLinePtr ( CLinePtr & ) = 0;
	
	// Line break recalc.
	virtual BOOL	RecalcView(BOOL fUpdateScrollBars, RECT* prc = NULL) = 0;

	// Rendering
	virtual void	Render(const RECT &rcView, const RECT &rcRender) = 0;

	// Scrollbar
	virtual BOOL	UpdateScrollBar(INT nBar, BOOL fUpdateRange = FALSE) = 0;
	void			GetViewDim(LONG& widthView, LONG& heightView);
	void			SetCpFirstVisible(LONG cp)		{_cpFirstVisible = cp;};
	LONG			ConvertScrollToXPos(LONG xPos);
	LONG			ConvertXPosToScrollPos(LONG xPos);
	virtual LONG	GetMaxXScroll() const = 0;

public:
	virtual	LONG	ConvertYPosToScrollPos(LONG yPos);

			CDisplay (CTxtEdit* ped);
	virtual CDisplay::~CDisplay();

	virtual BOOL	Init();
			void	InitFromDisplay(const CDisplay *pdp);

	// Device context management
	virtual BOOL	SetMainTargetDC(HDC hdc, LONG xWidthMax);
	virtual BOOL	SetTargetDC( HDC hdc, LONG dxpInch = -1, LONG dypInch = -1);

	// Getting properties
			CTxtEdit*		GetPed() const			{ return _ped;}
			CTxtStory*		GetStory() const		{ return _ped->GetTxtStory();}
			const CDevDesc*	GetDdRender() const		{ return this;}
	virtual const CDevDesc*	GetDdTarget() const		{ return NULL; }
			const CDevDesc*	GetTargetDev() const;
	
	virtual BOOL	IsMain() const = 0;
	virtual BOOL	IsPrinter() const;
			BOOL	IsRecalcDone() const			{ return _fRecalcDone;}
			BOOL	IsMultiLine() const				{ return _fMultiLine;}
			BOOL	IsTransparent() const			{ return _ped->IsTransparent();}
	virtual BOOL	GetWordWrap() const;
			void	SetWordWrap(BOOL fNoWrap);

			HRESULT	GetCachedSize(DWORD *pdwWidth, DWORD *pdwHeight);


	// maximum height and width
	virtual LONG	GetMaxWidth() const = 0;
	virtual LONG	GetMaxHeight() const = 0;
	virtual LONG 	GetMaxPixelWidth() const = 0;

	// Width, height and line count (all text)
	virtual LONG	GetWidth() const = 0;
	virtual LONG	GetHeight() const = 0;
	virtual LONG	GetResizeHeight() const = 0;
	virtual LONG	LineCount() const = 0;

	// View rectangle
			void	GetViewRect(RECT &rcView, LPCRECT prcClient = NULL);
			LONG	GetViewWidth() const			{ return _xWidthView;}
			LONG	GetViewHeight() const			{ return _yHeightView;}

	// Visible view properties
	virtual LONG	GetCliVisible(
						LONG *pcpMostVisible = NULL,
						BOOL fLastCharOfLastVisible = FALSE) const = 0;

			LONG	GetFirstVisibleCp() const		{return _cpFirstVisible;};
	virtual LONG	GetFirstVisibleLine() const = 0;

	// Line info
	virtual LONG	GetLineText(LONG ili, TCHAR *pchBuff, LONG cchMost) = 0;
	virtual LONG	CpFromLine(LONG ili, LONG *pyLine = NULL) = 0;
	
	virtual LONG	LineFromCp(LONG cp, BOOL fAtEnd) = 0;

	// Point <-> cp conversion
	virtual LONG	CpFromPoint(POINT pt, 
						const RECT *prcClient,
						CRchTxtPtr * const ptp, 
						CLinePtr * const prp, 
						BOOL fAllowEOL,
						HITTEST *pHit = NULL,
						CDispDim *pdispdim = NULL,
						LONG *pcpActual = NULL) = 0;

	virtual LONG	PointFromTp (
						const CRchTxtPtr &tp, 
						const RECT *prcClient,
						BOOL fAtEnd,	
						POINT &pt,
						CLinePtr * const prp, 
						UINT taMode,
						CDispDim *pdispdim = NULL) = 0;

	// View recalc and updating
			void	SetUpdateCaret()		{_fUpdateCaret = TRUE;}
			void	SetViewChanged()		{_fViewChanged = TRUE;}
			void	InvalidateRecalc()		{_fNeedRecalc = TRUE;}
			BOOL	RecalcView (const RECT &rcView, RECT* prcClient = NULL);
			BOOL	UpdateView();
	virtual BOOL	UpdateView(const CRchTxtPtr &tpFirst, LONG cchOld, LONG cchNew) = 0;

	// Rendering
			HRESULT Draw(HDC hicTargetDev,
						 HDC hdcDraw,
						 LPCRECT prcClient,
						 LPCRECT prcWBounds,
						 LPCRECT prcUpdate,
						 BOOL (CALLBACK * pfnContinue) (DWORD),
						 DWORD dwContinue);

	// Background recalc
	virtual void	StepBackgroundRecalc();
	virtual BOOL	WaitForRecalc(LONG cpMax, LONG yMax);
	virtual BOOL	WaitForRecalcIli(LONG ili);
	virtual BOOL	WaitForRecalcView();

	// Scrolling 
			LONG	GetXScroll() const			  {return _xScroll;} 
	virtual LONG	GetYScroll() const			  {return 0;}
			void	HScroll(WORD wCode, LONG xPos);
	virtual LRESULT VScroll(WORD wCode, LONG yPos);
	virtual void	LineScroll(LONG cli, LONG cch);
	virtual void	FractionalScrollView ( LONG yDelta );
	virtual void	ScrollToLineStart(LONG iDirection);
	virtual LONG	CalcYLineScrollDelta ( LONG cli, BOOL fFractionalFirst );
			BOOL	DragScroll(const POINT * ppt);	 // outside of client rect.
			BOOL	AutoScroll( POINT pt, const WORD xScrollInset, const WORD yScrollInset );
	virtual BOOL	ScrollView(LONG xScroll, LONG yScroll, BOOL fTracking, BOOL fFractionalScroll) = 0;
	virtual	LONG	AdjustToDisplayLastLine(LONG yBase,	LONG yScroll);

     // Smooth Scrolling 
			void	SmoothVScroll ( int direction, WORD cLines, int speedNum, int speedDenom, BOOL fMouseRoller );
			void	SmoothVScrollUpdate();
			BOOL	CheckInstallSmoothVScroll();
			void	CheckRemoveSmoothVScroll();
			void	FinishSmoothVScroll();
			BOOL	IsSmoothVScolling() { return _fSmoothVScroll; }

	// Scrollbars
	virtual LONG	GetScrollRange(INT nBar) const;
			BOOL	IsHScrollEnabled();
			BOOL	IsVScrollEnabled() {return _fVScrollEnabled; }

	// Resizing
			void	OnClientRectChange(const RECT &rcClient);
			void	OnViewRectChange(const RECT &rcView);
			HRESULT RequestResize();

	// Selection 
	virtual BOOL	InvertRange(LONG cp,
		                        LONG cch,
								SELDISPLAYACTION selAction) = 0;

	// Natural size calculation
	virtual HRESULT	GetNaturalSize(
						HDC hdcDraw,
						HDC hicTarget,
						DWORD dwMode,
						LONG *pwidth,
						LONG *pheight) = 0;

	LONG			GetZoomDenominator() const;
	LONG			GetZoomNumerator() const;
	LONG			Zoom(LONG x) const;
	LONG			UnZoom(LONG x) const;

	LONG		 	HimetricXtoDX(LONG xHimetric) const;
	LONG		 	HimetricYtoDY(LONG yHimetric) const;
	LONG			DXtoHimetricX(LONG dx)  const;
	LONG			DYtoHimetricY(LONG dy) const;

	void 			ReDrawOnRectChange(HDC hicTarget, const RECT *prcClient);

	HRESULT 		TransparentHitTest(
						HDC hdc,
						LPCRECT prcClient,
						POINT pt,
						DWORD *pHitResult);

	HRESULT 		RoundToLine(HDC hdc, LONG width, LONG *pheight);
	void			SetTempZoomDenominator(LONG lZoomDenominator)
					{ 
						_lTempZoomDenominator = lZoomDenominator;
					}
	LONG			GetTempZoomDenominator()
					{ 
						return _lTempZoomDenominator;
					}
	void			ResetTempZoomDenominator() 
					{ 
						_lTempZoomDenominator = INVALID_ZOOM_DENOMINATOR;
					}
	void			SetDrawInfo(
						CDrawInfo *pdi, 
						DWORD dwDrawAspect,	//@parm draw aspect
						LONG  lindex,		//@parm currently unused
						void *pvAspect,		//@parm info for drawing optimizations (OCX 96)
						DVTARGETDEVICE *ptd,//@parm information on target device								
						HDC hicTargetDev);	//@parm	target information context

	void			ReleaseDrawInfo();
	void 			ResetDrawInfo(const CDisplay *pdp);
	DWORD 			GetDrawAspect() const;
	LONG 			GetLindex() const;
	void *			GetAspect() const;
	DVTARGETDEVICE *GetPtd() const;
	void			SetActiveFlag(BOOL fActive) { _fActive = fActive; }
	BOOL			IsActive()	{ return _fActive; }
	virtual CDisplay *Clone() const = 0;

	// Support for freezing the display
	BOOL			IsFrozen();
	void			SaveUpdateCaret(BOOL fScrollIntoView);
	void			Freeze();
	void			SetNeedRedisplayOnThaw(BOOL fNeedRedisplay);
	void			Thaw();

	//
	// ITxNotify Interface
	//
	virtual void 	OnPreReplaceRange( 
						LONG cp, 
						LONG cchDel, 
						LONG cchNew,
						LONG cpFormatMin, LONG cpFormatMax);

	virtual void 	OnPostReplaceRange( 
						LONG cp, 
						LONG cchDel, 
						LONG cchNew,
						LONG cpFormatMin, 
						LONG cpFormatMax);

	virtual void	Zombie();
};

// Defines the draw info class. It is included here to prevent loops
// in dependencies that would require no inlining for functions dealing
// with this
#include	"_drwinfo.h"

/*
 *	CDisplay::ResetDrawInfo
 *
 *	@mfunc	Sets draw info using different display
 *
 *	@rdesc	void
 *
 */
inline void CDisplay::ResetDrawInfo(
	const CDisplay *pdp)	//@parm Display to use for draw information
{
	_pdi = pdp->_pdi;
}

/*
 *	CDisplay::ResetDrawInfo
 *
 *	@mfunc	Gets lindex as passed most recently from the host.
 *
 *	@rdesc	draw aspect
 *
 */
inline DWORD CDisplay::GetDrawAspect() const
{
	return _pdi ? _pdi->GetDrawAspect() : DVASPECT_CONTENT; 
}

/*
 *	CDisplay::GetLindex
 *
 *	@mfunc	Gets lindex as passed most recently from the host.
 *
 *	@rdesc	lindex
 *
 */
inline LONG CDisplay::GetLindex() const
{
	return _pdi ? _pdi->GetLindex() : -1; 
}

/*
 *	CDisplay::GetAspect
 *
 *	@mfunc	Gets aspect as passed most recently from the host.
 *
 *	@rdesc	Aspect data
 *
 */
inline void *CDisplay::GetAspect() const
{
	return _pdi ? _pdi->GetAspect() : NULL; 
}

/*
 *	CDisplay::GetPtd
 *
 *	@mfunc	Gets device target as passed most recently from the host.
 *
 *	@rdesc	DVTARGETDEVICE or NULL
 *
 */
inline DVTARGETDEVICE *CDisplay::GetPtd() const
{
	return _pdi ? _pdi->GetPtd() : NULL; 
}

/*
 *	CDisplay::IsFrozen
 *
 *	@mfunc	Return whether display is currently frozen
 *
 *	@rdesc	
 *		TRUE - display is frozen <nl>
 *		FALSE - display is not frozen
 *
 */
inline BOOL CDisplay::IsFrozen()
{
	return _padc != NULL;
}

/*
 *	CFreezeDisplay
 *	
 * 	@class	This class is used to freeze and guranatee that the display
 *			unfreeze a display when it passes out of its context.
 *
 *
 */
class CFreezeDisplay
{
public:	
						CFreezeDisplay(CDisplay *pdp); //@cmember Constructor Freezes

						~CFreezeDisplay();			//@cmember Destructor - Thaws

private:

	CDisplay *			_pdp;						//@cmember Display to freeze
};

/*
 *	CFreezeDisplay::CFreezeDisplay()
 *
 *	@mfunc
 *		Initialize object and tell the input display to freeze
 */
inline CFreezeDisplay::CFreezeDisplay(CDisplay *pdp) : _pdp(pdp)
{
	pdp->Freeze();
}

/*
 *	CFreezeDisplay::CFreezeDisplay()
 *
 *	@mfunc
 *		Free object and tell display to thaw.
 */
inline CFreezeDisplay::~CFreezeDisplay()
{
	_pdp->Thaw();
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_dispsl.h ===
/*
 *  _DISPML.H
 *  
 *  Purpose:
 *      CDisplaySL class. Single-line display.
 *  
 *  Authors:
 *      Eric Vasilik
 */

#ifndef _DISPSL_H
#define _DISPSL_H

#include "_disp.h"

// Forward declaration
class CTxtSelection;

class CDisplaySL : public CDisplay, private CLine
{
public:

    CDisplaySL ( CTxtEdit* ped );
    
protected:


    // The following are pure functions from the base

    // Helpers
    virtual BOOL Init();
    void InitVars();
    
    // Line breaking
    BOOL RecalcLine();

    // Rendering
    virtual VOID Render(const RECT &rcView, const RECT &rcRender);
    
    // Scrolling and scroller bars
    virtual BOOL UpdateScrollBar(INT nBar, BOOL fUpdateRange = FALSE);
    virtual LONG GetScrollRange(INT nBar) const;
    
    // Getting properties
    virtual void InitLinePtr ( CLinePtr & plp );
    virtual BOOL IsMain() const;
    
    // maximum height and width
    virtual LONG GetMaxWidth() const;
    virtual LONG GetMaxHeight() const;
	virtual LONG GetMaxPixelWidth() const;

    // Width, height and line count (of all text)
    virtual LONG GetWidth() const;
    virtual LONG GetHeight() const;
	virtual LONG GetResizeHeight() const;
    virtual LONG LineCount() const;

    // Visible view properties
    virtual LONG GetCliVisible(
					LONG *pcpMostVisible = NULL,
					BOOL fLastCharOfLastVisible = FALSE) const;

    virtual LONG GetFirstVisibleLine() const;

    // Line info
    virtual LONG GetLineText(LONG ili, TCHAR *pchBuff, LONG cchMost);
    virtual LONG CpFromLine(LONG ili, LONG *pyLine = NULL);
    virtual LONG LineFromCp(LONG cp, BOOL fAtEnd);
    
    // Point <-> cp conversion
    virtual LONG CpFromPoint(
    				POINT pt, 
					const RECT *prcClient,
    				CRchTxtPtr * const ptp, 
    				CLinePtr * const prp, 
    				BOOL fAllowEOL,
					HITTEST *pHit = NULL,
					CDispDim *pdispdim = 0,
					LONG *pcpActual = NULL);

    virtual LONG PointFromTp (
					const CRchTxtPtr &tp, 
					const RECT *prcClient,
					BOOL fAtEnd, 
					POINT &pt,
					CLinePtr * const prp, 
					UINT taMode,
					CDispDim *pdispdim = 0);

    // Line break recalc
    virtual BOOL RecalcView(BOOL fUpdateScrollBars, RECT* prc = NULL);
    virtual BOOL WaitForRecalcIli(LONG ili);

    // Complete updating (recalc + rendering)
    virtual BOOL UpdateView(const CRchTxtPtr &tpFirst, LONG cchOld, LONG cchNew);

    // Scrolling 
    virtual BOOL ScrollView(LONG xScroll, LONG yScroll, BOOL fTracking, BOOL fFractionalScroll);
    
    // Selection 
    virtual BOOL InvertRange(LONG cp, LONG cch, SELDISPLAYACTION selAction);

	// Natural size calculation
	virtual HRESULT	GetNaturalSize(
						HDC hdcDraw,
						HDC hicTarget,
						DWORD dwMode,
						LONG *pwidth,
						LONG *pheight);

    virtual BOOL    GetWordWrap() const;

	virtual CDisplay *Clone() const;

	virtual LONG	GetMaxXScroll() const;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_dte.h ===
/*
 *	_DTE.H
 *
 *	Purpose:
 *		Interface declaration for IDataTransferEngine
 *		there is typically one data transfer engine per
 *		CTxtEdit instance
 *
 *	Author:
 *		alexgo 3/25/95
 *
 *	NB!  THIS FILE IS NOW OBSOLETE
 */

#ifndef __DTE_H__
#define __DTE_H__

#include "_m_undo.h"

class CTxtRange;
class CTxtEdit;

/*
 *	DataObjectInfo
 *
 *	Purpose:
 *		enumeration of bit flags used to indicate what operations
 *		are possible from a given data object.
 */

typedef enum tagDataObjectInfo
{
	DOI_NONE			= 0,
	DOI_CANUSETOM		= 1,	// TOM<-->TOM optimized data transfers
	DOI_CANPASTEPLAIN	= 2,	// plain text pasting available
	DOI_CANPASTERICH	= 4, 	// rich text pasting available  
	DOI_CANPASTEOLE		= 8,	// object may be pasted as an OLE embedding
								// (note that this flag may be combined with
								// others). 
} DataObjectInfo;

/*
 *	IDataTransferEngine
 *
 *	Purpose:
 *		provides clipboard, drag drop, and data object data transfer
 *		capabilities.  Each implementation will provide a different 
 *		level of functionality (e.g. OLE vs no-OLE)
 */
class IDataTransferEngine
{
public:
	// memory mgmt

	virtual void Destroy() = 0;

	// clipboard operations

	virtual HRESULT CopyRangeToClipboard( CTxtRange *prg ) = 0;
	virtual HRESULT CutRangeToClipboard( CTxtRange *prg, 
						IUndoBuilder *publdr ) = 0;
	virtual HRESULT PasteClipboardToRange( CTxtRange *prg, 
						IUndoBuilder *publdr ) = 0;
	virtual BOOL 	CanPaste( CTxtRange *prg, CLIPFORMAT cf) = 0;

	// data object operations

	virtual HRESULT RangeToDataObject( CTxtRange *prg, LONG lStreamFormat,
									IDataObject **ppdo) = 0;
	virtual HRESULT PasteDataObjectToRange( IDataObject *pdo,
						CTxtRange *prg, IUndoBuilder *publdr) = 0;

	virtual HRESULT GetDataObjectInfo( IDataObject *pdo, DWORD *pDOIFlags ) = 0;
	
	// drag drop operations
	
	virtual HRESULT GetDropTarget( IDropTarget **ppDropTarget ) = 0;
	virtual HRESULT StartDrag( CTxtRange *prg, IUndoBuilder *publdr) = 0;

	// file i/o

	virtual LONG LoadFromEs( CTxtRange *prg, LONG lStreamFormat,
							 EDITSTREAM *pes, IUndoBuilder *publdr) = 0;
	virtual LONG SaveToEs(	 CTxtRange *prg, LONG lStreamFormat,
							 EDITSTREAM *pes ) = 0;

	// converstion routines

	virtual HGLOBAL AnsiPlainTextFromRange( CTxtRange *prg ) = 0;
	virtual HGLOBAL UnicodePlainTextFromRange( CTxtRange *prg ) = 0;

};

#endif // !__DTE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_drwinfo.h ===
/*	@doc INTERNAL
 *
 *	@module _DRWINFO.H  Class to hold draw parameters |
 *	
 *	This declares a class that is used to hold parameters passed from
 *	the host for drawing.
 *
 *	Original Author: <nl>
 *		Rick Sailor
 *
 *	History: <nl>
 *		11/01/95	ricksa	created
 */
#ifndef _DRWINFO_H_
#define _DRWINFO_H_

/*
 *	CArrayBase
 *	
 * 	@class	This class serves as a holder for all the parameters to a draw
 *	except currently the HDC. Access to these parameters will actually come
 *	through the display class.
 *
 *	@devnote Although each operation that takes the parameters for drawing
 *	will create one of these objects, the display keeps only one of these
 *	objects because it will only use the last set of drawing parameters to
 *	draw with. The depth count is used to tell draw whether it is appropriate
 *	to draw or not.
 *
 */
class CDrawInfo
{
//@access Public Methods
public:
						CDrawInfo(CTxtEdit *ped);	//@cmember Initialize object

	void				Init(						//@cmember Fills object 
													//with draw data.
							DWORD dwDrawAspect,	
							LONG  lindex,		
							void *pvAspect,		
							DVTARGETDEVICE *ptd,
							HDC hicTargetDev);	

	DWORD				Release();					//@cmember Dec's ref count

	const CDevDesc *	GetTargetDD();				//@cmember Gets target device

	DWORD				GetDrawDepth() const;		//@cmember Gets depth count

	DWORD 				GetDrawAspect() const;		//@cmember Gets Draw aspect

	LONG 				GetLindex() const;			//@cmember Gets lindex

	void *				GetAspect() const;			//@cmember Gets aspect

	DVTARGETDEVICE *	GetPtd() const;				//@cmember Gets target device
				   									// descriptor.
//@access Private Data
private:

	DWORD				_dwDepth;					//@cmember Max number of
													// users of this information

	DWORD				_cRefs;						//@cmember Number of current
													// users

	CDevDesc			_ddTarget;					//@cmember target device
													// (if any).

	DWORD 				_dwDrawAspect;				//@cmember draw aspect

	LONG  				_lindex;					//@cmember lindex

	void *				_pvAspect;					//@cmember aspect

	DVTARGETDEVICE *	_ptd;						//@cmember target device data
};

/*
 *	CDrawInfo::CDrawInfo
 *
 *	@mfunc	Initializes structure with base required information
 *
 *	@rdesc	Initialized object
 *
 *	@devnote This serves two purposes: (1) CDevDesc requires the ped to 
 *	initalize correctly and (2) We need to make sure that the ref counts
 *	are set to zero since this is created on the stack.
 *	
 */
inline CDrawInfo::CDrawInfo(
	CTxtEdit *ped) 		//@parm Edit object used by the target device
	: _ddTarget(ped), _dwDepth(0), _cRefs(0)							   
{
	// Header does the work
}

/*
 *	CDrawInfo::Init
 *
 *	@mfunc	Initializes object with drawing data
 *
 *	@rdesc	void
 *
 *	@devnote This is separated from the constructor because the display
 * 	only uses one copy of this object so the display may initialize
 *	a different object than the one constructed.
 */
inline void CDrawInfo::Init(
	DWORD dwDrawAspect,	//@parm draw aspect
	LONG  lindex,		//@parm currently unused
	void *pvAspect,		//@parm info for drawing optimizations (OCX 96)
	DVTARGETDEVICE *ptd,//@parm information on target device								
	HDC hicTargetDev)	//@parm	target information context
{
	_dwDepth++;
	_cRefs++;
	_dwDrawAspect = dwDrawAspect;
	_lindex = lindex;
	_pvAspect = pvAspect;
	_ptd = ptd;

	if (hicTargetDev != NULL)
	{
		_ddTarget.SetDC(hicTargetDev);	
	}
}


/*
 *	CDrawInfo::Release
 *
 *	@mfunc	Decrements the reference count
 *
 *	@rdesc	Number of outstanding references to this object
 *
 *	@devnote This is used by the display to tell the display when it can NULL
 * 	its pointer to the display object.
 */
inline DWORD CDrawInfo::Release()
{

	AssertSz((_cRefs != 0), "CDrawInfo::Release invalid");
	return --_cRefs;	
}


/*
 *	CDrawInfo::GetTargetDD
 *
 *	@mfunc	Get pointer to target device
 *
 *	@rdesc	Returns pointer to target device if there is one
 *
 */
inline const CDevDesc *CDrawInfo::GetTargetDD()
{
	return (_ddTarget.IsValid())
		? &_ddTarget 
		: NULL;
}

/*
 *	CDrawInfo::GetDrawDepth
 *
 *	@mfunc	Get number of uses of this object
 *
 *	@rdesc	Number of uses of this object
 *
 *	@devnote This allows the draw routine to determine if a recursive draw
 *	occurred.
 *
 */
inline DWORD CDrawInfo::GetDrawDepth() const
{
	return _dwDepth;
}

/*
 *	CDrawInfo::GetDrawAspect
 *
 *	@mfunc	Get the draw aspect passed in on draw
 *
 *	@rdesc	Returns draw aspect
 *
 */
inline DWORD CDrawInfo::GetDrawAspect() const
{
	return _dwDrawAspect; 
}

/*
 *	CDrawInfo::GetLindex
 *
 *	@mfunc	Gets lindex passed from host
 *
 *	@rdesc	lindex passed from host
 *
 */
inline LONG CDrawInfo::GetLindex() const
{
	return _lindex; 
}

/*
 *	CDrawInfo::GetAspect
 *
 *	@mfunc	Gets pointer to aspect passed from host
 *
 *	@rdesc	Returns pointer to aspect structure
 *
 *	@devnote this is data is currently not defined.
 *
 */
inline void *CDrawInfo::GetAspect() const
{
	return _pvAspect; 
}

/*
 *	CDrawInfo::GetPtd
 *
 *	@mfunc	Get device target data from host
 *
 *	@rdesc	Returns pointer to device target data
 *
 */
inline DVTARGETDEVICE *CDrawInfo::GetPtd() const
{
	return _ptd; 
}

#endif // _DRWINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_dragdrp.h ===
/*
 *	_DRAGDRP.H
 *
 *	Purpose:
 *		class declarations for Richedit's OLE drop target and drop source
 *		objects.
 *
 *	Author:
 *		alexgo (4/28/95)
 *
 */

#ifndef __DRAGDRP_H__
#define __DRAGDRP_H__

#include	"_osdc.h"

// DWORD packed flag values.  These are assigned values such that they can
// be or'd with DataObjectInfo flags and not conflict.  We are, in effect,
// overriding the DataObjectInfo flags.
#define DF_CLIENTCONTROL	0x80000000	// QueryAcceptData says the client
										// will handle this drop.
#define DF_CANDROP			0x40000000  // We can handle the drop
#define DF_OVERSOURCE       0x20000000  // Drop target is within source range.
#define DF_RIGHTMOUSEDRAG	0x10000000	// doing a right mouse drag drop


// forward declaration.
class CCallMgr;


#define	WIDTH_DROPCARET 1
#define	DEFAULT_DROPCARET_MAXHEIGHT 32

/*
 *	CDropCaret
 *
 *	Purpose:
 *		provides a caret for the location that drop will occur
 */
class CDropCaret
{
public:

					CDropCaret(CTxtEdit *ped);

					~CDropCaret();

	BOOL			Init();

	void			DrawCaret(LONG cpCur);

	void			HideCaret();

	void			ShowCaret();

	void			CancelRestoreCaretArea();

	BOOL			NoCaret();

private:

	CTxtEdit *		_ped;

	HDC				_hdcWindow;

	LONG			_yPixelsPerInch;

	LONG			_yHeight;

	LONG			_yHeightMax;

	POINT			_ptCaret;

	COffScreenDC	_osdc;
};

/*
 *	CDropCaret::CancelRestoreCaretArea
 *
 *	Purpose:
 *		Tell object not to restore area where caret was.
 *
 *	@devnote:
 *		When we drop we don't want to restore the old caret area
 *		since that is no longer correct.
 *
 */
inline void CDropCaret::CancelRestoreCaretArea()
{
	_yHeight = -1;
}


/*
 *	CDropCaret::NoCaret
 *
 *	Purpose:
 *		Tell whether caret has been turned off
 *
 */
inline BOOL CDropCaret::NoCaret()
{
	return -1 == _yHeight;
}


/*
 *	CDropSource
 *
 *	Purpose:
 *		provides drag drop feedback
 */

class CDropSource : public IDropSource
{
public:
	// IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDropSource methods
    STDMETHOD(QueryContinueDrag)(BOOL fEscapePressed, DWORD grfKeyState);
    STDMETHOD(GiveFeedback)(DWORD dwEffect);

	CDropSource();

private:
	// NOTE: private destructor, may not be allocated on the stack as 
	// this would break OLE's current object liveness rules
	~CDropSource();

	ULONG		_crefs;
};

/*
 *	CDropTarget
 *
 *	Purpose:
 *		an OLE drop-target object; provides a place for text to be "dropped"
 *
 */

class CDropTarget : public IDropTarget
{
public:
	// IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDropTarget methods
    STDMETHOD(DragEnter)(IDataObject *pdo, DWORD grfKeyState,
            POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragOver)(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragLeave)();
    STDMETHOD(Drop)(IDataObject *pdo, DWORD grfKeyState, POINTL pt,
           	DWORD *pdwEffect);
	
	
	CDropTarget(CTxtEdit *ped);

	// this method is used during drag drop to cache important information
	void SetDragInfo( IUndoBuilder *publdr, LONG cpMin, LONG cpMax );
	void Zombie();		//@cmember Nulls out the state of this object
						
	BOOL fInDrag();		//@cmember Tells whether another app is dragging
						// over us.

private:
	// this class is used in CDropTarget::Drop to clean up at the end
	// of the call.
	class CDropCleanup
	{
	public:
		CDropCleanup( CDropTarget *pdt )
		{	
			_pdt = pdt;
		}

		~CDropCleanup()
		{
			delete _pdt->_pcallmgr;
			_pdt->_pcallmgr = NULL;
			delete _pdt->_pdrgcrt;
			_pdt->_pdrgcrt = NULL;
		}
	private:
		CDropTarget *	_pdt;
	};

	friend class CDropCleanup;

	// NOTE: private destructor, may not be allocated on the stack as 
	// this would break OLE's current object liveness rules

	~CDropTarget();

	void UpdateEffect(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
	void DrawFeedback(void);
	void ConvertScreenPtToClientPt( POINTL *pptScreen, POINT *pptClient );
	HRESULT HandleRightMouseDrop(IDataObject *pdo, POINTL ptl);

	ULONG		_crefs;
	DWORD		_dwFlags;	// DataObjectInfo cache (e.g. DOI_CANPASTEPLAIN)
							// and other flags.
	CTxtEdit *	_ped;
	CCallMgr *	_pcallmgr;	// The call manager used during a drag drop operation.

	// cached information for drag drop operations
	IUndoBuilder *_publdr;	// the undo builder for the drag operation
	LONG		_cpMin;		// the min and max cp's for the range that is
	LONG		_cpMost;	//   being dragged so we can disable drag-onto-yourself!
	LONG		_cpSel;		// active end and length for selection *before*
	LONG		_cchSel;	//	 drag drop op occured (so we can restore it)
	LONG		_cpCur;		// the cp that the mouse is currently over
	CDropCaret *_pdrgcrt;	// Object that implements the drop caret
};


/*
 *	CDropTarget::fInDrag ()
 *
 *	Purpose:
 *		Tells interested parties whether a drag operation is occurring
 *
 */
inline BOOL CDropTarget::fInDrag()
{
	return _pcallmgr != NULL;
}

#endif // !__DRAGDRP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_dxfrobj.h ===
/*
 *	_DXFROBJ.H
 *
 *	Purpose:
 *		Class declaration for an OLE data transfer object (for use in
 *		drag drop and clipboard operations)
 *
 *	Author:
 *		alexgo (4/25/95)
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef __DXFEROBJ_H__
#define __DXFEROBJ_H__

class CTxtRange;

EXTERN_C const IID IID_IRichEditDO;

/*
 *	CDataTransferObj
 *
 *	Purpose:
 *		holds a "snapshot" of some rich-text data that can be used
 *		for drag drop or clipboard operations
 *
 *	Notes:
 *		FUTURE (alexgo): add in support for TOM<-->TOM optimized data
 *		transfers
 */

class CDataTransferObj : public IDataObject, public ITxNotify
{
public:

	// IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

	// IDataObject methods
    STDMETHOD(DAdvise)( FORMATETC * pFormatetc, DWORD advf,
    		IAdviseSink *pAdvSink, DWORD *pdwConnection);
    STDMETHOD(DUnadvise)( DWORD dwConnection);
    STDMETHOD(EnumDAdvise)( IEnumSTATDATA ** ppenumAdvise);
    STDMETHOD(EnumFormatEtc)( DWORD dwDirection,
            IEnumFORMATETC **ppenumFormatEtc);
    STDMETHOD(GetCanonicalFormatEtc)( FORMATETC *pformatetc,
            FORMATETC *pformatetcOut);
    STDMETHOD(GetData)( FORMATETC *pformatetcIn, STGMEDIUM *pmedium );
    STDMETHOD(GetDataHere)( FORMATETC *pformatetc, STGMEDIUM *pmedium);
    STDMETHOD(QueryGetData)( FORMATETC *pformatetc );
    STDMETHOD(SetData)( FORMATETC *pformatetc, STGMEDIUM *pmedium,
            BOOL fRelease);

	// ITxNotify methods
    virtual void    OnPreReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
                        LONG cpFormatMin, LONG cpFormatMax);
    virtual void    OnPostReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
                        LONG cpFormatMin, LONG cpFormatMax);
	virtual void	Zombie();

	static	CDataTransferObj * Create(CTxtEdit *ped, CTxtRange *prg, LONG lStreamFormat);

private:
	// NOTE: private cons/destructor, may not be allocated on the stack as 
	// this would break OLE's current object liveness rules
	CDataTransferObj(CTxtEdit *ped);
	~CDataTransferObj();

	BOOL		IsZombie() {return !_ped;}

	ULONG		_crefs;
	ULONG		_cTotal;		// total number of formats supported
	FORMATETC *	_prgFormats;	// the array of supported formats
	LONG		_lStreamFormat; // Stream format to use in Rtf conversion

	// for 1.0 compatability
	DWORD	_dwFlags;
	DWORD	_dwUser;
	DWORD	_dvaspect;

	enum TEXTKIND
	{
		tPlain,
		tRtf,
		tRtfUtf8,
		tRtfNCRforNonASCII
	};

	HGLOBAL     TextToHglobal( HGLOBAL &hText, TEXTKIND tKind );
	LPSTORAGE	GetDataForEmbeddedObject( LPOLEOBJECT pOleObj, LPSTORAGE lpstgdest );
	HGLOBAL		GetDataForObjectDescriptor(	LPOLEOBJECT pOleObj, DWORD dwAspect, SIZEL* psizel );

public:
	CTxtEdit *		_ped;
	HGLOBAL			_hPlainText;	// handle to the plain UNICODE text
	HGLOBAL			_hRtfText;		// handle to the RTF UNICODE text
	HGLOBAL			_hRtfUtf8;		// Handle to UTF8 encoding of RTF
	HGLOBAL			_hRtfNCRforNonASCII;	// Handle to NCRforNonASCII encoding of RTF
	IOleObject *	_pOleObj;		// Embedded Object
	LPSTORAGE		_pObjStg;		// Embedded object data
	HGLOBAL			_hObjDesc;		// Embedded object descriptor
	HMETAFILE		_hMFPict;		// Embedded object metafile
	LONG			_cch;			// number of "characters" in the this
									// dxfer object
	LONG			_cpMin;			// Starting cp for this dxfer object
	LONG			_cObjs;			// number of objects in this dxfer object.
};

/*
 *	class CEnumFormatEtc
 *
 *	Purpose:
 *		implements a generic format enumerator for IDataObject
 */

class CEnumFormatEtc : public IEnumFORMATETC
{
public:
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    STDMETHOD(Next) (ULONG celt, FORMATETC *rgelt,
            ULONG *pceltFetched);
    STDMETHOD(Skip) (ULONG celt);
    STDMETHOD(Reset) (void);
    STDMETHOD(Clone) (IEnumFORMATETC **ppenum);

    static HRESULT Create(FORMATETC *prgFormats, DWORD cFormats, 
    			IEnumFORMATETC **ppenum);

private:

	CEnumFormatEtc();
	~CEnumFormatEtc();

	ULONG		_crefs;
    ULONG       _iCurrent; 	// current clipboard format
    ULONG       _cTotal;   	// total number of formats
    FORMATETC * _prgFormats; // array of available formats
};


//
//	Some globally useful FORMATETCs

extern FORMATETC g_rgFETC[];
extern const DWORD g_rgDOI[];
#define CFETC	17						// Dimension of g_rgFETC[]

enum FETCINDEX							// Keep in sync with g_rgFETC[]
{
	iRtfUtf8,							// RTF in UTF8 encoding
	iRtfFETC,							// RTF
	iRtfNCRforNonASCII,					// RTF with NCR for nonASCII
	iEmbObj,							// Embedded Object
	iEmbSrc,							// Embed Source
	iObtDesc,							// Object Descriptor
	iLnkSrc,							// Link Source
	iMfPict,							// Metafile
	iDIB,								// DIB
	iBitmap,							// Bitmap
	iRtfNoObjs,							// RTF with no objects
	iUnicodeFETC,						// Unicode plain text
	iAnsiFETC,							// ANSI plain text
	iFilename,							// Filename
	iRtfAsTextFETC,						// Pastes RTF as text
	iTxtObj,							// Richedit Text
	iRichEdit							// RichEdit Text w/formatting
};

#define cf_RICHEDIT			 g_rgFETC[iRichEdit].cfFormat
#define cf_EMBEDDEDOBJECT	 g_rgFETC[iEmbObj].cfFormat
#define cf_EMBEDSOURCE		 g_rgFETC[iEmbSrc].cfFormat
#define cf_OBJECTDESCRIPTOR	 g_rgFETC[iObtDesc].cfFormat
#define cf_LINKSOURCE		 g_rgFETC[iLnkSrc].cfFormat
#define cf_RTF				 g_rgFETC[iRtfFETC].cfFormat
#define cf_RTFUTF8			 g_rgFETC[iRtfUtf8].cfFormat
#define cf_RTFNCRFORNONASCII g_rgFETC[iRtfNCRforNonASCII].cfFormat
#define cf_RTFNOOBJS		 g_rgFETC[iRtfNoObjs].cfFormat
#define cf_TEXTOBJECT		 g_rgFETC[iTxtObj].cfFormat
#define cf_RTFASTEXT		 g_rgFETC[iRtfAsTextFETC].cfFormat
#define cf_FILENAME			 g_rgFETC[iFilename].cfFormat

#endif // !__DXFROBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_format.h ===
/*
 *	_FORMAT.H
 *	
 *	Purpose:
 *		CCharFormatArray and CParaFormatArray
 *	
 *	Authors:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#ifndef _FORMAT_H
#define _FORMAT_H

#include "textserv.h"

#define celGrow     8
#define FLBIT		0x80000000

//+-----------------------------------------------------------------------
// 	Interface IFormatCache
// 	Interface ICharFormatCache
// 	Interface IParaFormatCache
//
//	Format caches - Used by the host to manage the cache of CHARFORMAT
// 	and PARAFORMAT structures.  Note that these interfaces DON'T derive from
//  IUnknown
//------------------------------------------------------------------------

interface IFormatCache
{
	virtual LONG		AddRef(LONG iFormat) = 0;
	virtual LONG	 	Release(LONG iFormat) = 0;
	virtual void		Destroy() = 0;
};

template <class FORMAT>
interface ITextFormatCache : public IFormatCache
{
	virtual HRESULT 	Cache(const FORMAT *pFormat, LONG *piFormat) = 0;
	virtual HRESULT		Deref(LONG iFormat, const FORMAT **ppFormat) const = 0;
};

interface ICharFormatCache : public ITextFormatCache<CCharFormat>
{
};

interface IParaFormatCache : public ITextFormatCache<CParaFormat>
{
};

void	ReleaseFormats(LONG iCF, LONG iPF);

HRESULT	CreateFormatCaches();
HRESULT	DestroyFormatCaches();


// ===========================  CFixArray  =================================

// This array class ensures stability of the indexes. Elements are freed by
// inserting them in a free list, and the array is never shrunk.
// The first UINT of ELEM is used to store the index of next element in the
// free list.

class CFixArrayBase
{
private:
	char*	_prgel;			// array of elements
	LONG 	_cel;			// total count of elements (including free ones)
	LONG	_ielFirstFree; 	// - first free element
	LONG 	_cbElem;		// size of each element

public:
	CFixArrayBase (LONG cbElem);
	~CFixArrayBase ()				{Free();}

	void*	Elem(LONG iel) const	{return _prgel + iel * _cbElem;}
	LONG 	Count() const			{return _cel;}

	LONG 	Add ();
	void 	Free (LONG ielFirst);
	void 	Free ();

	HRESULT	Deref  (LONG iel, const void **ppel) const;
	LONG	AddRef (LONG iel);
	LONG	Release(LONG iel);
	HRESULT	Cache  (const void *pel, LONG *piel);

#ifdef DEBUG
	void CheckFreeChainFn(LPSTR szFile, INT nLine); 
#endif

protected:
	LONG &	RefCount(LONG iel);

private:
	LONG	Find   (const void *pel);
};

template <class ELEM> 
class CFixArray : public CFixArrayBase
{
public:
	CFixArray () : CFixArrayBase (sizeof(ELEM)) 	{}
											//@cmember Get ptr to <p iel>'th
	ELEM *	Elem(LONG iel) const			// element
			{return (ELEM *)CFixArrayBase::Elem(iel);}

protected:									//@cmember Get ptr to <p iel>'th
	LONG &	RefCount(LONG iel)				// ref count
			{return CFixArrayBase::RefCount(iel);}
};

#ifdef DEBUG
#define CheckFreeChain()\
			CheckFreeChainFn(__FILE__, __LINE__)
#else
#define CheckFreeChain()
#endif // DEBUG


//================================  CCharFormatArray  ==============================

class CCharFormatArray : public CFixArray<CCharFormat>, public ICharFormatCache
{
protected:
	LONG 	Find(const CCharFormat *pCF);

public:
	CCharFormatArray() : CFixArray<CCharFormat>()	{}

	// ICharFormatCache
	virtual HRESULT		Cache(const CCharFormat *pCF, LONG *piCF);
	virtual HRESULT		Deref(LONG iCF, const CCharFormat **ppCF) const;
	virtual LONG	 	AddRef(LONG iCF);
	virtual LONG	 	Release(LONG iCF);
	virtual void		Destroy();
};


//===============================  CParaFormatArray  ==================================

class CParaFormatArray : public CFixArray<CParaFormat>, public IParaFormatCache
{
protected:	
	LONG 	Find(const CParaFormat *pPF);

public:
	CParaFormatArray() : CFixArray<CParaFormat>()	{}

	// IParaFormatCache
	virtual HRESULT 	Cache(const CParaFormat *pPF, LONG *piPF);
	virtual HRESULT		Deref(LONG iPF, const CParaFormat **ppPF) const;
	virtual LONG	 	AddRef(LONG iPF);
	virtual LONG	 	Release(LONG iPF);
	virtual void		Destroy();
};


//===============================  CTabsArray  ==================================

class CTabsArray : public CFixArray<CTabs>
{
protected:	
	LONG 		Find(const LONG *prgxTabs, LONG cTab);

public:
	CTabsArray() : CFixArray<CTabs>()	{}
	~CTabsArray();

	LONG 		Cache(const LONG *prgxTabs, LONG cTab);
	const LONG *Deref(LONG iTabs) const;

	LONG	 	AddRef (LONG iTabs);
	LONG	 	Release(LONG iTabs);
};

// Access to the format caches
ICharFormatCache *GetCharFormatCache();
IParaFormatCache *GetParaFormatCache();
CTabsArray		 *GetTabsCache();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_frunptr.h ===
/*
 *	@doc 	INTERNAL
 *
 *	@module _FRUNPTR.H  -- CFormatRunPtr class declaration |
 *	
 *	Original Authors: <nl>
 *		Original RichEdit code: David R. Fulmer <nl>
 *		Christian Fortini <nl>
 *		Murray Sargent <nl>
 *
 *	History: <nl>
 *		06-25-95	alexgo	cleanup and commenting
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#ifndef _FRUNPTR_H
#define _FRUNPTR_H

#include "_array.h"
#include "_text.h"
#include "_runptr.h"
#include "_format.h"

#define	CharFormat 0
#define	ParaFormat 1


typedef enum {
	IGNORE_CURRENT_FONT = 0,
	MATCH_CURRENT_CHARSET = 1,
	MATCH_FONT_SIG = 2,
	MATCH_ASCII = 4
} FONT_MATCHING;

/*
 *	CFormatRunPtr
 *
 *	@class	A Run pointer over an array of CFormatRun structures.
 *	This pointer understands how to add remove character/paragraph
 *	formatting
 *
 *	@base	public | CRunPtr<lt>CFormatRun<gt>
 *
 *	@devnote	The format run pointer has one extra interesting state
 *				transistion beyond the normal CRunPtrBase transistions.
 *
 *				If this run pointer is in the NULL state, then InitRuns may
 *				be used to create or fetch the correct run array for the
 *				run pointer.  Note that if a run array is already allocated
 *				it will be simply be fetched and used.  This allows us to
 *				treat unitialized run pointers the same as run pointers to
 *				an uninitialized document.
 *				@xref See also <mf CFormatRunPtr::InitRuns>
 */
class CFormatRunPtr : public CRunPtr<CFormatRun>
{
	friend class CRchTxtPtr;
	friend class CTxtRange;
	friend class CReplaceFormattingAE;
	friend class CUniscribe;

//@access Public Methods
public:
#ifdef DEBUG
	BOOL	Invariant(void) const;			//@cmember	Invariant tests
#endif
								
	CFormatRunPtr(const CFormatRunPtr &rp)	//@cmember	Copy Constructor
		: CRunPtr<CFormatRun>((CRunPtrBase&)rp) {}
								
	CFormatRunPtr(CFormatRuns *pfr)			//@cmember	Constructor
		: CRunPtr<CFormatRun>((CRunArray *)pfr) {}
								
	short	GetFormat() const;			//@cmember	Get current format index

	void	SetLevel (CBiDiLevel& level);		//@cmember Set run's embedding level
	
	BYTE	GetLevel (CBiDiLevel* pLevel = NULL);//@cmember Get run's embedding level

	BOOL	SameLevel (CFormatRunPtr* prp)
	{
		return !(IsValid() && GetRun(0)->_level._value != prp->GetRun(0)->_level._value);
	}

	BOOL	SameLevel (BYTE	bLevel)
	{
		return !(IsValid() && GetRun(0)->_level._value != bLevel);
	}

//@access Private Methods
private:
								//@cmember Format Run Array management
	BOOL	InitRuns(LONG ich, LONG cch, CFormatRuns **ppfrs);
								//@cmember Formatting replacement
	void	Delete(LONG cch, IFormatCache *pf, LONG cchMove);
								//@cmember Formatting insertion
	LONG	InsertFormat(LONG cch, LONG iformat, IFormatCache *pf);
								//@cmember Merge two adjacent formatting runs
	void	MergeRuns(LONG iRun, IFormatCache *pf);
								//@cmember Split run
	void	SplitFormat(IFormatCache *pf);
								//@cmember Sets the format for the current run
	LONG	SetFormat(LONG ifmt, LONG cch, IFormatCache *pf, CBiDiLevel* pLevel = NULL);
								//@cmember Extends formatting from previous run
	void	AdjustFormatting(LONG cch, IFormatCache *pf);
								//@cmember Remove <p cRun>
	void 	Remove (LONG cRun, IFormatCache *pf);
};


enum MASKOP
{
	MO_OR = 0,
	MO_AND,
	MO_EXACT
};

class CTxtEdit;

class CCFRunPtr : public CFormatRunPtr
{
	friend class CRchTxtPtr;
	friend class CTxtRange;

public:
	CTxtEdit *_ped;

	CCFRunPtr(const CRchTxtPtr &rtp);	//@cmember	Copy Constructor
	CCFRunPtr(const CFormatRunPtr &rp, CTxtEdit *ped);

	BOOL	IsHidden()	{return IsMask(CFE_HIDDEN);}
	BOOL	IsMask(DWORD dwMask, MASKOP mo = MO_OR);

	BOOL	IsInHidden();		//@cmember True if in hidden text
	LONG	FindUnhidden();		//@cmember Find nearest unhidden CF
	LONG	FindUnhiddenBackward();//@cmember Find previous unhidden CF
	LONG	FindUnhiddenForward();//@cmember Find previous unhidden CF

	int		MatchFormatSignature(const CCharFormat* pCF, int iScript, int fMatchCurrent, DWORD* pdwFontSig = NULL);

	//@member Get font info for code page
	bool GetPreferredFontInfo(
		int cpg,
		BYTE&  bCharSet,
		SHORT& iFont,
		SHORT& yHeight,
		BYTE& bPitchAndFamily,
		int	iFormat,
		int iMatchCurrent = MATCH_FONT_SIG
	);
};

class CPFRunPtr : public CFormatRunPtr
{
	friend class CRchTxtPtr;
	friend class CTxtRange;

public:
	CTxtEdit *_ped;

	CPFRunPtr(const CRchTxtPtr &rtp);	//@cmember	Copy Constructor
								//@cmember Find Heading before cpMost
	LONG	FindHeading(LONG cch, LONG& lHeading);
	BOOL	InTable();			//@cmember True if paraformat is in table
	BOOL	IsCollapsed();		//@cmember True if paraformat is collapsed
	LONG	FindExpanded();		//@cmember Find nearest expanded PF
	LONG	FindExpandedBackward();//@cmember Find previous expanded PF
	LONG	FindExpandedForward();//@cmember Find next expanded PF
	LONG	GetOutlineLevel();	//@cmember Get outline level
	LONG	GetStyle();			//@cmember Get style
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_edit.h ===
/*  _EDIT.H
 *
 *  Purpose:
 *      Base classes for rich-text manipulation
 *
 *  Authors:
 *      Christian Fortini
 *      Murray Sargent (and many others)
 *
 *  Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _EDIT_H
#define _EDIT_H

#include "textserv.h"
#include "textsrv2.h"
#include "_ldte.h"
#include "_m_undo.h"
#include "_notmgr.h"
#include "_doc.h"
#include "_objmgr.h"
#include "_cfpf.h"
#include "_callmgr.h"
#include "_magelln.h"

// Forward declarations
class CRchTxtPtr;
class CTxtSelection;
class CTxtStory;
class CTxtUndo;
class CMeasurer;
class CRenderer;
class CDisplay;
class CDisplayPrinter;
class CDrawInfo;
class CDetectURL;
class CUniscribe;
class CTxtBreaker;

// Macro for finding parent "this" of embedded class. If this turns out to be
// globally useful we should move it to _common.h.
#define GETPPARENT(pmemb, struc, membname) (\
                (struc FAR *)(((char FAR *)(pmemb))-offsetof(struc, membname)))

// These wonderful constants are for backward compatibility. They are the
// sizes used for initialization and reset in RichEdit 1.0
const LONG cInitTextMax  = (32 * 1024) - 1;
const LONG cResetTextMax = (64 * 1024);

extern DWORD CALLBACK ReadHGlobal (DWORD_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb);
extern DWORD GetKbdFlags(WORD vkey, DWORD dwFlags);

extern BYTE szUTF8BOM[];
extern WORD g_wFlags;                               // Toggled by Ctrl-"
#define KF_SMARTQUOTES  0x0001                      // Enable smart quotes
#define SmartQuotesEnabled()    (g_wFlags & KF_SMARTQUOTES)

struct SPrintControl
{
    union
    {
        DWORD       _dwAllFlags;                // Make it easy to set all flags at once.
        struct
        {
            ULONG   _fDoPrint:1;                // Whether actual print is required
            ULONG   _fPrintFromDraw:1;          // Whether draw is being used to print
        };
    };

    SPrintControl(void) { _dwAllFlags = 0; }
};

enum DOCUMENTTYPE
{
    DT_LTRDOC   = 1,            // DT_LTRDOC and DT_RTLDOC are mutually
    DT_RTLDOC   = 2,            //  exclusive
};

// Context rule settings.
// Optimally, these would be an enum, but we run into sign extension glitchs
// sticking an enum into a 2-bit field.
#define CTX_NONE    0       // No context direction/alignment.
#define CTX_NEUTRAL 1       // No strong characters in the control, direction/alignment follows keyboard.
#define CTX_LTR     2       // LTR direction/alignment (first strong character is LTR)
#define CTX_RTL     3       // RTL direction/alignment (first strong character is RTL)

#define IsStrongContext(x)  (x >= CTX_LTR)

class CDocInfo                  // Contains ITextDocument info
{
public:
    BSTR    pName;              // Document filename
    HANDLE  hFile;              // Handle used unless full file sharing
    WORD    wFlags;             // Open, share, create, and save flags
    WORD    wCpg;               // Code page
    LONG    dwDefaultTabStop;   // TOM settable default tab stop
    LCID    lcid;               // Document lcid (for RTF \deflang)
    LCID    lcidfe;             // Document FE lcid (for RTF \deflangfe)
    LPSTR   lpstrLeadingPunct;  // Leading kinsoku characters
    LPSTR   lpstrFollowingPunct;// Following kinsoku characters
    COLORREF *prgColor;         // Special color array
    char    cColor;             // Allocated count of colors in pColor
    BYTE    bDocType;           // 0-1-2: export none-\ltrdoc-\rtldoc
                                // If 0x80 or'd in, PWD instead of RTF
    BYTE    bCaretType;         // Caret type

    CDocInfo() {InitDocInfo();} // constructor
    ~CDocInfo();                // destructor

    void    InitDocInfo();
};

const DWORD tomInvalidCpg = 0xFFFF;
const DWORD tomInvalidLCID = 0xFFFE;

// This depends on the number of property bits defined in textserv.h. However, this is
// for private use by the text services so it is defined here.
#define MAX_PROPERTY_BITS   21
#define SPF_SETDEFAULT      4

// IDispatch global declarations
extern ITypeInfo *  g_pTypeInfoDoc;
extern ITypeInfo *  g_pTypeInfoSel;
extern ITypeInfo *  g_pTypeInfoFont;
extern ITypeInfo *  g_pTypeInfoPara;
HRESULT GetTypeInfoPtrs();
HRESULT GetTypeInfo(UINT iTypeInfo, ITypeInfo *&pTypeInfo,
                            ITypeInfo **ppTypeInfo);

BOOL IsSameVtables(IUnknown *punk1, IUnknown *punk2);

// Map from keyboard to font. (converse is handled in font.cpp)
typedef struct _kbdFont
{
    WORD    iKbd;
    SHORT   iCF;
} KBDFONT;

DWORD GetCharFlags(DWORD ch, BYTE bDefaultCharset = 0);
CUniscribe* GetUniscribe(void);

#define fBIDI                1
#define fDIGITSHAPE          2

#define fSURROGATE  0x00000010      // (0x10 - 0x80 No fontbind supported)
#define fUNIC_CTRL  0x00000020

/*  The font signature low DWORD has the bit definitions (note: SDK 98
    has Thai - Chinese off by one bit compared to FS_xxx defs in wingdi.h)

    0 1252 Latin 1
    1 1250 Latin 2: Eastern Europe
    2 1251 Cyrillic
    3 1253 Greek
    4 1254 Turkish
    5 1255 Hebrew
    6 1256 Arabic
    7 1257 Baltic
    8 1258 Vietnamese
    9 - 15 Reserved for ANSI
    16 874 Thai
    17 932 JIS/Japan
    18 936 Chinese: Simplified chars--PRC, Hong Kong, Singapore
    19 949 Korean Unified Hangul Code (Hangul TongHabHyung Code)
    20 950 Chinese: Traditional chars--Taiwan

    We define bit masks which are similar to the values above shifted over
    one byte (add 8) to make room for _dwCharFlags
*/
#define fHILATIN1   0x00000100
#define fLATIN2     0x00000200
#define fCYRILLIC   0x00000400
#define fGREEK      0x00000800

#define fTURKISH    0x00001000
#define fHEBREW     0x00002000
#define fARABIC     0x00004000
#define fBALTIC     0x00008000

#define fVIETNAMESE 0x00010000
#define fARMENIAN   0x00020000
#define fOEM        0x00040000
#define fCOMBINING  0x00080000

#define fASCIIUPR   0x00100000      // ASCII 0x40-0x7F
#define fBELOWX40   0x00200000      // ASCII 0x00-0x3F
#define fSYMBOL     0x00400000
#define fOTHER      0x00800000

#define fTHAI       0x01000000
#define fKANA       0x02000000
#define fCHINESE    0x04000000      // Simplified Chinese
#define fHANGUL     0x08000000
#define fBIG5       0x10000000      // Traditional Chinese

#define fDEVANAGARI 0x20000000
#define fTAMIL      0x40000000
#define fGEORGIAN   0x80000000

#define fASCII      (fASCIIUPR | fBELOWX40)
#define fLATIN1     (fASCII | fHILATIN1)
#define fFE         (fKANA | fCHINESE | fBIG5 | fHANGUL)
#define fABOVEX7FF  (fTHAI | fFE | fDEVANAGARI | fTAMIL | fOTHER)
#define fLATIN      (fHILATIN1 | fLATIN2 | fTURKISH | fBALTIC | fVIETNAMESE)

#define fNEEDWORDBREAK      fTHAI
#define fNEEDCHARBREAK      (fTHAI | fDEVANAGARI | fTAMIL)
#define fNEEDCSSEQCHECK     (fTHAI | fDEVANAGARI | fTAMIL)
#define fCOMPLEX_SCRIPT     (fBIDI | fARABIC | fHEBREW | fTHAI | fDEVANAGARI | fTAMIL | fCOMBINING | fDIGITSHAPE | fSURROGATE)

#define RB_DEFAULT      0x00000000  // perform default behavior
#define RB_NOSELCHECK   0x00000001  // for OnTxRButtonUp, bypass pt in selection check
#define RB_FORCEINSEL   0x00000002  // force point into selection (used by keyboard to get context menus)

// flags for OnTxLButtonUp
#define LB_RELEASECAPTURE   0x00000001  // Force release mouse capture
#define LB_FLUSHNOTIFY      0x00000002  // 1.0 mode force selection change notification if selChange is cached

enum AccentIndices
{
    ACCENT_GRAVE = 1,
    ACCENT_ACUTE,
    ACCENT_CARET,
    ACCENT_TILDE,
    ACCENT_UMLAUT,
    ACCENT_CEDILLA
};

#define KBD_CHAR    2       // Must be a bit value > 1

// ==================================  CTxtEdit  ============================================
// Outer most class for a Text Control.

class CTxtEdit : public ITextServices, public IRichEditOle, public ITextDocument2
{
public:
    friend class CCallMgr;
    friend class CMagellanBMPStateWrap;

    CTxtEdit(ITextHost2 *phost, IUnknown *punkOuter);
     ~CTxtEdit ();

    // Initialization
    BOOL        Init(const RECT *prcClient);

    // A helper function
    LONG GetTextLength() const  {return _story.GetTextLength();}
    LONG GetAdjustedTextLength();

    // Access to ActiveObject members

    IUnknown *      GetPrivateIUnknown()    { return &_unk; }
    CLightDTEngine *GetDTE()                { return &_ldte; }

    IUndoMgr *      GetUndoMgr()            { return _pundo; }
    IUndoMgr *      GetRedoMgr()            { return _predo; }
    IUndoMgr *      CreateUndoMgr(DWORD dwLim, USFlags flags);
    CCallMgr *      GetCallMgr()            {
                                                Assert(_pcallmgr);
                                                return _pcallmgr;
                                            }

    CObjectMgr *    GetObjectMgr();
                    // the callback is provided by the client
                    // to help with OLE support
    BOOL            HasObjects()            {return !!_pobjmgr;}
    IRichEditOleCallback *GetRECallback()
        { return _pobjmgr ? _pobjmgr->GetRECallback() : NULL; }
    LRESULT         HandleSetUndoLimit(LONG Count);
    LRESULT         HandleSetTextMode(DWORD mode);

    CNotifyMgr *    GetNotifyMgr();

    CDetectURL *    GetDetectURL()          {return _pdetecturl;}

    CUniscribe *    Getusp() const          {return GetUniscribe();}

#if !defined(NOMAGELLAN)
    CMagellan       mouse;
    LRESULT         HandleMouseWheel(WPARAM wparam, LPARAM lparam);
#endif

    // Misc helpers
    LONG            GetAcpFromCp(LONG cp, BOOL fPrecise=0);
    LONG            GetCpFromAcp(LONG acp, BOOL fPrecise=0);
    BOOL            Get10Mode() const           {return _f10Mode;}
    LONG            GetCpAccelerator() const    {return _cpAccelerator;}
    short           GetFreezeCount() const      {return _cFreeze;}

    BOOL            fCpMap() const              {return _f10Mode;}
    BOOL            fInOurHost() const          {return _fInOurHost;}
    BOOL            fInplaceActive() const      {return _fInPlaceActive;}
    BOOL            fHideSelection() const      {return _fHideSelection;}
    BOOL            fXltCRCRLFtoCR() const      {return _fXltCRCRLFtoCR;}
    BOOL            fUsePassword() const        {return _fUsePassword;}
    BOOL            fUseCRLF() const            {return _f10Mode;}
    BOOL            fUseLineServices() const    {return _bTypography & TO_ADVANCEDTYPOGRAPHY;}
    BOOL            fUseSimpleLineBreak() const {return (_bTypography & TO_SIMPLELINEBREAK) != 0;}
    BOOL            IsAutoFont() const          {return _fAutoFont;};
    BOOL            IsAutoKeyboard() const      {return _fAutoKeyboard;};
    BOOL            IsAutoFontSizeAdjust() const{return _fAutoFontSizeAdjust;};
    BOOL            IsBiDi() const              {return (_dwCharFlags & fBIDI) != 0;}
    BOOL            IsComplexScript() const     {return _dwCharFlags & fCOMPLEX_SCRIPT;}
    BOOL            IsFE() const                {return (_dwCharFlags & fFE) != 0;}
    BOOL            IsInOutlineView() const     {return _fOutlineView;}
    BOOL            IsMouseDown() const         {return _fMouseDown;}
    BOOL            IsRich() const              {return _fRich;}
    BOOL            IsLeftScrollbar() const;
    BOOL            IsSelectionBarRight() const {return IsLeftScrollbar(); }
    void            SetfSelChangeCharFormat()   {_fSelChangeCharFormat = TRUE; }
    BOOL            DelayChangeNotification()   {return _f10DeferChangeNotify;}
    BOOL            GetOOMNotified()            {return _fOOMNotified;}


    void    SetOOMNotified(BOOL ff)
            {
                Assert(ff == 1 || ff == 0);
                _fOOMNotified = ff;
            }


    //plain-text controls always use the UIFont
    bool            fUseUIFont() const          {return !_fRich || _fUIFont;}
    BOOL            IsTransparent()             {return _fTransparent;}

    LONG            GetZoomNumerator() const    {return _wZoomNumerator;}
    LONG            GetZoomDenominator() const  {return _wZoomDenominator;}
    void            SetZoomNumerator(LONG x)    {_wZoomNumerator = (WORD)x;}
    void            SetZoomDenominator(LONG x)  {_wZoomDenominator = (WORD)x;}
    DWORD           GetCpFirstStrong()          {return _cpFirstStrong;}
    void            SetReleaseHost();
    DWORD           GetCharFlags() const        {return _dwCharFlags;}
    void            OrCharFlags(DWORD dwFlags, IUndoBuilder* publdr = NULL);
    void            Beep();
    void            HandleKbdContextMenu();
    void            Set10Mode();
    void            SetContextDirection(BOOL fUseKbd = FALSE);
    void            ItemizeDoc(IUndoBuilder* publdr = NULL, LONG cchRange = -1);
    HRESULT         UpdateAccelerator();
    HRESULT         UpdateOutline();
    HRESULT         MoveSelection(LPARAM lparam, IUndoBuilder *publdr);
    HRESULT         PopAndExecuteAntiEvent(IUndoMgr *pundomgr, void *pAE);

    HRESULT         CutOrCopySelection(UINT msg, WPARAM wparam, LPARAM lparam,
                                       IUndoBuilder *publdr);

    HRESULT         PasteDataObjectToRange(
                        IDataObject *pdo,
                        CTxtRange *prg,
                        CLIPFORMAT cf,
                        REPASTESPECIAL *rps,
                        IUndoBuilder *publdr,
                        DWORD dwFlags );

    // Story access
    CTxtStory * GetTxtStory () {return &_story;}

    // Get access to cached CCharFormat and CParaFormat structures
    const CCharFormat*  GetCharFormat(LONG iCF)
                            {return _story.GetCharFormat(iCF);}
    const CParaFormat*  GetParaFormat(LONG iPF)
                            {return _story.GetParaFormat(iPF);}

    LONG        Get_iCF()           {return _story.Get_iCF();}
    LONG        Get_iPF()           {return _story.Get_iPF();}
    void        Set_iCF(LONG iCF)   {_story.Set_iCF(iCF);}
    void        Set_iPF(LONG iPF)   {_story.Set_iPF(iPF);}

    HRESULT     HandleStyle(CCharFormat *pCFTarget, const CCharFormat *pCF,
                            DWORD dwMask, DWORD dwMask2);
    HRESULT     HandleStyle(CParaFormat *pPFTarget, const CParaFormat *pPF,
                            DWORD dwMask);

    // Get host interface pointer
    ITextHost2 *GetHost() {return _phost;}

    // Helper for getting CDocInfo ptr and creating it if NULL
    CDocInfo *  GetDocInfo();
    HRESULT     InitDocInfo();

    LONG        GetDefaultTab()
                    {return _pDocInfo ? _pDocInfo->dwDefaultTabStop : lDefaultTab;};
    HRESULT     SetDefaultLCID   (LCID lcid);
    HRESULT     GetDefaultLCID   (LCID *pLCID);
    HRESULT     SetDefaultLCIDFE (LCID lcid);
    HRESULT     GetDefaultLCIDFE (LCID *pLCID);
    HRESULT     SetDocumentType  (LONG DocType);
    HRESULT     GetDocumentType  (LONG *pDocType);
    HRESULT     GetFollowingPunct(LPSTR *plpstrFollowingPunct);
    HRESULT     SetFollowingPunct(LPSTR lpstrFollowingPunct);
    HRESULT     GetLeadingPunct  (LPSTR *plpstrLeadingPunct);
    HRESULT     SetLeadingPunct  (LPSTR lpstrLeadingPunct);
    HRESULT     GetViewKind      (LRESULT *plres);
    HRESULT     SetViewKind      (long Value);
    HRESULT     GetViewScale     (long *pValue);
    HRESULT     SetViewScale     (long Value);

    // Notification Management Methods.  In principle, these methods
    // could form a separate class, but for space savings, they are part
    // of the CTxtEdit class

    HRESULT     TxNotify(DWORD iNotify, void *pv);  //@cmember General-purpose
                                                    // notification
    void        SendScrollEvent(DWORD iNotify);     //@cmember Send scroll
                                                    //  event
    void        SendUpdateEvent();                  //@cmember Send EN_UPDATE
                                                    //  event
                                                    //@cmember Use EN_PROTECTED
    BOOL        QueryUseProtection( CTxtRange *prg, //  to query protection
                    UINT msg,WPARAM wparam, LPARAM lparam);//  usage
                                                    //@cmember Indicates whether
                                                    // protection checking enabled
    BOOL        IsProtectionCheckingEnabled()
                    {return !!(_dwEventMask & ENM_PROTECTED);}

    // FUTURE (alexgo): maybe we can use just one method :-)
    BOOL        IsntProtectedOrReadOnly(UINT msg, WPARAM wparam, LPARAM lparam);

    BOOL        IsProtected(UINT msg, WPARAM wparam, LPARAM lparam);
    BOOL        IsProtectedRange(UINT msg, WPARAM wparam, LPARAM lparam, CTxtRange *prg);

    void        SetStreaming(BOOL flag) {_fStreaming = flag;}
    BOOL        IsStreaming()           {return _fStreaming;}

    DWORD       GetEventMask(){return _dwEventMask;}//@cmember Get event mask
                                                    //@cmember Handles EN_LINK
    BOOL        HandleLinkNotification(UINT msg, WPARAM wparam, LPARAM lparam,
                    BOOL *pfInLink = NULL);

    HRESULT     CloseFile (BOOL bSave);

    // Helper for determine when to load message filter
    BOOL LoadMsgFilter (UINT msg, WPARAM wparam, LPARAM lparam);

    //--------------------------------------------------------------
    // Inline proxies to ITextHost methods
    //--------------------------------------------------------------

    // Persisted properties (persisted by the host)
    // Get methods: called by the Text Services component to get
    // the value of a given persisted property

    // FUTURE (alexgo) !! some of these need to get cleaned up

    BOOL        TxGetAutoSize() const;
    BOOL        TxGetAutoWordSel() const;
    COLORREF    TxGetBackColor() const          {return _phost->TxGetSysColor(COLOR_WINDOW);}
    TXTBACKSTYLE TxGetBackStyle() const;
    HRESULT     TxGetDefaultCharFormat(CCharFormat *pCF, DWORD &dwMask);

    void        TxGetClientRect(LPRECT prc) const {_phost->TxGetClientRect(prc);}
    HRESULT     TxGetExtent(SIZEL *psizelExtents)
                    {return _phost->TxGetExtent(psizelExtents);}
    COLORREF    TxGetForeColor() const          {return _phost->TxGetSysColor(COLOR_WINDOWTEXT);}
    DWORD       TxGetMaxLength() const;
    void        TxSetMaxToMaxText(LONG cExtra = 0);
    BOOL        TxGetModified() const           {return _fModified;}
    HRESULT     TxGetDefaultParaFormat(CParaFormat *pPF);
    TCHAR       TxGetPasswordChar() const;
    BOOL        TxGetReadOnly() const           {return _fReadOnly;}
    BOOL        TxGetSaveSelection() const;
    DWORD       TxGetScrollBars() const ;
    LONG        TxGetSelectionBarWidth() const;
    void        TxGetViewInset(LPRECT prc, CDisplay *pdp) const;
    BOOL        TxGetWordWrap() const;

    BOOL        TxClientToScreen (LPPOINT lppt) {return _phost->TxClientToScreen(lppt); }
    BOOL        TxScreenToClient (LPPOINT lppt) {return _phost->TxScreenToClient(lppt); }


    //  ITextServices 2 wrappers
    BOOL        TxIsDoubleClickPending();
    HRESULT     TxGetWindow(HWND *phwnd);
    HRESULT     TxSetForegroundWindow();
    HPALETTE    TxGetPalette();
    HRESULT     TxGetFEFlags(LONG *pFEFlags);

    // Allowed only when in in-place
    // The host will fail if not in-place
    HDC         TxGetDC()               {return _phost->TxGetDC();}
    INT         TxReleaseDC(HDC hdc)    {return _phost->TxReleaseDC(hdc);}

    // Helper functions for metafile support
    INT         TxReleaseMeasureDC( HDC hMeasureDC );

    void        TxUpdateWindow()
                {
                    _phost->TxViewChange(_fInPlaceActive ? TRUE : FALSE);
                }
    void        TxScrollWindowEx (INT dx, INT dy, LPCRECT lprcScroll, LPCRECT lprcClip,
                                HRGN hrgnUpdate, LPRECT lprcUpdate, UINT fuScroll);

    void        TxSetCapture(BOOL fCapture)
                                        {_phost->TxSetCapture(fCapture);}
    void        TxSetFocus()
                                        {_phost->TxSetFocus();}

    // Allowed any-time

    BOOL        TxShowScrollBar(INT fnBar, BOOL fShow)
                                        {return _phost->TxShowScrollBar(fnBar, fShow);}
    BOOL        TxEnableScrollBar (INT fuSBFlags, INT fuArrowFlags)
                                        {return _phost->TxEnableScrollBar(fuSBFlags, fuArrowFlags);}
    BOOL        TxSetScrollRange(INT fnBar, LONG nMinPos, INT nMaxPos, BOOL fRedraw)
                                        {return _phost->TxSetScrollRange(fnBar, nMinPos, nMaxPos, fRedraw);}
    BOOL        TxSetScrollPos (INT fnBar, INT nPos, BOOL fRedraw)
                                        {return _phost->TxSetScrollPos(fnBar, nPos, fRedraw);}
    void        TxInvalidateRect(const LPRECT prc, BOOL fMode)
                                        {_phost->TxInvalidateRect(prc, fMode);}
    BOOL        TxCreateCaret(HBITMAP hbmp, INT xWidth, INT yHeight)
                                        {return _phost->TxCreateCaret(hbmp, xWidth, yHeight);}
    BOOL        TxShowCaret(BOOL fShow)
                                        {return _phost->TxShowCaret(fShow);}
    BOOL        TxSetCaretPos(INT x, INT y)
                                        {return _phost->TxSetCaretPos(x, y);}
    BOOL        TxSetTimer(UINT idTimer, UINT uTimeout)
                                        {return _phost->TxSetTimer(idTimer, uTimeout);}
    void        TxKillTimer(UINT idTimer)
                                        {_phost->TxKillTimer(idTimer);}
    COLORREF    TxGetSysColor(int nIndex){ return _phost->TxGetSysColor(nIndex);}

    int         TxWordBreakProc(TCHAR* pch, INT ich, INT cb, INT action, LONG cpStart, LONG cp = -1);

    // IME
    HIMC        TxImmGetContext()       {return _phost->TxImmGetContext();}
    void        TxImmReleaseContext(HIMC himc)
                                        {_phost->TxImmReleaseContext( himc );}

    // Selection access
    CTxtSelection *GetSel();
    CTxtSelection *GetSelNC() { return _psel; }
    LONG    GetSelMin() const;
    LONG    GetSelMost() const;
    void    GetSelRangeForRender(LONG *pcpSelMin, LONG *pcpSelMost);
    void    DiscardSelection();


    // Property Change Helpers
    HRESULT OnRichEditChange(BOOL fFlag);
    HRESULT OnTxMultiLineChange(BOOL fMultiLine);
    HRESULT OnTxReadOnlyChange(BOOL fReadOnly);
    HRESULT OnShowAccelerator(BOOL fPropertyFlag);
    HRESULT OnUsePassword(BOOL fPropertyFlag);
    HRESULT OnTxHideSelectionChange(BOOL fHideSelection);
    HRESULT OnSaveSelection(BOOL fPropertyFlag);
    HRESULT OnAutoWordSel(BOOL fPropertyFlag);
    HRESULT OnTxVerticalChange(BOOL fVertical);
    HRESULT NeedViewUpdate(BOOL fPropertyFlag);
    HRESULT OnWordWrapChange(BOOL fPropertyFlag);
    HRESULT OnAllowBeep(BOOL fPropertyFlag);
    HRESULT OnDisableDrag(BOOL fPropertyFlag);
    HRESULT OnTxBackStyleChange(BOOL fPropertyFlag);
    HRESULT OnMaxLengthChange(BOOL fPropertyFlag);
    HRESULT OnCharFormatChange(BOOL fPropertyFlag);
    HRESULT OnParaFormatChange(BOOL fPropertyFlag);
    HRESULT OnClientRectChange(BOOL fPropertyFlag);
    HRESULT OnScrollChange(BOOL fProperyFlag);
    HRESULT OnSetTypographyOptions(WPARAM wparam, LPARAM lparam);
    HRESULT OnHideSelectionChange(BOOL fHideSelection);

    // Helpers
    HRESULT TxCharFromPos(LPPOINT ppt, LRESULT *pacp);
    HRESULT OnTxUsePasswordChange(BOOL fUsePassword);
    HRESULT FormatAndPrint(
                HDC hdcDraw,
                HDC hicTargetDev,
                DVTARGETDEVICE *ptd,
                RECT *lprcBounds,
                RECT *lprcWBounds);

    HRESULT RectChangeHelper(
                CDrawInfo *pdi,
                DWORD dwDrawAspect,
                LONG  lindex,
                void *pvAspect,
                DVTARGETDEVICE *ptd,
                HDC hdcDraw,
                HDC hicTargetDev,
                const RECT **pprcClient,
                RECT *prcLocal);

    //
    // PUBLIC INTERFACE METHODS
    //

    // -----------------------------
    //  IUnknown interface
    // -----------------------------

    virtual HRESULT     WINAPI QueryInterface(REFIID riid, void **ppvObject);
    virtual ULONG       WINAPI AddRef(void);
    virtual ULONG       WINAPI Release(void);

    //--------------------------------------------------------------
    // ITextServices methods
    //--------------------------------------------------------------
    //@cmember Generic Send Message interface
    virtual HRESULT     TxSendMessage(
                            UINT msg,
                            WPARAM wparam,
                            LPARAM lparam,
                            LRESULT *plresult);

    //@cmember Rendering
    virtual HRESULT     TxDraw(
                            DWORD dwDrawAspect,     // draw aspect
                            LONG  lindex,           // currently unused
                            void * pvAspect,        // info for drawing
                                                    // optimizations (OCX 96)
                            DVTARGETDEVICE * ptd,   // information on target
                                                    // device                               '
                            HDC hdcDraw,            // rendering device context
                            HDC hicTargetDev,       // target information
                                                    // context
                            LPCRECTL lprcBounds,    // bounding (client)
                                                    // rectangle
                            LPCRECTL lprcWBounds,   // clipping rect for
                                                    // metafiles
                            LPRECT lprcUpdate,      // dirty rectange insde
                                                    // lprcBounds
                            BOOL (CALLBACK * pfnContinue) (DWORD), // for
                                                    // interupting
                            DWORD dwContinue,       // long displays (currently
                                                    // unused)
                            LONG lViewID);          // Specifies view to redraw

    //@cmember Horizontal scrollbar support
    virtual HRESULT     TxGetHScroll(
                            LONG *plMin,
                            LONG *plMax,
                            LONG *plPos,
                            LONG *plPage,
                            BOOL * pfEnabled );

    //@cmember Horizontal scrollbar support
    virtual HRESULT     TxGetVScroll(
                            LONG *plMin,
                            LONG *plMax,
                            LONG *plPos,
                            LONG *plPage,
                            BOOL * pfEnabled );

    //@cmember Setcursor
    virtual HRESULT     OnTxSetCursor(
                            DWORD dwDrawAspect,     // draw aspect
                            LONG  lindex,           // currently unused
                            void * pvAspect,        // info for drawing
                                                    // optimizations (OCX 96)
                            DVTARGETDEVICE * ptd,   // information on target
                                                    // device                               '
                            HDC hdcDraw,            // rendering device context
                            HDC hicTargetDev,       // target information
                                                    // context
                            LPCRECT lprcClient,
                            INT x,
                            INT y);

    //@cmember Hit-test
    virtual HRESULT     TxQueryHitPoint(
                            DWORD dwDrawAspect,     // draw aspect
                            LONG  lindex,           // currently unused
                            void * pvAspect,        // info for drawing
                                                    // optimizations (OCX 96)
                            DVTARGETDEVICE * ptd,   // information on target
                                                    // device                               '
                            HDC hdcDraw,            // rendering device context
                            HDC hicTargetDev,       // target information
                                                    // context
                            LPCRECT lprcClient,
                            INT x,
                            INT y,
                            DWORD * pHitResult);

    //@member Inplace activate notification
    virtual HRESULT     OnTxInPlaceActivate(const RECT *prcClient);

    //@member Inplace deactivate notification
    virtual HRESULT     OnTxInPlaceDeactivate();

    //@member UI activate notification
    virtual HRESULT     OnTxUIActivate();

    //@member UI deactivate notification
    virtual HRESULT     OnTxUIDeactivate();

    //@member Get text in control
    virtual HRESULT     TxGetText(BSTR *pbstrText);

    //@member Set text in control
    virtual HRESULT     TxSetText(LPCTSTR pszText);

    //@member Get x position of
    virtual HRESULT     TxGetCurTargetX(LONG *);
    //@member Get baseline position
    virtual HRESULT     TxGetBaseLinePos(LONG *);

    //@member Get Size to fit / Natural size
    virtual HRESULT     TxGetNaturalSize(
                            DWORD dwAspect,
                            HDC hdcDraw,
                            HDC hicTargetDev,
                            DVTARGETDEVICE *ptd,
                            DWORD dwMode,
                            const SIZEL *psizelExtent,
                            LONG *pwidth,
                            LONG *pheight);

    //@member Drag & drop
    virtual HRESULT     TxGetDropTarget( IDropTarget **ppDropTarget );

    //@member Bulk bit property change notifications
    virtual HRESULT     OnTxPropertyBitsChange(DWORD dwMask, DWORD dwBits);

    //@cmember Fetch the cached drawing size
    virtual HRESULT     TxGetCachedSize(DWORD *pdwWidth, DWORD *pdwHeight);

    //  IDispatch methods

    STDMETHOD(GetTypeInfoCount)( UINT * pctinfo);

    STDMETHOD(GetTypeInfo)(

      UINT itinfo,
      LCID lcid,
      ITypeInfo **pptinfo);

    STDMETHOD(GetIDsOfNames)(

      REFIID riid,
      OLECHAR **rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID * rgdispid);

    STDMETHOD(Invoke)(

      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS * pdispparams,
      VARIANT * pvarResult,
      EXCEPINFO * pexcepinfo,
      UINT * puArgErr);


    // ITextDocument2 methods
    STDMETHOD(GetName)(BSTR *pName);
    STDMETHOD(GetSelection)(ITextSelection **ppSel);
    STDMETHOD(GetStoryCount)(long *pCount);
    STDMETHOD(GetStoryRanges)(ITextStoryRanges **ppStories);
    STDMETHOD(GetSaved)(long *pValue);
    STDMETHOD(SetSaved)(long Value);
    STDMETHOD(GetDefaultTabStop)(float *pValue);
    STDMETHOD(SetDefaultTabStop)(float Value);
    STDMETHOD(New)();
    STDMETHOD(Open)(VARIANT *pVar, long Flags, long CodePage);
    STDMETHOD(Save)(VARIANT *pVar, long Flags, long CodePage);
    STDMETHOD(Freeze)(long *pCount);
    STDMETHOD(Unfreeze)(long *pCount);
    STDMETHOD(BeginEditCollection)();
    STDMETHOD(EndEditCollection)();
    STDMETHOD(Undo)(long Count, long *prop);
    STDMETHOD(Redo)(long Count, long *prop);
    STDMETHOD(Range)(long cpFirst, long cpLim, ITextRange ** ppRange);
    STDMETHOD(RangeFromPoint)(long x, long y, ITextRange **ppRange);
    STDMETHOD(AttachMsgFilter)(IUnknown *pFilter);
    STDMETHOD(GetEffectColor)( long Index, COLORREF *pcr);
    STDMETHOD(SetEffectColor)( long Index, COLORREF cr);
    STDMETHOD(GetCaretType)( long *pCaretType);
    STDMETHOD(SetCaretType)( long CaretType);
    STDMETHOD(GetImmContext)( long *pContext);
    STDMETHOD(ReleaseImmContext)( long Context);
    STDMETHOD(GetPreferredFont)( long cp, long CodePage, long lOption, long curCodepage,
        long curFontSize, BSTR *pFontName, long *pPitchAndFamily, long *pNewFontSize);
    STDMETHOD(GetNotificationMode)( long *plMode);
    STDMETHOD(SetNotificationMode)( long lMode);
    STDMETHOD(GetClientRect)( long Type, long *pLeft, long *pTop, long *pRight, long *pBottom);
    STDMETHOD(GetSelectionEx)(ITextSelection **ppSel);
    STDMETHOD(GetWindow)( long *phWnd );
    STDMETHOD(GetFEFlags)( long *pFlags );
    STDMETHOD(UpdateWindow)( void );
    STDMETHOD(CheckTextLimit)( long cch, long *pcch );
    STDMETHOD(IMEInProgress)( long lMode );
    STDMETHOD(SysBeep)( void );
    STDMETHOD(Update)( long lMode );
    STDMETHOD(Notify)( long lNotify );

    // IRichEditOle methods
    STDMETHOD(GetClientSite) ( LPOLECLIENTSITE  *lplpolesite);
    STDMETHOD_(LONG,GetObjectCount) (THIS);
    STDMETHOD_(LONG,GetLinkCount) (THIS);
    STDMETHOD(GetObject) ( LONG iob, REOBJECT  *lpreobject,
                          DWORD dwFlags);
    STDMETHOD(InsertObject) ( REOBJECT  *lpreobject);
    STDMETHOD(ConvertObject) ( LONG iob, REFCLSID rclsidNew,
                              LPCSTR lpstrUserTypeNew);
    STDMETHOD(ActivateAs) ( REFCLSID rclsid, REFCLSID rclsidAs);
    STDMETHOD(SetHostNames) ( LPCSTR lpstrContainerApp,
                             LPCSTR lpstrContainerObj);
    STDMETHOD(SetLinkAvailable) ( LONG iob, BOOL fAvailable);
    STDMETHOD(SetDvaspect) ( LONG iob, DWORD dvaspect);
    STDMETHOD(HandsOffStorage) ( LONG iob);
    STDMETHOD(SaveCompleted) ( LONG iob, LPSTORAGE lpstg);
    STDMETHOD(InPlaceDeactivate) (THIS);
    STDMETHOD(ContextSensitiveHelp) ( BOOL fEnterMode);
    STDMETHOD(GetClipboardData) ( CHARRANGE  *lpchrg, DWORD reco,
                                    LPDATAOBJECT  *lplpdataobj);
    STDMETHOD(ImportDataObject) ( LPDATAOBJECT lpdataobj,
                                    CLIPFORMAT cf, HGLOBAL hMetaPict);


private:

    // Get/Set text helpers
    LONG    GetTextRange(LONG cpFirst, LONG cch, TCHAR *pch);
    LONG    GetTextEx(GETTEXTEX *pgt, TCHAR *pch);
    LONG    GetTextLengthEx(GETTEXTLENGTHEX *pgtl);

    //--------------------------------------------------------------
    // WinProc dispatch methods
    // Internally called by the WinProc
    //--------------------------------------------------------------

    // Keyboard
    HRESULT OnTxKeyDown       (WORD vkey, DWORD dwFlags, IUndoBuilder *publdr);
    HRESULT OnTxChar          (WORD vkey, DWORD dwFlags, IUndoBuilder *publdr);
    HRESULT OnTxSysChar       (WORD vkey, DWORD dwFlags, IUndoBuilder *publdr);
    HRESULT OnTxSysKeyDown    (WORD vkey, DWORD dwFlags, IUndoBuilder *publdr);
    HRESULT OnTxSpecialKeyDown(WORD vkey, DWORD dwFlags, IUndoBuilder *publdr);

    // Mouse
    HRESULT OnTxLButtonDblClk(INT x, INT y, DWORD dwFlags);
    HRESULT OnTxLButtonDown  (INT x, INT y, DWORD dwFlags);
    HRESULT OnTxLButtonUp    (INT x, INT y, DWORD dwFlags, int ffOptions);
    HRESULT OnTxRButtonDown  (INT x, INT y, DWORD dwFlags);
    HRESULT OnTxRButtonUp    (INT x, INT y, DWORD dwFlags, int ffOptions);
    HRESULT OnTxMouseMove    (INT x, INT y, DWORD dwFlags, IUndoBuilder *publdr);
    HRESULT OnTxMButtonDown  (INT x, INT y, DWORD dwFlags);
    HRESULT OnTxMButtonUp    (INT x, INT y, DWORD dwFlags);
    HCURSOR TxSetCursor(HCURSOR hcur, BOOL bText)
    {
        return (_phost && _fInOurHost) ? (_phost)->TxSetCursor2(hcur, bText) :
                ::SetCursor(hcur);
    }

    // Timer
    HRESULT OnTxTimer(UINT idTimer);
    void CheckInstallContinuousScroll ();
    void CheckRemoveContinuousScroll ();

    // Scrolling
    HRESULT TxHScroll(WORD wCode, int xPos);
    LRESULT TxVScroll(WORD wCode, int yPos);
    HRESULT TxLineScroll(LONG cli, LONG cach);

    // Magellan mouse scrolling
    BOOL StopMagellanScroll();

    // Paint, size message
    LRESULT OnSize(HWND hwnd, WORD fwSizeType, int nWidth, int nHeight);

    // Selection commands
    LRESULT OnGetSelText(TCHAR *psz);
    LRESULT OnGetSel(LONG *pacpMin, LONG *pacpMost);
    LRESULT OnSetSel(LONG acpMin, LONG acpMost);
    void    OnExGetSel(CHARRANGE *pcr);

    // Editing commands
    void    OnClear(IUndoBuilder *publdr);

    // Format range related commands
    LRESULT OnFormatRange(FORMATRANGE *pfr, SPrintControl prtcon, BOOL fSetupDC = FALSE);

    BOOL    OnDisplayBand(const RECT *prc, BOOL fPrintFromDraw);

    // Scrolling commands
    void    OnScrollCaret();

    // Focus messages
    LRESULT OnSetFocus();
    LRESULT OnKillFocus();

    // System notifications
    HRESULT OnContextMenu(LPARAM lparam);

    // Get/Set other properties commands
    LRESULT OnFindText(UINT msg, DWORD flags, FINDTEXTEX *pftex);
    LRESULT OnGetWordBreakProc();
    LRESULT OnSetWordBreakProc();

    // Richedit stuff

    LRESULT OnGetCharFormat(CHARFORMAT2 *pCF2, DWORD dwFlags);
    LRESULT OnGetParaFormat(PARAFORMAT2 *pPF2, DWORD dwFlags);
    LRESULT OnSetCharFormat(WPARAM wparam, CCharFormat *pCF, IUndoBuilder *publdr,
                            DWORD dwMask, DWORD dwMask2);
    LRESULT OnSetParaFormat(WPARAM wparam, CParaFormat *pPF, IUndoBuilder *publdr,
                            DWORD dwMask);
    LRESULT OnSetFont(HFONT hfont);
    LRESULT OnSetFontSize(LONG yPoint, IUndoBuilder *publdr);

    LRESULT OnDropFiles(HANDLE hDropFiles);

    // Other services
    HRESULT TxPosFromChar(LONG acp, LPPOINT ppt);
    HRESULT TxGetLineCount(LRESULT *plres);
    HRESULT TxLineFromCp(LONG acp, LRESULT *plres);
    HRESULT TxLineLength(LONG acp, LRESULT *plres);
    HRESULT TxLineIndex (LONG ili, LRESULT *plres);
    HRESULT TxFindText(DWORD flags, LONG acpMin, LONG acpMost, const WCHAR *pch,
                       LONG *pacpMin, LONG *pacpMost);
    HRESULT TxFindWordBreak(INT nFunction, LONG acp, LRESULT *plres);

    HRESULT SetText(LPCWSTR pwszText, DWORD flags, LONG CodePage,
                    IUndoBuilder *publdr = NULL, LRESULT *plres = NULL);
    LONG    GetDefaultCodePage(UINT msg);


    // Other miscelleneous
#ifdef DEBUG
    void    OnDumpPed();
#endif

    COleObject * ObjectFromIOB(LONG iob);

    // Only when the selection is going away should this value be NULLed. We
    // use SelectionNull function rather than CTxtSelection::~CTxtSelection
    // to avoid circular dependencies.
    friend void SelectionNull(CTxtEdit *ped);
    void    SetSelectionToNull()
            {if(_fFocus)
                DestroyCaret();
                _psel = NULL;
            }

    // Helper for converting a rich text object to plain text.
    void HandleRichToPlainConversion();

    // Helper for clearing the undo buffers.
    void ClearUndo(IUndoBuilder *publdr);

    // Helper for setting the automatic EOP
    void SetRichDocEndEOP(LONG cchToReplace);

#ifndef MACPORT
    // Helper for OnDropFiles.  Not present on the Macintosh
    LRESULT CTxtEdit::InsertFromFile ( LPCTSTR lpFile );
#endif
//
//  Data Members
//

public:
    static DWORD        _dwTickDblClick;    // time of last double-click
    static POINT        _ptDblClick;        // position of last double-click

    static HCURSOR      _hcurArrow;
//  static HCURSOR      _hcurCross;         // OutlineSymbol drag not impl
    static HCURSOR      _hcurHand;
    static HCURSOR      _hcurIBeam;
    static HCURSOR      _hcurItalic;
    static HCURSOR      _hcurSelBar;

    typedef HRESULT (CTxtEdit::*FNPPROPCHG)(BOOL fPropFlag);

    static FNPPROPCHG   _fnpPropChg[MAX_PROPERTY_BITS];

    // Only wrapper functions should use this member...
    ITextHost2*         _phost;     // host

    // word break procedure
    EDITWORDBREAKPROC   _pfnWB;     // word break procedure

    // display subsystem
    CDisplay *          _pdp;       // display
    CDisplayPrinter *   _pdpPrinter;// display for printer

    // undo
    IUndoMgr *          _pundo;     // the undo stack
    IUndoMgr *          _predo;     // the redo stack

    // data transfer
    CLightDTEngine      _ldte;      // the data transfer engine

    CNotifyMgr          _nm;        // the notification manager (for floating

    // OLE support
    CObjectMgr *        _pobjmgr;   // handles most high-level OLE stuff

    // Re-entrancy && Notification Management
    CCallMgr *          _pcallmgr;

    // URL detection
    CDetectURL *        _pdetecturl;// manages auto-detection of URL strings

    CDocInfo *          _pDocInfo;  // Document info (name, flags, code page)

    CTxtBreaker *       _pbrk;      // text-breaker object

    DWORD               _dwEventMask;           // Event mask

    union
    {
      DWORD _dwFlags;               // All together now
      struct
      {

#define TXTBITS (TXTBIT_RICHTEXT      | \
                 TXTBIT_READONLY      | \
                 TXTBIT_USEPASSWORD   | \
                 TXTBIT_HIDESELECTION | \
                 TXTBIT_VERTICAL      | \
                 TXTBIT_ALLOWBEEP    | \
                 TXTBIT_DISABLEDRAG   )

        //  State information. Flags in TXTBITS must appear in same bit
        //  positions as the following (saves code in Init())

        //  TXTBIT_RICHTEXT         0   _fRich
        //  TXTBIT_MULTILINE        1
        //  TXTBIT_READONLY         2   _fReadOnly
        //  TXTBIT_SHOWACCELERATOR  3
        //  TXTBIT_USEPASSWORD      4   _fUsePassword
        //  TXTBIT_HIDESELECTION    5   _fHideSelection
        //  TXTBIT_SAVESELECTION    6
        //  TXTBIT_AUTOWORDSEL      7
        //  TXTBIT_VERTICAL         8
        //  TXTBIT_SELECTIONBAR     9
        //  TXTBIT_WORDWRAP         10
        //  TXTBIT_ALLOWBEEP        11  _fAllowBeep
        //  TXTBIT_DISABLEDRAG      12  _fDisableDrag
        //  TXTBIT_VIEWINSETCHANGE  13
        //  TXTBIT_BACKSTYLECHANGE  14
        //  TXTBIT_MAXLENGTHCHANGE  15
        //  TXTBIT_SCROLLBARCHANGE  16
        //  TXTBIT_CHARFORMATCHANGE 17
        //  TXTBIT_PARAFORMATCHANGE 18
        //  TXTBIT_EXTENTCHANGE     19
        //  TXTBIT_CLIENTRECTCHANGE 20

#ifdef MACPORT
//NOTE: Different BIT ordering on the MAC requires that we flip the following bit fields.
//      This is because they are unioned with _dwFlags which is bit compared using the
//      TXTBIT_xxx flags
//      IMPORTANT: For Mac, all 32 bits must be filled out, else they'll be shifted.

        DWORD   _fUpdateSelection   :1; // 31: If true, update sel at level 0
        DWORD   _fDragged           :1; // 30: Was the selection actually dragged?
        DWORD   _fKoreanBlockCaret  :1; // 29: Display Korean block caret during Kor IME
        DWORD   _fCheckAIMM         :1; // 28: if FALSE check if client has loaded AIMM
        DWORD   _fInOurHost         :1; // 27: Whether we are in our host
        DWORD   _fSaved             :1; // 26: ITextDocument Saved property
        DWORD   _fHost2             :1; // 25: TRUE iff _phost is a phost2
        DWORD   _fMButtonCapture    :1; // 24: captured mButton down.
        DWORD   _fContinuousScroll  :1; // 23: We have a timer running to support scrolling.

        // Font binding (see also _fAutoFontSizeAdjust)
        DWORD   _fAutoKeyboard      :1; // 22: auto switching keyboard
        DWORD   _fAutoFont          :1; // 21: auto switching font

        // Miscellaneous bits
        DWORD   _fUseUndo           :1; // 20: Only set to zero if undo limit is 0
        DWORD   _f10Mode            :1; // 19: Use Richedit10 behavior

        DWORD   _fRichPrevAccel     :1; // 18: Rich state previous to accelerator
        DWORD   _fWantDrag          :1; // 17: Want to initiate drag & drop
        DWORD   _fStreaming         :1; // 16: Currently streaming text in or out
        DWORD   _fScrollCaretOnFocus:1; // 15: Scroll caret into view on set focus
        DWORD   _fModified          :1; // 14: Control text has been modified
        DWORD   _fIconic            :1; // 13: Control/parent window is iconized
        DWORD   _fDisableDrag       :1; // 12: Disable Drag
        DWORD   _fAllowBeep         :1; // 11: Allow beep at doc boundaries
        DWORD   _fTransparent       :1; // 10: Background transparency
        DWORD   _fMouseDown         :1; // 9: One mouse button is current down
        DWORD   _fEatLeftDown       :1; // 8: Eat the next left down?
        DWORD   _fFocus             :1; // 7: Control has keyboard focus
        DWORD   _fOverstrike        :1; // 6: Overstrike mode vs insert mode
        DWORD   _fHideSelection     :1; // 5: Hide selection when inactive
        DWORD   _fUsePassword       :1; // 4: Whether to use password char
        DWORD   _fInPlaceActive     :1; // 3: Control is in place active
        DWORD   _fReadOnly          :1; // 2: Control is read only
        DWORD   _fCapture           :1; // 1: Control has mouse capture
        DWORD   _fRich              :1; // 0: Use rich-text formatting

#else

        DWORD   _fRich              :1; // 0: Use rich-text formatting
        DWORD   _fCapture           :1; // 1: Control has mouse capture
        DWORD   _fReadOnly          :1; // 2: Control is read only
        DWORD   _fInPlaceActive     :1; // 3: Control is in place active
        DWORD   _fUsePassword       :1; // 4: Whether to use password char
        DWORD   _fHideSelection     :1; // 5: Hide selection when inactive
        DWORD   _fOverstrike        :1; // 6: Overstrike mode vs insert mode
        DWORD   _fFocus             :1; // 7: Control has keyboard focus
        DWORD   _fEatLeftDown       :1; // 8: Eat the next left down?
        DWORD   _fMouseDown         :1; // 9: One mouse button is current down
        DWORD   _fTransparent       :1; // 10: Background transparency
        DWORD   _fAllowBeep         :1; // 11: Allow beep at doc boundaries
        DWORD   _fDisableDrag       :1; // 12: Disable Drag

        DWORD   _fIconic            :1; // 13: Control/parent window is iconized
        DWORD   _fModified          :1; // 14: Control text has been modified
        DWORD   _fScrollCaretOnFocus:1; // 15: Scroll caret into view on set focus
        DWORD   _fStreaming         :1; // 16: Currently streaming text in or out
        DWORD   _fWantDrag          :1; // 17: Want to initiate drag & drop
        DWORD   _fRichPrevAccel     :1; // 18: Rich state previous to accelerator

        // Miscellaneous bits
        DWORD   _f10Mode            :1; // 19: Use Richedit10 behavior
        DWORD   _fUseUndo           :1; // 20: Only set to zero if undo limit is 0

        // Font binding (see also _fAutoFontSizeAdjust)
        DWORD   _fAutoFont          :1; // 21: auto switching font
        DWORD   _fAutoKeyboard      :1; // 22: auto switching keyboard

        DWORD   _fContinuousScroll  :1; // 23: Timer runs to support scrolling
        DWORD   _fMButtonCapture    :1; // 24: captured mButton down
        DWORD   _fHost2             :1; // 25: TRUE iff _phost is a phost2
        DWORD   _fSaved             :1; // 26: ITextDocument Saved property
        DWORD   _fInOurHost         :1; // 27: Whether we are in our host
        DWORD   _fCheckAIMM         :1; // 28: if FALSE check if client has loaded AIMM
        DWORD   _fKoreanBlockCaret  :1; // 29: Display Korean block caret during Kor IME

        // Drag/Drop UI refinement.
        DWORD   _fDragged           :1; // 30: Was the selection actually dragged?
        DWORD   _fUpdateSelection   :1; // 31: If true, update sel at level 0
#endif
      };
    };

#define CD_LTR  2
#define CD_RTL  3

    WORD        _nContextDir        :2; // 0: no context; else CD_LTR or CD_RTL
    WORD        _nContextAlign      :2; // Current context alignment; default CTX_NONE
    WORD        _fNeutralOverride   :1; // Override direction of neutrals for layout
    WORD        _fSuppressNotify    :1; // Don't send SelChange Notification if True

    WORD        _cActiveObjPosTries :2; // Counter protecting against infinite repaint
                                        // loop when trying to put dragged-away
                                        // in-place active object where it belongs

    WORD        _fSingleCodePage    :1; // If TRUE, only allow single code page
                                        // (currently doesn't check streaming...)
    WORD        _fSelfDestruct      :1; // This CTxtEdit is selfdestructing
    WORD        _fAutoFontSizeAdjust:1; // Auto switching font size adjust

    // Miscellaneous bits used for BiDi input
    WORD        _fHbrCaps           :1; // Initialization of state of hebrew and caps lock status

    WORD        _fActivateKbdOnFocus:1; // Activate new kbd layout on WM_SETFOCUS
    WORD        _fOutlineView       :1; // Outline view is active

    // More IME bit
    WORD        _fIMEInProgress     :1; // TRUE if IME composition is in progress

    // Shutdown bit
    WORD        _fReleaseHost       :1; // TRUE if edit control needs to release host in
                                        // edit control destructor.

    union
    {
        WORD    _bEditStyle;
        struct
        {
            WORD    _fSystemEditMode    :1; //     1: Behave more like sys edit
            WORD    _fSystemEditBeep    :1; //     2: Beep when system edit does
            WORD    _fExtendBackColor   :1; //     4: Extend BkClr to margin
            WORD    _fUnusedEditStyle1  :1; //     8: SES_MAPCPS not used
            WORD    _fUnusedEditStyle2  :1; //    16: SES_EMULATE10 not used
            WORD    _fUnusedEditStyle3  :1; //    32: SES_USECRLF not used
            WORD    _fUnusedEditStyle4  :1; //    64: SES_USEAIMM handled in cmsgflt
            WORD    _fUnusedEditStyle5  :1; //   128: SES_NOIME handled in cmsgflt
            WORD    _fUnusedEditStyle6  :1; //   256: SES_ALLOWBEEPS not used
            WORD    _fUpperCase         :1; //   512: Convert all input to upper case
            WORD    _fLowerCase         :1; //  1024: Convert all input to lower case
            WORD    _fNoInputSequenceChk:1; //  2048: Disable ISCheck
            WORD    _fBiDi              :1; //  4096: Set Bidi document
            WORD    _fScrollCPOnKillFocus:1;//  8192: Scroll to cp=0 upon Kill focus
            WORD    _fXltCRCRLFtoCR     :1; // 16384: Translate CRCRLF to CR instead of ' '
            WORD    _fUnUsedEditStyle   :1; // 32768: Unused
        };
    };

    WORD        _fOOMNotified           :1; // flag determining if a OOM notification was already sent
    WORD        _fDualFont              :1; // Dual font support for FE typing
                                            //  Default = TRUE
    WORD        _fUIFont                :1; // If TRUE, use UI font
    WORD        _fItemizePending        :1; // Updated range hasn't been itemized
    WORD        _fSelChangeCharFormat   :1; // TRUE if the selection has been used to change
                                            // the character format of a specific set of
                                            // characters. The purpose of this has to do with
                                            // maintaining the illusion of having a default
                                            // charformat on machines whose default language
                                            // is a complex script i.e. Arabic. The idea is
                                            // that all EM_SETCHARFORMAT messages that would
                                            // just update the default format, are converted
                                            // to SCF_ALL so that all the text has the change
                                            // applied to it. Bug 5462 caused this change.
                                            // (a-rsail).
    WORD        _fExWordBreakProc       :1; // detemines which WordbreakProc Callback to use
                                            // Extended or regular
    WORD        _f10DeferChangeNotify   :1; // 1.0 mode immulation, defer selection change
                                            // notification until the mouse is up
    WORD        _fUnUsed                :9; // Available for use

    DWORD       _dwCharFlags;           // Char flags for text in control

private:
    SHORT       _cpAccelerator;         // Range for accelerator
    BYTE        _bTypography;           // Typography options
    BYTE        _bMouseFlags;           // CTRL, Mouse buttons, SHIFT
    SHORT       _cFreeze;               // Freeze count
    WORD        _wZoomNumerator;
    WORD        _wZoomDenominator;

    // Have to have mouse point on a per-instance basis to handle
    // simultaneous scrolling of two or more controls.
    // TODO: convert this back to DWORD from whence it came (lparam)
    POINT       _mousePt;               // Last known mouse position.

    // NOTE: the int's can be switched to SHORTs, since pixels are used and
    // 32768 pixels is a mighty big screen!

    DWORD       _cchTextMost;           // Maximum allowed text

    DWORD       _cpFirstStrong;         // cp of first strong directional character.
                                        // used for plain text controls whose direcitonality
                                        // depends on text input into the control.


    friend class CRchTxtPtr;

    IUnknown *  _punk;                  // IUnknown to use

    class CUnknown : public IUnknown
    {
        friend class CCallMgr;
    private:

        DWORD   _cRefs;                 // Reference count

    public:

        void    Init() {_cRefs = 1; }

        HRESULT WINAPI QueryInterface(REFIID riid, void **ppvObj);
        ULONG WINAPI    AddRef();
        ULONG WINAPI Release();
    };

    friend class CUnknown;

    CUnknown            _unk;               // Object that implements IUnknown
    CTxtStory           _story;
    CTxtSelection *     _psel;              // Selection object
    ITextMsgFilter *    _pMsgFilter;        // Pointer to message filter.
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_font.h ===
/*
 *	@doc 	INTERNAL
 *
 *	@module _FONT.H -- Declaration of classes comprising font caching |
 *	
 *	Purpose:
 *		Font cache
 *	
 *	Owner: <nl>
 *		David R. Fulmer (original RE 1.0 code)<nl>
 *		Christian Fortini (initial conversion to C++)<nl>
 *		Jon Matousek <nl>
 *
 *	History: <nl>
 *		8/6/95		jonmat Devised dynamic expanding cache for widths.
 *
 *	Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
 */

#ifndef _FONT_H
#define _FONT_H

// Forwards
class CFontCache;
class CDevDesc;
class CDisplay;
// =============================  CCcs  ========================
// CCcs - caches font metrics and character size for one font

#define DEFAULTCACHESIZE	0			// size - 1
#define INITIALCACHESIZE	7			// size - 1 = 7; 2^n-1; size = 8
#define PERFCHECKEPOCH		64			// If changed, you must recalc
										//  and change COLLISION_SHIFT below.

#define COLLISION_SHIFT		3			// log(PERFCHECKEPOCH) / log(2) - 3

static const INT maxCacheSize = 511;

SHORT GetFontNameIndex(const WCHAR *pFontName);
BYTE  GetFontLegitimateSize(LONG iFont, BOOL fUIFont, int cpg);
BOOL  SetFontLegitimateSize(LONG iFont, BOOL fUIFont, BYTE bSize, int cpg);
const WCHAR *GetFontName(LONG iFont);
UINT  GetTextCharsetInfoPri(HDC hdc, FONTSIGNATURE* pcsi, DWORD dwFlags);
DWORD GetFontSignatureFromFace(int ifont, DWORD* pdwFontSig = NULL);
void  FreeFontNames();

enum FONTINDEX
{
	IFONT_ARIAL		= 0,
	IFONT_TMSNEWRMN	= 1,
	IFONT_SYMBOL	= 2,
	IFONT_SYSTEM	= 3
};

typedef unsigned int CCSHASHKEY;

extern const WCHAR *szArial;
extern const WCHAR *szTimesNewRoman;
extern const WCHAR *szSymbol;
extern const WCHAR *szSystem;
extern const WCHAR *szWingdings;

//Not automatically added to font table
extern const WCHAR *szMicrosSansSerif;
extern const WCHAR *szMSSansSerif;
extern const WCHAR *szMangal;
extern const WCHAR *szLatha;
extern const WCHAR *szCordiaNew;
extern const WCHAR *szTahoma;
extern const WCHAR *szArialUnicode;

/*
 *	CWidthCache
 *
 *	@class	Lightweight Unicode width cache.
 *
 *	@devnote Initial size is 52 bytes, 1st step is 100, and exponentially
 *			growing (currently) to 4660 bytes; NOTE, this can be reduced
 *			to 28, 60 and 3100 bytes if shorts are used and appropriate
 *			guarantees are placed on the range of width values.
 *
 *	Owner: <nl>
 *		Jon Matousek (jonmat) <nl>
 */
class CWidthCache
{
//@access	Private methods and data
private:
						
	INT		_cacheSize;			//@cmember	size is total cache slots - 1.

	INT		_cacheUsed;			//@cmember	for statistics, num slots in use.
	INT		_collisions;		//@cmember	for statistics, num fetches required.
	INT		_accesses;			//@cmember	for statistics, total num accesses.
	BOOL	_fMaxPerformance;	//@cmember	for statistics, TRUE if grown to max.

	struct CacheEntry
	{
		WCHAR	ch;
		SHORT	width;
	};

	SHORT	_dxpHangul;
	SHORT	_dxpHan;
							//@cmember	default storage for widths.
	CacheEntry	_defaultWidthCache[DEFAULTCACHESIZE+1];
							//@cmember	pointers to storage for widths.
	CacheEntry *(_pWidthCache);

	inline BOOL	FLookasideCharacter(WCHAR ch)
	{
		if (ch < 0x4E00)
			return FALSE;

		if (IN_RANGE(0x4E00, ch, 0x9FFF) ||		// CJK ideograph
			 IN_RANGE(0xF900, ch, 0xFAFF) ||	// CJK compatibility ideograph
			 IN_RANGE(0xAC00, ch, 0xD7FF))		// Hangul
			 return TRUE;

		return FALSE;
	}

	void FetchLookasideWidth(WCHAR ch, LONG &dxp)
	{
		BOOL fHangul = IN_RANGE(0xAC00, ch, 0xD7FF);

		dxp = fHangul ? _dxpHangul : _dxpHan;
	}

							//@cmember	Get location where width is stored.
	inline CacheEntry * GetEntry( const WCHAR ch )
				{	// logical & is really a MOD, as all of the bits
					// of cacheSize are turned on; the value of cacheSize is
					// required to be of the form 2^n-1.
					return &_pWidthCache[ ch & _cacheSize ];
				}

							//@cmember	See if cache is performing within spec.
	void	CheckPerformance();
							//@cmember	Increase width cache size.
	BOOL	GrowCache( CacheEntry **widthCache, INT *cacheSize, INT *cacheUsed);

	//@access Public Methods
	public:
							//@cmember	Called before GetWidth
	BOOL	CheckWidth (const WCHAR ch, LONG &dxp);
							//@cmember	Fetch width if CheckWidth ret FALSE.
	BOOL	FillWidth (
				HDC hdc,
				const WCHAR ch,
				const SHORT xOverhang,
				LONG &dxp,
				UINT uiCodePage,
				INT iDefWidth);

							//@cmember	Fetch char width.
	INT		GetWidth(const WCHAR ch);
	
	void	Free();			//@cmember	Recycle width cache

	CWidthCache();			//@cmember	Construct width cache
	~CWidthCache();			//@cmember	Free dynamic mem
};


class CCcs
{
	friend class CFontCache;

private:
	CCSHASHKEY _ccshashkey;	// Hash key
	DWORD 	_dwAge;			// for LRU algorithm
	SHORT	_iFont;			// Index into FONTNAME table
	SHORT	_cRefs;			// ref. count

	class CWidthCache _widths;

public:
	DWORD	_dwFontSig;		// Flags from low 32 bits of FONTSIGNATURE fsCsb member

	HDC		_hdc;			// HDC font is selected into
	HFONT 	_hfont;			// Windows font handle
	void*	_sc;			// A handle to the Uniscribe glyph width/font cmap information

	//REVIEW (keithcu) We should make these into at least 24 bit or possibly 32 bit values,
	//or at least use unsigned values so that we don't overflow as easily.
	SHORT	_yHeightRequest;// Font height requested (logical units)
	SHORT	_yHeight;		// Total height of char cell (logical units)
	SHORT 	_yDescent;		// Distance from baseline to char cell bottom (logical units)

	SHORT	_xAveCharWidth;	// Average character width in logical units
	SHORT 	_xOverhangAdjust;// Overhang for synthesized fonts in logical units
	SHORT	_xOverhang;		// Font overhang.
	SHORT	_xUnderhang;	// Font underhang.

	SHORT	_dyULOffset;	// Underline offset
	SHORT	_dyULWidth;		// Underline width
	SHORT	_dySOOffset;	// Strikeout offset
	SHORT	_dySOWidth;		// Strikeout width

	SHORT	_yOffsetSuperscript; //Amount raised if superscipt (positive)
	SHORT	_yOffsetSubscript;//Amount lowered if subscript (negative)

	USHORT	_weight;		// Font weight
	USHORT	_wCodePage;		// Font code page

	BYTE	_bCharSetRequest; //Requested charset
	BYTE	_bCharSet;		// Font CharSet
	BYTE	_bCMDefault;	// Used in calculation of _bConvertMode
	BYTE	_bConvertMode;	// CONVERTMODE: CVT_NONE, CVT_WCTMB, CVT_LOWBYTE
	BYTE	_bPitchAndFamily;// Font pitch and family

	BYTE 	_fValid:1;		// CCcs is valid
	BYTE	_fFixPitchFont:1;// Font has fixed character width
	BYTE	_fItalic:1;		// Font is italic
	BYTE	_fFECharSet:1;	// Font has FE charset
	BYTE	_fForceTrueType:1;// Font has been forced to be truetype

private:

    BOOL    Compare (const CCharFormat * const pCF, HDC hdc);
    BOOL    MakeFont(const CCharFormat * const pCF);
	void 	DestroyFont();
	BOOL	GetMetrics(WCHAR *szNewFaceName = 0);
	HFONT	GetFontWithMetrics(LOGFONT *plf, WCHAR* szNewFaceName);
	BOOL	FillWidth(WCHAR ch, LONG &dxp);

public:
	CCcs ()		{_fValid = FALSE;}
	~CCcs ()	{if(_fValid) Free();}

	void GetOffset(const CCharFormat * const pCF, LONG dypInch,
				   LONG *pyOffset, LONG *pyAdjust);

	BOOL 	Init(const CCharFormat * const pCF);
	void 	Free();
	void 	AddRef() 				{_cRefs++;}
	void 	Release() 				{if(_cRefs) _cRefs--;}

	BOOL	Include(WCHAR ch, LONG &dxp)
	{
		if(!_widths.CheckWidth(ch, dxp))
			return FillWidth(ch, dxp);
		return TRUE;
	}
	BYTE	BestCharSet(BYTE bCharSet, BYTE bCharSetDefault, int fFontMatching);

	SHORT	AdjustFEHeight(BOOL fAjdust)
	{
		return ((fAjdust && _fFECharSet) ? MulDiv(_yHeight, 15, 100) : 0);
	}
};


// FONTINFO cache

typedef union
{
	WORD	wFlags;
	struct
	{
		WORD	fCached			:1;		// Font signature was already cached
		WORD	fBadFaceName	:1;		// Face is junk or doesnt exist in the system
		WORD	fTrueType		:1;		// Font is TrueType
		WORD	fBitmap			:1;		// Font is Bitmap
		WORD	fNonBiDiAscii	:1;		// Font is non-BiDi, single charset and support ASCII
		WORD	fScaleByCpg		:1;		// Scale the font based on given codepage
		WORD	fThaiDTP		:1;		// Thai DTP font
	};
} FONTINFO_FLAGS;

typedef struct
{
	const WCHAR 	*szFontName;
	DWORD 			dwFontSig; 			// font signature
	BYTE			bSizeUI;			// UI font legitimate size (in point)
	BYTE			bSizeNonUI;			// Non-UI font legitimate size
	FONTINFO_FLAGS	ff;					// flags
} FONTINFO;



// =============================  CFontCache  =====================================================
// CFontCache - maintains up to FONTCACHESIZE font caches

class CFontCache
{
	friend class CCcs;

private:
	CCcs	_rgccs[FONTCACHESIZE];
	DWORD 	_dwAgeNext;
	struct {
		CCSHASHKEY	ccshashkey;
		CCcs		*pccs;
	} quickHashSearch[CCSHASHSEARCHSIZE+1];

private:
	CCcs* 	GrabInitNewCcs(const CCharFormat * const pCF, HDC hdc);
	CCSHASHKEY MakeHashKey(const CCharFormat *pCF);
public:
	void Init();

	CCcs*	GetCcs(const CCharFormat * const pCF, const LONG dypInch, HDC hdc = 0, BOOL fForceTrueType = 0);
	FONTINFO_FLAGS	GetInfoFlags(int ifont);
};

extern CFontCache & fc();			// font cache manager

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_host.h ===
/*	@doc INTERNAL
 *
 *	@module _HOST.H  Text Host for Window's Rich Edit Control |
 *	
 *
 *	Original Author: <nl>
 *		Christian Fortini
 *		Murray Sargent
 *
 *	History: <nl>
 *		8/1/95	ricksa	Revised interface definition
 */
#ifndef _HOST_H
#define _HOST_H

#include "textserv.h"
#include "textsrv2.h"
#include "dynarray.hxx"

#ifndef NOACCESSIBILITY
// UNDONE:
//	Need to include this file int the project
#include "oleacc.h"
#endif

/*
 *	TXTEFFECT
 *
 *	@enum	Defines different background styles control
 */
enum TXTEFFECT {
	TXTEFFECT_NONE = 0,				//@emem	no special backgoround effect
	TXTEFFECT_SUNKEN,				//@emem	draw a "sunken 3-D" look
};


// @doc EXTERNAL

// ============================  CTxtWinHost  ================================================
// Implement the windowed version of the Plain Text control

/*
 *	CTxtWinHost
 *	
 * 	@class	Text Host for Window's Rich Edit Control implementation class
 *
 */
class CTxtWinHost : public ITextHost2
#ifndef NOACCESSIBILITY
	, public IAccessible
#endif
{

public:
	HWND		_hwnd;					// control window
	HWND		_hwndParent;			// parent window

	ITextServices	*_pserv;			// pointer to Text Services object

	ULONG		_crefs;					// reference count

// Properties

	DWORD		_dwStyle;				// style bits
	DWORD		_dwExStyle;				// extended style bits

	unsigned	_fBorder			:1;	// control has border
	unsigned	_fInBottomless		:1;	// inside bottomless callback
	unsigned	_fInDialogBox		:1;	// control is in a dialog box
	unsigned	_fEnableAutoWordSel	:1;	// enable Word style auto word selection?
	unsigned	_fIconic			:1;	// control window is iconic
	unsigned	_fHidden			:1;	// control window is hidden
	unsigned	_fNotSysBkgnd		:1;	// not using system background color
	unsigned	_fWindowLocked		:1;	// window is locked (no update)
	unsigned	_fRegisteredForDrop	:1; // whether host has registered for drop
	unsigned	_fVisible			:1;	// Whether window is visible or not.
	unsigned	_fResized			:1;	// resized while hidden
	unsigned	_fDisabled			:1;	// Window is disabled.
	unsigned	_fKeyMaskSet		:1;	// if ENM_KEYEVENTS has been set
	unsigned	_fMouseMaskSet		:1;	// if ENM_MOUSEEVENTS has been set
	unsigned	_fScrollMaskSet		:1;	// if ENM_SCROLLEVENTS has been set
	unsigned	_fUseSpecialSetSel	:1; // TRUE = use EM_SETSEL hack to not select
										// empty controls to make dialog boxes work.
	unsigned	_fEmSetRectCalled	:1;	// TRUE - application called EM_SETRECT
	unsigned	_fAccumulateDBC		:1;	// TRUE - need to cumulate ytes from 2 WM_CHAR msgs
										// we are in this mode when we receive VK_PROCESSKEY
	unsigned	_fANSIwindow		:1;	// TRUE - window created as "RichEdit20A"
	unsigned	_fTextServiceFree	:1;	// TRUE - Text Services freed at shutdown.
	COLORREF 	_crBackground;			// background color
    RECT        _rcViewInset;           // view rect inset /r client rect

	HIMC		_oldhimc;				// previous IME Context
	// TODO: the following could be a two-bit field as part of the unsigned field above
	DWORD		_usIMEMode;				// mode of IME operation
										// either 0 or ES_SELFIME or ES_NOIME
	HPALETTE	_hpal;					// Logical palette to use.

	TCHAR		_chPassword;			// Password char. If null, no password
	TCHAR		_chLeadByte;			// use when we are in _fAccumulateDBC mode
	SHORT		_sWidth;				// Last client width given by WM_SIZE
	char		_yInset;
	char		_xInset;
	CTxtWinHost	*_pnextdel;

public:
	// Initialization
	virtual BOOL Init(
					HWND hwnd,
					const CREATESTRUCT *pcs,
					BOOL fIsAnsi,
					BOOL fIs10Mode);

	void	SetScrollBarsForWmEnable(BOOL fEnable);


	void	OnSetMargins(
				DWORD fwMargin,
				DWORD xLeft,
				DWORD xRight);

	virtual void	SetScrollInfo(
				INT fnBar,
				BOOL fRedraw);

	// helpers
	HRESULT	CreateTextServices();
	void *	CreateNmhdr(UINT uiCode, LONG cb);
	void	HostRevokeDragDrop(void);
	void	HostRegisterDragDrop();
	void	DrawSunkenBorder(HWND hwnd, HDC hdc);
	void    OnSunkenWindowPosChanging(HWND hwnd, WINDOWPOS *pwndpos);
	LRESULT OnSize(HWND hwnd, WORD fwSizeType, int nWidth, int nHeight);
	virtual TXTEFFECT TxGetEffects() const;
	HRESULT	OnTxVisibleChange(BOOL fVisible);
	void	SetDefaultInset();
	BOOL	IsTransparentMode()
	{
		return (_dwExStyle & WS_EX_TRANSPARENT);
	}

	// Keyboard messages
	virtual LRESULT	OnKeyDown(WORD vKey, DWORD dwFlags);
	virtual LRESULT	OnChar(WORD vKey, DWORD dwFlags);
	
	// System notifications
	virtual void 	OnSysColorChange();
	virtual LRESULT OnGetDlgCode(WPARAM wparam, LPARAM lparam);

	// Other messages
	LRESULT OnGetOptions() const;
	void	OnSetOptions(WORD wOp, DWORD eco);
	void	OnSetReadOnly(BOOL fReadOnly);
	void	OnGetRect(LPRECT prc);
	void	OnSetRect(LPRECT prc, BOOL fNewBehavior, BOOL fRedraw);


public:
	CTxtWinHost();
	virtual ~CTxtWinHost();
	void	Shutdown();

	// Window creation/destruction
	static 	CTxtWinHost *OnNCCreate(
						HWND hwnd,
						const CREATESTRUCT *pcs,
						BOOL fIsAnsi,
						BOOL fIs10Mode);

	static 	void 	OnNCDestroy(CTxtWinHost *ped);
	virtual LRESULT OnCreate(const CREATESTRUCT *pcs);

	// -----------------------------
	//	IUnknown interface
	// -----------------------------

    virtual HRESULT 		WINAPI QueryInterface(REFIID riid, void **ppvObject);
    virtual ULONG 			WINAPI AddRef(void);
    virtual ULONG 			WINAPI Release(void);

	// -----------------------------
	//	ITextHost interface
	// -----------------------------
	//@cmember Get the DC for the host
	virtual HDC 		TxGetDC();

	//@cmember Release the DC gotten from the host
	virtual INT			TxReleaseDC(HDC hdc);
	
	//@cmember Show the scroll bar
	virtual BOOL 		TxShowScrollBar(INT fnBar, BOOL fShow);

	//@cmember Enable the scroll bar
	virtual BOOL 		TxEnableScrollBar (INT fuSBFlags, INT fuArrowflags);

	//@cmember Set the scroll range
	virtual BOOL 		TxSetScrollRange(
							INT fnBar,
							LONG nMinPos,
							INT nMaxPos,
							BOOL fRedraw);

	//@cmember Set the scroll position
	virtual BOOL 		TxSetScrollPos (INT fnBar, INT nPos, BOOL fRedraw);

	//@cmember InvalidateRect
	virtual void		TxInvalidateRect(LPCRECT prc, BOOL fMode);

	//@cmember Send a WM_PAINT to the window
	virtual void 		TxViewChange(BOOL fUpdate);
	
	//@cmember Create the caret
	virtual BOOL		TxCreateCaret(HBITMAP hbmp, INT xWidth, INT yHeight);

	//@cmember Show the caret
	virtual BOOL		TxShowCaret(BOOL fShow);

	//@cmember Set the caret position
	virtual BOOL		TxSetCaretPos(INT x, INT y);

	//@cmember Create a timer with the specified timeout
	virtual BOOL 		TxSetTimer(UINT idTimer, UINT uTimeout);

	//@cmember Destroy a timer
	virtual void 		TxKillTimer(UINT idTimer);

	//@cmember Scroll the content of the specified window's client area
	virtual void		TxScrollWindowEx (
							INT dx,
							INT dy,
							LPCRECT lprcScroll,
							LPCRECT lprcClip,
							HRGN hrgnUpdate,
							LPRECT lprcUpdate,
							UINT fuScroll);
	
	//@cmember Get mouse capture
	virtual void		TxSetCapture(BOOL fCapture);

	//@cmember Set the focus to the text window
	virtual void		TxSetFocus();

	//@cmember Establish a new cursor shape
	virtual void		TxSetCursor(HCURSOR hcur, BOOL fText);

	//@cmember Changes the mouse cursor
	virtual HCURSOR		TxSetCursor2(HCURSOR hcur, BOOL bText) { return ::SetCursor(hcur);}

	//@cmember Notification that text services is freed
	virtual void		TxFreeTextServicesNotification();

	//@cmember Converts screen coordinates of a specified point to the client coordinates
	virtual BOOL 		TxScreenToClient (LPPOINT lppt);

	//@cmember Converts the client coordinates of a specified point to screen coordinates
	virtual BOOL		TxClientToScreen (LPPOINT lppt);

	//@cmember Request host to activate text services
	virtual HRESULT		TxActivate( LONG * plOldState );

	//@cmember Request host to deactivate text services
   	virtual HRESULT		TxDeactivate( LONG lNewState );

	//@cmember Retrieves the coordinates of a window's client area
	virtual HRESULT		TxGetClientRect(LPRECT prc);

	//@cmember Get the view rectangle relative to the inset
	virtual HRESULT		TxGetViewInset(LPRECT prc);

	//@cmember Get the default character format for the text
	virtual HRESULT 	TxGetCharFormat(const CHARFORMAT **ppCF );

	//@cmember Get the default paragraph format for the text
	virtual HRESULT		TxGetParaFormat(const PARAFORMAT **ppPF);

	//@cmember Get the background color for the window
	virtual COLORREF	TxGetSysColor(int nIndex);

	//@cmember Get the background (either opaque or transparent)
	virtual HRESULT		TxGetBackStyle(TXTBACKSTYLE *pstyle);

	//@cmember Get the maximum length for the text
	virtual HRESULT		TxGetMaxLength(DWORD *plength);

	//@cmember Get the bits representing requested scroll bars for the window
	virtual HRESULT		TxGetScrollBars(DWORD *pdwScrollBar);

	//@cmember Get the character to display for password input
	virtual HRESULT		TxGetPasswordChar(TCHAR *pch);

	//@cmember Get the accelerator character
	virtual HRESULT		TxGetAcceleratorPos(LONG *pcp);

	//@cmember Get the native size
    virtual HRESULT		TxGetExtent(LPSIZEL lpExtent);

	//@cmember Notify host that default character format has changed
	virtual HRESULT 	OnTxCharFormatChange (const CHARFORMAT * pcf);

	//@cmember Notify host that default paragraph format has changed
	virtual HRESULT		OnTxParaFormatChange (const PARAFORMAT * ppf);

	//@cmember Bulk access to bit properties
	virtual HRESULT		TxGetPropertyBits(DWORD dwMask, DWORD *pdwBits);

	//@cmember Notify host of events
	virtual HRESULT		TxNotify(DWORD iNotify, void *pv);

	// FE Support Routines for handling the Input Method Context
//#ifdef WIN95_IME
	virtual HIMC		TxImmGetContext(void);
	virtual void		TxImmReleaseContext(HIMC himc);
//#endif

	//@cmember Returns HIMETRIC size of the control bar.
	virtual HRESULT		TxGetSelectionBarWidth (LONG *lSelBarWidth);

	// ITextHost2 methods
	virtual BOOL		TxIsDoubleClickPending();
	virtual HRESULT		TxGetWindow(HWND *phwnd);
	virtual HRESULT		TxSetForegroundWindow();
	virtual HPALETTE	TxGetPalette();
	virtual HRESULT		TxGetFEFlags(LONG *pFlags);
	virtual HRESULT		TxGetEditStyle(DWORD dwItem, DWORD *pdwData);
	virtual HRESULT		TxGetWindowStyles(DWORD *pdwStyle, DWORD *pdwExStyle);

#ifndef NOACCESSIBILITY
	ITypeInfo	*_pTypeInfo;

	virtual HRESULT	InitTypeInfo() {return E_NOTIMPL;}
	
	////////////////////////// IDispatch Methods /////////////////////////////////
	STDMETHOD(GetTypeInfoCount)(UINT __RPC_FAR *pctinfo);
	STDMETHOD(GetTypeInfo)(UINT iTInfo, LCID lcid, ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
	STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR __RPC_FAR *rgszNames, UINT cNames,
            				 LCID lcid, DISPID __RPC_FAR *rgDispId);
	STDMETHOD(Invoke)(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS __RPC_FAR *pDispParams,
					  VARIANT __RPC_FAR *pVarResult, EXCEPINFO __RPC_FAR *pExcepInfo, UINT __RPC_FAR *puArgErr);

	////////////////////////// IAccessible Methods /////////////////////////////////
    STDMETHOD(get_accParent)(IDispatch **ppdispParent) {return S_FALSE;}
    STDMETHOD(get_accChildCount)(long *pcountChildren)	{return S_FALSE;}
    STDMETHOD(get_accChild)(VARIANT varChild, IDispatch **ppdispChild) {return S_FALSE;}
    STDMETHOD(get_accName)(VARIANT varChild, BSTR *pszName) {return S_FALSE;}
    STDMETHOD(get_accValue)(VARIANT varChild, BSTR *pszValue) {return S_FALSE;}
    STDMETHOD(get_accDescription)(VARIANT varChild, BSTR *pszDescription) {return S_FALSE;}
    STDMETHOD(get_accRole)(VARIANT varChild, VARIANT *pvarRole) {return S_FALSE;}
    STDMETHOD(get_accState)(VARIANT varChild, VARIANT *pvarState) {return S_FALSE;}
    STDMETHOD(get_accHelp)(VARIANT varChild, BSTR *pszHelp) {return S_FALSE;}
    STDMETHOD(get_accHelpTopic)(BSTR *pszHelpFile, VARIANT varChild, long *pidTopic) {return S_FALSE;}
    STDMETHOD(get_accKeyboardShortcut)(VARIANT varChild, BSTR *pszKeyboardShortcut) {return S_FALSE;}
    STDMETHOD(get_accFocus)(VARIANT *pvarChild) {return S_FALSE;}
    STDMETHOD(get_accSelection)(VARIANT *pvarChildren) {return S_FALSE;}
    STDMETHOD(get_accDefaultAction)(VARIANT varChild, BSTR *pszDefaultAction) {return S_FALSE;}
    STDMETHOD(accSelect)(long flagsSelect, VARIANT varChild) {return S_FALSE;}
    STDMETHOD(accLocation)(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild)
    								{return S_FALSE;}
    STDMETHOD(accNavigate)(long navDir, VARIANT varStart, VARIANT *pvarEndUpAt) {return S_FALSE;}
    STDMETHOD(accHitTest)(long xLeft, long yTop, VARIANT *pvarChild) {return S_FALSE;}
    STDMETHOD(accDoDefaultAction)(VARIANT varChild) {return S_FALSE;}
    STDMETHOD(put_accName)(VARIANT varChild, BSTR szName) {return S_FALSE;}
    STDMETHOD(put_accValue)(VARIANT varChild, BSTR szValue) {return S_FALSE;}
#endif // NOACCESSIBILITY

};

// Work around some client's (MSN chat) problems with host deletions.
void DeleteDanglingHosts();

#define LBS_COMBOBOX    0x8000L
#define LBCB_TRACKING	WM_USER+2
#define LBCBM_PREPARE	1
#define LBCBM_START		2
#define LBCBM_END		3

// mask for LBCBM messages
#define LBCBM_PREPARE_SETFOCUS 1
#define LBCBM_PREPARE_SAVECURSOR 2


class CLbData
{
public:
	unsigned _fSelected	:1;		// indicates if the item has been selected	
	long	_dwData;			// Item data
};

struct CHARSORTINFO
{
	WCHAR*	str;
	int		sz;
};

#define CHECKNOERROR(x) if (NOERROR != x) goto CleanExit

class CCmbBxWinHost;
class CLstBxWinHost : public CTxtWinHost
{
public:
	typedef enum {					
		//kNoSel = 0,					//LBS_NOSEL
		kSingle = 1,					//LBS_SIMPLE
		kMultiple = 2,					//LBS_MULTIPLESEL
		kExtended = 3,					//LBS_EXTENDEDSEL
		kCombo = 8						//Combo box
	} Listtype;

#ifndef ACCESSIBILITY
public:
	// -----------------------------
	//	IUnknown interface
	// -----------------------------

    virtual HRESULT 		WINAPI QueryInterface(REFIID riid, void **ppvObject);
#endif
	
private:
	short _cWheelDelta;					//contains the delta values for mouse wheels
	int _nTopIdx;						//the item index at the top of list
										//Do not touch this unless you know what you are doing!!
public:
	unsigned int _fOwnerDraw	:1;		//indicates if list box is owner draw
	unsigned int _fSort			:1;		//determines if the list should be sorted
	unsigned int _fNoIntegralHeight :1;	//indicates if the size of the listbox should be readjusted according
										//how many items can be fully displayed
	unsigned int _fDisableScroll:1;		//indicates if scroll bar should be displayed at all times
	unsigned int _fNotify		:1;		//notifies parent dialog of activities done in list box.
	unsigned int _fSingleSel 	:1;		// Indicates the list box is a single selection item
	unsigned int _fMouseDown 	:1;		// Indicates if the mouse is down
	unsigned int _fFocus 		:1;		// determines if the control has focus
	unsigned int _fCapture		:1;		// determines if mouse capture is set
	unsigned int _fSearching  	:1;		// indicates if we are in type searching mode
	unsigned int _fDblClick		:1;		// flag indicating double click was received
	unsigned int _fNoResize		:1;		// internal flag to tell us if we should ignore resize messages
	unsigned int _fNotifyWinEvt	:1;		// Indicates only Notify Win Event (ACCESSIBILITY use)

	Listtype _fLstType;					//indicates current type of list box or combo box

#ifndef NOACCESSIBILITY
	DWORD	_dwWinEvent;				// Win Event code (ACCESSIBILITY use)
	int		_nAccessibleIdx;			// Index (ACCESSIBILITY use)
#endif

protected:

	UINT		_idCtrl;				// control's unique id
	COLORREF _crSelFore;				//Selected Forground color
	COLORREF _crSelBack;				//Selected Background color
	COLORREF _crDefFore;				//Default Forground color
	COLORREF _crDefBack;				//Default Background color

	RECT	_rcViewport;				//drawable area for the items
	long _nyFont;						// Font pixel size in y direction
	long _nyItem;						//Height of the items in the list box
	
	int _nViewSize;						//number of items which is viewable at the same time

	int _nCount;						//Number of items in the list box
	int _nAnchor;						//Indicates the top selected item
										//NOTE:
										//  In a single sel list box only _nCursor is used
	int _nCursor;						//Indicates the current item which has the focus

	int _nOldCursor;					//The old cursor position for combo boxes

	int _stvidx;						// This is for a hack to workaround a bug when the display
										// is frozen ITextRange doesn't cache to scroll change

	int _nidxSearch;					// Number of characters in search string
	WCHAR*	_pwszSearch;				// pointer to allocated string
	CDynamicArray<CLbData> _rgData;		// Array/link list of the item data
	LPARAM	_nPrevMousePos;				// Last position from Mousemove message
	CCmbBxWinHost*	_pcbHost;			// pointer to combo box win host

protected:
	// Changes the background color
	BOOL SetColors(DWORD, DWORD, long, long);

	// Makes sure the top item is displayed at the top of the view
	BOOL ScrollToView(long nTop);

	// Sets the requested item to be at the top of the viewable space
	BOOL SetTopViewableItem(long);

	// Searches if a given index qualifies as a match
	BOOL FindString(long idx, LPCTSTR szSearch, BOOL bExact);

	// helper function for the OnMouseMove function
	void MouseMoveHelper(int, BOOL);

	// Set the height of each item in the list box in the given range
	int SetItemsHeight(int,BOOL);

	
public:
	CLstBxWinHost();
	virtual ~CLstBxWinHost();

	void ResizeInset();
	// initialization function
	virtual BOOL Init(HWND,	const CREATESTRUCT *);

	// calculates the height of each item
	void UpdateViewArea();

	// Window creation/destruction
	static 	LRESULT OnNCCreate(HWND hwnd, const CREATESTRUCT *pcs);
	static 	void OnNCDestroy(CLstBxWinHost *ped);
	virtual LRESULT OnCreate(const CREATESTRUCT *pcs);

	////////////////////////// helper functions ////////////////////////////////////
	static wchar_t * wcscat(wchar_t * dst, const wchar_t * src)
	{
        wchar_t * cp = dst;
		while(*cp) cp++;		 // find null character in first string
        while( *cp++ = *src++ ); // Copy src over dst
        return( dst );
	}

	// given a source string the destination string contains a sorted version
	// separated by <CR>
	int SortInsertList(WCHAR* pszDst, WCHAR* pszSrc);

	// Sets the indents for the listbox
	BOOL SetListIndent(int fLeftIndent);

	// Equivalent to CompareString except int is a reference to an item index
	int CompareIndex(LPCTSTR szInsert, int nIndex);
	
	// Returns the position a string should be in a sorted list
	int GetSortedPosition(LPCTSTR, int, int);

	// Updates the system color settings
	void UpdateSysColors();
	
	// Inits search string
	void InitSearch();
	
	// Prevents the window from updating itself
	inline void Freeze();

	// Frees the window to update itself
	inline void Unfreeze();

	// Retrieves the range give the top and bottom index
	BOOL GetRange(long, long, ITextRange**);	

	// Inserts the string at the requested index
	BOOL InsertString(long, LPCTSTR);

	// Removes the string from the listbox
	BOOL RemoveString(long, long);

	// Retrieves the string at the requested index
	long GetString(long, PWCHAR);

	// Deselects all the items in the list box
	BOOL ResetContent();

	// Retrieves the nearest valid item from a given point
	int GetItemFromPoint(const POINT *);

	// Tells if a given points is within the listbox's rect
	BOOL PointInRect(const POINT *);

	// Sets the cursor position and draws the rect
	void SetCursor(HDC, int, BOOL);

	// Recalulates the height so no partial text will be displayed
	BOOL RecalcHeight(int, int);

	// returns of listbox is single selection
	inline BOOL IsSingleSelection() const {return _fSingleSel;}
	
	// Returns the current top index
	inline long GetTopIndex() const { return _nTopIdx;}
	
	// Checks if the mouse has been captured
	inline BOOL GetCapture() const { return _fCapture;}

	// return the item count
	inline int GetCount() const	{return _nCount;}

	// returns the anchor position
	inline int GetAnchor() const {return _nAnchor;}

	// returns the cursor position
	inline int GetCursor() const {return _nCursor;}

	// returns the viewsize
	inline int GetViewSize() const {return _nViewSize;}

	// returns the font height
	inline int GetFontHeight() const {return _nyFont;}

	// returns the item height
	inline int GetItemHeight() const {return _nyItem;}

	// returns the displays freeze count
	inline short FreezeCount() const;

	// initialize mouse wheel variable to zero
	inline void InitWheelDelta() { _cWheelDelta = 0;}

	inline BOOL IsItemViewable(long x) const
	{
		return (GetTopIndex() <= x && (x - GetTopIndex()) * _nyItem < _rcViewport.bottom);
	}

	// Determines if index is selected
	inline BOOL IsSelected(long nIdx)
	{
#ifdef _DEBUG
		Assert(nIdx < -1 || _nCount <= nIdx);
		if (nIdx < -1 || _nCount <= nIdx) return FALSE;
#endif
		if (nIdx < 0)
			return FALSE;
		else
			return _rgData[nIdx]._fSelected;
	}

	// Returns the ItemData of a given index
	inline long GetData(long nIdx)
	{		
		return _rgData.Get(nIdx)._dwData;
	}

	// Returns TRUE if point is within the client area of listbox

	/////////////////////ListBox Message Handling functions /////////////////////////
	// Set the height of the items in the list box
	BOOL LbSetItemHeight(int nHeight);
	
	// Set the selection state for the items in the range
	BOOL LbSetSelection(long, long, int, long, long);

	// Sets the requested item to be at the top of the list box
	long LbSetTopIndex(long);

	// Makes sure the requested index is visible
	BOOL LbShowIndex(long, BOOL);

	// Retrieves the index give a string and starting position
	long LbFindString(long, LPCTSTR, BOOL);	

	// Inserts the string at the requested location
	long LbInsertString(long, LPCTSTR);

	// Range to delete
	long LbDeleteString(long, long);

	// Sets the Item data
	void LbSetItemData(long, long, long);

	// returns the item rect of a given index
	BOOL LbGetItemRect(int, RECT*);

	// Notifies parent when an item is deleted
	void LbDeleteItemNotify(int, int);
	
	// Owner draw function
	void LbDrawItemNotify(HDC, int, UINT, UINT);

	// used to insert a list of strings rather than individually
	int LbBatchInsert(WCHAR* psz);

	///////////////////////// Message Map functions //////////////////////////////
	// if subclassed then make these functions virtual

	// Handles the WM_MOUSEMOVE message
	LRESULT OnMouseWheel(WPARAM, LPARAM);
	
	// Handles the WM_LBUTTONDOWN message
	LRESULT OnLButtonDown(WPARAM wparam, LPARAM lparam);

	// Handles the WM_MOUSEMOVE message
	LRESULT OnMouseMove(WPARAM, LPARAM);

	// Handles the WM_LBUTTONUP message
	LRESULT OnLButtonUp(WPARAM, LPARAM, int ff = 0);

	// Handles the WM_VSCROLL message
	LRESULT OnVScroll(WPARAM, LPARAM);

	// Handles the WM_TIMER message
	LRESULT OnTimer(WPARAM, LPARAM);

	// Handles the WM_KEYDOWN message
	LRESULT OnKeyDown(WPARAM, LPARAM, int);
	
	// Hanldes the WM_CAPTURECHANGED message
	LRESULT OnCaptureChanged(WPARAM, LPARAM);

	// Handles the WM_CHAR message
	virtual LRESULT	OnChar(WORD, DWORD);

	// Handles the WM_SYSCOLORCHANGE message
	virtual void OnSysColorChange();

	// Handles the WM_SETCURSOR message
	LRESULT OnSetCursor();

	//////////////////////////// overridden Tx fn's ////////////////////////////////
	//@cmember Get the bits representing requested scroll bars for the window
	virtual HRESULT	TxGetScrollBars(DWORD *pdwScrollBar);
	
	//@cmember Bulk access to bit properties
	virtual HRESULT	TxGetPropertyBits(DWORD, DWORD *);

	virtual TXTEFFECT TxGetEffects() const;

	//@cmember Notify host of events
	virtual HRESULT	TxNotify(DWORD iNotify, void *pv);

		//@cmember Show the scroll bar
	virtual BOOL TxShowScrollBar(INT fnBar, BOOL fShow);

	//@cmember Enable the scroll bar
	virtual BOOL TxEnableScrollBar (INT fuSBFlags, INT fuArrowflags);

	//@cmember Show the caret
	virtual BOOL TxShowCaret(BOOL fShow) {return TRUE;}

		//@cmember Create the caret
	virtual BOOL TxCreateCaret(HBITMAP hbmp, INT xWidth, INT yHeight) {return FALSE;}

	//@cmember Set the scroll range
	virtual void SetScrollInfo(INT, BOOL);

	/////////////////////////// Combobox helper fn's ///////////////////////////////
	void OnCBTracking(WPARAM, LPARAM);

	static int QSort(CHARSORTINFO rg[], int nStart, int nEnd);


#ifndef NOACCESSIBILITY
	HRESULT	InitTypeInfo();

	////////////////////////// IAccessible Methods /////////////////////////////////
    STDMETHOD(get_accParent)(IDispatch **ppdispParent);
    STDMETHOD(get_accName)(VARIANT varChild, BSTR *pszName);
    STDMETHOD(get_accChildCount)(long *pcountChildren);
    STDMETHOD(get_accRole)(VARIANT varChild, VARIANT *pvarRole);
    STDMETHOD(get_accState)(VARIANT varChild, VARIANT *pvarState);
    STDMETHOD(get_accKeyboardShortcut)(VARIANT varChild, BSTR *pszKeyboardShortcut);
    STDMETHOD(get_accFocus)(VARIANT *pvarChild);
    STDMETHOD(get_accSelection)(VARIANT *pvarChildren);
    STDMETHOD(get_accDefaultAction)(VARIANT varChild, BSTR *pszDefaultAction);
   	STDMETHOD(accSelect)(long flagsSelect, VARIANT varChild);
    STDMETHOD(accLocation)(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild);
    STDMETHOD(accNavigate)(long navDir, VARIANT varStart, VARIANT *pvarEndUpAt);
    STDMETHOD(accHitTest)(long xLeft, long yTop, VARIANT *pvarChild);
    STDMETHOD(accDoDefaultAction)(VARIANT varChild);
#endif // NOACCESSIBILITY
};

#ifndef NOACCESSIBILITY
// --------------------------------------------------------------------------
//
//  Although CListBoxSelection() is based off of IEnumVARIANT.
//	It will hand back the proper IDs so you can pass them to the real
//	listbox parent object.
//
// --------------------------------------------------------------------------
class CListBoxSelection : public IEnumVARIANT
{
    public:
        // IUnknown
        virtual STDMETHODIMP            QueryInterface(REFIID, void**);
        virtual STDMETHODIMP_(ULONG)    AddRef(void);
        virtual STDMETHODIMP_(ULONG)    Release(void);

        // IEnumVARIANT
        virtual STDMETHODIMP            Next(ULONG celt, VARIANT* rgvar, ULONG * pceltFetched);
        virtual STDMETHODIMP            Skip(ULONG celt);
        virtual STDMETHODIMP            Reset(void);
        virtual STDMETHODIMP            Clone(IEnumVARIANT ** ppenum);

        CListBoxSelection(int, int, LPINT);
        ~CListBoxSelection();

    protected:
        int     _cRef;
        int     _idChildCur;
        int     _cSel;
        LPINT   _piSel;
};
#endif

#ifndef DEBUG
#define AttCheckRunTotals(_fCF)
#define AttCheckPFRuns(_fCF)
#endif

#define ECO_STYLES (ECO_AUTOVSCROLL | ECO_AUTOHSCROLL | ECO_NOHIDESEL | \
						ECO_READONLY | ECO_WANTRETURN | ECO_SAVESEL | \
						ECO_SELECTIONBAR | ES_NOIME | ES_SELFIME )

#endif // _HOST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_ime.h ===
/*
 *	@doc 	INTERNAL
 *
 *	@module _ime.h -- support for IME APIs |
 *	
 *	Purpose:
 *		Most everything to do with FE composition string editing passes
 *		through here.
 *	
 *	Authors: <nl>
 *		Jon Matousek  <nl>
 *		Justin Voskuhl  <nl>
 *		Hon Wah Chan  <nl>
 * 
 *	History: <nl>
 *		10/18/1995		jonmat	Cleaned up level 2 code and converted it into
 *								a class hierarchy supporting level 3.
 *
 *	Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved.
 *
 */								 

#ifndef _IME_H
#define _IME_H


class CTextMsgFilter;

// defines for IME Level 2 and 3
#define	IME_LEVEL_2		2
#define IME_LEVEL_3		3
#define IME_PROTECTED	4

/*
 *	IME
 *
 *	@class	base class for IME support.
 *
 *	@devnote
 *		For level 2, at caret IMEs, the IME will draw a window directly over the text giving the
 *		impression that the text is being processed by the application--this is called pseudo inline.
 *		All UI is handled by the IME. This mode is currenlty bypassed in favor of level 3 true inline (TI);
 *		however, it would be trivial to allow a user preference to select this mode. Some IMEs may have
 *		a "special" UI, in which case level 3 TI is *NOT* used, necessitating level 2.
 *
 *		For level 2, near caret IMEs, the IME will draw a very small and obvious window near the current
 *		caret position in the document. This currently occurs for PRC(?) and Taiwan.
 *		All UI is handled by the IME.
 *
 *		For level 3, at caret IMEs, the composition string is drawn by the application, which is called
 *		true inline, bypassing the level 2 "composition window".
 *		Currently, we allow the IME to support all remaining UI *except* drawing of the composition string.
 */
class CIme
{
	friend LRESULT OnGetIMECompositionMode ( CTextMsgFilter &TextMsgFilter );
	friend HRESULT CompositionStringGlue ( const LPARAM lparam, CTextMsgFilter &TextMsgFilter );
	friend HRESULT EndCompositionGlue ( CTextMsgFilter &TextMsgFilter, BOOL fForceDelete);
	friend void CheckDestroyIME ( CTextMsgFilter &TextMsgFilter );


	//@access	Protected data
	protected:
	short	_imeLevel;								//@cmember IME Level 2 or 3
	short	_cIgnoreIMECharMsg;						//@cmember Level 2 IME use to eat WM_IME_CHAR message
	short	_fIgnoreEndComposition;					//@cmember ignore the next End Composition message
	short	_fIMETerminated;						//@cmember indicate this IME has been terminated
	short	_fSkipFirstOvertype;					//@cmember skip first overtype if selection is 
													//	deleted on StartComposition

	//@access	Public methods
	public:
	
	virtual ~CIme() {};

	INT		_compMessageRefCount;					//@cmember so as not to delete if recursed.
	short	_fDestroy;								//@cmember set when object wishes to be deleted.
													//@cmember	Handle WM_IME_STARTCOMPOSITION
	virtual HRESULT StartComposition ( CTextMsgFilter &TextMsgFilter ) = 0;
													//@cmember	Handle WM_IME_COMPOSITION and WM_IME_ENDCOMPOSITION
	virtual HRESULT CompositionString ( const LPARAM lparam, CTextMsgFilter &TextMsgFilter ) = 0;
													//@cmember	Handle post WM_IME_CHAR	to update comp window.
	virtual void PostIMEChar( CTextMsgFilter &TextMsgFilter ) = 0;

													//@cmember	Handle WM_IME_NOTIFY
	virtual HRESULT IMENotify (const WPARAM wparam, const LPARAM lparam, CTextMsgFilter &TextMsgFilter, BOOL fCCompWindow ) = 0;

	virtual BOOL	IMEMouseOperation ( CTextMsgFilter &TextMsgFilter, UINT	msg ) = 0;

	enum TerminateMode
	{ 
			TERMINATE_NORMAL = 1,
			TERMINATE_FORCECANCEL = 2
	};

	void	TerminateIMEComposition(CTextMsgFilter &TextMsgFilter,
				CIme::TerminateMode mode);			//@cmember	Terminate current IME composition session.
	
													//@cmember	check if we need to ignore WM_IME_CHAR messages
	BOOL	IgnoreIMECharMsg() { return _cIgnoreIMECharMsg > 0; }
													//@cmember	skip WM_IME_CHAR message
	void	SkipIMECharMsg() { _cIgnoreIMECharMsg--; }
													//@cmember	accept WM_IME_CHAR message
	void	AcceptIMECharMsg() { _cIgnoreIMECharMsg = 0; }

	static	void	CheckKeyboardFontMatching ( long cp, CTextMsgFilter &TextMsgFilter, ITextFont *pTextFont );	//@cmember	Check current font/keyboard matching.	

	BOOL	IsTerminated ()							//@cmember	Return _fIMETerminated
	{
		return _fIMETerminated; 
	}

	INT		GetIMELevel () 							//@cmember	Return the current IME level.
	{
		return _imeLevel;
	}


	

	//@access	Protected methods



	protected:										//@cmember	Get composition string, convert to unicode.
	
	static INT GetCompositionStringInfo( HIMC hIMC, DWORD dwIndex, WCHAR *uniCompStr, INT cchUniCompStr, BYTE *attrib, INT cbAttrib, LONG *cursorCP, LONG *cchAttrib, UINT kbCodePage, BOOL bUnicodeIME, BOOL bUsingAimm );
	static HRESULT CheckInsertResultString ( const LPARAM lparam, CTextMsgFilter &TextMsgFilter, short *pcch = NULL );


	void	SetCompositionFont ( CTextMsgFilter &TextMsgFilter, ITextFont *pTextFont );	//@cmember	Setup for level 2 and 3 composition and candidate window's font.
	void	SetCompositionForm ( CTextMsgFilter &TextMsgFilter );	//@cmember	Setup for level 2 IME composition window's position.


};

/*
 *	IME_Lev2
 *
 *	@class	Level 2 IME support.
 *
 */
class CIme_Lev2 : public CIme 
{

	//@access	Public methods
	public:											//@cmember	Handle level 2 WM_IME_STARTCOMPOSITION
	virtual HRESULT StartComposition ( CTextMsgFilter &TextMsgFilter );
													//@cmember	Handle level 2 WM_IME_COMPOSITION
	virtual HRESULT CompositionString ( const LPARAM lparam, CTextMsgFilter &TextMsgFilter );
													//@cmember	Handle post WM_IME_CHAR	to update comp window.
	virtual void PostIMEChar( CTextMsgFilter &TextMsgFilter );
													//@cmember	Handle level 2 WM_IME_NOTIFY
	virtual HRESULT IMENotify (const WPARAM wparam, const LPARAM lparam, CTextMsgFilter &TextMsgFilter, BOOL fIgnore );

	virtual BOOL	IMEMouseOperation ( CTextMsgFilter &TextMsgFilter, UINT	msg )
		{return FALSE;}

	CIme_Lev2( CTextMsgFilter &TextMsgFilter );
	virtual ~CIme_Lev2();

	ITextFont	*_pTextFont;						//@cmember  base format	

};

/*
 *	IME_PROTECTED
 *
 *	@class	IME_PROTECTED
 *
 */
class CIme_Protected : public CIme 
{
	//@access	Public methods
	public:											//@cmember	Handle level 2 WM_IME_STARTCOMPOSITION
	virtual HRESULT StartComposition ( CTextMsgFilter &TextMsgFilter )
		{_imeLevel	= IME_PROTECTED; return S_OK;}
													//@cmember	Handle level 2 WM_IME_COMPOSITION
	virtual HRESULT CompositionString ( const LPARAM lparam, CTextMsgFilter &TextMsgFilter );
													//@cmember	Handle post WM_IME_CHAR	to update comp window.
	virtual void PostIMEChar( CTextMsgFilter &TextMsgFilter )
		{}
													//@cmember	Handle level 2 WM_IME_NOTIFY
	virtual HRESULT IMENotify (const WPARAM wparam, const LPARAM lparam, CTextMsgFilter &TextMsgFilter, BOOL fIgnore )
		{return S_FALSE;}
	
	virtual BOOL	IMEMouseOperation ( CTextMsgFilter &TextMsgFilter, UINT	msg )
		{return FALSE;}

};

/*
 *	IME_Lev3
 *
 *	@class	Level 3 IME support.
 *
 */
class CIme_Lev3 : public CIme_Lev2 
{
	//@access	Private data
	private:										

	//@access	Protected data
	protected:
	long	_ichStart;								//@cmember	maintain starting ich.
	long	_cchCompStr;							//@cmember	maintain composition string's cch.

	short	_sIMESuportMouse;						//@cmember IME mouse support
	WPARAM	_wParamBefore;							//@cmember Previous wParam sent to IME
	HWND	_hwndIME;								//@cmember current IME hWnd

	long	_crTextColor;							//@cmember current font text color
	long	_crBkColor;								//@cmember current font background color

	// Helper function
													//@cmember get imeshare color for the attribute
	COLORREF GetIMEShareColor(CIMEShare *pIMEShare, DWORD dwAttribute, DWORD dwProperty);	

	//@access	Public methods
	public:											//@cmember	Handle level 3 WM_IME_STARTCOMPOSITION
	virtual HRESULT StartComposition ( CTextMsgFilter &TextMsgFilter );
													//@cmember	Handle level 3 WM_IME_COMPOSITION
	virtual HRESULT CompositionString ( const LPARAM lparam, CTextMsgFilter &TextMsgFilter );
													//@cmember	Handle level 3 WM_IME_NOTIFY
	virtual HRESULT	IMENotify (const WPARAM wparam, const LPARAM lparam, CTextMsgFilter &TextMsgFilter, BOOL fCCompWindow );

	void			SetCompositionStyle ( CTextMsgFilter &TextMsgFilter, UINT attribute, ITextFont *pTextFont );

	CIme_Lev3( CTextMsgFilter &TextMsgFilter );
	virtual ~CIme_Lev3() {};

	virtual BOOL	IMEMouseOperation ( CTextMsgFilter &TextMsgFilter, UINT	msg );
	virtual BOOL	IMESupportMouse ( CTextMsgFilter &TextMsgFilter );

	public:

	short		_fUpdateWindow;						//@cmember Update Window after closing CandidateWindow

	long GetIMECompositionStart()
	{ return _ichStart; }

	long GetIMECompositionLen()
	{ return _cchCompStr; }

};

/*
 *	Special IME_Lev3 for Korean Hangeul -> Hanja conversion
 *
 *	@class	Hangual IME support.
 *
 */
class CIme_HangeulToHanja : public CIme_Lev3 
{
	//@access	Private data
	private:

	public:		
	CIme_HangeulToHanja( CTextMsgFilter &TextMsgFilter );
													//@cmember	Handle Hangeul WM_IME_STARTCOMPOSITION
	virtual HRESULT StartComposition ( CTextMsgFilter &TextMsgFilter );
													//@cmember	Handle Hangeul WM_IME_COMPOSITION
	virtual HRESULT CompositionString ( const LPARAM lparam, CTextMsgFilter &TextMsgFilter );

	virtual BOOL	IMEMouseOperation ( CTextMsgFilter &TextMsgFilter, UINT	msg )
		{return FALSE;}
};

// Glue functions to call the respective methods of an IME object stored in the ed.
HRESULT StartCompositionGlue ( CTextMsgFilter &TextMsgFilter  );
HRESULT CompositionStringGlue ( const LPARAM lparam, CTextMsgFilter &TextMsgFilter );
HRESULT EndCompositionGlue ( CTextMsgFilter &TextMsgFilter, BOOL fForceDelete);
void	PostIMECharGlue ( CTextMsgFilter &TextMsgFilter );
HRESULT IMENotifyGlue ( const WPARAM wparam, const LPARAM lparam, CTextMsgFilter &TextMsgFilter ); // @parm the containing text edit.
HRESULT	IMEMouseCheck(CTextMsgFilter &TextMsgFilter, UINT *pmsg, WPARAM *pwparam, LPARAM *plparam, LRESULT *plres);

// IME helper functions.
void	IMECompositionFull ( CTextMsgFilter &TextMsgFilter );
LRESULT	OnGetIMECompositionMode ( CTextMsgFilter &TextMsgFilter ); 
BOOL	IMECheckGetInvertRange(CTextMsgFilter *ed, LONG &, LONG &);
void	CheckDestroyIME ( CTextMsgFilter &TextMsgFilter );
BOOL	IMEHangeulToHanja ( CTextMsgFilter &TextMsgFilter );
BOOL	IMEMessage ( CTextMsgFilter &TextMsgFilter, UINT uMsg, 
					WPARAM wParam, LPARAM lParam, BOOL bPostMessage );
HIMC	LocalGetImmContext ( CTextMsgFilter &TextMsgFilter );
void	LocalReleaseImmContext ( CTextMsgFilter &TextMsgFilter, HIMC hIMC );

long	IMEShareToTomUL ( UINT ulID );

#endif // define _IME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_ldte.h ===
/*
 *	@doc INTERNAL
 *
 *	@module _LDTE.H - Lighweight Data Transfer Engine |
 *
 *		Declaration for CLightDTEngine class
 *
 *	Author:
 *		alexgo 3/25/95
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#ifndef __LDTE_H__
#define __LDTE_H__

#include "_m_undo.h"
#include "_dragdrp.h"

class CTxtRange;
class CTxtEdit;

/*
 *	DataObjectInfo
 *
 *	Purpose:
 *		enumeration of bit flags used to indicate what operations
 *		are possible from a given data object.
 */

typedef enum tagDataObjectInfo
{
	DOI_NONE			= 0,
	DOI_CANUSETOM		= 1,	// TOM<-->TOM optimized data transfers
	DOI_CANPASTEPLAIN	= 2,	// plain text pasting available
	DOI_CANPASTERICH	= 4, 	// rich text pasting available 
	DOI_CANPASTEOLE		= 8,	// object may be pasted as an OLE embedding
								// (note that this flag may be combined with
								// others). 
} DataObjectInfo;

class CLightDTEngine;

typedef struct _READHGLOBAL
{								// Used by RtfHGlobalToRange()
	LPSTR	ptext;				// ANSI string remaining to be read
	LONG	cbLeft;				// Bytes remaining (might exceed string len)
} READHGLOBAL;

typedef struct _WRITEHGLOBAL
{								// Used by RtfHGlobalToRange()
	HGLOBAL	hglobal;
	LONG	cch;				// Count of ASCII chars written (a cb)
	LONG	cb;					// Count of bytes in hglobal
} WRITEHGLOBAL;

// the following macro (should be an in-line function...) defines
// the formula by which in-memory buffers will grow. It is exponential
// (sort of "if we needed this much memory, chances are we'll need at
// least as much more) but the actual growth factor should be played with
// to achieve better performance across most common scenarios
#define GROW_BUFFER(cbCurrentSize, cbRequestedGrowth)  (ULONG)max(2*(cbCurrentSize), (cbCurrentSize) + 2*(cbRequestedGrowth))

//DWORD packed flags for PasteDataObjectToRange.  Make sure new values
//are assigned such that flags can be or'd together.
#define PDOR_NONE		0x00000000 //No flags
#define PDOR_NOQUERY	0x00000001 //Do not call QueryAcceptData
#define PDOR_DROP		0x00000002 //This is a drop operation

class CLightDTEngine
{
public:
	CLightDTEngine();

	~CLightDTEngine();

	void Init(CTxtEdit * ped);

	void ReleaseDropTarget();

	void Destroy();

	// clipboard
	HRESULT CopyRangeToClipboard( CTxtRange *prg );
	HRESULT CutRangeToClipboard(  CTxtRange *prg, 
										IUndoBuilder *publdr );
	DWORD	CanPaste( IDataObject *pdo, CLIPFORMAT cf, DWORD flags );

	void	FlushClipboard(void);

	// data object
	HRESULT RangeToDataObject( CTxtRange *prg, LONG lStreamFormat,
										IDataObject **ppdo );
	HRESULT PasteDataObjectToRange( IDataObject *pdo, CTxtRange *prg, 
									CLIPFORMAT cf, REPASTESPECIAL *rps,
									IUndoBuilder *publdr, DWORD dwFlags );
	HRESULT CreateOleObjFromDataObj( IDataObject *pdo, CTxtRange *prg, 
									 REPASTESPECIAL *rps, INT iFormatEtc,
									 IUndoBuilder *publdr );

	// drag drop
	HRESULT GetDropTarget( IDropTarget **ppDropTarget );
	HRESULT StartDrag( CTxtSelection *psel, IUndoBuilder *publdr );
	BOOL fInDrag();

	// file I/O
	LONG LoadFromEs( CTxtRange *prg, LONG lStreamFormat, EDITSTREAM *pes, 
							 BOOL fTestLimit, IUndoBuilder *publdr);
	LONG SaveToEs(	 CTxtRange *prg, LONG lStreamFormat,
							 EDITSTREAM *pes );

	// conversion routines
	HGLOBAL AnsiPlainTextFromRange( CTxtRange *prg );
	HGLOBAL UnicodePlainTextFromRange( CTxtRange *prg );
	HGLOBAL RtfFromRange( CTxtRange *prg, LONG lStreamFormat );

	// direct clipboard support
	HRESULT RenderClipboardFormat(WPARAM wFmt);
	HRESULT RenderAllClipboardFormats();
	HRESULT DestroyClipboard();

	LONG 	ReadPlainText( CTxtRange *prg, EDITSTREAM *pes, BOOL fTestLimit,
								IUndoBuilder *publdr, LONG lStreamFormat);
protected:

	LONG	WritePlainText( CTxtRange *prg, EDITSTREAM *pes, LONG lStreamFormat);
	HRESULT HGlobalToRange(DWORD dwFormatIndex, HGLOBAL hGlobal, LPTSTR ptext,
									CTxtRange *prg,	IUndoBuilder *	publdr);
	HRESULT DIBToRange(HGLOBAL hGlobal,	CTxtRange *prg,	IUndoBuilder *	publdr);
	LONG	GetStreamCodePage(LONG lStreamFormat);

	CTxtEdit *		_ped;
	CDropTarget *	_pdt;		// the current drop target
	IDataObject *	_pdo;		// data object that may be on the clipboard.
	BYTE			_fUseLimit;	// Whether to use limit text in calculation
								// Note: if we need more flags do the bit 
								// field thing.
	BYTE			_fOleless;  // Ole clipboard support?
};

/*
 *	CLightDTEngine::Init (ped)
 *
 *	@mfunc
 *		initializes the object
 */
inline void CLightDTEngine::Init(
	CTxtEdit *ped)					// @parm text 
{
	_ped = ped;
}

/*
 *	CLightDTEngine::ReleaseDropTarget (ped)
 *
 *	@mfunc
 *		Releases the drop target if there is one.
 */
inline void CLightDTEngine::ReleaseDropTarget()
{
	if (_pdt)
	{
		_pdt->Release();
		_pdt = NULL;
	}
}

/*
 *	CLightDTEngine::fInDrag ()
 *
 *	@mfunc
 *		Tells whether a drag operation is occuring
 */
inline BOOL CLightDTEngine::fInDrag()
{
	return (_pdt != NULL) ? _pdt->fInDrag() : FALSE;
}

#endif // !__LDTE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_invar.h ===
/*
 *
 *
 *	_INVAR.H
 *	
 *	Purpose:
 *		Template class designed to call parameterized object's Invariant().
 *
 *	Overview (see also, usage):
 *		1)	declare and define a public const function BOOL Invariant( void ) in your class, with #ifdef DEBUG.
 *		2)	in the source: #define DEBUG_CLASSNAME to be the name of the class you're debugging.
 *		3)	followed by #include "_invar.h"
 *		4)	For every method you wish to check Invariants,
 *			insert the _TEST_INVARIANT_ macro once, usually at the beginning of a routine.
 *			OPTIONAL: You may optionally use the _TEST_INVARIANT_ON (x) to call x's Invariant directly.
 *
 *	Notes:
 *		Invariants are designed to be called at the beginning and upon exit of a routine, 
 *		testing the consistent properties of an object which remain invariant--always the same.
 *
 *		Functions may temporarily make an object inconsistent during their execution.
 *		A generalized invariant test should not be called during these inconsistent times;
 *		if there is a need for a function, which checks invariants, to be called during
 *		an inconsistent object state, a solution will need to be designed--the current design
 *		does not facilitate this.
 *
 *		Because it is entirely possible for an Invariant() function to recurse on itself
 *		causing a stack overflow, the template explicitly prevents this from happening.
 *		The template also prevents invariant-checking during the processing of Assert(),
 *		preventing another type of recursion.
 *
 *		Currently Invariant() returns a BOOL, as I think this allows for it to be called
 *		from the QuickWatch window under VC++2.0. TRUE indicates that the invariant executed
 *		normally.
 *
 *	Usage:
 *		-the _invariant.h header should only be included in source files. An error will occur
 *			if included in another header file. This is to prevent multiple #define DEBUG_CLASSNAME.
 *		-Typical #include into a source file looks like this:
			#define DEBUG_CLASSNAME ClassName
			#include "_invar.h"
 *		-Typical definition of a class' Invariant() method looks like this:
			#ifdef DEBUG
				public:
				BOOL Invariant( void ) const;
				protected:
			#endif	// DEBUG
 *		-Typical declaration of Invariant() looks like this:
			#ifdef DEBUG

			BOOL
			ClassName::Invariant( void ) const
			{
				static LONG	numTests = 0;
				numTests++;				// how many times we've been called.

				// do mega-assert checking here.

				return TRUE;
			}

			#endif	// DEBUG
 *
 *
 *		
 *	
 *	Author:
 *		Jon Matousek (jonmat) 5/04/1995
 *
 *		Any problems? Please let me know.
 */

#ifndef _INVARIANT_H

#define _INVARIANT_H

#ifndef DEBUG_CLASSNAME
prior to including _invariant.h file, you must define DEBUG_CLASSNAME
to be the name of the class for which you are making Invariant() calls.
#endif


#ifdef DEBUG

template < class T >
class InvariantDebug
{
	public:
	InvariantDebug	( const T & t) : _t(t)
 	{
		static volatile BOOL fRecurse = FALSE;

		if ( fRecurse )	return;		/* Don't allow recursion.*/
		
		fRecurse = TRUE;

		_t.Invariant();

		fRecurse = FALSE;
	}

	~InvariantDebug	()
	{
		static volatile BOOL fRecurse = FALSE;

		if ( fRecurse )	return;		/* Don't allow recursion.*/
		
		fRecurse = TRUE;

		_t.Invariant();

		fRecurse = FALSE;
	}

	private:
	 const T &_t;
};

typedef InvariantDebug<DEBUG_CLASSNAME> DoInvariant;

#define _TEST_INVARIANT_ DoInvariant __invariant_tester( *this );
#define _TEST_INVARIANT_ON(x) \
					{\
						static volatile BOOL fRecurse = FALSE;\
						if (FALSE == fRecurse )\
						{\
							fRecurse = TRUE;\
							(x).Invariant();\
							fRecurse = FALSE;\
						}\
					}

#else	// DEBUG

#define _TEST_INVARIANT_
#define _TEST_INVARIANT_ON(x)

#endif	// DEBUG


	// code that should be at the start and end of all Invariant() methods.

#else	// INVARIANT_H

	This file should only be included once per source file. jonmat

#endif	// INVARIANT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_ls.h ===
/*
 *  _LS.H
 *  
 *  Purpose:
 *		Line Services wrapper object class used to connect RichEdit with
 *		Line Services.
 *  
 *  Author:
 *		Murray Sargent
 *
 *	Copyright (c) 1997-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _LS_H
#define _LS_H

extern "C" {
#define ols COls
#define lsrun CLsrun
#define lscontext CLineServices
#include "lscbk.h"
#include "lsdnfin.h"
#include "lsdnset.h"
#include "lstxtcfg.h"
#include "lsimeth.h"
#include "plsline.h"
#include "lslinfo.h"
#include "lschp.h"
#include "lspap.h"
#include "plspap.h"
#include "lstxm.h"
#include "lsdevres.h"
#include "lscontxt.h"
#include "lscrline.h"
#include "lsqline.h"
#include "lssetdoc.h"
#include "lsdsply.h"
#include "heights.h"
#include "lsstinfo.H"
#include "lsulinfo.H"
#include "plsstinf.h"
#include "plsulinf.h"
#include "plstabs.h"
#include "lstabs.h"
#include "robj.h"
#include "ruby.h"
#include "tatenak.h"
#include "warichu.h"
#include "lsffi.h"
#include "lstfset.h"
#include "lsqsinfo.h"
#include "lscell.h"
}

struct CLineServices
{
public:

LSERR WINAPI CreateLine(LSCP cp, long duaWidth,
						BREAKREC *pBreakRecIn,  DWORD cBreakRecIn, DWORD cMaxOut,
						BREAKREC *pBreakRecOut, DWORD *pcBreakRecOut,
						LSLINFO* plsinfo, PLSLINE* pplsline)
				{return LsCreateLine(this, cp, duaWidth,
							pBreakRecIn,  cBreakRecIn, cMaxOut,
							pBreakRecOut, pcBreakRecOut,
							plsinfo, pplsline);}


LSERR WINAPI SetBreaking(DWORD cLsBrk, const LSBRK* rgLsBrk,
					DWORD cKinsokuCat, const BYTE *prgbrkpairsKinsoku)

				{return LsSetBreaking(this, cLsBrk, rgLsBrk,
								cKinsokuCat, prgbrkpairsKinsoku);}

LSERR WINAPI SetDoc(BOOL fDisplay, BOOL fEqualRes, const LSDEVRES* plsdevres)
				{return LsSetDoc(this, fDisplay, fEqualRes, plsdevres);}

LSERR WINAPI DestroyLine(PLSLINE plsline)
				{return LsDestroyLine(this, plsline);}

LSERR WINAPI dnFinishRegular(LSDCP cp, PLSRUN plsrun, PCLSCHP pclschp, PDOBJ pdobj, PCOBJDIM pcobjdim)
				{return LsdnFinishRegular(this, cp, plsrun, pclschp, pdobj, pcobjdim);}

LSERR WINAPI dnQueryObjDimRange(PLSDNODE plsdnode1, PLSDNODE plsdnode2, POBJDIM pobjdim)
				{return LsdnQueryObjDimRange(this, plsdnode1, plsdnode2, pobjdim);}
 
LSERR WINAPI dnSetRigidDup(PLSDNODE plsdnode, LONG dup)
				{return LsdnSetRigidDup(this, plsdnode, dup);}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_line.h ===
/*
 *	_LINE.H
 *	
 *	Purpose:
 *		CLine class
 *	
 *	Authors:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *
 *	Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
 */

#ifndef _LINE_H
#define _LINE_H

#include "_runptr.h"

class CDisplay;
class CMeasurer;
class CRenderer;
class CDispDim;

// ============================	 CLine	=====================================
// line - keeps track of a line of text
// All metrics are in rendering device units

class CLine : public CTxtRun
{
public:
	LONG	_xLeft;			// Line left position (line indent + line shift)
	LONG	_xWidth;		// Line width not incl _xLeft, trailing whitespace
	SHORT	_yHeight;		// Line height
	SHORT	_yDescent;		// Distance from baseline to bottom of line
	SHORT	_xLineOverhang;	// Overhang for the line. 
	WORD	_cchWhite;		// Count of white chars at end of line

	BYTE	_cchEOP;		// Count of EOP chars; 0 if no EOP this line
	BYTE	_bFlags;		// Flags defined below

	BYTE	_bNumber;		// Abstract paragraph number (0 is unnumbered)
	BYTE	_nHeading:4;	// Heading level (0 if not heading)
	BYTE	_fCollapsed:1;	// TRUE if line is collapsed
	BYTE	_fNextInTable:1;// TRUE if next line is in table

public:
	CLine ()	{}
	
	// !!!!! CLine should not have any virtual methods !!!!!!

	// The "big four" line methods: measure, render, CchFromXpos, XposFromCch 
	BOOL Measure (CMeasurer& me, LONG cchMax, LONG xWidth,
				 UINT uiFlags, CLine *pliTarget = NULL);
	BOOL Render (CRenderer& re);

	LONG CchFromXpos(CMeasurer& me, POINT pt, CDispDim *pdispdim = NULL,
					 HITTEST *pHit = NULL, LONG *pcpActual = NULL) const;
	LONG XposFromCch(CMeasurer& me, LONG cchMax, UINT taMode,
					 CDispDim *pdispdim = NULL, LONG *pdy = NULL) const;

	// Helper functions
	LONG GetHeight () const;
	void Init ()					{ZeroMemory(this, sizeof(CLine));}
	BOOL IsEqual (CLine& li);
};

// Line flags
#define fliHasEOP			0x0001		// True if ends with CR or LF
#define fliHasSpecialChars	0x0002		// Has special characters (Euro, etc.)
#define fliHasTabs			0x0004		// set if tabs, *not* iff tabs
#define fliHasOle			0x0008
#define fliFirstInPara		0x0010
#define fliUseOffScreenDC	0x0020		// Line needs to be rendered off
										//  screen to handle change in fonts
#define fliOffScreenOnce	0x0040		// Only render off screen once. Used
										//  for rendering 1st line of an edit
#define fliHasSurrogates	0x0080		// Has Unicode surrogate chars


// ==========================  CLineArray  ===================================
// Array of lines

typedef CArray<CLine>	CLineArray;

// ==========================  CLinePtr	 ===================================
// Maintains position in a array of lines

class CLinePtr : public CRunPtr<CLine>
{
protected:
	CDisplay *	_pdp;
	CLine *		_pLine;	

public:
	CLinePtr (CDisplay *pdp);
	CLinePtr (CLinePtr& rp) : CRunPtr<CLine> (rp)	{}

	void Init ( CLine & );
	void Init ( CLineArray & );
    
	// Alternate initializer
	void 	RpSet(LONG iRun, LONG ich);

	// Direct cast to a run index
	operator LONG() const			{return _iRun;}

	// Get the run index (line number)
	LONG GetLineIndex(void)			{return _iRun;}
	LONG GetAdjustedLineLength();

	LONG GetIch() const				{return _ich;}
	LONG GetCchLeft() const;

	// Dereferencing
	BOOL	IsValid(); 
	CLine *	operator ->() const;		
    CLine &	operator *() const;      
	CLine & operator [](LONG dRun);
	CLine * GetLine() const;
	WORD	GetNumber();
	WORD	GetHeading()	{return GetLine()->_nHeading;}
    
	// Pointer arithmetic
	BOOL	operator --(int);
	BOOL	operator ++(int);

	// Character position control
	LONG	RpGetIch() const		{return _ich;}
	BOOL	RpAdvanceCp(LONG cch);
	BOOL	RpSetCp(LONG cp, BOOL fAtEnd);
    BOOL	OperatorPostDeltaSL(LONG Delta);
    BOOL	RpAdvanceCpSL(LONG cch);

	// Array management 
    // These should assert, but gotta be here
    
    // Strictly speaking, these members should never be called for the single
    // line case.  The base class better assert
    
	void Remove (LONG cRun)
    {
        CRunPtr<CLine>::Remove(cRun);
    }

	BOOL Replace(LONG cRun, CArrayBase *parRun)
    {
        return CRunPtr<CLine>::Replace(cRun,parRun);
    }
	
	// Assignment from a run index
	CRunPtrBase& operator =(LONG iRun) {SetRun(iRun, 0); return *this;}

	LONG	FindParagraph(BOOL fForward);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_m_undo.h ===
/*
 *	_M_UNDO.H
 *
 *	Purpose:
 *		declares multi-level undo interfaces and classes
 *
 *	Author:
 *		alexgo  3/25/95
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef __M_UNDO_H__
#define __M_UNDO_H__

#include "_callmgr.h"

// Forward declaration to get around dependency cycle
class CTxtEdit;
class IUndoBuilder;

/*
 *	MergeDataTypes
 *
 *	@enum	Tags indicating the different data types that can be
 *			sent in IAntiEvent::MergeData
 */
enum MergeDataTypes
{
	MD_SIMPLE_REPLACERANGE	= 1,	//@emem a simple replace range; 
									//usually just typing or backspace
	MD_SELECTIONRANGE		= 2		//@emem the selection location
};

/*
 *	SimpleReplaceRange
 *
 *	@stuct	SimpleReplaceRange | has the data from a replace range operation
 *			*except* for any deleted characters.  If we don't have to save
 *			the deleted characters, we don't.
 */
struct SimpleReplaceRange
{
	LONG	cpMin;		//@field	cpMin of new text
	LONG	cpMax;		//@field	cpMax of new text
	LONG	cchDel;		//@field 	number of characters deleted
};

/*
 *	SELAEFLAGS
 *
 *	@enum	Flags to control how the selection range info should be treated
 */
enum SELAE
{
	SELAE_MERGE = 1,
	SELAE_FORCEREPLACE	= 2
};

/*
 *	SelRange
 *
 *	@struct SelRange | has the data for a selection's location _and_ the 
 *			information needed to generate an undo action for the selection
 *			placement
 *	
 *	@comm	-1 may be used to NO-OP any field
 */
struct SelRange
{
	LONG	cp;			//@field	Active end
	LONG	cch;		//@field	Signed extension
	LONG	cpNext;		//@field	cp for the inverse of this action
	LONG	cchNext;	//@field	Extension for the inverse of this action
	SELAE	flags;		//@field	Controls how this info is interpreted
};

/*
 *	IAntiEvent
 *
 *	Purpose:
 *		AntiEvents undo 'normal' events, like typing a character
 */

class IAntiEvent 
{
public:
	virtual void Destroy( void ) = 0;

	// It should be noted that CTxtEdit * here is really just a general
	// closure, i.e. it could be expressed by void *.  However, since
	// this interface is currently just used internally, I've opted
	// to use the extra type-checking.  alexgo
	virtual HRESULT Undo( CTxtEdit *ped, IUndoBuilder *publdr ) = 0;

	// This method will let us merge in arbitrary data for things like
	// group typing
	virtual HRESULT MergeData( DWORD dwDataType, void *pdata) = 0;

	// This method is called when anti-event is committed to undo stack.
	// Allows us to handle re-entrancy better for OLE objects.
	virtual void OnCommit(CTxtEdit *ped) = 0;

	// These two methods allow AntiEvents to be chained together in
	// a linked list
	virtual	void SetNext( IAntiEvent *pNext ) = 0;
	virtual IAntiEvent *GetNext( void ) = 0;
protected:
	~IAntiEvent() {;}
};

/*
 *	IUndoMgr
 *
 *	Purpose:
 *		interface for managing "stacks" of anti-events
 */

class IUndoMgr
{
public:
	virtual void Destroy( void ) = 0;
	virtual DWORD SetUndoLimit( DWORD dwLim ) = 0;
	virtual DWORD GetUndoLimit( ) = 0;
	virtual HRESULT PushAntiEvent( UNDONAMEID idName, IAntiEvent *pae ) = 0;
	virtual HRESULT PopAndExecuteAntiEvent( void* pAE) = 0;
	virtual UNDONAMEID GetNameIDFromAE( void *pAE) = 0;
	virtual IAntiEvent *GetMergeAntiEvent( void ) = 0;
	virtual void* GetTopAECookie( void ) = 0;
	virtual	void ClearAll() = 0;
	virtual BOOL CanUndo() = 0;
	virtual void StartGroupTyping() = 0;
	virtual void StopGroupTyping() = 0;

protected:
	~IUndoMgr() {;}
};

/*
 *	USFlags
 *
 *	@enum
 *		flags affecting the behaviour of Undo stacks
 */

enum USFlags
{
	US_UNDO				= 1,	//@emem regular undo stack
	US_REDO				= 2		//@emem	Undo stack is for REDO functionality
};
	
/*
 *	CUndoStack
 *	
 *	@class
 *		manages a stack of anti-events.  These anti-events are kept in
 *		a resizable ring buffer.  exports the IUndoMgr interface
 */

class CUndoStack : public IUndoMgr
{
//@access	Public Methods
public:
	virtual void Destroy( void );				//@cmember Destroy
	virtual DWORD SetUndoLimit( DWORD dwLim );	//@cmember Set item limit
	virtual DWORD GetUndoLimit();
	virtual HRESULT PushAntiEvent(UNDONAMEID idName, IAntiEvent *pae); //@cmember
												// add an AE to the stack
	virtual HRESULT PopAndExecuteAntiEvent( void *pAE); //@cmember 
												// execute the most recent anti
												// event or up to dwDoToCookie
	virtual UNDONAMEID GetNameIDFromAE( void *pAE);//@cmember Get
												//name of the given AE
	virtual IAntiEvent *GetMergeAntiEvent( void ); //@cmember get the most
												//recent AE of the merge state
	virtual void* GetTopAECookie( void );	 	//@cmember get a cookie for the
												//top AE

	virtual	void ClearAll();					//@cmember delete all AEs
	virtual BOOL CanUndo();						//@cmember something to undo?
	virtual void StartGroupTyping();			//@cmember starts group typing
	virtual void StopGroupTyping();				//@cmember stops group typing

	// Public methods; not part of IUndoMgr
	HRESULT	EnableSingleLevelMode();			//@cmember RE1.0 undo mode
	void	DisableSingleLevelMode();			//@cmember back to RE2.0 mode
												//@cmember are we in 1.0 mode?
	BOOL	GetSingleLevelMode() { return _fSingleLevelMode; }

	CUndoStack( CTxtEdit *ped, DWORD & rdwLim, USFlags flags );

private:
	~CUndoStack();

	struct UndoAction
	{
		IAntiEvent *	pae;
		UNDONAMEID		id;
	};

	void Next( void );							//@cmember advances by 1		
	void Prev( void );							//@cmember advances by -1
	DWORD GetPrev( void );						//@cmember get previous index
												//@cmember TRUE iff cookie
												// ae in in ae list 
	BOOL IsCookieInList( IAntiEvent *pae, IAntiEvent *paeCookie);
												//@cmember transfer this object to
												// a new stack
	void TransferToNewBuffer(UndoAction *prgnew, DWORD dwLimNew);

	UndoAction *_prgActions;					//@cmember The list of AEs

	DWORD 		_dwLim;							//@cmember the undo limit
	DWORD		_index;							//@cmember current index
	CTxtEdit *	_ped;							//@cmember Big Papa

	unsigned long	_fGroupTyping	: 1;		//@cmember Group Typing flag
	unsigned long	_fMerge			: 1;		//@cmember Merge flag
	unsigned long	_fRedo			: 1;		//@cmember Stack is the redo
												// stack.
	unsigned long	_fSingleLevelMode :1;		//@cmember Indicates if single
												// level undo mode is on. Valid
												// only for the undo stack
												// but not the redo stack
};

/*
 *	IUndoBuilder
 *
 *	Purpose:
 *		provides a closure for collecting a sequence of anti-events (such
 *		as all of the anti-events involved in doing an intra-edit drag-move
 *		operation.
 */

class IUndoBuilder
{
public:
	// Names anti-event collection
	virtual void SetNameID( UNDONAMEID idName ) = 0;

	// Adds a new anti-event to the collection
	virtual HRESULT AddAntiEvent( IAntiEvent *pae ) = 0;

	// Gets top most anti-event in this undo context.  This method
	// is useful for grouped typing (merging anti-events)
	virtual IAntiEvent *GetTopAntiEvent( ) = 0;

	// Commits anti-event collection
	virtual HRESULT Done( void ) = 0;

	// Get rid of any anti-events that have been collected.
	virtual void Discard( void ) = 0;

	// Notify that a group-typing session should start (forwarded
	// to the undo manager)
	virtual void StartGroupTyping() = 0;

	// Notify that a group-typing session should stop (forwarded
	// to the undo manager)
	virtual void StopGroupTyping() = 0;
};  

/*
 *	UBFlags
 *
 *	@enum
 *		flags affecting the behaviour of Undo builders
 */

enum UBFlags
{
	UB_AUTOCOMMIT		= 1,	//@emem call IUndoBuilder::Done before delete
	UB_REDO				= 2,	//@emem	Undo builder is for REDO functionality
	UB_DONTFLUSHREDO	= 4		//@emem don't flush redo stack when adding
								// anti-events to the undo stack
};

/*
 *	CGenUndoBuilder
 *
 *	@class
 *		A general purpose undo builder.  It can be easily allocated and freed
 *		on the stack and simply puts new anti-events at the beginning of an
 *		anti-event linked list.  NO attempt is made to optimize or reorder
 *		anti-events.
 */

class CGenUndoBuilder : public IUndoBuilder, public IReEntrantComponent
{
//@access	Public methods
public:
	virtual void SetNameID( UNDONAMEID idName );	//@cmember set the name
	virtual HRESULT AddAntiEvent(IAntiEvent *pae);	//@cmember add an AE
	virtual IAntiEvent *GetTopAntiEvent( );			//@cmember get top AE
	virtual HRESULT Done( void );					//@cmember Commit AEs
	virtual void Discard( void );					//@cmember Discard AEs
	virtual void StartGroupTyping(void);			//@cmember start GT
	virtual void StopGroupTyping(void);				//@cmember stop GT

	CGenUndoBuilder(CTxtEdit *ped, DWORD flags,		//@cmember Constructor
					IUndoBuilder **ppubldr = NULL);
	~CGenUndoBuilder( );							//@cmember Destructor

	// IReEntrantComponent methods
	virtual void OnEnterContext() {;}				//@cmember reentered notify

//@access	Private methods
private:
	IUndoBuilder *	_publdrPrev;					//@cmember Ptr to undobldr
													//		   higher in stack
	IUndoMgr *		_pundo;							//@cmember Ptr to undo mgr
	CTxtEdit *		_ped;							//@cmember Ptr to edit contxt
	UNDONAMEID		_idName;						//@cmember current name
	IAntiEvent *	_pfirstae;						//@cmember AE list
	UINT			_fAutoCommit:1;					//@cmember AutoCommit on?
	UINT			_fStartGroupTyping:1;			//@cmember GroupTyping on?
	UINT			_fRedo:1;						//@cmember UB destination is
													// the redo stack
	UINT			_fDontFlushRedo:1;				//@cmember Don't flush redo
													// stack; i.e. we are
													// invoking a redo action
	UINT			_fInactive:1;					//@cmember TRUE if undo enabled
};


/*
 *	CUndoStackGuard
 *
 *	@class
 *		A stack based class which helps manage re-entrancy for the undo stack.
 */
class CUndoStackGuard : public IReEntrantComponent
{
//@access	Public Methods
public:
	virtual void OnEnterContext();					//@cmember reentered notify

	CUndoStackGuard(CTxtEdit *ped);					//@cmember Constructor
	~CUndoStackGuard();								//@cmember Destructor

													//@cmember Execute the undo
													// actions in <p pae>
	HRESULT SafeUndo(IAntiEvent *pae, IUndoBuilder *publdr);
	BOOL	WasReEntered()  { return _fReEntered; }	//@cmember return the 
													// re-entered flag

//@access	Private Data
private:
	CTxtEdit *				_ped;					//@cmember Edit context
	volatile IAntiEvent *	_paeNext;				//@cmember Loop index for
													// the ae's
	volatile HRESULT		_hr;					//@cmember Cached hr
	IUndoBuilder *			_publdr;				//@cmember Undo/redo
													// context
	BOOL					_fReEntered;			//@cmember Have we been
													// been re-entered?
};

// Helper Functions. 

// Loop through a chain of anti-events and destroy them
void DestroyAEList(IAntiEvent *pae);

// Loop through a chain of anti-events and call OnCommit
void CommitAEList(IAntiEvent *pae, CTxtEdit *ped);

// Handles merging and/or creation of selection anti-event info
HRESULT HandleSelectionAEInfo(CTxtEdit *ped, IUndoBuilder *publdr, 
			LONG cp, LONG cch, LONG cpNext, LONG cchNext, SELAE flags);

#endif // !__M_UNDO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_measure.h ===
/*
 *	_MEASURE.H
 *	
 *	Purpose:
 *		CMeasurer class
 *	
 *	Authors:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 */

#ifndef _MEASURE_H
#define _MEASURE_H

#include "_rtext.h"
#include "_line.h"
#include "_disp.h"

#ifdef LINESERVICES
#include "_ols.h"
#endif

class CCcs;
class CDevDesc;
class CPartialUpdate;
class CUniscribe;

const short BITMAP_WIDTH_SUBTEXT = 4;
const short BITMAP_HEIGHT_SUBTEXT = 4;

const short BITMAP_WIDTH_HEADING = 10;
const short BITMAP_HEIGHT_HEADING = 10;

#define TA_STARTOFLINE	32768
#define TA_ENDOFLINE	16384
#define TA_LOGICAL		8192

// ===========================  CMeasurer  ===============================
// CMeasurer - specialized rich text pointer used to compute text metrics.
// All metrics are computed and stored in device units for the device
// indicated by _pdd.
class CMeasurer : public CRchTxtPtr
{
	friend class CDisplay;
	friend class CDisplayML;
	friend class CDisplayPrinter;
	friend class CDisplaySL;
	friend class CLine;
	friend struct COls;
	friend class CUniscribe;

public:
	CMeasurer (const CDisplay* const pdp);
	CMeasurer (const CDisplay* const pdp, const CRchTxtPtr &rtp);
	virtual ~CMeasurer();

	const CDisplay* GetPdp() const 		{return _pdp;}

	void 	AdjustLineHeight();
	LONG	GetDyrInch()				{return _dyrInch;}
	LONG	GetDxrInch()				{return _dxrInch;}

	LONG	GetDypInch()				{return _dypInch;}
	LONG	GetDxpInch()				{return _dxpInch;}

#ifdef LINESERVICES
	COls *	GetPols(CMeasurer **ppme);
	CUniscribe* Getusp() const { return GetPed()->Getusp(); }
#endif

	CCcs*	GetCcs(const CCharFormat *pCF);
	CCcs*	GetCcsFontFallback(const CCharFormat *pCF);
	CCcs*	ApplyFontCache(BOOL fFallback);
	
	void	CheckLineHeight();
	CCcs *	Check_pccs(BOOL fBullet = FALSE);
	LONG	GetNumber() const			{return _wNumber;}
	WCHAR	GetPasswordChar() const		{return _chPassword;}
	const CParaFormat *Get_pPF()		{return _pPF;}
	LONG	GetCch() const				{return _li._cch;}
	void	SetCch(LONG cch)			{_li._cch = cch;}
	CLine & GetLine(void)				{return _li;}
	HITTEST	HitTest(LONG x);

	BOOL	fFirstInPara() const		{return _li._bFlags & fliFirstInPara;}
	BOOL	fUseLineServices() const	{return GetPed()->fUseLineServices();}
	BOOL	IsRenderer() const			{return _fRenderer;}
	LONG	LXtoDX(LONG x);
	LONG	LYtoDY(LONG y);

	void	NewLine(BOOL fFirstInPara);
	void	NewLine(const CLine &li);
	LONG    MeasureLeftIndent();
	LONG	MeasureRightIndent();
	LONG 	MeasureLineShift();
	LONG	MeasureText(LONG cch);
	BOOL 	MeasureLine(
					LONG cchMax,
					LONG xWidthMax,
					UINT uiFlags, 
					CLine* pliTarget = NULL);
	LONG	MeasureTab(unsigned ch);
	void	SetNumber(WORD wNumber);
	void	UpdatePF()					{_pPF = GetPF();}
	LONG	XFromU(LONG u);
	LONG	UFromX(LONG x);
	CCcs*	GetCcsBullet(CCharFormat *pcfRet);
	void	SetUseTargetDevice(BOOL fUseTargetDevice);
	BOOL	FUseTargetDevice(void)		{return _fTarget || _dypInch == _dyrInch;}
	BOOL	fAdjustFELineHt()			{return _fAdjustFELineHt;}
	void	SetGlyphing(BOOL fGlyphing);

protected:
	void	Init(const CDisplay *pdp);
	LONG 	Measure(LONG xWidthMax, LONG cchMax, UINT uiFlags);
	LONG	MeasureBullet();
	LONG	GetBullet(WCHAR *pch, CCcs *pccs, LONG *pxWidth);

	BOOL	FormatIsChanged();
	void	ResetCachediFormat();
	LONG	DXtoLX(LONG x);	

private:
    void 	RecalcLineHeight(CCcs *,
			const CCharFormat * const pCF);	// Helper to recalc max line height
	LONG	MaxWidth();					// Helper for calc max width

protected:
		  CLine		_li;			// Line we are measuring

	const CDevDesc*	_pddReference;	// Reference device
		  LONG		_dyrInch;		// Resolution of reference device
		  LONG		_dxrInch;

	const CDisplay*	_pdp;			// Display we are operating in
		  LONG		_dypInch;		// Resolution of presentation device
		  LONG		_dxpInch;

		  CCcs*		_pccs;			// Current font cache
		  const CParaFormat *_pPF;	// Current CParaFormat

		  SHORT		_xAddLast;		// Last char considered but unused for line
		  WCHAR		_chPassword;	// Password character if any
		  WORD		_wNumber;		// Number offset
		  SHORT		_iFormat;		// Current format
		  BYTE		_dtRef;			// Device Caps technology for reference device
		  BYTE		_dtPres;		// Device Caps technology for presentation device
		  BYTE		_fRenderer:1;	// 0/1 for CMeasurer/CRenderer, resp.
		  BYTE		_fTarget:1;		// TRUE if we are supposed to be using
									//  reference metrics for laying out text
		  BYTE	_fAdjustFELineHt:1;	// TRUE if we need to adjust line height
									//	 for FE run
		  BYTE		_fFallback:1;	// Current font cache is fallback font
		  BYTE		_fGlyphing:1;	// In the process of creating glyphs
};


// Values for uiFlags in MeasureLine()
#define MEASURE_FIRSTINPARA 	0x0001
#define MEASURE_BREAKATWORD 	0x0002
#define MEASURE_BREAKBEFOREWIDTH 0x0004	// Breaks at character before target width
#define MEASURE_IGNOREOFFSET	0x0008
#define MEASURE_DONTINIT		0x0020


// Returned error codes for Measure(), MeasureText(), MeasureLine()
#define MRET_FAILED		-1
#define MRET_NOWIDTH	-2

inline BOOL CMeasurer::FormatIsChanged()
{
	return !_pccs || _iFormat != _rpCF.GetFormat() || _fFallback;
}

inline void CMeasurer::ResetCachediFormat()
{
	_iFormat = _rpCF.GetFormat();
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_notmgr.h ===
/*
 *	_NOTMGR.H
 *
 *	Purpose:
 *		Notification Manager declarations
 *
 *	Author:
 *		AlexGo	6/5/95
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#ifndef _NOTMGR_H_
#define _NOTMGR_H_

// forward declaration
class CNotifyMgr;

// Set cp to this to signal that the control has converted from rich to plain.
const DWORD CONVERT_TO_PLAIN = 0xFFFFFFFE;


/*
 *	ITxNotify
 *
 *	Purpose:
 *		a notification sink for events happening to the backing store,
 *		used by the Notification Manager
 */
class ITxNotify
{
public:
	virtual void OnPreReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
					LONG cpFormatMin, LONG cpFormatMax ) = 0;
	virtual void OnPostReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
					LONG cpFormatMin, LONG cpFormatMax ) = 0;
	virtual void Zombie() = 0;

private:
	ITxNotify *	_pnext;

	friend class CNotifyMgr;	// so it can manipulate _pnext
};


/*
 *	CNotifyMgr
 *
 *	Purpose:
 *		the general notification manager; keeps track of all interested 
 *		notification sinks
 */

class CNotifyMgr
{
public:
	void Add( ITxNotify *pITN );
	void Remove( ITxNotify *pITN );
	void NotifyPreReplaceRange( ITxNotify *pITNignore, LONG cp, LONG cchDel, 
			LONG cchNew, LONG cpFormatMin, LONG cpFormatMax );
	void NotifyPostReplaceRange( ITxNotify *pITNignore, LONG cp, LONG cchDel, 
			LONG cchNew, LONG cpFormatMin, LONG cpFormatMax );

	CNotifyMgr();
	~CNotifyMgr();

private:

	ITxNotify *	_pitnlist;
};

#endif //_NOTMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_magelln.h ===
/*
 *	@doc
 *
 *	@module _MAGELLN.H -- Declaration of class to handle Magellan mouse. |
 *	
 *	Authors: <nl>
 *		Jon Matousek 
 *
 *	Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved.
 */

#if !defined(_MAGELLN_H) && !defined(NOMAGELLAN)	// Win NT/95 only class.
#define _MAGELLN_H

#include "_edit.h"


// All of the knobs for magellan mouse scrolling.

const LONG	DEAD_ZONE_TWIPS			= 60;	// 3 pixels normally
const DWORD FAST_ROLL_SCROLL_TRANSITION_TICKS = 900;  // in mili seconds.
const INT FASTER_ROLL1_COUNT		= 5;
const INT FASTER_ROLL2_COUNT		= 10;

const WORD SMOOTH_ROLL_CLINES		= 2;	// multiples of rolls for roll1, roll2.
const int SMOOTH_ROLL_NUM			= 1;
const int SMOOTH_ROLL_DENOM			= 3;

class CMagellan {

	friend class CMagellanBMPStateWrap;

private:
	VOID CheckInstallMagellanTrackTimer (CTxtEdit &ed);
	VOID CheckRemoveMagellanUpdaterTimer (CTxtEdit &ed);
	BOOL InvertMagellanDownBMP ( CDisplay *pdp, BOOL fTurnOn, HDC repaintDC );

	WORD		_fMagellanBitMapOn	:1;	// TRUE if the MDOWN bitmap is displayed.
	WORD		_fMButtonScroll		:1;	// Auto scrolling initiated via magellan-mouse.
	WORD		_fLastScrollWasRoll	:1;	// scroll will be wither roll or mdown.

 	SHORT		_ID_currMDownBMP;		// Resource ID of _MagellanMDownBMP.
	HBITMAP		_MagellanMDownBMP;		// Loaded BMP
	POINT		_zMouseScrollStartPt;	// Magellan mouse's start scroll pt.



public:

	BOOL MagellanStartMButtonScroll ( CTxtEdit &ed, POINT mDownPt );
	VOID MagellanEndMButtonScroll ( CTxtEdit &ed );
	VOID MagellanRollScroll ( CDisplay *pdp, int direction, WORD cLines, int speedNum, int speedDenom, BOOL fAdditive );
	VOID TrackUpdateMagellanMButtonDown ( CTxtEdit &ed, POINT mousePt);

	BOOL IsAutoScrolling() {return _fMButtonScroll;}
	BOOL ContinueMButtonScroll(INT x, INT y) {return (_zMouseScrollStartPt.x == x && _zMouseScrollStartPt.y == y);}

	~CMagellan() { Assert( !_MagellanMDownBMP && !_fMButtonScroll /* client state problems? */); }

};

class CMagellanBMPStateWrap {
private:
	BOOL _fMagellanState;
	HDC _repaintDC;
	CTxtEdit &_ed;
public:
	CMagellanBMPStateWrap(CTxtEdit &ed, HDC repaintDC);
	~CMagellanBMPStateWrap();
};

#endif // _MAGELLN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_ols.h ===
/*
 *  _OLS.H
 *  
 *  Purpose:
 *		COls Line Services object class used to connect RichEdit with
 *		Line Services.
 *  
 *  Authors:
 *		Original RichEdit LineServices code: Rick Sailor
 *		Murray Sargent
 *
 *	Copyright (c) 1997-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _OLS_H
#define _OLS_H

#include "_common.h"
#include "_ls.h"
#include "_cfpf.h"
#include "usp10.h"

#define CP_BULLET			0x80000000

// ===============================  CLsrun =====================================
// CLsrun - LineServices run structure
struct CLsrun
{
	LONG				_cp;	// the starting cp of the run
	const CCharFormat*	_pCF;	// pointer to the character formatting
	struct CLsrun*		_pNext;	// next linked (shaped together) run
	SCRIPT_ANALYSIS		_a;		// run's analysis (will be 0 if non-complex script)
private:
	BYTE		_fSelected:1;	// Is this run selected?
	BYTE		_fFallback:1;	// Is font fallback applied?
public:
	void	SetSelected(BOOL fSelected) {_fSelected = fSelected;}
	BOOL	IsSelected();
	BOOL	IsBullet() {return _cp & CP_BULLET;}
	void	SetFallback(BOOL fFallback) {_fFallback = fFallback;}
	BOOL	IsFallback() {return _fFallback;}
};

// ===============================  CLsrunChunk =====================================
// CLsrunChunk - Manages a chunk of PLSRUNs
class CLsrunChunk
{
public:
	PLSRUN _prglsrun;
	int		_cel;
};

// ===============================  COls  =====================================
// COls - LineServices object class

class CTxtEdit;
class CMeasurer;
class CDispDim;

struct COls
{
public:
	CMeasurer *_pme;				// Active CMeasurer or CRenderer
	PLSLINE	   _plsline;			// Line cache
	LONG	   _cp;					// cpMin for _plsline
	const CDisplay *_pdp;			// Current Display object, used to determine if display
									// object changed without receiving focus messages
	LONG		_xWidth;			// Width of line to be formatted

	BOOL		_fCheckFit;			// See if the line will fit, but formatting left justified
									// into an infinitely long line.

	CArray<long> _rgcp;				// Array for CP mapping
	CArray<CLsrunChunk> _rglsrunChunk;	// Array of ClsrunChunks


	// Note: might be better to alloc the following only if needed
	LSTBD _rgTab[MAX_TAB_STOPS];	// Buffer used by pfnFetchTabs
	WCHAR _szAnm[CCHMAXNUMTOSTR + 4];//numbering + braces + space + end character
	WCHAR _rgchTemp[64];			// Temporary buffer for passwords and allcaps, etc.
	int			_cchAnm;			// cch in use
	CCharFormat _CFBullet;			// Character formatting for anm run
	LONG		_cEmit;				// Brace emitting protection (0 - balance)

	COls() {}
	~COls();

	//CP matching, reverser brace support
	LONG GetCpLsFromCpRe(LONG cpRe);
	LONG GetCpReFromCpLs(LONG cpLs);
	LONG BracesBeforeCp(LONG cpLs);
	BOOL AddBraceCp(LONG cpLs);

	PLSRUN CreatePlsrun(void);

	BOOL SetLsChp(DWORD dwObjId, PLSRUN plsrun, PLSCHP plschp);
	BOOL SetRun(PLSRUN plsrun);
	PLSRUN GetPlsrun(LONG cp, const CCharFormat *pCF, BOOL fAutoNumber);
	LSERR WINAPI FetchAnmRun(long cp, LPCWSTR *plpwchRun, DWORD *pcchRun,
							 BOOL *pfHidden, PLSCHP plsChp, PLSRUN *pplsrun);
	void	CchFromXpos(POINT pt, CDispDim *pdispdim, LONG *pcpActual);
	void	CreateOrGetLine();
	void	DestroyLine(CDisplay *pdp);
	HRESULT	Init(CMeasurer *pme); 
	BOOL	MeasureLine(LONG xWidth, CLine *pliTarget);
	LONG	MeasureText(LONG cch, UINT taMode, CDispDim *pdispdim);
	BOOL	RenderLine(CLine &li);
	CMeasurer * GetMeasurer() {return _pme;}
	CRenderer * GetRenderer() {return (CRenderer*) _pme;}

	void	SetMeasurer(CMeasurer *pme)	{_pme = pme;}
};

extern COls* g_pols;
extern const LSIMETHODS vlsimethodsOle;
extern CLineServices *g_plsc;		// LineServices Context

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_osdc.h ===
/*	@doc INTERNAL
 *
 *	@module _OSDC.H  Off Screen DC class |
 *	
 *	Define class for off screen DC
 *
 *	Original Author: <nl>
 *		Ricksa
 *
 *	History: <nl>
 *		1/11/96	ricksa	Created
 *
 *	Copyright (c) 1996-1998, Microsoft Corporation. All rights reserved.
 */
#ifndef __OSDC_H__
#define __OSDC_H__

/*
 *	COffScreenDC
 *	
 * 	@class	The COffScreenDC is a helper that creates, fills and destroys
 *			an off screen DC and its bitmaps.
 *
 */
class COffScreenDC
{
//@access Public Methods
public:
									//@cmember Constructor - create null object.
				COffScreenDC()		{_hdc = NULL;}

									//@cmember Destructor - clean up allocated 
									// resources if any.
				~COffScreenDC()		{FreeData();}
	
									//@cmember Initialize data based on input DC
	HDC			Init(HDC hdc, LONG xWidth, LONG yHeight, COLORREF crBackground);

									//@cmember Get DC for offscreen rendering
	HDC			GetDC()		{return _hdc;}
									//@cmember Fill bitmap associated with off
									// screen rendering with background color.
	void		FillBitmap(LONG xWidth, LONG yHeight);

									//@cmember Render off screen bitmap to hdc
	void		RenderBitMap(HDC hdc, LONG xLeft, LONG yTop, LONG xWidth, LONG yHeight);

									//@cmember Get a copy of a bitmap from hdc
	BOOL		Get(HDC hdc, LONG xLeft, LONG yTop, LONG xWidth, LONG yHeight);

									//@cmember Reallocate bitmap for render
	BOOL		Realloc(LONG xWidth, LONG yHeight);

									//@cmember Select in a palette
	void		SelectPalette(HPALETTE hpa);

//@access Private Methods
private:
									//@cmember Free all data associated with object
	void		FreeData();

//@access Private Data 
private:
	HDC			_hdc;		//@cmember HDC for off screen DC
	HBITMAP		_hbmpOld;	//@cmember bitmap when DC created
	HBITMAP		_hbmp;		//@cmember compatible bitmap for render
	HPALETTE	_hpalOld;	//@cmember palette used by DC
};

/*
 *	COffScreenDC::FillBitmap (xWidth, yHeight)
 *
 *	@mfunc	
 *		Fill bitmap
 */
inline void COffScreenDC::FillBitmap(
	LONG xWidth,		//@parm Width to fill with background color
	LONG yHeight)		//@parm height to fill with background color
{
	// Erase background
	RECT rcClient;
	rcClient.top = rcClient.left = 0;
	rcClient.right = xWidth;
	rcClient.bottom = yHeight;
	ExtTextOut(_hdc, 0, 0, ETO_OPAQUE, &rcClient, NULL, 0, NULL);
}

/*
 *	COffScreenDC::RenderBitMap(hdc, xLeft, yTop, xWidth, yHeight)
 *
 *	@mfunc	
 *		Render bitmap to input DC
 */
inline void COffScreenDC::RenderBitMap(
	HDC  hdc,			//@parm HDC to render to
	LONG xLeft,			//@parm left position to start render
	LONG yTop,			//@parm top top position to start render
	LONG xWidth,		//@parm width to render
	LONG yHeight)		//@parm height to render
{
	BitBlt(hdc, xLeft, yTop, xWidth, yHeight, _hdc, 0, 0, SRCCOPY);
}
	
/*
 *	COffScreenDC::Get(hdc, xLeft, yTop, xWidth, yHeight)
 *
 *	@mfunc	
 *		Get a copy of a bitmap from another DC
 *
 *	@rdesc
 *		TRUE - succeeded
 *		FALSE - Failed
 */
inline BOOL COffScreenDC::Get(
	HDC  hdc,			//@parm HDC to copy from
	LONG xLeft,			//@parm left position of source bitmap
	LONG yTop,			//@parm top top position of source bitmap
	LONG xWidth,		//@parm width of bitmap
	LONG yHeight)		//@parm height to bitmap
{
	return BitBlt(_hdc, 0, 0, xWidth, yHeight, hdc, xLeft, yTop, SRCCOPY);
}

#endif __OSDC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_objmgr.h ===
/*
 *  @doc    INTERNAL
 *
 *  @module _objmgr.h   Class declaration for the object manager class |
 *
 *  Author: alexgo 11/4/95
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */
#ifndef __OBJMGR_H__
#define __OBJMGR_H__

#include "_coleobj.h"
#include "_array.h"
#include "_m_undo.h"

class CTxtEdit;

/*
 *	@enum	return values for HandleClick
 */	
enum ClickStatus
{
	CLICK_IGNORED			= 0,
	CLICK_OBJDEACTIVATED	= 1,
	CLICK_SHOULDDRAG		= 2,
	CLICK_OBJSELECTED		= 3
};

typedef CArray<COleObject *> ObjectArray;

/*
 *	CObjectMgr
 *
 *	@class	keeps track of a collection of OLE embedded objects as well as
 *			various state tidbits
 */
class CObjectMgr
{
public:
	LONG			GetObjectCount(); 			//@cmember count # of objects 
	LONG			GetLinkCount();				//@cmember count # of links
	COleObject *	GetObjectFromCp(LONG cp);	//@cmember fetch object ptr
	COleObject *	GetObjectFromIndex(LONG index); //@cmember fetch obj ptr
												//@cmember insert object
	HRESULT			InsertObject(LONG cp, REOBJECT *preobj, 
						IUndoBuilder *publdr);
												//@cmember re-inserts the given
												// object
	HRESULT			RestoreObject(COleObject *pobj);

	IRichEditOleCallback *GetRECallback()		//@cmember return the callback
					{return _precall;}
												//@cmember set the OLE callback
	void			SetRECallback(IRichEditOleCallback *precall);			
												//@cmember sets a temporary flag
												// indicating whether or not
												// a UI update is pending.
	void			SetShowUIPending(BOOL fPending)
												{_fShowUIPending = fPending;}

	BOOL			GetShowUIPending()			//@cmember get _fShowUIPending
												{return _fShowUIPending;}
										   		//@cmember sets the inplace
												// active object
	void			SetInPlaceActiveObject(COleObject *pobj)
												{ _pobjactive = pobj; }
	COleObject *	GetInPlaceActiveObject()	//@cmember get the active obj
												{ return _pobjactive; }
	BOOL			GetHelpMode()				//@cmember in help mode?
												{ return _fInHelpMode; }
	void			SetHelpMode(BOOL fHelp)		//@cmember set the help mode
												{ _fInHelpMode = fHelp; }
												//@cmember Set the host names
	HRESULT			SetHostNames(LPWSTR pszApp, LPWSTR pszDoc);
	LPWSTR			GetAppName()				//@cmember get the app name
												{ return _pszApp; }
	LPWSTR			GetDocName()				//@cmember get the doc name
												{ return _pszDoc; }
												//@cmember activate an object
												//if appropriate
	BOOL			HandleDoubleClick(CTxtEdit *ped, const POINT &pt, 
							DWORD flags);
												//@cmember an object may be
												// selected or de-activated.
	ClickStatus		HandleClick(CTxtEdit *ped, const POINT &pt);
												//@cmember an object may be
												// selected or deselected.
	void			HandleSingleSelect(CTxtEdit *ped, LONG cp, BOOL fHiLite);
												//@cmember an object is
												// being selected by itself.
	COleObject *	GetSingleSelect(void)		{return _pobjselect;}
												//@cmember Count cObject
	LONG			CountObjects(LONG& rcObject,// objects up to cchMax
						LONG cp);				// chars away

												//@cmember Handles the deletion
												// of objects.
	void			ReplaceRange(LONG cp, LONG cchDel,
						IUndoBuilder *publdr);
												//@cmember Count the number
												//of objects in a range.
	LONG			CountObjectsInRange(LONG cpMin, LONG cpMost);
												//@cmember Get the first
												//object in a range.
	COleObject *	GetFirstObjectInRange(LONG cpMin, LONG cpMost);
								//@cmember activate objects of one class as
								//as another
	HRESULT ActivateObjectsAs(REFCLSID rclsid, REFCLSID rclsidAs);

												//@cmember inform objects
												// that scrolling has 
												// occured.
	void			ScrollObjects(LONG dx, LONG dy, LPCRECT prcScroll);

	LONG FindIndexForCp(LONG cp);	//@cmember does a binary search for cp
									//@cmember find an object near a point

#ifdef DEBUG
	void			DbgDump(void);
#endif

	CObjectMgr();								//@cmember constructor
	~CObjectMgr();								//@cmember destructor

private:
	ObjectArray		_objarray;		//@cmember	Array of embedded objects
	LONG			_lastindex;		//@cmember	Last index used 
									// (lookup optimization)
	IRichEditOleCallback *_precall;	//@cmember	Callback for various OLE 
									// operations.
	COleObject *	_pobjactive;	//@cmember	Object that is currently
									// inplace active 
	COleObject *	_pobjselect;	//@cmember	Object that is currently
									// individually selected (not active)
	LPWSTR		_pszApp;			//@cmember 	Name of app
	LPWSTR		_pszDoc;			//@cmember 	Name of "document"

	unsigned int	_fShowUIPending:1;//@cmember a UI update is pending
	unsigned int	_fInHelpMode:1;	//@cmember in context sensitive help mode?
};

#endif  //__OBJMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_rtfconv.h ===
/*
 *	@doc INTERNAL
 *
 *	@module _RTFCONV.H -- RichEdit RTF Converter Base Class Definition |
 *
 *	Description:
 *		This file contains the type declarations used by both the RTF reader
 *		and writer for the RICHEDIT control
 *
 *	Authors: <nl>
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco <nl>
 *		Conversion to C++ and RichEdit 2.0:  Murray Sargent
 *
 *	@devnote
 *		All sz's in the RTF*.? files refer to a LPSTRs, not LPTSTRs, unless
 *		noted as a szUnicode.
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */
#ifndef __RTFCONV_H
#define __RTFCONV_H

#include "_edit.h"
#include "_array.h"
#include "_range.h"
#include "_rtext.h"
#include "tokens.h"

extern const KEYWORD rgKeyword[];

// Convert between Twips and Himetric
// Ratio is 1440 twips/in, 2540 him/in, therefore 1440/2540 = 72/127 him/twips
// Use muldiv() to include rounding and 64-bit intermediate result
#define TwipsFromHimetric(_hm)	MulDiv(_hm, 72, 127)
#define HimetricFromTwips(_tw)	MulDiv(_tw, 127, 72)

#define	LBRACE	TEXT('{')
#define	BSLASH	TEXT('\\')
#define	RBRACE	TEXT('}')
#define ZERO	TEXT('0')

// Character property bits like an ASCII-only ANSI C LC_CTYPE types
#define fUC			0x01		// A-Z
#define	fLC			0x02		// a-z
#define fDG			0x04		// 0-9
#define	fSP			0x08		// Space chars
#define	fPN			0x10		// Punctuation chars
#define fCT			0x20		// Control chars
#define	fBL			0x40		// Blank chars
#define fHX			0x80		// 0-9, a-f, or A-F

#define	fAlpha		(fUC + fLC)
#define	fAlphaNum	(fAlpha + fDG)

extern const BYTE rgbCharClass[256];

#define Classify(_ch)		(rgbCharClass[_ch])
#define IsLC(_ch)			((Classify(_ch) & fLC))
#define IsAlpha(_ch)		((Classify(_ch) & fAlpha))
#define IsDigit(_ch)		((Classify(_ch) & fDG))
#define IsXDigit(_ch)		((Classify(_ch) & fHX))
#define IsAlphaNum(_ch) 	((Classify(_ch) & fAlphaNum))
#define IsAlphaNumBlank(_ch) ((Classify(_ch) & (fAlphaNum + fBL)))

template <class T> unsigned int DiffPtrs(T *pA, T *pB)
{
	return pA - pB;
}

//#define DiffPtrs(_pA, _pB, _type) ((UINT) (((_type *) (_pA)) - ((_type *) (_pB))))

extern INT  cKeywords;
extern const COLORREF g_Colors[];
extern const char szEndGroupCRLF[];

#define szaCRLF		(BYTE *)&szEndGroupCRLF[1]

/*
 *		Converter Error Codes
 */
enum
{
	ecNoError = 0,						// Success
	ecCantUnicode,
	ecColorTableOverflow,
	ecExpectingRtfKeyword,
	ecExpectingStartGroup,
	ecFontTableOverflow,
	ecGeneralFailure,
	ecKeywordTooLong,
	ecLexInitFailed,
	ecNoMemory,
	ecParserBusy,
	ecPutCharFailed,
	ecStackOverflow,
	ecStackUnderflow,
	ecUnexpectedChar,
	ecUnexpectedEOF,
	ecUnexpectedToken,
	ecUnGetCharFailed,
	ecTextMax,
	ecStreamOutObj,
	ecStreamInObj,
	ecTruncateAtCRLF,
	ecFormatCache,
	ecLastError							// Total error messages
};

typedef	INT	EC;

/*
 *	@struct RTFOBJECT |
 *		Object data transfer structure
 */
typedef struct _rtfobject
{
	SHORT	sType;				// @field object type (ROT_*)
	SHORT	sPictureType;		// @field specific type of sPicture
	SHORT	cBitsPerPixel;		// @field # bits per pixel, if bitmap
	SHORT	cColorPlanes;		// @field # color planes, if bitmap
	SHORT	cBytesPerLine;		// @field # bytes per raster line, if bitmap
	BOOL	fSetSize;			// @field Let client tell server the size
	LONG	xExt, yExt;			// @field dimensions in pixels for pictures, twips for
								//	for objects
	LONG	xScale, yScale;		// @field scaling percentage along axes
	SHORT	xExtGoal, yExtGoal;	// @field desired dimensions in twips for pictures
	RECT	rectCrop;			// @field cropping information in twips
	TCHAR *	szClass;			// @field object class
	TCHAR *	szName;				// @field object name

	// On RTF generation
	LONG	xExtPict, yExtPict;	// @field metafile dimensions
	LPBYTE	pbResult;			// metafile depiction of the object
	ULONG	cbResult;
} RTFOBJECT;

/*
 *	@enum ROTYPE | The values for OBJECT.sType
 *
 *		Keep this in sync with rgszROT in rtfwrit.c
 */
enum ROTYPE
{
	ROT_Bitmap,					// @emem Bitmap
	ROT_Metafile,				// @emem Metafile
	ROT_DIB,					// @emem Device-Independent Bitmap

	ROT_Embedded,				// @emem Embedded Object
	ROT_Link,					// @emem Linked Object
	ROT_AutoLink,				// @emem Autolink
	ROT_MacEdition				// @emem Mac object
};


/*
 *		DEFINE's
 */
#define cachBufferMost		4096
#define	cachTextMax			( 512 + 1 )
#define	cachKeywordMax		( 32 + 1 )
#define	cachParamMax		( 11 + 1 )
#define cFooChunk			8

// Characters to give to RichEdit
#define	chNonBreakingSpace		160
#define	chOptionalHyphen		173


#if	( cachTextMax - 1 ) % 2 == 1
#error "cachTextMax  - 1 MUST be even"
#endif

#if ( cachParamMax - 1 ) < 11
#error "cachParamMax MUST be >= 11"
#endif

/*
 * Some RTF defaults
 */
#ifdef NEVER
// we don't care about margins, just indents
#define dxDefaultLeftMargin		1800
#define dxDefaultRightMargin	1800

#else
#define dxDefaultLeftMargin		0
#define dxDefaultRightMargin	0
#endif

// next two in half points
#define	yDefaultFontSize		( 12 * 2 )
#define dyDefaultSuperscript	6

#define RESERVED_FONT_HANDLES	0x800

/*
 *	@struct TEXTFONT |
 *		text font structure
 */
typedef struct _textfont
{
	SHORT		sHandle;				// @field RTF input font handle
	BYTE		bCharSet;				// @field Font character set
	BYTE		bPitchAndFamily;		// @field Font family
	SHORT		iFont;					// @field Font name index
	TCHAR		szName[LF_FACESIZE+1];	// @field Font name
	SHORT		sCodePage;				// @field Code page for font 
										// 			(INVALID_CODEPAGE == not set)
	BYTE		fNameIsDBCS;			// @field Indicates if szName is DBCS stuffed into Unicode buffer
	BYTE		fCpgFromSystem;			// @field Indicates is cpg was 
										// 			retrieved from system based
										//			on font name.
} TEXTFONT;

/*
 *		Global variables for the scope of the entire parser/reader
 */
#ifdef DEBUG
extern CHAR *		rgszParseError[];
extern CHAR *		szDest[];
#endif

#define cchMaxNumText 16

// tagged font info
typedef struct _tfi
{
	TCHAR *szNormalName;
	TCHAR *szTaggedName;
	BYTE bCharSet;
} TFI;

typedef CArray<TEXTFONT> TEXTFONTS;
typedef CArray<COLORREF> COLORREFS;

const short INVALID_CODEPAGE = -1;
const short INVALID_LANGUAGE = -1;

// default value for \ucN tag
const int iUnicodeCChDefault = 1;

/*
 *	CRTFConverter
 *
 *	@class	RTF converter base class used by CRTFRead and CRTFWrite
 */
class CRTFConverter
{
//@access Protected Data Members
protected:
	TEXTFONTS	_fonts;				// @cmember Font table
	COLORREFS	_colors;			// @cmember Color table
	EC			_ecParseError;		// @cmember Error code
	CTxtEdit *	_ped;				// @cmember CTxtEdit
	CTxtRange *	_prg;				// @cmember CTxtRange to replace/write from
	EDITSTREAM *_pes;				// @cmember EDITSTREAM to use
	DWORD		_dwFlags;			// @cmember See #defines below
	CCharFormat	_CF;				// @cmember Character formatting info
	BYTE		_bCharSet;			// @cmember Converter char set (ANSI, UTF7, UTF8)

	static TFI *_rgtfi;				// @cmember Pointer to the first font substitute record
	static INT _ctfi;				// @cmember Number of the font substitute records
	static TCHAR *_pchFontSubInfo;	// @cmember Font strings for substitutions

//@access Protected Functions
	void ReadFontSubInfo(void);

	enum PARSEFONTNAME { PFN_SUCCESS, PFN_FAIL, PFN_EOF };
	PARSEFONTNAME ParseFontName(TCHAR *pchBuf,
							TCHAR *pchBufMax,
							TCHAR chDelimiter,
							TCHAR **pszName,
							BYTE &bCharSet,
							BOOL &fSetCharSet,
							TCHAR **ppchBufNew) const;
	BOOL FontSubstitute(TCHAR *szTaggedName, 
						TCHAR *szNormalName, 
						BYTE *pbCharSet);
	BOOL FindTaggedFont(const TCHAR *szNormalName, BYTE bCharSet, TCHAR **ppchTaggedName);	 
									// @cmember	Find font name with additional special tag 
									// corresponding to szNormalName & bCharSet
	BOOL IsTaggedFont(const TCHAR *szName, BYTE *pbCharSet, TCHAR **ppchNormalName);
								   	// @cmember Figure out is szName font name with additional tag
								   	// corresponding to pbCharSet

//@access Public Functions

public:
	CRTFConverter(CTxtRange *prg, EDITSTREAM *pes, DWORD dwFlags, BOOL fRead);
	inline ~CRTFConverter();
	static void FreeFontSubInfo();

protected:
#if defined(DEBUG) && !defined(MACPORT)
	// for capturing RTF as its read from or written to a file
	HANDLE _hfileCapture;
#endif
};

#define	fRTFNoObjs	1
#define	fRTFFE	8					// Check this

#define IsUTF8	((_dwFlags & (0xFFFF0000 | SF_USECODEPAGE)) \
					 == ((CP_UTF8 << 16) | SF_USECODEPAGE))

/*
 *	CRTFConverter::CRTFConverter()
 *
 *	@mfunc
 *		RTF Converter constructor
 */
inline CRTFConverter::~CRTFConverter()
{
#if defined(DEBUG) && !defined(MACPORT)
	if(_hfileCapture)
	{
		CloseHandle(_hfileCapture);
		_hfileCapture = NULL;
	}
#endif
}

#endif // __RTFCONV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_range.h ===
/*
 *	@doc
 *
 *	@module _RANGE.H -- CTxtRange Class |
 *	
 *		This class implements the internal text range and the TOM ITextRange
 *	
 *	Authors: <nl>
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *		Alex Gounares (floating ranges, etc.)
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#ifndef _RANGE_H
#define _RANGE_H

#include "_text.h"
#include "_m_undo.h"
#include "_rtext.h"
#include "_edit.h"
#include "_uspi.h"

long	FPPTS_TO_TWIPS(float x);
#define TWIPS_TO_FPPTS(x) (((float)(x)) * (float)0.05)

class CTxtEdit;
class CTxtFont;

/*
 *	SELRR
 *
 *	@enum	flags used to control how ReplaceRange (RR) should generate
 *			selection anti-events
 */
enum SELRR
{
	SELRR_IGNORE		= 0,
    SELRR_REMEMBERRANGE = 1,
    SELRR_REMEMBERCPMIN = 2,
    SELRR_REMEMBERENDIP = 3
};

/*
 *	FINDWORD_TYPE
 *
 *	@enum	defines the different cases for finding a word
 */
enum FINDWORD_TYPE {
	FW_EXACT	= 1,		//@emem	Finds the word exactly (no extra chars)
	FW_INCLUDE_TRAILING_WHITESPACE = 2,	//@emem find the word plus the
							// following whitespace (ala double-clicking)
};

enum MOVES
{
	MOVE_START = -1,
	MOVE_IP = 0,
	MOVE_END = 1,
};

enum MATCHES
{
	MATCH_UNTIL = 0,
	MATCH_WHILE = 1
};

enum EOPADJUST
{
	NONEWCHARS = 0,
	NEWCHARS = 1
};


// Substring's input flags
#define SUBSTR_INSPANCHARSET		1
#define SUBSTR_INSPANBLOCK			2

// Substring's output charflags
#define SUBSTR_OUTCCLTR				1
#define SUBSTR_OUTCCRTL				2

class CCharFlags
{
public:
	BYTE	_bFirstStrong;			// flag for first strong character
	BYTE	_bContaining;			// flags for all presented characters
};


#define	SCF_IGNORESELAE	0x80000000
#define SCF_IGNORENOTIFY 0x40000000	// use it with real caution! Caller must do it itself.

/*
 *	CTxtRange
 *	
 * 	@class
 *		The CTxtRange class implements RichEdit's text range, which is the
 *		main conduit through which changes are made to the document.
 *		The range inherits from the rich-text ptr, adding a signed length
 *		insertion-point char-format index, and a ref count for use when
 *		instantiated as a TOM ITextRange.  The range object also contains
 *		a flag that reveals whether the range is a selection (with associated
 *		screen behavior) or just a simple range.  This distinction is used
 *		to simplify some of the code.
 *
 *		Some methods are virtual to allow CTxtSelection objects to facilitate
 *		UI features and selection updating.
 *
 *		See tom.doc for lots of discussion on range and selection objects and
 *		on all methods in ITextRange, ITextSelection, ITextFont, and ITextPara.
 */
class CTxtRange : public ITextSelection, public CRchTxtPtr
{
	friend CTxtFont;

//@access Protected Data
protected:
	LONG	_cch;			//@cmember # chars in range. _cch > 0 for active
							//			end at range end (cpMost)
	LONG	_cRefs;			//@cmember ITextRange/ITextSelection ref count

	short	_iFormat;		//@cmember Character format for degenerate range

	union
	{
	  WORD _wFlags;			// All together now
	  struct
	  {
		WORD  _fExtend :1;		//@cmember True iff Advance methods should
								//  	   leave "other" end unchanged
		WORD  _fSel :1;			//@cmember True iff this is a CTxtSelection
		WORD  _fDragProtection :1;	//@cmember True is this range should think
								//	it's protected.  Set by drag/drop code
		WORD  _fDontUpdateFmt:1;//@cmember Don't update _iFormat
		WORD  _fDualFontMode:1;	//@cmember Set during dual font mode
		WORD  _fUseiFormat:1;	//@cmember Use iFormat when replacing
								// a non-degenerate range
		WORD  _fMoveBack:1;		//@cmember TRUE if last change moved backward
		WORD  _fSelHasEOP:1;	//@cmember TRUE if Sel has EOP
		WORD  _fSelHasCell:1;	//@cmember TRUE if Sel CELL	found looking for EOP
		WORD  _fUseBackwardPFFmt:1;	//@cmember Use backward PF format
	  };
	};

//@access Public methods
public:

#ifdef DEBUG
	BOOL	Invariant( void ) const;
#endif // DEBUG

	CTxtRange(const CTxtRange &rg);
	CTxtRange(CTxtEdit *ped, LONG cp = 0, LONG cch = 0);
	CTxtRange(CRchTxtPtr &rtp, LONG cch = 0);
	virtual	~CTxtRange();

	virtual CRchTxtPtr& 	operator =(const CRchTxtPtr &rtp);
	virtual CTxtRange&		operator =(const CTxtRange &rp);

	// ITxNotify methods
										//@cmember Handles notifications
	virtual void OnPreReplaceRange(		//  prior to ReplaceRange calls
				LONG cp, LONG cchDel, LONG cchNew,
				LONG cpFormatMin, LONG cpFormatMax);
										//@cmember Handles notifications for
	virtual void OnPostReplaceRange(	//  floating range and display updates
				LONG cp, LONG cchDel, LONG cchNew,
				LONG cpFormatMin, LONG cpFormatMax);
	virtual	void Zombie();				//@cmember Convert range into zombie

	void	SetIgnoreFormatUpdate(BOOL fUpdate) { _fDontUpdateFmt = fUpdate; }

	void	SetDualFontMode(BOOL fDualFontMode) {_fDualFontMode = fDualFontMode; }

	// Internal cp/cch methods
    LONG 	GetCch (void) const			//@cmember Get signed character count
				{return _cch;}
	BOOL	IsSel()						{return _fSel;}
	BOOL	fHasCell() const			{return _fSelHasCell;}
	BOOL	fHasEOP() const				{return _fSelHasEOP;}
    BOOL 	CpInRange (LONG cp) const;	//@cmember Says if cp is in this range
	BOOL	CheckTextLength (LONG cch, LONG *pcch = NULL);	//@cmember Says if cch chars can fit
	LONG	CheckChange(LONG cpSave);	//@cmember Used after _cp change to set
										//  selection-changed flag, choose _cch
										 //@cmember In outline mode, maintain _fSelHasEOP
	BOOL	CheckIfSelHasEOP(LONG cpSave, LONG cchSave);
	BOOL	IsInputSequenceValid(WCHAR* pwch, LONG cch, BOOL fOver, BOOL* pfBaseChar = NULL);//@cmember TRUE for valid sequence

	// GetRange() is faster than calling GetCpMin() and GetCpMost();
    LONG    GetCpMin () const;			//@cmember Get cp of first char in range
    LONG    GetCpMost () const;			//@cmember Get cp just beyond last char in range
										//@cmember Get range ends and count
	LONG	GetRange (LONG& cpMin, LONG& cpMost) const;
    BOOL	Set(LONG cp, LONG cch);
	LONG	SetCp(LONG cp);
    void 	SetExtend(unsigned f)			{_fExtend = f;}
	LONG	GetAdjustedTextLength() const
				{return GetPed()->GetAdjustedTextLength();}

	// Range specific methods
	LONG	Advance(LONG cch);	
	void 	Collapser(long fStart);
	void 	FlipRange();
	LONG 	CleanseAndReplaceRange (LONG cchS, WCHAR const *pchS, BOOL fTestLimit,
				IUndoBuilder *publdr, WCHAR *pchD = NULL, LONG* pcchMove = NULL, DWORD dwFlags = 0);
	LONG	CheckLimitReplaceRange (LONG cch, WCHAR const *pch,
				BOOL fTestLimit, IUndoBuilder *publdr, DWORD dwCharFlags,
				LONG *pcchMove, LONG cpFirst, int iMatchCurrent, DWORD dwFlags);
	HRESULT	HexToUnicode (IUndoBuilder *publdr);
	HRESULT	UnicodeToHex (IUndoBuilder *publdr);
	void	Delete(IUndoBuilder *publdr, SELRR selaemode);
	void	DeleteTerminatingEOP(IUndoBuilder *publdr);
	BOOL	AdjustEndEOP (EOPADJUST NewChars);

	// Outline management
	void	CheckOutlineLevel(IUndoBuilder *publdr);
	HRESULT	ExpandOutline  (LONG Level, BOOL fWholeDocument);
	HRESULT	OutlineExpander(LONG Level, BOOL fWholeDocument);
	HRESULT	Promote		   (LPARAM lparam, IUndoBuilder *publdr);

	// ReplaceRange must be virtual since the callers of
	// CLightDTEngine::CutRangeToClipboard() cast CTxtSelection* to CTxtRange*
	virtual	LONG 	ReplaceRange(LONG cchNew, TCHAR const *pch, IUndoBuilder *publdr,
						SELRR selaemode, LONG *pcchMove = NULL, DWORD dwFlags = 0);
	virtual	BOOL 	Update(BOOL fScrollIntoView);

	// Rich-text methods
	enum { PROTECTED_YES, PROTECTED_NO, PROTECTED_ASK };

	// Get/Set Char/Para Format methods
	void 	Update_iFormat(LONG iFmtDefault);
	DWORD	GetCharSetMask(BOOL fUseDocFormat = FALSE);	//@cmember Get range charset mask
	LONG	Get_iCF();						//@cmember Get range CF index
	LONG	Get_iFormat() {return _iFormat;}//@cmember Get _iFormat for quick peek
	LONG	GetiFormat() const;
    BOOL	Set_iCF(LONG iFormat);			//@cmember Set range CF index
	LONG	Get_iPF();						//@cmember Get active end PF index
	int		IsProtected(LONG iDirection);	//@cmember Is range protected?
	BOOL	IsZombie() {return !GetPed();}	//@cmember Is range zombied?
	BOOL	WriteAccessDenied ();
	DWORD	GetCharFormat(CCharFormat *pCF, DWORD flags = 0) const;
	DWORD	GetParaFormat(CParaFormat *pPF, DWORD flags = 0) const;
	void	SetDragProtection(BOOL fSet)	// Convinces range it's protected
				{_fDragProtection = fSet;}	//  w/o modifying backing store
	HRESULT	CharFormatSetter (const CCharFormat *pCF, DWORD dwMask);
	HRESULT	ParaFormatSetter (const CParaFormat *pPF, DWORD dwMask);

	HRESULT	SetCharFormat(const CCharFormat *pCF, DWORD flags,
						  IUndoBuilder *publdr, DWORD dwMask, DWORD dwMask2);
	HRESULT	SetParaFormat(const CParaFormat *pPF,
						  IUndoBuilder *publdr, DWORD dwMask);
	HRESULT	SetParaStyle (const CParaFormat *pPF,
						  IUndoBuilder *publdr, DWORD dwMask);
											//@cmember Format range CharSets
	// Complex script feature :- Itemization
	BOOL	ItemizeRuns(IUndoBuilder *publdr, BOOL fUnicodeBiDi = FALSE, BOOL fUseCtxLevel = FALSE);
	HRESULT BiDiLevelFromFSM (const CBiDiFSM* pfsm);
	LONG	GetRunsPF (CRchTxtPtr* prtp, CFormatRunPtr* prpPF, LONG& cchLeft);
#ifdef DEBUG
	void	DebugFont (void);
#endif

	// Find enclosing unit methods
	HRESULT	Expander		(long Unit, BOOL fExtend, LONG *pDelta,
							 LONG *pcpMin, LONG *pcpMost);
	void	FindAttributes	(LONG *pcpMin, LONG *pcpMost, LONG Unit) const;
	void	FindCell		(LONG *pcpMin, LONG *pcpMost) const;
    BOOL    FindObject		(LONG *pcpMin, LONG *pcpMost) const;
    void    FindParagraph	(LONG *pcpMin, LONG *pcpMost) const;
    void    FindSentence	(LONG *pcpMin, LONG *pcpMost) const;
	BOOL	FindVisibleRange(LONG *pcpMin, LONG *pcpMost) const;
    void    FindWord		(LONG *pcpMin, LONG *pcpMost,
								FINDWORD_TYPE type)const;

	LONG	AdvanceCRLF();
	LONG	BackupCRLF(BOOL fDiacriticCheck = TRUE);
	LONG    FindWordBreak(INT action);
	LONG	SnapToCluster(INT iDirection = 0);

	void	ValidateRange();

	void	SetUseiFormat(BOOL fUseiFormat) {_fUseiFormat = fUseiFormat;}

    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDispatch methods
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR ** rgszNames, UINT cNames,
							 LCID lcid, DISPID * rgdispid) ;
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
					  DISPPARAMS * pdispparams, VARIANT * pvarResult,
					  EXCEPINFO * pexcepinfo, UINT * puArgErr) ;

    // ITextRange methods
    STDMETHODIMP GetText (BSTR *pbstr);
    STDMETHODIMP SetText (BSTR bstr);
    STDMETHODIMP GetChar (long *pch);
    STDMETHODIMP SetChar (long ch);
    STDMETHODIMP GetDuplicate (ITextRange **ppRange);
    STDMETHODIMP GetFormattedText (ITextRange **ppRange);
    STDMETHODIMP SetFormattedText (ITextRange *pRange);
    STDMETHODIMP GetStart (long *pcpFirst);
    STDMETHODIMP SetStart (long cpFirst);
    STDMETHODIMP GetEnd (long *pcpLim);
    STDMETHODIMP SetEnd (long cpLim);
    STDMETHODIMP GetFont (ITextFont **pFont);
    STDMETHODIMP SetFont (ITextFont *pFont);
    STDMETHODIMP GetPara (ITextPara **pPara);
    STDMETHODIMP SetPara (ITextPara *pPara);
    STDMETHODIMP GetStoryLength (long *pcch);
    STDMETHODIMP GetStoryType (long *pValue);
    STDMETHODIMP Collapse (long bStart);
    STDMETHODIMP Expand (long Unit, long *pDelta);
    STDMETHODIMP GetIndex (long Unit, long *pIndex);
    STDMETHODIMP SetIndex (long Unit, long Index, long Extend);
    STDMETHODIMP SetRange (long cpActive, long cpOther);
    STDMETHODIMP InRange (ITextRange * pRange, long *pb);
    STDMETHODIMP InStory (ITextRange * pRange, long *pb);
    STDMETHODIMP IsEqual (ITextRange * pRange, long *pb);
    STDMETHODIMP Select ();
    STDMETHODIMP StartOf (long Unit, long Extend, long * pDelta);
    STDMETHODIMP EndOf (long Unit, long Extend, long * pDelta);
    STDMETHODIMP Move (long Unit, long Count, long * pDelta);
    STDMETHODIMP MoveStart (long Unit, long Count, long * pDelta);
    STDMETHODIMP MoveEnd (long Unit, long Count, long * pDelta);
    STDMETHODIMP MoveWhile (VARIANT * Cset, long Count, long * pDelta);
    STDMETHODIMP MoveStartWhile (VARIANT * Cset, long Count, long * pDelta);
    STDMETHODIMP MoveEndWhile (VARIANT * Cset, long Count, long * pDelta);
    STDMETHODIMP MoveUntil (VARIANT FAR* Cset, long Count, long * pDelta);
    STDMETHODIMP MoveStartUntil (VARIANT * Cset, long Count, long * pDelta);
    STDMETHODIMP MoveEndUntil (VARIANT * Cset, long Count, long * pDelta);
    STDMETHODIMP FindText (BSTR bstr, long cch, long Flags, long * pLength);
    STDMETHODIMP FindTextStart (BSTR bstr, long cch, long Flags, long * pLength);
    STDMETHODIMP FindTextEnd (BSTR bstr, long cch, long Flags, long * pLength);
    STDMETHODIMP Delete (long Unit, long Count, long * pDelta);
    STDMETHODIMP Cut (VARIANT * ppIDataObject);
    STDMETHODIMP Copy (VARIANT * ppIDataObject);
    STDMETHODIMP Paste (VARIANT * pIDataObject, long Format);
    STDMETHODIMP CanPaste (VARIANT * pIDataObject, long Format, long * pb);
    STDMETHODIMP CanEdit (long * pbCanEdit);
    STDMETHODIMP ChangeCase (long Type);
    STDMETHODIMP GetPoint (long Type, long * px, long * py);
    STDMETHODIMP SetPoint (long x, long y, long Type, long Extend);
    STDMETHODIMP ScrollIntoView (long Value);
    STDMETHODIMP GetEmbeddedObject (IUnknown ** ppv);


    // ITextSelection methods
    STDMETHODIMP GetFlags (long * pFlags) ;
    STDMETHODIMP SetFlags (long Flags) ;
    STDMETHODIMP GetType  (long * pType) ;
	STDMETHODIMP MoveLeft (long Unit, long Count, long Extend,
						   long *pDelta) ;
	STDMETHODIMP MoveRight(long pUnit, long Count, long Extend,
						   long *pDelta) ;
	STDMETHODIMP MoveUp   (long pUnit, long Count, long Extend,
						   long *pDelta) ;
	STDMETHODIMP MoveDown (long pUnit, long Count, long Extend,
						   long *pDelta) ;
	STDMETHODIMP HomeKey  (long pUnit, long Extend, long *pDelta) ;
	STDMETHODIMP EndKey   (long pUnit, long Extend, long *pDelta) ;
	STDMETHODIMP TypeText (BSTR bstr) ;


//@access Private ITextRange helper methods
private:
	void	RangeValidateCp (LONG cp, LONG cch);
	LONG	Comparer (ITextRange * pv);
	LONG	SpanSubstring (CUniscribe* pusp, CFormatRunPtr* pcrp, WCHAR* pwchString,
						LONG cchString, WORD& uSubStrLevel, DWORD dwInFlags, CCharFlags* pCharflags,
						WORD& wBiDiLangId);
	HRESULT EndSetter(LONG cp, BOOL fOther);
	HRESULT Finder	 (BSTR bstr, long Count, long Flags, LONG *pDelta,
						MOVES Mode);
	HRESULT GetLong  (LONG lValue, long *pLong);
	HRESULT	IsTrue	 (BOOL f, long *pB);
	HRESULT Matcher	 (VARIANT *Cset, long Count, LONG *pDelta, MOVES Mode,
						MATCHES Match);
	HRESULT	Mover	 (long Unit, long Count, LONG *pDelta, MOVES Mode);
	HRESULT	Replacer (LONG cchNew, TCHAR const *pch, DWORD dwFlags = 0);

	LONG	CalcTextLenNotInRange();
};



// Useful Unicode range definitions for use with MoveWhile/Until methods

#define	CodeRange(n, m)	0x8000000 | ((m) - (n)) << 16 | n

#define	CR_ASCII		CodeRange(0x0, 0x7f)
#define	CR_ANSI			CodeRange(0x0, 0xff)
#define	CR_ASCIIPrint	CodeRange(0x20, 0x7e)
#define	CR_Latin1		CodeRange(0x20, 0xff)
#define	CR_Latin1Supp	CodeRange(0xa0, 0xff)
#define	CR_LatinXA		CodeRange(0x100, 0x17f)
#define	CR_LatinXB		CodeRange(0x180, 0x24f)
#define	CR_IPAX			CodeRange(0x250, 0x2af)
#define	CR_SpaceMod		CodeRange(0x2b0, 0x2ff)
#define	CR_Combining	CodeRange(0x300, 0x36f)
#define	CR_Greek		CodeRange(0x370, 0x3ff)
#define	CR_BasicGreek	CodeRange(0x370, 0x3cf)
#define	CR_GreekSymbols	CodeRange(0x3d0, 0x3ff)
#define	CR_Cyrillic		CodeRange(0x400, 0x4ff)
#define	CR_Armenian		CodeRange(0x530, 0x58f)
#define	CR_Hebrew		CodeRange(0x590, 0x5ff)
#define	CR_BasicHebrew	CodeRange(0x5d0, 0x5ea)
#define	CR_HebrewXA		CodeRange(0x590, 0x5cf)
#define	CR_HebrewXB		CodeRange(0x5eb, 0x5ff)
#define	CR_Arabic		CodeRange(0x600, 0x6ff)
#define	CR_BasicArabic	CodeRange(0x600, 0x652)
#define	CR_ArabicX		CodeRange(0x653, 0x6ff)
#define	CR_Devengari	CodeRange(0x900, 0x97f)
#define	CR_Bengali		CodeRange(0x980, 0x9ff)
#define	CR_Gurmukhi		CodeRange(0xa00, 0xa7f)
#define	CR_Gujarati		CodeRange(0xa80, 0xaff)
#define	CR_Oriya		CodeRange(0xb00, 0xb7f)
#define	CR_Tamil		CodeRange(0xb80, 0xbff)
#define	CR_Teluga		CodeRange(0xc00, 0xc7f)
#define	CR_Kannada		CodeRange(0xc80, 0xcff)
#define	CR_Malayalam	CodeRange(0xd00, 0xd7f)
#define	CR_Thai 		CodeRange(0xe00, 0xe7f)
#define	CR_Lao  		CodeRange(0xe80, 0xeff)
#define	CR_GeorgianX	CodeRange(0x10a0, 0xa0cf)
#define	CR_BascGeorgian	CodeRange(0x10d0, 0x10ff)
#define	CR_Hanguljamo	CodeRange(0x1100, 0x11ff)
#define	CR_LatinXAdd	CodeRange(0x1e00, 0x1eff)
#define	CR_GreekX		CodeRange(0x1f00, 0x1fff)
#define	CR_GenPunct		CodeRange(0x2000, 0x206f)
#define	CR_SuperScript	CodeRange(0x2070, 0x207f)
#define	CR_SubScript	CodeRange(0x2080, 0x208f)
#define	CR_SubSuperScrp	CodeRange(0x2070, 0x209f)
#define	CR_Currency		CodeRange(0x20a0, 0x20cf)
#define	CR_CombMarkSym	CodeRange(0x20d0, 0x20ff)
#define	CR_LetterLike	CodeRange(0x2100, 0x214f)
#define	CR_NumberForms	CodeRange(0x2150, 0x218f)
#define	CR_Arrows		CodeRange(0x2190, 0x21ff)
#define	CR_MathOps		CodeRange(0x2200, 0x22ff)
#define	CR_MiscTech		CodeRange(0x2300, 0x23ff)
#define	CR_CtrlPictures	CodeRange(0x2400, 0x243f)
#define	CR_OptCharRecog	CodeRange(0x2440, 0x245f)
#define	CR_EnclAlphaNum	CodeRange(0x2460, 0x24ff)
#define	CR_BoxDrawing	CodeRange(0x2500, 0x257f)
#define	CR_BlockElement	CodeRange(0x2580, 0x259f)
#define	CR_GeometShapes	CodeRange(0x25a0, 0x25ff)
#define	CR_MiscSymbols	CodeRange(0x2600, 0x26ff)
#define	CR_Dingbats		CodeRange(0x2700, 0x27bf)
#define	CR_CJKSymPunct	CodeRange(0x3000, 0x303f)
#define	CR_Hiragana		CodeRange(0x3040, 0x309f)
#define	CR_Katakana		CodeRange(0x30a0, 0x30ff)
#define	CR_Bopomofo		CodeRange(0x3100, 0x312f)
#define	CR_HangulJamo	CodeRange(0x3130, 0x318f)
#define	CR_CJLMisc		CodeRange(0x3190, 0x319f)
#define	CR_EnclCJK		CodeRange(0x3200, 0x32ff)
#define	CR_CJKCompatibl	CodeRange(0x3300, 0x33ff)
#define	CR_Hangul		CodeRange(0x3400, 0x3d2d)
#define	CR_HangulA		CodeRange(0x3d2e, 0x44b7)
#define	CR_HangulB		CodeRange(0x44b8, 0x4dff)
#define	CR_CJKIdeograph	CodeRange(0x4e00, 0x9fff)
#define	CR_PrivateUse	CodeRange(0xe000, 0xf800)
#define	CR_CJKCompIdeog	CodeRange(0xf900, 0xfaff)
#define	CR_AlphaPres	CodeRange(0xfb00, 0xfb4f)
#define	CR_ArabicPresA	CodeRange(0xfb50, 0xfdff)
#define	CR_CombHalfMark	CodeRange(0xfe20, 0xfe2f)
#define	CR_CJKCompForm	CodeRange(0xfe30, 0xfe4f)
#define	CR_SmallFormVar	CodeRange(0xfe50, 0xfe6f)
#define	CR_ArabicPresB	CodeRange(0xfe70, 0xfefe)
#define	CR_HalfFullForm	CodeRange(0xff00, 0xffef)
#define	CR_Specials		CodeRange(0xfff0, 0xfffd)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_rtflog.h ===
/*
 *	@doc INTERNAL
 *
 *	@module _RTFLOG.H -- RichEdit RTF Log Class Definition |
 *
 *		This file contains the class declarations for an RTF log class
 *		which can be used to track the hit counts of RTF tags encountered
 *		by the RTF reader
 *
 *	Authors:<nl>
 *		Created for RichEdit 2.0:	Brad Olenick 
 *
 *	Copyright (c) 1995-1996, Microsoft Corporation. All rights reserved.
 */
#ifndef __RTFLOG_H
#define __RTFLOG_H

#include "tokens.h"	

extern INT cKeywords;

class CRTFLog
{
public:
	typedef size_t INDEX;
	typedef INDEX *PINDEX;
	typedef DWORD ELEMENT;
	typedef ELEMENT *PELEMENT;

	CRTFLog();				//@cmember CRTFLog constructor
	inline ~CRTFLog();		//@cmember CRTFLog destructor

	BOOL FInit() const 
		{ return _rgdwHits ? TRUE : FALSE; }	//@cmember Determines whether object is init'd

	INDEX ISize() const 
		{ return cKeywords; }			//@cmember Number of elements in log

	inline BOOL AddAt(INDEX i);					//@cmember Increment hit count for element at index i
	inline BOOL AddAt(LPCSTR lpcstrKeyword);	//@cmember Increment hit count for RTF keyword 	
	inline BOOL AddAt(TOKEN token);				//@cmember Increment hit count for RTF token

	inline ELEMENT GetAt(INDEX i) const
		{ return (*this)[i]; }											//@cmember Get hit count for element i
	inline BOOL GetAt(LPCSTR lpcstrKeyword, PELEMENT pelemCount) const;	//@cmember Get hit count for RTF keyword
	inline BOOL GetAt(TOKEN token, PELEMENT pelemCount) const;			//@cmember Get hit count for RTF token

	void Reset();						//@cmember Reset all hit count values to 0

	UINT UGetWindowMsg() const;			//@cmember Get window msg ID used for log change notifications

private:
	// we manage all updates through AddAt to 
	// facilitate change notifications
	ELEMENT &operator[](INDEX);				//@cmember Access element i for l-value
	const ELEMENT &operator[](INDEX) const;	//@cmember Access element i for r-value

	LPCSTR LpcstrLogFilename() const;	//@cmember Get name of log filename

	BOOL IIndexOfKeyword(LPCSTR lpcstrKeyword, PINDEX pi) const;	//@cmember Get log index for keyword
	BOOL IIndexOfToken(TOKEN token, PINDEX pi) const;				//@cmember Get log index for token

	void ChangeNotify(INDEX i) const
		{ 
			PostMessage(HWND_BROADCAST, UGetWindowMsg(), i, 0);
		}	//@cmember Notify clients of change to element i
	void ChangeNotifyAll() const 
		{ ChangeNotify(ISize() + 1); }						//@cmember Notify clients of log refresh

	HANDLE _hfm;		//@cmember Handle to file mapping
	HANDLE _hfile;		//@cmember Handle to file behind file mapping
	PELEMENT _rgdwHits;	//@cmember Handle to view of file mapping
	UINT _uMsg;			//@cmember Window msg ID for change notifications
};


/*
 *	CRTFLog::~CRTFLog
 *	
 *	@mfunc
 *		Destructor - cleans up memory-mapped file and underlying resources
 *
 */
inline CRTFLog::~CRTFLog()
{
	if(_rgdwHits)
	{
		UnmapViewOfFile(_rgdwHits);
	}

	if(_hfm)
	{
		CloseHandle(_hfm);
	}

	if(_hfile)
	{
		CloseHandle(_hfile);
	}
}


/*
 *	CRTFLog::AddAt(INDEX i)
 *	
 *	@mfunc
 *		Increments the hit count for log element, i, and
 *		notifies clients of the change
 *
 *	@rdesc
 *		BOOL			whether the increment was successful
 */
inline BOOL CRTFLog::AddAt(INDEX i)
{
	(*this)[i]++;

	// change notification
	ChangeNotify(i);

	return TRUE;
}


/*
 *	CRTFLog::AddAt(LPCSTR lpcstrKeyword)
 *	
 *	@mfunc
 *		Increments the hit count for log element corresponding
 *		to the RTF keyword, lpcstrKeyword, and 
 *		notifies clients of the change
 *
 *	@rdesc
 *		BOOL			whether the increment was successful
 */
inline BOOL CRTFLog::AddAt(LPCSTR lpcstrKeyword)
{
	INDEX i;

	if(!IIndexOfKeyword(lpcstrKeyword, &i))
	{
		return FALSE;
	}

	return AddAt(i);
}


/*
 *	CRTFLog::AddAt(TOKEN token)
 *	
 *	@mfunc
 *		Increments the hit count for log element corresponding
 *		to the RTF token, token, and 
 *		notifies clients of the change
 *
 *	@rdesc
 *		BOOL			whether the increment was successful
 */
inline BOOL CRTFLog::AddAt(TOKEN token)
{
	INDEX i;

	if(!IIndexOfToken(token, &i))
	{
		return FALSE;
	}

	return AddAt((INDEX)i);
}


/*
 *	CRTFLog::GetAt(LPCSTR lpcstKeyword, PELEMENT pelemCount)
 *	
 *	@mfunc
 *		Gets the hit count for log element corresponding to the
 *		RTF keyword, lpcstrKeywor
 *
 *	@rdesc
 *		BOOL		indicates whether a hit count was found for the element
 */
inline BOOL CRTFLog::GetAt(LPCSTR lpcstrKeyword, PELEMENT pelemCount) const
{
	INDEX i;
	
	if(!IIndexOfKeyword(lpcstrKeyword, &i))
	{
		return FALSE;
	}

	if(pelemCount)
	{
		*pelemCount = (*this)[i];
	}

	return TRUE;
}
	

/*
 *	CRTFLog::GetAt(LPCSTR lpcstKeyword, PELEMENT pelemCount)
 *	
 *	@mfunc
 *		Gets the hit count for log element corresponding to the
 *		RTF token, token
 *
 *	@rdesc
 *		BOOL		indicates whether a hit count was found for the element
 */
inline BOOL CRTFLog::GetAt(TOKEN token, PELEMENT pelemCount) const
{
	INDEX i;
	
	if(!IIndexOfToken(token, &i))
	{
		return FALSE;
	}

	if(pelemCount)
	{
		*pelemCount = (*this)[i];
	}

	return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_rtext.h ===
/*
 *	_RTEXT.H
 *	
 *	Purpose:
 *		Base classes for rich-text manipulation
 *	
 *	Authors:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *
 */

#ifndef _RTEXT_H
#define _RTEXT_H

#include "_edit.h"
#include "_array.h"
#include "_doc.h"
#include "_text.h"
#include "_runptr.h"
#include "_frunptr.h"
#include "_notmgr.h"



//#pragma warning(disable: 4250)	

#define yHeightCharMost	32760

class CTxtEdit;
class CTxtRange;
class CRchTxtPtr;

// ReplaceRange's flags
enum
{
	RR_ITMZ_NOUNICODEBIDI	= 0,
	RR_ITMZ_UNICODEBIDI		= 1,
	RR_ITMZ_NONE			= 2,
									//the following bits should be exclusive
	RR_NO_EOR_CHECK			= 8		//flag indicating not to perform end-of-row check,
};

extern BOOL IsWhiteSpace(unsigned ch);

// ==============================  CRchTxtPtr  =====================================================
// Keeps physical positions corresponding to text character position (cp)
// within current text block, formatting runs, objects, unknown RTF runs,
// and floating ranges.

class CRchTxtPtr : public ITxNotify
{
public:

#ifdef DEBUG
    BOOL Invariant( void ) const;
	int m_InvariantCheckInterval;
#endif  // DEBUG

	CTxtPtr			_rpTX;		// rp in the plain text array
	CFormatRunPtr	_rpCF;		// rp in character format runs
	CFormatRunPtr	_rpPF;		// rp in paragraph format runs

// Useful constructors

	CRchTxtPtr(CTxtEdit *ped);
	CRchTxtPtr(CTxtEdit *ped, LONG cp);
	CRchTxtPtr(const CRchTxtPtr& rtp);
	CRchTxtPtr(const CDisplay * pdp);

	virtual CRchTxtPtr& operator =(const CRchTxtPtr& rtp)
	{
		_rpTX._ped = rtp._rpTX._ped;
		SetCp(rtp.GetCp());
		return *this;
	}

	LONG 	Advance(LONG cch);
	LONG	AdvanceCRLF();
	LONG	BackupCRLF(BOOL fDiacriticCheck = TRUE);
	LONG	SnapToCluster(INT iDirection = 0);
	LONG	SetCp( LONG cp);
	void	BindToCp(LONG cp);
	void	CheckFormatRuns();
	LONG	GetCp() const			{ return _rpTX.GetCp(); }
	LONG	GetTextLength() const	{ return _rpTX.GetTextLength(); }
	LONG	GetObjectCount() const	{ return GetPed()->GetObjectCount(); }
	CTxtEdit *GetPed() const		{ return _rpTX._ped; }
	const TCHAR * GetPch(LONG &cchvalid) { return _rpTX.GetPch(cchvalid); }
	TCHAR 	GetChar()				{ return _rpTX.GetChar(); }
	TCHAR 	GetPrevChar()			{ return _rpTX.GetPrevChar(); }
	void	ValidateCp(LONG &cp) const;
	LONG	GetParaNumber() const;
	LONG	GetCachFromCch(LONG cch);
	LONG	GetCchFromCach(LONG cach);

	// Text manipulation methods

	// Range operations
	LONG	ReplaceRange(LONG cchOld, LONG cchNew, TCHAR const *pch,
						 IUndoBuilder *publdr, LONG iFormat,
						 LONG *pcchMove = NULL, DWORD dwFlags = 0);
	BOOL 	ItemizeReplaceRange(LONG cchUpdate, LONG cchMove,
						IUndoBuilder *publdr, BOOL fUnicodeBidi = FALSE);
	BOOL	ChangeCase(LONG cch, LONG Type, IUndoBuilder *publdr);
	LONG	UnitCounter (LONG iUnit, LONG &	cUnit, LONG cchMax);
	void	ExtendFormattingCRLF();
	LONG	ExpandRangeFormatting(LONG cchRange, LONG cchMove, LONG& cchAdvance);

	// Search and word-break support
	LONG	FindText(LONG cpMax, DWORD dwFlags, TCHAR const *pch,
					 LONG cchToFind);
	LONG	FindWordBreak(INT action, LONG cpMost = -1);

	// Text-run management
	LONG 	GetIchRunCF();
	LONG	GetIchRunPF();
	LONG 	GetCchRunCF();
	LONG 	GetCchLeftRunCF();
	LONG 	GetCchLeftRunPF();
	
	// Character & paragraph format retrieval
	const CCharFormat* GetCF() const;
	const CParaFormat* GetPF() const;

	BOOL	IsCollapsed() const	{return (GetPF()->_wEffects & PFE_COLLAPSED) != 0;}
	BOOL	IsHidden() const	{return (GetCF()->_dwEffects & CFE_HIDDEN)   != 0;}
	BOOL	InTable() const		{return (GetPF()->_wEffects & PFE_TABLE)     != 0;}
	BOOL	IsParaRTL() const	{return (GetPF()->_wEffects & PFE_RTLPARA)   != 0;}

    // ITxNotify methods
    virtual void    OnPreReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
    					LONG cpFormatMin, LONG cpFormatMax) { ; }
	virtual void 	OnPostReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
						LONG cpFormatMin, LONG cpFormatMax) { ; }
	virtual void	Zombie();

	BOOL	Check_rpCF();
	BOOL	Check_rpPF();

protected:
	BOOL 	AdvanceRunPtrs(LONG cp);
	void	InitRunPtrs();
	BOOL	IsRich();
	bool  	fUseUIFont() const {return GetPed()->fUseUIFont();}
	BOOL	IsInOutlineView() const {return GetPed()->IsInOutlineView();}
	void	SetRunPtrs(LONG cp, LONG cpFrom);

private:
	LONG	ReplaceRangeFormatting(LONG cchOld, LONG cchNew, LONG iFormat,
							IUndoBuilder *publdr,
							IAntiEvent **ppaeCF, IAntiEvent **ppaePF,
							LONG cchMove, LONG cchPrevEOP, LONG cchNextEOP,
							LONG cchSaveBefore = 0, LONG cchSaveAfter = 0);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_rtfwrit.h ===
/*
 *	@doc INTERNAL
 *
 *	@module _RTFWRIT.H -- RichEdit RTF Writer Class Definition |
 *
 *	Description:
 *		This file contains the type declarations used by the RTF writer
 *		for the RICHEDIT control
 *
 *	Authors: <nl>
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco <nl>
 *		Conversion to C++ and RichEdit 2.0:  Murray Sargent
 *
 *	@devnote
 *		All sz's in the RTF*.? files refer to a LPSTRs, not LPTSTRs, unless
 *		noted as a szUnicode.
 */
#ifndef __RTFWRIT_H
#define __RTFWRIT_H

#include "_rtfconv.h"
extern const KEYWORD rgKeyword[];

#define PUNCT_MAX	1024


class CRTFWrite ;


class RTFWRITEOLESTREAM : public OLESTREAM
{
	OLESTREAMVTBL OLEStreamVtbl;	// @member - memory for  OLESTREAMVTBL
public:
	 CRTFWrite *Writer;				// @cmember CRTFwriter to use

	RTFWRITEOLESTREAM::RTFWRITEOLESTREAM ()
	{
		lpstbl = & OLEStreamVtbl ;
	}		
};

enum									// Control-Word-Format indices
{
	CWF_STR, CWF_VAL, CWF_GRP, CWF_AST, CWF_GRV
};

#define chEndGroup RBRACE

/*
 *	CRTFWrite
 *
 *	@class	RTF writer class.
 *
 *	@base	public | CRTFConverter
 *
 */
class CRTFWrite : public CRTFConverter
{
private:
	LONG		_cchBufferOut;			//@cmember # chars in output buffer
	LONG		_cchOut;				//@cmember Total # chars put out
	LONG		_cbCharLast;			//@cmember # bytes in char last written
	BYTE		_fBullet;				//@cmember Currently in a bulleted style
	BYTE		_fBulletPending;		//@cmember Set if next output should bull
	BYTE		_fNeedDelimeter;		//@cmember Set if next char must be nonalphanumeric
	BYTE        _fIncludeObjects;       //@cmember Set if objects should be included in stream
	BYTE		_fCheckInTable;			//@cmember If set and in table, output intbl stuff
	BYTE		_fRangeHasEOP;			//@cmember Set if _prg has EOP
	BYTE		_fNCRForNonASCII;		//@cmember Put /uN for nonASCII
	char *		_pchRTFBuffer;			//@cmember Ptr to RTF write buffer
	BYTE *		_pbAnsiBuffer;			//@cmember Ptr to buffer used for conversion
	char *		_pchRTFEnd;				//@cmember Ptr to RTF-write-buffer end
	LONG		_symbolFont;			//@cmember Font number of Symbol used by Bullet style
	RTFWRITEOLESTREAM RTFWriteOLEStream;//@cmember RTFWRITEOLESTREAM to use
	LONG		_nHeadingStyle;			//@cmember Deepest heading # found
	LONG		_nNumber;				//@cmember Current number in para (1-based)
	LONG		_nFont;					//@cmember Current number font index
	LONG		_cpg;					//@cmember Current number code page
	const CParaFormat *_pPF;			//@cmember Current para format

										// @cmember Build font/color tables
	EC			BuildTables		(CFormatRunPtr& rpCF, CFormatRunPtr &rpPF,
								LONG cch, BOOL& fNameIsDBCS);
	inline void		CheckDelimeter()		// @cmember	Put ' ' if need delimeter
	{
		if(_fNeedDelimeter)
		{
			_fNeedDelimeter = FALSE;
			PutChar(' ');
		}
	};

	BOOL		CheckInTable	(BOOL fPutIntbl);
										// @cmember Stream out output buffer
	BOOL		FlushBuffer		();
										// @cmember Get index of <p colorref>
	LONG		LookupColor		(COLORREF colorref);
										// @cmember Get font index for <p pCF>
	LONG		LookupFont		(CCharFormat const * pCF);
										// @cmember "printf" to output buffer
	BOOL _cdecl printF			(CONST CHAR * szFmt, ...);
										// @cmember Put char <p ch> in output buffer
	EC			PutBorders		(BOOL fInTable);
	BOOL		PutChar			(CHAR ch);
										// @cmember Put control word <p iCtrl> with value <p iValue> into output buffer
	BOOL		PutCtrlWord		(LONG iFormat, LONG iCtrl, LONG iValue = 0);
										// @cmember Put string <p sz> in output buffer
	BOOL		Puts			(CHAR const * sz, LONG cb);
										// @cmember Write char format <p pCF>
	EC			WriteCharFormat	(const CCharFormat *pCF);
	EC			WriteColorTable	();		// @cmember Write color table
	EC			WriteFontTable	();		// @cmember Write font table
	EC			WriteInfo		();		// @cmember Write document info
										// @cmember Write para format <p pPF>
	EC			WriteParaFormat	(const CRchTxtPtr * prtp);
										// @cmember Write PC data <p szData>
	EC			WritePcData		(const TCHAR * szData, INT nCodePage = CP_ACP, BOOL fIsDBCS = FALSE );
										// @cmember Write <p cch> chars of text <p pch>
	EC			WriteText(LONG cwch, LPCWSTR lpcwstr, INT nCodePage, BOOL fIsDBCS);
	EC			WriteTextChunk(LONG cwch, LPCWSTR lpcwstr, INT nCodePage, BOOL fIsDBCS);


// OBJECT
	EC			WriteObject		(LONG cp, COleObject *pobj);
	BOOL		GetRtfObjectMetafilePict(HGLOBAL hmfp, RTFOBJECT &rtfobject, SIZEL &sizelGoal);
	BOOL		GetRtfObject(REOBJECT &reobject, RTFOBJECT &rtfobject);
	EC			WriteRtfObject(RTFOBJECT & rtfOb, BOOL fPicture);
	BOOL		ObjectWriteToEditstream(REOBJECT &reObject, RTFOBJECT &rtfobject);
	EC			WritePicture(REOBJECT &reObject,RTFOBJECT  &rtfObject);
	EC			WriteDib(REOBJECT &reObject,RTFOBJECT  &rtfObject);

	enum 		{ MAPTOKWD_ANSI, MAPTOKWD_UNICODE };
	inline BOOL	MapsToRTFKeywordW(WCHAR wch);
	inline BOOL	MapsToRTFKeywordA(char ch);
	int 		MapToRTFKeyword(void *pv, int cch, int iCharEncoding);

public:
											// @cmember Constructor
	CRTFWrite(CTxtRange *prg, EDITSTREAM *pes, DWORD dwFlags);
	~CRTFWrite() {FreePv(_pbAnsiBuffer);}	// @cmember Destructor

	LONG		WriteRtf();				// @cmember Main write entry used by
										//  CLiteDTEngine
	LONG		WriteData		(BYTE * pbBuffer, LONG cbBuffer);
	LONG		WriteBinData	(BYTE * pbBuffer, LONG cbBuffer);

};										


#endif // __RTFWRIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_runptr.h ===
/*
 *	@doc INTERNAL
 *
 *	@module _RUNPTR.H -- Text run and run pointer class defintion |
 *	
 *	Original Author:	<nl>
 *		Christian Fortini
 *
 *	History: <nl>
 *		6/25/95	alexgo	Commenting and Cleanup
 *
 *	Copyright (c) 1995-1997 Microsoft Corporation. All rights reserved.
 */

#ifndef _RUNPTR_H
#define _RUNPTR_H

#include "_array.h"
#include "_doc.h"

typedef CArray<CTxtRun> CRunArray;

/*
 *	CRunPtrBase
 *
 *	@class	Base run pointer functionality.  Keeps a position within an array
 *  	of text runs.
 *
 *	@devnote	Run pointers go through three different possible states :
 *
 *	NULL:	there is no data and no array (frequently a startup condition) <nl>
 *			<mf CRunPtrBase::SetRunArray> will transition from this state to 
 *			the Empty state.  It is typically up to the derived class to
 *			define when that method should be called. IsValid() fails. <nl>
 *
 *			<md CRunPtrBase::_pRuns> == NULL <nl>
 *			<md CRunPtrBase::_iRun> == 0 <nl>
 *			<md CRunPtrBase::_ich> == 0 <nl>
 *
 *	Empty:	an array class exists, but there is no data (can happen if all 
 *			of the elements in the array are deleted).  IsValid() fails.<nl>
 *	 		<md CRunPtrBase::_pRuns> != NULL <nl>
 *			<md CRunPtrBase::_iRun> == 0 <nl>
 *			<md CRunPtrBase::_ich> <gt>= 0 <nl>
 *			<md CRunPtrBase::_pRuns-<gt>Count()> == 0 <nl>
 *
 *	Normal:	the array class exists and has data; IsValid() succeeds and
 *			<md CRunPtrBase::_pRuns-<gt>Elem[] is defined <nl>
 *			<md CRunPtrBase::_pRuns> != NULL <nl>
 *			<md CRunPtrBase::_iRun> >= 0 <nl>
 *			<md CRunPtrBase::_ich> >= 0 <nl>
 *			<md _pRuns>-<gt>Count() > 0 <nl>		
 *	
 *	Note that in order to support the empty and normal states, the actual 
 *	array element at <md CRunPtrBase::_iRun> must be explicitly fetched in
 *	any method that may need it.
 *
 *	Currently, there is no way to transition to the NULL state from any of
 *  the other states.  If we needed to, we could support that by explicitly 
 *	fetching the array from the document on demand.
 *
 *	Note that only <md CRunPtrBase::_iRun> is kept.  We could also keep 
 * 	a pointer to the actual run (i.e. _pRun).  Earlier versions of this
 *	engine did in fact do this.  I've opted to not do this for several
 *	reasons: <nl>
 *		1. If IsValid(), _pRun is *always* available by calling Elem(_iRun).
 * 		Therefore, there is nominally no need to keep both _iRun and _pRun.<nl>
 *		2. Run pointers are typically used to either just move around
 *		and then fetch data or move and fetch data every time (like during 
 *		a measuring loop).  In the former case, there is no need to always
 *		bind _pRun; you can just do it on demand.  In the latter case, the
 *		two models are equivalent.  
 */

class CRunPtrBase
{
	friend class CDisplayML;
	friend class CDisplaySL;

//@access Public methods
public:

#ifdef DEBUG
	BOOL	Invariant() const;				//@cmember	Invariant tests
	void	ValidatePtr(void *pRun) const;	//@cmember	Validate <p pRun>
	LONG 	CalcTextLength() const;			//@cmember  Get total cch in runs
#define	VALIDATE_PTR(pRun)	ValidatePtr(pRun)

#else
#define	VALIDATE_PTR(pRun)
#endif // DEBUG

	CRunPtrBase(CRunArray *pRuns);			//@cmember	Constructor
	CRunPtrBase(CRunPtrBase& rp);			//@cmember	Constructor

	// Run Control
	void	SetRunArray(CRunArray *pRuns)	//@cmember Set run array for this
	{										// run ptr
		_pRuns = pRuns;
	}
	BOOL 	SetRun(LONG iRun, LONG ich);	//@cmember Set this runptr to run
											// <p iRun> & char offset <p ich>
	BOOL	NextRun();						//@cmember Advance to next run
	BOOL	PrevRun();						//@cmember Go back to prev run
	BOOL	ChgRun(LONG cRun)				//@cmember Move <p cRun> runs
	{										// returning TRUE if successful
		return SetRun(_iRun + cRun, 0);
	}	
											//@cmember Count <p cRun> runs 
	LONG	CountRuns(LONG &cRun,			// returning cch counted and
				LONG cchMax,				// updating <p cRun>
				LONG cp,
				LONG cchText) const;
											//@cmember Find run range limits
	void	FindRun (LONG *pcpMin,
				LONG *pcpMost, LONG cpMin, LONG cch, LONG cchText) const;

	CTxtRun * GetRun(LONG cRun) const;		//@cmember Retrieve run element at 
											// offset <p cRun> from this run
	LONG	Count() const					//@cmember	Get count of runs
	{
		return _pRuns->Count();
	}
	BOOL	SameRuns(CRunPtrBase *prp)		//@cmember Return TRUE iff same runs
	{
		return _pRuns == prp->_pRuns;
	}
	BOOL	SameRun(CRunPtrBase *prp)
	{
		return SameRuns(prp) && _iRun == prp->_iRun;
	}

	// Character position control
	LONG 	BindToCp(LONG cp);	//@cmember	Set cp for this run ptr = <p cp>
	LONG 	CalculateCp() const;//@cmember	Add _cch's up to _iRun, _ich
	LONG	AdvanceCp(LONG cch);//@cmember	Advance cp by <p cch> chars

	void 	AdjustBackward();	//@cmember	If on the edge of two runs, 
								// adjust to end of left (previous) run
	void	AdjustForward();	//@cmember	If at the edge of two runs,
								// adjust to start of right (next) run
	LONG 	GetIch() const		//@cmember	Return <md CRunPtrBase::_ich>
				{Assert(IsValid()); return _ich;}
	LONG	GetCchLeft() const;	//@cmember	Return GetRun(0)->_cch - GetIch()								
	BOOL	IsValid() const;	//@cmember	Return FALSE if run ptr is in
								// empty or NULL states.  TRUE otherwise
	void	SetToNull();		//@cmember	Clears data from run pointer

//@access Protected Data
protected:
	CRunArray *	_pRuns;	    	//@cmember	Pointer to CTxtRun array
	LONG 		_iRun;  	    //@cmember	Index of current run in array
	LONG 		_ich;		    //@cmember	Char offset inside current run
};


/*
 *	CRunPtr	(template)
 *
 *	@class	a template over CRunPtrBase allowing for type-safe versions of
 *		run pointers
 * 
 *	@tcarg	class 	| CElem | run array class to be used
 *
 *	@base	public | CRunPtrBase
 */
template <class CElem>
class CRunPtr : public CRunPtrBase
{
public:
	CRunPtr (void)								//@cmember	Constructor
		: CRunPtrBase (0) {}
	CRunPtr (CRunArray *pRuns)					//@cmember	Constructor
		: CRunPtrBase (pRuns) {}
	CRunPtr (CRunPtrBase& rp)					//@cmember	Constructor
		: CRunPtrBase (rp) {}

	// Array management 
										
	CElem *	Add (LONG cRun, LONG *pielIns)	//@cmember Add <p cRun> 	
	{											// elements at end of array
		return (CElem *)_pRuns->Add(cRun, pielIns);
	}
										
	CElem *	Insert (LONG cRun)					//@cmember Insert <p cRun>
	{											// elements at current pos
		return (CElem *)_pRuns->Insert(_iRun, cRun);
	}
										
	void 	Remove (LONG cRun)	//@cmember Remove <p cRun>
	{											// elements at current pos
		_pRuns->Remove (_iRun, cRun);
	}
										//@cmember	Replace <p cRun> elements
										// at current position with those
										// from <p parRun>
	BOOL 	Replace (LONG cRun, CArrayBase *parRun)
	{
		return _pRuns->Replace(_iRun, cRun, parRun);
	}

	CElem *	Elem(LONG iRun) const		//@cmember	Get ptr to run <p iRun>
	{
		return (CElem *)_pRuns->Elem(iRun);
	}
										
	CElem *	GetRun(LONG cRun) const		//@cmember	Get ptr <p cRun> runs
	{									//  away from current run
		return Elem(_iRun + cRun);
	}

	void	IncPtr(CElem *&pRun) const	//@cmember	Increment ptr <p pRun>
	{
		VALIDATE_PTR(pRun);				// Allow invalid ptr after ++ for
		pRun++;							//  for loops
	}
										
	CElem *	GetPtr(CElem *pRun, LONG cRun) const//@cmember Get ptr <p cRun>
	{											// runs away from ptr <p pRun>
		VALIDATE_PTR(pRun + cRun);
		return pRun + cRun;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_rtfread.h ===
/*
 *	@doc INTERNAL
 *
 *	@module _RTFREAD.H -- RichEdit RTF Reader Class Definition |
 *
 *		This file contains the type declarations used by the RTF reader
 *		for the RICHEDIT control
 *
 *	Authors:<nl>
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco <nl>
 *		Conversion to C++ and RichEdit 2.0:  Murray Sargent
 *
 *	@devnote
 *		All sz's in the RTF*.? files refer to a LPSTRs, not LPTSTRs, unless
 *		noted as a szUnicode.
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */
#ifndef __RTFREAD_H
#define __RTFREAD_H

#include "_rtfconv.h"

// TODO: Implement RTF tag logging for the Mac
#if defined(DEBUG) && !defined(MACPORT)
#include "_rtflog.h"
#endif

typedef SHORT	ALIGN;

/*
 *		Destinations of the stuff we may read in while parsing
 */
enum
{
	destRTF,
	destColorTable,
	destFontTable,
	destBinary,
	destObject,
	destObjectClass,
	destObjectName,
	destObjectData,		  // keep next two together
	destPicture,
	destField,
	destFieldResult,
	destFieldInstruction,
	destParaNumbering,
	destParaNumText,
	destRealFontName,
	destFollowingPunct,
	destLeadingPunct,
	destDocumentArea,
	destNULL,
	destStyleSheet
};


/*
 *		Super or subscripting state
 */
enum
{
	sSub = -1,
	sNoSuperSub,
	sSuper
};

/*
 *	@struct STATE | 
 *		Structure to save current reader state
 */
struct STATE
{
	SHORT		sLanguage;				//@field Font information
	SHORT		iCF;					//@field CF index at LBRACE

	// Miscellaneous flags
	unsigned	fInTable		 : 1;	//@field Are we parsing a table cell ?
	unsigned	fBullet			 : 1;	//@field group is a \\pn bullet group
	unsigned	fRealFontName	 : 1;	//@field found a real font name when parsing
	unsigned	fExplicitLang	 : 1;	//@field language explicitly declared
	unsigned	fFieldInst		 : 1;	//@field \fldinst being processed
	unsigned	fFieldRslt		 : 1;	//@field \fldrslt being processed or processed

	// BiDi flags
	unsigned	fRightToLeftPara : 1;	//@field Para text going right to left ?
	unsigned	fZeroWidthJoiner : 1;	//@field Zero Width Joiner ?

	unsigned	frtlch			 : 1;	//@field Are we going right to left ?
	unsigned	fltrch			 : 1;	//@field Are we going right to left ?
	unsigned	fdbch			 : 1;	//@field DBCS run ?
	

	// xchg 12370: keep numbering indent separate
	SHORT		sIndentNumbering;		//@field numbering indent
	SHORT		sDest;					//@field Current destination
	int			nCodePage;				//@field Current code page

	WORD		cbSkipForUnicodeMax;	//@field Bytes to skip after \uN is read

	// Scratch pad variables
	TEXTFONT *	ptf;					//@field Ptr to font table entry to fill
	BYTE		bRed;					//@field Color table red entry
	BYTE		bGreen;					//@field Color table green entry
	BYTE		bBlue;					//@field Color table blue entry
	STATE * 	pstateNext;				//@field Next state on stack
	STATE * 	pstatePrev;				//@field Previous state on stack

	CParaFormat *pPF;					//@field PF for the state to which 
										//	delta's are applied
	DWORD		dwMaskPF;

	STATE(LONG CodePage) {nCodePage = CodePage;}

										//@cmember Adds or applies PF to state's PF
	BOOL AddPF(const CParaFormat &PF,
				LONG lDocType, DWORD dwMask);
	void DeletePF();					//@cmember Deletes PF for state
	void SetCodePage(LONG CodePage);
};

class CRTFRead ;
class COleObject;


class RTFREADOLESTREAM : public OLESTREAM
{
	OLESTREAMVTBL OLEStreamVtbl;	// @member - memory for  OLESTREAMVTBL
public:
	 CRTFRead *Reader;				// @cmember EDITSTREAM to use

	RTFREADOLESTREAM::RTFREADOLESTREAM ()
	{
		lpstbl = & OLEStreamVtbl ;
	}		
};

#define	NSTYLES		(NHSTYLES + 1)
/*
 *	CRTFRead
 *
 *	@class	RichEdit RTF reader class.
 *
 *	@base	public | CRTFConverter
 *
 */
class CRTFRead : public CRTFConverter
{

//@access Private Methods and Data
	// Lexical analyzer outputs
	LONG		_iParam;				//@cmember Control-word parameter
	TOKEN		_token;					//@cmember Current control-word token
	TOKEN		_tokenLast;				//@cmember Previous token
	BYTE *		_szText;				//@cmember Current BYTE text string
	BYTE		_szParam[cachParamMax];	//@cmember Current parameter string

	// Used for reading in
	BYTE		_rgStyles[NSTYLES];		//@cmember Style handle table
	SHORT		_Style;					//@cmember Current style handle
	LONG		_cbBinLeft;				//@cmember cb of bin data left to read
	BYTE *		_pchRTFBuffer;			//@cmember Buffer for GetChar()
	BYTE *		_pchRTFCurrent;			//@cmember Current position in buffer
	BYTE *		_pchRTFEnd;				//@cmember End of buffer
	BYTE *		_pchHexCurr;			//@cmember Current position within
										//  _szText when reading object data
	INT			_nStackDepth;			//@cmember Stack depth
	STATE *		_pstateStackTop;		//@cmember Stack top
	STATE *		_pstateLast;			//@cmember Last STATE allocated
	LONG		_cpThisPara;			//@cmember Start of current paragraph

	DWORD		_dwMaskCF;				//@cmember Character format mask
	DWORD		_dwMaskCF2;				//@cmember Character format mask 2
	CParaFormat	_PF;					//@cmember Paragraph format changes
	DWORD		_dwMaskPF;				//@cmember Paragraph format mask

	LONG		_cTab;					//@cmember Count of defined tabs
	LONG		_dxCell;				//@cmember Half space betw table cells
	LONG		_cCell;					//@cmember Count of cells in table row
	LONG		_iCell;					//@cmember Current cell in table row 
	LONG		_rgxCell[MAX_TAB_STOPS];//@cmember Cell right boundaries
	LONG		_xRowOffset;			//@cmember Row offset to ensure rows fall along left margin
	DWORD		_dwBorderColor;			//@cmember Border colors
	WORD		_wBorders;				//@cmember Border styles
	WORD		_wBorderSpace;			//@cmember Border/text spaces
	WORD		_wBorderWidth;			//@cmember Border widths
	SHORT		_iTabsTable;			//@cmember _iTabs used by last table
	
	COleObject *_pobj;					//@cmember Pointer to our object

	union
	{
	  DWORD		_dwFlagsUnion;			// All together now
	  struct
	  {
		WORD	_fFailedPrevObj	 : 1;	//@cmember Fail to get prev object ?
		WORD	_fNeedIcon		 : 1;	//@cmember Objects needs an icon pres
		WORD	_fNeedPres		 : 1;	//@cmember Use stored presenation.
		WORD	_fGetColorYet	 : 1;	//@cmember used for AutoColor detect
		WORD	_fRightToLeftDoc : 1;	//@cmember Document is R to L ?
		WORD	_fReadDefFont	 : 1;	//@cmember True if we've read a default
										// 		   font from RTF input
		WORD	_fHyperlinkField : 1;	//@cmember TRUE if handling HYPERLINK field
		WORD	_fSeenFontTable	 : 1;	//@cmember True if \fonttbl	processed 
		WORD	_fCharSet		 : 1;	//@cmember True if \fcharset processed
		WORD    _fNoRTFtoken     : 1;   //@cmember True in 1.0 mode if \rtf hasn't been seen
		WORD	_fInTable		 : 1;	//@cmember True if pasting into table
		BYTE	_bDocType;				//@cmember Document Type
	  };
	};

	SHORT		_sDefaultFont;			//@cmember Default font to use
	SHORT       _sDefaultBiDiFont;      //@cmemeber Default Bidi font to use
	SHORT		_sDefaultLanguage;		//@cmember Default language to use
	SHORT		_sDefaultLanguageFE;	//@cmember Default FE language to use

	SHORT		_sDefaultTabWidth;		//@cmember Default tabwidth to use
	BYTE		_bAlignment;			//@cmember Alignment for tables
	BYTE		_bInstFieldCharSet;		//@cmember charset of for HYPERLINK inst field

	BYTE *		_szSymbolFieldResult;   //@cmember Buffer for SYMBOL field result
	CCharFormat _FieldCF;				//@cmember Formatting for field result
	int			_nFieldCodePage;
	DWORD		_dwMaskFieldCF;			//@cmember Character format mask for _FieldCF
	DWORD		_dwMaskFieldCF2;		//@cmember Character format mask 2 for _FieldCF
	TEXTFONT *	_ptfField;
	BOOL		_fRestoreFieldFormat;	//@cmember Indicates if the caced format was restored
	TCHAR		_szNumText[cchMaxNumText];	//@cmember Scratch pad for numbered lists

	int			_nCodePage;				//@cmember default codepage (RTF-read-level)
	int			_cchUsedNumText;		//@cmember space used in szNumText

	BYTE *		_szHyperlinkFldinst;	//@cmember Hyperlink Fldinst string	buffer
	int			_cchHyperlinkFldinst;	//@cmember size of Hyperlink Fldinst string	buffer
	int			_cchHyperlinkFldinstUsed;	//@cmember space used in Hyperlink Fldinst string buffer

	BYTE *		_szHyperlinkFldrslt;	//@cmember Hyperlink Fldrslt string	buffer	
	int			_cchHyperlinkFldrslt;	//@cmember size of Hyperlink Fldrslt string	buffer
	int			_cchHyperlinkFldrsltUsed;	//@cmember space used in Hyperlink Fldrslt string buffer

	RTFOBJECT *	_prtfObject;			//@cmember Ptr to RTF Object
	RTFREADOLESTREAM RTFReadOLEStream;	//@cmember RTFREADOLESTREAM to use

	TCHAR *		_szUnicode;				//@cmember String to hold Unicoded chars
	LONG		_cchUnicode;			//@cmember Size of _szUnicode in WCHARs
	DWORD		_cchMax;				//@cmember Max cch that can still be inserted
	LONG		_cpFirst;				//@cmember Starting cp for insertion

	// Object attachment placeholder list
	LONG *		_pcpObPos;
	int			_cobPosFree;
	int 		_cobPos;

	WORD		_wNumberingStyle;		//@cmember Numbering style to use
	WORD		_cbSkipForUnicode; 		//@cmember Bytes to skip after \uN
	BYTE		_bTabType;				//@cmember left/right/center/deciml/bar tab
	BYTE		_bTabLeader;			//@cmember none/dotted/dashed/underline
	BYTE		_bBorder;				//@cmember Current border segment
	BYTE		_bCellBrdrWdths;		//@cmember Current cell border widths

	BYTE		_bBiDiCharSet;			//@cmember Default system's charset

	// Lexical Analyzer Functions
	void	DeinitLex();				//@cmember Release lexer storage
	BOOL	InitLex();					//@cmember Alloc lexer storage
	EC		SkipToEndOfGroup();			//@cmember Skip to matching }
	TOKEN	TokenFindKeyword(BYTE *szKeyword);	//@cmember Find _token for szKeyword
	TOKEN	TokenGetHex();				//@cmember Get next byte from hex input
	TOKEN	TokenGetKeyword();			//@cmember Get next control word
	TOKEN	TokenGetText(BYTE ch);		//@cmember Get text in between ctrl words
	TOKEN	TokenGetToken();			//@cmember Get next {, }, \\, or text
	BOOL 	FInDocTextDest() const;		//@cmember Is reader in document text destination

	// Input Functions
	LONG	FillBuffer();				//@cmember Fill input buffer
	BYTE	GetChar();					//@cmember Return char from input buffer
	BYTE	GetHex();					//@cmember Get next hex value from input
	BYTE	GetHexSkipCRLF();			//@cmember Get next hex value from input
	void	ReadFontName(STATE *pstate, int iAllASCII);//@cmember Copy font name into state
	BOOL	UngetChar();				//@cmember Decrement input buffer ptr
	BOOL	UngetChar(UINT cch);		//@cmember Decrement input buffer ptr 'cch' times

	// Reader Functions
	EC		AddText(TCHAR *pch, LONG cch, BOOL fNumber);//@cmember Insert text into range
	void	Apply_CF();					//@cmember Apply _CF changes
	void	Apply_PF();					//@cmember Apply _PF changes
	COLORREF GetColor(DWORD dwMask);	//@cmember Get color _iParam for mask
	LONG	GetStandardColorIndex();	//@cmember Get std index <-> _iparam
	EC		HandleChar(WORD ch);		//@cmember Insert single Unicode
	EC		HandleEndGroup();			//@cmember Handle }
	EC		HandleEndOfPara();			//@cmember Insert EOP into range
	EC		HandleStartGroup();			//@cmember Handle {
	enum { CONTAINS_NONASCII, ALL_ASCII };
	EC		HandleText(BYTE *szText, int iAllASCII, LONG cchText = -1);//@cmember Insert szText into range
	EC		HandleToken();				//@cmember Grand _token switchboard
	void	SelectCurrentFont(INT iFont);//@cmember Select font <p iFont>
	void	SetPlain(STATE *pstate);	//@cmember Setup _CF for \plain
	EC		HandleFieldInstruction();	//@cmember	Handle field instruction
	EC		HandleFieldSymbolInstruction(BYTE *pch);	//@cmember	Handle specific SYMBOL field instruction
	EC		HandleFieldHyperlink(BYTE *pch); //@cmember	Handle hyperlink field instruction
	EC		HandleFieldSymbolFont(BYTE *pch); //@cmember Handle \\f "Facename" in symbol
	void	HandleFieldEndGroup();			//@cmember Handle Field End Group

	// Object functions
	EC		HexToByte(BYTE *rgchHex, BYTE *pb);
	void	FreeRtfObject();
	EC		StrAlloc(TCHAR ** ppsz, BYTE * sz);
	BOOL	ObjectReadFromEditStream(void);
	BOOL	StaticObjectReadFromEditStream(int cb = 0);
	BOOL	ObjectReadSiteFlags( REOBJECT * preobj);
	
	void	SetBorderParm(WORD& Parm, LONG Value);
	BOOL 	CpgInfoFromFaceName(TEXTFONT *ptf);	//@cmember Determines 
										// charset/cpg based on TEXTFONT::szName

//@access Public Methods
public:
		//@cmember RTF reader constructor
	CRTFRead(CTxtRange *prg, EDITSTREAM *pes, DWORD dwFlags);
	inline ~CRTFRead();					//@cmember CRTFRead destructor

	LONG	ReadRtf();					//@cmember Main Entry to RTF reader

	LONG	ReadData(BYTE *pbBuffer, LONG cbBuffer); // todo friend
	LONG	ReadBinaryData(BYTE *pbBuffer, LONG cbBuffer);
	LONG	SkipBinaryData(LONG cbSkip);
	LONG	ReadRawText(char	**pszRawText);				//@cmember Read in raw text

// Member functions/data to test coverage of RTF reader
#if defined(DEBUG)
public:
	void TestParserCoverage();
private:
	CHAR *PszKeywordFromToken(TOKEN token);
	BOOL FTokIsSymbol(TOKEN tok);
	BOOL FTokFailsCoverageTest(TOKEN tok);

	BOOL _fTestingParserCoverage;

private:
	// member data for RTF tag logging
	CRTFLog *_prtflg;
#endif //DEBUG
};

/*
 *	PointsToFontHeight(cHalfPoints)
 *
 *	@func
 *		Convert half points to font heights
 *
 *	@parm int |
 *		sPointSize |		Font height in half points
 *
 *	@rdesc
 *		LONG				The corresponding CCharFormat.yHeight value
 */
#define PointsToFontHeight(cHalfPoints) (((LONG) cHalfPoints) * 10)


/*
 *	CRTFRead::~CRTFRead
 *
 *	@mdesc
 *		Destructor 
 *
 */
inline CRTFRead::~CRTFRead()
{
// TODO: Implement RTF tag logging for the Mac and WinCE
#if defined(DEBUG) && !defined(MACPORT)	&& !defined(PEGASUS)
	if(_prtflg)
	{
		delete _prtflg;
		_prtflg = NULL;
	}
#endif
}
#endif // __RTFREAD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_render.h ===
/*
 *	_RENDER.H
 *	
 *	Purpose:
 *		CRenderer class
 *	
 *	Authors:
 *		RichEdit 1.0 code: David R. Fulmer
 *		Christian Fortini (initial conversion to C++)
 *		Murray Sargent
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _RENDER_H
#define _RENDER_H

#include "_measure.h"
#include "_rtext.h"
#include "_osdc.h"

BOOL IsTooSimilar(COLORREF cr1, COLORREF cr2);

class CDisplay;

// ==========================  CRenderer  ==================================
// CRenderer - specialized text pointer used for rendering text

class CRenderer : public CMeasurer
{
	friend struct COls;
	friend struct CLsrun;
	friend LSERR OlsDrawGlyphs(POLS,PLSRUN,BOOL,BOOL,PCGINDEX,const int*,const int*,PGOFFSET,PGPROP,
		PCEXPTYPE,DWORD,LSTFLOW,UINT,const POINT*,PCHEIGHTS,long,long,const RECT*);

private:
    RECT        _rcView;			// View rect (_hdc logical coords)
    RECT        _rcRender;			// Rendered rect (_hdc logical coords)
    RECT        _rc;				// Running clip/erase rect (_hdc logical coords)
    LONG        _xWidthLine;		// Total width of line
	LONG		_cpAccelerator;		// Accelerator cp if any (-1 if none).

	COLORREF	_crBackground;		// Default background color
	COLORREF	_crForeDisabled;	// Foreground color for disabled text
	COLORREF	_crShadowDisabled;	// Shadow color for disabled text
	COLORREF	_crTextColor;		// Default text color

	COLORREF	_crCurBackground;	// Current background color
	COLORREF	_crCurTextColor;	// Current text color

	COffScreenDC _osdc;				// Manager for off screen DC
	HDC			_hdc;

	union
	{
	  DWORD		_dwFlags;			// All together now
	  struct
	  {
		DWORD	_fDisabled:1;		// Draw text with disabled effects?
		DWORD	_fErase:1;	    	// Erase background (non transparent)
    	DWORD	_fSelected:1;   	// Render run with selection colors
		DWORD	_fLastChunk:1;		// Rendering last chunk
		DWORD	_fSelectToEOL:1;	// Whether selection runs to end of line
		DWORD	_fUseOffScreenDC:1;	// Using off screen DC
		DWORD	_fRenderSelection:1;// Render selection?
		DWORD	_fBackgroundColor:1;// Some text in the line has non-default 
									// background color.
		DWORD	_fEnhancedMetafileDC:1;	// Use ExtTextOutA to hack around all
										// sort of Win95FE EMF or font problems
		DWORD	_fFEFontOnNonFEWin9x:1; // have to use ExtTextOutW even for EMF.
		DWORD	_fSelectedPrev:1;	// TRUE if prev run selected
		DWORD	_fStrikeOut:1;		// TRUE if current run is struckout
	  };
	};

	LOGPALETTE *_plogpalette;
	POINT	 	_ptCur;				// Current rendering position on screen
	BYTE		_bUnderlineType;	// Underline type
	BYTE		_bUnderlineClrIdx;	// Underline color index (0 uses text color)

			void	Init();			// Initialize most members to zero

			void	UpdatePalette(COleObject *pobj);

			void	RenderText(const WCHAR* pch, LONG cch);

			BOOL	SetNewFont();
		
			BOOL 	RenderChunk(LONG &cchChunk, const WCHAR *pszToRender, LONG cch);
			LONG	RenderTabs(LONG cchChunk);
			BOOL	RenderBullet();

public:
	CRenderer (const CDisplay * const pdp);
	CRenderer (const CDisplay * const pdp, const CRchTxtPtr &rtp);
	~CRenderer (){}

	        void    operator =(const CLine& li)     {*(CLine*)this = li;}

			void	RenderExtTextOut(LONG x, LONG y, UINT fuOptions, RECT *prc, PCWSTR pch, UINT cch, const INT *rgdxp);
			void	SetSelected(BOOL f)				{_fSelected = f;}
			BOOL	fBackgroundColor() const		{return _fBackgroundColor;}
			BOOL	fUseOffScreenDC() const			{return _fUseOffScreenDC;}
			COLORREF GetTextColor(const CCharFormat *pCF);
			void	SetTextColor(COLORREF cr);

			void	SetCurPoint(const POINT &pt)	{_ptCur = pt;}
	const	POINT&	GetCurPoint() const				{return _ptCur;}

			void	SetClipRect(void);
            void    SetClipLeftRight(LONG xWidth);
			BOOL	RenderStartLine();
	const	RECT&	GetClipRect() const				{return _rc;}
			HDC		GetDC()	const					{return _hdc;}

			BOOL	StartRender(
						const RECT &rcView, 
						const RECT &rcRender,
						const LONG yHeightBitmap);

			void	EndRender();
			void	EndRenderLine(HDC hdcSave, LONG xAdj, LONG yAdj, LONG x);
			void	FillRectWithColor(RECT *prc, COLORREF cr);
			void 	NewLine (const CLine &li);
			BOOL	RenderLine(CLine &li);
			void	RenderOffScreenBitmap(HDC hdc, LONG yAdj, LONG xAdj);
			BOOL	RenderOutlineSymbol();
			void	RenderStrikeOut(LONG xStart, LONG yStart,
									LONG xWidth, LONG yThickness);
			void	RenderUnderline(LONG xStart, LONG yStart,
									LONG xWidth, LONG yThickness);
			void	SetFontAndColor(const CCharFormat *pCF);
			HDC		SetUpOffScreenDC(LONG& xAdj, LONG& yAdj);
			void	SetupUnderline(LONG UnderlineType);
	 CONVERTMODE	GetConvertMode();
	 BOOL			fFEFontOnNonFEWin9x()			{return _fFEFontOnNonFEWin9x;}
	 BOOL			UseXOR(COLORREF cr)						
	 				{
	 					return GetPed()->Get10Mode() || (_crBackground != ::GetSysColor(COLOR_WINDOW) && _crBackground == cr);
	 				}
};

/*
 * 	BottomOfRender (rcView, rcRender)
 *
 *	@mfunc
 *		Calculate maximum logical unit to render.
 *
 *	@rdesc
 *		Maximum pixel to render
 *
 *	@devnote
 *		This function exists to allow the renderer and dispml to be able
 *		to calculate the maximum pixel for rendering in exactly the same
 *		way.
 */
inline LONG BottomOfRender(const RECT& rcView, const RECT& rcRender)
{
	return min(rcView.bottom, rcRender.bottom);
}		

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_tomdoc.h ===
/*
 *	@doc TOM
 *
 *	@module _tomdoc.H -- CTxtDoc Class |
 *	
 *		This class implements the TOM ITextDocument interface
 *	
 *	@devnote
 *		This class depends on the internal RichEdit CTxtStory class, but is
 *		separate, that is, a CTxtDoc has a ptr to the internal CTxtStory,
 *		rather than CTxtDoc deriving from ITextDocument.  This choice
 *		was made so that edit control instances that don't use the
 *		ITextDocument interface don't have to have the extra vtable ptr.
 *
 *		When this class is destroyed, it doesn't destroy the internal
 *		CTxtStory object (CTxtEdit::_pdoc).  However the TOM client's
 *		perception is that the document is no longer in memory, so the internal
 *		document should be cleared.  It's the client's responsibility to save
 *		the document, if desired, before releasing it.
 *
 *	@future
 *		Generalize so that CTxtDoc can handle multiple CTxtStory's.
 */

#ifndef _tomdoc_H
#define _tomdoc_H

#include "_range.h"

class CTxtDoc : public ITextDocument
{
//@access Public methods
public:
	CTxtDoc(CTxtEdit *ped);

    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDispatch methods
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR ** rgszNames, UINT cNames,
							 LCID lcid, DISPID * rgdispid) ;
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
					  DISPPARAMS * pdispparams, VARIANT * pvarResult,
					  EXCEPINFO * pexcepinfo, UINT * puArgErr) ;

    // ITextDocument methods
	STDMETHODIMP GetName (BSTR * pName);		//@cmember Get document filename
	STDMETHODIMP GetCount (long *pCount);		//@cmember Get count of stories in document
	STDMETHODIMP _NewEnum(IEnumRange **ppenum);	//@cmember Get stories enumerator
	STDMETHODIMP Item (long Index, ITextRange **pprange);//@cmember Get <p Index>th story
	STDMETHODIMP Save (VARIANT * pVar);			//@cmember Save this document
	STDMETHODIMP BeginEditCollection ();		//@cmember Turn on undo grouping
	STDMETHODIMP EndEditCollection ();			//@cmember Turn off undo grouping

//@access Private data
private:
	CTxtEdit *		_ped;		//@cmember CTxtEdit this belongs to
	TCHAR *			_pName;		//@cmember Filename of document
	LONG			_cRefs;		//@cmember Reference count
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_tomfmt.h ===
/*
 *	@doc
 *
 *	@module _tomfmt.h -- CTxtFont and CTxtPara Classes |
 *	
 *		This class implements the TOM ITextFont and ITextPara interfaces
 *	
 *	Author: <nl>
 *		Murray Sargent
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _tomformat_H
#define _tomformat_H

#include "_range.h"

extern const BYTE g_rgREtoTOMAlign[];

// CTxtFormat: base class for CTxtFont and CTxtPara

class CTxtFormat
{
protected:
	CTxtFormat(CTxtRange *prg);
	~CTxtFormat();

	long		_cRefs;
	CTxtRange *	_prg;

	HRESULT	CanChange(long *pBool, BOOL fPara);
	HRESULT	GetParameter (long *pParm, DWORD dwMask, long Type, long *pValue);
	HRESULT	SetParameter (long *pParm, long Type, long Value);
	HRESULT	IsTrue		 (BOOL f, long *pB);
	BOOL	IsZombie()	 {return _prg && _prg->IsZombie();}
};


class CTxtFont : public ITextFont, CTxtFormat
{
	friend	CTxtRange;

	CCharFormat	_CF;
	DWORD		_dwMask;			// CHARFORMAT2 mask
	union
	{
	  DWORD _dwFlags;				// All together now
	  struct
	  {
		DWORD _fApplyLater : 1;		// Delay call to _prg->CharFormatSetter()
		DWORD _fCacheParms : 1;		// Update _CF now but not on GetXs
	  };
	};

public:
	CTxtFont(CTxtRange *prg);

	// IUnknown methods
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	// IDispatch methods
	STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
	STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo);
	STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR ** rgszNames, UINT cNames,
							 LCID lcid, DISPID * rgdispid) ;
	STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
					  DISPPARAMS * pdispparams, VARIANT * pvarResult,
					  EXCEPINFO * pexcepinfo, UINT * puArgErr) ;

	// ITextFont methods
	STDMETHODIMP GetDuplicate(ITextFont **ppFont);
	STDMETHODIMP SetDuplicate(ITextFont *pFont);
	STDMETHODIMP CanChange(long *pB);
	STDMETHODIMP IsEqual(ITextFont *pFont, long *pB);
	STDMETHODIMP Reset(long Value);
	STDMETHODIMP GetStyle(long *pValue);
	STDMETHODIMP SetStyle(long Value);
	STDMETHODIMP GetAllCaps(long *pValue);
	STDMETHODIMP SetAllCaps(long Value);
	STDMETHODIMP GetAnimation(long *pValue);
	STDMETHODIMP SetAnimation(long Value);
	STDMETHODIMP GetBackColor(long *pValue);
	STDMETHODIMP SetBackColor(long Value);
	STDMETHODIMP GetBold(long *pValue);
	STDMETHODIMP SetBold(long Value);
	STDMETHODIMP GetEmboss(long *pValue);
	STDMETHODIMP SetEmboss(long Value);
	STDMETHODIMP GetForeColor(long *pValue);
	STDMETHODIMP SetForeColor(long Value);
	STDMETHODIMP GetHidden(long *pValue);
	STDMETHODIMP SetHidden(long Value);
	STDMETHODIMP GetEngrave(long *pValue);
	STDMETHODIMP SetEngrave(long Value);
	STDMETHODIMP GetItalic(long *pValue);
	STDMETHODIMP SetItalic(long Value);
	STDMETHODIMP GetKerning(float *pValue);
	STDMETHODIMP SetKerning(float Value);
	STDMETHODIMP GetLanguageID(long *pValue);
	STDMETHODIMP SetLanguageID(long Value);
	STDMETHODIMP GetName(BSTR *pbstr);
	STDMETHODIMP SetName(BSTR bstr);
	STDMETHODIMP GetOutline(long *pValue);
	STDMETHODIMP SetOutline(long Value);
	STDMETHODIMP GetPosition(float *pValue);
	STDMETHODIMP SetPosition(float Value);
	STDMETHODIMP GetProtected(long *pValue);
	STDMETHODIMP SetProtected(long Value);
	STDMETHODIMP GetShadow(long *pValue);
	STDMETHODIMP SetShadow(long Value);
	STDMETHODIMP GetSize(float *pValue);
	STDMETHODIMP SetSize(float Value);
	STDMETHODIMP GetSmallCaps(long *pValue);
	STDMETHODIMP SetSmallCaps(long Value);
	STDMETHODIMP GetSpacing(float *pValue);
	STDMETHODIMP SetSpacing(float Value);
	STDMETHODIMP GetStrikeThrough(long *pValue);
	STDMETHODIMP SetStrikeThrough(long Value);
	STDMETHODIMP GetSubscript(long *pValue);
	STDMETHODIMP SetSubscript(long Value);
	STDMETHODIMP GetSuperscript(long *pValue);
	STDMETHODIMP SetSuperscript(long Value);
	STDMETHODIMP GetUnderline(long *pValue);
	STDMETHODIMP SetUnderline(long Value);
	STDMETHODIMP GetWeight(long *pValue);
	STDMETHODIMP SetWeight(long Value);

//@access Private ITextFont helper methods
private:
	HRESULT	GetParameter (long *pParm, DWORD dwMask, long Type, long *pValue);
	HRESULT	SetParameter (long *pParm, DWORD dwMask, long Type, long Value);
	HRESULT	EffectGetter (long *ptomBool, DWORD dwMask);
	HRESULT	EffectSetter (long Value, DWORD dwMask, DWORD dwEffect);
	HRESULT	FormatSetter (DWORD dwMask);
	HRESULT	UpdateFormat ();
};


class CTxtPara : public ITextPara, CTxtFormat
{
	friend	CTxtRange;

	CParaFormat	_PF;
	DWORD		_dwMask;			// PARAFORMAT2 mask
	union
	{
	  DWORD _dwFlags;				// All together now
	  struct
	  {
		DWORD _fApplyLater : 1;		// Delay call to _prg->ParaFormatSetter()
		DWORD _fCacheParms : 1;		// Update _PF now but not on GetXs
	  };
	};
	LONG		_rgxTabs[MAX_TAB_STOPS];// Place to store tabs till committed

public:
	CTxtPara(CTxtRange *prg);
	~CTxtPara();

	// IUnknown methods
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	// IDispatch methods
	STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
	STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo);
	STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR ** rgszNames, UINT cNames,
							 LCID lcid, DISPID * rgdispid) ;
	STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
					  DISPPARAMS * pdispparams, VARIANT * pvarResult,
					  EXCEPINFO * pexcepinfo, UINT * puArgErr) ;

	// ITextPara methods
	STDMETHODIMP GetDuplicate(ITextPara **ppPara);
	STDMETHODIMP SetDuplicate(ITextPara *pPara);
	STDMETHODIMP CanChange(long *pB);
	STDMETHODIMP IsEqual(ITextPara *pPara, long *pB);
	STDMETHODIMP Reset(long Value);
	STDMETHODIMP GetStyle(long *pValue);
	STDMETHODIMP SetStyle(long Value);

	STDMETHODIMP GetAlignment(long *pValue);
	STDMETHODIMP SetAlignment(long Value);
	STDMETHODIMP GetHyphenation(long *pValue);
	STDMETHODIMP SetHyphenation(long Value);
	STDMETHODIMP GetFirstLineIndent(float *pValue);
	STDMETHODIMP GetKeepTogether(long *pValue);
	STDMETHODIMP SetKeepTogether(long Value);
	STDMETHODIMP GetKeepWithNext(long *pValue);
	STDMETHODIMP SetKeepWithNext(long Value);
	STDMETHODIMP GetLeftIndent(float *pValue);
	STDMETHODIMP GetLineSpacing(float *pValue);
	STDMETHODIMP GetLineSpacingRule(long *pValue);
    STDMETHODIMP GetListAlignment(long * pValue);
    STDMETHODIMP SetListAlignment(long Value);
    STDMETHODIMP GetListLevelIndex(long * pValue);
    STDMETHODIMP SetListLevelIndex(long Value);
    STDMETHODIMP GetListStart(long * pValue);
    STDMETHODIMP SetListStart(long Value);
    STDMETHODIMP GetListTab(float * pValue);
    STDMETHODIMP SetListTab(float Value);
	STDMETHODIMP GetListType(long *pValue);
	STDMETHODIMP SetListType(long Value);
	STDMETHODIMP GetNoLineNumber(long *pValue);
	STDMETHODIMP SetNoLineNumber(long Value);
	STDMETHODIMP GetPageBreakBefore(long *pValue);
	STDMETHODIMP SetPageBreakBefore(long Value);
	STDMETHODIMP GetRightIndent(float *pValue);
	STDMETHODIMP SetRightIndent(float Value);
	STDMETHODIMP SetIndents(float StartIndent, float LeftIndent, float RightIndent);
	STDMETHODIMP SetLineSpacing(long LineSpacingRule, float LineSpacing);
	STDMETHODIMP GetSpaceAfter(float *pValue);
	STDMETHODIMP SetSpaceAfter(float Value);
	STDMETHODIMP GetSpaceBefore(float *pValue);
	STDMETHODIMP SetSpaceBefore(float Value);
	STDMETHODIMP GetWidowControl(long *pValue);
	STDMETHODIMP SetWidowControl(long Value);

	STDMETHODIMP GetTabCount(long *pValue);
	STDMETHODIMP AddTab(float tpPos, long tbAlign, long tbLeader);
	STDMETHODIMP ClearAllTabs();
	STDMETHODIMP DeleteTab(float tbPos);
	STDMETHODIMP GetTab(long iTab, float *ptbPos, long *ptbAlign, long *ptbLeader);

	HRESULT	FormatSetter (DWORD dwMask);

//@access Private ITextPara helper methods
private:
	HRESULT	GetParameter (long *pParm, DWORD dwMask, long Type, long *pValue);
	HRESULT	SetParameter (long *pParm, DWORD dwMask, long Type, long Value);
	HRESULT	EffectGetter (long * ptomBool, DWORD dwMask);
	HRESULT	EffectSetter (long Value, DWORD dwMask);
	HRESULT	UpdateFormat ();
	void	CheckTabsAddRef();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_select.h ===
/*
 *	SELECT.C
 *	
 *	Purpose:
 *		CTxtSelection class
 *	
 *	Owner:
 *		David R. Fulmer (original code)
 *		Christian Fortini
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#ifndef _SELECT_H
#define _SELECT_H

#include "_range.h"
#include "_m_undo.h"

// amount of time, in milisecs, before pending characters force a display update
#define ticksPendingUpdate 100	// 100 mili secs ~ display at least 10 characters per second.

class CDisplay;
class CLinePtr;

typedef enum
{
	smNone,
	smWord,
	smLine,
	smPara
} SELMODE;

enum
{
	CARET_NONE	= 0,
	CARET_CUSTOM = 1,
	CARET_BIDI = 2,
	CARET_THAI = 4,
	CARET_INDIC = 8
};

class CTxtSelection : public CTxtRange
{
#ifdef DEBUG
public:
	BOOL Invariant( void ) const; // Invariant checking.
#endif // DEBUG

//@access Protected Data
protected:
	CDisplay	*_pdp;			// display this selection belong to

	LONG	_cpSel;				// active end of displayed selection
	LONG	_cchSel;			// length of displayed selection

	LONG 	_xCaret;			// caret x on screen
	LONG 	_yCaret;			// caret y on screen 
	LONG 	_xCaretReally;		// real caret x (/r start of line) for vertical moves
	INT 	_yHeightCaret;		// caret height

	union
	{
	  DWORD _dwFlags;			// All together now
	  struct
	  {
	   DWORD _fCaretNotAtBOL:1;	// If at BOL, show caret at prev EOL
	   DWORD _fDeferUpdate	:1;	// Defer updating selection/caret on screen
	   DWORD _fInAutoWordSel:1;	// Current selection used auto word sel
	   DWORD _fShowCaret	:1;	// Show caret on screen
	   DWORD _fShowSelection:1;	// Show selection on screen

	   DWORD _fIsChar		:1;	// Currently adding a single char
	   DWORD _fObSelected	:1;	// An embedded object is selected
	   DWORD _fAutoSelectAborted : 1; // Whether auto word selection is aborted
	   DWORD _fCaretCreated	:1;	// Caret has been created
	   DWORD _fNoKeyboardUpdate :1; // Keyboard is not updated while in UpdateCaret()
	   DWORD _fEOP			:1;	// InsertEOP() has been called
	   DWORD _fHomeOrEnd	:1;	// Home or End key is being processed
	   DWORD _fAutoVScroll	:1;	// 1.0 specific: flag indicating autoscrolling should be applied
	   DWORD _fForceScrollCaret:1; // 1.0 specific: force craet to scroll
	  };
	};
	
	SELMODE	_SelMode;			// 0 none, 1 Word, 2 Line, 3 Paragraph
	DWORD	_ticksPending;		// Count of chars inserted without UpdateWindow
	LONG 	_cpAnchor;			// Initial anchor for auto word select
	LONG	_cpAnchorMin;		// Initial selection cpMin/cpMost for select
	LONG	_cpAnchorMost;		//  modes
	LONG 	_cpWordMin;			// Start of anchor word in word select mode
	LONG 	_cpWordMost;		// End   of anchor word in word select mode
	LONG	_cpWordPrev;		// Previous anchor word end

	HBITMAP	_hbmpCaret;			// Used for funky carets, like BiDi/ital carets
	DWORD	_dwCaretInfo;		// Current caret info used to avoid new create

//@access Public Methods
public:
	CTxtSelection(CDisplay * const pdp);
	~CTxtSelection();

	CRchTxtPtr&	operator =(const CRchTxtPtr& rtp);
	CTxtRange&  operator =(const CTxtRange &rg);

	// Set the display
	void	SetDisplay(CDisplay *pdp) { _pdp = pdp; }

	// Information for Selection Change notification

	void 	SetSelectionInfo(SELCHANGE *pselchg);

	// Replacement
	LONG	ReplaceRange(LONG cchNew, TCHAR const *pch, 
						IUndoBuilder *publdr, SELRR fCreateAE, LONG* pcchMove = NULL, DWORD dwFlags = 0);

	// Info for recalc line / UpdateView
	void	ClearCchPending()			{_ticksPending = 0;}
	LONG	GetScrSelMin() const		{return min(_cpSel, _cpSel - _cchSel);}
	LONG	GetScrSelMost() const		{return max(_cpSel, _cpSel - _cchSel);}
	BOOL	PuttingChar() const			{return _fIsChar;}

	// General updating
	virtual	BOOL 	Update(BOOL fScrollIntoView);

	BOOL	DeferUpdate()			
				{const BOOL fRet = _fDeferUpdate; _fDeferUpdate = TRUE; return fRet;}
	BOOL	DoDeferedUpdate(BOOL fScrollIntoView)		
				{_fDeferUpdate = FALSE; return Update(fScrollIntoView);}

	void SetAutoVScroll(BOOL bAuto) {_fAutoVScroll = bAuto;}
	BOOL GetAutoVScroll()	{return _fAutoVScroll;}

	void SetForceScrollCaret(BOOL bAuto) {_fForceScrollCaret = bAuto;}
	BOOL GetForceScrollCaret() {return _fForceScrollCaret;}

	// method used by selection anti-event for out-of-phase updates
	void	SetDelayedSelectionRange(LONG cp, LONG cch);
	void	StopGroupTyping();

	// Caret management
	BOOL	CaretNotAtBOL() const;
	void	CreateCaret();
	void	DeleteCaretBitmap(BOOL fReset);
	INT		GetCaretHt()				{return _yHeightCaret;}
	LONG	GetXCaretReally();
	LONG	GetXCaret()	const			{return _xCaret;}
	LONG	GetYCaret()	const			{return _yCaret;}
	BOOL 	IsCaretInView() const;
	BOOL 	IsCaretShown() const		{return _fShowCaret && !_cch;}
	LONG	LineLength(LONG *pcp) const;
	BOOL	SetXPosition(LONG xCaret, CLinePtr& rp);
	BOOL 	ShowCaret(BOOL fShow);
	BOOL 	UpdateCaret(BOOL fScrollIntoView, BOOL fForceCaret = FALSE);
	BOOL	GetCaretPoint(RECT &rcClient, POINT &pt, CLinePtr *prp, BOOL fBeforeCp);
	BOOL	MatchKeyboardToPara();

	// Selection management
	void	ClearPrevSel()				{ _cpSel = 0; _cchSel = 0; }
	BOOL	GetShowSelection()			{return _fShowSelection;}
	BOOL	ScrollWindowful(WPARAM wparam);
	void 	SetSelection(LONG cpFirst, LONG cpMost);
	BOOL	ShowSelection(BOOL fShow);
	void	Beep()						{GetPed()->Beep();}

	// Selection with the mouse
	void 	CancelModes	(BOOL fAutoWordSel = FALSE);
	void 	ExtendSelection(const POINT pt);
	BOOL	PointInSel	(const POINT pt, const RECT *prcClient,
						 HITTEST Hit = HT_Undefined) const;
	void 	SelectAll	();
	void 	SelectUnit	(const POINT pt, LONG Unit);
	void 	SelectWord	(const POINT pt);
 	void 	SetCaret	(const POINT pt, BOOL fUpdate = TRUE);

	// Keyboard movements
	BOOL 	Left	(BOOL fCtrl);
	BOOL	Right	(BOOL fCtrl);
	BOOL	Up		(BOOL fCtrl);
	BOOL	Down	(BOOL fCtrl);
	BOOL	Home	(BOOL fCtrl);
	BOOL	End		(BOOL fCtrl);
	BOOL	PageUp	(BOOL fCtrl);
	BOOL	PageDown(BOOL fCtrl);

	// Editing
	BOOL	BypassHiddenText(LONG iDir);
	BOOL	PutChar	 (TCHAR ch, DWORD dwFlags, IUndoBuilder *publdr);
	void	SetIsChar(BOOL);
	void	CheckUpdateWindow();
	void	CheckTableSelection();
	BOOL	InsertEOP(IUndoBuilder *publdr, WCHAR ch = 0);
	
	// Keyboard switching support.
	void	CheckChangeKeyboardLayout();
	bool	CheckChangeFont (const HKL hkl, UINT cp, LONG iSelFormat = 0, DWORD dwCharFlag = 0);
	UINT	CheckSynchCharSet(DWORD dwCharFlag = 0);

	// from CTxtRange
	BOOL	Delete  (DWORD flags, IUndoBuilder *publdr);
	BOOL	Backspace(BOOL fCtrl, IUndoBuilder *publdr);

	const CParaFormat* GetPF();

	// note that the parameters are different than CTxtRange::SetCharFormat
	// intentionally; the selection has extra options available to it.
	HRESULT	SetCharFormat(const CCharFormat *pCF, DWORD flags,  
									IUndoBuilder *publdr, DWORD dwMask, DWORD dwMask2);
	HRESULT	SetParaFormat(const CParaFormat *pPF,
									IUndoBuilder *publdr, DWORD dwMask);

	// Auto word selection helper
	void	InitClickForAutWordSel(const POINT pt);

	// dual font helper for CTxtSelection::PutChar
	void	SetupDualFont();

	// IUnknown and IDispatch methods handled by CTxtRange methods

	// ITextRange methods can use ITextRange methods directly, since
	// they either don't modify the display of the selection (get methods), or
	// they have appropriate virtual character to call on selection functions.

	// ITextSelection methods
	STDMETHODIMP GetFlags (long *pFlags) ;
	STDMETHODIMP SetFlags (long Flags) ;
	STDMETHODIMP GetType  (long *pType) ;
	STDMETHODIMP MoveLeft (long pUnit, long Count, long Extend,
									   long *pDelta) ;
	STDMETHODIMP MoveRight(long pUnit, long Count, long Extend,
									   long *pDelta) ;
	STDMETHODIMP MoveUp	  (long pUnit, long Count, long Extend,
									   long *pDelta) ;
	STDMETHODIMP MoveDown (long pUnit, long Count, long Extend,
									   long *pDelta) ;
	STDMETHODIMP HomeKey  (long pUnit, long Extend, long *pDelta) ;
	STDMETHODIMP EndKey   (long pUnit, long Extend, long *pDelta) ;
	STDMETHODIMP TypeText (BSTR bstr) ;
	STDMETHODIMP SetPoint (long x, long y, long Extend) ;

//@access Protected Methods
protected:

	// Protected update method
	void	UpdateSelection();

	// Protected caret management method
	INT 	GetCaretHeight(INT *pyDescent) const;

	HRESULT	GeoMover (long Unit, long Count, long Extend,
					  long *pDelta, LONG iDir);
	HRESULT Homer	 (long Unit, long Extend, long *pDelta,
					  BOOL (CTxtSelection::*pfn)(BOOL));

	// Auto Select Word Helpers
	void	UpdateForAutoWord();
	void	AutoSelGoBackWord(
				LONG *pcpToUpdate,
				int iDirToPrevWord,
				int	iDirToNextWord);

	void	ExtendToWordBreak(BOOL fAfterEOP, INT iDir);
	BOOL	CheckPlainTextFinalEOP();

};

/*
 *	CSelPhaseAdjuster
 *
 *	@class	This class is put on the stack and used to temporarily hold
 *			selection cp values until the control is "stable" (and thus,
 *			we can safely set the selection
 */
class CSelPhaseAdjuster : public IReEntrantComponent
{
//@access	Public methods
public:

	// IReEntrantComponent methods

	virtual	void OnEnterContext()	{;}		//@cmember re-entered notify

	CSelPhaseAdjuster(CTxtEdit *ped);		//@cmember constructor
	~CSelPhaseAdjuster();					//@cmember destructor

	void CacheRange(LONG cp, LONG cch);		//@cmember stores the sel range

//@access	Private data
private:
	CTxtEdit *		_ped;					//@cmember edit context
	LONG			_cp;					//@cmember sel active end to set
	LONG			_cch;					//@cmember sel extension
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_text.h ===
/*
 *	@doc 	INTERNAL
 *
 *	@module _TEXT.H	-- Declaration for a CTxtRun pointer |
 *	
 *	CTxtRun pointers point at the plain text runs (CTxtArray) of the
 *	backing store and derive from CRunPtrBase via the CRunPtr template.
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _TEXT_H
#define _TEXT_H

#include "_runptr.h"
#include "_doc.h"
#include "textserv.h"
#include "_m_undo.h"

class CRchTxtPtr;
class CTxtEdit;
class CTxtIStream;

/*
 *	CTxtPtr
 *
 *	@class
 *		provides access to the array of characters in the backing store
 *		(i.e. <c CTxtArray>)
 *
 *	@base 	public | CRunPtr<lt>CTxtArray<gt>
 *
 *	@devnote
 *		The state transitions for this object are the same as those for
 *		<c CRunPtrBase>.  <md CTxtPtr::_cp> simply caches the current
 *		cp (even though it can be derived from _iRun and _ich).  _cp is
 *		used frequently enough (and computing may be expensive) that
 *		caching the value is worthwhile.
 *
 *		CTxtPtr's *may* be put on the stack, but do so with extreme
 *		caution.  These objects do *not* float; if a change is made to
 *		the backing store while a CTxtPtr is active, it will be out
 *		of sync and may lead to a crash.  If such a situation may
 *		exist, use a <c CTxtRange> instead (as these float and keep
 *		their internal text && format run pointers up-to-date).
 *
 *		Otherwise, a CTxtPtr is a useful, very lightweight plain
 *		text scanner.
 */

// FindEOP() result flags.  Low byte used for cchEOP
#define FEOP_CELL	256
#define FEOP_EOP	512

// FindWhiteSpace input flags
#define FWS_SKIP		1
#define FWS_BOUNDTOPARA	2
#define FWS_ADVANCECP	256

class CTxtPtr : public CRunPtr<CTxtBlk>
{
	// Only CRchTxtPtr is allowed to call private methods like replace range.
	friend class CRchTxtPtr;

//@access Public Methods
public:
#ifdef DEBUG
	BOOL Invariant( void ) const;		//@cmember	Invariant checking
	void MoveGapToEndOfBlock () const;
#endif	// DEBUG

	CTxtPtr(CTxtEdit *ped, LONG cp);	//@cmember	Constructor
	CTxtPtr(const CTxtPtr &tp);			//@cmember	Copy Constructor

	LONG	GetText(LONG cch, TCHAR *pch);	//@cmember 	Fetch <p cch> chars

									//@cmember Fetch <p cch> chars with usp xlat	
	LONG	GetTextForUsp(LONG cch, TCHAR *pch, BOOL fNeutralOverride);

									//@cmember Fetch <p cch> chars with xlat
	LONG	GetPlainText(LONG cch, TCHAR *pchBuff,
					LONG cpMost, BOOL fTextize, BOOL fAdjustCRLF = TRUE);
	TCHAR	NextCharCount(LONG& cch);	//@cmember Advance, GetChar, decrement
	TCHAR	NextChar();				//@cmember Advance to & return next char
	TCHAR	PrevChar();				//@cmember Backup to & return previous char
	TCHAR	GetChar();				//@cmember Fetch char at current cp
	TCHAR	GetPrevChar();			//@cmember Fetch char at previous cp
	LONG	GetTextLength() const;	//@cmember Get total cch for this document
	const TCHAR* GetPch(LONG& cchValid) const;//@cmember	Get ptr to block of chars

							//@cmember	Get ptr to a reverse block of chars
	const TCHAR* GetPchReverse(LONG& cchValidReverse, LONG* pcchValid = NULL);

	// The text array has its own versions of these methods (overuling
	// those in runptr base so that <md CTxtPtr::_cp> can be correctly
	// maintained.

	LONG	BindToCp(LONG cp);	//@cmember	Rebinds text pointer to cp
	LONG 	SetCp(LONG cp);		//@cmember	Sets the cp for the run ptr
	LONG	GetCp() const 		//@cmember	Gets the current cp
	{
		// NB! Don't do invariant checking here so floating
		// range mechanism can work OK
		return _cp;
	};
	void	Zombie();			//@cmember	Turn this tp into a zombie

	LONG	AdvanceCp(LONG cch);//@cmember	Advance cp by cch chars
	
	// Advance/backup/adjust safe over CRLF and UTF-16 word pairs
	LONG	AdjustCpCRLF();		//@cmember	Backup to start of multichar
	LONG	AdvanceCpCRLF(BOOL fMulticharAdvance = TRUE);	//@cmember	Advance over multichar
							 	//@cmember	Backup over multichar
	LONG	BackupCpCRLF(BOOL fMulticharBackup = TRUE);
	BOOL	IsAfterEOP();		//@cmember	Does current cp follow an EOP?
	BOOL	IsAtEOP();			//@cmember	Is current cp at an EOP marker?
	BOOL	IsAtBOSentence();	//@cmember	At beginning of a sentence?
	BOOL	IsAtBOWord();		//@cmember	At beginning of word?
	LONG	MoveWhile(LONG cchRun, WCHAR chFirst, WCHAR chLast, BOOL fInRange);
	
	// Search
								//@cmember	Find indicated text
	LONG	FindText(LONG cpMost, DWORD dwFlags, TCHAR const *pch, LONG cch);
								//@cmember 	Find next EOP
	LONG	FindEOP(LONG cchMax, LONG *pResults = NULL);
								//@cmember	Find next exact	match to <p pch>
	LONG	FindExact(LONG cchMax, TCHAR *pch);
	LONG	FindBOSentence(LONG cch);	//@cmember	Find beginning of sentence
	LONG	FindOrSkipWhiteSpaces(LONG cchMax, DWORD dwFlags = 0, DWORD* pdwResult = NULL);
	LONG	FindWhiteSpaceBound(LONG cchMin, LONG& cpStart, LONG& cpEnd, DWORD dwFlags = 0);

	// Word break support
	LONG	FindWordBreak(INT action, LONG cpMost = -1);//@cmember	Find next word break
	LONG	TranslateRange(LONG cch, UINT CodePage,
						   BOOL fSymbolCharSet, IUndoBuilder *publdr);

//@access	Private methods and data
private:
							//@cmember	Replace <p cchOld> characters with
							// <p cchNew> characters from <p pch>
	LONG	ReplaceRange(LONG cchOld, LONG cchNew, TCHAR const *pch,
									IUndoBuilder *publdr, IAntiEvent *paeCF,
									IAntiEvent *paePF);

							//@cmember	undo helper
	void 	HandleReplaceRangeUndo(LONG cchOld, LONG cchNew,
						IUndoBuilder *publdr, IAntiEvent *paeCF,
						IAntiEvent *paePF);

									//@cmember	Insert a range of text helper
									// for ReplaceRange					
	LONG 	InsertRange(LONG cch, TCHAR const *pch);
	void 	DeleteRange(LONG cch);	//@cmember  Delete range of text helper
									// for ReplaceRange
		// support class for FindText
	class CTxtFinder
	{
	public:
		BOOL FindText(const CTxtPtr &tp, LONG cpMost, DWORD dwFlags,
					  const TCHAR *pchToFind, LONG cchToFind,
					  LONG &cpFirst, LONG &cpLast);
		//@cmember Same functionality as CTxtPtr::FindText wrapper
		
	private:
		inline BOOL CharComp(TCHAR ch1, TCHAR ch2) const;
		inline BOOL CharCompIgnoreCase(TCHAR ch1, TCHAR ch2) const;
		LONG FindChar(TCHAR ch, CTxtIStream &tistr);	
		//@cmember Advances cp to char matching ch from CTxtIStream
		LONG MatchString(const TCHAR *pchToFind, LONG cchToFind, CTxtIStream &tistr);
		//@cmember Advances cp if chars in pchToFind match next chars from CTxtIStream
		LONG MatchStringBiDi(const TCHAR *pchToFind, LONG cchToFind, CTxtIStream &tistr);
		//@cmember Like MatchString, but with checks for special Arabic/Hebrew chars
		
		LONG _cchToSearch;		//@cmember # of chars to search for current FindText call
		BOOL _fSearchForward;
		BOOL _fIgnoreCase;
		BOOL _fMatchAlefhamza;	//@cmember Flags derived from dwFlags from FindText for
		BOOL _fMatchKashida;	//	Arabic/Hebrew searches
		BOOL _fMatchDiac;
		int _iDirection;		//@cmember +/-1 to step through pchToFind
	};

	LONG		_cp;		//@cmember	Character position in text stream
#ifdef DEBUG
	const WCHAR *_pchCp;	// Points to string at cp for ease in debugging
#endif

public:
	CTxtEdit *	_ped;		//@cmember	Ptr to text edit class needed for
							//  things like word break proc and used a lot
							//  by derived classes
};

/*
 *	CTxtIStream
 *
 *	@class
 *		Refinement of the CTxtPtr class which implements an istream-like interface.
 *		Given a CTxtPtr and a direction, a CTxtFinder object returns a char
 *		for every call to GetChar.  No putzing around with the buffer gap is
 *		necessary, and expensive calls to AdvanceCp and GetPch are kept to an
 *		absolute minimum.
 *		
 *	@base 	private | CTxtPtr
 *
 *	@devnote
 *		At present, this class is used in the implementation of the CTxtFinder
 *		class.  Finds require fast scanning of the sequence of characters leading
 *		in either direction from the cp.  Calls to AdvanceCp and GetPch slow down
 *		such scanning significantly, so this class implements a unidirectional
 *		istream-like scanner which avoids unnecessary calls to these expensive
 *		CTxtPtr methods.
 */
class CTxtIStream : private CTxtPtr
{
public:
	enum { DIR_FWD, DIR_REV };
	typedef TCHAR (CTxtIStream::*PFNGETCHAR)();

							//@cmember Creates istr to read in iDir
	CTxtIStream(const CTxtPtr &tp, int iDir);

	inline TCHAR GetChar() 	//@cmember Returns next char in stream dir
		{ return (this->*_pfnGetChar)(); }

private:
	TCHAR GetNextChar();	//@cmember Returns next char in fwd dir	
	TCHAR GetPrevChar();	//@cmember Returns next char in rev dir

 	void FillPchFwd();		//@cmember Refreshes _pch and _cch with chars in fwd dir
 	void FillPchRev();		//@cmember Refreshes _pch and _cch with chars in rev dir

	PFNGETCHAR _pfnGetChar;	//@cmember Func ptr to routine which get next char in iDir
	LONG _cch;				//@cmember Count of valid chars in _pch in iDir
	const TCHAR *_pch;		//@cmember Next _cch chars in iDir
};

// =======================   Misc. routines  ====================================================

void	TxCopyText(TCHAR const *pchSrc, TCHAR *pchDst, LONG cch);
//LONG	TxFindEOP(const TCHAR *pchBuff, LONG cch);
INT		CALLBACK TxWordBreakProc(TCHAR const *pch, INT ich, INT cb, INT action);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_undoid.h ===
/*
 *	_undoid.h
 *
 *	Purpose:
 *		Undo ID defintions.  These ID's are used to lookup string names
 *		in our resources for the various undo operations
 *
 *	Author:
 *		AlexGo  4/13/95
 */

#ifndef __UNDOID_H__
#define __UNDOID_H__

//
//	typing operations
//

#define UID_TYPING			1
#define	UID_REPLACESEL		2
#define UID_DELETE			3

//
//	data transfer operations
//

#define	UID_DRAGDROP		4
#define UID_CUT				5
#define UID_PASTE			6
#define UID_LOAD			7

#endif // __UNDOID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\afxres.h ===
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_urlsup.h ===
/*
 *	@doc INTERNAL
 *
 *	@module	_URLSUP.H	URL detection support |
 *
 *	Author:	alexgo (4/1/96)
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#ifndef _URLSUP_H_
#define _URLSUP_H_

#include "_dfreeze.h"
#include "_notmgr.h"
#include "_range.h"

class CTxtEdit;
class IUndoBuilder;

// Maximum URL length. It's a good thing to have a protection like
// this to make sure we don't select the whole document; and we really
// need this for space-containing URLs
#define URL_MAX_SIZE			512
#define URL_MAX_SCOPE			512


// for MoveByDelimiter
#define	URL_EATWHITESPACE		32
#define URL_STOPATWHITESPACE	1
#define	URL_EATNONWHITESPACE	0
#define URL_STOPATNONWHITESPACE	2
#define	URL_EATPUNCT			0
#define URL_STOPATPUNCT			4
#define	URL_EATNONPUNCT			0
#define URL_STOPATNONPUNCT		8
#define URL_STOPATCHAR			16

// need this one to initialize a scan with something invalid
#define URL_INVALID_DELIMITER	TEXT(' ')

#define LEFTANGLEBRACKET	TEXT('<')
#define RIGHTANGLEBRACKET	TEXT('>')

/*
 *	CDetectURL
 *
 *	@class	This class will	watched edit changes and automatically
 *			change detected URL's into links (see CFE_LINK && EN_LINK)
 */
class CDetectURL : public ITxNotify
{
//@access	Public Methods
public:
	// constructor/destructor

	CDetectURL(CTxtEdit *ped);				//@cmember constructor
	~CDetectURL();							//@cmember destructor

	// ITxNotify methods
											//@cmember called before a change
	virtual void    OnPreReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
                       LONG cpFormatMin, LONG cpFormatMax);
											//@cmember called after a change
	virtual void    OnPostReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
                       LONG cpFormatMin, LONG cpFormatMax);
	virtual void	Zombie();				//@cmember turn into a zombie

	// useful methods

	void	ScanAndUpdate(IUndoBuilder *publdr);//@cmember scan the changed 
											// area and update the link status

//@access	Private Methods and Data
private:

	// worker routines for ScanAndUpdate
	BOOL GetScanRegion(LONG& rcpStart, LONG& rcpEnd);//@cmember get the region
											// to check and clear the accumltr

	void ExpandToURL(CTxtRange& rg, LONG &cchAdvance);		
											//@cmember expand the range to
											// the next URL candidate
	BOOL IsURL(CTxtRange& rg);				//@cmember returns TRUE if the text
											// is a URL.
	void SetURLEffects(CTxtRange& rg, IUndoBuilder *publdr);	//@cmember Set
											// the desired URL effects

											//@cmember removes URL effects if
											// appropriate
	void CheckAndCleanBogusURL(CTxtRange& rg, BOOL &fDidClean, IUndoBuilder *publdr);

											//@cmember scan along for white
											// space / not whitespace,
											// punctuation / non punctuation
											// and remember what stopped the scan
	LONG MoveByDelimiters(const CTxtPtr& tp, LONG iDir, DWORD grfDelimiters, 
							WCHAR *pchStopChar);

	LONG GetAngleBracket(CTxtPtr &tp, LONG cch = 0);
	WCHAR BraceMatch(WCHAR chEnclosing);
			
	CTxtEdit *				_ped;			//@cmember the edit context
	CAccumDisplayChanges 	_adc;			//@cmember change accumulator

	// FUTURE (alexgo): we may want to add more options to detection,
	// such as the charformat to use on detection, etc.
};

#endif // _URLSUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_util.h ===
/*
 *	_UTIL.H
 *
 *	Purpose:
 *		declarations for various useful utility functions
 *
 *	Author:
 *		alexgo (4/25/95)
 */

#ifndef __UTIL_H__
#define __UTIL_H__

HGLOBAL DuplicateHGlobal( HGLOBAL hglobal );
INT CountMatchingBits(const DWORD *a, const DWORD *b, INT total);
HRESULT ObjectReadSiteFlags(REOBJECT * preobj);


//Default values for drag scrolling
//(that aren't already defined by windows).
#define DEFSCROLLMAXVEL 100	//Cursor velocity above which we will not
							//drag scroll (units=.01 in/sec).
#define DEFSCROLLVAMOUNT 50	//Vert. scroll amount per interval (units=.01 in)
#define DEFSCROLLHAMOUNT 50 //Horz. scroll amount per interval (units=.01 in)

//Stuff from OLESTD samples

//Ole clipboard format defines.
#define CF_EMBEDSOURCE      "Embed Source"
#define CF_EMBEDDEDOBJECT   "Embedded Object"
#define CF_LINKSOURCE       "Link Source"
#define CF_OBJECTDESCRIPTOR "Object Descriptor"
#define CF_FILENAME         "FileName"
#define CF_OWNERLINK        "OwnerLink"

HRESULT OleStdSwitchDisplayAspect(
			LPOLEOBJECT			lpOleObj,
			LPDWORD				lpdwCurAspect,
			DWORD				dwNewAspect,
			HGLOBAL				hMetaPict,
			BOOL				fDeleteOldAspect,
			BOOL				fSetupViewAdvise,
			LPADVISESINK		lpAdviseSink,
			BOOL FAR *			lpfMustUpdate);
LPUNKNOWN OleStdQueryInterface(
			LPUNKNOWN			lpUnk,
			REFIID				riid);

void OleUIDrawShading(LPRECT lpRect, HDC hdc);

VOID OleSaveSiteFlags(LPSTORAGE pstg, DWORD dwFlags, DWORD dwUser, DWORD dvAspect);

INT	AppendString( BYTE **, BYTE *, int *, int * );

/****************************************************************************/
/*		     Stabilization classes				    						*/
/*        These are used to stabilize objects during re-entrant calls       */
/****************************************************************************/

//+-------------------------------------------------------------------------
//
//  Class: 	CSafeRefCount
//
//  Purpose: 	A concrete class for objects like the default handler to
//				inherit from.  CSafeRefCount will keep track of reference
//				counts, nesting counts, and zombie states, allowing objects
//				to easily manage the liveness of their memory images.
//
//  Interface:	
//
//  History:    dd-mmm-yy Author    Comment
//   			01-Aug-94 alexgo    author
//
//--------------------------------------------------------------------------

class CSafeRefCount
{
public:
	ULONG	SafeAddRef();
	ULONG	SafeRelease();
	ULONG	IncrementNestCount();
	ULONG	DecrementNestCount();
	BOOL	IsZombie();
   
			CSafeRefCount();
	virtual ~CSafeRefCount();

protected:
    VOID    Zombie();

private:

	ULONG	m_cRefs;
	ULONG	m_cNest;

	ULONG	m_fInDelete		:1;
	ULONG   m_fForceZombie	:1;
};

//+-------------------------------------------------------------------------
//
//  Class:	CStabilize
//
//  Purpose: 	An instance of this class should be allocated on the
//				stack of every object method that makes an outgoing call.
//				The contstructor takes a pointer to the object's base
//				CSafeRefCount class.
//
//  Interface:
//
//  History:    dd-mmm-yy Author    Comment
// 				01-Aug-94 alexgo    author
//
//  Notes:	The constructor will increment the nest count of the
//			object while the destructor will decrement it.
//
//--------------------------------------------------------------------------

class CStabilize
{
public:
	inline CStabilize( CSafeRefCount *pObjSafeRefCount );
	inline ~CStabilize();

private:
	CSafeRefCount *	m_pObjSafeRefCount;
};

inline CStabilize::CStabilize( CSafeRefCount *pObjSafeRefCount )
{
	pObjSafeRefCount->IncrementNestCount();
	m_pObjSafeRefCount = pObjSafeRefCount;
}

inline CStabilize::~CStabilize()
{
	m_pObjSafeRefCount->DecrementNestCount();
}

/*
 *	SafeReleaseAndNULL(IUnknown **ppUnk)
 *
 *	Purpose:
 *      Helper for getting stable pointers during destruction or other times
 *
 *	Notes: 
 *      Not thread safe, must provide higher level synchronization.
 */

inline void SafeReleaseAndNULL(IUnknown **ppUnk)
{
    if (*ppUnk != NULL)
    {
    IUnknown *pUnkSave = *ppUnk;
    *ppUnk = NULL;
    pUnkSave->Release();
    }
}

BOOL FIsIconMetafilePict(HGLOBAL hmfp);
HANDLE OleStdGetMetafilePictFromOleObject(
        LPOLEOBJECT         lpOleObj,
        DWORD               dwDrawAspect,
        LPSIZEL             lpSizelHim,
        DVTARGETDEVICE FAR* ptd);
HGLOBAL OleGetObjectDescriptorDataFromOleObject(
        LPOLEOBJECT pObj,
        DWORD       dwAspect,
        POINTL      ptl,
        LPSIZEL     pszl);

// Default size for stack buffer
#define MAX_STACK_BUF 256

/*
 *	CTempBuf
 *	
 * 	@class	A simple temporary buffer allocator class that will allocate
 *			buffers on the stack up to MAX_STACK_BUF and then use the 
 *			heap thereafter. 
 */
class CTempBuf
{
//@access Public Data
public:
							//@cmember Constructor
							CTempBuf();

							//@cmember Destructor
							~CTempBuf();

							//@cmember Get buffer of size cb
	void *					GetBuf(LONG cb);

//@access Private Data
private:

							//@cmember Sets up initial state of object
	void					Init();

							//@cmember Frees any buffers allocated from heap
	void					FreeBuf();

							//@cmember Buffer on stack to use
	char					_chBuf[MAX_STACK_BUF];

							//@cmember Pointer to buffer to use
	void *					_pv;

							//@cmember Size of currently allocated buffer
	LONG					_cb;
};

/*
 *	CTempBuf::CTempBuf
 *
 *	@mfunc	Initialize object
 *
 */
inline CTempBuf::CTempBuf()
{
	Init();
}

/*
 *	CTempBuf::~CTempBuf
 *
 *	@mfunc	Free any resources attached to this object
 *
 */
inline CTempBuf::~CTempBuf()
{
	FreeBuf();
}

/*
 *	CTempCharBuf
 *	
 * 	@class	A wrapper for the temporary buffer allocater that returns a buffer of
 *			char's.
 *
 *	@base	private | CTempBuf
 */
class CTempWcharBuf : private CTempBuf
{
//@access Public Data
public:

							//@cmember Get buffer of size cch wide characters
	WCHAR *					GetBuf(LONG cch);
};


/*
 *	CTempBuf::GetBuf
 *
 *	@mfunc	Get a buffer of the requested size
 *
 *	@rdesc	Pointer to buffer or NULL if one could not be allocated
 *
 */
inline WCHAR *CTempWcharBuf::GetBuf(
	LONG cch)				//@parm size of buffer needed in *characters*
{
	return (WCHAR *) CTempBuf::GetBuf(cch * sizeof(WCHAR));
}


/*
 *	CTempCharBuf
 *	
 * 	@class	A wrapper for the temporary buffer allocater that returns a buffer of
 *			char's.
 *
 *	@base	private | CTempBuf
 */
class CTempCharBuf : private CTempBuf
{
//@access Public Data
public:

							//@cmember Get buffer of size cch characters
	char *					GetBuf(LONG cch);
};


/*
 *	CTempBuf::GetBuf
 *
 *	@mfunc	Get a buffer of the requested size
 *
 *	@rdesc	Pointer to buffer or NULL if one could not be allocated
 *
 */
inline char *CTempCharBuf::GetBuf(LONG cch)
{
	return (char *) CTempBuf::GetBuf(cch * sizeof(TCHAR));
}


// Author revision color table
extern const COLORREF rgcrRevisions[]; 

// Only fixed number of revision color so don't let the table overflow.
#define REVMASK	7



#endif // !__UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_w32sys.h ===
/*
 *	_w32sys.h
 *	
 *	Purpose:
 *		Isolate various Win 32 system dependencies.
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#ifndef _W32SYS_H

#define _W32SYS_H

#if defined(PEGASUS)

#if !defined(WINNT)
#include "memory.h"								// for memmove
#endif

struct IMESTYLE;
struct IMECOLORSTY;
struct CIMEShare;

#define NOACCESSIBILITY							// No Accessibility support on Win CE
#define NOMAGELLAN								// No Magellan on Win CE
#define NODROPFILES								// No drop files support on Win CE
#define NOMETAFILES								// No metafiles on Win CE
#define NOPEDDUMP								// No support for ped debug dump on CE
#define NOFONTSUBINFO							// Avoid reading fontsubinfo profile on CE
#define CONVERT2BPP
#define NODUMPFORMATRUNS
#define NOMLKEYBOARD

#define dxCaret		2							// caret width
#define FONTCACHESIZE 8
#define CCSHASHSEARCHSIZE	15
#define DEFAULT_UNDO_SIZE 20
#define NUMPASTECHARSWAITCURSOR 1024

#else //!PEGASUS

#define dxCaret		1							// caret width
#define FONTCACHESIZE 24
#define CCSHASHSEARCHSIZE	31
#define DEFAULT_UNDO_SIZE 100
#define NUMPASTECHARSWAITCURSOR (1024*32)

#define OBSOLETE	// need this to get old IMEShare defines
#include "imeshare.h"

#endif	// defined(PEGASUS)

#ifndef NOLINESERVICES
#define LINESERVICES
#endif

#define	RSHIFT	1
#define	LSHIFT	2
#define	RCTRL	0x10
#define	LCTRL	0x20
#define	RALT	0x40
#define	LALT	0x80

#define SHIFT	(RSHIFT + LSHIFT)
#define ALT		(RALT + LALT)
#define CTRL	(RCTRL + LCTRL)

#define	HOTEURO			0x1000
#define ALT0			0x2000
#define ALTNUMPAD		0x4000
#define LETAFTERSHIFT	0x8000

// special virtual keys copied from Japan MSVC ime.h
#define VK_KANA         0x15
#define VK_KANJI        0x19

// Initialization flags that can be used in system.ini for testing purposes
#define SYSINI_USELS		0x1
#define SYSINI_BIDI			0x2
#define SYSINI_USEAIMM		0x4
#define SYSINI_DEBUGFONT	0x8
#define SYSINI_DEBUGGCF125X	0x10

/*
 *	GetCaretDelta ()
 *	
 *	@func 	Get size of caret to add to current caret position to get the
 *	maximum extent needed to display caret.
 *
 *	@rdesc	Size of caret over 1 pixel
 *
 *	@devnote	This exists solely to abstract this calculation
 *	to handle a variable size caret.
 */
inline int GetCaretDelta()
{
	return dxCaret - 1;
}


// Used in rtfread.cpp to keep track of lossy rtf.
#ifdef PWORD_CONVERTER_V2
#define REPORT_LOSSAGE
#endif


// Defines for some Codepages
#define CP_JAPAN			932
#define CP_KOREAN			949
#define CP_CHINESE_TRAD		950
#define CP_CHINESE_SIM		936
#define CP_HEBREW			1255
#define CP_ARABIC			1256
#define CP_THAI				874
#define CP_VIETNAMESE		1258

// Indic codepages from NT50
#define CP_DEVANAGARI		57002
#define CP_BENGALI			57003
#define CP_TAMIL			57004
#define CP_TELUGU			57005
#define CP_ASSAMESE			57006
#define CP_ORIYA			57007
#define CP_KANNADA			57008
#define CP_MALAYALAM		57009
#define CP_GUJARATI			57010
#define CP_PUNJABI			57011

// Ad hoc codepages to keep rgCpgCharSet unique
#define CP_GEORGIAN			58000
#define CP_ARMENIAN			58001

// Newly introduced Indic language ID
#if(WINVER < 0x500)
#define	LANG_HINDI			0x39
#define	LANG_KONKANI		0x57
#define	LANG_NEPALI			0x61
#define	LANG_BENGALI		0x45
#define	LANG_PUNJABI		0x46
#define	LANG_GUJARATHI		0x47
#define	LANG_ORIYA			0x48
#define	LANG_TAMIL			0x49
#define	LANG_TELUGU			0x4a
#define	LANG_KANNADA		0x4b
#define	LANG_MALAYALAM		0x4c
#define	LANG_ASSAMESE		0x4d
#define	LANG_MARATHI		0x4e
#define	LANG_SANSKRIT		0x4f
#endif


// Index returned by CharSetIndexFromChar()
#define	FE_FLAG			0x10000
#define	MULTIPLE_FLAG	0x80000000			// Sign bit
#define FE_INDEX		FE_FLAG + MULTIPLE_FLAG

#define ANSI_INDEX		0
#define ARABIC_INDEX	7
#define GREEK_INDEX		14
#define HAN_INDEX		FE_INDEX + 1
#define HANGUL_INDEX	FE_FLAG + 11
#define HEBREW_INDEX	6
#define RUSSIAN_INDEX	9
#define SHIFTJIS_INDEX	FE_FLAG + 8
#define VIET_INDEX		17
#define THAI_INDEX		18

#define DEVANAGARI_INDEX	19
#define TAMIL_INDEX			20
#define GEORGIAN_INDEX		21
#define ARMENIAN_INDEX		22
#define INDIC_FIRSTINDEX	DEVANAGARI_INDEX
#define INDIC_LASTINDEX		ARMENIAN_INDEX

#define UNKNOWN_INDEX		MULTIPLE_FLAG + 1

#define	PC437_CHARSET		254
#define DEVANAGARI_CHARSET	127
#define TAMIL_CHARSET		126
#define GEORGIAN_CHARSET	125
#define ARMENIAN_CHARSET	124
#define ADHOC_CHARSET		120

// controls the size of two charset tables.
#define NCHARSETS		 24

#define IsSymbolOrOEM(x)	(x == SYMBOL_CHARSET || x == OEM_CHARSET)

enum CC
{
	CC_ARABIC,
	CC_HEBREW,
	CC_RTL,
	CC_LTR,
	CC_EOP,
	CC_ASCIIDIGIT,
	CC_NEUTRAL
};

#define IsRTL(cc)		(cc <= CC_RTL)

const SHORT sLanguageEnglishUS = 0x0409;
const SHORT sLanguageMask	 = 	0x03ff;
const SHORT sLanguageArabic	 = 	0x0401;
const SHORT sLanguageHebrew	 = 	0x040d;
// FUTURE: currently this const == sLanguageEnglishUS
//			for no reason except that it was this way
//			in RE1.0 BiDi. Consider changing, or sticking
//			the real language in, and changing the logic
//			of handling wLang a bit.
const SHORT sLanguageNonBiDi =	0x0409;


// Logical unit definition
const int LX_PER_INCH = 1440;
const int LY_PER_INCH = 1440;

// HIMETRIC units per inch (used for conversion)
const int HIMETRIC_PER_INCH = 2540;

#ifdef DEBUG

void* __cdecl operator new(size_t nSize, char *szFile, int nLine);
#define NEW_DEBUG new(__FILE__, __LINE__)
#define new NEW_DEBUG

void UpdateMst(void);

struct MST
{
	char *szFile;
	int  cbAlloc;
}; //Memory Statistics;

extern MST vrgmst[];

#endif //DEBUG

#ifdef CopyMemory
#undef CopyMemory
#endif
#ifdef MoveMemory
#undef MoveMemory
#endif
#ifdef FillMemory
#undef FillMemory
#endif
#ifdef ZeroMemory
#undef ZeroMemory
#endif
#ifdef CompareMemory
#undef CompareMemory
#endif

#ifndef	KF_ALTDOWN
#define KF_ALTDOWN    0x2000
#endif

// Use for our version of ExtTextOut
enum CONVERTMODE
{
	CVT_NONE,			// Use Unicode (W) CharWidth/TextOut APIs
	CVT_WCTMB,			// Convert to MBCS using WCTMB and _wCodePage
	CVT_LOWBYTE			// Use low byte of 16-bit chars (for SYMBOL_CHARSET
};						//  and when code page isn't installed)

// Opaque Type
class CTxtSelection;
class CTxtEdit;
class CCharFormat;
class CCcs;

enum UN_FLAGS
{
	UN_NOOBJECTS				= 1,
	UN_CONVERT_WCH_EMBEDDING	= 2
};

#undef GetStringTypeEx
#undef CharLower
#undef CharLowerBuff
#undef CharUpperBuff
#undef CreateIC
#undef CreateFile
#undef CreateFontIndirect
#undef CompareString
#undef DefWindowProc
#undef GetKeyboardLayout
#undef GetProfileSection
#undef GetTextMetrics
#undef GetTextExtentPoint32
#undef GetTextFace
#undef GetWindowLong
#undef GetWindowLongPtr
#undef GetClassLong
#undef LoadBitmap
#undef LoadCursor
#undef LoadLibrary
#undef SendMessage
#undef SetWindowLong
#undef SetWindowLongPtr
#undef PostMessage
#undef lstrcmp
#undef lstrcmpi
#undef PeekMessage
#undef GetModuleFileName
#undef GetLayout
#undef SetLayout

// Bits used in _fFEFontInfo:
#define JPN_FONT_AVAILABLE		0x0001		// True if Jpn font is available
#define KOR_FONT_AVAILABLE		0x0002		// True if Kor font is available
#define BIG5_FONT_AVAILABLE		0x0004		// True if Trad. Chinese font is available
#define GB_FONT_AVAILABLE		0x0008		// True if Simplified Chinese font is available	
#define FEUSER_LCID				0x0010		// True if User LCID is FE LCID
#define FEUSER_CODEPAGE			0x0060		//  indicate which User FE codepage its
#define FEUSER_CP_JPN			0x0000		//	 =00 for JPN
#define FEUSER_CP_KOR			0x0020		//	 =20 for KOR
#define FEUSER_CP_BIG5			0x0040		//	 =40 for BIG5
#define FEUSER_CP_GB			0x0060		//	 =60 for GB
#define FEDATA_NOT_INIT			0xFFFF		// No data yet

class CConvertStrW
{
public:
    operator WCHAR *();

protected:
    CConvertStrW();
    ~CConvertStrW();
    void Free();

    LPWSTR   _pwstr;
    WCHAR    _awch[MAX_PATH * 2];
};

inline CConvertStrW::CConvertStrW()
{
    _pwstr = NULL;
}

inline CConvertStrW::~CConvertStrW()
{
    Free();
}

inline CConvertStrW::operator WCHAR *()
{
    return _pwstr;
}

class CStrInW : public CConvertStrW
{
public:
    CStrInW(LPCSTR pstr);
    CStrInW(LPCSTR pstr, UINT uiCodePage);
    CStrInW(LPCSTR pstr, int cch, UINT uiCodePage);
    int strlen();

protected:
    CStrInW();
    void Init(LPCSTR pstr, int cch, UINT uiCodePage);

    int _cwchLen;
	UINT _uiCodePage;
};

inline CStrInW::CStrInW()
{
}

inline int CStrInW::strlen()
{
    return _cwchLen;
}


typedef DWORD (WINAPI* PFN_GETLAYOUT)(HDC);
typedef DWORD (WINAPI* PFN_SETLAYOUT)(HDC, DWORD);


class CW32System
{
private :
	static DWORD		_dwPlatformId;				// platform GetVersionEx();
	static LCID			_syslcid;

public :
	static BOOL			_fHaveIMMProcs;
	static CIMEShare	*_pIMEShare;
	static BOOL			_fHaveAIMM;
	static BOOL			_fHaveIMMEShare;
	static UINT			_fRegisteredXBox;			// flag indicating if listbox and combobox were registered
	static DWORD		_dwMajorVersion;			// major version from GetVersionEx()
	static DWORD		_dwMinorVersion;			// minor version from GetVersionEx()
	static INT			_icr3DDarkShadow;			// value to use for COLOR_3DDKSHADOW
	static UINT			_MSIMEMouseMsg;				// private msg for support mouse operation
	static UINT			_MSIMEReconvertMsg;			// private msg for reconversion
	static UINT			_MSIMEReconvertRequestMsg;	// private msg for reconversion request
	static UINT			_MSIMEDocFeedMsg;			// private msg for document feed
	static UINT			_MSIMEQueryPositionMsg;		// private msg for query position
	static UINT			_MSIMEServiceMsg;			// private msg for checking MSIME98 or later

	static UINT			_MSMouseRoller;				// private msg for mouse scrolling

	// Misc flags used for more precise character classification
	static	WORD		_fFEFontInfo;
	static 	BOOL		_fLRMorRLM;


	CW32System();

	~CW32System();

	static DWORD AddRef();
	static DWORD Release();

	// Platform testing
	static bool OnWinNTFE()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_NT && IsFELCID(_syslcid );
	}
	static bool OnWinNTNonFE()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_NT && !IsFELCID(_syslcid );
	}
	static bool OnWinNT5()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_NT && 5 == _dwMajorVersion;
	}
	static bool OnWinNT4()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_NT && 4 == _dwMajorVersion;
	}
	static bool OnWin9xFE()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_WINDOWS && IsFELCID(_syslcid );
	}
	static bool OnWin9x()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_WINDOWS;
	}
	static bool OnWin95()
	{
		return OnWin9x() && (4 == _dwMajorVersion) && (0 == _dwMinorVersion);
	}
	static bool OnWin95FE()
	{
		return OnWin95() && IsFELCID(_syslcid );
	}
	static bool OnWin9xThai()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_WINDOWS && PRIMARYLANGID(_syslcid) == LANG_THAI;
	}
	static bool OnWin9xBiDi()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_WINDOWS && IsBiDiLcid(_syslcid);
	}
	static bool OnBiDiOS()
	{
		return IsBiDiLcid(_syslcid) != 0;
	}
	struct WM_CHAR_INFO
	{
		bool _fAccumulate;
		bool _fLeadByte;
		bool _fTrailByte;
		bool _fIMEChar;
	};
	static UINT GetACP() {return _ACP;}

	static LRESULT ANSIWndProc( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam, BOOL fIs10Mode );
	static void AnsiFilter( UINT &msg, WPARAM &wparam, LPARAM lparam, void *pvoid, BOOL fIs10Mode = FALSE );
	static HGLOBAL WINAPI GlobalAlloc( UINT uFlags, DWORD dwBytes );
	static HGLOBAL WINAPI GlobalFree( HGLOBAL hMem );
	static UINT WINAPI GlobalFlags( HGLOBAL hMem );
	static HGLOBAL WINAPI GlobalReAlloc( HGLOBAL hMem, DWORD dwBytes, UINT uFlags );
	static DWORD WINAPI GlobalSize( HGLOBAL hMem );
	static PVOID WINAPI GlobalLock( HGLOBAL hMem );
	static HGLOBAL WINAPI GlobalHandle( LPCVOID pMem );
	static BOOL WINAPI GlobalUnlock( HGLOBAL hMem );
	static void WINAPI REGetCharWidth(
		HDC		hdc,
		TCHAR	iChar,
		SHORT *	pWidth,
		UINT	uiCodePage,
		SHORT	xOverhang,		//@parm Equivalent to GetTextMetrics() tmOverhang.
		INT		iDefWidth);		//@parm Default width to use if font calc's zero
								//width. (Handles Win95 problem).
	static void WINAPI REExtTextOut(
		CONVERTMODE cm,
		UINT uiCodePage,
		HDC hdc,
		int x,
		int y,
		UINT fuOptions,
		CONST RECT *lprc,
		const WCHAR *lpString,
		UINT cch,
		CONST INT *lpDx,
		BOOL  FEFontOnNonFEWin95);
	static CONVERTMODE WINAPI DetermineConvertMode( HDC hdc, BYTE tmCharSet );
	static void WINAPI CalcUnderlineInfo(HDC hdc, CCcs *pccs, TEXTMETRIC *ptm );
	static BOOL WINAPI EnableScrollBar( HWND hWnd, UINT wSBflags, UINT wArrows );
	static BOOL WINAPI ShowScrollBar( HWND hWnd, int wBar, BOOL bShow, LONG nMax );
	static BOOL WINAPI IsEnhancedMetafileDC( HDC hdc );
	static HPALETTE WINAPI ManagePalette(
		HDC hdc,
		CONST LOGPALETTE *plogpal,
		HPALETTE &hpalOld,
		HPALETTE &hpalNew
	);

	static void GetFacePriCharSet(HDC hdc, LOGFONT* plf);

	static int WINAPI GetMapMode(HDC hdc);
	static BOOL WINAPI WinLPtoDP(HDC hdc, LPPOINT lppoints, int nCount);

	static long WINAPI WvsprintfA(LONG cb, LPSTR szBuf, LPCSTR szFmt, va_list arglist);

	static int WINAPI MulDiv(int nNumber, int nNumerator, int nDenominator);

	// Convert Himetric along the X axis to X pixels
	static inline LONG	HimetricXtoDX(LONG xHimetric, LONG xPerInch)
	{
		// This formula is rearranged to get rid of the need for floating point
		// arithmetic. The real way to understand the formula is to use
		// (xHimetric / HIMETRIC_PER_INCH) to get the inches and then multiply
		// the inches by the number of x pixels per inch to get the pixels.
		return (LONG) MulDiv(xHimetric, xPerInch, HIMETRIC_PER_INCH);
	}

	// Convert Himetric along the Y axis to Y pixels
	static inline LONG HimetricYtoDY(LONG yHimetric, LONG yPerInch)
	{
		// This formula is rearranged to get rid of the need for floating point
		// arithmetic. The real way to understand the formula is to use
		// (xHimetric / HIMETRIC_PER_INCH) to get the inches and then multiply
		// the inches by the number of y pixels per inch to get the pixels.
		return (LONG) MulDiv(yHimetric, yPerInch, HIMETRIC_PER_INCH);
	}

	// Convert Pixels on the X axis to Himetric
	static inline LONG DXtoHimetricX(LONG dx, LONG xPerInch)
	{
		// This formula is rearranged to get rid of the need for floating point
		// arithmetic. The real way to understand the formula is to use
		// (dx / x pixels per inch) to get the inches and then multiply
		// the inches by the number of himetric units per inch to get the
		// count of himetric units.
		return (LONG) MulDiv(dx, HIMETRIC_PER_INCH, xPerInch);
	}

	// Convert Pixels on the Y axis to Himetric
	static inline LONG DYtoHimetricY(LONG dy, LONG yPerInch)
	{
		// This formula is rearranged to get rid of the need for floating point
		// arithmetic. The real way to understand the formula is to use
		// (dy / y pixels per inch) to get the inches and then multiply
		// the inches by the number of himetric units per inch to get the
		// count of himetric units.
		return (LONG) MulDiv(dy, HIMETRIC_PER_INCH, yPerInch);
	}

	//
	// Case insensitive ASCII compare
	//
	static BOOL ASCIICompareI( const BYTE *pstr1, const BYTE *pstr2, int iCount )
	{
		int i;	
		for (i = 0; i < iCount && !((pstr1[i] ^ pstr2[i]) & ~0x20); i++)
			;
		return i == iCount;
	}

	//
	// Allocate and convert a MultiByte string to a wide character string
	// Allocated strings must be freed with delete
	//
	static WCHAR *ConvertToWideChar( const char *pstr )
	{
		int istrlen = 0;
		if(pstr)
			for (istrlen; pstr[istrlen]; istrlen++);
		WCHAR *pnew = new WCHAR[istrlen + 1];
		if(pnew && (!pstr || 0 != ::MultiByteToWideChar(
								CP_ACP, 0, pstr, -1, pnew, istrlen + 1)))
		{
			return pnew;
		}
		return NULL;
	}

	//
	// functions for memory and string management
	//
#ifdef DEBUG
	static void  PvSet(void *pv, char *szFile, int line);
	static PVOID PvAllocDebug(ULONG cbBuf, UINT uiMemFlags, char *szFile, int line);
	static PVOID PvReAllocDebug(PVOID pvBuf, DWORD cbBuf, char *szFile, int line);
	static void  FreePvDebug(PVOID pvBuf);
#endif
	static PVOID PvAlloc(ULONG cbBuf, UINT uiMemFlags);
	static PVOID PvReAlloc(PVOID pvBuf, DWORD cbBuf);
	static void	FreePv(PVOID pvBuf);

	static inline void *MoveMemory(void *dst, const void *src, size_t cb)
	{
		Assert(cb >= 0);
		return memmove(dst, src, cb);
	}

	static inline void *CopyMemory(void *dst, const void *src, size_t cb)
	{
		// Will work for overlapping regions
		Assert(cb >= 0);
		return MoveMemory(dst, src, cb);
	}

	static inline void *FillMemory(void *dst, int fill, size_t cb)
	{
		return memset(dst, fill, cb);
	}

	static inline void *ZeroMemory(void *dst, size_t cb)
	{
		Assert(cb >= 0);
		return memset(dst, 0, cb);
	}

	static inline int CompareMemory(const void *s1, const void *s2, size_t cb)
	{
		return memcmp(s1, s2, cb);
	}

	static size_t wcslen(const wchar_t *wcs);
	static wchar_t * wcscpy(wchar_t * dst, const wchar_t * src);
	static int wcscmp(const wchar_t * src, const wchar_t * dst);
	static int wcsicmp(const wchar_t * src, const wchar_t * dst);
	static wchar_t * wcsncpy (wchar_t * dest, const wchar_t * source, size_t count);
	static int wcsnicmp(const wchar_t *first, const wchar_t *last, size_t count);
	static unsigned long strtoul(const char *);


	// ----------------------------------
	// IME Support
	// ----------------------------------
	static BOOL ImmInitialize( void );
	static void ImmTerminate( void );
	static LONG ImmGetCompositionStringA ( HIMC, DWORD, PVOID, DWORD, BOOL );
	static LONG ImmGetCompositionStringW ( HIMC, DWORD, PVOID, DWORD, BOOL  );
	static HIMC ImmGetContext ( HWND );
	static BOOL ImmSetCompositionFontA ( HIMC, LPLOGFONTA, BOOL );
	static BOOL ImmSetCompositionWindow ( HIMC, LPCOMPOSITIONFORM, BOOL );
	static BOOL ImmReleaseContext ( HWND, HIMC );
	static DWORD ImmGetProperty ( HKL, DWORD, BOOL );
	static BOOL ImmGetCandidateWindow ( HIMC, DWORD, LPCANDIDATEFORM, BOOL );
	static BOOL ImmSetCandidateWindow ( HIMC, LPCANDIDATEFORM, BOOL );
	static BOOL ImmNotifyIME ( HIMC, DWORD, DWORD, DWORD, BOOL );
	static HIMC ImmAssociateContext ( HWND, HIMC, BOOL );
	static UINT ImmGetVirtualKey ( HWND, BOOL );
	static HIMC ImmEscape ( HKL, HIMC, UINT, PVOID, BOOL );
	static BOOL ImmGetOpenStatus ( HIMC, BOOL );
	static BOOL ImmSetOpenStatus ( HIMC, BOOL, BOOL );
	static BOOL ImmGetConversionStatus ( HIMC, LPDWORD, LPDWORD, BOOL );
	static BOOL ImmSetConversionStatus ( HIMC, DWORD, DWORD, BOOL );
	static HWND ImmGetDefaultIMEWnd ( HWND , BOOL);
	static BOOL ImmSetCompositionStringW (HIMC, DWORD, PVOID, DWORD, PVOID, DWORD);
	static BOOL FSupportSty ( UINT, UINT );
	static const IMESTYLE * PIMEStyleFromAttr ( const UINT );
	static const IMECOLORSTY * PColorStyleTextFromIMEStyle ( const IMESTYLE * );
	static const IMECOLORSTY * PColorStyleBackFromIMEStyle ( const IMESTYLE * );
	static BOOL FBoldIMEStyle ( const IMESTYLE * );
	static BOOL FItalicIMEStyle ( const IMESTYLE * );
	static BOOL FUlIMEStyle ( const IMESTYLE * );
	static UINT IdUlIMEStyle ( const IMESTYLE * );
	static COLORREF RGBFromIMEColorStyle ( const IMECOLORSTY * );

	// ----------------------------------
	// National Language Keyboard support
	// ----------------------------------
	static HKL	CheckChangeKeyboardLayout (BYTE bCharSet);
	static HKL	ActivateKeyboard (LONG index);
	static DWORD GetCharFlags125x(WCHAR ch);
	static BOOL GetKeyboardFlag (WORD dwKeyMask, WORD wKey);
	static WORD GetKeyboardFlags ()				{return _wKeyboardFlags;}
	static HKL  GetKeyboardLayout (DWORD dwThreadID);
	static WORD GetKeyPadNumber ()				{return _wNumKeyPad;}
	static WORD GetDeadKey ()					{return _wDeadKey;}
	static void InitKeyboardFlags ();
	static void RefreshKeyboardLayout ();
	static void ResetKeyboardFlag (WORD wFlag)	{_wKeyboardFlags &= ~wFlag;}
	static void SetDeadKey (WORD wDeadKey)		{_wDeadKey = wDeadKey;}
	static void SetKeyboardFlag (WORD wFlag)	{_wKeyboardFlags |= wFlag;}
	static void SetKeyPadNumber (WORD wNum)		{_wNumKeyPad = wNum;}
	static bool UsingHebrewKeyboard ()
					{return PRIMARYLANGID(_hklCurrent) == LANG_HEBREW;}
	static void InitPreferredFontInfo();
	static bool SetPreferredFontInfo(
		int cpg,
		bool fUIFont,
		SHORT iFont,
		BYTE yHeight,
		BYTE bPitchAndFamily
	);
	static bool GetPreferredFontInfo(
		int cpg,
		bool fUIFont,
		SHORT& iFont,
		BYTE& yHeight,
		BYTE& bPitchAndFamily
	);

	static SHORT GetPreferredFontHeight(	
		bool	fUIFont,
		BYTE	bOrgCharSet,
		BYTE	bNewCharSet,
		SHORT	yOrgHeight
	);

	static void CheckInstalledFEFonts();
	static void CheckInstalledKeyboards();
	static bool IsFontAvail( HDC hDC, int cpg, bool fUIFont = false, short *piFontIndex = NULL);
	static bool IsFEFontInSystem( int cpg );
	static UINT GetFEFontInfo( void );
	static int IsFESystem()
	{
		return IsFELCID( _syslcid );
	}

#ifndef NOACCESSIBILITY
	// ----------------------------------
	// Accessability Support
	// ----------------------------------
	static HRESULT VariantCopy(VARIANTARG FAR*  pvargDest, VARIANTARG FAR*  pvargSrc);
	static LRESULT LResultFromObject(REFIID riid, WPARAM wParam, LPUNKNOWN punk);
	static HRESULT AccessibleObjectFromWindow(HWND hWnd, DWORD dwID, REFIID riidInterface, void ** ppvObject);
	static BOOL BlockInput(BOOL fBlock);
	static UINT	SendInput(UINT nInputs, LPINPUT pInputs, int cbSize);
	static VOID	NotifyWinEvent(DWORD dwEvent, HWND hWnd, LONG lObjectType, LONG lObjectId);
#endif
	
	// ----------------------------------
	// OLE Support
	// ----------------------------------
	static HRESULT LoadRegTypeLib ( REFGUID, WORD, WORD, LCID, ITypeLib ** );
	static HRESULT LoadTypeLib ( const OLECHAR *, ITypeLib ** );
	static HRESULT LoadTypeLibEx( LPCOLESTR szFile, REGKIND regkind, ITypeLib ** pptlib );
	static BSTR SysAllocString ( const OLECHAR * );
	static BSTR SysAllocStringLen ( const OLECHAR *, UINT );
	static void SysFreeString ( BSTR );
	static UINT SysStringLen ( BSTR );
	static void VariantInit ( VARIANTARG * );
	static HRESULT OleCreateFromData ( LPDATAOBJECT, REFIID, DWORD, LPFORMATETC, LPOLECLIENTSITE, LPSTORAGE, void ** );
	static void CoTaskMemFree ( PVOID );
	static HRESULT CreateBindCtx ( DWORD, LPBC * );
	static HANDLE OleDuplicateData ( HANDLE, CLIPFORMAT, UINT );
	static HRESULT CoTreatAsClass ( REFCLSID, REFCLSID );
	static HRESULT ProgIDFromCLSID ( REFCLSID, LPOLESTR * );
	static HRESULT OleConvertIStorageToOLESTREAM ( LPSTORAGE, LPOLESTREAM );
	static HRESULT OleConvertIStorageToOLESTREAMEx ( LPSTORAGE, CLIPFORMAT, LONG, LONG, DWORD, LPSTGMEDIUM, LPOLESTREAM );
	static HRESULT OleSave ( LPPERSISTSTORAGE, LPSTORAGE, BOOL );
	static HRESULT StgCreateDocfileOnILockBytes ( ILockBytes *, DWORD, DWORD, IStorage ** );
	static HRESULT CreateILockBytesOnHGlobal ( HGLOBAL, BOOL, ILockBytes ** );
	static HRESULT OleCreateLinkToFile ( LPCOLESTR, REFIID, DWORD, LPFORMATETC, LPOLECLIENTSITE, LPSTORAGE, void ** );
	static PVOID CoTaskMemAlloc ( ULONG );
	static PVOID CoTaskMemRealloc ( PVOID, ULONG );
	static HRESULT OleInitialize ( PVOID );
	static void OleUninitialize ( );
	static HRESULT OleSetClipboard ( IDataObject * );
	static HRESULT OleFlushClipboard ( );
	static HRESULT OleIsCurrentClipboard ( IDataObject * );
	static HRESULT DoDragDrop ( IDataObject *, IDropSource *, DWORD, DWORD * );
	static HRESULT OleGetClipboard ( IDataObject ** );
	static HRESULT RegisterDragDrop ( HWND, IDropTarget * );
	static HRESULT OleCreateLinkFromData ( IDataObject *, REFIID, DWORD, LPFORMATETC, IOleClientSite *, IStorage *, void ** );
	static HRESULT OleCreateStaticFromData ( IDataObject *, REFIID, DWORD, LPFORMATETC, IOleClientSite *, IStorage *, void ** );
	static HRESULT OleDraw ( IUnknown *, DWORD, HDC, LPCRECT );
	static HRESULT OleSetContainedObject ( IUnknown *, BOOL );
	static HRESULT CoDisconnectObject ( IUnknown *, DWORD );
	static HRESULT WriteFmtUserTypeStg ( IStorage *, CLIPFORMAT, LPOLESTR );
	static HRESULT WriteClassStg ( IStorage *, REFCLSID );
	static HRESULT SetConvertStg ( IStorage *, BOOL );
	static HRESULT ReadFmtUserTypeStg ( IStorage *, CLIPFORMAT *, LPOLESTR * );
	static HRESULT ReadClassStg ( IStorage *pstg, CLSID * );
	static HRESULT OleRun ( IUnknown * );
	static HRESULT RevokeDragDrop ( HWND );
	static HRESULT CreateStreamOnHGlobal ( HGLOBAL, BOOL, IStream ** );
	static HRESULT GetHGlobalFromStream ( IStream *pstm, HGLOBAL * );
	static HRESULT OleCreateDefaultHandler ( REFCLSID, IUnknown *, REFIID, void ** );
	static HRESULT CLSIDFromProgID ( LPCOLESTR, LPCLSID );
	static HRESULT OleConvertOLESTREAMToIStorage ( LPOLESTREAM, IStorage *, const DVTARGETDEVICE * );
	static HRESULT OleLoad ( IStorage *, REFIID, IOleClientSite *, void ** );
	static HRESULT ReleaseStgMedium ( LPSTGMEDIUM );
	static HRESULT CoCreateInstance (REFCLSID rclsid, LPUNKNOWN pUnknown,
		DWORD dwClsContext, REFIID riid, PVOID *ppv);
	static void FreeOle();
	static void FreeIME();
	static BOOL HaveIMEShare();
	static BOOL getIMEShareObject(CIMEShare **ppIMEShare);	
	static BOOL IsAIMMLoaded() { return _fHaveAIMM; }
	static BOOL GetAimmObject(IUnknown **ppAimm);
	static BOOL LoadAIMM();
	static HRESULT AIMMDefWndProc(HWND hWnd, UINT msg, WPARAM wparam, LPARAM lparam, LRESULT *plres);
	static HRESULT AIMMGetCodePage (HKL hKL, UINT *uCodePage);
	static HRESULT AIMMActivate (BOOL fRestoreLayout);
	static HRESULT AIMMDeactivate (void);
	static HRESULT AIMMFilterClientWindows(ATOM *aaClassList, UINT uSize);
	
	int __cdecl sprintf(char * buff, char *fmt, ...);

	// ----------------------------------
	// Useful ANSI<-->Unicode conversion
	//          and language id routines
	// ----------------------------------
	static int	MbcsFromUnicode(LPSTR pstr, int cch, LPCWSTR pwstr,
					int cwch = -1, UINT codepage = CP_ACP,
					UN_FLAGS flags = UN_CONVERT_WCH_EMBEDDING);
	static int	UnicodeFromMbcs(LPWSTR pwstr, int cwch, LPCSTR pstr, int cch = -1,
					UINT uiCodePage = CP_ACP);
	static int	MBTWC(INT CodePage, DWORD dwFlags, LPCSTR pstrMB, int cchMB,
					LPWSTR pstrWC, int cchWC, LPBOOL pfNoCodePage);
	static int	WCTMB(INT CodePage, DWORD dwFlags, LPCWSTR pstrWC, int cchWC,
					LPSTR pstrMB, int cchMB, LPCSTR	pchDefault, LPBOOL pfUsedDef,
					LPBOOL pfNoCodePage, BOOL fTestCodePage = FALSE);
	static int	VerifyFEString(INT cpg, LPCWSTR pstrWC, int cchWC, BOOL	fTestInputCpg);
	static HGLOBAL TextHGlobalAtoW( HGLOBAL hglobal );
	static HGLOBAL TextHGlobalWtoA( HGLOBAL hglobal );
	static UINT ConvertLanguageIDtoCodePage(WORD lid);

	static HKL	FindDirectionalKeyboard(BOOL fRTL);
	static BYTE GetCharSet(INT cpg, int *pcharsetIndex = NULL);
	static BYTE MatchFECharSet(DWORD dwCharInfo, DWORD dwFontSig);	
	static INT  GetCodePage(BYTE bCharSet);
	static DWORD GetFontSig(WORD wCharSet);
	static DWORD GetFontSigFromScript(int iScript);
	static BYTE GetFirstAvailCharSet(DWORD dwFontSig);
	static UINT GetKeyboardCodePage(DWORD dwMakeAPICall = 0);
	static LCID GetKeyboardLCID(DWORD dwMakeAPICall = 0);
	static UINT GetLocaleCodePage();
	static LCID GetLocaleLCID();
	static HKL	GetPreferredKbd(LONG iScript) {return _hkl[iScript];}
	static void	SetPreferredKbd(LONG iScript, HKL hkl) {_hkl[iScript] = hkl;}
	static UINT GetSystemDefaultCodePage()
					{return ConvertLanguageIDtoCodePage(GetSystemDefaultLangID());}
	static int	GetTrailBytesCount(BYTE ach, UINT cpg);
	static BYTE	GetGdiCharSet(BYTE bCharSet);

	static INT  In125x(WCHAR ch, BYTE bCharSet);
	static BOOL Is8BitCodePage(unsigned CodePage);
	static BOOL IsAlef(TCHAR ch);
	static BOOL IsBiDiCharSet(unsigned CharSet)
					{return IN_RANGE(HEBREW_CHARSET, CharSet, ARABIC_CHARSET);}
	static bool IsBiDiCodePage(int cpg)
					{return	IN_RANGE(CP_HEBREW, cpg, CP_ARABIC);}
	static bool IsBiDiKbdInstalled()
					{return	_hkl[HEBREW_INDEX] || _hkl[ARABIC_INDEX];}
	static bool IsThaiKbdInstalled()
					{return	_hkl[THAI_INDEX] != 0;}
	static bool IsIndicKbdInstalled();
	static bool IsComplexKbdInstalled()
					{return	IsBiDiKbdInstalled() || IsThaiKbdInstalled() || IsIndicKbdInstalled();}
	static BOOL IsPrivateCharSet(unsigned CharSet)
					{return IN_RANGE(ADHOC_CHARSET, CharSet, DEVANAGARI_CHARSET);}
	static bool IsVietnameseCodePage(int cpg)
					{return	cpg == CP_VIETNAMESE;}
	static BOOL IsDiacritic(WCHAR ch);
	static BOOL IsBiDiDiacritic(TCHAR ch);
	static BOOL IsBiDiKashida(WCHAR ch)
					{return ch == 0x0640;}
	static BOOL IsBiDiLcid(LCID lcid);
	static BOOL IsIndicLcid(LCID lcid);
	static BOOL IsComplexScriptLcid(LCID lcid);
	static BOOL IsCharSetValid(BYTE bCharSet);
	static BOOL IsDiacriticOrKashida(WCHAR ch, WORD wC3Type);
	static bool IsFELCID(LCID lcid);
	static BOOL IsFECharSet (BYTE bCharSet);
	static bool IsFECodePage(int cpg)
					{return	IN_RANGE(CP_JAPAN, cpg, CP_CHINESE_TRAD);}
	static BOOL IsFECodePageFont (DWORD dwFontSig);
	static BOOL IsRTLCharSet(BYTE bCharSet);
		   BOOL IsStrongDirectional(CC cc)	{return cc <= CC_LTR;}
	static BOOL IsVietCdmSequenceValid(WCHAR ch1, WCHAR ch2);
	static BOOL	IsZWG(char ch, BYTE bCharSet);	//@cmember Is char a 0-width glyph?
	static BOOL IsUTF8BOM(BYTE *pstr);

	static LONG ScriptIndexFromCharSet(BYTE bCharSet);
	static LONG ScriptIndexFromChar	  (WCHAR ch);
	static LONG ScriptIndexFromFontSig(DWORD dwFontSig);

	static WPARAM ValidateStreamWparam(WPARAM wparam);

	static CC	MECharClass(TCHAR ch);

	static HDC GetScreenDC();


	// ----------------------------------
	// Unicode Wrapped Functions
	// ----------------------------------

	// We could use inline and a function pointer table to improve efficiency and code size.

	static ATOM WINAPI RegisterREClass(
		const WNDCLASSW *lpWndClass,
		const char *szAnsiClassName,
		WNDPROC AnsiWndProc
	);
	static BOOL GetVersion(
		DWORD *pdwPlatformId,
		DWORD *pdwMajorVersion,
		DWORD *pdwMinorVersion
	);
	static BOOL GetStringTypes(
		LCID	lcid,
		LPCTSTR lpSrcStr,
		int		cchSrc,
		LPWORD	lpCharType1,
		LPWORD	lpCharType3
	);
	static BOOL WINAPI GetStringTypeEx(
		LCID     Locale,
		DWORD    dwInfoType,
		LPCWSTR lpSrcStr,
		int      cchSrc,
		LPWORD   lpCharType
	);
	static LPWSTR WINAPI CharLower(LPWSTR pwstr);
	static DWORD WINAPI CharLowerBuff(LPWSTR pwstr, DWORD cchLength);
	static DWORD WINAPI CharUpperBuff(LPWSTR pwstr, DWORD cchLength);
	static HDC WINAPI CreateIC(
        LPCWSTR             lpszDriver,
        LPCWSTR             lpszDevice,
        LPCWSTR             lpszOutput,
        CONST DEVMODEW *    lpInitData
	);
	static HANDLE WINAPI CreateFile(
        LPCWSTR                 lpFileName,
        DWORD                   dwDesiredAccess,
        DWORD                   dwShareMode,
        LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
        DWORD                   dwCreationDisposition,
        DWORD                   dwFlagsAndAttributes,
        HANDLE                  hTemplateFile
	);
	static HFONT WINAPI CreateFontIndirect(CONST LOGFONTW * plfw);
	static int WINAPI CompareString (
		LCID  Locale,			// locale identifier
		DWORD  dwCmpFlags,		// comparison-style options
		LPCWSTR  lpString1,		// pointer to first string
		int  cch1,			// size, in bytes or characters, of first string
		LPCWSTR  lpString2,		// pointer to second string
		int  cch2 			// size, in bytes or characters, of second string
	);
	static LRESULT WINAPI DefWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
	static int WINAPI GetObject(HGDIOBJ hgdiObj, int cbBuffer, PVOID lpvObj);
	static DWORD APIENTRY GetProfileSection(
		LPCWSTR lpAppName,
		LPWSTR lpReturnedString,
		DWORD nSize
	);
	static BOOL APIENTRY GetTextExtentPoint32(
        HDC     hdc,
        LPCWSTR pwsz,
        int     cb,
        LPSIZE  pSize
	);
	static int WINAPI GetTextFace(
        HDC    hdc,
        int    cch,
        LPWSTR lpFaceName
	);
	static BOOL WINAPI GetTextMetrics(HDC hdc, LPTEXTMETRICW lptm);
	static BOOL WINAPI GetTextMetrics(HDC hdc, LOGFONTW &lf, TEXTMETRICW &tm);
	static LONG WINAPI GetWindowLong(HWND hWnd, int nIndex);
	static LONG_PTR WINAPI GetWindowLongPtr(HWND hWnd, int nIndex);
	static DWORD WINAPI GetClassLong(HWND hWnd, int nIndex);
	static HBITMAP WINAPI LoadBitmap(HINSTANCE hInstance, LPCWSTR lpBitmapName);
	static HCURSOR WINAPI LoadCursor(HINSTANCE hInstance, LPCWSTR lpCursorName);
	static HINSTANCE WINAPI LoadLibrary(LPCWSTR lpLibFileName);
	static LRESULT WINAPI SendMessage(
        HWND    hWnd,
        UINT    Msg,
        WPARAM  wParam,
        LPARAM  lParam
	);
	static LONG WINAPI SetWindowLong(HWND hWnd, int nIndex, LONG dwNewLong);
	static LONG WINAPI SetWindowLongPtr(HWND hWnd, int nIndex, LONG_PTR dwNew);
	static BOOL WINAPI PostMessage(
        HWND    hWnd,
        UINT    Msg,
        WPARAM  wParam,
        LPARAM  lParam
	);
	static BOOL WINAPI UnregisterClass(LPCWSTR lpClassName, HINSTANCE hInstance);
	static int WINAPI lstrcmp(LPCWSTR lpString1, LPCWSTR lpString2);
	static int WINAPI lstrcmpi(LPCWSTR lpString1, LPCWSTR lpString2);
	static BOOL WINAPI PeekMessage(
        LPMSG   lpMsg,
        HWND    hWnd,
        UINT    wMsgFilterMin,
        UINT    wMsgFilterMax,
        UINT    wRemoveMsg
	);
	static DWORD WINAPI GetModuleFileName(
		HMODULE hModule,
		LPWSTR lpFilename,
		DWORD nSize
    );
	static DWORD GetCurrentThreadId(void);

private:
	// System Parameters
	static BOOL		_fSysParamsOk;			// System Parameters have been Initialized
	static INT 		_xWidthSys;				// average char width of system font
	static INT 		_yHeightSys;			// height of system font
	static INT		_ySysFontLeading;		// System font internal leading
	static BOOL 	_fUsePalette;
	static LONG 	_xPerInchScreenDC;		// Pixels per inch used for conversions ...
	static LONG 	_yPerInchScreenDC;		// ... and determining whether screen or ...
	static INT		_cxBorder;				// GetSystemMetricx(SM_CXBORDER)...
	static INT		_cyBorder;				// GetSystemMetricx(SM_CYBORDER)...
	static INT		_cxVScroll;				// Width/height of scrlbar arw bitmap
	static INT		_cyHScroll;				// Width of scrlbar arw bitmap
	static LONG 	_dxSelBar;
	static INT		_sysiniflags;			// Start using line services from the start

	static UINT		_ACP;					// Current Ansi code page identifier

	static HDC		_hdcScreen;
	// Double click distances
	static INT		_cxDoubleClk;
	static INT		_cyDoubleClk;	

	// Double Click Time in milliseconds
	static INT		_DCT;

	//Width of hot zone (in pixels) for auto-scrolling
    static WORD	_nScrollInset;
    //Delay (in ms) before scrolling
    static WORD _nScrollDelay;
	//Interval (in ms) at which we scroll
    static WORD _nScrollInterval;
	//Amount of horizontal scroll at each interval (pixels)
	static WORD _nScrollHAmount;
	//Amount of vertical scroll at each interval (pixels)
	static WORD _nScrollVAmount;
	//Amount of time to wait for determining start of drag operation
	static WORD _nDragDelay;
	//Minimun distance that must be traversed within drag delay time interval
	static WORD _nDragMinDist;
	//Keyboard deadkey
	static WORD _wDeadKey;
	//Keyboard shift/ctrl/alt/lock status
	static WORD _wKeyboardFlags;
	//North/South sizing cursor (double arrow)
	static HCURSOR _hcurSizeNS;
	//West/East sizing cursor (double arrow)
	static HCURSOR _hcurSizeWE;
	//Northwest/Southeast sizing cursor (double arrow)
	static HCURSOR _hcurSizeNWSE;
	//Northeast/Southwest sizing cursor (double arrow)
	static HCURSOR _hcurSizeNESW;
	//Number of Lines to scroll with a mouse roller wheel, -1 for pages
	static LONG	_cLineScroll;
	//System Font Handle.  This one need only be done once.
	static HFONT _hSystemFont;
	//System Keyboard Layout
	static HKL _hklCurrent;
	static HKL _hkl[NCHARSETS];

	// Ref Count
	static DWORD _cRefs;

	//AltNumericKeyboard number
	static WORD _wNumKeyPad;

	//Digit substitution mode (context, none, national)
	static BYTE	_bDigitSubstMode;

	//SYSTEM_FONT charset
	static BYTE _bSysCharSet;

public:
	static INT	GetXWidthSys()		 {return _xWidthSys; }
	static INT	GetYHeightSys()		 {return _yHeightSys; }
	static INT	GetSysFontLeading()	 {return _ySysFontLeading; }
	static LONG GetXPerInchScreenDC(){return _xPerInchScreenDC; }
	static LONG GetYPerInchScreenDC(){return _yPerInchScreenDC; }
	static INT	GetCxBorder()		 {return _cxBorder; }
	static INT	GetCyBorder()		 {return _cyBorder; }
	static INT	GetCyHScroll()		 {return _cyHScroll; }
	static INT	GetCxVScroll()		 {return _cxVScroll; }
	static LONG GetDxSelBar()		 {return _dxSelBar; }
    static WORD GetScrollInset()	 {return _nScrollInset; }
    static WORD GetScrollDelay()	 {return _nScrollDelay; }
    static WORD GetScrollInterval()	 {return _nScrollInterval; }
	static WORD GetScrollHAmount()	 {return _nScrollHAmount; }
	static WORD GetScrollVAmount()	 {return _nScrollVAmount; }
	static INT	GetCxDoubleClk()	 {return _cxDoubleClk; }
	static INT	GetCyDoubleClk()	 {return _cyDoubleClk; }
	static INT	GetDCT()			 {return _DCT; }
	static WORD GetDragDelay()		 {return _nDragDelay; }
	static WORD GetDragMinDist()	 {return _nDragMinDist; }
	static LONG GetRollerLineScrollCount();
	static HCURSOR GetSizeCursor(LPTSTR idcur);
	static HFONT GetSystemFont()	 {return _hSystemFont; }
	static BYTE ReadRegDigitSubstitutionMode();
	static BYTE GetDigitSubstitutionMode() {return _bDigitSubstMode;}
	static bool fUseAimm()			 {return (_sysiniflags & SYSINI_USEAIMM) != 0;}
	static bool fUseBiDi()			 {return (_sysiniflags & SYSINI_BIDI) != 0;}
	static bool fUseLs()			 {return (_sysiniflags & SYSINI_USELS) != 0;}
	static bool fDebugFont()		 {return (_sysiniflags & SYSINI_DEBUGFONT) != 0;}
	static int  DebugDefaultCpg()    {return HIWORD(_sysiniflags);}
	static BOOL FUsePalette()		 {return _fUsePalette; }
	static void InitSysParams(BOOL fUpdate = FALSE);
	static DWORD GetRefs()			 {return _cRefs;}
	static BYTE	GetSysCharSet()		 {return _bSysCharSet;}

	// Should also be wrapped but aren't.  Used for debugging.
	// MessageBox
	// OutputDebugString

	// lstrcmpiA should also be wrapped for Win CE's sake but the code
	// that uses it is ifdeffed out for WINCE.


	// Mirroring API entry points
	static PFN_GETLAYOUT			_pfnGetLayout;
	static PFN_SETLAYOUT			_pfnSetLayout;
};

extern CW32System *W32;
HKL	   g_hkl[];

#if !defined(W32SYS_CPP)

#define OnWinNTFE					W32->OnWinNTFE
#define OnWin95FE					W32->OnWin95FE
#ifdef DEBUG
#define PvAlloc(cbBuf, uiMemFlags)	W32->PvAllocDebug(cbBuf, uiMemFlags, __FILE__, __LINE__)
#define PvReAlloc(pv, cbBuf)		W32->PvReAllocDebug(pv, cbBuf, __FILE__, __LINE__)
#define PvSet(pv)					W32->PvSet(pv, __FILE__, __LINE__)
#define FreePv						W32->FreePvDebug
#else
#define PvAlloc						W32->PvAlloc
#define PvReAlloc					W32->PvReAlloc
#define FreePv						W32->FreePv
#endif
#define CopyMemory					W32->CopyMemory
#define MoveMemory					W32->MoveMemory
#define FillMemory					W32->FillMemory
#define ZeroMemory					W32->ZeroMemory
#define CompareMemory				W32->CompareMemory
#define GlobalAlloc					W32->GlobalAlloc
#define GlobalFree					W32->GlobalFree
#define GlobalFlags					W32->GlobalFlags
#define	GlobalReAlloc				W32->GlobalReAlloc
#define	GlobalSize					W32->GlobalSize
#define	GlobalLock					W32->GlobalLock
#define	GlobalHandle				W32->GlobalHandle
#define	GlobalUnlock				W32->GlobalUnlock

#define ImmInitialize				W32->ImmInitialize
#define ImmTerminate				W32->ImmTerminate

#define ImmGetCompositionStringA	W32->ImmGetCompositionStringA
#define ImmGetCompositionStringW	W32->ImmGetCompositionStringW
#define ImmGetContext				W32->ImmGetContext
#define ImmSetCompositionFontA		W32->ImmSetCompositionFontA
#define ImmSetCompositionWindow		W32->ImmSetCompositionWindow
#define ImmReleaseContext			W32->ImmReleaseContext
#define ImmGetProperty				W32->ImmGetProperty
#define ImmGetCandidateWindow		W32->ImmGetCandidateWindow
#define ImmSetCandidateWindow		W32->ImmSetCandidateWindow
#define ImmNotifyIME				W32->ImmNotifyIME
#define ImmAssociateContext			W32->ImmAssociateContext
#define ImmGetVirtualKey			W32->ImmGetVirtualKey
#define ImmEscape					W32->ImmEscape
#define ImmGetOpenStatus			W32->ImmGetOpenStatus
#define ImmSetOpenStatus			W32->ImmSetOpenStatus
#define ImmGetConversionStatus		W32->ImmGetConversionStatus
#define ImmSetConversionStatus		W32->ImmSetConversionStatus
#define ImmGetDefaultIMEWnd			W32->ImmGetDefaultIMEWnd
#define ImmSetCompositionStringW	W32->ImmSetCompositionStringW
#define LoadRegTypeLib				W32->LoadRegTypeLib
#define LoadTypeLib					W32->LoadTypeLib
#define SysAllocString				W32->SysAllocString
#define SysAllocStringLen			W32->SysAllocStringLen
#define SysFreeString				W32->SysFreeString
#define SysStringLen				W32->SysStringLen
#define VariantInit					W32->VariantInit
#define OleCreateFromData			W32->OleCreateFromData
#define CoTaskMemFree				W32->CoTaskMemFree
#define CreateBindCtx				W32->CreateBindCtx
#define OleDuplicateData			W32->OleDuplicateData
#define CoTreatAsClass				W32->CoTreatAsClass
#define ProgIDFromCLSID				W32->ProgIDFromCLSID
#define OleConvertIStorageToOLESTREAM W32->OleConvertIStorageToOLESTREAM
#define OleConvertIStorageToOLESTREAMEx W32->OleConvertIStorageToOLESTREAMEx
#define OleSave						W32->OleSave
#define StgCreateDocfileOnILockBytes W32->StgCreateDocfileOnILockBytes
#define CreateILockBytesOnHGlobal	W32->CreateILockBytesOnHGlobal
#define OleCreateLinkToFile			W32->OleCreateLinkToFile
#define CoTaskMemAlloc				W32->CoTaskMemAlloc
#define CoTaskMemRealloc			W32->CoTaskMemRealloc
#define OleInitialize				W32->OleInitialize
#define OleUninitialize				W32->OleUninitialize
#define OleSetClipboard				W32->OleSetClipboard
#define OleFlushClipboard			W32->OleFlushClipboard
#define OleIsCurrentClipboard		W32->OleIsCurrentClipboard
#define DoDragDrop					W32->DoDragDrop
#define OleGetClipboard				W32->OleGetClipboard
#define RegisterDragDrop			W32->RegisterDragDrop
#define OleCreateLinkFromData		W32->OleCreateLinkFromData
#define OleCreateStaticFromData		W32->OleCreateStaticFromData
#define OleDraw						W32->OleDraw
#define OleSetContainedObject		W32->OleSetContainedObject
#define CoDisconnectObject			W32->CoDisconnectObject
#define WriteFmtUserTypeStg			W32->WriteFmtUserTypeStg
#define WriteClassStg				W32->WriteClassStg
#define SetConvertStg				W32->SetConvertStg
#define ReadFmtUserTypeStg			W32->ReadFmtUserTypeStg
#define ReadClassStg				W32->ReadClassStg
#define OleRun						W32->OleRun
#define RevokeDragDrop				W32->RevokeDragDrop
#define CreateStreamOnHGlobal		W32->CreateStreamOnHGlobal
#define GetHGlobalFromStream		W32->GetHGlobalFromStream
#define OleCreateDefaultHandler		W32->OleCreateDefaultHandler
#define CLSIDFromProgID				W32->CLSIDFromProgID
#define OleConvertOLESTREAMToIStorage W32->OleConvertOLESTREAMToIStorage
#define OleLoad						W32->OleLoad
#define ReleaseStgMedium			W32->ReleaseStgMedium
#define CoCreateInstance			W32->CoCreateInstance
#define FSupportSty					W32->FSupportSty
#define PIMEStyleFromAttr			W32->PIMEStyleFromAttr
#define PColorStyleTextFromIMEStyle W32->PColorStyleTextFromIMEStyle
#define PColorStyleBackFromIMEStyle W32->PColorStyleBackFromIMEStyle
#define FBoldIMEStyle				W32->FBoldIMEStyle
#define FItalicIMEStyle				W32->FItalicIMEStyle
#define FUlIMEStyle					W32->FUlIMEStyle
#define IdUlIMEStyle				W32->IdUlIMEStyle
#define RGBFromIMEColorStyle		W32->RGBFromIMEColorStyle

#define fHaveIMMProcs				W32->_fHaveIMMProcs
#define fHaveAIMM					W32->_fHaveAIMM
#define dwPlatformId				W32->_dwPlatformId
#define dwMajorVersion				W32->_dwMajorVersion
#define icr3DDarkShadow				W32->_icr3DDarkShadow
#define MSIMEMouseMsg				W32->_MSIMEMouseMsg				
#define MSIMEReconvertMsg			W32->_MSIMEReconvertMsg		
#define MSIMEReconvertRequestMsg	W32->_MSIMEReconvertRequestMsg
#define MSIMEDocFeedMsg				W32->_MSIMEDocFeedMsg
#define MSIMEQueryPositionMsg		W32->_MSIMEQueryPositionMsg
#define MSIMEServiceMsg				W32->_MSIMEServiceMsg

#define ScriptIndexFromChar			W32->ScriptIndexFromChar
#define ScriptIndexFromCharSet		W32->ScriptIndexFromCharSet	
#define MECharClass					W32->MECharClass
#define MbcsFromUnicode				W32->MbcsFromUnicode	
#define UnicodeFromMbcs				W32->UnicodeFromMbcs
#define TextHGlobalAtoW				W32->TextHGlobalAtoW
#define TextHGlobalWtoA				W32->TextHGlobalWtoA
#define ConvertLanguageIDtoCodePage	W32->ConvertLanguageIDtoCodePage	
#define In125x						W32->In125x	

#define Is8BitCodePage				W32->Is8BitCodePage
#define IsAlef						W32->IsAlef
#define IsAmbiguous					W32->IsAmbiguous
#define IsBiDiCharSet				W32->IsBiDiCharSet
#define IsBiDiDiacritic				W32->IsBiDiDiacritic
#define IsBiDiKashida				W32->IsBiDiKashida
#define IsBiDiKbdInstalled			W32->IsBiDiKbdInstalled
#define IsDiacritic					W32->IsDiacritic
#define	IsCharSetValid				W32->IsCharSetValid	
#define IsDiacriticOrKashida		W32->IsDiacriticOrKashida
#define IsFECharSet					W32->IsFECharSet	
#define IsFELCID					W32->IsFELCID	
#define IsPrivateCharSet			W32->IsPrivateCharSet
#define IsRTLCharSet				W32->IsRTLCharSet	
#define IsStrongDirectional			W32->IsStrongDirectional
#define IsThaiKbdInstalled			W32->IsThaiKbdInstalled
#define IsIndicKbdInstalled			W32->IsIndicKbdInstalled
#define IsComplexKbdInstalled		W32->IsComplexKbdInstalled
#define	IsTrailByte					W32->IsTrailByte
#define IsVietCdmSequenceValid		W32->IsVietCdmSequenceValid
	
#define	GetCharSet					W32->GetCharSet	
#define GetGdiCharSet				W32->GetGdiCharSet
#define	GetCodePage					W32->GetCodePage	
#define	GetFontSig					W32->GetFontSig
#define GetFirstAvailCharSet		W32->GetFirstAvailCharSet
#define MatchFECharSet				W32->MatchFECharSet
#define	GetKeyboardCodePage			W32->GetKeyboardCodePage	
#define	GetKeyboardLCID				W32->GetKeyboardLCID	
#define	GetLocaleCodePage			W32->GetLocaleCodePage	
#define	GetLocaleLCID				W32->GetLocaleLCID	
#define	GetSystemDefaultCodePage	W32->GetSystemDefaultCodePage
#define GetTrailBytesCount			W32->GetTrailBytesCount	
#define	MBTWC						W32->MBTWC	
#define	WCTMB						W32->WCTMB
#define VerifyFEString				W32->VerifyFEString		

#define CharLower					W32->CharLower
#define CharLowerBuff				W32->CharLowerBuff
#define CharUpperBuff				W32->CharUpperBuff
#define CreateIC					W32->CreateIC
#define CreateFile					W32->CreateFile
#define CreateFontIndirect			W32->CreateFontIndirect
#define CompareString				W32->CompareString
#define DefWindowProc				W32->DefWindowProc
#define GetDeadKey					W32->GetDeadKey
#define GetKeyboardFlag				W32->GetKeyboardFlag
#define GetKeyboardFlags			W32->GetKeyboardFlags
#define GetKeyboardLayout			W32->GetKeyboardLayout
#define GetKeyPadNumber				W32->GetKeyPadNumber
#define GetProfileSection			W32->GetProfileSection
#define GetTextExtentPoint32		W32->GetTextExtentPoint32
#define GetTextMetrics				W32->GetTextMetrics
#define GetTextFace					W32->GetTextFace
#define GetWindowLong				W32->GetWindowLong
#define GetWindowLongPtr			W32->GetWindowLongPtr
#define GetClassLong				W32->GetClassLong
#define InitKeyboardFlags			W32->InitKeyboardFlags
#define IsEnhancedMetafileDC		W32->IsEnhancedMetafileDC
#define LoadBitmap					W32->LoadBitmap
#define LoadCursor					W32->LoadCursor
#define LoadLibrary					W32->LoadLibrary
#define ResetKeyboardFlag			W32->ResetKeyboardFlag
#define SendMessage					W32->SendMessage
#define SetDeadKey					W32->SetDeadKey
#define SetKeyboardFlag				W32->SetKeyboardFlag
#define SetKeyPadNumber				W32->SetKeyPadNumber
#define SetWindowLong				W32->SetWindowLong
#define SetWindowLongPtr			W32->SetWindowLongPtr
#define PostMessage					W32->PostMessage
#define lstrcmp						W32->lstrcmp
#define lstrcmpi					W32->lstrcmpi
#define PeekMessage					W32->PeekMessage
#define GetMapMode					W32->GetMapMode
#define WinLPtoDP					W32->WinLPtoDP
#define MulDiv						W32->MulDiv

// AIMM wrapper
#define IsAIMMLoaded				W32->IsAIMMLoaded
#define LoadAIMM					W32->LoadAIMM
#define CallAIMMDefaultWndProc		W32->AIMMDefWndProc
#define GetAIMMKeyboardCP			W32->AIMMGetCodePage
#define ActivateAIMM				W32->AIMMActivate
#define DeactivateAIMM				W32->AIMMDeactivate
#define FilterClientWindowsAIMM		W32->AIMMFilterClientWindows
#define sprintf						W32->sprintf

#define wcslen						W32->wcslen
#define wcscpy						W32->wcscpy
#define wcscmp						W32->wcscmp
#define wcsicmp						W32->wcsicmp
#define wcsncpy						W32->wcsncpy

#define GetLayout					(*W32->_pfnGetLayout)
#define SetLayout					(*W32->_pfnSetLayout)

#define GetACP						W32->GetACP

#endif // !defined(W32SYS_CPP)

#define VER_PLATFORM_WIN32_MACINTOSH	0x8001

#if defined PEGASUS && !defined(WINNT)

// The follwing definitions do not exist in the Windows CE environment but we emulate them.
// The values have been copied from the appropriate win32 header files.

#pragma message(REVIEW "Using NT definitions not in Windows CE")

// Memory allocation flag.  Win CE uses Local mem instead of Global mem
#define GMEM_ZEROINIT       LMEM_ZEROINIT
#define GMEM_MOVEABLE		LMEM_MOVEABLE
#define GMEM_FIXED			LMEM_FIXED

// Scroll Bars
#define ESB_ENABLE_BOTH				0x0000
#define ESB_DISABLE_BOTH			0x0003

// Text alignment values
#define TA_TOP                      0
#define TA_BOTTOM                   8
#define TA_BASELINE                 24
#define TA_CENTER                   6
#define TA_LEFT                     0

// Device Technology.  This one is mostly used for exclusion
#define DT_METAFILE         5   // Metafile, VDM

// Resources for LoadCursor.
#define IDC_ARROW           MAKEINTRESOURCE(32512)
#define IDC_IBEAM           MAKEINTRESOURCE(32513)

// FInd/Replace options
#define FR_DOWN                         0x00000001
#define FR_WHOLEWORD                    0x00000002
#define FR_MATCHCASE                    0x00000004

// Window messages
#define WM_NCMOUSEMOVE                  0x00A0
#define WM_NCMBUTTONDBLCLK              0x00A9
#define WM_DROPFILES                    0x0233

// Code Pages
#define CP_UTF8              65001          /* UTF-8 translation */

// Clipboard formats
#define CF_METAFILEPICT     3

// Special cursor shapes
#define IDC_SIZENWSE        MAKEINTRESOURCE(32642)
#define IDC_SIZENESW        MAKEINTRESOURCE(32643)
#define IDC_SIZENS          MAKEINTRESOURCE(32645)
#define IDC_SIZEWE          MAKEINTRESOURCE(32644)

/* Mapping Modes */
#define MM_TEXT             1
#define SetMapMode(hdc, mapmode)
#define SetWindowOrgEx(hdc, xOrg, yOrg, pt)
#define SetViewportExtEx(hdc, nX, nY, lpSize)
#define SetWindowExtEx(hdc, x, y, lpSize)

/* Pen Styles : Windows CE only supports PS_DASH */
#define PS_DOT PS_DASH
#define PS_DASHDOT PS_DASH
#define PS_DASHDOTDOT PS_DASH

/* Missing APIs */
#define GetMessageTime()	0
#define IsIconic(hwnd)		0

#pragma message (REVIEW "JMO. This is temporary to try to get the Pegasus Build untracked" )

#ifdef DEBUG
#define MoveToEx(a, b, c, d) 0
#else
#define MoveToEx(a, b, c, d)
#endif

#ifdef DEBUG
#define LineTo(a, b, c) 0
#else
#define LineTo(a, b, c)
#endif

#define GetProfileIntA(a, b, c) 0

class METARECORD
{
};

#define GetDesktopWindow() NULL

#define WS_EX_TRANSPARENT       0x00000020L
#define WM_MOUSEACTIVATE			0x0021

#define IsDBCSLeadByte(x) 0

#define WM_SYSCOLORCHANGE               0x0015
#define WM_STYLECHANGING                0x007C
#define WM_WINDOWPOSCHANGING            0x0046
#define WM_SETCURSOR                    0x0020
#define WM_NCPAINT                      0x0085

#define OEM_CHARSET             255
#define SHIFTJIS_CHARSET        128
#define THAI_CHARSET            222
#define WM_IME_CHAR                     0x0286
#define IME_CMODE_NATIVE                0x0001
#define IME_CMODE_HANGEUL               IME_CMODE_NATIVE
#define IME_ESC_HANJA_MODE              0x1008

#define SM_SWAPBUTTON           23

class CHARSETINFO
{
};

class HDROP
{
};

#define TCI_SRCCODEPAGE 2

#define TPM_RIGHTBUTTON 0x0002L

#define RegisterClipboardFormatA(s)  RegisterClipboardFormatW(TEXT(s))
#define GetThreadLocale() 0

#define EASTEUROPE_CHARSET      238
#define HEBREW_CHARSET          177
#define RUSSIAN_CHARSET         204
#define GB2312_CHARSET          134
#define HANGEUL_CHARSET         129
#define JOHAB_CHARSET           130
#define CHINESEBIG5_CHARSET     136
#define GREEK_CHARSET           161
#define TURKISH_CHARSET         162
#define BALTIC_CHARSET          186
#define ARABIC_CHARSET          178
#define MAC_CHARSET             77

#define ENUMLOGFONTA ENUMLOGFONT
#define ENUMLOGFONTW ENUMLOGFONT
#define FONTENUMPROCA FONTENUMPROC
typedef int *LPOPENFILENAMEA;
typedef int *LPOPENFILENAMEW;

#endif

#ifndef WS_EX_LAYOUTRTL
#define WS_EX_LAYOUTRTL			0x00400000L		// Right to left mirroring
#endif

#ifndef LAYOUT_RTL
#define LAYOUT_RTL				0x00000001
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_txtbrk.h ===
/*
 *		Text Breaker & Bit stream break array class definition
 *		
 *		File:    _txtbrk.h
 * 		Create:  Mar 29, 1998
 *		Author:  Worachai Chaoweeraprasit (wchao)
 *
 *		Copyright (c) 1998, Microsoft Corporation. All rights reserved.
 */


#ifndef _TXTBRK_H
#define _TXTBRK_H

// DEBUG definition
#ifdef BITVIEW
#define	BVDEBUG		_DEBUG
#define Assert		ASSERT
#else
#define BVDEBUG		DEBUG
#endif


// The number of buffer breaks before the sync point
#define	CWORD_TILLSYNC		3	// Thai wordbreak engine is expected to be in sync within 3 words
#define CCLUSTER_TILLSYNC	1	// Indic cluster is normally in sync in within 1

// Abstract Data type
#define ITEM				UINT

// CPU register size
//#define RSIZE				(sizeof(ITEM)*8)
#define RSIZE				32

// Mask most/least significant <n> bits
#define MASK_LOW(u, n)		( ((ITEM)(u)) & (1<<(n))-1 )
#define MASK_HIGH(u, n)		~MASK_LOW(u, RSIZE-n)

// BreakArray Exit convention
#ifdef BVDEBUG
#define PUSH_STATE(x,y,z)	PushState(x,y,z)
#define VALIDATE(x)			Validate(x)
#else
#define PUSH_STATE(x,y,z)
#define VALIDATE(x)			x
#endif

// Who put the state?
#define INSERTER			0
#define REMOVER				1
#define COLLAPSER			2
#define REPLACER			3


#ifdef BVDEBUG
typedef struct {
	LONG	who;
	LONG	ibGap;
	LONG	cbGap;
	LONG	cbBreak;
	LONG	cbSize;
	LONG	cp;
	LONG	cch;
} BVSTATE;
#endif

class CBreakArray : public CArray<ITEM>
{
public:
#ifdef BITVIEW
	friend class CBitView;
#endif

	CBreakArray();
	~CBreakArray() {}

	ITEM*		Elem(LONG iel) const;
	BOOL		IsValid() const { return Count() > 0; }
	void		CheckArray();

	LONG		InsertBreak (LONG cp, LONG cch);
	LONG		RemoveBreak (LONG cp, LONG cch);
	LONG 		ReplaceBreak (LONG cp, LONG cchOld, LONG cchNew);
	void		ClearBreak (LONG cp, LONG cch);
	void		SetBreak (LONG cp, BOOL fOn);
	BOOL		GetBreak (LONG cp);

	LONG		CollapseGap (void);
private:

	// n-Bits shifting methods
	void		ShUp (LONG iel, LONG cel, LONG n);
	void		ShDn (LONG iel, LONG cel, LONG n);

	// Size (in bits)
	LONG		_ibGap;			// offset from start of array to gap
	LONG		_cbGap;			// gap size
	LONG		_cbBreak;		// number of valid break
	LONG		_cbSize;		// bit array size (excluded the sentinel element)
#ifdef BITVIEW
	LONG		_cCollapse;		// how many time collapse?
#endif

public:
	LONG		GetCchBreak() { return _cbBreak; }
#ifdef BVDEBUG
	LONG		GetCbSize() { return _cbSize; }
	LONG		Validate(LONG cchRet);		
	void		PushState(LONG cp, LONG cch, LONG who);
#endif
#ifdef BITVIEW
	LONG		SetCollapseCount();
#endif

protected:
#ifdef BVDEBUG
	BVSTATE		_s;
#endif
	LONG		AddBreak(LONG cp, LONG cch);
};


#ifndef BITVIEW


///////	Complex script text breaker class
// 
//		The engine to handle cluster and (dictionary-based) word breaking method
//		used by most SouthEast Asian languages such as Thai, Lao, Burmese etc.
//
//		Create: Mar 12, 1998
//

enum BREAK_UNIT
{
	BRK_WORD		= 1,
	BRK_CLUSTER 	= 2,
	BRK_BOTH		= 3
};

class CTxtBreaker : public ITxNotify
{
public:
	CTxtBreaker(CTxtEdit *ped);
	~CTxtBreaker();

	// Breaker allocation
	BOOL				AddBreaker(UINT brkUnit);

	// Breaker refreshing
	void				Refresh();

	// Query methods
	BOOL				CanBreakCp (BREAK_UNIT brk, LONG cp);

	// ITxNotify methods

	virtual void    	OnPreReplaceRange (LONG cp, LONG cchDel, LONG cchNew,
										LONG cpFormatMin, LONG cpFormatMax);
	virtual void    	OnPostReplaceRange (LONG cp, LONG cchDel, LONG cchNew,
										LONG cpFormatMin, LONG cpFormatMax);
	virtual void		Zombie() {};

private:
	CTxtEdit*			_ped;
	CBreakArray*		_pbrkWord;		// word-break array (per codepoint property)
	CBreakArray*		_pbrkChar;		// cluster-break array (per codepoint property)
};

#endif	// !BITVIEW

#endif	// _TXTBRK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\_uspi.h ===
/*
 *		Uniscribe interface (& related classes) class definition
 *		
 *		File:    _uspi.h
 * 		Create:  Jan 10, 1998
 *		Author:  Worachai Chaoweeraprasit (wchao)
 *
 *		Copyright (c) 1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _USPI_H
#define _USPI_H

#include "_ls.h"
#include "usp10.h"		// Uniscribe SDK protocol


// classes
//
class CFormatRunPtr;
class CMeasurer;
class CTxtEdit;
class CUniscribe;
class CBiDiFSM;
class CTxtBreaker;


#define ALIGN(x)            		(int)(((x)+3) & ~3)		// dword aligning
#define GLYPH_COUNT(c)          	((((c)*3)/2)+16)
#define MAX_CLIENT_BUF				512						// size (in byte) of internal buffer

// USP client parameters block
//
#define cli_string                  0x00000001
#define cli_psi                     0x00000002
#define cli_psla                    0x00000004
#define cli_pwgi					0x00000008
#define cli_psva					0x00000010
#define cli_pcluster				0x00000020
#define cli_pidx					0x00000040
#define cli_pgoffset				0x00000080

#define cli_Itemize                 (cli_string | cli_psi)
#define cli_Break                   (cli_psla)
#define cli_Shape					(cli_pwgi | cli_psva | cli_pcluster)
#define cli_Place					(cli_pidx | cli_pgoffset)
#define cli_ShapePlace				(cli_Shape | cli_Place)



#ifndef LOCALE_SNATIVEDIGITS
#define LOCALE_SNATIVEDIGITS		0x00000013
#endif



/////   LANG
//
//      The following defines are temporary - they will be removed once they
//      have been added to the standard NLS header files.


#ifndef LANG_BURMESE
#define LANG_BURMESE     			0x55       // Myanmar
#endif
#ifndef LANG_KHMER
#define LANG_KHMER       			0x53       // Cambodia
#endif
#ifndef LANG_LAO
#define LANG_LAO         			0x54       // Lao
#endif
#ifndef LANG_MONGOLIAN
#define LANG_MONGOLIAN   			0x50       // Mongolia
#endif
#ifndef LANG_TIBETAN
#define LANG_TIBETAN     			0x51       // Tibet
#endif
#ifndef LANG_URDU
#define LANG_URDU        			0x20       // India / Pakistan
#endif



//
// Memory block will contain USPCLIENT -the table of ptrs, as a memory block's header
// followed by subtables then requested data blocks. All things tie together as a
// contiguous data area so client can free the whole thing in one shot.
//


// SI subtable
//
typedef struct tagUSP_CLIENT_SI
{
	//
	// ScriptItemize's
	//
	WCHAR*          pwchString;
	int             cchString;
	SCRIPT_ITEM*    psi;
} USP_CLIENT_SI, *PUSP_CLIENT_SI;

// SB subtable
//
typedef struct tagUSP_CLIENT_SB
{
	//
	// ScriptBreak's
	//
	SCRIPT_LOGATTR* psla;
} USP_CLIENT_SB, *PUSP_CLIENT_SB;

// SS & SP subtable
typedef struct tagUSP_CLIENT_SSP
{
	//
	// ScriptShape's
	//
	WORD*			pwgi;
	WORD*			pcluster;
	SCRIPT_VISATTR*	psva;

	//
	// ScriptPlace's
	//
	int*			pidx;
	GOFFSET*		pgoffset;
} USP_CLIENT_SSP, *PUSP_CLIENT_SSP;


// header (root) table
//
typedef struct tagUSP_CLIENT
{
	PUSP_CLIENT_SI  si;
	PUSP_CLIENT_SB  sb;
	PUSP_CLIENT_SSP	ssp;
} USP_CLIENT, *PUSP_CLIENT;



// buffer request structure
//
typedef struct tagBUF_REQ
{
	int             size;	// size of requested element
	int             c;		// count of requested element
	PVOID*          ppv;	// ref to ptr of requested buffer
} BUF_REQ;


typedef enum
{
	DIGITS_NOTIMPL = 0,
	DIGITS_CTX,
	DIGITS_NONE,
	DIGITS_NATIONAL
} DIGITSHAPE;


#define		IsCS(x)				(BOOL)((x)==U_COMMA || (x)==U_PERIOD || (x)==U_COLON)


// CUniscribe's internal buffer request flag
//
#define 	igb_Glyph			1
#define 	igb_VisAttr			2
#define 	igb_Pidx			4



// LS Callback's static return buffer
#define 	celAdvance			32

class CBufferBase
{
public:
	CBufferBase(int cbElem) { _cbElem = cbElem; }
	void*	GetPtr(int cel);
	void	Release();
protected:
	void*	_p;
	int		_cElem;
	int		_cbElem;
};

template <class ELEM>
class CBuffer : public CBufferBase
{
public:
	CBuffer() : CBufferBase(sizeof(ELEM)) {}
	~CBuffer() { Release(); }
	ELEM*	Get(int cel) { return (ELEM*)GetPtr(cel); }
};


///////	Uniscribe interface object class
// 		
//

BOOL	IsSupportedOS();

class CUniscribe
{
public:
	CUniscribe();
	~CUniscribe();

	WORD	ApplyDigitSubstitution (BYTE bDigitSubstMode);

	// public helper functions
	//

	const   SCRIPT_PROPERTIES*  GeteProp (WORD eScript);
	const   CBiDiFSM*           GetFSM ();


	BOOL    CreateClientStruc (BYTE* pbBufIn, LONG cbBufIn, PUSP_CLIENT* ppc, LONG cchString, DWORD dwMask);
	void	SubstituteDigitShaper (PLSRUN plsrun, CMeasurer* pme);


	inline BOOL CacheAllocGlyphBuffers(int cch, int& cGlyphs, WORD*& pwgi, SCRIPT_VISATTR*& psva)
	{
		cGlyphs = GLYPH_COUNT(cch);
		return (pwgi = GetGlyphBuffer(cGlyphs)) && (psva = GetVABuffer(cGlyphs));
	}


	inline BOOL IsValid()
	{
		return TRUE;
	}


	BOOL	GetComplexCharSet(const SCRIPT_PROPERTIES* psp, BYTE bCharSetDefault, BYTE& bCharSetOut);
	BYTE	GetRtlCharSet(CTxtEdit* ped);


	// higher level services
	//
	int     ItemizeString (USP_CLIENT* pc, WORD uInitLevel, int* pcItems, WCHAR* pwchString, int cch,
						   BOOL fUnicodeBidi, WORD wLangId = LANG_NEUTRAL);
	int     ShapeString (PLSRUN plsrun, SCRIPT_ANALYSIS* psa, CMeasurer* pme, const WCHAR* pwch, int cch,
						 WORD*& pwgi, WORD* pwlc, SCRIPT_VISATTR*& psva);
	int     PlaceString (PLSRUN plsrun, SCRIPT_ANALYSIS* psa, CMeasurer* pme, const WORD* pcwgi, int cgi,
						 const SCRIPT_VISATTR* psva, int* pgdx, GOFFSET* pgduv, ABC* pABC);
	int		PlaceMetafileString (PLSRUN plsrun, CMeasurer* pme, const WCHAR* pwch, int cch, PINT* ppiDx);

private:


	// private helper functions
	//
	HDC     PrepareShapeDC (CMeasurer* pme, HRESULT hrReq, HFONT& hOrgFont);
	BYTE	GetCDMCharSet(BYTE bCharSetDefault);
	DWORD	GetNationalDigitLanguage(LCID lcid);

	// get callback static buffers
	//
	SCRIPT_VISATTR*	GetVABuffer(int cel) { return _rgva.Get(cel); }
	WORD*			GetGlyphBuffer(int cel) { return _rgglyph.Get(cel); }
	int*			GetWidthBuffer(int cel) { return _rgwidth.Get(cel); }



	// LS callback (static) buffers
	//
	CBuffer<WORD>						_rgglyph;
	CBuffer<int>						_rgwidth;
	CBuffer<SCRIPT_VISATTR>				_rgva;

	// pointer to BidiLevel Finite State Machine
	CBiDiFSM*                           _pFSM;

	// pointer to script properties resource table
	const SCRIPT_PROPERTIES**           _ppProp;

	WORD								_wesNationalDigit;	// National digit script ID
	BYTE								_bCharSetRtl;		// Right to left charset to use
	BYTE								_bCharSetCDM;		// CDM charset to use
};

extern CUniscribe*      g_pusp;
extern int				g_cMaxScript;		// Maximum number of script produced by Uniscribe

// Virtual script ID
#define	SCRIPT_MAX_COUNT	((WORD)g_cMaxScript)
#define	SCRIPT_WHITE		SCRIPT_MAX_COUNT + 1



///////	Bidi Finite State Machine class
// 		
//		(detail: bidifsm2.html)
//
//		Revise: 12-28-98 (wchao)
//

// inputs class:
#define 	NUM_FSM_INPUTS		5
typedef enum
{
	chLTR = 0,
	chRTL,
	digitLTR,
	digitRTL,
	chGround					// Neutralize current level down to initial level
} INPUT_CLASS;

// states:
#define		NUM_FSM_STATES		6
typedef enum
{
	S_A = 0,
	S_B,
	S_C,
	S_X,
	S_Y,
	S_Z
} STATES;


class CBiDiFSMCell
{
public:
	CBiDiLevel	_level;			// BiDi level
	USHORT  	_uNext;			// Offset to the next state relative to FSM start
};


class CBiDiFSM
{
public:
	CBiDiFSM (CUniscribe* pusp) { _pusp = pusp; }
	~CBiDiFSM ();

	BOOL                Init (void);
	INPUT_CLASS         InputClass (const CCharFormat* pcCF, CTxtPtr* ptp, LONG cchRun) const;
	HRESULT             RunFSM (CRchTxtPtr* prtp, LONG cRuns, LONG cRunsStart, BYTE bBaseLevel) const;

	inline void			SetFSMCell (CBiDiFSMCell* pCell, CBiDiLevel* pLevel, USHORT uNext)
	{
		pCell->_level	= *pLevel;
		pCell->_uNext	= uNext;
	}


private:
	short               _nState;		// number of state
	short               _nInput;		// number of input class
	CUniscribe*         _pusp;			// Uniscribe obj associated with
	CBiDiFSMCell*       _pStart;		// start FSM
};

#endif		// _USPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re32wrap\wrapper.h ===
#ifndef _WRAPPER_H_
#define _WRAPPER_H_
#include <windows.h>

#define RICHEDIT_CLASS10A   "RICHEDIT"          // Richedit 1.0

extern "C"
{
LRESULT CALLBACK RichEdit32WndProc(
    HWND hWnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam);
}


WNDPROC lpfnRichEditANSIWndProc;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re32wrap\wrapinit.cpp ===
#include "wrapper.h"

HINSTANCE hinstRE32 = 0;
static const char szClassRE10A[] = RICHEDIT_CLASS10A;

class   CTxtEdit;

extern "C"
{

__declspec(dllimport) LRESULT CALLBACK RichEdit10ANSIWndProc(HWND, UINT, WPARAM, LPARAM);

BOOL WINAPI DllMain(HMODULE hmod, DWORD dwReason, LPVOID lpvReserved)
{
    if(dwReason == DLL_PROCESS_DETACH)
    {
        UnregisterClassA(szClassRE10A, hinstRE32);
    }
    else if(dwReason == DLL_PROCESS_ATTACH) // We have just loaded
    {
        WNDCLASSA wca;

        hinstRE32 = hmod;

        wca.style = CS_DBLCLKS | CS_GLOBALCLASS | CS_PARENTDC;
        wca.lpfnWndProc = RichEdit10ANSIWndProc;
        wca.cbClsExtra = 0;
        wca.cbWndExtra = sizeof(CTxtEdit FAR *);
        wca.hInstance = hinstRE32;
        wca.hIcon = 0;
        wca.hCursor = 0;
        wca.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
        wca.lpszMenuName = NULL;
        wca.lpszClassName = szClassRE10A;

        //
        //  Register the RICHEDIT 10 class.
        //

        if( !RegisterClassA(&wca) )
        {
            return FALSE;
        }
    }

    return TRUE;
}

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\aimmex.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for aimmex.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __aimmex_h__
#define __aimmex_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IActiveIMMAppEx_FWD_DEFINED__
#define __IActiveIMMAppEx_FWD_DEFINED__
typedef interface IActiveIMMAppEx IActiveIMMAppEx;
#endif 	/* __IActiveIMMAppEx_FWD_DEFINED__ */


#ifndef __IAImmFnDocFeed_FWD_DEFINED__
#define __IAImmFnDocFeed_FWD_DEFINED__
typedef interface IAImmFnDocFeed IAImmFnDocFeed;
#endif 	/* __IAImmFnDocFeed_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"
#include "msctf.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_aimmex_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// aimmex.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// IActiveIMMEx Interfaces.



extern RPC_IF_HANDLE __MIDL_itf_aimmex_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_aimmex_0000_v0_0_s_ifspec;

#ifndef __IActiveIMMAppEx_INTERFACE_DEFINED__
#define __IActiveIMMAppEx_INTERFACE_DEFINED__

/* interface IActiveIMMAppEx */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IActiveIMMAppEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D7A6F58A-D478-44ab-86C9-591C23A26534")
    IActiveIMMAppEx : public IActiveIMMApp
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FilterClientWindowsEx( 
            /* [in] */ HWND hWnd,
            /* [in] */ BOOL fGuidMap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FilterClientWindowsGUIDMap( 
            /* [in] */ ATOM *aaClassList,
            /* [in] */ UINT uSize,
            /* [in] */ BOOL *aaGildMap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuidAtom( 
            /* [in] */ HIMC hImc,
            /* [in] */ BYTE bAttr,
            /* [out] */ TfGuidAtom *pGuidAtom) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnfilterClientWindowsEx( 
            /* [in] */ HWND hWnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMAppExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIMMAppEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIMMAppEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIMMAppEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContext )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC *phPrev);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA *pData);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW *pData);
        
        HRESULT ( STDMETHODCALLTYPE *CreateContext )( 
            IActiveIMMAppEx * This,
            /* [out] */ HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyContext )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIME);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateWindow )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionWindow )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionStatus )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pfdwConversion,
            /* [out] */ DWORD *pfdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultIMEWnd )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HWND *phDefWnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpenStatus )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD *pdwProperty);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA *pStyleBuf,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW *pStyleBuf,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatusWindowPos )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *GetVirtualKey )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [out] */ UINT *puVirtualKey);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEA )( 
            IActiveIMMAppEx * This,
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEW )( 
            IActiveIMMAppEx * This,
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsIME )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyIME )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseContext )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *SetCandidateWindow )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionWindow )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *SetConversionStatus )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpenStatus )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatusWindowPos )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *SimulateHotKey )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            IActiveIMMAppEx * This,
            /* [in] */ BOOL fRestoreLayout);
        
        HRESULT ( STDMETHODCALLTYPE *Deactivate )( 
            IActiveIMMAppEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnDefWindowProc )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *FilterClientWindows )( 
            IActiveIMMAppEx * This,
            /* [in] */ ATOM *aaClassList,
            /* [in] */ UINT uSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodePageA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [out] */ UINT *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLangId )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [out] */ LANGID *plid);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContextEx )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DisableIME )( 
            IActiveIMMAppEx * This,
            /* [in] */ DWORD idThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOA *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOA *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOW *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOW *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *EnumInputContext )( 
            IActiveIMMAppEx * This,
            /* [in] */ DWORD idThread,
            /* [out] */ IEnumInputContext **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *FilterClientWindowsEx )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [in] */ BOOL fGuidMap);
        
        HRESULT ( STDMETHODCALLTYPE *FilterClientWindowsGUIDMap )( 
            IActiveIMMAppEx * This,
            /* [in] */ ATOM *aaClassList,
            /* [in] */ UINT uSize,
            /* [in] */ BOOL *aaGildMap);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuidAtom )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hImc,
            /* [in] */ BYTE bAttr,
            /* [out] */ TfGuidAtom *pGuidAtom);
        
        HRESULT ( STDMETHODCALLTYPE *UnfilterClientWindowsEx )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd);
        
        END_INTERFACE
    } IActiveIMMAppExVtbl;

    interface IActiveIMMAppEx
    {
        CONST_VTBL struct IActiveIMMAppExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMAppEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIMMAppEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIMMAppEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIMMAppEx_AssociateContext(This,hWnd,hIME,phPrev)	\
    (This)->lpVtbl -> AssociateContext(This,hWnd,hIME,phPrev)

#define IActiveIMMAppEx_ConfigureIMEA(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEA(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMAppEx_ConfigureIMEW(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEW(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMAppEx_CreateContext(This,phIMC)	\
    (This)->lpVtbl -> CreateContext(This,phIMC)

#define IActiveIMMAppEx_DestroyContext(This,hIME)	\
    (This)->lpVtbl -> DestroyContext(This,hIME)

#define IActiveIMMAppEx_EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMAppEx_EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMAppEx_EscapeA(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeA(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMAppEx_EscapeW(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeW(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMAppEx_GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMAppEx_GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMAppEx_GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMAppEx_GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMAppEx_GetCandidateWindow(This,hIMC,dwIndex,pCandidate)	\
    (This)->lpVtbl -> GetCandidateWindow(This,hIMC,dwIndex,pCandidate)

#define IActiveIMMAppEx_GetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontA(This,hIMC,plf)

#define IActiveIMMAppEx_GetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontW(This,hIMC,plf)

#define IActiveIMMAppEx_GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMAppEx_GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMAppEx_GetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> GetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMAppEx_GetContext(This,hWnd,phIMC)	\
    (This)->lpVtbl -> GetContext(This,hWnd,phIMC)

#define IActiveIMMAppEx_GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMAppEx_GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMAppEx_GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)	\
    (This)->lpVtbl -> GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)

#define IActiveIMMAppEx_GetDefaultIMEWnd(This,hWnd,phDefWnd)	\
    (This)->lpVtbl -> GetDefaultIMEWnd(This,hWnd,phDefWnd)

#define IActiveIMMAppEx_GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMAppEx_GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMAppEx_GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMAppEx_GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMAppEx_GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMAppEx_GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMAppEx_GetOpenStatus(This,hIMC)	\
    (This)->lpVtbl -> GetOpenStatus(This,hIMC)

#define IActiveIMMAppEx_GetProperty(This,hKL,fdwIndex,pdwProperty)	\
    (This)->lpVtbl -> GetProperty(This,hKL,fdwIndex,pdwProperty)

#define IActiveIMMAppEx_GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMAppEx_GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMAppEx_GetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> GetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMAppEx_GetVirtualKey(This,hWnd,puVirtualKey)	\
    (This)->lpVtbl -> GetVirtualKey(This,hWnd,puVirtualKey)

#define IActiveIMMAppEx_InstallIMEA(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEA(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMAppEx_InstallIMEW(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEW(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMAppEx_IsIME(This,hKL)	\
    (This)->lpVtbl -> IsIME(This,hKL)

#define IActiveIMMAppEx_IsUIMessageA(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageA(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMAppEx_IsUIMessageW(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageW(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMAppEx_NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)	\
    (This)->lpVtbl -> NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)

#define IActiveIMMAppEx_RegisterWordA(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordA(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMAppEx_RegisterWordW(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordW(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMAppEx_ReleaseContext(This,hWnd,hIMC)	\
    (This)->lpVtbl -> ReleaseContext(This,hWnd,hIMC)

#define IActiveIMMAppEx_SetCandidateWindow(This,hIMC,pCandidate)	\
    (This)->lpVtbl -> SetCandidateWindow(This,hIMC,pCandidate)

#define IActiveIMMAppEx_SetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontA(This,hIMC,plf)

#define IActiveIMMAppEx_SetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontW(This,hIMC,plf)

#define IActiveIMMAppEx_SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMAppEx_SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMAppEx_SetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> SetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMAppEx_SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)	\
    (This)->lpVtbl -> SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)

#define IActiveIMMAppEx_SetOpenStatus(This,hIMC,fOpen)	\
    (This)->lpVtbl -> SetOpenStatus(This,hIMC,fOpen)

#define IActiveIMMAppEx_SetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> SetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMAppEx_SimulateHotKey(This,hWnd,dwHotKeyID)	\
    (This)->lpVtbl -> SimulateHotKey(This,hWnd,dwHotKeyID)

#define IActiveIMMAppEx_UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMAppEx_UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMAppEx_Activate(This,fRestoreLayout)	\
    (This)->lpVtbl -> Activate(This,fRestoreLayout)

#define IActiveIMMAppEx_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#define IActiveIMMAppEx_OnDefWindowProc(This,hWnd,Msg,wParam,lParam,plResult)	\
    (This)->lpVtbl -> OnDefWindowProc(This,hWnd,Msg,wParam,lParam,plResult)

#define IActiveIMMAppEx_FilterClientWindows(This,aaClassList,uSize)	\
    (This)->lpVtbl -> FilterClientWindows(This,aaClassList,uSize)

#define IActiveIMMAppEx_GetCodePageA(This,hKL,uCodePage)	\
    (This)->lpVtbl -> GetCodePageA(This,hKL,uCodePage)

#define IActiveIMMAppEx_GetLangId(This,hKL,plid)	\
    (This)->lpVtbl -> GetLangId(This,hKL,plid)

#define IActiveIMMAppEx_AssociateContextEx(This,hWnd,hIMC,dwFlags)	\
    (This)->lpVtbl -> AssociateContextEx(This,hWnd,hIMC,dwFlags)

#define IActiveIMMAppEx_DisableIME(This,idThread)	\
    (This)->lpVtbl -> DisableIME(This,idThread)

#define IActiveIMMAppEx_GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    (This)->lpVtbl -> GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)

#define IActiveIMMAppEx_GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    (This)->lpVtbl -> GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)

#define IActiveIMMAppEx_EnumInputContext(This,idThread,ppEnum)	\
    (This)->lpVtbl -> EnumInputContext(This,idThread,ppEnum)


#define IActiveIMMAppEx_FilterClientWindowsEx(This,hWnd,fGuidMap)	\
    (This)->lpVtbl -> FilterClientWindowsEx(This,hWnd,fGuidMap)

#define IActiveIMMAppEx_FilterClientWindowsGUIDMap(This,aaClassList,uSize,aaGildMap)	\
    (This)->lpVtbl -> FilterClientWindowsGUIDMap(This,aaClassList,uSize,aaGildMap)

#define IActiveIMMAppEx_GetGuidAtom(This,hImc,bAttr,pGuidAtom)	\
    (This)->lpVtbl -> GetGuidAtom(This,hImc,bAttr,pGuidAtom)

#define IActiveIMMAppEx_UnfilterClientWindowsEx(This,hWnd)	\
    (This)->lpVtbl -> UnfilterClientWindowsEx(This,hWnd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIMMAppEx_FilterClientWindowsEx_Proxy( 
    IActiveIMMAppEx * This,
    /* [in] */ HWND hWnd,
    /* [in] */ BOOL fGuidMap);


void __RPC_STUB IActiveIMMAppEx_FilterClientWindowsEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMAppEx_FilterClientWindowsGUIDMap_Proxy( 
    IActiveIMMAppEx * This,
    /* [in] */ ATOM *aaClassList,
    /* [in] */ UINT uSize,
    /* [in] */ BOOL *aaGildMap);


void __RPC_STUB IActiveIMMAppEx_FilterClientWindowsGUIDMap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMAppEx_GetGuidAtom_Proxy( 
    IActiveIMMAppEx * This,
    /* [in] */ HIMC hImc,
    /* [in] */ BYTE bAttr,
    /* [out] */ TfGuidAtom *pGuidAtom);


void __RPC_STUB IActiveIMMAppEx_GetGuidAtom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMAppEx_UnfilterClientWindowsEx_Proxy( 
    IActiveIMMAppEx * This,
    /* [in] */ HWND hWnd);


void __RPC_STUB IActiveIMMAppEx_UnfilterClientWindowsEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIMMAppEx_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_aimmex_0221 */
/* [local] */ 

EXTERN_C const CLSID CLSID_CAImmLayer;


extern RPC_IF_HANDLE __MIDL_itf_aimmex_0221_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_aimmex_0221_v0_0_s_ifspec;

#ifndef __IAImmFnDocFeed_INTERFACE_DEFINED__
#define __IAImmFnDocFeed_INTERFACE_DEFINED__

/* interface IAImmFnDocFeed */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAImmFnDocFeed;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6e098993-9577-499a-a830-52344f3e200d")
    IAImmFnDocFeed : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DocFeed( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearDocFeedBuffer( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartReconvert( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartUndoCompositionString( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAImmFnDocFeedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAImmFnDocFeed * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAImmFnDocFeed * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAImmFnDocFeed * This);
        
        HRESULT ( STDMETHODCALLTYPE *DocFeed )( 
            IAImmFnDocFeed * This);
        
        HRESULT ( STDMETHODCALLTYPE *ClearDocFeedBuffer )( 
            IAImmFnDocFeed * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartReconvert )( 
            IAImmFnDocFeed * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartUndoCompositionString )( 
            IAImmFnDocFeed * This);
        
        END_INTERFACE
    } IAImmFnDocFeedVtbl;

    interface IAImmFnDocFeed
    {
        CONST_VTBL struct IAImmFnDocFeedVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAImmFnDocFeed_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAImmFnDocFeed_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAImmFnDocFeed_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAImmFnDocFeed_DocFeed(This)	\
    (This)->lpVtbl -> DocFeed(This)

#define IAImmFnDocFeed_ClearDocFeedBuffer(This)	\
    (This)->lpVtbl -> ClearDocFeedBuffer(This)

#define IAImmFnDocFeed_StartReconvert(This)	\
    (This)->lpVtbl -> StartReconvert(This)

#define IAImmFnDocFeed_StartUndoCompositionString(This)	\
    (This)->lpVtbl -> StartUndoCompositionString(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAImmFnDocFeed_DocFeed_Proxy( 
    IAImmFnDocFeed * This);


void __RPC_STUB IAImmFnDocFeed_DocFeed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAImmFnDocFeed_ClearDocFeedBuffer_Proxy( 
    IAImmFnDocFeed * This);


void __RPC_STUB IAImmFnDocFeed_ClearDocFeedBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAImmFnDocFeed_StartReconvert_Proxy( 
    IAImmFnDocFeed * This);


void __RPC_STUB IAImmFnDocFeed_StartReconvert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAImmFnDocFeed_StartUndoCompositionString_Proxy( 
    IAImmFnDocFeed * This);


void __RPC_STUB IAImmFnDocFeed_StartUndoCompositionString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAImmFnDocFeed_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\aimm.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for aimm.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __aimm_h__
#define __aimm_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IEnumRegisterWordA_FWD_DEFINED__
#define __IEnumRegisterWordA_FWD_DEFINED__
typedef interface IEnumRegisterWordA IEnumRegisterWordA;
#endif 	/* __IEnumRegisterWordA_FWD_DEFINED__ */


#ifndef __IEnumRegisterWordW_FWD_DEFINED__
#define __IEnumRegisterWordW_FWD_DEFINED__
typedef interface IEnumRegisterWordW IEnumRegisterWordW;
#endif 	/* __IEnumRegisterWordW_FWD_DEFINED__ */


#ifndef __IEnumInputContext_FWD_DEFINED__
#define __IEnumInputContext_FWD_DEFINED__
typedef interface IEnumInputContext IEnumInputContext;
#endif 	/* __IEnumInputContext_FWD_DEFINED__ */


#ifndef __IActiveIMMRegistrar_FWD_DEFINED__
#define __IActiveIMMRegistrar_FWD_DEFINED__
typedef interface IActiveIMMRegistrar IActiveIMMRegistrar;
#endif 	/* __IActiveIMMRegistrar_FWD_DEFINED__ */


#ifndef __IActiveIMMMessagePumpOwner_FWD_DEFINED__
#define __IActiveIMMMessagePumpOwner_FWD_DEFINED__
typedef interface IActiveIMMMessagePumpOwner IActiveIMMMessagePumpOwner;
#endif 	/* __IActiveIMMMessagePumpOwner_FWD_DEFINED__ */


#ifndef __IActiveIMMApp_FWD_DEFINED__
#define __IActiveIMMApp_FWD_DEFINED__
typedef interface IActiveIMMApp IActiveIMMApp;
#endif 	/* __IActiveIMMApp_FWD_DEFINED__ */


#ifndef __IActiveIMMIME_FWD_DEFINED__
#define __IActiveIMMIME_FWD_DEFINED__
typedef interface IActiveIMMIME IActiveIMMIME;
#endif 	/* __IActiveIMMIME_FWD_DEFINED__ */


#ifndef __IActiveIME_FWD_DEFINED__
#define __IActiveIME_FWD_DEFINED__
typedef interface IActiveIME IActiveIME;
#endif 	/* __IActiveIME_FWD_DEFINED__ */


#ifndef __IActiveIME2_FWD_DEFINED__
#define __IActiveIME2_FWD_DEFINED__
typedef interface IActiveIME2 IActiveIME2;
#endif 	/* __IActiveIME2_FWD_DEFINED__ */


#ifndef __CActiveIMM_FWD_DEFINED__
#define __CActiveIMM_FWD_DEFINED__

#ifdef __cplusplus
typedef class CActiveIMM CActiveIMM;
#else
typedef struct CActiveIMM CActiveIMM;
#endif /* __cplusplus */

#endif 	/* __CActiveIMM_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_aimm_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// aimm.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// IActiveIMM Interfaces.




extern RPC_IF_HANDLE __MIDL_itf_aimm_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_aimm_0000_v0_0_s_ifspec;


#ifndef __ActiveIMM_LIBRARY_DEFINED__
#define __ActiveIMM_LIBRARY_DEFINED__

/* library ActiveIMM */
/* [version][lcid][helpstring][uuid] */ 

#ifndef _IMM_
#error Must include imm.h!
#endif
#if 0
typedef WORD LANGID;

typedef /* [public][public][public][public] */ struct __MIDL___MIDL_itf_aimm_0000_0001
    {
    LPSTR lpReading;
    LPSTR lpWord;
    } 	REGISTERWORDA;

typedef /* [public][public][public][public][public] */ struct __MIDL___MIDL_itf_aimm_0000_0002
    {
    LPWSTR lpReading;
    LPWSTR lpWord;
    } 	REGISTERWORDW;

typedef /* [public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_aimm_0000_0003
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    CHAR lfFaceName[ 32 ];
    } 	LOGFONTA;

typedef /* [public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_aimm_0000_0004
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    WCHAR lfFaceName[ 32 ];
    } 	LOGFONTW;

typedef DWORD HIMC;

typedef DWORD HIMCC;

typedef /* [public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_aimm_0000_0005
    {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT rcArea;
    } 	CANDIDATEFORM;

typedef /* [public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_aimm_0000_0006
    {
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT rcArea;
    } 	COMPOSITIONFORM;

typedef /* [public][public][public][public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_aimm_0000_0007
    {
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD dwOffset[ 1 ];
    } 	CANDIDATELIST;

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_aimm_0000_0008
    {
    DWORD dwStyle;
    CHAR szDescription[ 32 ];
    } 	STYLEBUFA;

typedef /* [public][public][public][public] */ struct __MIDL___MIDL_itf_aimm_0000_0009
    {
    DWORD dwStyle;
    WCHAR szDescription[ 32 ];
    } 	STYLEBUFW;

typedef WORD ATOM;

typedef /* [public][public][public][public][public] */ struct __MIDL___MIDL_itf_aimm_0000_0010
    {
    UINT cbSize;
    UINT fType;
    UINT fState;
    UINT wID;
    HBITMAP hbmpChecked;
    HBITMAP hbmpUnchecked;
    DWORD dwItemData;
    CHAR szString[ 80 ];
    HBITMAP hbmpItem;
    } 	IMEMENUITEMINFOA;

typedef /* [public][public][public][public][public] */ struct __MIDL___MIDL_itf_aimm_0000_0011
    {
    UINT cbSize;
    UINT fType;
    UINT fState;
    UINT wID;
    HBITMAP hbmpChecked;
    HBITMAP hbmpUnchecked;
    DWORD dwItemData;
    WCHAR szString[ 80 ];
    HBITMAP hbmpItem;
    } 	IMEMENUITEMINFOW;

#endif
#ifndef _DDKIMM_H_
typedef /* [public][public] */ struct __MIDL___MIDL_itf_aimm_0000_0012
    {
    HWND hWnd;
    BOOL fOpen;
    POINT ptStatusWndPos;
    POINT ptSoftKbdPos;
    DWORD fdwConversion;
    DWORD fdwSentence;
    union 
        {
        LOGFONTA A;
        LOGFONTW W;
        } 	lfFont;
    COMPOSITIONFORM cfCompForm;
    CANDIDATEFORM cfCandForm[ 4 ];
    HIMCC hCompStr;
    HIMCC hCandInfo;
    HIMCC hGuideLine;
    HIMCC hPrivate;
    DWORD dwNumMsgBuf;
    HIMCC hMsgBuf;
    DWORD fdwInit;
    DWORD dwReserve[ 3 ];
    } 	INPUTCONTEXT;

typedef /* [public][public] */ struct __MIDL___MIDL_itf_aimm_0000_0014
    {
    DWORD dwPrivateDataSize;
    DWORD fdwProperty;
    DWORD fdwConversionCaps;
    DWORD fdwSentenceCaps;
    DWORD fdwUICaps;
    DWORD fdwSCSCaps;
    DWORD fdwSelectCaps;
    } 	IMEINFO;

#endif

EXTERN_C const IID LIBID_ActiveIMM;

#ifndef __IEnumRegisterWordA_INTERFACE_DEFINED__
#define __IEnumRegisterWordA_INTERFACE_DEFINED__

/* interface IEnumRegisterWordA */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumRegisterWordA;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08C03412-F96B-11d0-A475-00AA006BCC59")
    IEnumRegisterWordA : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumRegisterWordA **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDA *rgRegisterWord,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRegisterWordAVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumRegisterWordA * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumRegisterWordA * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumRegisterWordA * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumRegisterWordA * This,
            /* [out] */ IEnumRegisterWordA **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumRegisterWordA * This,
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDA *rgRegisterWord,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumRegisterWordA * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumRegisterWordA * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumRegisterWordAVtbl;

    interface IEnumRegisterWordA
    {
        CONST_VTBL struct IEnumRegisterWordAVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRegisterWordA_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRegisterWordA_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRegisterWordA_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRegisterWordA_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRegisterWordA_Next(This,ulCount,rgRegisterWord,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgRegisterWord,pcFetched)

#define IEnumRegisterWordA_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRegisterWordA_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Clone_Proxy( 
    IEnumRegisterWordA * This,
    /* [out] */ IEnumRegisterWordA **ppEnum);


void __RPC_STUB IEnumRegisterWordA_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Next_Proxy( 
    IEnumRegisterWordA * This,
    /* [in] */ ULONG ulCount,
    /* [out] */ REGISTERWORDA *rgRegisterWord,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumRegisterWordA_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Reset_Proxy( 
    IEnumRegisterWordA * This);


void __RPC_STUB IEnumRegisterWordA_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Skip_Proxy( 
    IEnumRegisterWordA * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumRegisterWordA_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRegisterWordA_INTERFACE_DEFINED__ */


#ifndef __IEnumRegisterWordW_INTERFACE_DEFINED__
#define __IEnumRegisterWordW_INTERFACE_DEFINED__

/* interface IEnumRegisterWordW */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumRegisterWordW;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4955DD31-B159-11d0-8FCF-00AA006BCC59")
    IEnumRegisterWordW : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumRegisterWordW **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDW *rgRegisterWord,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRegisterWordWVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumRegisterWordW * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumRegisterWordW * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumRegisterWordW * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumRegisterWordW * This,
            /* [out] */ IEnumRegisterWordW **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumRegisterWordW * This,
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDW *rgRegisterWord,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumRegisterWordW * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumRegisterWordW * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumRegisterWordWVtbl;

    interface IEnumRegisterWordW
    {
        CONST_VTBL struct IEnumRegisterWordWVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRegisterWordW_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRegisterWordW_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRegisterWordW_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRegisterWordW_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRegisterWordW_Next(This,ulCount,rgRegisterWord,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgRegisterWord,pcFetched)

#define IEnumRegisterWordW_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRegisterWordW_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Clone_Proxy( 
    IEnumRegisterWordW * This,
    /* [out] */ IEnumRegisterWordW **ppEnum);


void __RPC_STUB IEnumRegisterWordW_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Next_Proxy( 
    IEnumRegisterWordW * This,
    /* [in] */ ULONG ulCount,
    /* [out] */ REGISTERWORDW *rgRegisterWord,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumRegisterWordW_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Reset_Proxy( 
    IEnumRegisterWordW * This);


void __RPC_STUB IEnumRegisterWordW_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Skip_Proxy( 
    IEnumRegisterWordW * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumRegisterWordW_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRegisterWordW_INTERFACE_DEFINED__ */


#ifndef __IEnumInputContext_INTERFACE_DEFINED__
#define __IEnumInputContext_INTERFACE_DEFINED__

/* interface IEnumInputContext */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumInputContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("09b5eab0-f997-11d1-93d4-0060b067b86e")
    IEnumInputContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumInputContext **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [out] */ HIMC *rgInputContext,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumInputContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumInputContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumInputContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumInputContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumInputContext * This,
            /* [out] */ IEnumInputContext **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumInputContext * This,
            /* [in] */ ULONG ulCount,
            /* [out] */ HIMC *rgInputContext,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumInputContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumInputContext * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumInputContextVtbl;

    interface IEnumInputContext
    {
        CONST_VTBL struct IEnumInputContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumInputContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumInputContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumInputContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumInputContext_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumInputContext_Next(This,ulCount,rgInputContext,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgInputContext,pcFetched)

#define IEnumInputContext_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumInputContext_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumInputContext_Clone_Proxy( 
    IEnumInputContext * This,
    /* [out] */ IEnumInputContext **ppEnum);


void __RPC_STUB IEnumInputContext_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumInputContext_Next_Proxy( 
    IEnumInputContext * This,
    /* [in] */ ULONG ulCount,
    /* [out] */ HIMC *rgInputContext,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumInputContext_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumInputContext_Reset_Proxy( 
    IEnumInputContext * This);


void __RPC_STUB IEnumInputContext_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumInputContext_Skip_Proxy( 
    IEnumInputContext * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumInputContext_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumInputContext_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMRegistrar_INTERFACE_DEFINED__
#define __IActiveIMMRegistrar_INTERFACE_DEFINED__

/* interface IActiveIMMRegistrar */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIMMRegistrar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b3458082-bd00-11d1-939b-0060b067b86e")
    IActiveIMMRegistrar : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterIME( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID lgid,
            /* [in] */ LPCWSTR pszIconFile,
            /* [in] */ LPCWSTR pszDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterIME( 
            /* [in] */ REFCLSID rclsid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMRegistrarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIMMRegistrar * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIMMRegistrar * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIMMRegistrar * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterIME )( 
            IActiveIMMRegistrar * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID lgid,
            /* [in] */ LPCWSTR pszIconFile,
            /* [in] */ LPCWSTR pszDesc);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterIME )( 
            IActiveIMMRegistrar * This,
            /* [in] */ REFCLSID rclsid);
        
        END_INTERFACE
    } IActiveIMMRegistrarVtbl;

    interface IActiveIMMRegistrar
    {
        CONST_VTBL struct IActiveIMMRegistrarVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMRegistrar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIMMRegistrar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIMMRegistrar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIMMRegistrar_RegisterIME(This,rclsid,lgid,pszIconFile,pszDesc)	\
    (This)->lpVtbl -> RegisterIME(This,rclsid,lgid,pszIconFile,pszDesc)

#define IActiveIMMRegistrar_UnregisterIME(This,rclsid)	\
    (This)->lpVtbl -> UnregisterIME(This,rclsid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIMMRegistrar_RegisterIME_Proxy( 
    IActiveIMMRegistrar * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ LANGID lgid,
    /* [in] */ LPCWSTR pszIconFile,
    /* [in] */ LPCWSTR pszDesc);


void __RPC_STUB IActiveIMMRegistrar_RegisterIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMRegistrar_UnregisterIME_Proxy( 
    IActiveIMMRegistrar * This,
    /* [in] */ REFCLSID rclsid);


void __RPC_STUB IActiveIMMRegistrar_UnregisterIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIMMRegistrar_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMMessagePumpOwner_INTERFACE_DEFINED__
#define __IActiveIMMMessagePumpOwner_INTERFACE_DEFINED__

/* interface IActiveIMMMessagePumpOwner */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIMMMessagePumpOwner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b5cf2cfa-8aeb-11d1-9364-0060b067b86e")
    IActiveIMMMessagePumpOwner : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE End( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTranslateMessage( 
            /* [in] */ const MSG *pMsg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( 
            /* [out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMMessagePumpOwnerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIMMMessagePumpOwner * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIMMMessagePumpOwner * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIMMMessagePumpOwner * This);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IActiveIMMMessagePumpOwner * This);
        
        HRESULT ( STDMETHODCALLTYPE *End )( 
            IActiveIMMMessagePumpOwner * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnTranslateMessage )( 
            IActiveIMMMessagePumpOwner * This,
            /* [in] */ const MSG *pMsg);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IActiveIMMMessagePumpOwner * This,
            /* [out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IActiveIMMMessagePumpOwner * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } IActiveIMMMessagePumpOwnerVtbl;

    interface IActiveIMMMessagePumpOwner
    {
        CONST_VTBL struct IActiveIMMMessagePumpOwnerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMMessagePumpOwner_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIMMMessagePumpOwner_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIMMMessagePumpOwner_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIMMMessagePumpOwner_Start(This)	\
    (This)->lpVtbl -> Start(This)

#define IActiveIMMMessagePumpOwner_End(This)	\
    (This)->lpVtbl -> End(This)

#define IActiveIMMMessagePumpOwner_OnTranslateMessage(This,pMsg)	\
    (This)->lpVtbl -> OnTranslateMessage(This,pMsg)

#define IActiveIMMMessagePumpOwner_Pause(This,pdwCookie)	\
    (This)->lpVtbl -> Pause(This,pdwCookie)

#define IActiveIMMMessagePumpOwner_Resume(This,dwCookie)	\
    (This)->lpVtbl -> Resume(This,dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_Start_Proxy( 
    IActiveIMMMessagePumpOwner * This);


void __RPC_STUB IActiveIMMMessagePumpOwner_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_End_Proxy( 
    IActiveIMMMessagePumpOwner * This);


void __RPC_STUB IActiveIMMMessagePumpOwner_End_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_OnTranslateMessage_Proxy( 
    IActiveIMMMessagePumpOwner * This,
    /* [in] */ const MSG *pMsg);


void __RPC_STUB IActiveIMMMessagePumpOwner_OnTranslateMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_Pause_Proxy( 
    IActiveIMMMessagePumpOwner * This,
    /* [out] */ DWORD *pdwCookie);


void __RPC_STUB IActiveIMMMessagePumpOwner_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_Resume_Proxy( 
    IActiveIMMMessagePumpOwner * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB IActiveIMMMessagePumpOwner_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIMMMessagePumpOwner_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMApp_INTERFACE_DEFINED__
#define __IActiveIMMApp_INTERFACE_DEFINED__

/* interface IActiveIMMApp */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIMMApp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08c0e040-62d1-11d1-9326-0060b067b86e")
    IActiveIMMApp : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AssociateContext( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC *phPrev) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEA( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEW( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateContext( 
            /* [out] */ HIMC *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyContext( 
            /* [in] */ HIMC hIME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA **pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW **pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeA( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeW( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListA( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListW( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pfdwConversion,
            /* [out] */ DWORD *pfdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultIMEWnd( 
            /* [in] */ HWND hWnd,
            /* [out] */ HWND *phDefWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOpenStatus( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD *pdwProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA *pStyleBuf,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW *pStyleBuf,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVirtualKey( 
            /* [in] */ HWND hWnd,
            /* [out] */ UINT *puVirtualKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEA( 
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEW( 
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsIME( 
            /* [in] */ HKL hKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageA( 
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageW( 
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyIME( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseContext( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpenStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SimulateHotKey( 
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ BOOL fRestoreLayout) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDefWindowProc( 
            /* [in] */ HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FilterClientWindows( 
            /* [in] */ ATOM *aaClassList,
            /* [in] */ UINT uSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodePageA( 
            /* [in] */ HKL hKL,
            /* [out] */ UINT *uCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLangId( 
            /* [in] */ HKL hKL,
            /* [out] */ LANGID *plid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AssociateContextEx( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableIME( 
            /* [in] */ DWORD idThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImeMenuItemsA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOA *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOA *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImeMenuItemsW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOW *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOW *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumInputContext( 
            /* [in] */ DWORD idThread,
            /* [out] */ IEnumInputContext **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMAppVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIMMApp * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIMMApp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIMMApp * This);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContext )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC *phPrev);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA *pData);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW *pData);
        
        HRESULT ( STDMETHODCALLTYPE *CreateContext )( 
            IActiveIMMApp * This,
            /* [out] */ HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyContext )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIME);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateWindow )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionWindow )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionStatus )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pfdwConversion,
            /* [out] */ DWORD *pfdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultIMEWnd )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HWND *phDefWnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpenStatus )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD *pdwProperty);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA *pStyleBuf,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW *pStyleBuf,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatusWindowPos )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *GetVirtualKey )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [out] */ UINT *puVirtualKey);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEA )( 
            IActiveIMMApp * This,
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEW )( 
            IActiveIMMApp * This,
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsIME )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageA )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageW )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyIME )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseContext )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *SetCandidateWindow )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionWindow )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *SetConversionStatus )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpenStatus )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatusWindowPos )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *SimulateHotKey )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            IActiveIMMApp * This,
            /* [in] */ BOOL fRestoreLayout);
        
        HRESULT ( STDMETHODCALLTYPE *Deactivate )( 
            IActiveIMMApp * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnDefWindowProc )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *FilterClientWindows )( 
            IActiveIMMApp * This,
            /* [in] */ ATOM *aaClassList,
            /* [in] */ UINT uSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodePageA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [out] */ UINT *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLangId )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [out] */ LANGID *plid);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContextEx )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DisableIME )( 
            IActiveIMMApp * This,
            /* [in] */ DWORD idThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOA *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOA *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOW *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOW *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *EnumInputContext )( 
            IActiveIMMApp * This,
            /* [in] */ DWORD idThread,
            /* [out] */ IEnumInputContext **ppEnum);
        
        END_INTERFACE
    } IActiveIMMAppVtbl;

    interface IActiveIMMApp
    {
        CONST_VTBL struct IActiveIMMAppVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMApp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIMMApp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIMMApp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIMMApp_AssociateContext(This,hWnd,hIME,phPrev)	\
    (This)->lpVtbl -> AssociateContext(This,hWnd,hIME,phPrev)

#define IActiveIMMApp_ConfigureIMEA(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEA(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMApp_ConfigureIMEW(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEW(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMApp_CreateContext(This,phIMC)	\
    (This)->lpVtbl -> CreateContext(This,phIMC)

#define IActiveIMMApp_DestroyContext(This,hIME)	\
    (This)->lpVtbl -> DestroyContext(This,hIME)

#define IActiveIMMApp_EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMApp_EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMApp_EscapeA(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeA(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMApp_EscapeW(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeW(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMApp_GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMApp_GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMApp_GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMApp_GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMApp_GetCandidateWindow(This,hIMC,dwIndex,pCandidate)	\
    (This)->lpVtbl -> GetCandidateWindow(This,hIMC,dwIndex,pCandidate)

#define IActiveIMMApp_GetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontA(This,hIMC,plf)

#define IActiveIMMApp_GetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontW(This,hIMC,plf)

#define IActiveIMMApp_GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMApp_GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMApp_GetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> GetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMApp_GetContext(This,hWnd,phIMC)	\
    (This)->lpVtbl -> GetContext(This,hWnd,phIMC)

#define IActiveIMMApp_GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMApp_GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMApp_GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)	\
    (This)->lpVtbl -> GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)

#define IActiveIMMApp_GetDefaultIMEWnd(This,hWnd,phDefWnd)	\
    (This)->lpVtbl -> GetDefaultIMEWnd(This,hWnd,phDefWnd)

#define IActiveIMMApp_GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMApp_GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMApp_GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMApp_GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMApp_GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMApp_GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMApp_GetOpenStatus(This,hIMC)	\
    (This)->lpVtbl -> GetOpenStatus(This,hIMC)

#define IActiveIMMApp_GetProperty(This,hKL,fdwIndex,pdwProperty)	\
    (This)->lpVtbl -> GetProperty(This,hKL,fdwIndex,pdwProperty)

#define IActiveIMMApp_GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMApp_GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMApp_GetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> GetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMApp_GetVirtualKey(This,hWnd,puVirtualKey)	\
    (This)->lpVtbl -> GetVirtualKey(This,hWnd,puVirtualKey)

#define IActiveIMMApp_InstallIMEA(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEA(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMApp_InstallIMEW(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEW(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMApp_IsIME(This,hKL)	\
    (This)->lpVtbl -> IsIME(This,hKL)

#define IActiveIMMApp_IsUIMessageA(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageA(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMApp_IsUIMessageW(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageW(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMApp_NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)	\
    (This)->lpVtbl -> NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)

#define IActiveIMMApp_RegisterWordA(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordA(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMApp_RegisterWordW(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordW(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMApp_ReleaseContext(This,hWnd,hIMC)	\
    (This)->lpVtbl -> ReleaseContext(This,hWnd,hIMC)

#define IActiveIMMApp_SetCandidateWindow(This,hIMC,pCandidate)	\
    (This)->lpVtbl -> SetCandidateWindow(This,hIMC,pCandidate)

#define IActiveIMMApp_SetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontA(This,hIMC,plf)

#define IActiveIMMApp_SetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontW(This,hIMC,plf)

#define IActiveIMMApp_SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMApp_SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMApp_SetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> SetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMApp_SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)	\
    (This)->lpVtbl -> SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)

#define IActiveIMMApp_SetOpenStatus(This,hIMC,fOpen)	\
    (This)->lpVtbl -> SetOpenStatus(This,hIMC,fOpen)

#define IActiveIMMApp_SetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> SetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMApp_SimulateHotKey(This,hWnd,dwHotKeyID)	\
    (This)->lpVtbl -> SimulateHotKey(This,hWnd,dwHotKeyID)

#define IActiveIMMApp_UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMApp_UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMApp_Activate(This,fRestoreLayout)	\
    (This)->lpVtbl -> Activate(This,fRestoreLayout)

#define IActiveIMMApp_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#define IActiveIMMApp_OnDefWindowProc(This,hWnd,Msg,wParam,lParam,plResult)	\
    (This)->lpVtbl -> OnDefWindowProc(This,hWnd,Msg,wParam,lParam,plResult)

#define IActiveIMMApp_FilterClientWindows(This,aaClassList,uSize)	\
    (This)->lpVtbl -> FilterClientWindows(This,aaClassList,uSize)

#define IActiveIMMApp_GetCodePageA(This,hKL,uCodePage)	\
    (This)->lpVtbl -> GetCodePageA(This,hKL,uCodePage)

#define IActiveIMMApp_GetLangId(This,hKL,plid)	\
    (This)->lpVtbl -> GetLangId(This,hKL,plid)

#define IActiveIMMApp_AssociateContextEx(This,hWnd,hIMC,dwFlags)	\
    (This)->lpVtbl -> AssociateContextEx(This,hWnd,hIMC,dwFlags)

#define IActiveIMMApp_DisableIME(This,idThread)	\
    (This)->lpVtbl -> DisableIME(This,idThread)

#define IActiveIMMApp_GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    (This)->lpVtbl -> GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)

#define IActiveIMMApp_GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    (This)->lpVtbl -> GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)

#define IActiveIMMApp_EnumInputContext(This,idThread,ppEnum)	\
    (This)->lpVtbl -> EnumInputContext(This,idThread,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIMMApp_AssociateContext_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIME,
    /* [out] */ HIMC *phPrev);


void __RPC_STUB IActiveIMMApp_AssociateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_ConfigureIMEA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDA *pData);


void __RPC_STUB IActiveIMMApp_ConfigureIMEA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_ConfigureIMEW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDW *pData);


void __RPC_STUB IActiveIMMApp_ConfigureIMEW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_CreateContext_Proxy( 
    IActiveIMMApp * This,
    /* [out] */ HIMC *phIMC);


void __RPC_STUB IActiveIMMApp_CreateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_DestroyContext_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIME);


void __RPC_STUB IActiveIMMApp_DestroyContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EnumRegisterWordA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordA **pEnum);


void __RPC_STUB IActiveIMMApp_EnumRegisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EnumRegisterWordW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordW **pEnum);


void __RPC_STUB IActiveIMMApp_EnumRegisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EscapeA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ LPVOID pData,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMApp_EscapeA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EscapeW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ LPVOID pData,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMApp_EscapeW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST *pCandList,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetCandidateListA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST *pCandList,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetCandidateListW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListCountA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD *pdwListSize,
    /* [out] */ DWORD *pdwBufLen);


void __RPC_STUB IActiveIMMApp_GetCandidateListCountA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListCountW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD *pdwListSize,
    /* [out] */ DWORD *pdwBufLen);


void __RPC_STUB IActiveIMMApp_GetCandidateListCountW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateWindow_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [out] */ CANDIDATEFORM *pCandidate);


void __RPC_STUB IActiveIMMApp_GetCandidateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionFontA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ LOGFONTA *plf);


void __RPC_STUB IActiveIMMApp_GetCompositionFontA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionFontW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ LOGFONTW *plf);


void __RPC_STUB IActiveIMMApp_GetCompositionFontW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionStringA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LONG *plCopied,
    /* [out] */ LPVOID pBuf);


void __RPC_STUB IActiveIMMApp_GetCompositionStringA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionStringW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LONG *plCopied,
    /* [out] */ LPVOID pBuf);


void __RPC_STUB IActiveIMMApp_GetCompositionStringW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionWindow_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ COMPOSITIONFORM *pCompForm);


void __RPC_STUB IActiveIMMApp_GetCompositionWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetContext_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [out] */ HIMC *phIMC);


void __RPC_STUB IActiveIMMApp_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetConversionListA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPSTR pSrc,
    /* [in] */ UINT uBufLen,
    /* [in] */ UINT uFlag,
    /* [out] */ CANDIDATELIST *pDst,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetConversionListA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetConversionListW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPWSTR pSrc,
    /* [in] */ UINT uBufLen,
    /* [in] */ UINT uFlag,
    /* [out] */ CANDIDATELIST *pDst,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetConversionListW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetConversionStatus_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD *pfdwConversion,
    /* [out] */ DWORD *pfdwSentence);


void __RPC_STUB IActiveIMMApp_GetConversionStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetDefaultIMEWnd_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [out] */ HWND *phDefWnd);


void __RPC_STUB IActiveIMMApp_GetDefaultIMEWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetDescriptionA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPSTR szDescription,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetDescriptionA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetDescriptionW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPWSTR szDescription,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetDescriptionW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetGuideLineA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LPSTR pBuf,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMApp_GetGuideLineA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetGuideLineW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LPWSTR pBuf,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMApp_GetGuideLineW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetIMEFileNameA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPSTR szFileName,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetIMEFileNameA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetIMEFileNameW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPWSTR szFileName,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetIMEFileNameW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetOpenStatus_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMApp_GetOpenStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetProperty_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ DWORD fdwIndex,
    /* [out] */ DWORD *pdwProperty);


void __RPC_STUB IActiveIMMApp_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetRegisterWordStyleA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFA *pStyleBuf,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetRegisterWordStyleA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetRegisterWordStyleW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFW *pStyleBuf,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMApp_GetRegisterWordStyleW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetStatusWindowPos_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ POINT *pptPos);


void __RPC_STUB IActiveIMMApp_GetStatusWindowPos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetVirtualKey_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [out] */ UINT *puVirtualKey);


void __RPC_STUB IActiveIMMApp_GetVirtualKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_InstallIMEA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ LPSTR szIMEFileName,
    /* [in] */ LPSTR szLayoutText,
    /* [out] */ HKL *phKL);


void __RPC_STUB IActiveIMMApp_InstallIMEA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_InstallIMEW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ LPWSTR szIMEFileName,
    /* [in] */ LPWSTR szLayoutText,
    /* [out] */ HKL *phKL);


void __RPC_STUB IActiveIMMApp_InstallIMEW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_IsIME_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL);


void __RPC_STUB IActiveIMMApp_IsIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_IsUIMessageA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWndIME,
    /* [in] */ UINT msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IActiveIMMApp_IsUIMessageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_IsUIMessageW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWndIME,
    /* [in] */ UINT msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IActiveIMMApp_IsUIMessageW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_NotifyIME_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwAction,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwValue);


void __RPC_STUB IActiveIMMApp_NotifyIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_RegisterWordA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szRegister);


void __RPC_STUB IActiveIMMApp_RegisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_RegisterWordW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister);


void __RPC_STUB IActiveIMMApp_RegisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_ReleaseContext_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMApp_ReleaseContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCandidateWindow_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ CANDIDATEFORM *pCandidate);


void __RPC_STUB IActiveIMMApp_SetCandidateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionFontA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LOGFONTA *plf);


void __RPC_STUB IActiveIMMApp_SetCompositionFontA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionFontW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LOGFONTW *plf);


void __RPC_STUB IActiveIMMApp_SetCompositionFontW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionStringA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ LPVOID pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ LPVOID pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIMMApp_SetCompositionStringA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionStringW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ LPVOID pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ LPVOID pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIMMApp_SetCompositionStringW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionWindow_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ COMPOSITIONFORM *pCompForm);


void __RPC_STUB IActiveIMMApp_SetCompositionWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetConversionStatus_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD fdwConversion,
    /* [in] */ DWORD fdwSentence);


void __RPC_STUB IActiveIMMApp_SetConversionStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetOpenStatus_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ BOOL fOpen);


void __RPC_STUB IActiveIMMApp_SetOpenStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetStatusWindowPos_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ POINT *pptPos);


void __RPC_STUB IActiveIMMApp_SetStatusWindowPos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SimulateHotKey_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwHotKeyID);


void __RPC_STUB IActiveIMMApp_SimulateHotKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_UnregisterWordA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szUnregister);


void __RPC_STUB IActiveIMMApp_UnregisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_UnregisterWordW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szUnregister);


void __RPC_STUB IActiveIMMApp_UnregisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_Activate_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ BOOL fRestoreLayout);


void __RPC_STUB IActiveIMMApp_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_Deactivate_Proxy( 
    IActiveIMMApp * This);


void __RPC_STUB IActiveIMMApp_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_OnDefWindowProc_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [in] */ UINT Msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMApp_OnDefWindowProc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_FilterClientWindows_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ ATOM *aaClassList,
    /* [in] */ UINT uSize);


void __RPC_STUB IActiveIMMApp_FilterClientWindows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCodePageA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [out] */ UINT *uCodePage);


void __RPC_STUB IActiveIMMApp_GetCodePageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetLangId_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HKL hKL,
    /* [out] */ LANGID *plid);


void __RPC_STUB IActiveIMMApp_GetLangId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_AssociateContextEx_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IActiveIMMApp_AssociateContextEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_DisableIME_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ DWORD idThread);


void __RPC_STUB IActiveIMMApp_DisableIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetImeMenuItemsA_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwType,
    /* [in] */ IMEMENUITEMINFOA *pImeParentMenu,
    /* [out] */ IMEMENUITEMINFOA *pImeMenu,
    /* [in] */ DWORD dwSize,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMApp_GetImeMenuItemsA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetImeMenuItemsW_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwType,
    /* [in] */ IMEMENUITEMINFOW *pImeParentMenu,
    /* [out] */ IMEMENUITEMINFOW *pImeMenu,
    /* [in] */ DWORD dwSize,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMApp_GetImeMenuItemsW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EnumInputContext_Proxy( 
    IActiveIMMApp * This,
    /* [in] */ DWORD idThread,
    /* [out] */ IEnumInputContext **ppEnum);


void __RPC_STUB IActiveIMMApp_EnumInputContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIMMApp_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMIME_INTERFACE_DEFINED__
#define __IActiveIMMIME_INTERFACE_DEFINED__

/* interface IActiveIMMIME */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIMMIME;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08C03411-F96B-11d0-A475-00AA006BCC59")
    IActiveIMMIME : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AssociateContext( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC *phPrev) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEA( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEW( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateContext( 
            /* [out] */ HIMC *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyContext( 
            /* [in] */ HIMC hIME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA **pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW **pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeA( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeW( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListA( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListW( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pfdwConversion,
            /* [out] */ DWORD *pfdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultIMEWnd( 
            /* [in] */ HWND hWnd,
            /* [out] */ HWND *phDefWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOpenStatus( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD *pdwProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA *pStyleBuf,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW *pStyleBuf,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVirtualKey( 
            /* [in] */ HWND hWnd,
            /* [out] */ UINT *puVirtualKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEA( 
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEW( 
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsIME( 
            /* [in] */ HKL hKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageA( 
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageW( 
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyIME( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseContext( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpenStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SimulateHotKey( 
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateMessage( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockIMC( 
            /* [in] */ HIMC hIMC,
            /* [out] */ INPUTCONTEXT **ppIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockIMC( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMCLockCount( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwLockCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateIMCC( 
            /* [in] */ DWORD dwSize,
            /* [out] */ HIMCC *phIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyIMCC( 
            /* [in] */ HIMCC hIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockIMCC( 
            /* [in] */ HIMCC hIMCC,
            /* [out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockIMCC( 
            /* [in] */ HIMCC hIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReSizeIMCC( 
            /* [in] */ HIMCC hIMCC,
            /* [in] */ DWORD dwSize,
            /* [out] */ HIMCC *phIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMCCSize( 
            /* [in] */ HIMCC hIMCC,
            /* [out] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMCCLockCount( 
            /* [in] */ HIMCC hIMCC,
            /* [out] */ DWORD *pdwLockCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHotKey( 
            /* [in] */ DWORD dwHotKeyID,
            /* [out] */ UINT *puModifiers,
            /* [out] */ UINT *puVKey,
            /* [out] */ HKL *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHotKey( 
            /* [in] */ DWORD dwHotKeyID,
            /* [in] */ UINT uModifiers,
            /* [in] */ UINT uVKey,
            /* [in] */ HKL hKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSoftKeyboard( 
            /* [in] */ UINT uType,
            /* [in] */ HWND hOwner,
            /* [in] */ int x,
            /* [in] */ int y,
            /* [out] */ HWND *phSoftKbdWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroySoftKeyboard( 
            /* [in] */ HWND hSoftKbdWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowSoftKeyboard( 
            /* [in] */ HWND hSoftKbdWnd,
            /* [in] */ int nCmdShow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodePageA( 
            /* [in] */ HKL hKL,
            /* [out] */ UINT *uCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLangId( 
            /* [in] */ HKL hKL,
            /* [out] */ LANGID *plid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KeybdEvent( 
            /* [in] */ LANGID lgidIME,
            /* [in] */ BYTE bVk,
            /* [in] */ BYTE bScan,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwExtraInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockModal( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockModal( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AssociateContextEx( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableIME( 
            /* [in] */ DWORD idThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImeMenuItemsA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOA *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOA *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImeMenuItemsW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOW *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOW *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumInputContext( 
            /* [in] */ DWORD idThread,
            /* [out] */ IEnumInputContext **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestMessageA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestMessageW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendIMCA( 
            /* [in] */ HWND hWnd,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SendIMCW( 
            /* [in] */ HWND hWnd,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSleeping( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMIMEVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIMMIME * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIMMIME * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIMMIME * This);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContext )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC *phPrev);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEA )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA *pData);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEW )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW *pData);
        
        HRESULT ( STDMETHODCALLTYPE *CreateContext )( 
            IActiveIMMIME * This,
            /* [out] */ HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyContext )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIME);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordA )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordW )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeA )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeW )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateWindow )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionWindow )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListA )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListW )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionStatus )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pfdwConversion,
            /* [out] */ DWORD *pfdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultIMEWnd )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HWND *phDefWnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionA )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionW )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameA )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameW )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpenStatus )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD *pdwProperty);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleA )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA *pStyleBuf,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleW )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW *pStyleBuf,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatusWindowPos )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *GetVirtualKey )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWnd,
            /* [out] */ UINT *puVirtualKey);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEA )( 
            IActiveIMMIME * This,
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEW )( 
            IActiveIMMIME * This,
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsIME )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageA )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageW )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyIME )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordA )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordW )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseContext )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *SetCandidateWindow )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionWindow )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *SetConversionStatus )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpenStatus )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatusWindowPos )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *SimulateHotKey )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordA )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordW )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateMessage )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *LockIMC )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ INPUTCONTEXT **ppIMC);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockIMC )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMCLockCount )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwLockCount);
        
        HRESULT ( STDMETHODCALLTYPE *CreateIMCC )( 
            IActiveIMMIME * This,
            /* [in] */ DWORD dwSize,
            /* [out] */ HIMCC *phIMCC);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyIMCC )( 
            IActiveIMMIME * This,
            /* [in] */ HIMCC hIMCC);
        
        HRESULT ( STDMETHODCALLTYPE *LockIMCC )( 
            IActiveIMMIME * This,
            /* [in] */ HIMCC hIMCC,
            /* [out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockIMCC )( 
            IActiveIMMIME * This,
            /* [in] */ HIMCC hIMCC);
        
        HRESULT ( STDMETHODCALLTYPE *ReSizeIMCC )( 
            IActiveIMMIME * This,
            /* [in] */ HIMCC hIMCC,
            /* [in] */ DWORD dwSize,
            /* [out] */ HIMCC *phIMCC);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMCCSize )( 
            IActiveIMMIME * This,
            /* [in] */ HIMCC hIMCC,
            /* [out] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMCCLockCount )( 
            IActiveIMMIME * This,
            /* [in] */ HIMCC hIMCC,
            /* [out] */ DWORD *pdwLockCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetHotKey )( 
            IActiveIMMIME * This,
            /* [in] */ DWORD dwHotKeyID,
            /* [out] */ UINT *puModifiers,
            /* [out] */ UINT *puVKey,
            /* [out] */ HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *SetHotKey )( 
            IActiveIMMIME * This,
            /* [in] */ DWORD dwHotKeyID,
            /* [in] */ UINT uModifiers,
            /* [in] */ UINT uVKey,
            /* [in] */ HKL hKL);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSoftKeyboard )( 
            IActiveIMMIME * This,
            /* [in] */ UINT uType,
            /* [in] */ HWND hOwner,
            /* [in] */ int x,
            /* [in] */ int y,
            /* [out] */ HWND *phSoftKbdWnd);
        
        HRESULT ( STDMETHODCALLTYPE *DestroySoftKeyboard )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hSoftKbdWnd);
        
        HRESULT ( STDMETHODCALLTYPE *ShowSoftKeyboard )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hSoftKbdWnd,
            /* [in] */ int nCmdShow);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodePageA )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [out] */ UINT *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLangId )( 
            IActiveIMMIME * This,
            /* [in] */ HKL hKL,
            /* [out] */ LANGID *plid);
        
        HRESULT ( STDMETHODCALLTYPE *KeybdEvent )( 
            IActiveIMMIME * This,
            /* [in] */ LANGID lgidIME,
            /* [in] */ BYTE bVk,
            /* [in] */ BYTE bScan,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwExtraInfo);
        
        HRESULT ( STDMETHODCALLTYPE *LockModal )( 
            IActiveIMMIME * This);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockModal )( 
            IActiveIMMIME * This);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContextEx )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DisableIME )( 
            IActiveIMMIME * This,
            /* [in] */ DWORD idThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOA *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOA *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOW *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOW *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *EnumInputContext )( 
            IActiveIMMIME * This,
            /* [in] */ DWORD idThread,
            /* [out] */ IEnumInputContext **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *RequestMessageA )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *RequestMessageW )( 
            IActiveIMMIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *SendIMCA )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWnd,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *SendIMCW )( 
            IActiveIMMIME * This,
            /* [in] */ HWND hWnd,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *IsSleeping )( 
            IActiveIMMIME * This);
        
        END_INTERFACE
    } IActiveIMMIMEVtbl;

    interface IActiveIMMIME
    {
        CONST_VTBL struct IActiveIMMIMEVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMIME_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIMMIME_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIMMIME_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIMMIME_AssociateContext(This,hWnd,hIME,phPrev)	\
    (This)->lpVtbl -> AssociateContext(This,hWnd,hIME,phPrev)

#define IActiveIMMIME_ConfigureIMEA(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEA(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMIME_ConfigureIMEW(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEW(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMIME_CreateContext(This,phIMC)	\
    (This)->lpVtbl -> CreateContext(This,phIMC)

#define IActiveIMMIME_DestroyContext(This,hIME)	\
    (This)->lpVtbl -> DestroyContext(This,hIME)

#define IActiveIMMIME_EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMIME_EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMIME_EscapeA(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeA(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMIME_EscapeW(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeW(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMIME_GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMIME_GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMIME_GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMIME_GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMIME_GetCandidateWindow(This,hIMC,dwIndex,pCandidate)	\
    (This)->lpVtbl -> GetCandidateWindow(This,hIMC,dwIndex,pCandidate)

#define IActiveIMMIME_GetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontA(This,hIMC,plf)

#define IActiveIMMIME_GetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontW(This,hIMC,plf)

#define IActiveIMMIME_GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMIME_GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMIME_GetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> GetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMIME_GetContext(This,hWnd,phIMC)	\
    (This)->lpVtbl -> GetContext(This,hWnd,phIMC)

#define IActiveIMMIME_GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMIME_GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMIME_GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)	\
    (This)->lpVtbl -> GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)

#define IActiveIMMIME_GetDefaultIMEWnd(This,hWnd,phDefWnd)	\
    (This)->lpVtbl -> GetDefaultIMEWnd(This,hWnd,phDefWnd)

#define IActiveIMMIME_GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMIME_GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMIME_GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMIME_GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMIME_GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMIME_GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMIME_GetOpenStatus(This,hIMC)	\
    (This)->lpVtbl -> GetOpenStatus(This,hIMC)

#define IActiveIMMIME_GetProperty(This,hKL,fdwIndex,pdwProperty)	\
    (This)->lpVtbl -> GetProperty(This,hKL,fdwIndex,pdwProperty)

#define IActiveIMMIME_GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMIME_GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMIME_GetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> GetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMIME_GetVirtualKey(This,hWnd,puVirtualKey)	\
    (This)->lpVtbl -> GetVirtualKey(This,hWnd,puVirtualKey)

#define IActiveIMMIME_InstallIMEA(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEA(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMIME_InstallIMEW(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEW(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMIME_IsIME(This,hKL)	\
    (This)->lpVtbl -> IsIME(This,hKL)

#define IActiveIMMIME_IsUIMessageA(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageA(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMIME_IsUIMessageW(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageW(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMIME_NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)	\
    (This)->lpVtbl -> NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)

#define IActiveIMMIME_RegisterWordA(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordA(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMIME_RegisterWordW(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordW(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMIME_ReleaseContext(This,hWnd,hIMC)	\
    (This)->lpVtbl -> ReleaseContext(This,hWnd,hIMC)

#define IActiveIMMIME_SetCandidateWindow(This,hIMC,pCandidate)	\
    (This)->lpVtbl -> SetCandidateWindow(This,hIMC,pCandidate)

#define IActiveIMMIME_SetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontA(This,hIMC,plf)

#define IActiveIMMIME_SetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontW(This,hIMC,plf)

#define IActiveIMMIME_SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMIME_SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMIME_SetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> SetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMIME_SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)	\
    (This)->lpVtbl -> SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)

#define IActiveIMMIME_SetOpenStatus(This,hIMC,fOpen)	\
    (This)->lpVtbl -> SetOpenStatus(This,hIMC,fOpen)

#define IActiveIMMIME_SetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> SetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMIME_SimulateHotKey(This,hWnd,dwHotKeyID)	\
    (This)->lpVtbl -> SimulateHotKey(This,hWnd,dwHotKeyID)

#define IActiveIMMIME_UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMIME_UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMIME_GenerateMessage(This,hIMC)	\
    (This)->lpVtbl -> GenerateMessage(This,hIMC)

#define IActiveIMMIME_LockIMC(This,hIMC,ppIMC)	\
    (This)->lpVtbl -> LockIMC(This,hIMC,ppIMC)

#define IActiveIMMIME_UnlockIMC(This,hIMC)	\
    (This)->lpVtbl -> UnlockIMC(This,hIMC)

#define IActiveIMMIME_GetIMCLockCount(This,hIMC,pdwLockCount)	\
    (This)->lpVtbl -> GetIMCLockCount(This,hIMC,pdwLockCount)

#define IActiveIMMIME_CreateIMCC(This,dwSize,phIMCC)	\
    (This)->lpVtbl -> CreateIMCC(This,dwSize,phIMCC)

#define IActiveIMMIME_DestroyIMCC(This,hIMCC)	\
    (This)->lpVtbl -> DestroyIMCC(This,hIMCC)

#define IActiveIMMIME_LockIMCC(This,hIMCC,ppv)	\
    (This)->lpVtbl -> LockIMCC(This,hIMCC,ppv)

#define IActiveIMMIME_UnlockIMCC(This,hIMCC)	\
    (This)->lpVtbl -> UnlockIMCC(This,hIMCC)

#define IActiveIMMIME_ReSizeIMCC(This,hIMCC,dwSize,phIMCC)	\
    (This)->lpVtbl -> ReSizeIMCC(This,hIMCC,dwSize,phIMCC)

#define IActiveIMMIME_GetIMCCSize(This,hIMCC,pdwSize)	\
    (This)->lpVtbl -> GetIMCCSize(This,hIMCC,pdwSize)

#define IActiveIMMIME_GetIMCCLockCount(This,hIMCC,pdwLockCount)	\
    (This)->lpVtbl -> GetIMCCLockCount(This,hIMCC,pdwLockCount)

#define IActiveIMMIME_GetHotKey(This,dwHotKeyID,puModifiers,puVKey,phKL)	\
    (This)->lpVtbl -> GetHotKey(This,dwHotKeyID,puModifiers,puVKey,phKL)

#define IActiveIMMIME_SetHotKey(This,dwHotKeyID,uModifiers,uVKey,hKL)	\
    (This)->lpVtbl -> SetHotKey(This,dwHotKeyID,uModifiers,uVKey,hKL)

#define IActiveIMMIME_CreateSoftKeyboard(This,uType,hOwner,x,y,phSoftKbdWnd)	\
    (This)->lpVtbl -> CreateSoftKeyboard(This,uType,hOwner,x,y,phSoftKbdWnd)

#define IActiveIMMIME_DestroySoftKeyboard(This,hSoftKbdWnd)	\
    (This)->lpVtbl -> DestroySoftKeyboard(This,hSoftKbdWnd)

#define IActiveIMMIME_ShowSoftKeyboard(This,hSoftKbdWnd,nCmdShow)	\
    (This)->lpVtbl -> ShowSoftKeyboard(This,hSoftKbdWnd,nCmdShow)

#define IActiveIMMIME_GetCodePageA(This,hKL,uCodePage)	\
    (This)->lpVtbl -> GetCodePageA(This,hKL,uCodePage)

#define IActiveIMMIME_GetLangId(This,hKL,plid)	\
    (This)->lpVtbl -> GetLangId(This,hKL,plid)

#define IActiveIMMIME_KeybdEvent(This,lgidIME,bVk,bScan,dwFlags,dwExtraInfo)	\
    (This)->lpVtbl -> KeybdEvent(This,lgidIME,bVk,bScan,dwFlags,dwExtraInfo)

#define IActiveIMMIME_LockModal(This)	\
    (This)->lpVtbl -> LockModal(This)

#define IActiveIMMIME_UnlockModal(This)	\
    (This)->lpVtbl -> UnlockModal(This)

#define IActiveIMMIME_AssociateContextEx(This,hWnd,hIMC,dwFlags)	\
    (This)->lpVtbl -> AssociateContextEx(This,hWnd,hIMC,dwFlags)

#define IActiveIMMIME_DisableIME(This,idThread)	\
    (This)->lpVtbl -> DisableIME(This,idThread)

#define IActiveIMMIME_GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    (This)->lpVtbl -> GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)

#define IActiveIMMIME_GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    (This)->lpVtbl -> GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)

#define IActiveIMMIME_EnumInputContext(This,idThread,ppEnum)	\
    (This)->lpVtbl -> EnumInputContext(This,idThread,ppEnum)

#define IActiveIMMIME_RequestMessageA(This,hIMC,wParam,lParam,plResult)	\
    (This)->lpVtbl -> RequestMessageA(This,hIMC,wParam,lParam,plResult)

#define IActiveIMMIME_RequestMessageW(This,hIMC,wParam,lParam,plResult)	\
    (This)->lpVtbl -> RequestMessageW(This,hIMC,wParam,lParam,plResult)

#define IActiveIMMIME_SendIMCA(This,hWnd,uMsg,wParam,lParam,plResult)	\
    (This)->lpVtbl -> SendIMCA(This,hWnd,uMsg,wParam,lParam,plResult)

#define IActiveIMMIME_SendIMCW(This,hWnd,uMsg,wParam,lParam,plResult)	\
    (This)->lpVtbl -> SendIMCW(This,hWnd,uMsg,wParam,lParam,plResult)

#define IActiveIMMIME_IsSleeping(This)	\
    (This)->lpVtbl -> IsSleeping(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIMMIME_AssociateContext_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIME,
    /* [out] */ HIMC *phPrev);


void __RPC_STUB IActiveIMMIME_AssociateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_ConfigureIMEA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDA *pData);


void __RPC_STUB IActiveIMMIME_ConfigureIMEA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_ConfigureIMEW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDW *pData);


void __RPC_STUB IActiveIMMIME_ConfigureIMEW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_CreateContext_Proxy( 
    IActiveIMMIME * This,
    /* [out] */ HIMC *phIMC);


void __RPC_STUB IActiveIMMIME_CreateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_DestroyContext_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIME);


void __RPC_STUB IActiveIMMIME_DestroyContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_EnumRegisterWordA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordA **pEnum);


void __RPC_STUB IActiveIMMIME_EnumRegisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_EnumRegisterWordW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordW **pEnum);


void __RPC_STUB IActiveIMMIME_EnumRegisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_EscapeA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ LPVOID pData,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMIME_EscapeA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_EscapeW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ LPVOID pData,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMIME_EscapeW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCandidateListA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST *pCandList,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMIME_GetCandidateListA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCandidateListW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST *pCandList,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMIME_GetCandidateListW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCandidateListCountA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD *pdwListSize,
    /* [out] */ DWORD *pdwBufLen);


void __RPC_STUB IActiveIMMIME_GetCandidateListCountA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCandidateListCountW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD *pdwListSize,
    /* [out] */ DWORD *pdwBufLen);


void __RPC_STUB IActiveIMMIME_GetCandidateListCountW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCandidateWindow_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [out] */ CANDIDATEFORM *pCandidate);


void __RPC_STUB IActiveIMMIME_GetCandidateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCompositionFontA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ LOGFONTA *plf);


void __RPC_STUB IActiveIMMIME_GetCompositionFontA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCompositionFontW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ LOGFONTW *plf);


void __RPC_STUB IActiveIMMIME_GetCompositionFontW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCompositionStringA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LONG *plCopied,
    /* [out] */ LPVOID pBuf);


void __RPC_STUB IActiveIMMIME_GetCompositionStringA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCompositionStringW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LONG *plCopied,
    /* [out] */ LPVOID pBuf);


void __RPC_STUB IActiveIMMIME_GetCompositionStringW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCompositionWindow_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ COMPOSITIONFORM *pCompForm);


void __RPC_STUB IActiveIMMIME_GetCompositionWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetContext_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWnd,
    /* [out] */ HIMC *phIMC);


void __RPC_STUB IActiveIMMIME_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetConversionListA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPSTR pSrc,
    /* [in] */ UINT uBufLen,
    /* [in] */ UINT uFlag,
    /* [out] */ CANDIDATELIST *pDst,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMIME_GetConversionListA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetConversionListW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPWSTR pSrc,
    /* [in] */ UINT uBufLen,
    /* [in] */ UINT uFlag,
    /* [out] */ CANDIDATELIST *pDst,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMIME_GetConversionListW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetConversionStatus_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD *pfdwConversion,
    /* [out] */ DWORD *pfdwSentence);


void __RPC_STUB IActiveIMMIME_GetConversionStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetDefaultIMEWnd_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWnd,
    /* [out] */ HWND *phDefWnd);


void __RPC_STUB IActiveIMMIME_GetDefaultIMEWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetDescriptionA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPSTR szDescription,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMIME_GetDescriptionA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetDescriptionW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPWSTR szDescription,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMIME_GetDescriptionW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetGuideLineA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LPSTR pBuf,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMIME_GetGuideLineA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetGuideLineW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LPWSTR pBuf,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMIME_GetGuideLineW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetIMEFileNameA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPSTR szFileName,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMIME_GetIMEFileNameA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetIMEFileNameW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPWSTR szFileName,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMIME_GetIMEFileNameW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetOpenStatus_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMIME_GetOpenStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetProperty_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ DWORD fdwIndex,
    /* [out] */ DWORD *pdwProperty);


void __RPC_STUB IActiveIMMIME_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetRegisterWordStyleA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFA *pStyleBuf,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMIME_GetRegisterWordStyleA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetRegisterWordStyleW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFW *pStyleBuf,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIMMIME_GetRegisterWordStyleW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetStatusWindowPos_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ POINT *pptPos);


void __RPC_STUB IActiveIMMIME_GetStatusWindowPos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetVirtualKey_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWnd,
    /* [out] */ UINT *puVirtualKey);


void __RPC_STUB IActiveIMMIME_GetVirtualKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_InstallIMEA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ LPSTR szIMEFileName,
    /* [in] */ LPSTR szLayoutText,
    /* [out] */ HKL *phKL);


void __RPC_STUB IActiveIMMIME_InstallIMEA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_InstallIMEW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ LPWSTR szIMEFileName,
    /* [in] */ LPWSTR szLayoutText,
    /* [out] */ HKL *phKL);


void __RPC_STUB IActiveIMMIME_InstallIMEW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_IsIME_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL);


void __RPC_STUB IActiveIMMIME_IsIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_IsUIMessageA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWndIME,
    /* [in] */ UINT msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IActiveIMMIME_IsUIMessageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_IsUIMessageW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWndIME,
    /* [in] */ UINT msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IActiveIMMIME_IsUIMessageW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_NotifyIME_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwAction,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwValue);


void __RPC_STUB IActiveIMMIME_NotifyIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_RegisterWordA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szRegister);


void __RPC_STUB IActiveIMMIME_RegisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_RegisterWordW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister);


void __RPC_STUB IActiveIMMIME_RegisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_ReleaseContext_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMIME_ReleaseContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCandidateWindow_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ CANDIDATEFORM *pCandidate);


void __RPC_STUB IActiveIMMIME_SetCandidateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCompositionFontA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LOGFONTA *plf);


void __RPC_STUB IActiveIMMIME_SetCompositionFontA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCompositionFontW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LOGFONTW *plf);


void __RPC_STUB IActiveIMMIME_SetCompositionFontW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCompositionStringA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ LPVOID pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ LPVOID pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIMMIME_SetCompositionStringA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCompositionStringW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ LPVOID pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ LPVOID pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIMMIME_SetCompositionStringW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCompositionWindow_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ COMPOSITIONFORM *pCompForm);


void __RPC_STUB IActiveIMMIME_SetCompositionWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetConversionStatus_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD fdwConversion,
    /* [in] */ DWORD fdwSentence);


void __RPC_STUB IActiveIMMIME_SetConversionStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetOpenStatus_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ BOOL fOpen);


void __RPC_STUB IActiveIMMIME_SetOpenStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetStatusWindowPos_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ POINT *pptPos);


void __RPC_STUB IActiveIMMIME_SetStatusWindowPos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SimulateHotKey_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwHotKeyID);


void __RPC_STUB IActiveIMMIME_SimulateHotKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_UnregisterWordA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szUnregister);


void __RPC_STUB IActiveIMMIME_UnregisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_UnregisterWordW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szUnregister);


void __RPC_STUB IActiveIMMIME_UnregisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GenerateMessage_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMIME_GenerateMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_LockIMC_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ INPUTCONTEXT **ppIMC);


void __RPC_STUB IActiveIMMIME_LockIMC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_UnlockIMC_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMIME_UnlockIMC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetIMCLockCount_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD *pdwLockCount);


void __RPC_STUB IActiveIMMIME_GetIMCLockCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_CreateIMCC_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ DWORD dwSize,
    /* [out] */ HIMCC *phIMCC);


void __RPC_STUB IActiveIMMIME_CreateIMCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_DestroyIMCC_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMCC hIMCC);


void __RPC_STUB IActiveIMMIME_DestroyIMCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_LockIMCC_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMCC hIMCC,
    /* [out] */ void **ppv);


void __RPC_STUB IActiveIMMIME_LockIMCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_UnlockIMCC_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMCC hIMCC);


void __RPC_STUB IActiveIMMIME_UnlockIMCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_ReSizeIMCC_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMCC hIMCC,
    /* [in] */ DWORD dwSize,
    /* [out] */ HIMCC *phIMCC);


void __RPC_STUB IActiveIMMIME_ReSizeIMCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetIMCCSize_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMCC hIMCC,
    /* [out] */ DWORD *pdwSize);


void __RPC_STUB IActiveIMMIME_GetIMCCSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetIMCCLockCount_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMCC hIMCC,
    /* [out] */ DWORD *pdwLockCount);


void __RPC_STUB IActiveIMMIME_GetIMCCLockCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetHotKey_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ DWORD dwHotKeyID,
    /* [out] */ UINT *puModifiers,
    /* [out] */ UINT *puVKey,
    /* [out] */ HKL *phKL);


void __RPC_STUB IActiveIMMIME_GetHotKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetHotKey_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ DWORD dwHotKeyID,
    /* [in] */ UINT uModifiers,
    /* [in] */ UINT uVKey,
    /* [in] */ HKL hKL);


void __RPC_STUB IActiveIMMIME_SetHotKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_CreateSoftKeyboard_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ UINT uType,
    /* [in] */ HWND hOwner,
    /* [in] */ int x,
    /* [in] */ int y,
    /* [out] */ HWND *phSoftKbdWnd);


void __RPC_STUB IActiveIMMIME_CreateSoftKeyboard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_DestroySoftKeyboard_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hSoftKbdWnd);


void __RPC_STUB IActiveIMMIME_DestroySoftKeyboard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_ShowSoftKeyboard_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hSoftKbdWnd,
    /* [in] */ int nCmdShow);


void __RPC_STUB IActiveIMMIME_ShowSoftKeyboard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCodePageA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [out] */ UINT *uCodePage);


void __RPC_STUB IActiveIMMIME_GetCodePageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetLangId_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HKL hKL,
    /* [out] */ LANGID *plid);


void __RPC_STUB IActiveIMMIME_GetLangId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_KeybdEvent_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ LANGID lgidIME,
    /* [in] */ BYTE bVk,
    /* [in] */ BYTE bScan,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwExtraInfo);


void __RPC_STUB IActiveIMMIME_KeybdEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_LockModal_Proxy( 
    IActiveIMMIME * This);


void __RPC_STUB IActiveIMMIME_LockModal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_UnlockModal_Proxy( 
    IActiveIMMIME * This);


void __RPC_STUB IActiveIMMIME_UnlockModal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_AssociateContextEx_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IActiveIMMIME_AssociateContextEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_DisableIME_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ DWORD idThread);


void __RPC_STUB IActiveIMMIME_DisableIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetImeMenuItemsA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwType,
    /* [in] */ IMEMENUITEMINFOA *pImeParentMenu,
    /* [out] */ IMEMENUITEMINFOA *pImeMenu,
    /* [in] */ DWORD dwSize,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMIME_GetImeMenuItemsA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetImeMenuItemsW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwType,
    /* [in] */ IMEMENUITEMINFOW *pImeParentMenu,
    /* [out] */ IMEMENUITEMINFOW *pImeMenu,
    /* [in] */ DWORD dwSize,
    /* [out] */ DWORD *pdwResult);


void __RPC_STUB IActiveIMMIME_GetImeMenuItemsW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_EnumInputContext_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ DWORD idThread,
    /* [out] */ IEnumInputContext **ppEnum);


void __RPC_STUB IActiveIMMIME_EnumInputContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_RequestMessageA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMIME_RequestMessageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_RequestMessageW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMIME_RequestMessageW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SendIMCA_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWnd,
    /* [in] */ UINT uMsg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMIME_SendIMCA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SendIMCW_Proxy( 
    IActiveIMMIME * This,
    /* [in] */ HWND hWnd,
    /* [in] */ UINT uMsg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIMMIME_SendIMCW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_IsSleeping_Proxy( 
    IActiveIMMIME * This);


void __RPC_STUB IActiveIMMIME_IsSleeping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIMMIME_INTERFACE_DEFINED__ */


#ifndef __IActiveIME_INTERFACE_DEFINED__
#define __IActiveIME_INTERFACE_DEFINED__

/* interface IActiveIME */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIME;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6FE20962-D077-11d0-8FE7-00AA006BCC59")
    IActiveIME : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Inquire( 
            /* [in] */ DWORD dwSystemInfoFlags,
            /* [out] */ IMEINFO *pIMEInfo,
            /* [out] */ LPWSTR szWndClass,
            /* [out] */ DWORD *pdwPrivate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConversionList( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR szSource,
            /* [in] */ UINT uFlag,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pDest,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW *pRegisterWord) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ UINT uReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Escape( 
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ void *pData,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActiveContext( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessKey( 
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uVirKey,
            /* [in] */ DWORD lParam,
            /* [in] */ BYTE *pbKeyState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Select( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fSelect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionString( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ void *pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ void *pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ToAsciiEx( 
            /* [in] */ UINT uVirKey,
            /* [in] */ UINT uScanCode,
            /* [in] */ BYTE *pbKeyState,
            /* [in] */ UINT fuState,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwTransBuf,
            /* [out] */ UINT *puSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWord( 
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWord( 
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyle( 
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW *pStyleBuf,
            /* [out] */ UINT *puBufSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWord( 
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodePageA( 
            /* [out] */ UINT *uCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLangId( 
            /* [out] */ LANGID *plid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMEVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIME * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIME * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIME * This);
        
        HRESULT ( STDMETHODCALLTYPE *Inquire )( 
            IActiveIME * This,
            /* [in] */ DWORD dwSystemInfoFlags,
            /* [out] */ IMEINFO *pIMEInfo,
            /* [out] */ LPWSTR szWndClass,
            /* [out] */ DWORD *pdwPrivate);
        
        HRESULT ( STDMETHODCALLTYPE *ConversionList )( 
            IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR szSource,
            /* [in] */ UINT uFlag,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pDest,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *Configure )( 
            IActiveIME * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW *pRegisterWord);
        
        HRESULT ( STDMETHODCALLTYPE *Destroy )( 
            IActiveIME * This,
            /* [in] */ UINT uReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Escape )( 
            IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ void *pData,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *SetActiveContext )( 
            IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fFlag);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessKey )( 
            IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uVirKey,
            /* [in] */ DWORD lParam,
            /* [in] */ BYTE *pbKeyState);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *Select )( 
            IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fSelect);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionString )( 
            IActiveIME * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ void *pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ void *pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *ToAsciiEx )( 
            IActiveIME * This,
            /* [in] */ UINT uVirKey,
            /* [in] */ UINT uScanCode,
            /* [in] */ BYTE *pbKeyState,
            /* [in] */ UINT fuState,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwTransBuf,
            /* [out] */ UINT *puSize);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWord )( 
            IActiveIME * This,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWord )( 
            IActiveIME * This,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyle )( 
            IActiveIME * This,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW *pStyleBuf,
            /* [out] */ UINT *puBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWord )( 
            IActiveIME * This,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodePageA )( 
            IActiveIME * This,
            /* [out] */ UINT *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLangId )( 
            IActiveIME * This,
            /* [out] */ LANGID *plid);
        
        END_INTERFACE
    } IActiveIMEVtbl;

    interface IActiveIME
    {
        CONST_VTBL struct IActiveIMEVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIME_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIME_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIME_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIME_Inquire(This,dwSystemInfoFlags,pIMEInfo,szWndClass,pdwPrivate)	\
    (This)->lpVtbl -> Inquire(This,dwSystemInfoFlags,pIMEInfo,szWndClass,pdwPrivate)

#define IActiveIME_ConversionList(This,hIMC,szSource,uFlag,uBufLen,pDest,puCopied)	\
    (This)->lpVtbl -> ConversionList(This,hIMC,szSource,uFlag,uBufLen,pDest,puCopied)

#define IActiveIME_Configure(This,hKL,hWnd,dwMode,pRegisterWord)	\
    (This)->lpVtbl -> Configure(This,hKL,hWnd,dwMode,pRegisterWord)

#define IActiveIME_Destroy(This,uReserved)	\
    (This)->lpVtbl -> Destroy(This,uReserved)

#define IActiveIME_Escape(This,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> Escape(This,hIMC,uEscape,pData,plResult)

#define IActiveIME_SetActiveContext(This,hIMC,fFlag)	\
    (This)->lpVtbl -> SetActiveContext(This,hIMC,fFlag)

#define IActiveIME_ProcessKey(This,hIMC,uVirKey,lParam,pbKeyState)	\
    (This)->lpVtbl -> ProcessKey(This,hIMC,uVirKey,lParam,pbKeyState)

#define IActiveIME_Notify(This,hIMC,dwAction,dwIndex,dwValue)	\
    (This)->lpVtbl -> Notify(This,hIMC,dwAction,dwIndex,dwValue)

#define IActiveIME_Select(This,hIMC,fSelect)	\
    (This)->lpVtbl -> Select(This,hIMC,fSelect)

#define IActiveIME_SetCompositionString(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionString(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIME_ToAsciiEx(This,uVirKey,uScanCode,pbKeyState,fuState,hIMC,pdwTransBuf,puSize)	\
    (This)->lpVtbl -> ToAsciiEx(This,uVirKey,uScanCode,pbKeyState,fuState,hIMC,pdwTransBuf,puSize)

#define IActiveIME_RegisterWord(This,szReading,dwStyle,szString)	\
    (This)->lpVtbl -> RegisterWord(This,szReading,dwStyle,szString)

#define IActiveIME_UnregisterWord(This,szReading,dwStyle,szString)	\
    (This)->lpVtbl -> UnregisterWord(This,szReading,dwStyle,szString)

#define IActiveIME_GetRegisterWordStyle(This,nItem,pStyleBuf,puBufSize)	\
    (This)->lpVtbl -> GetRegisterWordStyle(This,nItem,pStyleBuf,puBufSize)

#define IActiveIME_EnumRegisterWord(This,szReading,dwStyle,szRegister,pData,ppEnum)	\
    (This)->lpVtbl -> EnumRegisterWord(This,szReading,dwStyle,szRegister,pData,ppEnum)

#define IActiveIME_GetCodePageA(This,uCodePage)	\
    (This)->lpVtbl -> GetCodePageA(This,uCodePage)

#define IActiveIME_GetLangId(This,plid)	\
    (This)->lpVtbl -> GetLangId(This,plid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIME_Inquire_Proxy( 
    IActiveIME * This,
    /* [in] */ DWORD dwSystemInfoFlags,
    /* [out] */ IMEINFO *pIMEInfo,
    /* [out] */ LPWSTR szWndClass,
    /* [out] */ DWORD *pdwPrivate);


void __RPC_STUB IActiveIME_Inquire_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_ConversionList_Proxy( 
    IActiveIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPWSTR szSource,
    /* [in] */ UINT uFlag,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST *pDest,
    /* [out] */ UINT *puCopied);


void __RPC_STUB IActiveIME_ConversionList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_Configure_Proxy( 
    IActiveIME * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDW *pRegisterWord);


void __RPC_STUB IActiveIME_Configure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_Destroy_Proxy( 
    IActiveIME * This,
    /* [in] */ UINT uReserved);


void __RPC_STUB IActiveIME_Destroy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_Escape_Proxy( 
    IActiveIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ void *pData,
    /* [out] */ LRESULT *plResult);


void __RPC_STUB IActiveIME_Escape_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_SetActiveContext_Proxy( 
    IActiveIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ BOOL fFlag);


void __RPC_STUB IActiveIME_SetActiveContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_ProcessKey_Proxy( 
    IActiveIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uVirKey,
    /* [in] */ DWORD lParam,
    /* [in] */ BYTE *pbKeyState);


void __RPC_STUB IActiveIME_ProcessKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_Notify_Proxy( 
    IActiveIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwAction,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwValue);


void __RPC_STUB IActiveIME_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_Select_Proxy( 
    IActiveIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ BOOL fSelect);


void __RPC_STUB IActiveIME_Select_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_SetCompositionString_Proxy( 
    IActiveIME * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ void *pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ void *pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIME_SetCompositionString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_ToAsciiEx_Proxy( 
    IActiveIME * This,
    /* [in] */ UINT uVirKey,
    /* [in] */ UINT uScanCode,
    /* [in] */ BYTE *pbKeyState,
    /* [in] */ UINT fuState,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD *pdwTransBuf,
    /* [out] */ UINT *puSize);


void __RPC_STUB IActiveIME_ToAsciiEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_RegisterWord_Proxy( 
    IActiveIME * This,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szString);


void __RPC_STUB IActiveIME_RegisterWord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_UnregisterWord_Proxy( 
    IActiveIME * This,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szString);


void __RPC_STUB IActiveIME_UnregisterWord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_GetRegisterWordStyle_Proxy( 
    IActiveIME * This,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFW *pStyleBuf,
    /* [out] */ UINT *puBufSize);


void __RPC_STUB IActiveIME_GetRegisterWordStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_EnumRegisterWord_Proxy( 
    IActiveIME * This,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordW **ppEnum);


void __RPC_STUB IActiveIME_EnumRegisterWord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_GetCodePageA_Proxy( 
    IActiveIME * This,
    /* [out] */ UINT *uCodePage);


void __RPC_STUB IActiveIME_GetCodePageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_GetLangId_Proxy( 
    IActiveIME * This,
    /* [out] */ LANGID *plid);


void __RPC_STUB IActiveIME_GetLangId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIME_INTERFACE_DEFINED__ */


#ifndef __IActiveIME2_INTERFACE_DEFINED__
#define __IActiveIME2_INTERFACE_DEFINED__

/* interface IActiveIME2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIME2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e1c4bf0e-2d53-11d2-93e1-0060b067b86e")
    IActiveIME2 : public IActiveIME
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Sleep( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unsleep( 
            /* [in] */ BOOL fDead) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIME2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIME2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIME2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIME2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Inquire )( 
            IActiveIME2 * This,
            /* [in] */ DWORD dwSystemInfoFlags,
            /* [out] */ IMEINFO *pIMEInfo,
            /* [out] */ LPWSTR szWndClass,
            /* [out] */ DWORD *pdwPrivate);
        
        HRESULT ( STDMETHODCALLTYPE *ConversionList )( 
            IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR szSource,
            /* [in] */ UINT uFlag,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pDest,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *Configure )( 
            IActiveIME2 * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW *pRegisterWord);
        
        HRESULT ( STDMETHODCALLTYPE *Destroy )( 
            IActiveIME2 * This,
            /* [in] */ UINT uReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Escape )( 
            IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ void *pData,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *SetActiveContext )( 
            IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fFlag);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessKey )( 
            IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uVirKey,
            /* [in] */ DWORD lParam,
            /* [in] */ BYTE *pbKeyState);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *Select )( 
            IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fSelect);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionString )( 
            IActiveIME2 * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ void *pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ void *pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *ToAsciiEx )( 
            IActiveIME2 * This,
            /* [in] */ UINT uVirKey,
            /* [in] */ UINT uScanCode,
            /* [in] */ BYTE *pbKeyState,
            /* [in] */ UINT fuState,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwTransBuf,
            /* [out] */ UINT *puSize);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWord )( 
            IActiveIME2 * This,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWord )( 
            IActiveIME2 * This,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyle )( 
            IActiveIME2 * This,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW *pStyleBuf,
            /* [out] */ UINT *puBufSize);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWord )( 
            IActiveIME2 * This,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodePageA )( 
            IActiveIME2 * This,
            /* [out] */ UINT *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLangId )( 
            IActiveIME2 * This,
            /* [out] */ LANGID *plid);
        
        HRESULT ( STDMETHODCALLTYPE *Sleep )( 
            IActiveIME2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Unsleep )( 
            IActiveIME2 * This,
            /* [in] */ BOOL fDead);
        
        END_INTERFACE
    } IActiveIME2Vtbl;

    interface IActiveIME2
    {
        CONST_VTBL struct IActiveIME2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIME2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIME2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIME2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIME2_Inquire(This,dwSystemInfoFlags,pIMEInfo,szWndClass,pdwPrivate)	\
    (This)->lpVtbl -> Inquire(This,dwSystemInfoFlags,pIMEInfo,szWndClass,pdwPrivate)

#define IActiveIME2_ConversionList(This,hIMC,szSource,uFlag,uBufLen,pDest,puCopied)	\
    (This)->lpVtbl -> ConversionList(This,hIMC,szSource,uFlag,uBufLen,pDest,puCopied)

#define IActiveIME2_Configure(This,hKL,hWnd,dwMode,pRegisterWord)	\
    (This)->lpVtbl -> Configure(This,hKL,hWnd,dwMode,pRegisterWord)

#define IActiveIME2_Destroy(This,uReserved)	\
    (This)->lpVtbl -> Destroy(This,uReserved)

#define IActiveIME2_Escape(This,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> Escape(This,hIMC,uEscape,pData,plResult)

#define IActiveIME2_SetActiveContext(This,hIMC,fFlag)	\
    (This)->lpVtbl -> SetActiveContext(This,hIMC,fFlag)

#define IActiveIME2_ProcessKey(This,hIMC,uVirKey,lParam,pbKeyState)	\
    (This)->lpVtbl -> ProcessKey(This,hIMC,uVirKey,lParam,pbKeyState)

#define IActiveIME2_Notify(This,hIMC,dwAction,dwIndex,dwValue)	\
    (This)->lpVtbl -> Notify(This,hIMC,dwAction,dwIndex,dwValue)

#define IActiveIME2_Select(This,hIMC,fSelect)	\
    (This)->lpVtbl -> Select(This,hIMC,fSelect)

#define IActiveIME2_SetCompositionString(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionString(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIME2_ToAsciiEx(This,uVirKey,uScanCode,pbKeyState,fuState,hIMC,pdwTransBuf,puSize)	\
    (This)->lpVtbl -> ToAsciiEx(This,uVirKey,uScanCode,pbKeyState,fuState,hIMC,pdwTransBuf,puSize)

#define IActiveIME2_RegisterWord(This,szReading,dwStyle,szString)	\
    (This)->lpVtbl -> RegisterWord(This,szReading,dwStyle,szString)

#define IActiveIME2_UnregisterWord(This,szReading,dwStyle,szString)	\
    (This)->lpVtbl -> UnregisterWord(This,szReading,dwStyle,szString)

#define IActiveIME2_GetRegisterWordStyle(This,nItem,pStyleBuf,puBufSize)	\
    (This)->lpVtbl -> GetRegisterWordStyle(This,nItem,pStyleBuf,puBufSize)

#define IActiveIME2_EnumRegisterWord(This,szReading,dwStyle,szRegister,pData,ppEnum)	\
    (This)->lpVtbl -> EnumRegisterWord(This,szReading,dwStyle,szRegister,pData,ppEnum)

#define IActiveIME2_GetCodePageA(This,uCodePage)	\
    (This)->lpVtbl -> GetCodePageA(This,uCodePage)

#define IActiveIME2_GetLangId(This,plid)	\
    (This)->lpVtbl -> GetLangId(This,plid)


#define IActiveIME2_Sleep(This)	\
    (This)->lpVtbl -> Sleep(This)

#define IActiveIME2_Unsleep(This,fDead)	\
    (This)->lpVtbl -> Unsleep(This,fDead)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIME2_Sleep_Proxy( 
    IActiveIME2 * This);


void __RPC_STUB IActiveIME2_Sleep_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME2_Unsleep_Proxy( 
    IActiveIME2 * This,
    /* [in] */ BOOL fDead);


void __RPC_STUB IActiveIME2_Unsleep_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIME2_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_CActiveIMM;

#ifdef __cplusplus

class DECLSPEC_UUID("4955DD33-B159-11d0-8FCF-00AA006BCC59")
CActiveIMM;
#endif
#endif /* __ActiveIMM_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\antievt.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module	ANTIEVT.C |
 *
 *	Purpose:
 *		implemenation of common antievents and a caching mechanism
 *
 *	Author:
 *		alexgo 3/25/95
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_m_undo.h"
#include "_edit.h"
#include "_antievt.h"
#include "_range.h"
#include "_select.h"
#include "_format.h"
#include "_coleobj.h"
#include "_objmgr.h"
#ifdef DEBUG
#include "_uspi.h"
#endif

ASSERTDATA


//
// CAntiEventDispenser global instance
//
CAntiEventDispenser gAEDispenser;


//
//	CBaseAE PUBLIC methods
//

/*
 *	CBaseAE::Destroy ()
 *
 *	@mfunc
 *		sends the Destroy notification to the next antievent in the list
 */

void CBaseAE::Destroy()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CBaseAE::Destroy");
}

/*
 *	CBaseAE::Undo (ped, publdr)
 *
 *	@mfunc
 *		sends the Undo notification to the next antievent in the list
 *
 *	@rdesc	HRESULT
 */
HRESULT CBaseAE::Undo(
	CTxtEdit *	  ped,		//@parm	Edit context for this undo operation
	IUndoBuilder *publdr)	//@parm Undo context.
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CBaseAE::Undo");
	return NOERROR;
}

/*
 *	CBaseAE::OnCommit (ped)
 *
 *	@mfunc	called after the antievent is added to the undo stack
 *
 *	@rdesc	void
 */
void CBaseAE::OnCommit(
	CTxtEdit *ped)			//@parm Edit context
{
}

/*
 *	CBaseAE::MergeData (dwDataType, pdata)
 *
 *	@mfunc	simply forwards the merge data request to the next antievent
 *			(if one exists)
 *
 *	@rdesc	HRESULT.  If S_FALSE, indicates that nothing could be done
 *			with the merge data.
 */
HRESULT	CBaseAE::MergeData(
	DWORD dwDataType, 		//@parm Type of data in <p pdata>
	void *pdata)			//@parm Merge data
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CBaseAE::MergeData");

	return S_FALSE;
}

/*
 *	CBaseAE::SetNext(pNext)
 *
 *	@mfunc
 *		informs this antievent of the antievent which should follow it
 */
void CBaseAE::SetNext(
	IAntiEvent *pNext)		//@parm	the AntiEvent to link to
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CBaseAE::SetNext");

	_pnext  = pNext;
}

/*
 *	CBaseAE::GetNext()
 *
 *	@mfunc
 *		retrieves the next element (if any)
 *
 *	@rdesc	a pointer to the next AntiEvent
 */
IAntiEvent *CBaseAE::GetNext()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CBaseAE::GetNext");

	return _pnext;
}

//
// CBaseAE PROTECTED methods
//

/*
 *	CBaseAE::CBaseAE()
 *
 *	@mfunc	Constructor
 */
CBaseAE::CBaseAE()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CBaseAE::CBaseAE");

	_pnext = NULL;
}

/* 
 *	CReplaceRangeAE::Destroy ()
 *
 *	@mfunc
 *		deletes this instance
 */
void CReplaceRangeAE::Destroy()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceRangeAE::Destroy");

	if(_paeCF)
	{
		_paeCF->Destroy();
		_paeCF = NULL;
	}
	if(_paePF)
	{
		_paePF->Destroy();
		_paePF = NULL;
	}

	CBaseAE::Destroy();
	delete this;
}
	
/*
 *	CReplaceRangeAE::Undo (ped, publdr)
 *
 *	@mfunc
 *		undoes a CTxtPtr::ReplaceRange operation
 *
 *	@rdesc
 *		HRESULT
 *
 *	@comm	
 *	Algorithm:
 *
 *		A replace range works as follows:  delete n characters and in their
 *		place, put m characters.
 *
 *		To undo this, we delete m characters and restore the n that were
 *		originally deleted.  Note that we restore the n characters with
 *		default formatting.  If there was any other formatting to those
 *		characters, a separate antievent (CReplaceFormattingAE) will
 *		apply the correct formatting.
 */
HRESULT CReplaceRangeAE::Undo(
	CTxtEdit *	  ped,		//@parm	Context for this undo operation
	IUndoBuilder *publdr)	//@parm Undo context	
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceRangeAE::Undo");

	CRchTxtPtr rtp(ped, _cpMin);
	LONG	   cchMove = 0;

	rtp.ReplaceRange(_cpMax - _cpMin, _cchDel, _pchDel,
					 publdr, -1, &cchMove,
					 RR_ITMZ_NONE | RR_NO_TRD_CHECK);	// RAID 6554

	// Passing NULL for the publdr is *extremely* important
	// below.  The rich text pointer ReplaceRange call will
	// already generate the appropriate antievents for any 
	// deleted formatting, so we do not need to repeat that here.
	if(_paeCF)
		_paeCF->Undo(ped, NULL);

	if(_paePF)
		_paePF->Undo(ped, NULL);

	if (ped->IsComplexScript())
	{
		// For complex script doc, we need itemization at the end of the range undo.
		// Since the formattings were rolled back, the rtp's runptrs are no longer
		// reliable.
		if (_paeCF && rtp._rpCF.IsValid())
			rtp._rpCF.BindToCp(_cpMin + _cchDel);

		if (_paePF && rtp._rpPF.IsValid())
			rtp._rpPF.BindToCp(_cpMin + _cchDel);

		rtp.ItemizeReplaceRange(_cchDel, cchMove, NULL, FALSE);
	}
	return CBaseAE::Undo(ped, publdr);
}

/*
 *	CReplaceRangeAE::MergeData (dwDataType, pdata)	
 *
 *	@mfunc	gives the caller a chance to extend the current antievent
 *			if we're in merge typing mode
 *
 *	@rdesc
 *		HRESULT
 *
 *	@comm	if the requested data can be trivially merged into this
 *			antievent, then do so; otherwise, return S_FALSE.
 *
 *			There are two cases of interest:  <nl>
 *				1. typing another character
 *				2. backspacing over a character in this merge
 *				   typing session.
 */
HRESULT CReplaceRangeAE::MergeData(
	DWORD dwDataType, 		//@parm	Type of <p pdata>
	void *pdata)			//@parm Merge data
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceRangeAE::MergeData");

	if(dwDataType == MD_SIMPLE_REPLACERANGE)
	{
		SimpleReplaceRange *psr = (SimpleReplaceRange *)pdata;

		// Test for first case: just typing another character
		if(psr->cpMin == _cpMax && psr->cchDel == 0)
		{
			_cpMax = psr->cpMax;
			return NOERROR;
		}
		// Second case: deleting text stored in this antievent
		if (psr->cpMax == psr->cpMin &&
			psr->cpMin + psr->cchDel == _cpMax &&
			psr->cpMin >= _cpMin)
		{
			_cpMax = psr->cpMax;
			return NOERROR;
		}
	}
	return S_FALSE;
}	

/* 
 *	CReplaceRangeAE::CReplaceRangeAE (cpMin, cpMax, cchDel, pchDel, paeCF, paePF)
 *
 *	@mfunc	Constructor for a text replace range antievent
 */
CReplaceRangeAE::CReplaceRangeAE(
	LONG cpMin, 		//@parm cp starting the *final* range
	LONG cpMax, 		//@parm cp ending the *final* range
	LONG cchDel, 		//@parm # of chars deleted during ReplaceRange
	WCHAR *pchDel, 		//@parm Deleted characters. Ownership xfers to this object
	IAntiEvent *paeCF,	//@parm Antievent for any character formatting replacement
	IAntiEvent *paePF)	//@parm Antievent for any paragraph formatting replacement
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceRangeAE::CReplaceRangeAE");

	_cpMin 	= cpMin;
	_cpMax 	= cpMax;
	_cchDel = cchDel;
	_pchDel	= pchDel;
	_paeCF  = paeCF;
	_paePF  = paePF;
}

/*
 *	CReplaceRangeAE::~CReplaceRangeAE ()
 *
 *	@mfunc	Destructor
 */
CReplaceRangeAE::~CReplaceRangeAE()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceRangeAE::~CReplaceRangeAE");
		
	if(_pchDel)
		delete _pchDel;
}

/*
 *	CReplaceFormattingAE
 *
 *	@mfunc	Destroys this instance
 */
void CReplaceFormattingAE::Destroy()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceFormattingAE::Destroy");

	CBaseAE::Destroy();
	delete this;
}

/*
 *	CReplaceFormattingAE::Undo (ped, publdr)
 *
 *	@mfunc		Undoes a formatting operation
 *
 *	@rdesc
 *		HRESULT
 *
 *	@devnote	This antievent assumes that the text to which formatting
 *				should be applied exists!!
 */			
HRESULT CReplaceFormattingAE::Undo(
	CTxtEdit *	  ped,		//@parm CTxtEdit closure
	IUndoBuilder *publdr)	//@parm Undo builder context
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceFormattingAE::Undo");

	LONG			cchEaten;
	LONG			cchTotal = 0;
	LONG			delta;
	LONG			iRunMerge;
	IAntiEvent *	pae;
	IFormatCache *	pf = _fPara
					   ? (IFormatCache *)GetParaFormatCache()
					   : (IFormatCache *)GetCharFormatCache();
	CNotifyMgr *	pnm = ped->GetNotifyMgr();
	CFormatRuns **	ppfmtruns;
	CTxtStory *		pStory = ped->GetTxtStory();
	const CParaFormat * pDefPF = _fPara ? pStory->GetParaFormat(-1) : NULL;
	BYTE			bDefPFLevel = pDefPF && pDefPF->IsRtl() ? 1 : 0;

	// First set things up correctly for whether we are paragraph
	// or character formatting
	CFormatRunPtr rp(_fPara ? pStory->GetPFRuns() :pStory->GetCFRuns());

	// Count up count of characters affected
	for(LONG i = 0 ; i < _cRuns; i++)
		cchTotal += _prgRuns[i]._cch;

	// We are going to be adding in some runs, so be sure the format
	// run array is allocated!
	if(!rp.IsValid())
	{
		ppfmtruns = _fPara ? &(pStory->_pPFRuns) : &(pStory->_pCFRuns);

		if(!rp.InitRuns(0, ped->GetTextLength(), ppfmtruns))
			return E_OUTOFMEMORY;

		// tell folks we allocated a new run
		if(pnm)
			pnm->NotifyPostReplaceRange(NULL, CP_INFINITE, 0, 0, CP_INFINITE, CP_INFINITE);
	} 
	// Now do a pre-notification of the change we are about to make
	// This lets objects like a delayed render data object grab
	// any data *before* we change it.


	// Do a little more checking
#ifdef DEBUG
	LONG	cchText = ped->GetTextLength();
	LONG	cp =
#endif
	rp.BindToCp(_cp);

	AssertSz(_cp == cp && rp.CalcTextLength() == cchText && _cp <= cchText,
		"CReplaceFormattingAE::Undo: invalid cp");

	if(pnm)
		pnm->NotifyPreReplaceRange(NULL, CP_INFINITE, 0, 0, _cp, _cp + cchTotal);

	// We want to merge runs with where we start plus one behind
	iRunMerge = rp._iRun;
	if(iRunMerge > 0)
		iRunMerge--;

	// If we need to be able to undo this operation, go through and
	// save existing run information
	if(publdr)
	{
		LONG	cchBackup = 0, cchMove = 0;
		if (ped->IsBiDi())
		{
			// For redo'ing purpose, we expand the range to keep in the antievent
			// to make sure that BiDi levels are recorded adequately.
			CRchTxtPtr	rtp(ped, _cp);
			cchBackup = rtp.ExpandRangeFormatting(cchTotal, 0, cchMove);
			Assert(cchBackup <= 0);
			rp.Move(cchBackup);
		}
		pae = gAEDispenser.CreateReplaceFormattingAE(ped, _cp + cchBackup, rp,
					cchTotal - cchBackup + cchMove, pf, _fPara);
		rp.Move(-cchBackup);

		if(pae)
			publdr->AddAntiEvent(pae);
	}	

	// Now go through and apply the saved formatting.
	for(i = 0; i < _cRuns; i++)
	{
		cchEaten = 0;

        // Use a do-while, because we may have a zero-length
        // format run.  We know we need to do "something" at
        // least once, because otherwise, we would not have
        // bothered creating a run!
		do 
		{
			if (_fPara && _prgRuns[i]._iFormat == -1)
				// (#6768) The -1 format may have changed before undoing.
				_prgRuns[i]._level._value = bDefPFLevel;

			delta = rp.SetFormat(_prgRuns[i]._iFormat, 
							_prgRuns[i]._cch - cchEaten, pf, &_prgRuns[i]._level);
			if(delta == -1)
			{
				ped->GetCallMgr()->SetOutOfMemory();
				break;
			}
			cchEaten += delta;
		} while(cchEaten < _prgRuns[i]._cch);
	}

	// Merge formatting runs in case there are duplicate formatting
	// runs side by side
    rp.NextRun();
	rp.MergeRuns(iRunMerge, pf);

	// Make sure the runs are still OK  
	AssertNr(rp.CalcTextLength() == cchText);

	if(pnm)
		pnm->NotifyPostReplaceRange(NULL, CP_INFINITE, 0, 0, _cp, _cp + cchTotal);

	ped->GetCallMgr()->SetChangeEvent(CN_GENERIC);

	return CBaseAE::Undo(ped, publdr);
}

/*
 *	CReplaceFormattingAE::CReplaceFormattingAE(ped, cp, &rpIn, cch, pf, fPara)
 *
 *	@mfunc	Constructor.  During construction, we will loop through and
 *			find all of the formats for the given text range
 */
CReplaceFormattingAE::CReplaceFormattingAE(
	CTxtEdit *	   ped,		//@parm CTxtEdit
	LONG		   cp,		//@parm cp at start of replace
	CFormatRunPtr &rpIn, 	//@parm	Run pointer to start with
	LONG		   cch,		//@parm cch to find formatting info on
	IFormatCache * pf,		//@parm Format cache (to AddRef/Release formats) 
	BOOL		   fPara)	//@parm If TRUE, formatting is for paras
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceFormattingAE::CReplaceFormattingAE");

    LONG		  cchLeft;
	LONG		  cchTemp = cch;
	CFormatRunPtr rp(rpIn);			// We use 2 format run pointers to avoid
	CFormatRunPtr rpTemp(rpIn);		// backing up after counting the number of
									// format runs
	Assert(pf);

	_cp = cp;
	AssertSz(_cp == (cp = rpIn.CalculateCp()),
		"CReplaceFormattingAE::CReplaceFormattingAE: illegal cp");

	_fPara = fPara;

	// Count the number of formats needed.  Recall that even if no characters
    // are to be deleted, we may still be "deleting" a zero length format run.
	_cRuns = 0;
    do
	{
		_cRuns++;
        cchLeft = rp.GetCchLeft();
		cchTemp -= min(cchLeft, cchTemp);
	} while(rp.NextRun() && cchTemp > 0);

	_prgRuns = new CFormatRun[_cRuns];
	if(!_prgRuns)
	{
		_cRuns = 0;
		return;
	}

	for(LONG i = 0; i < _cRuns; i++)
	{
		_prgRuns[i]._cch = min(cch, rpTemp.GetCchLeft());
		CFormatRun *pRun = rpTemp.GetRun(0);

		_prgRuns[i]._iFormat = pRun->_iFormat;
		_prgRuns[i]._level	 = pRun->_level;

		pf->AddRef(_prgRuns[i]._iFormat);
		rpTemp.NextRun();
		cch -= _prgRuns[i]._cch;
	}
	Assert(cch == 0);
}

/*
 * 	CReplaceFormattingAE::~CReplaceFormattingAE	()
 *
 *	@mfunc	Destructor
 */
CReplaceFormattingAE::~CReplaceFormattingAE()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceFormattingAE::~CReplaceFormattingAE");

	IFormatCache *	pf = _fPara
					   ? (IFormatCache *)GetParaFormatCache()
					   : (IFormatCache *)GetCharFormatCache();
	if(_prgRuns)
	{
		if(pf)
		{
			for(LONG i = 0; i < _cRuns; i++)
				pf->Release(_prgRuns[i]._iFormat);
		}
		delete _prgRuns;
	}
}

//
//	CReplaceObjectAE PUBLIC methods
//

/*
 *	CReplaceObjectAE::Destroy()
 *
 *	@mfunc	Destroy's this object
 */
void CReplaceObjectAE::Destroy()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceObjectAE::Destroy");

	COleObject *pobj = _pobj;
	_pobj = NULL;

	// We only need to zombie the object if it wasn't put back into
	// the document.
	if(!_fUndoInvoked)
		pobj->MakeZombie();

	pobj->Release();
	CBaseAE::Destroy();
	delete this;
}

/*
 *	CReplaceObjectAE::Undo (ped, publdr)
 *
 *	@mfunc
 *		Undo'es the delete operation and restores the object
 *		to its original state
 *
 *	@rdesc	HRESULT
 */
HRESULT CReplaceObjectAE::Undo(
	CTxtEdit *	  ped,		//@parm	Edit context
	IUndoBuilder *publdr)	//@parm Undo/redo context
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceObjectAE::Undo");

	CObjectMgr *pobjmgr = ped->GetObjectMgr();
	if(_pobj && pobjmgr)
	{
		_fUndoInvoked = TRUE;
		_pobj->Restore();
		pobjmgr->RestoreObject(_pobj);
	}
	return CBaseAE::Undo(ped, publdr);
}

/*
 *	CReplaceObjectAE::OnCommit(ped)
 *
 *	@mfunc	called when the antievent chain is committed to the
 *			undo stack.  This gives us a chance to make 'dangerous'
 *			calls that could cause us to be re-entered.
 */
void CReplaceObjectAE::OnCommit(
	CTxtEdit *ped)			//@parm Edit context
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceObjectAE::OnCommit");
	_pobj->Close(OLECLOSE_SAVEIFDIRTY);
}

//
//	CReplaceObjectAE PRIVATE methods
//

/*
 *	CReplaceObjectAE::CReplaceObjectAE (pobj)
 *
 *	@mfunc	constructor
 */
CReplaceObjectAE::CReplaceObjectAE(
	COleObject *pobj)		//@parm Object that was deleted
{
	_fUndoInvoked = FALSE;
	_pobj = pobj;
	_pobj->AddRef();
}

/*
 *	CReplaceObjectAE::~CReplaceObjectAE
 *
 *	@mfunc	destructor
 */
CReplaceObjectAE::~CReplaceObjectAE()
{
	Assert(_pobj == NULL);
}

//
//	CResizeObjectAE PUBLIC methods
//

/*
*	CResizeObjectAE::Destroy ()
 *
 *	@mfunc	Destroy's this object
 */
void CResizeObjectAE::Destroy()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CResizeObjectAE::Destroy");

	_pobj = NULL;
	CBaseAE::Destroy();

	delete this;
}

/*
 *	CResizeObjectAE::Undo(ped, publdr)
 *
 *	@mfunc	Undo'es the resize operation and restores the object
 *			to it's original size/position
 *
 *	@rdesc	HRESULT
 */
HRESULT CResizeObjectAE::Undo(
	CTxtEdit *	  ped,		//@parm	Edit context
	IUndoBuilder *publdr)	//@parm Undo/redo context
{
	CObjectMgr *pobjmgr;

	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceObjectAE::Undo");

	pobjmgr = ped->GetObjectMgr();

	if(_pobj && pobjmgr)
	{
		_fUndoInvoked = TRUE;
		_pobj->Resize(_size, FALSE);
	}

	return CBaseAE::Undo(ped, publdr);
}

/*
 *	CResizeObjectAE::OnCommit(ped)
 *
 *	@mfunc	called when the antievent chain is committed to the
 *			undo stack.  This gives us a chance to make 'dangerous'
 *			calls that could cause us to be re-entered.
 */
void CResizeObjectAE::OnCommit(
	CTxtEdit *ped)			//@parm Edit context
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceObjectAE::OnCommit");
}

//
//	CResizeObjectAE PRIVATE methods
//

/*
 *	CResizeObjectAE::CResizeObjectAE (pobj, size)
 *
 *	@mfunc	constructor
 */
CResizeObjectAE::CResizeObjectAE(
	COleObject *pobj,		//@parm Object that was resized
	SIZEUV		size)		//@parm Old size
{
	_fUndoInvoked = FALSE;
	_pobj = pobj;
	_size = size;
}

/*
 *	CResizeObjectAE::~CResizeObjectAE
 *
 *	@mfunc	destructor
 */
CResizeObjectAE::~CResizeObjectAE()
{
	Assert(_pobj == NULL);
}

//
//  CSelectionAE PUBLIC methods
//

/*
 *  CSelectionAE::Destroy ()
 *
 *  @mfunc  gets rid of this instance
 */
void CSelectionAE::Destroy()
{
    TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CSelectionAE::Destroy");

    CBaseAE::Destroy();
    delete this;
}

/*
 *  CSelectionAE::Undo (ped, publdr)
 *
 *  @mfunc  Restore selection to its former position
 *
 *  @rdesc  NOERROR
 */
HRESULT CSelectionAE::Undo(
    CTxtEdit *	  ped,		//@parm Edit context
    IUndoBuilder *publdr)   //@parm Undo context
{
    TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CSelectionAE::Destroy");

    CTxtSelection *psel = ped->GetSel();

    if(psel)
        psel->SetDelayedSelectionRange(_cp, _cch);

	if(publdr)
	{
		IAntiEvent *pae;
		pae = gAEDispenser.CreateSelectionAE(ped, _cpNext, _cchNext, 
					_cp, _cch);
		if(pae)
			publdr->AddAntiEvent(pae);
	}
	return CBaseAE::Undo(ped, publdr);
}

/*
 *  CSelectionAE::MergeData(dwDataType, pdata)
 *
 *  @mfunc  merges new selection data
 *
 *  @rdesc  S_FALSE, NOERROR
 *
 *	@comm	The mergine algorithm is fairly tricky.  There are basically two
 *			cases of interest:  group typing and drag-move.
 *
 *			In the group typing case, the "start" of the typing becomes a
 *			fixed reference from which characters are added or removed (i.e.
 *			you type or hit the backspace key).  "Undo" should return you to
 *			that reference point; redo, on the other hand, should return the
 *			selection to the last insertion point.  Thus, we only update
 *			_xxNext for the SELAE_MERGE action.
 *
 *			Drag-Move is somewhat different; in this case, there are really
 *			two actions--the "paste" on the drop, and the subsequent "cut"
 *			operation.  Thus, we need to be able to update the selection
 *			antievent during the cut (since this only happens on move; not
 *			copies).  This is accomplished with teh FORCEREPLACE flag
 *			and by setting fields to -1 to be ignored.
 *
 */
HRESULT CSelectionAE::MergeData(
    DWORD dwDataType,       //@parm Type of data in <p pdata>
    void *pdata)            //@parm Merge data
{
    TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CSelectionAE::MergeData");

    SelRange *psrg = (SelRange *)pdata;

    if(dwDataType == MD_SELECTIONRANGE)
    {
		if(psrg->flags == SELAE_MERGE)
		{
			Assert(psrg->cpNext != -1);
			_cpNext = psrg->cpNext;
			_cchNext = psrg->cchNext;
		}
		else
		{
			// -1 is used a no-op, so we should ignore it
			if(psrg->cp != -1)
			{
				_cp = psrg->cp;
				_cch = psrg->cch;
			}
			if(psrg->cpNext != -1)
			{
				_cpNext = psrg->cpNext;
				_cchNext = psrg->cchNext;
			}
		}
        return NOERROR;
    }
    return S_FALSE;
}

//
//  CSelectionAE PRIVATE methods
//

/*
 *  CSelectionAE::CSelectionAE (cp, cch, cpNext, cchNext)
 *
 *  @mfunc  Constructor
 */
CSelectionAE::CSelectionAE(
    LONG    cp,			//@parm Active end cp
    LONG    cch,        //@parm Signed extension
	LONG	cpNext,		//@parm cp to use for the AE of this AE
	LONG	cchNext)	//@parm cch for the AE of this AE
{
    _cp			= cp;
    _cch		= cch;
    _cpNext		= cpNext;
	_cchNext	= cchNext;
}

/*
 *  CSelectionAE::~CSelectionAE()
 *
 *  @mfunc  desctructor
 */
CSelectionAE::~CSelectionAE()
{
    ;
}

/*
 *	CAntiEventDispenser::CreateReplaceRangeAE(ped, cpMin, cpMax, cchDel,
 *											  pchDel, paeCF, paePF)
 *	@mfunc
 *		creates an antievent for a replace range operation 
 *
 *	@rdesc
 *		IAntiEvent *
 */
IAntiEvent * CAntiEventDispenser::CreateReplaceRangeAE(
	CTxtEdit *	ped,	//@parm edit context
	LONG		cpMin, 	//@parm cp starting the *final* range
	LONG		cpMax, 	//@parm cp ending the *final* range
	LONG		cchDel, //@parm # of chars deleted during ReplaceRange
	WCHAR *		pchDel,	//@parm Deleted chars. Ownership transfers to this object
	IAntiEvent *paeCF,	//@parm Antievent for any char formatting replacement
	IAntiEvent *paePF)	//@parm Antievent for any para formatting replacement	
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CAntiEventDispenser::CreateReplaceRangeAE");

	// FUTURE (alexgo): improve the efficiency of this routine!!
	IAntiEvent *pae = (IAntiEvent *)(new CReplaceRangeAE(cpMin, cpMax,
									cchDel, pchDel, paeCF, paePF));
	if(!pae)
	{
		// We don't need to do anything else; the callmgr will discard
		// undo for us.
		ped->GetCallMgr()->SetOutOfMemory();
	}
	return pae;
}

/*
 *	CAntiEventDispenser::CreateReplaceFormattingAE(ped, cp, &rp, cch, pf, fPara)
 *
 *	@mfunc
 *		Creates an antievent for replacing formatting
 *
 *	@rdesc
 *		IAntiEvent *
 */
IAntiEvent * CAntiEventDispenser::CreateReplaceFormattingAE(
	CTxtEdit *		ped,	//@parm Edit context
	LONG			cp,		//@parm Position at start of replace
	CFormatRunPtr &	rp,		//@parm	Run pointer to start with
	LONG			cch,	//@parm Count of characters to find formatting info on
	IFormatCache *	pf,		//@parm Format cache (to AddRef/Release formats) 
	BOOL			fPara)	//@parm If TRUE, formatting is paragraphs
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CAntiEventDispenser::CreateReplaceFormattingAE");

	// FUTURE (alexgo): improve the efficiency of this routine!!!
	IAntiEvent *pae = (IAntiEvent *)(new CReplaceFormattingAE(ped, cp, rp, cch, pf, fPara));
	if(!pae)
	{
		// We don't need to do anything else; the callmgr will discard
		// undo for us.
		ped->GetCallMgr()->SetOutOfMemory();
	}
	return pae;
}

/*
 *	CAntiEventDispenser::CreateReplaceObjectAE (ped, pobj)
 *
 *	@mfunc	Creates an antievent for replacing an object
 *
 *	@rdesc
 *		IAntiEvent * created
 */
IAntiEvent * CAntiEventDispenser::CreateReplaceObjectAE(
	CTxtEdit *	ped,	//@parm Edit context.
	COleObject *pobj)	//@parm Object that was deleted
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, 
		"CAntiEventDispenser::CreateReplaceObjectAE");

	// Always allocating is probably a reasonable strategy for objects;
	// they are not expected to be the bread & butter case.
	IAntiEvent *pae = (IAntiEvent *)(new CReplaceObjectAE(pobj));
	if(!pae)
	{
		// We don't need to do anything else; the callmgr will discard
		// undo for us.
		ped->GetCallMgr()->SetOutOfMemory();
	}
	return pae;
}

/*
 *	CAntiEventDispenser::CreateResizeObjectAE (ped, pobj, size)
 *
 *	@mfunc	Creates an antievent for resizing an object
 *
 *	@rdesc	the created antievent
 */
IAntiEvent * CAntiEventDispenser::CreateResizeObjectAE(
	CTxtEdit *	ped,	//@parm Edit context.
	COleObject *pobj,	//@parm Object that was resized
	SIZEUV		size)	//@parm Old object position rectangle
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, 
		"CAntiEventDispenser::CreateResizeeObjectAE");

	// Always allocating is probably a reasonable strategy for objects;
	// they are not expected to be the bread & butter case.
	IAntiEvent *pae = (IAntiEvent *)(new CResizeObjectAE(pobj, size));
	if(!pae)
	{
		// We don't need to do anything else; the callmgr will discard
		// undo for us.
		ped->GetCallMgr()->SetOutOfMemory();
	}
	return pae;
}

/*
 *  CAntiEventDispenser::CreateSelectionAE (ped, cp, cch, cpNext, cchNext)
 *
 *  @mfunc  Creates an antievent for restoring a non-degenerate selection
 *
 *  @rdesc  created antievent
 */
IAntiEvent * CAntiEventDispenser::CreateSelectionAE(
	CTxtEdit *ped,		//@parm Edit context
    LONG    cp,			//@parm Active end of selection
    LONG    cch,        //@parm Signed extension
	LONG	cpNext,		//@parm cp to use for AE of this AE
	LONG	cchNext)	//@parm cch to use for AE 
{
	// FUTURE (alexgo): improve the efficiency of this routine
	IAntiEvent *pae = (IAntiEvent *)(new CSelectionAE(cp, cch, cpNext, cchNext));
	if(!pae)
	{
		// We don't need to do anything else; the callmgr will discard
		// undo for us.
		ped->GetCallMgr()->SetOutOfMemory();
	}
	return pae;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\aimm_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.01.75 */
/* at Tue Jan 13 08:56:29 1998
 */
/* Compiler settings for aimm.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID LIBID_ActiveIMM = {0x4955DD30,0xB159,0x11d0,{0x8F,0xCF,0x00,0xAA,0x00,0x6B,0xCC,0x59}};


const IID IID_IEnumRegisterWordA = {0x08C03412,0xF96B,0x11d0,{0xA4,0x75,0x00,0xAA,0x00,0x6B,0xCC,0x59}};


const IID IID_IEnumRegisterWordW = {0x4955DD31,0xB159,0x11d0,{0x8F,0xCF,0x00,0xAA,0x00,0x6B,0xCC,0x59}};


const IID IID_IAIMMRegistrar = {0xc7afa428,0x5007,0x11d1,{0xaa,0x94,0x00,0x60,0xb0,0x67,0xb8,0x6e}};


const IID IID_IActiveIMMMessagePumpOwner = {0xb5cf2cfa,0x8aeb,0x11d1,{0x93,0x64,0x00,0x60,0xb0,0x67,0xb8,0x6e}};


const IID IID_IActiveIMMApp = {0x08c0e040,0x62d1,0x11d1,{0x93,0x26,0x00,0x60,0xb0,0x67,0xb8,0x6e}};


const IID IID_IActiveIMMIME = {0x08C03411,0xF96B,0x11d0,{0xA4,0x75,0x00,0xAA,0x00,0x6B,0xCC,0x59}};


const IID IID_IActiveIME = {0x6FE20962,0xD077,0x11d0,{0x8F,0xE7,0x00,0xAA,0x00,0x6B,0xCC,0x59}};


const CLSID CLSID_CActiveIMM = {0x4955DD33,0xB159,0x11d0,{0x8F,0xCF,0x00,0xAA,0x00,0x6B,0xCC,0x59}};

/* c1ee01f2-b3b6-4a6a-9ddd-e988c088ec82 */
const CLSID CLSID_CActiveIMM12 = { 
    0xc1ee01f2,
    0xb3b6,
    0x4a6a,
    {0x9d, 0xdd, 0xe9, 0x88, 0xc0, 0x88, 0xec, 0x82}
  };

/* D7A6F58A-D478-44ab-86C9-591C23A26534 */
const IID IID_IActiveIMMAppEx = {
	0xD7A6F58A,
	0xD478,
	0x44ab,
	{0x86, 0xC9, 0x59, 0x1C, 0x23, 0xA2, 0x65, 0x34}};

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\cbhost.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	LBHOST.CPP -- Text Host for CreateWindow() Rich Edit 
 *		Combo Box Control | 
 *		Implements CCmbBxWinHost message
 *		
 *	Original Author: 
 *		Jerry Kim
 *
 *	History: <nl>
 *		01/30/97 - v-jerrki Created
 *
 *	Set tabs every four (4) columns
 *
 *	Copyright (c) 1997-2000 Microsoft Corporation. All rights reserved.
 */
#include "_common.h"

#ifndef NOLISTCOMBOBOXES

#include "_host.h"
#include "imm.h"
#include "_format.h"
#include "_edit.h"
#include "_cfpf.h"
#include "_cbhost.h"

ASSERTDATA

// Helper function in edit.cpp
LONG GetECDefaultHeightAndWidth(
	ITextServices *pts,
	HDC hdc,
	LONG lZoomNumerator,
	LONG lZoomDenominator,
	LONG yPixelsPerInch,
	LONG *pxAveWidth,
	LONG *pxOverhang,
	LONG *pxUnderhang);

// For effeciency and to avoid Winnt thunking layer we will call
// the listbox winproc directly
extern "C" LRESULT CALLBACK RichListBoxWndProc(
	HWND hwnd,
	UINT msg,
	WPARAM wparam,
	LPARAM lparam);

//////////////////////////// System Window Procs ////////////////////////////
/*
 *	RichComboBoxWndProc (hwnd, msg, wparam, lparam)
 *
 *	@mfunc
 *		Handle window messages pertinent to the host and pass others on to
 *		text services. 
 *	@rdesc
 *		LRESULT = (code processed) ? 0 : 1
 */
extern "C" LRESULT CALLBACK RichComboBoxWndProc(
	HWND hwnd,
	UINT msg,
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "RichComboBoxWndProc");

	LRESULT	lres = 1;	//signify we didn't handle the message
	HRESULT hr = S_FALSE;
	CCmbBxWinHost *phost = (CCmbBxWinHost *) GetWindowLongPtr(hwnd, ibPed);

#ifdef DEBUG
	Tracef(TRCSEVINFO, "hwnd %lx, msg %lx, wparam %lx, lparam %lx", hwnd, msg, wparam, lparam);
#endif	// DEBUG

	switch(msg)
	{
	case WM_NCCREATE:
		return CCmbBxWinHost::OnNCCreate(hwnd, (CREATESTRUCT *)lparam);

	case WM_CREATE:
		// We may be on a system with no WM_NCCREATE (e.g. WINCE)
		if (!phost)
		{
			(void) CCmbBxWinHost::OnNCCreate(hwnd, (CREATESTRUCT *) lparam);
			phost = (CCmbBxWinHost *) GetWindowLongPtr(hwnd, ibPed);
		}
		break;

	case WM_DESTROY:
		if(phost)
			CCmbBxWinHost::OnNCDestroy(phost);
		return 0;
	}

	if (!phost)
		return ::DefWindowProc(hwnd, msg, wparam, lparam);

	// in certain out-of-memory situations, clients may try to re-enter us 
	// with calls.  Just bail on the call if we don't have a text services
	// pointer.
	if(!phost->_pserv)
		return 0;

	// stabilize ourselves
	phost->AddRef();

	switch(msg)
	{
	case WM_MOUSEMOVE:
		if (!phost->OnMouseMove(wparam, lparam))
			break;
		goto serv;

	case WM_MOUSELEAVE:
		lres = phost->OnMouseLeave(wparam, lparam);
		break;

	case WM_LBUTTONUP:
		if (!phost->OnLButtonUp(wparam, lparam))
			break;
		goto serv;

	case WM_MOUSEWHEEL:
		if (!phost->OnMouseWheel(wparam, lparam))
			break;
		goto defproc;

	case WM_LBUTTONDBLCLK:
	case WM_LBUTTONDOWN:
		if (!phost->OnLButtonDown(wparam, lparam))
			goto Exit;
		goto serv;

	case WM_COMMAND:
		if (!phost->OnCommand(wparam, lparam))
			break;
		goto serv;		

	case WM_CREATE:
		lres = phost->OnCreate((CREATESTRUCT*)lparam);
		break;
	
	case WM_KEYDOWN:
		if (!phost->OnKeyDown((WORD) wparam, (DWORD) lparam))
			break;								
		goto serv;						//  give it to text services		   

	case WM_SETTEXT:
		if (phost->_cbType != CCmbBxWinHost::kDropDown)
		{
			lres = CB_ERR;
			break;
		}
		phost->_fIgnoreChange = 1;
		phost->_nCursor = -2;			// Reset last selected item
		goto serv;
		
	case WM_GETTEXT:
		GETTEXTEX gt;
		if (W32->OnWin9x() || phost->_fANSIwindow)
			W32->AnsiFilter( msg, wparam, lparam, (void *) &gt );
		goto serv;

	case WM_GETTEXTLENGTH:
		GETTEXTLENGTHEX gtl;
		if (W32->OnWin9x() || phost->_fANSIwindow)
			W32->AnsiFilter( msg, wparam, lparam, (void *) &gtl );
		goto serv;
		
	case WM_CHAR:

		if (W32->OnWin9x() || phost->_fANSIwindow)
		{
			CW32System::WM_CHAR_INFO wmci;
			wmci._fAccumulate = phost->_fAccumulateDBC != 0;
			W32->AnsiFilter( msg, wparam, lparam, (void *) &wmci );
			if (wmci._fLeadByte)
			{
				phost->_fAccumulateDBC = TRUE;
				phost->_chLeadByte = wparam << 8;
				goto Exit;					// Wait for trail byte
			}
			else if (wmci._fTrailByte)
			{
				// UNDONE:
				// Need to see what we should do in WM_IME_CHAR
				wparam = phost->_chLeadByte | wparam;
				phost->_fAccumulateDBC = FALSE;
				phost->_chLeadByte = 0;
				msg = WM_IME_CHAR;
				goto serv;
			}
			else if (wmci._fIMEChar)
			{
				msg = WM_IME_CHAR;
				goto serv;
			}
			else if (wmci._fIMEChar)
			{
				msg = WM_IME_CHAR;
				goto serv;
			}
		}
	
		if(!phost->OnChar((WORD) wparam, (DWORD) lparam))
			// processed code: break out
			break;							
		goto serv;							//  else give it to text services

	case WM_DRAWITEM:
		lres = phost->CbMessageItemHandler(NULL, ITEM_MSG_DRAWLIST, wparam, lparam);
		if (lres)
			break;
		goto defproc;

	case WM_DELETEITEM:
		lres = phost->CbMessageItemHandler(NULL, ITEM_MSG_DELETE, wparam, lparam);
		if (lres)
			break;
		goto defproc;		

	case WM_ENABLE:
		if (phost->OnEnable(wparam, lparam))
		{
			if(!wparam ^ phost->_fDisabled)
			{
				// Stated of window changed so invalidate it so it will
				// get redrawn.
				InvalidateRect(phost->_hwnd, NULL, TRUE);
				phost->SetScrollBarsForWmEnable(wparam);

				// Need to enable the listbox window
				::EnableWindow(phost->_hwndList, wparam);
			}
			phost->_fDisabled = !wparam;				// Set disabled flag
			lres = 0;							// Return value for message
		}
											// Fall thru to WM_SYSCOLORCHANGE?
	case WM_SYSCOLORCHANGE:
		//forward message to listbox first then pass to textservice
		SendMessage(phost->_hwndList, msg, wparam, lparam);
		phost->OnSysColorChange();
		goto serv;							// Notify text services that
											//  system colors have changed
	case WM_GETDLGCODE:
		//forward message to listbox first then pass to textservice
		SendMessage(phost->_hwndList, msg, wparam, lparam);
		lres = phost->OnGetDlgCode(wparam, lparam);
		break;

    case WM_STYLECHANGING:
		// Just pass this one to the default window proc
		lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		break;
		
	case WM_SIZE:
		lres = phost->OnSize(wparam, lparam);
		break;

	case WM_SETCURSOR:
		//	Only set cursor when over us rather than a child; this
		//	helps prevent us from fighting it out with an inplace child
		if((HWND)wparam == hwnd)
		{
			if(!(lres = ::DefWindowProc(hwnd, msg, wparam, lparam)))
				lres = phost->OnSetCursor(wparam, lparam);
		}
		break;

	case WM_SHOWWINDOW:
		hr = phost->OnTxVisibleChange((BOOL)wparam);
		break;

	case WM_NCPAINT:
		RECT	rcClient;

		GetClientRect(hwnd, &rcClient);
		lres = 0;
		if (rcClient.bottom - rcClient.top <= phost->_cyCombo && !phost->DrawCustomFrame(wparam, NULL))
			lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		break;

	case WM_PAINT:
		lres = phost->OnPaint(wparam, lparam);
		break;

	case WM_KILLFOCUS:
		lres = phost->OnKillFocus(wparam, lparam);
		if (!lres)
			goto serv;
		goto defproc;

	case LBCB_TRACKING:
		// release any mousedown stuff
		phost->OnLButtonUp(0, 0);
		phost->_fFocus = 1;
		phost->_fLBCBMessage = 1;
		// Fall through case!!!
		
	case WM_SETFOCUS:
		lres = phost->OnSetFocus(wparam, lparam);		
		if (lres)
			goto defproc;
		goto serv;

	case WM_SYSKEYDOWN:
		if (phost->OnSyskeyDown((WORD)wparam, (DWORD)lparam))
			goto serv;
		break;

	case WM_CAPTURECHANGED:
		if (!phost->OnCaptureChanged(wparam, lparam))
			goto serv;
		break;

	case WM_MEASUREITEM:
		lres = phost->CbMessageItemHandler(NULL, ITEM_MSG_MEASUREITEM, wparam, lparam);
		goto Exit;

	//bug fix #4076
	case CB_GETDROPPEDSTATE:
		lres = phost->_fListVisible;
		goto Exit;

	// combo box messages
	case CB_GETEXTENDEDUI:
		lres = phost->CbGetExtendedUI();
		break;

	case CB_SETEXTENDEDUI:
		lres = phost->CbSetExtendedUI(wparam);
		break;
	
    case CB_SETITEMHEIGHT:
		lres = phost->CbSetItemHeight(wparam, lparam);
		break;

	case CB_GETITEMHEIGHT:
		lres = phost->CbGetItemHeight(wparam, lparam);
		break;

    case CB_SETDROPPEDWIDTH:
		phost->CbSetDropWidth(wparam);
		// fall thru

    case CB_GETDROPPEDWIDTH:
		lres = phost->CbGetDropWidth();
		break;

// Listbox specific messages
    case CB_DELETESTRING:
    	msg = LB_DELETESTRING;
    	goto deflstproc;

    case CB_SETTOPINDEX:
    	msg = LB_SETTOPINDEX;
    	goto deflstproc;

    case CB_GETTOPINDEX:
    	msg = LB_GETTOPINDEX;
    	goto deflstproc;
 
    case CB_GETCOUNT:
    	msg = LB_GETCOUNT;
    	goto deflstproc;
    	
    case CB_GETCURSEL:
    	msg = LB_GETCURSEL;
    	goto deflstproc;
    	
    case CB_GETLBTEXT:
    	msg = LB_GETTEXT;
    	goto deflstproc;
    	
    case CB_GETLBTEXTLEN:
    	msg = LB_GETTEXTLEN;
    	goto deflstproc;
    	
    case CB_INSERTSTRING:
    	msg = LB_INSERTSTRING;
    	goto deflstproc;
    	
    case CB_RESETCONTENT:
    	msg = LB_RESETCONTENT;
    	goto deflstproc;

    case CB_FINDSTRING:
    	msg = LB_FINDSTRING;
    	goto deflstproc;

    case CB_FINDSTRINGEXACT:
    	msg = LB_FINDSTRINGEXACT;
    	goto deflstproc;

    case CB_SELECTSTRING:
    	//bug fix
    	// The system control does 2 things here.  1) selects the requested item
    	// 2) sets the newly selected item to the top of the list
    	lres = CB_ERR;
    	if (phost->_hwndList)
    	{
    		lres = RichListBoxWndProc(phost->_hwndList, LB_SELECTSTRING, wparam, lparam);
    		phost->UpdateEditBox();
    	}
    	break;    	

    case CB_GETITEMDATA:
    	msg = LB_GETITEMDATA;
    	goto deflstproc;

    case CB_SETITEMDATA:
    	msg = LB_SETITEMDATA;
    	goto deflstproc;

    case CB_SETCURSEL:
    	//bug fix
    	// The system control does 2 things here.  1) selects the requested item
    	// 2) sets the newly selected item to the top of the list
    	if (phost->_hwndList)
    	{
    		lres = RichListBoxWndProc(phost->_hwndList, LB_SETCURSEL, wparam, lparam);
    		if (lres != -1)
    			RichListBoxWndProc(phost->_hwndList, LB_SETTOPINDEX, wparam, 0);
    		phost->UpdateEditBox();
    	}
    	break;

	case CB_ADDSTRING:
		msg = LB_ADDSTRING;
		goto deflstproc;

    case CB_GETHORIZONTALEXTENT:
		msg = LB_GETHORIZONTALEXTENT;
		goto deflstproc;

    case CB_SETHORIZONTALEXTENT:
		msg = LB_SETHORIZONTALEXTENT;
		goto deflstproc;

// edit box specific messages
    case CB_GETEDITSEL:
		msg = EM_GETSEL;
		goto serv;

    case CB_LIMITTEXT:
		msg = EM_SETLIMITTEXT;
		goto serv;    	
    
    case CB_SETEDITSEL:
    	if (phost->_cbType == CCmbBxWinHost::kDropDownList)
    	{
    	    lres = CB_ERR;
    		break;
    	}
    	msg = EM_SETSEL;
		// When we are in a dialog box that is empty, EM_SETSEL will not select
		// the final always existing EOP if the control is rich.
		if (phost->_fUseSpecialSetSel &&
			((CTxtEdit *)phost->_pserv)->GetAdjustedTextLength() == 0 &&
			wparam != -1)
		{
			lparam = 0;
			wparam = 0;
		}
		else
		{			
			//parameters are different between CB and EM messages
			wparam = (WPARAM)(signed short)LOWORD(lparam);
			lparam = (LPARAM)(signed short)HIWORD(lparam);
		}
		goto serv;

	
	case EM_SETMARGINS:  //PPT uses this message for the combo box. bug fix #4072
		// We need to keep track of the margins size because we have a minimum inset
		// value bug fix #4659
		if (wparam & EC_LEFTMARGIN)
			phost->_dxLOffset = LOWORD(lparam);
		if (wparam & EC_RIGHTMARGIN)
			phost->_dxROffset = HIWORD(lparam);
		phost->OnSetMargins(wparam, LOWORD(lparam) + phost->_dxLInset, 
			HIWORD(lparam) + phost->_dxRInset);
		break;
		
	case EM_GETOPTIONS:
		lres = phost->OnGetOptions();
		break;
		
	case EM_SETOPTIONS:
		phost->OnSetOptions((WORD) wparam, (DWORD) lparam);
		lres = (phost->_dwStyle & ECO_STYLES);
		if(phost->_fEnableAutoWordSel)
			lres |= ECO_AUTOWORDSELECTION;
		break;

	case EM_HIDESELECTION:
		if(lparam)
		{
			DWORD dwPropertyBits = 0;

			phost->_dwStyle |= ES_NOHIDESEL;
			if(wparam)
			{
				phost->_dwStyle &= ~ES_NOHIDESEL;
				dwPropertyBits = TXTBIT_HIDESELECTION;
			}

			// Notify text services of change in status.
			phost->_pserv->OnTxPropertyBitsChange(TXTBIT_HIDESELECTION, 
				dwPropertyBits);
		}
		goto serv;

	case EM_GETPASSWORDCHAR:
#ifndef NOACCESSIBILITY    
		lres = 0;
		break;
#endif

	// We should ignore any EM_ messages which we don't handle ourselves
	case EM_SETPALETTE:
	case EM_GETRECT:
	case EM_SETBKGNDCOLOR:
	case EM_SETPASSWORDCHAR:
	case EM_SETREADONLY:
	case EM_SETRECTNP:							
	case EM_SETRECT:	
//	case CB_INITSTORAGE:        
    case CB_SETLOCALE:
    case CB_GETLOCALE:
		AssertSz(FALSE, "Message not supported");
		//FALL THROUGH!!!

	case WM_STYLECHANGED:
		break;

	case CB_GETDROPPEDCONTROLRECT:
		lres = 0;
		if (lparam)
		{
			RECT rcList;
			lres = 1;
			phost->GetListBoxRect(rcList);
			memcpy((void *)lparam, &rcList, sizeof(RECT));
		}
		break;

	case EM_SETTEXTEX:
		phost->OnSetTextEx(wparam, lparam);
		break;

	case EM_SETEDITSTYLE:
		lres = phost->OnSetEditStyle(wparam, lparam);
		break;

    case CB_SHOWDROPDOWN:
		if (wparam && !phost->_fListVisible)
		{
			phost->ShowListBox(TRUE);
			phost->TxSetCapture(TRUE);
			phost->_fCapture = TRUE;
		}
		else if (!wparam && phost->_fListVisible)
		{
			phost->HideListBox(TRUE, FALSE);
		}
        break;

#ifndef NOACCESSIBILITY        
	case WM_GETOBJECT:	
		IUnknown* punk;
		phost->QueryInterface(IID_IUnknown, (void**)&punk);
		Assert(punk);
		lres = W32->LResultFromObject(IID_IUnknown, wparam, (LPUNKNOWN)punk);
		AssertSz(!FAILED((HRESULT)lres), "WM_GETOBJECT message FAILED\n");
		punk->Release();
		break;
#endif		
		
	default:
		//CTxtWinHost message handler
serv:
		hr = phost->_pserv->TxSendMessage(msg, wparam, lparam, &lres);

defproc:
		if(hr == S_FALSE)
		{			
			// Message was not processed by text services so send it
			// to the default window proc.
			lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		}

		// Need to do some things after we send the message to ITextService
		switch (msg)
		{
		case EM_SETSEL:
			phost->_pserv->TxSendMessage(EM_HIDESELECTION, 0, 0, NULL);
			lres = 1;
			break;

		case EM_SETLIMITTEXT:
			lres = 1;								// Need to return 1 per SDK documentation
			break;

		case WM_SETTINGCHANGE:
			phost->CbCalcControlRects(NULL, FALSE);	// Need to resize control after setting change
			break;

		case WM_SETTEXT:
			phost->_fIgnoreChange = 0;
			break;

		case WM_SETFONT:
		{
			// Special border processing. The inset changes based on the size of the
			// defautl character set. So if we got a message that changes the default
			// character set, we need to update the inset.
			// Update our font height member variable with the new fonts height
			// Get the inset information
			HDC hdc = GetDC(hwnd);
			LONG xAveCharWidth = 0;
			LONG yCharHeight = GetECDefaultHeightAndWidth(phost->_pserv, hdc, 1, 1,
				W32->GetYPerInchScreenDC(), &xAveCharWidth, NULL, NULL);
			ReleaseDC(hwnd, hdc);

			if (yCharHeight)
				phost->_dyFont = yCharHeight;

			// force a recalculation of the edit control
			phost->_dyEdit = 0;
			phost->CbCalcControlRects(&phost->_rcWindow, TRUE);

			// force a resize of the control
			phost->_fListVisible = 1;
			phost->HideListBox(FALSE, FALSE);
		}
			goto deflstproc;
			
		case EM_FORMATRANGE:
		case EM_SETPARAFORMAT:
		case EM_SETCHARFORMAT:
		case EM_SETLANGOPTIONS:
		case EM_SETBIDIOPTIONS:
		case EM_SETTYPOGRAPHYOPTIONS:
			goto deflstproc;			
		}
		break;

deflstproc:
		//CLstBxWinHost message handler
		Assert(phost->_hwndList);
		if (phost->_hwndList)
		{
			lres = SendMessage(phost->_hwndList, msg, wparam, lparam);
			
			switch (msg)
			{
			case LB_RESETCONTENT:
				//need to remove the content from the edit box
				phost->_fIgnoreChange = 1;
				phost->_pserv->TxSendMessage(WM_SETTEXT, wparam, NULL, &lres);
				phost->_fIgnoreChange = 0;
				// Fall thru to update the listbox

			case LB_SETCURSEL:
				// need to update the edit control
				phost->UpdateEditBox();
				break;	
			}
		}
		break;				
	}	

Exit:
	phost->Release();
	return lres;
}


//////////////// CCmbBxWinHost Creation/Initialization/Destruction ///////////////////////
#ifndef NOACCESSIBILITY
/*
 *	CCmbBxWinHost::QueryInterface(REFIID riid, void **ppv)
 *
 *	@mfunc
 *		
 */
HRESULT CCmbBxWinHost::QueryInterface(
	REFIID riid, 
	void **ppv)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::QueryInterface");
  
  	if(riid == IID_IAccessible)
		*ppv = (IAccessible*)this;
    else if (riid == IID_IDispatch)
		*ppv = (IDispatch*)(IAccessible*)this;
    else if (IsEqualIID(riid, IID_IUnknown))
		*ppv = (IUnknown*)(IAccessible*)this;
    else
        return CTxtWinHost::QueryInterface(riid, ppv);

	AddRef();		
	return NOERROR;
}
#endif

/*
 *	CCmbBxWinHost::OnNCCreate (hwnd, pcs)
 *
 *	@mfunc
 *		Static global method to handle WM_NCCREATE message (see remain.c)
 */
LRESULT CCmbBxWinHost::OnNCCreate(
	HWND hwnd,
	const CREATESTRUCT *pcs)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnNCCreate");


	CCmbBxWinHost *phost = new CCmbBxWinHost();

	if (!phost)
	{
		// Allocation failure.
		return 0;
	}

	if(!phost->Init(hwnd, pcs))					// Stores phost in associated
	{											//  window data
		phost->Shutdown();
		delete phost;
		return 0;
	}
	return TRUE;
}

/*
 *	CCmbBxWinHost::OnNCDestroy (phost)
 *
 *	@mfunc
 *		Static global method to handle WM_NCCREATE message
 *
 *	@devnote
 *		phost ptr is stored in window data (GetWindowLongPtr())
 */
void CCmbBxWinHost::OnNCDestroy(
	CCmbBxWinHost *phost)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnNCDestroy");

	// NOTE:
	//	We have to be careful when we destroy the window because there can be cases
	// when we have a valid hwnd but no host for the hwnd so we have to check for
	// both cases

	phost->_fShutDown = 1;
	if (phost->_plbHost)
	{
		phost->_plbHost->_fShutDown = 1;
		phost->_plbHost->Release();
	}
		
	// Destroy list box here so we will get the WM_DELETEITEM before the
	// combo box gets destroyed
	if (phost->_hwndList)
		DestroyWindow(phost->_hwndList);

	phost->Shutdown();
	phost->Release();
	
}

/*
 *	CCmbBxWinHost::CCmbBxWinHost()
 *
 *	@mfunc
 *		constructor
 */
CCmbBxWinHost::CCmbBxWinHost(): CTxtWinHost(), _plbHost(NULL), _hwndList(NULL), _hcurOld(NULL)
{
	//_dxLInset = _dxRInset = 0;
	//_fIgnoreUpdate = 0;
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::CTxtWinHost");
}

/*
 *	CCmbBxWinHost::~CCmbBxWinHost()
 *
 *	@mfunc
 *		destructor
 */
CCmbBxWinHost::~CCmbBxWinHost()
{
}

/*
 *	CCmbBxWinHost::Init (hwnd, pcs)
 *
 *	@mfunc
 *		Initialize this CCmbBxWinHost
 */
BOOL CCmbBxWinHost::Init(
	HWND hwnd,					//@parm Window handle for this control
	const CREATESTRUCT *pcs)	//@parm Corresponding CREATESTRUCT
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::Init");

	if(!pcs->lpszClass)
		return -1;

	//_fRightAlign = 0;
	//_fListVisible = 0;
	//_fOwnerDraw = 0;
	//_fOwnerDrawVar = 0;
	//_fFocus = 0;
	//_fMousedown = 0;
	//_cyList = 0;
	//_cxList = 0;
	//_fDisabled = 0;
	//_fNoIntegralHeight = 0;
	_idCtrl = (UINT)(DWORD_PTR) pcs->hMenu;
	//_fKeyMaskSet = 0;
	//_fMouseMaskSet = 0;
	//_fScrollMaskSet = 0;
	_nCursor = -2;
	//_fExtendedUI = 0;
	//_fLBCBMessage = 0;
	//_dxROffset = _dxLOffset = 0;

	// Set pointer back to CCmbBxWinHost from the window
	if(hwnd)
		SetWindowLongPtr(hwnd, ibPed, (INT_PTR)this);

	_hwnd = hwnd;

	if(pcs)
	{
		_hwndParent = pcs->hwndParent;
		_dwExStyle	= pcs->dwExStyle;
		_dwStyle	= pcs->style;

		// We need to change our Extended because we don't support most of them
		DWORD dwExStyle = _dwExStyle & (WS_EX_LEFTSCROLLBAR | WS_EX_TOPMOST | WS_EX_RIGHT |
							WS_EX_RTLREADING | WS_EX_CLIENTEDGE); 
		//	NOTE:
		//	  The order in which we check the style flags immulate
		//	WinNT's order.  So please verify with NT order before
		//	reaaranging order.
		if (_dwStyle & CBS_DROPDOWN)
		{
			_cbType = kDropDown;
			if (_dwStyle & CBS_SIMPLE)
				_cbType = kDropDownList;
		}
		else
		{
			AssertSz(FALSE, "CBS_SIMPLE not supported");
		}

		if (_dwStyle & (CBS_OWNERDRAWFIXED | CBS_OWNERDRAWVARIABLE))
		{
			_fOwnerDraw = 1;
			_fOwnerDrawVar = !!(_dwStyle & CBS_OWNERDRAWVARIABLE);
		}
			
		if (_dwStyle & WS_DISABLED)
			_fDisabled = 1;

		if (_dwStyle & CBS_NOINTEGRALHEIGHT)
			_fNoIntegralHeight = 1;

		// the combobox doesn't support ES_RIGHT because its value is the 
		// same as CBS_DROPDOWN!!
		if (_dwExStyle & WS_EX_RIGHT)
		{
			_fRightAlign = 1;
			_dwStyle |= ES_RIGHT;
		}

		// implicitly set the ES_AUTOHSCROLL style bit
		_dwStyle |= ES_AUTOHSCROLL;				
		// _dwStyle &= ~ES_AUTOVSCROLL;

		// If we have any kind of border it will always be a 3d border
		if (_dwStyle & WS_BORDER || _dwExStyle & WS_EX_CLIENTEDGE)
		{
			_fBorder = 1;
			_dwStyle &= ~WS_BORDER;
			_dwExStyle |= WS_EX_CLIENTEDGE;
			dwExStyle |= WS_EX_CLIENTEDGE;
		}

		// handle default disabled
		if(_dwStyle & WS_DISABLED)
			_fDisabled = TRUE;

		DWORD dwStyle = _dwStyle;

		// Remove the scroll style for the edit window
		dwStyle &= ~(WS_VSCROLL | WS_HSCROLL);

        // Set the window styles
        SetWindowLong(_hwnd, GWL_STYLE, dwStyle);
        SetWindowLong(_hwnd, GWL_EXSTYLE, dwExStyle);
	}

	DWORD dwStyleSaved = _dwStyle;

	// get rid of all ES styles except ES_AUTOHSCROLL and ES_RIGHT
	_dwStyle &= (~(0x0FFFFL) | ES_AUTOHSCROLL | ES_RIGHT);

	// Create Text Services component
	if(FAILED(CreateTextServices()))
		return FALSE;

	_dwStyle = dwStyleSaved;
	_xInset = 1;
	_yInset = 1;

	PARAFORMAT PF2;	
	PF2.dwMask = 0;
	if(_dwExStyle & WS_EX_RIGHT)
	{
		PF2.dwMask |= PFM_ALIGNMENT;
		PF2.wAlignment = (WORD)(PFA_RIGHT);	// right or center-aligned
	}

	if(_dwExStyle & WS_EX_RTLREADING)
	{
		PF2.dwMask |= PFM_RTLPARA;
		PF2.wEffects = PFE_RTLPARA;		// RTL reading order
	}

	if (PF2.dwMask)
	{
		PF2.cbSize = sizeof(PARAFORMAT2);
		//  tell text services
		_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (LPARAM)&PF2, NULL);
	}
	
	PARAFORMAT PF;							// If left or right alignment,
	if(_fRightAlign)				//  tell text services
	{
		PF.cbSize = sizeof(PARAFORMAT);
		PF.dwMask = PFM_ALIGNMENT;
		PF.wAlignment = (WORD)PFA_RIGHT;
		_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (LPARAM)&PF, NULL);
	}

	//bug fix #4644 we want the EN_CHANGE and EN_UPDATE notifications
	_pserv->TxSendMessage(EM_SETEVENTMASK, 0, ENM_UPDATE | ENM_CHANGE, NULL);

	// Tell textservices to turn-on auto font sizing
	_pserv->TxSendMessage(EM_SETLANGOPTIONS, 0, 
			IMF_AUTOKEYBOARD | IMF_AUTOFONT | IMF_AUTOFONTSIZEADJUST | IMF_UIFONTS |
			IMF_IMEALWAYSSENDNOTIFY, NULL);

	return TRUE;
}


/*
 *	CCmbBxWinHost::OnCreate (pcs)
 *
 *	@mfunc
 *		Handle WM_CREATE message
 *
 *	@rdesc
 *		LRESULT = -1 if failed to in-place activate; else 0
 */
LRESULT CCmbBxWinHost::OnCreate(
	const CREATESTRUCT *pcs)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnCreate");

	RECT rcClient;

	// sometimes, these values are -1 (from windows itself); just treat them
	// as zero in that case
	LONG cy = (pcs->cy < 0) ? 0 : pcs->cy;
	LONG cx = (pcs->cx < 0) ? 0 : pcs->cx;

	rcClient.top = pcs->y;
	rcClient.bottom = rcClient.top + cy;
	rcClient.left = pcs->x;
	rcClient.right = rcClient.left + cx;

	// Notify Text Services that we are in place active
	if(FAILED(_pserv->OnTxInPlaceActivate(&rcClient)))
		return -1;	

	// Get the font height to base the control heights from
	// Initially the font height is the item height	
	HDC hdc = GetDC(_hwnd);	
	LONG xAveCharWidth = 0;
	_dyFont = GetECDefaultHeightAndWidth(_pserv, hdc, 1, 1,
		W32->GetYPerInchScreenDC(), &xAveCharWidth, NULL, NULL);
	Assert(_dyFont != 0); // _yInset should be zero since listbox's doesn't have yinsets

	ReleaseDC(_hwnd, hdc);
	
	
	// init variables
	_idCtrl = (UINT)(DWORD_PTR)pcs->hMenu;

	// Need to calculate the rects of EVERYTHING!!
	// Force a request of itemHeight
	_rcButton.left = 0;
	_dyEdit = 0;
	_cyList = -1;
	CbCalcControlRects(&rcClient, TRUE);

	// Now lets handle the listbox stuff!
	// create and tranlate styles for combo box to listbox
	DWORD lStyle = WS_BORDER | WS_CHILD | WS_VISIBLE | LBS_NOTIFY | LBS_COMBOBOX | WS_CLIPSIBLINGS;
	if (_dwStyle & CBS_HASSTRINGS)
		lStyle |= LBS_HASSTRINGS;

	if (_dwStyle & CBS_SORT)
		lStyle |= LBS_SORT;

	if (_dwStyle & CBS_DISABLENOSCROLL)
		lStyle |= LBS_DISABLENOSCROLL;

	if (_dwStyle & CBS_NOINTEGRALHEIGHT)
		lStyle |= LBS_NOINTEGRALHEIGHT;

	if (_dwStyle & CBS_OWNERDRAWFIXED)
		lStyle |= LBS_OWNERDRAWFIXED;
	else if (_dwStyle & CBS_OWNERDRAWVARIABLE)
		lStyle |= LBS_OWNERDRAWVARIABLE;


	// copy over some window styles
	lStyle |= (_dwStyle & WS_DISABLED);
	lStyle |= (_dwStyle & (WS_VSCROLL | WS_HSCROLL));

	// no longer need scrollbar or else the editbox will look bad
	_dwStyle &= ~(WS_VSCROLL | WS_HSCROLL);

	DWORD lExStyle = _dwExStyle & (WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR);

	//NOTE. It doesn't matter if the listbox is made with the correct size since
	// it's going to get resized anyways
	if (!W32->OnWin9x())
	{
		//WinNT
		_hwndList = ::CreateWindowExW(lExStyle | WS_EX_TOOLWINDOW, L"REListBox20W", 
					NULL, lStyle, _rcList.left, _rcList.top, _rcList.right - _rcList.left,
					_rcList.bottom - _rcList.top, _hwnd, (HMENU)CB_LISTBOXID, NULL, this);
	}
	else
	{
		// Win '95, '98 system
		_hwndList = ::CreateWindowExA(lExStyle | WS_EX_TOOLWINDOW, "REListBox20W", 
					NULL, lStyle, _rcList.left, _rcList.top, _rcList.right - _rcList.left,
					_rcList.bottom - _rcList.top, _hwnd, (HMENU)CB_LISTBOXID, NULL, this);
	}

	Assert(_hwndList);
	_plbHost = (CLstBxWinHost *) GetWindowLongPtr(_hwndList, ibPed);
	Assert(_plbHost);
	if (!_plbHost)
		return -1;
		
	// increment reference counter!
	_plbHost->AddRef();

	if (_cbType != kSimple)
		ShowWindow(_hwndList, SW_HIDE);
	SetParent(_hwndList, NULL);

	_fIgnoreChange = 1;
	if (_cbType == kDropDownList)
	{			
		AssertSz(!((CTxtEdit*)_pserv)->_fReadOnly, "edit is readonly");
		
		// Tell textservices to select the entire background
		_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_EXTENDBACKCOLOR, SES_EXTENDBACKCOLOR, NULL);	

		// format the paragraph to immulate the system control
		PARAFORMAT2 pf;
		pf.cbSize = sizeof(PARAFORMAT2);
		pf.dwMask = PFM_STARTINDENT;
		pf.dxStartIndent = (1440.0 / W32->GetXPerInchScreenDC());
		_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (LPARAM)&pf, NULL);
		_usIMEMode = ES_NOIME;
		// Tell textservices to turnoff ime
		_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_NOIME, SES_NOIME, NULL);	

	}
	else
	{
		// make the richedit control behave like the edit control		
		_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_EMULATESYSEDIT, SES_EMULATESYSEDIT, NULL);
	}

	// Need to resize the list box
	if (_cbType != kSimple)
		SetDropSize(&_rcList);

	_fIgnoreChange = 0;
	return 0;
}


/////////////////////////// CCmbBxWinHost Helper functions /////////////////////////////////
/*
 *	CCmbBxWinHost::GetTextLength ()
 *
 *	@mfunc
 *		returns the text length of the edit control using CR and NOT CRLF
 *
 *	@rdesc
 *		LRESULT = text length
 */
LRESULT CCmbBxWinHost::GetTextLength()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::GetTextLength");

	LRESULT lr = 0;
	GETTEXTLENGTHEX gtl;
	gtl.flags = GTL_NUMCHARS | GTL_PRECISE;
	gtl.codepage = 1200;

#ifdef DEBUG
	HRESULT hr = _pserv->TxSendMessage(EM_GETTEXTLENGTHEX, (WPARAM)&gtl, 0, &lr);
	Assert(hr == NOERROR);
#else
	_pserv->TxSendMessage(EM_GETTEXTLENGTHEX, (WPARAM)&gtl, 0, &lr);
#endif
	return lr;
}

/*
 *	CCmbBxWinHost::GetEditText (LPTSTR, int)
 *
 *	@mfunc
 *		returns the text length in the edit control in UNICODE
 *
 *	@rdesc
 *		LRESULT = text length copied to passed in buffer
 */
LRESULT CCmbBxWinHost::GetEditText (
	LPTSTR szStr, 
	int nSize)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::GetEditText");

	LRESULT lr = 0;
	GETTEXTEX gt;
	gt.cb = nSize * sizeof(WCHAR);
	gt.flags = 0;
	gt.codepage = 1200;
	gt.lpDefaultChar = NULL;
	gt.lpUsedDefChar = NULL;

#ifdef DEBUG
	HRESULT hr = _pserv->TxSendMessage(EM_GETTEXTEX, (WPARAM)&gt, (LPARAM)szStr, &lr);
	Assert(hr == NOERROR);
#else
	_pserv->TxSendMessage(EM_GETTEXTEX, (WPARAM)&gt, (LPARAM)szStr, &lr);
#endif
	return lr;
}
 
 
/*
 *	CCmbBxWinHost::SetDropSize(RECT* prc)
 *
 *	@mfunc
 *		Compute the drop down window's width and max height
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
void CCmbBxWinHost::SetDropSize(
	RECT* prc)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::SetDropSize");

	_fListVisible = TRUE;
	HideListBox(FALSE, FALSE);
	POINT pt1 = {prc->left, prc->top};
	POINT pt2 = {prc->right, prc->bottom};

	::ClientToScreen(_hwnd, &pt1);
	::ClientToScreen(_hwnd, &pt2);

	int   iWidth = pt2.x - pt1.x;

	if (_cxList > iWidth)
		iWidth = _cxList;

	MoveWindow(_hwndList, pt1.x, pt1.y, iWidth,
			pt2.y - pt1.y, FALSE);

}

/*
 *	CCmbBxWinHost::SetSizeEdit(int nLeft, int nTop, int nRight, int nBottom)
 *
 *	@mfunc
 *		sets the edit controls size
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
void CCmbBxWinHost::SetSizeEdit(
	int nLeft,
	int nTop,
	int nRight,
	int nBottom)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::SizeEdit");

	// Generate default view rect from client rect
	if(_fBorder)
	{
		// Factors in space for borders
  		_rcViewInset.top	= W32->DeviceToHimetric(nTop, W32->GetYPerInchScreenDC());
   		_rcViewInset.bottom	= W32->DeviceToHimetric(nBottom, W32->GetYPerInchScreenDC());
   		_rcViewInset.left	= W32->DeviceToHimetric(nLeft, W32->GetXPerInchScreenDC());
   		_rcViewInset.right	= W32->DeviceToHimetric(nRight, W32->GetXPerInchScreenDC());
	}
	else
	{
		// Default the top and bottom inset to 0 and the left and right
		// to the size of the border.
		_rcViewInset.top = 0;
		_rcViewInset.bottom = 0;
		_rcViewInset.left = W32->DeviceToHimetric(nLeft, W32->GetXPerInchScreenDC());
		_rcViewInset.right = W32->DeviceToHimetric(nRight, W32->GetXPerInchScreenDC());
	}
}

/*
 *	CCmbBxWinHost::CbCalcControlRects(RECT* prc, BOOL bCalcChange)
 *
 *	@mfunc
 *		Calculates the RECT for all the controls.  The rect should
 *	include the non-client area's also
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
BOOL CCmbBxWinHost::CbCalcControlRects(
	RECT* prc, 
	BOOL bCalcChange)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::CbCalcControlRects");

	// copy over the window rect
	if (prc)
		_rcWindow = *prc;

	// Item specific things
	const int smY = GetSystemMetrics(SM_CYEDGE);
	const int smX = GetSystemMetrics(SM_CXEDGE);

	BOOL fCustomLook = ((CTxtEdit *) _pserv)->_fCustomLook;
	BOOL fAdjustBorder = _fBorder && !fCustomLook;

	_cxCombo = _rcWindow.right - _rcWindow.left;

	if (!_dyEdit)
		_dyEdit = _dyFont + 2 + ((fAdjustBorder) ? (2 * _yInset) : 0);
	
	if (_fOwnerDraw)
	{		
		if (bCalcChange)
		{
            // No height has been defined yet for the static text window.  Send
            // a measure item message to the parent
			MEASUREITEMSTRUCT mis;
            mis.CtlType = ODT_COMBOBOX;
            mis.CtlID = _idCtrl;
            mis.itemID = (UINT)-1;
            mis.itemHeight = _dyEdit;
            mis.itemData = 0;

            SendMessage(_hwndParent, WM_MEASUREITEM, _idCtrl, (LPARAM)&mis);
			_dyEdit = mis.itemHeight;
        }
	}
	else
	{
		// NOTE:
		//	Richedit prevents us from trying to set the itemHeight less than the 
		// font height so we need to take account of this by preventing user from
		// setting height less than font height
		int nyEdit = _dyFont + (fAdjustBorder ? 2 * _yInset : 0);
		if (_dyEdit > nyEdit)
		{
			//In order for the highlighting to work properly we need to empty
			//the richedit control
			LRESULT nLen;
			_pserv->TxSendMessage(WM_GETTEXTLENGTH, 0, 0, &nLen);

			WCHAR* pwch = NULL;
			if (nLen && _cbType == kDropDownList)
			{
				pwch = new WCHAR[nLen + 1 /*NULL*/];
				AssertSz(pwch, "Unable to allocate memory for string");

				if (pwch)
				{				
					// Get the text from richedit and emtpy it
					_fIgnoreChange = 1;
					_fDontWinNotify = 1;
					_pserv->TxSendMessage(WM_GETTEXT, nLen + 1, (LPARAM)pwch, NULL);
					_fDontWinNotify = 1;
					_pserv->TxSendMessage(WM_SETTEXT, 0, NULL, NULL);
					_fIgnoreChange = 0;
				}
				else
				{
					// something bad happened so send a message
					// to client
					TxNotify(EN_ERRSPACE, NULL);	
				}
			}
			else if (_cbType == kDropDown && nLen == 0)
			{
				// we need to insert a dummy character into the richedit
				// control so it won't try to highlight space after
				// the paragraph
				_fIgnoreChange = 1;
				_fDontWinNotify = 1;
				_pserv->TxSendMessage(WM_SETTEXT, 0, (LPARAM)L" ", NULL);
				_fIgnoreChange = 0;
			}

		 	// Calculate the difference in size
		 	nyEdit = _dyEdit - nyEdit;
			int		nyAbove = 0;

			PARAFORMAT2 pf;
			pf.cbSize = sizeof(PARAFORMAT2);
			pf.dwMask = PFM_SPACEAFTER;

			if (fCustomLook)
			{
				// Try to center the text vertically using Space Before

				nyEdit += 2;			// adjust for the custom frame
				nyAbove = nyEdit / 2;

				pf.dwMask = PFM_SPACEAFTER | PFM_SPACEBEFORE;
				pf.dySpaceBefore = (int)(((double)nyAbove * 1440.0) / (double)W32->GetYPerInchScreenDC());
				nyEdit -= nyAbove;
			}

			pf.dySpaceAfter = (int)(((double)nyEdit * 1440.0) / (double)W32->GetYPerInchScreenDC());
			_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (LPARAM)&pf, NULL);

			//Reset the text which was there before in the richedit control
			if (pwch || (_cbType == kDropDown && nLen == 0))
			{
				_fIgnoreChange = 1;
				_pserv->TxSendMessage(WM_SETTEXT, 0, (LPARAM)(pwch ? pwch : NULL), NULL);
				_fIgnoreChange = 0;
				if (pwch)
					delete pwch;
			}
		}
		else
			_dyEdit = nyEdit;	// stabalize ourselves
	}

	// For Bordered Combobox we take account of the clientedge for the top
	// and bottom. And since we want to draw the focus rect within the yellow
	// area we need to subtract 1.
	_cyCombo = min(_dyEdit + ((_fBorder) ? 2 * smY : 0), 
				_rcWindow.bottom - _rcWindow.top); 
	
	// recompute the max height of the dropdown listbox -- full window
    // size MINUS edit/static height
	int iHeight = (_rcWindow.bottom - _rcWindow.top) - _cyCombo;

	if (_cyList == -1 || iHeight > _dyEdit)
		_cyList = iHeight;

	// calculate the rect for the buttons
	if (_cbType != kSimple)
	{
		_rcButton.top = 0;
		_rcButton.bottom = _cyCombo;
		if (!fCustomLook)
			_rcButton.bottom = min(_dyEdit, _rcWindow.bottom - _rcWindow.top);

		if (_fRightAlign)
		{
			_rcButton.left = 0;
			_rcButton.right = _rcButton.left + W32->GetCxVScroll();
		}
		else
		{
			_rcButton.right = _cxCombo - (fAdjustBorder ? (2 * smX): 0);
			_rcButton.left = _rcButton.right - W32->GetCxVScroll();
		}
	}


	// calculate the edit control rect	
	int nTop = _yInset;
	int nBottom = 0;
	_dxLInset = _xInset;
	_dxRInset = _xInset;	
	if (_cbType != kSimple)
	{
		if (_fRightAlign)
			_dxLInset = (_rcButton.right - _rcButton.left) + fCustomLook ? 0 : smX;
		else
			_dxRInset = (_rcButton.right - _rcButton.left) + fCustomLook ? 0 : smX;
	}
	SetSizeEdit(_dxLInset + _dxLOffset, nTop, _dxRInset + _dxROffset, nBottom);

	// calculate the rect for the list box window
	_rcList.left = fAdjustBorder ? - smX : 0;
	_rcList.top = _cyCombo - (fAdjustBorder ? smY : 0);
	_rcList.right = fAdjustBorder ? max(_cxCombo - smX, 0) : _rcWindow.right;
	_rcList.bottom = _cyCombo + _cyList;	

	return TRUE;
}


/*
 *	CCmbBxWinHost::DrawButton(HDC, BOOL)
 *
 *	@mfunc
 *		Draws the combo box button given an hdc
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
void CCmbBxWinHost::DrawButton(
	HDC hdc, 
	BOOL bDown)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::DrawButton");
	// Check if we have to draw the drop down button
    if (_cbType != kSimple) 
	{
		BOOL bRelease = !hdc;
		if (!hdc)
			hdc = TxGetDC();

		if (((CTxtEdit *) _pserv)->_fCustomLook)
		{
			// Draw buttomn using new look
			COLORREF crBorder = W32->GetCtlBorderColor(_fListVisible, _fMouseover);
			COLORREF crBackground = W32->GetCtlBkgColor(_fListVisible, _fMouseover);
			COLORREF crArrow = W32->GetCtlTxtColor(_fListVisible, _fMouseover, _fDisabled);;
		
			W32->DrawBorderedRectangle(hdc, &_rcButton, crBorder, crBackground);			
			W32->DrawArrow(hdc, &_rcButton, crArrow);
		}
		else
		{
			DrawFrameControl(hdc, &_rcButton, DFC_SCROLL, DFCS_SCROLLCOMBOBOX |
				(bDown ? DFCS_PUSHED | DFCS_FLAT: 0) | (!_fBorder ? DFCS_FLAT : 0) |
				(!_fDisabled ? 0 : DFCS_INACTIVE));
		}

		if (bRelease)
			TxReleaseDC(hdc);
    }
}

/* 
 *	CCmbBxWinHost::TxNotify (iNotify,	pv)
 *
 *	@mfunc
 *		Notify Text Host of various events.  Note that there are
 *		two basic categories of events, "direct" events and 
 *		"delayed" events.  In the case of the combobox we will
 *		notify parent of only two edit notifications; EN_CHANGE 
 *		and EN_UPDATE.  The others will be from the listbox
 *		or be generated because of focus changing
 *
 *
 *	@rdesc	
 *		S_OK - call succeeded <nl>
 *		S_FALSE	-- success, but do some different action
 *		depending on the event type (see below).
 *
 *	@comm
 *		<CBN_DBLCLK> user double-clicks an item in the list box
 *
 *		<CBN_ERRSPACE> The list box cannot allocate enough memory to 
 *		fulfill a request
 *
 *		<CBN_KILLFOCUS> The list box loses the keyboard focus
 *
 *		<CBN_SELENDCANCEL> notification message is sent when the user 
 *		selects an item, but then selects another control or closes the 
 *		dialog box
 *
 *		<CBN_SELCHANGE> notification message is sent when the user changes 
 *		the current selection in the list box of a combo box
 *
 *		<CBN_SETFOCUS> The list box receives the keyboard focus
 *
 *		<CBN_CLOSEUP> This message is sent when the listbox has been closed
 *
 *		<CBN_SELENDOK> notification message is sent when the user selects a 
 *		list item, or selects an item and then closes the list
 *
 *		<CBN_EDITCHANGE> notification message is sent after the user 
 *		has taken an action that may have altered the text in the edit 
 *		control portion of a combo box
 *
 *		<CBN_EDITUPDATE> notification message is sent when the edit control 
 *		portion of a combo box is about to display altered text
 *
 *		<CBN_DROPDOWN> This message is sent when the listbox has been made visible
 */
HRESULT CCmbBxWinHost::TxNotify(
	DWORD iNotify,		//@parm	Event to notify host of.  One of the
						//		EN_XXX values from Win32, e.g., EN_CHANGE
	void *pv)			//@parm In-only parameter with extra data.  Type
						//		dependent on <p iNotify>
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CCmbBxWinHost::TxNotify");
	HRESULT hr = S_FALSE;
	BOOL	fSendNotify = FALSE;

	if (EN_SAVECLIPBOARD == iNotify)	// Special RE notify
		return S_OK;					//	return S_OK to put data on clipboard

	if (_hwndParent)
	{
		// First, handle WM_NOTIFY style notifications
		//WPARAM LOWORD(_idCtrl) ; LPARAM - HWND(COMBO)
		switch(iNotify)
		{
		case EN_CHANGE:

#ifndef NOACCESSIBILITY
			if (!_fDontWinNotify)
				fSendNotify = TRUE;

			_fDontWinNotify = 0;
#endif
			//update the listbox bug fix #5206
			if (_fIgnoreChange)
			{
				if (!fSendNotify)
					return hr;

				goto WIN_EVENT;
			}

			if (_fListVisible && _cbType == kDropDown)
				UpdateListBox(FALSE);
			else if (_cbType == kDropDownList)
			    // don't send notification if dropdownlist
			    return S_FALSE;
			    
			iNotify = CBN_EDITUPDATE;
			_fSendEditChange = 1;

			goto SEND_MSG;
			
		case EN_UPDATE:
			//bug fix - we're sending too much CBN_UPDATE notifications
			if (_fIgnoreUpdate)
				return hr;
			if (_cbType == kDropDownList)
			    return S_FALSE;
			    
			iNotify = CBN_EDITCHANGE;
			goto SEND_MSG;
			
		case EN_ERRSPACE:
			iNotify = (unsigned)CBN_ERRSPACE;
			goto SEND_MSG;

		case CBN_SELCHANGE: 
		case CBN_SELENDCANCEL:		
		case CBN_CLOSEUP:
		case CBN_DBLCLK:	
		case CBN_DROPDOWN:  
		case CBN_KILLFOCUS:  
		case CBN_SELENDOK:
		case CBN_SETFOCUS:
	
SEND_MSG:
		hr = SendMessage(_hwndParent, WM_COMMAND, 
						GET_WM_COMMAND_MPS(_idCtrl, _hwnd, iNotify));


WIN_EVENT:
#ifndef NOACCESSIBILITY
		if (fSendNotify)
			W32->NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, _hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
#endif
		}		
	}
	return hr;
}

/*
 *	CCmbBxWinHost::TxScrollWindowEx (dx, dy, lprcScroll, lprcClip, hrgnUpdate,
 *									lprcUpdate, fuScroll)
 *	@mfunc
 *		Request Text Host to scroll the content of the specified client area.
 *
 *	@devnote
 *		Need to exclude the drop-dwon button from the Clip rect or else ScrollWindowEx
 *		will scroll the button image as well.
 *
 */
void CCmbBxWinHost::TxScrollWindowEx (
	INT		dx, 			//@parm	Amount of horizontal scrolling
	INT		dy, 			//@parm	Amount of vertical scrolling
	LPCRECT lprcScroll, 	//@parm	Scroll rectangle
	LPCRECT lprcClip,		//@parm	Clip rectangle
	HRGN	hrgnUpdate, 	//@parm	Handle of update region
	LPRECT	lprcUpdate,		//@parm	Update rectangle
	UINT	fuScroll)		//@parm	Scrolling flags
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CCmbBxWinHost::TxScrollWindowEx");

	Assert(_hwnd);
	RECT	rcClip = *lprcClip;

	if (_cbType != kSimple && lprcClip && dx)
	{
		// Exclude the dropdown button rect from the clipping rect
		if (_fRightAlign)
			rcClip.left = max(lprcClip->left, _rcButton.right);
		else
			rcClip.right = min(lprcClip->right, _rcButton.left);
	}
	::ScrollWindowEx(_hwnd, dx, dy, lprcScroll, &rcClip, hrgnUpdate, lprcUpdate, fuScroll);
}

/* 
 *	CCmbBxWinHost::TxInvalidateRect (prc, fMode)
 *
 *	@mfunc
 *		Adds a rectangle to the Text Host window's update region
 *
 *	@comm
 *		We want to make sure the invalidate rect include the focus rect.
 *
 */
void CCmbBxWinHost::TxInvalidateRect(
	LPCRECT	prc, 		//@parm	Address of rectangle coordinates
	BOOL	fMode)		//@parm	Erase background flag
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CCmbBxWinHost::TxInvalidateRect");

	Assert(_hwnd);

	if(!_fVisible)
	{
		// There doesn't seem to be a deterministic way to determine whether
		// our window is visible or not via message notifications. Therefore,
		// we check this each time in case it might have changed.
		_fVisible = IsWindowVisible(_hwnd);

		if(_fVisible)
			OnTxVisibleChange(TRUE);
	}

	// Don't bother with invalidating rect if we aren't visible
	if(_fVisible)
	{
		RECT rcLocal;
		if (prc && _cbType == kDropDownList)
		{
			RECT rcClient;
			GetClientRect(_hwnd, &rcClient);

			rcClient.top += _yInset;
			rcClient.bottom -= _yInset;

			if (prc->bottom < rcClient.bottom || prc->top > rcClient.top)
			{
				// Make sure we also invalidate the focus rect as well
				rcLocal = *prc;
				if (prc->bottom < rcClient.bottom)
					rcLocal.bottom = rcClient.bottom;

				if (prc->top > rcClient.top)
					rcLocal.top = rcClient.top;

				prc = &rcLocal;
			}
		}
		::InvalidateRect(_hwnd, prc, FALSE);
	}
}

/* 
 *	CCmbBxWinHost::TxGetClientRect (prc)
 *
 *	@mfunc
 *		Retrieve client coordinates of CCmbBxWinHost's client area.
 *
 *	@rdesc
 *		HRESULT = (success) ? S_OK : E_FAIL
 */
HRESULT CCmbBxWinHost::TxGetClientRect(
	LPRECT prc)		//@parm	Where to put client coordinates
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CCmbBxWinHost::TxGetClientRect");

	HRESULT hr;

	Assert(_hwnd && prc);
	hr = ::GetClientRect(_hwnd, prc) ? S_OK : E_FAIL;

	if (hr == S_OK && _cbType != kSimple)
	{
		if (_fRightAlign)
			prc->left = _rcButton.right + _xInset;
		else
			prc->right = _rcButton.left - (((CTxtEdit *)_pserv)->_fCustomLook ? 0 : _xInset);
	}

	return hr;
}

/*
 *	CCmbBxWinHost::DrawEditFocus(HDC)
 *
 *	@mfunc
 *		Either draws or notifies owner to draw the focus rect
 *
 *	@rdesc
 *		void
 */
void CCmbBxWinHost::DrawEditFocus(
	HDC hdc)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::DrawEditFocus");

	BOOL bRelease = FALSE;
	if (!hdc)
	{
		hdc = TxGetDC();
		bRelease = TRUE;
	}

	RECT rc;
	GetClientRect(_hwnd, &rc);

	if (!_fOwnerDraw)
	{
		HiliteEdit(_fFocus);

		if (_cbType == kDropDownList)
		{
			// shrink the focus rect by the inset
			rc.top += _yInset;
			rc.bottom -= _yInset;			
			
			if (_fRightAlign)
				rc.left = _rcButton.right;
			else
				rc.right = _rcButton.left;

			rc.left += _xInset;

			if (!((CTxtEdit *) _pserv)->_fCustomLook)
				rc.right -= _xInset;

			DrawFocusRect(hdc, &rc);
		}
	}

	if (bRelease)
		TxReleaseDC(hdc);
	
}

/*
 *	CCmbBxWinHost::SetSelectionInfo(BOOL bOk, int nIdx)
 *
 *	@mfunc
 *		Completes the text in the edit box with the closest match from the
 * listbox.  If a prefix match can't be found, the edit control text isn't
 * updated. Assume a DROPDOWN style combo box.
 *
 *	@rdesc
 *		void
 */
void CCmbBxWinHost::SetSelectionInfo(
	BOOL bOk, 
	int nIdx)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::SetSelectionInfo");

	_nCursor = nIdx;
	_bSelOk = bOk;	
}

/*
 *	CCmbBxWinHost::AutoUpdateEdit(int i)
 *
 *	@mfunc
 *		Completes the text in the edit box with the closest match from the
 * listbox.  If a prefix match can't be found, the edit control text isn't
 * updated. Assume a DROPDOWN style combo box.
 *
 *	@rdesc
 *		void
 */
void CCmbBxWinHost::AutoUpdateEdit(
	int nItem)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::AutoUpdateEdit");

    // We update the edit part of the combo box with the current selection of
    // the list box
	int cch;
	WCHAR* pszText;
	LRESULT lr;

	// find the best matching string in the list box
	if (nItem == -1 || nItem == -2)
	{
		cch = GetTextLength();

		// no text to search so just get out
	    if (!cch)
	    	return;

	    cch++; // account for null character
	    pszText = new WCHAR[cch];
	    AssertSz(pszText, "string allocation failed");
	    if (!pszText) 
	    {
			TxNotify((unsigned)CBN_ERRSPACE, NULL);
			return;
		}

		// get string from edit control and try to find a exact match else a match
		// in the list box
		GetEditText(pszText, cch);
		
	    nItem = RichListBoxWndProc(_hwndList, LB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)pszText);

	    if (nItem == -1)
	    	nItem = RichListBoxWndProc(_hwndList, LB_FINDSTRING, (WPARAM)-1, (LPARAM)pszText);
		delete [] pszText;

		// no match found so just get out
	    if (nItem == -1)         	
	    	return;
    }

	cch = RichListBoxWndProc(_hwndList, LB_GETTEXTLEN, nItem, 0);

	if (cch <= 0)
		return;
		
    cch++; // account for null character
    pszText = new WCHAR[cch];
	AssertSz(pszText, "Unable to allocate string");
	if (!pszText)
	{
		TxNotify((unsigned)CBN_ERRSPACE, NULL);
		return;
	}

	RichListBoxWndProc(_hwndList, LB_GETTEXT, nItem, (LPARAM)pszText);
	_fIgnoreChange = 1;
	_pserv->TxSendMessage(WM_SETTEXT, 0, (LPARAM)pszText, &lr);
	_fIgnoreChange = 0;

   	HiliteEdit(TRUE);

    delete [] pszText;
}

/*
 *	CCmbBxWinHost::HiliteEdit(BOOL)
 *
 *	@mfunc
 *		Sets the hilite background or selects the entire text for the
 *	edit control
 *
 *	@rdesc
 *		void
 */
void CCmbBxWinHost::HiliteEdit(
	BOOL bSelect)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::HiliteEdit");

	//bug fix 4073
	Assert(!_fOwnerDraw || _cbType == kDropDown);

	if (_cbType != kDropDownList)
	{
		//if bSelect is true else put cursor at beginning of text
		_pserv->TxSendMessage(EM_SETSEL, 0, (LPARAM)((bSelect) ? -1 : 0), NULL);
	}
	else
	{
		//Get the range of the paragraph
		ITextRange* pRange;		
		if (NOERROR != ((CTxtEdit*)_pserv)->Range(0, 0, &pRange))
		{
			AssertSz(FALSE, "unable to get range");
			return;
		}
		Assert(pRange);

		DWORD crFore = (unsigned)tomAutoColor;
		DWORD crBack = (unsigned)tomAutoColor;
		if (bSelect)
		{
			crFore = ::GetSysColor(COLOR_HIGHLIGHTTEXT);
			crBack = ::GetSysColor(COLOR_HIGHLIGHT);
		}

		// Get the entire paragraph
		ITextFont* pFont = NULL;	

		// Select entire text
		CHECKNOERROR(pRange->SetIndex(tomParagraph, 1, 1));
		
		// Set the background and forground color
		CHECKNOERROR(pRange->GetFont(&pFont));
		
		Assert(pFont);
		CHECKNOERROR(pFont->SetBackColor(crBack));
		CHECKNOERROR(pFont->SetForeColor(crFore));

CleanExit:
		// Release pointers
		if (pFont)
			pFont->Release();
		pRange->Release();
	}
}


/*
 *	CCmbBxWinHost::UpdateEditBox()
 *
 *	@mfunc
 *		Updates the editcontrol window so that it contains the text
 * given by the current selection in the listbox.  If the listbox has no
 * selection (ie. -1), then we erase all the text in the editcontrol.
 *
 * hdc is from WM_PAINT messages Begin/End Paint hdc. If null, we should
 * get our own dc.
 *
 *	@rdesc
 *		void
 */
void CCmbBxWinHost::UpdateEditBox()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::UpdateEditBox");

    Assert(_hwndList);
    Assert(_plbHost);

    // Update the edit box
    if (_cbType == kDropDownList && _fOwnerDraw)
    {
	   	CbMessageItemHandler(NULL, ITEM_MSG_DRAWCOMBO, 0, 0);
	   	return;
	}
    else 
    {
		WCHAR* pszText = NULL;
	   	int nItem = (signed)_plbHost->GetCursor();   	
	    if (nItem != -1)
		{
			int cch = RichListBoxWndProc(_hwndList, LB_GETTEXTLEN, (LPARAM)nItem, 0);
		    pszText = new WCHAR[cch + 1];
			AssertSz(pszText, "allocation failed");

			// just get out if memory allocation failed
			if (!pszText)
			{
				TxNotify((unsigned)CBN_ERRSPACE, NULL);
				return;
			}
			RichListBoxWndProc(_hwndList, LB_GETTEXT, (WPARAM)nItem, (LPARAM)pszText);		
		}
	
    	// if the cursor is on a valid item then update edit with the item text
    	// else we just display a blank text
    	WCHAR szEmpty[] = L"";
    	_fIgnoreChange = 1;
    	_pserv->TxSendMessage(WM_SETTEXT, 0, (LPARAM)((pszText) ? pszText : szEmpty), NULL);
   		DrawEditFocus(NULL);
    	if (pszText)
    		delete pszText;
		_fIgnoreChange = 0;
    }
}

/*
 *	CCmbBxWinHost::UpdateListBox(BOOL)
 *
 *	@mfunc
 *		Updates the list box by searching and moving to the top the text in
 *	edit control.  And possibly pre-selecting the item if bSetSel is set
 *
 *	@rdesc
 *		int = found ? index of item : -1
 */
int CCmbBxWinHost::UpdateListBox(
	BOOL bSetSel)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::UpdateListBox");

    int nItem = -1;
    int nSel = -1;
	WCHAR* pszText;
	int cch;

	// Get text from edit box
    cch = GetTextLength();
    if (cch) 
    {
    	// add one for null string
        cch++;
        pszText = new WCHAR[cch];
        if (pszText != NULL) 
        {  
        	if (GetEditText(pszText, cch))
        	{
        		//Bypass Winnt thunking layer by calling the function directly
        		nItem = RichListBoxWndProc(_hwndList, LB_FINDSTRING, (WPARAM)-1L, (LPARAM)pszText);
        	}
        	delete [] pszText;        	
        }
        else
        {
			TxNotify((unsigned)CBN_ERRSPACE, NULL);
			return 0;
		}
    }

    if (bSetSel)
        nSel = nItem;

	// update the list box
    RichListBoxWndProc(_hwndList, LB_SETCURSEL, (LPARAM)nSel, 0);
	RichListBoxWndProc(_hwndList, LB_SETTOPINDEX, (LPARAM)max(nItem, 0), 0);	
    return nItem;
}


/*
 *	CCmbBxWinHost::HideListBox(BOOL, BOOL)
 *
 *	@mfunc
 *		Hides the list box
 *
 *	@rdesc
 *		void
 */
BOOL CCmbBxWinHost::HideListBox(
	BOOL bNotify, 
	BOOL fSelOk)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::HideListBox");

	//send CBN_SELENDOK to all types of comboboxes but only
    // allow CBN_SELENDCANCEL to be sent for droppable comboboxes
	if (bNotify)
	{
		if (fSelOk)
		{
			TxNotify(CBN_SELENDOK, NULL);
		}
		else if (_cbType != kSimple)
		{
			TxNotify(CBN_SELENDCANCEL, NULL);
		}
	}
	
    // return, we don't hide simple combo boxes.
	if (!_fListVisible || _cbType == kSimple) 
    	return TRUE;

    // Tell the listbox to end tracking
    Assert(_plbHost);
	_plbHost->OnCBTracking(LBCBM_END, 0);     	
    
    // Hide the listbox window
    _fListVisible = 0;
	_fMouseover = 0;
    ShowWindow(_hwndList, SW_HIDE);
	if (_fCapture)
	{
		_fCapture = FALSE;
		TxSetCapture(FALSE);
	}

	_fResizing = 1;
    // Invalidate the item area now since SWP() might update stuff.
    // Since the combo is CS_VREDRAW/CS_HREDRAW, a size change will
    // redraw the whole thing, including the item rect.  But if it
    // isn't changing size, we still want to redraw the item anyway
    // to show focus/selection
    if (_cbType == kDropDownList)
	{
		if (!_fOwnerDraw)
			HiliteEdit(_fFocus);
        InvalidateRect(_hwnd, NULL, TRUE);
	}

	//bug fix
	// The button may look depressed so we must redraw the button
	if (_fMousedown)
	{
		_fMousedown = FALSE;
		InvalidateRect(_hwnd, &_rcButton, FALSE);
	}

    SetWindowPos(_hwnd, HWND_TOP, 0, 0, _cxCombo, _cyCombo, 
    	SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

	_fResizing = 0;

	if (_cbType == kDropDown)
		AutoUpdateEdit(_nCursor);
	_nCursor = -2;

    // In case size didn't change
    UpdateWindow(_hwnd);

    if (bNotify) 
    {
        //Notify parent we will be popping up the combo box.
        TxNotify(CBN_CLOSEUP, NULL);
    }

	// reset back to old cursor if mouse cursor was set
	if (_hcurOld)
	{
		TxSetCursor2(_hcurOld, NULL);
		_hcurOld = NULL;
	}
    return(TRUE);
}

/*
 *	CCmbBxWinHost::GetListBoxRect(RECT &rcList)
 *
 *	@mfunc
 *		Get the rect for the list box
 *
 *	@rdesc
 *		void
 */
void CCmbBxWinHost::GetListBoxRect(
	RECT &rcList)
{
	POINT pt1;
	int iWidth = _rcList.right - _rcList.left;

	if (iWidth < _cxList)
		iWidth = _cxList;

    pt1.x = _rcList.left;
    pt1.y = _rcList.top;

	TxClientToScreen(&pt1);
	rcList.left = pt1.x;
	rcList.top = pt1.y;
	rcList.right = rcList.left + iWidth;
	rcList.bottom = rcList.top + _cyList;

	int iWindowHeight = max((_rcWindow.bottom - _rcWindow.top) - _cyCombo, 0);
    int iHeight = max(_cyList, iWindowHeight);

	if (!_fOwnerDrawVar)
	{
		// List area
		int cyItem = _plbHost->GetItemHeight();
		AssertSz(cyItem, "LB_GETITEMHEIGHT is returning 0");

		if (cyItem == 0)
    		cyItem = _plbHost->GetFontHeight();

		// Windows NT comment:
		//  we shoulda' just been able to use cyDrop here, but thanks to VB's need
		//  to do things their OWN SPECIAL WAY, we have to keep monitoring the size
		//  of the listbox 'cause VB changes it directly (jeffbog 03/21/94)

		DWORD dwMult = (DWORD)RichListBoxWndProc(_hwndList, LB_GETCOUNT, 0, 0);
		INT	cyEdge = GetSystemMetrics(SM_CYEDGE);

		if (dwMult) 
		{
			dwMult = (DWORD)(LOWORD(dwMult) * cyItem);
			dwMult += cyEdge;

			if (dwMult < 0x7FFF)
				iHeight = min(LOWORD(dwMult), iHeight);
		}

		if (!_fNoIntegralHeight)
			iHeight = ((iHeight - cyEdge) / cyItem) * cyItem + cyEdge;
	}

    //UNDONE: Multi-monitor
    //	We need to change the following code if we are to support multi-monitor
    int yTop;
    int nScreenHeight = GetSystemMetrics(SM_CYFULLSCREEN);    
    if (rcList.top + iHeight <= nScreenHeight) 
    {
        yTop = rcList.top;
        if (!_fBorder)
            yTop -= W32->GetCyBorder();
    } 
    else 
    {
        yTop = max(rcList.top - iHeight - _cyCombo + 
			((_fBorder) ? W32->GetCyBorder() : 0), 0);
    }

	rcList.top = yTop;
	rcList.bottom = rcList.top + iHeight;
}

/*
 *	CCmbBxWinHost::ShowListBox(BOOL)
 *
 *	@mfunc
 *		Displays the list box
 *
 *	@rdesc
 *		void
 */
void CCmbBxWinHost::ShowListBox(
	BOOL fTrack)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::ShowListBox");
	
	Assert(_cbType != kSimple);
	Assert(_hwndList);

	// Notify parent window we are about to drop down the list box
	TxNotify(CBN_DROPDOWN, NULL);

	// force a redraw of the button so it looks depressed
	InvalidateRect(_hwnd, &_rcButton, TRUE);

	_fListVisible = TRUE;
	_fIgnoreChange = 0;

	_bSelOk = 0;
	if (_cbType == kDropDown)
	{
		UpdateListBox(!_fMousedown);
		if (!_fMousedown)
			AutoUpdateEdit(-1);
		_nCursor = _plbHost->GetCursor();

	}
	else
	{
        // Scroll the currently selected item to the top of the listbox.        
		int idx = (signed)_plbHost->GetCursor();
		_nCursor = idx;
		if (idx == -1)
			idx = 0;

		// set the top index if there is something in the list box
		if (_plbHost->GetCount() > 0)
			RichListBoxWndProc(_hwndList, LB_SETTOPINDEX, idx, 0);	

		// We are to lose focus in this case
		_fFocus = 0;
		if (!_fOwnerDraw)
			HiliteEdit(FALSE);
		
	    // We need to invalidate the edit rect so that the focus frame/invert
        // will be turned off when the listbox is visible.  Tandy wants this for
        // his typical reasons...        
        InvalidateRect(_hwnd, NULL, TRUE);        
    }

    // Figure out where to position the dropdown listbox.
    // We want the dropdown to pop below or above the combo
    // Get screen coords
	RECT	rcList;

	GetListBoxRect(rcList);
    SetWindowPos(_hwndList, HWND_TOPMOST, rcList.left,
        rcList.top, rcList.right - rcList.left, rcList.bottom - rcList.top, 0);

	Assert(_plbHost);
    _plbHost->SetScrollInfo(SB_VERT, FALSE);

	
	if (_cbType == kDropDownList)
		_fFocus = 0;

	// UNDONE:
	// Are we going to support window animation?	
    ShowWindow(_hwndList, SW_SHOW);
	
	// We send a message to the listbox to prepare for tracking
	if (fTrack)
	{		
		Assert(_plbHost);
		// initialize type searching
		_plbHost->InitSearch();
		_plbHost->OnCBTracking(LBCBM_PREPARE, LBCBM_PREPARE_SAVECURSOR | 
						((_cbType == kDropDownList) ? LBCBM_PREPARE_SETFOCUS : 0));
	}
	
	// Since we are about to display the list box change mouse cursor to arrow
	if (!_hcurOld)
		_hcurOld = TxSetCursor2(LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW)), NULL);
}

////////////////////////// Combo box Message Handlers ////////////////////////////////

/*
 *	CCmbBxWinHost::CbSetItemHeight(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Sets the size of the edit or list box.
 *
 *
 *	@rdesc
 *		LRESULT = successful ? 1 : CB_ERR
 */
LRESULT CCmbBxWinHost::CbSetItemHeight(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::CbSetItemHeight");

	int nHeight = lparam;
	//bug fix #4556
	if (nHeight == 0 || nHeight > 255)
		return CB_ERR;

	// We need to update the height internally
	if (wparam == (unsigned)-1)
	{
		RECT rc;
		GetClientRect(_hwnd, &rc);
		_dyEdit = nHeight;
		OnSize(0, MAKELONG(rc.right - rc.left, rc.bottom - rc.top));
	}
	else
		RichListBoxWndProc(_hwndList, LB_SETITEMHEIGHT, wparam, MAKELPARAM(nHeight, 0));

	return 1;
}

/*
 *	CCmbBxWinHost::CbGetDropWidth()
 *
 *	@mfunc
 *		Retrieves the drop width of the list box.
 *
 *
 *	@rdesc
 *		LRESULT = successful ? 1 : CB_ERR
 */
LRESULT CCmbBxWinHost::CbGetDropWidth()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::CbGetDropWidth");

	int iWidth = _rcList.right - _rcList.left;

	return _cxList > iWidth ? _cxList : iWidth;
}

/*
 *	CCmbBxWinHost::CbSetDropWidth(WPARAM)
 *
 *	@mfunc
 *		sets the drop width of the list box.
 *
 */
void CCmbBxWinHost::CbSetDropWidth(
	WPARAM wparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::CbSetDropWidth");

	if ((int)wparam != _cxList)
	{
		_cxList = wparam;

		if (_cbType != kSimple)
			SetDropSize(&_rcList);	// Need to resize the list box
	}

}

/*
 *	CCmbBxWinHost::CbGetItemHeight(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Retrieves the item height of the edit or list box.
 *
 *
 *	@rdesc
 *		LRESULT = item height of the edit or list box
 */
LRESULT CCmbBxWinHost::CbGetItemHeight(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::CbGetItemHeight");

	return (wparam == (unsigned)-1) ? _dyEdit :
		RichListBoxWndProc(_hwndList, LB_GETITEMHEIGHT, _fOwnerDrawVar ? wparam : 0, 0);
}


/*
 *	CCmbBxWinHost::CbSetExtendedUI(BOOL)
 *
 *	@mfunc
 *		Retrieves the size of the edit or list box.
 *
 *
 *	@rdesc
 *		LRESULT = successful ? CB_OKAY : CB_ERR
 */
LRESULT CCmbBxWinHost::CbSetExtendedUI(
	BOOL bExtendedUI)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::CbSetExtendedUI");

	// We need to update the height internally
	_fExtendedUI = bExtendedUI ? 1 : 0;
	return CB_OKAY;
}


/*
 *	CCmbBxWinHost::CbMessageItemHandler(int, WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles any and all WM_DRAWITEM, WM_DELETEITEM, and WM_MEASUREITEM messages
 *
 *
 *	@rdesc
 *		LRESULT = whatever the parent window returns
 */
LRESULT CCmbBxWinHost::CbMessageItemHandler(
	HDC hdc, 
	int ff, 
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::CbMessageItemHandler");

	// modify the structure info a bit and pass it to the parent window
    DRAWITEMSTRUCT dis;   
    BOOL bRelease = FALSE;
    UINT msg = WM_DRAWITEM;
	switch (ff)
	{
	case ITEM_MSG_DRAWLIST:
		((LPDRAWITEMSTRUCT)lparam)->CtlType = ODT_COMBOBOX;
	    ((LPDRAWITEMSTRUCT)lparam)->CtlID = _idCtrl;
	    ((LPDRAWITEMSTRUCT)lparam)->hwndItem = _hwnd;	    
	    break;

	case ITEM_MSG_DELETE:
		((LPDELETEITEMSTRUCT)lparam)->CtlType = ODT_COMBOBOX;
	    ((LPDELETEITEMSTRUCT)lparam)->CtlID = _idCtrl;
	    ((LPDELETEITEMSTRUCT)lparam)->hwndItem = _hwnd;
	    msg = WM_DELETEITEM;
	    break;

	case ITEM_MSG_MEASUREITEM:
		((LPMEASUREITEMSTRUCT)lparam)->CtlType = ODT_COMBOBOX;
		((LPMEASUREITEMSTRUCT)lparam)->CtlID = _idCtrl;
		msg = WM_MEASUREITEM;
		break;

	case ITEM_MSG_DRAWCOMBO:
		if (!hdc)
	    {
	    	bRelease = TRUE;
	    	hdc = TxGetDC();
	    }
	    //Fill the DRAWITEMSTRUCT with the unchanging constants
	    dis.CtlType = ODT_COMBOBOX;
	    dis.CtlID = _idCtrl;    

	    // Use -1 if an invalid item number is being used.  This is so that the app
	    // can detect if it should draw the caret (which indicates the lb has the
	    // focus) in an empty listbox
	    dis.itemID = _plbHost->GetCursor();
	    dis.itemAction = ODA_DRAWENTIRE;
	    dis.hwndItem = _hwnd;	    
	    dis.hDC = hdc;
		dis.itemData = (_plbHost->GetCount()) ? (((signed)dis.itemID >= 0) ? _plbHost->GetData(dis.itemID) : 0) : 0;
	    dis.itemState = (UINT)((_fFocus && !_fListVisible ? ODS_SELECTED | ODS_FOCUS : 0) |
                    ((_fDisabled) ? ODS_DISABLED : 0) | ODS_COMBOBOXEDIT);
		           
		// Calculate the drawing rect
        TxGetClientRect(&dis.rcItem);
        if (_cbType != kSimple)
        {
        	if (_fRightAlign)
        		dis.rcItem.left = _rcButton.right;
        	else
        		dis.rcItem.right = _rcButton.left;
        }

        // immulate the system by making the HDC invert text if we have focus
		SetBkMode(hdc, OPAQUE);
		DWORD	crBack = GetSysColor(_fDisabled ? COLOR_BTNFACE : COLOR_WINDOW);
		HBRUSH	hbrBack = CreateSolidBrush(crBack);
		HBRUSH	hOldBrush = NULL;
		if (hbrBack)
			hOldBrush = (HBRUSH)::SelectObject(hdc, hbrBack);

		PatBlt(hdc, dis.rcItem.left, dis.rcItem.top, dis.rcItem.right - dis.rcItem.left,
                dis.rcItem.bottom - dis.rcItem.top, PATCOPY);

		if (hOldBrush)
			hOldBrush = (HBRUSH)::SelectObject(hdc, hOldBrush);
		::DeleteObject(hbrBack);

		if (_fFocus && !_fListVisible) 
		{
            SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
            SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
        }

		DrawCustomFrame(0, hdc);      

        // Don't let ownerdraw dudes draw outside of the combo client
        // bounds.
		InflateRect(&dis.rcItem, -1, -1);

		// For new look case, we are off by 1 between this rect and the dropdown rect
		// after the InflateRect
		if (_cbType != kSimple && ((CTxtEdit *) _pserv)->_fCustomLook)
		{
			if (_fRightAlign)
				dis.rcItem.left -= 1;
			else
				dis.rcItem.right += 1;
		}

        IntersectClipRect(hdc, dis.rcItem.left, dis.rcItem.top, dis.rcItem.right, 
        				dis.rcItem.bottom);
	    lparam = (LPARAM)&dis;		
	}

	LRESULT lres = SendMessage(_hwndParent, msg, _idCtrl, lparam);
	if (bRelease)
		TxReleaseDC(hdc);

	return lres;
}

/////////////////////////// Windows Message Handlers /////////////////////////////////
/* 
 *	CCmbBxWinHost::OnCommand(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles notification from listbox and reflects it to the parent of
 *		the combo box
 *
 *	@comm
 *		LRESULT = Handled ? 0 : 1
 *
 *
 */
HRESULT CCmbBxWinHost::OnCommand(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CCmbBxWinHost::OnCommand");
	
	// Filter-out all the messages except Listbox notification messages
	Assert(_hwndParent);
	switch (HIWORD(wparam))
	{	
	case LBN_DBLCLK:
    	TxNotify(CBN_DBLCLK, NULL);
        break;

    case LBN_ERRSPACE:
        TxNotify((unsigned)CBN_ERRSPACE, NULL);
        break;

    case LBN_SELCHANGE:
    case LBN_SELCANCEL:
    	if (!_fListVisible)
			HideListBox(TRUE, TRUE);
    	TxNotify(CBN_SELCHANGE, NULL);
        UpdateEditBox();
        break;

    default:
    	// not handled so pass down the line
        return 1;
	}
	return 0;
}

/*
 *	CCmbBxWinHost::OnEnable(WPARAM, LPARAM)
 *
 *	@mfunc
 *		handles the WM_ENABLE message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnEnable(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnEnable");

	if (_fMousedown) 
	{
        _fMousedown = FALSE;
        DrawButton(NULL, FALSE);

        //
        // Pop combo listbox back up, canceling.
        //
        if (_fListVisible)
            HideListBox(TRUE, FALSE);
    }
    return 1;
}


/*
 *	CCmbBxWinHost::OnChar(WPARAM, LPARAM)
 *
 *	@mfunc
 *		handles the WM_CHAR message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnChar(
	WORD wparam, 
	DWORD lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnChar");

	// Check if we should eat the message or not
	if (_cbType == kDropDownList)
	{
		//bug fix #5318 - ignore delete, insert and clear
		if (((WCHAR)wparam) == VK_DELETE || ((WCHAR)wparam) == VK_INSERT ||
			((WCHAR)wparam) == VK_CLEAR)
			return 0;
			
		// Sending WM_CHAR is BAD!!! call the message handler directly
		// send the character string message to the listbox if visible
		_plbHost->OnChar(LOWORD(wparam), lparam);

		//	If Hi-Ansi need to send a wm_syskeyup message to ITextServices to 
		// stabalize the state
		if (0x80 <= wparam && wparam <= 0xFF && !HIWORD(GetKeyState(VK_MENU)))
		{
			LRESULT lres;
			_pserv->TxSendMessage(WM_SYSKEYUP, VK_MENU, 0xC0000000, &lres);
		}		
		return 0;
	}

	
	if (_cbType == kDropDown)
	{
		if (_fListVisible)
		{
			if (!_fCapture)
			{
				// Tell listbox to reset capturing by ending then starting it up
				_plbHost->OnCBTracking(LBCBM_END, 0);
				_plbHost->OnCBTracking(LBCBM_PREPARE, 0);			
			}

			// Send the message to the edit control iff it's not a tab
			if (((WCHAR)wparam) != VK_TAB)
				_pserv->TxSendMessage(WM_CHAR, wparam, lparam, NULL);

			if (!_fCapture)
			{
				// capture the cursor
				TxSetCapture(TRUE);
				_fCapture = 1;				
			}
		}
		else
		{
			// set the cursel to -1 if it already isn't
			if ((wparam != VK_RETURN) && (_plbHost->GetCursor() != -1))
				RichListBoxWndProc(_hwndList, LB_SETCURSEL, (WPARAM)-1, 0);

			// Send the message to the edit control iff it's not CTRL+i or CTRL+h
			if (((WCHAR)wparam) != VK_TAB)
				_pserv->TxSendMessage(WM_CHAR, wparam, lparam, NULL);
		}		
		return 0;
	}
	return 1;
}

/*
 *	CCmbBxWinHost::OnKeyDown(WPARAM, LPARAM)
 *
 *	@mfunc
 *		handles the WM_KEYDOWN message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnKeyDown(
	WORD wparam, 
	DWORD lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnKeyDown");

	BOOL	fUpdateCursor = FALSE;

	if (_fListVisible && (wparam == VK_RETURN || wparam == VK_ESCAPE))
	{
		if (wparam == VK_RETURN)
			_nCursor = _plbHost->GetCursor();

		// if we don't have focus then set the focus first
		if (!_fFocus)
			TxSetFocus();
		_fFocus = 1;

		HideListBox(TRUE, wparam == VK_RETURN);
		return 0;
	}
	
	// if we are in extended mode and F4 is hit
	// we just ignore it
	if (_fExtendedUI && wparam == VK_F4)
		return 0;
	
	Assert(_plbHost);
	int fExtUI = _fExtendedUI;
	int nCurSel = _plbHost->GetCursor();
	Assert(nCurSel >= -1);
	
	// if we are a dropdownlist combo box then just forward the message on to the 
	// list box 
	if (_cbType == kDropDownList)
	{
		switch (wparam)
		{		
		case VK_F4:
			if (_fListVisible)
				break;;
			fExtUI = 1;
			Assert(fExtUI && !_fListVisible);
			// fall through case		
			
		case VK_DOWN:
			if (fExtUI && !_fListVisible)
			{
				ShowListBox(TRUE);
				TxSetCapture(TRUE);			
				_fCapture = TRUE;
				return 1;			
			}		
			// Fall through case
			
		case VK_UP:
		case VK_NEXT:
		case VK_PRIOR:		
		case VK_RETURN:
		case VK_ESCAPE:	
		case VK_HOME:
		case VK_END:
			break;	

		//bug fix #5318
		/*
		case VK_DELETE:
		case VK_CLEAR:
		case VK_INSERT:
		*/

		default:
			// There no reason for us to pass these keys to ITextServices since the control is suppose
			// to be read-only
			return 0;
		}
	}
	else 
	{
		fUpdateCursor = TRUE;

		switch (wparam)
		{		
		case VK_F4:
			if (_fListVisible)
				break;
			fExtUI = 1;
			Assert(fExtUI && !_fListVisible);
			// fall through case		
			
		case VK_DOWN:
			if (fExtUI && !_fListVisible)
			{
				ShowListBox(TRUE);
				TxSetCapture(TRUE);			
				_fCapture = TRUE;
				return 0;			
			}		
			// Fall through case
			
		case VK_UP:
		case VK_NEXT:
		case VK_PRIOR:
			if (_fListVisible)
			{				
				if (_fCapture)
				{
					// release our capture flag and tell lb to start tracking
					_fCapture = 0;
					_plbHost->OnCBTracking(LBCBM_START, _fMousedown);
				}

				// selecting the top index and then sending the keydown to the 
				// listbox causes 2 moves so handle this ourselves
				if (nCurSel == -1)
				{
					LRESULT lResult = RichListBoxWndProc(_hwndList, LB_SETCURSEL, _plbHost->GetTopIndex(), 0);
					UpdateEditBox();
					UpdateCbWindow();
					if (lResult != LB_ERR)
						TxNotify(CBN_SELCHANGE, NULL);
					return 0;
				}
			}
			else
			{
				// if Listbox isn't visible and the listbox cursor is -1
				// then we should try to select the correct item in the list
				// box
				if (nCurSel == -1)
				{
					UpdateListBox(TRUE);
					if (_plbHost->GetCursor() >= 0)
					{
						HiliteEdit(TRUE);
						return 0;
					} else if (!_plbHost->GetCount())
					{
						return 0;
					}
				}
			}
			break;
		
		case VK_RETURN:
		case VK_ESCAPE:	
			break;		

		default:
			// return zero to say we didn't handle this
			return 1;
		}
	}
	// pass message to list box
	_plbHost->OnKeyDown(wparam, lparam, 0);
	UpdateCbWindow();

	if (fUpdateCursor)
		_nCursor = _plbHost->GetCursor();

	return 0; 
	
}

/*
 *	CCmbBxWinHost::OnSyskeyDown(WORD, DWORD)
 *
 *	@mfunc
 *		handles the WM_SYSKEYDOWN message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnSyskeyDown(
	WORD wparam, 
	DWORD lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnSyskeyDown");

	if (lparam & 0x20000000L)  /* Check if the alt key is down */ 
	{
	    // Handle Combobox support.  We want alt up or down arrow to behave
	    // like F4 key which completes the combo box selection
		if (lparam & 0x1000000)
		{
			// We just want to ignore keys on the number pad...
	        // This is an extended key such as the arrow keys not on the
	        // numeric keypad so just drop the combobox.
	        if (wparam != VK_DOWN && wparam != VK_UP)
	            return 1;
		}
		else if (GetKeyState(VK_NUMLOCK) & 0x1) 
	    {
	        //If numlock down, just send all system keys to dwp
	        return 1;
	    } 
	    else 
	    {
			if (wparam != VK_DOWN && wparam != VK_UP)
				return 1;	    	
	    }

	    // If the listbox isn't visible, just show it
	    if (!_fListVisible) 
		{
			ShowListBox(TRUE);
			TxSetCapture(TRUE);			
			_fCapture = TRUE;
		}
	    else  	//Ok, the listbox is visible.  So hide the listbox window.
	        HideListBox(TRUE, TRUE);
	    return 0;
	}
	return 1;
}

/*
 *	CCmbBxWinHost::OnCaptureChanged(WPARAM, LPARAM)
 *
 *	@mfunc
 *		handles the WM_CAPTURECHANGED message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnCaptureChanged(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnCaptureChanged");
    if (_fCapture) 
    {   
        // Pop combo listbox back up, canceling.
        if (_fListVisible)
            HideListBox(TRUE, FALSE);
        else
        {
        	_fCapture = FALSE;
   			_fMousedown = FALSE;
        	DrawButton(NULL, FALSE);
        }
		return 0;
    }
	return 1;
}


/*
 *	CCmbBxWinHost::OnMouseMove(WPARAM, LPARAM)
 *
 *	@mfunc
 *		handles the WM_MOUSEMOVE message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnMouseMove(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnMouseMove");

	if (((CTxtEdit *) _pserv)->_fCustomLook &&
		!_fMouseover && 
		W32->TrackMouseLeave(_hwnd))
	{
		if (_fFocus || W32->IsForegroundFrame(_hwnd))
		{
			_fMouseover = TRUE;
			// Force redraw
			InvalidateRect(_hwnd, NULL, TRUE);
		}
	}

	// We do the following if we have mouse captured or if the listbox is visible
	if (_cbType != kSimple && _fCapture)
	{
		// get the point coordinates of mouse
		POINT pt;
		POINTSTOPOINT(pt, lparam);
		if (_fListVisible)
		{
			// if the listbox is visible visible check if the cursor went over 
			// list box
			RECT rc;
			POINT ptScreen = pt;
			GetWindowRect(_hwndList, &rc);
			TxClientToScreen(&ptScreen);			
			if (PtInRect(&rc, ptScreen))
			{
				// Release the capture state of the mouse
				if (_fCapture)
				{
					_fCapture = FALSE;
					TxSetCapture(FALSE);
				}

				// notify the listbox to start tracking
				Assert(_plbHost);
				// BUGBUG REVIEW JMO Wrong PostMessage????
				::PostMessage(_hwndList, LBCB_TRACKING, LBCBM_START, _fMousedown);
				_fMousedown = 0;
			}
		}
		DrawButton(NULL, _fMousedown ? PtInRect(&_rcButton, pt) : FALSE);
		return FALSE;
	}
#ifdef DEBUG
	if (_cbType != kSimple)
		Assert(!_fListVisible);
#endif
	return TRUE;
}

/*
 *	CCmbBxWinHost::OnMouseLeave(WPARAM, LPARAM)
 *
 *	@mfunc
 *		handles the WM_MOUSELEAVE message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnMouseLeave(
	WPARAM wparam, 
	LPARAM lparam)
{
	if (!_fListVisible && _fMouseover)
	{
		_fMouseover = FALSE;
		InvalidateRect(_hwnd, NULL, TRUE);
	}
	return 0;
}

/*
 *	CCmbBxWinHost::OnSetEditStyle(WPARAM, LPARAM)
 *
 *	@mfunc
 *		handles the WM_MOUSELEAVE message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnSetEditStyle(
	WPARAM wparam, 
	LPARAM lparam)
{
	LRESULT	lres;
	_pserv->TxSendMessage(EM_SETEDITSTYLE, wparam, lparam, &lres);
	if (lparam & SES_CUSTOMLOOK)
	{
		if (wparam & SES_CUSTOMLOOK)
		{
			_dwExStyle &= ~WS_EX_CLIENTEDGE;
			_fBorder = 1;
		}
		else
			_dwExStyle |= WS_EX_CLIENTEDGE;

		SetWindowLong(_hwnd, GWL_EXSTYLE, _dwExStyle);
	}
	return lres;
}
	
/*
 *	CCmbBxWinHost::OnLButtonUp(WPARAM, LPARAM)
 *
 *	@mfunc
 *		handles the WM_LBUTTONUP message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnLButtonUp(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnLButtonUp");
 
    if (_fMousedown) 
	{
        _fMousedown = FALSE;
        if (_cbType != kSimple) 
		{
            // If an item in the listbox matches the text in the edit
            // control, scroll it to the top of the listbox. Select the
            // item only if the mouse button isn't down otherwise we
            // will select the item when the mouse button goes up.
			if (_cbType == kDropDown)
			{
				UpdateListBox(TRUE);
				AutoUpdateEdit(-1);		
			}
			
			// if we recieved a mouse up and the listbox is still visible then user 
			// hasn't selected any items from the listbox so don't release the capture yet
			if (_fCapture && !_fListVisible)
			{
				_fCapture = FALSE;
				TxSetCapture(FALSE);
			}

			DrawButton(NULL, FALSE);
			if (_fButtonDown)
			{
				_fButtonDown = 0;
#ifndef NOACCESSIBILITY
				W32->NotifyWinEvent(EVENT_OBJECT_STATECHANGE, _hwnd, OBJID_CLIENT, INDEX_COMBOBOX_BUTTON);
#endif
			}
			return FALSE;
		}
    }
	return TRUE;
}

/*
 *	CCmbBxWinHost::OnLButtonDown(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Draws the client edges of the combo box
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnLButtonDown(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnLButtonDown");

	// check if we should dropdown the list box
	POINT pt;
	POINTSTOPOINT(pt, lparam);
	RECT	rcEdit = _rcWindow;
	BOOL	fListVisibleBefore = _fListVisible;
	LRESULT	retCode = 1;

	rcEdit.bottom = _cyCombo;

	// if we don't have focus then set the focus first
	if (!_fFocus)
	{
		TxSetFocus();
		if (_cbType != kDropDownList)
			retCode = 0;
	}
	_fFocus = 1;

	if (fListVisibleBefore && !_fListVisible)	// This is the case where OnSetFocus 
		return 0;								//	has hide the listbox already

	// listbox is down so pop it back up
	if (_fListVisible)
		return !HideListBox(TRUE, FALSE);

	if ((_cbType == kDropDownList && PtInRect(&rcEdit, pt))
		|| (_cbType == kDropDown && PtInRect(&_rcButton, pt)))
	{
		// need to show listbox
		ShowListBox(TRUE);
		_fMousedown = TRUE;
					
		TxSetCapture(TRUE);			
		_fCapture = TRUE;

#ifndef NOACCESSIBILITY
		if (_cbType == kDropDown)
		{
			_fButtonDown = TRUE;
			W32->NotifyWinEvent(EVENT_OBJECT_STATECHANGE, _hwnd, OBJID_CLIENT, INDEX_COMBOBOX_BUTTON);
		}
#endif
		return 0;
	}
	return retCode;
}

/*
 *	CCmbBxWinHost::OnMouseWheel(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Draws the client edges of the combo box
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnMouseWheel(
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnMouseWheel");
	
    // Handle only scrolling.
    if (wparam & (MK_CONTROL | MK_SHIFT))
        return 1;

    // If the listbox is visible, send it the message to scroll.
    // if the listbox is 
	if (_fListVisible)
	{
		_plbHost->OnMouseWheel(wparam, lparam);
		return 0;
	}
		
    // If we're in extended UI mode or the edit control isn't yet created,
    // bail.
    if (_fExtendedUI)
        return 0;

    // Emulate arrow up/down messages to the edit control.
    int i = abs(((short)HIWORD(wparam))/WHEEL_DELTA);
    wparam = ((short)HIWORD(wparam) > 0) ? VK_UP : VK_DOWN;

    while (i-- > 0) 
        OnKeyDown(wparam, lparam);

	return 0;
}


/*
 *	CCmbBxWinHost::OnSetCursor(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Changes the cursor depending on where the cursor is
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
LRESULT CCmbBxWinHost::OnSetCursor(
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnSetCursor");

	POINT pt;
	GetCursorPos(&pt);
	::ScreenToClient(_hwnd, &pt);

	if ((_cbType == kDropDownList) || 
		(_cbType == kDropDown && ((_fRightAlign) ? _rcButton.right >= pt.x : _rcButton.left <= pt.x)))
	{
		TxSetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW)), NULL);
	}
	else
		_pserv->OnTxSetCursor(DVASPECT_CONTENT,	-1,	NULL, NULL, NULL, NULL,
			NULL, pt.x, pt.y);

	return TRUE;
}

/*
 *	CCmbBxWinHost::OnSetFocus(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Draws the button and sends the WM_DRAWITEM message for owner draw
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
LRESULT CCmbBxWinHost::OnSetFocus(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnSetFocus");

    _fFocus = TRUE;

	// Hide the list box
	if (_fListVisible)		    	
    	HideListBox(TRUE, _bSelOk);
    else if (_fOwnerDraw && _cbType == kDropDownList)
    	CbMessageItemHandler(NULL, ITEM_MSG_DRAWCOMBO, 0, 0);
	else    
		DrawEditFocus(NULL);    // Draw the focus 

    // Notify the parent we have the focus iff this function
    // wasn't called in response to LBCB_TRACKING
    if (_fLBCBMessage)
    	_fLBCBMessage = 0;
    else
	    TxNotify(CBN_SETFOCUS, NULL);

	// we return 1 if we are owner draw or if
	// we are a kDropDownList, this is because
	// we have to prevent the message from being passed
	// to _pserv
    return (_cbType == kDropDownList);
}


/*
 *	CCmbBxWinHost::OnKillFocus(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Draws the button and sends the WM_DRAWITEM message for owner draw
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
LRESULT CCmbBxWinHost::OnKillFocus(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnKillFocus");

	// if we never had focus or if not list window just get out
	if (_hwndList == NULL)
	      return 0;

	BOOL fHideListBox = FALSE;

    if ((HWND)wparam != _hwndList) 
    {
		// We only give up the focus if the new window getting the focus
        // doesn't belong to the combo box.
	    
	    // The combo box is losing the focus.  Send buttonup clicks so that
	    // things release the mouse capture if they have it...  If the
	    // pwndListBox is null, don't do anything.  This occurs if the combo box
	    // is destroyed while it has the focus.
	    OnLButtonUp(0L, 0xFFFFFFFFL);

		if (_fListVisible)
		{
			fHideListBox = TRUE;
			HideListBox(TRUE, FALSE);
		}
	}

	//bug fix #4013
	if (!_fFocus)
		return 0;
	_fFocus = FALSE;

	if (!fHideListBox)
		TxNotify(CBN_SELENDCANCEL, NULL);	// System Combo is always sending this notification

	// Remove Focus Rect
	if (_cbType != kDropDownList)
	{		
		HiliteEdit(FALSE);

		// Hide any selections
		_pserv->TxSendMessage(EM_HIDESELECTION, 1, 0, NULL);
	}
	else if (_fOwnerDraw)
		CbMessageItemHandler(NULL, ITEM_MSG_DRAWCOMBO, 0, 0);
	else
		DrawEditFocus(NULL);
		
		
	TxNotify(CBN_KILLFOCUS, NULL); 

	if (_cbType == kDropDownList)
		return 1;
	return 0;
}


/*
 *	CCmbBxWinHost::OnSize(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Draws the button and sends the WM_DRAWITEM message for owner draw
 *
 *	@rdesc
 *		BOOL = Processed ? FALSE : TRUE
 */
LRESULT CCmbBxWinHost::OnSize(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnCbSize");

    // only deal with this message if we didn't generate the message and
    // the new size is a valid one
    if (!_fResizing && _hwndList)
    {
    	_fResizing = 1;
    	RECT rc;
    	GetWindowRect(_hwnd, &rc);
    	rc.right -= rc.left;
    	rc.bottom -= rc.top;    	
    	rc.left = rc.top = 0;
    	CbCalcControlRects(&rc, FALSE);
    	
    	// Need to resize the list box
		if (_cbType != kSimple)
			SetDropSize(&_rcList);
		_fResizing = 0;
    } 
	_pserv->TxSendMessage(WM_SIZE, wparam, lparam, NULL);
	CTxtWinHost::OnSize(_hwnd, wparam, (int)LOWORD(lparam), (int)HIWORD(lparam));	
	return FALSE;
}

/*
 *	CCmbBxWinHost::OnGetDlgCode(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Draws the button and sends the WM_DRAWITEM message for owner draw
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
LRESULT CCmbBxWinHost::OnGetDlgCode(
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnGetDlgCode");

	// call the parents GetDlgCode first	
	LRESULT code = DLGC_WANTCHARS | DLGC_WANTARROWS;
	if (_cbType != kDropDownList)
		code |= DLGC_HASSETSEL;

	// If the listbox is dropped and the ENTER key is pressed,
	// we want this message so we can close up the listbox
	if ((lparam != 0) &&
	    (((LPMSG)lparam)->message == WM_KEYDOWN) &&
	    _fListVisible &&
	    ((wparam == VK_RETURN) || (wparam == VK_ESCAPE)))
	{
	    code |= DLGC_WANTMESSAGE;
	}
	_fInDialogBox = TRUE;
		
	return((LRESULT)code);
}

/*
 *	CCmbBxWinHost::OnSetTextEx(WPARAM, LPARAM)
 *
 *	@mfunc
 *		The first item is sent to the editbox and the rest
 *	of the string is sent to the listbox.
 *
 *	@rdesc
 *		LRESULT
 */
LRESULT CCmbBxWinHost::OnSetTextEx(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnSetTextEx");

	WCHAR	*psz = (WCHAR*)lparam;

	_nCursor = -2;			// Reset last selected item
	if (!psz || *psz == L'\0')
	{
		// Null string
		_pserv->TxSendMessage(EM_SETTEXTEX, wparam, lparam, NULL);
		return S_OK;
	}

	while (*psz != L'\r' && *psz)
		psz++;

	long cch = (psz - (WCHAR*)lparam);

	WCHAR *pwch = new WCHAR[cch + 1];

	if (!pwch)			// No memory?
	{
		TxNotify((unsigned)CBN_ERRSPACE, NULL);
		return S_OK;
	}

	if (cch)
		memcpy(pwch, (void *)lparam, cch * sizeof(WCHAR));

	_pserv->TxSendMessage(EM_SETTEXTEX, wparam, (LPARAM)pwch, NULL);

	delete [] pwch;

	if (*psz == L'\0')
		return S_OK;

	// Send rest of strings to REListbox.
	psz++;

	return SendMessage(_hwndList, EM_SETTEXTEX, wparam, (LPARAM)psz);
}

/*
 *	CCmbBxWinHost::OnPaint(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Draws the button and sends the WM_DRAWITEM message for owner draw
 *
 *	@rdesc
 *		BOOL = processed ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnPaint(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnPaint");

	PAINTSTRUCT ps;
	HPALETTE hpalOld = NULL;
	HDC hdc = BeginPaint(_hwnd, &ps);
	RECT rcClient;

	_fIgnoreUpdate = 1;		// Ignore EN_UPDATE from host

	// Since we are using the CS_PARENTDC style, make sure
	// the clip region is limited to our client window.
	GetClientRect(_hwnd, &rcClient);

	// pass message on to the parentwindow if owner draw
	if (_cbType != kDropDownList || !_fOwnerDraw)
	{
		RECT rcFocus = rcClient;
		
		// Set up the palette for drawing our data
		if (_hpal)
		{
			hpalOld = SelectPalette(hdc, _hpal, TRUE);
			RealizePalette(hdc);
		}

		SaveDC(hdc);

		IntersectClipRect(hdc, rcClient.left, rcClient.top, rcClient.right,
			rcClient.bottom);

		// Fill-in the gap between the button and richedit control
		RECT rcGap;
		if (_fRightAlign)
		{
			rcGap.left = _rcButton.right;
			rcGap.right = rcGap.left + _xInset + 1;
		}
		else
		{
			rcGap.right = _rcButton.left;
			rcGap.left = rcGap.right - _xInset - 1;
		}
		rcGap.top = rcClient.top;
		rcGap.bottom = rcClient.bottom;			
		FillRect(hdc, &rcGap, (HBRUSH)(DWORD_PTR)(((_fDisabled) ? COLOR_BTNFACE : COLOR_WINDOW) + 1));
	
		if (_fFocus && _cbType == kDropDownList)		
		{	
			//First if there is a focus rect then remove the focus rect
			// shrink the focus rect by the inset
			rcFocus.top += _yInset;
			rcFocus.bottom -= _yInset;			
			
			if (_fRightAlign)
				rcFocus.left = _rcButton.right;
			else
				rcFocus.right = _rcButton.left;

			rcFocus.left += _xInset;

			if (!((CTxtEdit *) _pserv)->_fCustomLook)
				rcFocus.right -= _xInset;

			// We need to erase the focus rect if we haven't already 
			// erased the background
			DrawFocusRect(hdc, &rcFocus);
		}		

		if (_cbType != kSimple)
		{
			if (_fRightAlign)
				rcClient.left = _rcButton.right + _xInset;
			else
				rcClient.right = _rcButton.left - (((CTxtEdit *)_pserv)->_fCustomLook ? 0 : _xInset);
		}


		_pserv->TxDraw(
			DVASPECT_CONTENT,  		// Draw Aspect
			-1,						// Lindex
			NULL,					// Info for drawing optimazation
			NULL,					// target device information
			hdc,					// Draw device HDC
			NULL, 				   	// Target device HDC
			(const RECTL *) &rcClient,// Bounding client rectangle
			NULL, 					// Clipping rectangle for metafiles
			&ps.rcPaint,			// Update rectangle
			NULL, 	   				// Call back function
			NULL,					// Call back parameter
			TXTVIEW_ACTIVE);		// What view - the active one!

		// Restore palette if there is one
		if(hpalOld)
			SelectPalette(hdc, hpalOld, TRUE);

		RestoreDC(hdc, -1);

		//Redraw the focus rect, don't have to recalc since we already did above
		if (_fFocus && _cbType == kDropDownList)
			DrawFocusRect(hdc, &rcFocus);

		DrawButton(hdc, _fMousedown);

		DrawCustomFrame(0, hdc);
	}
	else
	{
		// We have to draw the button first because CbMessageItemHandler
		// will perform a IntersectClipRect which will prevent us from
		// drawing the button later
		DrawButton(hdc, _fMousedown);
		
		CbMessageItemHandler(hdc, ITEM_MSG_DRAWCOMBO, 0, 0);
	}

	EndPaint(_hwnd, &ps);

	_fIgnoreUpdate = 0;
	if (_fSendEditChange)
	{
		TxNotify(EN_UPDATE, NULL);
		_fSendEditChange = 0;
	}
    return FALSE;
}


/*
 *	CCmbBxWinHost::DrawCustomFrame(WPARAM, hDCIn)
 *
 *	@mfunc
 *		Draws the custom frame
 *
 *	@rdesc
 *		BOOL = processed ? TRUE : FALSE
 */
BOOL CCmbBxWinHost::DrawCustomFrame(
	WPARAM	wParam,
	HDC		hDCIn)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::DrawCustomFrame");

	BOOL retCode = FALSE;
	if (((CTxtEdit *) _pserv)->_fCustomLook)
	{
		HDC		hdc = hDCIn;
		BOOL	fReleaseDC = hDCIn ? FALSE : TRUE;

		if (!hdc)
		{
			if (wParam == 1)
				hdc = ::GetDC(_hwnd);
			else
				hdc = ::GetDCEx(_hwnd, (HRGN)wParam, DCX_WINDOW|DCX_INTERSECTRGN);
		}

		if (hdc)
		{
			RECT rcClient;

			GetClientRect(_hwnd, &rcClient);

			retCode = TRUE;
			// Draw border rectangle using new look
			COLORREF crBorder = W32->GetCtlBorderColor(_fListVisible, _fMouseover);
			HBRUSH hbrBorder = CreateSolidBrush(crBorder);
			::FrameRect(hdc, &rcClient, hbrBorder);
			::DeleteObject(hbrBorder);

			if (fReleaseDC)
				::ReleaseDC(_hwnd, hdc);
		}
	}
	return retCode;
}

#endif // NOLISTCOMBOBOXES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\array.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	ARRAY.C	-- Generic Array Implementation |
 *	
 *	Original Author: <nl>
 *		Christian Fortini
 *
 *	History: <nl>
 *		6/25/95  alexgo  Cleanup and Commented
 *				 KeithCu Changed to auto/grow and shrink exponentially
 *
 *	Copyright (c) 1995-1999, Microsoft Corporation. All rights reserved.
 */


#include "_common.h"
#include "_array.h"

ASSERTDATA

const int celGrow = 4;

//
//	Invariant support
//
#define	DEBUG_CLASSNAME	CArrayBase
#include "_invar.h"

// ===================================  CArrayBase  ================================================

#ifdef DEBUG
/*
 *	CArrayBase::Invariant()
 *
 *	@mfunc	Tests the array state to make sure it is valid.  DEBUG only
 *
 *	@rdesc	TRUE if the tests succeed, FALSE otherwise
 */
BOOL CArrayBase::Invariant() const
{
	Assert(_cbElem > 0);

	if(!_prgel)
	{
		Assert(_cel == 0);
		Assert(_celMax == 0);

		// We go ahead and return a value here so that
		// this function can be executed in the "watch"
		// window of various debuggers
		if(_cel || _celMax)
			return FALSE;
	}
	else
	{
		Assert(_celMax > 0 );
		Assert(_cel <= _celMax);

		if(_celMax == 0 || _cel > _celMax)
			return FALSE;
	}

	return TRUE;
}

/* 
 *	CArrayBase::Elem(iel)
 *
 *	@mfunc	Returns a pointer to the element indexed by <p iel>
 *
 *	@rdesc	A pointer to the element indexed by <p iel>.  This pointer may
 *	be cast to a pointer of the appropriate element type.
 */
void* CArrayBase::Elem(
	LONG iel) const	//@parm Index to use
{
	_TEST_INVARIANT_

	AssertSz(iel == 0 || (iel > 0 && iel < _cel),
		"CArrayBase::Elem() - Index out of range");

	return _prgel + iel * _cbElem;
}								 
#endif

/*
 *	CArrayBase::TransferTo
 *
 *	@mfunc Shallow copy array to passed-in array, and
 *	initialize *this.
 */
void CArrayBase::TransferTo(CArrayBase &ar)
{
	Assert(ar._cbElem == _cbElem);
	ar._cel = _cel;
	ar._celMax = _celMax;
	ar._prgel = _prgel;

	_prgel = NULL; 
	_cel = 0; 
	_celMax = 0; 
}

/*
 *	CArrayBase::CArrayBase
 *
 *	@mfunc Constructor
 */
CArrayBase::CArrayBase(
	LONG cbElem)		//@parm	Size of an individual array element
{	
	_prgel = NULL; 
	_cel = 0; 
	_celMax = 0; 
	_cbElem = cbElem;
}

/*
 *	CArrayBase::ArAdd
 *
 *	@mfunc	Adds <p celAdd> elements to the end of the array.
 *
 *	@rdesc	A pointer to the start of the new elements added.  If non-NULL, 
 *	<p pielIns> will be set to the index at which elements were added.
 *
 *  We grow in steps of celGrow when small and exponentially when large.
 */
void* CArrayBase::ArAdd(
	LONG celAdd,	//@parm Count of elements to add
	LONG *pielIns)	//@parm Out parm for index of first element added
{
	_TEST_INVARIANT_
	char *pel;

	if(!_prgel || _cel + celAdd > _celMax)					// need to grow 
	{
		LONG celNew;

		if (!_prgel)
		{
			_cel = 0;
			_celMax = 0;
		}
		
		celNew = max(celAdd, celGrow) + _cel / 16;

		pel = (char*)PvReAlloc(_prgel, (_celMax + celNew) * _cbElem);
		if(!pel)
			return NULL;
		_prgel = pel;
		_celMax += celNew;
	}
	pel = _prgel + _cel * _cbElem;
	ZeroMemory(pel, celAdd * _cbElem);

	if(pielIns)
		*pielIns = _cel;

	_cel += celAdd;
	return pel;
}

/*
 *	CArrayBase::ArInsert (iel, celIns)
 *
 *	@mfunc Inserts <p celIns> new elements at index <p iel>
 *
 *	@rdesc A pointer to the newly inserted elements.  Will be NULL on
 *	failure.
 */
void* CArrayBase::ArInsert(
	LONG iel,		//@parm	Index at which to insert
	LONG celIns)	//@parm Count of elements to insert
{
	char *pel;

	_TEST_INVARIANT_

	AssertSz(iel <= _cel, "CArrayBase::Insert() - Insert out of range");

	if(iel >= _cel)
		return ArAdd(celIns, NULL);

	if(_cel + celIns > _celMax)				// need to grow 
	{
		AssertSz(_prgel, "CArrayBase::Insert() - Growing a non existent array !");

		LONG celNew = max(celIns, celGrow) + _cel / 16;
		pel = (char*)PvReAlloc(_prgel, (_celMax + celNew) * _cbElem);
		if(!pel)
		{
			TRACEERRORSZ("CArrayBase::Insert() - Couldn't realloc line array");
			return NULL;
		}
		_prgel = pel;
		_celMax += celNew;
	}
	pel = _prgel + iel * _cbElem;
	if(iel < _cel)				// Nove Elems up to make room for new ones
		MoveMemory(pel + celIns*_cbElem, pel, (_cel - iel)*_cbElem);

	_cel += celIns;
	return pel;
}

/*
 *	CArrayBase::Remove
 *
 *	@mfunc	Removes the <p celFree> elements from the array starting at index
 *	<p ielFirst>.  If <p celFree> is negative, then all elements after
 *	<p ielFirst> are removed.
 *
 *	@rdesc nothing
 */
void CArrayBase::Remove(
	LONG ielFirst, 		//@parm Index at which elements should be removed
	LONG celFree) 		//@parm	Count of elements to remove. 
{
	char *pel;

	_TEST_INVARIANT_

	if(celFree < 0)
		celFree = _cel - ielFirst;

	AssertSz(ielFirst + celFree <= _cel, "CArrayBase::Free() - Freeing out of range");

	if(_cel > ielFirst + celFree)
	{
		pel = _prgel + ielFirst * _cbElem;
		MoveMemory(pel, pel + celFree * _cbElem,
			(_cel - ielFirst - celFree) * _cbElem);
	}

	_cel -= celFree;

	if(_cel < _celMax - celGrow - _cel / 16)
	{
		// Shrink array
		LONG	celCount = max(_cel, celGrow);
		char*	prgelLocal = (char*)PvReAlloc(_prgel, celCount * _cbElem);

		if (prgelLocal)
		{
			_celMax	= celCount;
			_prgel	= prgelLocal;
		}
	}
}

/*
 *	CArrayBase::Clear
 *
 *	@mfunc	Clears the entire array, potentially deleting all of the memory
 *	as well.
 *
 *	@rdesc	nothing
 */
void CArrayBase::Clear(
	ArrayFlag flag)	//@parm Indicates what should be done with the memory
					//in the array.  One of AF_DELETEMEM or AF_KEEPMEM
{
	_TEST_INVARIANT_

	_cel = 0;
	if( flag != AF_DELETEMEM && _prgel)
	{
		LONG	celCount = min(celGrow, _celMax);
		char	*prgelLocal = (char*) PvReAlloc(_prgel, celCount * _cbElem);

		if (prgelLocal)
		{
			_celMax	= celCount;
			_prgel	= prgelLocal;
			return;
		}
	}

	FreePv(_prgel);
	_prgel = NULL;
	_celMax = 0;
}

/*
 *	CArrayBase::Replace
 *
 *	@mfunc	Replaces the <p celRepl> elements at index <p ielRepl> with the
 *	contents of the array specified by <p par>.  If <p celRepl> is negative,
 *	then the entire contents of <p this> array starting at <p ielRepl> should
 *	be replaced.
 *
 *	@rdesc	Returns TRUE on success, FALSE otherwise.
 */
BOOL CArrayBase::Replace(
	LONG ielRepl, 		//@parm index at which replacement should occur
	LONG celRepl, 		//@parm number of elements to replace (may be
						//		negative, indicating that all
	CArrayBase *par)	//@parm array to use as the replacement source
{
	_TEST_INVARIANT_

	LONG celMove = 0;
	LONG celIns = par->Count();
	
	if (celRepl < 0)
		celRepl = _cel - ielRepl;

	AssertSz(ielRepl + celRepl <= _cel, "CArrayBase::ArReplace() - Replacing out of range");
	
	celMove = min(celRepl, celIns);

	if (celMove > 0) 
	{
		MoveMemory(Elem(ielRepl), par->Elem(0), celMove * _cbElem);
		celIns -= celMove;
		celRepl -= celMove;
		ielRepl += celMove;
	}

	Assert(celIns >= 0);
	Assert(celRepl >= 0);
	Assert(celIns + celMove == par->Count());

	if(celIns > 0)
	{
		Assert(celRepl == 0);
		void *pelIns = ArInsert (ielRepl, celIns);
		if (!pelIns)
			return FALSE;
		MoveMemory(pelIns, par->Elem(celMove), celIns * _cbElem);
	}
	else if(celRepl > 0)
		Remove (ielRepl, celRepl);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\cfpf.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module	CFPF.C -- -- RichEdit CCharFormat and CParaFormat Classes |
 *
 *	Created: <nl>
 *		9/1995 -- Murray Sargent <nl>
 *
 *	@devnote
 *		The this ptr for all methods points to an internal format class, i.e.,
 *		either a CCharFormat or a CParaFormat, which uses the cbSize field as
 *		a reference count.  The pCF or pPF argument points at an external
 *		CCharFormat or CParaFormat class, that is, pCF->cbSize and pPF->cbSize
 *		give the size of their structure.  The code still assumes that both
 *		internal and external forms are derived from the CHARFORMAT(2) and
 *		PARAFORMAT(2) API structures, so some redesign would be necessary to
 *		obtain a more space-efficient internal form.
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_array.h"					// for fumemmov()
#include "_rtfconv.h"				// for IsCharSetValid()
#include "_font.h"					// for GetFontNameIndex(), GetFontName()

ASSERTDATA


// Table of formatting info for Normal and Heading styles
const STYLEFORMAT g_Style[] =		// {dwEffects; yHeight}
{							// Measurements in points
	{CFE_BOLD,				14},	// Heading 1
	{CFE_BOLD + CFE_ITALIC,	12},	// Heading 2
	{0,						12},	// Heading 3
	{CFE_BOLD,				12},	// Heading 4
	{0,						11},	// Heading 5
	{CFE_ITALIC,			11},	// Heading 6
	{0,						 0},	// Heading 7
	{CFE_ITALIC,			 0},	// Heading 8
	{CFE_BOLD + CFE_ITALIC,	 9}		// Heading 9
};


BOOL IsValidTwip(LONG dl)
{
	static const LONG dlMax =  0x00FFFFFF;
	static const LONG dlMin = -0x00FFFFFF;
	if (dl > dlMax || dl < dlMin)
		return FALSE;
	return TRUE;
}

//------------------------- CCharFormat Class -----------------------------------

/*
 *	CCharFormat::Apply(pCF, dwMask, dwMask2)
 *
 *	@mfunc
 *		Apply *<p pCF> to this CCharFormat as specified by nonzero bits in
 *		dwMask and dwMask2
 *
 *	@rdesc
 *		HRESULT = NOERROR
 *
 *	@devnote
 *		Autocolor is dealt with through a neat little hack made possible
 *		by the choice CFE_AUTOCOLOR = CFM_COLOR (see richedit.h).  Hence
 *		if <p pCF>->dwMask specifies color, it automatically resets autocolor
 *		provided (<p pCF>->dwEffects & CFE_AUTOCOLOR) is zero.
 *
 *		*<p pCF> is an external CCharFormat, i.e., it's either a CHARFORMAT
 *		or a CHARFORMAT2 with the appropriate size given by cbSize. But
 *		this CCharFormat is internal and cbSize is used as a reference count.
 */
HRESULT CCharFormat::Apply (
	const CCharFormat *pCF,	//@parm	CCharFormat to apply to this CF
	DWORD dwMask,			//@parm Mask corresponding to CHARFORMAT2
	DWORD dwMask2)			//@parm Mask for additional internal parms
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormat::Apply");

	DWORD	dwEffectMask = dwMask & CFM_EFFECTS2;
	bool	fNewCharset = false;

	// Reset effect bits to be modified and OR in supplied values
	_dwEffects &= ~dwEffectMask;
	_dwEffects |= pCF->_dwEffects & dwEffectMask;

	// Ditto for additional effects given by dwMask2
	dwEffectMask = dwMask2 & 0xBBFC0000;	// Don't allow autocolors, sub/sups
	_dwEffects	&= ~dwEffectMask;
	_dwEffects	|= pCF->_dwEffects & dwEffectMask;

	// Setup Temp. display attributes idx
	if (dwMask2 & CFM2_USETMPDISPATTR)
		_sTmpDisplayAttrIdx = pCF->_sTmpDisplayAttrIdx;

	// If CFM_BOLD is specified, it overrides the font weight
	if(dwMask & CFM_BOLD)
		_wWeight = (pCF->_dwEffects & CFE_BOLD) ? FW_BOLD : FW_NORMAL;

	// Handle CFM_COLOR since it's overloaded with CFE_AUTOCOLOR
	if(dwMask & CFM_COLOR)
		_crTextColor = pCF->_crTextColor;

	if(dwMask & ~CFM_EFFECTS)				// Early out if only dwEffects
	{										//  is modified. Note that
		if(dwMask & CFM_SIZE)				//  CFM_EFFECTS includes CFM_COLOR
		{
			// If dwMask2 CFM2_USABLEFONT bit is set, pCF->_yHeight (from
			// EM_SETFONTSIZE wparam) is signed increment in points.
			_yHeight = dwMask2 & CFM2_USABLEFONT
					? GetUsableFontHeight(_yHeight, pCF->_yHeight)
					: pCF->_yHeight;
		}

		if(dwMask & CFM_OFFSET)
			_yOffset = pCF->_yOffset;

		if((dwMask & CFM_CHARSET) &&

			// Caller guarantees no check needed
			(dwMask2 & (CFM2_NOCHARSETCHECK | CFM2_MATCHFONT) ||

			// Caller is itemizer. Change to ANSI_CHARSET only if current is BiDi,
			// dont change if current is DBCS/FE charset or symbol.
			(dwMask2 & CFM2_SCRIPT && 
			 (!pCF->_iCharRep && IsBiDiCharRep(_iCharRep) || 
			  pCF->_iCharRep && _iCharRep < NCHARSETS && !IsFECharRep(_iCharRep) &&
			  !IsSymbolOrOEMCharRep(_iCharRep) && !(_dwEffects & CFE_RUNISDBCS))) ||

			// Caller is not itemizer. Allow consistent direction
			(!(dwMask2 & CFM2_SCRIPT) && 
			 (!(IsRTLCharRep(_iCharRep) ^ IsRTLCharRep(pCF->_iCharRep)) ||
			  IsSymbolOrOEMCharRep(pCF->_iCharRep)))))
		{
			fNewCharset = TRUE;
			_iCharRep = pCF->_iCharRep;
		}
			
		if ((dwMask2 & (CFM2_MATCHFONT | CFM2_ADJUSTFONTSIZE)) == (CFM2_MATCHFONT | CFM2_ADJUSTFONTSIZE) &&
			_iCharRep != pCF->_iCharRep && (dwMask & CFM_SIZE))
		{
			// Check if we need to adjust the font size
			_yHeight = W32->GetPreferredFontHeight(
				(dwMask2 & CFM2_UIFONT) != 0,
				pCF->_iCharRep,
				_iCharRep,
				_yHeight);
		}

		if(dwMask & CFM_FACE)
		{
			_bPitchAndFamily = pCF->_bPitchAndFamily;
			_iFont = pCF->_iFont;
			
			const WCHAR *pch = GetFontName((LONG)_iFont);
			WCHAR ch = pch[0];
			
			if (!fNewCharset && ch == L'\0')
			{
				// API to choose default font								
				BYTE	bDefPitchAndFamily;
				SHORT	iDefFont;
				int		iCharRep = GetLocaleCharRep();
				BYTE	yDefHeight;

				// Get default font name and charset
				bool	fr = W32->GetPreferredFontInfo(
							iCharRep, FALSE, iDefFont, 
							(BYTE&)yDefHeight, bDefPitchAndFamily );
					
				if (fr) 
				{
					_iCharRep = iCharRep;
					_iFont = iDefFont;
						
					if(!(dwMask & CFM_SIZE) || _yHeight < yDefHeight * 20)	// Setup default height if needed.
						_yHeight = yDefHeight * 20;

					_bPitchAndFamily = bDefPitchAndFamily;
				}				
			}
			else if(GetCharFlags(pch, 2) & FFE && !IsFECharRep(_iCharRep))
			{
				// make sure that we dont end up having DBCS facename with Non-FE charset
				QWORD qwFontSig;
				if (GetFontSignatureFromFace(_iFont, &qwFontSig))
				{
					qwFontSig &= FFE ;		// Only interest in FE charset
					if (qwFontSig)
						_iCharRep = GetFirstAvailCharRep(qwFontSig);
				}
			}
#ifdef DEBUG
			_pchFaceName = GetFontName((LONG)_iFont);
#endif
		}

		if(!(dwMask2 & CFM2_CHARFORMAT) && (dwMask & ~CFM_ALL))	// CHARFORMAT2 extensions
		{
			if((dwMask & (CFM_WEIGHT | CFM_BOLD)) == CFM_WEIGHT) 
			{			
				_wWeight		= pCF->_wWeight;
				_dwEffects	   |= CFE_BOLD;			// Set above-average
				if(_wWeight < 551)					//  weights to bold
					_dwEffects &= ~CFE_BOLD;
			}

			if(dwMask & CFM_BACKCOLOR)
				_crBackColor	= pCF->_crBackColor;

			if(dwMask & CFM_LCID)
			{
				_lcid			= pCF->_lcid;
				if(!(dwMask & CFM_CHARSET) && !IsFECharRep(_iCharRep) && PRIMARYLANGID(_lcid))
					_iCharRep	= CharRepFromLID(_lcid);
			}

			if(dwMask & CFM_SPACING)
				_sSpacing		= pCF->_sSpacing;

			if(dwMask & CFM_KERNING)
				_wKerning		= pCF->_wKerning;

			if(dwMask & CFM_STYLE)
				_sStyle			= pCF->_sStyle;

			if(dwMask & CFM_UNDERLINETYPE)
			{
				_bUnderlineType	= pCF->_bUnderlineType;
				if(!(dwMask & CFM_UNDERLINE))		// If CFE_UNDERLINE
				{									//  isn't defined,
					_dwEffects	&= ~CFE_UNDERLINE;	//  set it according to
					if(_bUnderlineType)				//  bUnderlineType
						_dwEffects |= CFE_UNDERLINE;
				}
				else
					_bUnderlineColor = pCF->_bUnderlineColor;
			}

			if((dwMask & CFM_ANIMATION) && pCF->_bAnimation <= 18)
				_bAnimation		= pCF->_bAnimation;

			if(dwMask & CFM_REVAUTHOR)
				_bRevAuthor		= pCF->_bRevAuthor;
    	}
	}

	// RichEdit currently doesn't do a good job of assigning LangIDs to text,
	// primarily assigning them only on initialization, when the keyboard
	// changes, and when LangIDs are read in from RTF. The following weak
	// LangID recognizer uses the facts that most languages are associated
	// with a single CharRep and that the keyboard provides a good hint as
	// to which	language. The else if could be expanded to include more
	// CharReps than Arabic, Hebrew, and Ansi, e.g., CJK. More generally,
	// LangID recognition requires natural language processing beyond the
	// choice of the writing system, which is given in RichEdit by _iCharRep.
	if(CharRepFromLID(_lcid) != _iCharRep)
	{
		LONG lcid = (WORD)W32->GetPreferredKbd(_iCharRep);
		if(lcid)
			_lcid = lcid;					// Use keyboard lang for _iCharRep

		else if(_iCharRep == ANSI_INDEX)	// No ANSI_CHARSET keyboard
			_lcid = MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT);

		else if(IsBiDiCharRep(_iCharRep))	// Use default langs for BiDi
			_lcid = MAKELANGID(_iCharRep == HEBREW_INDEX ? LANG_HEBREW : LANG_ARABIC,
							   SUBLANG_DEFAULT);
	}

	if(dwMask2 & CFM2_SCRIPT)
		_wScript = pCF->_wScript;

	return NOERROR;
}

/*
 *	CCharFormat::ApplyDefaultStyle(Style)
 *
 *	@mfunc	
 *		Set default style properties in this CCharFormat
 */
void CCharFormat::ApplyDefaultStyle (
	LONG Style)		//@parm Style to use
{
	Assert(IsKnownStyle(Style));

	if(IsHeadingStyle(Style))
	{
		LONG i = -Style + STYLE_HEADING_1;
		_dwEffects = (_dwEffects & 0xFFFFFF00) | g_Style[i].bEffects;
		_wWeight = (_dwEffects & CFE_BOLD) ? FW_BOLD : FW_NORMAL;

		if(g_Style[i].bHeight)
			_yHeight = g_Style[i].bHeight * 20;

		QWORD qwFontSig;
		LONG  iFont = _iFont;			// Save _iFont in case Arial doesn't
		_iFont = IFONT_ARIAL;			//  support _bCharSet

		GetFontSignatureFromFace(_iFont, &qwFontSig);
		if(FontSigFromCharRep(_iCharRep) & qwFontSig)
			_bPitchAndFamily = FF_SWISS;// Arial supports _iCharRep
		else
			_iFont = iFont;				// Restore iFont
#ifdef DEBUG
		_pchFaceName = GetFontName((LONG)_iFont);
#endif
	}
}

BOOL CCharFormat::CanKernWith(const CCharFormat *pCF) const
{
	const DWORD dwMask = CFE_ITALIC;

	return this == pCF ||
			(!((_dwEffects ^ pCF->_dwEffects) & dwMask) &&
			_iFont == pCF->_iFont &&
			_yHeight == pCF->_yHeight &&
			_wWeight == pCF->_wWeight);
}

/*
 *	CCharFormat::Compare(pCF)
 *
 *	@mfunc
 *		Compare this CCharFormat to *<p pCF>
 *
 *	@rdesc
 *		TRUE if they are the same not including _cRefs
 */
BOOL CCharFormat::Compare (
	const CCharFormat *pCF) const	//@parm	CCharFormat to compare this
{									//  CCharFormat to
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormat::Compare");

	return !CompareMemory(this, pCF, sizeof(CCharFormat));
}

/*
 *	CCharFormat::Delta(pCF, fCHARFORMAT)
 *
 *	@mfunc
 *		Calculate dwMask for differences between this CCharformat and
 *		*<p pCF>
 *
 *	@rdesc
 *		return dwMask of differences (1 bit means a difference)
 */
DWORD CCharFormat::Delta (
	CCharFormat *pCF,		//@parm	CCharFormat to compare this one to
	BOOL fCHARFORMAT) const	//@parm Only compare CHARFORMAT members
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormat::Delta");
												// Collect bits for properties
	LONG dw = _dwEffects ^ pCF->_dwEffects;		//  that change. Note: auto
												//  color is handled since
	if(_yHeight		!= pCF->_yHeight)			//  CFM_COLOR = CFE_AUTOCOLOR
		dw |= CFM_SIZE;

	if(_yOffset		!= pCF->_yOffset)
		dw |= CFM_OFFSET;

	if(_crTextColor	!= pCF->_crTextColor)
		dw |= CFM_COLOR;

	if(_iCharRep	!= pCF->_iCharRep)
		dw |= CFM_CHARSET;

	if(_iFont		!= pCF->_iFont)
		dw |= CFM_FACE;

	if(fCHARFORMAT)
		return dw;							// Done with CHARFORMAT stuff

	if(_crBackColor	!= pCF->_crBackColor)	// CHARFORMAT2 stuff
		dw |= CFM_BACKCOLOR;

	if(_wKerning	!= pCF->_wKerning)
		dw |= CFM_KERNING;

	if(_lcid		!= pCF->_lcid)
		dw |= CFM_LCID;

	if(_wWeight		!= pCF->_wWeight)
		dw |= CFM_WEIGHT;

	if(_sSpacing	!= pCF->_sSpacing)
		dw |= CFM_SPACING;

	if(_sStyle		!= pCF->_sStyle)
		dw |= CFM_STYLE;

	if(_bUnderlineType != pCF->_bUnderlineType)
		dw |= CFM_UNDERLINETYPE;

	if(_bAnimation	!= pCF->_bAnimation)
		dw |= CFM_ANIMATION;

	if(_bRevAuthor	!= pCF->_bRevAuthor)
		dw |= CFM_REVAUTHOR;

	return dw;
}

/*
 *	CCharFormat::fSetStyle(dwMask)
 *
 *	@mfunc
 *		return TRUE iff pCF specifies that the style should be set. See
 *		code for list of conditions for this to be true
 *
 *	@rdesc
 *		TRUE iff pCF specifies that the style _sStyle should be set
 */
BOOL CCharFormat::fSetStyle(DWORD dwMask, DWORD dwMask2) const
{
	return	dwMask != CFM_ALL2		&&
			dwMask &  CFM_STYLE		&&
			!(dwMask2 & CFM2_CHARFORMAT) &&
			IsKnownStyle(_sStyle);
}

/*
 *	CCharFormat::Get(pCF, CodePage)
 *
 *	@mfunc
 *		Copy this CCharFormat to the CHARFORMAT or CHARFORMAT2 *<p pCF>
 */
void CCharFormat::Get (
	CHARFORMAT2 *pCF2,		//@parm CHARFORMAT to copy this CCharFormat to
	UINT CodePage) const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormat::Get");

	pCF2->dwMask		= CFM_ALL;				// Use CHARFORMAT
	pCF2->dwEffects		= _dwEffects;
	pCF2->yHeight		= _yHeight;
	pCF2->yOffset		= _yOffset;
	pCF2->crTextColor	= _crTextColor;
	pCF2->bCharSet		= CharSetFromCharRep(_iCharRep);
	pCF2->bPitchAndFamily = _bPitchAndFamily;

	UINT cb = pCF2->cbSize;
	const WCHAR *pch = GetFontName((LONG)_iFont);

	AssertSz((CodePage != 1200) ^ IsValidCharFormatW(pCF2),
		"CCharFormat::Get: wrong codepage for CHARFORMAT");
	
	if(CodePage != 1200)
	{
		if(_dwEffects & CFE_FACENAMEISDBCS)
		{
			// The face name is actually DBCS stuffed into the unicode
			// buffer, so simply un-stuff this DBCS into the ANSI string
			char *pachDst = (char *)pCF2->szFaceName;

			while(*pch)
				*pachDst++ = *pch++;

			*pachDst = 0;
		}
		else
		{
			MbcsFromUnicode((char *)pCF2->szFaceName, LF_FACESIZE,
							pch, -1, CodePage, UN_NOOBJECTS);
		}
	}
	else
		wcscpy(pCF2->szFaceName, pch);
	
	if (cb == sizeof(CHARFORMATW) || cb == sizeof(CHARFORMATA))	// We're done
		return;

	char *pvoid = (char *)&pCF2->wWeight;
	if(pCF2->cbSize == sizeof(CHARFORMAT2A))
		pvoid -= sizeof(CHARFORMAT2W) - sizeof(CHARFORMAT2A);
	else
		Assert(pCF2->cbSize == sizeof(CHARFORMAT2));// Better be a CHARFORMAT2

	pCF2->dwMask = CFM_ALL2;
	CopyMemory(pvoid, &_wWeight, 3*sizeof(DWORD));
	CopyMemory(pvoid + 4*sizeof(DWORD),  &_sStyle,  2*sizeof(DWORD));
	*(DWORD *)(pvoid + 3*sizeof(DWORD)) = 0;
}

/*
 *	CCharFormat::InitDefault(hfont)
 *
 *	@mfunc	
 *		Initialize this CCharFormat with information coming from the font
 *		<p hfont>
 *	
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : E_FAIL
 */
HRESULT CCharFormat::InitDefault (
	HFONT hfont)		//@parm Handle to font info to use
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormat::InitDefault");

	LOGFONT lf;
	BOOL	fUseStockFont = hfont == NULL;

	ZeroMemory(this, sizeof(CCharFormat));

	// If hfont isn't defined, get LOGFONT for default font
	if(!hfont)
		hfont = W32->GetSystemFont();

	// Get LOGFONT for passed hfont
	if(!W32->GetObject(hfont, sizeof(LOGFONT), &lf))
		return E_FAIL;

	_yHeight = (lf.lfHeight * LY_PER_INCH) / W32->GetYPerInchScreenDC();
	if(_yHeight <= 0)
		_yHeight = -_yHeight;
	else if (fUseStockFont)		// This is Cell Height for System Font case
		_yHeight -= (W32->GetSysFontLeading() * LY_PER_INCH) / W32->GetYPerInchScreenDC();
	else
	{
		// This is Cell Height, need to get the character height by subtracting 
		// the tm.tmInternalLeading.
		CLock		lock;
		HDC			hdc = W32->GetScreenDC();
		HFONT		hOldFont = SelectFont(hdc, hfont);
		TEXTMETRIC	tm;

		if(hOldFont)
		{
			if(GetTextMetrics(hdc, &tm))			
    			_yHeight -= (tm.tmInternalLeading * LY_PER_INCH) / W32->GetYPerInchScreenDC();

			SelectFont(hdc, hOldFont); 
		}
	}

	_dwEffects = (CFM_EFFECTS | CFE_AUTOBACKCOLOR) & ~(CFE_PROTECTED | CFE_LINK);

	if(lf.lfWeight < FW_BOLD)
		_dwEffects &= ~CFE_BOLD;

	if(!lf.lfItalic)
		_dwEffects &= ~CFE_ITALIC;

	if(!lf.lfUnderline)
		_dwEffects &= ~CFE_UNDERLINE;

	if(!lf.lfStrikeOut)
		_dwEffects &= ~CFE_STRIKEOUT;

	_wWeight		= (WORD)lf.lfWeight;
	_lcid			= GetSystemDefaultLCID();
	_iCharRep		= CharRepFromCharSet(lf.lfCharSet);
	_bPitchAndFamily= lf.lfPitchAndFamily;
	_iFont			= GetFontNameIndex(lf.lfFaceName);
	_bUnderlineType	= CFU_UNDERLINE;			// Default solid underlines
												// Are gated by CFE_UNDERLINE
	// Qualify the charformat produced by incoming hfont before exit.
	// We did this to make sure that the charformat we derived from hfont is usable
	// since caller can send us bad font like given facename can't handle given charset.
	if (!fUseStockFont)
	{
		QWORD qwFontSig;
		if (GetFontSignatureFromFace(_iFont, &qwFontSig) &&
			!(FontSigFromCharRep(_iCharRep) & qwFontSig))
			_iCharRep = GetFirstAvailCharRep(qwFontSig);
		_bQuality = lf.lfQuality;
	}

	// Initialize to no temp. display attr.
	_sTmpDisplayAttrIdx = -1;

#ifdef DEBUG
	_pchFaceName = GetFontName((LONG)_iFont);
#endif
	return NOERROR;
}

/*
 *	CCharFormat::Set(pCF, CodePage)
 *
 *	@mfunc
 *		Copy the CHARFORMAT or CHARFORMAT2 *<p pCF> to this CCharFormat 
 */
void CCharFormat::Set (
	const CHARFORMAT2 *pCF2, 	//@parm	CHARFORMAT to copy to this CCharFormat
	UINT CodePage)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormat::Set");
	
	_dwEffects			= pCF2->dwEffects;
	_iCharRep			= CharRepFromCharSet(pCF2->bCharSet);
	_bPitchAndFamily	= pCF2->bPitchAndFamily;
	if(pCF2->dwMask & CFM_FACE)
	{
		AssertSz((CodePage != 1200) ^ IsValidCharFormatW(pCF2),
			"CCharFormat::Set: wrong codepage for CHARFORMAT");

		if(CodePage != 1200)
		{
			WCHAR sz[LF_FACESIZE + 1];
			UnicodeFromMbcs(sz, LF_FACESIZE, (char *)pCF2->szFaceName, LF_FACESIZE,
							CodePage);
			_iFont		= GetFontNameIndex(sz);
		}
		else
			_iFont		= GetFontNameIndex(pCF2->szFaceName);
	}
	_yHeight			= Get16BitTwips(pCF2->yHeight);
	_yOffset			= Get16BitTwips(pCF2->yOffset);
	_crTextColor		= pCF2->crTextColor;
	

	UINT cb = pCF2->cbSize;
	if(cb == sizeof(CHARFORMATW) || cb == sizeof(CHARFORMATA))
	{
		_dwEffects |= CFE_AUTOBACKCOLOR;
		_bUnderlineType = CFU_UNDERLINE;
		ZeroMemory((LPBYTE)&_wWeight,
			sizeof(CCharFormat) - offsetof(CCharFormat, _wWeight));
#ifdef DEBUG
		_pchFaceName = GetFontName((LONG)_iFont);
#endif
		return;
	}

	char *pvoid = (char *)&pCF2->wWeight;
	if(pCF2->cbSize == sizeof(CHARFORMAT2A))
		pvoid -= sizeof(CHARFORMAT2W) - sizeof(CHARFORMAT2A);
	else
		Assert(pCF2->cbSize == sizeof(CHARFORMAT2));// Better be a CHARFORMAT2

	CopyMemory(&_wWeight, pvoid, 3*sizeof(DWORD));
	CopyMemory(&_sStyle,  pvoid + 4*sizeof(DWORD),  2*sizeof(DWORD));

#ifdef DEBUG
	_pchFaceName = GetFontName((LONG)_iFont);
#endif
}


//------------------------- CParaFormat Class -----------------------------------

/*
 *	CParaFormat::AddTab(tbPos, tbAln, tbLdr, prgxTabs)
 *
 *	@mfunc
 *		Add tabstop at position <p tbPos>, alignment type <p tbAln>, and
 *		leader style <p tbLdr>
 *
 *	@rdesc
 *		(success) ? NOERROR : S_FALSE
 *
 *	@devnote
 *		Tab struct that overlays LONG in internal _rgxTabs is
 *
 *			DWORD	tabPos : 24;
 *			DWORD	tabType : 4;
 *			DWORD	tabLeader : 4;
 */
HRESULT CParaFormat::AddTab (
	LONG	tbPos,		//@parm New tab position
	LONG	tbAln,		//@parm New tab alignment type
	LONG	tbLdr,		//@parm New tab leader style
	LONG *	prgxTabs)	//@parm Where the tabs are
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::AddTab");

	if (IsTableRowDelimiter() ||
		(DWORD)tbAln > tomAlignBar ||			// Validate arguments
		(DWORD)tbLdr > tomEquals ||				// Comparing DWORDs causes
		(DWORD)tbPos > 0xffffff || !tbPos)		//  negative values to be
	{											//  treated as invalid
		return E_INVALIDARG;
	}

	LONG iTab;
	LONG tbValue = tbPos + (tbAln << 24) + (tbLdr << 28);

	for(iTab = 0; iTab < _bTabCount &&			// Determine where to
		tbPos > GetTabPos(prgxTabs[iTab]); 		//  insert new tabstop
		iTab++) ;

	if(iTab >= MAX_TAB_STOPS)
		return S_FALSE;

	LONG tbPosCurrent = GetTabPos(prgxTabs[iTab]);
	if(iTab == _bTabCount || tbPosCurrent != tbPos)
	{
		if(_bTabCount >= MAX_TAB_STOPS)
			return S_FALSE;

		MoveMemory(&prgxTabs[iTab + 1],			// Shift array down
			&prgxTabs[iTab],					//  (unless iTab = Count)
			(_bTabCount - iTab)*sizeof(LONG));

		_bTabCount++;							// Increment tab count
	}
	prgxTabs[iTab] = tbValue;
	return NOERROR;
}

/*
 *	CParaFormat::Apply(pPF, dwMask, dwMask2)
 *
 *	@mfunc
 *		Apply *<p pPF> to this CParaFormat as specified by nonzero bits in
 *		<p pPF>->dwMask
 *
 *	@rdesc
 *		HRESULT = E_INVALIDARG or NOERROR
 */
HRESULT CParaFormat::Apply (
	const CParaFormat *pPF,	//@parm CParaFormat to apply to this PF
	DWORD	dwMask,			//@parm mask to use
	DWORD	dwMask2)		//@parm Mask for additional internal parms
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::Apply");

	const DWORD dwMaskApply	= dwMask;
	BOOL		fPF = dwMask2 & PFM2_PARAFORMAT;
	WORD		wEffectMask;

	if(dwMaskApply & PFM_NUMBERING)
		_wNumbering = pPF->_wNumbering;

	if(dwMaskApply & PFM_OFFSET)
	{
		if (!IsValidTwip(pPF->_dxOffset))
			return E_INVALIDARG;
		_dxOffset = pPF->_dxOffset;
	}

	if(dwMaskApply & PFM_STARTINDENT)
	{
		if (!IsValidTwip(pPF->_dxStartIndent))
			return E_INVALIDARG;

		_dxStartIndent = pPF->_dxStartIndent;
	}
	else if(dwMaskApply & PFM_OFFSETINDENT)
	{
		if (!IsValidTwip(pPF->_dxStartIndent))
			return E_INVALIDARG;

		// bug fix #5761
		LONG dx = max(0, _dxStartIndent + pPF->_dxStartIndent);

		// Disallow shifts that move start of first or subsequent lines left of left margin.
		// Normally we just make indent zero in paraformat check below, 
		//	but in the case of bullet we want some space left.
		
		if(!_wNumbering || dx + _dxOffset >= 0)
			_dxStartIndent = dx;
	}

	if(dwMaskApply & PFM_RIGHTINDENT)
	{
		if (!IsValidTwip(pPF->_dxRightIndent))
			return E_INVALIDARG;

		_dxRightIndent = pPF->_dxRightIndent;
	}

	if(dwMaskApply & PFM_ALIGNMENT)
	{
		if(!fPF && !IN_RANGE(PFA_LEFT, pPF->_bAlignment, PFA_SNAP_GRID))
		{
			TRACEERRORSZ("CParaFormat::Apply: invalid Alignment ignored");
			return E_INVALIDARG;
		}
		if(pPF->_bAlignment <= PFA_SNAP_GRID)
			_bAlignment = pPF->_bAlignment;
	}

	// Reset effect bits to be modified and OR in supplied values
	wEffectMask	= (WORD)((dwMaskApply >> 16) |
						 (dwMask2 & PFM2_TABLEROWSHIFTED));
	_wEffects &= ~wEffectMask;				
	_wEffects |= pPF->_wEffects & wEffectMask;

	if(dwMaskApply & PFM_TABSTOPS)
	{
		LONG cmax  = IsTableRowDelimiter() ? MAX_TABLE_CELLS :	MAX_TAB_STOPS;
		_bTabCount = (BYTE)min(pPF->_bTabCount, cmax);
		_bTabCount = (BYTE)max(_bTabCount, 0);
		_iTabs	   = pPF->_iTabs;
		AssertSz(!_bTabCount || _iTabs >= 0,
			"CParaFormat::Apply: illegal _iTabs value");
	}

	if ((dwMaskApply & PFM_RTLPARA) && !(dwMaskApply & PFM_ALIGNMENT) &&
		_bAlignment != PFA_CENTER)
	{
		_bAlignment = IsRtlPara() ? PFA_RIGHT : PFA_LEFT;
	}

	// PARAFORMAT check
	if(fPF)
	{
		if(dwMaskApply & (PFM_STARTINDENT | PFM_OFFSET))
		{
			if(_dxStartIndent < 0)				// Don't let indent go
				_dxStartIndent = 0;				//  negative

			if(_dxStartIndent + _dxOffset < 0)	// Don't let indent +
				_dxOffset = -_dxStartIndent;	//  offset go negative
		}
		return NOERROR;							// Nothing more for
	}											//  PARAFORMAT

	// PARAFORMAT2 extensions
	if(dwMaskApply & PFM_SPACEBEFORE)
	{
		_dySpaceBefore = 0;

		if (pPF->_dySpaceBefore > 0)
			_dySpaceBefore	= pPF->_dySpaceBefore;
	}

	if(dwMaskApply & PFM_SPACEAFTER)
	{
		_dySpaceAfter = 0;

		if (pPF->_dySpaceAfter > 0)
			_dySpaceAfter	= pPF->_dySpaceAfter;
	}

	if(dwMaskApply & PFM_LINESPACING)
	{
		_dyLineSpacing	  = pPF->_dyLineSpacing;
		_bLineSpacingRule = pPF->_bLineSpacingRule;
	}

	if(dwMaskApply & PFM_OUTLINELEVEL)
		_bOutlineLevel	= pPF->_bOutlineLevel;

	if(dwMaskApply & PFM_STYLE)
		HandleStyle(pPF->_sStyle);

	Assert((_bOutlineLevel & 1) ^ IsHeadingStyle(_sStyle));

	if(dwMaskApply & PFM_SHADING)
	{
		_wShadingWeight	= pPF->_wShadingWeight;
		_wShadingStyle	= pPF->_wShadingStyle;
	}

	if(dwMaskApply & PFM_NUMBERINGSTART)
		_wNumberingStart = pPF->_wNumberingStart;

	if(dwMaskApply & PFM_NUMBERINGSTYLE)
		_wNumberingStyle = pPF->_wNumberingStyle;

	if(dwMaskApply & PFM_NUMBERINGTAB)
		_wNumberingTab	= pPF->_wNumberingTab;

	if(dwMaskApply & PFM_BORDER)
	{
		_dwBorderColor	= pPF->_dwBorderColor;
		_wBorders		= pPF->_wBorders;
		_wBorderSpace	= pPF->_wBorderSpace;
		_wBorderWidth	= pPF->_wBorderWidth;
	}

	if(dwMaskApply & PFM_TABLE)
		_bTableLevel	= pPF->_bTableLevel;


#ifdef DEBUG
	ValidateTabs();
	AssertSz((!(_wEffects & PFE_TABLE) || _bTableLevel) && _bTableLevel >= 0,
		"CParaFormat::Apply: invalid table level");
#endif // DEBUG

	return NOERROR;
}

/*
 *	CParaFormat::ApplyDefaultStyle(Style)
 *
 *	@mfunc	
 *		Copy default properties for Style
 */
void CParaFormat::ApplyDefaultStyle (
	LONG Style)		//@parm Style to apply
{
	Assert(IsKnownStyle(Style));

	if(IsHeadingStyle(Style))				// Set Style's dySpaceBefore,
	{										//  dySpaceAfter (in twips)
		_dySpaceBefore = 12*20;				//  (same for all headings)
		_dySpaceAfter  =  3*20;
		_wNumbering	   = 0;					// No numbering
	}
}

/*
 *	CParaFormat::DeleteTab(tbPos)
 *
 *	@mfunc
 *		Delete tabstop at position <p tbPos>
 *
 *	@rdesc
 *		(success) ? NOERROR : S_FALSE
 */
HRESULT CParaFormat::DeleteTab (
	LONG	tbPos,			//@parm Tab position to delete
	LONG *	prgxTabs)		//@parm Tab array to use
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::DeleteTab");

	if(tbPos <= 0 || IsTableRowDelimiter())
		return E_INVALIDARG;

	LONG Count	= _bTabCount;
	for(LONG iTab = 0; iTab < Count; iTab++)	// Find tabstop for position
	{
		if(GetTabPos(prgxTabs[iTab]) == tbPos)
		{
			MoveMemory(&prgxTabs[iTab],			// Shift array down
				&prgxTabs[iTab + 1],			//  (unless iTab is last tab)
				(Count - iTab - 1)*sizeof(LONG));
			_bTabCount--;						// Decrement tab count and
			return NOERROR;						//  signal no error
		}
	}
	return S_FALSE;
}

/*
 *	CParaFormat::Delta(pPF, fPARAFORMAT)
 *
 *	@mfunc
 *		return mask of differences between this CParaFormat and *<p pPF>.
 *		1-bits indicate corresponding parameters differ; 0 indicates they
 *		are the same
 *
 *	@rdesc
 *		mask of differences between this CParaFormat and *<p pPF>
 */
DWORD CParaFormat::Delta (
	CParaFormat *pPF,		 		//@parm	CParaFormat to compare this
	BOOL		fPARAFORMAT) const	//		CParaFormat to
{									
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::Delta");

	LONG dwT = 0;								// No differences yet

	if(_wNumbering	  != pPF->_wNumbering)
		dwT |= PFM_NUMBERING;					// _wNumbering values differ

	if(_dxStartIndent != pPF->_dxStartIndent)
		dwT |= PFM_STARTINDENT;					// ...

	if(_dxRightIndent != pPF->_dxRightIndent)
		dwT |= PFM_RIGHTINDENT;

	if(_dxOffset	  != pPF->_dxOffset)
		dwT |= PFM_OFFSET;

	if(_bAlignment	  != pPF->_bAlignment)
		dwT |= PFM_ALIGNMENT;

	AssertSz(pPF->_bTabCount >= 0 && pPF->_bTabCount <= 
			(pPF->IsTableRowDelimiter() ? MAX_TABLE_CELLS : MAX_TAB_STOPS),
		"RTR::GetParaFormat(): illegal tab count");

	if (_bTabCount != pPF->_bTabCount)
		dwT |= PFM_TABSTOPS;
	else if (_bTabCount > 0)
	{
		const LONG	*pTabs1 = GetTabs();
		const LONG	*pTabs2 = pPF->GetTabs();
		LONG cb = _bTabCount * sizeof(LONG);

		if(IsTableRowDelimiter())
			cb *= CELL_EXTRA + 1;
		if (pTabs1 != pTabs2 &&
			(pTabs1 == 0 || pTabs2 == 0 || CompareMemory(pTabs1, pTabs2, cb)))
			dwT |= PFM_TABSTOPS;
	}

	dwT |= (_wEffects ^ pPF->_wEffects) << 16;


	if(!fPARAFORMAT)
	{
		if(_dySpaceBefore	!= pPF->_dySpaceBefore)
			dwT |= PFM_SPACEBEFORE;

		if(_dySpaceAfter	!= pPF->_dySpaceAfter)
			dwT |= PFM_SPACEAFTER;

		if (_dyLineSpacing	!= pPF->_dyLineSpacing	||
		   _bLineSpacingRule!= pPF->_bLineSpacingRule)
		{
			dwT |= PFM_LINESPACING;
		}

		if(_sStyle			!= pPF->_sStyle)
			dwT |= PFM_STYLE;

		if (_wShadingWeight	!= pPF->_wShadingWeight ||
			_wShadingStyle	!= pPF->_wShadingStyle)
		{
			dwT |= PFM_SHADING;
		}

		if(_wNumberingStart	!= pPF->_wNumberingStart)
			dwT |= PFM_NUMBERINGSTART;

		if(_wNumberingStyle	!= pPF->_wNumberingStyle)
			dwT |= PFM_NUMBERINGSTYLE;

		if(_wNumberingTab	!= pPF->_wNumberingTab)
			dwT |= PFM_NUMBERINGTAB;

		if (_wBorders		!= pPF->_wBorders	 ||
			_wBorderWidth	!= pPF->_wBorderWidth ||
			_wBorderSpace	!= pPF->_wBorderSpace ||
			_dwBorderColor	!= pPF->_dwBorderColor)
		{
			dwT |= PFM_BORDER;
		}
		if(_bTableLevel != pPF->_bTableLevel)
			dwT |= PFM_TABLEROWDELIMITER;
	}

	return dwT;
}		

#define PFM_IGNORE	(PFM_OUTLINELEVEL | PFM_COLLAPSED | PFM_BOX | PFM_TABLE | PFM_TABLEROWDELIMITER)

/*
 *	CParaFormat::fSetStyle(dwMask, dwMask2)
 *
 *	@mfunc
 *		Return TRUE iff this PF specifies that the style should be set.
 *		See code for list of conditions for this to be true
 *
 *	@rdesc
 *		TRUE iff pCF specifies that the style _sStyle should be set
 */
BOOL CParaFormat::fSetStyle(
	DWORD	dwMask,			//@parm mask to use
	DWORD	dwMask2) const	//@parm Mask for additional internal parms
{
	return	(dwMask & ~PFM_IGNORE) != (PFM_ALL2 & ~(PFM_TABLE | PFM_TABLEROWDELIMITER)) &&
			!(dwMask2 & (PFM2_PARAFORMAT | PFM2_ALLOWTRDCHANGE))		&&
			dwMask & PFM_STYLE && IsKnownStyle(_sStyle);
}

/*
 *	CParaFormat::Get(pPF2)
 *
 *	@mfunc
 *		Copy this CParaFormat to *<p pPF>
 */
void CParaFormat::Get (
	PARAFORMAT2 *pPF2) const	//@parm	PARAFORMAT2 to copy this CParaFormat to
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::Get");

	LONG cb = pPF2->cbSize;

	pPF2->dwMask = PFM_ALL2;					// Default PARAFORMAT2
	if(cb != sizeof(PARAFORMAT2))				// It isn't
	{
		pPF2->dwMask = PFM_ALL;					// Make it PARAFORMAT
		Assert(cb == sizeof(PARAFORMAT));		// It better be a PARAFORMAT
	}
	CopyMemory(&pPF2->wNumbering, &_wNumbering, (char *)&_bAlignment - (char *)&_wNumbering);
	pPF2->wAlignment = _bAlignment;
	pPF2->cTabCount	= _bTabCount;

	LONG cb1 = _bTabCount*sizeof(LONG);
	if(_bTabCount)
	{
		// Need API for handling table cells. For now, just don't overwrite
		// pPF2->rgxTabs[].
		cb1 = min(cb1, (LONG)MAX_TAB_STOPS*sizeof(LONG));
		AssertSz(_iTabs >= 0,
			"CParaFormat::Get: illegal _iTabs value");
		CopyMemory(pPF2->rgxTabs, GetTabsCache()->Deref(_iTabs), cb1);
	}
	ZeroMemory(pPF2->rgxTabs + _bTabCount, MAX_TAB_STOPS*sizeof(LONG) - cb1);
	CopyMemory(&pPF2->dySpaceBefore, &_dySpaceBefore,
			   cb - offsetof(PARAFORMAT2, dySpaceBefore));
}

/*
 *	CParaFormat::GetRTLRowLength()
 *
 *	@mfunc
 *		Get the length of the current row if this CParaFormat is a table
 *		row delimiter with a PFE_RTLPara effect.
 *
 *	@rdesc
 *		Length of current row if PFE_TABLEROWDELIMITER and PFE_RTLPARA are
 *		on; else 0
 */
LONG CParaFormat::GetRTLRowLength() const
{
	if ((_wEffects & (PFE_TABLEROWDELIMITER | PFE_RTLPARA))
		!= (PFE_TABLEROWDELIMITER | PFE_RTLPARA))
	{
		return 0;							// Not an RTL row
	}

	const CELLPARMS * prgCellParms = GetCellParms();

	for(LONG i = 0, dulRTLRow = 0; i < _bTabCount; i++)
		dulRTLRow += GetCellWidth(prgCellParms[i].uCell);

	return dulRTLRow;
}

/*
 *	CParaFormat::GetTab (iTab, ptbPos, ptbAln, ptbLdr, prgxTabs)
 *
 *	@mfunc
 *		Get tab parameters for the <p iTab> th tab, that is, set *<p ptbPos>,
 *		*<p ptbAln>, and *<p ptbLdr> equal to the <p iTab> th tab's
 *		displacement, alignment type, and leader style, respectively.  The
 *		displacement is given in twips.
 *
 *	@rdesc
 *		HRESULT = (no <p iTab> tab)	? E_INVALIDARG : NOERROR
 */
HRESULT CParaFormat::GetTab (
	long	iTab,				//@parm Index of tab to retrieve info for
	long *	ptbPos,				//@parm Out parm to receive tab displacement
	long *	ptbAln,				//@parm Out parm to receive tab alignment type
	long *	ptbLdr,				//@parm Out parm to receive tab leader style
	const LONG *prgxTabs) const	//@parm Tab array
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEEXTERN, "CParaFormat::GetTab");

	AssertSz(ptbPos && ptbAln && ptbLdr,
		"CParaFormat::GetTab: illegal arguments");

	if(IsTableRowDelimiter())
		return E_INVALIDARG;

	if(iTab < 0)									// Get tab previous to, at,
	{												//  or subsequent to the
		if(iTab < tomTabBack)						//  position *ptbPos
			return E_INVALIDARG;

		LONG i;
		LONG tbPos = *ptbPos;
		LONG tbPosi;

		*ptbPos = 0;								// Default tab not found
		for(i = 0; i < _bTabCount &&				// Find *ptbPos
			tbPos > GetTabPos(prgxTabs[i]); 
			i++) ;

		tbPosi = GetTabPos(prgxTabs[i]);			// tbPos <= tbPosi
		if(iTab == tomTabBack)						// Get tab info for tab
			i--;									//  previous to tbPos
		else if(iTab == tomTabNext)					// Get tab info for tab
		{											//  following tbPos
			if(tbPos == tbPosi)
				i++;
		}
		else if(tbPos != tbPosi)					// tomTabHere
			return S_FALSE;

		iTab = i;		
	}
	if((DWORD)iTab >= (DWORD)_bTabCount)			// DWORD cast also
		return E_INVALIDARG;						//  catches values < 0

	iTab = prgxTabs[iTab];
	*ptbPos = GetTabPos(iTab);
	*ptbAln = GetTabAlign(iTab);
	*ptbLdr = GetTabLdr(iTab);
	return NOERROR;
}

/*
 *	CParaFormat::GetTabs ()
 *
 *	@mfunc
 *		Get ptr to tab array.  Use GetTabPos(), GetTabAlign(), and
 *		GetTabLdr() to access the tab position, alignment, and leader
 *		type, respectively.
 *
 *	@rdesc
 *		Ptr to tab array.
 */
const LONG * CParaFormat::GetTabs () const
{
	return GetTabsCache()->Deref(_iTabs);
}

/*
 *	CParaFormat::HandleStyle(Style)
 *
 *	@func
 *		If Style is a promote/demote command, i.e., if abs((char)Style)
 *			<= # heading styles - 1, add (char)Style to	sStyle (if heading)
 *			and to bOutlineLevel (subject to defined max and min values);
 *		else sStyle = Style.
 *
 *	@rdesc
 *		return TRUE iff sStyle or bOutlineLevel changed
 *
 *	@devnote
 *		Heading styles are -2 (heading 1) through -10 (heading 9), which
 *		with TOM and WOM. Heading outline levels are 0, 2,..., 16,
 *		corresponding to headings 1 through 9 (NHSTYLES), respectively,
 *		while text that follows has outline levels 1, 3,..., 17.  This value
 *		is used for indentation. Collapsed text has the PFE_COLLAPSED bit set.
 */
BOOL CParaFormat::HandleStyle(
	LONG Style)		//@parm Style, promote/demote code, or collapse-level code
{
	if(IsStyleCommand(Style))					// Set collapse level
	{											
		WORD wEffectsSave = _wEffects;			

		Style = (char)Style;					// Sign extend low byte
		if(IN_RANGE(1, Style, NHSTYLES))
		{
			_wEffects &= ~PFE_COLLAPSED;
			if((_bOutlineLevel & 1) || _bOutlineLevel > 2*(Style - 1))
				_wEffects |= PFE_COLLAPSED;		// Collapse nonheadings and
		}										//  higher numbered headings
		else if(Style == -1)
			_wEffects &= ~PFE_COLLAPSED;		// Expand all

		return _wEffects != wEffectsSave;		// Return whether something
	}											//  changed

	// Ordinary Style specification
	BYTE bLevel = _bOutlineLevel;
	_bOutlineLevel |= 1;						// Default not a heading
	if(IsHeadingStyle(Style))					// Headings have levels
	{											//  0, 2,..., 16, while the
		_bOutlineLevel = -2*(Style				//  text that follows has
						 - STYLE_HEADING_1);	//  1, 3,..., 17.
	}
	if(_sStyle == Style && bLevel == _bOutlineLevel)
		return FALSE;							// No change

	_sStyle = (SHORT)Style;						
	return TRUE;
}

/*
 *	CParaFormat::InitDefault(wDefEffects)
 *
 *	@mfunc
 *		Initialize this CParaFormat with default paragraph formatting
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : E_FAIL
 */
HRESULT CParaFormat::InitDefault(
	WORD wDefEffects)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::InitDefault");
	
	ZeroMemory(this, sizeof(CParaFormat));
	_bAlignment		= PFA_LEFT;
	_sStyle			= STYLE_NORMAL;			// Default style
	_wEffects		= wDefEffects;
	_bOutlineLevel	= 1;					// Default highest text outline
	_iTabs			= -1;					//  level
											
#if lDefaultTab <= 0
#error "default tab (lDefaultTab) must be > 0"
#endif

	return NOERROR;
}

/*
 *	CParaFormat::NumToStr(pch, n)
 *
 *	@mfunc	
 *		Convert the list number n to a string taking into consideration
 *		CParaFormat::wNumbering, wNumberingStart, and wNumberingStyle
 *	
 *	@rdesc
 *		cch of string converted
 */
LONG CParaFormat::NumToStr(
	TCHAR *	pch,				//@parm Target string
	LONG	n,					//@parm Number + 1 to convert
	DWORD   grf) const			//@parm Collection of flags
{
	if(IsNumberSuppressed())
	{
		*pch = 0;
		return 0;								// Number/bullet suppressed
	}

	if(!n)										// Bullet of some kind
	{											// CParaFormat::wNumbering
		*pch++ = (_wNumbering > ' ')			//  values > ' ' are Unicode
			   ? _wNumbering : 0x00B7;			//  bullets. Else use bullet
		return 1;								//  in symbol font
	}

	// Numbering of some kind
	//							 i  ii  iii  iv v  vi  vii  viii   ix
	const BYTE RomanCode[]	  = {1, 5, 0x15, 9, 2, 6, 0x16, 0x56, 0xd};
	const char RomanLetter[] = "ivxlcdmno";
	BOOL		fRtlPara = IsRtlPara() && !(grf & fRtfWrite);
	LONG		RomanOffset = 0;
	LONG		cch	= 0;						// No chars yet
	WCHAR		ch	= fRtlPara && (grf & fIndicDigits) ? 0x0660 : '0';	
												// Default char code offset
	LONG		d	= 1;						// Divisor
	LONG		r	= 10;						// Default radix 
	LONG   		quot, rem;						// ldiv result
	LONG		Style = (_wNumberingStyle << 8) & 0xF0000;

	n--;										// Convert to number offset
	if(Style == tomListParentheses ||			// Numbering like: (x)
	   fRtlPara && Style == 0)					// or 1) in bidi text.
	{										
		cch = 1;								// Store leading lparen
		*pch++ = '(';
	}
	else if (Style == tomListPeriod && fRtlPara)
	{
		cch = 1;
		*pch++ = '.';
		Style = tomListPlain;
	}

	if(_wNumbering == tomListNumberAsSequence)
		ch = _wNumberingStart;					// Needs generalizations, e.g.,
												//  appropriate radix
	else
	{
		n += _wNumberingStart;
		if(IN_RANGE(tomListNumberAsLCLetter, _wNumbering, tomListNumberAsUCLetter))
		{
			ch = (_wNumbering == tomListNumberAsLCLetter) ? 'a' : 'A';
			if(_wNumberingStart >= 1)
				n--;
			r = 26;								// LC or UC alphabetic number
		}										// Radix 26
	}

	while(d < n)
	{
		d *= r;									// d = smallest power of r > n
		RomanOffset += 2;
	}
	if(n && d > n)
	{
		d /= r;
		RomanOffset -= 2;
	}

	while(d)
	{
		quot = n / d;
		rem = n % d;
		if(IN_RANGE(tomListNumberAsLCRoman, _wNumbering, tomListNumberAsUCRoman))
		{
			if(quot)
			{
				n = RomanCode[quot - 1];
				while(n)
				{
					ch = RomanLetter[(n & 3) + RomanOffset - 1];
					if(_wNumbering == tomListNumberAsUCRoman)
						ch &= 0x5F;
					*pch++ = ch;
					n >>= 2;
					cch++;
				}
			}
			RomanOffset -= 2;
		}
		else
		{
			n = quot + ch;
			if(r == 26 && d > 1)				// If alphabetic higher-order
				n--;							//  digit, base it on 'a' or 'A'
			*pch++ = (WORD)n;					// Store digit
			cch++;
		}
		n = rem;								// Setup remainder
		d /= r;
	}
	if (Style != tomListPlain &&				// Trailing text
		(!fRtlPara || Style))
	{											// We only do rparen or period
		*pch++ = (Style == tomListPeriod) ? '.' : ')';

		cch++;
	}
	
	*pch = 0;									// Null terminate for RTF writer
	return cch;
}

/*
 *	CParaFormat::Set(pPF2)
 *
 *	@mfunc
 *		Copy PARAFORMAT or PARAFORMAT2 *<p pPF> to this CParaFormat 
 */
void CParaFormat::Set (
	const PARAFORMAT2 *pPF2) 	//@parm	PARAFORMAT to copy to this CParaFormat
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::Set");

	CopyMemory(&_wNumbering, &pPF2->wNumbering,
			   (char *)&_bAlignment - (char *)&_wNumbering);
	_bAlignment = (BYTE)pPF2->wAlignment;

	_iTabs = -1;
	_bTabCount = 0;
	_wEffects &= ~PFE_TABLEROWDELIMITER;

	if((pPF2->dwMask & PFM_TABSTOPS) && pPF2->cTabCount)
	{
		LONG cTab = min(pPF2->cTabCount, MAX_TAB_STOPS);
		if (pPF2->dwMask   & PFM_TABLEROWDELIMITER &&
			pPF2->wEffects & PFE_TABLEROWDELIMITER)
		{
			// TODO: create an API for setting cell info
		}
		else
		{
			_bTabCount = cTab;
			_iTabs = GetTabsCache()->Cache(pPF2->rgxTabs, cTab);
		}
	}

	if(pPF2->dwMask & ~PFM_ALL)
	{
		Assert(pPF2->cbSize == sizeof(PARAFORMAT2));

		CopyMemory(&_dySpaceBefore, &pPF2->dySpaceBefore,
			sizeof(PARAFORMAT2) - offsetof(PARAFORMAT2, dySpaceBefore));
	}

#ifdef DEBUG
	ValidateTabs();
#endif // DEBUG
}

/*
 *	CParaFormat::UpdateNumber(n, pPF)
 *
 *	@mfunc
 *		Return new value of number for paragraph described by this PF
 *		following a paragraph described by pPF
 *
 *	@rdesc
 *		New number for paragraph described by this PF
 */
LONG CParaFormat::UpdateNumber (
	LONG  n,						//@parm Current value of number
	const CParaFormat *pPF) const	//@parm Previous CParaFormat
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::UpdateNumber");

	if(!IsListNumbered())			
		return 0;						// No numbering

	if(IsNumberSuppressed())
		return n;						// Number is suppressed, so no change

	if (!pPF || (pPF->_wEffects & PFE_TABLEROWDELIMITER) ||
		_wNumbering != pPF->_wNumbering ||
		(_wNumberingStyle & PFNS_NEWNUMBER) ||
		(_wNumberingStyle != pPF->_wNumberingStyle && !pPF->IsNumberSuppressed()) ||
		_wNumberingStart != pPF->_wNumberingStart)
	{									// Numbering type or style
		return 1;						//  changed, so start over
	}
	return n + 1;						// Same kind of numbering,
}

#ifdef DEBUG
/*
 *	CParaFormat::ValidateTabs()
 *
 *	@mfunc
 *		Makes sure that a set of tabs would make sense for a non-table
 *		paragraph. Is called in places where we have set the tabs.
 *
 *	@rdesc
 *		None.
 */
void CParaFormat::ValidateTabs()
{
	if (_wEffects & PFE_TABLE)
	{
		// It would be nice to assert something reasonable here. However, the
		// rtf reader insists on setting things inconsistenly and I don't
		// have time at the moment to figure out why. (a-rsail)
		//	AssertSz((_bTabCount != 0),
		//	"CParaFormat::ValidateTabs: table with invalid tab count ");
		
		return;
	}

	// Non-table case.

	// It would be nice to assert on the consistency between these _bTabCount and _iTabs
	// but rtf reader has troubles with this. 
	//	AssertSz(((_bTabCount != 0) && (-1 != _iTabs)) || ((-1 == _iTabs) && (0 == _bTabCount)), 
	//	"CParaFormat::ValidateTabs: tab count and default tab index inconsistent");

	if (-1 == _iTabs)
	{
		// No tabs to validate so we are done.
		return;
	}

	const LONG *prgtabs = GetTabs();

	AssertSz(prgtabs != NULL, "CParaFormat::ValidateTabs: missing tab table");

	for (int i = 0; i < _bTabCount; i++)
	{
		AssertSz(GetTabAlign(prgtabs[i]) <= tomAlignBar,
			"CParaFormat::ValidateTabs: Invalid tab being set");
	}
}
#endif // DEBUG

/*
 *	CELLPARMS::ICellFromUCell(prgCell, dul, cCell)
 *
 *	@mfunc
 *		Return iCell such that SUM(CellWidths[iCell]) == dul. Return -1 if
 *		no dul is found in prgCell
 *
 *	@rdesc
 *		iCell such that SUM(CellWidths[iCell]) == dul
 */
LONG CELLPARMS::ICellFromUCell(
	LONG dul,					//@parm Logical x offset of cell right border
	LONG cCell) const			//@parm Count of cells in array
{
	const CELLPARMS *prgCell = this;
	LONG x = 0;

	for(LONG i = 0; i < cCell; i++)
	{
		x += GetCellWidth(prgCell[i].uCell);
		if(x == dul)
			return i;
	}
	return -1;
}


//------------------------- Helper Functions -----------------------------------

// Defines and fixed font size details for increasing/decreasing font size
#define PWD_FONTSIZEPOINTMIN    1
// The following corresponds to the max signed 2-byte TWIP value, (32760)
#define PWD_FONTSIZEPOINTMAX    1638    

typedef struct tagfsFixup
{
    BYTE EndValue;
    BYTE Delta;
}
FSFIXUP;

const FSFIXUP fsFixups[] =
{
    12, 1,
    28, 2,
    36, 0,
    48, 0,
    72, 0,
    80, 0,
  	 0, 10			// EndValue = 0 case is treated as "infinite"
};

#define PWD_FONTSIZEMAXFIXUPS   (sizeof(fsFixups)/sizeof(fsFixups[0]))

/*
 *	GetUsableFontHeight(ySrcHeight, lPointChange)
 *
 *	@func
 *		Return a font size for setting text or insertion point attributes
 *
 *	@rdesc
 *		New TWIPS height
 *
 *	@devnote
 *		Copied from WinCE RichEdit code (written by V-GUYB)
 */
LONG GetUsableFontHeight(
	LONG ySrcHeight,		//@parm Current font size in twips
	LONG lPointChange)		//@parm Increase in pt size, (-ve if shrinking)
{
	LONG	EndValue;
	LONG	Delta;
    int		i;
    LONG	yRetHeight;

    // Input height in twips here, (TWentIeths of a Point).
    // Note, a Point is a 1/72th of an inch. To make these
    // calculations clearer, use point sizes here. Input height
    // in twips is always divisible by 20 (NOTE (MS3): maybe with
	// a truncation, since RTF uses half-point units).
    yRetHeight = (ySrcHeight / 20) + lPointChange;

    // Fix new font size to match sizes used by Word95
    for(i = 0; i < PWD_FONTSIZEMAXFIXUPS; ++i)
    {
		EndValue = fsFixups[i].EndValue;
		Delta	 = fsFixups[i].Delta;

        // Does new height lie in this range of point sizes?
        if(yRetHeight <= EndValue || !EndValue)
        {
            // If new height = EndValue, then it doesn't need adjusting
            if(yRetHeight != EndValue)
            {
                // Adjust new height to fit this range of point sizes. If
                // Delta = 1, all point sizes in this range stay as they are.
                if(!Delta)
                {
                    // Everything in this range is rounded to the EndValue
                    yRetHeight = fsFixups[(lPointChange > 0 ?
                                    i : max(i - 1, 0))].EndValue;
                }
                else if(Delta != 1)
                {
                    // Round new height to next delta in this range
                    yRetHeight = ((yRetHeight +
                        (lPointChange > 0 ? Delta - 1 : 0))
                                / Delta) * Delta;
                }
            }
            break;
        }
    }

    // Limit the new text size. Note, if we fix the text size
    // now, then we won't take any special action if we change
    // the text size later in the other direction. For example,
    // we shrink chars with size 1 and 2. They both change to
    // size 1. Then we grow them both to 2. So they are the
    // same size now, even though they weren't before. This
    // matches Word95 behavior.
    yRetHeight = max(yRetHeight, PWD_FONTSIZEPOINTMIN);
    yRetHeight = min(yRetHeight, PWD_FONTSIZEPOINTMAX);

    return yRetHeight*20;			// Return value in twips
}

/*
 *	IsValidCharFormatW(pCF)
 *
 *	@func
 *		Return TRUE iff the structure *<p pCF> has the correct size to be
 *		a CHARFORMAT or a CHARFORMAT2
 *
 *	@rdesc
 *		Return TRUE if *<p pCF> is a valid CHARFORMAT(2)
 */
BOOL IsValidCharFormatW (
	const CHARFORMAT * pCF) 		//@parm CHARFORMAT to validate
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "IsValidCharFormat");

	return pCF && (pCF->cbSize == sizeof(CHARFORMATW) ||
				   pCF->cbSize == sizeof(CHARFORMAT2W));
}

/*
 *	IsValidCharFormatA(pCFA)
 *
 *	@func
 *		Return TRUE iff the structure *<p pCF> has the correct size to be
 *		a CHARFORMATA or a CHARFORMAT2A
 *
 *	@rdesc
 *		Return TRUE if *<p pCF> is a valid CHARFORMAT(2)A
 */
BOOL IsValidCharFormatA (
	const CHARFORMATA * pCFA) 	//@parm CHARFORMATA to validate
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "IsValidCharFormatA");

	return pCFA && (pCFA->cbSize == sizeof(CHARFORMATA) ||
					pCFA->cbSize == sizeof(CHARFORMAT2A));
}

/*
 *	IsValidParaFormat(pPF)
 *
 *	@func
 *		Return TRUE iff the structure *<p pPF> has the correct size to be
 *		a PARAFORMAT or a PARAFORMAT2
 *
 *	@rdesc
 *		Return TRUE if *<p pPF> is a valid PARAFORMAT(2)
 */
BOOL IsValidParaFormat (
	const PARAFORMAT * pPF)		//@parm PARAFORMAT to validate
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "IsValidParaFormat");

	if (pPF && (pPF->cbSize == sizeof(PARAFORMAT) ||
				pPF->cbSize == sizeof(PARAFORMAT2)))
	{
		return TRUE;
	}
	TRACEERRORSZ("!!!!!!!!!!! bogus PARAFORMAT from client !!!!!!!!!!!!!");
	return FALSE;
}

/*
 *	Get16BitTwips(dy)
 *
 *	@func
 *		Return dy if |dy| < 32768; else return 32767, i.e., max value
 *		that fits into a SHORT
 *
 *	@rdesc
 *		dy if abs(cy) < 32768; else 32767
 */
SHORT Get16BitTwips(LONG dy)
{
	return abs(dy) < 32768 ? (SHORT)dy : 32767;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\callmgr.cpp ===
/*
 *
 *	@doc	INTERNAL
 *
 *	@module	CALLMGR.CPP		CCallMgr implementation |
 *
 *	Purpose:  The call manager controls various aspects of
 *		a client call chain, including re-entrancy management,
 *		undo contexts, and change notifications.
 *
 *	Author:	<nl>
 *		alexgo 2/8/96
 *
 *	See the documentation in reimplem.doc for a detailed explanation
 *	of how all this stuff works.
 *
 *	Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_m_undo.h"
#include "_callmgr.h"
#include "_select.h"
#include "_disp.h"
#include "_dxfrobj.h"

#ifndef NOPRIVATEMESSAGE
#include "_MSREMSG.H"
#endif

#define EN_CLIPFORMAT			0x0712
#define ENM_CLIPFORMAT			0x00000080

typedef struct _clipboardformat
{
	NMHDR nmhdr;
	CLIPFORMAT cf;
} CLIPBOARDFORMAT;


ASSERTDATA

/*
 *	CCallMgr::SetChangeEvent(fType)
 *
 *	@mfunc	informs the callmgr that some data in the document 
 *			changed.  The fType parameter describes the actual change
 */
void CCallMgr::SetChangeEvent(
	CHANGETYPE fType)		//@parm the type of change (e.g. text, etc)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::SetChangeEvent");

	// if another callmgr exists higher up the chain, then 
	// delegate the call to it
	if( _pPrevcallmgr )
	{
		Assert(_fChange == FALSE);
		Assert(_fTextChanged == FALSE);
		_pPrevcallmgr->SetChangeEvent(fType);
	}
	else
	{
		_fChange = TRUE;
		_ped->_fModified = TRUE;
		_ped->_fSaved = FALSE;
		_fTextChanged = !!(fType & CN_TEXTCHANGED);
	}
}

/*
 *	CCallmgr::ClearChangeEvent()
 *
 *	@mfunc	If a change happened, then clear the change event bit. 
 *			This allows callers to make changes to the edit control
 *			_without_ having a notifcation fire.  Sometimes, this
 *			is necessary for backwards compatibility.
 *
 *	@devnote	This is a very dangerous method to use.  If _fChange
 *			is set, it may represent more than 1 change; in other words,
 *			other changes than the one that should be ignored.  However,
 *			for all existing uses of this method, earlier changes are
 *			irrelevant.
 */
void CCallMgr::ClearChangeEvent()
{
	if( _pPrevcallmgr )
	{
		Assert(_fChange == FALSE);
		Assert(_fTextChanged == FALSE);
		_pPrevcallmgr->ClearChangeEvent();
	}
	else
	{
		_fChange = FALSE;
		_fTextChanged = FALSE;
		// caller is responsible for setting _fModifed
	}
}

/*
 *	CCallMgr::SetNewUndo()
 *
 *	@mfunc	Informs the notification code that a new undo action has
 *			been added to the undo stack
 */
void CCallMgr::SetNewUndo()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::SetNewUndo");

	// we should only ever do this once per call
//	It's assert during IME composition in Outlook.  (see bug #3883)
//  Removing the assert does not caused any side effect.
//	Assert(_fNewUndo == FALSE);


	if( _pPrevcallmgr )
	{
		_pPrevcallmgr->SetNewUndo();
	}
	else
	{
		_fNewUndo = TRUE;
	}
}

/*
 *		
 *	CCallMgr::SetNewRedo ()
 *
 *	@mfunc	Informs the notification code that a new redo action has
 *			been added to the redo stack.
 */
void CCallMgr::SetNewRedo()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::SetNewRedo");

	// we should only ever do this once per call.
	// The following assert looks bogus as it is forced to occur when an undo is
	// called with a count greater than 1. Therefore, for now, I (a-rsail) am
	// commenting it out.
	// Assert(_fNewRedo == FALSE);

	if( _pPrevcallmgr )
	{
		_pPrevcallmgr->SetNewRedo();
	}
	else
	{
		_fNewRedo = TRUE;
	}
}

/*
 *	CCallMgr::SetMaxText()
 *
 *	@mfunc	Informs the notification code that the max text limit has
 *			been reached.
 */
 void CCallMgr::SetMaxText()
 {
     TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::SetMaxText");

	// if there is a call context higher on the stack, delegate to it.

	if( _pPrevcallmgr )
	{
		Assert(_fMaxText == 0);
		_pPrevcallmgr->SetMaxText();
	}
	else
	{
		_fMaxText = TRUE;
	}
}

/*
 *	CCallMgr::SetSelectionChanged()
 *
 *	@mfunc	Informs the notification code that the selection has
 *			changed
 */
void CCallMgr::SetSelectionChanged()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::SetSelectionChanged");

    AssertSz(_ped->DelayChangeNotification() ? _ped->Get10Mode() : 1, "Flag only should be set in 1.0 mode");        
    if (_ped->DelayChangeNotification())
        return;
	
	// if there is a call context higher on the stack, delegate to it.

	if( _pPrevcallmgr )
	{
		Assert(_fSelChanged == 0);
		_pPrevcallmgr->SetSelectionChanged();
	}
	else
	{
		_fSelChanged = TRUE;
	}
}

/*
 *	CCallMgr::SetOutOfMemory()
 *
 *	@mfunc	Informs the notification code that we were unable to allocate
 *			enough memory.
 */
void CCallMgr::SetOutOfMemory()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::SetOutOfMemory");

	// if there is a call context higher on the stack, delegate to it.

	if( _pPrevcallmgr )
	{
		Assert(_fOutOfMemory == 0);
		_pPrevcallmgr->SetOutOfMemory();
	}
	else
	{
		_fOutOfMemory = TRUE;
	}
}

/*
 *	CCallMgr::SetInProtected
 *
 *	@mfunc	Indicates that we are currently processing an EN_PROTECTED
 *			notification
 *
 *	@rdesc	void
 */
void CCallMgr::SetInProtected(BOOL flag)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::SetInProtected");

	if( _pPrevcallmgr )
	{
		_pPrevcallmgr->SetInProtected(flag);
	}
	else
	{
		_fInProtected = flag;
	}
}

/*
 *	CCallMgr:GetInProtected()
 *
 *	@mfunc	retrieves the InProtected flag, whether or not we are currently
 *			processing an EN_PROTECTED notification
 *
 *	@rdesc	TRUE if we're processing an EN_PROTECTED notification
 */
BOOL CCallMgr::GetInProtected()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::GetInProtected");

	if( _pPrevcallmgr )
	{
		return _pPrevcallmgr->GetInProtected();
	}
	else
	{
		return _fInProtected;
	}
}	

/*
 *	CCallMgr::RegisterComponent(pcomp, name)
 *
 *	@mfunc	Registers a subsystem component implementing IReEntrantComponent.
 *			This enables this call manager to inform those objects about
 *			relevant changes in our re-entrancy status.
 */
void CCallMgr::RegisterComponent(
	IReEntrantComponent *pcomp,	//@parm The component to register
	CompName name)				//@parm The name for the component
{
	pcomp->_idName = name;
	pcomp->_pnext = _pcomplist;
	_pcomplist = pcomp;
}

/*
 *	CCallMgr::RevokeComponent(pcomp)
 *
 *	@mfunc	Removes a subsystem component from the list of components.  The
 *			component must have been previously registered with _this_
 *			call context.
 */
void CCallMgr::RevokeComponent(
	IReEntrantComponent *pcomp)	//@parm The component to remove
{
	IReEntrantComponent *plist, **ppprev;
	plist = _pcomplist;
	ppprev = &_pcomplist;

	while( plist != NULL )
	{
		if( plist == pcomp )
		{
			*ppprev = plist->_pnext;
			break;
		}
		ppprev = &(plist->_pnext);
		plist = plist->_pnext;
	} 
}

/*
 *	CCallMgr::GetComponent(name)
 *
 *	@mfunc	Retrieves the earliest instance of a registered sub-component.
 *
 *	@rdesc	A pointer to the component, if one has been registered.  NULL
 *			otherwise.
 */
IReEntrantComponent *CCallMgr::GetComponent(
	CompName name)				//@parm the subsystem to look for
{
	IReEntrantComponent *plist = _pcomplist;

	while( plist != NULL )
	{
		if( plist->_idName == name )
		{
			return plist;
		}
		plist = plist->_pnext;
	}

	// hmm, didn't find anything.  Try contexts higher up, if we're
	// the top context, then just return NULL.

	if( _pPrevcallmgr )
	{
		return _pPrevcallmgr->GetComponent(name);
	}
	return NULL;
}

/*
 *	CCallMgr::CCallMgr(ped)
 *
 *	@mfunc	Constructor
 *
 *	@rdesc	void
 */
CCallMgr::CCallMgr(CTxtEdit *ped)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::");

	// set everthing to NULL
	ZeroMemory(this, sizeof(CCallMgr));

	if(ped)								// If ped is NULL, a zombie has
	{									//  been entered
		_ped = ped;
		_pPrevcallmgr = ped->_pcallmgr;
		ped->_pcallmgr = this;
		NotifyEnterContext();

#ifndef NOPRIVATEMESSAGE
		if (!_pPrevcallmgr && _ped->_pMsgFilter && _ped->_pMsgCallBack)
				_ped->_pMsgCallBack->NotifyEvents(NE_ENTERTOPLEVELCALLMGR);
#endif
	}
}

/*
 *	CCallMgr::~CCallMgr()
 *
 *	@mfunc	Destructor.  If appropriate, we will fire any cached
 *			notifications and cause the edit object to be destroyed.
 *
 *	@rdesc	void
 */
CCallMgr::~CCallMgr()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::");

	if(IsZombie())					// No reentrancy with Zombies
		return;

	if( _pPrevcallmgr )
	{
		// we don't allow these flags to be set in re-entrant call
		// states
		Assert(_fMaxText == FALSE);
		Assert(_fSelChanged == FALSE);
		Assert(_fTextChanged == FALSE);
		Assert(_fChange == FALSE);
		Assert(_fNewRedo == FALSE);
		Assert(_fNewUndo == FALSE);
		Assert(_fOutOfMemory == FALSE);

		// set the ped to the next level of the call state
		_ped->_pcallmgr = _pPrevcallmgr;
	
		return;
	}

	// we're the top level. Note that we explicity do not
	// have an overall guard for cases where we are re-entered
	// while firing these notifications.  This is necessary for
	// better 1.0 compatibility and for Forms^3, which wants
	// to 'guard' their implementation of ITextHost::TxNotify and
	// ignore any notifications that happen while they are 
	// processing our notifications.  Make sense?

	_ped->_pcallmgr = NULL;

	// Process our internal notifications
	if(_ped->_fUpdateSelection)
	{	
		CTxtSelection *psel = _ped->GetSel();

		_ped->_fUpdateSelection = FALSE;

		if(psel && !_ped->_pdp->IsFrozen() && !_fOutOfMemory )
		{
			// this may cause an out of memory, so set things
			// up for that
			CCallMgr callmgr(_ped);
			psel->Update(FALSE);
		}
	}

	// Now fire any external notifications that may be necessary
	if( _fChange || _fSelChanged || _fMaxText || _fOutOfMemory )
	{
		SendAllNotifications();
	}

	// finally, we should check to see if we should delete the 
	// CTxtEdit instance.

	if(!_ped->_fSelfDestruct)
	{
		if( _ped->_unk._cRefs == 0)
		{
			delete _ped;
		}
#ifndef NOPRIVATEMESSAGE
		else
		{
			if (_ped->_pMsgFilter && _ped->_pMsgCallBack)
			{
				DWORD	dwEvents = NE_EXITTOPLEVELCALLMGR;

				if (_fSelChanged)
					dwEvents |= NE_CALLMGRSELCHANGE;

				if (_fChange)
					dwEvents |= NE_CALLMGRCHANGE;

				_ped->_pMsgCallBack->NotifyEvents(dwEvents);
			}
		}
#endif
	}
}

//
//	PRIVATE methods
//

/*
 *	CCallMgr::SendAllNotifications()
 *
 *	@mfunc	sends notifications for any cached notification bits.
 */
void CCallMgr::SendAllNotifications()
{
	//if the ped has already destructed, we cant make calls though it
	if (_ped->_fSelfDestruct)
		return;
	
	ITextHost *phost = _ped->GetHost();
	CHANGENOTIFY	cn;

    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::");

	//
	// COMPATIBILITY ISSUE: The ordering of these events _may_
	// be an issue.  I've attempted to preserve the ordering
	// that the original code would use, but we have ~many~ more
	// control paths, so it's difficult.
	//
	if(	_fMaxText )
	{			
		// Beep if we are to emulate the system edit control
		if (_ped->_fSystemEditBeep)
			_ped->Beep();
		phost->TxNotify(EN_MAXTEXT, NULL);
	}
	
	if( _fSelChanged )
	{ 		
		if( (_ped->_dwEventMask & ENM_SELCHANGE) && !(_ped->_fSuppressNotify))
		{
			CTxtSelection * const psel = _ped->GetSel();
			if(psel)
			{
				SELCHANGE selchg;
				ZeroMemory(&selchg, sizeof(SELCHANGE));
				psel->SetSelectionInfo(&selchg);
			
				if (_ped->Get10Mode())
				{
					selchg.chrg.cpMin = _ped->GetAcpFromCp(selchg.chrg.cpMin);
					selchg.chrg.cpMost = _ped->GetAcpFromCp(selchg.chrg.cpMost);
				}

				phost->TxNotify(EN_SELCHANGE, &selchg);
			}
		}
	}

	if( _fOutOfMemory && !_ped->GetOOMNotified())
	{
		_fNewUndo = 0;
		_fNewRedo = 0;
		_ped->ClearUndo(NULL);
		_ped->_pdp->InvalidateRecalc();
		_ped->SetOOMNotified(TRUE);
		phost->TxNotify(EN_ERRSPACE, NULL);
		_ped->SetOOMNotified(FALSE);

	}

	if( _fChange )
	{
		if( (_ped->_dwEventMask & ENM_CHANGE) && !(_ped->_fSuppressNotify))
		{
			cn.dwChangeType = 0;
			cn.pvCookieData = 0;
			
			if( _fNewUndo )
			{
				Assert(_ped->_pundo);
				cn.dwChangeType |= CN_NEWUNDO;
				cn.pvCookieData = _ped->_pundo->GetTopAECookie();

			}
			else if( _fNewRedo )
			{
				Assert(_ped->_predo);
				cn.dwChangeType |= CN_NEWREDO;
				cn.pvCookieData = _ped->_predo->GetTopAECookie();
			}

			if( _fTextChanged )
			{
				cn.dwChangeType |= CN_TEXTCHANGED;
			}
			_ped->_dwEventMask &= ~ENM_CHANGE;
			phost->TxNotify(EN_CHANGE, &cn);
			_ped->_dwEventMask |= ENM_CHANGE;
		}
	}
	if((_ped->_dwEventMask & ENM_CLIPFORMAT) && _ped->_ClipboardFormat)
	{
		CLIPBOARDFORMAT cf;
		ZeroMemory(&cf, sizeof(CLIPBOARDFORMAT));
		cf.cf = g_rgFETC[_ped->_ClipboardFormat - 1].cfFormat;
		_ped->_ClipboardFormat = 0;
		phost->TxNotify(EN_CLIPFORMAT, &cf);
	}

#if !defined(NOLINESERVICES) && !defined(NOCOMPLEXSCRIPTS)
	extern char *g_szMsgBox;
	if(g_szMsgBox)
	{
		CLock lock;
		if(g_szMsgBox)
		{
			MessageBoxA(NULL, g_szMsgBox, NULL, MB_ICONEXCLAMATION | MB_TASKMODAL | MB_SETFOREGROUND);
			FreePv((void *)g_szMsgBox);
			g_szMsgBox = NULL;
		}
	}
#endif
}

/*
 *	CCallMgr::NotifyEnterContext()
 *
 *	@mfunc	Notify any registered components that a new context
 *			has been entered.
 *
 */
void CCallMgr::NotifyEnterContext()
{
	IReEntrantComponent *pcomp = _pcomplist;

	while( pcomp )
	{
		pcomp->OnEnterContext();
		pcomp = pcomp->_pnext;
	}

	if( _pPrevcallmgr )
	{
		_pPrevcallmgr->NotifyEnterContext();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\cmsgflt.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	CMSGFLT.CPP	-- Text Message Implementation |
 *	
 *		Most everything to do with IME message handling.
 *
 *	Original Author: <nl>
 *		Hon Wah Chan
 *
 *	History: <nl>
 *		2/6/98  v-honwch
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */
#include "_common.h"

#ifndef NOFEPROCESSING

#ifndef NOPRIVATEMESSAGE
#include "_MSREMSG.H"
#endif	

#include "_array.h"
#include "msctf.h"
#include "textstor.h"
#include "msctfp.h"

#include "textserv.h"
#include "_cmsgflt.h"
#include "_ime.h"

#include "_cuim.h"
#include "imeapp.h"


#define MAX_RECONVERSION_SIZE 100
#define CONTROL(_ch) (_ch - 'A' + 1)

/*
 *	void CreateIMEMessageFilter(ITextMsgFilter **ppMsgFilter)
 *
 *	@func
 *		TextMsgFilter class factory.
 */       
void CreateIMEMessageFilter(ITextMsgFilter **ppMsgFilter)
{
	CTextMsgFilter *pNewFilter = new CTextMsgFilter;
	*ppMsgFilter = pNewFilter ? pNewFilter : NULL;
}

/*
 *	void CTextMsgFilter::~CTextMsgFilter
 *
 *	@mfunc
 *		CTextMsgFilter Destructor
 *			Release objects being used.
 *		
 */
CTextMsgFilter::~CTextMsgFilter ()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::~CTextMsgFilter");

	if (_nIMEMode)
	{
		SetIMESentenseMode(FALSE);
		_nIMEMode = 0;
	}

	if (_hIMCContext)
		ImmAssociateContext(_hwnd, _hIMCContext, _fUsingAIMM);	// Restore IME before exit

	if (_pMsgCallBack)
	{		
		delete _pMsgCallBack;
		_pMsgCallBack = NULL;
	}

	// Release various objects
	TurnOffUIM(FALSE);
	
	TurnOffAimm(FALSE);

	if (_pFilter)
		_pFilter->Release();
	
	if (_pTextSel)
		_pTextSel->Release();
	
	_pFilter = NULL;
	_pTextDoc = NULL;
	_pTextSel = NULL;
	_hwnd = NULL;
	_hIMCContext = NULL;
	FreePv(_pcrComp);
	_pcrComp = NULL;
}

/*
 *	STDMETHODIMP CTextMsgFilter::QueryInterface (riid, ppv)
 *
 *	@mfunc
 *		IUnknown QueryInterface support
 *
 *	@rdesc
 *		NOERROR if interface supported
 *
 */
STDMETHODIMP CTextMsgFilter::QueryInterface (REFIID riid, void ** ppv)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::QueryInterface");

	if( IsEqualIID(riid, IID_IUnknown) )
	{
		*ppv = (IUnknown *)this;
	}
	else if( IsEqualIID(riid, IID_ITextMsgFilter) )
	{
		*ppv = (ITextMsgFilter *)this;
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	AddRef();

	return NOERROR;
}

/*
 *	STDMETHODIMP_(ULONG) CTextMsgFilter::AddRef
 *
 *	@mfunc
 *		IUnknown AddRef support
 *
 *	@rdesc
 *		Reference count
 */
STDMETHODIMP_(ULONG) CTextMsgFilter::AddRef()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::AddRef");

	return ++_crefs;
}

/*
 *	STDMETHODIMP_(ULONG) CTextMsgFilter::Release()
 *
 *	@mfunc
 *		IUnknown Release support - delete object when reference count is 0
 *
 *	@rdesc
 *		Reference count
 */
STDMETHODIMP_(ULONG) CTextMsgFilter::Release()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::Release");

	_crefs--;

	if( _crefs == 0 )
	{
		delete this;
		return 0;
	}

	return _crefs;
}

/*
 *	STDMETHODIMP_(HRESULT) CTextMsgFilter::AttachDocument(HWND, ITextDocument2)
 *
 *	@mfunc
 *		Attach message filter. Perform genral initialization
 *
 *	@rdesc
 *		NOERROR
 */
STDMETHODIMP_(HRESULT) CTextMsgFilter::AttachDocument( HWND hwnd, ITextDocument2 *pTextDoc, IUnknown *punk)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::AttachDocument");

	// Cache the values for possible later use.
	// The TextDocument interface pointer is not AddRefed because it is a back pointer
	// and the lifetime of message filters is assumed to be nested inside text documents	
	_hwnd = hwnd;
	_pTextDoc = pTextDoc;
	_pTextService = (ITextServices *)punk;

	// Don't get selection until it is needed
	_pTextSel = NULL;

	_fUnicodeWindow = 0;	
	if (hwnd)
		_fUnicodeWindow = IsWindowUnicode(hwnd);

	_fUsingAIMM = 0; 

	_pTim = NULL;
	_pCUIM = NULL;	
	_fUsingUIM = 0;

	// Check if current keyboard is MSIME98 or later.
	CheckIMEType(NULL);

	// Initialize some member data
	_fHangulToHanja = FALSE;
	_fIMECancelComplete = FALSE;	
	_fIMEAlwaysNotify = FALSE;
	_hIMCContext = NULL;
	_pcrComp = NULL;
	_pMsgCallBack = NULL;

	_pTextDoc->GetFEFlags(&_lFEFlags);
	_fRE10Mode = (_lFEFlags & tomRE10Mode);

	_uSystemCodePage = GetACP();

	return NOERROR;
}

/*
 *	STDMETHODIMP_(HRESULT) CTextMsgFilter::HandleMessage(UINT *, WPARAM *, LPARAM *, LRESULT *)
 *
 *	@mfunc
 *		Main Message filter message loop handling
 *
 *	@rdesc
 *		S_OK		if we have handled the message
 *		S_FALSE		if we want the caller to process the message
 */
STDMETHODIMP_(HRESULT) CTextMsgFilter::HandleMessage( 
		UINT *		pmsg,
        WPARAM *	pwparam,
		LPARAM *	plparam,
		LRESULT *	plres)
{
	//TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::HandleMessage");

	HRESULT hr = S_FALSE;
	BOOL	bReleaseSelction = FALSE;
	HRESULT hResult;

	// Give other message filters a chance to handle message
	// Stop with the first guy that handles the message
	if (_pFilter)	 
		hr = _pFilter->HandleMessage(pmsg, pwparam, plparam, plres);

	if (hr == S_OK)
		return hr;

 	if (IsIMEComposition() || _pCUIM && _pCUIM->IsUIMTyping())
	{
		// During IME Composition, there are some messages we should
		// not handle.  Also, there are other messages we need to handle by
		// terminating the IME composition first.
		// For WM_KEYDOWN, this is handled inside edit.c OnTxKeyDown().
		switch( *pmsg )
		{
			case WM_COPY:
			case WM_CUT:
			case WM_DROPFILES:
			case EM_REDO:
			case EM_SETCHARFORMAT:			
			case WM_SETFONT:
				return S_OK;					// Just ignore these

			
			case EM_UNDO:
			case WM_UNDO:
				// just terminate and exist for undo cases
				CompleteUIMTyping(CIme::TERMINATE_NORMAL);
				return S_OK;

			case WM_SETTEXT:
			case WM_CLEAR:
			case EM_STREAMIN:
				// these messages are used to reset our state, so reset
				// IME as well
				CompleteUIMTyping(CIme::TERMINATE_FORCECANCEL);
				break;

			case EM_SETTEXTEX:
				if (!_fRE10Mode)			// Don't terminate if running in 10 mode			
					CompleteUIMTyping(CIme::TERMINATE_FORCECANCEL);
				break;

			case WM_SYSKEYDOWN:
				// Don't terminate IME composition on VK_PROCESSKEY (F10) since Japanese 
				// IME will process the F10 key
				if (*pwparam != VK_PROCESSKEY)
					CompleteUIMTyping(CIme::TERMINATE_NORMAL);	// otherwise we want to terminate the IME
				break;

			case WM_CHAR:
			case WM_UNICHAR:
				if (IsIMEComposition() && _ime->GetIMELevel() == IME_LEVEL_3 && !_fReceivedKeyDown)
					return S_OK;				// Ignore this during IME composition and we haven't seen 
												//	any keydown message,
												//	else fall thru to terminate composition
				_fReceivedKeyDown = 0;

			case EM_SETWORDBREAKPROC:
 			case WM_PASTE:
			case EM_PASTESPECIAL:					  			
 			case EM_SCROLL:
			case EM_SCROLLCARET:
 			case WM_VSCROLL:
			case WM_HSCROLL:
			case EM_SETREADONLY:
			case EM_SETPARAFORMAT:
			case WM_INPUTLANGCHANGEREQUEST:	
			case EM_REPLACESEL:
			case EM_STREAMOUT:
				CompleteUIMTyping(CIme::TERMINATE_NORMAL);
				break;

			case WM_KILLFOCUS:
				CompleteUIMTyping(CIme::TERMINATE_NORMAL, FALSE);
				break;

			case EM_SETSEL:
				if (IsIMEComposition())
					CompleteUIMTyping(CIme::TERMINATE_NORMAL);
				else
					return S_OK;					// Ignore this during Cicero typing

			case WM_KEYUP:
				_fReceivedKeyDown = 0;
				break;

			case WM_KEYDOWN:
				_fReceivedKeyDown = 1;
				if(GetKeyState(VK_CONTROL) & 0x8000)
				{	
					// During IME Composition, there are some key events we should
					// not handle.  Also, there are other key events we need to handle by
					// terminating the IME composition first.			
					switch((WORD) *pwparam)
					{
					case VK_TAB:
		   			case VK_CLEAR:
					case VK_NUMPAD5:
					case 'A':						// Ctrl-A => select all
					case 'C':						// Ctrl-C => copy
					case 'X':						// Ctrl-X => cut
					case 'Y':						// Ctrl-Y => redo
						return S_OK;				// Just ignore these

					case 'V':						// Ctrl-V => paste
					case 'Z':						// Ctrl-Z => undo	
						CompleteUIMTyping(CIme::TERMINATE_NORMAL);						
						if ((WORD) *pwparam == 'Z')	// Early exist for undo case
							return S_OK;
					}
				}
				else
				{
					switch((WORD) *pwparam)
					{					
					case VK_F16:
						return S_OK;				// Just ignore these
					
					case VK_BACK:
					case VK_INSERT:					// Ins			
					case VK_LEFT:					// Left arrow
					case VK_RIGHT:					// Right arrow
					case VK_UP:						// Up arrow
					case VK_DOWN:					// Down arrow
					case VK_HOME:					// Home
					case VK_END:					// End
					case VK_PRIOR:					// PgUp
					case VK_NEXT:					// PgDn
					case VK_DELETE:					// Del
					case CONTROL('J'):
					case VK_RETURN:
						CompleteUIMTyping(CIme::TERMINATE_NORMAL);
						break;
					}
				}
				break;

			default:
				// Only need to handle mouse related msgs during composition
				if (IN_RANGE(WM_MOUSEFIRST, *pmsg, WM_MBUTTONDBLCLK) || *pmsg == WM_SETCURSOR)
				{
					if (IsIMEComposition())
					{
						bReleaseSelction = GetTxSelection();
						if (_pTextSel)
							hr = IMEMouseCheck( *this, pmsg, pwparam, plparam, plres);
						goto Exit;
					}

					// Cicero composition
					if (_pCUIM->_fMosueSink)
					{
						bReleaseSelction = GetTxSelection();
						if (_pTextSel)
							hr = _pCUIM->MouseCheck(pmsg, pwparam, plparam, plres);
						goto Exit;
					}
					if (IN_RANGE(WM_LBUTTONDOWN, *pmsg, WM_MOUSELAST) && !(*pmsg == WM_LBUTTONUP || *pmsg == WM_RBUTTONUP || *pmsg == WM_MBUTTONUP))
						CompleteUIMTyping(CIme::TERMINATE_NORMAL);		// Terminate on Mouse down and double-click messages
				}
				break;
		}
	}

	// Get Fe Flags for ES_NOIME or ES_SELFIME setting
	_lFEFlags = 0;

	// ... Local mucking with msg, params, etc, ...
	switch ( *pmsg )
	{
		case WM_CHAR:
			hr = OnWMChar (pmsg, pwparam, plparam, plres);
			break;

		case WM_IME_CHAR:
			_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			if ((_lFEFlags & ES_NOIME))
				hr = S_OK;
			else
				hr = OnWMIMEChar (pmsg, pwparam, plparam, plres);
			break;
		
		case WM_IME_STARTCOMPOSITION:
			_fReceivedKeyDown = 0;
			_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			if (!(_lFEFlags & ES_SELFIME))
			{				
				bReleaseSelction = GetTxSelection();
				if (_pTextSel)
					hr = StartCompositionGlue (*this);
			}
			break;

		case WM_IME_COMPOSITION:
			_fReceivedKeyDown = 0;
			_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			
			if ((_lFEFlags & ES_NOIME) && !IsIMEComposition())
				hr = S_OK;			
			else if (!(_lFEFlags & ES_SELFIME))
			{
				bReleaseSelction = GetTxSelection();
				if (_pTextSel)
				{
					hr = CompositionStringGlue ( *plparam, *this );
					// Turn off Result string bit to avoid WM_IME_CHAR message.
					*plparam &= ~GCS_RESULTSTR;
				}
			}

			if (_hwnd && IsIMEComposition() && _ime->IgnoreIMECharMsg())
			{
				_ime->AcceptIMECharMsg();
				if (fHaveAIMM)
					hr = CallAIMMDefaultWndProc(_hwnd, *pmsg, *pwparam, *plparam, plres);
				else
					*plres = ::DefWindowProc(_hwnd, *pmsg, *pwparam, *plparam);				

				hr = S_OK;
			}

			break;

		case WM_IME_ENDCOMPOSITION:
			_fReceivedKeyDown = 0;
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			if (!(_lFEFlags & ES_SELFIME))
			{			
				bReleaseSelction = GetTxSelection();
				if (_pTextSel)
					hr = EndCompositionGlue ( *this, FALSE );
			}
			break;

		case WM_IME_NOTIFY:
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			if (!(_lFEFlags & (ES_SELFIME | ES_NOIME)))
			{
				bReleaseSelction = GetTxSelection();
				if (_pTextSel)			
					hr = IMENotifyGlue ( *pwparam, *plparam, *this );
			}
			break;

		case WM_IME_COMPOSITIONFULL:	// Level 2 comp string about to overflow.
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			if (!(_lFEFlags & ES_SELFIME))
			{
				IMECompositionFull ( *this );
			}
			hr = S_FALSE;
			break;

		case WM_KEYDOWN:
			if (*pwparam == VK_KANJI)
			{
				hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
				
				_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);
				// for Korean, need to convert the next Korean Hangul character to Hanja
				if(CP_KOREAN == _uKeyBoardCodePage && !(_lFEFlags & (ES_SELFIME | ES_NOIME)))
				{
					bReleaseSelction = GetTxSelection();
					if (_pTextSel)
						hr = IMEHangeulToHanja ( *this );
				}
			}
			break;

		case WM_INPUTLANGCHANGE: 
			CheckIMEType((HKL)*plparam);
			if (_nIMEMode && GetFocus() == _hwnd)
				SetIMESentenseMode(TRUE, (HKL)*plparam);
			hr = S_FALSE;
			break;
			
		case WM_INPUTLANGCHANGEREQUEST:
			if (_nIMEMode && GetFocus() == _hwnd)
				SetIMESentenseMode(FALSE);
			break;

		case WM_KILLFOCUS:
			OnKillFocus();
			break;
		
		case WM_SETFOCUS:
			OnSetFocus();
			break;

		case EM_SETIMEOPTIONS:
			*plres = OnSetIMEOptions(*pwparam, *plparam);
			hr = S_OK;
			break;

		case EM_GETIMEOPTIONS:
			*plres = OnGetIMEOptions();
			hr = S_OK;
			break;

		case WM_IME_REQUEST:
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			if (!(_lFEFlags & (ES_SELFIME | ES_NOIME)))
			{				
				bReleaseSelction = GetTxSelection();
				if (_pTextSel)
				{
					_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);
					if (*pwparam == IMR_RECONVERTSTRING || *pwparam == IMR_CONFIRMRECONVERTSTRING
						|| *pwparam == IMR_DOCUMENTFEED)			
						hr = OnIMEReconvert(pmsg, pwparam, plparam, plres, _fUnicodeWindow);	
					else if (*pwparam == IMR_QUERYCHARPOSITION)
						hr = OnIMEQueryPos(pmsg, pwparam, plparam, plres, _fUnicodeWindow);
				}				
			}
			break;

		case EM_RECONVERSION:
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			if (!(_lFEFlags & (ES_SELFIME | ES_NOIME)))
			{
				// Application initiates reconversion
				bReleaseSelction = GetTxSelection();
				if (_pTextSel)
				{
					if (!(IsIMEComposition() || _pCUIM && _pCUIM->IsUIMTyping()))
					{
						if (_pCUIM && _pCUIM->Reconverse() >= 0)
							break;

						if (_fMSIME && MSIMEReconvertRequestMsg)
							IMEMessage( *this, MSIMEReconvertRequestMsg, 0, (LPARAM)_hwnd, TRUE );				
						else
						{
							hr = OnIMEReconvert(pmsg, pwparam, plparam, plres, TRUE);							
							*plres = 0;
						}
					}
				}
			}
			hr = S_OK;
			break;

		case EM_SETLANGOPTIONS:
			// Setup IME related setting.
			// hr is not S_OK so textserv could handle other language setting
			_fIMEAlwaysNotify = (*plparam & IMF_IMEALWAYSSENDNOTIFY) != 0;
			_fIMECancelComplete = (*plparam & IMF_IMECANCELCOMPLETE) != 0;
			*plres = 1;
			break;

		case EM_GETLANGOPTIONS:
			// Report IME related setting.
			// hr is not S_OK so textserv could fill in other language setting
			if ( _fIMECancelComplete ) 
				*plres |= IMF_IMECANCELCOMPLETE;
			if ( _fIMEAlwaysNotify )
				*plres |= IMF_IMEALWAYSSENDNOTIFY;
			break;

		case EM_GETIMECOMPMODE:
			// Get current IME level
			if (_pCUIM && _pCUIM->IsUIMTyping())
				*plres = ICM_CTF;
			else
				*plres = OnGetIMECompositionMode( *this );
			hr = S_OK;
			break;
		
		case EM_SETUIM:
			// This is RE private message equivalent to EM_SETEDITSTYLE
			if (!_fNoIme)							// Ignore if no IME
			{
				if (!_fUsingUIM && !_fUsingAIMM)	// Ignore if we already using something
				{
					if (*pwparam == SES_USEAIMM11 || *pwparam == SES_USEAIMM12)
					{
						if (!_fTurnOffAIMM)
						StartAimm(*pwparam == SES_USEAIMM12);
					}
					else if (!_fTurnOffUIM)			// Client doesn't want UIM?
						StartUIM();
				}
			}
						
			hr = S_OK;
			break;

		case EM_SETEDITSTYLE:
			if (*plparam & SES_USECTF)
			{
				if ((*pwparam & SES_USECTF))
				{
					if (!_fRE10Mode)
					{
						if (_fUsingAIMM)
							TurnOffAimm(TRUE);						
						
						// Turn on Cicero
						if (!_fUsingUIM)
							StartUIM();

						goto SKIP_AIMM;
					}
				}
				else
				{
					// Turn off Cicero
					_fTurnOffUIM = 1;					// Flag to ignore in EM_SETUIM
					if (_fUsingUIM)
						TurnOffUIM(TRUE);
				}
			}

			if ((*pwparam & SES_USEAIMM) && ((*plparam & SES_USEAIMM) || *plparam == 0))
			{
				if (_fUsingUIM)
						TurnOffUIM(TRUE);
					
				if (!_fUsingAIMM)
				{
					hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
					if (!(_lFEFlags & ES_NOIME))		// No IME style on?
						StartAimm(TRUE);
				}
			}
			else if ((*plparam & SES_USEAIMM))
			{
				_fTurnOffAIMM = 1;					// Flag to ignore in EM_SETUIM
				TurnOffAimm(TRUE);
			}

SKIP_AIMM:
			if ((*plparam == 0 || *plparam & SES_NOIME) && _hwnd)
			{
				if (*pwparam & SES_NOIME)
				{
					_fNoIme = 1;
					TurnOffUIM(TRUE);
					TurnOffAimm(TRUE);

					if (!_hIMCContext)
						_hIMCContext = ImmAssociateContext(_hwnd, NULL, _fUsingAIMM);	// turn off IME									
				}
				else if (*plparam & SES_NOIME)
				{
					_fNoIme = 0;
					if (_hIMCContext)
						ImmAssociateContext(_hwnd, _hIMCContext, _fUsingAIMM);			// turn on IME
					_hIMCContext = NULL;
				}
			}			

			if (*plparam & SES_CTFALLOWEMBED)
				_fAllowEmbedded = (*pwparam & SES_CTFALLOWEMBED) ? 1 : 0;

			if (*plparam & (SES_CTFALLOWSMARTTAG | SES_CTFALLOWPROOFING))
				HandleCTFService(*pwparam, *plparam);

			// remove settings that are handled.
			*pwparam &= ~(SES_NOIME | SES_USEAIMM | SES_USECTF | SES_CTFALLOWEMBED | SES_CTFALLOWSMARTTAG | SES_CTFALLOWPROOFING);
			*plparam &= ~(SES_NOIME | SES_USEAIMM | SES_USECTF | SES_CTFALLOWEMBED | SES_CTFALLOWSMARTTAG | SES_CTFALLOWPROOFING);

			// fall thru to return the edit style

		case EM_GETEDITSTYLE:
			if (_hIMCContext)
				*plres = SES_NOIME;			// IME has been turned off
			if (_fUsingAIMM)
				*plres |= SES_USEAIMM;		// AIMM is on
			if (_fUsingUIM)
				*plres |= SES_USECTF;		// Cicero is on

			// Cicero services
			if (_fAllowEmbedded)
				*plres |= SES_CTFALLOWEMBED;
			if (_fAllowSmartTag)
				*plres |= SES_CTFALLOWSMARTTAG;
			if (_fAllowProofing)
				*plres |= SES_CTFALLOWPROOFING;

			break;

		case EM_SETIMECOLOR:
			if (_fRE10Mode)
			{
				COMPCOLOR* pcrComp = GetIMECompAttributes();

				if (pcrComp)
				{
					memcpy(pcrComp, (const void *)(*plparam), sizeof(COMPCOLOR) * 4);
					*plres = 1;
				}
			}
			hr = S_OK;
			break;

		case EM_GETIMECOLOR:
			if (_fRE10Mode)
			{
				COMPCOLOR* pcrComp = GetIMECompAttributes();

				if (pcrComp)
				{
					memcpy((void *)(*plparam), pcrComp, sizeof(COMPCOLOR) * 4);
					*plres = 1;
				}
			}
			hr = S_OK;
			break;

		case EM_SETIMEMODEBIAS:
			OnSetIMEMode(*pwparam, *plparam);
				// following thru to return EM_GETIMEMODEBIAS
		case EM_GETIMEMODEBIAS:
			*plres = OnGetIMEMode();
			hr = S_OK;
			break;

		case EM_SETCTFMODEBIAS:
			OnSetUIMMode(*pwparam);
				// following thru to return EM_GETCTFMODEBIAS
		case EM_GETCTFMODEBIAS:
			*plres = OnGetUIMMode();
			hr = S_OK;
			break;

		case EM_SETCTFOPENSTATUS:
		case EM_GETCTFOPENSTATUS:
			*plres = 0;
			if (_pCUIM)
				*plres = _pCUIM->CTFOpenStatus(*pmsg == EM_GETCTFOPENSTATUS, *pwparam != 0);
			hr = S_OK;
			break;

		case EM_ISIME:
			*plres = CheckIMEType(NULL, 0);
			hr = S_OK;
			break;

		case EM_GETIMEPROPERTY:
			*plres = ImmGetProperty(GetKeyboardLayout(0x0FFFFFFFF), *pwparam, _fUsingAIMM);
			hr = S_OK;
			break;

		case EM_GETIMECOMPTEXT:
			*plres = OnGetIMECompText(*pwparam, *plparam);
			hr = S_OK;
			break;

		case WM_SIZE:
		case WM_MOVE:
			if (_pMsgCallBack)
				_pMsgCallBack->NotifyEvents(NE_LAYOUTCHANGE);
			break;

		case EM_GETOLEINTERFACE:
			if(*plparam && *pwparam == 0x0435446)		// 'CTF'
			{
				if (_pCUIM && _pCUIM->GetITfContext())
				{
					*(ITfContext **)(*plparam) = _pCUIM->GetITfContext();
					_pCUIM->GetITfContext()->AddRef();
				}
				else
					*(IUnknown **)(*plparam) = 0;
				
				*plres = TRUE;
				hr = S_OK;
			}
			break;

		default:
			if (*pmsg)
			{
				// Look for IME messages
				if (*pmsg == MSIMEReconvertMsg || *pmsg == MSIMEDocFeedMsg
					|| *pmsg == MSIMEQueryPositionMsg)
				{
					hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
					if (!(_lFEFlags & (ES_SELFIME | ES_NOIME)))
					{
						bReleaseSelction = GetTxSelection();
						if (_pTextSel)
						{
							if (*pmsg == MSIMEQueryPositionMsg)
								hr = OnIMEQueryPos(pmsg, pwparam, plparam, plres, TRUE);
							else
								hr = OnIMEReconvert(pmsg, pwparam, plparam, plres, TRUE);
						}
					}
				}

				if (_pCUIM && _pCUIM->_fMosueSink && 
					(IN_RANGE(WM_MOUSEFIRST, *pmsg, WM_MBUTTONDBLCLK) || *pmsg == WM_SETCURSOR))
				{
					bReleaseSelction = GetTxSelection();

					if (_pTextSel)
						hr = _pCUIM->MouseCheck(pmsg, pwparam, plparam, plres);
				}
			}
			break;
	}

Exit:
	// Release Selection if we get it for this message
	if (bReleaseSelction && _pTextSel)
	{
		_pTextSel->Release();
		_pTextSel = NULL;
	}

	// Return the value that will cause message to be processed normally
	return hr;
}

/*
 *	HRESULT CTextMsgFilter::AttachMsgFilter(ITextMsgFilter *)
 *
 *	@mfunc
 *		Add another message filter to the chain
 *
 *	@rdesc
 *		NOERROR if added
 */
HRESULT STDMETHODCALLTYPE CTextMsgFilter::AttachMsgFilter( ITextMsgFilter *pMsgFilter)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::AttachMsgFilter");

	HRESULT hr = NOERROR;
	if (_pFilter)
		hr = _pFilter->AttachMsgFilter( pMsgFilter );
	else
	{
		_pFilter = pMsgFilter;
		_pFilter->AddRef();
	}
	return hr;
}

/*
 *	HRESULT CTextMsgFilter::OnWMChar(UINT *, WPARAM *, LPARAM *, LRESULT *)
 *
 *	@mfunc
 *		Handle WM_CHAR message - look for Japanese keyboard with Kana key on
 *		Convert the SB Kana to Unicode if needed.
 *
 *	@rdesc
 *		S_FALSE so caller will handle the modified character in wparam
 */
HRESULT CTextMsgFilter::OnWMChar( 
		UINT *		pmsg,
        WPARAM *	pwparam,
		LPARAM *	plparam,
		LRESULT *	plres)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::OnWMChar");

	// For Japanese keyboard, if Kana mode is on,
	// Kana characters (single byte Japanese chars) are coming in via WM_CHAR.
	if ( GetKeyState(VK_KANA) & 0x1 )
	{
		_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);

		if (_uKeyBoardCodePage == CP_JAPAN)
		{
			// check if this is a single byte character.
 			TCHAR	unicodeConvert;
			BYTE	bytes[2];
			bytes[0] = (BYTE)(*pwparam >> 8);	// Interchange DBCS bytes in endian
			bytes[1] = (BYTE)*pwparam;			// independent fashion (use byte array)

			if (!bytes[0])
			{
				if(UnicodeFromMbcs((LPWSTR)&unicodeConvert, 1, 
					(LPCSTR)&bytes[1], 1, _uKeyBoardCodePage) == 1)
					*pwparam = unicodeConvert;
			}
			
			return InputFEChar(*pwparam);
		}
	}

	return S_FALSE;
}

/*
 *	HRESULT CTextMsgFilter::OnWMIMEChar(UINT *, WPARAM *, LPARAM *, LRESULT *)
 *
 *	@mfunc
 *		Handle WM_IMECHAR message - convert the character to unicode.
 *
 *	@rdesc
 *		S_OK - caller to ignore the message
 *		S_FALSE - caller to handle the message.  wparam may contains a new char
 */
HRESULT CTextMsgFilter::OnWMIMEChar( 
		UINT *		pmsg,
        WPARAM *	pwparam,
		LPARAM *	plparam,
		LRESULT *	plres)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::OnWMIMEChar");

	TCHAR	unicodeConvert;
	BYTE	bytes[2];

	// We may receive IMECHAR even if we have handled the composition char already.
	// This is the case when the host does not call the DefWinProc with the composition
	// bit masked off.  So, we need to ignore this message to avoid double entry.
	if (IsIMEComposition() && _ime->IgnoreIMECharMsg())
	{
		_ime->SkipIMECharMsg();		// Skip this ime char msg
		return S_OK;	
	}

	if (_fUnicodeWindow && !W32->OnWin9x())
		return S_FALSE;

	bytes[0] = *pwparam >> 8;		// Interchange DBCS bytes in endian
	bytes[1] = *pwparam;			// independent fashion (use byte array)
	
	// need to convert both single-byte KANA and DBC
	if (!bytes[0] || GetTrailBytesCount(bytes[0], _uKeyBoardCodePage))
	{
		if( UnicodeFromMbcs((LPWSTR)&unicodeConvert, 1, 
			bytes[0] == 0 ? (LPCSTR)&bytes[1] : (LPCSTR)bytes,
			bytes[0] == 0 ? 1 : 2,
			_uKeyBoardCodePage) == 1 )
			*pwparam = unicodeConvert;

		return InputFEChar(*pwparam);
	}

	return S_FALSE;
}

/*
 *	HRESULT CTextMsgFilter::OnIMEReconvert(UINT *, WPARAM *, LPARAM *, LRESULT *)
 *
 *	@mfunc
 *		Handle IME Reconversion and Document feed. We only handle Unicode messages.
 *		We use a limit of MAX_RECONVERSION_SIZE(100) characters in both cases.
 *
 *	@rdesc
 *		S_OK		if we have handled the message
 */
HRESULT CTextMsgFilter::OnIMEReconvert( 
		UINT *		pmsg,
        WPARAM *	pwparam,
		LPARAM *	plparam,
		LRESULT *	plres,
		BOOL		fUnicode)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::OnIMEReconvert");

	HRESULT		hr = S_OK;
	LPRECONVERTSTRING lpRCS = (LPRECONVERTSTRING)(*plparam);
	long		cbStringSize;
	long		cpMin, cpMax;
	long		cpParaStart, cpParaEnd;
	HRESULT		hResult;
	ITextRange *pTextRange, *pTempTextRange;
	long		cbAdded;				
	BOOL		bDocumentFeed;
	long		cLastChar;
	BOOL		fAdjustedRange = FALSE;

	*plres = 0;

	// NT doesn't support Ansi window when the CP_ACP isn't the same
	// as keyboard codepage.
	if (!fUnicode && !(W32->OnWin9x()) && _uKeyBoardCodePage != _uSystemCodePage)
		return S_OK;

	bDocumentFeed = (MSIMEDocFeedMsg && *pmsg == MSIMEDocFeedMsg)
					|| (*pmsg == WM_IME_REQUEST && *pwparam == IMR_DOCUMENTFEED);

	if (bDocumentFeed && IsIMEComposition() && _ime->GetIMELevel() == IME_LEVEL_3)
	{
		// Composition in progress, use composition string as selection
		cpMin = ((CIme_Lev3 *)_ime)->GetIMECompositionStart();
		cpMax = ((CIme_Lev3 *)_ime)->GetIMECompositionLen() + cpMin;
	}
	else
	{
		// Get current selection
		hResult	= _pTextSel->GetStart(&cpMin);
		hResult	= _pTextSel->GetEnd(&cpMax);
	}

	// Expand to include the current paragraph
	hResult = _pTextDoc->Range(cpMin, cpMax, &pTextRange);
	Assert (pTextRange != NULL);
	if (hResult != NOERROR)
		return S_OK;

	hResult = pTextRange->Expand(tomParagraph, &cbAdded);

	// Fail to get Paragraph, get the story
	// Note:- Expand will return S_FALSE for plain text when
	// the whole story is selected
	if (hResult != NOERROR)		
		hResult = pTextRange->Expand(tomStory, &cbAdded);

	hResult = pTextRange->GetStart(&cpParaStart);
	hResult = pTextRange->GetEnd(&cpParaEnd);

	if (*pwparam == IMR_CONFIRMRECONVERTSTRING)
	{
		*plres = CheckIMEChange(lpRCS, cpParaStart, cpParaEnd, cpMin, cpMax, fUnicode);		
		goto Exit;
	}
		
	// Initialize to hugh number
	_cpReconvertStart = tomForward;

	// Check if Par included	
	hResult = _pTextDoc->Range(cpParaEnd-1, cpParaEnd, &pTempTextRange);
	if (hResult != NOERROR)
		goto Exit;
	Assert (pTempTextRange != NULL);

	hResult	= pTempTextRange->GetChar(&cLastChar);
	pTempTextRange->Release();

	if (hResult == NOERROR && (WCHAR)cLastChar == CR)
	{
		if (cpMax == cpParaEnd)
		{								
			// Par is selected, change selection to exclude the par char
			cpMax--;
			_pTextSel->SetEnd(cpMax);

			if (cpMin > cpMax)
			{
				// Adjust cpMin as well
				cpMin = cpMax;
				_pTextSel->SetStart(cpMin);
			}
		}

		// Get rid of par char 
		cpParaEnd--;
		fAdjustedRange = TRUE;
	}

	// Check for MAX_RECONVERSION_SIZE since we don't want to pass a hugh buffer
	// to IME
	long	cchSelected;

	cchSelected = cpMax - cpMin;
	if (cpParaEnd - cpParaStart > MAX_RECONVERSION_SIZE)
	{
		// Too many character selected, forget it
		if (cchSelected > MAX_RECONVERSION_SIZE)
			goto Exit;

		if (cchSelected == MAX_RECONVERSION_SIZE)
		{
			// Selection reaches the limit
			cpParaStart = cpMin;
			cpParaEnd = cpMax;
		}
		else
		{
			long	cchBeforeSelection = cpMin - cpParaStart;
			long	cchAfterSelection = cpParaEnd - cpMax;
			long	cchNeeded = MAX_RECONVERSION_SIZE - cchSelected;
			
			if (cchBeforeSelection < cchNeeded/2)
			{
				// Put in all characters from the Par start
				// and move Par end
				cpParaEnd = cpParaStart + MAX_RECONVERSION_SIZE - 1;
			}
			else if (cchAfterSelection < cchNeeded/2)
			{
				// Put in all character to the Par end
				// and move Par start
				cpParaStart = cpParaEnd - MAX_RECONVERSION_SIZE + 1;

			}
			else
			{
				// Adjust both end
				cpParaStart = cpMin - cchNeeded/2;
				cpParaEnd = cpParaStart + MAX_RECONVERSION_SIZE - 1;
			}
		}
		fAdjustedRange = TRUE;
	}

	if (fAdjustedRange)
	{
		// Adjust the text range
		hResult	= pTextRange->SetRange(cpParaStart, cpParaEnd);
		
		if (hResult != NOERROR)
			goto Exit;
	}

	cbStringSize = (cpParaEnd - cpParaStart) * 2;

	// No char in current par, forget it.
	if (cbStringSize <= 0)
		goto Exit;

	if (EM_RECONVERSION == *pmsg)
	{
		// RE reconversion msg, allocate the Reconversion buffer
		lpRCS = (LPRECONVERTSTRING) PvAlloc(sizeof(RECONVERTSTRING) + cbStringSize + 2, GMEM_ZEROINIT);
		Assert(lpRCS != NULL);

		if (lpRCS)
			lpRCS->dwSize = sizeof(RECONVERTSTRING) + cbStringSize + 2;
	}

	if (lpRCS)
	{
		BSTR		bstr = NULL;
		LPSTR		lpReconvertBuff;

		hResult = pTextRange->GetText(&bstr);

		if (hResult != NOERROR || bstr == NULL)
		{
			if (EM_RECONVERSION == *pmsg)
				FreePv(lpRCS);
			goto Exit;						// forget it		
		}
		
		if (lpRCS->dwSize - sizeof(RECONVERTSTRING) - 2 < (DWORD)cbStringSize)
			cbStringSize = lpRCS->dwSize - sizeof(RECONVERTSTRING) - 2;
		
		lpReconvertBuff = (LPSTR)(lpRCS) + sizeof(RECONVERTSTRING);

		if (fUnicode)
		{
			// fill in the buffer
			memcpy(lpReconvertBuff, (LPSTR)bstr, cbStringSize);

			*(lpReconvertBuff+cbStringSize) = '\0';
			*(lpReconvertBuff+cbStringSize+1) = '\0';
			
			lpRCS->dwStrLen = (cpParaEnd - cpParaStart);					
			lpRCS->dwCompStrLen = (cpMax - cpMin);
			lpRCS->dwCompStrOffset = (cpMin - cpParaStart)*2;	// byte offset from beginning of string
		}
		else
		{
			// Ansi case, need to find byte offset and Ansi string
			long	cch = WideCharToMultiByte(_uKeyBoardCodePage, 0, bstr, -1, lpReconvertBuff, cbStringSize+1, NULL, NULL);
			Assert (cch > 0);
			if (cch > 0)
			{
				CTempCharBuf tcb;
				char *psz = tcb.GetBuf(cch);

				if (!psz)			// No memory
					goto CleanUp;	//	forget it.

				if (cch > 1 && lpReconvertBuff[cch-1] == '\0')
					cch--;			// Get rid of the null char

				int cpOffset = cpMin - cpParaStart;

				Assert(cpOffset >= 0);
				lpRCS->dwStrLen = cch;
				lpRCS->dwCompStrOffset = WideCharToMultiByte(_uKeyBoardCodePage, 0, 
					bstr, cpOffset, psz, cch, NULL, NULL);

				lpRCS->dwCompStrLen = 0;
				if (cpMax > cpMin)				
					lpRCS->dwCompStrLen = WideCharToMultiByte(_uKeyBoardCodePage, 0, 
						bstr+cpOffset, cpMax - cpMin, psz, cch, NULL, NULL);				
			}
			else
			{
CleanUp:
				SysFreeString (bstr);
				if (EM_RECONVERSION == *pmsg)
					FreePv(lpRCS);
				goto Exit;						// forget it
			}
		}

		// Fill in the rest of the RCS struct
		lpRCS->dwVersion = 0;		
		lpRCS->dwStrOffset = sizeof(RECONVERTSTRING);		// byte offset from beginning of struct		
		lpRCS->dwTargetStrLen = lpRCS->dwCompStrLen;
		lpRCS->dwTargetStrOffset = lpRCS->dwCompStrOffset;
		
		*plres = sizeof(RECONVERTSTRING) + cbStringSize + 2;

		// Save this for the CONFIRMRECONVERTSTRING handling
		_cpReconvertStart = cpParaStart;
		_cpReconvertEnd = cpParaEnd;
		
		SysFreeString (bstr);

		if (EM_RECONVERSION == *pmsg)
		{
			HIMC	hIMC = LocalGetImmContext(*this);

			if (hIMC)
			{
				DWORD imeProperties = ImmGetProperty(GetKeyboardLayout(0x0FFFFFFFF), IGP_SETCOMPSTR, _fUsingAIMM);

				if ((imeProperties & (SCS_CAP_SETRECONVERTSTRING | SCS_CAP_MAKEREAD))
					== (SCS_CAP_SETRECONVERTSTRING | SCS_CAP_MAKEREAD))
				{
					if (ImmSetCompositionStringW(hIMC, SCS_QUERYRECONVERTSTRING, lpRCS, *plres, NULL, 0, _fUsingAIMM))
					{
						// Check if there is any change in selection
						CheckIMEChange(lpRCS, cpParaStart, cpParaEnd, cpMin, cpMax, TRUE);
						ImmSetCompositionStringW(hIMC, SCS_SETRECONVERTSTRING, lpRCS, *plres, NULL, 0, _fUsingAIMM);
					}
				}
				LocalReleaseImmContext(*this, hIMC);
			}

			FreePv(lpRCS);
		}
	}
	else
	{
		// return size for IME to allocate the buffer
		*plres = sizeof(RECONVERTSTRING) + cbStringSize + 2;	
	}

Exit:
	pTextRange->Release();

	return hr;
}

/* 
 *  BOOL  CTextMsgFilter::CheckIMEChange(LPRECONVERTSTRING,long,long,long,long)
 *
 *	@mfunc
 *	 	Verify if IME wants to re-adjust the selection
 *
 *	@rdesc
 *		TRUE - allow IME to change the selection
 */
BOOL  CTextMsgFilter::CheckIMEChange(
	LPRECONVERTSTRING	lpRCS,
	long				cpParaStart, 
	long				cpParaEnd,
	long				cpMin,
	long				cpMax,
	BOOL				fUnicode)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::CheckIMEChange");

	long		cpImeSelectStart = 0;
	long		cpImeSelectEnd = 0;
	HRESULT		hResult;	

	if (!lpRCS || _cpReconvertStart == tomForward)
		// Never initialize, forget it
		return FALSE;

	if (fUnicode)
	{
		cpImeSelectStart = _cpReconvertStart + lpRCS->dwCompStrOffset / 2;
		cpImeSelectEnd = cpImeSelectStart + lpRCS->dwCompStrLen;
	}
	else
	{
		// Need to convert the byte offset to char offset.
		ITextRange *pTextRange;
		BSTR		bstr = NULL;

		hResult = _pTextDoc->Range(_cpReconvertStart, _cpReconvertEnd, &pTextRange);
		if (hResult != NOERROR)
			return FALSE;
				
		// Get the text
		hResult = pTextRange->GetText(&bstr);

		if (hResult == S_OK)
		{
			long	cchReconvert = _cpReconvertEnd - _cpReconvertStart + 1;
			CTempCharBuf tcb;
			char *psz = tcb.GetBuf((cchReconvert)*2);

			hResult = S_FALSE;
			if (psz)
			{
				long cch = WideCharToMultiByte(_uKeyBoardCodePage, 0, 
					bstr, -1, psz, (cchReconvert)*2, NULL, NULL);

				if (cch > 0)
				{
					long dwCompStrOffset, dwCompStrLen;
					CTempWcharBuf	twcb;
					WCHAR			*pwsz = twcb.GetBuf(cchReconvert);

					if (pwsz)
					{
						dwCompStrOffset = MultiByteToWideChar(_uKeyBoardCodePage, 0, 
							psz, lpRCS->dwCompStrOffset, pwsz, cchReconvert);

						dwCompStrLen = MultiByteToWideChar(_uKeyBoardCodePage, 0, 
							psz+lpRCS->dwCompStrOffset, lpRCS->dwCompStrLen, pwsz, cchReconvert);

						Assert(dwCompStrOffset > 0 || dwCompStrLen > 0);

						cpImeSelectStart = _cpReconvertStart + dwCompStrOffset;
						cpImeSelectEnd = cpImeSelectStart + dwCompStrLen;
						hResult = S_OK;
					}
				}
			}
		}

		if (bstr)
			SysFreeString (bstr);
			
		pTextRange->Release();

		if (hResult != S_OK)
			return FALSE;
	}

	if (cpParaStart <= cpImeSelectStart && cpImeSelectEnd <= cpParaEnd)
	{
		if (_pTextSel && (cpImeSelectStart != cpMin || cpImeSelectEnd != cpMax))
		{
			// IME changes selection.
			hResult	= _pTextSel->SetRange(cpImeSelectStart, cpImeSelectEnd);

			if (hResult != NOERROR)
				return FALSE;
		}
		return TRUE;		// Allow Ime to change selection
	}

	return FALSE;
}

/* 
 *  BOOL  CTextMsgFilter::GetTxSelection()
 *
 *	@mfunc
 *	 	Get Selection if we haven't got it before
 *
 *	@rdesc
 *		TRUE if this is first time getting the selection
 *		FALSE if it is already exist or no selection available.
 */
BOOL  CTextMsgFilter::GetTxSelection()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::GetTxSelection");

	HRESULT hResult;

	if (_pTextSel)
		return FALSE;					// Already there

	hResult = _pTextDoc->GetSelectionEx(&_pTextSel);

	return _pTextSel ? TRUE : FALSE;
}

/*
 *	HRESULT CTextMsgFilter::OnIMEQueryPos(UINT *, WPARAM *, LPARAM *, LRESULT *, BOOL)
 *
 *	@mfunc
 *		Fill in the current character size and window rect. size.  
 *
 *	@rdesc
 *		S_OK
 *		*plres = 0 if we do not filled in data
 */
HRESULT CTextMsgFilter::OnIMEQueryPos( 
		UINT *		pmsg,
        WPARAM *	pwparam,
		LPARAM *	plparam,
		LRESULT *	plres,
		BOOL		fUnicode)		
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::OnIMEQueryPos");

	HRESULT				hResult;
	PIMECHARPOSITION	pIMECharPos = (PIMECHARPOSITION)*plparam;
	long				cpRequest;
	RECT				rcArea;
	ITextRange			*pTextRange = NULL;
	POINT				ptTopPos, ptBottomPos = {0, 0};
	bool				fGetBottomPosFail = false;

	if (pIMECharPos->dwSize != sizeof(IMECHARPOSITION))
		goto Exit;

	// NT doesn't support Ansi window when the CP_ACP isn't the same
	// as keyboard codepage.
	if (!fUnicode && !(W32->OnWin9x()) && _uKeyBoardCodePage != _uSystemCodePage)
		goto Exit;

	if (IsIMEComposition() && _ime->GetIMELevel() == IME_LEVEL_3)
	{
		cpRequest = ((CIme_Lev3 *)_ime)->GetIMECompositionStart();
		if (fUnicode)
			cpRequest += pIMECharPos->dwCharPos;
		else if (pIMECharPos->dwCharPos > 0)
		{
			// Need to convert pIMECharPos->dwCharPos from Acp to Cp
			long	cchComp = ((CIme_Lev3 *)_ime)->GetIMECompositionLen();
			long	cchAcp = (long)(pIMECharPos->dwCharPos);
			BSTR	bstr;
			WCHAR	*pChar;

			if (cchComp)
			{
				hResult = _pTextDoc->Range(cpRequest, cpRequest+cchComp, &pTextRange);
				
				Assert (pTextRange != NULL);				
				if (hResult != NOERROR || !pTextRange)
					goto Exit;
				
				hResult = pTextRange->GetText(&bstr);
				if (hResult != NOERROR )
					goto Exit;

				// The algorithm assumes that for a DBCS charset any character
				// above 128 has two bytes, except for the halfwidth KataKana,
				// which are single bytes in ShiftJis.
				pChar = (WCHAR *)bstr;
				Assert (pChar);

				while (cchAcp > 0 && cchComp > 0)
				{
					cchAcp--;
					if(*pChar >= 128 && (CP_JAPAN != _uKeyBoardCodePage ||
						!IN_RANGE(0xFF61, *pChar, 0xFF9F)))
						cchAcp--;

					pChar++;
					cchComp--;
					cpRequest++;
				}

				SysFreeString (bstr);
				pTextRange->Release();
				pTextRange = NULL;
			}
		}
	}
	else if (pIMECharPos->dwCharPos == 0)
	{
		// Get current selection
		hResult	= _pTextSel->GetStart(&cpRequest);
		if (hResult != NOERROR)
			goto Exit;
	}
	else
		goto Exit;

	// Get requested cp location in screen coordinates
	hResult = _pTextDoc->Range(cpRequest, cpRequest+1, &pTextRange);
	Assert (pTextRange != NULL);	
	if (hResult != NOERROR || !pTextRange)
		goto Exit;

	long lTextFlow;	
	long lTopType;
	long lBottomType;

	lTextFlow = _lFEFlags & tomTextFlowMask;	
	lTopType = tomStart+TA_TOP+TA_LEFT;
	lBottomType = tomStart+TA_BOTTOM+TA_LEFT;
	
	if (lTextFlow == tomTextFlowWN)
	{
		lTopType = tomStart+TA_TOP+TA_RIGHT;
		lBottomType = tomStart+TA_BOTTOM+TA_RIGHT	;
	}

	hResult = pTextRange->GetPoint( lTopType,
			&(ptTopPos.x), &(ptTopPos.y) );

	if (hResult != NOERROR)
	{
		// Scroll and try again
		hResult = pTextRange->ScrollIntoView(tomStart);
		if (hResult == NOERROR)
			hResult = pTextRange->GetPoint( lTopType,
				&(ptTopPos.x), &(ptTopPos.y) );
	}

	if (hResult == NOERROR)
	{
		hResult = pTextRange->GetPoint( lBottomType,
				&(ptBottomPos.x), &(ptBottomPos.y) );
		if (hResult != NOERROR)
			fGetBottomPosFail = true;
	}

	pIMECharPos->pt = ptTopPos;

	// Get application rect in screen coordinates
	hResult = _pTextDoc->GetClientRect(tomIncludeInset,
				&(rcArea.left), &(rcArea.top),
				&(rcArea.right), &(rcArea.bottom));	

	if (hResult != NOERROR)
		goto Exit;

	// Get line height in pixel
	if (fGetBottomPosFail)
		pIMECharPos->cLineHeight = rcArea.bottom - ptTopPos.y;
	else
	{
		if (lTextFlow == tomTextFlowSW || lTextFlow == tomTextFlowNE)
			pIMECharPos->cLineHeight = abs(ptTopPos.x - ptBottomPos.x);			
		else
			pIMECharPos->cLineHeight = abs(ptBottomPos.y - ptTopPos.y);

		if (lTextFlow == tomTextFlowWN)
			pIMECharPos->pt = ptBottomPos;
	}

	pIMECharPos->rcDocument = rcArea;

	*plres = TRUE;

Exit:
	if (pTextRange)
		pTextRange->Release();

	return S_OK;
}

/*
 *	CTextMsgFilter::CheckIMEType(HKL hKL, DWORD dwFlags)
 *
 *	@mfunc
 *		Check for FE IME keyboard and/or MSIME98 or later
 *
 *	@rdesc
 *		TRUE if FE IME keyboard
 */
BOOL CTextMsgFilter::CheckIMEType(
	HKL		hKL,
	DWORD	dwFlags)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::CheckIMEType");

	BOOL	fFEKeyboard = FALSE;
	
	if (!hKL)
		hKL = GetKeyboardLayout(0x0FFFFFFFF);				// Get default HKL if caller pass in NULL

	// initialize to non MS IME
	if (dwFlags & CHECK_IME_SERVICE)		// Check MSIME98?
		_fMSIME	= 0;

	if (IsFELCID((WORD)hKL) && ImmIsIME(hKL, _fUsingAIMM))
	{
		fFEKeyboard = TRUE;

		if (dwFlags & CHECK_IME_SERVICE)		// Check MSIME98?
		{
			if (MSIMEServiceMsg && IMEMessage( *this, MSIMEServiceMsg, 0, 0, FALSE ))
				_fMSIME = 1;
		}
	}
	return fFEKeyboard;
}

/*
 *	CTextMsgFilter::InputFEChar(WCHAR	wchFEChar)
 *
 *	@mfunc
 *		Input the FE character and ensure we have a correct font.
 *
 *	@rdesc
 *		S_OK if handled
 */
HRESULT CTextMsgFilter::InputFEChar(
	WCHAR	wchFEChar)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::InputFEChar");

	BOOL	bReleaseSelction = GetTxSelection();
	long	cchExced;
	HRESULT	hr = S_FALSE;
	
	if (wchFEChar > 256 
		&& _pTextSel->CanEdit(NULL) == NOERROR
		&& _pTextDoc->CheckTextLimit(1, &cchExced) == NOERROR
		&& cchExced == 0)
	{
		// setup FE font to handle the FE character
		long		cpMin, cpMax;
		TCHAR		wchFE[2];
		BOOL		fSelect = FALSE;
		ITextRange	*pTextRange = NULL;
		ITextFont	*pTextFont = NULL;
		ITextFont	*pFEFont = NULL;
		HRESULT		hResult = S_FALSE;
		BSTR		bstr = NULL;

		// Inform client IME compostion is on to by-pass some font setting
		// problem in Arabic systems
		_pTextDoc->IMEInProgress(tomTrue);

		wchFE[0] = wchFEChar;
		wchFE[1] = L'\0';				
		
		_pTextSel->GetStart(&cpMin);
		_pTextSel->GetEnd(&cpMax);
		
		// For selection case, we want font to the right of first character
		if (cpMin != cpMax)
		{
			hResult = _pTextDoc->Range(cpMin, cpMin, &pTextRange);
			if (hResult != S_OK)
				goto ERROR_EXIT;

			hResult = pTextRange->GetFont(&pTextFont);

			cpMin++;
			fSelect = TRUE;
		}
		else
			hResult = _pTextSel->GetFont(&pTextFont);

		// Get a duplicate font and setup the correct FE font
		hResult = pTextFont->GetDuplicate(&pFEFont);

		if (hResult != S_OK)
			goto ERROR_EXIT;				

		CIme::CheckKeyboardFontMatching (cpMin, this, pFEFont);
		
		if (fSelect)
			_pTextSel->SetText(NULL);		// Delete the selection

		bstr = SysAllocString(wchFE);
		if (!bstr)
		{
			hResult = E_OUTOFMEMORY;
			goto ERROR_EXIT;				
		}

		_pTextSel->SetFont(pFEFont);		// Setup FE font
		_pTextSel->TypeText(bstr);			// Input the new FE character
					
ERROR_EXIT:
		if (hResult == S_OK)
			hr = S_OK;

		if (pFEFont)
			pFEFont->Release();

		if (pTextFont)
			pTextFont->Release();

		if (pTextRange)
			pTextRange->Release();

		if (bstr)
			SysFreeString(bstr);

		// Inform client IME compostion is done
		_pTextDoc->IMEInProgress(tomFalse);
	}


	if (bReleaseSelction && _pTextSel)
	{
		_pTextSel->Release();
		_pTextSel = NULL;
	}

	return hr;
}

/*
 *	CTextMsgFilter::OnSetFocus()
 *
 *	@mfunc
 *		Restore the previous keyboard if we are in FORCEREMEMBER mode.  
 *		Otherwise, setup the FE keyboard.
 *		
 */
void CTextMsgFilter::OnSetFocus()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::OnSetFocus");

	if (_fUsingUIM && _pCUIM)
	{
		_pCUIM->OnSetFocus();
	}
	else if (_fForceRemember && _fIMEHKL)
	{
		// Restore previous keyboard
		ActivateKeyboardLayout(_fIMEHKL, 0);
		if (IsFELCID((WORD)_fIMEHKL))
		{
			// Set Open status and Conversion mode
			HIMC	hIMC = LocalGetImmContext(*this);
			if (hIMC)
			{
				if (ImmSetOpenStatus(hIMC, _fIMEEnable, _fUsingAIMM) && _fIMEEnable)
					ImmSetConversionStatus(hIMC, _fIMEConversion, _fIMESentence, _fUsingAIMM); // Set conversion status

				LocalReleaseImmContext(*this, hIMC);
			}			
		}
	}
	else
		SetupIMEOptions();

	if (_nIMEMode)
		SetIMESentenseMode(TRUE);
}

/*
 *	CTextMsgFilter::OnKillFocus()
 *
 *	@mfunc
 *		If we are in FORCE_REMEMBER mode, save the current keyboard
 *	and conversion setting.
 *		
 */
void CTextMsgFilter::OnKillFocus()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::OnKillFocus");

	// Windowless mode, need to inform Cicero
	if (!_hwnd && _fUsingUIM && _pCUIM)
		_pCUIM->OnSetFocus(FALSE);

	if (_fForceRemember)
	{
		// Get current keyboard
		_fIMEHKL = GetKeyboardLayout(0x0FFFFFFFF);

		if (IsFELCID((WORD)_fIMEHKL))
		{
			// Get Open status
			HIMC	hIMC = LocalGetImmContext(*this);
			if (hIMC)
			{
				_fIMEEnable = ImmGetOpenStatus(hIMC, _fUsingAIMM);

				if (_fIMEEnable)					
					ImmGetConversionStatus(hIMC, &_fIMEConversion, &_fIMESentence, _fUsingAIMM); // get conversion status

				LocalReleaseImmContext(*this, hIMC);
			}			
		}
	}
	if (_nIMEMode)
		SetIMESentenseMode(FALSE);
}

/*
 *	CTextMsgFilter::OnSetIMEOptions(WPARAM wparam, LPARAM lparam)
 *
 *	@mfunc
 *	
 *	@rdesc
 */
LRESULT CTextMsgFilter::OnSetIMEOptions(
	WPARAM	wparam,
	LPARAM	lparam)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::OnSetIMEOptions");

	LRESULT lIMEOptionCurrent = OnGetIMEOptions();
	LRESULT lIMEOptionNew = 0;

	// Mask off bits that we will support for now
	lparam &= (IMF_FORCEACTIVE | IMF_FORCEENABLE | IMF_FORCEREMEMBER);

	switch(wparam)
	{
	case ECOOP_SET:
		lIMEOptionNew = lparam;
		break;

	case ECOOP_OR:
		lIMEOptionNew = lIMEOptionCurrent | lparam;
		break;

	case ECOOP_AND:
		lIMEOptionNew = lIMEOptionCurrent & lparam;
		break;

	case ECOOP_XOR:
		lIMEOptionNew = lIMEOptionCurrent ^ lparam;
		break;

	default:
		return 0;		// Bad option
	}

	if (lIMEOptionNew == lIMEOptionCurrent)			// Nothing change
		return 1;

	_fForceActivate = FALSE;
	if (lIMEOptionNew & IMF_FORCEACTIVE)
		_fForceActivate = TRUE;

	_fForceEnable = FALSE;
	if (lIMEOptionNew & IMF_FORCEENABLE)
		_fForceEnable = TRUE;
	
	_fForceRemember = FALSE;
	if (lIMEOptionNew & IMF_FORCEREMEMBER)
		_fForceRemember = TRUE;

	SetupIMEOptions();

	return 1;
}

/*
 *	CTextMsgFilter::OnGetIMEOptions()
 *
 *	@mfunc
 *	
 *	@rdesc
 */
LRESULT CTextMsgFilter::OnGetIMEOptions()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::OnGetIMEOptions");

	LRESULT		lres = 0;

	if (_fForceActivate)
		lres |= IMF_FORCEACTIVE;		

	if (_fForceEnable)
		lres |= IMF_FORCEENABLE;

	if (_fForceRemember)
		lres |= IMF_FORCEREMEMBER;

	return lres;
}

/*
 *	CTextMsgFilter::SetupIMEOptions()
 *
 *	@mfunc
 *	
 */
void CTextMsgFilter::SetupIMEOptions()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::SetupIMEOptions");

	if (!_hwnd)
		return;

	_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);	

	if (_fForceEnable)
	{		
		LONG	cpgLocale = GetACP();
		INT		iCharRep = CharRepFromCodePage(cpgLocale);

		if (W32->IsFECodePage(cpgLocale))
		{
			if (_uKeyBoardCodePage != (UINT)cpgLocale)
				W32->CheckChangeKeyboardLayout(iCharRep);

			HIMC	hIMC = LocalGetImmContext(*this);

			if (hIMC)
			{
				if (ImmSetOpenStatus(hIMC, TRUE, _fUsingAIMM) && _fForceActivate)
				{
					// Activate native input mode
					DWORD	dwConversion;
					DWORD	dwSentence;

					if (ImmGetConversionStatus(hIMC, &dwConversion, &dwSentence, _fUsingAIMM))
					{
						dwConversion |= IME_CMODE_NATIVE;
						if (iCharRep == SHIFTJIS_INDEX)
							dwConversion |= IME_CMODE_FULLSHAPE;
						ImmSetConversionStatus(hIMC, dwConversion, dwSentence, _fUsingAIMM);
					}
				}
				LocalReleaseImmContext(*this, hIMC);
			}			
		}
	}
}

/*
 *	CTextMsgFilter::OnSetIMEMode(WPARAM wparam, LPARAM lparam)
 *
 *	@mfunc
 *		Handle EM_SETIMEMODE message to setup or clear the IMF_SMODE_PHRASEPREDICT mode
 *
 */
void CTextMsgFilter::OnSetIMEMode(
	WPARAM	wparam,
	LPARAM	lparam)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::OnSetIMEMode");

	BOOL	fNotifyUIM = FALSE;

	if (!(lparam & (IMF_SMODE_PLAURALCLAUSE | IMF_SMODE_NONE)))		// Only IMF_SMODE_PHRASEPREDICT for now	
		return;										//	Bad mask option

	if ((wparam & (IMF_SMODE_PLAURALCLAUSE | IMF_SMODE_NONE)) == _nIMEMode)	// Nothing change...
		return;														//	Done.

	_nIMEMode = wparam & (IMF_SMODE_PLAURALCLAUSE | IMF_SMODE_NONE);

	if (_hwnd && GetFocus() == _hwnd)
		SetIMESentenseMode(_nIMEMode);

	// Setup UIM mode bias
	if (_nIMEMode)
	{
		if (_nIMEMode == IMF_SMODE_PLAURALCLAUSE && _wUIMModeBias != CTFMODEBIAS_NAME)
		{
			_wUIMModeBias = CTFMODEBIAS_NAME;
			fNotifyUIM = TRUE;
		}
		else if (_nIMEMode == IMF_SMODE_NONE && _wUIMModeBias != CTFMODEBIAS_DEFAULT)
		{
			_wUIMModeBias = CTFMODEBIAS_DEFAULT;
			fNotifyUIM = TRUE;
		}
	}
	else
	{
		_wUIMModeBias = 0;
		fNotifyUIM = TRUE;
	}

	if (fNotifyUIM && _pMsgCallBack)
		_pMsgCallBack->NotifyEvents(NE_MODEBIASCHANGE);
}

/*
 *	CTextMsgFilter::SetIMESentenseMode()
 *
 *	@mfunc
 *		Setup phrase mode or restore previous sentence mode
 */
void CTextMsgFilter::SetIMESentenseMode(
	BOOL	fSetup,
	HKL		hKL)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::SetIMESentenseMode");

	if (_hwnd && CheckIMEType(hKL, 0) &&		// FE IME Keyboard?
		(fSetup || _fRestoreOLDIME))
	{
		HIMC	hIMC = LocalGetImmContext(*this);

		if (hIMC)
		{
			DWORD	dwConversion;
			DWORD	dwSentence;

			if (ImmGetConversionStatus(hIMC, &dwConversion, &dwSentence, _fUsingAIMM))
			{
				if (fSetup)
				{
					if (!_fRestoreOLDIME)
					{
						// Setup IME Mode
						_wOldIMESentence = dwSentence & 0x0FFFF;
						_fRestoreOLDIME = 1;
					}
					dwSentence &= 0x0FFFF0000;
					if (_nIMEMode == IMF_SMODE_PLAURALCLAUSE)
						dwSentence |= IME_SMODE_PLAURALCLAUSE;
					else
						dwSentence |= IME_SMODE_NONE;
				}
				else
				{
					// Restore previous mode
					dwSentence &= 0x0FFFF0000;
					dwSentence |= _wOldIMESentence;
					_fRestoreOLDIME = 0;
				}

				ImmSetConversionStatus(hIMC, dwConversion, dwSentence, _fUsingAIMM);
			}

			LocalReleaseImmContext(*this, hIMC);
		}
	}
}

/*
 *	CTextMsgFilter::OnGetIMECompText(WPARAM wparam, LPARAM lparam)
 *
 *	@mfunc
 *
 *	@rdesc
 */
int CTextMsgFilter::OnGetIMECompText(
	WPARAM	wparam,
	LPARAM	lparam)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::OnGetIMECompText");
	if (_ime)
	{
		HRESULT hr;
		IMECOMPTEXT *pIMECompText = (IMECOMPTEXT *)wparam;

		if (pIMECompText->flags == ICT_RESULTREADSTR)
		{
			int cbSize = pIMECompText->cb;
			hr = CIme::CheckInsertResultString(0, *this, NULL, &cbSize, (WCHAR *)lparam);

			if (hr == S_OK)
				return cbSize/2;
		}
	}
	return 0;
}

/*
 *	CTextMsgFilter::NoIMEProcess()
 *
 *	@mfunc
 *		check if you should handle IME
 */
BOOL CTextMsgFilter::NoIMEProcess()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::NoIMEProcess");

	if (_fNoIme)
		return TRUE;

	_pTextDoc->GetFEFlags(&_lFEFlags);

	if (_lFEFlags & (ES_NOIME | tomUsePassword))
		return TRUE;

	return FALSE;
}

/*
 *	CTextMsgFilter::MouseOperation(UINT msg, long ichStart, long cchComp, WPARAM wParam,
 *							WPARAM *pwParamBefore, BOOL *pfTerminateIME, HWND	hwndIME)
 *
 *	@mfunc
 *		handle mouse operation for CTF or IME
 *
 *	@rdesc
 *		BOOL-TRUE if CTF or IME handled the mouse events
 */
BOOL CTextMsgFilter::MouseOperation(
	UINT			msg,
	long			ichStart,
	long			cchComp,
	WPARAM			wParam,
	WPARAM			*pwParamBefore,
	BOOL			*pfTerminateIME,
	HWND			hwndIME,
	long			*pCpCursor,
	ITfMouseSink	*pMouseSink)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::MouseOperation");
	BOOL	fRetCode = FALSE;
	BOOL	fButtonPressed = FALSE;
	WORD	wButtons = 0;
	POINT	ptCursor;
	WPARAM	wParamIME;
	WPARAM	fwkeys = wParam;
	BOOL	fHandleIME = hwndIME ? TRUE : FALSE;
	HWND	hHostWnd = _hwnd;
	long	hWnd;

	if (!hHostWnd)									// Windowless mode...
	{
		if (_pTextDoc->GetWindow(&hWnd) != S_OK || !hWnd)
			return FALSE;

		hHostWnd = (HWND)(DWORD_PTR)hWnd;
	}

	*pfTerminateIME = TRUE;

	switch (msg)
	{
		case WM_MOUSEMOVE:
			goto LCheckButton;

		case WM_LBUTTONDOWN:
			fButtonPressed = TRUE;
		case WM_LBUTTONDBLCLK:
			fwkeys |= MK_LBUTTON;
			goto LCheckButton;

		case WM_LBUTTONUP:
			fwkeys &= (~MK_LBUTTON);
			goto LCheckButton;

		case WM_RBUTTONDOWN:
			fButtonPressed = TRUE;
		case WM_RBUTTONDBLCLK:
			fwkeys |= MK_RBUTTON;
			goto LCheckButton;

		case WM_RBUTTONUP:
			fwkeys &= (~MK_RBUTTON);
			goto LCheckButton;

		case WM_MBUTTONUP:
			fwkeys &= (~MK_MBUTTON);
			goto LCheckButton;

		case WM_MBUTTONDOWN:
			fButtonPressed = TRUE;
		case WM_MBUTTONDBLCLK:
			fwkeys |= MK_MBUTTON;
LCheckButton:
			if (fwkeys & MK_LBUTTON)
				wButtons |= IMEMOUSE_LDOWN;
			if (fwkeys & MK_RBUTTON)
				wButtons |= IMEMOUSE_RDOWN;
			if (fwkeys & MK_MBUTTON)
				wButtons |= IMEMOUSE_MDOWN;
			break;

		case WM_SETCURSOR:
			wButtons = LOBYTE(*pwParamBefore);
			break;

		default:
			return FALSE;
	}

	// Kor special - click should terminate IME
	if (fHandleIME && fButtonPressed && _uKeyBoardCodePage == CP_KOREAN)
	{
		*pfTerminateIME = TRUE;
		return FALSE;
	}

	// Change in button since last message?
	if ((wButtons != LOBYTE(LOWORD(*pwParamBefore))) && GetCapture() == hHostWnd)
	{
		fButtonPressed = FALSE;
		wButtons = 0;
		ReleaseCapture();
	}

	if (GetCursorPos(&ptCursor))
	{
		ITextRange *pTextRange;
		HRESULT		hResult;
		long		ichCursor;
		long		lTextFlow;
		POINT		ptCPTop = {0, 0};
		POINT		ptCPBottom = {0, 0};
		POINT		ptCenterTop = {0, 0};
		POINT		ptCenterBottom = {0, 0};
		BOOL		fWithinCompText = FALSE;

		// Get cp at current Cursor position
		hResult = _pTextDoc->RangeFromPoint(ptCursor.x, ptCursor.y,
			&pTextRange);

		if (hResult != NOERROR)
			return FALSE;

		_pTextDoc->GetFEFlags(&lTextFlow);
		lTextFlow &= tomTextFlowMask;

		hResult = pTextRange->GetStart(&ichCursor);
		pTextRange->GetPoint(TA_TOP, &(ptCPTop.x), &(ptCPTop.y));
		pTextRange->GetPoint(TA_BOTTOM, &(ptCPBottom.x), &(ptCPBottom.y));
		pTextRange->Release();
		pTextRange = NULL;
		if (hResult != NOERROR)
			return FALSE;

		if (pCpCursor)
			*pCpCursor = ichCursor;

		// Click within composition text?
		if (ichStart <= ichCursor && ichCursor <= ichStart + cchComp)
		{
			WORD	wPos = 0;

			LONG lTestCursor = TestPoint(ptCPTop, ptCPBottom, ptCursor, TEST_ALL, lTextFlow);

			if (lTestCursor & (TEST_TOP | TEST_BOTTOM))
					goto HIT_OUTSIDE;

			// Cursor locates to the left of the first composition character
			// or cursor locates to the right of the last composition character
			if (ichStart == ichCursor && (lTestCursor & TEST_LEFT) ||
				ichCursor == ichStart + cchComp && (lTestCursor & TEST_RIGHT))
				goto HIT_OUTSIDE;

			// Need to calculate the relative position of the Cursor and the center of character:
			//
			// If Cursor locates to the Left of the cp, 
			//		If Cursor is more than 1/4 the character width from the cp
			//			wPos = 0;
			//		Otherwise
			//			wPos = 1;
			//
			// If Cursor locates to the Right of the cp, 
			//		If Cursor is less than 1/4 the character width from the cp
			//			wPos = 2;
			//		Otherwise
			//			wPos = 3;
			//
			if (lTestCursor & TEST_LEFT)
				hResult = _pTextDoc->Range(ichCursor-1, ichCursor, &pTextRange);
			else
				hResult = _pTextDoc->Range(ichCursor, ichCursor+1, &pTextRange);

			if (pTextRange)
			{
				LONG	lTestCenter = 0;
				LONG	uMouse = 0;
				LONG	uHalfCenter = 0;

				pTextRange->GetPoint(tomStart + TA_TOP + TA_CENTER, &(ptCenterTop.x), &(ptCenterTop.y));
				pTextRange->GetPoint(tomStart + TA_BOTTOM + TA_CENTER, &(ptCenterBottom.x), &(ptCenterBottom.y));
				pTextRange->Release();

				lTestCenter = TestPoint(ptCPTop, ptCPBottom, ptCenterBottom, TEST_ALL, lTextFlow);

				if (lTestCenter & (TEST_TOP | TEST_BOTTOM))
					goto HIT_OUTSIDE;					// Not on the same line

				if (lTextFlow == tomTextFlowES || lTextFlow == tomTextFlowWN)
				{
					uMouse = ptCursor.x - ptCPBottom.x;
					uHalfCenter = ptCenterBottom.x - ptCPBottom.x;
				}
				else
				{
					uMouse = ptCursor.y - ptCPBottom.y;
					uHalfCenter = ptCenterBottom.y - ptCPBottom.y;
				}

				uMouse = abs(uMouse);
				uHalfCenter = abs(uHalfCenter) / 2;

				if (lTestCursor & TEST_LEFT)
				{
					if (lTestCenter & TEST_LEFT)
						wPos = uMouse > uHalfCenter ? 0: 1;
				}
				else if (lTestCenter & TEST_RIGHT)
					wPos = uMouse >= uHalfCenter ? 3: 2;

				wButtons = MAKEWORD(wButtons, wPos);
			}

			wParamIME = MAKEWPARAM(wButtons, ichCursor - ichStart);
			fButtonPressed &= (*pwParamBefore & 0xff) == 0;

			if (*pwParamBefore != wParamIME || fHandleIME && msg == WM_MOUSEMOVE && !fButtonPressed)
			{
				*pwParamBefore = wParamIME;
				if (fHandleIME)	// IME case
				{
					HIMC hIMC = LocalGetImmContext(*this);

					if (hIMC)
					{
						fRetCode = SendMessage(hwndIME, MSIMEMouseMsg, *pwParamBefore, hIMC);
						LocalReleaseImmContext(*this, hIMC);
					}
				}
				else			// Cicero case
				{
					BOOL	fEaten = FALSE;
					DWORD	dwBtn = 0;

					dwBtn |= wButtons & IMEMOUSE_LDOWN ? MK_LBUTTON : 0;
					dwBtn |= wButtons & IMEMOUSE_MDOWN ? MK_MBUTTON : 0;
					dwBtn |= wButtons & IMEMOUSE_RDOWN ? MK_RBUTTON : 0;

					if (S_OK == pMouseSink->OnMouseEvent(ichCursor - ichStart, wPos, dwBtn, &fEaten) && fEaten)
						fRetCode = TRUE;
				}
			}
			else
				fRetCode = TRUE;		// No change from last time, no need to send message to IME

			fWithinCompText = TRUE;
			if (fHandleIME && fRetCode && fButtonPressed && GetCapture() != hHostWnd)
				SetCapture(hHostWnd);
		}

HIT_OUTSIDE:
		if (!fWithinCompText && (GetCapture() == hHostWnd || msg == WM_LBUTTONUP))	//We don't want to determine while dragging...
			fRetCode = TRUE;
	}

	*pfTerminateIME = !fRetCode;
	return fRetCode;
}

/*
 *	CTextMsgFilter::CompleteUIMTyping(LONG mode, BOOL fTransaction)
 *
 *	@mfunc
 *		Terminate IME or UIM composition 
 *	
 */
void CTextMsgFilter::CompleteUIMTyping(
	LONG mode,
	BOOL fTransaction)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::CompleteUIMTyping");

	if (_ime)
	{
		Assert(!(_pCUIM && _pCUIM->IsUIMTyping()));
		_ime->TerminateIMEComposition(*this, (CIme::TerminateMode)mode);
	}
	else
	{
		Assert (_pCUIM);
		if (_pCUIM && _fSendTransaction == 0)
		{
			if (fTransaction)
			{
				ITextStoreACPSink *ptss = _pCUIM->_ptss;

				if (ptss)
				{
					_fSendTransaction = 1;
					ptss->OnStartEditTransaction();
				}
			}
			_pCUIM->CompleteUIMText();
		}
	}
}

/*
 *	CTextMsgFilter::GetIMECompAttributes()
 *
 *	@mfunc
 *		Get the 1.0 mode IME color and underline for displaying cmposition strings
 *
 *	@rdesc
 *		COMPCOLOR *.  Could be NULL if PvAlloc failed
 *	
 */
COMPCOLOR* CTextMsgFilter::GetIMECompAttributes()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::GetIMECompAttributes");

	// For 1.0 mode IME color 
	if (!_pcrComp)
	{
		_pcrComp = (COMPCOLOR *)PvAlloc(sizeof(COMPCOLOR) * 4, GMEM_ZEROINIT);

		if (_pcrComp)
		{
			// Init. IME composition color/underline the same way as RE1.0			
			_pcrComp[0].crBackground = 0x0ffffff;
			_pcrComp[0].dwEffects = CFE_UNDERLINE;
			_pcrComp[1].crBackground = 0x0808080;
			_pcrComp[2].crBackground = 0x0ffffff;
			_pcrComp[2].dwEffects = CFE_UNDERLINE;
			_pcrComp[3].crText = 0x0ffffff;
		}
	}

	return _pcrComp;
}

/*
 *	CTextMsgFilter::SetupCallback()
 *
 *	@mfunc
 *
 *	@rdesc
 *	
 */
void CTextMsgFilter::SetupCallback()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::SetupCallback");

	if (!_pMsgCallBack)
		_pMsgCallBack = new CMsgCallBack(this);
	if (_pMsgCallBack)
	{
		LRESULT lresult;
		_pTextService->TxSendMessage(EM_SETCALLBACK, 0, (LPARAM)_pMsgCallBack, &lresult);
	}
}

/*
 *	CTextMsgFilter::SetupLangSink()
 *
 *	@mfunc
 *		Setup the Language sink to catch the keyboard changing event.  We are not
 *	getting WM_INPUTLANGCHANGEREQUEST and thus need this sink.
 *
 */
void CTextMsgFilter::SetupLangSink()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::SetupLangSink");

	if (!_pITfIPP)
	{
		CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, CLSCTX_INPROC_SERVER,
			IID_ITfInputProcessorProfiles, (void**)&_pITfIPP);

		if (_pITfIPP)
		{
			_pCLangProfileSink = new CLangProfileSink();
			if (_pCLangProfileSink)
			{
				if (_pCLangProfileSink->_Advise(this, _pITfIPP) != S_OK)
				{
					_pCLangProfileSink->Release();
					_pCLangProfileSink = NULL;
					_pITfIPP->Release();
					_pITfIPP = NULL;
				}
			}
			else
			{
				_pITfIPP->Release();
				_pITfIPP = NULL;
			}
		}
	}
}

/*
 *	CTextMsgFilter::ReleaseLangSink()
 *
 *	@mfunc
 *		Release the lang sink object
 *
 */
void CTextMsgFilter::ReleaseLangSink()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::ReleaseLangSink");

	if (_pITfIPP)
	{
		Assert(_pCLangProfileSink);

		_pCLangProfileSink->_Unadvise();
		_pCLangProfileSink->Release();
		_pCLangProfileSink = NULL;

		_pITfIPP->Release();
		_pITfIPP = NULL;
	}
}

/*
 *	CTextMsgFilter::StartUIM()
 *
 *	@mfunc
 *
 *	@rdesc
 *	
 */
void CTextMsgFilter::StartUIM()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::StartUIM");

	if (NoIMEProcess())
		return;

	_fUsingUIM = CreateUIM(this);

	if (_fUsingUIM)
	{
		SetupCallback();
		SetupLangSink();
	}
}

/*
 *	CTextMsgFilter::StartAimm()
 *
 *	@mfunc
 *
 *	@rdesc
 *	
 */
void CTextMsgFilter::StartAimm(BOOL fUseAimm12)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::StartAimm");

	if (!_hwnd || NoIMEProcess())
		return;

	if (LoadAIMM(fUseAimm12))
	{
		HRESULT	hResult = ActivateAIMM(FALSE);

		if (hResult == NOERROR)
		{
			DWORD	dwAtom;
			ATOM	aClass;

			// filter client windows
			if (dwAtom = GetClassLong(_hwnd, GCW_ATOM))
			{
				aClass = dwAtom;				
				hResult = FilterClientWindowsAIMM(&aClass, 1, _hwnd);
			}
			_fUsingAIMM = 1;
			SetupCallback();

			if (!fLoadAIMM10)
				SetupLangSink();
		}
	}
}

/*
 *	CTextMsgFilter::TurnOffUIM()
 *
 *	@mfunc
 *
 *	@rdesc
 *	
 */
void CTextMsgFilter::TurnOffUIM(BOOL fSafeToSendMessage)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::TurnOffUIM");

	if (fSafeToSendMessage && _fUsingUIM && _pCUIM && _pCUIM->IsUIMTyping())
		CompleteUIMTyping(CIme::TERMINATE_NORMAL);

	_fUsingUIM = FALSE;

	ReleaseLangSink();

	// Release various objects
	if (_pCUIM)
	{
		CUIM *pCUIM = _pCUIM;
		LRESULT lresult;

		_pCUIM = NULL;

		if (fSafeToSendMessage)
			_pTextService->TxSendMessage(EM_SETUPNOTIFY, 0, (LPARAM)(ITxNotify *)pCUIM, &lresult);
		else
			pCUIM->_fShutDown = 1;

		pCUIM->Uninit();
		pCUIM->Release();
	
	}

	if (_pTim)
	{
		ITfThreadMgr *pTim = _pTim;
		
		_pTim = NULL;
		pTim->Deactivate();
		pTim->Release();
	}

	// Turn off Callback
	if (fSafeToSendMessage && _pMsgCallBack)
	{
		LRESULT lresult;
		_pTextService->TxSendMessage(EM_SETCALLBACK, 0, (LPARAM)0, &lresult);
		delete _pMsgCallBack;
		_pMsgCallBack = NULL;
	}
}

/*
 *	CTextMsgFilter::HandleCTFService(wparam, lparam)
 *
 *	@mfunc
 *		Setup Cicero setting to handle or disable smarttag and proofing services
 *	
 */
void CTextMsgFilter::HandleCTFService(
	WPARAM wparam, 
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::HandleCTFService");

	BOOL	fChangeInSetting = FALSE;

	if (lparam & SES_CTFALLOWSMARTTAG)
	{
		BOOL fAllowSmartTagLocal = (wparam & SES_CTFALLOWSMARTTAG) ? 1 : 0;

		if ((BOOL)_fAllowSmartTag != fAllowSmartTagLocal)
		{
			_fAllowSmartTag = fAllowSmartTagLocal;
			fChangeInSetting = TRUE;
		}
	}
	if (lparam & SES_CTFALLOWPROOFING)
	{
		BOOL fAllowProofLocal = (wparam & SES_CTFALLOWPROOFING) ? 1 : 0;

		if ((BOOL)_fAllowProofing != fAllowProofLocal)
		{
			_fAllowProofing = fAllowProofLocal;
			fChangeInSetting = TRUE;
		}
	}

	if (fChangeInSetting)
	{
		if (_fUsingUIM && _pCUIM)
			_pCUIM->NotifyService();
	}
}

/*
 *	CTextMsgFilter::TurnOffAimm()
 *
 *	@mfunc
 *		Turn off Aimm.
 *	
 */
void CTextMsgFilter::TurnOffAimm(BOOL fSafeToSendMessage)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::TurnOffAimm");

	if (_fUsingAIMM)
	{
		if (IsIMEComposition())
		{
			if (fSafeToSendMessage)
				CompleteUIMTyping(CIme::TERMINATE_NORMAL);
			else
			{
				delete _ime;
				_ime = NULL;
			}
		}

		_fUsingAIMM = FALSE;

		UnfilterClientWindowsAIMM(_hwnd);
		DeactivateAIMM();

		ReleaseLangSink();

		// Turn off Callback
		if (fSafeToSendMessage && _pMsgCallBack)
		{
			LRESULT lresult;
			_pTextService->TxSendMessage(EM_SETCALLBACK, 0, (LPARAM)0, &lresult);
			delete _pMsgCallBack;
			_pMsgCallBack = NULL;
		}
	}
}

/*
 *	void CTextMsgFilter::OnSetUIMMode()
 *
 *	@mfunc
 *
 *	@rdesc
 *	
 */
void CTextMsgFilter::OnSetUIMMode(WORD wUIMModeBias) 
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextMsgFilter::OnSetUIMMode");

	if (_wUIMModeBias != wUIMModeBias && 
		IN_RANGE(CTFMODEBIAS_DEFAULT, wUIMModeBias, CTFMODEBIAS_HALFWIDTHALPHANUMERIC))
	{
		_wUIMModeBias = wUIMModeBias;

		if (_pMsgCallBack)
			_pMsgCallBack->NotifyEvents(NE_MODEBIASCHANGE);
	}
}

/*
 *	HRESULT CMsgCallBack::HandlePostMessage()
 *
 *	@mfunc
 *
 *	@rdesc
 *
 */
HRESULT CMsgCallBack::HandlePostMessage(
	HWND hWnd,
	UINT msg, 
	WPARAM wparam, 
	LPARAM lparam, 
	LRESULT *plres)
{
	//TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CMsgCallBack::HandlePostMessage");

	if (_pTextMsgFilter->_fUsingAIMM)
		return CallAIMMDefaultWndProc(hWnd, msg, wparam, lparam, plres);

	return S_FALSE;
}

/*
 *	HRESULT CMsgCallBack::NotifyEvents()
 *
 *	@mfunc
 *
 *	@rdesc
 *
 */
HRESULT CMsgCallBack::NotifyEvents(DWORD dwEvents)
{
	//TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CMsgCallBack::NotifyEvents");

	CUIM	*pCUIM = _pTextMsgFilter->_pCUIM;

	if (pCUIM)
	{
		ITextStoreACPSink *ptss = pCUIM->_ptss;

		if (dwEvents & NE_ENTERTOPLEVELCALLMGR)
		{
			pCUIM->_cCallMgrLevels++;
		}
		else if (dwEvents & NE_EXITTOPLEVELCALLMGR)
		{
			Assert (pCUIM->_cCallMgrLevels > 0);
			pCUIM->_cCallMgrLevels--;
		}

		if (pCUIM->_cCallMgrLevels)
		{
			// Save events to be sent later
			if ((dwEvents & NE_CALLMGRSELCHANGE) && !pCUIM->_fReadLockOn)
				pCUIM->_fSelChangeEventPending = 1;

			if (dwEvents & (NE_CALLMGRCHANGE | NE_LAYOUTCHANGE))
				pCUIM->_fLayoutEventPending = 1;

			if (dwEvents & NE_MODEBIASCHANGE)
				pCUIM->_fModeBiasPending = 1;
		}
		else
		{
			if (pCUIM->_fSelChangeEventPending || (dwEvents & NE_CALLMGRSELCHANGE))
			{
				pCUIM->_fSelChangeEventPending = 0;
				if (ptss && !pCUIM->_fHoldCTFSelChangeNotify && !pCUIM->_fReadLockOn)
					ptss->OnSelectionChange();
			}

			if (pCUIM->_fLayoutEventPending || (dwEvents & (NE_CALLMGRCHANGE | NE_LAYOUTCHANGE)))
			{
				pCUIM->_fLayoutEventPending = 0;
				if (ptss)
					ptss->OnLayoutChange(TS_LC_CHANGE, 0);	
			}

			if (pCUIM->_fModeBiasPending || (dwEvents & NE_MODEBIASCHANGE))
			{
				pCUIM->_fModeBiasPending = 0;
				if (ptss)
				{	
					LONG	ccpMax = 0;

					if (pCUIM->GetStoryLength(&ccpMax) != S_OK)
						ccpMax = tomForward;

					ptss->OnAttrsChange(0, ccpMax, 1, &GUID_PROP_MODEBIAS);		// only ModeBias for now
				}
			}

			// Probably safe to let UIM to lock data now
			if (ptss && (pCUIM->_fReadLockPending || pCUIM->_fWriteLockPending))
			{
				HRESULT hResult;
				HRESULT hResult1;

				hResult = pCUIM->RequestLock(pCUIM->_fWriteLockPending ? TS_LF_READWRITE : TS_LF_READ, &hResult1);
			}

			if (_pTextMsgFilter->_fSendTransaction)
			{
				_pTextMsgFilter->_fSendTransaction = 0;
				if (ptss)
					ptss->OnEndEditTransaction();
			}

			pCUIM->_fHoldCTFSelChangeNotify = 0;
		}
	}

	return S_OK;
}

/*
 *	CLangProfileSink::QueryInterface()
 *
 *	@mfunc
 *
 *	@rdesc
 *
 */
STDAPI CLangProfileSink::QueryInterface(REFIID riid, void **ppvObj)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CLangProfileSink::QueryInterface");

	*ppvObj = NULL;

	if (IsEqualIID(riid, IID_IUnknown) ||
		IsEqualIID(riid, IID_ITfLanguageProfileNotifySink))
		*ppvObj = this;

	if (*ppvObj)
	{
		AddRef();
		return S_OK;
	}

	return E_NOINTERFACE;
}

/*
 *	CLangProfileSink::AddRef()
 *
 *	@mfunc
 *
 *	@rdesc
 *
 */
STDAPI_(ULONG) CLangProfileSink::AddRef()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CLangProfileSink::AddRef");

	return ++_cRef;
}

/*
 *	CLangProfileSink::Release()
 *
 *	@mfunc
 *
 *	@rdesc
 *
 */
STDAPI_(ULONG) CLangProfileSink::Release()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CLangProfileSink::Release");

	long cr;

	cr = --_cRef;
	Assert(cr >= 0);

	if (cr == 0)
		delete this;

	return cr;
}

/*
 *	CLangProfileSink::CLangProfileSink()
 *
 *	@mfunc
 *
 *	@rdesc
 *
 */
CLangProfileSink::CLangProfileSink()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CLangProfileSink::CLangProfileSink");

	_cRef = 1;
	_dwCookie = (DWORD)(-1);
}

/*
 *	CLangProfileSink::OnLanguageChange()
 *
 *	@mfunc
 *
 *	@rdesc
 *
 */
STDMETHODIMP CLangProfileSink::OnLanguageChange(LANGID langid, BOOL *pfAccept)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CLangProfileSink::OnLanguageChange");

	Assert (pfAccept);

	*pfAccept = TRUE;

	if (_pTextMsgFilter->_hwnd && GetFocus() == _pTextMsgFilter->_hwnd)
	{
		LRESULT		lresult = 0;
		if ( S_OK == _pTextMsgFilter->_pTextService->TxSendMessage(
				EM_GETDOCFLAGS, GDF_ALL, 0, &lresult))
		{
			if (lresult & GDF_SINGLECPG)
			{
				LCID syslcid = GetSysLCID();

				// Check if new langid supported by the system
				if (langid != syslcid)
				{
					LOCALESIGNATURE ls;

					if(GetLocaleInfoA(langid, LOCALE_FONTSIGNATURE, (LPSTR)&ls, sizeof(ls)))
					{
						CHARSETINFO cs;
						HDC hdc = GetDC(_pTextMsgFilter->_hwnd);
						TranslateCharsetInfo((DWORD *)(DWORD_PTR)GetTextCharsetInfo(hdc, NULL, 0), &cs, TCI_SRCCHARSET);
						ReleaseDC(_pTextMsgFilter->_hwnd, hdc);
						DWORD fsShell = cs.fs.fsCsb[0];
						if (!(fsShell & ls.lsCsbSupported[0]))
							*pfAccept = FALSE;
					}
				}
			}
		}

		if (*pfAccept == TRUE && _pTextMsgFilter-> _nIMEMode)
			_pTextMsgFilter->SetIMESentenseMode(FALSE);
	}

    return S_OK;
}

/*
 *	CLangProfileSink::OnLanguageChanged()
 *
 *	@mfunc
 *
 *	@rdesc
 *
 */
STDMETHODIMP CLangProfileSink::OnLanguageChanged()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CLangProfileSink::OnLanguageChanged");

    return S_OK;
}

/*
 *	CLangProfileSink::_Advise()
 *
 *	@mfunc
 *
 *	@rdesc
 *
 */
HRESULT CLangProfileSink::_Advise(
	CTextMsgFilter *pTextMsgFilter,
	ITfInputProcessorProfiles *pipp)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CLangProfileSink::_Advise");

    HRESULT hr;
    ITfSource *pSource = NULL;

	_pTextMsgFilter = pTextMsgFilter;
    _pITFIPP = pipp;
    hr = E_FAIL;

    if (FAILED(_pITFIPP->QueryInterface(IID_ITfSource, (void **)&pSource)))
        goto Exit;

    if (FAILED(pSource->AdviseSink(IID_ITfLanguageProfileNotifySink, this, &_dwCookie)))
        goto Exit;

    hr = S_OK;

Exit:
    pSource->Release();
    return hr;
}

/*
 *	CLangProfileSink::_Unadvise()
 *
 *	@mfunc
 *
 *	@rdesc
 *
 */
HRESULT CLangProfileSink::_Unadvise()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CLangProfileSink::_Unadvise");

	HRESULT hr;
	ITfSource *pSource = NULL;

	hr = E_FAIL;

	if (_pITFIPP == NULL)
		return hr;

	if (FAILED(_pITFIPP->QueryInterface(IID_ITfSource, (void **)&pSource)))
		return hr;

	if (FAILED(pSource->UnadviseSink(_dwCookie)))
		goto Exit;

	hr = S_OK;

Exit:
	pSource->Release();
	return hr;
}

#endif // NOFEPROCESSING
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\coleobj.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module	COLEOBJ.CPP	OLE Object management class implemenation |
 *
 * 	Authors:
 *	alexgo  Much of this code is a port from RichEdit 1.0 sources
 *			(cleaned up a bit, ported to C++, etc.)  So if there's any
 *			bit of strangeness, it's probably there for a reason.
 *
 *	KeithCu	Cleaned up (removed _rcPos, ResetPosRect(), ScrollObject,
			fixed undo/resizing issues)
 *			Added textflow support
 *
 *	Copyright (c) 1995-2000, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_coleobj.h"
#include "_objmgr.h"
#include "_select.h"
#include "_rtext.h"
#include "_disp.h"
#include "_dispprt.h"
#include "_antievt.h"
#include "_dxfrobj.h"

ASSERTDATA

// 
// data private to this file
//
static const OLECHAR szSiteFlagsStm[] = OLESTR("RichEditFlags");	

// 
// EXCEL clsid's.  We have to make some special purpose hacks
// for XL.
const CLSID rgclsidExcel[] =
{
    { 0x00020810L, 0, 0, {0xC0, 0, 0, 0, 0, 0, 0, 0x46} },  // Excel Worksheet
    { 0x00020811L, 0, 0, {0xC0, 0, 0, 0, 0, 0, 0, 0x46} },  // Excel Chart
    { 0x00020812L, 0, 0, {0xC0, 0, 0, 0, 0, 0, 0, 0x46} },  // Excel App1
    { 0x00020841L, 0, 0, {0xC0, 0, 0, 0, 0, 0, 0, 0x46} },  // Excel App2
};
const INT cclsidExcel = sizeof(rgclsidExcel) / sizeof(rgclsidExcel[0]);


//
//	WordArt CLSID for more special purpose hacks.
//
const GUID CLSID_WordArt = 
    { 0x000212F0L, 0, 0, {0xC0, 0, 0, 0, 0, 0, 0, 0x46} };
const GUID CLSID_PaintbrushPicture = 
    { 0x0003000AL, 0x0000, 0x0000, { 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 } };
const GUID CLSID_BitmapImage = 
    { 0xD3E34B21L, 0x9D75, 0x101A, { 0x8C, 0x3D, 0x00, 0xAA, 0x00, 0x1A, 0x16, 0x52 } };

//
//	Ink object
//
const GUID CLSID_Ink = 
	{ 0x13DE4A42, 0x8D21, 0x4C8E, {0xBF, 0x9C, 0x8F, 0x69, 0xCB, 0x06, 0x8F, 0xCA} };
const IID IID_ILineInfo = 
	{ 0x9C1C5AD5, 0xF22F, 0x4DE4, {0xB4, 0x53, 0xA2, 0xCC, 0x48, 0x2E, 0x7C, 0x33} };

#define dxyHandle (6) // Object frame handle size
#define dxyFrameDefault  (1) // Object frame width

// 
// utility functions
//

/*
 *	IsExcelCLSID (clsid)
 *
 *	@func	checks to see if the given clsid is one of XL's
 *
 *	@rdesc	TRUE/FALSE
 */
BOOL IsExcelCLSID(
	REFGUID clsid)
{
    for(LONG i = 0; i < cclsidExcel; i++)
    {
        if(IsEqualCLSID(clsid, rgclsidExcel[i]))
			return TRUE;
    }
    return FALSE;
}

//
//	PUBLIC methods
//

/*
 *	COleObject::QueryInterface(ridd, ppv)
 *
 *	@mfunc	the standard OLE QueryInterface
 *
 *	@rdesc	NOERROR		<nl>
 *			E_NOINTERFACE
 */
STDMETHODIMP COleObject::QueryInterface(
	REFIID	riid,		//@parm Requested interface ID
	void **	ppv)		//@parm Out parm for result
{
	HRESULT hr = NOERROR;

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::QueryInterface");

    if(IsZombie())
        return CO_E_RELEASED;
        
	if(!ppv)
		return E_INVALIDARG;
	else
		*ppv = NULL;

	if(IsEqualIID(riid, IID_IUnknown))
		*ppv = (IUnknown *)(IOleClientSite *)this;

	else if(IsEqualIID(riid, IID_IOleClientSite))
		*ppv = (IOleClientSite *)this;

	else if(IsEqualIID(riid, IID_IOleInPlaceSite))
		*ppv = (IOleInPlaceSite *)this;

	else if(IsEqualIID(riid, IID_IAdviseSink))
		*ppv = (IAdviseSink *)this;

	else if(IsEqualIID(riid, IID_IOleWindow))
		*ppv = (IOleWindow *)this;

	else if(IsEqualIID(riid, IID_IRichEditOleCallback))
	{
		// NB!! Returning this pointer in our QI is 
		// phenomenally bogus; it breaks fundamental COM
		// identity rules (granted, not many understand them!).
		// Anyway, RichEdit 1.0 did this, so we better.

		TRACEWARNSZ("Returning IRichEditOleCallback interface, COM "
			"identity rules broken!");

		*ppv = _ped->GetRECallback();
	}
	else
		hr = E_NOINTERFACE;

	if(*ppv)
		(*(IUnknown **)ppv)->AddRef();

	return hr;
}

/*
 *	COleObject::AddRef()
 *
 *	@mfunc	Increments reference count
 *
 *	@rdesc	New reference count
 */
STDMETHODIMP_(ULONG) COleObject::AddRef()
{
    ULONG cRef;
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::AddRef");

    cRef = SafeAddRef();
	
	return cRef;
}

/*
 *	COleObject::Release	()
 *
 *	@mfunc	Decrements reference count
 *
 *	@rdesc	New reference count
 */
STDMETHODIMP_(ULONG) COleObject::Release()
{
    ULONG cRef;
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::Release");

	cRef = SafeRelease();

	return cRef;
}

/*
 *	COleObject::SaveObject ()
 *
 *	@mfunc	implemtenation of IOleClientSite::SaveObject
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::SaveObject()
{
	CCallMgr	callmgr(_ped);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::SaveObject");

	return SafeSaveObject();
}

/*
 *	COleObject::SafeSaveObject ()
 *
 *	@mfunc	implemtenation of IOleClientSite::SaveObject for internal consumption
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::SafeSaveObject()
{
	IPersistStorage *pps;
	HRESULT hr;
	CStabilize stabilize(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::SafeSaveObject");

	if(!_punkobj || !_pstg)
	{
		TRACEWARNSZ("SaveObject called on invalid object");
		return E_UNEXPECTED;
	}

    if(IsZombie())
        return CO_E_RELEASED;

	hr = _punkobj->QueryInterface(IID_IPersistStorage, (void **)&pps);

	TESTANDTRACEHR(hr);

	if(hr == NOERROR)
	{
        if(IsZombie())
            return CO_E_RELEASED;
        
		SavePrivateState();
		
        if(IsZombie())
            return CO_E_RELEASED;
        
		hr = OleSave(pps, _pstg, TRUE);
	
	    if(IsZombie())
	        return CO_E_RELEASED;
        
		TESTANDTRACEHR(hr);

		// note that SaveCompleted is called even if OleSave fails.
		// If both OleSave and SaveCompleted succeed, then go ahead
		// and commit the changes

		if(pps->SaveCompleted(NULL) == NOERROR && hr == NOERROR)
		{
		    if(IsZombie())
		        return CO_E_RELEASED;
			
			hr = _pstg->Commit(STGC_DEFAULT);

			TESTANDTRACEHR(hr);
		}
        pps->Release();
	}
	return hr;
}

/*
 *	COleObject::GetMoniker (dwAssign, dwWhichMoniker, ppmk)
 *
 *	@mfunc	implementation of IOleClientSite::GetMoniker
 *
 *	@rdesc	E_NOTIMPL
 */
STDMETHODIMP COleObject::GetMoniker(
	DWORD		dwAssign,		//@parm	Force an assignment?
	DWORD		dwWhichMoniker,	//@parm	Kind of moniker to get
	IMoniker **	ppmk)			//@parm Out parm for result
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::GetMoniker");

	TRACEWARNSZ("method not implemented!");

	if(ppmk)
		*ppmk = NULL;

	return E_NOTIMPL;
}
	
/*
 *	COleObject::GetContainer(ppcont)
 *
 *	@mfunc	implementation of IOleClientSite::GetContainer
 *
 *	@rdesc	E_NOINTERFACE
 */
STDMETHODIMP COleObject::GetContainer(
	IOleContainer **ppcont)	//@parm	Out parm for result
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::GetContainer");

	TRACEWARNSZ("method not implemented!");

	if(ppcont)
		*ppcont = NULL;

	// Richedit 1.0 returns E_NOINTERFACE instead of E_NOTIMPL.  Do
	// the same.
	return E_NOINTERFACE;
}

/*
 *	COleObject::ShowObject()
 *
 *	@mfunc	Implementation of IOleClientSite::ShowObject.  
 *
 *	@rdesc	E_NOTIMPL
 */
STDMETHODIMP COleObject::ShowObject()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::ShowObject");

	TRACEWARNSZ("method not implemented!");

	return E_NOTIMPL;
}

/*
 *	COleObject::OnShowWindow (fShow)
 *
 *	@mfunc
 *		implementation of IOleClientSite::OnShowWindow -- notifies
 *		the client site that the object is or is not being shown in its
 *		own application window.  This governs whether or not hatching 
 *		should appear around the object in richedit.
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::OnShowWindow(
	BOOL fShow)		//@parm If TRUE, object is being drawn in its own window
{
	DWORD dwFlags = _pi.dwFlags;
	CCallMgr	callmgr(_ped);
	CStabilize stabilize(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnShowWindow");

    if(IsZombie())
        return CO_E_RELEASED;

	_pi.dwFlags &= ~REO_OPEN;
	if(fShow)
		_pi.dwFlags |= REO_OPEN;

	// If something changed, redraw object
	if(dwFlags != _pi.dwFlags)
	{
		RECTUV rc;
		GetRectuv(rc);

		// Invalidate rect that we're in.
		_ped->TxInvalidateRect(&rc);

		// We're not allowed to call invalidate rect by itself without
		// terminating it with a call to update window.However, we don't
		// care at this point if things are redrawn right away.
		_ped->TxUpdateWindow();
	}
	return NOERROR;
}

/*
 *	COleObject::RequestNewObjectLayout ()
 *
 *	@mfunc	Implementation of IOleClientSite::RequestNewObjectLayout
 *
 *	@rdesc	E_NOTIMPL
 */
STDMETHODIMP COleObject::RequestNewObjectLayout()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, 
			"COleObject::RequestNewObjectLayout");

	TRACEWARNSZ("method not implemented!");

	return E_NOTIMPL;
}

/*
 *	COleObject::GetWindow(phwnd)
 *
 *	@mfunc	Implementation of IOleInPlaceSite::GetWindow
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::GetWindow(
	HWND *phwnd)	//@parm Where to put window
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::GetWindow");

	// NB! this method is not stabilized.

    if(IsZombie())
        return CO_E_RELEASED;
        
	if(phwnd)
		return _ped->TxGetWindow(phwnd);

	return E_INVALIDARG;
}

/*
 *	COleObject::ContextSensitiveHelp(fEnterMode)
 *
 *	@mfunc	Implemenation of IOleInPlaceSite::ContextSensitiveHelp
 *
 *	@rdesc	HRESULT
 */
 STDMETHODIMP COleObject::ContextSensitiveHelp(
 	BOOL fEnterMode)	//@parm, If TRUE, then we're in help mode
 {
 	IRichEditOleCallback *precall;
	CCallMgr	callmgr(_ped);
	CStabilize	stabilize(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, 
			"COleObject::ContextSensitiveHelp");

    if(IsZombie())
        return CO_E_RELEASED;

	CObjectMgr *pobjmgr = _ped->GetObjectMgr();
	if(!pobjmgr)
		return E_OUTOFMEMORY;
	
	// If the mode changes
	if(pobjmgr->GetHelpMode() != fEnterMode)
	{
		pobjmgr->SetHelpMode(fEnterMode);

		precall = _ped->GetRECallback();
		if(precall)
			return precall->ContextSensitiveHelp(fEnterMode);
	}
	return NOERROR;
}

/*
 *	COleObject::CanInPlaceActivate()
 *
 *	@mfunc	implementation of IOleInPlaceSite::CanInPlaceActivate
 *
 *	@rdesc	NOERROR or S_FALSE
 */
STDMETHODIMP COleObject::CanInPlaceActivate()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, 
			"COleObject::CanInPlaceActivate");

    if(IsZombie())
        return CO_E_RELEASED;
        
	// If we have a callback && the object is willing to show
	// content, then we can in-place activate

	if(_ped->GetRECallback() && _pi.dvaspect == DVASPECT_CONTENT)
 		return NOERROR;
 
	return S_FALSE;
}

/*
 *	COleObject::OnInPlaceActivate()
 *
 *	@mfunc	implementation of IOleInPlaceSite::OnInPlaceActivate
 *
 *	@rdesc	noerror
 */
STDMETHODIMP COleObject::OnInPlaceActivate()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnInPlaceActivate");
	// assume that in-place objects can never be blank.
	_pi.dwFlags &= ~REO_BLANK;
	_fInPlaceActive = TRUE;

	return NOERROR;
}

/*
 *	COleObject::OnUIActivate ()
 *
 *	@mfunc	implementation of IOleInPlaceSite::OnUIActivate.  Notifies
 *			the container that the object is about to be activated in
 *			place with UI elements suchs as merged menus
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::OnUIActivate()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnUIActivate");

	CCallMgr	callmgr(_ped);
	CStabilize	stabilize(this);

    if(IsZombie())
        return CO_E_RELEASED;
        
	CObjectMgr *pobjmgr = _ped->GetObjectMgr();
	if(!pobjmgr)
		return E_OUTOFMEMORY;

	IRichEditOleCallback *precall = pobjmgr->GetRECallback();

	if(precall)
	{
		// Force this object to be selected, if it isn't already
		// Update the selection before making the outgoing call
		if(!(_pi.dwFlags & REO_SELECTED))
		{
			CTxtSelection *psel = _ped->GetSel();
			if(psel)
				psel->SetSelection(_cp, _cp + 1);
		}
		precall->ShowContainerUI(FALSE);
	    if(IsZombie())
	        return CO_E_RELEASED;
        
		// This is an optimization for activating multiple
		pobjmgr->SetShowUIPending(FALSE);

		// RAID 7212
		// We don't want to set the in place active object if we are already in the process of activating the pbject.
		// Otherwise, there will be bad interactions with the code in TxDraw for out of process servers.
		// Note : it may be possible to always set this in ActivateObj but I left this here for those cases wher
		// OnUIActivate may be called directly.
		if (!_fActivateCalled)
		{
			Assert(!pobjmgr->GetInPlaceActiveObject());	
			pobjmgr->SetInPlaceActiveObject(this);
			_pi.dwFlags |= REO_INPLACEACTIVE;
		}

		return NOERROR;
	}
	return E_UNEXPECTED;
}

/*
 *	COleObject::GetWindowContext(ppipframe, ppipuidoc, prcPos, prcClip, pipfinfo) 
 *
 *	@mfunc	Implementation of IOleInPlaceSite::GetWindowContext.
 *			Enables the in-place object to retrieve the window
 *			interfaces that form the window object hierarchy.
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::GetWindowContext(
	IOleInPlaceFrame **ppipframe,	//@parm	Where to put in-place frame
	IOleInPlaceUIWindow **ppipuidoc,//@parm Where to put ui window
	LPRECT prcPos,					//@parm Position rect
	LPRECT prcClip,					//@parm Clipping rect
	LPOLEINPLACEFRAMEINFO pipfinfo)	//@parm Accelerator information
{
	CCallMgr	callmgr(_ped);
	CStabilize stabilize(this);
	
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::GetWindowContext");
	
    if(IsZombie())
        return CO_E_RELEASED;
        
	// Let container verify other parameters; we don't use them
	if(!prcPos || !prcClip)
		return E_INVALIDARG;
		
	IRichEditOleCallback *precall = _ped->GetRECallback();
	if(precall)
	{
		RECTUV rcuv;
		GetRectuv(rcuv);
		_ped->_pdp->RectFromRectuv(*prcPos, rcuv);

		// FUTURE (alexgo); we may need to get this from the
		// display instead to handle the inactive state if we ever
		// want to support embedded objects with the inactive state.
		_ped->TxGetClientRect(prcClip);
		return precall->GetInPlaceContext(ppipframe, ppipuidoc, pipfinfo);
	}
	return E_UNEXPECTED;
}

/*
 *	COleObject::Scroll(sizeScroll)
 *
 *	@mfunc	implementation of IOleInPlaceSite::Scroll
 *
 *	@rdesc 	E_NOTIMPL;
 */
STDMETHODIMP COleObject::Scroll(
	SIZE sizeScroll)	//@parm Amount to scroll
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::Scroll");

	TRACEWARNSZ("method not implemented!");

	return E_NOTIMPL;
}

/*
 *	COleObject::OnUIDeactivate (fUndoable)
 *
 *	@mfunc	implementation of IOleInPlaceSite::OnUIDeactivate.  Notifies
 *			the container that it should re-install its user interface
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::OnUIDeactivate(
	BOOL fUndoable)		//@parm Whether you can undo anything here
{
	CCallMgr	callmgr(_ped);
	CStabilize stabilize(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnUIDeactivate");

    if(IsZombie())
        return CO_E_RELEASED;

	CObjectMgr *pobjmgr = _ped->GetObjectMgr();
	IRichEditOleCallback *precall = _ped->GetRECallback();

	if(_fIsPaintBrush)
	{
		// Hack for RAID 3293.  Bitmap object disappears after editing.
		// Apparently paint only triggers OnUIDeactivate and not OnInPlaceDeactivate
		// assume that in-place objects can never be blank.
		_fInPlaceActive = FALSE;
		// Reset REO_INPLACEACTIVE
		_pi.dwFlags &= ~REO_INPLACEACTIVE;
	}

	if(!precall)
		return E_UNEXPECTED;

	if(_ped->TxIsDoubleClickPending())
		_ped->GetObjectMgr()->SetShowUIPending(TRUE);
	else
	{
		// Ignore any errors; the old code did.
		precall->ShowContainerUI(TRUE);

	    if(IsZombie())
	        return CO_E_RELEASED;
	}
	
	pobjmgr->SetInPlaceActiveObject(NULL);

	if (!_fDeactivateCalled)
	{
		// We got here without DeActiveObj. Since to shutdown correctly
		// we need to call this, we do so here.
		DeActivateObj();
	}

	// Get focus back
	_ped->TxSetFocus();

#ifdef DEBUG
	// the OLE undo model is not very compatible with multi-level undo.
	// For simplicity, just ignore stuff.
	if(fUndoable)
	{
		TRACEWARNSZ("Ignoring a request to keep undo from an OLE object");
	}
#endif

	// Some objects are lame and draw outside the
	// areas they are supposed to.  So we need to 
	// just invalidate everything and redraw.

	_ped->TxInvalidate();
	return NOERROR;
}

/*
 *	COleObject::OnInPlaceDeactivate	()
 *
 *	@mfunc	implementation of IOleInPlaceSite::OnInPlaceDeactivate
 *
 *	@rdesc	NOERROR
 */
STDMETHODIMP COleObject::OnInPlaceDeactivate()
{
	CCallMgr	callmgr(_ped);
	CStabilize stabilize(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, 
			"COleObject::OnInPlaceDeactivate");

	_fInPlaceActive = FALSE;

	//Reset REO_INPLACEACTIVE
	_pi.dwFlags &= ~REO_INPLACEACTIVE;

	if(!_punkobj)
		return E_UNEXPECTED;

    if(IsZombie())
        return CO_E_RELEASED;
        
	// Apparently, WordArt 2.0 had some sizing problems.  The original
	// code has this call to GetExtent-->SetExtent, so I've kept it here.
	if(_fIsWordArt2)
	{
		// Ignore errors.  If anything fails, too bad.
		FetchObjectExtents();	// this will reset _size
		SetExtent(SE_NOTACTIVATING);
	}

	// Some objects are lame and draw outside the
	// areas they are supposed to.  So we need to 
	// just invalidate everything and redraw.

	// Note that we do this in UIDeactivate as well; however, the
	// double invalidation is necessary to cover some re-entrancy 
	// cases where we might be painted before everything is ready.

	_ped->TxInvalidate();
	return NOERROR;
}

/*
 *	COleObject::DiscardUndoState ()
 *
 *	@mfunc	implementation of IOleInPlaceSite::DiscardUndoState.
 *
 *	@rdesc	NOERROR
 */
STDMETHODIMP COleObject::DiscardUndoState()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, 
			"COleObject::DiscardUndoState");

	// Nothing to do here; we don't keep any OLE-undo state as it's
	// not very compatible with multi-level undo.
	
	return NOERROR;
}

/*
 *	COleObject::DeactivateAndUndo ()
 *
 *	@mfunc	implementation of IOleInPlaceSite::DeactivateAndUndo--
 *			called by an active object when the user invokes undo
 *			in the active object
 *
 *	@rdesc	NOERROR	(yep, richedit1.0 ignored all the errors here)
 */
STDMETHODIMP COleObject::DeactivateAndUndo()
{
	CStabilize	stabilize(this);

  	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::DeactivateAndUndo");

    if(IsZombie())
        return CO_E_RELEASED;
        
	// Ignore error
	_ped->InPlaceDeactivate();

	// COMPATIBILITY ISSUE: we don't bother doing any undo here, as 
	// a multi-level undo model is incompatible with OLE undo.

	return NOERROR;
}

/*
 *	COleObject::OnPosRectChange	(prcPos)
 *
 *	@mfunc	implementation of IOleInPlaceSite::OnPosRectChange.  This
 *			method is called by an in-place object when its extents have
 *			changed
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::OnPosRectChange(
	LPCRECT prcPos)
{
	IOleInPlaceObject *pipo;
 	RECT rcClip;
	RECT rcNewPos;
	CCallMgr	callmgr(_ped);
	CStabilize stabilize(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnPosRectChange");
	
	if(!prcPos)
		return E_INVALIDARG;

	if(!_punkobj)
		return E_UNEXPECTED;
		
    if(IsZombie())
        return CO_E_RELEASED;

	if(!_ped->fInplaceActive())
		return E_UNEXPECTED;
        
	// Check to see if the rect moved; we don't allow this, but
	// do allow the object to keep the new size

	rcNewPos = *prcPos;

	rcNewPos.right = rcNewPos.left + (prcPos->right - prcPos->left);
	rcNewPos.bottom = rcNewPos.top + (prcPos->bottom - prcPos->top);		

	_ped->TxGetClientRect(&rcClip);

	HRESULT hr = _punkobj->QueryInterface(IID_IOleInPlaceObject, (void **)&pipo);
	if(hr == NOERROR)
	{
		hr = pipo->SetObjectRects(&rcNewPos, &rcClip);
        pipo->Release();

        // bug fix 6073
        // Need to set viewchange flag so we resize the ole object properly on ITextServices::TxDraw
		CObjectMgr * pobjmgr = _ped->GetObjectMgr();
		if (pobjmgr && pobjmgr->GetInPlaceActiveObject() == this)
			_fViewChange = TRUE;
	}
	return hr;
}

/*
 *	COleObject::OnDataChange (pformatetc, pmedium)
 *
 *	@mfunc	implementation of IAdviseSink::OnDataChange
 *
 *	@rdesc	NOERROR
 */
STDMETHODIMP_(void) COleObject::OnDataChange(
	FORMATETC *pformatetc,		//@parm Format of data that changed
	STGMEDIUM *pmedium)			//@parm Data that changed
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnDataChange");
	CCallMgr	callmgr(_ped);

    if(IsZombie())
        return;
	_pi.dwFlags &= ~REO_BLANK;
	// this will also set the modified flag
	_ped->GetCallMgr()->SetChangeEvent(CN_GENERIC);

	return;
}

/*
 *	COleObject::OnViewChange(dwAspect, lindex) 
 *
 *	@mfunc	implementation of IAdviseSink::OnViewChange.  Notifies
 *			us that the object's view has changed.
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP_(void) COleObject::OnViewChange(
	DWORD	dwAspect,		//@parm Aspect that has changed
	LONG	lindex)			//@parm unused
{
	CStabilize	stabilize(this);
	CCallMgr	callmgr(_ped);
		
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnViewChange");
	
	if(!_punkobj)
		return;		// E_UNEXPECTED

    if(IsZombie())
        return;

	if (_fInUndo)	// This object has been deleted, forget view change
		return;

	_pi.dwFlags &= ~REO_BLANK;
	// Richedit 1.0 ignored errors on getting object extents

  	FetchObjectExtents();

    // bug fix 6073
    // Need to set viewchange flag so we resize the ole object properly on ITextServices::TxDraw
    CObjectMgr * pobjmgr = _ped->GetObjectMgr();
	if (pobjmgr && pobjmgr->GetInPlaceActiveObject() == this)
		_fViewChange = TRUE;
      
	CDisplay *pdp = _ped->_pdp;
	if(pdp)
		pdp->OnPostReplaceRange(CP_INFINITE, 0, 0, _cp, _cp + 1, NULL);

	_ped->GetCallMgr()->SetChangeEvent(CN_GENERIC);
	return;
}
	
/*
 *	COleObject::OnRename (pmk)
 *
 *	@mfunc	implementation of IAdviseSink::OnRename.  Notifies the container
 *			that the object has been renamed
 *
 *	@rdesc	E_NOTIMPL
 */
STDMETHODIMP_(void) COleObject::OnRename(
	IMoniker *pmk)			//@parm Object's new name
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnRename");
	
	TRACEWARNSZ("IAdviseSink::OnRename not implemented!");

	return;	// E_NOTIMPL;
}

/*
 *	COleObject::OnSave ()
 *
 *	@mfunc	implementation of IAdviseSink::OnSave.  Notifies the container
 *			that an object has been saved
 *
 *	@rdesc	NOERROR
 */
STDMETHODIMP_(void) COleObject::OnSave()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnSave");
	_pi.dwFlags &= ~REO_BLANK;
}

/*
 *	COleObject::OnClose	()
 *
 *	@mfunc	implementation of IAdviseSink::OnClose.  Notifies the container
 *			that an object has been closed.
 *
 *	@rdesc	NOERROR
 */
STDMETHODIMP_(void) COleObject::OnClose()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnClose");
	
    if(IsZombie())
        return;
        
	// If the object is blank (i.e. no data in it), we don't want to leave
	// it in the backing store--there is nothing for us to draw && therefore
	// nothing for the user to click on!  So just delete the object with
	// a space.  Note that 1.0 actually deleted the object; we'll just
	// replace it with a space to make everything work out right.
	if(_pi.dwFlags & REO_BLANK)
	{
		CCallMgr	callmgr(_ped);
		CStabilize	stabilize(this);
		CRchTxtPtr	rtp(_ped, _cp);

		// We don't want the delete of this object to go on the undo
		// stack.  We use a space so that cp's will work out right for
		// other undo actions.
		rtp.ReplaceRange(1, 1, L" ", NULL, -1);
	}
	_ped->TxSetForegroundWindow();
}
				
/*
 *	COleObject::OnPreReplaceRange
 *
 *	@mfunc	implementation of ITxNotify::OnPreReplaceRange
 *			called before changes are made to the backing store
 */
void COleObject::OnPreReplaceRange(
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	Assert(_fInUndo == FALSE);
}

/*
 *	COleObject::OnPostReplaceRange
 *
 *	@mfunc	implementation of ITxNotify::OnPostReplaceRange
 *			called after changes are made to the backing store
 *	
 *	@comm	we use this method to keep our cp's up-to-date
 */
void COleObject::OnPostReplaceRange(
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	// The only case we need to worry about is when changes
	// come before our object

	Assert(_fInUndo == FALSE);
#ifndef NOINKOBJECT
	LONG	cpOld = _cp;
#endif
	_fDraw = TRUE;
	if(cp <= _cp)
	{		
		if(cp + cchDel > _cp)
		{
			_fDraw = FALSE;
			return;
		}
		_cp += (cchNew - cchDel);
	}
#ifndef NOINKOBJECT
	if (_ped && _fIsInkObject && _pILineInfo)
	{
		if (cpFormatMin <= cpOld && cpOld < cpFormatMax)
		{
			// Inform Ink object for the formatting changes
			UINT	iInkWidth = 0;

			_ped->SetInkProps(_cp, _pILineInfo, &iInkWidth);

		}
	}
#endif
}
		
/*
 *	COleObject::Zombie ()
 *
 *	@mfunc
 *		Turn this object into a zombie
 *
 */
void COleObject::Zombie ()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::Zombie");

	_ped = NULL;
}

/*
 *	COleObject::COleObject(ped)
 *
 *	@mfunc	constructor
 */
COleObject::COleObject(
	CTxtEdit *ped)	//@parm context for this object
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::COleObject");

	AddRef();

	// Most values will be NULL by virtue of the allocator
	_ped = ped;

	CNotifyMgr *pnm = ped->GetNotifyMgr();
	if(pnm)
		pnm->Add((ITxNotify *)this);
}

/*
 *	COleObject::GetObjectData(preobj, dwFlags)
 *
 *	@mfunc	fills out an REOBJECT structure with information relevant
 *			to this object
 *
 *	@rdesc	HRESULT
 */
HRESULT	COleObject::GetObjectData(
	REOBJECT *preobj, 		//@parm Struct to fill out
	DWORD dwFlags)			//@parm Indicate what data is requested
{
	IOleObject *poo = NULL;

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::GetObjectData");

	Assert(preobj);
	Assert(_punkobj);

	preobj->cp = _cp;
	
	if(_punkobj->QueryInterface(IID_IOleObject, (void **)&poo) == NOERROR)
	{
		// Don't worry about failures here
		poo->GetUserClassID(&(preobj->clsid));
	}
	
	preobj->dwFlags 	= _pi.dwFlags;
	preobj->dvaspect 	= _pi.dvaspect;
	preobj->dwUser 		= _pi.dwUser;
	memcpy(&preobj->sizel, &_size, sizeof(SIZE));

   	if(dwFlags & REO_GETOBJ_POLEOBJ)
	{
		preobj->poleobj = poo;
		if(poo)
			poo->AddRef();
	}
	else
		preobj->poleobj = NULL;

    if(poo)
        poo->Release();

    if(IsZombie())
        return CO_E_RELEASED;
        
	if(dwFlags & REO_GETOBJ_PSTG)
	{
		preobj->pstg = _pstg;
		if(_pstg)
			_pstg->AddRef();
	}
	else
		preobj->pstg = NULL;

	if(dwFlags & REO_GETOBJ_POLESITE)
	{
		// COMPATIBILITY HACK!!  Note that we don't 'release' any pointer that
		// may already be in the stored in the site.  RichEdit1.0 always sets
		// the value, consequently several apps pass in garbage for the site.
		//
		// If the site was previously set, we will get a reference counting
		// bug, so be sure that doesn't happen!
     
       	preobj->polesite = (IOleClientSite *)this;
       	AddRef();
 	}
	else
		preobj->polesite = NULL;

	return NOERROR;
}	

/*
 *	COleObject::IsLink()
 *
 *	@mfunc	returns TRUE if the object is a link
 *
 *	@rdesc	BOOL
 */
BOOL COleObject::IsLink()
{
	return !!(_pi.dwFlags & REO_LINK);
}

/*
 *	COleObject::InitFromREOBJECT(cp, preobj)
 *
 *	@mfunc	initializes this object's state from the given
 *			REOBJECT data structure
 *
 *	@rdesc	HRESULT
 */
HRESULT COleObject::InitFromREOBJECT(
	LONG	cp,			//@parm cp for the object
	REOBJECT *preobj)	//@parm	Data to use for initialization
{
	IOleLink *plink;
	HRESULT	hr = E_INVALIDARG;
	
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::InitFromREOBJECT");
	
	Assert(_punkobj == NULL);
    if(IsZombie())
        return CO_E_RELEASED;

	_cp = cp;

	if(preobj->poleobj)
		hr = preobj->poleobj->QueryInterface(IID_IUnknown, (void **)&_punkobj);
	else
	{
		_punkobj = (IOleClientSite *) this;
		AddRef();
		hr = NOERROR;
	}
        
	if(hr != NOERROR)
		return hr;
	
	_pstg = preobj->pstg;
	if(_pstg)
		_pstg->AddRef();

	_pi.dwFlags	 = preobj->dwFlags & REO_READWRITEMASK;
	_pi.dwUser	 = preobj->dwUser;
	_pi.dvaspect = preobj->dvaspect;

	preobj->sizel.cx = max(preobj->sizel.cx, 0);
	preobj->sizel.cy = max(preobj->sizel.cy, 0);

	memcpy(&_size, &preobj->sizel, sizeof(SIZE));	// COMPATIBILITY ISSUE: the RE 1.0 code had
													// some stuff to deal with REO_DYNAMICSIZE
													// here. We do not currently support that.
	
	if(_punkobj->QueryInterface(IID_IOleLink, (void **)&plink) == NOERROR)
	{
		_pi.dwFlags |= REO_LINK | REO_LINKAVAILABLE;
		plink->Release();
	}

    if(IsZombie())
        return CO_E_RELEASED;
        
	if (IsEqualCLSID(preobj->clsid, CLSID_StaticMetafile) ||
		IsEqualCLSID(preobj->clsid, CLSID_StaticDib) ||
		IsEqualCLSID(preobj->clsid, CLSID_Picture_EnhMetafile))
	{
		_pi.dwFlags |= REO_STATIC;
	}
	else if(IsExcelCLSID(preobj->clsid))
		_pi.dwFlags |= REO_GETMETAFILE;

	else if(IsEqualCLSID(preobj->clsid, CLSID_WordArt))
		_fIsWordArt2 = TRUE;

	else if(IsEqualCLSID(preobj->clsid, CLSID_PaintbrushPicture) ||
			IsEqualCLSID(preobj->clsid, CLSID_BitmapImage))
	{
		_fIsPaintBrush = TRUE;

		// These calls will initialize the flag, _fPBUseLocalSize, which
		// indicates that for this PB object, SetExtent calls are not 
		// acknowledged by the object, and we are to use our local value
		// of _size as the object extents.
		FetchObjectExtents();
		SetExtent(SE_NOTACTIVATING);
	}
#ifndef NOINKOBJECT
	else if(IsEqualCLSID(preobj->clsid, CLSID_Ink))
	{
		ILineInfo	*pILineInfo;

		_fIsInkObject = TRUE;

		_pi.dwFlags &= ~REO_RESIZABLE;		// No resizing for ink objects
		_pi.dwFlags |= REO_BELOWBASELINE | REO_INVERTEDSELECT;

		if(_punkobj->QueryInterface(IID_ILineInfo, (void **)&pILineInfo) == NOERROR)
		{
			UINT	iInkWidth = 0;

			_pILineInfo = pILineInfo;
			
			// Inform Ink object for the formatting changes
			_ped->SetInkProps(_cp, _pILineInfo, &iInkWidth);
		}
	}
#endif

	hr = ConnectObject();

    if(IsZombie())
        return CO_E_RELEASED;
        
	if(preobj->sizel.cx || preobj->sizel.cy)
		memcpy(&_size, &preobj->sizel, sizeof(SIZE));
	else
		FetchObjectExtents();

    if(IsZombie())
        return CO_E_RELEASED;

	// We don't do the following anymore although it was originally spec'd as the correct
	// behavior for applications in OLE 2.01. The reason is that no one else seems to and
	// it seems to result in some odd behavior.
#if 0
    // Finally, lock down Link objects so they we don't try to refetch their
	// extents from the server.  After initialization, link object size is
	// entirely determined by the container.
	if(_pi.dwFlags & REO_LINK)
    {
        // so we don't call GetExtents on remeasuring.
        _fSetExtent = TRUE;
	}
#endif 

	return NOERROR;
}

/*
 *	COleObject::MeasureObj(dypInch, dxpInch, dup, dvpAscent, dvpDescent, dvpDescentFont, tflow)
 *
 * Review: (keithcu) Should yDescentFont be descent of font
 * or descent of entire line? LS does one thing, old measurer
 * does another. I'm hoping that this feature is only used on
 * lines with one font..
 *	@mfunc	calculates the size of this object in device units
 */
void COleObject::MeasureObj(
	long	dvpInch,		//@parm	resolution of device
	long	dupInch,
	LONG &	dup,			//@parm Object width
	LONG &	dvpAscent,		//@parm Object ascent
	LONG &  dvpDescent,		//@parm Object descent
	SHORT	dvpDescentFont,	//@parm object's font descent
	TFLOW	tflow)			//@parm textflow
{
	LONG dvp;

	//If we are rotated and the OLE object doesn't understand rotation, then
	//we will measure and draw the object unrotated
	if (IsUVerticalTflow(tflow) && !(_pi.dwFlags & REO_CANROTATE))
	{
		dup = W32->HimetricToDevice(_size.dv, dupInch);
		dvp = W32->HimetricToDevice(_size.du, dvpInch);
	}
	else
	{
		dup = W32->HimetricToDevice(_size.du, dupInch);
		dvp = W32->HimetricToDevice(_size.dv, dvpInch);
	}

	if (_pi.dwFlags & REO_BELOWBASELINE)
	{
		dvpDescent = dvpDescentFont;
		dvpAscent = max(0, dvp - dvpDescent);
	}
	else //The normal case
	{
		dvpAscent = dvp;
		dvpDescent = 0;
	}
}

/* 
 * COleObject::InHandle(x, y, &pt)
 *
 * @mfunc  See if a point is in the rectangle defined by the handle at
 *		the given coordinates.
 *
 * @rdesc True if point is in handle.
 */
BOOL COleObject::InHandle(
	int		up,		//@parm Upper left corner x coordinate of handle box
	int		vp,		//@parm Upper left corner y coordinate of handle box
	const POINTUV &pt)//@parm Point to check
{
    RECTUV    rc;
    
    rc.left = up;
    rc.top = vp;

	// Add one to bottom right because PtInRect does not consider
	// points on bottom or right to be in rect.
    rc.right = rc.left + dxyHandle + 1;
    rc.bottom = rc.top + dxyHandle + 1;
    return PtInRect(&rc, pt);
}  

/*
 *	COleObject::CheckForHandleHit(&pt)
 *
 *	@mfunc	Check for a hit on any of the frame handles.
 *
 *	@rdesc	 NULL if no hit, cursor resource ID if there is a hit.
 */
LPTSTR COleObject::CheckForHandleHit(
	const POINTUV &pt,	//@parm POINT containing client coord. of the cursor.
	BOOL fLogical)		//@parm TRUE if you want the logical as opposed to visual cursor
{
	// If object is not resizeable, no chance of hitting a resize handle!
	if(!(_pi.dwFlags & REO_RESIZABLE) || FWrapTextAround())
		return NULL;

	RECTUV rc;
	GetRectuv(rc);

	if(!_dxyFrame)
		_dxyFrame = dxyFrameDefault;

	// Check to see if point is farther into the interior of the
	// object than the handles extent. If it is we can just bail.
	InflateRect(&rc, -(_dxyFrame + dxyHandle), -(_dxyFrame + dxyHandle));
	if(PtInRect(&rc, pt))
		return NULL;

	WCHAR *idcur = 0;

	// Check to see if point is in any of the handles and
	// return the proper cursor ID if it is.
	InflateRect(&rc, dxyHandle, dxyHandle);

	if(InHandle(rc.left, rc.top, pt) ||
	   InHandle(rc.right-dxyHandle, rc.bottom-dxyHandle, pt))
	{
		idcur = IDC_SIZENWSE;
	}
	else if(InHandle(rc.left, rc.top+(rc.bottom-rc.top-dxyHandle)/2, pt) ||
	   InHandle(rc.right-dxyHandle,
			rc.top+(rc.bottom-rc.top-dxyHandle)/2, pt))
	{
		idcur = IDC_SIZEWE;
	}
	else if(InHandle(rc.left, rc.bottom-dxyHandle, pt) ||
	   InHandle(rc.right-dxyHandle, rc.top, pt))
	{
		idcur = IDC_SIZENESW;
	}
	else if(InHandle(rc.left+(rc.right-rc.left-dxyHandle)/2, rc.top, pt) ||
	   InHandle(rc.left+(rc.right-rc.left-dxyHandle)/2,
			rc.bottom-dxyHandle, pt))
	{
		idcur = IDC_SIZENS;
	}

	//Convert logical cursor to visual cursor
	if (!fLogical && IsUVerticalTflow(_ped->_pdp->GetTflow()))
	{
		if (idcur == IDC_SIZENS)
			idcur = IDC_SIZEWE;
		else if (idcur == IDC_SIZEWE)
			idcur = IDC_SIZENS;
		else if (idcur == IDC_SIZENESW)
			idcur = IDC_SIZENWSE;
		else if (idcur == IDC_SIZENWSE)
			idcur = IDC_SIZENESW;
	}

	return idcur;
}

/* 
 * COleObject::DrawHandle(hdc, x, y)
 *
 * @mfunc  Draw a handle on the object frame at the specified coordinate
 */
void COleObject::DrawHandle(
	HDC hdc,	//@parm HDC to be drawn into
	int x,		//@parm x coordinate of upper-left corner of handle box
	int y)		//@parm y coordinate of upper-left corner of handle box
{
    RECT    rc;
    
	// Draw handle by inverting
    rc.left = x;
    rc.top = y;
    rc.right = x + dxyHandle;
    rc.bottom = y + dxyHandle;
    InvertRect(hdc, &rc);
}  

/*
 *	COleObject::DrawFrame(pdp, hdc, prc)
 *
 *	@mfunc	Draw a frame around the object.  Invert if required and
 *		include handles if required.
 */
void COleObject::DrawFrame(
	const CDisplay *pdp,    //@parm the display to draw to
	HDC             hdc,	//@parm the device context
	RECT           *prc)  //@parm the rect around which to draw
{
	if(_pi.dwFlags & REO_OWNERDRAWSELECT)
		return;

	RECT	rc;
	CopyRect(&rc, prc);

	if(_pi.dwFlags & REO_INVERTEDSELECT)
		InvertRect(hdc, &rc);				//Invert entire object

	else
	{
		// Just the border, so use a null brush
		int ropOld = SetROP2(hdc, R2_NOT);
		HBRUSH hbrOld = (HBRUSH) SelectObject(hdc, GetStockObject(NULL_BRUSH));
		Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);
		SelectObject(hdc, hbrOld);
		SetROP2(hdc, ropOld);
	}

	if(_pi.dwFlags & REO_RESIZABLE)
	{
		int     bkmodeOld;
		HPEN	hpen;
		LOGPEN	logpen;

		bkmodeOld = SetBkMode(hdc, TRANSPARENT);

		// Get frame width
		_dxyFrame = dxyFrameDefault;
		hpen = (HPEN)GetCurrentObject(hdc, OBJ_PEN);
		if(W32->GetObject(hpen, sizeof(LOGPEN), &logpen))
		{
			if(logpen.lopnWidth.x)
				_dxyFrame = (SHORT)logpen.lopnWidth.x;
		}

		// Draw handles inside rectangle boundary
 		InflateRect(&rc, -_dxyFrame, -_dxyFrame);

		LONG x = rc.left;

		DrawHandle(hdc, x, rc.top);
		DrawHandle(hdc, x, rc.top	 + (rc.bottom - rc.top - dxyHandle)/2);
		DrawHandle(hdc, x, rc.bottom - dxyHandle);

		x = rc.left + (rc.right - rc.left - dxyHandle)/2; 
		DrawHandle(hdc, x, rc.top);
		DrawHandle(hdc, x, rc.bottom - dxyHandle);

		x = rc.right - dxyHandle;
		DrawHandle(hdc, x, rc.top);
		DrawHandle(hdc, x, rc.top + (rc.bottom - rc.top - dxyHandle)/2);
		DrawHandle(hdc, x, rc.bottom - dxyHandle);

		SetBkMode(hdc, bkmodeOld);
	}
}


/*
 *	COleObject::CreateDib (hdc)
 *
 *	@mfunc	Create DIB for Windows CE display
 */
void COleObject::CreateDib(
	HDC hdc)
{
	int				nCol = 0;
    BYTE            *pbDib;
	HGLOBAL			hnew = NULL;
	BYTE			*pbSrcBits;
	LPBITMAPINFO	pbmi = (LPBITMAPINFO) GlobalLock(_hdata);
	DWORD			dwPixelsPerRow = 0;
	DWORD			dwPixels = 0;

    if(pbmi->bmiHeader.biBitCount <= 8)
    {
	    nCol = 1 << pbmi->bmiHeader.biBitCount;

		// Calculate the number of pixels.  Account for DWORD alignment
		DWORD dwPixelsPerByte = 8 / pbmi->bmiHeader.biBitCount;
		DWORD dwBitsPerRow = pbmi->bmiHeader.biWidth * pbmi->bmiHeader.biBitCount;
		dwBitsPerRow = (dwBitsPerRow + 7) & ~7;				// Round up to byte boundary
		DWORD dwBytesPerRow = dwBitsPerRow / 8;
		dwBytesPerRow = (dwBytesPerRow + 3) & ~3;			// Round up to DWORD
		dwPixelsPerRow = dwBytesPerRow * dwPixelsPerByte;

		// Double check with original
		#ifdef DEBUG
		DWORD dwBlockSize = GlobalSize(_hdata);
		DWORD dwBitMapBytes = dwBlockSize - sizeof(BITMAPINFOHEADER) - (nCol * sizeof(RGBQUAD));
		DWORD dwBitMapPixels = dwBitMapBytes * dwPixelsPerByte;
		dwPixels = dwPixelsPerRow * pbmi->bmiHeader.biHeight;
		Assert(dwPixels == dwBitMapPixels);
		#endif
    }
	else
		dwPixelsPerRow = pbmi->bmiHeader.biWidth;

	dwPixels = dwPixelsPerRow * pbmi->bmiHeader.biHeight;
    
	pbSrcBits = (BYTE*)(pbmi) + sizeof(BITMAPINFOHEADER) + (nCol * sizeof(RGBQUAD));

#ifdef UNDER_NT

	// For NT viewing convert four color bitmaps to 16 color bitmap
	if(nCol == 4)
	{
		// First let's figure out how big the new memory block needs to be.
		DWORD cb = sizeof(BITMAPINFOHEADER) + (16 * sizeof(RGBQUAD));
		cb += dwPixels / 2;
		hnew = GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, cb);
	
		// Now locate the interesting places
		LPBITMAPINFO pNewBmi = (LPBITMAPINFO) GlobalLock(hnew);
		BYTE *pNewBits = (BYTE*)(pNewBmi) + sizeof(BITMAPINFOHEADER) + (16 * sizeof(RGBQUAD));

		// Modify the header
		pNewBmi->bmiHeader = pbmi->bmiHeader;
		pNewBmi->bmiHeader.biBitCount = 4;
		pNewBmi->bmiHeader.biClrUsed = 4;

		// Set up the DIB RGB Colors.
		for (int i = 0; i < 16; i++)
		{
			BYTE data = 0;
			switch (i % 4)
			{
			case 0:
				break;
			case 1:
				data = 0x55;
				break;
			case 2:
				data = 0xAA;
				break;
			case 3:
				data = 0xFF;
				break;
			}
			pNewBmi->bmiColors[i].rgbBlue = data;
			pNewBmi->bmiColors[i].rgbGreen = data;
			pNewBmi->bmiColors[i].rgbRed = data;
			pNewBmi->bmiColors[i].rgbReserved = 0;
		}

		// Convert the byte array.
		for (DWORD j = 0; j < dwPixels; j++)
		{
			int iSrcByte = j / 4;

			BYTE bits = pbSrcBits[iSrcByte];
			bits >>= 6 - (j%4) * 2;
			bits &= 0x3;
			int iDstByte = j / 2;
			bits <<= 4 - (j%2) * 4;
			pNewBits[iDstByte] |= bits;
		}
		GlobalUnlock(pbmi);
		pbmi = pNewBmi;
		pbSrcBits = pNewBits;
	}
#endif

	_hdib = CreateDIBSection(hdc, pbmi, DIB_RGB_COLORS, (void**)&pbDib, NULL, 0);
	if(_hdib == NULL)
	{
		_ped->GetCallMgr()->SetOutOfMemory();

        // V-GUYB:
        // Do not attempt to repaint this picture until the user starts typing in the
        // control. This allows the user to dismiss the oom that will appear and then
        // save the document, and then free up some space. If we don't do this here, 
        // every time the oom msg is dismissed it will appear again. This doesn't allow 
        // the user to save the document unless they can find some memory to free.
        _fDraw = FALSE;

		TRACEWARNSZ("Out of memory creating DIB");
		return;
	}

	DWORD nBytes;

	if(nCol)
	{
		DWORD nPixelsPerByte =  8 / pbmi->bmiHeader.biBitCount;
		nBytes = dwPixels / nPixelsPerByte;
	}
	else
		nBytes =  dwPixels * 4;			// Each pixel occupies 4 bytes in DIB
	CopyMemory(pbDib, pbSrcBits, nBytes);

	GlobalUnlock(pbmi);
	GlobalFree(hnew);
}

/*
 *	COleObject::DrawDib (hdc, prc)
 *
 *	@mfunc	Auxiliary function that draws the dib in the given dc
 */
void COleObject::DrawDib(
	HDC hdc,
	RECT *prc)
{
	if(!_hdib)
		CreateDib(hdc);

	// If _hdib is still NULL, just return.  Maybe out of memory.
	if(!_hdib)
		return;

	HDC hdcMem = CreateCompatibleDC(hdc);
	if (!hdcMem)
		return;

	LPBITMAPINFO	pbmi = (LPBITMAPINFO) GlobalLock(_hdata);
	SelectObject(hdcMem, _hdib);
    StretchBlt(hdc, prc->left, prc->top,
			prc->right - prc->left, prc->bottom - prc->top,
			hdcMem, 0, 0, pbmi->bmiHeader.biWidth, pbmi->bmiHeader.biHeight, SRCCOPY);
	GlobalUnlock(pbmi);
	DeleteDC(hdcMem);
}

/*
 *	COleObject::DrawObj (pdp, hdc, fMetafile, ppt, prcRender)
 *
 *	@mfunc	draws the object.
 *	REVIEW (keithcu) How expensive is SaveDC/RestoreDC? We could
 *  have a flag when we know that the object isn't going to totally screw
 *	around with our DC and then not go through that expense.
 *
 */
void COleObject::DrawObj(
	const CDisplay *pdp,	//@parm Display object for the view
	LONG		dypInch,	//@parm Resolution of device
	LONG		dxpInch,
	HDC			hdc,		//@parm Drawing HDC (can differ from display's)
	const RECTUV *prcClip,	//@parm Clipping rectangle
	BOOL		fMetafile,	//@parm Whether the HDC is a metafile
	POINTUV	   *ppt,		//@parm Top left corner of where to draw
	LONG		dvpBaselineLine,
	LONG		dvpDescentMaxCur,
	TFLOW		tflow)
{
	BOOL			 fMultipleSelect = FALSE;
	CObjectMgr *	 pobjmgr = _ped->GetObjectMgr();
	IViewObject *	 pvo;
	CDisplayPrinter *pdpPrint;
	RECT			 rc, rcClip;
	RECTUV			 rcuv;
	LONG			 cpMin, cpMost;
	_ped->GetSelRangeForRender(&cpMin, &cpMost);
	BOOL			 fSelected = _cp >= cpMin && _cp < cpMost && !FWrapTextAround();

	SaveDC(hdc);	 //Anything in this function below could change things.

	if(pdp->IsMain() && !(_pi.dwFlags & REO_OWNERDRAWSELECT))
	{
		if (fSelected)
		{
			if(cpMost - cpMin > 1)
				fMultipleSelect = TRUE;

			// The following overwrites the selection colors currently
			// selected into the hdc. We do this for RE 2.0 compatibility,
			// e.g., else selected name links in Outlook appear yellow
			// after the InvertRect() in DrawFrame() (altho the semicolon
			// blanks appear in selection colors). Note: we could define
			// REO_OWNERDRAWSELECT, which would bypass the following 2 lines
			// and suppress the InvertRect below and in DrawFrame(). Then
			// Outlook's From:, To:, and CC: would have correct selection
			// colors throughout.
			::SetTextColor(hdc, _ped->TxGetForeColor());
			::SetBkColor  (hdc, _ped->TxGetBackColor());
		}
	}

	if(_fInPlaceActive || !_fDraw)
	{
		// If we're inplace active, don't do anything; the server is
		// drawing for us. We also don't do anything prior to the fDraw
		// property being set
		return;
	}

	// Draw object where we are asked within rendering rectangle
	rcuv.left = ppt->u;
	rcuv.bottom = ppt->v + dvpBaselineLine;

	if (IsUVerticalTflow(tflow) && !(_pi.dwFlags & REO_CANROTATE))
	{
		rcuv.right = rcuv.left + W32->HimetricToDevice(_size.dv, dypInch);
		rcuv.top = rcuv.bottom - W32->HimetricToDevice(_size.du, dxpInch);
	}
	else
	{
		rcuv.right = rcuv.left + W32->HimetricToDevice(_size.du, dxpInch);
		rcuv.top = rcuv.bottom - W32->HimetricToDevice(_size.dv, dypInch);
	}

	if (_pi.dwFlags & REO_BELOWBASELINE)
		OffsetRect((RECT*)&rcuv, 0, dvpDescentMaxCur);

	pdp->RectFromRectuv(rc, rcuv);
	pdp->RectFromRectuv(rcClip, *prcClip);

	if (fSelected)
		SetBkMode(hdc, OPAQUE);

	SetTextAlign(hdc, TA_TOP);

	SaveDC(hdc);  // calls to OLE object (IViewObject::Draw or OleDraw) might change HDC

	//Do clipping because OLE doesn't know where to draw
	IntersectClipRect(hdc, rcClip.left, rcClip.top, rcClip.right, rcClip.bottom);

	if(_fIsEBookImage)
	{
		POINT pt = {rc.left, rc.top};
		WinLPtoDP(hdc, &pt, 1);
		if(_ped->fInHost2())
    		(_ped->GetHost())->TxEBookImageDraw(_EBookImageID, hdc, &pt, NULL/*&rc*/,
                                        (pobjmgr->GetSingleSelect()==this));
	}
	else if(_hdata)
	{
		// This is some Windows CE Dib, let's try the direct approach
		DrawDib(hdc, &rc);
	}
	else if(fMetafile)
	{
		if(_punkobj->QueryInterface(IID_IViewObject, (void **)&pvo) 
				== NOERROR)
		{
			pdpPrint = (CDisplayPrinter *)pdp;

			//REVIEW (keithcu) Has this ever been tested? GetPrintPage
			//is in twips while IViewObject::Draw is in metafile units!
			RECT rc1 = pdpPrint->GetPrintPage();

			// Fix up rc for Draw()
			rc1.bottom = rc1.bottom - rc1.top;			    
			rc1.right = rc1.right - rc1.left;

			pvo->Draw(_pi.dvaspect, -1, NULL, NULL, 0, hdc, (RECTL *)&rc,
					(RECTL *)&rc1, NULL, 0);
			pvo->Release();
		}
	}
	else
		OleDraw(_punkobj, _pi.dvaspect, hdc, &rc);

	RestoreDC(hdc, -1);

	// Do selection stuff if this is for the main (screen) view.
	if(pdp->IsMain() && !FWrapTextAround())
	{
		if(_pi.dwFlags & REO_OPEN)
			OleUIDrawShading(&rc, hdc);

		// If the object has been selected by clicking on it, draw
		// a frame and handles around it.  Otherwise, if we are selected
		// as part of a range, invert ourselves.
		if(!fMetafile && pobjmgr->GetSingleSelect() == this)
			DrawFrame(pdp, hdc, &rc);

		else if(fMultipleSelect)
			InvertRect(hdc, &rc);
	}

	RestoreDC(hdc, -1);
}

/*
 *	COleObject::Delete (publdr)
 *
 *	@mfunc	deletes this object from the backing store _without_
 *			making outgoing calls.  The commit on generated anti-events
 *			will handle the outgoing calls
 */
void COleObject::Delete(
	IUndoBuilder *publdr)
{

	Assert(_fInUndo == FALSE);
	_fInUndo = TRUE;

	//REVIEW (keithcu) Too heavy handed?
 //	if (FWrapTextAround())
//		_ped->_pdp->InvalidateRecalc();

	CNotifyMgr *pnm = _ped->GetNotifyMgr();
	if(pnm)
		pnm->Remove((ITxNotify *)this);

	if(publdr)
	{
		// The anti-event will take care of calling IOO::Close for us
		IAntiEvent *pae = gAEDispenser.CreateReplaceObjectAE(_ped, this);
		if(pae)
			publdr->AddAntiEvent(pae);
	}
	else
	{
		Close(OLECLOSE_NOSAVE);
		MakeZombie();
	}

	// If we're being deleted, we can't be selected anymore
	_pi.dwFlags &= ~REO_SELECTED;
	_fDraw = 0;
}

/*
 *	COleObject::Restore()
 *
 *	@mfunc	restores the object from the undo state back into the
 *			backing store
 *
 *			No outgoing calls will be made
 */
void COleObject::Restore()
{
	Assert(_fInUndo);

	_fInUndo = FALSE;
	_fDraw = TRUE;

	CNotifyMgr *pnm = _ped->GetNotifyMgr();
	if(pnm)
		pnm->Add((ITxNotify *)this);
}

/*
 *	COleObject::SetREOSELECTED (fSelect)
 *
 *	@mfunc	cmember set REO_SELECTED state
 */
void COleObject::SetREOSELECTED(
	BOOL fSelect)
{
	_pi.dwFlags &= ~REO_SELECTED;
	if(fSelect)
		_pi.dwFlags |= REO_SELECTED;
}
    
/*
 *	COleObject::Close(dwSave)
 *
 *	@mfunc	closes this object
 */
void COleObject::Close(
	DWORD	dwSave)		//same as IOleObject::Close
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::Close");

	if(!_punkobj)
		return;

	IOleObject *poo;
	if(_punkobj->QueryInterface(IID_IOleObject, (void **)&poo) == NOERROR)
	{
		poo->Close(dwSave);
		poo->Release();
	}
}

				
//
//	PRIVATE methods
//
/*
 *	COleObject::~COleObject()
 *
 *	@mfunc	destructor
 */
COleObject::~COleObject()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::~COleObject");

	CleanupState();
}

/*
 *	COleObject::SavePrivateState()
 *
 *	@mfunc	Saves information such as the aspect and various flags
 *	into the object's storage.
 *
 *	@devnote	This method is used mostly for compatibility with 
 *	richedit 1.0--we save the same information they did.
 *
 *	Also note that this method returns void--even if any particular
 *	call fails, we should be able to "recover" and limp along.
 *	Richedit 1.0 also had this behavior.
 */
void COleObject::SavePrivateState()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::SavePrivateState");
	Assert(_pstg);

	IStream *	pstm;
	HRESULT hr = _pstg->CreateStream(szSiteFlagsStm, STGM_READWRITE |
					STGM_CREATE | STGM_SHARE_EXCLUSIVE, 0, 0, &pstm);
    if(IsZombie())
        return;
        
	if(hr == NOERROR)
	{
		pstm->Write(&_pi, sizeof(PersistedInfo), NULL);
		pstm->Release();
	}
}

/*
 *	COleObject::FetchObjectExtents()
 *
 *	@mfunc 	determines the object's size in himetric.  Typically, this
 *			is achieved via IOleObject::GetExtent, but some error 
 *			recovery is implemented
 *
 *	@rdesc	void.  _size is updated
 */
void COleObject::FetchObjectExtents()
{
	HRESULT hr = NOERROR;
	IOleObject *poo;
	IViewObject2 *pvo;

    if(IsZombie())
        return;
        
	// We _don't_ want to make calls to GetExtent if:
	// (1) We have outstanding updates to _size for which we
	//		haven't successfully called SetExtent
	// (2) This is a PaintBrush object and the most recent call 
	//		to SetExtent for this PB object failed

	if(_fIsEBookImage)
	{
		_size.du = _ped->_pdp->DUtoHimetricU(_sizeEBookImage.cx);
		_size.dv = _ped->_pdp->DVtoHimetricV(_sizeEBookImage.cy);
	}
	else
	if(_fAspectChanged || !(_fSetExtent || (_fIsPaintBrush && _fPBUseLocalSize)))
	{	
		// try IOleObject::GetExtent as long as we shouldn't try for
		// the metafile first.

		// If this flag was set, it has done its job so turn it off.
		_fAspectChanged = FALSE;

		if(!(_pi.dwFlags & REO_GETMETAFILE))
		{
			hr = _punkobj->QueryInterface(IID_IOleObject, (void **)&poo);
			if(hr == NOERROR)
			{
				hr = poo->GetExtent(_pi.dvaspect, (SIZE*)&_size);
				poo->Release();
			}
			if(IsZombie())
				return;
		}
		else
			hr = E_FAIL;
        
		if(hr != NOERROR)
		{
			if(_punkobj->QueryInterface(IID_IViewObject2, (void **)&pvo) == NOERROR)
			{
				hr = pvo->GetExtent(_pi.dvaspect, -1, NULL, (SIZE*)&_size);
				pvo->Release();
			}
		}

	    if(IsZombie())
	        return;
        
		if(hr != NOERROR || _size.du == 0 || _size.dv == 0)
			_size.du = _size.dv = 2000;
	}
}

/*
 *	COleObject::ConnectObject()
 *
 *	@mfunc	setup the necessary advises to the embedded object.
 *
 *	@rdesc 	HRESULT
 *
 *	@comm	This code is similar to ole2ui's OleStdSetupAdvises
 */
HRESULT COleObject::ConnectObject()
{
	IViewObject *pvo;
	IOleObject *poo;

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::ConnectObject");
	
    if(IsZombie())
        return CO_E_RELEASED;
	
	Assert(_punkobj);

	if(_punkobj->QueryInterface(IID_IViewObject, (void **)&pvo) == NOERROR)
	{
		pvo->SetAdvise(_pi.dvaspect, ADVF_PRIMEFIRST, (IAdviseSink *)this);
		pvo->Release();
	}

    if(IsZombie())
        return CO_E_RELEASED;
	
	HRESULT hr = _punkobj->QueryInterface(IID_IOleObject, (void **)&poo);
	if(hr == NOERROR)
	{
		hr = poo->Advise((IAdviseSink *)this, &_dwConn);

		CObjectMgr *pobjmgr = _ped->GetObjectMgr();
		Assert(pobjmgr);		
		if(!pobjmgr)
		{
			poo->Release();
			return E_OUTOFMEMORY;
		}

		// The doc may be NULL, but not the app.  Don't do anything
		// if the app name is NULL
		if(pobjmgr->GetAppName())
		{
			hr = poo->SetHostNames(pobjmgr->GetAppName(), 
						pobjmgr->GetDocName());
		}
		poo->Release();
	}

    if(IsZombie())
        return CO_E_RELEASED;
	
	OleSetContainedObject(_punkobj, TRUE);
	return hr;
}

/*
 *	COleObject::DisconnectObject
 *
 *	@mfunc	reverses the connections made in ConnectObject and releases
 *			the object.  Note that the object's storage is _NOT_
 *			released.
 */
void COleObject::DisconnectObject()
{
	IOleObject * poo = NULL;
	IViewObject *pvo = NULL;

	if(IsZombie())
		return;		// Already Disconnected.

	if(_punkobj->QueryInterface(IID_IOleObject, (void **)&poo) == NOERROR)
	{
		poo->SetClientSite(NULL);
		if(_dwConn)
			poo->Unadvise(_dwConn);
	
		poo->Release();
	}

	if(_punkobj->QueryInterface(IID_IViewObject, (void **)&pvo) == NOERROR)
	{
		pvo->SetAdvise(_pi.dvaspect, ADVF_PRIMEFIRST, NULL);
		pvo->Release();
	}

#ifndef NOINKOBJECT
	SafeReleaseAndNULL((IUnknown**)&_pILineInfo);
#endif

	CoDisconnectObject(_punkobj, NULL);
	SafeReleaseAndNULL(&_punkobj);
}

/*
 *	COleObject::MakeZombie()
 *
 *	@mfunc	Force this object to enter a zombie state.  This
 *      is called when we should be gone but aren't.  It cleans
 *      up our state and flags us so we don't do nasty things
 *		between now and the time were are deleted.
 *
 */
void COleObject::MakeZombie()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::MakeZombie");

	CleanupState();
    Zombie();
}

/*
 *	COleObject::CleanupState()
 *
 *	@mfunc	Called on delete and when we become zombied.  It cleans
 *		up our member data and any other dependencies that need to
 *		be resolved.
 */
void COleObject::CleanupState()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::CleanupState");
	
	CDocInfo *pDocInfo = NULL;
	if(_ped)
	{
		pDocInfo = _ped->GetDocInfoNC();
		if(!_fInUndo)
		{
			CNotifyMgr *pnm = _ped->GetNotifyMgr();
			if(pnm)
				pnm->Remove((ITxNotify *)this);

			_ped = NULL;
		}
	}

	DisconnectObject();

	if(_pstg)
		SafeReleaseAndNULL((IUnknown**)&_pstg);

	if(_hdib)
	{
		::DeleteObject(_hdib);
		_hdib = NULL;
	}

	if(!pDocInfo || _hdata != pDocInfo->_hdata)
		GlobalFree(_hdata);	// Don't free _hdata if background is using it

	_hdata = NULL;
	if(_pimageinfo)
	{
		delete _pimageinfo;
		_pimageinfo = NULL;
	}
}	

/*
 *	COleObject::ActivateObj	(uiMsg, wParam, lParam)
 *	
 *	@mfunc Activates the object.
 *
 *	@rdesc
 *		BOOL	Whether object has been activated.
 */
BOOL COleObject::ActivateObj(
	UINT uiMsg,
	WPARAM wParam,
	LPARAM lParam)
{
	LPOLEOBJECT		poo;
	HWND			hwnd;
	MSG				msg;
	DWORD			dwPos;

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::AcitvateObj");

	if(_ped->TxGetWindow(&hwnd) != NOERROR)
		return FALSE;

	// Fill in message structure
	msg.hwnd = hwnd;
	msg.message = uiMsg;
	msg.wParam = wParam;
	msg.lParam = lParam;
	msg.time = GetMessageTime();
	dwPos = GetMessagePos();
	msg.pt.x = (LONG) LOWORD(dwPos);
	msg.pt.y = (LONG) HIWORD(dwPos);

	// Force this object to be selected, if it isn't already
	// Update the selection before making the outgoing call
	if(!(_pi.dwFlags & REO_SELECTED))
	{
		CTxtSelection *psel = _ped->GetSel();
		if(psel)
			psel->SetSelection(_cp, _cp + 1);
	}

	// Execute the primary verb
	if(_punkobj->QueryInterface(IID_IOleObject, (void **)&poo) == NOERROR)
	{
		_fActivateCalled = TRUE;

		// Make sure we tell the object its size has changed if we haven't
		// already notified it.
		if(_fSetExtent)
			SetExtent(SE_ACTIVATING);

		HRESULT	hr;
		RECTUV rc;
		RECT rcPos;

		GetRectuv(rc);
		_ped->_pdp->RectFromRectuv(rcPos, rc);
		hr = poo->DoVerb(OLEIVERB_PRIMARY, &msg, (LPOLECLIENTSITE)this, 0, hwnd, &rcPos);

		if(FAILED(hr))
		{
			ENOLEOPFAILED	enoleopfailed;

			enoleopfailed.iob = _ped->_pobjmgr->FindIndexForCp(GetCp());
			enoleopfailed.lOper = OLEOP_DOVERB;
			enoleopfailed.hr = hr;
	        _ped->TxNotify(EN_OLEOPFAILED, &enoleopfailed);
		}
	    poo->Release();
		if(_fInPlaceActive && !(_pi.dwFlags & REO_INPLACEACTIVE))
		{
			CObjectMgr *pobjmgr = _ped->GetObjectMgr();
			if(!pobjmgr)
			{
				_fActivateCalled = FALSE;
				return FALSE;
			}

			Assert(!pobjmgr->GetInPlaceActiveObject());	
			pobjmgr->SetInPlaceActiveObject(this);
			_pi.dwFlags |= REO_INPLACEACTIVE;
		}
		_fActivateCalled = FALSE;
	}
	else
		return FALSE;

	return TRUE;
}

/*
 *	COleObject::DeActivateObj
 *	
 *	@mfunc Deactivates the object.
 *
 */
HRESULT COleObject::DeActivateObj(void)
{
	IOleInPlaceObject * pipo;
	IOleObject *poo;
	MSG msg;
	HRESULT hr = NOERROR;

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::DeActivateObj");

	if (_fDeactivateCalled)
	{
		// There are multiple paths through the deactive code. The assumption
		// with this logic is that it is more disconcerting for an app to
		// get multiple deactivate calls than the opposite. This might
		// prove to be an incorrect assumption. This go put in because I
		// added a DeActivateObj call in DeActivateObj where there wasn't
		// one before and I was afraid that this could cause problems because
		// apps might get a call that they didn't have before. It is important
		// to note that the opposite might be the case. (a-rsail).
		return NOERROR;
	}

	_fDeactivateCalled = TRUE;

	if(_punkobj->QueryInterface(IID_IOleInPlaceObject, (void **)&pipo) 
		== NOERROR)
	{
		hr  =_punkobj->QueryInterface(IID_IOleObject, (void **)&poo);
		if(hr == NOERROR) 
		{
			// This code is a bit different from 1.0, but seems to 
			// make things work a bit better.  Basically, we've taken a leaf
			// from various sample apps and do the most brute force "de-activate"
			// possible (you'd think just one call would be enough ;-)

			// Don't bother with the error return here.
			pipo->UIDeactivate();
			
			// Fake something
			ZeroMemory(&msg, sizeof(MSG));
			msg.message = WM_LBUTTONDOWN;	
			_ped->TxGetWindow(&msg.hwnd);

			RECT	rcPos;
			RECTUV rcuv;
			GetRectuv(rcuv);
			_ped->_pdp->RectFromRectuv(rcPos, rcuv);

			// Again, don't bother checking for errors; we need to
			// plow through and get rid of stuff as much as possible.
			poo->DoVerb(OLEIVERB_HIDE, &msg, (IOleClientSite *)this, -1, msg.hwnd, &rcPos);

			// COMPATIBILITY ISSUE (alexgo): the RE1.0 code did some funny
			// stuff with undo here, but I don't think it's necessary now
			// with our multi-level undo model.
			hr = pipo->InPlaceDeactivate();
			poo->Release();
		}
	    pipo->Release();
	}

	_fDeactivateCalled = FALSE;
	return hr; 
}

/*
 *	COleObject::Convert (rclsidNew,	lpstrUserTypeNew)
 *
 *	@mfunc	Converts the object to the specified class.  Does reload
 *		the object but does NOT force an update (caller must do this).
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
HRESULT COleObject::Convert(
	REFCLSID rclsidNew,			//@parm Destination clsid
	LPCSTR	 lpstrUserTypeNew)	//@parm New user type name
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::Convert");

	CLIPFORMAT cfOld;
	CLSID clsidOld;
	LPOLESTR szUserTypeOld = NULL;
	HRESULT hr;
	HRESULT hrLatest;
	UsesMakeOLESTR;


	// If object has no storage, return
	if(!_pstg)
		return ResultFromScode(E_INVALIDARG);

	// Read the old class, format, and user type in
	if ((hr = ReadClassStg(_pstg, &clsidOld)) ||
		(hr = ReadFmtUserTypeStg(_pstg, &cfOld, &szUserTypeOld)))
	{
		return hr;
	}

	// Unload object
	Close(OLECLOSE_SAVEIFDIRTY);
	_punkobj->Release();

    if(IsZombie())
        return CO_E_RELEASED;

	// Write new class and user type, but old format, into storage
	if ((hr = WriteClassStg(_pstg, rclsidNew)) ||
		(hr = WriteFmtUserTypeStg(_pstg, cfOld,
			(LPOLESTR) MakeOLESTR(lpstrUserTypeNew))) ||
		(hr = SetConvertStg(_pstg, TRUE)) ||
		((hr = _pstg->Commit(0)) && (hr = _pstg->Commit(STGC_OVERWRITE))))
	{
		// Uh oh, we're in a bad state; rewrite the original info
		(VOID) WriteClassStg(_pstg, clsidOld);
		(VOID) WriteFmtUserTypeStg(_pstg, cfOld, szUserTypeOld);
	}

    if(IsZombie())
        return CO_E_RELEASED;

	// Reload the object and connect. If we can't reload it, delete it.
	hrLatest = OleLoad(_pstg, IID_IOleObject, (LPOLECLIENTSITE) this,
			(void **)&_punkobj);

	if(hrLatest != NOERROR)
	{
		CRchTxtPtr	rtp(_ped, _cp);

		// we don't want the delete of this object to go on the undo
		// stack.  We use a space so that cp's will work out right for
		// other undo actions.
		rtp.ReplaceRange(1, 1, L" ", NULL, -1);
	}
	else
		ConnectObject();

	// Free the old
	CoTaskMemFree(szUserTypeOld);
	return hr ? hr : hrLatest;
}

/*
 *	COleObject::ActivateAs (rclsid, rclsidAs)
 *
 *	@mfunc	Handles a request by the user to activate all objects of a particular
 *		class as objects of another class.
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
HRESULT COleObject::ActivateAs(
	REFCLSID rclsid,
	REFCLSID rclsidAs)
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::ActivateAs");

	IOleObject * poo = NULL;
	CLSID	clsid;

	// Get clsid of object
	HRESULT hr = _punkobj->QueryInterface(IID_IOleObject, (void **)&poo);
	if(hr == NOERROR)
	{
		// NOTE:  We are depending on the behavior of GetUserClassID to
		// return the current clsid of the object (not the TreatAs id).
		// This should hold true as long as long as we haven't reloaded
		// it yet.  If there are problems with ActivateAs in the future,
		// this might be a suspect.
		hr = poo->GetUserClassID(&clsid);
		poo->Release();
	}

	if(hr != NOERROR)
		return hr;
	
    if(IsZombie())
        return CO_E_RELEASED;

	// Check to see if object clsid matches clsid to be treated as something
	// else. If it is we need to unload and reload the object.
	if(IsEqualCLSID(clsid, rclsid))
	{
		// Unload object
		Close(OLECLOSE_SAVEIFDIRTY);
		_punkobj->Release();

		if(IsZombie())
			return CO_E_RELEASED;

		// Reload object and connect. If we can't reload it, delete it.
		hr = OleLoad(_pstg, IID_IOleObject, (LPOLECLIENTSITE) this,
				(void **)&_punkobj);

		if(hr != NOERROR)
		{
			CRchTxtPtr	rtp(_ped, _cp);

			// We don't want the delete of this object to go on the undo
			// stack.  We use a space so that cp's will work out right for
			// other undo actions.
			rtp.ReplaceRange(1, 1, L" ", NULL, -1);
		}
		else
			ConnectObject();
	}
	return hr;
}

/*
 *	COleObject::SetLinkAvailable(fAvailable)
 *
 *	@mfunc
 *		Allows client to tell us whether the link is available or not.
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
HRESULT COleObject::SetLinkAvailable(
	BOOL fAvailable)	//@parm	if TRUE, make object linkable
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::SetLinkAvailable");
	
	// If this is not a link, return
	if(!(_pi.dwFlags & REO_LINK))
		return E_INVALIDARG;

	// Set flag as appropriate
	_pi.dwFlags &= ~REO_LINKAVAILABLE;
	if(fAvailable)
		_pi.dwFlags |= REO_LINKAVAILABLE;

	return NOERROR;
}

/*
 *	COleObject::WriteTextInfoToEditStream(pes, CodePage)
 *
 *	@mfunc
 *		Used for textize support,  Tries to determine the text representation
 *		for an object and then writes that info	to the given stream. If
 *		CodePage = 1200 (little-endian Unicode), the object is queried for
 *		Unicode text; else it's queried for Ansi text.
 *
 *	@rdesc
 *		LONG	count of chars written
 */
LONG COleObject::WriteTextInfoToEditStream(
	EDITSTREAM *pes,		//@parm Edit stream to write to
	UINT		CodePage)	//@parm CodePage: 1200 uses Unicode; else Ansi
{
	LONG		 cbWritten = 0;
	BOOL		 fUnicode = CodePage == 1200;
	STGMEDIUM	 med;
	IDataObject *pdataobj = NULL;
	IOleObject * poo;

	HRESULT hr = _punkobj->QueryInterface(IID_IOleObject, (void **)&poo);
	if(hr == NOERROR)
	{
		hr = poo->GetClipboardData(0, &pdataobj);
        poo->Release();
	}

	if(FAILED(hr))
	{
		hr = _punkobj->QueryInterface(IID_IDataObject, (void **)&pdataobj);
		if(FAILED(hr))
		{
			pes->dwError = (DWORD) E_FAIL;
			goto Default;
		}
	}

	med.tymed = TYMED_HGLOBAL;
	med.pUnkForRelease = NULL;
	med.hGlobal = NULL;

	hr = pdataobj->GetData(&g_rgFETC[fUnicode ? iUnicodeFETC : iAnsiFETC], &med);
	if(FAILED(hr))
		pes->dwError = (DWORD)hr;
	else
	{
		HANDLE	hGlobal = med.hGlobal;
		LONG	cb = 0;
		BYTE *	pb = (BYTE *)GlobalLock(hGlobal);
		if(pb)
		{
			if(fUnicode)
				for(; (WCHAR)pb[cb]; cb += 2);
			else
				for(; pb[cb]; cb++);

			pes->dwError = pes->pfnCallback(pes->dwCookie, pb, cb, &cbWritten);
			GlobalUnlock(hGlobal);
		}
		ReleaseStgMedium(&med);
	}

Default:
	if(cbWritten <= 0)
	{
		BYTE rgb[] = {' ', 0};

		pes->pfnCallback(pes->dwCookie, rgb, 1 + fUnicode, &cbWritten);
		pes->dwError = 0;
	}

    pdataobj->Release();
	return cbWritten;
}

/*
 *	COleObject::SetDvaspect (dvaspect)
 *
 *	@mfunc	Allows client to tell us which aspect to use and force us
 *		to recompute positioning and redraw.
 */
void COleObject::SetDvaspect(
	DWORD dvaspect)	//@parm	the aspect to use
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::SetDvaspect");

	_pi.dvaspect = dvaspect;
	
	// Force FetchObjectExtents to call through
	_fAspectChanged = TRUE;

	// Cause ourselves to redraw and update
	OnViewChange(dvaspect, (DWORD) -1);
}

/*
 *	COleObject::HandsOffStorage
 *
 *	@mfunc	See IPersistStore::HandsOffStorage.
 *
 */
void COleObject::HandsOffStorage(void)
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::HandsOffStorage");

	// Free storage we currently have, if we have one.
	SafeReleaseAndNULL((IUnknown**)&_pstg);
}

/*
 *	COleObject::SaveCompleted
 *
 *	@mfunc	See IPersistStore::SaveCompleted.
 */
void COleObject::SaveCompleted(
	LPSTORAGE lpstg)	//@parm	new storage
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::SaveCompleted");

	// Did our caller give us a new storage to remember?
	if(lpstg)
	{
		// Free storage we currently have, if we have one
		if(_pstg)
			SafeReleaseAndNULL((IUnknown**)&_pstg);

		// Remember storage we are given, since we are given one
		lpstg->AddRef();
		_pstg = lpstg;
	}
}

/*
 *	SetAllowedResizeDirections
 *	
 *	@func Resizing helper function
 *
 */
static void SetAllowedResizeDirections(
	const POINTUV  & pt,
	const RECTUV   & rc,
	      LPTSTR   lphand,
	      BOOL   & fTop,
	      BOOL   & fBottom,
	      BOOL   & fLeft,
	      BOOL   & fRight)
{
   	fTop = abs(pt.v - rc.top) < abs(pt.v - rc.bottom);
	fBottom = !fTop;
	fLeft = abs(pt.u - rc.left) < abs(pt.u - rc.right);
	fRight = !fLeft;

	if(lphand == IDC_SIZENS)
		fLeft = fRight = FALSE; 
	else if(lphand == IDC_SIZEWE)
		fTop = fBottom = FALSE;
}

/*
 *	COleObject::HandleResize (&ptxy)
 *	
 *	@mfunc Deal with object resizing.
 *
 *	@rdesc	BOOL
 */
BOOL COleObject::HandleResize(
	const POINT &ptxy)
{
	LPTSTR lphand;
	DWORD  dwFlags = _pi.dwFlags;
 	HWND   hwnd;
	RECT   rcxyPos;
	RECTUV rcPos;
	BOOL   fTop, fBottom, fLeft, fRight, fEscape;
	POINTUV	pt;
	CDisplay *pdp = _ped->_pdp;
	int dupMin = pdp->GetDupSystemFont();
	int dvpMin = pdp->GetDvpSystemFont();

	pdp->PointuvFromPoint(pt, ptxy);

	if(!(dwFlags & REO_SELECTED) || !(dwFlags & REO_RESIZABLE) ||
		(lphand = CheckForHandleHit(pt, TRUE)) == NULL)
		return FALSE;
 	
	GetRectuv(rcPos);
	pdp->RectFromRectuv(rcxyPos, rcPos);

	HDC hdc = pdp->GetDC();
	_ped->TxGetWindow(&hwnd);
	SetCapture(hwnd);
	
	SetAllowedResizeDirections(pt, rcPos, lphand, fTop, fBottom, fLeft, fRight);
	
	// Erase and redraw frame without handles.
	DrawFrame(pdp, hdc, &rcxyPos);
	_pi.dwFlags = REO_NULL;
	DrawFrame(pdp, hdc, &rcxyPos);

	fEscape = FALSE;
	const INT vkey = GetSystemMetrics(SM_SWAPBUTTON) ? VK_RBUTTON : VK_LBUTTON;
	while (GetAsyncKeyState(vkey) & 0x8000)
	{		
		POINT ptLast = ptxy;
		POINT ptxyCur;
		POINTUV ptCur;
		MSG msg;

		// Stop if the ESC key has been pressed
		if(GetAsyncKeyState(VK_ESCAPE) & 0x0001)
		{
			fEscape = TRUE;
			break;
		}
		
		GetCursorPos(&ptxyCur);
		ScreenToClient(hwnd, &ptxyCur);
		pdp->PointuvFromPoint(ptCur, ptxyCur);

#ifndef UNDER_CE
// GetCursorPos() isn't supported on WinCE. We have  it hacked to
// be GetMessagePos() which unfortunately in this case will cause
// ptCur to never change. By removing this check we end up drawing
// multiple times when the user pauses during a resize. 
		// If mouse hasn't moved, try again
		if((ptxyCur.x == ptLast.x) && (ptxyCur.y == ptLast.y))
			continue;
#endif

		ptLast = ptxyCur;

		// Erase old rectangle, update rectangle, and redraw
		DrawFrame(pdp, hdc, &rcxyPos);	

		if(fLeft)   rcPos.left   = min(ptCur.u, rcPos.right - dupMin);
		if(fRight)  rcPos.right  = max(ptCur.u, rcPos.left + dupMin);
		if(fTop)    rcPos.top    = min(ptCur.v, rcPos.bottom - dvpMin);
		if(fBottom) rcPos.bottom = max(ptCur.v, rcPos.top + dvpMin);

		pdp->RectFromRectuv(rcxyPos, rcPos);
		DrawFrame(pdp, hdc, &rcxyPos);

		// FUTURE: (joseogl): It would be cool if we could do something
		// better here, but for now, it appears to be necessary.
		Sleep(100);
		
		// Eat input messages
		if (PeekMessage(&msg, 0, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE) ||
			PeekMessage(&msg, 0, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE | PM_NOYIELD) ||
			PeekMessage(&msg, 0, WM_NCMOUSEMOVE, WM_NCMBUTTONDBLCLK, PM_REMOVE | PM_NOYIELD))
		{
			// Break out of the loop if the Escape key was pressed
		    if(msg.message == WM_KEYDOWN && msg.wParam == VK_ESCAPE)
			{
	        	fEscape = TRUE;
				break;
			}
		}
	}

	DrawFrame(pdp, hdc, &rcxyPos);
  	ReleaseCapture();
 	_pi.dwFlags = dwFlags;

	// Resize unless the user aborted
	if(!fEscape)
	{
		SIZEUV size;
		if (IsUVerticalTflow(pdp->GetTflow()) && !(_pi.dwFlags & REO_CANROTATE))
		{
			size.du = rcPos.bottom - rcPos.top;
			size.dv = rcPos.right - rcPos.left;
		}
		else
		{
			size.du = rcPos.right - rcPos.left;
			size.dv = rcPos.bottom - rcPos.top;
		}

		size.du = pdp->DUtoHimetricU(size.du);
		size.dv = pdp->DVtoHimetricV(size.dv);
		Resize(size, TRUE);
	}

	pdp->ReleaseDC(hdc);
	return TRUE;
}

/*
 *	COleObject::Resize(size)
 *	
 *	@mfunc Set new object size.  Handle undo details.
 */
void COleObject::Resize(
	const SIZEUV &size, 
	BOOL  fCreateAntiEvent)
{
	CDisplay *	pdp = _ped->_pdp;
	SIZEUV		sizeold = _size;

	// Change the size of our internal representation.
	_size = size;

	//If size didn't really change, don't do anything else.
	if(size.du != sizeold.du || size.dv != sizeold.dv)
	{
		if(_ped->_fUseUndo && fCreateAntiEvent)
		{
			CGenUndoBuilder undobldr(_ped, UB_AUTOCOMMIT);
			IAntiEvent *pae;

			pae = gAEDispenser.CreateResizeObjectAE(_ped, this, sizeold);
			if(pae)
				undobldr.AddAntiEvent(pae);
		}

		SetExtent(SE_NOTACTIVATING);

		// Force a redraw that will stretch the object.
		pdp->OnPostReplaceRange(CP_INFINITE, 0, 0, _cp, _cp + 1, NULL);

		_ped->GetCallMgr()->SetChangeEvent(CN_GENERIC);
	}
}

/*
 *	COleObject::OnReposition ()
 *	
 *	@mfunc Set object's new position.  May have changed as a result of scrolling.
 */
void COleObject::OnReposition()
{
	IOleInPlaceObject *pipo;

	if(!_fInPlaceActive)
	{
		// If we're not inplace active, don't do anything
		return;
	}

	if(_punkobj->QueryInterface(IID_IOleInPlaceObject, (void **)&pipo) == NOERROR)
	{
		RECTUV rcuvClip, rcuv;
		RECT rcClip, rc;

		_ped->_pdp->GetViewRect(rcuvClip);
		_ped->_pdp->RectFromRectuv(rcClip, rcuvClip);

		GetRectuv(rcuv);
		_ped->_pdp->RectFromRectuv(rc, rcuv);

		pipo->SetObjectRects(&rc, &rcClip);
        pipo->Release();
	}
}

 /*
 *	COleObject::GetRectuv(rc)
 *	
 *	@mfunc Compute the object's position rectangle from its cp.
 */
void COleObject::GetRectuv(
	 RECTUV &rc)
{
	CRchTxtPtr rtp(_ped, _cp);
	POINTUV pt;
	CDispDim dispdim;

	DWORD grf = TA_BASELINE;
	if (_pi.dwFlags & REO_BELOWBASELINE)
		grf = TA_BOTTOM;
	
	if(_ped->_pdp->PointFromTp(rtp, NULL, FALSE, pt, NULL, grf, &dispdim) == -1)
		return;

	rc.left = pt.u;
	rc.right = rc.left + dispdim.dup;
	rc.bottom = pt.v;

	LONG dv = _size.dv;
	if (IsUVerticalTflow(_ped->_pdp->GetTflow()) && !(_pi.dwFlags & REO_CANROTATE))
		dv = _size.du;

	rc.top = rc.bottom - _ped->_pdp->HimetricVtoDV(dv);
}

#ifdef DEBUG
void COleObject::DbgDump(DWORD id)
{
	Tracef(TRCSEVNONE, "Object #%d %X: cp = %d , ",id,this,_cp);
}
#endif

/*	
 *	COleObject:SetExtent(iActivating)
 *
 *	@mfunc A wrapper around IOleObject::SetExtent which makes some additional
 *			checks if the first call to IOleObject::SetExtent fails.  
 *
 *	@rdesc HRESULT
 */
HRESULT COleObject::SetExtent(
	int iActivating) //@parm indicates if object is currently being activated
{
	LPOLEOBJECT poo;

	// If we are connected to a link object, the native extent can't be change,
	// so don't bother doing anything here.
	if(_pi.dwFlags & REO_LINK)
	{
		// So we don't call GetExtents on remeasuring.
		_fSetExtent = TRUE;
		return NOERROR;
	}

	HRESULT hr = _punkobj->QueryInterface(IID_IOleObject, (void **)&poo);
	if(hr != NOERROR)
		return hr;

	// If we are about to activate the object, fall through and OleRun the
	// object prior to attempting to SetExtent.  Otherwise, attempt a SetExtent
	// directly.
	if(iActivating == SE_NOTACTIVATING)
	{
		// By default, we will call SetExtent when the object is next activated.
		_fSetExtent = TRUE;

		hr = poo->SetExtent(_pi.dvaspect, (SIZE*)&_size);

		DWORD dwStatus;

		// If the server is not running we need to to some additional
		// checking. If it was, we do not need to call SetExtent again.

		// Find out if OLEMISC_RECOMPOSEONRESIZE is set.  If it is, we should
		// run the object and call setextent.  If not, we defer calling set
		// extent until we are ready to activate the object.
		if(!(hr == OLE_E_NOTRUNNING &&
			poo->GetMiscStatus(_pi.dvaspect, &dwStatus) == NOERROR &&
			(dwStatus & OLEMISC_RECOMPOSEONRESIZE)))
		{
			goto DontRunAndSetAgain;
		}
		// Fall through and attempt the SetExtent again after running the object
	}

	SIZEUV sizesave;
	sizesave = _size;
	OleRun(_punkobj);		// This call causes _size to be reset 
							// via OLE and FetchObjectExtents.
	_size = sizesave;
	poo->SetExtent(_pi.dvaspect, (SIZE*)&_size);

DontRunAndSetAgain:
	if((hr == NOERROR) || 
		(iActivating == SE_NOTACTIVATING && hr != OLE_E_NOTRUNNING))
	{
		_fSetExtent = FALSE;
	}
	// If the server is still not running, we try again at
	// activation time.  Otherwise the server has either 
	// done its thing or it doesn't do resize.  Either way
	// we don't bother trying again at activation time.

	if(hr == NOERROR && _fIsPaintBrush)
	{
		SIZEUV sizeChk;

		poo->GetExtent(_pi.dvaspect, (SIZE*)&sizeChk);
		_fPBUseLocalSize = !(sizeChk.du == _size.du && sizeChk.dv == _size.dv);
		// HACK:  Calls to SetExtent on PaintBrush objects may not
		// 	actually change the object extents.  In such cases, 
		//	we will rely on local _size for PaintBrush object extents.
	}
	poo->Release();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\cicclsid.c ===
//
//  !! WARNING WARNING WARNING !!
// 
//  THIS FILE WAS GENERATED BY CICCLSID.BAT.
//  THESE CLSIDS MUST BE SAME WITH *.RGS FILES UNDER UIM.
//


/* 529A9E6B-6587-4F23-AB9E-9C7D683E3C50 */
const CLSID CLSID_TF_ThreadMgr = { 
    0x529A9E6B,
    0x6587,
    0x4F23,
    {0xAB, 0x9E, 0x9C, 0x7D, 0x68, 0x3E, 0x3C, 0x50}
  };
/* EBB08C45-6C4A-4FDC-AE53-4EB8C4C7DB8E */
const CLSID CLSID_TF_LangBarMgr = { 
    0xEBB08C45,
    0x6C4A,
    0x4FDC,
    {0xAE, 0x53, 0x4E, 0xB8, 0xC4, 0xC7, 0xDB, 0x8E}
  };
/* 3CE74DE4-53D3-4D74-8B83-431B3828BA53 */
const CLSID CLSID_TF_DisplayAttributeMgr = { 
    0x3CE74DE4,
    0x53D3,
    0x4D74,
    {0x8B, 0x83, 0x43, 0x1B, 0x38, 0x28, 0xBA, 0x53}
  };
/* A4B544A1-438D-4B41-9325-869523E2D6C7 */
const CLSID CLSID_TF_CategoryMgr = { 
    0xA4B544A1,
    0x438D,
    0x4B41,
    {0x93, 0x25, 0x86, 0x95, 0x23, 0xE2, 0xD6, 0xC7}
  };
/* 33C53A50-F456-4884-B049-85FD643ECFED */
const CLSID CLSID_TF_InputProcessorProfiles = { 
    0x33C53A50,
    0xF456,
    0x4884,
    {0xB0, 0x49, 0x85, 0xFD, 0x64, 0x3E, 0xCF, 0xED}
  };
/* B9931692-A2B3-4FAB-BF33-9EC6F9FB96AC */
const CLSID CLSID_TF_LangBarItemMgr = { 
    0xB9931692,
    0xA2B3,
    0x4FAB,
    {0xBF, 0x33, 0x9E, 0xC6, 0xF9, 0xFB, 0x96, 0xAC}
  };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\clasifyc.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module clasifyc.cpp -- Kinsoku classify characters |
 *	
 *		Used in word breaking procs, particularly important
 *		for properly wrapping a line.
 *	
 *	Authors: <nl>
 *		Jon Matousek
 *
 *	Copyright (c) 1995-2000 Microsoft Corporation. All rights reserved.
 */								 

//FUTURE (keithcu) Some of this data we could get from GetStringTypeEx which
//would make us smaller.

#include "_common.h"
#include "_clasfyc.h"
#include "_array.h"

ASSERTDATA

// Data for Kinsoku character classifications.
// NOTE: All values are for UNICODE characters.

// "dumb" quotes and other characters with no left/right orientation.
// This is a hack-around the Kinsoku rules, these are treated
// like an opening paren, when leading and kind of like a closing
// paren when follow--but will only break on white space in former case.
#define	brkclsQuote	0
#define C3_FullWidth	(C3_KATAKANA | C3_HIRAGANA | C3_IDEOGRAPH | C3_FULLWIDTH)

const WCHAR set0[] = {
	0x0022,	// QUOTATION MARK
	0x0027, // APOSTROPHE
	0x2019, // RIGHT SINGLE QUOTATION MARK
	0x301F,	// LOW DOUBLE PRIME QUOTATION MARK
	0xFF02,	// FULLWIDTH QUOTATION MARK
	0xFF07,	// FULLWIDTH APOSTROPHE
	0
};

// Opening-parenthesis character
#define	brkclsOpen	1

const WCHAR set1[] = {
	0x0028, // LEFT PARENTHESIS
	0x003C,	// LEFT ANGLE BRACKET
	0x005B, // LEFT SQUARE BRACKET
	0x007B, // LEFT CURLY BRACKET
	0x00AB, // LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
	0x2018, // LEFT SINGLE QUOTATION MARK
	0x201C, // LEFT DOUBLE QUOTATION MARK
	0x2039, // SINGLE LEFT-POINTING ANGLE QUOTATION MARK
	0x2045, // LEFT SQUARE BRACKET WITH QUILL
	0x207D, // SUPERSCRIPT LEFT PARENTHESIS
	0x208D, // SUBSCRIPT LEFT PARENTHESIS
	0x3008, // LEFT ANGLE BRACKET
	0x300A, // LEFT DOUBLE ANGLE BRACKET
	0x300C, // LEFT CORNER BRACKET
	0x300E, // LEFT WHITE CORNER BRACKET
	0x3010, // LEFT BLACK LENTICULAR BRACKET
	0x3014, // LEFT TORTOISE SHELL BRACKET
	0x3016, // LEFT WHITE LENTICULAR BRACKET
	0x3018, // LEFT WHITE TORTOISE SHELL BRACKET
	0x301A, // LEFT WHITE SQUARE BRACKET
	0x301D, // REVERSED DOUBLE PRIME QUOTATION MARK
	0xFD3E, // ORNATE LEFT PARENTHESIS
	0xFE59, // SMALL LEFT PARENTHESIS
	0xFE5B, // SMALL LEFT CURLY BRACKET
	0xFE5D, // SMALL LEFT TORTOISE SHELL BRACKET
	0xFF08, // FULLWIDTH LEFT PARENTHESIS
	0xFF3B, // FULLWIDTH LEFT SQUARE BRACKET
	0xFF5B, // FULLWIDTH LEFT CURLY BRACKET
	0xFF62, // HALFWIDTH LEFT CORNER BRACKET
	0xFFE9, // HALFWIDTH LEFTWARDS ARROW
	0
};


// Closing-parenthesis character
#define	brkclsClose	2

//FUTURE (keithcu) A dash next to a dash should be a break opportunity.

const WCHAR set2[] = {
	// 0x002C, // COMMA	moved to set 6 to conjoin numerals.
	0x002D,	// HYPHEN
	0x2013,	// EN-DASH
	0x2014,	// EM-DASH
	0x00AD,	// OPTIONAL HYPHEN
	0x055D, // ARMENIAN COMMA
	0x060C, // ARABIC COMMA
	0x3001, // IDEOGRAPHIC COMMA
	0xFE50, // SMALL COMMA
	0xFE51, // SMALL IDEOGRAPHIC COMMA
	0xFF0C, // FULLWIDTH COMMA
	0xFF64, // HALFWIDTH IDEOGRAPHIC COMMA

	0x0029, // RIGHT PARENTHESIS
	0x003E,	// RIGHT ANGLE BRACKET
	0x005D, // RIGHT SQUARE BRACKET
	0x007D, // RIGHT CURLY BRACKET
	0x00BB, // RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
	//0x2019, // RIGHT SINGLE QUOTATION MARK moved to set 0
	0x201D, // RIGHT DOUBLE QUOTATION MARK
	0x203A, // SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
	0x2046, // RIGHT SQUARE BRACKET WITH QUILL
	0x207E, // SUPERSCRIPT RIGHT PARENTHESIS
	0x208E, // SUBSCRIPT RIGHT PARENTHESIS
	0x3009, // RIGHT ANGLE BRACKET
	0x300B, // RIGHT DOUBLE ANGLE BRACKET
	0x300D, // RIGHT CORNER BRACKET
	0x300F, // RIGHT WHITE CORNER BRACKET
	0x3011, // RIGHT BLACK LENTICULAR BRACKET
	0x3015, // RIGHT TORTOISE SHELL BRACKET
	0x3017, // RIGHT WHITE LENTICULAR BRACKET
	0x3019, // RIGHT WHITE TORTOISE SHELL BRACKET
	0x301B, // RIGHT WHITE SQUARE BRACKET
	0x301E, // DOUBLE PRIME QUOTATION MARK
	0xFD3F, // ORNATE RIGHT PARENTHESIS
	0xFE5A, // SMALL RIGHT PARENTHESIS
	0xFE5C, // SMALL RIGHT CURLY BRACKET
	0xFE5E, // SMALL RIGHT TORTOISE SHELL BRACKET
	0xFF09, // FULLWIDTH RIGHT PARENTHESIS
	0xFF3D, // FULLWIDTH RIGHT SQUARE BRACKET
	0xFF5D, // FULLWIDTH RIGHT CURLY BRACKET
	0xFF63, // HALFWIDTH RIGHT CORNER BRACKET
	0xFFEB, // HALFWIDTH RIGHTWARDS ARROW
	0
};

// 'Non-breaking' em-character at line-starting point
#define	brkclsGlueA	3

const WCHAR set3[] = {
	0x3005, // IDEOGRAPHIC ITERATION MARK
	0x309D, // HIRAGANA ITERATION MARK
	0x309E, // HIRAGANA VOICED ITERATION MARK
	0x30FC, // KATAKANA-HIRAGANA PROLONGED SOUND MARK
	0x30FD, // KATAKANA ITERATION MARK
	0x30FE, // KATAKANA VOICED ITERATION MARK
	0x3041, // HIRAGANA LETTER SMALL A
	0x3043, // HIRAGANA LETTER SMALL I
	0x3045, // HIRAGANA LETTER SMALL U
	0x3047, // HIRAGANA LETTER SMALL E
	0x3049, // HIRAGANA LETTER SMALL O
	0x3063, // HIRAGANA LETTER SMALL TU
	0x3083, // HIRAGANA LETTER SMALL YA
	0x3085, // HIRAGANA LETTER SMALL YU
	0x3087, // HIRAGANA LETTER SMALL YO
	0x308E, // HIRAGANA LETTER SMALL WA
	0x309B,	// KATAKANA-HIRAGANA VOICED SOUND MARK
	0x309C,	// KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK
	0x30A1, // KATAKANA LETTER SMALL A
	0x30A3, // KATAKANA LETTER SMALL I
	0x30A5, // KATAKANA LETTER SMALL U
	0x30A7, // KATAKANA LETTER SMALL E
	0x30A9, // KATAKANA LETTER SMALL O
	0x30C3, // KATAKANA LETTER SMALL TU
	0x30E3, // KATAKANA LETTER SMALL YA
	0x30E5, // KATAKANA LETTER SMALL YU
	0x30E7, // KATAKANA LETTER SMALL YO
	0x30EE, // KATAKANA LETTER SMALL WA
	0x30F5, // KATAKANA LETTER SMALL KA
	0x30F6, // KATAKANA LETTER SMALL KE
	0xFF67, // HALFWIDTH KATAKANA LETTER SMALL A
	0xFF68, // HALFWIDTH KATAKANA LETTER SMALL I
	0xFF69, // HALFWIDTH KATAKANA LETTER SMALL U
	0xFF6A, // HALFWIDTH KATAKANA LETTER SMALL E
	0xFF6B, // HALFWIDTH KATAKANA LETTER SMALL O
	0xFF6C, // HALFWIDTH KATAKANA LETTER SMALL YA
	0xFF6D, // HALFWIDTH KATAKANA LETTER SMALL YU
	0xFF6E, // HALFWIDTH KATAKANA LETTER SMALL YO
	0xFF6F, // HALFWIDTH KATAKANA LETTER SMALL TU
	0xFF70, // HALFWIDTH KATAKANA-HIRAGANA PROLONGED SOUND MARK
	0xFF9E,	// HALFWIDTH KATAKANA VOICED SOUND MARK
	0xFF9F,	// HALFWIDTH KATAKANA SEMI-VOICED SOUND MARK
	0
};

// Expression mark
#define	brkclsExclaInterr	4

const WCHAR set4[] = {
	0x0021, // EXCLAMATION MARK
	0x003F, // QUESTION MARK
	0x00A1, // INVERTED EXCLAMATION MARK
	0x00BF, // INVERTED QUESTION MARK
	0x01C3, // LATIN LETTER RETROFLEX CLICK
	0x037E, // GREEK QUESTION MARK
	0x055C, // ARMENIAN EXCLAMATION MARK
	0x055E, // ARMENIAN QUESTION MARK
	0x055F, // ARMENIAN ABBREVIATION MARK
	0x061F, // ARABIC QUESTION MARK
	0x203C, // DOUBLE EXCLAMATION MARK
	0x203D, // INTERROBANG
	0x2762, // HEAVY EXCLAMATION MARK ORNAMENT
	0x2763, // HEAVY HEART EXCLAMATION MARK ORNAMENT
	0xFE56, // SMALL QUESTION MARK
	0xFE57, // SMALL EXCLAMATION MARK
	0xFF01, // FULLWIDTH EXCLAMATION MARK
	0xFF1F, // FULLWIDTH QUESTION MARK
	0
};

// Centered punctuation mark

const WCHAR set5[] = {		        
//	0x003A,	// COLON		moved to set 6 to conjoin numerals.
//	0x003B, // SEMICOLON	moved to set 6 to conjoin numerals
	0x00B7, // MIDDLE DOT
	0x30FB, // KATAKANA MIDDLE DOT
	0xFF65, // HALFWIDTH KATAKANA MIDDLE DOT
	0x061B, // ARABIC SEMICOLON
	0xFE54, // SMALL SEMICOLON
	0xFE55, // SMALL COLON
	0xFF1A, // FULLWIDTH COLON
	0xFF1B, // FULLWIDTH SEMICOLON
	0
};

// Punctuation mark		// diverged from the Kinsoku tables to enhance 
#define	brkclsSlash	6

const WCHAR set6[] = {	// How colon, comma, and full stop are treated around 
	0x002C, // COMMA	//  numerals and set 15 (roman text).
	0x002f,	// SLASH	// But don't break up URLs (see IsURLDelimiter())!
	0x003A, // COLON
	0x003B, // SEMICOLON

	0x002E, // FULL STOP (PERIOD)
	0x0589, // ARMENIAN FULL STOP
	0x06D4, // ARABIC FULL STOP
	0x3002, // IDEOGRAPHIC FULL STOP
	0xFE52, // SMALL FULL STOP
	0xFF0E, // FULLWIDTH FULL STOP
	0xFF61, // HALFWIDTH IDEOGRAPHIC FULL STOP
	0
};

// Inseparable character
#define	brkclsInseparable	7

const WCHAR set7[] = {
	0		// FUTURE (alexgo): maybe handle these.
};

// Pre-numeral abbreviation
#define	brkclsPrefix	8

const WCHAR set8[] = {
	0x0024, // DOLLAR SIGN
	0x00A3, // POUND SIGN
	0x00A4, // CURRENCY SIGN
	0x00A5, // YEN SIGN
	0x005C, // REVERSE SOLIDUS (looks like Yen in FE fonts.)
	0x0E3F, // THAI CURRENCY SYMBOL BAHT
	0x20AC, // EURO-CURRENCY SIGN
	0x20A1, // COLON SIGN
	0x20A2, // CRUZEIRO SIGN
	0x20A3, // FRENCH FRANC SIGN
	0x20A4, // LIRA SIGN
	0x20A5, // MILL SIGN
	0x20A6, // NAIRA SIGN
	0x20A7, // PESETA SIGN
	0x20A8, // RUPEE SIGN
	0x20A9, // WON SIGN
	0x20AA, // NEW SHEQEL SIGN

	0xFF04, // FULLWIDTH DOLLAR SIGN
	0xFFE5,	// FULLWIDTH YEN SIGN
	0xFFE6,	// FULLWIDTH WON SIGN

	0xFFE1,	// FULLWIDTH POUND SIGN
	0
};

// Post-numeral abbreviation
#define	brkclsPostfix	9

const WCHAR set9[] = {
	0x00A2, // CENT SIGN
	0x00B0, // DEGREE SIGN
	0x2103, // DEGREE CELSIUS
	0x2109, // DEGREE FAHRENHEIT
	0x212A, // KELVIN SIGN
	0x0025, // PERCENT SIGN
	0x066A, // ARABIC PERCENT SIGN
	0xFE6A, // SMALL PERCENT SIGN
	0xFF05, // FULLWIDTH PERCENT SIGN
	0x2030, // PER MILLE SIGN
	0x2031, // PER TEN THOUSAND SIGN
	0x2032, // PRIME
	0x2033, // DOUBLE PRIME
	0x2034, // TRIPLE PRIME
	0x2035, // REVERSED PRIME
	0x2036, // REVERSED DOUBLE PRIME
	0x2037,	// REVERSED TRIPLE PRIME

	0xFF05,	// FULLWIDTH PERCENT SIGN
	0xFFE0,	// FULLWIDTH CENT SIGN
	0
};

// Japanese space (blank) character
#define	brkclsNoStartIdeo	10

const WCHAR set10[] = {
	0x3000,  // IDEOGRAPHIC SPACE
	0
};

// Japanese characters other than above
#define	brkclsIdeographic	11

const WCHAR set11[] = {
	0		//we use GetStringTypeEx
};

// Characters included in numeral-sequence
#define	brkclsNumeral	12

const WCHAR set12[] = {
	0x0030, // DIGIT ZERO
	0x0031, // DIGIT ONE
	0x0032, // DIGIT TWO
	0x0033, // DIGIT THREE
	0x0034, // DIGIT FOUR
	0x0035, // DIGIT FIVE
	0x0036, // DIGIT SIX
	0x0037, // DIGIT SEVEN
	0x0038, // DIGIT EIGHT
	0x0039, // DIGIT NINE
	0x0660, // ARABIC-INDIC DIGIT ZERO
	0x0661, // ARABIC-INDIC DIGIT ONE
	0x0662, // ARABIC-INDIC DIGIT TWO
	0x0663, // ARABIC-INDIC DIGIT THREE
	0x0664, // ARABIC-INDIC DIGIT FOUR
	0x0665, // ARABIC-INDIC DIGIT FIVE
	0x0666, // ARABIC-INDIC DIGIT SIX
	0x0667, // ARABIC-INDIC DIGIT SEVEN
	0x0668, // ARABIC-INDIC DIGIT EIGHT
	0x0669, // ARABIC-INDIC DIGIT NINE
	0x06F0, // EXTENDED ARABIC-INDIC DIGIT ZERO
	0x06F1, // EXTENDED ARABIC-INDIC DIGIT ONE
	0x06F2, // EXTENDED ARABIC-INDIC DIGIT TWO
	0x06F3, // EXTENDED ARABIC-INDIC DIGIT THREE
	0x06F4, // EXTENDED ARABIC-INDIC DIGIT FOUR
	0x06F5, // EXTENDED ARABIC-INDIC DIGIT FIVE
	0x06F6, // EXTENDED ARABIC-INDIC DIGIT SIX
	0x06F7, // EXTENDED ARABIC-INDIC DIGIT SEVEN
	0x06F8, // EXTENDED ARABIC-INDIC DIGIT EIGHT
	0x06F9, // EXTENDED ARABIC-INDIC DIGIT NINE
	0x0966, // DEVANAGARI DIGIT ZERO
	0x0967, // DEVANAGARI DIGIT ONE
	0x0968, // DEVANAGARI DIGIT TWO
	0x0969, // DEVANAGARI DIGIT THREE
	0x096A, // DEVANAGARI DIGIT FOUR
	0x096B, // DEVANAGARI DIGIT FIVE
	0x096C, // DEVANAGARI DIGIT SIX
	0x096D, // DEVANAGARI DIGIT SEVEN
	0x096E, // DEVANAGARI DIGIT EIGHT
	0x096F, // DEVANAGARI DIGIT NINE
	0x09E6, // BENGALI DIGIT ZERO
	0x09E7, // BENGALI DIGIT ONE
	0x09E8, // BENGALI DIGIT TWO
	0x09E9, // BENGALI DIGIT THREE
	0x09EA, // BENGALI DIGIT FOUR
	0x09EB, // BENGALI DIGIT FIVE
	0x09EC, // BENGALI DIGIT SIX
	0x09ED, // BENGALI DIGIT SEVEN
	0x09EE, // BENGALI DIGIT EIGHT
	0x09EF, // BENGALI DIGIT NINE
	0x0A66, // GURMUKHI DIGIT ZERO
	0x0A67, // GURMUKHI DIGIT ONE
	0x0A68, // GURMUKHI DIGIT TWO
	0x0A69, // GURMUKHI DIGIT THREE
	0x0A6A, // GURMUKHI DIGIT FOUR
	0x0A6B, // GURMUKHI DIGIT FIVE
	0x0A6C, // GURMUKHI DIGIT SIX
	0x0A6D, // GURMUKHI DIGIT SEVEN
	0x0A6E, // GURMUKHI DIGIT EIGHT
	0x0A6F, // GURMUKHI DIGIT NINE
	0x0AE6, // GUJARATI DIGIT ZERO
	0x0AE7, // GUJARATI DIGIT ONE
	0x0AE8, // GUJARATI DIGIT TWO
	0x0AE9, // GUJARATI DIGIT THREE
	0x0AEA, // GUJARATI DIGIT FOUR
	0x0AEB, // GUJARATI DIGIT FIVE
	0x0AEC, // GUJARATI DIGIT SIX
	0x0AED, // GUJARATI DIGIT SEVEN
	0x0AEE, // GUJARATI DIGIT EIGHT
	0x0AEF, // GUJARATI DIGIT NINE
	0x0B66, // ORIYA DIGIT ZERO
	0x0B67, // ORIYA DIGIT ONE
	0x0B68, // ORIYA DIGIT TWO
	0x0B69, // ORIYA DIGIT THREE
	0x0B6A, // ORIYA DIGIT FOUR
	0x0B6B, // ORIYA DIGIT FIVE
	0x0B6C, // ORIYA DIGIT SIX
	0x0B6D, // ORIYA DIGIT SEVEN
	0x0B6E, // ORIYA DIGIT EIGHT
	0x0B6F, // ORIYA DIGIT NINE
	0x0BE7, // TAMIL DIGIT ONE
	0x0BE8, // TAMIL DIGIT TWO
	0x0BE9, // TAMIL DIGIT THREE
	0x0BEA, // TAMIL DIGIT FOUR
	0x0BEB, // TAMIL DIGIT FIVE
	0x0BEC, // TAMIL DIGIT SIX
	0x0BED, // TAMIL DIGIT SEVEN
	0x0BEE, // TAMIL DIGIT EIGHT
	0x0BEF, // TAMIL DIGIT NINE
	0x0BF0, // TAMIL NUMBER TEN
	0x0BF1, // TAMIL NUMBER ONE HUNDRED
	0x0BF2, // TAMIL NUMBER ONE THOUSAND
	0x0C66, // TELUGU DIGIT ZERO
	0x0C67, // TELUGU DIGIT ONE
	0x0C68, // TELUGU DIGIT TWO
	0x0C69, // TELUGU DIGIT THREE
	0x0C6A, // TELUGU DIGIT FOUR
	0x0C6B, // TELUGU DIGIT FIVE
	0x0C6C, // TELUGU DIGIT SIX
	0x0C6D, // TELUGU DIGIT SEVEN
	0x0C6E, // TELUGU DIGIT EIGHT
	0x0C6F, // TELUGU DIGIT NINE
	0x0CE6, // KANNADA DIGIT ZERO
	0x0CE7, // KANNADA DIGIT ONE
	0x0CE8, // KANNADA DIGIT TWO
	0x0CE9, // KANNADA DIGIT THREE
	0x0CEA, // KANNADA DIGIT FOUR
	0x0CEB, // KANNADA DIGIT FIVE
	0x0CEC, // KANNADA DIGIT SIX
	0x0CED, // KANNADA DIGIT SEVEN
	0x0CEE, // KANNADA DIGIT EIGHT
	0x0CEF, // KANNADA DIGIT NINE
	0x0D66, // MALAYALAM DIGIT ZERO
	0x0D67, // MALAYALAM DIGIT ONE
	0x0D68, // MALAYALAM DIGIT TWO
	0x0D69, // MALAYALAM DIGIT THREE
	0x0D6A, // MALAYALAM DIGIT FOUR
	0x0D6B, // MALAYALAM DIGIT FIVE
	0x0D6C, // MALAYALAM DIGIT SIX
	0x0D6D, // MALAYALAM DIGIT SEVEN
	0x0D6E, // MALAYALAM DIGIT EIGHT
	0x0D6F, // MALAYALAM DIGIT NINE
	0x0E50, // THAI DIGIT ZERO
	0x0E51, // THAI DIGIT ONE
	0x0E52, // THAI DIGIT TWO
	0x0E53, // THAI DIGIT THREE
	0x0E54, // THAI DIGIT FOUR
	0x0E55, // THAI DIGIT FIVE
	0x0E56, // THAI DIGIT SIX
	0x0E57, // THAI DIGIT SEVEN
	0x0E58, // THAI DIGIT EIGHT
	0x0E59, // THAI DIGIT NINE
	0x0ED0, // LAO DIGIT ZERO
	0x0ED1, // LAO DIGIT ONE
	0x0ED2, // LAO DIGIT TWO
	0x0ED3, // LAO DIGIT THREE
	0x0ED4, // LAO DIGIT FOUR
	0x0ED5, // LAO DIGIT FIVE
	0x0ED6, // LAO DIGIT SIX
	0x0ED7, // LAO DIGIT SEVEN
	0x0ED8, // LAO DIGIT EIGHT
	0x0ED9, // LAO DIGIT NINE
	0xFF10, // FULLWIDTH DIGIT ZERO
	0xFF11, // FULLWIDTH DIGIT ONE
	0xFF12, // FULLWIDTH DIGIT TWO
	0xFF13, // FULLWIDTH DIGIT THREE
	0xFF14, // FULLWIDTH DIGIT FOUR
	0xFF15, // FULLWIDTH DIGIT FIVE
	0xFF16, // FULLWIDTH DIGIT SIX
	0xFF17, // FULLWIDTH DIGIT SEVEN
	0xFF18, // FULLWIDTH DIGIT EIGHT
	0xFF19, // FULLWIDTH DIGIT NINE

	0x3007, // IDEOGRAPHIC NUMBER ZERO
	0x3021, // HANGZHOU NUMERAL ONE
	0x3022, // HANGZHOU NUMERAL TWO
	0x3023, // HANGZHOU NUMERAL THREE
	0x3024, // HANGZHOU NUMERAL FOUR
	0x3025, // HANGZHOU NUMERAL FIVE
	0x3026, // HANGZHOU NUMERAL SIX
	0x3027, // HANGZHOU NUMERAL SEVEN
	0x3028, // HANGZHOU NUMERAL EIGHT
	0x3029, // HANGZHOU NUMERAL NINE
	0
};

// Characters included in unit symbol group
const WCHAR set13[] = {
	0		//we use GetStringTypeEx
};

//Roman inter-word space
#define	brkclsSpaceN	14

const WCHAR set14[] = {
	0x0009,	// TAB
	0x0020, // SPACE
	0x2002, // EN SPACE
	0x2003, // EM SPACE
	0x2004, // THREE-PER-EM SPACE
	0x2005, // FOUR-PER-EM SPACE
	0x2006, // SIX-PER-EM SPACE
	0x2007, // FIGURE SPACE
	0x2008, // PUNCTUATION SPACE
	0x2009, // THIN SPACE
	0x200A, // HAIR SPACE
	0x200B,  // ZERO WIDTH SPACE
	WCH_EMBEDDING, // OBJECT EMBEDDING (0xFFFC)
	0
};

// Roman characters
#define	brkclsAlpha	15

const WCHAR set15[] = {
	0		//we use GetStringTypeEx
};

// So we can easily loop over all Kinsoku categories.
const WCHAR *charCategories[] = {
	set0,
	set1,
	set2,
	set3,
	set4,
	set5,
	set6,
	set7,
	set8,
	set9,
	set10,
	set11,
	set12,
	set13,
	set14,
	set15
};

static const INT classifyChunkSize = 64;
static const INT indexSize = 65536 / classifyChunkSize;
static const INT classifyBitMapSize = indexSize / 8;
static const INT bitmapShift = 6; // 16 - log(indexSize)/log(2)

typedef struct {
	CHAR classifications[classifyChunkSize];		// must be unsigned bytes!
} ClassifyChunk;

static ClassifyChunk *classifyData;					// Chunk array, sparse chrs
static BYTE *classifyIndex;							// Indexes into chunk array


/*
 *	BOOL InitKinsokuClassify()
 *
 *	@func
 *		Map the static character tables into a compact array for
 *		quick lookup of the characters Kinsoku classification.
 *
 *	@comm
 *		Kinsoku classification is necessary for word breaking and
 *		may be neccessary for proportional line layout, Kinsoku style.
 *
 *	@devnote
 *		We break the entire Unicode range in to chunks of characters.
 *		Not all of the chunks will have data in them. We do not
 *		maintain information on empty chunks, therefore we create
 *		a compact, contiguous array of chunks for only the chunks
 *		that do contain information. We prepend 1 empty chunk to the
 *		beginning of this array, where all of the empty chunks map to,
 *		this prevents a contiontional test on NULL data. The lookup
 *		will return 0 for any character not in the tables, so the client
 *		will then need to process the character further in such cases.
 *
 *	@rdesc
 *		return TRUE if we successfully created the lookup table.
 */
BOOL InitKinsokuClassify()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "InitKinsokuClassify");

	WORD	bitMapKey;								// For calcing total chunks
	BYTE	bitData;								// For calcing total chunks
	WCHAR	ch;
	LPCWSTR pWChar;								// Looping over char sets.
	INT		i, j, count;							// Loop support.
	BYTE	classifyBitMap[classifyBitMapSize],		// Temp bitmap.
			*pIndex;								// Index into chunk array.

	// See how many chunks we'll need. We loop over all of the special
	//  characters
	AssertSz(cKinsokuCategories == ARRAY_SIZE(charCategories),
		"InitKinsokuClassify: incorrect Kinsoku-category count");

	ZeroMemory(classifyBitMap, sizeof(classifyBitMap));
	for (i = 0; i < cKinsokuCategories; i++ )
	{
		pWChar = charCategories[i];
		while ( ch = *pWChar++ )
		{
			bitMapKey = ch >> bitmapShift;
			classifyBitMap[bitMapKey >> 3] |= 1 << (bitMapKey & 7);
		}
	}

	// Now that we know how many chunks we'll need, allocate the memory.
	count = 1 + CountMatchingBits((DWORD *)classifyBitMap, (DWORD *)classifyBitMap, sizeof(classifyBitMap)/sizeof(DWORD));
	classifyData = (ClassifyChunk *) PvAlloc( sizeof(ClassifyChunk) * count, GMEM_ZEROINIT);
	classifyIndex = (BYTE *) PvAlloc( sizeof(BYTE) * indexSize, GMEM_ZEROINIT);

	// We failed if we did not get the memory.
	if ( !classifyData || !classifyIndex )
		return FALSE;								// FAILED.

	// Set Default missing value.
	FillMemory( classifyData, -1, sizeof(ClassifyChunk) * count );  

	// Init the pointers to the chunks, which are really just indexes into
	//  a contiguous block of memory -- an one-based array of chunks.
	pIndex = classifyIndex;
	count = 1;										// 1 based array.
	for (i = 0; i < sizeof(classifyBitMap); i++ )	// Loop over all bytes.
	{												// Get the bitmap data.
		bitData = classifyBitMap[i];				// For each bit in the byte
		for (j = 0; j < 8; j++, bitData >>= 1, pIndex++)
		{
			if(bitData & 1)			
				*pIndex = count++;					// We used a chunk.
		}
	}
	
	// Store the classifications of each character.
	// Note: classifications are 1 based, a zero value
	//  means the category was not set.
	for (i = 0; i < cKinsokuCategories; i++ )
	{
		pWChar = charCategories[i];					// Loop over all chars in
		while ( ch = *pWChar++ )					//  category.
		{
			bitMapKey = ch >> bitmapShift;
			Assert( classifyIndex[bitMapKey] > 0 );
			Assert( classifyIndex[bitMapKey] < count );

			classifyData[classifyIndex[bitMapKey]].
				classifications[ ch & ( classifyChunkSize-1 )] = (char)i;
		}
	}
	return TRUE;									// Successfully created.
}

void UninitKinsokuClassify()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "UninitKinsokuClassify");

	FreePv(classifyData);
	FreePv(classifyIndex);
}

/*
 *	KinsokuClassify(ch)
 *
 *	@func
 *		Kinsoku classify the character iff it was a given from
 *		one of the classification tables.
 *
 *	@comm
 *		Hi order bits of ch are used to get an index value used to index
 *		into an array of chunks. Each chunk contains the classifications
 *		for that character as well as some number of characters adjacent
 *		to that character. The low order bits are used to index into
 *		the chunk of adjacent characters.
 *
 *	@devnote
 *		Because of the way we constructed the array, all that we need to
 *		do is look up the data; no conditionals necessary.
 *
 *		The routine is inline to avoid the call overhead. It is static
 *		because it only returns characters from the tables; i.e., this 
 *		routine does NOT classify all Unicode characters.
 *
 *	@rdesc
 *		Returns the classification.
 */
static __forceinline INT
KinsokuClassify(
	WCHAR ch )	// @parm char to classify.
{
	//TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "KinsokuClassify");

	return classifyData[ classifyIndex[ ch >> bitmapShift ] ].
			classifications[ ch & ( classifyChunkSize-1 )];
}


#define IsSameNonFEClass(_c1, _c2)	(!(((_c1) ^ (_c2)) & WBF_CLASS))
#define IdeoKanaTypes (C3_HALFWIDTH | C3_FULLWIDTH | C3_KATAKANA | C3_HIRAGANA)
#define IdeoTypes	  (IdeoKanaTypes | C3_IDEOGRAPH)
#define IsIdeographic(_c1) ( 0 != (_c1 & (C3_KATAKANA | C3_HIRAGANA | C3_IDEOGRAPH)) )

/*
 *	IsSameClass(currType1, startType1, currType3, startType3 )
 *
 *	@func	Used to determine word breaks.
 *
 *	@comm	Ideographic chars are all considered to be unique, so that only
 *			one at a time is selected
 */
BOOL IsSameClass(WORD currType1, WORD startType1,
				 WORD currType3, WORD startType3 )
{
	BOOL	fIdeographic = IsIdeographic(currType3);

	// Do classifications for startType3 being ideographic
	if(IsIdeographic(startType3))
	{
		int checkTypes = (currType3 & IdeoTypes) ^ (startType3 & IdeoTypes);

		// We only get picky with non-ideographic Kana chars
		//  C3_HALFWIDTH | C3_FULLWIDTH | C3_KATAKANA | C3_HIRAGANA.
		return fIdeographic && (startType3 & IdeoKanaTypes) &&
			   (!checkTypes || checkTypes == C3_FULLWIDTH || checkTypes == C3_HIRAGANA || 
			   checkTypes == (C3_FULLWIDTH | C3_HIRAGANA));
	}	

	// Do classifications for nonideographic startType3
	return !fIdeographic && IsSameNonFEClass(currType1, startType1);
}

WORD ClassifyChar(
	WCHAR	ch,
	LCID	lcid)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "ClassifyChar");
	WORD wRes, cType3;
	int kinsokuclass;

	BatchClassify(&ch, 1, lcid, &cType3, &kinsokuclass, &wRes);
	return wRes;
}


//
//This is a cache of the wres information for ansi.
//
const byte rgwresAnsi[256] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, //0x00
0x00, 0x13, 0x14, 0x14, 0x14, 0x14, 0x00, 0x00, //0x08
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x10
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x18
0x32, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, //0x20
0x01, 0x01, 0x01, 0x01, 0x01, 0x41, 0x01, 0x01, //0x28
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x30
0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, //0x38
0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x40
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x48
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x50
0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, //0x58
0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x60
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x68
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x70
0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x00, //0x78
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x80
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x88
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x90
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x98
0x12, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, //0xA0
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, //0xA8
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, //0xB0
0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, //0xB8
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0xC0
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0xC8
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, //0xD0
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0xD8
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0xE0
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0xE8
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0xF0
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};//0xF8

/*
 *	BatchClassify (pch, cch, lcid, pcType3, kinsokuClassifications, pwRes)
 *
 *	@func
 *		Kinsoku classify and ClassifyChar() each character of the given string.
 *
 *	@comm
 *		The Kinsoku classifications are passed to the CanBreak() routine. We
 *		do process in batch to save on overhead.
 *
 *		If the character is not in the Kinsoku classification tables then
 *		GetStringTypeEx is used to classify any remaining character.
 *
 *		*Note* Using CT_CTYPE1 values alone is unreliable since CT_CTYPE1
 *		defines C1_PUNCT for all diacritic characters. According to KDChang,
 *		this is by design for POSIX compatibility and it couldn't be changed
 *		easily since Win9x shares the same NLS data with NT. (wchao)
 *		Therefore we use CT_CTYPE3 data to distinguish diacritics, except on
 *		Win9x, for which we use a range check, since GetStringTypeExW isn't
 *		supported).
 *
 *	@rdesc
 *		Result in out param kinsokuClassifications.
 *		pcType3 result from GetStringTypeEx for CT_CTYPE3
 */
void BatchClassify (
	const WCHAR *pch,	//@parm char string
	INT	  cch,			//@parm Count of chars in string
	LCID  lcid,			//@parm lcid to use for GetStringTypeExA()
	WORD *pcType3,		//@parm Result of GetStringTypeEx for CT_CTYPE3
	INT * kinsokuClassifications,	// @parm Result of the classifications
	WORD *pwRes)		//@parm ClassifyChar() result
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "BatchClassify");

	WCHAR	ch;
	WORD	wRes;

	Assert( cch < MAX_CLASSIFY_CHARS );
	Assert( pch );
	Assert( kinsokuClassifications );

	W32->GetStringTypes(lcid, pch, cch, pwRes, pcType3);

	while ( cch-- )									// For all ch...
	{
		wRes = *pwRes;
		ch = *pch++;
		
		if (ch <= 255)
			wRes = rgwresAnsi[ch];
		else if(IsKorean(ch))								
			wRes = WBF_KOREAN;						// Special Korean class
		else if (IsThai(ch))
			wRes = 0;						// Thai class
		else if (ch == WCH_EMBEDDING)				// Objects
			wRes = 2 | WBF_BREAKAFTER;
		else if(wRes & C1_SPACE)
		{
			if (wRes & C1_BLANK)
				wRes = 2 | WBF_ISWHITE | WBF_BREAKLINE;
			else
				wRes = 4 | WBF_ISWHITE | WBF_BREAKLINE;
		}
		else if((wRes & C1_PUNCT) && !IsDiacriticOrKashida(ch, *pcType3))
			wRes = 1;
		else 
			wRes = 0;

		*pwRes++ = wRes;

		*kinsokuClassifications++ = GetKinsokuClass(ch, *pcType3, lcid);
		pcType3++;
	}
}


/*
 *	GetKinsokuClass (ch, cType3, lcid)
 *
 *	@func
 *		Kinsoku classify ch
 *
 *	@comm
 *		The Kinsoku classifications are passed to the CanBreak() routine. This
 *		single-character routine is for use with LineServices
 *
 *		If the character is not in the Kinsoku classification tables then
 *		GetStringTypeEx is used to classify any remaining character.
 *
 *	@rdesc
 *		Kinsoku classification for ch
 */
INT GetKinsokuClass (
	WCHAR	ch,		//@parm char 
	WORD	cType3,	//@parm cType3 info
	LCID	lcid)	//@parm lcid
{
	//TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "GetKinsokuClass");

	// surrogate classification
	if (IN_RANGE(0xD800, ch, 0xDFFF))
		return IN_RANGE(0xDC00, ch, 0xDFFF) ? brkclsClose : brkclsOpen;

	INT iCategory = KinsokuClassify(ch);
	if(iCategory >= 0)
		return iCategory;

	if (cType3 == 0xFFFF)
		W32->GetStringTypeEx(lcid, CT_CTYPE3, &ch, 1, &cType3);

	if(cType3 & C3_SYMBOL)
		return 13;							// Symbol chars

	if(IsKorean(ch) || cType3 & C3_FullWidth)
		return 11;							// Ideographic chars

	return 15;								// All other chars.
}

/*
 *	CanBreak(class1, class2)
 *
 *	@func
 *		Look into the truth table to see if two consecutive charcters
 *		can have a line break between them.
 *
 *	@comm
 *		This determines whether two successive characters can break a line.
 *		The matrix is taken from JIS X4051 and is based on categorizing
 *		characters into 15 classifications.
 *
 *	@devnote
 *		The table is 1 based.
 *
 *	@rdesc
 *		Returns TRUE if the characters can be broken across a line.
 */
BOOL CanBreak(
	INT class1,		//@parm	Kinsoku classification of character #1
	INT class2 )	//@parm	Kinsoku classification of following character.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CanBreak");

	static const WORD br[16] = {//   fedc ba98 7654 3210
		0x0000,					// 0 0000 0000 0000 0000
		0x0000,					// 1 0000 0000 0000 0000
		0xfd82,					// 2 1111 1101 1000 0010
		0xfd82,					// 3 1111 1101 1000 0010
		0xfd82,					// 4 1111 1101 1000 0010
		0xfd82,					// 5 1111 1101 1000 0010
		0x6d82,					// 6 0110 1101 1000 0010
		0xfd02,					// 7 1111 1101 0000 0010
		0x0000,					// 8 0000 0000 0000 0000
		0xfd82,					// 9 1111 1101 1000 0010
		0xfd83,					// a 1111 1101 1000 0011
		0xfd82,					// b 1111 1101 1000 0010
		0x6d82,					// c 0110 1101 1000 0010
		0x5d82,					// d 0101 1101 1000 0010
		0xfd83,					// e 1111 1101 1000 0011
		0x4d82,					// f 0100 1101 1000 0010
	};
	return (br[class1] >> class2) & 1;
}

/*
 *	IsURLDelimiter(ch)
 *
 *	@func
 *		Punctuation characters are those of sets 0, 1, 2, 4, 5, and 6,
 *		and < or > which we consider to be brackets, not "less" or
 *      "greater" signs. On the other hand; "/" (in set 6) should not be
 *		a delimiter, but rather a part of the URL.
 *
 *	@comm This function is used in URL detection
 *
 *	@rdesc
 *		Returns TRUE if the character is a punctuation mark.
 */
BOOL IsURLDelimiter(
	WCHAR ch)
{
	if (IsKorean(ch))
		return TRUE;

	INT iset = KinsokuClassify(ch);

	return IN_RANGE(0, iset, 2) || (IN_RANGE(4, iset, 6) && ch != '/')
		   || ch == '<' || ch == '>';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\ctfutb.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for ctfutb.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ctfutb_h__
#define __ctfutb_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ITfLangBarMgr_FWD_DEFINED__
#define __ITfLangBarMgr_FWD_DEFINED__
typedef interface ITfLangBarMgr ITfLangBarMgr;
#endif 	/* __ITfLangBarMgr_FWD_DEFINED__ */


#ifndef __ITfLangBarEventSink_FWD_DEFINED__
#define __ITfLangBarEventSink_FWD_DEFINED__
typedef interface ITfLangBarEventSink ITfLangBarEventSink;
#endif 	/* __ITfLangBarEventSink_FWD_DEFINED__ */


#ifndef __ITfLangBarItemSink_FWD_DEFINED__
#define __ITfLangBarItemSink_FWD_DEFINED__
typedef interface ITfLangBarItemSink ITfLangBarItemSink;
#endif 	/* __ITfLangBarItemSink_FWD_DEFINED__ */


#ifndef __IEnumTfLangBarItems_FWD_DEFINED__
#define __IEnumTfLangBarItems_FWD_DEFINED__
typedef interface IEnumTfLangBarItems IEnumTfLangBarItems;
#endif 	/* __IEnumTfLangBarItems_FWD_DEFINED__ */


#ifndef __ITfLangBarItemMgr_FWD_DEFINED__
#define __ITfLangBarItemMgr_FWD_DEFINED__
typedef interface ITfLangBarItemMgr ITfLangBarItemMgr;
#endif 	/* __ITfLangBarItemMgr_FWD_DEFINED__ */


#ifndef __ITfLangBarItem_FWD_DEFINED__
#define __ITfLangBarItem_FWD_DEFINED__
typedef interface ITfLangBarItem ITfLangBarItem;
#endif 	/* __ITfLangBarItem_FWD_DEFINED__ */


#ifndef __ITfSystemLangBarItemSink_FWD_DEFINED__
#define __ITfSystemLangBarItemSink_FWD_DEFINED__
typedef interface ITfSystemLangBarItemSink ITfSystemLangBarItemSink;
#endif 	/* __ITfSystemLangBarItemSink_FWD_DEFINED__ */


#ifndef __ITfSystemLangBarItem_FWD_DEFINED__
#define __ITfSystemLangBarItem_FWD_DEFINED__
typedef interface ITfSystemLangBarItem ITfSystemLangBarItem;
#endif 	/* __ITfSystemLangBarItem_FWD_DEFINED__ */


#ifndef __ITfSystemDeviceTypeLangBarItem_FWD_DEFINED__
#define __ITfSystemDeviceTypeLangBarItem_FWD_DEFINED__
typedef interface ITfSystemDeviceTypeLangBarItem ITfSystemDeviceTypeLangBarItem;
#endif 	/* __ITfSystemDeviceTypeLangBarItem_FWD_DEFINED__ */


#ifndef __ITfLangBarItemButton_FWD_DEFINED__
#define __ITfLangBarItemButton_FWD_DEFINED__
typedef interface ITfLangBarItemButton ITfLangBarItemButton;
#endif 	/* __ITfLangBarItemButton_FWD_DEFINED__ */


#ifndef __ITfLangBarItemBitmapButton_FWD_DEFINED__
#define __ITfLangBarItemBitmapButton_FWD_DEFINED__
typedef interface ITfLangBarItemBitmapButton ITfLangBarItemBitmapButton;
#endif 	/* __ITfLangBarItemBitmapButton_FWD_DEFINED__ */


#ifndef __ITfLangBarItemBitmap_FWD_DEFINED__
#define __ITfLangBarItemBitmap_FWD_DEFINED__
typedef interface ITfLangBarItemBitmap ITfLangBarItemBitmap;
#endif 	/* __ITfLangBarItemBitmap_FWD_DEFINED__ */


#ifndef __ITfLangBarItemBalloon_FWD_DEFINED__
#define __ITfLangBarItemBalloon_FWD_DEFINED__
typedef interface ITfLangBarItemBalloon ITfLangBarItemBalloon;
#endif 	/* __ITfLangBarItemBalloon_FWD_DEFINED__ */


#ifndef __ITfMenu_FWD_DEFINED__
#define __ITfMenu_FWD_DEFINED__
typedef interface ITfMenu ITfMenu;
#endif 	/* __ITfMenu_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "msctf.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_ctfutb_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// ctfutb.h


// CTF declarations.

//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR TFPLIED, INCLUDING BUT NOT LIMITED TO
// THE TFPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#ifndef CTFUTB_DEFINED
#define CTFUTB_DEFINED

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#define TF_FLOATINGLANGBAR_WNDTITLEW L"TF_FloatingLangBar_WndTitle"
#define TF_FLOATINGLANGBAR_WNDTITLEA "TF_FloatingLangBar_WndTitle"
#ifdef UNICODE
#define TF_FLOATINGLANGBAR_WNDTITLE TF_FLOATINGLANGBAR_WNDTITLEW
#else
#define TF_FLOATINGLANGBAR_WNDTITLE TF_FLOATINGLANGBAR_WNDTITLEA
#endif
#define TF_LBI_ICON                0x00000001
#define TF_LBI_TEXT                0x00000002
#define TF_LBI_TOOLTIP             0x00000004
#define TF_LBI_BITMAP              0x00000008
#define TF_LBI_BTNALL              0x00000007
#define TF_LBI_BMPBTNALL           0x0000000b
#define TF_LBI_BMPALL              0x0000000c
#define TF_LBI_BALLOON             0x00000010
#define TF_LBI_STATUS              0x00010000
#define TF_LBI_STYLE_HIDDENSTATUSCONTROL  0x00000001
#define TF_LBI_STYLE_SHOWNINTRAY        0x00000002
#define TF_LBI_STYLE_HIDEONNOOTHERITEMS 0x00000004
#define TF_LBI_STYLE_SHOWNINTRAYONLY    0x00000008
#define TF_LBI_STYLE_HIDDENBYDEFAULT    0x00000010
#define TF_LBI_STYLE_BTN_BUTTON         0x00010000
#define TF_LBI_STYLE_BTN_MENU           0x00020000
#define TF_LBI_STYLE_BTN_TOGGLE         0x00040000
#define TF_LBI_STATUS_HIDDEN           0x00000001
#define TF_LBI_STATUS_DISABLED         0x00000002
#define TF_LBI_STATUS_BTN_TOGGLED      0x00010000
#define TF_LBI_BMPF_VERTICAL           0x00000001
#define TF_SFT_SHOWNORMAL               0x00000001
#define TF_SFT_DOCK                     0x00000002
#define TF_SFT_MINIMIZED                0x00000004
#define TF_SFT_HIDDEN                   0x00000008
#define TF_SFT_NOTRANSPARENCY           0x00000010
#define TF_SFT_LOWTRANSPARENCY          0x00000020
#define TF_SFT_HIGHTRANSPARENCY         0x00000040
#define TF_SFT_LABELS                   0x00000080
#define TF_SFT_NOLABELS                 0x00000100
#define TF_SFT_EXTRAICONSONMINIMIZED    0x00000200
#define TF_SFT_NOEXTRAICONSONMINIMIZED  0x00000400
#define TF_INVALIDMENUITEM            (UINT)(-1)
#define TF_DTLBI_USEPROFILEICON         0x00000001
#ifdef __cplusplus
}
#endif  /* __cplusplus */







extern RPC_IF_HANDLE __MIDL_itf_ctfutb_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ctfutb_0000_v0_0_s_ifspec;

#ifndef __ITfLangBarMgr_INTERFACE_DEFINED__
#define __ITfLangBarMgr_INTERFACE_DEFINED__

/* interface ITfLangBarMgr */
/* [unique][uuid][local][object] */ 

#define	TF_LBESF_GLOBAL	( 0x1 )

#define	TF_LBESF_FLOATING	( 0x2 )

#define	TF_LBSMI_FILTERCURRENTTHREAD	( 0x1 )


EXTERN_C const IID IID_ITfLangBarMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("87955690-e627-11d2-8ddb-00105a2799b5")
    ITfLangBarMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AdviseEventSink( 
            /* [in] */ ITfLangBarEventSink *pSink,
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseEventSink( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadMarshalInterface( 
            /* [in] */ DWORD dwThreadId,
            /* [in] */ DWORD dwType,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppunk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadLangBarItemMgr( 
            /* [in] */ DWORD dwThreadId,
            /* [out] */ ITfLangBarItemMgr **pplbi,
            /* [out] */ DWORD *pdwThreadid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputProcessorProfiles( 
            /* [in] */ DWORD dwThreadId,
            /* [out] */ ITfInputProcessorProfiles **ppaip,
            /* [out] */ DWORD *pdwThreadid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestoreLastFocus( 
            DWORD *pdwThreadId,
            BOOL fPrev) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetModalInput( 
            /* [in] */ ITfLangBarEventSink *pSink,
            /* [in] */ DWORD dwThreadId,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowFloating( 
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetShowFloatingStatus( 
            DWORD *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfLangBarMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfLangBarMgr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfLangBarMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfLangBarMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseEventSink )( 
            ITfLangBarMgr * This,
            /* [in] */ ITfLangBarEventSink *pSink,
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseEventSink )( 
            ITfLangBarMgr * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadMarshalInterface )( 
            ITfLangBarMgr * This,
            /* [in] */ DWORD dwThreadId,
            /* [in] */ DWORD dwType,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ IUnknown **ppunk);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadLangBarItemMgr )( 
            ITfLangBarMgr * This,
            /* [in] */ DWORD dwThreadId,
            /* [out] */ ITfLangBarItemMgr **pplbi,
            /* [out] */ DWORD *pdwThreadid);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputProcessorProfiles )( 
            ITfLangBarMgr * This,
            /* [in] */ DWORD dwThreadId,
            /* [out] */ ITfInputProcessorProfiles **ppaip,
            /* [out] */ DWORD *pdwThreadid);
        
        HRESULT ( STDMETHODCALLTYPE *RestoreLastFocus )( 
            ITfLangBarMgr * This,
            DWORD *pdwThreadId,
            BOOL fPrev);
        
        HRESULT ( STDMETHODCALLTYPE *SetModalInput )( 
            ITfLangBarMgr * This,
            /* [in] */ ITfLangBarEventSink *pSink,
            /* [in] */ DWORD dwThreadId,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ShowFloating )( 
            ITfLangBarMgr * This,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetShowFloatingStatus )( 
            ITfLangBarMgr * This,
            DWORD *pdwFlags);
        
        END_INTERFACE
    } ITfLangBarMgrVtbl;

    interface ITfLangBarMgr
    {
        CONST_VTBL struct ITfLangBarMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfLangBarMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfLangBarMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfLangBarMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfLangBarMgr_AdviseEventSink(This,pSink,hwnd,dwFlags,pdwCookie)	\
    (This)->lpVtbl -> AdviseEventSink(This,pSink,hwnd,dwFlags,pdwCookie)

#define ITfLangBarMgr_UnadviseEventSink(This,dwCookie)	\
    (This)->lpVtbl -> UnadviseEventSink(This,dwCookie)

#define ITfLangBarMgr_GetThreadMarshalInterface(This,dwThreadId,dwType,riid,ppunk)	\
    (This)->lpVtbl -> GetThreadMarshalInterface(This,dwThreadId,dwType,riid,ppunk)

#define ITfLangBarMgr_GetThreadLangBarItemMgr(This,dwThreadId,pplbi,pdwThreadid)	\
    (This)->lpVtbl -> GetThreadLangBarItemMgr(This,dwThreadId,pplbi,pdwThreadid)

#define ITfLangBarMgr_GetInputProcessorProfiles(This,dwThreadId,ppaip,pdwThreadid)	\
    (This)->lpVtbl -> GetInputProcessorProfiles(This,dwThreadId,ppaip,pdwThreadid)

#define ITfLangBarMgr_RestoreLastFocus(This,pdwThreadId,fPrev)	\
    (This)->lpVtbl -> RestoreLastFocus(This,pdwThreadId,fPrev)

#define ITfLangBarMgr_SetModalInput(This,pSink,dwThreadId,dwFlags)	\
    (This)->lpVtbl -> SetModalInput(This,pSink,dwThreadId,dwFlags)

#define ITfLangBarMgr_ShowFloating(This,dwFlags)	\
    (This)->lpVtbl -> ShowFloating(This,dwFlags)

#define ITfLangBarMgr_GetShowFloatingStatus(This,pdwFlags)	\
    (This)->lpVtbl -> GetShowFloatingStatus(This,pdwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfLangBarMgr_AdviseEventSink_Proxy( 
    ITfLangBarMgr * This,
    /* [in] */ ITfLangBarEventSink *pSink,
    /* [in] */ HWND hwnd,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD *pdwCookie);


void __RPC_STUB ITfLangBarMgr_AdviseEventSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarMgr_UnadviseEventSink_Proxy( 
    ITfLangBarMgr * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB ITfLangBarMgr_UnadviseEventSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarMgr_GetThreadMarshalInterface_Proxy( 
    ITfLangBarMgr * This,
    /* [in] */ DWORD dwThreadId,
    /* [in] */ DWORD dwType,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown **ppunk);


void __RPC_STUB ITfLangBarMgr_GetThreadMarshalInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarMgr_GetThreadLangBarItemMgr_Proxy( 
    ITfLangBarMgr * This,
    /* [in] */ DWORD dwThreadId,
    /* [out] */ ITfLangBarItemMgr **pplbi,
    /* [out] */ DWORD *pdwThreadid);


void __RPC_STUB ITfLangBarMgr_GetThreadLangBarItemMgr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarMgr_GetInputProcessorProfiles_Proxy( 
    ITfLangBarMgr * This,
    /* [in] */ DWORD dwThreadId,
    /* [out] */ ITfInputProcessorProfiles **ppaip,
    /* [out] */ DWORD *pdwThreadid);


void __RPC_STUB ITfLangBarMgr_GetInputProcessorProfiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarMgr_RestoreLastFocus_Proxy( 
    ITfLangBarMgr * This,
    DWORD *pdwThreadId,
    BOOL fPrev);


void __RPC_STUB ITfLangBarMgr_RestoreLastFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarMgr_SetModalInput_Proxy( 
    ITfLangBarMgr * This,
    /* [in] */ ITfLangBarEventSink *pSink,
    /* [in] */ DWORD dwThreadId,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITfLangBarMgr_SetModalInput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarMgr_ShowFloating_Proxy( 
    ITfLangBarMgr * This,
    DWORD dwFlags);


void __RPC_STUB ITfLangBarMgr_ShowFloating_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarMgr_GetShowFloatingStatus_Proxy( 
    ITfLangBarMgr * This,
    DWORD *pdwFlags);


void __RPC_STUB ITfLangBarMgr_GetShowFloatingStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfLangBarMgr_INTERFACE_DEFINED__ */


#ifndef __ITfLangBarEventSink_INTERFACE_DEFINED__
#define __ITfLangBarEventSink_INTERFACE_DEFINED__

/* interface ITfLangBarEventSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfLangBarEventSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("18a4e900-e0ae-11d2-afdd-00105a2799b5")
    ITfLangBarEventSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnSetFocus( 
            /* [in] */ DWORD dwThreadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnThreadTerminate( 
            /* [in] */ DWORD dwThreadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnThreadItemChange( 
            /* [in] */ DWORD dwThreadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnModalInput( 
            /* [in] */ DWORD dwThreadId,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowFloating( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemFloatingRect( 
            /* [in] */ DWORD dwThreadId,
            /* [in] */ REFGUID rguid,
            /* [out] */ RECT *prc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfLangBarEventSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfLangBarEventSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfLangBarEventSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfLangBarEventSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnSetFocus )( 
            ITfLangBarEventSink * This,
            /* [in] */ DWORD dwThreadId);
        
        HRESULT ( STDMETHODCALLTYPE *OnThreadTerminate )( 
            ITfLangBarEventSink * This,
            /* [in] */ DWORD dwThreadId);
        
        HRESULT ( STDMETHODCALLTYPE *OnThreadItemChange )( 
            ITfLangBarEventSink * This,
            /* [in] */ DWORD dwThreadId);
        
        HRESULT ( STDMETHODCALLTYPE *OnModalInput )( 
            ITfLangBarEventSink * This,
            /* [in] */ DWORD dwThreadId,
            /* [in] */ UINT uMsg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *ShowFloating )( 
            ITfLangBarEventSink * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemFloatingRect )( 
            ITfLangBarEventSink * This,
            /* [in] */ DWORD dwThreadId,
            /* [in] */ REFGUID rguid,
            /* [out] */ RECT *prc);
        
        END_INTERFACE
    } ITfLangBarEventSinkVtbl;

    interface ITfLangBarEventSink
    {
        CONST_VTBL struct ITfLangBarEventSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfLangBarEventSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfLangBarEventSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfLangBarEventSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfLangBarEventSink_OnSetFocus(This,dwThreadId)	\
    (This)->lpVtbl -> OnSetFocus(This,dwThreadId)

#define ITfLangBarEventSink_OnThreadTerminate(This,dwThreadId)	\
    (This)->lpVtbl -> OnThreadTerminate(This,dwThreadId)

#define ITfLangBarEventSink_OnThreadItemChange(This,dwThreadId)	\
    (This)->lpVtbl -> OnThreadItemChange(This,dwThreadId)

#define ITfLangBarEventSink_OnModalInput(This,dwThreadId,uMsg,wParam,lParam)	\
    (This)->lpVtbl -> OnModalInput(This,dwThreadId,uMsg,wParam,lParam)

#define ITfLangBarEventSink_ShowFloating(This,dwFlags)	\
    (This)->lpVtbl -> ShowFloating(This,dwFlags)

#define ITfLangBarEventSink_GetItemFloatingRect(This,dwThreadId,rguid,prc)	\
    (This)->lpVtbl -> GetItemFloatingRect(This,dwThreadId,rguid,prc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfLangBarEventSink_OnSetFocus_Proxy( 
    ITfLangBarEventSink * This,
    /* [in] */ DWORD dwThreadId);


void __RPC_STUB ITfLangBarEventSink_OnSetFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarEventSink_OnThreadTerminate_Proxy( 
    ITfLangBarEventSink * This,
    /* [in] */ DWORD dwThreadId);


void __RPC_STUB ITfLangBarEventSink_OnThreadTerminate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarEventSink_OnThreadItemChange_Proxy( 
    ITfLangBarEventSink * This,
    /* [in] */ DWORD dwThreadId);


void __RPC_STUB ITfLangBarEventSink_OnThreadItemChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarEventSink_OnModalInput_Proxy( 
    ITfLangBarEventSink * This,
    /* [in] */ DWORD dwThreadId,
    /* [in] */ UINT uMsg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB ITfLangBarEventSink_OnModalInput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarEventSink_ShowFloating_Proxy( 
    ITfLangBarEventSink * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITfLangBarEventSink_ShowFloating_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarEventSink_GetItemFloatingRect_Proxy( 
    ITfLangBarEventSink * This,
    /* [in] */ DWORD dwThreadId,
    /* [in] */ REFGUID rguid,
    /* [out] */ RECT *prc);


void __RPC_STUB ITfLangBarEventSink_GetItemFloatingRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfLangBarEventSink_INTERFACE_DEFINED__ */


#ifndef __ITfLangBarItemSink_INTERFACE_DEFINED__
#define __ITfLangBarItemSink_INTERFACE_DEFINED__

/* interface ITfLangBarItemSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfLangBarItemSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("57dbe1a0-de25-11d2-afdd-00105a2799b5")
    ITfLangBarItemSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnUpdate( 
            DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfLangBarItemSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfLangBarItemSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfLangBarItemSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfLangBarItemSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnUpdate )( 
            ITfLangBarItemSink * This,
            DWORD dwFlags);
        
        END_INTERFACE
    } ITfLangBarItemSinkVtbl;

    interface ITfLangBarItemSink
    {
        CONST_VTBL struct ITfLangBarItemSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfLangBarItemSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfLangBarItemSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfLangBarItemSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfLangBarItemSink_OnUpdate(This,dwFlags)	\
    (This)->lpVtbl -> OnUpdate(This,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfLangBarItemSink_OnUpdate_Proxy( 
    ITfLangBarItemSink * This,
    DWORD dwFlags);


void __RPC_STUB ITfLangBarItemSink_OnUpdate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfLangBarItemSink_INTERFACE_DEFINED__ */


#ifndef __IEnumTfLangBarItems_INTERFACE_DEFINED__
#define __IEnumTfLangBarItems_INTERFACE_DEFINED__

/* interface IEnumTfLangBarItems */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfLangBarItems;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("583f34d0-de25-11d2-afdd-00105a2799b5")
    IEnumTfLangBarItems : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfLangBarItems **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [size_is][out] */ ITfLangBarItem **ppItem,
            /* [unique][out][in] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfLangBarItemsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfLangBarItems * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfLangBarItems * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfLangBarItems * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfLangBarItems * This,
            /* [out] */ IEnumTfLangBarItems **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfLangBarItems * This,
            /* [in] */ ULONG ulCount,
            /* [size_is][out] */ ITfLangBarItem **ppItem,
            /* [unique][out][in] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfLangBarItems * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfLangBarItems * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfLangBarItemsVtbl;

    interface IEnumTfLangBarItems
    {
        CONST_VTBL struct IEnumTfLangBarItemsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfLangBarItems_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfLangBarItems_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfLangBarItems_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfLangBarItems_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumTfLangBarItems_Next(This,ulCount,ppItem,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,ppItem,pcFetched)

#define IEnumTfLangBarItems_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfLangBarItems_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfLangBarItems_Clone_Proxy( 
    IEnumTfLangBarItems * This,
    /* [out] */ IEnumTfLangBarItems **ppEnum);


void __RPC_STUB IEnumTfLangBarItems_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfLangBarItems_Next_Proxy( 
    IEnumTfLangBarItems * This,
    /* [in] */ ULONG ulCount,
    /* [size_is][out] */ ITfLangBarItem **ppItem,
    /* [unique][out][in] */ ULONG *pcFetched);


void __RPC_STUB IEnumTfLangBarItems_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfLangBarItems_Reset_Proxy( 
    IEnumTfLangBarItems * This);


void __RPC_STUB IEnumTfLangBarItems_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfLangBarItems_Skip_Proxy( 
    IEnumTfLangBarItems * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfLangBarItems_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfLangBarItems_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_ctfutb_0202 */
/* [local] */ 

typedef /* [uuid] */  DECLSPEC_UUID("12a1d29f-a065-440c-9746-eb2002c8bd19") struct TF_LANGBARITEMINFO
    {
    CLSID clsidTip;
    GUID guidItem;
    DWORD dwStyle;
    ULONG ulSort;
    WCHAR szDescription[ 32 ];
    } 	TF_LANGBARITEMINFO;



extern RPC_IF_HANDLE __MIDL_itf_ctfutb_0202_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ctfutb_0202_v0_0_s_ifspec;

#ifndef __ITfLangBarItemMgr_INTERFACE_DEFINED__
#define __ITfLangBarItemMgr_INTERFACE_DEFINED__

/* interface ITfLangBarItemMgr */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ITfLangBarItemMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ba468c55-9956-4fb1-a59d-52a7dd7cc6aa")
    ITfLangBarItemMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumItems( 
            /* [out] */ IEnumTfLangBarItems **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItem( 
            /* [in] */ REFGUID rguid,
            /* [out] */ ITfLangBarItem **ppItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddItem( 
            /* [in] */ ITfLangBarItem *punk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveItem( 
            /* [in] */ ITfLangBarItem *punk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AdviseItemSink( 
            /* [in] */ ITfLangBarItemSink *punk,
            /* [out] */ DWORD *pdwCookie,
            /* [in] */ REFGUID rguidItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseItemSink( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemFloatingRect( 
            /* [in] */ DWORD dwThreadId,
            /* [in] */ REFGUID rguid,
            /* [out] */ RECT *prc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemsStatus( 
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const GUID *prgguid,
            /* [size_is][out][in] */ DWORD *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemNum( 
            /* [out] */ ULONG *pulCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItems( 
            /* [in] */ ULONG ulCount,
            /* [size_is][out] */ ITfLangBarItem **ppItem,
            /* [size_is][out][in] */ TF_LANGBARITEMINFO *pInfo,
            /* [size_is][out][in] */ DWORD *pdwStatus,
            /* [unique][out][in] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AdviseItemsSink( 
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ ITfLangBarItemSink **ppunk,
            /* [size_is][in] */ const GUID *pguidItem,
            /* [size_is][out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnadviseItemsSink( 
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ DWORD *pdwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfLangBarItemMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfLangBarItemMgr * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfLangBarItemMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfLangBarItemMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumItems )( 
            ITfLangBarItemMgr * This,
            /* [out] */ IEnumTfLangBarItems **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            ITfLangBarItemMgr * This,
            /* [in] */ REFGUID rguid,
            /* [out] */ ITfLangBarItem **ppItem);
        
        HRESULT ( STDMETHODCALLTYPE *AddItem )( 
            ITfLangBarItemMgr * This,
            /* [in] */ ITfLangBarItem *punk);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveItem )( 
            ITfLangBarItemMgr * This,
            /* [in] */ ITfLangBarItem *punk);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseItemSink )( 
            ITfLangBarItemMgr * This,
            /* [in] */ ITfLangBarItemSink *punk,
            /* [out] */ DWORD *pdwCookie,
            /* [in] */ REFGUID rguidItem);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseItemSink )( 
            ITfLangBarItemMgr * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemFloatingRect )( 
            ITfLangBarItemMgr * This,
            /* [in] */ DWORD dwThreadId,
            /* [in] */ REFGUID rguid,
            /* [out] */ RECT *prc);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemsStatus )( 
            ITfLangBarItemMgr * This,
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const GUID *prgguid,
            /* [size_is][out][in] */ DWORD *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemNum )( 
            ITfLangBarItemMgr * This,
            /* [out] */ ULONG *pulCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetItems )( 
            ITfLangBarItemMgr * This,
            /* [in] */ ULONG ulCount,
            /* [size_is][out] */ ITfLangBarItem **ppItem,
            /* [size_is][out][in] */ TF_LANGBARITEMINFO *pInfo,
            /* [size_is][out][in] */ DWORD *pdwStatus,
            /* [unique][out][in] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *AdviseItemsSink )( 
            ITfLangBarItemMgr * This,
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ ITfLangBarItemSink **ppunk,
            /* [size_is][in] */ const GUID *pguidItem,
            /* [size_is][out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *UnadviseItemsSink )( 
            ITfLangBarItemMgr * This,
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ DWORD *pdwCookie);
        
        END_INTERFACE
    } ITfLangBarItemMgrVtbl;

    interface ITfLangBarItemMgr
    {
        CONST_VTBL struct ITfLangBarItemMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfLangBarItemMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfLangBarItemMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfLangBarItemMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfLangBarItemMgr_EnumItems(This,ppEnum)	\
    (This)->lpVtbl -> EnumItems(This,ppEnum)

#define ITfLangBarItemMgr_GetItem(This,rguid,ppItem)	\
    (This)->lpVtbl -> GetItem(This,rguid,ppItem)

#define ITfLangBarItemMgr_AddItem(This,punk)	\
    (This)->lpVtbl -> AddItem(This,punk)

#define ITfLangBarItemMgr_RemoveItem(This,punk)	\
    (This)->lpVtbl -> RemoveItem(This,punk)

#define ITfLangBarItemMgr_AdviseItemSink(This,punk,pdwCookie,rguidItem)	\
    (This)->lpVtbl -> AdviseItemSink(This,punk,pdwCookie,rguidItem)

#define ITfLangBarItemMgr_UnadviseItemSink(This,dwCookie)	\
    (This)->lpVtbl -> UnadviseItemSink(This,dwCookie)

#define ITfLangBarItemMgr_GetItemFloatingRect(This,dwThreadId,rguid,prc)	\
    (This)->lpVtbl -> GetItemFloatingRect(This,dwThreadId,rguid,prc)

#define ITfLangBarItemMgr_GetItemsStatus(This,ulCount,prgguid,pdwStatus)	\
    (This)->lpVtbl -> GetItemsStatus(This,ulCount,prgguid,pdwStatus)

#define ITfLangBarItemMgr_GetItemNum(This,pulCount)	\
    (This)->lpVtbl -> GetItemNum(This,pulCount)

#define ITfLangBarItemMgr_GetItems(This,ulCount,ppItem,pInfo,pdwStatus,pcFetched)	\
    (This)->lpVtbl -> GetItems(This,ulCount,ppItem,pInfo,pdwStatus,pcFetched)

#define ITfLangBarItemMgr_AdviseItemsSink(This,ulCount,ppunk,pguidItem,pdwCookie)	\
    (This)->lpVtbl -> AdviseItemsSink(This,ulCount,ppunk,pguidItem,pdwCookie)

#define ITfLangBarItemMgr_UnadviseItemsSink(This,ulCount,pdwCookie)	\
    (This)->lpVtbl -> UnadviseItemsSink(This,ulCount,pdwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfLangBarItemMgr_EnumItems_Proxy( 
    ITfLangBarItemMgr * This,
    /* [out] */ IEnumTfLangBarItems **ppEnum);


void __RPC_STUB ITfLangBarItemMgr_EnumItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemMgr_GetItem_Proxy( 
    ITfLangBarItemMgr * This,
    /* [in] */ REFGUID rguid,
    /* [out] */ ITfLangBarItem **ppItem);


void __RPC_STUB ITfLangBarItemMgr_GetItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemMgr_AddItem_Proxy( 
    ITfLangBarItemMgr * This,
    /* [in] */ ITfLangBarItem *punk);


void __RPC_STUB ITfLangBarItemMgr_AddItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemMgr_RemoveItem_Proxy( 
    ITfLangBarItemMgr * This,
    /* [in] */ ITfLangBarItem *punk);


void __RPC_STUB ITfLangBarItemMgr_RemoveItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemMgr_AdviseItemSink_Proxy( 
    ITfLangBarItemMgr * This,
    /* [in] */ ITfLangBarItemSink *punk,
    /* [out] */ DWORD *pdwCookie,
    /* [in] */ REFGUID rguidItem);


void __RPC_STUB ITfLangBarItemMgr_AdviseItemSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemMgr_UnadviseItemSink_Proxy( 
    ITfLangBarItemMgr * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB ITfLangBarItemMgr_UnadviseItemSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemMgr_GetItemFloatingRect_Proxy( 
    ITfLangBarItemMgr * This,
    /* [in] */ DWORD dwThreadId,
    /* [in] */ REFGUID rguid,
    /* [out] */ RECT *prc);


void __RPC_STUB ITfLangBarItemMgr_GetItemFloatingRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemMgr_GetItemsStatus_Proxy( 
    ITfLangBarItemMgr * This,
    /* [in] */ ULONG ulCount,
    /* [size_is][in] */ const GUID *prgguid,
    /* [size_is][out][in] */ DWORD *pdwStatus);


void __RPC_STUB ITfLangBarItemMgr_GetItemsStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemMgr_GetItemNum_Proxy( 
    ITfLangBarItemMgr * This,
    /* [out] */ ULONG *pulCount);


void __RPC_STUB ITfLangBarItemMgr_GetItemNum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemMgr_GetItems_Proxy( 
    ITfLangBarItemMgr * This,
    /* [in] */ ULONG ulCount,
    /* [size_is][out] */ ITfLangBarItem **ppItem,
    /* [size_is][out][in] */ TF_LANGBARITEMINFO *pInfo,
    /* [size_is][out][in] */ DWORD *pdwStatus,
    /* [unique][out][in] */ ULONG *pcFetched);


void __RPC_STUB ITfLangBarItemMgr_GetItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemMgr_AdviseItemsSink_Proxy( 
    ITfLangBarItemMgr * This,
    /* [in] */ ULONG ulCount,
    /* [size_is][in] */ ITfLangBarItemSink **ppunk,
    /* [size_is][in] */ const GUID *pguidItem,
    /* [size_is][out] */ DWORD *pdwCookie);


void __RPC_STUB ITfLangBarItemMgr_AdviseItemsSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemMgr_UnadviseItemsSink_Proxy( 
    ITfLangBarItemMgr * This,
    /* [in] */ ULONG ulCount,
    /* [size_is][in] */ DWORD *pdwCookie);


void __RPC_STUB ITfLangBarItemMgr_UnadviseItemsSink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfLangBarItemMgr_INTERFACE_DEFINED__ */


#ifndef __ITfLangBarItem_INTERFACE_DEFINED__
#define __ITfLangBarItem_INTERFACE_DEFINED__

/* interface ITfLangBarItem */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfLangBarItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("73540d69-edeb-4ee9-96c9-23aa30b25916")
    ITfLangBarItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInfo( 
            /* [out] */ TF_LANGBARITEMINFO *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [out] */ DWORD *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Show( 
            /* [in] */ BOOL fShow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTooltipString( 
            /* [out] */ BSTR *pbstrToolTip) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfLangBarItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfLangBarItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfLangBarItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfLangBarItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            ITfLangBarItem * This,
            /* [out] */ TF_LANGBARITEMINFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            ITfLangBarItem * This,
            /* [out] */ DWORD *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE *Show )( 
            ITfLangBarItem * This,
            /* [in] */ BOOL fShow);
        
        HRESULT ( STDMETHODCALLTYPE *GetTooltipString )( 
            ITfLangBarItem * This,
            /* [out] */ BSTR *pbstrToolTip);
        
        END_INTERFACE
    } ITfLangBarItemVtbl;

    interface ITfLangBarItem
    {
        CONST_VTBL struct ITfLangBarItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfLangBarItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfLangBarItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfLangBarItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfLangBarItem_GetInfo(This,pInfo)	\
    (This)->lpVtbl -> GetInfo(This,pInfo)

#define ITfLangBarItem_GetStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetStatus(This,pdwStatus)

#define ITfLangBarItem_Show(This,fShow)	\
    (This)->lpVtbl -> Show(This,fShow)

#define ITfLangBarItem_GetTooltipString(This,pbstrToolTip)	\
    (This)->lpVtbl -> GetTooltipString(This,pbstrToolTip)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfLangBarItem_GetInfo_Proxy( 
    ITfLangBarItem * This,
    /* [out] */ TF_LANGBARITEMINFO *pInfo);


void __RPC_STUB ITfLangBarItem_GetInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItem_GetStatus_Proxy( 
    ITfLangBarItem * This,
    /* [out] */ DWORD *pdwStatus);


void __RPC_STUB ITfLangBarItem_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItem_Show_Proxy( 
    ITfLangBarItem * This,
    /* [in] */ BOOL fShow);


void __RPC_STUB ITfLangBarItem_Show_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItem_GetTooltipString_Proxy( 
    ITfLangBarItem * This,
    /* [out] */ BSTR *pbstrToolTip);


void __RPC_STUB ITfLangBarItem_GetTooltipString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfLangBarItem_INTERFACE_DEFINED__ */


#ifndef __ITfSystemLangBarItemSink_INTERFACE_DEFINED__
#define __ITfSystemLangBarItemSink_INTERFACE_DEFINED__

/* interface ITfSystemLangBarItemSink */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfSystemLangBarItemSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1449d9ab-13cf-4687-aa3e-8d8b18574396")
    ITfSystemLangBarItemSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitMenu( 
            /* [in] */ ITfMenu *pMenu) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnMenuSelect( 
            /* [in] */ UINT wID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfSystemLangBarItemSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfSystemLangBarItemSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfSystemLangBarItemSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfSystemLangBarItemSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitMenu )( 
            ITfSystemLangBarItemSink * This,
            /* [in] */ ITfMenu *pMenu);
        
        HRESULT ( STDMETHODCALLTYPE *OnMenuSelect )( 
            ITfSystemLangBarItemSink * This,
            /* [in] */ UINT wID);
        
        END_INTERFACE
    } ITfSystemLangBarItemSinkVtbl;

    interface ITfSystemLangBarItemSink
    {
        CONST_VTBL struct ITfSystemLangBarItemSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfSystemLangBarItemSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfSystemLangBarItemSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfSystemLangBarItemSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfSystemLangBarItemSink_InitMenu(This,pMenu)	\
    (This)->lpVtbl -> InitMenu(This,pMenu)

#define ITfSystemLangBarItemSink_OnMenuSelect(This,wID)	\
    (This)->lpVtbl -> OnMenuSelect(This,wID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfSystemLangBarItemSink_InitMenu_Proxy( 
    ITfSystemLangBarItemSink * This,
    /* [in] */ ITfMenu *pMenu);


void __RPC_STUB ITfSystemLangBarItemSink_InitMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfSystemLangBarItemSink_OnMenuSelect_Proxy( 
    ITfSystemLangBarItemSink * This,
    /* [in] */ UINT wID);


void __RPC_STUB ITfSystemLangBarItemSink_OnMenuSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfSystemLangBarItemSink_INTERFACE_DEFINED__ */


#ifndef __ITfSystemLangBarItem_INTERFACE_DEFINED__
#define __ITfSystemLangBarItem_INTERFACE_DEFINED__

/* interface ITfSystemLangBarItem */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfSystemLangBarItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1e13e9ec-6b33-4d4a-b5eb-8a92f029f356")
    ITfSystemLangBarItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetIcon( 
            /* [in] */ HICON hIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTooltipString( 
            /* [size_is][in] */ WCHAR *pchToolTip,
            /* [in] */ ULONG cch) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfSystemLangBarItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfSystemLangBarItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfSystemLangBarItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfSystemLangBarItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetIcon )( 
            ITfSystemLangBarItem * This,
            /* [in] */ HICON hIcon);
        
        HRESULT ( STDMETHODCALLTYPE *SetTooltipString )( 
            ITfSystemLangBarItem * This,
            /* [size_is][in] */ WCHAR *pchToolTip,
            /* [in] */ ULONG cch);
        
        END_INTERFACE
    } ITfSystemLangBarItemVtbl;

    interface ITfSystemLangBarItem
    {
        CONST_VTBL struct ITfSystemLangBarItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfSystemLangBarItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfSystemLangBarItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfSystemLangBarItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfSystemLangBarItem_SetIcon(This,hIcon)	\
    (This)->lpVtbl -> SetIcon(This,hIcon)

#define ITfSystemLangBarItem_SetTooltipString(This,pchToolTip,cch)	\
    (This)->lpVtbl -> SetTooltipString(This,pchToolTip,cch)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfSystemLangBarItem_SetIcon_Proxy( 
    ITfSystemLangBarItem * This,
    /* [in] */ HICON hIcon);


void __RPC_STUB ITfSystemLangBarItem_SetIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfSystemLangBarItem_SetTooltipString_Proxy( 
    ITfSystemLangBarItem * This,
    /* [size_is][in] */ WCHAR *pchToolTip,
    /* [in] */ ULONG cch);


void __RPC_STUB ITfSystemLangBarItem_SetTooltipString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfSystemLangBarItem_INTERFACE_DEFINED__ */


#ifndef __ITfSystemDeviceTypeLangBarItem_INTERFACE_DEFINED__
#define __ITfSystemDeviceTypeLangBarItem_INTERFACE_DEFINED__

/* interface ITfSystemDeviceTypeLangBarItem */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfSystemDeviceTypeLangBarItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("45672eb9-9059-46a2-838d-4530355f6a77")
    ITfSystemDeviceTypeLangBarItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetIconMode( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIconMode( 
            /* [out] */ DWORD *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfSystemDeviceTypeLangBarItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfSystemDeviceTypeLangBarItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfSystemDeviceTypeLangBarItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfSystemDeviceTypeLangBarItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetIconMode )( 
            ITfSystemDeviceTypeLangBarItem * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetIconMode )( 
            ITfSystemDeviceTypeLangBarItem * This,
            /* [out] */ DWORD *pdwFlags);
        
        END_INTERFACE
    } ITfSystemDeviceTypeLangBarItemVtbl;

    interface ITfSystemDeviceTypeLangBarItem
    {
        CONST_VTBL struct ITfSystemDeviceTypeLangBarItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfSystemDeviceTypeLangBarItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfSystemDeviceTypeLangBarItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfSystemDeviceTypeLangBarItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfSystemDeviceTypeLangBarItem_SetIconMode(This,dwFlags)	\
    (This)->lpVtbl -> SetIconMode(This,dwFlags)

#define ITfSystemDeviceTypeLangBarItem_GetIconMode(This,pdwFlags)	\
    (This)->lpVtbl -> GetIconMode(This,pdwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfSystemDeviceTypeLangBarItem_SetIconMode_Proxy( 
    ITfSystemDeviceTypeLangBarItem * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITfSystemDeviceTypeLangBarItem_SetIconMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfSystemDeviceTypeLangBarItem_GetIconMode_Proxy( 
    ITfSystemDeviceTypeLangBarItem * This,
    /* [out] */ DWORD *pdwFlags);


void __RPC_STUB ITfSystemDeviceTypeLangBarItem_GetIconMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfSystemDeviceTypeLangBarItem_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_ctfutb_0207 */
/* [local] */ 

typedef /* [public][public][public][public][public][uuid] */  DECLSPEC_UUID("8fb5f0ce-dfdd-4f0a-85b9-8988d8dd8ff2") 
enum __MIDL___MIDL_itf_ctfutb_0207_0001
    {	TF_LBI_CLK_NONE	= 0,
	TF_LBI_CLK_RIGHT	= 1,
	TF_LBI_CLK_LEFT	= 2,
	TF_LBI_CLK_RIGHT_DBL	= 3,
	TF_LBI_CLK_LEFT_DBL	= 4
    } 	TfLBIClick;



extern RPC_IF_HANDLE __MIDL_itf_ctfutb_0207_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ctfutb_0207_v0_0_s_ifspec;

#ifndef __ITfLangBarItemButton_INTERFACE_DEFINED__
#define __ITfLangBarItemButton_INTERFACE_DEFINED__

/* interface ITfLangBarItemButton */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfLangBarItemButton;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("28c7f1d0-de25-11d2-afdd-00105a2799b5")
    ITfLangBarItemButton : public ITfLangBarItem
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnClick( 
            /* [in] */ TfLBIClick click,
            /* [in] */ POINT pt,
            /* [in] */ const RECT *prcArea) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitMenu( 
            /* [in] */ ITfMenu *pMenu) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnMenuSelect( 
            /* [in] */ UINT wID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIcon( 
            /* [out] */ HICON *phIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            /* [out] */ BSTR *pbstrText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfLangBarItemButtonVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfLangBarItemButton * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfLangBarItemButton * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfLangBarItemButton * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            ITfLangBarItemButton * This,
            /* [out] */ TF_LANGBARITEMINFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            ITfLangBarItemButton * This,
            /* [out] */ DWORD *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE *Show )( 
            ITfLangBarItemButton * This,
            /* [in] */ BOOL fShow);
        
        HRESULT ( STDMETHODCALLTYPE *GetTooltipString )( 
            ITfLangBarItemButton * This,
            /* [out] */ BSTR *pbstrToolTip);
        
        HRESULT ( STDMETHODCALLTYPE *OnClick )( 
            ITfLangBarItemButton * This,
            /* [in] */ TfLBIClick click,
            /* [in] */ POINT pt,
            /* [in] */ const RECT *prcArea);
        
        HRESULT ( STDMETHODCALLTYPE *InitMenu )( 
            ITfLangBarItemButton * This,
            /* [in] */ ITfMenu *pMenu);
        
        HRESULT ( STDMETHODCALLTYPE *OnMenuSelect )( 
            ITfLangBarItemButton * This,
            /* [in] */ UINT wID);
        
        HRESULT ( STDMETHODCALLTYPE *GetIcon )( 
            ITfLangBarItemButton * This,
            /* [out] */ HICON *phIcon);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            ITfLangBarItemButton * This,
            /* [out] */ BSTR *pbstrText);
        
        END_INTERFACE
    } ITfLangBarItemButtonVtbl;

    interface ITfLangBarItemButton
    {
        CONST_VTBL struct ITfLangBarItemButtonVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfLangBarItemButton_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfLangBarItemButton_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfLangBarItemButton_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfLangBarItemButton_GetInfo(This,pInfo)	\
    (This)->lpVtbl -> GetInfo(This,pInfo)

#define ITfLangBarItemButton_GetStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetStatus(This,pdwStatus)

#define ITfLangBarItemButton_Show(This,fShow)	\
    (This)->lpVtbl -> Show(This,fShow)

#define ITfLangBarItemButton_GetTooltipString(This,pbstrToolTip)	\
    (This)->lpVtbl -> GetTooltipString(This,pbstrToolTip)


#define ITfLangBarItemButton_OnClick(This,click,pt,prcArea)	\
    (This)->lpVtbl -> OnClick(This,click,pt,prcArea)

#define ITfLangBarItemButton_InitMenu(This,pMenu)	\
    (This)->lpVtbl -> InitMenu(This,pMenu)

#define ITfLangBarItemButton_OnMenuSelect(This,wID)	\
    (This)->lpVtbl -> OnMenuSelect(This,wID)

#define ITfLangBarItemButton_GetIcon(This,phIcon)	\
    (This)->lpVtbl -> GetIcon(This,phIcon)

#define ITfLangBarItemButton_GetText(This,pbstrText)	\
    (This)->lpVtbl -> GetText(This,pbstrText)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfLangBarItemButton_OnClick_Proxy( 
    ITfLangBarItemButton * This,
    /* [in] */ TfLBIClick click,
    /* [in] */ POINT pt,
    /* [in] */ const RECT *prcArea);


void __RPC_STUB ITfLangBarItemButton_OnClick_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemButton_InitMenu_Proxy( 
    ITfLangBarItemButton * This,
    /* [in] */ ITfMenu *pMenu);


void __RPC_STUB ITfLangBarItemButton_InitMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemButton_OnMenuSelect_Proxy( 
    ITfLangBarItemButton * This,
    /* [in] */ UINT wID);


void __RPC_STUB ITfLangBarItemButton_OnMenuSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemButton_GetIcon_Proxy( 
    ITfLangBarItemButton * This,
    /* [out] */ HICON *phIcon);


void __RPC_STUB ITfLangBarItemButton_GetIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemButton_GetText_Proxy( 
    ITfLangBarItemButton * This,
    /* [out] */ BSTR *pbstrText);


void __RPC_STUB ITfLangBarItemButton_GetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfLangBarItemButton_INTERFACE_DEFINED__ */


#ifndef __ITfLangBarItemBitmapButton_INTERFACE_DEFINED__
#define __ITfLangBarItemBitmapButton_INTERFACE_DEFINED__

/* interface ITfLangBarItemBitmapButton */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfLangBarItemBitmapButton;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a26a0525-3fae-4fa0-89ee-88a964f9f1b5")
    ITfLangBarItemBitmapButton : public ITfLangBarItem
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnClick( 
            /* [in] */ TfLBIClick click,
            /* [in] */ POINT pt,
            /* [in] */ const RECT *prcArea) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitMenu( 
            /* [in] */ ITfMenu *pMenu) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnMenuSelect( 
            /* [in] */ UINT wID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPreferedSize( 
            /* [in] */ const SIZE *pszDefault,
            /* [out] */ SIZE *psz) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DrawBitmap( 
            /* [in] */ LONG bmWidth,
            /* [in] */ LONG bmHeight,
            /* [in] */ DWORD dwFlags,
            /* [out] */ HBITMAP *phbmp,
            /* [out] */ HBITMAP *phbmpMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            /* [out] */ BSTR *pbstrText) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfLangBarItemBitmapButtonVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfLangBarItemBitmapButton * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfLangBarItemBitmapButton * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfLangBarItemBitmapButton * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            ITfLangBarItemBitmapButton * This,
            /* [out] */ TF_LANGBARITEMINFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            ITfLangBarItemBitmapButton * This,
            /* [out] */ DWORD *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE *Show )( 
            ITfLangBarItemBitmapButton * This,
            /* [in] */ BOOL fShow);
        
        HRESULT ( STDMETHODCALLTYPE *GetTooltipString )( 
            ITfLangBarItemBitmapButton * This,
            /* [out] */ BSTR *pbstrToolTip);
        
        HRESULT ( STDMETHODCALLTYPE *OnClick )( 
            ITfLangBarItemBitmapButton * This,
            /* [in] */ TfLBIClick click,
            /* [in] */ POINT pt,
            /* [in] */ const RECT *prcArea);
        
        HRESULT ( STDMETHODCALLTYPE *InitMenu )( 
            ITfLangBarItemBitmapButton * This,
            /* [in] */ ITfMenu *pMenu);
        
        HRESULT ( STDMETHODCALLTYPE *OnMenuSelect )( 
            ITfLangBarItemBitmapButton * This,
            /* [in] */ UINT wID);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreferedSize )( 
            ITfLangBarItemBitmapButton * This,
            /* [in] */ const SIZE *pszDefault,
            /* [out] */ SIZE *psz);
        
        HRESULT ( STDMETHODCALLTYPE *DrawBitmap )( 
            ITfLangBarItemBitmapButton * This,
            /* [in] */ LONG bmWidth,
            /* [in] */ LONG bmHeight,
            /* [in] */ DWORD dwFlags,
            /* [out] */ HBITMAP *phbmp,
            /* [out] */ HBITMAP *phbmpMask);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            ITfLangBarItemBitmapButton * This,
            /* [out] */ BSTR *pbstrText);
        
        END_INTERFACE
    } ITfLangBarItemBitmapButtonVtbl;

    interface ITfLangBarItemBitmapButton
    {
        CONST_VTBL struct ITfLangBarItemBitmapButtonVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfLangBarItemBitmapButton_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfLangBarItemBitmapButton_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfLangBarItemBitmapButton_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfLangBarItemBitmapButton_GetInfo(This,pInfo)	\
    (This)->lpVtbl -> GetInfo(This,pInfo)

#define ITfLangBarItemBitmapButton_GetStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetStatus(This,pdwStatus)

#define ITfLangBarItemBitmapButton_Show(This,fShow)	\
    (This)->lpVtbl -> Show(This,fShow)

#define ITfLangBarItemBitmapButton_GetTooltipString(This,pbstrToolTip)	\
    (This)->lpVtbl -> GetTooltipString(This,pbstrToolTip)


#define ITfLangBarItemBitmapButton_OnClick(This,click,pt,prcArea)	\
    (This)->lpVtbl -> OnClick(This,click,pt,prcArea)

#define ITfLangBarItemBitmapButton_InitMenu(This,pMenu)	\
    (This)->lpVtbl -> InitMenu(This,pMenu)

#define ITfLangBarItemBitmapButton_OnMenuSelect(This,wID)	\
    (This)->lpVtbl -> OnMenuSelect(This,wID)

#define ITfLangBarItemBitmapButton_GetPreferedSize(This,pszDefault,psz)	\
    (This)->lpVtbl -> GetPreferedSize(This,pszDefault,psz)

#define ITfLangBarItemBitmapButton_DrawBitmap(This,bmWidth,bmHeight,dwFlags,phbmp,phbmpMask)	\
    (This)->lpVtbl -> DrawBitmap(This,bmWidth,bmHeight,dwFlags,phbmp,phbmpMask)

#define ITfLangBarItemBitmapButton_GetText(This,pbstrText)	\
    (This)->lpVtbl -> GetText(This,pbstrText)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfLangBarItemBitmapButton_OnClick_Proxy( 
    ITfLangBarItemBitmapButton * This,
    /* [in] */ TfLBIClick click,
    /* [in] */ POINT pt,
    /* [in] */ const RECT *prcArea);


void __RPC_STUB ITfLangBarItemBitmapButton_OnClick_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemBitmapButton_InitMenu_Proxy( 
    ITfLangBarItemBitmapButton * This,
    /* [in] */ ITfMenu *pMenu);


void __RPC_STUB ITfLangBarItemBitmapButton_InitMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemBitmapButton_OnMenuSelect_Proxy( 
    ITfLangBarItemBitmapButton * This,
    /* [in] */ UINT wID);


void __RPC_STUB ITfLangBarItemBitmapButton_OnMenuSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemBitmapButton_GetPreferedSize_Proxy( 
    ITfLangBarItemBitmapButton * This,
    /* [in] */ const SIZE *pszDefault,
    /* [out] */ SIZE *psz);


void __RPC_STUB ITfLangBarItemBitmapButton_GetPreferedSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemBitmapButton_DrawBitmap_Proxy( 
    ITfLangBarItemBitmapButton * This,
    /* [in] */ LONG bmWidth,
    /* [in] */ LONG bmHeight,
    /* [in] */ DWORD dwFlags,
    /* [out] */ HBITMAP *phbmp,
    /* [out] */ HBITMAP *phbmpMask);


void __RPC_STUB ITfLangBarItemBitmapButton_DrawBitmap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemBitmapButton_GetText_Proxy( 
    ITfLangBarItemBitmapButton * This,
    /* [out] */ BSTR *pbstrText);


void __RPC_STUB ITfLangBarItemBitmapButton_GetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfLangBarItemBitmapButton_INTERFACE_DEFINED__ */


#ifndef __ITfLangBarItemBitmap_INTERFACE_DEFINED__
#define __ITfLangBarItemBitmap_INTERFACE_DEFINED__

/* interface ITfLangBarItemBitmap */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfLangBarItemBitmap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("73830352-d722-4179-ada5-f045c98df355")
    ITfLangBarItemBitmap : public ITfLangBarItem
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnClick( 
            /* [in] */ TfLBIClick click,
            /* [in] */ POINT pt,
            /* [in] */ const RECT *prcArea) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPreferedSize( 
            /* [in] */ const SIZE *pszDefault,
            /* [out] */ SIZE *psz) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DrawBitmap( 
            /* [in] */ LONG bmWidth,
            /* [in] */ LONG bmHeight,
            /* [in] */ DWORD dwFlags,
            /* [out] */ HBITMAP *phbmp,
            /* [out] */ HBITMAP *phbmpMask) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfLangBarItemBitmapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfLangBarItemBitmap * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfLangBarItemBitmap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfLangBarItemBitmap * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            ITfLangBarItemBitmap * This,
            /* [out] */ TF_LANGBARITEMINFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            ITfLangBarItemBitmap * This,
            /* [out] */ DWORD *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE *Show )( 
            ITfLangBarItemBitmap * This,
            /* [in] */ BOOL fShow);
        
        HRESULT ( STDMETHODCALLTYPE *GetTooltipString )( 
            ITfLangBarItemBitmap * This,
            /* [out] */ BSTR *pbstrToolTip);
        
        HRESULT ( STDMETHODCALLTYPE *OnClick )( 
            ITfLangBarItemBitmap * This,
            /* [in] */ TfLBIClick click,
            /* [in] */ POINT pt,
            /* [in] */ const RECT *prcArea);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreferedSize )( 
            ITfLangBarItemBitmap * This,
            /* [in] */ const SIZE *pszDefault,
            /* [out] */ SIZE *psz);
        
        HRESULT ( STDMETHODCALLTYPE *DrawBitmap )( 
            ITfLangBarItemBitmap * This,
            /* [in] */ LONG bmWidth,
            /* [in] */ LONG bmHeight,
            /* [in] */ DWORD dwFlags,
            /* [out] */ HBITMAP *phbmp,
            /* [out] */ HBITMAP *phbmpMask);
        
        END_INTERFACE
    } ITfLangBarItemBitmapVtbl;

    interface ITfLangBarItemBitmap
    {
        CONST_VTBL struct ITfLangBarItemBitmapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfLangBarItemBitmap_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfLangBarItemBitmap_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfLangBarItemBitmap_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfLangBarItemBitmap_GetInfo(This,pInfo)	\
    (This)->lpVtbl -> GetInfo(This,pInfo)

#define ITfLangBarItemBitmap_GetStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetStatus(This,pdwStatus)

#define ITfLangBarItemBitmap_Show(This,fShow)	\
    (This)->lpVtbl -> Show(This,fShow)

#define ITfLangBarItemBitmap_GetTooltipString(This,pbstrToolTip)	\
    (This)->lpVtbl -> GetTooltipString(This,pbstrToolTip)


#define ITfLangBarItemBitmap_OnClick(This,click,pt,prcArea)	\
    (This)->lpVtbl -> OnClick(This,click,pt,prcArea)

#define ITfLangBarItemBitmap_GetPreferedSize(This,pszDefault,psz)	\
    (This)->lpVtbl -> GetPreferedSize(This,pszDefault,psz)

#define ITfLangBarItemBitmap_DrawBitmap(This,bmWidth,bmHeight,dwFlags,phbmp,phbmpMask)	\
    (This)->lpVtbl -> DrawBitmap(This,bmWidth,bmHeight,dwFlags,phbmp,phbmpMask)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfLangBarItemBitmap_OnClick_Proxy( 
    ITfLangBarItemBitmap * This,
    /* [in] */ TfLBIClick click,
    /* [in] */ POINT pt,
    /* [in] */ const RECT *prcArea);


void __RPC_STUB ITfLangBarItemBitmap_OnClick_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemBitmap_GetPreferedSize_Proxy( 
    ITfLangBarItemBitmap * This,
    /* [in] */ const SIZE *pszDefault,
    /* [out] */ SIZE *psz);


void __RPC_STUB ITfLangBarItemBitmap_GetPreferedSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemBitmap_DrawBitmap_Proxy( 
    ITfLangBarItemBitmap * This,
    /* [in] */ LONG bmWidth,
    /* [in] */ LONG bmHeight,
    /* [in] */ DWORD dwFlags,
    /* [out] */ HBITMAP *phbmp,
    /* [out] */ HBITMAP *phbmpMask);


void __RPC_STUB ITfLangBarItemBitmap_DrawBitmap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfLangBarItemBitmap_INTERFACE_DEFINED__ */


#ifndef __ITfLangBarItemBalloon_INTERFACE_DEFINED__
#define __ITfLangBarItemBalloon_INTERFACE_DEFINED__

/* interface ITfLangBarItemBalloon */
/* [unique][uuid][object] */ 

typedef /* [public][public][public][uuid] */  DECLSPEC_UUID("f399a969-9e97-4ddd-b974-2bfb934cfbc9") 
enum __MIDL_ITfLangBarItemBalloon_0001
    {	TF_LB_BALLOON_RECO	= 0,
	TF_LB_BALLOON_SHOW	= 1,
	TF_LB_BALLOON_MISS	= 2
    } 	TfLBBalloonStyle;

typedef /* [uuid] */  DECLSPEC_UUID("37574483-5c50-4092-a55c-922e3a67e5b8") struct TF_LBBALLOONINFO
    {
    TfLBBalloonStyle style;
    BSTR bstrText;
    } 	TF_LBBALLOONINFO;


EXTERN_C const IID IID_ITfLangBarItemBalloon;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("01C2D285-D3C7-4B7B-B5B5-D97411D0C283")
    ITfLangBarItemBalloon : public ITfLangBarItem
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnClick( 
            /* [in] */ TfLBIClick click,
            /* [in] */ POINT pt,
            /* [in] */ const RECT *prcArea) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPreferedSize( 
            /* [in] */ const SIZE *pszDefault,
            /* [out] */ SIZE *psz) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBalloonInfo( 
            /* [out] */ TF_LBBALLOONINFO *pInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfLangBarItemBalloonVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfLangBarItemBalloon * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfLangBarItemBalloon * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfLangBarItemBalloon * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInfo )( 
            ITfLangBarItemBalloon * This,
            /* [out] */ TF_LANGBARITEMINFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            ITfLangBarItemBalloon * This,
            /* [out] */ DWORD *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE *Show )( 
            ITfLangBarItemBalloon * This,
            /* [in] */ BOOL fShow);
        
        HRESULT ( STDMETHODCALLTYPE *GetTooltipString )( 
            ITfLangBarItemBalloon * This,
            /* [out] */ BSTR *pbstrToolTip);
        
        HRESULT ( STDMETHODCALLTYPE *OnClick )( 
            ITfLangBarItemBalloon * This,
            /* [in] */ TfLBIClick click,
            /* [in] */ POINT pt,
            /* [in] */ const RECT *prcArea);
        
        HRESULT ( STDMETHODCALLTYPE *GetPreferedSize )( 
            ITfLangBarItemBalloon * This,
            /* [in] */ const SIZE *pszDefault,
            /* [out] */ SIZE *psz);
        
        HRESULT ( STDMETHODCALLTYPE *GetBalloonInfo )( 
            ITfLangBarItemBalloon * This,
            /* [out] */ TF_LBBALLOONINFO *pInfo);
        
        END_INTERFACE
    } ITfLangBarItemBalloonVtbl;

    interface ITfLangBarItemBalloon
    {
        CONST_VTBL struct ITfLangBarItemBalloonVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfLangBarItemBalloon_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfLangBarItemBalloon_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfLangBarItemBalloon_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfLangBarItemBalloon_GetInfo(This,pInfo)	\
    (This)->lpVtbl -> GetInfo(This,pInfo)

#define ITfLangBarItemBalloon_GetStatus(This,pdwStatus)	\
    (This)->lpVtbl -> GetStatus(This,pdwStatus)

#define ITfLangBarItemBalloon_Show(This,fShow)	\
    (This)->lpVtbl -> Show(This,fShow)

#define ITfLangBarItemBalloon_GetTooltipString(This,pbstrToolTip)	\
    (This)->lpVtbl -> GetTooltipString(This,pbstrToolTip)


#define ITfLangBarItemBalloon_OnClick(This,click,pt,prcArea)	\
    (This)->lpVtbl -> OnClick(This,click,pt,prcArea)

#define ITfLangBarItemBalloon_GetPreferedSize(This,pszDefault,psz)	\
    (This)->lpVtbl -> GetPreferedSize(This,pszDefault,psz)

#define ITfLangBarItemBalloon_GetBalloonInfo(This,pInfo)	\
    (This)->lpVtbl -> GetBalloonInfo(This,pInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfLangBarItemBalloon_OnClick_Proxy( 
    ITfLangBarItemBalloon * This,
    /* [in] */ TfLBIClick click,
    /* [in] */ POINT pt,
    /* [in] */ const RECT *prcArea);


void __RPC_STUB ITfLangBarItemBalloon_OnClick_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemBalloon_GetPreferedSize_Proxy( 
    ITfLangBarItemBalloon * This,
    /* [in] */ const SIZE *pszDefault,
    /* [out] */ SIZE *psz);


void __RPC_STUB ITfLangBarItemBalloon_GetPreferedSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLangBarItemBalloon_GetBalloonInfo_Proxy( 
    ITfLangBarItemBalloon * This,
    /* [out] */ TF_LBBALLOONINFO *pInfo);


void __RPC_STUB ITfLangBarItemBalloon_GetBalloonInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfLangBarItemBalloon_INTERFACE_DEFINED__ */


#ifndef __ITfMenu_INTERFACE_DEFINED__
#define __ITfMenu_INTERFACE_DEFINED__

/* interface ITfMenu */
/* [unique][uuid][object] */ 

#define	TF_LBMENUF_CHECKED	( 0x1 )

#define	TF_LBMENUF_SUBMENU	( 0x2 )

#define	TF_LBMENUF_SEPARATOR	( 0x4 )

#define	TF_LBMENUF_RADIOCHECKED	( 0x8 )

#define	TF_LBMENUF_GRAYED	( 0x10 )


EXTERN_C const IID IID_ITfMenu;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6F8A98E4-AAA0-4F15-8C5B-07E0DF0A3DD8")
    ITfMenu : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddMenuItem( 
            /* [in] */ UINT uId,
            /* [in] */ DWORD dwFlags,
            /* [in] */ HBITMAP hbmp,
            /* [in] */ HBITMAP hbmpMask,
            /* [size_is][unique][in] */ const WCHAR *pch,
            /* [in] */ ULONG cch,
            /* [unique][out][in] */ ITfMenu **ppMenu) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfMenuVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfMenu * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfMenu * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfMenu * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddMenuItem )( 
            ITfMenu * This,
            /* [in] */ UINT uId,
            /* [in] */ DWORD dwFlags,
            /* [in] */ HBITMAP hbmp,
            /* [in] */ HBITMAP hbmpMask,
            /* [size_is][unique][in] */ const WCHAR *pch,
            /* [in] */ ULONG cch,
            /* [unique][out][in] */ ITfMenu **ppMenu);
        
        END_INTERFACE
    } ITfMenuVtbl;

    interface ITfMenu
    {
        CONST_VTBL struct ITfMenuVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfMenu_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfMenu_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfMenu_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfMenu_AddMenuItem(This,uId,dwFlags,hbmp,hbmpMask,pch,cch,ppMenu)	\
    (This)->lpVtbl -> AddMenuItem(This,uId,dwFlags,hbmp,hbmpMask,pch,cch,ppMenu)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfMenu_AddMenuItem_Proxy( 
    ITfMenu * This,
    /* [in] */ UINT uId,
    /* [in] */ DWORD dwFlags,
    /* [in] */ HBITMAP hbmp,
    /* [in] */ HBITMAP hbmpMask,
    /* [size_is][unique][in] */ const WCHAR *pch,
    /* [in] */ ULONG cch,
    /* [unique][out][in] */ ITfMenu **ppMenu);


void __RPC_STUB ITfMenu_AddMenuItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfMenu_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_ctfutb_0212 */
/* [local] */ 

#endif // CTFUTB_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_ctfutb_0212_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ctfutb_0212_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HBITMAP_UserSize(     unsigned long *, unsigned long            , HBITMAP * ); 
unsigned char * __RPC_USER  HBITMAP_UserMarshal(  unsigned long *, unsigned char *, HBITMAP * ); 
unsigned char * __RPC_USER  HBITMAP_UserUnmarshal(unsigned long *, unsigned char *, HBITMAP * ); 
void                      __RPC_USER  HBITMAP_UserFree(     unsigned long *, HBITMAP * ); 

unsigned long             __RPC_USER  HICON_UserSize(     unsigned long *, unsigned long            , HICON * ); 
unsigned char * __RPC_USER  HICON_UserMarshal(  unsigned long *, unsigned char *, HICON * ); 
unsigned char * __RPC_USER  HICON_UserUnmarshal(unsigned long *, unsigned char *, HICON * ); 
void                      __RPC_USER  HICON_UserFree(     unsigned long *, HICON * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\cuim.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	CUIM.CPP	-- Cicero Implementation
 *	
 *		Most everything to do with Cicero handling.
 *
 *	Original Author: <nl>
 *		Hon Wah Chan
 *
 *	History: <nl>
 *		11/16/1999  honwch
 *
 *	Copyright (c) 1995-2001, Microsoft Corporation. All rights reserved.
 */
#include "_common.h"

#ifndef NOFEPROCESSING

#ifndef NOPRIVATEMESSAGE
#include "_MSREMSG.H"
#endif	

#include "_array.h"
#include "msctf.h"
#include "textstor.h"
#include "ctffunc.h"

#include "msctf_g.c"
#include "msctf_i.c"
#include "textstor_i.c"
#include "ctffunc_i.c"
#include "msctfp.h"
#include "msctfp_g.c"

#include "textserv.h"
#include "_cmsgflt.h"
#include "_ime.h"

#include "_cuim.h"

const IID IID_ITfContextRenderingMarkup = { 
    0xa305b1c0,
    0xc776,
    0x4523,
    {0xbd, 0xa0, 0x7c, 0x5a, 0x2e, 0x0f, 0xef, 0x10}
};

const IID IID_ITfEnableService = {
	0x3035d250,
	0x43b4,
	0x4253,
	{0x81, 0xe6, 0xea, 0x87, 0xfd, 0x3e, 0xed, 0x43}
};

const IID IID_IServiceProvider = {
	0x6d5140c1,
	0x7436,
	0x11ce,
	{0x80, 0x34, 0x00, 0xaa, 0x00, 0x60, 0x09, 0xfa}
};

// {35D46968-01FF-4cd8-A379-9A87C9CC789F}
const GUID CLSID_MSFTEDIT = {
	0x35d46968,
	0x01ff,
	0x4cd8,
	{0xa3,0x79,0x9a,0x87, 0xc9,0xcc,0x78,0x9f}
};

#define CONNECT_E_NOCONNECTION MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0200)	// from OLECTL.H

#undef DEFINE_GUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    const GUID name \
        = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }

#include "dcattrs.h"

const TS_ATTRID *_arTSAttridSupported[] =
{
	&DCATTRID_Font_FaceName,			// iattrFacename
	&DCATTRID_Font_SizePts,				// iattrSize
	&DCATTRID_Font_Style_Color,			// iattrColor
	&DCATTRID_Font_Style_Bold,			// iattrBold
	&DCATTRID_Font_Style_Italic,		// iattrItalic
	&DCATTRID_Font_Style_Underline,		// iattrUnderline
	&DCATTRID_Font_Style_Subscript,		// iattrSubscript
	&DCATTRID_Font_Style_Superscript,	// iattrSuperscript
	&DCATTRID_Text_RightToLeft,			// iattrRTL
	&DCATTRID_Text_VerticalWriting,		// iattrVertical
	&GUID_PROP_MODEBIAS,				// iattrBias
	&DCATTRID_Text_Orientation,			// iattrTxtOrient
};

enum IATTR_INDEX
{
	iattrFacename = 0,
	iattrSize,
	iattrColor,
	iattrBold,
	iattrItalic,
	iattrUnderline,
	iattrSubscript,
	iattrSuperscript,
	iattrRTL,
	iattrVertical,
	iattrBias,
	iattrTxtOrient,
	MAX_ATTR_SUPPORT
};


/* GUID_NULL */
const GUID GUID_NULL = {
	0x00000000,
	0x0000,
	0x0000,
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	};

const GUID GUID_DCSERVICE_DATAOBJECT = {
	0x6086fbb5, 
	0xe225, 
	0x46ce, 
	{0xa7, 0x70, 0xc1, 0xbb, 0xd3, 0xe0, 0x5d, 0x7b}
};

const GUID GUID_DCSERVICE_ACCESSIBLE = {
	0xf9786200, 
	0xa5bf, 
	0x4a0f, 
	{0x8c, 0x24, 0xfb, 0x16, 0xf5, 0xd1, 0xaa, 0xbb}
};

const GUID GUID_DCSERVICE_ACTIVEX = {
	0xea937a50, 
	0xc9a6, 
	0x4b7d, 
	{0x89, 0x4a, 0x49, 0xd9, 0x9b, 0x78, 0x48, 0x34}
};

// This array need to match the definition for EM_SETCTFMODEBIAS
const GUID *_arModeBiasSupported[] =
{
	&GUID_MODEBIAS_NONE,
	&GUID_MODEBIAS_FILENAME,
	&GUID_MODEBIAS_NAME,
	&GUID_MODEBIAS_READING,
	&GUID_MODEBIAS_DATETIME,
	&GUID_MODEBIAS_CONVERSATION,
	&GUID_MODEBIAS_NUMERIC,
	&GUID_MODEBIAS_HIRAGANA,
	&GUID_MODEBIAS_KATAKANA,
	&GUID_MODEBIAS_HANGUL,
	&GUID_MODEBIAS_HALFWIDTHKATAKANA,
	&GUID_MODEBIAS_FULLWIDTHALPHANUMERIC,
	&GUID_MODEBIAS_HALFWIDTHALPHANUMERIC,
};

/*
 *	CUIM::CUIM ()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 *
 */
CUIM::CUIM(CTextMsgFilter *pTextMsgFilter)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::CUIM");

	_crefs = 1;
	_pTextMsgFilter = pTextMsgFilter;
};

/*
 *	CUIM::~CUIM ()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 *
 */
CUIM::~CUIM()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::~CUIM");

	Uninit();
}

/*
 *	STDMETHODIMP CUIM::QueryInterface (riid, ppv)
 *
 *	@mfunc
 *		IUnknown QueryInterface support
 *
 *	@rdesc
 *		NOERROR if interface supported
 *
 */
STDMETHODIMP CUIM::QueryInterface (REFIID riid, void ** ppv)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::QueryInterface");

	if( IsEqualIID(riid, IID_IUnknown) ||
		IsEqualIID(riid, IID_ITextStoreACP) )
		*ppv = (ITextStoreACP *)this;

    else if(IsEqualIID(riid, IID_ITfContextOwnerCompositionSink) )
		*ppv = (ITfContextOwnerCompositionSink *)this;

	else if (IsEqualIID(riid, IID_ITfMouseTrackerACP))
		*ppv = (ITfMouseTrackerACP *)this;

    else if (IsEqualIID(riid, IID_ITfEnableService))
		*ppv = (ITfEnableService *)this;

    else if (IsEqualIID(riid, IID_IServiceProvider))
		*ppv = (IServiceProvider *)this;

	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	AddRef();

	return NOERROR;
}

/*
 *	STDMETHODIMP_(ULONG) CUIM::AddRef
 *
 *	@mfunc
 *		IUnknown AddRef support
 *
 *	@rdesc
 *		Reference count
 */
STDMETHODIMP_(ULONG) CUIM::AddRef()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::AddRef");

	return ++_crefs;
}

/*
 *	STDMETHODIMP_(ULONG) CUIM::Release()
 *
 *	@mfunc
 *		IUnknown Release support - delete object when reference count is 0
 *
 *	@rdesc
 *		Reference count
 */
STDMETHODIMP_(ULONG) CUIM::Release()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::Release");

	_crefs--;

	if( _crefs == 0 )
	{
		delete this;
		return 0;
	}

	return _crefs;
}

/*
 *	STDMETHODIMP CUIM::AdviseSink()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::AdviseSink(
	REFIID riid, 
	IUnknown *punk, 
	DWORD dwMask)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::AdviseSink");

    HRESULT hr = E_FAIL;

	if (_fShutDown)
		return E_UNEXPECTED;

    Assert(_ptss == NULL);
    
	if(IsEqualIID(riid, IID_ITextStoreACPSink))
		hr = punk->QueryInterface(riid, (void **)&_ptss);

    return hr == S_OK ? S_OK : E_UNEXPECTED;
}

/*
 *	STDMETHODIMP CUIM::UnadviseSink()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::UnadviseSink(IUnknown *punk)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::UnadviseSink");

    Assert(_ptss == punk); // we're dealing with cicero, this should always hold
    _ptss->Release();
	_ptss = NULL;
    return S_OK;
}

/*
 *	STDMETHODIMP CUIM::RequestLock()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::RequestLock(
	DWORD dwLockFlags, 
	HRESULT *phrSession)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::RequestLock");

	if (!phrSession)
		return E_POINTER;

	if (_fShutDown)
	{
		*phrSession = TS_E_SYNCHRONOUS;
		return S_OK;
	}

	Assert(_ptss);

	if (_cCallMgrLevels && !_fAllowUIMLock ||	// Check if we are ready to grant locks
		_fReadLockOn || _fWriteLockOn)			//  We don't allow re-entrance either.
	{
		// No lock allow
		if (dwLockFlags & TS_LF_SYNC)
			*phrSession = TS_E_SYNCHRONOUS;
		else
		{
			if (dwLockFlags & TS_LF_READ)
				_fReadLockPending = 1;
			if ((dwLockFlags & TS_LF_READWRITE) == TS_LF_READWRITE)
				_fWriteLockPending = 1;

			*phrSession = TS_S_ASYNC; 
		}
		return S_OK;
	}

	IUnknown *pIUnknown = NULL;

	HRESULT hResult = _pTextMsgFilter->_pTextDoc->GetCallManager(&pIUnknown);

	if ((dwLockFlags & TS_LF_READWRITE) == TS_LF_READWRITE)
	{
		_fReadLockPending = 0;
		_fWriteLockPending = 0;
		_fReadLockOn = 1;
		_fWriteLockOn = 1;
	}
	else if ((dwLockFlags & TS_LF_READ) == TS_LF_READ)
	{
		_fReadLockPending = 0;
		_fReadLockOn = 1;
	}

	if (_fWriteLockOn)
	{
		if (W32->IsFECodePage(_pTextMsgFilter->_uKeyBoardCodePage))
			_pTextMsgFilter->_pTextDoc->IMEInProgress(tomTrue);
		EnterCriticalSection(&g_CriticalSection);
	}

	*phrSession = _ptss->OnLockGranted(dwLockFlags);

	if (_fWriteLockOn)
	{
		// Check if any text has been added
		if (_parITfEnumRange && _parITfEnumRange->Count())
		{
			int	idx;
			int idxMax = _parITfEnumRange->Count();

			for (idx = 0 ; idx < idxMax; idx++)
			{
				IEnumTfRanges **ppEnumRange = (IEnumTfRanges **)(_parITfEnumRange->Elem(idx));
				if (ppEnumRange && *ppEnumRange)
				{
					HandleFocusRange(*ppEnumRange);
					(*ppEnumRange)->Release();
				}
			}
			_parITfEnumRange->Clear(AF_KEEPMEM);
		}
	}

	if (_fEndTyping)
		OnUIMTypingDone();

	if (_fWriteLockOn)
	{
		_pTextMsgFilter->_pTextDoc->IMEInProgress(tomFalse);
		LeaveCriticalSection(&g_CriticalSection);
	}

	_fEndTyping = 0;
	_fWriteLockOn = 0;
	_fReadLockOn = 0;
	_fHoldCTFSelChangeNotify = 1;

	if (pIUnknown)
		hResult = _pTextMsgFilter->_pTextDoc->ReleaseCallManager(pIUnknown);

	_fHoldCTFSelChangeNotify = 0;

	return S_OK;
}

/*
 *	STDMETHODIMP CUIM::GetStatus()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::GetStatus(
	TS_STATUS *pdcs)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetStatus");

	if (_fShutDown)
		return S_OK;

	if (pdcs)
	{
		LRESULT		lresult = 0;

		pdcs->dwStaticFlags = (TS_SS_REGIONS | TS_SS_NOHIDDENTEXT);

		if ( S_OK == _pTextMsgFilter->_pTextService->TxSendMessage(
			EM_GETDOCFLAGS, GDF_ALL, 0, &lresult))
		{
			if (lresult & GDF_READONLY)
				pdcs->dwDynamicFlags = TS_SD_READONLY;

			// Don't want to support overtyping in Cicero yet.
			//	if (lresult & GDF_OVERTYPE)
			//		dcs.dwDynamicFlags = TS_SD_OVERTYPE;
		}
	}
	return S_OK;
}
/*
 *	STDMETHODIMP CUIM::QueryInsert()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::QueryInsert(
	LONG		acpTestStart,
	LONG		acpTestEnd,
	ULONG		cch,
	LONG		*pacpResultStart,
	LONG		*pacpResultEnd)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::QueryInsert");

	HRESULT hResult;
	ITextRange *pTextRange = NULL;

	*pacpResultStart = -1;
	*pacpResultEnd = -1;

	if (_fShutDown)
		return S_OK;

	hResult = _pTextMsgFilter->_pTextDoc->Range(acpTestStart, acpTestEnd, &pTextRange);

	if (hResult != S_OK)
		return TS_E_READONLY;

	Assert(pTextRange);
	if(pTextRange->CanEdit(NULL) == S_FALSE)
	{
		hResult = TS_E_READONLY;
		goto EXIT;			// Cannot edit text
	}

	*pacpResultStart = acpTestStart;
	*pacpResultEnd = acpTestEnd;
	hResult = S_OK;

EXIT:
	pTextRange->Release();
	return hResult;
}

/*
 *	STDMETHODIMP CUIM::GetSelection()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::GetSelection(
	ULONG ulIndex, 
	ULONG ulCount, 
	TS_SELECTION_ACP *pSelection, 
	ULONG *pcFetched)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetSelection");

	HRESULT hResult;
	ITextSelection	*pTextSel = NULL;

	if (!pSelection || !pcFetched)
		return E_POINTER;

	if (!_fReadLockOn)
		return TS_E_NOLOCK;

	*pcFetched = 0;

	if (_fShutDown)
		return TS_E_NOSELECTION;

	if (ulIndex == TS_DEFAULT_SELECTION)
		ulIndex = 0;
	else if (ulIndex > 1)
		return E_INVALIDARG; // We donnot have discontiguous selection.

	if (_fInterimChar)
	{
		pSelection[0].acpStart = _acpInterimStart;
		pSelection[0].acpEnd = _acpInterimEnd;
		pSelection[0].style.ase = (TsActiveSelEnd) _ase;
		pSelection[0].style.fInterimChar = TRUE;

	    *pcFetched = 1;

		return S_OK;
	}

	hResult = _pTextMsgFilter->_pTextDoc->GetSelectionEx(&pTextSel);

	if (pTextSel)
	{
		long	cpMin = 0, cpMax = 0;
		long	lFlags = 0;
		hResult	= pTextSel->GetStart(&cpMin);
		hResult	= pTextSel->GetEnd(&cpMax);
		hResult = pTextSel->GetFlags(&lFlags);

		pSelection[0].acpStart = cpMin;
		pSelection[0].acpEnd = cpMax;
		pSelection[0].style.ase = (lFlags & tomSelStartActive) ? TS_AE_START : TS_AE_END;
		pSelection[0].style.fInterimChar = FALSE;

	    *pcFetched = 1;
		pTextSel->Release();

		return S_OK;	
	}
	return TS_E_NOSELECTION;
}

/*
 *	STDMETHODIMP CUIM::SetSelection()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::SetSelection(
	ULONG ulCount, 
	const TS_SELECTION_ACP *pSelection)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::SetSelection");

	HRESULT hResult;
	ITextRange *pTextRange = NULL;

	if (!pSelection)
		return E_POINTER;

	if (ulCount <= 0)
		return E_INVALIDARG;

	if (!_fWriteLockOn)
		return TS_E_NOLOCK;

	if (_fShutDown)
		return S_OK;

	if (pSelection->style.fInterimChar)
	{
		_pTextMsgFilter->_pTextDoc->SetCaretType(tomKoreanBlockCaret);	// Set Block caret mode
		_acpInterimStart = pSelection[0].acpStart;
		_acpInterimEnd = pSelection[0].acpEnd;
		_fInterimChar = 1;
		_ase = pSelection[0].style.ase;
	}
	else
	{
		if (_fInterimChar)
		{
			_fInterimChar = 0;
			_pTextMsgFilter->_pTextDoc->SetCaretType(tomNormalCaret);		// Reset Block caret mode
		}

		hResult = _pTextMsgFilter->_pTextDoc->Range(pSelection[0].acpStart, pSelection[0].acpEnd, &pTextRange);

		if (pTextRange)
		{
			long	lCount;
			_pTextMsgFilter->_pTextDoc->Freeze(&lCount);		// Turn off display
			pTextRange->Select();
			pTextRange->Release();
			_pTextMsgFilter->_pTextDoc->Unfreeze(&lCount);		// Turn on display
		}
	}
	return S_OK;
}

/*
 *	STDMETHODIMP CUIM::GetText()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::GetText(
	LONG acpStart, 
	LONG acpEnd, 
	WCHAR *pchPlain, 
	ULONG cchPlainReq, 
	ULONG *pcchPlainOut, 
	TS_RUNINFO *prgRunInfo,
	ULONG ulRunInfoReq, 
	ULONG *pulRunInfoOut, 
	LONG *pacpNext)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetText");

	if (!_fReadLockOn)
		return TS_E_NOLOCK;

	if (pchPlain == NULL && cchPlainReq != 0 ||
		prgRunInfo == NULL && ulRunInfoReq != 0)
		return E_INVALIDARG;

	BOOL	fDoRunInfo = ulRunInfoReq > 0;
	LONG	acpMaxText = 0;
	BOOL	fEOP = FALSE;

	GetStoryLength(&acpMaxText);

	if (acpStart < 0 || acpStart > acpMaxText)
		return TS_E_INVALIDPOS;

	if (acpEnd < 0)
		acpEnd = acpMaxText;
	else if (acpEnd < acpStart)
		return TS_E_INVALIDPOS;

	if (pcchPlainOut)
		*pcchPlainOut = 0;
	if (pulRunInfoOut)
		*pulRunInfoOut = 0;
	if (pacpNext)
		*pacpNext = acpStart;

	if (_fShutDown)
		return S_OK;

	LRESULT		lresult = 0;
	if ( S_OK == _pTextMsgFilter->_pTextService->TxSendMessage(
		EM_GETDOCFLAGS, GDF_ALL, 0, &lresult))
	{
		if ((lresult & GDF_RICHTEXT) && acpEnd == acpMaxText)
			fEOP = TRUE;
	}

	if (cchPlainReq || ulRunInfoReq)
	{
		HRESULT		hResult;
		ITextRange	*pTextRange = NULL;
		long		fHiddenTextInRange = tomFalse;
		BOOL		fCopyData = FALSE;
		long		*pHiddenTxtBlk = NULL;
		long		cHiddenTxtBlk = 0;

		if (cchPlainReq && acpEnd > (long)cchPlainReq + acpStart)
			acpEnd = cchPlainReq + acpStart;

		hResult = _pTextMsgFilter->_pTextDoc->Range(acpStart, acpEnd, &pTextRange);

		if (pTextRange)
		{
			BSTR	bstr = NULL;
			long	cpMin, cpMax;
			ULONG	cch;

			pTextRange->GetStart(&cpMin);
			pTextRange->GetEnd(&cpMax);

			if (fDoRunInfo)
			{
				ITextFont	*pFont = NULL;

				hResult = pTextRange->GetFont(&pFont);

				if (pFont)
				{
					pFont->GetHidden(&fHiddenTextInRange);
					pFont->Release();

					if (fHiddenTextInRange == tomUndefined)		// Some hidden text inside range
						BuildHiddenTxtBlks(cpMin, cpMax, &pHiddenTxtBlk, cHiddenTxtBlk);
				}
			}

			hResult = pTextRange->GetText(&bstr);

			if (bstr)
			{
				cch = cpMax - cpMin;

				if (cchPlainReq)
				{
					if (cchPlainReq > cch)		
						cchPlainReq = cch;
					
					fCopyData = TRUE;
				}
				else
					cchPlainReq = cch;

				// Convert character into special Cicero char.
				long	cpCurrentStart = cpMin;
				long	cpCurrent = cpMin;
				long	idx = 0;
				ULONG	cRunInfo = 0;
				BOOL	fRunInfoNotEnough = FALSE;

				long cpNextHiddenText = tomForward;

				if (fDoRunInfo && pHiddenTxtBlk)
					cpNextHiddenText = pHiddenTxtBlk[0];

				if (fHiddenTextInRange != tomTrue)
				{
					WCHAR *pText = (WCHAR *)bstr;
					while (cpCurrent < cpMax)
					{
						if (cpCurrent == cpNextHiddenText)
						{
							// setup run info for current good text
							if (cpCurrent != cpCurrentStart)
							{
								if (cRunInfo >= ulRunInfoReq)
								{
									fRunInfoNotEnough = TRUE;
									break;
								}
								prgRunInfo[cRunInfo].uCount = cpCurrent - cpCurrentStart;
								prgRunInfo[cRunInfo].type = TS_RT_PLAIN;
								cRunInfo++;
							}

							long cchHiddenText = pHiddenTxtBlk[idx+1];

							// setup run info for hidden text block
							if (cRunInfo >= ulRunInfoReq)
							{
								fRunInfoNotEnough = TRUE;
								break;
							}
							prgRunInfo[cRunInfo].uCount = cchHiddenText;
							prgRunInfo[cRunInfo].type = TS_RT_OPAQUE;
							cRunInfo++;

							idx += 2;
							if (idx < cHiddenTxtBlk)
								cpNextHiddenText = pHiddenTxtBlk[idx];
							else
								cpNextHiddenText = tomForward;

							cpCurrent += cchHiddenText;
							pText += cchHiddenText;
							cpCurrentStart = cpCurrent;
						}
						else
						{
							switch (*pText)
							{
								case WCH_EMBEDDING:
									*pText = TS_CHAR_EMBEDDED;
									break;

								case STARTFIELD:
								case ENDFIELD:
									*pText = TS_CHAR_REGION;
									if (cpCurrent + 1 < cpMax)
									{
										pText++;
										cpCurrent++;
										Assert(*pText == 0x000d);
										*pText = TS_CHAR_REGION;
									}
									break;
							}
							cpCurrent++;
							// Convert EOP into TS_CHAR_REGION
							if (fEOP && cpCurrent == acpMaxText && *pText == CR)
								*pText = TS_CHAR_REGION;
							pText++;
						}
					}
				}

				if (fDoRunInfo)
				{
					// setup run info for last chunk of good text
					if (cpCurrent != cpCurrentStart && cRunInfo < ulRunInfoReq)
					{
						prgRunInfo[cRunInfo].uCount = cpCurrent - cpCurrentStart;
						prgRunInfo[cRunInfo].type = TS_RT_PLAIN;
						cRunInfo++;
					}

					if (pulRunInfoOut)
						*pulRunInfoOut = cRunInfo ? cRunInfo : 1;

					// All the text belong to the same run
					if (cRunInfo == 0)
					{
						prgRunInfo[0].uCount = cchPlainReq;
						prgRunInfo[0].type = (fHiddenTextInRange == tomTrue) ? TS_RT_OPAQUE : TS_RT_PLAIN;
					}
				}

				if (fRunInfoNotEnough)
				{
					// Runinfo too small. need to add cch from all valid runs
					TS_RUNINFO	*prgRunInfoData = prgRunInfo;
					ULONG	idx;
					cchPlainReq = 0;
					for (idx=0; idx < cRunInfo; idx++)
					{
						cchPlainReq += prgRunInfoData->uCount;
						prgRunInfoData++;
					}
				}

				if (fCopyData)
					// fill in the buffer
					memcpy(pchPlain, (LPSTR)bstr, cchPlainReq * sizeof(WCHAR));

				if (pcchPlainOut)
					*pcchPlainOut = cchPlainReq;

				if (pacpNext)
					*pacpNext = cpMin + cchPlainReq;

				SysFreeString(bstr);
			}

			pTextRange->Release();

			FreePv(pHiddenTxtBlk);
		}
	}

	return S_OK;
}

/*
 *	STDMETHODIMP CUIM::SetText()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::SetText(
	DWORD dwFlags,
	LONG acpStart, 
	LONG acpEnd, 
	const WCHAR *pchText, 
	ULONG cch, 
	TS_TEXTCHANGE *pChange)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::SetText");

	return InsertData(dwFlags, acpStart, acpEnd, pchText, cch, NULL, pChange);
}

/*
 *	STDMETHODIMP CUIM::InsertData()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::InsertData(
	DWORD			dwFlags,
	LONG			acpStart,
	LONG			acpEnd,
	const WCHAR		*pchText,
	ULONG			cch,
	IDataObject		*pDataObject,
	TS_TEXTCHANGE	*pChange)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::InsertData");

	HRESULT		hResult = S_OK;
	ITextRange	*pTextRange = NULL;
	BOOL		fInsertObject = pDataObject != NULL;

	if (!_fWriteLockOn)
		return TS_E_NOLOCK;

	if (_fShutDown)
		return S_OK;

	hResult = _pTextMsgFilter->_pTextDoc->Range(acpStart, acpEnd, &pTextRange);

	if (pTextRange)
	{
		BSTR	bstr = NULL;

		if(pTextRange->CanEdit(NULL) == S_FALSE)
		{
			pTextRange->Release();
			return TS_E_READONLY;			// Cannot edit text
		}

		LONG	cchExced = 0;
		BOOL	fDelSelection = FALSE;
		if ((LONG)cch > (acpEnd - acpStart) &&
			_pTextMsgFilter->_pTextDoc->CheckTextLimit((LONG)cch - (acpEnd-acpStart), &cchExced) == NOERROR &&
				cchExced > 0)
		{
			// We reach text limit, beep and exit
			_pTextMsgFilter->_pTextDoc->SysBeep();
			pTextRange->Release();
			return E_FAIL;
		}

		if (!fInsertObject)
		{
			bstr = SysAllocStringLen(pchText, cch);

			if (!bstr)
			{
				pTextRange->Release();
				return E_OUTOFMEMORY;
			}
		}

		if (!_fAnyWriteOperation)
		{
			// Start the UIM typing
			ITextFont	*pCurrentFont = NULL;
			BOOL		fRestFont = TRUE;
			_fAnyWriteOperation = 1;
			
			hResult	= pTextRange->GetStart(&_cpMin);

			// Hold notification if needed
			if (!(_pTextMsgFilter->_fIMEAlwaysNotify))
				_pTextMsgFilter->_pTextDoc->SetNotificationMode(tomFalse);

			if (!_bstrComposition)
			{
				if (fRestFont && _pTextFont)
				{
					_pTextFont->Release();
					_pTextFont = NULL;
				}

				if (acpStart != acpEnd)
				{
					if (_pTextFont == NULL)
					{
						ITextRange *pRange = NULL;
						// Get font at cpStart+1
						hResult = _pTextMsgFilter->_pTextDoc->Range(acpStart, acpStart+1, &pRange);
						if (pRange)
						{
							hResult = pRange->GetFont(&pCurrentFont);

							if (pCurrentFont)
							{
								hResult = pCurrentFont->GetDuplicate(&_pTextFont);
								pCurrentFont->Release();
								pCurrentFont = NULL;
							}
							pRange->Release();
						}
					}

					// if any current selection, turn on Undo to delete it....
					_pTextMsgFilter->_pTextDoc->Undo(tomResume, NULL);
					pTextRange->SetText(NULL);
					_pTextMsgFilter->_pTextDoc->Undo(tomSuspend, NULL);
					fDelSelection = TRUE;
				}
				else
				{
					ITextSelection	*pTextSel = NULL;
					hResult = _pTextMsgFilter->_pTextDoc->GetSelectionEx(&pTextSel);
					if (pTextSel)
					{
						long	cpMin = 0;
						hResult	= pTextSel->GetStart(&cpMin);

						if (hResult == S_OK && cpMin == acpStart)
							hResult = pTextSel->GetFont(&pCurrentFont);

						if (!pCurrentFont)
							hResult = pTextRange->GetFont(&pCurrentFont);

						if (pCurrentFont)
						{
							hResult = pCurrentFont->GetDuplicate(&_pTextFont);
							pCurrentFont->Release();
							pCurrentFont = NULL;
						}

						pTextSel->Release();
					}
				}
			}
			Assert (_pTextFont);
			if (_pTextFont)
			{
				long cpMin;
				pTextRange->GetStart(&cpMin);
				_pTextMsgFilter->_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);
				CIme::CheckKeyboardFontMatching(cpMin, _pTextMsgFilter, _pTextFont);
			}
		}

		if (fInsertObject)
		{
			LRESULT		lresult;
			CHARRANGE	charRange = {acpStart, acpEnd};

			if (fDelSelection)
				charRange.cpMost = acpStart;

			hResult = _pTextMsgFilter->_pTextService->TxSendMessage(EM_INSERTOBJ, (WPARAM)&charRange,
				(LPARAM)pDataObject, &lresult);

			if (hResult == NOERROR && pChange)
			{
				pChange->acpStart = acpStart;
				pChange->acpOldEnd = acpEnd;
				pChange->acpNewEnd = acpStart+1;
			}
		}
		else
		{
			long	lCount;
			long	cpMin, cpMax;
			_pTextMsgFilter->_pTextDoc->Freeze(&lCount);		// Turn off display
			hResult = pTextRange->SetText(bstr);
			_pTextMsgFilter->_pTextDoc->Unfreeze(&lCount);		// Turn on display

			pTextRange->GetStart(&cpMin);
			pTextRange->GetEnd(&cpMax);

			if (_pTextFont)
				pTextRange->SetFont(_pTextFont);

			POINT	ptBottomPos;

			if (_pTextMsgFilter->_uKeyBoardCodePage == CP_KOREAN)
			{
				if (pTextRange->GetPoint( tomEnd+TA_BOTTOM+TA_LEFT,
					&(ptBottomPos.x), &(ptBottomPos.y) ) != NOERROR)
					pTextRange->ScrollIntoView(tomEnd);
			}

			SysFreeString(bstr);

			// out params
			pChange->acpStart = cpMin;
			pChange->acpOldEnd = acpEnd;
			pChange->acpNewEnd = cpMax;	

			hResult = S_OK;
		}
		pTextRange->Release();
	}
	return hResult;
}

/*
 *	STDMETHODIMP CUIM::GetFormattedText()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::GetFormattedText(
	LONG acpStart, 
	LONG acpEnd, 
	IDataObject **ppDataObject)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetFormattedText");

	return E_NOTIMPL;
}

/*
 *	STDMETHODIMP CUIM::GetEmbedded()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::GetEmbedded(
	LONG acpPos, 
	REFGUID rguidService, 
	REFIID riid, 
	IUnknown **ppunk)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetEmbedded");

	WORD	wServiceRequested = 0;

	if (!_fReadLockOn)
		return TS_E_NOLOCK;

	if (!ppunk)
		return E_INVALIDARG;

	if (IsEqualIID(rguidService, GUID_DCSERVICE_ACTIVEX))
		wServiceRequested = 1;
	else if (IsEqualIID(rguidService, GUID_DCSERVICE_DATAOBJECT))
		wServiceRequested = 2;
	else
		return E_INVALIDARG;

	ITextRange	*pTextRange = NULL;
	IUnknown	*pIUnk = NULL;
	HRESULT		hResult = _pTextMsgFilter->_pTextDoc->Range(acpPos, acpPos+1, &pTextRange);

	if (SUCCEEDED(hResult) && pTextRange)
	{
		hResult = pTextRange->GetEmbeddedObject(&pIUnk);
		
		if (SUCCEEDED(hResult) && pIUnk)
			hResult = pIUnk->QueryInterface(wServiceRequested == 1 ? riid : IID_IDataObject, 
				(LPVOID FAR *)ppunk);
		else
			hResult = E_FAIL;

		if (pIUnk)
			pIUnk->Release();

		pTextRange->Release();
	}

	return hResult;
}

/*
 *	STDMETHODIMP CUIM::InsertEmbedded()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::InsertEmbedded(
	DWORD dwFlags, 
	LONG acpStart, 
	LONG acpEnd, 
	IDataObject *pDataObject, 
	TS_TEXTCHANGE *pChange)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::InsertEmbedded");

	if (!pDataObject)
		return E_INVALIDARG;

	if (_pTextMsgFilter->_fAllowEmbedded == 0)
		return TS_E_FORMAT;			// Client doesn't want insert embedded

	return InsertData(dwFlags, acpStart, acpEnd, NULL, 1, pDataObject, pChange);
}

/*
 *	STDMETHODIMP CUIM::RequestSupportedAttrs()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::RequestSupportedAttrs(
	DWORD dwFlags, 
	ULONG cFilterAttrs, 
	const TS_ATTRID *paFilterAttrs)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::RequestSupportedAttrs");

	if (_fShutDown)
		return E_NOTIMPL;

	return GetAttrs(0, cFilterAttrs, paFilterAttrs, TRUE);
}

/*
 *	STDMETHODIMP CUIM::RequestAttrsAtPosition()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::RequestAttrsAtPosition(
	LONG acpPos, 
	ULONG cFilterAttrs, 
	const TS_ATTRID *paFilterAttrs, 
	DWORD dwFlags)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::RequestAttrsAtPosition");

	if (_fShutDown)
		return E_NOTIMPL;

	return GetAttrs(acpPos, cFilterAttrs, paFilterAttrs, FALSE);
}

/*
 *	STDMETHODIMP CUIM::RequestAttrsTransitioningAtPosition()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::RequestAttrsTransitioningAtPosition(
	LONG acpPos, 
	ULONG cFilterAttrs, 
	const TS_ATTRID *paFilterAttrs, 
	DWORD dwFlags)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::RequestAttrsTransitioningAtPosition");

	return E_NOTIMPL;
}

/*
 *	STDMETHODIMP CUIM::FindNextAttrTransition()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::FindNextAttrTransition(
	LONG acpStart, 
	LONG acpHalt, 
	ULONG cFilterAttrs, 
	const TS_ATTRID *paFilterAttrs,		
	DWORD dwFlags, 
	LONG *pacpNext,
	BOOL *pfFound,
	LONG *plFoundOffset)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::FindNextAttrTransition");

	return E_NOTIMPL;
}

/*
 *	STDMETHODIMP CUIM::RetrieveRequestedAttrs()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::RetrieveRequestedAttrs(
	ULONG ulCount, 
	TS_ATTRVAL *paAttrVals, 
	ULONG *pcFetched)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::RetrieveRequestedAttrs");

	if (!pcFetched)
		return E_INVALIDARG;

	if (_fShutDown)
		return E_NOTIMPL;

	*pcFetched = 0;

	if (_parAttrsVal && _uAttrsValCurrent < _uAttrsValTotal)
	{
		ULONG cFetched = min(ulCount, _uAttrsValTotal - _uAttrsValCurrent);

		if (cFetched)
		{
			memcpy(paAttrVals, &_parAttrsVal[_uAttrsValCurrent], cFetched * sizeof(TS_ATTRVAL));
			memset(&_parAttrsVal[_uAttrsValCurrent], 0, cFetched * sizeof(TS_ATTRVAL));
			_uAttrsValCurrent += cFetched;
			*pcFetched = cFetched;

			// If everything is fetched, clean up
			if (_uAttrsValCurrent == _uAttrsValTotal)
				InitAttrVarArray();
		}
	}

	return S_OK;
}

/*
 *	STDMETHODIMP CUIM::GetEndACP()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::GetEndACP(LONG *pacp)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetEndACP");

	if (!_fReadLockOn)
		return TS_E_NOLOCK;

	if (!pacp)
		return E_INVALIDARG;

	if (_fShutDown)
		return E_NOTIMPL;

	return GetStoryLength(pacp);
}

/*
 *	STDMETHODIMP CUIM::GetActiveView()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::GetActiveView(TsViewCookie *pvcView)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetActiveView");

	if (!pvcView)
		return E_INVALIDARG;

	*pvcView = 0;
	return S_OK;
}

/*
 *	STDMETHODIMP CUIM::GetACPFromPoint()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::GetACPFromPoint(
	TsViewCookie vcView,
	const POINT *pt, 
	DWORD dwFlags, 
	LONG *pacp)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetACPFromPoint");

	if (!pt || !pacp)
		return E_POINTER;

	if (_fShutDown)
		return E_NOTIMPL;

	ITextRange	*pTextRange = NULL;

	HRESULT hResult = _pTextMsgFilter->_pTextDoc->RangeFromPoint(pt->x, pt->y, &pTextRange);

	if (hResult == S_OK && pTextRange)
		hResult = pTextRange->GetStart(pacp);

	if (pTextRange)
		pTextRange->Release();

	return hResult;
}

/*
 *	STDMETHODIMP CUIM::GetTextExt()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::GetTextExt(
	TsViewCookie vcView,
	LONG acpStart, 
	LONG acpEnd, 
	RECT *prc, 
	BOOL *pfClipped)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetTextExt");

	if (!prc)
		return E_POINTER;

	if (_fShutDown)
		return E_NOTIMPL;

	if (pfClipped)
		*pfClipped = TRUE;

	ITextRange	*pTextRange = NULL;

	HRESULT hResult = _pTextMsgFilter->_pTextDoc->Range(acpStart, acpEnd, &pTextRange);

	if (hResult == S_OK && pTextRange)
	{
		BOOL fClipped = FALSE;

		POINT ptStart, ptEnd;
		hResult = pTextRange->GetPoint( tomStart+TA_TOP+TA_LEFT,
				&(ptStart.x), &(ptStart.y) );	
		
		if (hResult != S_OK)
		{
			hResult = pTextRange->GetPoint( tomStart+TA_TOP+TA_LEFT+tomAllowOffClient,
				&(ptStart.x), &(ptStart.y) );
			fClipped = TRUE;
		}

		if (hResult == S_OK)
		{
			hResult = pTextRange->GetPoint( acpStart == acpEnd ? tomStart+TA_BOTTOM+TA_LEFT : 
				tomEnd+TA_BOTTOM+TA_LEFT,
				&(ptEnd.x), &(ptEnd.y) );

			if (hResult != S_OK)
			{
				hResult = pTextRange->GetPoint( acpStart == acpEnd ? tomStart+TA_BOTTOM+TA_LEFT+tomAllowOffClient : 
					tomEnd+TA_BOTTOM+TA_LEFT+tomAllowOffClient,
					&(ptEnd.x), &(ptEnd.y) );
				fClipped = TRUE;
			}

			if (hResult == S_OK)
			{
				prc->left	= ptStart.x;
				prc->top	= ptStart.y;
				prc->right	= ptEnd.x;
				prc->bottom = ptEnd.y;
				if (pfClipped)
					*pfClipped = fClipped;
			}
		}
	}

	if (pTextRange)
		pTextRange->Release();

	return hResult;
}

/*
 *	STDMETHODIMP CUIM::GetScreenExt()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::GetScreenExt(
	TsViewCookie vcView,
	RECT *prc)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetScreenExt");

	if (!prc)
		return E_POINTER;

	return _pTextMsgFilter->_pTextDoc->GetClientRect(tomIncludeInset,
		&(prc->left), &(prc->top), &(prc->right), &(prc->bottom));

}

/*
 *	STDMETHODIMP CUIM::GetWnd()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::GetWnd(
	TsViewCookie vcView,
	HWND *phwnd)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetWnd");

	if (!phwnd)
		return E_INVALIDARG;

	if (_fShutDown)
		return E_NOTIMPL;

	*phwnd = _pTextMsgFilter->_hwnd;
	if (!*phwnd)								// Windowless mode...
	{
		long	hWnd;
		
		if (_pTextMsgFilter->_pTextDoc->GetWindow(&hWnd) != S_OK || !hWnd)
			return E_NOTIMPL;	

		*phwnd = (HWND)(DWORD_PTR)hWnd;
	}

	return S_OK;
}

/*
 *	STDMETHODIMP CUIM::QueryInsertEmbedded()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::QueryInsertEmbedded(
	const GUID *pguidService, 
	const FORMATETC *pFormatEtc, 
	BOOL *pfInsertable)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::QueryInsertEmbedded");
	if (!pfInsertable)
		return E_INVALIDARG;

	// Check setting if client wants to support embedded
	*pfInsertable = _pTextMsgFilter->_fAllowEmbedded ? TRUE : FALSE;
	return S_OK; 
}

/*
 *	STDMETHODIMP CUIM::InsertTextAtSelection()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::InsertTextAtSelection(
	DWORD dwFlags,
	const WCHAR *pchText,
	ULONG cch,
	LONG *pacpStart,
	LONG *pacpEnd,
	TS_TEXTCHANGE *pChange)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::InsertTextAtSelection");

	TS_SELECTION_ACP	acpSelection;
	ULONG				cFetched;
    LONG				acpResultStart;
    LONG				acpResultEnd;
	HRESULT				hr;

	if (_fShutDown)
		return E_NOTIMPL;

	if ((dwFlags & TS_IAS_QUERYONLY) || !(dwFlags & TS_IAS_NOQUERY))
	{
		if (!pacpStart || !pacpEnd)
			return E_POINTER;
	}

	hr = GetSelection(TS_DEFAULT_SELECTION, 1, &acpSelection, &cFetched);
	if (hr != S_OK)
		return hr;

	hr = QueryInsert(acpSelection.acpStart, acpSelection.acpEnd, cch,
		&acpResultStart, &acpResultEnd);

	if (hr != S_OK)
		return hr;

	if (dwFlags & TS_IAS_QUERYONLY)
    {
		// Query only, return data
        *pacpStart = acpResultStart;
        *pacpEnd = acpResultEnd;
        return S_OK;
    }

	if (!_fUIMTyping)
	{
		// special case where no OnStartComposition before this call
		_fInsertTextAtSel = 1;
		_pTextMsgFilter->_pTextDoc->Undo(tomSuspend, NULL);		// turn off undo
	}

	hr = SetText(0, acpResultStart, acpResultEnd, pchText, cch, pChange);

	if (hr != S_OK)
	{
		if (!_fUIMTyping)
		{
			// SetText fail, reset state before exit
			_fInsertTextAtSel = 0;
			_pTextMsgFilter->_pTextDoc->Undo(tomResume, NULL);		// turn on undo
		}
		return hr;
	}

	if (!(dwFlags & TS_IAS_NOQUERY) && pChange)
	{
		*pacpStart = pChange->acpStart;
		*pacpEnd = pChange->acpNewEnd;
	}

	return S_OK;
}

/*
 *	STDMETHODIMP CUIM::InsertEmbeddedAtSelection()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::InsertEmbeddedAtSelection(
	DWORD dwFlags,
	IDataObject *pDataObject,
	LONG *pacpStart,
	LONG *pacpEnd,
	TS_TEXTCHANGE *pChange)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::InsertEmbeddedAtSelection");
	return E_NOTIMPL; 
}

/*
 *	void CUIM::OnPreReplaceRange()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
void CUIM::OnPreReplaceRange( 
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::OnPreReplaceRange");

	return;
};

/*
 *	void CUIM::OnPostReplaceRange()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
void CUIM::OnPostReplaceRange( 
	LONG		cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG		cchDel,			//@parm Count of chars after cp that are deleted
	LONG		cchNew,			//@parm Count of chars inserted after cp
	LONG		cpFormatMin,	//@parm cpMin  for a formatting change
	LONG		cpFormatMax,	//@parm cpMost for a formatting change
	NOTIFY_DATA *pNotifyData)	//@parm special data to indicate changes
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::OnPostReplaceRange");

	if (_fShutDown)
		return;

	if (cp != CONVERT_TO_PLAIN && cp != CP_INFINITE	&& _ptss && !_fWriteLockOn)
	{
		// Forward change notification to UIM
		TS_TEXTCHANGE	tsTxtChange;
		tsTxtChange.acpStart = cp;

		if (cchDel == cchNew)
		{
			// text modified
			tsTxtChange.acpNewEnd =
				tsTxtChange.acpOldEnd = cp + cchDel;		
			_ptss->OnTextChange(0, &tsTxtChange);
		}
		else
		{
			if (cchDel)
			{
				// text deleted
				tsTxtChange.acpNewEnd = cp;
				tsTxtChange.acpOldEnd = cp + cchDel;		
				_ptss->OnTextChange(0, &tsTxtChange);
			}

			if (cchNew)
			{
				// text added
				tsTxtChange.acpOldEnd = cp;
				tsTxtChange.acpNewEnd = cp + cchNew;
				_ptss->OnTextChange(0, &tsTxtChange);
			}
		}
	}
	return;
};

/*
 *	void CUIM::Zombie()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
void CUIM::Zombie() 
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::Zombie");

	return;
};

/*
 *	STDMETHODIMP CUIM::OnStartComposition()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDAPI CUIM::OnStartComposition(
	ITfCompositionView *pComposition,
	BOOL *pfOk)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::OnStartComposition");
	if (_fUIMTyping)
		*pfOk = FALSE;
	else
	{
		BOOL fInsertTextCalled = _fInsertTextAtSel;
		BOOL fRetainFont = _fEndTyping;

		*pfOk = TRUE;
		_fUIMTyping = 1;
		_fAnyWriteOperation = _fAnyWriteOperation && (_fEndTyping || fInsertTextCalled);
		_fEndTyping = 0;
		_fInsertTextAtSel = 0;
		if (!fInsertTextCalled)
			_pTextMsgFilter->_pTextDoc->Undo(tomSuspend, NULL);		// turn off undo
		_cchComposition = 0;
		_acpFocusRange = tomForward;
		_cchFocusRange = 0;

		CleanUpComposition();

		if (!fInsertTextCalled && pComposition)
		{
			HRESULT		hr;
			ITfRange	*pRangeNew = NULL;

			hr = pComposition->GetRange(&pRangeNew);

			if (pRangeNew)
			{
				LONG	acpStart;
				LONG	cchStart;

				GetExtentAcpPrange(pRangeNew, acpStart, cchStart);
				pRangeNew->Release();

				if (cchStart > 0)
				{
					// Save the original text
					ITextRange	*pTextRange = NULL;
					ITextFont	*pCurrentFont = NULL;
					HRESULT	hResult = _pTextMsgFilter->_pTextDoc->Range(acpStart, acpStart+cchStart, &pTextRange);

					if (!fRetainFont && _pTextFont)
					{
						_pTextFont->Release();
						_pTextFont = NULL;
					}

					if (pTextRange)
					{
						if (fRetainFont && _acpPreFocusRangeLast <= acpStart
							&& (acpStart + cchStart) <= (_acpPreFocusRangeLast + _cchFocusRangeLast))
						{
							// Cont'u from previous composition
							_acpFocusRange = _acpPreFocusRangeLast;
							_cchFocusRange = _cchFocusRangeLast;
						}
						else
						{
							hResult = pTextRange->GetText(&_bstrComposition);
							Assert(!_pObjects);
							_cObjects = BuildObject(pTextRange, _bstrComposition, &_pObjects, 0);
							_acpBstrStart = acpStart;
							_cchComposition = cchStart;
							GetEndACP(&_cpEnd);
						}

						if (!_pTextFont)
						{
							hResult = pTextRange->Collapse(tomTrue);
							hResult = pTextRange->Move(1, tomCharacter, NULL); 
							hResult = pTextRange->GetFont(&pCurrentFont);
							if (pCurrentFont)
							{
								hResult = pCurrentFont->GetDuplicate(&_pTextFont);
								pCurrentFont->Release();

								if (_pTextFont)
								{
									long cpMin;
									pTextRange->GetStart(&cpMin);
									_pTextMsgFilter->_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);
									CIme::CheckKeyboardFontMatching(cpMin, _pTextMsgFilter, _pTextFont);
								}
							}
						}
						pTextRange->Release();
					}
				}
			}
		}
	}

	return S_OK;
}

/*
 *	STDMETHODIMP CUIM::OnUpdateComposition()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDAPI CUIM::OnUpdateComposition(
	ITfCompositionView *pComposition,
	ITfRange *pRangeNew)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::OnUpdateComposition");

	LONG	acpStart;
	LONG	cchStart;

	if (pRangeNew)
	{
		GetExtentAcpPrange(pRangeNew, acpStart, cchStart);

		if (_bstrComposition)
		{
			long	cpEnd;

			GetEndACP(&cpEnd);

			long	cpCurrentCompEnd = _acpBstrStart + _cchComposition + cpEnd - _cpEnd;
			long	cchExtendAfter = acpStart + cchStart - cpCurrentCompEnd;

			if (_acpBstrStart > acpStart)
			{
				LONG	cchExtendBefore = _acpBstrStart - acpStart;
				ITextRange	*pTextRange = NULL;
				HRESULT	hResult = _pTextMsgFilter->_pTextDoc->Range(acpStart, 
					acpStart+cchExtendBefore, &pTextRange);

				if (pTextRange)
				{
					BSTR	bstrExtendBefore = NULL;
					hResult = pTextRange->GetText(&bstrExtendBefore);

					if (bstrExtendBefore)
					{
						BSTR	bstrNew = SysAllocStringLen(NULL, _cchComposition+cchExtendBefore+1);

						if (bstrNew)
						{
							WCHAR	*pNewText = (WCHAR *)bstrNew;
							WCHAR	*pText = (WCHAR *)bstrExtendBefore;

							memcpy(pNewText, pText, cchExtendBefore * sizeof(WCHAR));

							pNewText += cchExtendBefore;
							pText = (WCHAR *)_bstrComposition;
							memcpy(pNewText, pText, _cchComposition * sizeof(WCHAR));
							*(pNewText+_cchComposition) = L'\0';

							SysFreeString(_bstrComposition);
							_bstrComposition = bstrNew;
							_cchComposition += cchExtendBefore;
							_acpBstrStart = acpStart;
						}
						SysFreeString(bstrExtendBefore);
					}
					pTextRange->Release();
				}
			}

			if (cchExtendAfter > 0)
			{
				// Extend beyond current composition, append new text to the original text
				ITextRange	*pTextRange = NULL;
				HRESULT	hResult = _pTextMsgFilter->_pTextDoc->Range(cpCurrentCompEnd, 
					cpCurrentCompEnd+cchExtendAfter, &pTextRange);

				if (pTextRange)
				{
					BSTR	bstrExtend = NULL;

					hResult = pTextRange->GetText(&bstrExtend);

					if (bstrExtend)
					{
						BSTR	bstrNew = SysAllocStringLen(NULL, _cchComposition+cchExtendAfter+1);

						if (bstrNew)
						{
							WCHAR	*pNewText = (WCHAR *)bstrNew;
							WCHAR	*pText = (WCHAR *)_bstrComposition;

							memcpy(pNewText, pText, _cchComposition * sizeof(WCHAR));

							pNewText += _cchComposition;
							pText = (WCHAR *)bstrExtend;
							memcpy(pNewText, pText, cchExtendAfter * sizeof(WCHAR));
							*(pNewText+cchExtendAfter) = L'\0';

							SysFreeString(_bstrComposition);
							_bstrComposition = bstrNew;
							_cchComposition += cchExtendAfter;
						}
						SysFreeString(bstrExtend);
					}
					pTextRange->Release();
				}
			}
		}
	}

	if (pComposition)
	{
		HRESULT		hr;
		ITfRange	*pRangeComp = NULL;

		hr = pComposition->GetRange(&pRangeComp);

		if (pRangeComp)
		{
			GetExtentAcpPrange(pRangeComp, _acpFocusRange, _cchFocusRange);
			pRangeComp->Release();
		}
	}

	return S_OK;
}

/*
 *	STDMETHODIMP CUIM::OnEndComposition()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDAPI CUIM::OnEndComposition(
	ITfCompositionView *pComposition)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::OnEndComposition");
	_fUIMTyping = 0;
	_fEndTyping = 1;
	_acpPreFocusRangeLast = _acpFocusRange;
	_cchFocusRangeLast = _cchFocusRange;
	_acpFocusRange = tomForward;
	_cchFocusRange = 0;

	return S_OK;
}

/*
 *	STDMETHODIMP CUIM::AdviseMouseSink()
 *
 *	@mfunc
 *		Setup Mouse Sink to handle mouse operation
 *
 *	@rdesc
 *		S_OK is mouse trap is added to link list
 *		CONNECT_E_NOCONNECTION is not added.
 */
STDAPI CUIM::AdviseMouseSink(
	ITfRangeACP *pRangeACP,
	ITfMouseSink *pSinkInput,
	DWORD *pdwCookie)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::AdviseMouseSink");

	if (_fShutDown)
		return CONNECT_E_NOCONNECTION;

	if (!pRangeACP || !pSinkInput || !pdwCookie)
		return E_POINTER;

	CTFMOUSETRAP	*pSinkNew = NULL;
	LONG			cpMouseStart, cchMosueComp;
	ITfMouseSink	*pSinkMouseInput = NULL;

	if (FAILED(pSinkInput->QueryInterface(IID_ITfMouseSink, (void **)&pSinkMouseInput)))
        return E_FAIL;

	if (GetExtentAcpPrange(pRangeACP, cpMouseStart, cchMosueComp))
	{
		if (!_pSinkList)						// No first link
		{
			_pSinkList = new CTFMOUSETRAP;
			pSinkNew = _pSinkList;
		}
		else
		{
			if (!(_pSinkList->pMouseSink))		// The first link is empty
				pSinkNew = _pSinkList;
			else
			{
				pSinkNew = new CTFMOUSETRAP;

				if (pSinkNew)					// Add new trap to the bottom of list
				{
					CTFMOUSETRAP	*pSink = _pSinkList;

					while (pSink->pNext)		// Find the bottom of list
						pSink = pSink->pNext;

					pSink->pNext = pSinkNew;
				}
			}
		}

		if (pSinkNew)
		{
			pSinkNew->dwCookie = *pdwCookie = (DWORD)(DWORD_PTR)pSinkMouseInput;
			pSinkNew->cpMouseStart = cpMouseStart;
			pSinkNew->cchMosueComp = cchMosueComp;
			pSinkNew->pMouseSink = pSinkMouseInput;

			_fMosueSink = 1;

			return S_OK;
		}
	}

	if (pSinkMouseInput)
		pSinkMouseInput->Release();

	return CONNECT_E_NOCONNECTION;
}

/*
 *	STDMETHODIMP CUIM::UnadviseMouseSink()
 *
 *	@mfunc
 *		Remove Mouse Sink
 *
 *	@rdesc
 *
 */
STDAPI CUIM::UnadviseMouseSink(
	DWORD	dwCookie)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::UnadviseMouseSink");

	if (_fShutDown)
		return CONNECT_E_NOCONNECTION;

	if (_fMosueSink == 0)
		return	CONNECT_E_NOCONNECTION;

	Assert(_pSinkList);

	CTFMOUSETRAP	*pSink = _pSinkList;
	CTFMOUSETRAP	*pSinkParent = NULL;

	while (pSink->dwCookie != dwCookie)		// Find the cookie
	{
		pSinkParent = pSink;
		pSink = pSink->pNext;

		if (!pSink)							// Reach list bottom?
			return CONNECT_E_NOCONNECTION;	//	cookie not found
	}
	
	Assert(pSink->pMouseSink);
	if (pSink->pMouseSink)
		pSink->pMouseSink->Release();

	if (pSink == _pSinkList)				// Match the first link?
	{
		if (pSink->pNext)
			_pSinkList = pSink->pNext;
		else
		{
			_fMosueSink = 0;				// No more mouse trap left
			memset(_pSinkList, 0, sizeof(CTFMOUSETRAP));
		}
	}
	else
	{										// Match link other than the first link
		Assert(pSinkParent);
		pSinkParent->pNext = pSink->pNext;
		delete pSink;
	}

	return S_OK;
}
	
/*
 *	STDMETHODIMP CUIM::Init()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDMETHODIMP CUIM::Init()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::Init");

	HRESULT hResult;
	
	// Init some CUIM data
	_cCallMgrLevels = 1;
	_fAllowUIMLock = 1;

	hResult = _pTextMsgFilter->_pTim->CreateDocumentMgr(&_pdim);

	if (FAILED(hResult))
		goto ExitError;

	hResult = _pdim->CreateContext(_pTextMsgFilter->_tid, 0, (ITextStoreACP *)this, &_pic, &_editCookie);
	if (FAILED(hResult))
		goto ExitError;

	hResult = _pdim->Push(_pic);
	if (FAILED(hResult))
		goto ExitError;

	// Get the interface for rendering markup
	if (_pic->QueryInterface(IID_ITfContextRenderingMarkup, (void **)&_pContextRenderingMarkup) != S_OK)
		_pContextRenderingMarkup = NULL;

	_pDAM = NULL;
	_pCategoryMgr = NULL;

	hResult = CoCreateInstance(CLSID_TF_DisplayAttributeMgr, NULL, CLSCTX_INPROC_SERVER, 
		IID_ITfDisplayAttributeMgr, (void**)&(_pDAM));

	hResult = CoCreateInstance(CLSID_TF_CategoryMgr, NULL, CLSCTX_INPROC_SERVER, 
		IID_ITfCategoryMgr, (void**)&_pCategoryMgr);

	_pTextEditSink = new CTextEditSink(EndEditCallback, this);

	if (_pTextEditSink)
	{
		if (FAILED(_pTextEditSink->_Advise(_pic)))
		{
			delete _pTextEditSink;
			_pTextEditSink = NULL;
		}
	}

	LRESULT lresult;
	_pTextMsgFilter->_pTextService->TxSendMessage(EM_SETUPNOTIFY, 1, (LPARAM)(ITxNotify *)this, &lresult);
	
	_fAllowUIMLock = 0;

	return S_OK;

ExitError:
	Uninit();
	return hResult;
}

/*
 *	void CUIM::Uninit()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
void CUIM::Uninit()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::Uninit");

	if (_pTextFont)
	{
		_pTextFont->Release();
		_pTextFont = NULL;
	}

	if (_parITfEnumRange)
	{
		int idx = _parITfEnumRange->Count();

		for ( ; idx > 0; idx--)
		{
			IEnumTfRanges **ppEnumRange = (IEnumTfRanges **)(_parITfEnumRange->Elem(idx-1));
			if (ppEnumRange && *ppEnumRange)
				(*ppEnumRange)->Release();
		}

		_parITfEnumRange->Clear(AF_DELETEMEM);
		delete _parITfEnumRange;
		_parITfEnumRange = NULL;
	}

	if (_parAttrsVal)
	{
		InitAttrVarArray(FALSE);
		FreePv (_parAttrsVal);
		_parAttrsVal = NULL;
	}

	if (_pSinkList)
	{
		CTFMOUSETRAP	*pSink = _pSinkList;

		_pSinkList = NULL;

		// Delete the Mouse sinks list
		while (1)
		{
			CTFMOUSETRAP	*pNext = pSink->pNext;

			if(pSink->pMouseSink)
				pSink->pMouseSink->Release();

			delete pSink;

			if (!pNext)		// Any more?
				break;		//	Done.

			pSink = pNext;
		}
	}

	if (_pContextRenderingMarkup)
	{
		_pContextRenderingMarkup->Release();
		_pContextRenderingMarkup = NULL;
	}

	if (_pDAM)
	{
		_pDAM->Release();
		_pDAM = NULL;
	}

	if (_pCategoryMgr)
	{
		_pCategoryMgr->Release();
		_pCategoryMgr = NULL;
	}

	if (_pTextEditSink)
	{
		_pTextEditSink->_Unadvise();
		delete _pTextEditSink;
		_pTextEditSink = NULL;
	}

	if (_pdim && _pic)
		_pdim->Pop(TF_POPF_ALL);

	if (_pic)
	{
		_pic->Release();
		_pic = NULL;
	}

	if (_pdim)
	{
		_pdim->Release();
		_pdim = NULL;
	}

	if (_pacrUl)
	{
		_pacrUl->Clear(AF_DELETEMEM);
		delete _pacrUl;
		_pacrUl = NULL;
	}
}

/*
 *	void CreateUIM()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
BOOL CreateUIM(CTextMsgFilter *pTextMsgFilter)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CreateUIM");

	BOOL	fCreateUIM = FALSE;

	HRESULT hResult = CoCreateInstance(CLSID_TF_ThreadMgr, NULL, CLSCTX_INPROC_SERVER, 
		IID_ITfThreadMgr, (void**)&(pTextMsgFilter->_pTim));


	if (hResult == S_OK)
	{	
		// ready to start interacting
		if (pTextMsgFilter->_pTim->Activate(&(pTextMsgFilter->_tid)) == S_OK)
		{
			pTextMsgFilter->_pCUIM = new CUIM(pTextMsgFilter);

			if (pTextMsgFilter->_pCUIM)
			{
				hResult = pTextMsgFilter->_pCUIM->Init();
				if (hResult == S_OK)               
					fCreateUIM = TRUE;
				else
				{
					delete pTextMsgFilter->_pCUIM;
					pTextMsgFilter->_pCUIM = NULL;									
				}
			}
		}

		if (!fCreateUIM)
		{
			pTextMsgFilter->_pTim->Release();
			pTextMsgFilter->_pTim = NULL;
		}
		else if (GetFocus() == pTextMsgFilter->_hwnd)
			pTextMsgFilter->_pCUIM->OnSetFocus();
	}
	return fCreateUIM;
}

/*
 *	BOOL CUIM::GetExtentAcpPrange()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
BOOL CUIM::GetExtentAcpPrange(
	ITfRange *ITfRangeIn, 
	long &cpFirst,
	long &cpLim)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetExtentAcpPrange");

	ITfRangeACP *prangeACP = NULL;
	if (SUCCEEDED(ITfRangeIn->QueryInterface(IID_ITfRangeACP, (void **)&prangeACP)))
	{
		prangeACP->GetExtent(&cpFirst, &cpLim);
		
		prangeACP->Release();
	
		return TRUE;
	}

	return FALSE;
}

/*
 *	HRESULT CUIM::EndEditCallback()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
HRESULT CUIM::EndEditCallback(ITfEditRecord *pEditRecord, void *pv)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::EndEditCallback");

	HRESULT hr;
	CUIM	*_this = (CUIM *)pv;
	IEnumTfRanges *pEnumRanges;
	const GUID *rgGUID[1];

	if (!(_this->_fWriteLockOn))
	{
		_this->HandleTempDispAttr(pEditRecord);
		return S_OK;
	}

	// Get lid changes
	rgGUID[0] = &GUID_PROP_LANGID;
	hr = pEditRecord->GetTextAndPropertyUpdates(0, (const GUID**)rgGUID, 1, &pEnumRanges);
	if (SUCCEEDED(hr))
	{
		_this->HandleLangID (pEnumRanges);
		pEnumRanges->Release();
	}

	// Get attribute changes
	rgGUID[0] = &GUID_PROP_ATTRIBUTE;
	hr = pEditRecord->GetTextAndPropertyUpdates(0, (const GUID**)rgGUID, 1, &pEnumRanges);
	if (SUCCEEDED(hr))
	{
		_this->HandlePropAttrib (pEnumRanges);
		pEnumRanges->Release();
	}

	rgGUID[0] = &GUID_PROP_COMPOSING;
	hr = pEditRecord->GetTextAndPropertyUpdates(0, (const GUID**)rgGUID, 1, &pEnumRanges);
	if (SUCCEEDED(hr))
	{
		// Save the TextDelta to be process after the lock is off
		if (!(_this->_parITfEnumRange))
			_this->_parITfEnumRange = new CITfEnumRange();

		if (_this->_parITfEnumRange)
		{
			LONG				idxItem;
			IEnumTfRanges		**ppItem;
			ppItem = _this->_parITfEnumRange->Add(1, &idxItem);
			if (ppItem)
				*ppItem = pEnumRanges;
			else						
				pEnumRanges->Release();			// Add fail, forget it
		}
	}

	return S_OK;
}

/*
 *	void CUIM::HandleDispAttr(*pITfRangeProp, var, cp, cch)
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
void CUIM::HandleDispAttr(
	ITfRange *pITfRangeProp, 
	VARIANT  &var,
	long	 acpStartRange,
	long	 cch)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::HandleDispAttr");

	HRESULT hResult = TRUE;

	if (pITfRangeProp)
		hResult = GetExtentAcpPrange(pITfRangeProp, acpStartRange, cch);

	if (hResult && cch > 0)
	{
		ITextRange *pTextRange = NULL;
		hResult = _pTextMsgFilter->_pTextDoc->Range(acpStartRange, acpStartRange+cch, &pTextRange);
		if (pTextRange)
		{
			ITextFont	*pFont = NULL;

			if (_pTextFont)
				_pTextFont->GetDuplicate(&pFont);

			if (pFont)
			{
				if (var.vt == VT_I4)
				{
					GUID guid;
					ITfDisplayAttributeInfo *pDAI = NULL;
					TF_DISPLAYATTRIBUTE da;

					if (_pCategoryMgr->GetGUID(var.ulVal, &guid) == S_OK &&
						SUCCEEDED(_pDAM->GetDisplayAttributeInfo(guid, &pDAI, NULL)))
					{
						COLORREF	cr;
						long		lUnderline;
						long		idx = 0;

						Assert(pDAI);
						pDAI->GetAttributeInfo(&da);

						if (GetUIMAttributeColor(&da.crText, &cr))
							pFont->SetForeColor(cr);

						if (GetUIMAttributeColor(&da.crBk, &cr))
							pFont->SetBackColor(cr);

						lUnderline = GetUIMUnderline(da, idx, cr);
						if (lUnderline != tomNone)
						{
							if (idx)
							{
								hResult = _pTextMsgFilter->_pTextDoc->SetEffectColor(idx, cr);
								if (hResult == S_OK)
									lUnderline += (idx << 8);
							}
							pFont->SetUnderline(lUnderline);
						}
					}
					if (pDAI)
						pDAI->Release();
				}
				pTextRange->SetFont(pFont);
				pFont->Release();
			}
			pTextRange->Release();
		}
	}
}

/*
 *	HRESULT CUIM::HandlePropAttrib(ITfEnumTextDeltas *pEnumTextDeltas)
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
HRESULT CUIM::HandlePropAttrib(IEnumTfRanges *pEnumRanges)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::HandlePropAttrib");

	ITfRange	*pITfRange = NULL;

	if (!_pDAM || !_pCategoryMgr || _fInterimChar)
		return S_OK;
		
	ITfProperty		*pProp = NULL;
	HRESULT			hResult = _pic->GetProperty(GUID_PROP_ATTRIBUTE, &pProp);

	if (SUCCEEDED(hResult))
	{
		long	lCount;
		TS_SELECTION_ACP acpSelection;
		ULONG	cFetched;

		GetSelection(0, 0, &acpSelection, &cFetched);

		_pTextMsgFilter->_pTextDoc->Freeze(&lCount);				// Turn off display
		while (pEnumRanges->Next(1, &pITfRange, NULL) == S_OK)
		{
			BOOL			fAnyPropRange = FALSE;
			IEnumTfRanges	*pEnumPropRange = NULL;
			long			acpRangeStart, ccpRangeStart;
			VARIANT			var;

			GetExtentAcpPrange(pITfRange, acpRangeStart, ccpRangeStart);
			
			// Create a property Enum for ranges within pITfRange
			if (pProp->EnumRanges(_editCookie, &pEnumPropRange, pITfRange) == S_OK)
			{
				ITfRange	*pITfRangeProp = NULL;

				while (pEnumPropRange->Next(1, &pITfRangeProp, NULL) == S_OK)
				{
					VariantInit(&var);
					if (!fAnyPropRange)
					{
						long	acpCurrentRange, ccpCurrent;

						if (GetExtentAcpPrange(pITfRangeProp, acpCurrentRange, ccpCurrent))
						{
							if (acpCurrentRange > acpRangeStart)
								HandleDispAttr(NULL, var, acpRangeStart, acpCurrentRange - acpRangeStart);
						}
						fAnyPropRange = TRUE;
					}

					pProp->GetValue(_editCookie, pITfRangeProp, &var);
					HandleDispAttr(pITfRangeProp, var);

					VariantClear(&var);
					pITfRangeProp->Release();
				}
				pEnumPropRange->Release();
			}

			if (!fAnyPropRange)
			{
				// Whole string doesn't contain any disp. attribute.
				VariantInit(&var);
				HandleDispAttr(pITfRange, var);
			}

			pITfRange->Release();
		}
		pProp->Release();

		// Only want to scroll back if its not a selection
		if (acpSelection.acpStart == acpSelection.acpEnd)
		{
			ITextRange *pTextRange;

			hResult = _pTextMsgFilter->_pTextDoc->Range(acpSelection.acpStart, acpSelection.acpEnd, &pTextRange);
			if (pTextRange)
			{
				pTextRange->Select();
				pTextRange->Release();
			}
		}
		_pTextMsgFilter->_pTextDoc->Unfreeze(&lCount);				// Turn on display
	}

	return S_OK;
}

/*
 *	void CUIM::GetUIMUnderline()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *	
 */
long CUIM::GetUIMUnderline(
	TF_DISPLAYATTRIBUTE &da, 
	long &idx, 
	COLORREF &cr)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetUIMUnderline");

	long lStyle = tomNone;

	idx = 0;

	if (da.lsStyle != TF_LS_NONE)
	{							
		switch(da.lsStyle)
		{
			// case TFLS_SOLID:
			default:
				lStyle = da.fBoldLine ? tomThick : tomSingle;
				break;

			case TF_LS_DOT:
			case TF_LS_DASH:		// Dash line should show as dotted line
				lStyle = tomDotted;
				break;

			case TF_LS_SQUIGGLE:
				lStyle = tomWave;
				break;
		}

		if (GetUIMAttributeColor(&da.crLine, &cr))
		{
			if (!_pacrUl)				// Create the array if it is not there
				_pacrUl = new CUlColorArray(); 

			if (_pacrUl)
			{
				LONG		idxMax = _pacrUl->Count();
				LONG		idxItem;
				COLORREF	*pCr;

				// Check if this item is in the array
				for (idxItem=0; idxItem < idxMax; idxItem++)
				{
					pCr = _pacrUl->Elem(idxItem);
					Assert(pCr);
					if (*pCr == cr)
						idx = idxItem + 1;		// found it
				}

				if (!idx)
				{
					// Add it to array
					pCr = _pacrUl->Add(1, &idxItem);

					if (pCr)
					{
						*pCr = cr;
						idx = idxItem + 1;			// return new idx
					}
				}
			}
		}
	}

	return lStyle;
}

/*
 *	void CUIM::HandleFinalString(ITfRange *pPropRange, long acpStartRange, long cch)
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
void CUIM::HandleFinalString(
	ITfRange *pPropRange,
	long	acpStartRange,
	long	cch,
	BOOL	fEndComposition)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::HandleFinalString");

	HRESULT	hResult = TRUE;

	if (pPropRange)
		hResult = GetExtentAcpPrange(pPropRange, acpStartRange, cch);

	if (hResult == TRUE && cch)
	{
		if (_bstrComposition && !fEndComposition)
			return;

		ITextRange *pTextRange = NULL;
		ITextSelection	*pTextSel = NULL;
		long	cpSelMin = 0, cpSelMax = 0;
		BOOL	fTextSel = FALSE;

		// Need to maintain current selection
		hResult = _pTextMsgFilter->_pTextDoc->GetSelectionEx(&pTextSel);

		if (pTextSel)
		{
			hResult	= pTextSel->GetStart(&cpSelMin);
			hResult	= pTextSel->GetEnd(&cpSelMax);
			pTextSel->Release();
			fTextSel = TRUE;
		}

		if (_bstrComposition)
		{
			long	cpEnd;

			GetEndACP(&cpEnd);

			cch = _cchComposition + cpEnd - _cpEnd;
			acpStartRange = _acpBstrStart;
		}

		hResult = _pTextMsgFilter->_pTextDoc->Range(acpStartRange, acpStartRange+cch, &pTextRange);
		if (pTextRange)
		{
			long		cEmbeddedObjects = 0;
			BSTR		bstr = NULL;

			if (cch)
				hResult = pTextRange->GetText(&bstr);

			if (SUCCEEDED(hResult) && (bstr || cch == 0))
			{
				long	lCount;
				BSTR	bstrTemp = NULL;

				if (!_fAnyWriteOperation)		// No new string
					goto IGNORE_STRING;			//	no need to insert

				if (_bstrComposition)
				{
					if (bstr)
					{
						WCHAR *pStr1 = _bstrComposition;
						WCHAR *pStr2 = bstr;

						while (*pStr1 != 0 && *pStr1 == *pStr2)
						{
							pStr1++;
							pStr2++;
						}

						if (*pStr1 == *pStr2)		// Same data, no need to insert
						{
							if (acpStartRange == cpSelMin)
							{
								pTextRange->Collapse(tomFalse);
								pTextRange->Select();
							}
							goto IGNORE_STRING;
						}
					}

					bstrTemp = _bstrComposition;
				}

				// Build embed object data if necessary
				EMBEDOBJECT	arEmbeddObjects[5];
				EMBEDOBJECT *pEmbeddObjects = arEmbeddObjects;

				if (bstr)
					cEmbeddedObjects = 
						BuildObject(pTextRange, bstr, &pEmbeddObjects, ARRAY_SIZE(arEmbeddObjects));

				_pTextMsgFilter->_pTextDoc->Freeze(&lCount);				// Turn off display

				// We want the final text to be in the undo stack.
				// So, we first delete the final string.
				// Resume undo and add the final string back.  Yuk!
				if (bstrTemp && _cObjects)
				{
					long	cpMin;
					long	cchBstr = SysStringLen(bstrTemp);

					pTextRange->GetStart(&cpMin);
					InsertTextandObject(pTextRange, bstrTemp, _pObjects, _cObjects);
					pTextRange->SetRange(cpMin, cpMin+cchBstr);
				}
				else
					pTextRange->SetText(bstrTemp);

				if (_pTextFont)
					pTextRange->SetFont(_pTextFont);

				_pTextMsgFilter->_pTextDoc->Undo(tomResume, NULL);
				_pTextMsgFilter->_pTextDoc->SetNotificationMode(tomTrue);

				if (cEmbeddedObjects == 0)
					pTextRange->SetText(bstr);
				else
				{
					InsertTextandObject(pTextRange, bstr, pEmbeddObjects, cEmbeddedObjects);
					CleanUpObjects(cEmbeddedObjects, pEmbeddObjects);
					if (pEmbeddObjects != arEmbeddObjects)
						delete pEmbeddObjects;
				}

				_pTextMsgFilter->_pTextDoc->Undo(tomSuspend, NULL);

				// Hold notification if needed
				if (!(_pTextMsgFilter->_fIMEAlwaysNotify))
					_pTextMsgFilter->_pTextDoc->SetNotificationMode(tomFalse);

				if (fTextSel)
				{
					ITextRange *pSelRange = NULL;
					// restore previous selection.
					hResult = _pTextMsgFilter->_pTextDoc->Range(cpSelMin, cpSelMax, &pSelRange);
					if (pSelRange)
					{
						pSelRange->Select();
						pSelRange->Release();
					}
				}
				else
				{
					pTextRange->Collapse(tomFalse);
					pTextRange->Select();
				}

				_pTextMsgFilter->_pTextDoc->Unfreeze(&lCount);				// Turn on display
			}
IGNORE_STRING:
			if (bstr)
				SysFreeString(bstr);
			pTextRange->Release();
		}
	}
}

/*
 *	HRESULT CUIM::HandleFocusRange(IEnumTfRanges *pEnumRanges)
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
HRESULT CUIM::HandleFocusRange(IEnumTfRanges *pEnumRanges)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::HandleFocusRange");

	ITfProperty		*pProp = NULL;	
	ITfRange		*pITfRange;
	HRESULT			hResult = _pic->GetProperty(GUID_PROP_COMPOSING, &pProp);
	BOOL			fAnyPendingFocusRange = FALSE;

	if (SUCCEEDED(hResult))
	{
		// Enumerate all the changes
		pEnumRanges->Reset();
		while (pEnumRanges->Next(1, &pITfRange, NULL) == S_OK)
		{
			BOOL			fAnyPropRange = FALSE;
			IEnumTfRanges	*pEnumPropRange = NULL;

			long			acpStartRange, ccp;

			GetExtentAcpPrange(pITfRange, acpStartRange, ccp);


			// Create a property Enum for ranges within pITfRange
			if (pProp->EnumRanges(_editCookie, &pEnumPropRange, pITfRange) == S_OK)
			{
				ITfRange	*pPropRange = NULL;

				// Try to get a value for the property
				while (pEnumPropRange->Next(1, &pPropRange, NULL) == S_OK)
				{
					VARIANT		var;

					VariantInit(&var);

					if (!fAnyPropRange)
					{
						long	acpCurrentRange, ccpCurrent;

						GetExtentAcpPrange(pPropRange, acpCurrentRange, ccpCurrent);
						if (acpCurrentRange > acpStartRange)
						{
							// We have a final string before the new string.
							HandleFinalString(NULL, acpStartRange, acpCurrentRange - acpStartRange);
						}
						fAnyPropRange = TRUE;
					}

					hResult = pProp->GetValue(_editCookie, pPropRange, &var);

					if (SUCCEEDED(hResult) && var.vt == VT_I4 && var.ulVal == 0)					
						hResult = E_FAIL;				// Just as good as not finding the range
					else
						fAnyPendingFocusRange = TRUE;

					VariantClear(&var);

					if (hResult != S_OK)
						HandleFinalString(pPropRange);

					pPropRange->Release();
				}
				pEnumPropRange->Release();
			}

			if (!fAnyPropRange)					// Any focus range?
				HandleFinalString(pITfRange);	//	No --> the whole string is final string

			if (_fEndTyping && _bstrComposition && _acpBstrStart != tomForward)
				HandleFinalString(NULL, _acpBstrStart, _cchComposition, TRUE);

			pITfRange->Release();
		}
		pProp->Release();		
	}

	return S_OK;
}

/*
 *	HRESULT CUIM::HandleLangID(IEnumTfRanges *pEnumRanges)
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
HRESULT CUIM::HandleLangID(IEnumTfRanges *pEnumRanges)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::HandleLangID");

	ITfProperty		*pProp = NULL;	
	ITfRange		*pITfRange;
	HRESULT			hResult;
	LCID			lcid;

	// TODO:
	// if _pTextFont is NULL, setup _pTextFont to handle the langID.
	if (!_pTextFont)
		return S_OK;

	hResult = _pic->GetProperty(GUID_PROP_LANGID, &pProp);

	if (SUCCEEDED(hResult))
	{
		// Enumerate all the changes
		pEnumRanges->Reset();
		while (pEnumRanges->Next(1, &pITfRange, NULL) == S_OK)
		{
			IEnumTfRanges	*pEnumPropRange = NULL;

			// Create a property Enum for ranges within pITfRange
			if (pProp->EnumRanges(_editCookie, &pEnumPropRange, pITfRange) == S_OK)
			{
				ITfRange	*pPropRange = NULL;
				if (pEnumPropRange->Next(1, &pPropRange, NULL) == S_OK)
				{
					VARIANT		var;

					VariantInit(&var);

					hResult = pProp->GetValue(_editCookie, pITfRange, &var);

					if (SUCCEEDED(hResult) && var.vt == VT_I4)
					{
						lcid = (LCID)var.ulVal;

						UINT		cpgProp = CodePageFromCharRep(CharRepFromLID(lcid));
						ITextFont	*pTextFont=NULL;

						_pTextFont->GetDuplicate(&pTextFont);
						if (pTextFont)
						{
							HRESULT		hResult;
							LONG		acpStart, cchStart;
							ITextRange	*pTextRange;
							UINT		cpgTemp = _pTextMsgFilter->_uKeyBoardCodePage;

							GetExtentAcpPrange(pITfRange, acpStart, cchStart);
							if (cchStart)
							{
								_pTextMsgFilter->_uKeyBoardCodePage = cpgProp;
								CIme::CheckKeyboardFontMatching(acpStart, _pTextMsgFilter, pTextFont);
								_pTextMsgFilter->_uKeyBoardCodePage = cpgTemp;

								hResult = _pTextMsgFilter->_pTextDoc->Range(acpStart, acpStart+cchStart, &pTextRange);
								if (pTextRange)
								{
									pTextRange->SetFont(pTextFont);
									pTextRange->Release();
								}
							}
							pTextFont->Release();
						}
					}
					VariantClear(&var);
					pPropRange->Release();
				}
				pEnumPropRange->Release();
			}
			pITfRange->Release();
		}
		pProp->Release();
	}

	return S_OK;
}

/*
 *	HRESULT CUIM::OnSetFocus(BOOL fEnable)
 *
 *	@mfunc
 *	
 *
 */
void CUIM::OnSetFocus(BOOL fEnable)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::OnSetFocus");

	_pTextMsgFilter->_pTim->SetFocus(fEnable ? _pdim : NULL);
}

/*
 *	HRESULT CUIM::CompleteUIMText()
 *
 *	@mfunc
 *	
 *
 */
void CUIM::CompleteUIMText()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::CompleteUIMText");

	HRESULT								hResult;
	ITfContextOwnerCompositionServices	*pCompositionServices;

	_fAllowUIMLock = 1;

	Assert(_pic);

	if (_pic->QueryInterface(IID_ITfContextOwnerCompositionServices, (void **)&pCompositionServices) == S_OK)
	{
		// passing in NULL means "all compositions"
		hResult = pCompositionServices->TerminateComposition(NULL);
		pCompositionServices->Release();
	}

	_fAllowUIMLock = 0;

}

/*
 *	BOOL CUIM::GetUIMAttributeColor()
 *
 *	@mfunc
 *		Helper routine to get UIM color
 *
 *	@rdesc
 *		TRUE if we setup input pcr with the UIM color 
 *
 */
BOOL CUIM::GetUIMAttributeColor(TF_DA_COLOR *pdac, COLORREF *pcr)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetUIMAttributeColor");

	BOOL	fRetCode = FALSE;
	switch (pdac->type)
	{
		//case TFCT_NONE:
		//	return FALSE;

		case TF_CT_SYSCOLOR:
			*pcr = GetSysColor(pdac->nIndex);
			fRetCode = TRUE;
			break;

		case TF_CT_COLORREF:
			*pcr = pdac->cr;
			fRetCode = TRUE;
			break;
	}
	return fRetCode;    
}

/*
 *	void CUIM::OnUIMTypingDone()
 *
 *	@mfunc
 *		Helper routine to cleanup after UIM Typing is done
 *
 */
void CUIM::OnUIMTypingDone()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::OnUIMTypingDone");

	if (_pTextFont)
	{
		_pTextFont->Release();
		_pTextFont = NULL;
	}

	CleanUpComposition();

	// Reset Korean block caret if needed
	if (_fInterimChar)
	{
		_fInterimChar = 0;
		_pTextMsgFilter->_pTextDoc->SetCaretType(tomNormalCaret);		// Reset Block caret mode
	}

	_fAnyWriteOperation = 0;
	_pTextMsgFilter->_pTextDoc->Undo(tomResume, NULL);
	_pTextMsgFilter->_pTextDoc->SetNotificationMode(tomTrue);

	if (_pacrUl)
		_pacrUl->Clear(AF_DELETEMEM);
};

/*
 *	BOOL CUIM::GetGUIDATOMFromGUID()
 *
 *	@mfunc
 *		Helper routine to get GUIDATOM from UIM
 *
 */
BOOL CUIM::GetGUIDATOMFromGUID(
	REFGUID rguid, 
	TfGuidAtom *pguidatom)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetGUIDATOMFromGUID");

	if (_pCategoryMgr && _pCategoryMgr->RegisterGUID(rguid, pguidatom) == S_OK)
		return TRUE;

	return FALSE;
}
/*
 *	BOOL CUIM::GetAttrs()
 *
 *	@mfunc
 *		Helper routine to get Attr
 *
 */
HRESULT CUIM::GetAttrs(
	LONG acpPos,
	ULONG cFilterAttrs,
	const TS_ATTRID *paFilterAttrs, 
	BOOL fGetDefault)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetAttrs");

	HRESULT		hResult;
	ITextFont	*pTextFont = NULL;
	ITextPara	*pTextPara = NULL;
	int			idx;
	BOOL		fRequestedAll = FALSE;
	int			idxAttr;
	TS_ATTRVAL	*pAttrVal;
	ITextRange	*pTextRange = NULL;	

	if (cFilterAttrs == 0)
	{
		fRequestedAll = TRUE;
		cFilterAttrs = MAX_ATTR_SUPPORT;
	}

	InitAttrVarArray();

	if (!_parAttrsVal)
		return E_OUTOFMEMORY;

	if (fGetDefault)
	{
		// Get document defaults font and para
		hResult = _pTextMsgFilter->_pTextDoc->GetDocumentFont(&pTextFont);
		if (FAILED(hResult))
			goto EXIT;
		
		hResult = _pTextMsgFilter->_pTextDoc->GetDocumentPara(&pTextPara);
		if (FAILED(hResult))
			goto EXIT;
	}
	else
	{
		hResult = _pTextMsgFilter->_pTextDoc->Range(acpPos, acpPos, &pTextRange);
		if (FAILED(hResult))
			goto EXIT;

		hResult = pTextRange->GetFont(&pTextFont);
		hResult = pTextRange->GetPara(&pTextPara);
	}

	pAttrVal = _parAttrsVal;
	for (idx = 0; idx < (int)cFilterAttrs; idx++, paFilterAttrs++)
	{
		if (fRequestedAll)
			idxAttr = idx;
		else
			idxAttr = FindGUID(*paFilterAttrs);

		if (idxAttr >= 0)
		{
			if (PackAttrData(idxAttr, pTextFont, pTextPara, pAttrVal))
			{
				_uAttrsValTotal++;
				pAttrVal++;
				
				if (_uAttrsValTotal == MAX_ATTR_SUPPORT)
					break;
			}
		}
	}
	hResult = S_OK;

EXIT:
	if (pTextFont)
		pTextFont->Release();	

	if (pTextPara)
		pTextPara->Release();

	if (pTextRange)
		pTextRange->Release();

	return hResult;
}
/*
 *	int CUIM::FindGUID
 *
 *	@mfunc
 *		Helper routine to check if we supported the requested Attribute GUID
 *
 */
int CUIM::FindGUID(REFGUID guid)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::FindGUID");

	ULONG i;

	for (i=0; i < MAX_ATTR_SUPPORT; i++)
	{
		if (IsEqualIID(*(_arTSAttridSupported[i]), guid))
			return i;
	}

	// not found
	return -1;
}

/*
 *	int CUIM::PackAttrData
 *
 *	@mfunc
 *		Helper routine to fill in data for the given Attrib index
 *
 */
BOOL CUIM::PackAttrData(
	LONG		idx,
	ITextFont	*pITextFont,
	ITextPara	*pITextPara,
	TS_ATTRVAL	*pAttrVal)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::PackAttrData");

	long	lValue;
	float	x;
	BSTR	bstrName;
	HRESULT	hResult;
	const	GUID	*pGUID;
	TfGuidAtom	guidatom;


	if (idx < 0 || idx >= MAX_ATTR_SUPPORT)
		return FALSE;

	if (!pITextFont && idx <= iattrSuperscript)
		return FALSE;

	if (!pITextPara && idx == iattrRTL)
		return FALSE;

	pAttrVal->varValue.vt = VT_BOOL;
	memcpy(&pAttrVal->idAttr, _arTSAttridSupported[idx], sizeof(TS_ATTRID));


	switch(idx)
	{
		case iattrFacename:
			hResult = pITextFont->GetName(&bstrName);
			pAttrVal->varValue.vt = VT_BSTR;
			pAttrVal->varValue.bstrVal = bstrName;				
			break;

		case iattrSize:
			x = 0.0;
			hResult = pITextFont->GetSize(&x);
			lValue = (long)x;
			pAttrVal->varValue.vt = VT_I4;
			pAttrVal->varValue.lVal = x;
			break;

		case iattrColor:
			hResult = pITextFont->GetForeColor(&lValue);
			pAttrVal->varValue.vt = VT_I4;
			pAttrVal->varValue.lVal = lValue;			// TODO: check for tomAutocolor
			break;

		case iattrBold:
			hResult = pITextFont->GetBold(&lValue);
			pAttrVal->varValue.boolVal = lValue == tomTrue ? tomTrue : VARIANT_FALSE;				
			break;

		case iattrItalic:
			hResult = pITextFont->GetItalic(&lValue);
			pAttrVal->varValue.boolVal = lValue == tomTrue ? tomTrue : VARIANT_FALSE;				
			break;

		case iattrUnderline:
			hResult = pITextFont->GetUnderline(&lValue);
			pAttrVal->varValue.boolVal = lValue == tomNone ? VARIANT_FALSE : tomTrue;
			break;

		case iattrSubscript:
			hResult = pITextFont->GetSubscript(&lValue);
			pAttrVal->varValue.boolVal = lValue == tomTrue ? tomTrue : VARIANT_FALSE;
			break;

		case iattrSuperscript:
			hResult = pITextFont->GetSuperscript(&lValue);
			pAttrVal->varValue.boolVal = lValue == tomTrue ? tomTrue : VARIANT_FALSE;
			break;

		case iattrRTL:
			{
				LRESULT lres = 0;
				_pTextMsgFilter->_pTextService->TxSendMessage(
					EM_GETPARATXTFLOW, 0, (LPARAM)pITextPara, &lres);
				pAttrVal->varValue.boolVal = lres ? tomTrue : VARIANT_FALSE;
			}
			break;

		case iattrVertical:
			BOOL fAtFont;
			_pTextMsgFilter->_pTextDoc->GetFEFlags(&lValue);
			fAtFont = lValue & tomUseAtFont;
			lValue &= tomTextFlowMask;
			pAttrVal->varValue.boolVal = (fAtFont && lValue == tomTextFlowSW) ? tomTrue : VARIANT_FALSE;
			break;

		case iattrBias:
			pGUID = &GUID_MODEBIAS_NONE;
			if (IN_RANGE(CTFMODEBIAS_DEFAULT, _pTextMsgFilter->_wUIMModeBias, CTFMODEBIAS_HALFWIDTHALPHANUMERIC))		
				pGUID = _arModeBiasSupported[_pTextMsgFilter->_wUIMModeBias];

			if (!GetGUIDATOMFromGUID(*pGUID, &guidatom))
				guidatom = TF_INVALID_GUIDATOM;

			pAttrVal->varValue.vt = VT_I4;
			pAttrVal->varValue.lVal = guidatom;
			break;

		case iattrTxtOrient:
			// Get Text flow and setup the text rotation
			_pTextMsgFilter->_pTextDoc->GetFEFlags(&lValue);
			lValue &= tomTextFlowMask;
			pAttrVal->varValue.vt = VT_I4;
			pAttrVal->varValue.lVal = 0;
			if (lValue == tomTextFlowSW)
				pAttrVal->varValue.lVal = 2700;
			else if (lValue == tomTextFlowNE)
				pAttrVal->varValue.lVal = 900;

			break;
	}

	return TRUE;
}

/*
 *	STDMETHODIMP CUIM::GetStoryLength
 *
 *	@mfunc
 *		Helper routine to check the attribute filters
 *
 */
STDMETHODIMP CUIM::GetStoryLength(LONG *pacp)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetStoryLength");

	ITextRange	*pTextRange = NULL;

	HRESULT hResult = _pTextMsgFilter->_pTextDoc->Range(0, 0, &pTextRange);
	if (hResult == S_OK && pTextRange)
	{
		long	Count;

		hResult = pTextRange->GetStoryLength(&Count);

		if (hResult == S_OK)
			*pacp = Count;

		pTextRange->Release();
	}
	return hResult;
}

/*
 *	void CUIM::InitAttrVarArray
 *
 *	@mfunc
 *		Helper routine to setup AttrVar Array
 *
 */
void CUIM::InitAttrVarArray(BOOL fAllocData)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::InitAttrVarArray");

	if (_parAttrsVal)
	{
		USHORT		uIdx;
		TS_ATTRVAL	*pAttrVal = _parAttrsVal;

		for (uIdx = 0; uIdx < _uAttrsValTotal; uIdx++, pAttrVal++)
			VariantClear(&(pAttrVal->varValue));
					
		memset(_parAttrsVal, 0, _uAttrsValTotal * sizeof(TS_ATTRVAL));

	}
	else if (fAllocData)
	{
		_parAttrsVal= (TS_ATTRVAL *)PvAlloc(sizeof(TS_ATTRVAL) * MAX_ATTR_SUPPORT, GMEM_ZEROINIT);
		Assert(_parAttrsVal);
	}
	_uAttrsValCurrent = 0;
	_uAttrsValTotal = 0;
}

/*
 *	HRESULT CUIM::MouseCheck(UINT *pmsg, WPARAM *pwparam, LPARAM *plparam, LRESULT *plres)
 *
 *	@mfunc
 *		Perform UIM mouse check
 *
 *	@rdesc
 *		int		S_OK	if handled
 *				S_FALSE Don't handle and should be ignored
 *
 */
HRESULT CUIM::MouseCheck(
	UINT *pmsg,
	WPARAM *pwparam,
	LPARAM *plparam,
	LRESULT *plres)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::MouseCheck");

	BOOL fRetCode = FALSE;

	if (_fShutDown)
		return S_FALSE;

	if (_fMosueSink)
	{
		BOOL			fTerminateIME;
		long			cpCusor = -1;
		CTFMOUSETRAP	*pSinkList = _pSinkList;

		Assert(_pSinkList);

		_fAllowUIMLock = 1;

		// Get thru the list until one of the traps has handled the message
		while(fRetCode == FALSE && pSinkList)
		{
			if (cpCusor == -1 || pSinkList->cpMouseStart < cpCusor &&
				cpCusor <= pSinkList->cpMouseStart + pSinkList->cchMosueComp)	// Within composition range?
			{
				fRetCode = _pTextMsgFilter->MouseOperation(*pmsg, pSinkList->cpMouseStart,
						pSinkList->cchMosueComp, *pwparam, &(pSinkList->wParamBefore), &fTerminateIME, 
						NULL, &cpCusor, pSinkList->pMouseSink);
			}

			pSinkList = pSinkList->pNext;
		}

		_fAllowUIMLock = 0;
		if ( !fRetCode && IsUIMTyping() && WM_MOUSEMOVE != *pmsg )
			_pTextMsgFilter->CompleteUIMTyping(CIme::TERMINATE_NORMAL);
	}
	return fRetCode ? S_OK : S_FALSE;
}

/*
 *	HRESULT CUIM::Reconverse
 *
 *	@mfunc
 *		Perform UIM reconversion
 *
 *	@rdesc
 *		int		S_OK	if handled
 *				S_FALSE Don't handle and should be ignored
 *				-1		Don't handle and try IME reconverse
 *
 */
int CUIM::Reconverse()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::Reconverse");

	HRESULT					hResult;
	ITfRange				*pITfRange = NULL;
	ITfFnReconversion		*pITfReconverse = NULL;
	ITfFunctionProvider		*pITfFctProvider = NULL;
	TF_SELECTION			TFSel = {0};
	ULONG					cSel;
	int						retCode = -1;
	int						fConvertible = FALSE;

	if (_fUIMTyping)
		return S_FALSE;

	_fAllowUIMLock = 1;
	_fHoldCTFSelChangeNotify = 1;

	hResult = _pTextMsgFilter->_pTim->GetFunctionProvider(GUID_SYSTEM_FUNCTIONPROVIDER, &pITfFctProvider);
	if (SUCCEEDED(hResult))
	{
		hResult = pITfFctProvider->GetFunction(GUID_NULL, IID_ITfFnReconversion, (IUnknown **)&pITfReconverse);
		pITfFctProvider->Release();

		if (SUCCEEDED(hResult))
		{
			int fCurrentLock = _fReadLockOn;

			if (!fCurrentLock)
				_fReadLockOn = 1;	// Setup internal read lock

			hResult = _pic->GetSelection(_editCookie, 0, 1, &TFSel, &cSel);

			if (!fCurrentLock)
				_fReadLockOn = 0;	// Clear internal read lock

			if (hResult == S_OK && cSel == 1)
			{
				if (pITfReconverse->QueryRange(TFSel.range, &pITfRange, &fConvertible) == S_OK && fConvertible)
				{
					pITfReconverse->Reconvert(pITfRange);
					retCode = S_OK;
				}
			}
		}
	}

	if (TFSel.range)
		TFSel.range->Release();

	if (pITfRange)
		pITfRange->Release();

	if (pITfReconverse)
		pITfReconverse->Release();

	_fAllowUIMLock = 0;

	return retCode;
}

/*
 *	HRESULT CUIM::FindHiddenText
 *
 *	@mfunc
 *		Find Hidden text and return the end of the range
 *
 *	@rdesc
 *
 */
HRESULT CUIM::FindHiddenText(
	long cp, 
	long cpEnd, 
	long &cpRange)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::FindHiddenText");

	HRESULT		hResult;
	long		unitMoved;
	ITextRange	*pTextRange = NULL;

	cpRange = cp;
	if (cpRange >= cpEnd)
		return S_OK;

	hResult = _pTextMsgFilter->_pTextDoc->Range(cpRange, cpRange, &pTextRange);
	if (!SUCCEEDED(hResult))
		return hResult;

	hResult = pTextRange->EndOf(tomHidden, tomExtend, &unitMoved);
	if (SUCCEEDED(hResult))
	{
		Assert(unitMoved);
		cpRange = 0;
		hResult = pTextRange->GetEnd(&cpRange);
		Assert(cpRange);
	}
	pTextRange->Release();
	return hResult;
}

/*
 *	HRESULT CUIM::FindUnhiddenText
 *
 *	@mfunc
 *		Find Unhidden text and return the end of the range
 *
 *	@rdesc
 *
 */
HRESULT CUIM::FindUnhiddenText(
	long cp, 
	long cpEnd, 
	long &cpRange)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::FindUnhiddenText");

	HRESULT		hResult;
	long		unitMoved;
	ITextRange	*pTextRange = NULL;
	ITextFont	*pTextFont = NULL;
	long		fHidden;

	cpRange = cp;
	if (cpRange >= cpEnd)
		return S_OK;

	hResult = _pTextMsgFilter->_pTextDoc->Range(cpRange, cpRange, &pTextRange);
	if (!SUCCEEDED(hResult))
		return hResult;

	Assert(pTextRange);
	while (cpRange < cpEnd)
	{
		hResult = pTextRange->MoveEnd(tomCharacter, 1, &unitMoved);
		if (!SUCCEEDED(hResult))
			break;

		if (!unitMoved)
		{
			hResult = E_FAIL;
			break;
		}

		hResult = pTextRange->GetFont(&pTextFont);
		if (!SUCCEEDED(hResult))
			break;

		Assert(pTextFont);
		pTextFont->GetHidden(&fHidden);
		pTextFont->Release();

		if (fHidden)
			break;

		hResult = pTextRange->EndOf(tomCharFormat, tomMove, &unitMoved);
		if (!SUCCEEDED(hResult))
			break;

		if (unitMoved > 0)
		{
			cpRange = 0;
			hResult = pTextRange->GetEnd(&cpRange);
			if (!SUCCEEDED(hResult))
				break;
			Assert(cpRange);
		}
		else
			cpRange = cpEnd;
	}

	pTextRange->Release();
	return hResult;
}

/*
 *	void CUIM::BuildHiddenTxtBlks
 *
 *	@mfunc
 *		Build hidden text blocks
 *
 *
 */
void CUIM::BuildHiddenTxtBlks(
	long &cpMin, 
	long &cpMax, 
	long **ppHiddenTxtBlk, 
	long &cHiddenTxtBlk)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::BuildHiddenTxtBlks");

	long		cHiddenTxtBlkAlloc = 0;
	long		*pHiddenTxtBlk;
	long		cpCurrent = cpMin;
	long		cpNext;
	HRESULT		hResult;

	cHiddenTxtBlkAlloc = 20;
	pHiddenTxtBlk = (long *)PvAlloc(cHiddenTxtBlkAlloc * sizeof(long), GMEM_ZEROINIT);

	if (pHiddenTxtBlk)
	{
		pHiddenTxtBlk[0] = tomForward;
		while (cpCurrent < cpMax)
		{
			hResult = FindUnhiddenText(cpCurrent, cpMax, cpNext);
			if (!SUCCEEDED(hResult))
				break;

			if (cpNext >= cpMax)
				break;

			hResult = FindHiddenText(cpNext, cpMax, cpCurrent);
			if (!SUCCEEDED(hResult))
				break;

			Assert(cpCurrent > cpNext);

			// Save the hidden text block cp and length
			pHiddenTxtBlk[cHiddenTxtBlk] = cpNext;
			cpCurrent = min(cpCurrent, cpMax);
			pHiddenTxtBlk[cHiddenTxtBlk+1] = cpCurrent - cpNext;
			cHiddenTxtBlk += 2;
			if (cHiddenTxtBlk >= cHiddenTxtBlkAlloc)
			{
				cHiddenTxtBlkAlloc += 20;
				pHiddenTxtBlk = (long *)PvReAlloc(pHiddenTxtBlk, cHiddenTxtBlkAlloc * sizeof(long));

				if (!pHiddenTxtBlk)
					break;
			}
		}
	}
	*ppHiddenTxtBlk = pHiddenTxtBlk;
}

/*
 *	BOOL CUIM::CTFOpenStatus
 *
 *	@mfunc
 *		Get/Set current CTF open status
 *
 *	@rdesc
 *		For GetOpenStatus
 *			return 1 is Open, 0 if Close or fail
 *
 *		For SetOpenStatus
 *			return TRUE is set status without problem, FALSE if fail
 *
 */
BOOL CUIM::CTFOpenStatus(
	BOOL fGetOpenStatus,
	BOOL fOpen)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::CTFOpenStatus");

	HRESULT				hr;
	VARIANT				var;
	BOOL				fRet = FALSE;
	ITfCompartment		*pComp = NULL;
	ITfCompartmentMgr	*pCompMgr = NULL;


	hr = _pTextMsgFilter->_pTim->QueryInterface(IID_ITfCompartmentMgr, (void **)&pCompMgr);

	if (SUCCEEDED(hr))
	{
		Assert(pCompMgr);

		hr = pCompMgr->GetCompartment(GUID_COMPARTMENT_KEYBOARD_OPENCLOSE, &pComp);

		if (SUCCEEDED(hr))
		{
			Assert(pComp);

			VariantInit(&var);
			if (fGetOpenStatus)
			{
				if (pComp->GetValue(&var) == S_OK)
				{
					Assert(var.vt == VT_I4);
					fRet = var.lVal ? TRUE : FALSE ;
				}
			}
			else
			{
				var.vt = VT_I4;
				var.lVal = fOpen;
				hr = pComp->SetValue(_pTextMsgFilter->_tid, &var);
				fRet = SUCCEEDED(hr);
			}
			VariantClear(&var);
		}
	}

	if (pComp)
		pComp->Release();

	if (pCompMgr)
		pCompMgr->Release();

	return fRet;
}

/*
 *	BOOL CUIM::BuildObject
 *
 *	@mfunc
 *		Build an array of embedded objects
 *
 *	@rdesc
 *		return Number of objects in the array returned in pEmbeddObjects
 *
 */
int CUIM::BuildObject(
	ITextRange	*pTextRange, 
	BSTR		bstr, 
	EMBEDOBJECT **ppEmbeddObjects,
	int			cSize)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::BuildObject");

	long	cpMin;
	HRESULT hResult = pTextRange->GetStart(&cpMin);
	WCHAR	*pText = (WCHAR *)bstr;
	EMBEDOBJECT	*pEmbeddObjStart =  *ppEmbeddObjects;
	EMBEDOBJECT *pEmbeddObj = *ppEmbeddObjects;
	BOOL	fAllocateBuffer = FALSE;

	long	cObjects = 0;
	long	cchBstr = SysStringLen(bstr);

	if (hResult == S_OK)
	{
		for(long i = 0; i < cchBstr; i++, pText++)
		{
			if (*pText == WCH_EMBEDDING)
			{
				// Get IDataObject
				HRESULT hr;
				IDataObject *pIDataObj = NULL;
				BOOL fReadLockOld = _fReadLockOn;

				_fReadLockOn = TRUE;
				hr = GetEmbedded(cpMin+i, GUID_DCSERVICE_DATAOBJECT, IID_IDataObject, (IUnknown **)&pIDataObj);

				_fReadLockOn = fReadLockOld;
				// Store it in the memory
				if (cObjects < cSize)
				{
					pEmbeddObj->cpOffset = i;
					pEmbeddObj->pIDataObj = pIDataObj;
					pEmbeddObj++;
					cObjects++;
				}
				else
				{
					long cNewSize = cSize + 5;
					EMBEDOBJECT *pEmbeddObjTemp;
					if (fAllocateBuffer)
					{
						pEmbeddObjTemp = (EMBEDOBJECT *)PvReAlloc(pEmbeddObjStart, sizeof(EMBEDOBJECT) * cNewSize);

						if (pEmbeddObjTemp)
						{
							pEmbeddObjStart = pEmbeddObjTemp;
							pEmbeddObj = pEmbeddObjStart + cSize;
							cSize = cNewSize;
							pEmbeddObj->cpOffset = i;
							pEmbeddObj->pIDataObj = pIDataObj;
							pEmbeddObj++;
							cObjects++;
						}
						else
						{
							// Cleanup here
							pIDataObj->Release();
							break;
						}
					}
					else
					{
						fAllocateBuffer = TRUE;

						pEmbeddObjTemp = (EMBEDOBJECT *)PvAlloc(sizeof(EMBEDOBJECT) * cNewSize, GMEM_ZEROINIT);
						if (pEmbeddObjTemp)
						{
							if (cSize)
							{
								// Copy previous data to new buffer
								memcpy(pEmbeddObjTemp, pEmbeddObjStart, sizeof(EMBEDOBJECT) * cSize);
							}
							pEmbeddObjStart = pEmbeddObjTemp;
							pEmbeddObj = pEmbeddObjStart + cSize;
							cSize = cNewSize;
							pEmbeddObj->cpOffset = i;
							pEmbeddObj->pIDataObj = pIDataObj;
							pEmbeddObj++;
							cObjects++;
						}
						else
						{
							// Cleanup here
							pIDataObj->Release();
							break;
						}
					}
				}
			}
		}
	}

	*ppEmbeddObjects = pEmbeddObjStart;

	return cObjects;
}

/*
 *	BOOL CUIM::InsertTextandObject
 *
 *	@mfunc
 *		Insert text and embedded objects
 *
 */
void CUIM::InsertTextandObject(
	ITextRange	*pTextRange, 
	BSTR		bstr, 
	EMBEDOBJECT *pEmbeddObjects, 
	long		cEmbeddedObjects)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::InsertTextandObject");

	WCHAR	*pText = (WCHAR *)bstr;
	WCHAR	*pTextStart = pText;
	long	cObjects = 0;
	long	cchBstr = SysStringLen(bstr);
	HRESULT hr;

	for(long i = 0; i < cchBstr; i++, pText++)
	{
		if (*pText == WCH_EMBEDDING)
		{
			// Insert Text if necessary
			if (pTextStart != pText)
			{
				BSTR	bstr = SysAllocStringLen(pTextStart, pText-pTextStart);

				if (bstr)
				{
					hr = pTextRange->SetText(bstr);

					SysFreeString(bstr);
					pTextRange->Collapse(tomFalse);
				}
			}

			if (cObjects < cEmbeddedObjects)
			{
				LRESULT				lresult;
				long	cpMin = 0, cpMax = 0;
				HRESULT	hResult	= pTextRange->GetStart(&cpMin);
				hResult	= pTextRange->GetEnd(&cpMax);
				CHARRANGE	charRange = {cpMin, cpMax};

				hr = _pTextMsgFilter->_pTextService->TxSendMessage(EM_INSERTOBJ, (WPARAM)&charRange,
					(LPARAM)(pEmbeddObjects->pIDataObj), &lresult);

				hr = pTextRange->Move(tomCharacter, 1, NULL);	// move over the embedded char
				cObjects++;
				pEmbeddObjects++;
			}

			// Setup for next string after the embedded object
			pTextStart = pText + 1;
		}
	}

	// Insert last Text if necessary
	if (pTextStart != pText)
	{
		BSTR	bstr = SysAllocStringLen(pTextStart, pText-pTextStart);

		if (bstr)
		{
			hr = pTextRange->SetText(bstr);
			SysFreeString(bstr);
		}
	}
}

/*
 *	BOOL CUIM::CleanUpObjects
 *
 *	@mfunc
 *		Free the objects
 *
 */
void CUIM::CleanUpObjects(
	long cObjects,
	EMBEDOBJECT *pObjects)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::CleanUpObjects");

	for (long i = 0; i < cObjects; i++, pObjects++)
	{
		if (pObjects->pIDataObj)
			pObjects->pIDataObj->Release();
	}
}

/*
 *	void CUIM::CleanUpComposition
 *
 *	@mfunc
 *		Free the composition string and objects list
 *
 */
void CUIM::CleanUpComposition()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::CleanUpComposition");

	if (_bstrComposition)
	{
		SysFreeString (_bstrComposition);
		_bstrComposition = NULL;
	}

	_acpBstrStart = tomForward;
	if (_cObjects)
	{
		CleanUpObjects(_cObjects, _pObjects);
		delete _pObjects;
		_cObjects = 0;
		_pObjects = NULL;
	}
}

/*
 *	BOOL CUIM::HandleTempDispAttr
 *
 *	@mfunc
 *		This routine handle temp. display attribute that are set
 *	outside CTF composition.  It is using ITfContextRenderingMarkup
 *	to get the range and display data.
 *
 */
void CUIM::HandleTempDispAttr(
	ITfEditRecord *pEditRecord)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::HandleTempDispAttr");

	if (_pContextRenderingMarkup)
	{
		HRESULT hr;
		const GUID *rgGUID[1];
		IEnumTfRanges *pEnumRanges = NULL;

		// Get attribute changes
		rgGUID[0] = &GUID_PROP_ATTRIBUTE;
		hr = pEditRecord->GetTextAndPropertyUpdates(0, (const GUID**)rgGUID, 1, &pEnumRanges);
		if (SUCCEEDED(hr))
		{
			ITfRange	*pITfRange = NULL;

			while (pEnumRanges->Next(1, &pITfRange, NULL) == S_OK)
			{
				IEnumTfRenderingMarkup *pEnumMarkup;
				TF_RENDERINGMARKUP tfRenderingMarkup;
				long acpStartRange, cch;

				if (_pContextRenderingMarkup->GetRenderingMarkup(_editCookie, TF_GRM_INCLUDE_PROPERTY, pITfRange, &pEnumMarkup) == S_OK)
				{
					while (pEnumMarkup->Next(1, &tfRenderingMarkup, NULL) == S_OK)
					{
						HRESULT hResult;

						hResult = GetExtentAcpPrange(tfRenderingMarkup.pRange, acpStartRange, cch);
						if (hResult && cch > 0)
						{
							ITextRange *pTextRange = NULL;
							hResult = _pTextMsgFilter->_pTextDoc->Range(acpStartRange, acpStartRange+cch, &pTextRange);
							if (pTextRange)
							{
								ITextFont	*pFont = NULL;

								hResult = pTextRange->GetFont(&pFont);

								if (pFont)
								{
									long		lStyle;
									COLORREF	cr;

									_pTextMsgFilter->_pTextDoc->Undo(tomSuspend, NULL);

									TF_DISPLAYATTRIBUTE da = tfRenderingMarkup.tfDisplayAttr;

									pFont->Reset(tomApplyTmp);

									switch (da.lsStyle)
									{
										// case TFLS_SOLID:
										default:
											lStyle = da.fBoldLine ? tomThick : tomSingle;
											break;

										case TF_LS_DOT:
										case TF_LS_DASH:		// Dash line should show as dotted line
											lStyle = tomDotted;
											break;

										case TF_LS_SQUIGGLE:
											lStyle = tomWave;
											break;

										case TF_LS_NONE:
											lStyle = tomNone;
											break;
									}
									if (lStyle != tomNone)
									{
										pFont->SetUnderline(lStyle);

										if (GetUIMAttributeColor(&da.crLine, &cr))
											pFont->SetUnderline(cr | 0x0FF000000);
									}

									if (GetUIMAttributeColor(&da.crText, &cr))
										pFont->SetForeColor(cr);

									if (GetUIMAttributeColor(&da.crBk, &cr))
										pFont->SetBackColor(cr);

									pFont->Reset(tomApplyNow);
									pFont->Release();

									_pTextMsgFilter->_pTextDoc->Undo(tomResume, NULL);
								}
								pTextRange->Release();
							}
						}
					}
					pEnumMarkup->Release();
				}
				pITfRange->Release();
			}
		}

		if (pEnumRanges)
			pEnumRanges->Release();
	}
}

/*
 *	STDAPI	CUIM::QueryService(REFGUID guidService, REFIID riid, void **ppv)
 *
 *	@mfunc
 *		Handle ITfEnableService::QueryService. Cicero/tip call this interface to obtain
 *	IID_ITfEnableService i/f
 *
 *	@rdesc
 *		S_OK if service supported
 *
 */
STDAPI CUIM::QueryService(
	REFGUID guidService,
	REFIID riid,
	void **ppv)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::QueryService");

	if (ppv == NULL)
		return E_INVALIDARG;

	*ppv = NULL;

	// we support just one service
	if (!IsEqualGUID(guidService, GUID_SERVICE_TEXTSTORE))
		return E_NOINTERFACE;

	if (IsEqualIID(riid, IID_IServiceProvider))
	{
		*ppv = (IServiceProvider *)this;
	}
	else if (IsEqualIID(riid, IID_ITfEnableService))
	{
		*ppv = (ITfEnableService *)this;
	}

	if (*ppv == NULL)
		return E_NOINTERFACE;

	AddRef();

	return S_OK;
}

/*
 *	STDAPI	CUIM::IsEnabled(REFGUID rguidServiceCategory, CLSID clsidService, IUnknown *punkService, BOOL *pfOkToRun)
 *
 *	@mfunc
 *		Handle ITfEnableService::QueryService. Cicero/tip call this interface to check
 *	if we support the service
 *
 *	@rdesc
 *		S_OK if service supported
 *
 */
STDAPI CUIM::IsEnabled(
	REFGUID rguidServiceCategory,
	CLSID clsidService,
	IUnknown *punkService,
	BOOL *pfOkToRun)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::IsEnabled");
    
	if (pfOkToRun == NULL)
		return E_INVALIDARG;

	// default is disallow
	*pfOkToRun = FALSE;

	// clsidService identifies the particular tip, but we don't use it here
	// punkService is a custom interface, probably for config, but we don't use it here yet

	if (IsEqualGUID(rguidServiceCategory, GUID_TFCAT_TIP_SMARTTAG))
	{
		*pfOkToRun = _pTextMsgFilter->_fAllowSmartTag ? TRUE : FALSE;
	}
	else if (IsEqualGUID(rguidServiceCategory, GUID_TFCAT_TIP_PROOFING))
	{
		*pfOkToRun = _pTextMsgFilter->_fAllowProofing ? TRUE : FALSE;;
	}

	return S_OK;
}

/*
 *	STDAPI	CUIM::GetId(GUID *pguidId)
 *
 *	@mfunc
 *		get the RE clid
 *
 *	@rdesc
 *		S_OK
 *
 */
STDAPI CUIM::GetId(
	GUID *pguidId)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::GetId");
    
	if (pguidId == NULL)
        return E_INVALIDARG;

    *pguidId = CLSID_MSFTEDIT;
    return S_OK;
}

/*
 *	void	CUIM::NotifyService()
 *
 *	@mfunc
 *		Notify Cicero about change in services.
 *
 *
 */
void CUIM::NotifyService()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CUIM::NotifyService");

	ITfCompartmentMgr *pCompartmentMgr;
	ITfCompartment *pCompartment;
	VARIANT varValue;

	if (_pic->QueryInterface(IID_ITfCompartmentMgr, (void **)&pCompartmentMgr) != S_OK)
		return;

	// give any waiting tips a heads up we've changed our state
	if (pCompartmentMgr->GetCompartment(GUID_COMPARTMENT_ENABLESTATE, &pCompartment) == S_OK)
	{
		varValue.vt = VT_I4;
		varValue.lVal = 1; // arbitrary value, we just want to generate a change event

		pCompartment->SetValue(_pTextMsgFilter->_tid, &varValue);
		pCompartment->Release();
	}

	pCompartmentMgr->Release();
}

/*
 *	STDAPI CTextEditSink::QueryInterface
 *
 *	@mfunc
 *		IUnknown QueryInterface support
 *
 *	@rdesc
 *		NOERROR if interface supported
 *
 */
STDAPI CTextEditSink::QueryInterface(REFIID riid, void **ppvObj)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextEditSink::QueryInterface");

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_ITfTextEditSink))
    {
        *ppvObj = (CTextEditSink *)this;
    }

    if (*ppvObj)
    {
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

/*
 *	STDMETHODIMP_(ULONG) CTextEditSink::AddRef
 *
 *	@mfunc
 *		IUnknown AddRef support
 *
 *	@rdesc
 *		Reference count
 */
STDAPI_(ULONG) CTextEditSink::AddRef()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextEditSink::AddRef");

    return ++_cRef;
}


/*
 *	STDMETHODIMP_(ULONG) CTextEditSink::Release()
 *
 *	@mfunc
 *		IUnknown Release support - delete object when reference count is 0
 *
 *	@rdesc
 *		Reference count
 */
STDAPI_(ULONG) CTextEditSink::Release()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextEditSink::Release");

    long cr;

    cr = --_cRef;
    Assert(cr >= 0);

    if (cr == 0)
    {
        delete this;
    }

    return cr;
}

/*
 *	CTextEditSink::CTextEditSink()
 *
 *	@mfunc
 *
 *		ctor
 *
 */
CTextEditSink::CTextEditSink(PTESCALLBACK pfnCallback, void *pv)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextEditSink::CTextEditSink");

    _cRef = 1;
    _dwCookie = 0x0FFFFFFFF;

    _pfnCallback = pfnCallback;
    _pv = pv;
}

/*
 *	STDAPI CTextEditSink::OnEndEdit()
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
STDAPI CTextEditSink::OnEndEdit(
	ITfContext *pic,
	TfEditCookie ecReadOnly, 
	ITfEditRecord *pEditRecord)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextEditSink::OnEndEdit");

	return _pfnCallback(pEditRecord, _pv);
}

/*
 *	HRESULT CTextEditSink::_Advise
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
HRESULT CTextEditSink::_Advise(ITfContext *pic)
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextEditSink::_Advise");

    HRESULT hr;
    ITfSource *source = NULL;

    _pic = NULL;
    hr = E_FAIL;

    if (FAILED(pic->QueryInterface(IID_ITfSource, (void **)&source)))
        return E_FAIL;

    if (FAILED(source->AdviseSink(IID_ITfTextEditSink, this, &_dwCookie)))
        goto Exit;

    _pic = pic;
    _pic->AddRef();

    hr = S_OK;

Exit:
    source->Release();
    return hr;
}

/*
 *	HRESULT CTextEditSink::_Unadvise
 *
 *	@mfunc
 *
 *
 *	@rdesc
 *
 */
HRESULT CTextEditSink::_Unadvise()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CTextEditSink::_Unadvise");

    HRESULT hr;
    ITfSource *source = NULL;

    hr = E_FAIL;

    if (_pic == NULL)
        return E_FAIL;

    if (FAILED(_pic->QueryInterface(IID_ITfSource, (void **)&source)))
        return E_FAIL;

    if (FAILED(source->UnadviseSink(_dwCookie)))
        goto Exit;

    hr = S_OK;

Exit:
    source->Release();
    _pic->Release();
	_pic = NULL;
    return hr;
}

#endif	//	NOFEPROCESSING
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\dfreeze.cpp ===
/*	@doc INTERNAL
 *
 *	@module _DFREEZE.CPP  Implementation for classes handle freezing the display |
 *	
 *	This module implements non-inline members used by logic to handle freezing the display
 *
 *	History: <nl>
 *		2/8/96	ricksa	Created
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */
#include	"_common.h"
#include	"_disp.h"
#include	"_dfreeze.h"

ASSERTDATA

/*
 *	CAccumDisplayChanges::GetUpdateRegion(pcpStart, pcchDel, pcchNew,
 *										  pfUpdateCaret, pfScrollIntoView)
 *	@mfunc
 *		Get region for display to update
 */
void CAccumDisplayChanges::GetUpdateRegion(
	LONG *pcpStart,			//@parm where to put the cpStart
	LONG *pcchDel,			//@parm where to put the del char count
	LONG *pcchNew,			//@parm where to put the new char count
	BOOL *pfUpdateCaret,	//@parm whether caret update is needed
	BOOL *pfScrollIntoView,	//@parm whether to scroll caret into view
	BOOL *pfNeedRedisplay)	//@parm whether it needs redisplay
{
	LONG cchDel;
	*pcpStart = _cpMin;

	if(pfUpdateCaret)
		*pfUpdateCaret = _fUpdateCaret;
	if(pfScrollIntoView)
		*pfScrollIntoView = _fScrollIntoView;
	if (pfNeedRedisplay)
		*pfNeedRedisplay = _fNeedRedisplay;

	if(_cpMin == CP_INFINITE)
		return;

	cchDel = _cpMax - _cpMin;

	if(pcchDel)
		*pcchDel =  cchDel;

	*pcchNew = cchDel + _delta;

	_cpMin = CP_INFINITE;
}

/*
 *	CAccumDisplayChanges::UpdateRecalcRegion(cpStartNew, cchDel, cchNew)
 *
 *	@mfunc
 *		Merge new update with region to be recalculated
 */
void CAccumDisplayChanges::UpdateRecalcRegion(
	LONG cpStartNew,	//@parm Start of update
	LONG cchDel,		//@parm Count of chars to delete
	LONG cchNew)		//@parm Count of chars to add
{
	if(CP_INFINITE == _cpMin)
	{
		// Object is empty so just assign values
		_cpMin = cpStartNew;
		_cpMax = cpStartNew + cchDel;
		_delta = cchNew - cchDel;
		return;
	}

	// The basic idea of this algorithm is to merge the updates so that
	// they appear to the display sub-system as if only one replace range
	// has occured. To do this we keep track of the start of the update 
	// (_cpMin) relative to the original text and the end of the update 
	// (_cpMax) relative to the original text and the change  in the count 
	// of text (_delta). We can recreate cchDel from _cpMost - _cpMin and 
	// cchNew from cchDel + _delta.

	// Do we need to update _cpMin? - we only need to update _cpMin if the
	// current update begins before the last update because the final update
	// need only know the very start of the range updated.
	if(cpStartNew < _cpMin)
		_cpMin = cpStartNew;

	// Do we need to udpate _cpMax? - we only need to update _cpMax if the
	// current update implies a _cpMax that is greater than the current one.
	// Note that because prior updates affect where the _cpMax is located
	// we need to compare againt the proposed _cpMax against the current
	// _cpMax adjusted by the change in the text since the beginning of the
	// updates.
	if(cpStartNew + cchDel > _cpMax + _delta)
		_cpMax = cpStartNew + cchDel - _delta;

	// Increment the total change by the change for this update.
	_delta += cchNew - cchDel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\ctffunc.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for ctffunc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ctffunc_h__
#define __ctffunc_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ITfCandidateString_FWD_DEFINED__
#define __ITfCandidateString_FWD_DEFINED__
typedef interface ITfCandidateString ITfCandidateString;
#endif 	/* __ITfCandidateString_FWD_DEFINED__ */


#ifndef __IEnumTfCandidates_FWD_DEFINED__
#define __IEnumTfCandidates_FWD_DEFINED__
typedef interface IEnumTfCandidates IEnumTfCandidates;
#endif 	/* __IEnumTfCandidates_FWD_DEFINED__ */


#ifndef __ITfCandidateList_FWD_DEFINED__
#define __ITfCandidateList_FWD_DEFINED__
typedef interface ITfCandidateList ITfCandidateList;
#endif 	/* __ITfCandidateList_FWD_DEFINED__ */


#ifndef __ITfFnReconversion_FWD_DEFINED__
#define __ITfFnReconversion_FWD_DEFINED__
typedef interface ITfFnReconversion ITfFnReconversion;
#endif 	/* __ITfFnReconversion_FWD_DEFINED__ */


#ifndef __ITfFnAbort_FWD_DEFINED__
#define __ITfFnAbort_FWD_DEFINED__
typedef interface ITfFnAbort ITfFnAbort;
#endif 	/* __ITfFnAbort_FWD_DEFINED__ */


#ifndef __ITfFnPlayBack_FWD_DEFINED__
#define __ITfFnPlayBack_FWD_DEFINED__
typedef interface ITfFnPlayBack ITfFnPlayBack;
#endif 	/* __ITfFnPlayBack_FWD_DEFINED__ */


#ifndef __ITfFnLangProfileUtil_FWD_DEFINED__
#define __ITfFnLangProfileUtil_FWD_DEFINED__
typedef interface ITfFnLangProfileUtil ITfFnLangProfileUtil;
#endif 	/* __ITfFnLangProfileUtil_FWD_DEFINED__ */


#ifndef __ITfFnConfigure_FWD_DEFINED__
#define __ITfFnConfigure_FWD_DEFINED__
typedef interface ITfFnConfigure ITfFnConfigure;
#endif 	/* __ITfFnConfigure_FWD_DEFINED__ */


#ifndef __ITfFnConfigureRegisterWord_FWD_DEFINED__
#define __ITfFnConfigureRegisterWord_FWD_DEFINED__
typedef interface ITfFnConfigureRegisterWord ITfFnConfigureRegisterWord;
#endif 	/* __ITfFnConfigureRegisterWord_FWD_DEFINED__ */


#ifndef __ITfFnShowHelp_FWD_DEFINED__
#define __ITfFnShowHelp_FWD_DEFINED__
typedef interface ITfFnShowHelp ITfFnShowHelp;
#endif 	/* __ITfFnShowHelp_FWD_DEFINED__ */


#ifndef __ITfFnBalloon_FWD_DEFINED__
#define __ITfFnBalloon_FWD_DEFINED__
typedef interface ITfFnBalloon ITfFnBalloon;
#endif 	/* __ITfFnBalloon_FWD_DEFINED__ */


#ifndef __ITfFnGetSAPIObject_FWD_DEFINED__
#define __ITfFnGetSAPIObject_FWD_DEFINED__
typedef interface ITfFnGetSAPIObject ITfFnGetSAPIObject;
#endif 	/* __ITfFnGetSAPIObject_FWD_DEFINED__ */


#ifndef __ITfFnPropertyUIStatus_FWD_DEFINED__
#define __ITfFnPropertyUIStatus_FWD_DEFINED__
typedef interface ITfFnPropertyUIStatus ITfFnPropertyUIStatus;
#endif 	/* __ITfFnPropertyUIStatus_FWD_DEFINED__ */


#ifndef __ITfFnLMProcessor_FWD_DEFINED__
#define __ITfFnLMProcessor_FWD_DEFINED__
typedef interface ITfFnLMProcessor ITfFnLMProcessor;
#endif 	/* __ITfFnLMProcessor_FWD_DEFINED__ */


#ifndef __ITfFnLMInternal_FWD_DEFINED__
#define __ITfFnLMInternal_FWD_DEFINED__
typedef interface ITfFnLMInternal ITfFnLMInternal;
#endif 	/* __ITfFnLMInternal_FWD_DEFINED__ */


#ifndef __IEnumTfLatticeElements_FWD_DEFINED__
#define __IEnumTfLatticeElements_FWD_DEFINED__
typedef interface IEnumTfLatticeElements IEnumTfLatticeElements;
#endif 	/* __IEnumTfLatticeElements_FWD_DEFINED__ */


#ifndef __ITfLMLattice_FWD_DEFINED__
#define __ITfLMLattice_FWD_DEFINED__
typedef interface ITfLMLattice ITfLMLattice;
#endif 	/* __ITfLMLattice_FWD_DEFINED__ */


#ifndef __ITfFnAdviseText_FWD_DEFINED__
#define __ITfFnAdviseText_FWD_DEFINED__
typedef interface ITfFnAdviseText ITfFnAdviseText;
#endif 	/* __ITfFnAdviseText_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "msctf.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_ctffunc_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// ctffunc.h


// CTF Function interfaces.

//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#ifndef CTFFUNC_DEFINED
#define CTFFUNC_DEFINED

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#ifdef __cplusplus
}
#endif  /* __cplusplus */
#define TF_E_NOCONVERSION     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0600)
EXTERN_C const CLSID CLSID_SapiLayr;


extern RPC_IF_HANDLE __MIDL_itf_ctffunc_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ctffunc_0000_v0_0_s_ifspec;

#ifndef __ITfCandidateString_INTERFACE_DEFINED__
#define __ITfCandidateString_INTERFACE_DEFINED__

/* interface ITfCandidateString */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfCandidateString;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("581f317e-fd9d-443f-b972-ed00467c5d40")
    ITfCandidateString : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetString( 
            /* [out] */ BSTR *pbstr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndex( 
            /* [out] */ ULONG *pnIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfCandidateStringVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfCandidateString * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfCandidateString * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfCandidateString * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            ITfCandidateString * This,
            /* [out] */ BSTR *pbstr);
        
        HRESULT ( STDMETHODCALLTYPE *GetIndex )( 
            ITfCandidateString * This,
            /* [out] */ ULONG *pnIndex);
        
        END_INTERFACE
    } ITfCandidateStringVtbl;

    interface ITfCandidateString
    {
        CONST_VTBL struct ITfCandidateStringVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfCandidateString_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfCandidateString_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfCandidateString_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfCandidateString_GetString(This,pbstr)	\
    (This)->lpVtbl -> GetString(This,pbstr)

#define ITfCandidateString_GetIndex(This,pnIndex)	\
    (This)->lpVtbl -> GetIndex(This,pnIndex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfCandidateString_GetString_Proxy( 
    ITfCandidateString * This,
    /* [out] */ BSTR *pbstr);


void __RPC_STUB ITfCandidateString_GetString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCandidateString_GetIndex_Proxy( 
    ITfCandidateString * This,
    /* [out] */ ULONG *pnIndex);


void __RPC_STUB ITfCandidateString_GetIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfCandidateString_INTERFACE_DEFINED__ */


#ifndef __IEnumTfCandidates_INTERFACE_DEFINED__
#define __IEnumTfCandidates_INTERFACE_DEFINED__

/* interface IEnumTfCandidates */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfCandidates;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("defb1926-6c80-4ce8-87d4-d6b72b812bde")
    IEnumTfCandidates : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfCandidates **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfCandidateString **ppCand,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfCandidatesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfCandidates * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfCandidates * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfCandidates * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfCandidates * This,
            /* [out] */ IEnumTfCandidates **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfCandidates * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ ITfCandidateString **ppCand,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfCandidates * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfCandidates * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfCandidatesVtbl;

    interface IEnumTfCandidates
    {
        CONST_VTBL struct IEnumTfCandidatesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfCandidates_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfCandidates_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfCandidates_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfCandidates_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumTfCandidates_Next(This,ulCount,ppCand,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,ppCand,pcFetched)

#define IEnumTfCandidates_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfCandidates_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfCandidates_Clone_Proxy( 
    IEnumTfCandidates * This,
    /* [out] */ IEnumTfCandidates **ppEnum);


void __RPC_STUB IEnumTfCandidates_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfCandidates_Next_Proxy( 
    IEnumTfCandidates * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ ITfCandidateString **ppCand,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumTfCandidates_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfCandidates_Reset_Proxy( 
    IEnumTfCandidates * This);


void __RPC_STUB IEnumTfCandidates_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfCandidates_Skip_Proxy( 
    IEnumTfCandidates * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfCandidates_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfCandidates_INTERFACE_DEFINED__ */


#ifndef __ITfCandidateList_INTERFACE_DEFINED__
#define __ITfCandidateList_INTERFACE_DEFINED__

/* interface ITfCandidateList */
/* [unique][uuid][object] */ 

typedef /* [public][public][uuid] */  DECLSPEC_UUID("baa898f2-0207-4643-92ca-f3f7b0cf6f80") 
enum __MIDL_ITfCandidateList_0001
    {	CAND_FINALIZED	= 0,
	CAND_SELECTED	= 0x1,
	CAND_CANCELED	= 0x2
    } 	TfCandidateResult;


EXTERN_C const IID IID_ITfCandidateList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a3ad50fb-9bdb-49e3-a843-6c76520fbf5d")
    ITfCandidateList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumCandidates( 
            /* [out] */ IEnumTfCandidates **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidate( 
            /* [in] */ ULONG nIndex,
            /* [out] */ ITfCandidateString **ppCand) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateNum( 
            /* [out] */ ULONG *pnCnt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetResult( 
            /* [in] */ ULONG nIndex,
            /* [in] */ TfCandidateResult imcr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfCandidateListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfCandidateList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfCandidateList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfCandidateList * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumCandidates )( 
            ITfCandidateList * This,
            /* [out] */ IEnumTfCandidates **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidate )( 
            ITfCandidateList * This,
            /* [in] */ ULONG nIndex,
            /* [out] */ ITfCandidateString **ppCand);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateNum )( 
            ITfCandidateList * This,
            /* [out] */ ULONG *pnCnt);
        
        HRESULT ( STDMETHODCALLTYPE *SetResult )( 
            ITfCandidateList * This,
            /* [in] */ ULONG nIndex,
            /* [in] */ TfCandidateResult imcr);
        
        END_INTERFACE
    } ITfCandidateListVtbl;

    interface ITfCandidateList
    {
        CONST_VTBL struct ITfCandidateListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfCandidateList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfCandidateList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfCandidateList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfCandidateList_EnumCandidates(This,ppEnum)	\
    (This)->lpVtbl -> EnumCandidates(This,ppEnum)

#define ITfCandidateList_GetCandidate(This,nIndex,ppCand)	\
    (This)->lpVtbl -> GetCandidate(This,nIndex,ppCand)

#define ITfCandidateList_GetCandidateNum(This,pnCnt)	\
    (This)->lpVtbl -> GetCandidateNum(This,pnCnt)

#define ITfCandidateList_SetResult(This,nIndex,imcr)	\
    (This)->lpVtbl -> SetResult(This,nIndex,imcr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfCandidateList_EnumCandidates_Proxy( 
    ITfCandidateList * This,
    /* [out] */ IEnumTfCandidates **ppEnum);


void __RPC_STUB ITfCandidateList_EnumCandidates_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCandidateList_GetCandidate_Proxy( 
    ITfCandidateList * This,
    /* [in] */ ULONG nIndex,
    /* [out] */ ITfCandidateString **ppCand);


void __RPC_STUB ITfCandidateList_GetCandidate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCandidateList_GetCandidateNum_Proxy( 
    ITfCandidateList * This,
    /* [out] */ ULONG *pnCnt);


void __RPC_STUB ITfCandidateList_GetCandidateNum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfCandidateList_SetResult_Proxy( 
    ITfCandidateList * This,
    /* [in] */ ULONG nIndex,
    /* [in] */ TfCandidateResult imcr);


void __RPC_STUB ITfCandidateList_SetResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfCandidateList_INTERFACE_DEFINED__ */


#ifndef __ITfFnReconversion_INTERFACE_DEFINED__
#define __ITfFnReconversion_INTERFACE_DEFINED__

/* interface ITfFnReconversion */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnReconversion;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4cea93c0-0a58-11d3-8df0-00105a2799b5")
    ITfFnReconversion : public ITfFunction
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryRange( 
            /* [in] */ ITfRange *pRange,
            /* [unique][out][in] */ ITfRange **ppNewRange,
            /* [out] */ BOOL *pfConvertable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReconversion( 
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfCandidateList **ppCandList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reconvert( 
            /* [in] */ ITfRange *pRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnReconversionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnReconversion * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnReconversion * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnReconversion * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFnReconversion * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *QueryRange )( 
            ITfFnReconversion * This,
            /* [in] */ ITfRange *pRange,
            /* [unique][out][in] */ ITfRange **ppNewRange,
            /* [out] */ BOOL *pfConvertable);
        
        HRESULT ( STDMETHODCALLTYPE *GetReconversion )( 
            ITfFnReconversion * This,
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfCandidateList **ppCandList);
        
        HRESULT ( STDMETHODCALLTYPE *Reconvert )( 
            ITfFnReconversion * This,
            /* [in] */ ITfRange *pRange);
        
        END_INTERFACE
    } ITfFnReconversionVtbl;

    interface ITfFnReconversion
    {
        CONST_VTBL struct ITfFnReconversionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnReconversion_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnReconversion_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnReconversion_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnReconversion_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define ITfFnReconversion_QueryRange(This,pRange,ppNewRange,pfConvertable)	\
    (This)->lpVtbl -> QueryRange(This,pRange,ppNewRange,pfConvertable)

#define ITfFnReconversion_GetReconversion(This,pRange,ppCandList)	\
    (This)->lpVtbl -> GetReconversion(This,pRange,ppCandList)

#define ITfFnReconversion_Reconvert(This,pRange)	\
    (This)->lpVtbl -> Reconvert(This,pRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFnReconversion_QueryRange_Proxy( 
    ITfFnReconversion * This,
    /* [in] */ ITfRange *pRange,
    /* [unique][out][in] */ ITfRange **ppNewRange,
    /* [out] */ BOOL *pfConvertable);


void __RPC_STUB ITfFnReconversion_QueryRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfFnReconversion_GetReconversion_Proxy( 
    ITfFnReconversion * This,
    /* [in] */ ITfRange *pRange,
    /* [out] */ ITfCandidateList **ppCandList);


void __RPC_STUB ITfFnReconversion_GetReconversion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfFnReconversion_Reconvert_Proxy( 
    ITfFnReconversion * This,
    /* [in] */ ITfRange *pRange);


void __RPC_STUB ITfFnReconversion_Reconvert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnReconversion_INTERFACE_DEFINED__ */


#ifndef __ITfFnAbort_INTERFACE_DEFINED__
#define __ITfFnAbort_INTERFACE_DEFINED__

/* interface ITfFnAbort */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnAbort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("17f2317f-addb-49df-870e-66227bc51d1a")
    ITfFnAbort : public ITfFunction
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Abort( 
            /* [in] */ ITfContext *pic) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnAbortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnAbort * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnAbort * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnAbort * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFnAbort * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            ITfFnAbort * This,
            /* [in] */ ITfContext *pic);
        
        END_INTERFACE
    } ITfFnAbortVtbl;

    interface ITfFnAbort
    {
        CONST_VTBL struct ITfFnAbortVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnAbort_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnAbort_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnAbort_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnAbort_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define ITfFnAbort_Abort(This,pic)	\
    (This)->lpVtbl -> Abort(This,pic)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFnAbort_Abort_Proxy( 
    ITfFnAbort * This,
    /* [in] */ ITfContext *pic);


void __RPC_STUB ITfFnAbort_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnAbort_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_ctffunc_0219 */
/* [local] */ 

EXTERN_C const GUID GUID_COMPARTMENT_SAPI_AUDIO;
EXTERN_C const GUID GUID_COMPARTMENT_SPEECH_DICTATIONSTAT;
#define TF_DICTATION_ON          0x00000001
#define TF_DICTATION_ENABLED     0x00000002
#define TF_COMMANDING_ENABLED    0x00000004
#define TF_COMMANDING_ON         0x00000008

EXTERN_C const GUID GUID_COMPARTMENT_SPEECH_UI_STATUS;
#define TF_SHOW_BALLOON          0x00000001
#define TF_DISABLE_BALLOON       0x00000002
EXTERN_C const GUID GUID_COMPARTMENT_SPEECH_CFGMENU;
#define TF_MENUREADY          0x00000001
EXTERN_C const GUID GUID_LBI_SAPILAYR_CFGMENUBUTTON;



extern RPC_IF_HANDLE __MIDL_itf_ctffunc_0219_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ctffunc_0219_v0_0_s_ifspec;

#ifndef __ITfFnPlayBack_INTERFACE_DEFINED__
#define __ITfFnPlayBack_INTERFACE_DEFINED__

/* interface ITfFnPlayBack */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnPlayBack;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a3a416a4-0f64-11d3-b5b7-00c04fc324a1")
    ITfFnPlayBack : public ITfFunction
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryRange( 
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfRange **ppNewRange,
            /* [out] */ BOOL *pfPlayable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Play( 
            /* [in] */ ITfRange *pRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnPlayBackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnPlayBack * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnPlayBack * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnPlayBack * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFnPlayBack * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *QueryRange )( 
            ITfFnPlayBack * This,
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfRange **ppNewRange,
            /* [out] */ BOOL *pfPlayable);
        
        HRESULT ( STDMETHODCALLTYPE *Play )( 
            ITfFnPlayBack * This,
            /* [in] */ ITfRange *pRange);
        
        END_INTERFACE
    } ITfFnPlayBackVtbl;

    interface ITfFnPlayBack
    {
        CONST_VTBL struct ITfFnPlayBackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnPlayBack_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnPlayBack_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnPlayBack_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnPlayBack_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define ITfFnPlayBack_QueryRange(This,pRange,ppNewRange,pfPlayable)	\
    (This)->lpVtbl -> QueryRange(This,pRange,ppNewRange,pfPlayable)

#define ITfFnPlayBack_Play(This,pRange)	\
    (This)->lpVtbl -> Play(This,pRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFnPlayBack_QueryRange_Proxy( 
    ITfFnPlayBack * This,
    /* [in] */ ITfRange *pRange,
    /* [out] */ ITfRange **ppNewRange,
    /* [out] */ BOOL *pfPlayable);


void __RPC_STUB ITfFnPlayBack_QueryRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfFnPlayBack_Play_Proxy( 
    ITfFnPlayBack * This,
    /* [in] */ ITfRange *pRange);


void __RPC_STUB ITfFnPlayBack_Play_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnPlayBack_INTERFACE_DEFINED__ */


#ifndef __ITfFnLangProfileUtil_INTERFACE_DEFINED__
#define __ITfFnLangProfileUtil_INTERFACE_DEFINED__

/* interface ITfFnLangProfileUtil */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnLangProfileUtil;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A87A8574-A6C1-4E15-99F0-3D3965F548EB")
    ITfFnLangProfileUtil : public ITfFunction
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterActiveProfiles( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsProfileAvailableForLang( 
            /* [in] */ LANGID langid,
            /* [out] */ BOOL *pfAvailable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnLangProfileUtilVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnLangProfileUtil * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnLangProfileUtil * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnLangProfileUtil * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFnLangProfileUtil * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterActiveProfiles )( 
            ITfFnLangProfileUtil * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsProfileAvailableForLang )( 
            ITfFnLangProfileUtil * This,
            /* [in] */ LANGID langid,
            /* [out] */ BOOL *pfAvailable);
        
        END_INTERFACE
    } ITfFnLangProfileUtilVtbl;

    interface ITfFnLangProfileUtil
    {
        CONST_VTBL struct ITfFnLangProfileUtilVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnLangProfileUtil_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnLangProfileUtil_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnLangProfileUtil_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnLangProfileUtil_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define ITfFnLangProfileUtil_RegisterActiveProfiles(This)	\
    (This)->lpVtbl -> RegisterActiveProfiles(This)

#define ITfFnLangProfileUtil_IsProfileAvailableForLang(This,langid,pfAvailable)	\
    (This)->lpVtbl -> IsProfileAvailableForLang(This,langid,pfAvailable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFnLangProfileUtil_RegisterActiveProfiles_Proxy( 
    ITfFnLangProfileUtil * This);


void __RPC_STUB ITfFnLangProfileUtil_RegisterActiveProfiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfFnLangProfileUtil_IsProfileAvailableForLang_Proxy( 
    ITfFnLangProfileUtil * This,
    /* [in] */ LANGID langid,
    /* [out] */ BOOL *pfAvailable);


void __RPC_STUB ITfFnLangProfileUtil_IsProfileAvailableForLang_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnLangProfileUtil_INTERFACE_DEFINED__ */


#ifndef __ITfFnConfigure_INTERFACE_DEFINED__
#define __ITfFnConfigure_INTERFACE_DEFINED__

/* interface ITfFnConfigure */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnConfigure;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("88f567c6-1757-49f8-a1b2-89234c1eeff9")
    ITfFnConfigure : public ITfFunction
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Show( 
            /* [in] */ HWND hwndParent,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID rguidProfile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnConfigureVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnConfigure * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnConfigure * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnConfigure * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFnConfigure * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *Show )( 
            ITfFnConfigure * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID rguidProfile);
        
        END_INTERFACE
    } ITfFnConfigureVtbl;

    interface ITfFnConfigure
    {
        CONST_VTBL struct ITfFnConfigureVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnConfigure_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnConfigure_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnConfigure_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnConfigure_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define ITfFnConfigure_Show(This,hwndParent,langid,rguidProfile)	\
    (This)->lpVtbl -> Show(This,hwndParent,langid,rguidProfile)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFnConfigure_Show_Proxy( 
    ITfFnConfigure * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ LANGID langid,
    /* [in] */ REFGUID rguidProfile);


void __RPC_STUB ITfFnConfigure_Show_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnConfigure_INTERFACE_DEFINED__ */


#ifndef __ITfFnConfigureRegisterWord_INTERFACE_DEFINED__
#define __ITfFnConfigureRegisterWord_INTERFACE_DEFINED__

/* interface ITfFnConfigureRegisterWord */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnConfigureRegisterWord;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bb95808a-6d8f-4bca-8400-5390b586aedf")
    ITfFnConfigureRegisterWord : public ITfFunction
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Show( 
            /* [in] */ HWND hwndParent,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID rguidProfile,
            /* [unique][in] */ BSTR bstrRegistered) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnConfigureRegisterWordVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnConfigureRegisterWord * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnConfigureRegisterWord * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnConfigureRegisterWord * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFnConfigureRegisterWord * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *Show )( 
            ITfFnConfigureRegisterWord * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ LANGID langid,
            /* [in] */ REFGUID rguidProfile,
            /* [unique][in] */ BSTR bstrRegistered);
        
        END_INTERFACE
    } ITfFnConfigureRegisterWordVtbl;

    interface ITfFnConfigureRegisterWord
    {
        CONST_VTBL struct ITfFnConfigureRegisterWordVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnConfigureRegisterWord_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnConfigureRegisterWord_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnConfigureRegisterWord_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnConfigureRegisterWord_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define ITfFnConfigureRegisterWord_Show(This,hwndParent,langid,rguidProfile,bstrRegistered)	\
    (This)->lpVtbl -> Show(This,hwndParent,langid,rguidProfile,bstrRegistered)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFnConfigureRegisterWord_Show_Proxy( 
    ITfFnConfigureRegisterWord * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ LANGID langid,
    /* [in] */ REFGUID rguidProfile,
    /* [unique][in] */ BSTR bstrRegistered);


void __RPC_STUB ITfFnConfigureRegisterWord_Show_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnConfigureRegisterWord_INTERFACE_DEFINED__ */


#ifndef __ITfFnShowHelp_INTERFACE_DEFINED__
#define __ITfFnShowHelp_INTERFACE_DEFINED__

/* interface ITfFnShowHelp */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnShowHelp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AB1D30C-094D-4C29-8EA5-0BF59BE87BF3")
    ITfFnShowHelp : public ITfFunction
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Show( 
            /* [in] */ HWND hwndParent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnShowHelpVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnShowHelp * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnShowHelp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnShowHelp * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFnShowHelp * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *Show )( 
            ITfFnShowHelp * This,
            /* [in] */ HWND hwndParent);
        
        END_INTERFACE
    } ITfFnShowHelpVtbl;

    interface ITfFnShowHelp
    {
        CONST_VTBL struct ITfFnShowHelpVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnShowHelp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnShowHelp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnShowHelp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnShowHelp_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define ITfFnShowHelp_Show(This,hwndParent)	\
    (This)->lpVtbl -> Show(This,hwndParent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFnShowHelp_Show_Proxy( 
    ITfFnShowHelp * This,
    /* [in] */ HWND hwndParent);


void __RPC_STUB ITfFnShowHelp_Show_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnShowHelp_INTERFACE_DEFINED__ */


#ifndef __ITfFnBalloon_INTERFACE_DEFINED__
#define __ITfFnBalloon_INTERFACE_DEFINED__

/* interface ITfFnBalloon */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnBalloon;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3BAB89E4-5FBE-45F4-A5BC-DCA36AD225A8")
    ITfFnBalloon : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE UpdateBalloon( 
            /* [in] */ TfLBBalloonStyle style,
            /* [size_is][in] */ const WCHAR *pch,
            /* [in] */ ULONG cch) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnBalloonVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnBalloon * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnBalloon * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnBalloon * This);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateBalloon )( 
            ITfFnBalloon * This,
            /* [in] */ TfLBBalloonStyle style,
            /* [size_is][in] */ const WCHAR *pch,
            /* [in] */ ULONG cch);
        
        END_INTERFACE
    } ITfFnBalloonVtbl;

    interface ITfFnBalloon
    {
        CONST_VTBL struct ITfFnBalloonVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnBalloon_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnBalloon_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnBalloon_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnBalloon_UpdateBalloon(This,style,pch,cch)	\
    (This)->lpVtbl -> UpdateBalloon(This,style,pch,cch)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFnBalloon_UpdateBalloon_Proxy( 
    ITfFnBalloon * This,
    /* [in] */ TfLBBalloonStyle style,
    /* [size_is][in] */ const WCHAR *pch,
    /* [in] */ ULONG cch);


void __RPC_STUB ITfFnBalloon_UpdateBalloon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnBalloon_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_ctffunc_0225 */
/* [local] */ 

typedef /* [public][public][uuid] */  DECLSPEC_UUID("36adb6d9-da1f-45d8-a499-86167e0f936b") 
enum __MIDL___MIDL_itf_ctffunc_0225_0001
    {	GETIF_RESMGR	= 0,
	GETIF_RECOCONTEXT	= 0x1,
	GETIF_RECOGNIZER	= 0x2,
	GETIF_VOICE	= 0x3,
	GETIF_DICTGRAM	= 0x4,
	GETIF_RECOGNIZERNOINIT	= 0x5
    } 	TfSapiObject;



extern RPC_IF_HANDLE __MIDL_itf_ctffunc_0225_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ctffunc_0225_v0_0_s_ifspec;

#ifndef __ITfFnGetSAPIObject_INTERFACE_DEFINED__
#define __ITfFnGetSAPIObject_INTERFACE_DEFINED__

/* interface ITfFnGetSAPIObject */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnGetSAPIObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5c0ab7ea-167d-4f59-bfb5-4693755e90ca")
    ITfFnGetSAPIObject : public ITfFunction
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ TfSapiObject sObj,
            /* [out] */ IUnknown **ppunk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnGetSAPIObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnGetSAPIObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnGetSAPIObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnGetSAPIObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFnGetSAPIObject * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *Get )( 
            ITfFnGetSAPIObject * This,
            /* [in] */ TfSapiObject sObj,
            /* [out] */ IUnknown **ppunk);
        
        END_INTERFACE
    } ITfFnGetSAPIObjectVtbl;

    interface ITfFnGetSAPIObject
    {
        CONST_VTBL struct ITfFnGetSAPIObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnGetSAPIObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnGetSAPIObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnGetSAPIObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnGetSAPIObject_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define ITfFnGetSAPIObject_Get(This,sObj,ppunk)	\
    (This)->lpVtbl -> Get(This,sObj,ppunk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFnGetSAPIObject_Get_Proxy( 
    ITfFnGetSAPIObject * This,
    /* [in] */ TfSapiObject sObj,
    /* [out] */ IUnknown **ppunk);


void __RPC_STUB ITfFnGetSAPIObject_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnGetSAPIObject_INTERFACE_DEFINED__ */


#ifndef __ITfFnPropertyUIStatus_INTERFACE_DEFINED__
#define __ITfFnPropertyUIStatus_INTERFACE_DEFINED__

/* interface ITfFnPropertyUIStatus */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnPropertyUIStatus;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2338AC6E-2B9D-44C0-A75E-EE64F256B3BD")
    ITfFnPropertyUIStatus : public ITfFunction
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [in] */ REFGUID refguidProp,
            /* [out] */ DWORD *pdw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ REFGUID refguidProp,
            /* [in] */ DWORD dw) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnPropertyUIStatusVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnPropertyUIStatus * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnPropertyUIStatus * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnPropertyUIStatus * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFnPropertyUIStatus * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            ITfFnPropertyUIStatus * This,
            /* [in] */ REFGUID refguidProp,
            /* [out] */ DWORD *pdw);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            ITfFnPropertyUIStatus * This,
            /* [in] */ REFGUID refguidProp,
            /* [in] */ DWORD dw);
        
        END_INTERFACE
    } ITfFnPropertyUIStatusVtbl;

    interface ITfFnPropertyUIStatus
    {
        CONST_VTBL struct ITfFnPropertyUIStatusVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnPropertyUIStatus_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnPropertyUIStatus_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnPropertyUIStatus_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnPropertyUIStatus_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define ITfFnPropertyUIStatus_GetStatus(This,refguidProp,pdw)	\
    (This)->lpVtbl -> GetStatus(This,refguidProp,pdw)

#define ITfFnPropertyUIStatus_SetStatus(This,refguidProp,dw)	\
    (This)->lpVtbl -> SetStatus(This,refguidProp,dw)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFnPropertyUIStatus_GetStatus_Proxy( 
    ITfFnPropertyUIStatus * This,
    /* [in] */ REFGUID refguidProp,
    /* [out] */ DWORD *pdw);


void __RPC_STUB ITfFnPropertyUIStatus_GetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfFnPropertyUIStatus_SetStatus_Proxy( 
    ITfFnPropertyUIStatus * This,
    /* [in] */ REFGUID refguidProp,
    /* [in] */ DWORD dw);


void __RPC_STUB ITfFnPropertyUIStatus_SetStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnPropertyUIStatus_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_ctffunc_0227 */
/* [local] */ 


#define TF_PROPUI_STATUS_SAVETOFILE  0x00000001

EXTERN_C const GUID GUID_TFCAT_TIP_MASTERLM;
EXTERN_C const GUID GUID_MASTERLM_FUNCTIONPROVIDER;
EXTERN_C const GUID GUID_LMLATTICE_CICERO_VER1_0;
EXTERN_C const GUID GUID_PROP_LMLATTICE;


extern RPC_IF_HANDLE __MIDL_itf_ctffunc_0227_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ctffunc_0227_v0_0_s_ifspec;

#ifndef __ITfFnLMProcessor_INTERFACE_DEFINED__
#define __ITfFnLMProcessor_INTERFACE_DEFINED__

/* interface ITfFnLMProcessor */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnLMProcessor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7AFBF8E7-AC4B-4082-B058-890899D3A010")
    ITfFnLMProcessor : public ITfFunction
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryRange( 
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfRange **ppNewRange,
            /* [out] */ BOOL *pfAccepted) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryLangID( 
            /* [in] */ LANGID langid,
            /* [out] */ BOOL *pfAccepted) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReconversion( 
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfCandidateList **ppCandList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reconvert( 
            /* [in] */ ITfRange *pRange) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryKey( 
            /* [in] */ BOOL fUp,
            /* [in] */ WPARAM vKey,
            /* [in] */ LPARAM lparamKeydata,
            /* [out] */ BOOL *pfInterested) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvokeKey( 
            /* [in] */ BOOL fUp,
            /* [in] */ WPARAM vKey,
            /* [in] */ LPARAM lparamKeyData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvokeFunc( 
            /* [in] */ ITfContext *pic,
            /* [in] */ REFGUID refguidFunc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnLMProcessorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnLMProcessor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnLMProcessor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnLMProcessor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFnLMProcessor * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *QueryRange )( 
            ITfFnLMProcessor * This,
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfRange **ppNewRange,
            /* [out] */ BOOL *pfAccepted);
        
        HRESULT ( STDMETHODCALLTYPE *QueryLangID )( 
            ITfFnLMProcessor * This,
            /* [in] */ LANGID langid,
            /* [out] */ BOOL *pfAccepted);
        
        HRESULT ( STDMETHODCALLTYPE *GetReconversion )( 
            ITfFnLMProcessor * This,
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfCandidateList **ppCandList);
        
        HRESULT ( STDMETHODCALLTYPE *Reconvert )( 
            ITfFnLMProcessor * This,
            /* [in] */ ITfRange *pRange);
        
        HRESULT ( STDMETHODCALLTYPE *QueryKey )( 
            ITfFnLMProcessor * This,
            /* [in] */ BOOL fUp,
            /* [in] */ WPARAM vKey,
            /* [in] */ LPARAM lparamKeydata,
            /* [out] */ BOOL *pfInterested);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeKey )( 
            ITfFnLMProcessor * This,
            /* [in] */ BOOL fUp,
            /* [in] */ WPARAM vKey,
            /* [in] */ LPARAM lparamKeyData);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeFunc )( 
            ITfFnLMProcessor * This,
            /* [in] */ ITfContext *pic,
            /* [in] */ REFGUID refguidFunc);
        
        END_INTERFACE
    } ITfFnLMProcessorVtbl;

    interface ITfFnLMProcessor
    {
        CONST_VTBL struct ITfFnLMProcessorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnLMProcessor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnLMProcessor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnLMProcessor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnLMProcessor_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define ITfFnLMProcessor_QueryRange(This,pRange,ppNewRange,pfAccepted)	\
    (This)->lpVtbl -> QueryRange(This,pRange,ppNewRange,pfAccepted)

#define ITfFnLMProcessor_QueryLangID(This,langid,pfAccepted)	\
    (This)->lpVtbl -> QueryLangID(This,langid,pfAccepted)

#define ITfFnLMProcessor_GetReconversion(This,pRange,ppCandList)	\
    (This)->lpVtbl -> GetReconversion(This,pRange,ppCandList)

#define ITfFnLMProcessor_Reconvert(This,pRange)	\
    (This)->lpVtbl -> Reconvert(This,pRange)

#define ITfFnLMProcessor_QueryKey(This,fUp,vKey,lparamKeydata,pfInterested)	\
    (This)->lpVtbl -> QueryKey(This,fUp,vKey,lparamKeydata,pfInterested)

#define ITfFnLMProcessor_InvokeKey(This,fUp,vKey,lparamKeyData)	\
    (This)->lpVtbl -> InvokeKey(This,fUp,vKey,lparamKeyData)

#define ITfFnLMProcessor_InvokeFunc(This,pic,refguidFunc)	\
    (This)->lpVtbl -> InvokeFunc(This,pic,refguidFunc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFnLMProcessor_QueryRange_Proxy( 
    ITfFnLMProcessor * This,
    /* [in] */ ITfRange *pRange,
    /* [out] */ ITfRange **ppNewRange,
    /* [out] */ BOOL *pfAccepted);


void __RPC_STUB ITfFnLMProcessor_QueryRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfFnLMProcessor_QueryLangID_Proxy( 
    ITfFnLMProcessor * This,
    /* [in] */ LANGID langid,
    /* [out] */ BOOL *pfAccepted);


void __RPC_STUB ITfFnLMProcessor_QueryLangID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfFnLMProcessor_GetReconversion_Proxy( 
    ITfFnLMProcessor * This,
    /* [in] */ ITfRange *pRange,
    /* [out] */ ITfCandidateList **ppCandList);


void __RPC_STUB ITfFnLMProcessor_GetReconversion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfFnLMProcessor_Reconvert_Proxy( 
    ITfFnLMProcessor * This,
    /* [in] */ ITfRange *pRange);


void __RPC_STUB ITfFnLMProcessor_Reconvert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfFnLMProcessor_QueryKey_Proxy( 
    ITfFnLMProcessor * This,
    /* [in] */ BOOL fUp,
    /* [in] */ WPARAM vKey,
    /* [in] */ LPARAM lparamKeydata,
    /* [out] */ BOOL *pfInterested);


void __RPC_STUB ITfFnLMProcessor_QueryKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfFnLMProcessor_InvokeKey_Proxy( 
    ITfFnLMProcessor * This,
    /* [in] */ BOOL fUp,
    /* [in] */ WPARAM vKey,
    /* [in] */ LPARAM lparamKeyData);


void __RPC_STUB ITfFnLMProcessor_InvokeKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfFnLMProcessor_InvokeFunc_Proxy( 
    ITfFnLMProcessor * This,
    /* [in] */ ITfContext *pic,
    /* [in] */ REFGUID refguidFunc);


void __RPC_STUB ITfFnLMProcessor_InvokeFunc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnLMProcessor_INTERFACE_DEFINED__ */


#ifndef __ITfFnLMInternal_INTERFACE_DEFINED__
#define __ITfFnLMInternal_INTERFACE_DEFINED__

/* interface ITfFnLMInternal */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnLMInternal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("04B825B1-AC9A-4F7B-B5AD-C7168F1EE445")
    ITfFnLMInternal : public ITfFnLMProcessor
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ProcessLattice( 
            /* [in] */ ITfRange *pRange) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnLMInternalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnLMInternal * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnLMInternal * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnLMInternal * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFnLMInternal * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *QueryRange )( 
            ITfFnLMInternal * This,
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfRange **ppNewRange,
            /* [out] */ BOOL *pfAccepted);
        
        HRESULT ( STDMETHODCALLTYPE *QueryLangID )( 
            ITfFnLMInternal * This,
            /* [in] */ LANGID langid,
            /* [out] */ BOOL *pfAccepted);
        
        HRESULT ( STDMETHODCALLTYPE *GetReconversion )( 
            ITfFnLMInternal * This,
            /* [in] */ ITfRange *pRange,
            /* [out] */ ITfCandidateList **ppCandList);
        
        HRESULT ( STDMETHODCALLTYPE *Reconvert )( 
            ITfFnLMInternal * This,
            /* [in] */ ITfRange *pRange);
        
        HRESULT ( STDMETHODCALLTYPE *QueryKey )( 
            ITfFnLMInternal * This,
            /* [in] */ BOOL fUp,
            /* [in] */ WPARAM vKey,
            /* [in] */ LPARAM lparamKeydata,
            /* [out] */ BOOL *pfInterested);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeKey )( 
            ITfFnLMInternal * This,
            /* [in] */ BOOL fUp,
            /* [in] */ WPARAM vKey,
            /* [in] */ LPARAM lparamKeyData);
        
        HRESULT ( STDMETHODCALLTYPE *InvokeFunc )( 
            ITfFnLMInternal * This,
            /* [in] */ ITfContext *pic,
            /* [in] */ REFGUID refguidFunc);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessLattice )( 
            ITfFnLMInternal * This,
            /* [in] */ ITfRange *pRange);
        
        END_INTERFACE
    } ITfFnLMInternalVtbl;

    interface ITfFnLMInternal
    {
        CONST_VTBL struct ITfFnLMInternalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnLMInternal_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnLMInternal_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnLMInternal_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnLMInternal_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define ITfFnLMInternal_QueryRange(This,pRange,ppNewRange,pfAccepted)	\
    (This)->lpVtbl -> QueryRange(This,pRange,ppNewRange,pfAccepted)

#define ITfFnLMInternal_QueryLangID(This,langid,pfAccepted)	\
    (This)->lpVtbl -> QueryLangID(This,langid,pfAccepted)

#define ITfFnLMInternal_GetReconversion(This,pRange,ppCandList)	\
    (This)->lpVtbl -> GetReconversion(This,pRange,ppCandList)

#define ITfFnLMInternal_Reconvert(This,pRange)	\
    (This)->lpVtbl -> Reconvert(This,pRange)

#define ITfFnLMInternal_QueryKey(This,fUp,vKey,lparamKeydata,pfInterested)	\
    (This)->lpVtbl -> QueryKey(This,fUp,vKey,lparamKeydata,pfInterested)

#define ITfFnLMInternal_InvokeKey(This,fUp,vKey,lparamKeyData)	\
    (This)->lpVtbl -> InvokeKey(This,fUp,vKey,lparamKeyData)

#define ITfFnLMInternal_InvokeFunc(This,pic,refguidFunc)	\
    (This)->lpVtbl -> InvokeFunc(This,pic,refguidFunc)


#define ITfFnLMInternal_ProcessLattice(This,pRange)	\
    (This)->lpVtbl -> ProcessLattice(This,pRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFnLMInternal_ProcessLattice_Proxy( 
    ITfFnLMInternal * This,
    /* [in] */ ITfRange *pRange);


void __RPC_STUB ITfFnLMInternal_ProcessLattice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnLMInternal_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_ctffunc_0229 */
/* [local] */ 

typedef /* [uuid] */  DECLSPEC_UUID("1b646efe-3ce3-4ce2-b41f-35b93fe5552f") struct TF_LMLATTELEMENT
    {
    DWORD dwFrameStart;
    DWORD dwFrameLen;
    DWORD dwFlags;
    /* [switch_is][switch_type] */ union 
        {
        /* [case()] */ INT iCost;
        } 	;
    BSTR bstrText;
    } 	TF_LMLATTELEMENT;



extern RPC_IF_HANDLE __MIDL_itf_ctffunc_0229_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ctffunc_0229_v0_0_s_ifspec;

#ifndef __IEnumTfLatticeElements_INTERFACE_DEFINED__
#define __IEnumTfLatticeElements_INTERFACE_DEFINED__

/* interface IEnumTfLatticeElements */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumTfLatticeElements;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56988052-47DA-4A05-911A-E3D941F17145")
    IEnumTfLatticeElements : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTfLatticeElements **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_LMLATTELEMENT *rgsElements,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTfLatticeElementsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTfLatticeElements * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTfLatticeElements * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTfLatticeElements * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTfLatticeElements * This,
            /* [out] */ IEnumTfLatticeElements **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTfLatticeElements * This,
            /* [in] */ ULONG ulCount,
            /* [length_is][size_is][out] */ TF_LMLATTELEMENT *rgsElements,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTfLatticeElements * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTfLatticeElements * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumTfLatticeElementsVtbl;

    interface IEnumTfLatticeElements
    {
        CONST_VTBL struct IEnumTfLatticeElementsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTfLatticeElements_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTfLatticeElements_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTfLatticeElements_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTfLatticeElements_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumTfLatticeElements_Next(This,ulCount,rgsElements,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgsElements,pcFetched)

#define IEnumTfLatticeElements_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTfLatticeElements_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumTfLatticeElements_Clone_Proxy( 
    IEnumTfLatticeElements * This,
    /* [out] */ IEnumTfLatticeElements **ppEnum);


void __RPC_STUB IEnumTfLatticeElements_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfLatticeElements_Next_Proxy( 
    IEnumTfLatticeElements * This,
    /* [in] */ ULONG ulCount,
    /* [length_is][size_is][out] */ TF_LMLATTELEMENT *rgsElements,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumTfLatticeElements_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfLatticeElements_Reset_Proxy( 
    IEnumTfLatticeElements * This);


void __RPC_STUB IEnumTfLatticeElements_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumTfLatticeElements_Skip_Proxy( 
    IEnumTfLatticeElements * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumTfLatticeElements_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTfLatticeElements_INTERFACE_DEFINED__ */


#ifndef __ITfLMLattice_INTERFACE_DEFINED__
#define __ITfLMLattice_INTERFACE_DEFINED__

/* interface ITfLMLattice */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfLMLattice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D4236675-A5BF-4570-9D42-5D6D7B02D59B")
    ITfLMLattice : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryType( 
            /* [in] */ REFGUID rguidType,
            /* [out] */ BOOL *pfSupported) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumLatticeElements( 
            /* [in] */ DWORD dwFrameStart,
            /* [in] */ REFGUID rguidType,
            /* [out] */ IEnumTfLatticeElements **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfLMLatticeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfLMLattice * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfLMLattice * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfLMLattice * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryType )( 
            ITfLMLattice * This,
            /* [in] */ REFGUID rguidType,
            /* [out] */ BOOL *pfSupported);
        
        HRESULT ( STDMETHODCALLTYPE *EnumLatticeElements )( 
            ITfLMLattice * This,
            /* [in] */ DWORD dwFrameStart,
            /* [in] */ REFGUID rguidType,
            /* [out] */ IEnumTfLatticeElements **ppEnum);
        
        END_INTERFACE
    } ITfLMLatticeVtbl;

    interface ITfLMLattice
    {
        CONST_VTBL struct ITfLMLatticeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfLMLattice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfLMLattice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfLMLattice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfLMLattice_QueryType(This,rguidType,pfSupported)	\
    (This)->lpVtbl -> QueryType(This,rguidType,pfSupported)

#define ITfLMLattice_EnumLatticeElements(This,dwFrameStart,rguidType,ppEnum)	\
    (This)->lpVtbl -> EnumLatticeElements(This,dwFrameStart,rguidType,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfLMLattice_QueryType_Proxy( 
    ITfLMLattice * This,
    /* [in] */ REFGUID rguidType,
    /* [out] */ BOOL *pfSupported);


void __RPC_STUB ITfLMLattice_QueryType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfLMLattice_EnumLatticeElements_Proxy( 
    ITfLMLattice * This,
    /* [in] */ DWORD dwFrameStart,
    /* [in] */ REFGUID rguidType,
    /* [out] */ IEnumTfLatticeElements **ppEnum);


void __RPC_STUB ITfLMLattice_EnumLatticeElements_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfLMLattice_INTERFACE_DEFINED__ */


#ifndef __ITfFnAdviseText_INTERFACE_DEFINED__
#define __ITfFnAdviseText_INTERFACE_DEFINED__

/* interface ITfFnAdviseText */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfFnAdviseText;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3527268B-7D53-4DD9-92B7-7296AE461249")
    ITfFnAdviseText : public ITfFunction
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnTextUpdate( 
            /* [in] */ ITfRange *pRange,
            /* [size_is][in] */ const WCHAR *pchText,
            /* [in] */ LONG cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnLatticeUpdate( 
            /* [in] */ ITfRange *pRange,
            /* [in] */ ITfLMLattice *pLattice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfFnAdviseTextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITfFnAdviseText * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITfFnAdviseText * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITfFnAdviseText * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ITfFnAdviseText * This,
            /* [out] */ BSTR *pbstrName);
        
        HRESULT ( STDMETHODCALLTYPE *OnTextUpdate )( 
            ITfFnAdviseText * This,
            /* [in] */ ITfRange *pRange,
            /* [size_is][in] */ const WCHAR *pchText,
            /* [in] */ LONG cch);
        
        HRESULT ( STDMETHODCALLTYPE *OnLatticeUpdate )( 
            ITfFnAdviseText * This,
            /* [in] */ ITfRange *pRange,
            /* [in] */ ITfLMLattice *pLattice);
        
        END_INTERFACE
    } ITfFnAdviseTextVtbl;

    interface ITfFnAdviseText
    {
        CONST_VTBL struct ITfFnAdviseTextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfFnAdviseText_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITfFnAdviseText_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITfFnAdviseText_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITfFnAdviseText_GetDisplayName(This,pbstrName)	\
    (This)->lpVtbl -> GetDisplayName(This,pbstrName)


#define ITfFnAdviseText_OnTextUpdate(This,pRange,pchText,cch)	\
    (This)->lpVtbl -> OnTextUpdate(This,pRange,pchText,cch)

#define ITfFnAdviseText_OnLatticeUpdate(This,pRange,pLattice)	\
    (This)->lpVtbl -> OnLatticeUpdate(This,pRange,pLattice)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITfFnAdviseText_OnTextUpdate_Proxy( 
    ITfFnAdviseText * This,
    /* [in] */ ITfRange *pRange,
    /* [size_is][in] */ const WCHAR *pchText,
    /* [in] */ LONG cch);


void __RPC_STUB ITfFnAdviseText_OnTextUpdate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITfFnAdviseText_OnLatticeUpdate_Proxy( 
    ITfFnAdviseText * This,
    /* [in] */ ITfRange *pRange,
    /* [in] */ ITfLMLattice *pLattice);


void __RPC_STUB ITfFnAdviseText_OnLatticeUpdate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITfFnAdviseText_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_ctffunc_0232 */
/* [local] */ 

#endif // CTFFUNC_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_ctffunc_0232_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ctffunc_0232_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\ctffunc_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for ctffunc.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ITfCandidateString,0x581f317e,0xfd9d,0x443f,0xb9,0x72,0xed,0x00,0x46,0x7c,0x5d,0x40);


MIDL_DEFINE_GUID(IID, IID_IEnumTfCandidates,0xdefb1926,0x6c80,0x4ce8,0x87,0xd4,0xd6,0xb7,0x2b,0x81,0x2b,0xde);


MIDL_DEFINE_GUID(IID, IID_ITfCandidateList,0xa3ad50fb,0x9bdb,0x49e3,0xa8,0x43,0x6c,0x76,0x52,0x0f,0xbf,0x5d);


MIDL_DEFINE_GUID(IID, IID_ITfFnReconversion,0x4cea93c0,0x0a58,0x11d3,0x8d,0xf0,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_ITfFnAbort,0x17f2317f,0xaddb,0x49df,0x87,0x0e,0x66,0x22,0x7b,0xc5,0x1d,0x1a);


MIDL_DEFINE_GUID(IID, IID_ITfFnPlayBack,0xa3a416a4,0x0f64,0x11d3,0xb5,0xb7,0x00,0xc0,0x4f,0xc3,0x24,0xa1);


MIDL_DEFINE_GUID(IID, IID_ITfFnLangProfileUtil,0xA87A8574,0xA6C1,0x4E15,0x99,0xF0,0x3D,0x39,0x65,0xF5,0x48,0xEB);


MIDL_DEFINE_GUID(IID, IID_ITfFnConfigure,0x88f567c6,0x1757,0x49f8,0xa1,0xb2,0x89,0x23,0x4c,0x1e,0xef,0xf9);


MIDL_DEFINE_GUID(IID, IID_ITfFnConfigureRegisterWord,0xbb95808a,0x6d8f,0x4bca,0x84,0x00,0x53,0x90,0xb5,0x86,0xae,0xdf);


MIDL_DEFINE_GUID(IID, IID_ITfFnShowHelp,0x5AB1D30C,0x094D,0x4C29,0x8E,0xA5,0x0B,0xF5,0x9B,0xE8,0x7B,0xF3);


MIDL_DEFINE_GUID(IID, IID_ITfFnBalloon,0x3BAB89E4,0x5FBE,0x45F4,0xA5,0xBC,0xDC,0xA3,0x6A,0xD2,0x25,0xA8);


MIDL_DEFINE_GUID(IID, IID_ITfFnGetSAPIObject,0x5c0ab7ea,0x167d,0x4f59,0xbf,0xb5,0x46,0x93,0x75,0x5e,0x90,0xca);


MIDL_DEFINE_GUID(IID, IID_ITfFnPropertyUIStatus,0x2338AC6E,0x2B9D,0x44C0,0xA7,0x5E,0xEE,0x64,0xF2,0x56,0xB3,0xBD);


MIDL_DEFINE_GUID(IID, IID_ITfFnLMProcessor,0x7AFBF8E7,0xAC4B,0x4082,0xB0,0x58,0x89,0x08,0x99,0xD3,0xA0,0x10);


MIDL_DEFINE_GUID(IID, IID_ITfFnLMInternal,0x04B825B1,0xAC9A,0x4F7B,0xB5,0xAD,0xC7,0x16,0x8F,0x1E,0xE4,0x45);


MIDL_DEFINE_GUID(IID, IID_IEnumTfLatticeElements,0x56988052,0x47DA,0x4A05,0x91,0x1A,0xE3,0xD9,0x41,0xF1,0x71,0x45);


MIDL_DEFINE_GUID(IID, IID_ITfLMLattice,0xD4236675,0xA5BF,0x4570,0x9D,0x42,0x5D,0x6D,0x7B,0x02,0xD5,0x9B);


MIDL_DEFINE_GUID(IID, IID_ITfFnAdviseText,0x3527268B,0x7D53,0x4DD9,0x92,0xB7,0x72,0x96,0xAE,0x46,0x12,0x49);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0345 */
/* Compiler settings for ctffunc.idl:
    Oicf, W1, Zp8, env=Win64 (32b run,appending)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ITfCandidateString,0x581f317e,0xfd9d,0x443f,0xb9,0x72,0xed,0x00,0x46,0x7c,0x5d,0x40);


MIDL_DEFINE_GUID(IID, IID_IEnumTfCandidates,0xdefb1926,0x6c80,0x4ce8,0x87,0xd4,0xd6,0xb7,0x2b,0x81,0x2b,0xde);


MIDL_DEFINE_GUID(IID, IID_ITfCandidateList,0xa3ad50fb,0x9bdb,0x49e3,0xa8,0x43,0x6c,0x76,0x52,0x0f,0xbf,0x5d);


MIDL_DEFINE_GUID(IID, IID_ITfFnReconversion,0x4cea93c0,0x0a58,0x11d3,0x8d,0xf0,0x00,0x10,0x5a,0x27,0x99,0xb5);


MIDL_DEFINE_GUID(IID, IID_ITfFnAbort,0x17f2317f,0xaddb,0x49df,0x87,0x0e,0x66,0x22,0x7b,0xc5,0x1d,0x1a);


MIDL_DEFINE_GUID(IID, IID_ITfFnPlayBack,0xa3a416a4,0x0f64,0x11d3,0xb5,0xb7,0x00,0xc0,0x4f,0xc3,0x24,0xa1);


MIDL_DEFINE_GUID(IID, IID_ITfFnLangProfileUtil,0xA87A8574,0xA6C1,0x4E15,0x99,0xF0,0x3D,0x39,0x65,0xF5,0x48,0xEB);


MIDL_DEFINE_GUID(IID, IID_ITfFnConfigure,0x88f567c6,0x1757,0x49f8,0xa1,0xb2,0x89,0x23,0x4c,0x1e,0xef,0xf9);


MIDL_DEFINE_GUID(IID, IID_ITfFnConfigureRegisterWord,0xbb95808a,0x6d8f,0x4bca,0x84,0x00,0x53,0x90,0xb5,0x86,0xae,0xdf);


MIDL_DEFINE_GUID(IID, IID_ITfFnShowHelp,0x5AB1D30C,0x094D,0x4C29,0x8E,0xA5,0x0B,0xF5,0x9B,0xE8,0x7B,0xF3);


MIDL_DEFINE_GUID(IID, IID_ITfFnBalloon,0x3BAB89E4,0x5FBE,0x45F4,0xA5,0xBC,0xDC,0xA3,0x6A,0xD2,0x25,0xA8);


MIDL_DEFINE_GUID(IID, IID_ITfFnGetSAPIObject,0x5c0ab7ea,0x167d,0x4f59,0xbf,0xb5,0x46,0x93,0x75,0x5e,0x90,0xca);


MIDL_DEFINE_GUID(IID, IID_ITfFnPropertyUIStatus,0x2338AC6E,0x2B9D,0x44C0,0xA7,0x5E,0xEE,0x64,0xF2,0x56,0xB3,0xBD);


MIDL_DEFINE_GUID(IID, IID_ITfFnLMProcessor,0x7AFBF8E7,0xAC4B,0x4082,0xB0,0x58,0x89,0x08,0x99,0xD3,0xA0,0x10);


MIDL_DEFINE_GUID(IID, IID_ITfFnLMInternal,0x04B825B1,0xAC9A,0x4F7B,0xB5,0xAD,0xC7,0x16,0x8F,0x1E,0xE4,0x45);


MIDL_DEFINE_GUID(IID, IID_IEnumTfLatticeElements,0x56988052,0x47DA,0x4A05,0x91,0x1A,0xE3,0xD9,0x41,0xF1,0x71,0x45);


MIDL_DEFINE_GUID(IID, IID_ITfLMLattice,0xD4236675,0xA5BF,0x4570,0x9D,0x42,0x5D,0x6D,0x7B,0x02,0xD5,0x9B);


MIDL_DEFINE_GUID(IID, IID_ITfFnAdviseText,0x3527268B,0x7D53,0x4DD9,0x92,0xB7,0x72,0x96,0xAE,0x46,0x12,0x49);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\devdsc.cpp ===
/*
 *	DEVDSC.C
 *	
 *	Purpose:
 *		CDevDesc (Device Descriptor) class
 *	
 *	Owner:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 */

#include "_common.h"
#include "_devdsc.h"
#include "_edit.h"
#include "_font.h"

ASSERTDATA

BOOL CDevDesc::SetDC(HDC hdc, LONG dxpInch, LONG dypInch)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDevDesc::SetDC");

	AssertSz((NULL == hdc) || (GetDeviceCaps(hdc, TECHNOLOGY) != DT_METAFILE),
		"CDevDesc::SetDC attempting to set a metafile");

	_hdc = hdc;
	if(!_hdc)
	{
	    if(!_ped->_fInPlaceActive || !(hdc = _ped->TxGetDC()))
        {
            _dxpInch = _dypInch = 0;
    	    return FALSE;
        }
    }

	if (dxpInch == -1)
	{
		// Get device metrics - these should both succeed
		_dxpInch = (SHORT)GetDeviceCaps(hdc, LOGPIXELSX);
		AssertSz(_dxpInch != 0, "CDevDesc::SetDC _dxpInch is 0");
	}
	else
		_dxpInch = dxpInch;

	if (dypInch == -1)
	{
		_dypInch = (SHORT)GetDeviceCaps(hdc, LOGPIXELSY);
		AssertSz(_dypInch != 0, "CDevDesc::SetDC _dypInch is 0");
	}
	else
		_dypInch = dypInch;

	if(!_dxpInch || !_dypInch)
		return FALSE;

	// Release DC if we got the window DC
	if(!_hdc)
		_ped->TxReleaseDC(hdc);

	return TRUE;
}


void CDevDesc::SetMetafileDC(
	HDC hdcMetafile,
	LONG xMeasurePerInch,
	LONG yMeasurePerInch)
{
	_fMetafile = TRUE;
	_hdc = hdcMetafile;
	_dxpInch = (SHORT) xMeasurePerInch;
	_dypInch = (SHORT) yMeasurePerInch;
}

HDC CDevDesc::GetScreenDC() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDevDesc::GetScreenDC");

	Assert(!_hdc);
	Assert(_ped);
	return _ped->TxGetDC();
}

VOID CDevDesc::ReleaseScreenDC(HDC hdc) const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDevDesc::ReleaseScreenDC");

	Assert(!_hdc);
	Assert(_ped);
	_ped->TxReleaseDC(hdc);
}


void CDevDesc::LRtoDR(RECT &rcDest, const RECT &rcSrc, TFLOW tflow) const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDevDesc::LRtoDR");

	if (!IsUVerticalTflow(tflow))
	{
		rcDest.left = LXtoDX(rcSrc.left);    
		rcDest.right = LXtoDX(rcSrc.right);    
		rcDest.top = LYtoDY(rcSrc.top);    
		rcDest.bottom = LYtoDY(rcSrc.bottom);    
	}
	else
	{
		rcDest.left = LYtoDY(rcSrc.left);    
		rcDest.right = LYtoDY(rcSrc.right);    
		rcDest.top = LXtoDX(rcSrc.top);    
		rcDest.bottom = LXtoDX(rcSrc.bottom);    
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re41\debug.cpp ===
/*
 *	DEBUG.CPP
 *	
 *	Purpose:
 *		RICHEDIT debugging support--commented out in ship builds
 *
 *	History: <nl>
 *		7/29/98	KeithCu Wrote it stealing much from Rich Arneson's code
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"

//Module is empty if this is a retail build.
#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)

#ifdef NOFULLDEBUG
PFNASSERTHOOK pfnAssert = NULL;   //Assert hook function
#else

DWORD dwDebugOptions = 0;         //Debug option flags
PFNASSERTHOOK pfnAssert = NULL;   //Assert hook function
PFNTRACEHOOK pfnTrace = NULL;     //Trace hook function

// Static variables
static HINSTANCE ghMod;                        //Dll module handle
static DWORD TlsIndex;                      //Debug output indent level
static HANDLE hLogFile = NULL;              //Log file handle
static BOOL fIgnoreAsserts = FALSE;         //Ignore all asserts if true
static CRITICAL_SECTION csLog;              //Critical section for log file i/o
static CRITICAL_SECTION csAssert;           //Critical section for asserts
static HANDLE hEventAssert1 = NULL;         //Event for assert syncing
static HANDLE hEventAssert2 = NULL;         //Event for assert syncing
static HWND hwndAssert = NULL;           	//Assert dialog window handle
static HANDLE hAssertThrd = NULL;           //Assert thread handle
static char szAssert[MAXDEBUGSTRLEN];       //Assert message buffer
static int idAssert = -1;                   //Assert button pressed by user
DWORD WINAPI AssertThread(LPVOID lParam);	//Assert thread entry point
static BOOL fDllDetach = FALSE;				//True if we are in dll detach

//Strings for subsystem element of message
static char* TrcSubsys [] =
{
    "",
    "Display",
    "Wrapper",
    "Edit",
    "TextServices",
    "TOM",
    "OLE Object Support",
    "Store",
    "Selection",
    "WinHost",
    "DataXfer",
    "MultiUndo",
    "Range",
    "Util",
    "Notification Mgr.",
    "RTF Reader",
    "RTF Writer",
    "Printing",
    "East Asia",
	"Font"
};

//Strings for severity element of message
static char* TrcSeverity [] =
{
    "",
    "WARNING",
    "ERROR",
    "ASSERT",
    "INFO",
	"MEMORY"
};

//Strings for scope element of message
static char* TrcScope [] =
{
    "",
    "External",
    "Internal"
};

//Structure for lookup tables
typedef struct
{
    DWORD dwKey;
    char * sz;
} TabElem;

//Lookup table for CTrace param strings
static TabElem TrcParamTab [] = 
{
//Richedit Messages
    {(DWORD)EM_GETLIMITTEXT, "EM_GETLIMITTEXT"},
    {(DWORD)EM_POSFROMCHAR, "EM_POSFROMCHAR"},
    {(DWORD)EM_CHARFROMPOS, "EM_CHARFROMPOS"},
    {(DWORD)EM_SCROLLCARET, "EM_SCROLLCARET"},
    {(DWORD)EM_CANPASTE, "EM_CANPASTE"},
    {(DWORD)EM_DISPLAYBAND, "EM_DISPLAYBAND"},
    {(DWORD)EM_EXGETSEL, "EM_EXGETSEL"},
    {(DWORD)EM_EXLIMITTEXT, "EM_EXLIMITTEXT"},
    {(DWORD)EM_EXLINEFROMCHAR, "EM_EXLINEFROMCHAR"},
    {(DWORD)EM_EXSETSEL, "EM_EXSETSEL"},
    {(DWORD)EM_FINDTEXT, "EM_FINDTEXT"},
    {(DWORD)EM_FORMATRANGE, "EM_FORMATRANGE"},
    {(DWORD)EM_GETCHARFORMAT, "EM_GETCHARFORMAT"},
    {(DWORD)EM_GETEVENTMASK, "EM_GETEVENTMASK"},
    {(DWORD)EM_GETOLEINTERFACE, "EM_GETOLEINTERFACE"},
    {(DWORD)EM_GETPARAFORMAT, "EM_GETPARAFORMAT"},
    {(DWORD)EM_GETSELTEXT, "EM_GETSELTEXT"},
    {(DWORD)EM_HIDESELECTION, "EM_HIDESELECTION"},
    {(DWORD)EM_PASTESPECIAL, "EM_PASTESPECIAL"},
    {(DWORD)EM_REQUESTRESIZE, "EM_REQUESTRESIZE"},
    {(DWORD)EM_SELECTIONTYPE, "EM_SELECTIONTYPE"},
    {(DWORD)EM_SETBKGNDCOLOR, "EM_SETBKGNDCOLOR"},
    {(DWORD)EM_SETCHARFORMAT, "EM_SETCHARFORMAT"},
    {(DWORD)EM_SETEVENTMASK, "EM_SETEVENTMASK"},
    {(DWORD)EM_SETOLECALLBACK, "EM_SETOLECALLBACK"},
    {(DWORD)EM_SETPARAFORMAT, "EM_SETPARAFORMAT"},
    {(DWORD)EM_SETTARGETDEVICE, "EM_SETTARGETDEVICE"},
    {(DWORD)EM_STREAMIN, "EM_STREAMIN"},
    {(DWORD)EM_STREAMOUT, "EM_STREAMOUT"},
    {(DWORD)EM_GETTEXTRANGE, "EM_GETTEXTRANGE"},
    {(DWORD)EM_FINDWORDBREAK, "EM_FINDWORDBREAK"},
    {(DWORD)EM_SETOPTIONS, "EM_SETOPTIONS"},
    {(DWORD)EM_GETOPTIONS, "EM_GETOPTIONS"},
    {(DWORD)EM_FINDTEXTEX, "EM_FINDTEXTEX"},
    {(DWORD)EM_GETWORDBREAKPROCEX, "EM_GETWORDBREAKPROCEX"},
    {(DWORD)EM_SETWORDBREAKPROCEX, "EM_SETWORDBREAKPROCEX"},
    {(DWORD)EM_SETUNDOLIMIT, "EM_SETUNDOLIMIT"},
    {(DWORD)EM_REDO, "EM_REDO"},
    {(DWORD)EM_CANREDO, "EM_CANREDO"},
    {(DWORD)EM_SETPUNCTUATION, "EM_SETPUNCTUATION"},
    {(DWORD)EM_GETPUNCTUATION, "EM_GETPUNCTUATION"},
    {(DWORD)EM_SETWORDWRAPMODE, "EM_SETWORDWRAPMODE"},
    {(DWORD)EM_GETWORDWRAPMODE, "EM_GETWORDWRAPMODE"},
    {(DWORD)EM_SETIMECOLOR, "EM_SETIMECOLOR"},
    {(DWORD)EM_GETIMECOLOR, "EM_GETIMECOLOR"},
    {(DWORD)EM_SETIMEOPTIONS, "EM_SETIMEOPTIONS"},
    {(DWORD)EM_GETIMEOPTIONS, "EM_GETIMEOPTIONS"},
    {(DWORD)EN_MSGFILTER, "EN_MSGFILTER"},
    {(DWORD)EN_REQUESTRESIZE, "EN_REQUESTRESIZE"},
    {(DWORD)EN_SELCHANGE, "EN_SELCHANGE"},
    {(DWORD)EN_DROPFILES, "EN_DROPFILES"},
    {(DWORD)EN_PROTECTED, "EN_PROTECTED"},
    {(DWORD)EN_CORRECTTEXT, "EN_CORRECTTEXT"},
    {(DWORD)EN_STOPNOUNDO, "EN_STOPNOUNDO"},
    {(DWORD)EN_IMECHANGE, "EN_IMECHANGE"},
    {(DWORD)EN_SAVECLIPBOARD, "EN_SAVECLIPBOARD"},
    {(DWORD)EN_OLEOPFAILED, "EN_OLEOPFAILED"},

//Window Messages

	{(DWORD)WM_NULL, "WM_NULL"},
	{(DWORD)WM_CREATE, "WM_CREATE"},
	{(DWORD)WM_DESTROY, "WM_DESTROY"},
	{(DWORD)WM_MOVE, "WM_MOVE"},
	{(DWORD)WM_SIZE, "WM_SIZE"},
	{(DWORD)WM_ACTIVATE, "WM_ACTIVATE"},
	{(DWORD)WM_SETFOCUS, "WM_SETFOCUS"},
	{(DWORD)WM_KILLFOCUS, "WM_KILLFOCUS"},
	{(DWORD)WM_ENABLE, "WM_ENABLE"},
	{(DWORD)WM_SETREDRAW, "WM_SETREDRAW"},
	{(DWORD)WM_SETTEXT, "WM_SETTEXT"},
	{(DWORD)WM_GETTEXT, "WM_GETTEXT"},
	{(DWORD)WM_GETTEXTLENGTH, "WM_GETTEXTLENGTH"},
	{(DWORD)WM_PAINT, "WM_PAINT"},
	{(DWORD)WM_CLOSE, "WM_CLOSE"},
	{(DWORD)WM_QUERYENDSESSION, "WM_QUERYENDSESSION"},
	{(DWORD)WM_QUIT, "WM_QUIT"},
	{(DWORD)WM_QUERYOPEN, "WM_QUERYOPEN"},
	{(DWORD)WM_ERASEBKGND, "WM_ERASEBKGND"},
	{(DWORD)WM_SYSCOLORCHANGE, "WM_SYSCOLORCHANGE"},
	{(DWORD)WM_ENDSESSION, "WM_ENDSESSION"},
	{(DWORD)WM_SHOWWINDOW, "WM_SHOWWINDOW"},
	{(DWORD)WM_WININICHANGE, "WM_WININICHANGE"},
	{(DWORD)WM_SETTINGCHANGE, "WM_SETTINGCHANGE"},
	{(DWORD)WM_DEVMODECHANGE, "WM_DEVMODECHANGE"},
	{(DWORD)WM_ACTIVATEAPP, "WM_ACTIVATEAPP"},
	{(DWORD)WM_FONTCHANGE, "WM_FONTCHANGE"},
	{(DWORD)WM_TIMECHANGE, "WM_TIMECHANGE"},
	{(DWORD)WM_CANCELMODE, "WM_CANCELMODE"},
	{(DWORD)WM_SETCURSOR, "WM_SETCURSOR"},
	{(DWORD)WM_MOUSEACTIVATE, "WM_MOUSEACTIVATE"},
	{(DWORD)WM_CHILDACTIVATE, "WM_CHILDACTIVATE"},
	{(DWORD)WM_QUEUESYNC, "WM_QUEUESYNC"},
	{(DWORD)WM_GETMINMAXINFO, "WM_GETMINMAXINFO"},
	{(DWORD)WM_PAINTICON, "WM_PAINTICON"},
	{(DWORD)WM_ICONERASEBKGND, "WM_ICONERASEBKGND"},
	{(DWORD)WM_NEXTDLGCTL, "WM_NEXTDLGCTL"},
	{(DWORD)WM_SPOOLERSTATUS, "WM_SPOOLERSTATUS"},
	{(DWORD)WM_DRAWITEM, "WM_DRAWITEM"},
	{(DWORD)WM_MEASUREITEM, "WM_MEASUREITEM"},
	{(DWORD)WM_DELETEITEM, "WM_DELETEITEM"},
	{(DWORD)WM_VKEYTOITEM, "WM_VKEYTOITEM"},
	{(DWORD)WM_CHARTOITEM, "WM_CHARTOITEM"},
	{(DWORD)WM_SETFONT, "WM_SETFONT"},
	{(DWORD)WM_GETFONT, "WM_GETFONT"},
	{(DWORD)WM_SETHOTKEY, "WM_SETHOTKEY"},
	{(DWORD)WM_GETHOTKEY, "WM_GETHOTKEY"},
	{(DWORD)WM_QUERYDRAGICON, "WM_QUERYDRAGICON"},
	{(DWORD)WM_COMPAREITEM, "WM_COMPAREITEM"},
	{(DWORD)WM_COMPACTING, "WM_COMPACTING"},
	{(DWORD)WM_COMMNOTIFY, "WM_COMMNOTIFY"},
	{(DWORD)WM_WINDOWPOSCHANGING, "WM_WINDOWPOSCHANGING"},
	{(DWORD)WM_WINDOWPOSCHANGED, "WM_WINDOWPOSCHANGED"},
	{(DWORD)WM_POWER, "WM_POWER"},
	{(DWORD)WM_COPYDATA, "WM_COPYDATA"},
	{(DWORD)WM_CANCELJOURNAL, "WM_CANCELJOURNAL"},
	{(DWORD)WM_NOTIFY, "WM_NOTIFY"},
	{(DWORD)WM_INPUTLANGCHANGEREQUEST, "WM_INPUTLANGCHANGEREQUEST"},
	{(DWORD)WM_INPUTLANGCHANGE, "WM_INPUTLANGCHANGE"},
	{(DWORD)WM_TCARD, "WM_TCARD"},
	{(DWORD)WM_HELP, "WM_HELP"},
	{(DWORD)WM_USERCHANGED, "WM_USERCHANGED"},
	{(DWORD)WM_NOTIFYFORMAT, "WM_NOTIFYFORMAT"},
	{(DWORD)WM_CONTEXTMENU, "WM_CONTEXTMENU"},
	{(DWORD)WM_STYLECHANGING, "WM_STYLECHANGING"},
	{(DWORD)WM_STYLECHANGED, "WM_STYLECHANGED"},
	{(DWORD)WM_DISPLAYCHANGE, "WM_DISPLAYCHANGE"},
	{(DWORD)WM_GETICON, "WM_GETICON"},
	{(DWORD)WM_SETICON, "WM_SETICON"},
	{(DWORD)WM_NCCREATE, "WM_NCCREATE"},
	{(DWORD)WM_NCDESTROY, "WM_NCDESTROY"},
	{(DWORD)WM_NCCALCSIZE, "WM_NCCALCSIZE"},
	{(DWORD)WM_NCHITTEST, "WM_NCHITTEST"},
	{(DWORD)WM_NCPAINT, "WM_NCPAINT"},
	{(DWORD)WM_NCACTIVATE, "WM_NCACTIVATE"},
	{(DWORD)WM_GETDLGCODE, "WM_GETDLGCODE"},
	{(DWORD)WM_NCMOUSEMOVE, "WM_NCMOUSEMOVE"},
	{(DWORD)WM_NCLBUTTONDOWN, "WM_NCLBUTTONDOWN"},
	{(DWORD)WM_NCLBUTTONUP, "WM_NCLBUTTONUP"},
	{(DWORD)WM_NCLBUTTONDBLCLK, "WM_NCLBUTTONDBLCLK"},
	{(DWORD)WM_NCRBUTTONDOWN, "WM_NCRBUTTONDOWN"},
	{(DWORD)WM_NCRBUTTONUP, "WM_NCRBUTTONUP"},
	{(DWORD)WM_NCRBUTTONDBLCLK, "WM_NCRBUTTONDBLCLK"},
	{(DWORD)WM_NCMBUTTONDOWN, "WM_NCMBUTTONDOWN"},
	{(DWORD)WM_NCMBUTTONUP, "WM_NCMBUTTONUP"},
	{(DWORD)WM_NCMBUTTONDBLCLK, "WM_NCMBUTTONDBLCLK"},
	{(DWORD)WM_KEYFIRST, "WM_KEYFIRST"},
	{(DWORD)WM_KEYDOWN, "WM_KEYDOWN"},
	{(DWORD)WM_KEYUP, "WM_KEYUP"},
	{(DWORD)WM_CHAR, "WM_CHAR"},
	{(DWORD)WM_DEADCHAR, "WM_DEADCHAR"},
	{(DWORD)WM_SYSKEYDOWN, "WM_SYSKEYDOWN"},
	{(DWORD)WM_SYSKEYUP, "WM_SYSKEYUP"},
	{(DWORD)WM_SYSCHAR, "WM_SYSCHAR"},
	{(DWORD)WM_SYSDEADCHAR, "WM_SYSDEADCHAR"},
	{(DWORD)WM_KEYLAST, "WM_KEYLAST"},
	{(DWORD)WM_IME_STARTCOMPOSITION, "WM_IME_STARTCOMPOSITION"},
	{(DWORD)WM_IME_ENDCOMPOSITION, "WM_IME_ENDCOMPOSITION"},
	{(DWORD)WM_IME_COMPOSITION, "WM_IME_COMPOSITION"},
	{(DWORD)WM_IME_KEYLAST, "WM_IME_KEYLAST"},
	{(DWORD)WM_INITDIALOG, "WM_INITDIALOG"},
	{(DWORD)WM_COMMAND, "WM_COMMAND"},
	{(DWORD)WM_SYSCOMMAND, "WM_SYSCOMMAND"},
	{(DWORD)WM_TIMER, "WM_TIMER"},
	{(DWORD)WM_HSCROLL, "WM_HSCROLL"},
	{(DWORD)WM_VSCROLL, "WM_VSCROLL"},
	{(DWORD)WM_INITMENU, "WM_INITMENU"},
	{(DWORD)WM_INITMENUPOPUP, "WM_INITMENUPOPUP"},
	{(DWORD)WM_MENUSELECT, "WM_MENUSELECT"},
	{(DWORD)WM_MENUCHAR, "WM_MENUCHAR"},
	{(DWORD)WM_ENTERIDLE, "WM_ENTERIDLE"},
	{(DWORD)WM_CTLCOLORMSGBOX, "WM_CTLCOLORMSGBOX"},
	{(DWORD)WM_CTLCOLOREDIT, "WM_CTLCOLOREDIT"},
	{(DWORD)WM_CTLCOLORLISTBOX, "WM_CTLCOLORLISTBOX"},
	{(DWORD)WM_CTLCOLORBTN, "WM_CTLCOLORBTN"},
	{(DWORD)WM_CTLCOLORDLG, "WM_CTLCOLORDLG"},
	{(DWORD)WM_CTLCOLORSCROLLBAR, "WM_CTLCOLORSCROLLBAR"},
	{(DWORD)WM_CTLCOLORSTATIC, "WM_CTLCOLORSTATIC"},
	{(DWORD)WM_MOUSEFIRST, "WM_MOUSEFIRST"},
	{(DWORD)WM_MOUSEMOVE, "WM_MOUSEMOVE"},
	{(DWORD)WM_LBUTTONDOWN, "WM_LBUTTONDOWN"},
	{(DWORD)WM_LBUTTONUP, "WM_LBUTTONUP"},
	{(DWORD)WM_LBUTTONDBLCLK, "WM_LBUTTONDBLCLK"},
	{(DWORD)WM_RBUTTONDOWN, "WM_RBUTTONDOWN"},
	{(DWORD)WM_RBUTTONUP, "WM_RBUTTONUP"},
	{(DWORD)WM_RBUTTONDBLCLK, "WM_RBUTTONDBLCLK"},
	{(DWORD)WM_MBUTTONDOWN, "WM_MBUTTONDOWN"},
	{(DWORD)WM_MBUTTONUP, "WM_MBUTTONUP"},
	{(DWORD)WM_MBUTTONDBLCLK, "WM_MBUTTONDBLCLK"},
	{(DWORD)WM_MOUSELAST, "WM_MOUSELAST"},
	{(DWORD)WM_PARENTNOTIFY, "WM_PARENTNOTIFY"},
	{(DWORD)WM_ENTERMENULOOP, "WM_ENTERMENULOOP"},
	{(DWORD)WM_EXITMENULOOP, "WM_EXITMENULOOP"},
	{(DWORD)WM_NEXTMENU, "WM_NEXTMENU"},
	{(DWORD)WM_SIZING, "WM_SIZING"},
	{(DWORD)WM_CAPTURECHANGED, "WM_CAPTURECHANGED"},
	{(DWORD)WM_MOVING, "WM_MOVING"},
	{(DWORD)WM_POWERBROADCAST, "WM_POWERBROADCAST"},
	{(DWORD)WM_DEVICECHANGE, "WM_DEVICECHANGE"},
	{(DWORD)WM_IME_SETCONTEXT, "WM_IME_SETCONTEXT"},
	{(DWORD)WM_IME_NOTIFY, "WM_IME_NOTIFY"},
	{(DWORD)WM_IME_CONTROL, "WM_IME_CONTROL"},
	{(DWORD)WM_IME_COMPOSITIONFULL, "WM_IME_COMPOSITIONFULL"},
	{(DWORD)WM_IME_SELECT, "WM_IME_SELECT"},
	{(DWORD)WM_IME_CHAR, "WM_IME_CHAR"},
	{(DWORD)WM_IME_KEYDOWN, "WM_IME_KEYDOWN"},
	{(DWORD)WM_IME_KEYUP, "WM_IME_KEYUP"},
	{(DWORD)WM_MDICREATE, "WM_MDICREATE"},
	{(DWORD)WM_MDIDESTROY, "WM_MDIDESTROY"},
	{(DWORD)WM_MDIACTIVATE, "WM_MDIACTIVATE"},
	{(DWORD)WM_MDIRESTORE, "WM_MDIRESTORE"},
	{(DWORD)WM_MDINEXT, "WM_MDINEXT"},
	{(DWORD)WM_MDIMAXIMIZE, "WM_MDIMAXIMIZE"},
	{(DWORD)WM_MDITILE, "WM_MDITILE"},
	{(DWORD)WM_MDICASCADE, "WM_MDICASCADE"},
	{(DWORD)WM_MDIICONARRANGE, "WM_MDIICONARRANGE"},
	{(DWORD)WM_MDIGETACTIVE, "WM_MDIGETACTIVE"},
	{(DWORD)WM_MDISETMENU, "WM_MDISETMENU"},
	{(DWORD)WM_ENTERSIZEMOVE, "WM_ENTERSIZEMOVE"},
	{(DWORD)WM_EXITSIZEMOVE, "WM_EXITSIZEMOVE"},
	{(DWORD)WM_DROPFILES, "WM_DROPFILES"},
	{(DWORD)WM_MDIREFRESHMENU, "WM_MDIREFRESHMENU"},
	{(DWORD)WM_CUT, "WM_CUT"},
	{(DWORD)WM_COPY, "WM_COPY"},
	{(DWORD)WM_PASTE, "WM_PASTE"},
	{(DWORD)WM_CLEAR, "WM_CLEAR"},
	{(DWORD)WM_UNDO, "WM_UNDO"},
	{(DWORD)WM_RENDERFORMAT, "WM_RENDERFORMAT"},
	{(DWORD)WM_RENDERALLFORMATS, "WM_RENDERALLFORMATS"},
	{(DWORD)WM_DESTROYCLIPBOARD, "WM_DESTROYCLIPBOARD"},
	{(DWORD)WM_DRAWCLIPBOARD, "WM_DRAWCLIPBOARD"},
	{(DWORD)WM_PAINTCLIPBOARD, "WM_PAINTCLIPBOARD"},
	{(DWORD)WM_VSCROLLCLIPBOARD, "WM_VSCROLLCLIPBOARD"},
	{(DWORD)WM_SIZECLIPBOARD, "WM_SIZECLIPBOARD"},
	{(DWORD)WM_ASKCBFORMATNAME, "WM_ASKCBFORMATNAME"},
	{(DWORD)WM_CHANGECBCHAIN, "WM_CHANGECBCHAIN"},
	{(DWORD)WM_HSCROLLCLIPBOARD, "WM_HSCROLLCLIPBOARD"},
	{(DWORD)WM_QUERYNEWPALETTE, "WM_QUERYNEWPALETTE"},
	{(DWORD)WM_PALETTEISCHANGING, "WM_PALETTEISCHANGING"},
	{(DWORD)WM_PALETTECHANGED, "WM_PALETTECHANGED"},
	{(DWORD)WM_HOTKEY, "WM_HOTKEY"},
	{(DWORD)WM_PRINT, "WM_PRINT"},
	{(DWORD)WM_PRINTCLIENT, "WM_PRINTCLIENT"},
	{(DWORD)WM_HANDHELDFIRST, "WM_HANDHELDFIRST"},
	{(DWORD)WM_HANDHELDLAST, "WM_HANDHELDLAST"},
	{(DWORD)WM_AFXFIRST, "WM_AFXFIRST"},
	{(DWORD)WM_AFXLAST, "WM_AFXLAST"},
	{(DWORD)WM_PENWINFIRST, "WM_PENWINFIRST"},
	{(DWORD)WM_PENWINLAST, "WM_PENWINLAST"},
	{(DWORD)WM_APP, "WM_APP"}
};

// release + asserts build has no memory checking
#ifndef _RELEASE_ASSERTS_

void DlgDisplayVrgmst(HWND hListMemory)
{
	char szTemp[300];
	int cbTotal = 0;
	for(int imst = 0; vrgmst[imst].szFile != 0; imst++)
		{
		cbTotal += vrgmst[imst].cbAlloc;
		wsprintfA(szTemp, "%6.d   %s", vrgmst[imst].cbAlloc, vrgmst[imst].szFile);
		SendMessage(hListMemory, LB_ADDSTRING, 0,  (LPARAM) szTemp);
		}

	wsprintfA(szTemp, "%6.d   %s", cbTotal, "--- Total ---");
	SendMessage(hListMemory, LB_ADDSTRING, 0,  (LPARAM) szTemp);
}

HFONT hf = 0;

INT_PTR CALLBACK FDlgRicheditDebugCentral(HWND hdlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	HWND hListMemory;
	switch (message)
		{
		case WM_INITDIALOG:
			hListMemory = GetDlgItem(hdlg, IDC_MEMORY_STATISTICS);
			LOGFONTA lf;
			ZeroMemory(&lf, sizeof(lf));
			lf.lfHeight = 14;
			memcpy(lf.lfFaceName, "Courier New", 12);
			hf = CreateFontIndirectA(&lf);
			SendMessage(hListMemory, WM_SETFONT, (WPARAM)hf, FALSE);
			UpdateMst();
			DlgDisplayVrgmst(hListMemory);
			return FALSE;

		case WM_COMMAND:
			switch (wParam)
				{
				case IDOK:
					EndDialog(hdlg, IDOK);
					return TRUE;
				case IDCANCEL:
					EndDialog(hdlg, IDCANCEL);
					return TRUE;
				}
			break;
		}

	return FALSE;
}

void RicheditDebugCentral(void)
{
	DialogBoxA(hinstRE, MAKEINTRESOURCEA(IDD_DEBUG), NULL, FDlgRicheditDebugCentral);
	DeleteObject(hf);
}

#endif //!_RELEASE_ASSERTS_


/*
 *  DebugMain
 *	
 *  @mfunc
 *      Dll entry point.  See Win32 SDK documentation for details.
 *          hDLL - handle of DLL
 *          dwReason - indicates why DLL called
 *          lpReserved - reserved
 *
 *  @rdesc
 *      TRUE (always)
 *
 */
BOOL WINAPI DebugMain (HINSTANCE hDLL, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            //
            // DLL is attaching to the address space of the current process.
            //
            ghMod = hDLL;
            TlsIndex = TlsAlloc();
            TlsSetValue(TlsIndex, (LPVOID)-1);
            InitializeCriticalSection(&csLog);
            InitializeCriticalSection(&csAssert);

			//Create a separate thread to handle asserts.
            //We use events to halt the the asserting thread
            //during an assert, and to halt the assert thread the rest of
            //the time.  Note that these are autoreset events.
            hEventAssert1= CreateEventA(NULL, FALSE, FALSE, NULL);
            hEventAssert2= CreateEventA(NULL, FALSE, FALSE, NULL);

            INITDEBUGSERVICES(OPTUSEDEFAULTS, NULL, NULL);

            break;
        }

        case DLL_THREAD_ATTACH:
        {

            //
            // A new thread is being created in the current process.
            //
            TlsSetValue(TlsIndex, (LPVOID)-1);
            break;
        }

        case DLL_THREAD_DETACH:
        {
            //
            // A thread is exiting cleanly.
            //
            break;
        }

        case DLL_PROCESS_DETACH:
        {
            //
            // The calling process is detaching the DLL from its address space.
            //
			fDllDetach = TRUE;

            //Clean up after ourselves.
            TlsFree(TlsIndex);
            SETLOGGING(FALSE);

			//Clean up the assert thread stuff.
            if (NULL != hAssertThrd)
                TerminateThread(hAssertThrd, 0);
            if (NULL != hEventAssert1)
                CloseHandle(hEventAssert1);
            if (NULL != hEventAssert2)
                CloseHandle(hEventAssert2);

            DeleteCriticalSection(&csLog);
            DeleteCriticalSection(&csAssert);

            break;
        }
    }   

    return TRUE;
}


//This is not in release asserts build
#ifndef _RELEASE_ASSERTS_

/*
 *  SetLogging
 *	
 *  @mfunc
 *      This function starts and stops logging of output from
 *      the debug services.  If logging is being started, it
 *      creates a new file for logging (path and name specified
 *      in win.ini).  fStartLog is TRUE and logging is already
 *      on, or fStartLog is FALSE and logging is off, this
 *      nothing happens.
 *
 *      fStartLog - TRUE to start logging, FALSE to stop logging.
 *
 */
void WINAPI SetLogging(BOOL fStartLog)
{
    //Don't start logging if it's already on.
    if (fStartLog && !fLogging)
    {
        char szLogFile[MAX_PATH];

        //Set option flag telling everyone we're on
        dwDebugOptions |= OPTLOGGINGON;

        //Get file name
        GetProfileStringA("RICHEDIT DEBUG", "LOGFILE", "", szLogFile, MAX_PATH);

        //Create new file
        hLogFile = CreateFileA(szLogFile, GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        //If we didn't succed creating the file, reset flags and tell user.
        if (INVALID_HANDLE_VALUE == hLogFile)
        {
            dwDebugOptions &= ~OPTLOGGINGON;
            MessageBoxA(NULL, "Unable to open log file.", "Richedit Debug", MB_OK);
        }
    }
    //Don't stop logging if it's not on.
    else if (!fStartLog && fLogging)
    {
        //Set option flag telling everyone we're off, and close file.
        dwDebugOptions &= ~OPTLOGGINGON;
        CloseHandle(hLogFile);
    }
}

#endif //!_RELEASE_ASSERTS_


/*
 *  InitDebugServices
 *	
 *  @mfunc
 *      This function initializes the options for the debug
 *      services.  If this function is not called, all optional
 *      debug services are left off by default.
 *      If OPTUSEDEFAULTS is specified for dwOpts, options are
 *      loaded from win.ini, otherwise  the caller specified
 *      options are set.  If the caller wishes to specify options
 *      they must specify all options they want turned on.  Any
 *      options not explicitly specified will be turned off.
 *      The function also takes a pointer to an assert hook
 *      function and a trace hook function.
 *
 *      dwOpts - Debug options to be set.
 *      pfnAssertHook - Pointer to assert hook function (NULL if none).
 *      pfnTraceHook - Pointer to trace hook function (NULL if none).
 *
 */
DllExport void WINAPI InitDebugServices(DWORD dwOpts,
    PFNASSERTHOOK pfnAssertHook, PFNTRACEHOOK pfnTraceHook)
{
    // Check to see if OPTUSEDEFAULTS was specified.  If so, get
    // values from win.ini.  Otherwise, set options to values
    // specified by caller.
    if (dwOpts & OPTUSEDEFAULTS)
    {
        SETLOGGING(GetProfileIntA("RICHEDIT DEBUG", "LOGGING", 0));
        SETVERBOSE(GetProfileIntA("RICHEDIT DEBUG", "VERBOSE", 0));
        SETINFO(GetProfileIntA("RICHEDIT DEBUG", "INFO", 0));
        SETMEMORY(GetProfileIntA("RICHEDIT DEBUG", "MEMORY", 0));
        SETTRACING(GetProfileIntA("RICHEDIT DEBUG", "TRACE", 0));
        SETTRACEEXT(GetProfileIntA("RICHEDIT DEBUG", "TRACEEXT", 0));
        SETOPT(OPTTRACEDISP, GetProfileIntA("RICHEDIT DEBUG", "TRACEDISP", 0));
        SETOPT(OPTTRACEWRAP, GetProfileIntA("RICHEDIT DEBUG", "TRACEWRAP", 0));
        SETOPT(OPTTRACEEDIT, GetProfileIntA("RICHEDIT DEBUG", "TRACEEDIT", 0));
        SETOPT(OPTTRACETS, GetProfileIntA("RICHEDIT DEBUG", "TRACETS", 0));
        SETOPT(OPTTRACETOM, GetProfileIntA("RICHEDIT DEBUG", "TRACETOM", 0));
        SETOPT(OPTTRACEOLE, GetProfileIntA("RICHEDIT DEBUG", "TRACEOLE", 0));
        SETOPT(OPTTRACEBACK, GetProfileIntA("RICHEDIT DEBUG", "TRACEBACK", 0));
        SETOPT(OPTTRACESEL, GetProfileIntA("RICHEDIT DEBUG", "TRACESEL", 0));
        SETOPT(OPTTRACEHOST, GetProfileIntA("RICHEDIT DEBUG", "TRACEHOST", 0));
        SETOPT(OPTTRACEDTE, GetProfileIntA("RICHEDIT DEBUG", "TRACEDTE", 0));
        SETOPT(OPTTRACEUNDO, GetProfileIntA("RICHEDIT DEBUG", "TRACEUNDO", 0));
        SETOPT(OPTTRACERANG, GetProfileIntA("RICHEDIT DEBUG", "TRACERANG", 0));
        SETOPT(OPTTRACEUTIL, GetProfileIntA("RICHEDIT DEBUG", "TRACEUTIL", 0));
        SETOPT(OPTTRACENOTM, GetProfileIntA("RICHEDIT DEBUG", "TRACENOTM", 0));
        SETOPT(OPTTRACERTFR, GetProfileIntA("RICHEDIT DEBUG", "TRACERTFR", 0));
        SETOPT(OPTTRACERTFW, GetProfileIntA("RICHEDIT DEBUG", "TRACERTFW", 0));
        SETOPT(OPTTRACEPRT, GetProfileIntA("RICHEDIT DEBUG", "TRACEPRT", 0));
        SETOPT(OPTTRACEFE, GetProfileIntA("RICHEDIT DEBUG", "TRACEFE", 0));
        SETOPT(OPTTRACEFONT, GetProfileIntA("RICHEDIT DEBUG", "TRACEFONT", 0));
    }
    else
    {
        //Set up logging before we set dwDebugOptions because
        //SetLogging will not turn logging on if the flag
        //indicates it is already on.
        SETLOGGING(dwOpts & OPTLOGGINGON);
        dwDebugOptions = dwOpts;
    }

    SETASSERTFN(pfnAssertHook);
    SETTRACEFN(pfnTraceHook);
}


/*
 *  AssertProc
 *	
 *  @mfunc
 *      This is the dialog proc for the assert message.
/ *
 *      lParam - The string to display in the dialog.
 *
 */
BOOL CALLBACK AssertProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
        case WM_INITDIALOG:
            {
                RECT rcDlg, rcDesk;

                GetWindowRect(hwndDlg, &rcDlg);
                GetWindowRect(GetDesktopWindow(), &rcDesk);

                SetWindowPos(hwndDlg, HWND_TOP,
                ((rcDesk.right - rcDesk.left ) - (rcDlg.right - rcDlg.left))/2,
                ((rcDesk.bottom - rcDesk.top ) - (rcDlg.bottom - rcDlg.top))/2,
                0, 0, SWP_NOSIZE);


                if (NULL != lParam)
                    SetDlgItemTextA(hwndDlg, IDC_MSG, (LPSTR)lParam);

                //Sometimes we don't always end up on top.  I don't know why.
                SetForegroundWindow(hwndDlg);                
            }
            break;

        case WM_COMMAND:
            //Kill dialog and return button id that was pressed.
            EndDialog(hwndDlg, LOWORD(wParam));
            break;

        default:
            return FALSE;
    }
    return TRUE;
}


/*
 *  AssertThread
 *	
 *  @mfunc
 *      This is the entry point for the thread created for the
 *      assert dialog.
 *
 *      lParam - Data passed to thread...not used.
 *
 *  @rdesc
 *      Should not return.  It will be explicitly terminated.
 *
 */
DWORD WINAPI AssertThread(LPVOID lParam)
{
    //This should run until it is explicitly terminated in
    //process detach.
    while(TRUE)
    {
		//We go into a wait state until the event is signaled,
		//which means we are handling an assert.
        WaitForSingleObject(hEventAssert1, INFINITE);
        idAssert = DialogBoxParamA(ghMod, MAKEINTRESOURCEA(IDD_ASSERT),
            NULL, (DLGPROC)AssertProc, (LPARAM)szAssert);
		//The asserting thread will be waiting on this event so
		//set it to allow the asserting thread continue.
        SetEvent(hEventAssert2);
    }

    return 0;
}

/*
 *  AssertSzFn
 *	
 *  @mfunc
 *      Display a message for the user and give the
 *      option to abort, ignore, or ignore all.
 *      Selecting ignore all causes all asserts to be
 *      ignored from that time forward.  It cannot be
 *      reset.  If the assert dialog cannot be created
 *      A message box is used.  The message box has one
 *      button (OK) which will cause an abort.
 *
 *      szFile - the file the warning occured in.
 *      iLine - the line number the warning occured at.
 *      szUserMsg - User define message string
 *
 */
void AssertSzFn(LPSTR szUserMsg, LPSTR szFile, int iLine)
{
    char szModuleName[MAX_PATH];
    char * pszModuleName;
    DWORD pid;
    DWORD tid;
    DWORD dwAssertTID;

    //Check to see if an assert hook has been set. If it has, call
    //it with pointers to all our parameters (they can be modified
    //this way if desired).  If the hook returns false, return.
    //Otherwise, continue with our assert with the potentially
    //modified parameters.
    if (NULL != pfnAssert)
        if (!pfnAssert(szUserMsg, szFile, &iLine))
            return;


    if( NULL == hAssertThrd )
    {
        if( NULL != hEventAssert1 && NULL != hEventAssert2)
        {
            hAssertThrd = CreateThread(NULL, 0, AssertThread,
                NULL, 0, &dwAssertTID);
        }
    }

    //This critical section will prevent us from being entered simultaneously
    //by multiple threads.  This alone will not prevent reentrance by our own thread
    //once the assert dialog is up. Under normal circumstances a special thread
    //exists to run the assert dialog and Event objects are used to halt this
    //thread while the assert dialog is up (see WaitForSingleObject
    //further down).  If the assert thread does not exist, a MessageBox is used
    //and we can be reentered (this is a fallback position and there's
    //not much we can do about it).
    EnterCriticalSection(&csAssert);

    pid = GetCurrentProcessId();
    tid = GetCurrentThreadId();

    //Get the module name to include in assert message.
    if (GetModuleFileNameA(NULL, szModuleName, MAX_PATH))
    {
        pszModuleName = strrchr(szModuleName, '\\');
        if (!pszModuleName)
        {
            pszModuleName = szModuleName;
        }
        else
        {
            pszModuleName++;
        }
    }
    else
    {
        pszModuleName = "Unknown";
    }


    //Send a message to the debug output and build a string for the
    //assert dialog.  The string depends on whether the user provided
    //a message.
    if (NULL != szUserMsg)
    {
		TRACEASSERTSZ(szUserMsg, szFile, iLine);
        sprintf(szAssert,
            "PROCESS: %s, PID: %d, TID: %d\nFILE: %s (%d)\n%s\n",
             pszModuleName, pid, tid, szFile, iLine, szUserMsg);
    }
    else
    {
		TRACEASSERT(szFile, iLine);
        sprintf(szAssert,
            "PROCESS: %s, PID: %d, TID: %d\nFILE: %s (%d)\n",
             pszModuleName, pid, tid, szFile, iLine);
    }


    //If the user did not disable asserts on a previous assert,
    //put up a dialog with the assert message.
    if (!fIgnoreAsserts)
    {
        idAssert = -1;

		//If we are in the middle of process detach, the assert thread
		//will not execute so pop the dialog here ourselves.  Presumably there
		//is little change of reentrancy at this point.  If we are not
		//in process detach, let the assert thread handle the assert.
		if (fDllDetach)
		{
            idAssert = DialogBoxParamA(ghMod, MAKEINTRESOURCEA(IDD_ASSERT),
                NULL, (DLGPROC)AssertProc, (LPARAM)szAssert);
		}
        else
        {
            SetEvent(hEventAssert1);
            WaitForSingleObject(hEventAssert2, INFINITE);
        }

        //The assert thread doesn't exist or the dialogbox create failed so
        //use a message box instead.  In this case, since we
        //are obviously having problems, we are only going to
        //give the user one choice...abort.
        if (-1 == idAssert)
        {
            idAssert = MessageBoxA(NULL,
                             szAssert,
                             "Richedit Assert - (retry will be ignored)",
                              MB_SETFOREGROUND | MB_TASKMODAL |
                              MB_ICONEXCLAMATION | MB_ABORTRETRYIGNORE);

            //
            // If id == 0, then an error occurred.  There are two possibilities
            // that can cause the error:  Access Denied, which means that this
            // process does not have access to the default desktop, and everything
            // else (usually out of memory).
            //
            if (!idAssert)
            {
                if (GetLastError() == ERROR_ACCESS_DENIED)
                {
                    //
                    // Retry this one with the SERVICE_NOTIFICATION flag on.  That
                    // should get us to the right desktop.
                    //
                    idAssert = MessageBoxA(   NULL,
                                        szAssert,
                                        "Richedit Assert - (retry will be ignored)",
                                        MB_SETFOREGROUND | MB_TASKMODAL | MB_ICONEXCLAMATION | 
                                        MB_ABORTRETRYIGNORE);

                }
            }
        }

        if (idAssert == ID_IGNOREALL)
        {
            fIgnoreAsserts = TRUE;
        }

        if (idAssert == IDABORT )
        {
            //This will cause a break when debugging, and
            //an exception leading to termination otherwise.
            DebugBreak();
			return;
        }
    }

    LeaveCriticalSection(&csAssert);
}


/*
 *  TabLookup
 *	
 *  @mfunc
 *      This function searches an array of TabElem
 *      structures looking for an entry whose key
 *      matches the one we were given. If found, it
 *      copies the string associated with the key into
 *      the supplied buffer.
 *      
 *      Table - TabElem pointer to start of array.
 *      TabSize - Size of array in bytes.
 *      dwKey - Key to match.
 *      szBuf - Buffer to hold string (assumed MAXDEBUGSTRLEN in size).
 *
 *  @rdesc
 *      FALSE if key not found, TRUE if found.
 *
 */
BOOL TabLookup(TabElem * Table, UINT TabSize, DWORD dwKey, LPSTR szBuf)
{
    BOOL fRet = FALSE;
    UINT cTab, index;
    
    cTab = TabSize/sizeof(TabElem);

    for (index = 0; index < cTab; index++)
    {
        if (Table[index].dwKey == dwKey)
            break;
    }

    if (index < cTab)
    {
        lstrcpyA(szBuf, Table[index].sz);
        fRet = TRUE;
    }

    return fRet;
}

/*
 *  GetHResultSz
 *	
 *  @mfunc
 *      This function fills a buffer with a string associated
 *      with a given HRESULT.  This string can then be used
 *      in the output from TraceMsg.
 *      
 *      hr - HRESULT on which the string will be based.
 *      szBuf - Buffer to hold string (MAXDEBUGSTRLEN in size).
 *
 */
void GetHResultSz(HRESULT hr, LPSTR szBuf)
{
    // Build string based on FormatMessageA
    if (!FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, (DWORD)hr,
        MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
        szBuf, MAXDEBUGSTRLEN, NULL))
    {
        // Build default string
        sprintf(szBuf, "hr = %d: Unrecognized HRESULT.", hr);
    }
    else
    {
        int cch;
        char * pch;

        //Need to get rid of the CRLF from FormatMessageA.
        pch = szBuf;
        cch = strlen(szBuf);
        pch += (cch - 2);
        *pch = '\0';
    }
}


/*
 *  GetParamSz
 *	
 *  @mfunc
 *      This function fills a buffer with a string associated
 *      with a param from the text message handler.
 *      This string can then be used in the output from
 *      TraceMsg.
 *      
 *      dwParam - param on which the string will be based.
 *      szBuf - Buffer to hold string (MAXDEBUGSTRLEN in size).
 */
void GetParamSz(DWORD dwParam, LPSTR szBuf)
{
    char szTemp[MAXDEBUGSTRLEN];

    if (!TabLookup(TrcParamTab, sizeof(TrcParamTab), (DWORD)dwParam, szTemp))
	{
        sprintf(szBuf, "PARAM = %d: Unrecognized PARAM.", dwParam);
	}
	else
	{
        sprintf(szBuf, "PARAM: %s", szTemp);
	}
}

/*
 *  GetDefaultSz
 *	
 *  @mfunc
 *      This function fills a buffer with a string associated
 *      with either the value from GetLastError, or with a
 *      default string. This string can then be used in the
 *      output from TraceMsg.
 *      
 *      dwError - Value from GetLastError.
 *      szBuf - Buffer to hold string (MAXDEBUGSTRLEN in size).
 *
 */
void GetDefaultSz(DWORD dwError, LPSTR szBuf)
{
    //Check to see if we have an error value
    if (dwError)
    {
        // Build string based on FormatMessageA
        if (!FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwError,
            MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
            szBuf, MAXDEBUGSTRLEN, NULL))
        {
            // Build default string
            lstrcpyA(szBuf, "Reason unknown.");
        }
        else
        {
            int cch;
            char * pch;

            //Need to get rid of the CRLF from FormatMessageA.
            pch = szBuf;
            cch = strlen(szBuf);
            pch += (cch - 2);
            *pch = '\0';
        }
    }
    else
    {
        // Build default string
        lstrcpyA(szBuf, "Reason unknown.");
    }
}

//The following are not used by the release with asserts build
#ifndef _RELEASE_ASSERTS_

/*
 *  GetDataSz
 *	
 *  @mfunc
 *      This function fills a buffer with a string representing
 *      data passed to TraceMsg in one of it's DWORDS data
 *      parameters. This string can then be used in the
 *      output from TraceMsg.
 *      
 *      uDataType - This is the type of data we are dealing with.
 *      dwData - This is the data itself.
 *      szBuf - Buffer to hold string (MAXDEBUGSTRLEN in size).
 *
 */
void GetDataSz(UINT uDataType, DWORD dwData, LPSTR szBuf)
{
    switch (uDataType)
    {
        // Data is an HRESULT
        case TRCDATAHRESULT:
            GetHResultSz((HRESULT)dwData, szBuf);
            break;

        // Data is a string (copy to szBuf and pass it through)
        case TRCDATASTRING:
            lstrcpyA(szBuf, (LPSTR)(DWORD_PTR)dwData);
            break;

        // Data is a parameter value
        case TRCDATAPARAM:
            GetParamSz(dwData, szBuf);
            break;

        // Get string based on GetLastError
        case TRCDATADEFAULT:
        default:
            GetDefaultSz(dwData, szBuf);
            break;
    }
}


/*
 *  LogDebugString
 *	
 *  @mfunc
 *      This function writes a string to the log file.  The file must
 *      be opened already and hLogFile must contain the handle.
 *      
 *      szDebugMsg - String to write to log file.
 *
 */
void LogDebugString(LPSTR szDebugMsg)
{
    if ((NULL != hLogFile) && (INVALID_HANDLE_VALUE != hLogFile))
    {
        DWORD dwMsgBytes, dwBytes;

        dwMsgBytes = strlen(szDebugMsg)*sizeof(char);

        //Prevent other threads from trying to write at same time.
        EnterCriticalSection(&csLog);
        SetFilePointer(hLogFile, 0, NULL, FILE_END);
        WriteFile (hLogFile, szDebugMsg, dwMsgBytes, &dwBytes, NULL);
        LeaveCriticalSection(&csLog);
    }
}


/*
 *  TraceMsg
 *	
 *  @mfunc
 *      This is the central message generating facility for
 *      the debug tools.  All messages to the debug output
 *      or log file are generated here. This function takes
 *      a DWORD (dwFlags) that consists of packed values that determine
 *      the kind of message to generated.  It takes two DWORD
 *      data parameters that can contain several dif