_TEMPLATE_REFLOG
    PTRACE_LOG  m_pTraceLog;
#endif
    
    /*
        'Consumer' public interfaces
        Methods for getting info out of a CTemplate
    */

    // Returns name of source file on which this template is based
    LPTSTR GetSourceFileName(SOURCEPATHTYPE = SOURCEPATHTYPE_PHYSICAL);

    // Returns virtual path of the source file
    LPTSTR GetApplnPath(SOURCEPATHTYPE = SOURCEPATHTYPE_PHYSICAL);

    // Returns hashing key of the template
    const CTemplateKey *ExtractHashKey() const;

    // Returns version stamp of compiler by which this template was compiled
    LPSTR GetCompilerVersion();

    // Component counts
    USHORT Count(TEMPLATE_COMPONENT tcomp);
    USHORT CountScriptEngines() { return (USHORT)m_cScriptEngines; }

    // Returns i-th script block as ptr to prog lang id and ptr to script text
    void GetScriptBlock(UINT i, LPSTR* pszScriptEngine, PROGLANG_ID** ppProgLangId, LPCOLESTR* pwstrScriptText);

    // Returns i-th object-info as object name, clsid, scope, model
    HRESULT GetObjectInfo(UINT i, LPSTR* ppszObjectName,
            CLSID *pClsid, CompScope *pScope, CompModel *pcmModel);

    // Returns i-th HTML block as ptr, count of bytes, original offset, incl filename
    HRESULT GetHTMLBlock(UINT i, LPSTR* pszHTML, ULONG* pcbHTML, ULONG* pcbSrcOffs, LPSTR* pszSrcIncFile);

    // Returns line number and source file name a given target line in a given script engine.
    void GetScriptSourceInfo(UINT idEngine, int iTargetLine, LPTSTR* pszPathInfo, LPTSTR* pszPathTranslated, ULONG* piSourceLine, ULONG* pichSourceLine, BOOLB* pfGuessedLine);

    // Converts a character offset from the target script to the offset in the source
    void GetSourceOffset(ULONG idEngine, ULONG cchTargetOffset, TCHAR **pszSourceFile, ULONG *pcchSourceOffset, ULONG *pcchSourceText);

    // Converts a character offset from the source document to the offset in the target
    BOOL GetTargetOffset(TCHAR *szSourceFile, ULONG cchSourceOffset, ULONG *pidEngine, ULONG *pcchTargetOffset);

    // Get the character position of a line (directly implements debugging interface)
    HRESULT GetPositionOfLine(CFileMap *pFilemap, ULONG cLineNumber, ULONG *pcCharacterPosition);

    // Get the line # of a character position (directly implements debugging interface)
    HRESULT GetLineOfPosition(CFileMap *pFilemap, ULONG cCharacterPosition, ULONG *pcLineNumber, ULONG *pcCharacterOffsetInLine);

    // Return a RUNNING script based on the engine, or NULL if code context has never been requested yet
    CActiveScriptEngine *GetActiveScript(ULONG idEngine);

    // associate a running script for an engine ID (Use after you get the first code context)
    HRESULT AddScript(ULONG idEngine, CActiveScriptEngine *pScriptEngine);

    // attach the CTemplate object to an application (debugger tree view)
    HRESULT AttachTo(CAppln *pAppln);

    // detach the CTemplate object from an application (debugger tree view)
    HRESULT DetachFrom(CAppln *pAppln);

    // detach the CTemplate object all applications (and release script engines)
    HRESULT Detach();

    // Signifies last use of template as a recylable object. Any outstanding references
    // should be from currently executing scripts.
    ULONG End();

    // Let debugger know about page start/end
    HRESULT NotifyDebuggerOnPageEvent(BOOL fStart);

    // Generate 449 response in cookie negotiations with IE when needed
    HRESULT Do449Processing(CHitObj *pHitObj);

    HRESULT PersistData(char    *pszTempFilePath);
    HRESULT UnPersistData();
    HRESULT PersistCleanup();
    ULONG   TemplateSize()  { return m_cbTemplate; }

    TransType GetTransType();
    BOOL FTransacted();
    BOOL FSession();
    BOOL FScriptless();
    BOOL FDebuggable();
    BOOL FIsValid();        // determine if compilation succeeded
    BOOL FTemplateObsolete();
    BOOL FGlobalAsa();
    BOOL FIsZombie();
    BOOL FDontAttach();
    BOOL FIsPersisted();
    VOID Zombify();

    IDispatch *PTypeLibWrapper();

    void       SetHashTablePtr(void  *pTable) { m_pHashTable = pTable; }
    void      *GetHashTablePtr() { return m_pHashTable; }

public:
    /*
        COM public interfaces
        Implementation of debugging documents.
    */

    // IUnknown methods
    STDMETHOD(QueryInterface)(const GUID &, void **);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDebugDocumentProvider methods
    STDMETHOD(GetDocument)(/* [out] */ IDebugDocument **ppDebugDoc);

    // IDebugDocumentInfo (also IDebugDocumentProvider) methods
    STDMETHOD(GetName)(
        /* [in] */ DOCUMENTNAMETYPE dnt,
        /* [out] */ BSTR *pbstrName);

    STDMETHOD(GetDocumentClassId)(/* [out] */ CLSID *)
        {
        return E_NOTIMPL;
        }

    // IDebugDocumentText methods
    STDMETHOD(GetDocumentAttributes)(
        /* [out] */ TEXT_DOC_ATTR *ptextdocattr);

    STDMETHOD(GetSize)(
        /* [out] */ ULONG *pcLines,
        /* [out] */ ULONG *pcChars);

    STDMETHOD(GetPositionOfLine)(
        /* [in] */ ULONG cLineNumber,
        /* [out] */ ULONG *pcCharacterPosition);

    STDMETHOD(GetLineOfPosition)(
        /* [in] */ ULONG cCharacterPosition,
        /* [out] */ ULONG *pcLineNumber,
        /* [out] */ ULONG *pcCharacterOffsetInLine);

    STDMETHOD(GetText)(
        /* [in] */ ULONG cCharacterPosition,
        /* [size_is][length_is][out][in] */ WCHAR *pcharText,
        /* [size_is][length_is][out][in] */ SOURCE_TEXT_ATTR *pstaTextAttr,
        /* [out][in] */ ULONG *pcChars,
        /* [in] */ ULONG cMaxChars);

    STDMETHOD(GetPositionOfContext)(
        /* [in] */ IDebugDocumentContext *psc,
        /* [out] */ ULONG *pcCharacterPosition,
        /* [out] */ ULONG *cNumChars);

    STDMETHOD(GetContextOfPosition)(
        /* [in] */ ULONG cCharacterPosition,
        /* [in] */ ULONG cNumChars,
        /* [out] */ IDebugDocumentContext **ppsc);

    // IConnectionPointContainer methods
    STDMETHOD(EnumConnectionPoints)(
        /* [out] */ IEnumConnectionPoints __RPC_FAR *__RPC_FAR *ppEnum)
            {
            return E_NOTIMPL;   // doubt we need this - client is expecting only TextEvents
            }

    STDMETHOD(FindConnectionPoint)(
        /* [in] */ const IID &iid,
        /* [out] */ IConnectionPoint **ppCP);

private:
    /*  NOTE Compile() works by calling GetSegmentsFromFile followed by WriteTemplate
        Most other private methods support one of these two workhorse functions
    */

    void        AppendMapFile(LPCTSTR szFileSpec, CFileMap* pfilemapParent, BOOLB fVirtual,
                                    CHitObj* pHitObj, BOOLB fGlobalAsp);
    void        GetSegmentsFromFile(CFileMap& filemap, CWorkStore& WorkStore, CHitObj* pHitObj, BOOL fIsHTML = TRUE);
    void        GetLanguageEquivalents();
    void        SetLanguageEquivalent(HANDLE hKeyScriptLanguage, LPSTR szLanguageItem, LPSTR* pszOpen, LPSTR* pszClose);
    void        ThrowError(BYTE* pbErrorLocation, UINT idErrMsg);
    void        AppendErrorMessageInsert(BYTE* pbInsert, UINT cbInsert);
    void        ThrowErrorSingleInsert(BYTE* pbErrorLocation, UINT idErrMsg, BYTE* pbInsert, UINT cbInsert);
    HRESULT     ShowErrorInDebugger(CFileMap* pFilemap, UINT cchErrorLocation, char* szDescription, CHitObj* pHitObj, BOOL fAttachDocument);
    void        ProcessSpecificError(CFileMap& filemap, CHitObj* pHitObj);
    void        HandleCTemplateError(CFileMap* pfilemap, BYTE* pbErrorLocation,
                                        UINT idErrMsg, UINT cInserts, char** ppszInserts, CHitObj *pHitObj);
    void        FreeGoodTemplateMemory();
    void        UnmapFiles();

    // ExtractAndProcessSegment: gets and processes next source segment in search range
    void        ExtractAndProcessSegment(CByteRange& brSearch, const SOURCE_SEGMENT& ssegLeading,
                    _TOKEN* rgtknOpeners, UINT ctknOpeners, CFileMap* pfilemapCurrent, CWorkStore& WorkStore,
                    CHitObj* pHitObj, BOOL fScriptTagProcessed = FALSE, BOOL fIsHTML = TRUE);
    // Support methods for ExtractAndProcessSegment()
    SOURCE_SEGMENT  SsegFromHTMLComment(CByteRange& brSegment);
    void        ProcessSegment(SOURCE_SEGMENT sseg, CByteRange& brSegment, CFileMap* pfilemapCurrent,
                                CWorkStore& WorkStore, BOOL fScriptTagProcessed, CHitObj* pHitObj,
                                BOOL fIsHTML);
    void        ProcessHTMLSegment(CByteRange& brHTML, CBuffer& bufHTMLBlocks, UINT idSequence, CFileMap* pfilemapCurrent);
    void        ProcessHTMLCommentSegment(CByteRange& brSegment, CFileMap* pfilemapCurrent, CWorkStore& WorkStore, CHitObj* pHitObj);
    void        ProcessScriptSegment(SOURCE_SEGMENT sseg, CByteRange& brSegment, CFileMap* pfilemapCurrent,
                                        CWorkStore& WorkStore, UINT idSequence, BOOLB fScriptTagProcessed, CHitObj* pHitObj);
    HRESULT     ProcessMetadataSegment(const CByteRange& brSegment, UINT *pidError, CHitObj* pHitObj);
    HRESULT     ProcessMetadataTypelibSegment(const CByteRange& brSegment, UINT *pidError, CHitObj* pHitObj);
    HRESULT     ProcessMetadataCookieSegment(const CByteRange& brSegment, UINT *pidError, CHitObj* pHitObj);
	void		GetScriptEngineOfSegment(CByteRange& brSegment, CByteRange& brEngine, CByteRange& brInclude);
    void        ProcessTaggedScriptSegment(CByteRange& brSegment, CFileMap* pfilemapCurrent, CWorkStore& WorkStore, CHitObj* pHitObj);
    void        ProcessObjectSegment(CByteRange& brSegment, CFileMap* pfilemapCurrent, CWorkStore& WorkStore,
                                        UINT idSequence);
    void        GetCLSIDFromBrClassIDText(CByteRange& brClassIDText, LPCLSID pclsid);
    void        GetCLSIDFromBrProgIDText(CByteRange& brProgIDText, LPCLSID pclsid);
    BOOLB       FValidObjectName(CByteRange& brName);
    void        ProcessIncludeFile(CByteRange& brSegment, CFileMap* pfilemapCurrent, CWorkStore& WorkStore, UINT idSequence, CHitObj* pHitObj, BOOL fIsHTML);
    void        ProcessIncludeFile2(CHAR* szFileSpec, CByteRange& brFileSpec, CFileMap* pfilemapCurrent, CWorkStore& WorkStore, UINT idSequence, CHitObj* pHitObj, BOOL fIsHTML);
    BYTE*       GetOpenToken(CByteRange brSearch, SOURCE_SEGMENT ssegLeading, _TOKEN* rgtknOpeners, UINT ctknOpeners, _TOKEN* ptknOpen);
    BYTE*       GetCloseToken(CByteRange brSearch, _TOKEN tknClose);
    _TOKEN      GetComplementToken(_TOKEN tkn);
    SOURCE_SEGMENT  GetSegmentOfOpenToken(_TOKEN tknOpen);
    CByteRange  BrTagsFromSegment(CByteRange brSegment, _TOKEN tknClose, BYTE** ppbCloseTag);
    CByteRange  BrValueOfTag(CByteRange brTags, _TOKEN tknTag);
    BYTE*       GetTagName(CByteRange brTags, _TOKEN tknTagName);

    BOOL        GetTag(CByteRange &brTags, int nIndex = 1);
    BOOL        CompTagName(CByteRange &brTags, _TOKEN tknTagName);

    BOOLB       FTagHasValue(const CByteRange& brTags, _TOKEN tknTag, _TOKEN tknValue);
    void        CopySzAdv(char* pchWrite, LPSTR psz);

    // WriteTemplate: writes the template to a contiguous block of memory
    void    WriteTemplate(CWorkStore& WorkStore, CHitObj* pHitObj);
    // Support methods for WriteTemplate()
    // NOTE Adv suffix on some function names == advance ptr after writing
    void    WriteHeader(USHORT cScriptBlocks,USHORT cObjectInfos, USHORT cHTMLBlocks, UINT* pcbHeaderOffset, UINT* pcbOffsetToOffset);
    void    WriteScriptBlockOfEngine(USHORT idEnginePrelim, USHORT idEngine, CWorkStore& WorkStore, UINT* pcbDataOffset,
                                        UINT* pcbOffsetToOffset, CHitObj* pHitObj);
    void    WritePrimaryScriptProcedure(USHORT idEngine, CWorkStore& WorkStore, UINT* pcbDataOffset, UINT cbScriptBlockStart);
    void    WriteScriptSegment(USHORT idEngine, CFileMap* pfilemap, CByteRange& brScript, UINT* pcbDataOffset, UINT cbScriptBlockStart,
                                BOOL fAllowExprWrite);
    void    WriteScriptMinusEscapeChars(CByteRange brScript, UINT* pcbDataOffset, UINT* pcbPtrOffset);
    BOOLB   FVbsComment(CByteRange& brLine);
    BOOLB   FExpression(CByteRange& brLine);
    void    WriteOffsetToOffset(USHORT cBlocks, UINT* pcbHeaderOffset, UINT* pcbOffsetToOffset);
    void    WriteSzAsBytesAdv(LPCSTR szSource, UINT* pcbDataOffset);
    void    WriteByteRangeAdv(CByteRange& brSource, BOOLB fWriteAsBsz, UINT* pcbDataOffset, UINT* pcbPtrOffset);
    void    WriteLongAdv(ULONG uSource, UINT* pcbOffset);
    void    WriteShortAdv(USHORT uSource, UINT* pcbOffset);
    void    MemCpyAdv(UINT* pcbOffset, void* pbSource, ULONG cbSource, UINT cbByteAlign = 0);

    // Memory access primitives
    // NOTE invalid until WriteTemplate() has succeeded
    BYTE*   GetAddress(TEMPLATE_COMPONENT tcomp, USHORT i);

    // Debugging methods
    void    AppendSourceInfo(USHORT idEngine, CFileMap* pfilemap, BYTE* pbSource,
							 ULONG cbSourceOffset, ULONG cbScriptBlockOffset, ULONG cbTargetOffset,
							 ULONG cchSourceText, BOOL fIsHTML);
    UINT    SourceLineNumberFromPb(CFileMap* pfilemap, BYTE* pbSource);
    HRESULT CreateDocumentTree(CFileMap *pfilemapRoot, IDebugApplicationNode **ppDocRoot);
    BOOLB   FIsLangVBScriptOrJScript(USHORT idEngine);

#if 0
    void OutputDebugTables();
    void OutputIncludeHierarchy(CFileMap *pfilemap, int cchIndent);
    void GetScriptSnippets(ULONG cchSourceOffset, CFileMap *pFilemapSource, ULONG cchTargetOffset, ULONG idTargetEngine, wchar_t wszSourceText[], wchar_t wszTargetText[]);
#endif

    void    RemoveFromIncFiles();

    void    ReleaseTypeLibs();
    void    WrapTypeLibs(CHitObj *pHitObj);

    void    Release449();

    HRESULT BuildPersistedDACL(PACL  *ppRetDACL);

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()

public:
    // memory allocation
    static void* SmallMalloc(SIZE_T dwBytes);
    static void* SmallReAlloc(void* pvMem, SIZE_T dwBytes);
    static void  SmallFree(void* pvMem);

    static void* LargeMalloc(SIZE_T dwBytes);
    static void* LargeReAlloc(void* pvMem, SIZE_T dwBytes);
    static void  LargeFree(void* pvMem);
};

////////////////////////////////////////////////////////////////////////////////
//  Inline functions

// Write a long or short to memory, then advance target-ptr
inline void     CTemplate::WriteLongAdv(ULONG uSource, UINT* pcbOffset)
                    { MemCpyAdv(pcbOffset, &uSource, sizeof(ULONG), sizeof(ULONG)); }
inline void     CTemplate::WriteShortAdv(USHORT uSource, UINT* pcbOffset)
                    { MemCpyAdv(pcbOffset, &uSource, sizeof(USHORT), sizeof(USHORT)); }
inline const CTemplateKey * CTemplate::ExtractHashKey() const
					{ return &m_LKHashKey; }
inline TransType CTemplate::GetTransType()
                    { return(m_ttTransacted); }
inline BOOL     CTemplate::FTransacted()
                    { return (m_ttTransacted != ttUndefined); }
inline BOOL     CTemplate::FDebuggable()
                    { return(m_fDebuggable); }
inline BOOL     CTemplate::FSession()
                    { return(m_fSession); }
inline BOOL     CTemplate::FScriptless()
                    { return m_fScriptless; }
inline BOOL     CTemplate::FIsValid()
                    { return(m_fIsValid); }
inline BOOL     CTemplate::FGlobalAsa()
                    { return(m_fGlobalAsa); }
inline BOOL     CTemplate::FIsZombie()
                    { return m_fZombie; }
inline VOID     CTemplate::Zombify()
                    { m_fZombie = TRUE; }
inline BOOL     CTemplate::FDontAttach()
                    { return (m_fDontAttach); }
inline BOOL     CTemplate::FIsPersisted()
                    { return (m_fIsPersisted); }
inline LPTSTR   CTemplate::GetApplnPath(SOURCEPATHTYPE pathtype)
                    { Assert (pathtype == SOURCEPATHTYPE_VIRTUAL); return m_szApplnVirtPath; }
inline IDispatch *CTemplate::PTypeLibWrapper()
                    { return (m_pdispTypeLibWrapper); }


/*  ****************************************************************************
    Class:      CIncFile
    Synopsis:   A file included by one or more templates.

    NOTE: We store an incfile-template dependency by storing a template ptr in m_rgpTemplates.
    This is efficient but ***will break if we ever change Denali to move its memory around***
*/
class CIncFile :
            private CLinkElem,
            public IDebugDocumentProvider,
            public IDebugDocumentText,
            public IConnectionPointContainer    // Source of IDebugDocumentTextEvents
{
// CIncFileMap is a friend so that it can manipulate CLinkElem private members and to access m_ftLastWriteTime
friend class CIncFileMap;

private:
    LONG                m_cRefs;            // ref count - NOTE LONG required by InterlockedIncrement
    TCHAR *             m_szIncFile;        // include file name - NOTE we keep this as a stable ptr to hash table key
    CRITICAL_SECTION    m_csUpdate;         // CS for updating the template ptrs array
    vector<CTemplate *> m_rgpTemplates;     // array of ptrs to templates which include this include file
    CTemplateConnPt     m_CPTextEvents;     // Connection point for IDebugDocumentTextEvents
    BOOLB               m_fCsInited;        // has CS been initialized yet?

    CTemplate::CFileMap *GetFilemap();      // Return the filemap pointer from a template

public:
                CIncFile();
    HRESULT     Init(const TCHAR* szIncFile);
                ~CIncFile();
    HRESULT     AddTemplate(CTemplate* pTemplate);
    void        RemoveTemplate(CTemplate* pTemplate);
    CTemplate*  GetTemplate(int iTemplate);
    BOOL        FlushTemplates();
    TCHAR *     GetIncFileName() { return m_szIncFile; }
    void        OnIncFileDecache();

    /*
        COM public interfaces
        Implementation of debugging documents.
    */

    // IUnknown methods
    STDMETHOD(QueryInterface)(const GUID &, void **);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDebugDocumentProvider methods
    STDMETHOD(GetDocument)(/* [out] */ IDebugDocument **ppDebugDoc);

    // IDebugDocumentInfo (also IDebugDocumentProvider) methods
    STDMETHOD(GetName)(
        /* [in] */ DOCUMENTNAMETYPE dnt,
        /* [out] */ BSTR *pbstrName);

    STDMETHOD(GetDocumentClassId)(/* [out] */ CLSID *)
        {
        return E_NOTIMPL;
        }

    // IDebugDocumentText methods
    STDMETHOD(GetDocumentAttributes)(
        /* [out] */ TEXT_DOC_ATTR *ptextdocattr);

    STDMETHOD(GetSize)(
        /* [out] */ ULONG *pcLines,
        /* [out] */ ULONG *pcChars);

    STDMETHOD(GetPositionOfLine)(
        /* [in] */ ULONG cLineNumber,
        /* [out] */ ULONG *pcCharacterPosition);

    STDMETHOD(GetLineOfPosition)(
        /* [in] */ ULONG cCharacterPosition,
        /* [out] */ ULONG *pcLineNumber,
        /* [out] */ ULONG *pcCharacterOffsetInLine);

    STDMETHOD(GetText)(
        /* [in] */ ULONG cCharacterPosition,
        /* [size_is][length_is][out][in] */ WCHAR *pcharText,
        /* [size_is][length_is][out][in] */ SOURCE_TEXT_ATTR *pstaTextAttr,
        /* [out][in] */ ULONG *pcChars,
        /* [in] */ ULONG cMaxChars);

    STDMETHOD(GetPositionOfContext)(
        /* [in] */ IDebugDocumentContext *psc,
        /* [out] */ ULONG *pcCharacterPosition,
        /* [out] */ ULONG *cNumChars);

    STDMETHOD(GetContextOfPosition)(
        /* [in] */ ULONG cCharacterPosition,
        /* [in] */ ULONG cNumChars,
        /* [out] */ IDebugDocumentContext **ppsc);

    // IConnectionPointContainer methods
    STDMETHOD(EnumConnectionPoints)(
        /* [out] */ IEnumConnectionPoints __RPC_FAR *__RPC_FAR *ppEnum)
            {
            return E_NOTIMPL;   // doubt we need this - client is expecting only TextEvents
            }

    STDMETHOD(FindConnectionPoint)(
        /* [in] */ const IID &iid,
        /* [out] */ IConnectionPoint **ppCP);

};

#endif /* _TEMPLATE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\template.cpp ===
//depot/private/jasbr/inetsrv/iis/svcs/cmp/asp/template.cpp#19 - edit change 3548 (text)
/*==============================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

File:           template.cpp
Maintained by:  DaveK
Component:      source file for Denali Compiled Template object
==============================================================================*/
#include "denpre.h"

#pragma hdrstop

const int SNIPPET_SIZE = 20;    // # of characters in the code snippets

#pragma warning( disable : 4509 )   // suppress SEH/destructor warnings
#pragma warning( disable : 4355 )   // ignore: "'this' used in base member init

#include "debugger.h"
#include "dbgutil.h"
#include "tlbcache.h"
#include "ie449.h"

#include "memchk.h"
#include "vecimpl.h"    // Include after memchk to insure that vector uses our mem manager.

#include "Accctrl.h"
#include "aclapi.h"

// Init class statics
CTemplate::CTokenList *CTemplate::gm_pTokenList = NULL;
PTRACE_LOG CTemplate::gm_pTraceLog = NULL;
HANDLE CTemplate::sm_hSmallHeap = NULL;
HANDLE CTemplate::sm_hLargeHeap = NULL;

// Max # of opener tokens to look for
#define TOKEN_OPENERS_MAX   8

// Expose AspDoRevertHack and AspUndoRevertHack so that it can be used in template.cpp
extern VOID AspDoRevertHack( HANDLE * phToken );
extern VOID AspUndoRevertHack( HANDLE * phToken );

/*===================================================================
    Private non-class support functions
===================================================================*/
static void       ByteRangeFromPb(BYTE* pbSource, CByteRange& brTarget);
static BOOLB      FByteRangesAreEqual(CByteRange& br1, CByteRange& br2);
static unsigned   CharAdvDBCS(WORD wCodePage, char *pchStart, char *pchEnd, unsigned cCharAdv, char **ppchEnd, BOOL fForceDBCS = FALSE);
static void       LineFromByteRangeAdv(CByteRange& br, CByteRange& brLine);
static void       LTrimWhiteSpace(CByteRange& br);
static void       RTrimWhiteSpace(CByteRange& br);
static CByteRange BrNewLine(CByteRange br);
static BOOLB      FWhiteSpace(char ch, BOOLB fSpaceIsWhiteSpace = TRUE);
static BOOLB      FByteRangeIsWhiteSpace(CByteRange br);
static BOOLB      FTagName(BYTE* pb, UINT cb);
static void       ByteAlignOffset(UINT* pcbOffset, UINT cbAlignment);
static void       GetSzFromPatternInserts(char* pszPattern, UINT cInserts, char** ppszInserts, char* szReturned);
static UINT       CchPathFromFilespec(LPCTSTR szFile);
static void       GetPathFromParentAndFilespec(LPCTSTR szParentPath, LPCTSTR szFileSpec, LPTSTR* pszPath);
static void       HandleAccessFailure(CHitObj* pHitObj, TCHAR* szFile);
static void       SendToLog(DWORD dwMask, CHAR *szFileName, CHAR *szLineNum, CHAR *szShortDes, CHAR *szLongDes, CHAR *szEngine, CHitObj *pHitObj);
static HRESULT    GetProgLangId(CByteRange& brEngine, PROGLANG_ID* pProgLangId);

inline
void __cdecl DebugPrintf(LPCSTR fmt, ...)
    {
#if DBG
    char msg[512];
    va_list marker;
    va_start(marker, fmt);
    vsprintf(msg, fmt, marker);
    va_end(marker);
    OutputDebugStringA(msg);
#endif
    }


/*  ============================================================================
    ByteRangeFromPb
    Gets a byte range from a contiguous block of memory

Returns:
    Nothing.

Side effects:
    None.
*/
void
ByteRangeFromPb
(
BYTE*       pbSource,
CByteRange& brTarget
)
    {
    Assert(pbSource != NULL);
    brTarget.m_cb = *(ULONG*)pbSource;
    brTarget.m_pb = pbSource + sizeof(ULONG);
    }

/*  ============================================================================
    FByteRangesAreEqual

    Compares two byte ranges

    Returns:
        BOOLB. True if byte ranges are equal, else false.

    Side effects:
        None.
*/
BOOLB
FByteRangesAreEqual
(
CByteRange& br1,
CByteRange& br2
)
    {
    if(br1.m_cb != br2.m_cb)
        return FALSE;
    return (!_strnicmp((LPCSTR)br1.m_pb, (LPCSTR)br2.m_pb, br1.m_cb));
    }

/*  ============================================================================
    CharAdvDBCS

    Advance "cchCharAdv" characters in a buffer
    SBCS: Degenerates to simple pointer arithmatic

    Arguments:
            wCodePage       - code page
            pchStart        - pointer to beginning of segment
            pchEnd          - pointer to just past end of segment
            cCharAdv        - # of characters to advance
            ppchEnd         - [output], contains pointer "cCharAdv" chars past pchStart
            fForceDBCS      - if TRUE, always use double byte algorithm.
                                (for verifying correct behavior of func in debug mode)

    Returns:
        (int) # of characters that we actually advanced

    Notes:
        By passing INFINITE for "cCharAdv", you can use this function to count characters
        in a block

    Side effects:
        None.
*/
unsigned
CharAdvDBCS
(
WORD wCodePage,
char *pchStart,
char *pchEnd,
unsigned cCharAdv,
char **ppchEnd,
BOOL fForceDBCS
)
    {
    CPINFO CpInfo;
    GetCPInfo(wCodePage, &CpInfo);
    if (!fForceDBCS && CpInfo.MaxCharSize == 1)
        {
        char *pchT = pchStart + min(cCharAdv, unsigned(pchEnd - pchStart));

        if (ppchEnd)
            *ppchEnd = pchT;

        #if DBG
            // Verify DBCS algorithm (not often tested otherwise)
            char *pchTest;
            unsigned cchTest = CharAdvDBCS(wCodePage, pchStart, pchEnd, cCharAdv, &pchTest, TRUE);
            Assert (cchTest == unsigned(pchT - pchStart) && pchTest == pchT);
        #endif

        return DIFF(pchT - pchStart);
        }
    else
        {
        int cch = 0;
        char *pchNext = pchStart;

        // Count DBCS characters. We have to stop before pchEnd because
        // pchEnd may point past file map and CharNextExA AVs when advancing
        // past allocated memory

        while (cCharAdv > 0 && pchNext < pchEnd-2)
            {
            pchNext = *pchNext? AspCharNextA(wCodePage, pchNext) : pchNext + 1;
            --cCharAdv;
            ++cch;
            }

        // We could stop on the last or the before last character
        // depending on the DBCS char sequence
        if (cCharAdv > 0 && pchNext == pchEnd-1)
            {
            // Only one byte - has to be one single byte character
            ++pchNext;
            ++cch;
            }

        else if (cCharAdv > 0 && pchNext == pchEnd-2)
            {
            // 2 bytes left - either 1 2-byte char or 2 1-byte chars
            if (IsDBCSLeadByteEx(wCodePage, *pchNext))
                {
                ++cch;
                pchNext += 2;
                }
            else
                {
                // Two characters left. If cCharAdv > 1, this means that user wants to
                // advance at least two more chars. Otherwise, cCharAdv == 1, and
                // we advance one char
                //
                if (cCharAdv > 1)
                    {
                    cch += 2;
                    pchNext += 2;
                    }
                else
                    {
                    Assert (cCharAdv == 1);
                    ++cch;
                    ++pchNext;
                    }
                }
            }

        if (ppchEnd)
            *ppchEnd = pchNext;

        return cch;
        }
    }

/*  ============================================================================
    LineFromByteRangeAdv
    Gets the first line in a byte range.

    Returns:
        Nothing

    Side effects:
        Advances source byte range to just beyond its first non-white-space line,
        if one is found.

*/
void
LineFromByteRangeAdv
(
CByteRange& brSource,
CByteRange& brLine
)
    {
    CByteRange brTemp;

    if(brSource.IsNull())
        {
        brLine.Nullify();
        return;
        }

    brLine.m_pb = brSource.m_pb;

        brTemp = BrNewLine(brSource);
    if(brTemp.IsNull())
        {
        // We found no newline in a non-empty byte range:
        // set line range to entire source byte range and empty source byte range
        brLine.m_cb = brSource.m_cb;
        brSource.Nullify();
        }
    else
        {
        // We found a newline in a non-empty byte range:
        // set line range to portion of source byte range before new line;
        // set source range to portion of source range after new line
        brLine.m_cb = DIFF(brTemp.m_pb - brSource.m_pb);
        brSource.m_pb = brTemp.m_pb + brTemp.m_cb;
        brSource.m_cb -= (brLine.m_cb + brTemp.m_cb);
        }
    }

/*  ============================================================================
LTrimWhiteSpace

Left-trim white space from byte-range

Returns:
    Nothing

Side effects:
    Advances byte range to just beyond its first non-white-space character.

*/
void
LTrimWhiteSpace
(
CByteRange& br
)
    {
    if(br.IsNull())
        return;
    while(FWhiteSpace(*br.m_pb))
        {
        br.m_pb++;
        if(--br.m_cb == 0)
            return;
        }
    }

/*  ============================================================================
    RTrimWhiteSpace
    Right-trim white space from byte-range
*/
void
RTrimWhiteSpace(CByteRange& br)
    {
    if(br.IsNull())
        return;
    while(FWhiteSpace(*(br.m_pb + br.m_cb - 1)))
        {
        if(--br.m_cb == 0)
            return;
        }
    }

/*  ============================================================================
    BrNewLine
    Returns ptr to the first newline in a byte range
    NOTE does not change byte range (since it is passed by value)
*/
CByteRange
BrNewLine(CByteRange br)
    {
    while(!br.IsNull())
        {
        if(*br.m_pb == '\r')
                        return CByteRange(br.m_pb, (br.m_cb > 1 && br.m_pb[1] == '\n')? 2 : 1);

        else if (*br.m_pb == '\n')
                return CByteRange(br.m_pb, 1);

        ++br.m_pb;
        --br.m_cb;
        }
    return CByteRange();
    }

/*  ============================================================================
    FWhiteSpace
    Returns:
        TRUE if ch is a white-space character, else returns FALSE
        Certain character(s) (e.g. space) may be treated as
        non-white-space; to do this, caller passes FALSE for
        fSpaceIsWhiteSpace flag.
*/
BOOLB
FWhiteSpace(char ch, BOOLB fSpaceIsWhiteSpace)
{
    switch (ch)
    {
        case ' ':
            return fSpaceIsWhiteSpace;
        case '\0':
            return TRUE;
        case '\a':
            return TRUE;
        case '\b':
            return TRUE;
        case '\f':
            return TRUE;
        case '\n':
            return TRUE;
        case '\r':
            return TRUE;
        case '\t':
            return TRUE;
        case '\v':
            return TRUE;
        default:
            return FALSE;
    }
}

/*  ============================================================================
    FByteRangeIsWhiteSpace
    Is the entire input byte range white space?
    NOTE input byte range is byval; caller's copy is not changed
*/
BOOLB
FByteRangeIsWhiteSpace(CByteRange br)
    {
    while(!br.IsNull())
        {
        if(!FWhiteSpace(*(br.m_pb)))
            return FALSE;
        br.Advance(1);
        }

    return TRUE;
    }

/*  ============================================================================
    FTagName
    Does pb point to a valid HTML tag name?
    (i.e., is *pb a valid HTML tag name and not a substring?)

    Returns
        TRUE or FALSE
    Side effects
        None
*/
BOOLB
FTagName(BYTE* pb, UINT cb)
    {
    if((pb == NULL) || (cb == 0))
        return FALSE;

    // a valid HTML tag name must be preceded by white space  ...
    if( FWhiteSpace(*(pb - 1)) ||  *(pb - 1) == '@' )
        {
        // ... and followed either by white space or the tag separator
        if(FWhiteSpace(*(pb + cb)))
            return TRUE;
        else if(*(pb + cb) == CH_ATTRIBUTE_SEPARATOR)
            return TRUE;
        }

    return FALSE;
    }

/*===================================================================
    ByteAlignOffset
    Byte-aligns an offset value, based on size of source data
*/
void
ByteAlignOffset
(
UINT*   pcbOffset,      // ptr to offset value
UINT    cbAlignment // Alignment boundary
)
    {
        // comment the below code out so that it works for 64 bit...

    // only byte-align for 2-, or 4-byte data
    // since our base pointer in only aligned to a 4 byte boundary
    //if(cbAlignment == 2 || cbAlignment == 4)
        //{
        // if current offset does not fall on a byte-aligned location for current data type,
        // advance offset to next byte-aligned location
                Assert(cbAlignment > 0);
        --cbAlignment;
                if (*pcbOffset & cbAlignment)
                        *pcbOffset = (*pcbOffset + cbAlignment + 1) & ~cbAlignment;
    }

/*  ============================================================================
    GetSzFromPatternInserts
    Returns a 'resolved' version of a pattern string, i.e. a new string in which
    | characters have been replaced by caller-specified insert strings.
    NOTE this function allocates, but caller must free

    Returns:
        Nothing
    Side effects:
        allocates memory
*/
void
GetSzFromPatternInserts
(
char*   pszPattern,     // 'pattern' string
UINT    cInserts,       // count of insert strings
char**  ppszInserts,    // array of ptrs to insert strings
char*   szReturned      // returned string MUST be allocated by caller
)
    {
    UINT    cchRet = strlen(pszPattern);   // length of return string
    char*   pchStartCopy = pszPattern;      // ptr to start of copy range in pattern
    char*   pchEndCopy = pszPattern;        // ptr to end of copy range in pattern
    UINT    cActualInserts = 0;             // count of actual insert strings

    // init return string to empty so we can concatenate onto it
    szReturned[0] = NULL;

    // zero out length of return string - we now use it to count actual length as we build return string
    cchRet = 0;

    while(TRUE)
        {
        // advance end-of-copy ptr through pattern looking for insertion points or end of string

        while ((*pchEndCopy != NULL) && (IsDBCSLeadByte(*pchEndCopy) || (*pchEndCopy != '|')))
            pchEndCopy = CharNextA(pchEndCopy);

        // cat from start-of-copy to end-of-copy onto return string
        strncat(szReturned, pchStartCopy, DIFF(pchEndCopy - pchStartCopy));

        // update return string length
        cchRet += DIFF(pchEndCopy - pchStartCopy);

        // if we are at end of pattern, exit
        if(*pchEndCopy == NULL)
            goto Exit;

        if(cActualInserts < cInserts)
            {
            // if inserts remain, cat the next one onto return string
            strcat(szReturned, ppszInserts[cActualInserts]);
            // update return string length
            cchRet += strlen(ppszInserts[cActualInserts]);
            cActualInserts++;
            }

        // advance end-of-copy and start-of-copy beyond insertion point
        pchEndCopy++;
        pchStartCopy = pchEndCopy;
        }

Exit:
    // null-terminate return string
    szReturned[cchRet] = NULL;
    }

/*  ============================================================================
    CchPathFromFilespec
    Returns a filespec's path length (exclusive of filespec)
    NOTE path string includes trailing '\' or '/'

    Returns:
        Length of path string
    Side effects:
        None
*/
UINT
CchPathFromFilespec
(
LPCTSTR  szFileSpec  // filespec
)
    {
    // BUG FIX 102010 DBCS fixes
    //int   ich = lstrlen(szFileSpec) - 1;  // index of char to compare
    //
    //while(*(szFileSpec + ich) != '\\' && *(szFileSpec + ich) != '/')
    //  {
    //  if(--ich < 0)
    //      THROW(E_FAIL);
    //  }
    //return (UINT) (ich + 1);  // path length, including trailing '\' or '/', is char index + 1

    TCHAR* p1 = _tcsrchr(szFileSpec, _T('\\'));
    TCHAR* p2 = _tcsrchr(szFileSpec, _T('/'));        // this wont be a DBCS trail byte.

    if (p1 == NULL && p2 == NULL)
        THROW(E_FAIL);

    return (UINT) ((((LPTSTR)max(p1,p2) - szFileSpec)) + 1);
    }

/*  ============================================================================
    GetPathFromParentAndFilespec
    Returns an absolute path which is a 'parent' file's path concatenated with a filespec.

    Returns:
        absolute path (out-parameter)
    Side effects:
        None
*/
void
GetPathFromParentAndFilespec
(
LPCTSTR  szParentPath,   // parent path
LPCTSTR  szFileSpec,     // filespec
LPTSTR*  pszPath         // resolved path (out-parameter)
)
    {
    UINT    cchParentPath = CchPathFromFilespec(szParentPath);

	if ((cchParentPath + _tcslen(szFileSpec)) > MAX_PATH)
		THROW(E_FAIL);
	
    _tcsncpy(*pszPath, szParentPath, cchParentPath);
    _tcscpy(*pszPath + cchParentPath, szFileSpec);
    }

/*  ============================================================================
    HandleAccessFailure
    Handles an access-denied failure

    Returns:
        nothing
    Side effects:
        none
*/
void
HandleAccessFailure
(
CHitObj*    pHitObj,	// browser's hitobj
TCHAR *     szFile		// file path of main template
)
    {
    Assert(pHitObj);

        // debugging diagnostic print
#if DBG

    STACK_BUFFER( authUserBuff, 32 );

    char *szAuthUser;
    DWORD cbAuthUser;

    if (SERVER_GET(pHitObj->PIReq(), "AUTH_USER", &authUserBuff, &cbAuthUser)) {
	    szAuthUser = (char*)authUserBuff.QueryPtr();
    }
    else {
            szAuthUser = "anonymous";
    }

#if UNICODE
	DBGPRINTF((DBG_CONTEXT, "No permission to read file %S\n", szFile != NULL? szFile : pHitObj->PIReq()->QueryPszPathTranslated()));
#else
	DBGPRINTF((DBG_CONTEXT, "No permission to read file %s\n", szFile != NULL? szFile : pHitObj->PIReq()->QueryPszPathTranslated()));
#endif
    DBGPRINTF((DBG_CONTEXT, "  The user account is \"%s\"\n", szAuthUser));
#endif

    CResponse *pResponse = pHitObj->PResponse();
    if (!pResponse)
        return;

    pHitObj->PIReq()->SetDwHttpStatusCode(401);
    HandleSysError(401,3,IDE_401_3_ACCESS_DENIED,IDH_401_3_ACCESS_DENIED,pHitObj->PIReq(),pHitObj);

    return;
    }

/*  ============================================================================
    SendToLog
    Sends Error Info to Log

    Returns:
        Nothing

    Side effects:
        None.
*/
void
SendToLog
(
DWORD   dwMask,
CHAR    *szFileName,
CHAR    *szLineNum,
CHAR    *szEngine,
CHAR    *szErrCode,
CHAR    *szShortDes,
CHAR    *szLongDes,
CHitObj *pHitObj    // browser's hitobj
)
{
    CHAR    *szFileNameT;
    CHAR    *szLineNumT;
    CHAR    *szEngineT;
    CHAR    *szErrCodeT;
    CHAR    *szShortDesT;
    CHAR    *szLongDesT;
    if(pHitObj) {
        // NOTE - szFileName is assumed to be UTF8 when UNICODE is defined
        szFileNameT = StringDupA(szFileName);
        szLineNumT  = StringDupA(szLineNum);
        szEngineT   = StringDupA(szEngine);
        szErrCodeT  = StringDupA(szErrCode);
        szShortDesT = StringDupA(szShortDes);
        szLongDesT  = StringDupA(szLongDes);

        HandleError(szShortDesT, szLongDesT, dwMask, szFileNameT, szLineNumT, szEngineT, szErrCodeT, NULL, pHitObj);
        }
    }

/*  ============================================================================
    FreeNullify
    Frees and nullifies a ptr to memory allocated with malloc.

    Returns:
        Nothing
    Side effects:
        None
*/
static void
FreeNullify
(
void**  pp
)
    {
    if(*pp != NULL)
        {
        free(*pp);
        *pp = NULL;
        }
    }

/*  ============================================================================
    SmallTemplateFreeNullify
    Frees and nullifies a ptr to memory allocated with CTemplate::SmallMalloc.

    Returns:
        Nothing
    Side effects:
        None
*/
static void
SmallTemplateFreeNullify
(
void**  pp
)
    {
    if(*pp != NULL)
        {
        CTemplate::SmallFree(*pp);
        *pp = NULL;
        }
    }

/*  ============================================================================
    LargeTemplateFreeNullify
    Frees and nullifies a ptr to memory allocated with CTemplate::LargeMalloc.

    Returns:
        Nothing
    Side effects:
        None
*/
static void
LargeTemplateFreeNullify
(
void**  pp
)
    {
    if(*pp != NULL)
        {
        CTemplate::LargeFree(*pp);
        *pp = NULL;
        }
    }

/*  ============================================================================
    GetProgLangId
    Gets the prog lang id for a script engine

    Returns:
        Nothing
    Side effects:
        throws on error
*/
HRESULT
GetProgLangId
(
CByteRange&     brEngine,   // engine name
PROGLANG_ID*    pProgLangId // prog lang id (out-parameter)
)
    {

    STACK_BUFFER( tempEngine, 128 );

    if (!tempEngine.Resize(brEngine.m_cb + 1)) {
        return E_OUTOFMEMORY;
    }

    LPSTR           szProgLang = static_cast<LPSTR> (tempEngine.QueryPtr());

    strncpy(szProgLang, (LPCSTR)brEngine.m_pb, brEngine.m_cb);
    szProgLang[brEngine.m_cb] = '\0';

    return g_ScriptManager.ProgLangIdOfLangName((LPCSTR) szProgLang, pProgLangId);
    }

/*  ****************************************************************************
    CByteRange member functions
*/

/*  ========================================================
    CByteRange::Advance
    Advances a byte range.
*/
void
CByteRange::Advance(UINT i)
    {
    if(i >= m_cb)
        {
        Nullify();
        }
    else
        {
        m_pb += i;
        m_cb -= i;
        }
    }

/*  ========================================================
    CByteRange::FMatchesSz
    Compares a byte range with a string, case-insensitively
*/
BOOLB
CByteRange::FMatchesSz
(
LPCSTR psz
)
    {
    if(IsNull() || (psz == NULL))
        return FALSE;
    if((ULONG)strlen(psz) != m_cb)
        return FALSE;
    return !_strnicmp((const char*)m_pb, psz, m_cb);
    }

/*  ============================================================================
    CByteRange::PbString
    Finds a case-insensitive string within a byte range

    Returns:
        Ptr to first case-insensitive occurrence of the string in this byte range;
        NULL if none found.
    Side effects:
        None
*/
BYTE*
CByteRange::PbString
(
LPSTR   psz,
LONG    lCodePage
)
    {
    UINT cch = strlen(psz);
    if(cch == 0)
        return NULL;

    BYTE *pbLocal  = m_pb;
    UINT  cbLocal  = m_cb;
    char  ch0 = psz[0];
    BYTE *pbTemp = NULL;
    UINT cbAdvanced = 0;

    if (IsCharAlpha(ch0))
        {
        // cannot use strchr
        while (cbLocal >= cch)
            {
            if (_strnicmp((const char *)pbLocal, psz, cch) == 0)
                return pbLocal;

            // The following code simply performs a DBCS-enabled ByteRange.Advance() action.
            pbTemp = pbLocal;
            pbLocal = *pbLocal? (BYTE *)AspCharNextA((WORD)lCodePage, (const char *)pbLocal) : pbLocal + 1;
            cbAdvanced = DIFF(pbLocal - pbTemp);
            if (cbAdvanced >= cbLocal)
                {
                cbLocal = 0;
                pbLocal = NULL;
                }
            else
                cbLocal -= cbAdvanced;
            }
        }
    else
        {
        // can use strchr
        while (cbLocal >= cch)
            {
            pbTemp = (BYTE *)memchr(pbLocal, ch0, cbLocal);
            if (pbTemp == NULL)
                break;
            UINT cbOffset = DIFF(pbTemp - pbLocal);
            if (cbOffset >= cbLocal)
                break;
            pbLocal = pbTemp;
            cbLocal -= cbOffset;
            if (cch <= cbLocal && _strnicmp((const char *)pbLocal, psz, cch) == 0)
                return pbLocal;
            // The following code simply performs a DBCS-enabled ByteRange.Advance() action.
            pbTemp = pbLocal;
            pbLocal = *pbLocal? (BYTE *)AspCharNextA((WORD)lCodePage, (const char *)pbLocal) : pbLocal + 1;
            cbAdvanced = DIFF(pbLocal - pbTemp);
            if (cbAdvanced >= cbLocal)
                {
                cbLocal = 0;
                pbLocal = NULL;
                }
            else
                cbLocal -= cbAdvanced;
            }
        }

    return NULL;
    }

/*  ============================================================================
    CByteRange::PbOneOfAspOpenerStringTokens
    Finds a case-insensitive string within a byte range
        that matches one of the strings passed

!!! WILL ONLY WORK IF THE FOLLOWING IS TRUE:
        1) All the tokens start with the same charater (for example '<')
        2) This character is not alpha (so that strchr() would work)
!!! THE ABOVE ASSUMPTIONS MAKE THE CODE WORK FASTER

    Returns:
        Ptr to first case-insensitive occurrence of the string in this byte range;
        NULL if none found.
        *pcindex is set to the index of string found
    Side effects:
        None
*/
BYTE*
CByteRange::PbOneOfAspOpenerStringTokens
(
LPSTR rgszTokens[],
UINT rgcchTokens[],
UINT nTokens,
UINT *pidToken
)
{
    if (nTokens == 0)
        return NULL;

    BYTE *pb  = m_pb;               // pointer to unsearched remainder of the range
    UINT  cbRemainder = m_cb;       // remaining byte range length
    char  ch0 = rgszTokens[0][0];   // first char of every token

    while (cbRemainder > 0) {
        // BUG 82331: avoid strchr() because byte range is not null-terminated
        while (cbRemainder > 0 && *pb != ch0)
            {
            ++pb;
            --cbRemainder;
            }

        if (cbRemainder == 0)
            break;

        for (UINT i = 0; i < nTokens; i++) {

            if ((rgcchTokens[i] <= cbRemainder)
                && (rgszTokens[i] != NULL)
                && (_strnicmp((const char *)pb, rgszTokens[i], rgcchTokens[i]) == 0)) {

                *pidToken = i;
                return pb;
            }
        }
        ++pb;
        --cbRemainder;
    }

    return NULL;
}


/*  ============================================================================
    CByteRange::FEarlierInSourceThan
    Does this byte range occur earlier in source than parameter byte range?

    Returns
        TRUE or FALSE
    Side effects
        None
*/
BOOLB
CByteRange::FEarlierInSourceThan(CByteRange& br)
    {
    if(br.IsNull())
        return TRUE;
    return(m_idSequence < br.m_idSequence);
    }

/*  ****************************************************************************
    CTemplate member functions
*/

/*  ============================================================================
    CTemplate::InitClass
    Initilaizes CTemplate static members

    Returns:
        hresult
    Side effects:
        allocates memory for static members
*/
HRESULT
CTemplate::InitClass
(
)
    {
    HRESULT hr = S_OK;

    TRY
        // init heaps
        sm_hSmallHeap = ::HeapCreate(0, 0, 0);
        sm_hLargeHeap = ::HeapCreate(0, 0, 0);

        // Init token list
        gm_pTokenList = new CTokenList;
                if (gm_pTokenList == NULL)
                        return E_OUTOFMEMORY;

        gm_pTokenList->Init();

    CATCH(hrException)
        hr = hrException;
    END_TRY

    return hr;
    }

/*  ============================================================================
    CTemplate::UnInitClass
    Un-initilaizes CTemplate static members

    Returns:
        Nothing
    Side effects:
        None
*/
void
CTemplate::UnInitClass()
    {
    delete gm_pTokenList;
    gm_pTokenList = NULL;

    ::HeapDestroy(sm_hLargeHeap);
    if (sm_hLargeHeap != sm_hSmallHeap)
        ::HeapDestroy(sm_hSmallHeap);
    sm_hLargeHeap = sm_hSmallHeap = NULL;
    }


/*  ============================================================================
    CTemplate::Init
    Inits template in preparation for calling Compile
    Does the minimum needed

    Returns:
        Success or failure code
    Side effects:
        Allocates memory
*/
HRESULT
CTemplate::Init
(
CHitObj            *pHitObj,            // ptr to template's hit object
BOOL                fGlobalAsa,         // is this the global.asa file?
const CTemplateKey &rTemplateKey        // hash table key
)
    {
    HRESULT hr;

    // Create debug critical section
    ErrInitCriticalSection(&m_csDebuggerDetach, hr);
    if (FAILED(hr))
        return hr;

    // note critical section creation success
    m_fDebuggerDetachCSInited = TRUE;

    // Create event: manual-reset, ready-for-use event; non-signaled
    m_hEventReadyForUse = IIS_CREATE_EVENT(
                              "CTemplate::m_hEventReadyForUse",
                              this,
                              TRUE,     // flag for manual-reset event
                              FALSE     // flag for initial state
                              );
    if (!m_hEventReadyForUse)
        return E_OUTOFMEMORY;

    // cache GlobalAsp flag
    m_fGlobalAsa = BOOLB(fGlobalAsa);

    // CIsapiReqInfo better be present
    if (pHitObj->PIReq() == NULL)
        return E_POINTER;

    // Initialize the template's code page

    m_wCodePage = pHitObj->PAppln()->QueryAppConfig()->uCodePage();
    m_lLCID = pHitObj->PAppln()->QueryAppConfig()->uLCID();

    STACK_BUFFER( serverNameBuff, 32 );
    STACK_BUFFER( serverPortBuff, 10 );
    STACK_BUFFER( portSecureBuff, 8 );

    DWORD cbServerName;
    DWORD cbServerPort;
        DWORD cbServerPortSecure;

    // Construct a URL for the application

    // Get the server name and port
    if (!SERVER_GET(pHitObj->PIReq(), "SERVER_NAME", &serverNameBuff, &cbServerName)
        || !SERVER_GET(pHitObj->PIReq(), "SERVER_PORT", &serverPortBuff, &cbServerPort)) {

        if (GetLastError() == E_OUTOFMEMORY) {
            hr = E_OUTOFMEMORY;
        }
        else {
            hr = E_FAIL;
        }
        return hr;
    }

    char *szServerPort = (char *)serverPortBuff.QueryPtr();
    char *szServerName = (char *)serverNameBuff.QueryPtr();

    BOOL fServerPortSecure = FALSE;

	// determine if server port is secure
    if (SERVER_GET(pHitObj->PIReq(), "SERVER_PORT_SECURE", &portSecureBuff, &cbServerPortSecure)) {
	    char *szServerPortSecure = (char *)portSecureBuff.QueryPtr();
        fServerPortSecure = (szServerPortSecure[0] == '1');
    }

    // Get the application virtual path
    TCHAR szApplnVirtPath[256];
    if (FAILED(hr = FindApplicationPath(pHitObj->PIReq(), szApplnVirtPath, sizeof szApplnVirtPath)))
        return hr;

    TCHAR   *szServerNameT;
    TCHAR   *szServerPortT;

#if UNICODE
    CMBCSToWChar convServer;
    if (FAILED(hr = convServer.Init(szServerName))) {
        return hr;
    }
    szServerNameT = convServer.GetString();
#else
    szServerNameT = szServerName;
#endif

#if UNICODE
    CMBCSToWChar convPort;
    if (FAILED(hr = convPort.Init(szServerPort))) {
        return hr;
    }
    szServerPortT = convPort.GetString();
#else
    szServerPortT = szServerPort;
#endif

    // Allocate space for and construct the application URL
    m_szApplnURL = new TCHAR [(9 /* sizeof "https://:" */ + _tcslen(szServerNameT) + _tcslen(szServerPortT) + _tcslen(szApplnVirtPath) + 1)];
    if (m_szApplnURL == NULL)
        return E_OUTOFMEMORY;

    TCHAR *pT;

    // start with the protocol prefix...

    pT = strcpyEx(m_szApplnURL, fServerPortSecure? _T("https://") : _T("http://"));

    // next add the servername

    pT = strcpyEx(pT, szServerNameT);

    // next the colon between the servername and the serverport

    pT = strcpyEx(pT, _T(":"));

    // next the server port

    pT = strcpyEx(pT, szServerPortT);

    // now the applURL is built up to the appln path.  The next step will be to
    // add the virtpath.  

    m_szApplnVirtPath = pT;

    _tcscpy(m_szApplnVirtPath, szApplnVirtPath);

    m_LKHashKey.dwInstanceID = rTemplateKey.dwInstanceID;
    if ((m_LKHashKey.szPathTranslated = StringDup((TCHAR *)rTemplateKey.szPathTranslated)) == NULL)
    	return E_OUTOFMEMORY;

    return S_OK;
    }

/*  ============================================================================
    CTemplate::Compile
    Compiles the template from its source file and include files, if any,
    by calling GetSegmentsFromFile (to populate WorkStore),
    followed by WriteTemplate (to create the template from WorkStore).

    Returns:
        HRESULT indicating success or type of failure
    Side effects:
        Indirectly allocates memory (via WriteTemplate)
        Indirectly frees memory on error (via FreeGoodTemplateMemory)
*/
HRESULT
CTemplate::Compile
(
CHitObj*    pHitObj
)
    {
    HRESULT hr = S_OK;

    // The following code moved from Init() (to make Init() lighter)

    Assert(pHitObj);

    // Create and Init WorkStore

    if (SUCCEEDED(hr))
        {
        // construct the workstore - bail on fail
        if(NULL == (m_pWorkStore = new CWorkStore))
            hr = E_OUTOFMEMORY;
        }

    if (SUCCEEDED(hr))
        {
        hr = (m_pWorkStore->m_ScriptStore).Init(pHitObj->QueryAppConfig()->szScriptLanguage(),
                                                pHitObj->QueryAppConfig()->pCLSIDDefaultEngine());

        if (hr == TYPE_E_ELEMENTNOTFOUND)
            {
            // default script language in registry is bogus - send error msg to browser
            HandleCTemplateError(
                                NULL,                                   // source file map
                                NULL,                                   // ptr to source location where error occurred
                                IDE_TEMPLATE_BAD_PROGLANG_IN_REGISTRY,  // error message id
                                0,                                      // count of insert strings for error msg
                                NULL,                                   // array of ptrs to error msg insert strings
                                pHitObj                                 // Browser Request
                                );
            }

        if (FAILED(hr))
            {
            delete m_pWorkStore;
            m_pWorkStore = NULL;
            }
        }

    // Try to init the workstore and map main file - this can fail with oom, etc or user lacks permissions

    if (SUCCEEDED(hr))
        {
        TRY
            m_pWorkStore->Init();
            AppendMapFile(
                        NULL,       // file spec for this file - NULL means get filespec from pHitObj
                        NULL,       // ptr to filemap of parent file
                        FALSE,      // don't care
                        pHitObj,    // ptr to template's hit object
                        m_fGlobalAsa    // is this the global.asa file?
                        );

        CATCH(hrException)
            delete m_pWorkStore;
            m_pWorkStore = NULL;

            hr = hrException;

            if(hr == E_USER_LACKS_PERMISSIONS)
                HandleAccessFailure(pHitObj,
                                                                        (m_rgpFilemaps && m_rgpFilemaps[0])? m_rgpFilemaps[0]->m_szPathTranslated : NULL);

            if (m_rgpFilemaps && m_rgpFilemaps[0])
                {
                // empty file will fail to map but will have a handle, so we check for it here
                if (0 == GetFileSize(m_rgpFilemaps[0]->m_hFile, NULL))
                    hr = E_SOURCE_FILE_IS_EMPTY;

                m_rgpFilemaps[0]->UnmapFile();
                }

            if (SUCCEEDED(hr))
                hr = E_FAIL;    // make sure the error is set
        END_TRY
        }

    if (SUCCEEDED(hr))
        {
        Assert(m_rgpFilemaps[0]);
        Assert(m_rgpFilemaps[0]->m_szPathTranslated);
        Assert(FImplies(!m_fGlobalAsa, (0 == _tcscmp(m_rgpFilemaps[0]->m_szPathTranslated, pHitObj->PSzCurrTemplatePhysPath()))));
        Assert(FImplies(m_fGlobalAsa, (0 == _tcscmp(m_rgpFilemaps[0]->m_szPathTranslated, pHitObj->GlobalAspPath()))));
        Assert(0 < m_rgpFilemaps[0]->GetSize());
        }

    if (FAILED(hr))
        {
        m_fDontCache = TRUE;
        // OK, cache HR if m_fDontCache is true
        // later, another thread might find this template from the cache even if the template
        // has some error and marked as DontCache.
        m_hrOnNoCache = hr;
        m_fReadyForUse = TRUE;
        SetEvent(m_hEventReadyForUse);
        return hr;
        }

    // End of Code moved from Init()


    // By default we are not in a transaction
    m_ttTransacted = ttUndefined;
    // By default session is required
    m_fSession = TRUE;
    // By default assume script exists
    m_fScriptless = FALSE;

    // we assert, in effect, that template is already init'ed
    Assert(FImplies(!m_fGlobalAsa, (0 == _tcscmp(m_rgpFilemaps[0]->m_szPathTranslated, pHitObj->PSzCurrTemplatePhysPath()))));
    Assert(FImplies(m_fGlobalAsa, (0 == _tcscmp(m_rgpFilemaps[0]->m_szPathTranslated, pHitObj->GlobalAspPath()))));

    TRY
        // Get source segments from source file
        GetSegmentsFromFile(*(m_rgpFilemaps[0]), *m_pWorkStore, pHitObj);

        /*  get "language equivalents" for primary languagefrom registry
            NOTE we do this here because the user can reset the primary language in the script file,
            so we must wait until after GetSegmentsFromFile()
        */
        GetLanguageEquivalents();

        // Call WriteTemplate, which writes out template components to contiguous memory,
        // resulting in a compiled template
        WriteTemplate(*m_pWorkStore, pHitObj);

        // Calculate the # of characters in a filemap before we unmap the file for all time.
        for (unsigned i = 0; i < m_cFilemaps; ++i)
            m_rgpFilemaps[i]->CountChars((WORD)m_wCodePage);

        // Wrap typelibs into single IDispatch*
        WrapTypeLibs(pHitObj);

        m_fIsValid = TRUE;

    CATCH(hrException)
        // NOTE: we used to free template memory here.  Now we do not because if the
        // error was E_USER_LACKS_PERMISSIONS, and template is in cache, we don't want
        // to sabotage future requests. There's no need to decache the template.
        //
        // The template destructor will free this memory anyway.
        //
        hr = hrException;
    END_TRY

    // check if scriptless
    if (!m_fGlobalAsa)
        {
        // count various stuff to make the determination
        DWORD cScriptEngines         = m_pWorkStore->m_ScriptStore.CountPreliminaryEngines();
        DWORD cPrimaryScriptSegments = (cScriptEngines > 0) ? m_pWorkStore->m_ScriptStore.m_ppbufSegments[0]->Count() : 0;
        DWORD cObjectTags            = m_pWorkStore->m_ObjectInfoStore.Count();
        DWORD cHtmlSegments          = m_pWorkStore->m_bufHTMLSegments.Count();
        DWORD c449Cookies            = m_rgp449.length();
        BOOL  fPageCommandsPresent   = m_pWorkStore->m_fPageCommandsExecuted;

        if (cScriptEngines <= 1         &&
            cPrimaryScriptSegments == 0 &&
            cObjectTags == 0            &&
            cHtmlSegments == 1          &&
            c449Cookies == 0            &&
            !fPageCommandsPresent)
            {
            m_fScriptless = TRUE;
            }
        }

    // free working storage - no longer needed
    delete m_pWorkStore;
    m_pWorkStore = NULL;

    // un-map filemaps - NOTE filemaps stay around for possible post-compile errors (e.g., script failure)
    UnmapFiles();

    // Debugging: print data structure to debugger
        IF_DEBUG(SCRIPT_DEBUGGER)
                {
                if (SUCCEEDED(hr))
                        {
                        DBGPRINTF((DBG_CONTEXT, "Script Compiled\n"));

                        for (UINT i = 0; i < m_cScriptEngines; ++i)
                                {
                                char *szEngineName;
                                PROGLANG_ID *pProgLangID;
                                const wchar_t *wszScriptText;

                                GetScriptBlock(i, &szEngineName, &pProgLangID, &wszScriptText);
                                DBGPRINTF((DBG_CONTEXT, "Engine %d, Language=\"%s\":\n", i, szEngineName));
#ifndef _NO_TRACING_
                DBGINFO((DBG_CONTEXT, (char *) wszScriptText));
                DBGINFO((DBG_CONTEXT, "\n"));
#else
                OutputDebugStringW(wszScriptText);
                OutputDebugStringA("\n");
#endif
				}
#if 0
			OutputDebugTables();
#endif
			}
        }

    if (hr == E_TEMPLATE_COMPILE_FAILED_DONT_CACHE)
                {
        m_fDontCache = TRUE;
                m_hrOnNoCache = hr;
                }

    // Set ready-for-use flag true and event to signaled
    // NOTE we do this whether success or failure, since even a failed-compile template
    // will remain in the cache to allow template cache mgr to satisfy requests on it
    m_fReadyForUse = TRUE;
    SetEvent(m_hEventReadyForUse);

    // Note whether the template currently is debuggable
    // BUG BUG: Template is debuggable or not based on first app. If shared between a debug
    //          & non-debug app, the first application wins.
    m_fDebuggable = (BOOLB)!!pHitObj->PAppln()->FDebuggable();
    return hr;
    }

/*  ============================================================================
    CTemplate::Deliver
    Delivers template to caller once template is ready for use
    NOTE 'compile failure' == template is 'ready for use' but did not compile successfully;
    this allows cache mgr to keep a failed template in cache in case it gets requested again

    Returns
        success or failure
    Side effects
        none
*/
HRESULT
CTemplate::Deliver
(
CHitObj*    pHitObj
)
    {
    // NOTE: There was a compiler bug where 'ps' would not be correctly aligned,
    //       EVEN if it was declared to be a DWORD array, if 'ps' was nested in
    //       a block.  Thus declare it here.
    //
    BYTE    ps[SIZE_PRIVILEGE_SET];                     // privilege set
    HRESULT hr = S_OK;

    // if ready flag is not yet set block until template is ready for use
    if(!m_fReadyForUse)
        {
        WaitForSingleObject(m_hEventReadyForUse, INFINITE);
        Assert(m_fReadyForUse); // when event unblocks, flag will be set
        }

    if (m_pbStart == NULL)
        {
        if (m_fDontCache && m_dwLastErrorMask == 0)
            {
            DBGPRINTF((DBG_CONTEXT, "template compile failed with %08x\n", m_hrOnNoCache));
            DBG_ASSERT(FAILED(m_hrOnNoCache));

                        // Safety net: always fail, even if "m_hrOnNoCache" did not get set somehow.
            hr = m_hrOnNoCache;
                        if (SUCCEEDED(m_hrOnNoCache))
                                hr = E_FAIL;

            if(hr == E_USER_LACKS_PERMISSIONS)
                HandleAccessFailure(pHitObj,
                                                                        (m_rgpFilemaps && m_rgpFilemaps[0])? m_rgpFilemaps[0]->m_szPathTranslated : NULL);
            return hr;
            }
        // template compile failed  - NOTE null start-of-template ptr == template compile failed
        // use cached error info
        SendToLog(  m_dwLastErrorMask,
                    m_pszLastErrorInfo[ILE_szFileName],
                    m_pszLastErrorInfo[ILE_szLineNum],
                    m_pszLastErrorInfo[ILE_szEngine],
                    m_pszLastErrorInfo[ILE_szErrorCode],
                    m_pszLastErrorInfo[ILE_szShortDes],
                    m_pszLastErrorInfo[ILE_szLongDes],
                    pHitObj);
        hr = E_TEMPLATE_COMPILE_FAILED;
        }
    else if (!pHitObj->FIsBrowserRequest())
        {
        return hr;
        }
    else if (Glob(fWinNT))
        // template compile succeeded  - check user's file permissions
        // ACLs: the following code should in future be shared with IIS (see creatfil.cxx in IIS project)
        {
        HANDLE          hUserAccessToken = pHitObj->HImpersonate(); // current user's access token
        DWORD           dwPS = sizeof(ps);                          // privilege set size
        DWORD           dwGrantedAccess;                            // granted access mask
        BOOL            fAccessGranted;                             // access granted flag
        GENERIC_MAPPING gm = {                                      // generic mapping struct
                                FILE_GENERIC_READ,
                                FILE_GENERIC_WRITE,
                                FILE_GENERIC_EXECUTE,
                                FILE_ALL_ACCESS
                            };

        ((PRIVILEGE_SET*)&ps)->PrivilegeCount = 0;                  // set privilege count to 0

        Assert(NULL != hUserAccessToken);

        for(UINT i = 0; i < m_cFilemaps; i++)
            {

            if(NULL == m_rgpFilemaps[i]->m_pSecurityDescriptor)
                continue;

            if(!AccessCheck(
                            m_rgpFilemaps[i]->m_pSecurityDescriptor,    // pointer to security descriptor
                            hUserAccessToken,       // handle to client access token
                            FILE_GENERIC_READ,      // access mask to request
                            &gm,                    // address of generic-mapping structure
                            (PRIVILEGE_SET*)ps,     // address of privilege-set structure
                            &dwPS,                  // address of size of privilege-set structure
                            &dwGrantedAccess,       // address of granted access mask
                            &fAccessGranted         // address of flag indicating whether access granted
                            ))
                return E_FAIL;

            if(!fAccessGranted)
                {
                // if access is denied on any file, handle the failure and return
                HandleAccessFailure(pHitObj, m_rgpFilemaps[0]->m_szPathTranslated);
                return E_USER_LACKS_PERMISSIONS;
                }
            }
        }

    // Reset the Session.CodePage to the script compilation-time codepage
    // only if a code page directive was found during compilation
    if (m_fCodePageSet && (!pHitObj->FHasSession() || !pHitObj->PSession()->FCodePageSet()))
        {
        pHitObj->SetCodePage(m_wCodePage);
        }

    // Reset the Session.LCID to the script compilation-time LCID
    // only if an LCID directive was found during compilation
    if (m_fLCIDSet && (!pHitObj->FHasSession() || !pHitObj->PSession()->FLCIDSet()))
        {
        pHitObj->SetLCID(m_lLCID);
        }

    return hr;
    }


/*  ============================================================================
    CTemplate::CTemplate
    Ctor
*/
CTemplate::CTemplate()
: m_pWorkStore(NULL),
  m_fGlobalAsa(FALSE),
  m_fReadyForUse(FALSE),
  m_fDontAttach(FALSE),
  m_hEventReadyForUse(NULL),
  m_fDebuggerDetachCSInited(FALSE),
  m_pbStart(NULL),
  m_cbTemplate(0),
  m_cRefs(1),                           // NOTE ctor AddRefs implicitly
  m_pbErrorLocation(NULL),
  m_idErrMsg(0),
  m_cMsgInserts(0),
  m_ppszMsgInserts(NULL),
  m_cScriptEngines(0),
  m_rgrgSourceInfos(NULL),
  m_rgpDebugScripts(NULL),
  m_rgpFilemaps(NULL),
  m_cFilemaps(0),
  m_rgpSegmentFilemaps(NULL),
  m_cSegmentFilemapSlots(0),
  m_wCodePage(CP_ACP),
  m_lLCID(LOCALE_SYSTEM_DEFAULT),
  m_ttTransacted(ttUndefined),
  m_fSession(TRUE),
  m_fScriptless(FALSE),
  m_fDebuggable(FALSE),
  m_fIsValid(FALSE),
  m_fDontCache(FALSE),
  m_fZombie(FALSE),
  m_fCodePageSet(FALSE),
  m_fLCIDSet(FALSE),
  m_fIsPersisted(FALSE),
  m_szPersistTempName(NULL),
  m_szApplnVirtPath(NULL),
  m_szApplnURL(NULL),
  m_CPTextEvents(this, IID_IDebugDocumentTextEvents),
  m_pdispTypeLibWrapper(NULL),
  m_dwLastErrorMask(S_OK),
  m_hrOnNoCache(S_OK),
  m_cbTargetOffsetPrevT(0),
  m_pHashTable(NULL)  
  {
     for (UINT i = 0; i < ILE_MAX; i++)
    {
        m_pszLastErrorInfo[i] = NULL;
    }

     IF_DEBUG(TEMPLATE)
     {
        WriteRefTraceLog(gm_pTraceLog, m_cRefs, this);
     }
#if PER_TEMPLATE_REFLOG
     m_pTraceLog = CreateRefTraceLog (100,0);
     WriteRefTraceLog (m_pTraceLog,m_cRefs, this);
#endif
  }

/*  ============================================================================
    CTemplate::~CTemplate
    Destructor

    Returns:
        Nothing
    Side effects:
        None
*/
CTemplate::~CTemplate()
    {
    DBGPRINTF(( DBG_CONTEXT, "Deleting template, m_cFilemaps = %d,  m_rgpFilemaps %p\n", m_cFilemaps, m_rgpFilemaps));

    // first, remove this template from its inc-files' template lists
    // NOTE must do this before freeing template memory
    RemoveFromIncFiles();

    // Remove the template from the debugger's list of documents
    Detach();

    PersistCleanup();

    if(m_rgpFilemaps)
        {
        for(UINT i = 0; i < m_cFilemaps; i++)
            delete m_rgpFilemaps[i];
        SmallTemplateFreeNullify((void**) &m_rgpFilemaps);
        }

    FreeGoodTemplateMemory();

    if (m_pWorkStore)
        delete m_pWorkStore;

    //FileName, LineNum, Engine, ErrorCode, ShortDes, LongDes
    for(UINT iErrInfo = 0; iErrInfo < ILE_MAX; iErrInfo++)
        {
        FreeNullify((void**) &m_pszLastErrorInfo[iErrInfo]);
        }

    if(m_hEventReadyForUse != NULL)
        CloseHandle(m_hEventReadyForUse);

    if (m_LKHashKey.szPathTranslated)
		free((void *)m_LKHashKey.szPathTranslated);

    if (m_szApplnURL)
        delete [] m_szApplnURL;

    if (m_fDebuggerDetachCSInited)
        DeleteCriticalSection(&m_csDebuggerDetach);

    if (m_pdispTypeLibWrapper)
        m_pdispTypeLibWrapper->Release();

    if (m_szPersistTempName)
        CTemplate::LargeFree(m_szPersistTempName);

#if PER_TEMPLATE_REFLOG
    DestroyRefTraceLog (m_pTraceLog);
#endif
}

/*  ============================================================================
    CTemplate::QueryInterface
    Provides QueryInterface implementation for CTemplate

    NOTE: It is arbitrary which vtable we return for IDebugDocument & IDebugDocumentInfo.
*/
HRESULT
CTemplate::QueryInterface(const GUID &uidInterface, void **ppvObj)
    {
    if (uidInterface == IID_IUnknown || uidInterface == IID_IDebugDocumentProvider)
        *ppvObj = static_cast<IDebugDocumentProvider *>(this);

    else if (uidInterface == IID_IDebugDocument || uidInterface == IID_IDebugDocumentInfo || uidInterface == IID_IDebugDocumentText)
        *ppvObj = static_cast<IDebugDocumentText *>(this);

    else if (uidInterface == IID_IConnectionPointContainer)
        *ppvObj = static_cast<IConnectionPointContainer *>(this);

    else
        *ppvObj = NULL;

    if (*ppvObj)
        {
        AddRef();
        return S_OK;
        }
    else
        return E_NOINTERFACE;
    }

/*  ============================================================================
    CTemplate::AddRef
    Adds a ref to this template, thread-safely
*/
ULONG
CTemplate::AddRef()
    {
    LONG cRefs = InterlockedIncrement(&m_cRefs);

    Assert(FImplies(m_fIsValid,FImplies(cRefs > 1, m_pbStart != NULL)));
    IF_DEBUG(TEMPLATE)
    {
        WriteRefTraceLog(gm_pTraceLog, cRefs, this);
    }

#if PER_TEMPLATE_REFLOG
    WriteRefTraceLog(m_pTraceLog, cRefs, this);
#endif

    return cRefs;
    }

/*  ============================================================================
    CTemplate::Release
    Releases a ref to this template, thread-safely
*/
ULONG
CTemplate::Release()
{
    LONG cRefs = InterlockedDecrement(&m_cRefs);
    IF_DEBUG(TEMPLATE)
    {
        WriteRefTraceLog(gm_pTraceLog, cRefs, this);
    }
    
#if PER_TEMPLATE_REFLOG
    WriteRefTraceLog(m_pTraceLog, cRefs, this);
#endif

    if (cRefs == 0)
        delete this;

    return cRefs;
}

/*  ============================================================================
    CTemplate::RemoveIncFile
    Removes (by setting to null) an inc-file ptr from this template's inc-file list.

    Returns:
        Nothing
    Side effects:
        None
*/
void
CTemplate::RemoveIncFile
(
CIncFile*   pIncFile
)
    {

    // If the filemap count is non-zero the pointer to
    // the array of filemaps has better not be null
    DBGPRINTF(( DBG_CONTEXT, "m_cFilemaps = %d,  m_rgpFilemaps %p\n", m_cFilemaps, m_rgpFilemaps));
    Assert((m_cFilemaps <= 0) || (m_rgpFilemaps != NULL));

    // find the inc-file in list
    for(UINT i = 1; (i < m_cFilemaps) && (m_rgpFilemaps[i]->m_pIncFile != pIncFile); i++)
        ;

    // assert that we found the inc-file in list
    Assert((i < m_cFilemaps) && (m_rgpFilemaps[i]->m_pIncFile == pIncFile));

    // set inc-file ptr null
    m_rgpFilemaps[i]->m_pIncFile = NULL;
    }

/*===================================================================
CTemplate::FTemplateObsolete

Test to see if the files this template depends on have changed since it
was compiled.

We use this in cases where we may have missed a change notification,
for example, when there were too many changes to record in our change
notification buffer. We check the last time the file was written too,
and the security descriptor, since changes to the security descriptor
aren't noted in the file last write time.

Parameters:
    None

Returns:
    TRUE if the template is obsolete, else FALSE
*/
BOOL CTemplate::FTemplateObsolete(VOID)
    {
    BOOL fStatus = FALSE;

    // On Windows 95 files should not be cached
    // so assume the template has changed
    if (!FIsWinNT())
        {
        return TRUE;
        }

    for (UINT i = 0; i < m_cFilemaps; i++)
        {
        if (FFileChangedSinceCached(m_rgpFilemaps[i]->m_szPathTranslated, m_rgpFilemaps[i]->m_ftLastWriteTime))
            {
            // If the file write time has changed we know enough
            // and can quit here
            fStatus = TRUE;
            break;
            }
        else
            {
            // The file hasn't been writen to, but the security descriptor may
            // have chagned

            // Assert on non-valid security descriptor

            if (NULL != m_rgpFilemaps[i]->m_pSecurityDescriptor)
                {

                PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
                DWORD dwSize = m_rgpFilemaps[i]->m_dwSecDescSize;

                if( 0 == GetSecDescriptor(m_rgpFilemaps[i]->m_szPathTranslated, &pSecurityDescriptor, &dwSize))
                    {
                    if (pSecurityDescriptor)
                        {
                        // if the size is not the same then set fStatus to TRUE no need to compare memory blocks.

                        if(dwSize != GetSecurityDescriptorLength(m_rgpFilemaps[i]->m_pSecurityDescriptor))
                            {
                            fStatus = TRUE;
                            }
                        else
                            {
                            // The size of the security descriptor hasn't changed
                            // but we have to compare the contents to make sure they haven't changed
                            fStatus = !(0 == memcmp(m_rgpFilemaps[i]->m_pSecurityDescriptor, pSecurityDescriptor, dwSize));
                            }

                        // We are done with the descriptor
                        free(pSecurityDescriptor);

                        }
                    else
                        {
                        // Since we failed to get a security descriptor
                        // assume the file has changed.
                        fStatus = TRUE;
                        }
                    }
                }
            }

        // Quit as soon as we find a change
        if (fStatus)
            {
            break;
            }
        }

    return fStatus;
    }


/*  ============================================================================
    CTemplate::GetSourceFileName
    Returns name of source file on which this template is based

    Returns
        source file name
    Side effects
        none
*/
LPTSTR
CTemplate::GetSourceFileName(SOURCEPATHTYPE pathtype)
    {
    if (!m_rgpFilemaps)
        {
        return NULL;
        }

    switch (pathtype)
        {
    case SOURCEPATHTYPE_PHYSICAL:
        return((m_rgpFilemaps[0] ? m_rgpFilemaps[0]->m_szPathTranslated : NULL));

    case SOURCEPATHTYPE_VIRTUAL:
        return((m_rgpFilemaps[0] ? m_rgpFilemaps[0]->m_szPathInfo : NULL));

    default:
        return(NULL);
        }
    }

/*  ============================================================================
    CTemplate::Count
    Returns count of components of type tcomp contained in this template

    Returns:
        Count of components of type tcomp
    Side effects:
        None
*/
USHORT
CTemplate::Count
(
TEMPLATE_COMPONENT  tcomp
)
    {
    Assert(NULL != m_pbStart);

    // script engines and script blocks have the same count, stored in same slot
    if(tcomp == tcompScriptEngine)
        tcomp = tcompScriptBlock;

    // counts are stored at start of template in sequential slots, starting with script blocks count
    return * (USHORT*) ((USHORT*)m_pbStart + (tcomp - tcompScriptBlock));
    }

/*  ============================================================================
    CTemplate::GetScriptBlock
    Gets ptrs to script engine name, prog lang id and script text of i-th script block.

    Returns:
        Out-parameters; see below
    Side effects:
        None
*/
void
CTemplate::GetScriptBlock
(
UINT            i,                  // script block id
LPSTR*          pszScriptEngine,    // ptr to script engine name    (out-parameter)
PROGLANG_ID**   ppProgLangId,       // ptr to prog lang id          (out-parameter)
LPCOLESTR*      pwstrScriptText     // ptr to wstr script text      (out-parameter)
)
    {
    CByteRange  brEngine;       // engine name
    CByteRange  brScriptText;   // script text
    UINT        cbAlignment;    // count of bytes guid was shifted in WriteTemplate() to make it dword-aligned
    BYTE*       pbEngineInfo = GetAddress(tcompScriptEngine, (USHORT)i);    // ptr to engine info

    Assert(pbEngineInfo != NULL);
    Assert(i < CountScriptEngines());

    // Get engine name from start of engine info
    ByteRangeFromPb(pbEngineInfo, brEngine);

    ByteRangeFromPb(GetAddress(tcompScriptBlock, (USHORT)i), brScriptText);

    Assert(!brEngine.IsNull());
    Assert(!brScriptText.IsNull());

    // Advance ptr past name to prog lang id
    //           length of prefix + length of name  + NULL
    pbEngineInfo += (sizeof(UINT) + (*pbEngineInfo) + 1);

    // Get prog lang id - it will be on the next pointer sized boundary
    cbAlignment = (UINT) (((DWORD_PTR) pbEngineInfo) % sizeof(DWORD));
    if(cbAlignment > 0)
       {pbEngineInfo += (sizeof(DWORD) - cbAlignment);}

    *pszScriptEngine = (LPSTR)brEngine.m_pb;
    *ppProgLangId = (PROGLANG_ID*)pbEngineInfo;
    *pwstrScriptText = (LPCOLESTR)brScriptText.m_pb;
    }

/*  ============================================================================
    CTemplate::GetObjectInfo
    Returns i-th object-info in template as object name and
    its clsid, scope, model

    Returns:
        HRESULT
        Out-parameters; see below
    Side effects:
*/
HRESULT
CTemplate::GetObjectInfo
(
UINT        i,              // object index
LPSTR*      ppszObjectName, // address of object name ptr   (out-parameter)
CLSID*      pClsid,         // address of object clsid
CompScope*  pcsScope,       // address of object scope
CompModel*  pcmModel        // address of object threading model
)
    {
    BYTE*       pbObjectInfo = GetAddress(tcompObjectInfo, (USHORT)i);  // ptr to current read location
    CByteRange  brName;         // object name
    UINT        cbAlignment;    // count of bytes guid was shifted in WriteTemplate() to make it dword-aligned

    Assert(i < Count(tcompObjectInfo));

    // Get name from start of object-info
    ByteRangeFromPb(pbObjectInfo, brName);
    Assert(!brName.IsNull());

    // Advance ptr past name
    //           length of prefix + length of name  + NULL
    pbObjectInfo += (sizeof(UINT) + (*pbObjectInfo) + 1);

    // Get clsid - it will be on the next DWORD boundary
    cbAlignment = (UINT)(((DWORD_PTR) pbObjectInfo) % sizeof(DWORD));
    if(cbAlignment > 0)
        pbObjectInfo += (sizeof(DWORD) - cbAlignment);

    *pClsid = *(CLSID*)pbObjectInfo;
    pbObjectInfo += sizeof(CLSID);

    // Get scope
    *pcsScope = *(CompScope*)pbObjectInfo;
    pbObjectInfo += sizeof(CompScope);

    // Get model
    *pcmModel = *(CompModel*)pbObjectInfo;
    pbObjectInfo += sizeof(CompModel);

    *ppszObjectName = (LPSTR)brName.m_pb;
    return S_OK;
    }

/*  ============================================================================
    CTemplate::GetHTMLBlock
    Returns i-th HTML block

    Parameters:
        UINT   i             block number
        LPSTR* pszHTML       [out] html text
        ULONG* pcbHTML       [out] html text length
        ULONG* pcbSrcOffs    [out] offset in the source file
        LPSTR* pszSrcIncFile [out] include source file name

    Returns:
        Nothing
    Side effects:
        None
*/
HRESULT
CTemplate::GetHTMLBlock
(
UINT i,
LPSTR* pszHTML,
ULONG* pcbHTML,
ULONG* pcbSrcOffs,
LPSTR* pszSrcIncFile
)
    {
    Assert(i < Count(tcompHTMLBlock));

    // this was added due to user attempt to access the method with an invalid array offset
    //
    if ( i >= Count(tcompHTMLBlock) )
        return E_FAIL;

    // get address of the block start in template memory
    BYTE *pbBlock = GetAddress(tcompHTMLBlock, (USHORT)i);
    Assert(pbBlock);

    // retrieve the byte range of the html code
    CByteRange brHTML;
    ByteRangeFromPb(pbBlock, brHTML);
    *pszHTML = (LPSTR)brHTML.m_pb;
    *pcbHTML = brHTML.m_cb;

    // advance to the source offset
    pbBlock += sizeof(ULONG);   // skip prefix
    pbBlock += brHTML.m_cb+1;   // skip html bytes (incl. '\0')

    // Add byte aligment which is done in ByteAlignOffset()
    if ((reinterpret_cast<ULONG_PTR>(pbBlock)) & 3)
        pbBlock = reinterpret_cast<BYTE *>((reinterpret_cast<ULONG_PTR>(pbBlock) + 4) & ~3);

    *pcbSrcOffs = *((ULONG*)pbBlock);

    // advance to the source name length
    pbBlock += sizeof(ULONG);   // skip source offset prefix
    ULONG cbSrcIncFile = *((ULONG *)pbBlock); // inc file name length
    pbBlock += sizeof(ULONG);   // skip inc file name length
    *pszSrcIncFile = (cbSrcIncFile > 0) ? (LPSTR)pbBlock : NULL;
    return S_OK;
    }

/*  ============================================================================
    CTemplate::GetScriptSourceInfo
    Returns line number and source file name a given target line in a given script engine.

    Returns
        line number and source file name (as out-parameters)
    Side effects:
        None
*/
void
CTemplate::GetScriptSourceInfo
(
UINT    idEngine,           // script engine id
int     iTargetLine,        // target line number
LPTSTR* pszPathInfo,        // ptr to source file virtual path      (out-parameter)
LPTSTR* pszPathTranslated,  // ptr to source file real path         (out-parameter)
ULONG*  piSourceLine,       // ptr to source line number            (out-parameter)
ULONG*  pichSourceLine,     // ptr to source file offset            (out-parameter)
BOOLB*  pfGuessedLine       // ptr to flag: did we guess the source line?
)
    {
    // Initialize some out parameters
    if (pszPathInfo)
        *pszPathInfo = _T("?"); // In case we don't ever find the path

    if (pszPathTranslated)
        *pszPathTranslated = _T("?"); // In case we don't ever find the path

    if (piSourceLine)
        *piSourceLine = 0;

    if (pichSourceLine)
        *pichSourceLine = 0;

    if (pfGuessedLine)
        *pfGuessedLine = FALSE;

    if (iTargetLine <=0)
        {
        return;
        }

    // CHANGE: The rgSourceInfo array is now ZERO based.  Decrement target line
    //           to convert.
    --iTargetLine;

    // CONSIDER: Make these assertions?
    if(!m_rgrgSourceInfos)
        return;
    if(idEngine > (m_cScriptEngines - 1))   // bug 375: check vs. array bound
        return;
    if(size_t(iTargetLine) >= m_rgrgSourceInfos[idEngine].length()) // bug 375: check vs. array bound
        return;

    vector<CSourceInfo> *prgSourceInfos = &m_rgrgSourceInfos[idEngine];

    // bug 379: move backwards through target lines, starting with the caller's, until we find one whose
    // fIsHTML flag is false.  this handles the case where vbs flags a manufactured line as in error;
    // we assume the actual error occurred at the most recent authored line
    while (iTargetLine >= 0 && (*prgSourceInfos)[iTargetLine].m_fIsHTML)
        {
        --iTargetLine;
        if (pfGuessedLine)
            *pfGuessedLine = TRUE;
        }


    if (iTargetLine >= 0)
        {
        if (pszPathInfo && (*prgSourceInfos)[iTargetLine].m_pfilemap != NULL)
            *pszPathInfo = (*prgSourceInfos)[iTargetLine].m_pfilemap->m_szPathInfo;

        if (pszPathTranslated && (*prgSourceInfos)[iTargetLine].m_pfilemap != NULL)
            *pszPathTranslated = (*prgSourceInfos)[iTargetLine].m_pfilemap->m_szPathTranslated;

        if (piSourceLine)
            *piSourceLine = (*prgSourceInfos)[iTargetLine].m_idLine;

        if (pichSourceLine)
            *pichSourceLine = (*prgSourceInfos)[iTargetLine].m_cchSourceOffset;
        }
    }

/*  ============================================================================
    CTemplate::GetPositionOfLine
    Get the character offset of a line of source
    (Debugger API Extended to specify a filemap)
*/
HRESULT
CTemplate::GetPositionOfLine
(
CFileMap *pFilemap,
ULONG cLineNumber,
ULONG *pcCharacterPosition
)
    {
    // NOTE:
    //    The table is not binary-searchable because include files
    //    will start a new line ordering
    //
    // Algorithm:
    //
    //   Find the largest source line N across all engines, such that
    //   N <= cLineNumber and the line corresponds to an line
    //   in the appropriate file.
    //
    CSourceInfo *pSourceInfoLE = NULL;
    ++cLineNumber;                  // Convert zero-based line # to one-based

    // Find the correct offset
    for (unsigned idEngine = 0; idEngine < m_cScriptEngines; ++idEngine)
        {
        vector<CSourceInfo> *prgSourceInfos = &m_rgrgSourceInfos[idEngine];

        // Loop through all lines EXCEPT the EOF line
        for (unsigned j = 0; j < prgSourceInfos->length() - 1; ++j)
            {
            CSourceInfo *pSourceInfo = &(*prgSourceInfos)[j];
            if (pFilemap == pSourceInfo->m_pfilemap &&
                pSourceInfo->m_idLine <= cLineNumber &&
                (pSourceInfoLE == NULL || pSourceInfo->m_idLine > pSourceInfoLE->m_idLine))
                {
                pSourceInfoLE = pSourceInfo;
                }
            }
        }

    // We had better be able to map all line numbers to offsets, unless they passed a bogus line
    // (in which case we still find an offset)
    //
    Assert (pSourceInfoLE != NULL);

    if (pSourceInfoLE == NULL) {
        return E_FAIL;
    }
    *pcCharacterPosition = pSourceInfoLE->m_cchSourceOffset;
#if 0
	IF_DEBUG(SCRIPT_DEBUGGER)
		{
		wchar_t wszSourceText[SNIPPET_SIZE + 1], wszTargetText[SNIPPET_SIZE + 1], wszDebugMessage[256];
		GetScriptSnippets(
						pSourceInfoLE->m_cchSourceOffset, pSourceInfoLE->m_pfilemap,
						0, 0,
						wszSourceText, NULL
						 );

		DBGPRINTF((
				DBG_CONTEXT,
				"Source Line %d corresponds to source offset %d (Text: \"%S\")\n",
				cLineNumber - 1, pSourceInfoLE->m_cchSourceOffset,
				wszSourceText
				));
		}
#endif
    return S_OK;
    }

/*  ============================================================================
    CTemplate::GetLineOfPosition
    Get the line # & offset in line of an arbitrary character offset in source
    (Debugger API Extended to specify a filemap)
*/
HRESULT CTemplate::GetLineOfPosition
(
CFileMap *pFilemap,
ULONG cCharacterPosition,
ULONG *pcLineNumber,
ULONG *pcCharacterOffsetInLine
)
    {
    // FAIL if source offset totally off-base
    if (cCharacterPosition >= pFilemap->m_cChars)
        return E_FAIL;

    // NOTE:
    //    The table is not binary-searchable because include files
    //    will start a new line ordering
    //
    // Algorithm:
    //
    //   Find the largest source line N across all engines, such that
    //   N <= cLineNumber and the line corresponds to an line
    //   in the appropriate file.
    //
    CSourceInfo *pSourceInfoLE = NULL;

    // Find the correct offset
    for (unsigned idEngine = 0; idEngine < m_cScriptEngines; ++idEngine)
        {
        vector<CSourceInfo> *prgSourceInfos = &m_rgrgSourceInfos[idEngine];

        // Loop through all lines EXCEPT the EOF line
        for (unsigned j = 0; j < prgSourceInfos->length() - 1; ++j)
            {
            CSourceInfo *pSourceInfo = &(*prgSourceInfos)[j];
            if (pFilemap == pSourceInfo->m_pfilemap &&
                pSourceInfo->m_cchSourceOffset <= cCharacterPosition &&
                (pSourceInfoLE == NULL || pSourceInfo->m_cchSourceOffset > pSourceInfoLE->m_cchSourceOffset))
                {
                pSourceInfoLE = pSourceInfo;
                }
            }
        }

    // We had better be able to map all offsets to line numbers, unless they passed a bogus offset
    // (in which case we still find a line #, but may go out of range for the offset in line.
    //  That case is handled later)
    //
    Assert (pSourceInfoLE != NULL);

    if (pSourceInfoLE == NULL) {
        return E_FAIL;
    }

    *pcLineNumber = pSourceInfoLE->m_idLine - 1;    // Convert to zero-based line #
    *pcCharacterOffsetInLine = cCharacterPosition - pSourceInfoLE->m_cchSourceOffset;
#if 0
	IF_DEBUG(SCRIPT_DEBUGGER)
		{
		wchar_t wszSourceText[SNIPPET_SIZE + 1], wszTargetText[SNIPPET_SIZE + 1], wszDebugMessage[256];
		GetScriptSnippets(
						pSourceInfoLE->m_cchSourceOffset, pSourceInfoLE->m_pfilemap,
						0, 0,
						wszSourceText, NULL
						 );

        DBGPRINTF((
                                DBG_CONTEXT,
                                "Source offset %d corresponds to source line %d (Text: \"%S\")\n",
                                pSourceInfoLE->m_cchSourceOffset, *pcLineNumber,
                                wszSourceText
                                ));
                }

		DBGPRINTF((
				DBG_CONTEXT,
				"Source offset %d corresponds to source line %d (Text: \"%S\")\n",
				pSourceInfoLE->m_cchSourceOffset, *pcLineNumber,
				wszSourceText
				));
		}
#endif
    return S_OK;
    }

/*  ============================================================================
    CTemplate::GetSourceOffset
    Convert a character offset relative to the target script to the appropriate
    offset in the source.

    NOTE:   offsets in the middle of a target line are converted to the
            offset relative to the beginning of source line - NOT to the
            precise source offset.

            this is OK because debugger ultimately wants the offset of the
            beginning of line.  It is a lot of work to do the precise conversion
            due to the translation of "=" to Response.Write & HTML to
            Response.WriteBlock

            Also, because of these translations, we return the length of the segment
            calculated during compilation, and throw away the length the scripting
            engine sent to us.
*/
void
CTemplate::GetSourceOffset
(
ULONG idEngine,
ULONG cchTargetOffset,
TCHAR **pszSourceFile,
ULONG *pcchSourceOffset,
ULONG *pcchSourceText
)
    {
    Assert (idEngine < m_cScriptEngines);
    vector<CSourceInfo> *prgSourceInfos = &m_rgrgSourceInfos[idEngine];

    // Find the closest offset in the source
    // This is the largest target offset N, such that N <= cchTargetOffset
    CSourceInfo *pSourceInfo;
    GetBracketingPair(
            cchTargetOffset,                                    // value to search for
            prgSourceInfos->begin(), prgSourceInfos->end(),     // array to search
            CTargetOffsetOrder(),                               // ordering predicate
            &pSourceInfo, static_cast<CSourceInfo **>(NULL)     // return values
            );

    // Since the first offset is zero, which is less than all other conceivable offsets,
    // the offset must have been found or else there is a bug.
    Assert (pSourceInfo != NULL);
    Assert (cchTargetOffset >= pSourceInfo->m_cchTargetOffset);
#if 0
	IF_DEBUG(SCRIPT_DEBUGGER)
		{
		wchar_t wszSourceText[SNIPPET_SIZE + 1], wszTargetText[SNIPPET_SIZE + 1], wszDebugMessage[256];
		GetScriptSnippets(
						pSourceInfo->m_cchSourceOffset, pSourceInfo->m_pfilemap,
						cchTargetOffset, idEngine,
						wszSourceText, wszTargetText
						 );
		DBGPRINTF((
				DBG_CONTEXT,
				"Target offset %d (Text: \"%S\") corresponds to source offset %d (Text: \"%S\")  (Length is %d)\n",
				cchTargetOffset, wszTargetText,
				pSourceInfo->m_cchSourceOffset, wszSourceText,
				pSourceInfo->m_cchSourceText
				));
		}
#endif
    *pszSourceFile = pSourceInfo->m_pfilemap->m_szPathTranslated;
    *pcchSourceOffset = pSourceInfo->m_cchSourceOffset;
    *pcchSourceText = pSourceInfo->m_cchSourceText;
    }

/*  ============================================================================
    CTemplate::GetTargetOffset
    Convert a character offset relative to the source script to the appropriate
    offset in the target.

    Returns:
        TRUE  - source offset corresponds to script
        FALSE - source offset corresponds to HTML

    NOTES:
        1.  This function is very slow. consider caching the value of this function
            (The CTemplateDocumentContext class does this.)

        2.  This function returns the source offset in the master include file -
            if the target offset corresponds to an offset in a header file, then
            the offset to the #include line in the source is returned.

        3.  offsets in the middle of a target line are converted to the
            offset relative to the beginning of source line - NOT to the
            precise source offset.

            this is OK because the debugger ultimately wants the offset of the
            beginning of line.  It is a lot of work to do the precise conversion
            due to the translation of "=" to Response.Write & HTML to
            Response.WriteBlock

    CONSIDER:
        Figure out a better way to do this
*/
BOOL CTemplate::GetTargetOffset
(
TCHAR *szSourceFile,
ULONG cchSourceOffset,
/* [out] */ ULONG *pidEngine,
/* [out] */ ULONG *pcchTargetOffset
)
    {
    // NOTE:
    //    The table is not binary-searchable because of two factors:
    //       1. Include files will start a new line ordering
    //       2. For engine 0, tagged scripts will be re-arranged in
    //          the target code to reside after all primary script in
    //          engine 0.
    //
    // Algorithm:
    //
    //   Find the largest source offset N across all engines, such that
    //   N <= cchSourceOffset and the offset corresponds to an offset
    //   in the appropriate file.
    //
    CSourceInfo *pSourceInfoLE = NULL;
    unsigned idEngineLE = 0;

    // Find the correct offset
    for (unsigned idEngine = 0; idEngine < m_cScriptEngines; ++idEngine)
        {
        vector<CSourceInfo> *prgSourceInfos = &m_rgrgSourceInfos[idEngine];

        // Loop through all lines EXCEPT the EOF line
        for (unsigned j = 0; j < prgSourceInfos->length() - 1; ++j)
            {
            CSourceInfo *pSourceInfo = &(*prgSourceInfos)[j];
            if (_tcscmp(pSourceInfo->m_pfilemap->m_szPathTranslated, szSourceFile) == 0 &&
                pSourceInfo->m_cchSourceOffset <= cchSourceOffset &&
                (pSourceInfoLE == NULL || pSourceInfo->m_cchSourceOffset > pSourceInfoLE->m_cchSourceOffset))
                {
                pSourceInfoLE = pSourceInfo;
                idEngineLE = idEngine;
                }
            }
        }

    // There won't be a valid offset in the case where there is no
    // code corresponding to the first line in the file (this only
    // occurs when the first line is whitespace, because there is no
    // corresponding "Response.WriteBlock" call there)
    //
    // In that case, return FALSE, which will cause the caller to fail
    //
    if (pSourceInfoLE == NULL)
        {
        *pidEngine = 0;
        *pcchTargetOffset = 0;
        return FALSE;
        }

    *pidEngine = idEngineLE;
    *pcchTargetOffset = pSourceInfoLE->m_cchTargetOffset;
#if 0
	IF_DEBUG(SCRIPT_DEBUGGER)
		{
		wchar_t wszSourceText[SNIPPET_SIZE + 1], wszTargetText[SNIPPET_SIZE + 1], wszDebugMessage[256];
		GetScriptSnippets(
						cchSourceOffset, pSourceInfoLE->m_pfilemap,
						*pcchTargetOffset, *pidEngine,
						wszSourceText, wszTargetText
						 );
		DBGPRINTF((
				DBG_CONTEXT,
				"Source offset %d (Text: \"%S\") corresponds to target offset %d (Text: \"%S\")\n",
				cchSourceOffset, wszSourceText,
				*pcchTargetOffset, wszTargetText
				));
		}
#endif
    return !pSourceInfoLE->m_fIsHTML;
    }

/*  ============================================================================
    CTemplate::GetActiveScript
    Return a cached script from the template - only used in debug mode
*/
CActiveScriptEngine *CTemplate::GetActiveScript(ULONG idEngine)
    {
    if (m_rgpDebugScripts == NULL)
        return NULL;

    else
        {
        Assert (idEngine < m_cScriptEngines);
        CActiveScriptEngine *pEng = m_rgpDebugScripts[idEngine];
        if (pEng)
            pEng->AddRef();

        return pEng;
        }
    }

/*  ============================================================================
    CTemplate::AddScript
    add an active script to the template object
*/
HRESULT CTemplate::AddScript(ULONG idEngine, CActiveScriptEngine *pScriptEngine)
    {
    if (m_rgpDebugScripts == NULL)
        {
        if (
            (m_rgpDebugScripts = new CActiveScriptEngine *[m_cScriptEngines])
            == NULL
           )
            {
            return E_OUTOFMEMORY;
            }

        memset(m_rgpDebugScripts, 0, m_cScriptEngines * sizeof(CActiveScriptEngine *));
        }

    Assert (idEngine < m_cScriptEngines);
    CActiveScriptEngine **ppScriptElem = &m_rgpDebugScripts[idEngine];

    if (*ppScriptElem != NULL)
        (*ppScriptElem)->Release();

    *ppScriptElem = pScriptEngine;
    pScriptEngine->AddRef();

    // Initialize the script engine now (is currently uninitialized)
    // so that the debugger user can set breakpoints.
    IActiveScript *pActiveScript = pScriptEngine->GetActiveScript();
    HRESULT  hr;

    TRY
        hr = pActiveScript->SetScriptSite(static_cast<IActiveScriptSite *>(pScriptEngine));
    CATCH(nExcept)
        HandleErrorMissingFilename(IDE_SCRIPT_ENGINE_GPF,
                                   NULL,
                                   TRUE,
                                   nExcept,
                                   "IActiveScript::SetScriptSite()",
                                   "CTemplate::AddScript()");
        hr = nExcept;
    END_TRY

    if (FAILED(hr))
        {
        *ppScriptElem = NULL;
        return E_FAIL;
        }

    TRY
        hr = pActiveScript->SetScriptState(SCRIPTSTATE_INITIALIZED);
    CATCH(nExcept)
        HandleErrorMissingFilename(IDE_SCRIPT_ENGINE_GPF,
                                   NULL,
                                   TRUE,
                                   nExcept,
                                   "IActiveScript::SetScriptState()",
                                   "CTemplate::AddScript()");
        hr = nExcept;
    END_TRY

    if (FAILED(hr))
        return E_FAIL;

    return S_OK;
    }

/*  ============================================================================
    CTemplate::AppendMapFile
    Appends a filemap to the workstore and memory-maps its file

    Returns:
        Nothing
    Side effects:
        Allocates memory; throws exception on error
*/
void
CTemplate::AppendMapFile
(
LPCTSTR     szFileSpec,         // file spec for this file
CFileMap*   pfilemapCurrent,    // ptr to filemap of parent file
BOOLB       fVirtual,           // is file spec virtual or relative?
CHitObj*    pHitObj,            // ptr to template's hit object
BOOLB       fGlobalAsa          // is this file the global.asa file?
)
    {
    // alloc or realloc as needed
    if(m_cFilemaps++ == 0)
        m_rgpFilemaps = (CFileMap**) CTemplate::SmallMalloc(sizeof(CFileMap*));
    else
        m_rgpFilemaps = (CFileMap**) CTemplate::SmallReAlloc(m_rgpFilemaps, m_cFilemaps * sizeof(CFileMap*));

    if(NULL == m_rgpFilemaps)
        THROW(E_OUTOFMEMORY);

    if(NULL == (m_rgpFilemaps[m_cFilemaps - 1] = new CFileMap))
        THROW(E_OUTOFMEMORY);

    // map the file
    m_rgpFilemaps[m_cFilemaps - 1]->MapFile(
                                            szFileSpec,
                                            m_szApplnVirtPath,
                                            pfilemapCurrent,
                                            fVirtual,
                                            pHitObj,
                                            fGlobalAsa
                                            );
    }

/*  ============================================================================
    CTemplate::GetSegmentsFromFile
    Gets source segments from a source file by calling ExtractAndProcessSegment
    until there are no more segments; populates WorkStore with info on source segments.

    Returns:
        Nothing
    Side effects:
        None
*/
void
CTemplate::GetSegmentsFromFile
(
CFileMap&   filemap,        // this file's file map
CWorkStore& WorkStore,      // working storage for source segments
CHitObj*    pHitObj,        // Browser request object
BOOL        fIsHTML
)
    {
    CByteRange  brSearch;       // byte range to search for source segments
    _TOKEN      rgtknOpeners[TOKEN_OPENERS_MAX]; // array of permitted open tokens
    UINT        ctknOpeners;    // count of permitted open tokens
    SOURCE_SEGMENT ssegThisFile = ssegHTML; // Either HTML or <SCRIPT> segment
    BOOL        fPrevCodePageSet = FALSE;
    UINT        wPrevCodePage;

    // init search range to all of file - NOTE we ignore high dword of file size
    brSearch.m_pb = filemap.m_pbStartOfFile;
    brSearch.m_cb = filemap.GetSize();

    if (fIsHTML)
        {
                // populate array of permitted open tokens
                ctknOpeners = 4;
                rgtknOpeners[0] = CTokenList::tknOpenPrimaryScript;
                rgtknOpeners[1] = CTokenList::tknOpenTaggedScript;
                rgtknOpeners[2] = CTokenList::tknOpenObject;
                rgtknOpeners[3] = CTokenList::tknOpenHTMLComment;
                }
        else
                {
                ctknOpeners = 1;
                rgtknOpeners[0] = CTokenList::tknOpenHTMLComment;
        ssegThisFile = ssegTaggedScript;
                }

    TRY

        if ((brSearch.m_cb >= 2)
            && (((brSearch.m_pb[0] == 0xff) && (brSearch.m_pb[1] == 0xfe))
                || ((brSearch.m_pb[0] == 0xfe) && (brSearch.m_pb[1] == 0xff)))) {
            ThrowError(brSearch.m_pb,IDE_TEMPLATE_UNICODE_NOTSUP);
            return;
        }

        // check for the UTF-8 BOM mark.  If present, then treat this similar to
        // seeing @CODEPAGE=65001.  Note that previous values are retained in the
        // event that there are differing @CODEPAGE settings.  This probably should
        // be an error in itself, but I can imagine that this might break a lot of
        // apps as more and more UTF8 files are put into use.

        if ((brSearch.m_cb >= 3)
            && (brSearch.m_pb[0] == 0xEF) 
            && (brSearch.m_pb[1] == 0xBB)
            && (brSearch.m_pb[2] == 0xBF)) {

            pHitObj->SetCodePage(65001);

            fPrevCodePageSet = m_fCodePageSet;
            wPrevCodePage = m_wCodePage;

            m_fCodePageSet = TRUE;
            m_wCodePage = 65001;
            brSearch.Advance(3);
        }


        // Process source segments until we run out of them, i.e. until search segment is empty
        // NOTE we pass current filemap as 'parent file' to ExtractAndProcessSegment
        // NOTE ExtractAndProcessSegment appends source segments to WorkStore, advancing brSearch as it goes
        while(!brSearch.IsNull())
            ExtractAndProcessSegment(
                                        brSearch,
                                        ssegThisFile,
                                        rgtknOpeners,
                                        ctknOpeners,
                                        &filemap,
                                        WorkStore,
                                        pHitObj,
                                        ssegThisFile == ssegTaggedScript,
                                        fIsHTML
                                    );

    CATCH(hrException)
        /*
            NOTE we indicate 'generic error' by m_idErrMsg == 0; this happens as we move
            up the 'include file stack' after processing a specific error (m_idErrMsg != 0).
            Only the specific error is processed; generic error, we simply re-throw exception.
        */
        if(m_idErrMsg != 0)
            {
            // process specific error
            ProcessSpecificError(filemap, pHitObj);

            // reset err message so next msg will be generic as we move up the stack
            m_idErrMsg = 0;
            }

        THROW(hrException);

    END_TRY

    if (fPrevCodePageSet){
        m_wCodePage = wPrevCodePage;
        pHitObj->SetCodePage(wPrevCodePage);
    }
    }


#define SZ_REG_LANGUAGE_ENGINES "SYSTEM\\CurrentControlSet\\Services\\W3SVC\\ASP\\LanguageEngines\\"
/*  ============================================================================
    CTemplate::GetLanguageEquivalents
    Gets the "Write", "WriteBlock", etc. equivalents from registry for primary scripting language

    Returns
        Nothing
    Side effects
        Throws on error
*/
void
CTemplate::GetLanguageEquivalents
(
)
    {
    CByteRange  brPrimaryEngine;
    m_pWorkStore->m_ScriptStore.m_bufEngineNames.GetItem(0, brPrimaryEngine);   // 0-th engine is primary

#if DBG

    /*  DEBUG ONLY - to test the reg lookup code you must:
        1) create the key HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W3SVC\ASP\LanguageEngines\Debug
        2) put the language reg values for WriteBlock and Write under the language you want to test
    */
    HANDLE  hKey;
    if(ERROR_SUCCESS != RegOpenKeyExA(
                                        HKEY_LOCAL_MACHINE,
                                        "SYSTEM\\CurrentControlSet\\Services\\W3SVC\\ASp\\LanguageEngines\\Debug",
                                        0,
                                        KEY_READ,
                                        (PHKEY)&hKey
                                    ))
        {
        return;
        }

    RegCloseKey((HKEY)hKey);

#else

    //  if the primary language is one of the big two, return; we don't need to look up equivalents
    if(brPrimaryEngine.FMatchesSz("VBScript"))
        return;
    if(brPrimaryEngine.FMatchesSz("JScript"))
        return;
    if(brPrimaryEngine.FMatchesSz("JavaScript"))
        return;
    if(brPrimaryEngine.FMatchesSz("LiveScript"))
        return;

#endif  // DBG

    /*  query the registry; language equivalents are stored in:
        HKEY_LOCAL_MACHINE
            key: SYSTEM
                key: CurrentControlSet
                    key: Services
                        key: W3SVC
                            key: ASP
                                key: LanguageEngines
                                    key: <LanguageName>
                                        value: Write        data: <replacement syntax for Response.Write(|)>
                                        value: WriteBlock   data: <replacement syntax for Response.WriteBlock(|)>
    */
    STACK_BUFFER( tempRegKeyPath, 512 );

    UINT    cchRegKeyPath = strlen(SZ_REG_LANGUAGE_ENGINES);

    if (!tempRegKeyPath.Resize(cchRegKeyPath + brPrimaryEngine.m_cb + 1)) {
        SetLastError(E_OUTOFMEMORY);
        return;
    }

    LPSTR   szRegKeyPath = static_cast<LPSTR> (tempRegKeyPath.QueryPtr());

    LPSTR   pch = szRegKeyPath;

    strcpy(pch, SZ_REG_LANGUAGE_ENGINES);
    pch += cchRegKeyPath;
    strncpy(pch, (const char *) brPrimaryEngine.m_pb, brPrimaryEngine.m_cb);
    pch += brPrimaryEngine.m_cb;
    *pch = '\0';

    HANDLE      hKeyScriptLanguage; // handle of script language reg key

    if(ERROR_SUCCESS == RegOpenKeyExA(
                                        HKEY_LOCAL_MACHINE, // handle constant
                          (const char*) szRegKeyPath,       // LPCSTR lpSubKey     subkey to open
                                        0,                  // DWORD ulOptions      reserved; must be zero
                                        KEY_QUERY_VALUE,    // REGSAM samDesired    security access mask
                                        (PHKEY) &hKeyScriptLanguage // PHKEY phkResult      address of handle of open key
                                    ))
        {
        SetLanguageEquivalent(hKeyScriptLanguage, "Write",      &(m_pWorkStore->m_szWriteOpen),      &(m_pWorkStore->m_szWriteClose));
        SetLanguageEquivalent(hKeyScriptLanguage, "WriteBlock", &(m_pWorkStore->m_szWriteBlockOpen), &(m_pWorkStore->m_szWriteBlockClose));
        RegCloseKey((HKEY) hKeyScriptLanguage);
        }

    }

/*  ============================================================================
    CTemplate::SetLanguageEquivalent
    Sets a "language equivalent" from the registry.

    Returns:
        language item opener and closer as out-parameters
        Ex: "Response.Write(" and ")"
    Side effects:
        Throws on error
*/
void
CTemplate::SetLanguageEquivalent
(
HANDLE  hKeyScriptLanguage, // reg key
LPSTR   szLanguageItem,     // reg value name - "Write", "WriteBlock", etc.
LPSTR*  pszOpen,            // ptr to language item opener, e.g. "Response.Write("  (out-parameter)
LPSTR*  pszClose            // ptr to language item closer, e.g. ")"                (out-parameter)
)
    {
    LONG    lError;
    DWORD   cbSyntax;
    LPSTR   szSyntax;
    char*   pchInsert;
    UINT    cchOpen;
    UINT    cchClose;

    // query registry to get buffer size
    lError = RegQueryValueExA(
                                (HKEY) hKeyScriptLanguage,  // handle of key to query
                                szLanguageItem,     // name of value to query
                                NULL,               // reserved; must be NULL
                                NULL,               // ptr to value type; not required
                                NULL,               // ptr to data buffer
                                &cbSyntax           // ptr to data buffer size
                            );

    if(ERROR_FILE_NOT_FOUND == lError)
        // if we don't find szLanguageItem in registry, return silently, leaving *pszOpen and *pszClose unchanged
        return;
    else if((ERROR_MORE_DATA != lError) && (ERROR_SUCCESS != lError))
        THROW(lError);

    Assert(cbSyntax > 0);

    // allocate buffer and re-query registry to get syntax string
    // NOTE RegQueryValueEx returns cbSyntax that includes room for '\0' terminator

    STACK_BUFFER(tempSyntax, 64);

    if (!tempSyntax.Resize(cbSyntax)) {
        THROW(E_OUTOFMEMORY);
    }
    szSyntax = static_cast<LPSTR> (tempSyntax.QueryPtr());
    lError = RegQueryValueExA(
                                (HKEY) hKeyScriptLanguage,  // handle of key to query
                                szLanguageItem,     // name of value to query
                                NULL,               // reserved; must be NULL
                                NULL,               // ptr to value type; not required
                       (LPBYTE) szSyntax,           // ptr to data buffer
                                &cbSyntax           // ptr to data buffer size
                            );

    /*  NOTE there is the slight possibility of ERROR_FILE_NOT_FOUND or ERROR_MORE_DATA
        if the registry value was deleted or changed between the first and second calls to RegQueryValueEx.
        Since this occurs with vanishingly small probability, we throw (instead of coding the re-try logic).
    */
    if(ERROR_SUCCESS != lError)
        THROW(lError);

    pchInsert = szSyntax;

    while(*pchInsert != '|' && *pchInsert != '\0')
        pchInsert++;

    cchOpen = DIFF(pchInsert - szSyntax);

    cchClose =  *pchInsert == '|'
                ? cbSyntax - cchOpen - 2    // found insert symbol: deduct 2 chars, 1 for insert symbol, 1 for '\0'
                : cbSyntax - cchOpen - 1;   // didn't find insert symbol: deduct 1 char for '\0'

    Assert(FImplies(cchOpen == 0, *szSyntax == '|'));
    Assert(FImplies(*pchInsert == '\0', cchClose == 0));

    if(cchOpen == 0)
        // opener is empty - set caller's opener ptr null
        *pszOpen = NULL;
    else if(cchOpen > 0)
        {
        // opener is non-empty - set caller's opener to opener in registry
        if(NULL == (*pszOpen = (LPSTR) CTemplate::SmallMalloc(cchOpen + 1)))
            THROW(E_OUTOFMEMORY);

        strncpy(*pszOpen, szSyntax, cchOpen);
        (*pszOpen)[cchOpen] = '\0';
        }

    if(cchClose == 0)
        // closer is empty - set caller's closer ptr null
        *pszClose = NULL;
    else if(cchClose > 0)
        {
        // closer is non-empty - set caller's closer to closer in registry
        if(NULL == (*pszClose = (LPSTR) CTemplate::SmallMalloc(cchClose + 1)))
            THROW(E_OUTOFMEMORY);

        strncpy(*pszClose, (pchInsert + 1), cchClose);
        (*pszClose)[cchClose] = '\0';
        }

    }

/*  ============================================================================
    CTemplate::ThrowError
    Sets up for processing a compile failure.

    Returns:
        Nothing
    Side effects:
        Throws error
*/
void
CTemplate::ThrowError
(
BYTE*   pbErrorLocation,    // ptr to error location in source file
UINT    idErrMsg            // error id
)
    {
    m_pbErrorLocation = pbErrorLocation;
    m_idErrMsg = idErrMsg;

    // bug 80745: always throw compile-failed-don't-cache
    THROW(E_TEMPLATE_COMPILE_FAILED_DONT_CACHE);
    }

/*  ============================================================================
    CTemplate::AppendErrorMessageInsert
    Appends an error message insert to member array.

    Returns:
        Nothing
    Side effects:
        Appends to inserts array
*/
void
CTemplate::AppendErrorMessageInsert
(
BYTE*   pbInsert,   // ptr to insert
UINT    cbInsert    // length of insert
)
    {
    if (m_ppszMsgInserts == NULL)
        {
        m_ppszMsgInserts = new char*;
        m_cMsgInserts = 0;

        if (m_ppszMsgInserts == NULL)
            return;
        }

    m_ppszMsgInserts[m_cMsgInserts] = new char[cbInsert + 1];
    if (m_ppszMsgInserts[m_cMsgInserts] == NULL)
        return;

    strncpy(m_ppszMsgInserts[m_cMsgInserts], (const char*)pbInsert, cbInsert);
    m_ppszMsgInserts[m_cMsgInserts++][cbInsert] = NULL;
    }

/*  ============================================================================
    CTemplate::ThrowErrorSingleInsert
    Appends a single message insert to member array and throws a compile error.

    Returns:
        Nothing
    Side effects:
        Throws error indirectly
*/
void
CTemplate::ThrowErrorSingleInsert
(
BYTE*   pbErrorLocation,    // ptr to error location in source file
UINT    idErrMsg,           // error id
BYTE*   pbInsert,           // ptr to insert
UINT    cbInsert            // length of insert
)
    {
    AppendErrorMessageInsert(pbInsert, cbInsert);
    ThrowError(pbErrorLocation, idErrMsg);
    }

/*  ============================================================================
    CTemplate::ProcessSpecificError
    Processes a specific compile failure.

    Returns:
        Nothing
    Side effects:
        None
*/
void
CTemplate::ProcessSpecificError
(
CFileMap&   filemap,        // source file map
CHitObj*    pHitObj         // Browser request object
)
    {
    // no error msg for generic failures
    if(m_idErrMsg == E_FAIL || m_idErrMsg == E_OUTOFMEMORY)
        return;

    HandleCTemplateError(
                            &filemap,
                            m_pbErrorLocation,
                            m_idErrMsg,
                            m_cMsgInserts,
                            m_ppszMsgInserts,
                            pHitObj
                        );
    }


/*  ============================================================================
    CTemplate::ShowErrorInDebugger
    Display a runtime error by invoking the JIT debugger

    Returns:
        failure if debugger won't start

    Side effects:
        None.
*/
HRESULT
CTemplate::ShowErrorInDebugger
(
CFileMap* pfilemap,
UINT cchErrorLocation,
char* szDescription,
CHitObj *pHitObj,
BOOL fAttachDocument
)
    {
    HRESULT hr = S_OK;
    char szDebugTitle[64];

    if (pfilemap == NULL || szDescription == NULL || pHitObj == NULL)
        return E_POINTER;

    // Create a new document context for this statement
    // CONSIDER: character count that we return is bogus - however our debugging
    //           client (Caesar's) does not use this information anyway.
    //
    CTemplateDocumentContext *pDebugContext = new CTemplateDocumentContext(this, cchErrorLocation, 1);
    if (pDebugContext == NULL)
        return E_OUTOFMEMORY;

    // Make sure debug document is attached to debugger
    if (fAttachDocument)
                AttachTo(pHitObj->PAppln());

    // Yes it does, bring up the debugger on this line
    hr =  InvokeDebuggerWithThreadSwitch(g_pDebugApp, DEBUGGER_UI_BRING_DOC_CONTEXT_TO_TOP, pDebugContext);
    if (FAILED(hr))
        goto LExit;

    // Load the compiler message string
    CchLoadStringOfId(IDE_TEMPLATE_ERRMSG_TITLE, szDebugTitle, sizeof szDebugTitle);

    // pop up a message box with the error description
    MessageBoxA(NULL, szDescription, szDebugTitle, MB_SERVICE_NOTIFICATION | MB_TOPMOST | MB_OK | MB_ICONEXCLAMATION);

LExit:
    if (pDebugContext)
        pDebugContext->Release();

    return hr;
    }

/*  ============================================================================
    CTemplate::HandleCTemplateError
    Handles template compilation errors

    Returns:
        Nothing

    Side effects:
        None.
*/
void
CTemplate::HandleCTemplateError
(
CFileMap*   pfilemap,           // ptr to source file map
BYTE*       pbErrorLocation,    // ptr to source location where error occurred
UINT        idErrMsg,           // error message id
UINT        cMsgInserts,        // count of insert strings for error msg
char**      ppszMsgInserts,     // array of ptrs to error msg insert strings
CHitObj*    pHitObj             // Browser Request
)
    {
    char    szErrMsgPattern[MAX_RESSTRINGSIZE]; // error message pattern
    CHAR    szLineNum[12];
    TCHAR   szFileName[512];
    CHAR    szShortDes[256];
    CHAR    szEngine[256];
    CHAR    szErrCode[20];
    CHAR    szLongDes[MAX_RESSTRINGSIZE];
    CHAR    szCombinedDes[sizeof szShortDes + sizeof szLongDes];    // long & short desc
    DWORD   dwMask;
    UINT    cch;


    // if request ptr or ecb ptr is null, bail; we won't be able to write error msg anyway
    if(pHitObj == NULL)
        return;

    /*  if this was a security error, process it specially and bail
        NOTE security error causes exception, rather than true error id
        NOTE template will be destroyed anyway in this case, so no need to maintain m_pszLastErrorMessage
    */
    if(idErrMsg == E_USER_LACKS_PERMISSIONS)
        {
        Assert(cMsgInserts == 1);
        HandleAccessFailure(pHitObj,
                                                        (m_rgpFilemaps && m_rgpFilemaps[0])? m_rgpFilemaps[0]->m_szPathTranslated : NULL);

        return;
        }

    // get error resource message
    LoadErrResString(idErrMsg, &dwMask, szErrCode, szShortDes, szLongDes);

    // if we have a specific error location, construct msg prefix
    if(pbErrorLocation != NULL) {
        Assert(pfilemap != NULL);
        // get line number of error location as string
        _itoa(SourceLineNumberFromPb(pfilemap, pbErrorLocation), szLineNum, 10);
    }
    else {
        szLineNum[0] = NULL;
    }

    if(pfilemap != NULL) {
        cch = _tcslen(pfilemap->m_szPathInfo);
        _tcsncpy(szFileName, pfilemap->m_szPathInfo, cch);
    }
    else {
        cch = 0;
    }

    szFileName[cch] = '\0';

    //Load Default Engine from resource
    cch = CchLoadStringOfId(IDS_ENGINE, szEngine, sizeof szEngine);
    szEngine[cch] = '\0';

    // resolve error msg pattern and inserts into actual error msg
    cch = strlen(szLongDes);
    memcpy(szErrMsgPattern, szLongDes, cch);
    szErrMsgPattern[cch] = '\0';

    // get an idea of the possibility of a buffer overrunn
    UINT dwTotalLen=0;
        BOOL fTooBig = FALSE;

    if (cMsgInserts) {
        // allow 32 characters for space, etc.
        dwTotalLen = 32 + strlen(szErrMsgPattern);
		for (UINT i = 0; i < cMsgInserts; i++)
			dwTotalLen += strlen(ppszMsgInserts[i]);

		if (dwTotalLen > sizeof szLongDes) {
			cch = CchLoadStringOfId(IDE_TOOBIG, szLongDes, sizeof szLongDes);
			szLongDes[cch] = '\0';
			fTooBig = TRUE;
        }
    }

    if (!fTooBig)
        GetSzFromPatternInserts(szErrMsgPattern, cMsgInserts, ppszMsgInserts, szLongDes);
    
    // attempt to bring up debugger to display the error - if we cannot then log the error

    /* Find the character offset closest to cbErrorLocation.  This will be
     * the place where we start looping with CharNext() to get the full
     * character offset.
     *
     * NOTE: compilation is done in two phases.
     *          Errors are detected and reported in phase 1.
     *          The DBCS mapping is created in phase 2.
     *
     *    Therefore, we don't have the benefit of the rgByte2DBCS table
     *    because it doesn't exist yet.  Therefore we are left with a SLOW
     *    loop starting at BOF.  To make things not so abysmal, we don't
     *    do the loop on SBCS charsets.  We also don't do this conversion
     *    unless debugging is enabled.
     */

    if (FCaesars() && pHitObj->PAppln()->FDebuggable()) {
        unsigned cchErrorLocation = CharAdvDBCS(
                                        (WORD)m_wCodePage,
                                        reinterpret_cast<char *>(pfilemap->m_pbStartOfFile),
                                        reinterpret_cast<char *>(pbErrorLocation),
                                        INFINITE,
                                        NULL);

        // Create the description string
        char *szEnd = strcpyExA(szCombinedDes, szShortDes);
        *szEnd++ = '\n';
        *szEnd++ = '\n';
        strcpy(szEnd, szLongDes);

        ShowErrorInDebugger(pfilemap, cchErrorLocation, szCombinedDes, pHitObj, idErrMsg != IDE_TEMPLATE_CYCLIC_INCLUDE);
    }

    //cache the info in case we need to use later.
    m_dwLastErrorMask = dwMask;
    //delay NULL check to caller who use this info.
#if UNICODE
    m_pszLastErrorInfo[ILE_szFileName]  = StringDupUTF8(szFileName);
#else
    m_pszLastErrorInfo[ILE_szFileName]  = StringDupA(szFileName);
#endif
    m_pszLastErrorInfo[ILE_szLineNum]   = StringDupA(szLineNum);
    m_pszLastErrorInfo[ILE_szEngine]    = StringDupA(szEngine);
    m_pszLastErrorInfo[ILE_szErrorCode] = StringDupA(szErrCode);
    m_pszLastErrorInfo[ILE_szShortDes]  = StringDupA(szShortDes);
    m_pszLastErrorInfo[ILE_szLongDes]   = StringDupA(szLongDes);

    SendToLog(  m_dwLastErrorMask,
                m_pszLastErrorInfo[ILE_szFileName],
                m_pszLastErrorInfo[ILE_szLineNum],
                m_pszLastErrorInfo[ILE_szEngine],
                m_pszLastErrorInfo[ILE_szErrorCode],
                m_pszLastErrorInfo[ILE_szShortDes],
                m_pszLastErrorInfo[ILE_szLongDes],
                pHitObj);
    }

/*  ============================================================================
    CTemplate::FreeGoodTemplateMemory
    Frees memory allocated for a 'good' (successfully compiled) template.
    This includes the template itself, memory to support compile-time errors
    (since the entire concatenated compile-time error message is cached in
    last-err-msg member), and memory to support run-time errors (since if the
    template didn't compile, it can't run).

    Returns
        Nothing
    Side effects
        None
*/
void
CTemplate::FreeGoodTemplateMemory
(
)
    {
    UINT    i;

        LargeTemplateFreeNullify((void**) &m_pbStart);
    SmallTemplateFreeNullify((void**) &m_rgpSegmentFilemaps);

    delete[] m_rgrgSourceInfos;
    m_rgrgSourceInfos = NULL;

    if(m_ppszMsgInserts)
        {
        for(i = 0; i < m_cMsgInserts; i++)
            delete m_ppszMsgInserts[i];
        delete m_ppszMsgInserts;
        m_ppszMsgInserts = NULL;
        }

    // release the collected type libs
    ReleaseTypeLibs();

    // release any 449-echo-cookie objects
    Release449();
    }

/*  ============================================================================
    CTemplate::UnmapFiles
    Unmaps the template's filemaps.
    NOTE: we keep filemap objects around so that filenames will be available for runtime errors

    Returns
        Nothing
    Side effects
        Unmaps template's filemaps
*/
void
CTemplate::UnmapFiles
(
)
    {
    UINT    i;
    for(i = 0; i < m_cFilemaps; i++)
        m_rgpFilemaps[i]->UnmapFile();
    }

/*===================================================================
    CTemplate::ExtractAndProcessSegment
    Extracts and processes leading source segment and first contained
    source segment from search range.

    Returns
        Nothing
    Side effects
        None
*/
void
CTemplate::ExtractAndProcessSegment
(
CByteRange&             brSearch,           // byte range to search for next segment-opening token
const SOURCE_SEGMENT&   ssegLeading,        // type of 'leading', i.e. pre-token, source segment
_TOKEN*                 rgtknOpeners,       // array of permitted open tokens
UINT                    ctknOpeners,        // count of permitted open tokens
CFileMap*               pfilemapCurrent,    // ptr to filemap of parent file
CWorkStore&             WorkStore,          // working storage for source segments
CHitObj*                pHitObj,            // Browser request object
BOOL                    fScriptTagProcessed,// has script tag been processed?
BOOL                    fIsHTML             // are we in HTML segment?
)
    {
    CByteRange      brLeadSegment;      // byte range of leading source segment
    SOURCE_SEGMENT  ssegContained;      // type of 'contained', i.e. post-token, source segment
    CByteRange      brContainedSegment; // byte range of contained source segment
    _TOKEN          tknOpen;            // opening token
    BYTE*           pbTokenOpen;        // ptr to opening token
    _TOKEN          tknClose;           // closing token
    BYTE*           pbTokenClose;       // ptr to closing token

    // NOTE: If "fScriptTagProcessed" is TRUE, then "fIsHTML" must be FALSE.  The reason for
    // both flags is that if "fScriptTagProcessed" is FALSE, then "fIsHTML" may be either TRUE
    // or FALSE (indeterminate)
    //
    Assert (FImplies(fScriptTagProcessed, !fIsHTML));

    // If search range is empty, return
    if(brSearch.IsNull())
        return;

    // Set ptr of leading segment to start of search segment
    brLeadSegment.m_pb = brSearch.m_pb;

    // get open token for contained segment
    pbTokenOpen = GetOpenToken(
                                brSearch,
                                ssegLeading,
                                rgtknOpeners,
                                ctknOpeners,
                                &tknOpen
                            );

    // Set count of leading segment to distance between start of search range and token
    brLeadSegment.m_cb = DIFF(pbTokenOpen - brSearch.m_pb);

    // Process leading segment
    ProcessSegment(ssegLeading, brLeadSegment, pfilemapCurrent, WorkStore, fScriptTagProcessed, pHitObj, fIsHTML);

    // If open token was 'EOF', empty out search range and return
    if(tknOpen == CTokenList::tknEOF)
        {
        brSearch.Nullify();
        return;
        }

    // Set contained segment type and close token based upon the opener we found
    tknClose = GetComplementToken(tknOpen);
    ssegContained = GetSegmentOfOpenToken(tknOpen);

    if(ssegContained == ssegHTMLComment)
        // for html comment segments, advance search range to open token
        // NOTE keep html comment tags in segment because they must be sent to client
        brSearch.Advance(DIFF(pbTokenOpen - brSearch.m_pb));
    else
        // for all but html comment segments, advance search range to just past open token
        gm_pTokenList->MovePastToken(tknOpen, pbTokenOpen, brSearch);

    // Get closing token - if none, throw error
    if(NULL == (pbTokenClose = GetCloseToken(brSearch, tknClose)))
        {
        if(tknOpen == CTokenList::tknOpenPrimaryScript)
            ThrowError(pbTokenOpen, IDE_TEMPLATE_NO_CLOSE_PSCRIPT);
        else if(tknOpen == CTokenList::tknOpenTaggedScript)
            ThrowError(pbTokenOpen, IDE_TEMPLATE_NO_CLOSE_TSCRIPT);
        else if(tknOpen == CTokenList::tknOpenObject)
            ThrowError(pbTokenOpen, IDE_TEMPLATE_NO_CLOSE_OBJECT);
        else if(tknOpen == CTokenList::tknOpenHTMLComment)
            ThrowError(pbTokenOpen, IDE_TEMPLATE_NO_CLOSE_HTML_COMMENT);
        }

    // calc contained segment
    brContainedSegment.m_pb = brSearch.m_pb;
    brContainedSegment.m_cb = DIFF(pbTokenClose - brSearch.m_pb);

    // advance search range to just past close token
    gm_pTokenList->MovePastToken(tknClose, pbTokenClose, brSearch);

    // if an html comment segment, get actual segment type (e.g. might be a server-side include command)
    // NOTE call may also change contained segment byte range
    if(ssegContained == ssegHTMLComment)
        ssegContained = SsegFromHTMLComment(brContainedSegment);

    // if an html comment segment, add its close tag to contained segment
    // NOTE we keep html comment tags as part of segment so we can process like any other html segment
    if(ssegContained == ssegHTMLComment)
        brContainedSegment.m_cb += CCH_TOKEN(tknClose);

    if(ssegContained == ssegMetadata)
        {
        // METADATA comments are used by DESIGN time controls and we don't send
        // them to the client.

        // We process metadata to get to the typelib info
        UINT idError = 0;
        HRESULT hr = ProcessMetadataSegment(brContainedSegment, &idError, pHitObj);

        if (FAILED(hr))
            ThrowError(brContainedSegment.m_pb, idError);
        }
    else if (ssegContained == ssegFPBot)
        {
        }
    else
        {
        // process contained segment
        ProcessSegment(ssegContained, brContainedSegment, pfilemapCurrent, WorkStore, fScriptTagProcessed, pHitObj, fIsHTML);
        }
    }

/*  ============================================================================
    CTemplate::SsegFromHTMLComment
    Determines source segment type of HTML comment.

    Returns
        Source segment type
    Side effects
        May advance segment byte range
*/
CTemplate::SOURCE_SEGMENT
CTemplate::SsegFromHTMLComment
(
CByteRange& brSegment   // source segment
)
    {
    SOURCE_SEGMENT  ssegRet = ssegHTMLComment;  // return value
    BYTE*           pbToken;                    // ptr to token

    if(NULL != (pbToken = gm_pTokenList->GetToken(CTokenList::tknCommandINCLUDE, brSegment, m_wCodePage)))
        {
        gm_pTokenList->MovePastToken(CTokenList::tknCommandINCLUDE, pbToken, brSegment);
        ssegRet = ssegInclude;
        }
    else if(NULL != (pbToken = gm_pTokenList->GetToken(CTokenList::tknTagMETADATA, brSegment, m_wCodePage)))
        {
        gm_pTokenList->MovePastToken(CTokenList::tknTagMETADATA, pbToken, brSegment);
        ssegRet = ssegMetadata;
        }
    else if(NULL != (pbToken = gm_pTokenList->GetToken(CTokenList::tknTagFPBot, brSegment, m_wCodePage)))
        {
        gm_pTokenList->MovePastToken(CTokenList::tknTagFPBot, pbToken, brSegment);
        ssegRet = ssegFPBot;
        }

    return ssegRet;
    }

/*  ============================================================================
    CTemplate::ProcessSegment
    Processes a source segment based on its type.

    Returns
        Nothing
    Side effects
        None
*/
void
CTemplate::ProcessSegment
(
SOURCE_SEGMENT  sseg,                   // segment type
CByteRange&     brSegment,              // segment byte range
CFileMap*       pfilemapCurrent,        // ptr to filemap of parent file
CWorkStore&     WorkStore,              // working storage for source segments
BOOL            fScriptTagProcessed,    // has script tag been processed?
CHitObj*        pHitObj,                // Browser request object
BOOL            fIsHTML                 // Is segment in HTML block or script?
)
    {
    UINT        idSequence; // sequence id for this segment

    // if segment is entirely white space, silently return
    if(FByteRangeIsWhiteSpace(brSegment))
        return;

    // set local sequence id and increment member
    idSequence = WorkStore.m_idCurSequence++;

    // Process segment based on its type
    if(sseg == ssegHTML)
        ProcessHTMLSegment(brSegment, WorkStore.m_bufHTMLSegments, idSequence, pfilemapCurrent);
    else if(sseg == ssegHTMLComment)
        ProcessHTMLCommentSegment(brSegment, pfilemapCurrent, WorkStore, pHitObj);
    else if(sseg == ssegPrimaryScript || sseg == ssegTaggedScript)
        ProcessScriptSegment(sseg, brSegment, pfilemapCurrent, WorkStore, idSequence, (BOOLB)!!fScriptTagProcessed, pHitObj);
    else if(sseg == ssegObject)
        ProcessObjectSegment(brSegment, pfilemapCurrent, WorkStore, idSequence);
    else if(sseg == ssegInclude)
        {
        if (! fIsHTML)
                ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_SSI_COMMAND);

        ProcessIncludeFile(brSegment, pfilemapCurrent, WorkStore, idSequence, pHitObj, fIsHTML);
        }

    // malloc/realloc array if needed
    if(m_cSegmentFilemapSlots == 0)
        {
        m_cSegmentFilemapSlots = C_SCRIPTSEGMENTSDEFAULT + C_HTMLSEGMENTSDEFAULT;
        if(NULL == (m_rgpSegmentFilemaps = (CFileMap**) CTemplate::SmallMalloc(m_cSegmentFilemapSlots * sizeof(CFileMap*))))
            THROW(E_OUTOFMEMORY);
        }
    else if(idSequence >= m_cSegmentFilemapSlots)
        {
        // grab twice what we had before
        m_cSegmentFilemapSlots *= 2;
        if(NULL == (m_rgpSegmentFilemaps = (CFileMap**) CTemplate::SmallReAlloc(m_rgpSegmentFilemaps,
                                                            m_cSegmentFilemapSlots * sizeof(CFileMap*))))
            THROW(E_OUTOFMEMORY);
        }

    // set filemap ptr for this segment - NOTE 'parent' filemap is also current file map
    m_rgpSegmentFilemaps[idSequence] = pfilemapCurrent;
    }

/*  ========================================================
    CTemplate::ProcessHTMLSegment

    Processes an HTML segment.

    Returns
        Nothing
    Side effects
        None
*/
void
CTemplate::ProcessHTMLSegment
(
CByteRange& brHTML,         // html segment
CBuffer&    bufHTMLBlocks,  // working storage for html blocks
UINT        idSequence,     // segment sequence id
CFileMap*   pfilemapCurrent // current filemap
)
    {
    if(!(brHTML.IsNull()))
        // If byte range is non-empty, store it in html buffer (non-local)
        bufHTMLBlocks.Append(brHTML, FALSE, idSequence, pfilemapCurrent);
    }

/*  ========================================================
    CTemplate::ProcessHTMLCommentSegment
    Processes an HTML comment segment: within an HTML comment we
    honor plain text (passed through as HTML comment) and primary script.
    See bug 182 for istudio scenarios that require this behavior.

    Returns
        Nothing
    Side effects
        None
*/
void
CTemplate::ProcessHTMLCommentSegment
(
CByteRange&     brSegment,          // segment byte range
CFileMap*       pfilemapCurrent,    // ptr to filemap of parent file
CWorkStore&     WorkStore,          // working storage for source segments
CHitObj*        pHitObj             // Browser request object
)
    {
    _TOKEN*     rgtknOpeners;   // array of permitted open tokens
    UINT        ctknOpeners;    // count of permitted open tokens

    // populate array of permitted open tokens
    ctknOpeners = 1;
    _TOKEN  tknOpeners[1];
    rgtknOpeners = tknOpeners;
    rgtknOpeners[0] = CTokenList::tknOpenPrimaryScript;

    // Process source segments embedded within HTML comment segment
    while(!brSegment.IsNull())
        ExtractAndProcessSegment(
                                    brSegment,      // byte range to search for next segment-opening token
                                    ssegHTML,       // type of 'leading', i.e. pre-token, source segment
                                    rgtknOpeners,   // array of permitted open tokens
                                    ctknOpeners,    // count of permitted open tokens
                                    pfilemapCurrent,// ptr to filemap of parent file
                                    WorkStore,      // working storage for source segments
                                    pHitObj         // Browser request object
                                );
    }

/*  ============================================================================
    CTemplate::ProcessScriptSegment
    Processes a script segment.

    Returns
        Nothing
    Side effects
        None
*/
void
CTemplate::ProcessScriptSegment
(
SOURCE_SEGMENT  sseg,               // segment type
CByteRange&     brSegment,          // segment byte range
CFileMap*       pfilemapCurrent,    // ptr to filemap of parent file
CWorkStore&     WorkStore,          // working storage for scripts
UINT            idSequence,         // segment sequence id
BOOLB           fScriptTagProcessed,// has script tag been processed?
CHitObj*        pHitObj             // Browser request object
)
    {
    CByteRange  brEngine;       // script engine name - NOTE constructed null

    if(m_fGlobalAsa)
        if(sseg == ssegPrimaryScript)
            // error out on primary script if we are processing global.asa
            ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_GLOBAL_PSCRIPT);

    if(sseg == ssegPrimaryScript)
        {
        CByteRange  brTemp = brSegment;

        LTrimWhiteSpace(brTemp);

        if(*brTemp.m_pb == '@') // CONSIDER: tknTagSetPriScriptLang
            {
            // impossible condition: page-level @ commands can't be allowed if they have already been executed
            Assert(!(WorkStore.m_fPageCommandsAllowed && WorkStore.m_fPageCommandsExecuted));

            if(!WorkStore.m_fPageCommandsAllowed)
                {
                if(WorkStore.m_fPageCommandsExecuted)
                    // error out if trying to re-execute page-level @ commands
                    ThrowError(brSegment.m_pb, IDE_TEMPLATE_PAGE_COMMAND_REPEATED);
                else
                    // error out if trying to execute page-level @ commands when not allowed
                    ThrowError(brSegment.m_pb, IDE_TEMPLATE_PAGE_COMMAND_NOT_FIRST);
                }

            // if we made it here, must be allowed to execute page-level @ commands AND they have not been executed
            Assert((WorkStore.m_fPageCommandsAllowed && !WorkStore.m_fPageCommandsExecuted));

            /*  set primary script language if required
                NOTE we call GetTagName to see if LANGUAGE tag occurs in tags segment; this is somewhat wasteful,
                since BrValueOfTag must simply call GetTagName again.  However, this scheme is easier than changing
                BrValueOfTag to return a BOOL and amending all its other callers, who don't need this info.
            */

            // Flags and counters used to track and validate the @ command directive
            //
            int     nFirstPass = 1;
            int     nOffset     = 0;
            BOOLB   fTagLanguage    = TRUE;
            BOOLB   fTagCodePage    = TRUE;
            BOOLB   fTagLCID        = TRUE;
            BOOLB   fTagTransacted  = TRUE;
            BOOLB   fTagSession     = TRUE;

            while( GetTag( brSegment, nFirstPass) )
                {
                nFirstPass =2;
                nOffset = 0;

                if ( fTagLanguage && CompTagName( brSegment, CTokenList::tknTagLanguage ) )
                    {
                    fTagLanguage = FALSE;
                    brEngine = BrValueOfTag(brSegment, CTokenList::tknTagLanguage);
                    if ( brEngine.IsNull() )
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_NO_ENGINE_NAME);

                    // get prog lang id
                    PROGLANG_ID ProgLangId;
                    HRESULT hr = GetProgLangId(brEngine, &ProgLangId);

                    if(hr == TYPE_E_ELEMENTNOTFOUND)
                        // if prog lang not found, throw error
                        ThrowErrorSingleInsert(
                                            brEngine.m_pb,
                                            IDE_TEMPLATE_BAD_PROGLANG,
                                            brEngine.m_pb,
                                            brEngine.m_cb
                                            );
                    else if(FAILED(hr))
                        // other failure: re-throw exception code
                        THROW(hr);

                    Assert(WorkStore.m_ScriptStore.CountPreliminaryEngines() >= 1);

                    // Set 0-th (primary) script engine to user-specified value
                    WorkStore.m_ScriptStore.m_bufEngineNames.SetItem(
                                                                0,          // index of item to set
                                                                brEngine,   // engine name
                                                                FALSE,      // item is non-local
                                                                0,          // sequence id (don't care)
                                                                NULL        // filemap ptr (don't care)
                                                                );

                    // Set 0-th (primary) prog lang id to engine's
                    WorkStore.m_ScriptStore.m_rgProgLangId[0] = ProgLangId;
                    brSegment.Advance(DIFF(brEngine.m_pb - brSegment.m_pb));

                    }

                /*  set code page if required
                    see NOTE above for why we call we call GetTagName.
                */
                else if ( fTagCodePage && CompTagName( brSegment, CTokenList::tknTagCodePage ) )
                    {
                    fTagCodePage = FALSE;
                    CByteRange brCodePage = BrValueOfTag( brSegment, CTokenList::tknTagCodePage );
                    if ( brCodePage.IsNull() )
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_NO_CODEPAGE);

                    if ( brCodePage.m_cb > 10 )
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_CODEPAGE);

                    char    szCodePage[31];
                    strncpy( szCodePage, (char*) brCodePage.m_pb, brCodePage.m_cb );
                    szCodePage[ brCodePage.m_cb ] = '\0';

                                        char   *pchEnd;
                                        UINT    uCodePage = UINT( strtoul( szCodePage, &pchEnd, 10 ) );

                                        // verify that pchEnd is the NULL
                                        if (*pchEnd != 0)
                                                ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_CODEPAGE);

                    if ( FAILED( pHitObj->SetCodePage( uCodePage ) ) )
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_CODEPAGE);
                    else
                        {
                        m_wCodePage = uCodePage;
                        m_fCodePageSet = TRUE;
                        }

                    brSegment.Advance(DIFF(brCodePage.m_pb - brSegment.m_pb));
                    }
                /*  set LCID if required
                    see NOTE above for why we call we call GetTagName.
                */
                else if ( fTagLCID && CompTagName( brSegment, CTokenList::tknTagLCID ) )
                    {
                    fTagLCID = FALSE;
                    CByteRange brLCID = BrValueOfTag( brSegment, CTokenList::tknTagLCID );
                    if ( brLCID.IsNull() )
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_NO_LCID);

                    char    szLCID[31];
                    strncpy( szLCID, (char*) brLCID.m_pb, brLCID.m_cb );
                    szLCID[ brLCID.m_cb ] = '\0';

                                        char   *pchEnd;
                                        UINT    uLCID = UINT( strtoul( szLCID, &pchEnd, 10 ) );

                                        // verify that pchEnd is the NULL
                                        if (*pchEnd != 0)
                                                ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_LCID);

                    if ( FAILED( pHitObj->SetLCID( uLCID ) ) )
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_LCID);
                    else
                        {
                        m_lLCID = uLCID;
                        m_fLCIDSet = TRUE;
                        }

                    brSegment.Advance(DIFF(brLCID.m_pb - brSegment.m_pb));
                    }
                /* Set transacted if requiured
                   see NOTE above for why we call GetTagName
                */
                else if ( fTagTransacted && CompTagName( brSegment, CTokenList::tknTagTransacted ) )
                    {

                    STACK_BUFFER( tempTransValue, 32 );

                    fTagTransacted = FALSE;
                    CByteRange brTransacted = BrValueOfTag( brSegment, CTokenList::tknTagTransacted );
                    if ( brTransacted.IsNull() )
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_TRANSACTED_VALUE);

                    if (!tempTransValue.Resize(brTransacted.m_cb + 1)) {
                        ThrowError(brSegment.m_pb, IDE_OOM);
                    }

                    LPSTR szTransacted = static_cast<LPSTR> (tempTransValue.QueryPtr());
                    strncpy(szTransacted, (LPCSTR)brTransacted.m_pb, brTransacted.m_cb);
                    szTransacted[brTransacted.m_cb]='\0';
                    if (!strcmpi(szTransacted, "REQUIRED"))
                        m_ttTransacted = ttRequired;
                    else if (!strcmpi(szTransacted, "REQUIRES_NEW"))
                        m_ttTransacted = ttRequiresNew;
                    else if (!strcmpi(szTransacted, "SUPPORTED"))
                        m_ttTransacted = ttSupported;
                    else if (!strcmpi(szTransacted, "NOT_SUPPORTED"))
                        m_ttTransacted = ttNotSupported;
                    else
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_TRANSACTED_VALUE);

                    brSegment.Advance(DIFF(brTransacted.m_pb - brSegment.m_pb));
                    }
                /* Set session flag
                   see NOTE above for why we call GetTagName
                */
                else if ( fTagSession && CompTagName( brSegment, CTokenList::tknTagSession ) )
                    {

                    STACK_BUFFER( tempSession, 16 );

                    fTagSession = FALSE;
                    CByteRange brSession = BrValueOfTag( brSegment, CTokenList::tknTagSession );
                    if ( brSession.IsNull() )
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_SESSION_VALUE);

                    if (!tempSession.Resize(brSession.m_cb + 1))
                        ThrowError(brSegment.m_pb, IDE_OOM);

                    LPSTR szSession = static_cast<LPSTR> (tempSession.QueryPtr());
                    strncpy(szSession, (LPCSTR)brSession.m_pb, brSession.m_cb);
                    szSession[brSession.m_cb]='\0';
                    if (strcmpi(szSession, "TRUE") == 0)
						{
                        m_fSession = TRUE;
						if (!pHitObj->PAppln()->QueryAppConfig()->fAllowSessionState())
							ThrowError(brSegment.m_pb, IDE_TEMPLATE_CANT_ENABLE_SESSIONS);
						}
                    else if (strcmpi(szSession, "FALSE") == 0)
                        m_fSession = FALSE;
                    else
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_SESSION_VALUE);

                    brSegment.Advance(DIFF(brSession.m_pb - brSegment.m_pb));
                    }
                else
                    ThrowErrorSingleInsert( brSegment.m_pb,
                                            IDE_TEMPLATE_BAD_AT_COMMAND,
                                            brSegment.m_pb,
                                            brSegment.m_cb
                                            );
                }

                if (nFirstPass == 1)
                    ThrowErrorSingleInsert( brSegment.m_pb,
                                            IDE_TEMPLATE_BAD_AT_COMMAND,
                                            brSegment.m_pb,
                                            brSegment.m_cb
                                            );



            // set flag true and ignore remainder of segment, since we only use this segment for page-level @ commands
            WorkStore.m_fPageCommandsExecuted = TRUE;
            goto LExit;
            }

        }

    if(sseg == ssegTaggedScript)
        {
        if(!fScriptTagProcessed)
            {
            /*  semantics of script-tag-processed flag:
                - if false, we have a 'fresh' tagged script block, so we need to get its engine name
                  (which also advances past the script tag header) and then process the tagged segment
                  via indirect recursive call
                - if true, we have aleady been called recursively, so we bypass further recursion
                  and simply append to store
            */
            CByteRange brIncludeFile;
            GetScriptEngineOfSegment(brSegment, WorkStore.m_brCurEngine, brIncludeFile);
            if (! brIncludeFile.IsNull())
                {

                STACK_BUFFER( tempInclude, 256 );

                if (!tempInclude.Resize(brIncludeFile.m_cb + 1)) {
                    ThrowError(brSegment.m_pb, IDE_OOM);
                }

                                // Create Null-terminated string from brIncludeFile
                                char *szFileSpec = reinterpret_cast<char *>(tempInclude.QueryPtr());
                                memcpy(szFileSpec, brIncludeFile.m_pb, brIncludeFile.m_cb);
                                szFileSpec[brIncludeFile.m_cb] = 0;
                                if (szFileSpec[0] == '\\')      // metabase stuff chokes on initial '\' char
                                    szFileSpec[0] = '/';

                                // read the include file (szFileSpec & brIncludeFile in this case point to same string contents.
                                // however, "brIncludeFile" is used as an error location.
                                //
                TRY
                                    ProcessIncludeFile2(szFileSpec, brIncludeFile, pfilemapCurrent, WorkStore, idSequence, pHitObj, FALSE);
                CATCH(hrException)

                    // The TRY/CATCH below may re-throw a IDE_TEMPLATE_BAD_PROGLANG when the
                    // segment being processed is tagged script with a SRC file.  The reason being
                    // that to properly report the error, the ThrowErrorSingleInsert must be called
                    // from the template which contained the script tag with the bad prog lang.  If
                    // called from the template created containing the included script, then the
                    // brEngine assigned below is not pointing into the included script's filemap
                    // which results in AVs because we can't do the pointer math to determine the
                    // line number.

                    if(hrException == IDE_TEMPLATE_BAD_PROGLANG)
                        // exception code is really an error message id: set err id to it
                        ThrowErrorSingleInsert(
                                                WorkStore.m_brCurEngine.m_pb,
                                                IDE_TEMPLATE_BAD_PROGLANG,
                                                WorkStore.m_brCurEngine.m_pb,
                                                WorkStore.m_brCurEngine.m_cb
                                                );
                    else

                        // other exception: re-throw
                        THROW(hrException);

                END_TRY


                                // done - don't process script text
                                return;
                }
            else
                                ProcessTaggedScriptSegment(brSegment, pfilemapCurrent, WorkStore, pHitObj);
            }

        brEngine = WorkStore.m_brCurEngine;
        }

    TRY
        // append script segment to store
        WorkStore.m_ScriptStore.AppendScript(brSegment, brEngine, (sseg == ssegPrimaryScript), idSequence, pfilemapCurrent);

    CATCH(hrException)
        // NOTE exception code from AppendScript() is overloaded: it can be an error message id or a true exception

        // if the brEngine does not point to memory within the current filemap, then
        // we must have come into here because of a tagged script statement with a SRC=
        // attrib.  In which case, we won't call ThrowError from here but will re-throw
        // the error to be caught above.

        if((hrException == IDE_TEMPLATE_BAD_PROGLANG)
           && (brEngine.m_pb >= pfilemapCurrent->m_pbStartOfFile)
           && (brEngine.m_pb <  (pfilemapCurrent->m_pbStartOfFile + pfilemapCurrent->GetSize()))) {
            // exception code is really an error message id: set err id to it
            ThrowErrorSingleInsert(
                                    brEngine.m_pb,
                                    IDE_TEMPLATE_BAD_PROGLANG,
                                    brEngine.m_pb,
                                    brEngine.m_cb
                                    );
        }
        else
            // other exception: re-throw
            THROW(hrException);

    END_TRY

LExit:
    // set flag to say we can no longer set primary language (must be in first script segment, if at all)
    WorkStore.m_fPageCommandsAllowed = FALSE;
    }


/*  ========================================================
    CTemplate::ProcessMetadataSegment
    Parses the metadata comment for typelib information.

    Returns
        HRESULT
*/
HRESULT
CTemplate::ProcessMetadataSegment
(
const CByteRange& brSegment,
UINT *pidError,
CHitObj *pHitObj
)
    {
    // TYPELIB
    if (FTagHasValue(brSegment,
                     CTokenList::tknTagType,
                     CTokenList::tknValueTypeLib))
        {
        return ProcessMetadataTypelibSegment(brSegment, pidError, pHitObj);
        }
        // METADATA INVALID in Global.asa
        else if (m_fGlobalAsa)
                {
                ThrowError(brSegment.m_pb, IDE_TEMPLATE_METADATA_IN_GLOBAL_ASA);
                return E_TEMPLATE_COMPILE_FAILED_DONT_CACHE;   // to keep compiler happy; in reality doesn't return.
                }
    // COOKIE
    else if (FTagHasValue(brSegment,
                     CTokenList::tknTagType,
                     CTokenList::tknValueCookie))
        {
        return ProcessMetadataCookieSegment(brSegment, pidError, pHitObj);
        }
    // Ignore everything else
    else
        {
        return S_OK;
        }
    }


/*  ========================================================
    CTemplate::ProcessMetadataTypelibSegment
    Parses the metadata comment for typelib information.

    Returns
        HRESULT
*/
HRESULT
CTemplate::ProcessMetadataTypelibSegment
(
const CByteRange& brSegment,
UINT *pidError,
CHitObj *pHitObj
)
    {
    // Ignore ENDSPAN segments
    if (GetTagName(brSegment, CTokenList::tknTagEndspan))
        {
        // ENDSPAN found - ignore
        return S_OK;
        }

    HRESULT hr;
    char  szFile[MAX_PATH+1];
    DWORD cbFile;

    // Try to get the filename
    CByteRange br = BrValueOfTag(brSegment, CTokenList::tknTagFile);
    if (!br.IsNull())
        {
        // filename present
        if (br.m_cb > MAX_PATH)
            {
            // file too long
            *pidError = IDE_TEMPLATE_BAD_TYPELIB_SPEC;
            return E_FAIL;
            }
        memcpy(szFile, br.m_pb, br.m_cb);
        cbFile = br.m_cb;
        szFile[cbFile] = '\0';
        }
    else
        {
        // No filename - use GUID, version, LCID to get file

        char szUUID[44]; // {} + hex chars + dashes
        char szVers[16]; // "1.0", etc
        char szLCID[16]; // locale id - a number

        br = BrValueOfTag(brSegment, CTokenList::tknTagUUID);
        if (br.IsNull() || br.m_cb > sizeof(szUUID)-3)
            {
            // no filename and no uuid -> invalid typelib spec
            *pidError = IDE_TEMPLATE_BAD_TYPELIB_SPEC;
            return E_FAIL;
            }

        if (br.m_pb[0] == '{')
            {
            // already in braces
            memcpy(szUUID, br.m_pb, br.m_cb);
            szUUID[br.m_cb] = '\0';
            }
        else
            {
            // enclose in {}
            szUUID[0] = '{';
            memcpy(szUUID+1, br.m_pb, br.m_cb);
            szUUID[br.m_cb+1] = '}';
            szUUID[br.m_cb+2] = '\0';
            }

        // Optional Version
        szVers[0] = '\0';
        br = BrValueOfTag(brSegment, CTokenList::tknTagVersion);
        if (!br.IsNull() && br.m_cb < sizeof(szVers)-1)
            {
            memcpy(szVers, br.m_pb, br.m_cb);
            szVers[br.m_cb] = '\0';
            }

        // Optional LCID
        LCID lcid;
        br = BrValueOfTag(brSegment, CTokenList::tknTagLCID);
        if (!br.IsNull() && br.m_cb < sizeof(szLCID)-1)
            {
            memcpy(szLCID, br.m_pb, br.m_cb);
            szLCID[br.m_cb] = '\0';
            lcid = strtoul(szLCID, NULL, 16);
            }
        else
            {
            // if the LCID is not defined -> use system's
            lcid = GetSystemDefaultLCID();
            }

        // Get TYPELIB filename from registry
        hr = GetTypelibFilenameFromRegistry
            (
            szUUID,
            szVers,
            lcid,
            szFile,
            MAX_PATH
            );

        if (FAILED(hr))
            {
            *pidError = IDE_TEMPLATE_BAD_TYPELIB_REG_SPEC;
            return hr;
            }

        cbFile = strlen(szFile);
        }
    
    // Convert filename to double-byte to call LoadTypeLib()

    STACK_BUFFER( tempFile, MAX_PATH * sizeof(WCHAR) );

    if (!tempFile.Resize((cbFile+1) * sizeof(WCHAR))) {
        *pidError = IDE_OOM;
        return E_FAIL;
    }

    LPWSTR wszFile = (LPWSTR)tempFile.QueryPtr();

    if (MultiByteToWideChar(pHitObj->GetCodePage(), MB_ERR_INVALID_CHARS,
                            szFile, cbFile, wszFile, cbFile) == 0)
        {
        *pidError = IDE_OOM;
        return E_FAIL;
        }
    wszFile[cbFile] = L'\0';

    // LoadTypeLib() to get ITypeLib*
    ITypeLib *ptlb = NULL;
    hr = LoadTypeLib(wszFile, &ptlb);

    if (FAILED(hr))
        {
        *pidError = IDE_TEMPLATE_LOAD_TYPELIB_FAILED;
        return hr;
        }

    // Remember ITypeLib* in the array
    Assert(ptlb);
    hr = m_rgpTypeLibs.append(ptlb);
    if (FAILED(hr))
        {
        *pidError = IDE_TEMPLATE_LOAD_TYPELIB_FAILED;
        return hr;
        }


    return S_OK;
    }


/*  ========================================================
    CTemplate::ProcessMetadataCookieSegment
    Parses the metadata comment for cookie information.

    Returns
        HRESULT
*/
HRESULT
CTemplate::ProcessMetadataCookieSegment
(
const CByteRange& brSegment,
UINT *pidError,
CHitObj *pHitObj
)
    {
    HRESULT hr;
    CByteRange br;
    char  *pszName;
    char  szFile[MAX_PATH+1];
    TCHAR sztFile[MAX_PATH+1];
    CMBCSToWChar    convStr;

    STACK_BUFFER( tempCookie, 64 );
    STACK_BUFFER( tempFile, 64 );    

    // Try to get the cookie name
    br = BrValueOfTag(brSegment, CTokenList::tknTagName);
    if (br.IsNull() || (br.m_cb == 0)) {
        *pidError = IDE_TEMPLATE_BAD_COOKIE_SPEC_NAME;
        return E_FAIL;
    }

    if (!tempCookie.Resize(br.m_cb + 1)) {
        *pidError = IDE_OOM;
        return E_FAIL;
    }

    pszName = (char *)tempCookie.QueryPtr();
    if (!pszName)
        {
        *pidError = IDE_OOM;
        return E_FAIL;
        }
    memcpy(pszName, br.m_pb, br.m_cb);
    pszName[br.m_cb] = '\0';


    // Try to get the path to the script
    br = BrValueOfTag(brSegment, CTokenList::tknTagSrc);
    if (br.IsNull() || (br.m_cb >= MAX_PATH) || (br.m_cb == 0))
        {
        *pidError = IDE_TEMPLATE_BAD_COOKIE_SPEC_SRC;
        return E_FAIL;
        }
    memcpy(szFile, br.m_pb, br.m_cb);
    szFile[br.m_cb] = '\0';

    // Convert file to physical path
    Assert(pHitObj->PServer());

    WCHAR   *pCookieFile;
#if _IIS_5_1
    // just use CP_ACP for 5.1 since the Core can't handle anything else anyway
    if (FAILED (convStr.Init (szFile))) {
#else 
    // 6.0 can handle UNICODE. Convert using script code page
    if (FAILED (convStr.Init (szFile,pHitObj->GetCodePage()))) {
#endif
        *pidError = IDE_OOM;
        return E_FAIL;
    }

    pCookieFile = convStr.GetString();
    if (FAILED(pHitObj->PServer()->MapPathInternal(0, pCookieFile, sztFile)))
        {
        *pidError = IDE_TEMPLATE_BAD_COOKIE_SPEC_SRC;
        return E_FAIL;
        }
    Normalize(sztFile);

    // Construct 449-echo-cookie object
    C449Cookie *p449 = NULL;
    hr = Create449Cookie(pszName, sztFile, &p449);
    if (FAILED(hr))
        {
        *pidError = IDE_TEMPLATE_LOAD_COOKIESCRIPT_FAILED;
        return hr;
    }

    // Remember 449 cookie in the array
    Assert(p449);
    hr = m_rgp449.append(p449);
    if (FAILED(hr)) {
        *pidError = IDE_TEMPLATE_LOAD_COOKIESCRIPT_FAILED;
        return hr;
    }

    return S_OK;
}


/*  ========================================================
    CTemplate::GetScriptEngineOfSegment
    Returns script engine name for a script segment.

    Returns
        Byte range containing script engine name
    Side effects
        Advances segment byte range past close tag token
*/
void
CTemplate::GetScriptEngineOfSegment
(
CByteRange&                     brSegment,                      // segment byte range
CByteRange&                     brEngine,                       // script engine name
CByteRange&                     brInclude                       // value of SRC tag
)
    {
    BYTE*       pbCloseTag;     // ptr to close of start tag
                                // tags contained in start tag
    CByteRange  brTags = BrTagsFromSegment(brSegment, CTokenList::tknCloseTaggedScript, &pbCloseTag);

    // if no close found, throw error
    if(pbCloseTag == NULL)
        ThrowError(brSegment.m_pb, IDE_TEMPLATE_NO_CLOSE_TSCRIPT);

    Assert(FTagHasValue(brTags, CTokenList::tknTagRunat, CTokenList::tknValueServer));

    // get engine name from tags
    brEngine = BrValueOfTag(brTags, CTokenList::tknTagLanguage);
    if(brEngine.IsNull())
        ThrowError(brSegment.m_pb, IDE_TEMPLATE_NO_ENGINE_NAME);

    // Get SRC attribute from tags
    brInclude = BrValueOfTag(brTags, CTokenList::tknTagSrc);

    // advance segment past close tag token
    gm_pTokenList->MovePastToken(CTokenList::tknCloseTag, pbCloseTag, brSegment);
    }

/*  ========================================================
    CTemplate::ProcessTaggedScriptSegment
    Processes a tagged script segment: within tagged script we
    honor plain text (passed through as script text) and HTML comments.
    See bug 423 for istudio scenarios that require this behavior.

    Returns
        Nothing
    Side effects
        None
*/
void
CTemplate::ProcessTaggedScriptSegment
(
CByteRange&     brSegment,      // segment byte range
CFileMap*       pfilemapCurrent,// ptr to filemap of parent file
CWorkStore&     WorkStore,      // working storage for source segments
CHitObj*        pHitObj         // Browser request object
)
    {
    _TOKEN*     rgtknOpeners;   // array of permitted open tokens
    _TOKEN      tknOpeners[1];
    UINT        ctknOpeners;    // count of permitted open tokens

    // populate array of permitted open tokens
    ctknOpeners = 1;
    rgtknOpeners = tknOpeners;
    rgtknOpeners[0] = CTokenList::tknOpenHTMLComment;

    // Process source segments embedded within tagged script segment
    while(!brSegment.IsNull())
        ExtractAndProcessSegment(
                                    brSegment,          // byte range to search for next segment-opening token
                                    ssegTaggedScript,   // type of 'leading', i.e. pre-token, source segment
                                    rgtknOpeners,       // array of permitted open tokens
                                    ctknOpeners,        // count of permitted open tokens
                                    pfilemapCurrent,    // ptr to filemap of parent file
                                    WorkStore,          // working storage for source segments
                                    pHitObj,            // Browser request object
                                    TRUE,               // script tag has been processed
                                    FALSE               // NOT in HTML segment
                                );
    }

/*  ============================================================================
    CTemplate::ProcessObjectSegment
    Processes an object segment.

    Returns
        Nothing
    Side effects
        throws on error
*/
void
CTemplate::ProcessObjectSegment
(
CByteRange&     brSegment,      // segment byte range
CFileMap*       pfilemapCurrent,// ptr to filemap of parent file
CWorkStore&     WorkStore,      // working storage for source segments
UINT            idSequence      // segment sequence id
)
    {
    BYTE*       pbCloseTag;     // ptr to close of start tag
                                // tags contained in start tag
    CByteRange  brTags = BrTagsFromSegment(brSegment, CTokenList::tknCloseObject, &pbCloseTag);

    // if no close found, bail on error
    if(pbCloseTag == NULL)
        ThrowError(brSegment.m_pb, IDE_TEMPLATE_NO_CLOSE_OBJECT);

    // if this is a server object (RUNAT=Server), process its tags
    if(FTagHasValue(brTags, CTokenList::tknTagRunat, CTokenList::tknValueServer))
        {
        CLSID   ClsId;  // clsid

        // get name value
        CByteRange brName = BrValueOfTag(brTags, CTokenList::tknTagID);

        // if name is null, error out
        if(brName.IsNull())
            ThrowError(brSegment.m_pb, IDE_TEMPLATE_NO_OBJECT_NAME);

        if(!FValidObjectName(brName))
            ThrowErrorSingleInsert(brName.m_pb, IDE_TEMPLATE_INVALID_OBJECT_NAME, brName.m_pb, brName.m_cb);

        // get values for ClassID and ProgID tags
        CByteRange brClassIDText = BrValueOfTag(brTags, CTokenList::tknTagClassID);
        CByteRange brProgIDText = BrValueOfTag(brTags, CTokenList::tknTagProgID);

        if(!brClassIDText.IsNull())
            // if we find a text class id, set clsid with it
            // NOTE progid tag is ignored if classid tag exists
            GetCLSIDFromBrClassIDText(brClassIDText, &ClsId);
        else if(!brProgIDText.IsNull())
            // else if we find a prog id, resolve it into a class id
            GetCLSIDFromBrProgIDText(brProgIDText, &ClsId);
        else
            // else, throw error; can't create an object without at least one of classid or progid
            ThrowErrorSingleInsert(brTags.m_pb, IDE_TEMPLATE_NO_CLASSID_PROGID, brName.m_pb, brName.m_cb);

        // set scope; bail if bogus
        CompScope csScope = csUnknown;
        CByteRange brScope = BrValueOfTag(brTags, CTokenList::tknTagScope);
        if(brScope.FMatchesSz(SZ_TOKEN(CTokenList::tknValuePage)) || brScope.IsNull())
            // non-existent scope tag defaults to page scope
            csScope = csPage;
        else if(brScope.FMatchesSz(SZ_TOKEN(CTokenList::tknValueApplication)))
            csScope = csAppln;
        else if(brScope.FMatchesSz(SZ_TOKEN(CTokenList::tknValueSession)))
            csScope = csSession;
        else
            ThrowError(brTags.m_pb, IDE_TEMPLATE_BAD_OBJECT_SCOPE);

        if(!m_fGlobalAsa && csScope != csPage)
            // error out on non-page-level object if we are processing anything but global.asa
            ThrowErrorSingleInsert(brTags.m_pb, IDE_TEMPLATE_BAD_PAGE_OBJECT_SCOPE, brName.m_pb, brName.m_cb);
        else if(m_fGlobalAsa && csScope == csPage)
            // error out on page-level object if we are processing global.asa
            ThrowErrorSingleInsert(brTags.m_pb, IDE_TEMPLATE_BAD_GLOBAL_OBJECT_SCOPE, brName.m_pb, brName.m_cb);

        // set threading model
        CompModel cmModel = cmSingle;
        CompModelFromCLSID(ClsId, &cmModel);

        // append object-info to store
        WorkStore.m_ObjectInfoStore.AppendObject(brName, ClsId, csScope, cmModel, idSequence);

        }

    }

/*  ============================================================================
    CTemplate::GetCLSIDFromBrClassIDText
    Sets a clsid from a byte range containing an ANSI text version of a class id

    Returns
        ptr to clsid (out-parameter)
    Side effects
        throws on error
*/
void
CTemplate::GetCLSIDFromBrClassIDText
(
CByteRange& brClassIDText,
LPCLSID pclsid
)
    {
    // if class id text starts with its standard object tag prefix, advance past it
    if(!_strnicmp((char*)brClassIDText.m_pb, "clsid:", 6))
        brClassIDText.Advance(6);

    // if class id text is bracketed with {}, adjust byte range to strip them
    // NOTE we always add {} below, because normal case is that they are missing from input text
    if(*brClassIDText.m_pb == '{')
        brClassIDText.Advance(1);
    if(*(brClassIDText.m_pb + brClassIDText.m_cb - 1) == '}')
        brClassIDText.m_cb--;

    // Allocate a wide char string for the string version of class id
    // NOTE we add 3 characters to hold {} and null terminator
    OLECHAR* pszWideClassID = new WCHAR[brClassIDText.m_cb + 3];
    if (NULL == pszWideClassID)
        THROW(E_OUTOFMEMORY);

    // start wide string class id with left brace
    pszWideClassID[0] = '{';

    // Convert the string class id to wide chars
    if (0 == MultiByteToWideChar(   CP_ACP,                     // ANSI code page
                                    MB_ERR_INVALID_CHARS,       // err on invalid chars
                                    (LPCSTR)brClassIDText.m_pb, // input ANSI string version of class id
                                    brClassIDText.m_cb,         // length of input string
                                    pszWideClassID + 1,         // location for output wide string class id
                                    brClassIDText.m_cb          // size of output buffer
                                ))
        {
        delete [] pszWideClassID;
        THROW(E_FAIL);
        }

    // append right brace to wide string
    pszWideClassID[brClassIDText.m_cb + 1] = '}';

    // Null terminate the wide string
    pszWideClassID[brClassIDText.m_cb + 2] = NULL;

    // Now get the clsid from wide string class id
    if(FAILED(CLSIDFromString(pszWideClassID, pclsid)))
        {
        delete [] pszWideClassID;
        ThrowErrorSingleInsert(brClassIDText.m_pb, IDE_TEMPLATE_BAD_CLASSID, brClassIDText.m_pb, brClassIDText.m_cb);
        }

    if(NULL != pszWideClassID)
        delete [] pszWideClassID;
    }

/*  ===================================================================
    CTemplate::GetCLSIDFromBrProgIDText
    Gets a clsid from the registry given a ProgID

    Returns
        ptr to clsid (out-parameter)
    Side effects
        throws on error
*/
void
CTemplate::GetCLSIDFromBrProgIDText
(
CByteRange& brProgIDText,
LPCLSID pclsid
)
    {
    // allocate a wide char string for ProgID plus null terminator
    OLECHAR* pszWideProgID = new WCHAR[brProgIDText.m_cb + 1];
    if (NULL == pszWideProgID)
        THROW(E_OUTOFMEMORY);

    // Convert the string class id to wide chars
    if (0 == MultiByteToWideChar(   CP_ACP,                     // ANSI code page
                                    MB_ERR_INVALID_CHARS,       // err on invalid chars
                                    (LPCSTR)brProgIDText.m_pb,  // input ANSI string version of prog id
                                    brProgIDText.m_cb,          // length of input string
                                    pszWideProgID,              // location for output wide string prog id
                                    brProgIDText.m_cb           // size of output buffer
                                ))
        {
        delete [] pszWideProgID; pszWideProgID = NULL;
        THROW(E_FAIL);
        }

    // Null terminate the wide string
    pszWideProgID[brProgIDText.m_cb] = NULL;

    // Now get clsid from ProgID
    if(FAILED(CLSIDFromProgID(pszWideProgID, pclsid)))
        {
        delete [] pszWideProgID; pszWideProgID = NULL;
        ThrowErrorSingleInsert(brProgIDText.m_pb, IDE_TEMPLATE_BAD_PROGID, brProgIDText.m_pb, brProgIDText.m_cb);
        }

    // Cache ProgId to CLSID mapping
    g_TypelibCache.RememberProgidToCLSIDMapping(pszWideProgID, *pclsid);

    if (NULL != pszWideProgID)
        delete [] pszWideProgID;
}

/*  ============================================================================
    CTemplate::FValidObjectName
    Determines whether an object name clashes with a Denali intrinsic object name.

    Returns
        TRUE or FALSE
    Side effects
        None
*/
BOOLB
CTemplate::FValidObjectName
(
CByteRange& brName  // object name
)
    {
    if(brName.FMatchesSz(SZ_OBJ_APPLICATION))
        return FALSE;
    if(brName.FMatchesSz(SZ_OBJ_REQUEST))
        return FALSE;
    if(brName.FMatchesSz(SZ_OBJ_RESPONSE))
        return FALSE;
    if(brName.FMatchesSz(SZ_OBJ_SERVER))
        return FALSE;
    if(brName.FMatchesSz(SZ_OBJ_CERTIFICATE))
        return FALSE;
    if(brName.FMatchesSz(SZ_OBJ_SESSION))
        return FALSE;
    if(brName.FMatchesSz(SZ_OBJ_SCRIPTINGNAMESPACE))
        return FALSE;

    return TRUE;
    }

/*  ============================================================================
    CTemplate::ProcessIncludeFile

    Processes an include file.

    Returns
        Nothing
*/
void
CTemplate::ProcessIncludeFile
(
CByteRange& brSegment,          // segment byte range
CFileMap*   pfilemapCurrent,    // ptr to filemap of parent file
CWorkStore& WorkStore,          // current working storage
UINT        idSequence,         // sequence #
CHitObj*    pHitObj,            // Browser request object pointer
BOOL        fIsHTML
)
    {
    CByteRange  brFileSpec;             // filespec of include file
    BOOLB       fVirtual = FALSE;       // is include filespec virtual?
                                        // filespec of include file (sz)
    CHAR        szFileSpec[MAX_PATH + 1];
    LPSTR       szTemp = szFileSpec;    // temp ptr to filespec

    // get value of FILE tag
    brFileSpec = BrValueOfTag(brSegment, CTokenList::tknTagFile);

    if(brFileSpec.IsNull())
        {
        // if we found no FILE tag, get value of VIRTUAL tag
        brFileSpec = BrValueOfTag(brSegment, CTokenList::tknTagVirtual);
        fVirtual = TRUE;
        }

    if(brFileSpec.IsNull())
        // if we found neither, error out
        ThrowError(brSegment.m_pb, IDE_TEMPLATE_NO_INCLUDE_NAME);

    if (brFileSpec.m_cb>MAX_PATH)
    {
    	// return the last MAX_PATH chars of the file name.  This is done
        // this way to avoid a Error Too Long message when the include
        // file spec is exceedingly long.

    	char fileNameLast[MAX_PATH+4];
    	strcpy(fileNameLast, "...");
    	strcpy(fileNameLast+3, (LPSTR)(brFileSpec.m_pb+brFileSpec.m_cb-MAX_PATH));
    	
        ThrowErrorSingleInsert(brFileSpec.m_pb,
                               IDE_TEMPLATE_BAD_INCLUDE,
                               brFileSpec.m_pb,
                               brFileSpec.m_cb);

    }

    // NOTE we manipulate temp sz to preserve szFileSpec
    if(fVirtual)
        {
        if(*brFileSpec.m_pb == '\\')
            {
            // if VIRTUAL path starts with backslash, replace it with fwd slash
            *szTemp++ = '/';
            brFileSpec.Advance(1);
            }
        else if(*brFileSpec.m_pb != '/')
            // if VIRTUAL path starts with anything other than fwd slash or backslash, prepend fwd slash
            *szTemp++ = '/';
        }

    // append supplied path to temp sz
    strncpy(szTemp, (LPCSTR) brFileSpec.m_pb, brFileSpec.m_cb);
    szTemp[brFileSpec.m_cb] = NULL;

    if(!fVirtual)
        {
        // if FILE filespec starts with \ or /, hurl
        if(*szFileSpec == '\\' || *szFileSpec == '/')
            ThrowErrorSingleInsert(
                                    brFileSpec.m_pb,
                                    IDE_TEMPLATE_BAD_FILE_TAG,
                                    brFileSpec.m_pb,
                                    brFileSpec.m_cb
                                  );
        }

    // NOTE: szFileSpec is the doctored path (it possibly has "/" prepended.
    //       brFileSpec is used as the error location.
    //
    ProcessIncludeFile2(szFileSpec, brFileSpec, pfilemapCurrent, WorkStore, idSequence, pHitObj, fIsHTML);
    }

/*  ============================================================================
    CTemplate::ProcessIncludeFile2

    adds a #include file to the CTemplate and starts the template to processing
    the file.

    Returns
        Nothing
    Side effects
        Calls GetSegmentsFromFile recursively

    NOTE - kind of an oddball thing here.  The szFileSpec in this case is
    intentionally ANSI as it came from the ASP script content.  It may need
    to be converted to UNICODE.
*/
void
CTemplate::ProcessIncludeFile2
(
CHAR *      szAnsiFileSpec,			// file to include
CByteRange&	brErrorLocation,	// ByteRange in source where errors should be reported
CFileMap*   pfilemapCurrent,    // ptr to filemap of parent file
CWorkStore& WorkStore,          // current working storage
UINT        idSequence,         // sequence #
CHitObj*    pHitObj,            // Browser request object pointer
BOOL        fIsHTML
)
{
    HRESULT     hr;
    TCHAR      *szFileSpec;

#if UNICODE
    CMBCSToWChar    convFileSpec;

    if (FAILED(hr = convFileSpec.Init(szAnsiFileSpec, pHitObj->GetCodePage()))) {
        THROW(hr);
    }
    szFileSpec = convFileSpec.GetString();
#else
    szFileSpec = szAnsiFileSpec;
#endif
    // if parent paths are disallowed and filespec contains parent dir reference, hurl
    if (!pHitObj->QueryAppConfig()->fEnableParentPaths() && _tcsstr(szFileSpec, _T("..")))
            ThrowErrorSingleInsert(
                                    brErrorLocation.m_pb,
                                    IDE_TEMPLATE_DISALLOWED_PARENT_PATH,
                                    brErrorLocation.m_pb,
                                    brErrorLocation.m_cb
                                  );

    TRY
        AppendMapFile(
                        szFileSpec,
                        pfilemapCurrent,
                        (szFileSpec[0] == _T('/')) || (szFileSpec[0] == _T('\\')),  // fVirtual
                        pHitObj,        // main file's hit object
                        FALSE           // not the global.asa file
                    );
    CATCH(hrException)

        // MapFile() threw an exception: delete last filemap's memory and decrement filemap counter
        // NOTE this is a bit hokey, but we need to do it here rather than AppendMapFile (where we allocated)
        // because its other caller(s) may not want this behavior
        delete m_rgpFilemaps[m_cFilemaps-- - 1];

        /*  NOTE exception code from MapFile() is overloaded: it can sometimes
            be an error message id, sometimes a true exception
            NOTE security error causes exception E_USER_LACKS_PERMISSIONS, rather than error id,
            but we pass it thru as if it were an error id because the various error-catch routines
            know how to handle E_USER_LACKS_PERMISSIONS specially.
        */
        UINT    idErrMsg;
        if(hrException == IDE_TEMPLATE_CYCLIC_INCLUDE || hrException == E_USER_LACKS_PERMISSIONS)
            // exception code is really an error message id: set err id to it
            idErrMsg = hrException;
        else if(hrException == E_COULDNT_OPEN_SOURCE_FILE)
            // exception is generic couldn't-open-file : set err id to generic bad-file error
            idErrMsg = IDE_TEMPLATE_BAD_INCLUDE;
        else
            // other exception: re-throw
            THROW(hrException);

        ThrowErrorSingleInsert(
                                brErrorLocation.m_pb,
                                idErrMsg,
                                brErrorLocation.m_pb,
                                brErrorLocation.m_cb
                              );
    END_TRY

    // store ptr to current file map in local before recursive call (which may increment m_cFilemaps)
    CFileMap*   pfilemap = m_rgpFilemaps[m_cFilemaps - 1];

    // get inc-file object from cache
    CIncFile*   pIncFile;

    if(FAILED(hr = g_IncFileMap.GetIncFile(pfilemap->m_szPathTranslated, &pIncFile)))
        THROW(hr);

    // add this template to inc-file's template list
    if (FAILED(hr = pIncFile->AddTemplate(this)))
        THROW(hr);

    // set filemap's inc-file ptr
    pfilemap->m_pIncFile = pIncFile;

    // get source segments from include file
    // bugs 1363, 1364: process include file only after we establish dependencies;
    // required for cache flushing to work correctly after compile errors
    GetSegmentsFromFile(*pfilemap, WorkStore, pHitObj, fIsHTML);
}

/*  ===================================================================
    CTemplate::GetOpenToken
    Returns the token index of and a ptr to the first valid open token
    in search range.  For the open token to be valid, we must bypass
    segments we should not process, e.g. scripts or objects not tagged as 'server'

    Returns
        ptr to open token; ptr to open token enum value (out-parameter)
    Side effects
        None
*/
BYTE*
CTemplate::GetOpenToken
(
CByteRange  brSearch,       // (ByVal) byte range to search for next segment-opening token
SOURCE_SEGMENT ssegLeading, // type of 'leading', i.e. pre-token, source segment
                            //  (only used when deciding to ignore non-SSI comments)
_TOKEN*     rgtknOpeners,   // array of permitted open tokens
UINT        ctknOpeners,    // count of permitted open tokens
_TOKEN*     ptknOpen        // ptr to open token enum value (out-parameter)
)
    {
    BYTE*   pbTokenOpen = NULL;     // ptr to opening token

    // keep getting segment-opening tokens until we find one that we need to process
    while(TRUE)
        {
        // Get next open token in search range
        *ptknOpen = gm_pTokenList->NextOpenToken(
                                                    brSearch,
                                                    rgtknOpeners,
                                                    ctknOpeners,
                                                    &pbTokenOpen,
                                                    m_wCodePage
                                                );

        /*  Certain tokens must be followed immediately by white space; others need not.
            NOTE it is pure coincidence that the 'white-space tokens' are also those that
            get special processing below; hence we handle white space issue there.
            If we ever add another 'white-space token' that doesn't require the special processing,
            we will need to handle the white space issue here.
        */

        /*  Similar thing applies to non-include and non-metadata HTML
            comments. We really don't care for them to generate their
            own segments -- we can reduce number of Response.WriteBlock()
            calls by considering them part of the preceding HTML segment.
        */

        if (*ptknOpen == CTokenList::tknOpenHTMLComment)
            {
            if (ssegLeading != ssegHTML)  // if not inside HTML
                break;                    // generate a new segment

            // for HTML comments check if it is an include or metadata
            // and if not, this is not a separate segment - keep on looking
            // for the next opener

            // advance search range to just past open token
            gm_pTokenList->MovePastToken(*ptknOpen, pbTokenOpen, brSearch);

            // find end of comment
            BYTE *pbClose = gm_pTokenList->GetToken(CTokenList::tknCloseHTMLComment,
                                                    brSearch, m_wCodePage);
            if (pbClose == NULL)
                {
                // Error -- let other code handle this
                break;
                }

            // construct comment byte range to limit search to it
            CByteRange brComment = brSearch;
            brComment.m_cb = DIFF(pbClose - brSearch.m_pb);

            // look for metadata and include (only inside the comment)

            if (gm_pTokenList->GetToken(CTokenList::tknCommandINCLUDE,
                                        brComment, m_wCodePage))
                {
                // SSI inclide -- keep it
                break;
                }
            else if (gm_pTokenList->GetToken(CTokenList::tknTagMETADATA,
                                             brComment, m_wCodePage))
                {
                // METADATA -- keep it
                break;
                }
            else if (gm_pTokenList->GetToken(CTokenList::tknTagFPBot,
                                             brComment, m_wCodePage))
                {
                // METADATA -- keep it
                break;
                }
            else
                {
                // Regular comment - ignore it
                goto LKeepLooking;
                }
            }
        else if (*ptknOpen == CTokenList::tknOpenTaggedScript || *ptknOpen == CTokenList::tknOpenObject)
            {
            /*  if token was script or object tag, check to see if:
                a) it is followed immediately by white space; if not keep looking
                b) it opens a well-formed segment, i.e. one with a proper close tag; if not, throw error
                c) it is designated runat-server; if not keep looking
            */

            // advance search range to just past open token
            gm_pTokenList->MovePastToken(*ptknOpen, pbTokenOpen, brSearch);

            // bug 760: if token is not followed immediately by white space, keep looking
            if(!brSearch.IsNull())
                if(!FWhiteSpace(*brSearch.m_pb))
                    goto LKeepLooking;

            // ptr to close of start tag
            BYTE*       pbCloseTag;
            // tags contained in start tag
            CByteRange  brTags = BrTagsFromSegment(
                                                    brSearch,
                                                    GetComplementToken(*ptknOpen),
                                                    &pbCloseTag
                                                );

            if(pbCloseTag == NULL)
                {
                // if no close tag, throw error
                if(*ptknOpen == CTokenList::tknOpenObject)
                    ThrowError(pbTokenOpen, IDE_TEMPLATE_NO_CLOSE_OBJECT);
                else if(*ptknOpen == CTokenList::tknOpenTaggedScript)
                    ThrowError(pbTokenOpen, IDE_TEMPLATE_NO_CLOSE_TSCRIPT);
                }

            // if this is a server object (RUNAT=Server), we will process it; else keep looking
            if(FTagHasValue(brTags, CTokenList::tknTagRunat, CTokenList::tknValueServer))
                break;

            }
        else
            {
            // if token was other than script or object tag, or comment
            // we should process segment;
            // hence we have found our open token, so break
            break;
            }

LKeepLooking: ;
        }

    return pbTokenOpen;
    }

/*  ===================================================================
    CTemplate::GetCloseToken
    Returns a ptr to the next token of type tknClose.

    Returns
        ptr to close token
    Side effects
        Detects and errors out on attempt to nest tagged script or object blocks.
*/
BYTE*
CTemplate::GetCloseToken
(
CByteRange  brSearch,       // (ByVal) byte range to search
_TOKEN      tknClose        // close token
)
    {
    BYTE*   pbTokenClose = gm_pTokenList->GetToken(tknClose, brSearch, m_wCodePage);

    if(pbTokenClose != NULL)
        if(tknClose == CTokenList::tknCloseTaggedScript || tknClose == CTokenList::tknCloseObject)
            {
            CByteRange  brSegment;
            BYTE*       pbTokenOpen;

            brSegment.m_pb = brSearch.m_pb;
            brSegment.m_cb = DIFF(pbTokenClose - brSearch.m_pb);

            if(NULL != (pbTokenOpen = gm_pTokenList->GetToken(GetComplementToken(tknClose), brSegment, m_wCodePage)))
                {
                if(tknClose == CTokenList::tknCloseTaggedScript)
                    ThrowError(pbTokenOpen, IDE_TEMPLATE_NESTED_TSCRIPT);
                else if(tknClose == CTokenList::tknCloseObject)
                    ThrowError(pbTokenOpen, IDE_TEMPLATE_NESTED_OBJECT);
                }
            }

    return pbTokenClose;
    }

/*===================================================================
    CTemplate::GetComplementToken

    Returns a token's compement token.

    Returns
        Complement token
    Side effects
        None
*/
_TOKEN
CTemplate::GetComplementToken
(
_TOKEN  tkn
)
    {
    switch(tkn)
        {
    // open tokens
    case CTokenList::tknOpenPrimaryScript:
        return CTokenList::tknClosePrimaryScript;
    case CTokenList::tknOpenTaggedScript:
        return CTokenList::tknCloseTaggedScript;
    case CTokenList::tknOpenObject:
        return CTokenList::tknCloseObject;
    case CTokenList::tknOpenHTMLComment:
        return CTokenList::tknCloseHTMLComment;

    // close tokens
    case CTokenList::tknClosePrimaryScript:
        return CTokenList::tknOpenPrimaryScript;
    case CTokenList::tknCloseTaggedScript:
        return CTokenList::tknOpenTaggedScript;
    case CTokenList::tknCloseObject:
        return CTokenList::tknOpenObject;
    case CTokenList::tknCloseHTMLComment:
        return CTokenList::tknOpenHTMLComment;
        }

    Assert(FALSE);
    return CTokenList::tknEOF;
    }

/*===================================================================
    CTemplate::GetSegmentOfOpenToken

    Returns the segment type of an open token.

    Returns
        source segment type of open token
    Side effects
        None
*/
CTemplate::SOURCE_SEGMENT
CTemplate::GetSegmentOfOpenToken
(
_TOKEN tknOpen
)
    {
    switch(tknOpen)
        {
    case CTokenList::tknOpenPrimaryScript:
        return ssegPrimaryScript;
    case CTokenList::tknOpenTaggedScript:
        return ssegTaggedScript;
    case CTokenList::tknOpenObject:
        return ssegObject;
    case CTokenList::tknOpenHTMLComment:
        return ssegHTMLComment;
        }

    return ssegHTML;
    }

/*  ========================================================
    CTemplate::BrTagsFromSegment

    Returns the tag range from an HTML start tag

    Returns
        tag byte range
    Side effects
        none
*/
CByteRange
CTemplate::BrTagsFromSegment
(
CByteRange  brSegment,  // segment byte range
_TOKEN      tknClose,   // close token
BYTE**      ppbCloseTag // ptr-to-ptr to close tag - returned to caller
)
    {
    CByteRange  brTags; // tags return value - NOTE constructed null
                        // ptr to close token - NOTE null if none within segment byte range
    BYTE*       pbTokenClose = GetCloseToken(brSegment, tknClose);

    // if no close tag found, return null tags
    if(NULL == (*ppbCloseTag = gm_pTokenList->GetToken(CTokenList::tknCloseTag, brSegment, m_wCodePage)))
        goto Exit;

    // if next non-null close token occurs before close tag, close tag is invalid; return nulls
    if((pbTokenClose != NULL) && (*ppbCloseTag > pbTokenClose ))
        {
        *ppbCloseTag = NULL;
        goto Exit;
        }

    // crack tags from header tag
    brTags.m_pb = brSegment.m_pb;
    brTags.m_cb = DIFF(*ppbCloseTag - brSegment.m_pb);

Exit:
    return brTags;
    }

/*  ========================================================
    CTemplate::BrValueOfTag

    Returns a tag's value from a byte range; null if tag is not found
    NOTE value search algorithm per W3 HTML spec - see www.w3.org

    Returns
        byte range of tag's value
        pfTagExists - does the tag exist in tags byte range?    (out-parameter)
            NOTE we default *pfTagExists = TRUE; most callers don't care and omit this parameter
    Side effects
        none
*/
CByteRange
CTemplate::BrValueOfTag
(
CByteRange  brTags,     // tags byte range
_TOKEN      tknTagName  // tag name token
)
    {
    CByteRange  brTemp = brTags;        // temp byte range
    CByteRange  brValue;                // byte range of value for the given tag - NOTE constructed null
    char        chDelimiter = NULL;     // value delimiter
                                        // ptr to tag name
    BYTE*       pbTagName = GetTagName(brTags, tknTagName);

    // If we did not find tag, return
    if(pbTagName == NULL)
        return brValue;

    // Move past tag name token and pre-separator white space
    brTemp.Advance(DIFF(pbTagName - brTags.m_pb) + CCH_TOKEN(tknTagName));
    LTrimWhiteSpace(brTemp);
    if(brTemp.IsNull())
        goto Exit;

    // If we did not find separator, return
    if(*brTemp.m_pb != CH_ATTRIBUTE_SEPARATOR)
        goto Exit;

    // Move past separator and post-separator white space
    brTemp.Advance(sizeof(CH_ATTRIBUTE_SEPARATOR));
    LTrimWhiteSpace(brTemp);
    if(brTemp.IsNull())
        goto Exit;

    // If value begins with a quote mark, cache it as delimiter
    if((*brTemp.m_pb == CH_SINGLE_QUOTE) || (*brTemp.m_pb == CH_DOUBLE_QUOTE))
        chDelimiter = *brTemp.m_pb;

    if(chDelimiter)
        {
        // move past delimiter
        brTemp.Advance(sizeof(chDelimiter));
        if(brTemp.IsNull())
            goto Exit;
        }

    // provisionally set value to temp byte range
    brValue = brTemp;

    // advance temp byte range to end of value range
    while(
            (chDelimiter && (*brTemp.m_pb != chDelimiter))  // if we have a delimiter, find next delimiter
         || (!chDelimiter && (!FWhiteSpace(*brTemp.m_pb)))  // if we have no delimiter, find next white space
         )
        {
        // advance temp byte range
        brTemp.Advance(1);
        if(brTemp.IsNull())
            {
            if(chDelimiter)
                // we found no closing delimiter, so error out
                ThrowErrorSingleInsert(brValue.m_pb, IDE_TEMPLATE_NO_ATTRIBUTE_DELIMITER,
                                            pbTagName, CCH_TOKEN(tknTagName));
            else
                // value runs to end of temp byte range, so exit (since we already init'ed to temp)
                goto Exit;
            }
        }

    // set byte count so that value points to delimited range
    brValue.m_cb = DIFF(brTemp.m_pb - brValue.m_pb);

Exit:
    // if tag is empty, raise an error
    if (brValue.IsNull())
        {
        ThrowErrorSingleInsert(brTags.m_pb, IDE_TEMPLATE_VALUE_REQUIRED, pbTagName, CCH_TOKEN(tknTagName));
        }

    // enforce mandatory tag values if required
    if(tknTagName == CTokenList::tknTagRunat)
        {
        if(!brValue.FMatchesSz(SZ_TOKEN(CTokenList::tknValueServer)))
            ThrowError(brTags.m_pb, IDE_TEMPLATE_RUNAT_NOT_SERVER);
        }

    return brValue;
    }

/*  ============================================================================
    CTemplate::CompTagName

    Compares characters in two buffers (case-insensitive) and returns TRUE or FALSE

    Side effects
        none
*/
BOOL
CTemplate::CompTagName
(
CByteRange  &brTags,        // tags byte range
_TOKEN      tknTagName  // tag name token
)
    {
    CByteRange  brTemp = brTags;                            // local byte range, so we don't change tags byte range
    UINT        cbAttributeName = CCH_TOKEN(tknTagName);    // length of tag name
    LPSTR       pszAttributeName = SZ_TOKEN(tknTagName);    // tag name string

    // search for potential matches on tag name string, case-insensitive
    if(!brTemp.IsNull())
        if( 0 == _memicmp( brTemp.m_pb, pszAttributeName, cbAttributeName ))
            return TRUE;
    return FALSE;
    }


/*  ============================================================================
    CTemplate::GetTagName

    Returns a ptr to a tag name in a byte range; null if not found

    Returns
        ptr to tag name
    Side effects
        none
*/
BYTE*
CTemplate::GetTagName
(
CByteRange  brTags,     // tags byte range
_TOKEN      tknTagName  // tag name token
)
    {
    CByteRange  brTemp = brTags;                            // local byte range, so we don't change tags byte range
    UINT        cbAttributeName = CCH_TOKEN(tknTagName);    // length of tag name
    LPSTR       pszAttributeName = SZ_TOKEN(tknTagName);    // tag name string

        // PREFIX: pszAttributeName could be NULL, though I don't think that can happen.
        Assert (pszAttributeName != NULL);

    while(TRUE)
        {
        // search for potential matches on tag name string, case-insensitive
        while(!brTemp.IsNull())
            {
            if(0 == _strnicmp((char*)brTemp.m_pb, pszAttributeName, cbAttributeName ))
                break;
            brTemp.Advance(1);
            }

        // if we did not find tag name string at all, return 'not found'
        if(brTemp.IsNull())
            goto NotFound;

        // if it is a valid HTML tag name, return it
        if(FTagName(brTemp.m_pb, cbAttributeName))
            goto Exit;

        // if we found a matching but invalid substring, advance beyond it so we can search again
        brTemp.Advance(cbAttributeName);

        // if we have exhausted search range, return 'not found'
        if(brTemp.IsNull())
            goto NotFound;
        }

Exit:
    return brTemp.m_pb;

NotFound:
    return NULL;
    }

/*  ============================================================================
    CTemplate::GetTag

    Returns a ptr to a tag name in a byte range; null if not found

    Returns
        ptr to tag name
    Side effects
        none
*/
BOOL
CTemplate::GetTag
(
CByteRange  &brTags,        // tags byte range
int         nIndex
)
    {
    CByteRange  brTemp      = brTags;                           // local byte range, so we don't change tags byte range
    int         nTIndex     = 0;

    while(TRUE)
        {
        // locate the start of a tag by skipping past the script tag "<%" and any leading white space
        //
        while(!brTemp.IsNull())
            {
            if( *brTemp.m_pb == '<' ||
                *brTemp.m_pb == '%' ||
                *brTemp.m_pb == '@' ||
                FWhiteSpace(*brTemp.m_pb))
                {
                brTemp.Advance(1);
                brTags.Advance(1);
                }
            else
                break;
            }



        // search for potential matches on tag name string, case-insensitive
        //
        while(!brTemp.IsNull())
            {
            if( *brTemp.m_pb == '=' || FWhiteSpace(*brTemp.m_pb))
                {
                nTIndex++;
                break;
                }
            brTemp.Advance(1);
            }

        // if we did not find tag name string at all, return 'not found'
        if(brTemp.IsNull())
            goto NotFound;

        // if it is a valid HTML tag name, return it
        if(FTagName(brTags.m_pb, DIFF(brTemp.m_pb - brTags.m_pb)))
            if(nTIndex >= nIndex)
                goto Exit;

        // position past named pair data and reset start and if end of byte range then
        // goto NotFound
        //
        while(!brTemp.IsNull() && !FWhiteSpace(*brTemp.m_pb))
            brTemp.Advance(1);

        if(brTemp.IsNull())
            goto NotFound;
        else
            brTags.Advance(DIFF(brTemp.m_pb - brTags.m_pb));
        }
Exit:
    return TRUE;

NotFound:
    return FALSE;
    }


/*  ============================================================================
    CTemplate::FTagHasValue

    Do tags include tknTag=tknValue?

    Returns
        TRUE if tags include value, else FALSE
    Side effects
        none
*/
BOOLB
CTemplate::FTagHasValue
(
const CByteRange&   brTags,     // tags byte range to search
_TOKEN              tknTag,     // tag token
_TOKEN              tknValue    // value token
)
    {
    return (BrValueOfTag(brTags, tknTag)    // byte range of value
            .FMatchesSz(SZ_TOKEN(tknValue)));
    }

/*  =========================
    CTemplate::CopySzAdv

    Copies a string to a ptr and advances the ptr just beyond the copied string.

    Returns
        Nothing
    Side effects
        advances ptr beyond copied string
*/
void
CTemplate::CopySzAdv
(
char*   pchWrite,   // write location ptr
LPSTR   psz         // string to copy
)
    {
    strcpy(pchWrite, psz);
    pchWrite += strlen(psz);
    }

/*  ============================================================================
    CTemplate::WriteTemplate

    Writes the template out to a contiguous block of memory.

    Returns:
        nothing
    Side effects:
        Allocates, and possibly re-allocates, memory for the template.

    HERE IS HOW IT WORKS
    --------------------
    - an 'offset' is the count of bytes from start-of-template to a location
      within template memory
    - at the start of the template are 3 USHORTs, the counts of script blocks,
      object-infos and HTML blocks, respectively
    - next are 4 ULONGs, each an offset to a block of offsets; in order, these are:
        offset-to-offset to first script engine name
        offset-to-offset to first script block (the script text itself)
        offset-to-offset to first object-info
        offset-to-offset to first HTML block
    - next are a variable number of ULONGs, each an offset to a particular
      template component.  In order these ULONGs are:
        Offsets to                  Count of offsets
        ----------                  ----------------
        script engine names         cScriptBlocks
        script blocks               cScriptBlocks
        object-infos                cObjectInfos
        HTML blocks                 cHTMLBlocks
    - next are the template components themselves, stored sequentially
      in the following order:
        script engine names
        script blocks
        object-infos
        HTML blocks

    HERE IS HOW IT LOOKS
    --------------------
    |--|--|--|                      3 template component counts (USHORTs)

    |-- --|-- --|                   4 offsets to template component offsets (ULONGs)

    |-- --|-- --|-- --|-- --|-- --| template component offsets (ULONGs)
    |-- --| ............... |-- --|
    |-- --|-- --|-- --|-- --|-- --|

    | ........................... | template components
    | ........................... |
    | ........................... |
    | ........................... |

    or, mnemonically:

     cS cO cH                       3 template component counts (USHORTs)

     offSE offSB offOb offHT        4 offsets to template component offsets (ULONGs)

    |-- --|-- --|-- --|-- --|-- --| template component offsets (ULONGs)
    |-- --| ............... |-- --|
    |-- --|-- --|-- --|-- --|-- --|

    | ........................... | template components
    | ........................... |
    | ........................... |
    | ........................... |
*/
void
CTemplate::WriteTemplate
(
CWorkStore& WorkStore,          // working storage for source segments
CHitObj*    pHitObj
)
    {
    USHORT      i;              // loop index
    CByteRange  brWrite;        // general-purpose byte range for writing stuff out

    USHORT cScriptBlocks = WorkStore.CRequiredScriptEngines(m_fGlobalAsa);  // count of script blocks - 1 per required engine
    USHORT cObjectInfos = WorkStore.m_ObjectInfoStore.Count();  // count of object-infos
    USHORT cHTMLBlocks = WorkStore.m_bufHTMLSegments.Count();   // count of HTML segments

    // Calc count of offset-to-offsets == total count of all scripts, objects, etc
    // NOTE we keep separate offset-to-offsets for script engine names and script text, hence 2x
    USHORT cBlockPtrs = (2 * cScriptBlocks) + cObjectInfos + cHTMLBlocks;

    // Calc total memory required
    // NOTE header includes counts and ptr-ptrs
    UINT    cbRequiredHeader = (C_COUNTS_IN_HEADER * sizeof(USHORT)) + (C_OFFOFFS_IN_HEADER * sizeof(BYTE**));
    UINT    cbRequiredBlockPtrs = cBlockPtrs * sizeof(BYTE*);

    // Init write-offset locations
    // offset to location for writing the next header information; header is at start of template
    UINT    cbHeaderOffset = 0;
    // offset to location for writing the next offset-to-offset; immediately follows header
    UINT    cbOffsetToOffset = cbRequiredHeader;
    // offset to location for writing the next block of data; immediately follows offset-to-offsets
    UINT    cbDataOffset = cbOffsetToOffset + cbRequiredBlockPtrs;

    // offset in source file (for html blocks)
    ULONG   cbSourceOffset;
    // source filename (only if include file)
    BYTE   *pbIncFilename;
    ULONG   cbIncFilename;

    // Allocate memory and init start-ptr; bail on fail
    // NOTE here we init template member variables m_pbStart and m_cbTemplate
    if(NULL == (m_pbStart = (BYTE*) CTemplate::LargeMalloc(m_cbTemplate = CB_TEMPLATE_DEFAULT)))
        THROW(E_OUTOFMEMORY);

    // write out template header
    WriteHeader(cScriptBlocks, cObjectInfos, cHTMLBlocks, &cbHeaderOffset, &cbOffsetToOffset);

    // Reset offset-to-offset ptr to beginning of its section
    cbOffsetToOffset = cbRequiredHeader;

    // write script engine names and prog lang ids at current of data section
    for(i = 0; i < WorkStore.m_ScriptStore.CountPreliminaryEngines(); i++)
        {
        // bug 933: only write non-empty script engines
        if(WorkStore.FScriptEngineRequired(i, m_fGlobalAsa))
            {
            WorkStore.m_ScriptStore.m_bufEngineNames.GetItem(i, brWrite);
            WriteByteRangeAdv(brWrite, TRUE, &cbDataOffset, &cbOffsetToOffset);
            MemCpyAdv(&cbDataOffset, &(WorkStore.m_ScriptStore.m_rgProgLangId[i]), sizeof(PROGLANG_ID), sizeof(DWORD));
            }
        }
   
    // write the script blocks for each engine at current of data section
    // NOTE we sequence this after script engine names (rather than interleave)
    USHORT  idEngine = 0;
    for(i = 0; i < WorkStore.m_ScriptStore.CountPreliminaryEngines(); i++)
        {
        // bug 933: only write non-empty script engines
        if(WorkStore.FScriptEngineRequired(i, m_fGlobalAsa))
            {
            // bug 933: we need to pass both 'preliminary' engine id (i) and id of instantiated engine (idEngine)
            WriteScriptBlockOfEngine(i, idEngine, WorkStore, &cbDataOffset, &cbOffsetToOffset, pHitObj);
            idEngine++;
            }
        }

    // Write object-infos at current of data section
    for(i = 0; i < cObjectInfos; i++)
        {
        // get i-th object info from work store
        WorkStore.m_ObjectInfoStore.m_bufObjectNames.GetItem(i, brWrite);
        // write object name
        WriteByteRangeAdv(brWrite, TRUE, &cbDataOffset, &cbOffsetToOffset);
        // write clsid, scope and model
        /*  CONSIDER include if we need to byte-align clsid
        // NOTE byte-align clsid (16-byte), which then byte-aligns scope and model (both 4-byte)
        MemCpyAdv(&cbDataOffset, &(WorkStore.m_ObjectInfoStore.m_pObjectInfos[i].m_clsid), sizeof(CLSID), TRUE); */
        MemCpyAdv(&cbDataOffset, &(WorkStore.m_ObjectInfoStore.m_pObjectInfos[i].m_clsid), sizeof(CLSID), sizeof(DWORD));
        MemCpyAdv(&cbDataOffset, &(WorkStore.m_ObjectInfoStore.m_pObjectInfos[i].m_scope), sizeof(CompScope));
        MemCpyAdv(&cbDataOffset, &(WorkStore.m_ObjectInfoStore.m_pObjectInfos[i].m_model), sizeof(CompModel));
        }

    // if other than globals template, write HTML blocks at current of data section
    if(!m_fGlobalAsa)
        for(i = 0; i < cHTMLBlocks; i++)
            {
            // write byterange with html code
            WorkStore.m_bufHTMLSegments.GetItem(i, brWrite);
            WriteByteRangeAdv(brWrite, TRUE, &cbDataOffset, &cbOffsetToOffset);

            // source offset and include file
            cbSourceOffset = 0;
            pbIncFilename = NULL;
            cbIncFilename = 0;

            if (brWrite.m_pfilemap)
                {
                // calculate offset from filemap
                CFileMap *pFileMap = (CFileMap *)brWrite.m_pfilemap;
                if (pFileMap->m_pbStartOfFile) // mapped?
                    {
                    cbSourceOffset = DIFF(brWrite.m_pb - pFileMap->m_pbStartOfFile) + 1;

                    if (pFileMap->GetParent() != NULL && // is include file?
                        pFileMap->m_szPathInfo)  // path exists
                        {
                        pbIncFilename = (BYTE *)pFileMap->m_szPathInfo;
                        cbIncFilename = _tcslen(pFileMap->m_szPathInfo)*sizeof(TCHAR);
                        }
                    }
                }

            // write them
            MemCpyAdv(&cbDataOffset, &cbSourceOffset, sizeof(ULONG));
            MemCpyAdv(&cbDataOffset, &cbIncFilename, sizeof(ULONG));
            if (cbIncFilename > 0)
                MemCpyAdv(&cbDataOffset, pbIncFilename, cbIncFilename+sizeof(TCHAR));
            }

    // trim template memory to exactly what we used
    // NOTE cbDataOffset now contains maximum reach we have written to
    if(NULL == (m_pbStart = (BYTE*) CTemplate::LargeReAlloc(m_pbStart, m_cbTemplate = cbDataOffset)))
        THROW(E_OUTOFMEMORY);
  
    }

/*  ============================================================================
    CTemplate::WriteHeader

    Writes template header, and writes vesrion stamp and source file name into
    template data region.

    Returns
        nothing
    Side effects
        none
*/
void
CTemplate::WriteHeader
(
USHORT  cScriptBlocks,      // count of script blocks
USHORT  cObjectInfos,       // count of object-infos
USHORT  cHTMLBlocks,        // count of HTML blocks
UINT*   pcbHeaderOffset,    // ptr to offset value for header write location
UINT*   pcbOffsetToOffset   // ptr to offset value for offset-to-offset write location
)
    {
    // Write template component counts out at start of header
    WriteShortAdv(cScriptBlocks,    pcbHeaderOffset);
    WriteShortAdv(cObjectInfos,     pcbHeaderOffset);
    WriteShortAdv(cHTMLBlocks,      pcbHeaderOffset);

    // Write offsets-to-offset to script engine names, script blocks, object-infos, HTML blocks
    // NOTE counts of script engine names and script blocks are identical
    WriteOffsetToOffset(cScriptBlocks,  pcbHeaderOffset, pcbOffsetToOffset);
    WriteOffsetToOffset(cScriptBlocks,  pcbHeaderOffset, pcbOffsetToOffset);
    WriteOffsetToOffset(cObjectInfos,   pcbHeaderOffset, pcbOffsetToOffset);
    WriteOffsetToOffset(cHTMLBlocks,    pcbHeaderOffset, pcbOffsetToOffset);
    }

/*  ============================================================================
    CTemplate::WriteScriptBlockOfEngine

    Writes out script block for idEngine-th script engine.
    NOTE segment buffer [0] contains primary script segments
         segment buffer [1] contains tagged script segments of default engine
         segment buffer [i] contains tagged script segments of (i-1)th engine, for i >= 2

    Returns
        nothing
    Side effects
        none
*/
void
CTemplate::WriteScriptBlockOfEngine
(
USHORT      idEnginePrelim,     // preliminary script engine id (assigned during template pre-processing)
USHORT      idEngine,           // actual script engine id (written into compiled template)
CWorkStore& WorkStore,          // working storage for source segments
UINT*       pcbDataOffset,      // ptr to write location offset value
UINT*       pcbOffsetToOffset,  // ptr to offset-to-offset offset value
CHitObj*    pHitObj
)
    {
                                            // NOTE works for all id's - see comment above
    USHORT      iTSegBuffer = idEnginePrelim + 1;   // index of tagged segment buffer
    CByteRange  brSegment;                  // current script segment
    UINT        i;                          // loop index
    UINT        cbScriptBlockOffset;        // offset to script block write-location
                                            // count of tagged script segments
    UINT        cTaggedSegments = WorkStore.m_ScriptStore.m_ppbufSegments[iTSegBuffer]->Count();

    // Byte-align data offset location, since next thing we will write there is script block length
    // NOTE we use brSegment.m_cb generically; we really want CByteRange::m_cb
    ByteAlignOffset(pcbDataOffset, sizeof(brSegment.m_cb));
    // Cache current data offset location as offset to start of script block
    cbScriptBlockOffset = *pcbDataOffset;
    // Write offset to start of script block at current offset-to-offset offset
    WriteLongAdv(cbScriptBlockOffset, pcbOffsetToOffset);
    // advance data ptr (by init'ing script length value to 0)
    WriteLongAdv(0, pcbDataOffset);
    // reset counter that AppendSourceInfo uses
    m_cbTargetOffsetPrevT = 0;

    // if other than globals template and this is default script engine (prelim engine 0),
    // write primary script procedure at current of data section
    if(!m_fGlobalAsa)
        if(idEnginePrelim == 0)
            WritePrimaryScriptProcedure(0, WorkStore, pcbDataOffset, cbScriptBlockOffset + sizeof(long));

    // write out tagged script segments at current of data section
    for(i = 0; i < cTaggedSegments; i++)
        {
        WorkStore.m_ScriptStore.m_ppbufSegments[iTSegBuffer]->GetItem(i, brSegment);
        WriteScriptSegment(
                            idEngine,
                            m_rgpSegmentFilemaps[brSegment.m_idSequence],
                            brSegment,
                            pcbDataOffset,
                            cbScriptBlockOffset + sizeof(long),
                            FALSE       /* fAllowExprWrite - disallowed for tagged script */
                          );
        }

    // Write out null terminator
    MemCpyAdv(pcbDataOffset, SZ_NULL, 1);

    // convert script text to unicode, so script engine won't have to do this at runtime

    // ptr to start of script is:
    //           ptr start of template + offset to script    + size of script length
    LPSTR szScript = (LPSTR) m_pbStart + cbScriptBlockOffset + sizeof(ULONG);
    /*  script block length is:
        == EndOfScriptText                           - StartOfScriptText
        == (current of data ptr - length of null )   - (start of primary script byte range + length of br.m_cb)
    */
    ULONG cbScript = (*pcbDataOffset - sizeof(BYTE)) - (cbScriptBlockOffset + sizeof(ULONG));

    /*  bug 887: we append one extra "pseudo-line" to the end of source-infos array
        to cover the case where the script engine reports back an error line number
        that falls after end of script. We always want the "pseudo-line" to point to the
        main file, so that the debugger can display something reasonable, so we pass
        m_rgpFilemaps[0] as the source file, which is the main file.
    */
    AppendSourceInfo(idEngine, m_rgpFilemaps[0],
                     NULL,              // Don't calculate line #
                     UINT_MAX,          // Don't care & calculation is expensive
                     UINT_MAX,                  // Start of script blocks
                     UINT_MAX,                  // Really don't care
                     0,                 // zero characters exist past EOF
                     TRUE);             // Line is HTML (bogus)

    // get wide string version of script text, using hitobj's code page
    // NOTE we may slightly over-allocate space for wstrScript by using cbScript (e.g. if script contains DBCS).
    // However, this won't matter since we call MultiByteToWideChar with -1, telling it to calc length of szScript
    LPOLESTR wstrScript = NULL;
    DWORD cbConvert = ( cbScript + 1 ) * 2;

    STACK_BUFFER( tempScript, 2048 );

    if (!tempScript.Resize(cbConvert)) {
        THROW(E_OUTOFMEMORY);
    }

    wstrScript = (LPOLESTR)tempScript.QueryPtr();

    MultiByteToWideChar( m_wCodePage, 0, szScript, -1, wstrScript, (cbScript + 1) );

    // reset data offset location to start of script
    *pcbDataOffset = cbScriptBlockOffset + sizeof(ULONG);
    // write wide string script text over top of ansi version
    MemCpyAdv(pcbDataOffset, wstrScript, sizeof(WCHAR) * cbScript);
    // write wide string null terminator
    MemCpyAdv(pcbDataOffset, WSTR_NULL, sizeof(WCHAR));

    //  write script length at start of script byte range
    // NOTE we do this here because script length was initially unknown
    WriteLongAdv(sizeof(WCHAR) * cbScript, &cbScriptBlockOffset);

    }

/*  ============================================================================
    CTemplate::WritePrimaryScriptProcedure

    Writes out default-engine primary script procedure.
    If VBScript is default-engine, the primary script procedure contains
    interleaved script commands and HTML block-writes, like this:
        Sub Main
            ...
            [script segment]
            Response.WriteBlock([HTML block id])
            ...
            [script segment]
            Response.WriteBlock([HTML block id])
            ...
            [script segment]
            Response.WriteBlock([HTML block id])
            ...
        End Sub

    NOTE segment buffer [0] == primary script segments

    Returns
        nothing
    Side effects
        none
*/
void
CTemplate::WritePrimaryScriptProcedure
(
USHORT      idEngine,           // script engine id
CWorkStore& WorkStore,          // working storage for source segments
UINT*       pcbDataOffset,      // ptr to write location offset value
UINT        cbScriptBlockOffset // ptr to start of script engine code
)
    {
    USHORT      cScriptSegmentsProcessed = 0;   // count of script blocks processed
    USHORT      cHTMLBlocksProcessed = 0;       // count of HTML blocks processed
    CByteRange  brScriptNext;                   // next script block to write out
    CByteRange  brHTMLNext;                     // next HTML block to write out
    char        szHTMLBlockID[6];               // sz representation of HTML block ID - NOTE limited to 5 digits
                                                // count of primary script segments
    USHORT      cPrimaryScriptSegments = WorkStore.m_ScriptStore.m_ppbufSegments[0]->Count();
                                                // count of HTML blocks
    USHORT      cHTMLBlocks = WorkStore.m_bufHTMLSegments.Count();
    CFileMap*   pfilemap;                       // file where HTML segment lives in

    // get initial script segment and initial html segment
    if(cPrimaryScriptSegments)
        WorkStore.m_ScriptStore.m_ppbufSegments[0]->GetItem(0, brScriptNext);
    if(cHTMLBlocks)
        WorkStore.m_bufHTMLSegments.GetItem(0, brHTMLNext);

    // While HTML block(s) or primary script segment(s) remain to be processed ...
    while((cHTMLBlocksProcessed < cHTMLBlocks) || (cScriptSegmentsProcessed < cPrimaryScriptSegments))
        {
        // If HTML block(s) remain to be processed ...
        if(cHTMLBlocksProcessed < cHTMLBlocks)
            while (TRUE)
                {
                // Write out write-block command for each HTML segment earlier in source than next script segment
                if(brHTMLNext.FEarlierInSourceThan(brScriptNext) || (cScriptSegmentsProcessed >= cPrimaryScriptSegments))
                    {
                    // append source-info for the target script line we just manufactured
                    pfilemap = m_rgpSegmentFilemaps[brHTMLNext.m_idSequence];
                    AppendSourceInfo(idEngine, pfilemap,
                                     NULL,                                              // Don't calculate line #
                                     DIFF(brHTMLNext.m_pb - pfilemap->m_pbStartOfFile), // line offset
                                     cbScriptBlockOffset,
                                     *pcbDataOffset - cbScriptBlockOffset,              // character offset in target script
                                     CharAdvDBCS((WORD)m_wCodePage,                     // length of the segment
                                                 reinterpret_cast<char *>(brHTMLNext.m_pb),
                                                 reinterpret_cast<char *>(brHTMLNext.m_pb + brHTMLNext.m_cb),
                                                 INFINITE, NULL),
                                     TRUE);                                             // Line is HTML text

                    // Get block number as an sz
                    _itoa(cHTMLBlocksProcessed, szHTMLBlockID, 10);
                    // Write out write-block opener
                    WriteSzAsBytesAdv(WorkStore.m_szWriteBlockOpen, pcbDataOffset);
                    // Write out block number
                    WriteSzAsBytesAdv(szHTMLBlockID, pcbDataOffset);
                    // Write out write-block closer and newline
                    WriteSzAsBytesAdv(WorkStore.m_szWriteBlockClose, pcbDataOffset);
                    WriteSzAsBytesAdv(SZ_NEWLINE, pcbDataOffset);

                    if(++cHTMLBlocksProcessed >= cHTMLBlocks)
                        break;

                    // Get next HTML block
                    WorkStore.m_bufHTMLSegments.GetItem(cHTMLBlocksProcessed, brHTMLNext);
                    }
                    else
                        break;
                }

        // if primary script segment(s) remain to be processed ...
        if(cScriptSegmentsProcessed < cPrimaryScriptSegments)
            while (TRUE)
                {
                // Write out each primary script segment earlier in the source file than the next HTML block
                if(brScriptNext.FEarlierInSourceThan(brHTMLNext) || (cHTMLBlocksProcessed >= cHTMLBlocks))
                    {
                    WriteScriptSegment(
                                        idEngine,
                                        m_rgpSegmentFilemaps[brScriptNext.m_idSequence],
                                        brScriptNext,
                                        pcbDataOffset,
                                        cbScriptBlockOffset,
                                        TRUE        /* fAllowExprWrite - allowed for primary script */
                                      );

                    if(++cScriptSegmentsProcessed >= cPrimaryScriptSegments)
                        break;

                    // Get next script segment
                    WorkStore.m_ScriptStore.m_ppbufSegments[0]->GetItem(cScriptSegmentsProcessed, brScriptNext);
                    }
                else
                    break;
                }
        }
    }


/*  ============================================================================
    CTemplate::WriteScriptSegment

    Writes a script segment to template memory line-by-line.
    NOTE a 'script segment' is a piece (possibly all) of a 'script block'

    Returns
        nothing
    Side effects
        none
*/
void
CTemplate::WriteScriptSegment
(
USHORT      idEngine,       // script engine id
CFileMap*   pfilemap,       // ptr to source file map
CByteRange& brScript,       // byte range containing script segment
UINT*       pcbDataOffset,  // ptr to write location offset value
UINT        cbScriptBlockOffset,// ptr to beginning of the script text
BOOL        fAllowExprWrite // allow short-hand expression write?
)
    {
    CByteRange  brLine;                 // byte range containing next line
    UINT        cbPtrOffset = 0;        // ptr offset - 0 tells WriteByteRangeAdv 'ignore this'
    BOOL        fExpression = FALSE;    // is current line an expression?
    BOOL        fCalcLineNumber = TRUE; // calc source line number?
    BOOL        fFirstLine = TRUE;      // first line in script segment?

    if(FByteRangeIsWhiteSpace(brScript))
        return;

    // trim white space from beginning of script segment
    if (FIsLangVBScriptOrJScript(idEngine))
        LTrimWhiteSpace(brScript);

    while(!(brScript.IsNull()))
        {
        // fetch next line from byte range
        // NOTE LineFromByteRangeAdv advances through brScript until brScript is null
        LineFromByteRangeAdv(brScript, brLine);

        if(FByteRangeIsWhiteSpace(brLine))
            {
            // if line is blank, don't process it; simply force calc of line number on next non-blank line
            fCalcLineNumber = TRUE;
            continue;
            }

        // line is non-blank; trim its white space
        if (FIsLangVBScriptOrJScript(idEngine))
            LTrimWhiteSpace(brLine);
        RTrimWhiteSpace(brLine);

        // append source-info to array; if flag is set, calc line number
        // from location in source file; else, simply increment previous line number (NULL indicates this)
        AppendSourceInfo(idEngine, pfilemap,
                         fCalcLineNumber? brLine.m_pb : NULL,           // info to calc line #
                         DIFF(brLine.m_pb - pfilemap->m_pbStartOfFile), // line offset
                         cbScriptBlockOffset,
                         *pcbDataOffset - cbScriptBlockOffset,          // character offset in target script
                         CharAdvDBCS((WORD)m_wCodePage,                 // statement length
                                     reinterpret_cast<char *>(brLine.m_pb),
                                     reinterpret_cast<char *>(brLine.m_pb + brLine.m_cb),
                                     INFINITE, NULL),
                         FALSE);                                        // HTML?

        /*  if it's true, set calc-line-number flag false
            NOTE this is purely an optimization, to make the call to AppendSourceInfo faster
            on subsequent calls within a contiguous block of non-blank lines
        */
        if(fCalcLineNumber)
            fCalcLineNumber = FALSE;

        if(fAllowExprWrite && fFirstLine)
            {
            // bug 912: test for remainder of script segment null on temp copy of script byte range, not on actual
            CByteRange  brTemp = brScript;
            LTrimWhiteSpace(brTemp);    // NOTE will nullify brScript if it is all white space

            if(brTemp.IsNull())
                {
                /*  if
                      a) expr-write is allowed AND
                      b) this is only script line in this segment (i.e. first line in segment and remainder of segment is null)
                    then, test this line to see if it is an expression.
                    NOTE test (b) fixes bug 785

                    if this line is an expression, create a script command that reads
                        Response.Write([line contents])
                */
                if(fExpression = FExpression(brLine))
                    {
                    Assert(idEngine == 0);  // =expr is only enabled for primary engine
                    WriteSzAsBytesAdv(m_pWorkStore->m_szWriteOpen, pcbDataOffset);
                    }

                // in this case only, set actual script to (now null) temp copy, since brScript governs while loop termination
                brScript = brTemp;
                }
            }

        Assert(FImplies(fExpression, fFirstLine));          // if an expr, must be first line in segment
        Assert(FImplies(fExpression, brScript.IsNull()));   // if an expr, no more script lines remain
        Assert(FImplies(!fFirstLine, !fExpression));            // if not first line in segment, line cannot be expr
        Assert(FImplies(!brScript.IsNull(), !fExpression)); // if script lines remain, line cannot be expr

        // write out line contents
        WriteScriptMinusEscapeChars(brLine, pcbDataOffset, &cbPtrOffset);

        // if this line is an expression, close script command
        if(fExpression)
            WriteSzAsBytesAdv(m_pWorkStore->m_szWriteClose, pcbDataOffset);

        // write new-line and set first-line flag false
        WriteSzAsBytesAdv(SZ_NEWLINE, pcbDataOffset);
        fFirstLine = FALSE;
        }
    }

/*  ============================================================================
    CTemplate::WriteScriptMinusEscapeChars
    Writes a script byte range to memory, minus its escape characters, if any.

    Returns:
        Nothing.
    Side effects:
        None.
*/
void
CTemplate::WriteScriptMinusEscapeChars
(
CByteRange  brScript,       // (ByVal) script byte range
UINT*       pcbDataOffset,  // offset where data will be written
UINT*       pcbPtrOffset    // offset where ptr will be written
)
    {
    BYTE*   pbToken;

    while(NULL != (pbToken = gm_pTokenList->GetToken(CTokenList::tknEscapedClosePrimaryScript, brScript, m_wCodePage)))
        {
        CByteRange  brTemp = brScript;

        // set temp range to source range up to escaped-token
        brTemp.m_cb = DIFF(pbToken - brTemp.m_pb);

        // write out temp range and actual-token - this replaces escaped-token with actual-token
        WriteByteRangeAdv(brTemp, FALSE, pcbDataOffset, pcbPtrOffset);
        WriteSzAsBytesAdv(SZ_TOKEN(CTokenList::tknClosePrimaryScript), pcbDataOffset);

        //advance source range past escaped-token
        brScript.Advance(DIFF(pbToken - brScript.m_pb) + CCH_TOKEN(CTokenList::tknEscapedClosePrimaryScript));
        }

    // write remainder of source range
    WriteByteRangeAdv(brScript, FALSE, pcbDataOffset, pcbPtrOffset);
    }

/*  ============================================================================
    CTemplate::FVbsComment
    Determines whether a script line is a VBS comment.
    NOTE caller must ensure that brLine is non-blank and has no leading white space

    Returns
        TRUE if the line is a VBS comment, else FALSE
    Side effects
        none
*/
BOOLB
CTemplate::FVbsComment(CByteRange& brLine)
    {
    // CONSIDER: SCRIPTLANG generic comment token
    if(!_strnicmp((LPCSTR)brLine.m_pb, SZ_TOKEN(CTokenList::tknVBSCommentSQuote), CCH_TOKEN(CTokenList::tknVBSCommentSQuote)))
        return TRUE;
    if(!_strnicmp((LPCSTR)brLine.m_pb, SZ_TOKEN(CTokenList::tknVBSCommentRem), CCH_TOKEN(CTokenList::tknVBSCommentRem)))
        return TRUE;

    return FALSE;
    }

/*  ============================================================================
    CTemplate::FExpression

    Determines whether a script line is an expression, and if so returns
    just the expression in brLine.
    NOTE caller must ensure that brLine has no leading white space

    Returns
        TRUE if the line is an expression, else FALSE
    Side effects
        none
*/
BOOLB
CTemplate::FExpression(CByteRange& brLine)
    {
        // may be whitespace (other languages besides VB & JScript will have whitespace)
        char *pchLine = reinterpret_cast<char *>(brLine.m_pb);
        int cchLine = brLine.m_cb;

        while (cchLine > 0 && FWhiteSpace(*pchLine))
                {
                --cchLine;
                ++pchLine;
                }

    // if line starts with =, it is an expression: bypass =, left-trim whitespace and return true
    if(cchLine > 0 && *pchLine == '=')
        {
        brLine.Advance(1 + DIFF(reinterpret_cast<BYTE *>(pchLine) - brLine.m_pb));  // OK to advance past whitespace now.
        LTrimWhiteSpace(brLine);
        return TRUE;
        }

    // else return false
    return FALSE;
    }

/**
 **     In the following function names:
 **         'Adv' == 'advance offset after writing'
 **/

/*  ============================================================================
    CTemplate::WriteOffsetToOffset

    Writes a offset-to-offset offset (0 if no blocks) into header,
    and advances header offset and offset-to-offset.

    Returns:
        Nothing.
    Side effects:
        Advances offsets.
*/
void
CTemplate::WriteOffsetToOffset
(
USHORT  cBlocks,            // count of blocks
UINT*   pcbHeaderOffset,    // ptr to header offset value
UINT*   pcbOffsetToOffset   // ptr to offset-to-offset value
)
    {
    // if blocks of this type, write offset to first of them into header;
    // if no blocks of this type, write 0 into header
    WriteLongAdv((cBlocks > 0) ? *pcbOffsetToOffset : 0, pcbHeaderOffset);

    // advance offset-to-offset offset
    *pcbOffsetToOffset += cBlocks * sizeof(ULONG);
    }

/*  ============================================================================
    CTemplate::WriteSzAsBytesAdv

    Writes a null-terminated string as bytes, i.e. without its null terminator
    and advances offset

    Returns:
        Nothing.
    Side effects:
        Advances offset.
*/
void
CTemplate::WriteSzAsBytesAdv
(
LPCSTR  szSource,       // source string
UINT*   pcbDataOffset   // ptr to offset value
)
    {
    if((szSource == NULL) || (*szSource == '\0'))
        return;
    MemCpyAdv(pcbDataOffset, (void*) szSource, strlen(szSource));
    }

/*  ============================================================================
    CTemplate::WriteByteRangeAdv

    Writes a byte range to memory at template offset location *pcbDataOffset and, optionally,
    writes a ptr to the written data at template offset location *pcbPtrOffset
    (pass *pcbPtrOffset == 0 to avoid this)

    fWriteAsBsz == FALSE -->    write only byte range's data
    fWriteAsBsz == TRUE  -->    write length, followed by data, followed by NULL
                                NOTE bsz == length-prefixed, null-terminated string

    Returns:
        Nothing.
    Side effects:
        Advances offset(s).
*/
void
CTemplate::WriteByteRangeAdv
(
CByteRange& brSource,       // source data
BOOLB       fWriteAsBsz,    // write as bsz?
UINT*       pcbDataOffset,  // offset where data will be written
UINT*       pcbPtrOffset    // offset where ptr will be written
)
    {
    // bail if source is empty
    if(brSource.IsNull())
        return;

    // If writing as a bsz, write length prefix
    if(fWriteAsBsz)
        WriteLongAdv(brSource.m_cb, pcbDataOffset);

    // Write data
    MemCpyAdv(pcbDataOffset, brSource.m_pb, brSource.m_cb);

    // If writing as a bsz, write null terminator and advance target ptr
    if(fWriteAsBsz)
        MemCpyAdv(pcbDataOffset, SZ_NULL, 1);

    // If caller passed a non-zero ptr offset, write offset to data there
    if(*pcbPtrOffset > 0)
        {
        if(fWriteAsBsz)
            /* if writing as a bsz ...
                offset to start of data == current data offset
                                          - null terminator
                                          - data length
                                          - sizeof length prefix
            */
            WriteLongAdv(*pcbDataOffset - 1 - brSource.m_cb - sizeof(brSource.m_cb), pcbPtrOffset);
        else
            // else, offset to start of data == current data offset - data length
            WriteLongAdv(*pcbDataOffset - brSource.m_cb, pcbPtrOffset);
        }
    }

/*===================================================================
    CTemplate::MemCpyAdv

    Copies from a memory location to a template offset location,
    and advances offset.

    Returns:
        Nothing.
    Side effects:
        Advances offset.
        Re-allocates memory if required.
*/
void
CTemplate::MemCpyAdv
(
UINT*   pcbOffset,  // ptr to offset value
void*   pbSource,   // ptr to source
ULONG   cbSource,   // length of source
UINT    cbByteAlign // align bytes on short/long/dword boundary?
)
    {
    // byte-align offset location before write, if specified by caller
    if(cbByteAlign > 0)
        ByteAlignOffset(pcbOffset, cbByteAlign);

    // calc number of bytes by which to grow allocated template memory:
    // if projected reach exceeds current reach, we need to grow by the difference;
    // else, no need to grow
    if((*pcbOffset + cbSource) > m_cbTemplate)
        {
        // Reallocate space for storing local data - we grab twice what we had before
        // or twice current growth requirement, whichever is more
        m_cbTemplate = 2 * max(m_cbTemplate, (*pcbOffset + cbSource) - m_cbTemplate);
        if(NULL == (m_pbStart = (BYTE*) CTemplate::LargeReAlloc(m_pbStart, m_cbTemplate)))
            THROW(E_OUTOFMEMORY);
        }

    // copy source to template offset location
    memcpy(m_pbStart + *pcbOffset, pbSource, cbSource);
    // advance offset location
    *pcbOffset += cbSource;
    }

/*  ============================================================================
    CTemplate::GetAddress
    Returns a ptr to the i-th object of type tcomp
*/
BYTE*
CTemplate::GetAddress
(
TEMPLATE_COMPONENT  tcomp,
USHORT              i
)
    {
    DWORD*  pdwBase;

    Assert(NULL != m_pbStart);

    // refer to CTemplate::WriteTemplate comments for the structure of what this is dealing with

    pdwBase = (DWORD*)(m_pbStart + (C_COUNTS_IN_HEADER * sizeof(USHORT)));

    // tcomp types are ptr-to-ptrs
    DWORD* pdwTcompBase = (DWORD *) (m_pbStart + pdwBase[tcomp]);

    return m_pbStart + pdwTcompBase[i];
    }




/*  ============================================================================
    CTemplate::AppendSourceInfo
    Appends a source line number for the current target line
    NOTE if caller passes null source ptr, we append prev source line number + 1

    Returns
        Nothing
    Side effects
        allocates memory first time thru; may realloc
*/
void
CTemplate::AppendSourceInfo
(
USHORT      idEngine,            // script engine id
CFileMap*   pfilemap,            // ptr to source file map
BYTE*       pbSource,            // ptr to current location in source file
ULONG       cbSourceOffset,      // byte offset of line in source file
ULONG           cbScriptBlockOffset, // pointer to start of script text
ULONG       cbTargetOffset,      // character offset of line in target file
ULONG       cchSourceText,       // # of characters in source text
BOOL        fIsHTML              // TRUE if manufactured line
)
    {
    UINT                i;                  // loop index
    CSourceInfo         si;                 // temporary CSourceInfo structure
    vector<CSourceInfo> *prgSourceInfos;    // pointer to line mapping table for the engine
    ULONG               cchSourceOffset = 0;// cch corresponding to cbSourceOffset
    HRESULT             hr = S_OK;

    // if arrays are not yet allocated, allocate them
    if (m_rgrgSourceInfos == NULL)
        {
        // transfer count of script engines from workstore to template
        m_cScriptEngines = m_pWorkStore->CRequiredScriptEngines(m_fGlobalAsa);

        // one source-info array per engine
        if ((m_rgrgSourceInfos = new vector<CSourceInfo>[m_cScriptEngines]) == NULL)
            THROW (E_OUTOFMEMORY);
        }

    // new script engine must be allocated in IdEngineFromBr (way upstream of this point),
    // so we assert that current engine must already be covered
    Assert(idEngine < m_pWorkStore->CRequiredScriptEngines(m_fGlobalAsa));

    /*  set current target line's source line number (SLN):
        a) if caller passed a source ptr, calc SLN from the source ptr;
        b) else if caller passed a filemap ptr, set SLN to prev target line's SLN plus one;
        c) else set SLN to 0

        semantics:
        a) we have a source file location, but must calc a line # for that location
        b) caller tells us (by passing NULL source file location) that this target line
           immediately follows prev target line.  This is an optimization because
           SourceLineNumberFromPb is very slow.

        change:
            caller used to pass NULL filemap ptr that target line is 'manufactured'
            i.e. has no corresponding authored line in source file

            HOWEVER - now filemap ptr must NOT be NULL because 'manufactured' lines
            are also stored in the file map array
    */

    Assert (pfilemap != NULL);

    prgSourceInfos = &m_rgrgSourceInfos[idEngine];
    
    if (pbSource == NULL)
        {
        if (prgSourceInfos->length() == 0)
            si.m_idLine = 1;
        else
            si.m_idLine = (*prgSourceInfos)[prgSourceInfos->length() - 1].m_idLine + 1;
        }
    else
        si.m_idLine = SourceLineNumberFromPb(pfilemap, pbSource);

    // The EOF line does not have a source offset (caller passes -1 (UINT_MAX)).  For this case, no
    // DBCS calculations etc. should be done.  (set cchSourceOffset to UINT_MAX).
    if (cbSourceOffset == UINT_MAX)
        cchSourceOffset = UINT_MAX;
    else
        {
        // BUG 80901: Source offset needs to point to the beginning of leading white space on the line
        //            Adjust source length by one as we decrement source offset
        // Note: whitepsace is never trailing byte, so loop will work with DBCS encoded character sets
        while (cbSourceOffset > 0 && strchr(" \t\v\a\f", pfilemap->m_pbStartOfFile[cbSourceOffset - 1]))
            {
            --cbSourceOffset;
            ++cchSourceText;
            }

        // BUG 95859
        // If the cursor is on the opening token of a script block (the "<%" part of a line), the
        // BP is set in the previous HTML, not in the script block, as is desired.
        //
        // To correct this, if we are in a script block, scan back two characters, see if it is the open
        // token.  If it is, set the offset back two, and add two to the length.
        //
        if (!fIsHTML)
            {
            // Skip whitespace (including newlines -- the previous step did not skip newlines)
            //
            ULONG cbOpen = cbSourceOffset;
            while (cbOpen > 0 && strchr(" \t\v\a\f\r\n", pfilemap->m_pbStartOfFile[cbOpen - 1]))
                --cbOpen;

            if (cbOpen >= 2 && strncmp(reinterpret_cast<char *>(&pfilemap->m_pbStartOfFile[cbOpen - 2]), "<%", 2) == 0)
                {
                cbOpen -= 2;
                cchSourceText += cbSourceOffset - cbOpen;
                cbSourceOffset = cbOpen;
                }

            // Look for trailing "%>" in this snippet, and if it exists then include the end delimiter in
            // the length.  NOTE: No DBCS awareness needed here - if we find a lead byte we just get out
            // of the loop.  We are looking for <whitespace>*"%>" which is totally SBCS chars.
            //
            ULONG cbClose = cbSourceOffset + cchSourceText;
            ULONG cbFile = pfilemap->GetSize();
            while (cbClose < cbFile && strchr(" \t\v\a\f\r\n", pfilemap->m_pbStartOfFile[cbClose]))
                ++cbClose;

            if (cbClose < cbFile && strncmp(reinterpret_cast<char *>(&pfilemap->m_pbStartOfFile[cbClose]), "%>", 2) == 0)
                cchSourceText += cbClose - (cbSourceOffset + cchSourceText) + 2;
            }

        // BUG 82222, 85584
        // Compiler marks HTML segments starting with the newline on the previous line
        // if the line ends with %>.
        //
        // This screws up the debugger, becasue when you press <F9>, the pointer is placed
        // on the line above when it should point to the start of the whitespace on the next line.
        if (fIsHTML)
            {
            UINT cbEOF = pfilemap->GetSize(), cbRover = cbSourceOffset;

            // Skip initial whitespace
            while (cbRover < cbEOF && strchr(" \t\a\f", pfilemap->m_pbStartOfFile[cbRover]))
                ++cbRover;

            // If what's left is a CR/LF pair, then advance cbSourceOffset to next line
            BOOL fCR = FALSE, fLF = FALSE;
            if (cbRover < cbEOF && strchr("\r\n", pfilemap->m_pbStartOfFile[cbRover]))
                {
                fCR = pfilemap->m_pbStartOfFile[cbRover] == '\r';
                fLF = pfilemap->m_pbStartOfFile[cbRover] == '\n';

                ++cbRover;
                Assert (fCR || fLF);
                }

            // we allow either <CR>, <LF>, <CR><LF>, or <LF><CR> to terminate a line,
            // so look for its opposite terminator if one is found (but don't require it)

            if (fCR && cbRover < cbEOF && pfilemap->m_pbStartOfFile[cbRover] == '\n')
                ++cbRover;

            if (fLF && cbRover < cbEOF && pfilemap->m_pbStartOfFile[cbRover] == '\r')
                ++cbRover;

            // OK, adjust cbSourceOffset now

            if ((fCR || fLF) && cbRover < cbEOF)
                {
                cchSourceText -= cbRover - cbSourceOffset;  // adjust # of chars to select
                cbSourceOffset = cbRover;
                }
            }

        // Now that we have the source offset, calculate its CCH by finding
        // the last time we sampled the value, then add that to the number
        // of DBCS characters from that point to the current offset.
        //
        // For the case of includes, it's possible offset already exists
        // (if the entry was previously generated by another instance of
        //  #include - therefore we have to search)

        COffsetInfo *pOffsetInfoLE, *pOffsetInfoGE;
        GetBracketingPair(
                        cbSourceOffset,                     // value to find
                        pfilemap->m_rgByte2DBCS.begin(),    // beginning of array
                        pfilemap->m_rgByte2DBCS.end(),      // end of array
                        CByteOffsetOrder(),                 // search for byte offset
                        &pOffsetInfoLE, &pOffsetInfoGE      // return values
                        );

        // If we find an equal match, don't insert any duplicates
        if (pOffsetInfoLE == NULL || pOffsetInfoLE->m_cbOffset < cbSourceOffset)
            {
            // if pOffsetInfoLE is NULL, it means that the array is empty -
            // create the mapping of offset 0 to offset 0.
            //
            // In the case of the first line of a file being an include directive,
            // the first executable line from the file may not start at offset zero,
            // so in this case we need to create this entry AND execute the next "if"
            // block.
            //
            if (pOffsetInfoLE == NULL)
                {
                COffsetInfo oiZero;         // ctor will init
                if (FAILED(hr = pfilemap->m_rgByte2DBCS.append(oiZero)))
                    THROW(hr);
                pOffsetInfoLE = pfilemap->m_rgByte2DBCS.begin();
                Assert (pOffsetInfoLE != NULL);
                }

            // If cbSourceOffset is zero, we handled it above
            if (cbSourceOffset != 0)
                {
                cchSourceOffset = pOffsetInfoLE->m_cchOffset +
                                    CharAdvDBCS
                                     (
                                     (WORD)m_wCodePage,
                                     reinterpret_cast<char *>(pfilemap->m_pbStartOfFile + pOffsetInfoLE->m_cbOffset),
                                     reinterpret_cast<char *>(pfilemap->m_pbStartOfFile + cbSourceOffset),
                                     INFINITE,
                                     NULL
                                     );

                // Now add the value to the table
                COffsetInfo oi;

                oi.m_cchOffset = cchSourceOffset;
                oi.m_cbOffset  = cbSourceOffset;

                if (pOffsetInfoGE == NULL)              // No offset greater
                    hr = pfilemap->m_rgByte2DBCS.append(oi);
                else
                    hr = pfilemap->m_rgByte2DBCS.insertAt(DIFF(pOffsetInfoGE - pfilemap->m_rgByte2DBCS.begin()), oi);

                if (FAILED(hr))
                    THROW(hr);
                }
            }
        else
            {
            // If we're not adding anything for the table, Assert it's because there's
            // a duplicate item
            Assert (cbSourceOffset == pOffsetInfoLE->m_cbOffset);
            cchSourceOffset = pOffsetInfoLE->m_cchOffset;
            }
        }

        UINT cchTargetOffset = UINT_MAX;
        if (cbTargetOffset != UINT_MAX)
                {
                // ptr to start of script is:
                //           ptr start of template + offset to script    + size of script length
                LPSTR szScript = (LPSTR) m_pbStart + cbScriptBlockOffset;

                // Calculate cchTargetOffset (have the cb).  The cch is the number of characters since the
                // last cch calculated in the end of the array.
                //
                if (prgSourceInfos->length() > 0)
                        cchTargetOffset = (*prgSourceInfos)[prgSourceInfos->length() - 1].m_cchTargetOffset;
                else
                        cchTargetOffset = 0;

                cchTargetOffset += CharAdvDBCS
                                                         (
                                                         (WORD) m_wCodePage,
                                                         &szScript[m_cbTargetOffsetPrevT],
                                                         &szScript[cbTargetOffset],
                                                         INFINITE,
                                                         NULL
                                                         );

                // Keeps track of offsets during compilation
                //
                m_cbTargetOffsetPrevT = cbTargetOffset;
                }

    // Store this record and move on.
    //
    si.m_pfilemap        = pfilemap;
    si.m_fIsHTML         = fIsHTML;
    si.m_cchSourceOffset = cchSourceOffset;
    si.m_cchTargetOffset = cchTargetOffset;
    si.m_cchSourceText   = cchSourceText;

    if (FAILED(prgSourceInfos->append(si)))
        THROW(hr);
    }

/*  ============================================================================
    CTemplate::SourceLineNumberFromPb
    Returns the starting source line number for the given source file location
*/
UINT
CTemplate::SourceLineNumberFromPb
(
CFileMap*   pfilemap,   // ptr to source file map
BYTE*       pbSource    // ptr to current location in source file
)
    {
    UINT        cSourceLines = 1;   // count of lines into source file
    CByteRange  brScan;             // byte range to scan for newlines
    CByteRange  brSOL;              // start-of-line ptr

    if(pbSource == NULL || pfilemap == NULL)
        return 0;

    // set scan range to run from start-of-template to caller's ptr
    brScan.m_pb = pfilemap->m_pbStartOfFile;
    brScan.m_cb = max(DIFF(pbSource - brScan.m_pb), 0);
   
    // get newlines in scan range
    brSOL = BrNewLine(brScan);
    
    while(!brSOL.IsNull())
    {
        // advance start-of-line ptr and scan byte range
        brScan.Advance(DIFF((brSOL.m_pb + brSOL.m_cb) - brScan.m_pb));

        // increment source line counter
        cSourceLines++;    

        // find next newline
        brSOL = BrNewLine(brScan);
    }
   
    return cSourceLines;
    }

/*  ============================================================================
    CTemplate::RemoveFromIncFiles
    Removes this template from inc-files on which it depends

    Returns:
        Nothing
    Side effects:
        None
*/
void
CTemplate::RemoveFromIncFiles
(
)
    {
    // NOTE we loop from 1 to count, since 0-th filemap is for main file
    for(UINT i = 1; i < m_cFilemaps; i++)
        {
        if(NULL != m_rgpFilemaps[i]->m_pIncFile)
            m_rgpFilemaps[i]->m_pIncFile->RemoveTemplate(this);
        }
    }

/*  ****************************************************************************
    IDebugDocumentProvider implementation
*/

/*  ============================================================================
    CTemplate::GetDocument
    Return a pointer to the IDebugDocument implementation. (same object in this case)

    Returns:
        *ppDebugDoc is set to "this".
    Notes:
        always succeeds
*/
HRESULT CTemplate::GetDocument
(
IDebugDocument **ppDebugDoc
)
    {
    return QueryInterface(IID_IDebugDocument, reinterpret_cast<void **>(ppDebugDoc));
    }

/*  ============================================================================
    CTemplate::GetName
    Return the various names of a document.
*/

HRESULT CTemplate::GetName
(
/* [in] */ DOCUMENTNAMETYPE doctype,
/* [out] */ BSTR *pbstrName
)
{
    TCHAR *szPathInfo = m_rgpFilemaps[0]->m_szPathInfo;
    switch (doctype) {
        case DOCUMENTNAMETYPE_APPNODE:
        case DOCUMENTNAMETYPE_FILE_TAIL:
        case DOCUMENTNAMETYPE_TITLE:
            // Skip application path portion of the filename
        {
            // Make sure the template remembers the virtual path
            // from the same application (it could be different
            // if template is shared between two applications)
            //
            int cch = _tcslen(m_szApplnVirtPath);
            if (_tcsncicmp(szPathInfo, m_szApplnVirtPath, cch) == 0)
                szPathInfo += cch;

            // Strip leading '/'
            if (*szPathInfo == _T('/'))
                szPathInfo++;
#if UNICODE
            *pbstrName = SysAllocString(szPathInfo);
            if (*pbstrName == NULL)
                return E_OUTOFMEMORY;
            return S_OK;
#else
            return SysAllocStringFromSz(szPathInfo, 0, pbstrName, m_wCodePage);
#endif
        }

        case DOCUMENTNAMETYPE_URL:
            // prefix with the URL, use szPathInfo for the rest of the path
        {
            STACK_BUFFER( tempName, MAX_PATH );

            int cbURLPrefix = DIFF(m_szApplnVirtPath - m_szApplnURL) * sizeof (TCHAR);
            if (!tempName.Resize(cbURLPrefix + (_tcslen(szPathInfo)*sizeof(TCHAR)) + sizeof(TCHAR))) {
                return E_OUTOFMEMORY;
            }

            TCHAR *szURL = (TCHAR *)tempName.QueryPtr();

            memcpy(szURL, m_szApplnURL, cbURLPrefix);
            _tcscpy(&szURL[cbURLPrefix/sizeof(TCHAR)], szPathInfo);

#if UNICODE
            *pbstrName = SysAllocString(szURL);
            if (*pbstrName == NULL)
                return E_OUTOFMEMORY;
            return S_OK;
#else
            return SysAllocStringFromSz(szURL, 0, pbstrName, m_wCodePage);
#endif
        }

        default:
            return E_FAIL;
    }
}

/*  ****************************************************************************
    IDebugDocumentText implementation
*/

/*  ============================================================================
    CTemplate::GetSize
    Return the number of lines & characters in the document
*/
HRESULT CTemplate::GetSize
(
/* [out] */ ULONG *pcLines,
/* [out] */ ULONG *pcChars
)
    {
    /*
     * NOTE: compilation is done in two phases.
     *          Errors are detected and reported in phase 1.
     *          The DBCS mapping is created in phase 2.
     *
     * If an error occurred during compilation, m_cChars will be equal to zero
     * (Since zero length files are not compiled, m_cChars == 0 means "size
     * is unknown", not "size is zero").
     */
    if (m_rgpFilemaps[0]->m_cChars == 0)
        {
        // Likely need to remap the file, then count
        BOOL fRemapTemplate = !m_rgpFilemaps[0]->FIsMapped();
        if (fRemapTemplate)
            TRY
                m_rgpFilemaps[0]->RemapFile();
            CATCH (dwException)
                return E_FAIL;
            END_TRY

        m_rgpFilemaps[0]->CountChars((WORD)m_wCodePage);

        if (fRemapTemplate)
            TRY
                m_rgpFilemaps[0]->UnmapFile();
            CATCH (dwException)
                return E_FAIL;
            END_TRY

        // let's hope client is not relying on # of lines - expensive to compute

        *pcChars = m_rgpFilemaps[0]->m_cChars;
        *pcLines = ULONG_MAX;
        }
    else
        {
        /* The last line in the line mapping array of each engine is the <<EOF>> line
         * for that engine.  Therefore, the # of lines is the largest <<EOF>> line
         * number - 1.  The EOF line always points into the main file, so there are no
         * include file glitches here.
         */
        ULONG cLinesMax = 0;
        for (UINT i = 0; i < m_cScriptEngines; ++i)
            {
            ULONG cLinesCurrentEngine = m_rgrgSourceInfos[0][m_rgrgSourceInfos[0].length() - 1].m_idLine - 1;
            if (cLinesCurrentEngine > cLinesMax)
                cLinesMax = cLinesCurrentEngine;
            }

        *pcLines = cLinesMax;
        *pcChars = m_rgpFilemaps[0]->m_cChars;
        }

    IF_DEBUG(SCRIPT_DEBUGGER) {
#if UNICODE
		DBGPRINTF((DBG_CONTEXT, "GetSize(\"%S\") returns %lu characters (%lu lines)\n", m_rgpFilemaps[0]->m_szPathTranslated, *pcChars, *pcLines));
#else
		DBGPRINTF((DBG_CONTEXT, "GetSize(\"%s\") returns %lu characters (%lu lines)\n", m_rgpFilemaps[0]->m_szPathTranslated, *pcChars, *pcLines));
#endif
    }

    return S_OK;
}

/*  ============================================================================
    CTemplate::GetDocumentAttributes
    Return doc attributes
*/
HRESULT CTemplate::GetDocumentAttributes
(
/* [out] */ TEXT_DOC_ATTR *ptextdocattr
)
    {
    // Easy way to tell debugger that we don't support editing.
    *ptextdocattr = TEXT_DOC_ATTR_READONLY;
    return S_OK;
    }

/*  ============================================================================
    CTemplate::GetPositionOfLine
    From a line number, return the character offset of the beginning
*/
HRESULT CTemplate::GetPositionOfLine
(
/* [in] */ ULONG cLineNumber,
/* [out] */ ULONG *pcCharacterPosition
)
    {
    return GetPositionOfLine(m_rgpFilemaps[0], cLineNumber, pcCharacterPosition);
    }

/*  ============================================================================
    CTemplate::GetLineOfPosition
    From a character offset, return the line number and offset within the line
*/
HRESULT CTemplate::GetLineOfPosition
(
/* [in] */ ULONG cCharacterPosition,
/* [out] */ ULONG *pcLineNumber,
/* [out] */ ULONG *pcCharacterOffsetInLine
)
    {
    return GetLineOfPosition(m_rgpFilemaps[0], cCharacterPosition, pcLineNumber, pcCharacterOffsetInLine);
    }

/*  ============================================================================
    CTemplate::GetText
    From a character offset and length, return the document text
*/
HRESULT CTemplate::GetText
(
ULONG cchSourceOffset,
WCHAR *pwchText,
SOURCE_TEXT_ATTR *pTextAttr,
ULONG *pcChars,
ULONG cMaxChars
)
    {
    return m_rgpFilemaps[0]->GetText((WORD)m_wCodePage, cchSourceOffset, pwchText, pTextAttr, pcChars, cMaxChars);
    }

/*  ============================================================================
    CTemplate::GetPositionOfContext
    Decompose a document context into the document offset & length
*/
HRESULT CTemplate::GetPositionOfContext
(
/* [in] */ IDebugDocumentContext *pUnknownDocumentContext,
/* [out] */ ULONG *pcchSourceOffset,
/* [out] */ ULONG *pcchText
)
    {
    // Make sure that the context is one of ours
    CTemplateDocumentContext *pDocumentContext;
    if (FAILED(pUnknownDocumentContext->QueryInterface(IID_IDenaliTemplateDocumentContext, reinterpret_cast<void **>(&pDocumentContext))))
        return E_FAIL;

    if (pcchSourceOffset)
        *pcchSourceOffset = pDocumentContext->m_cchSourceOffset;

    if (pcchText)
        *pcchText = pDocumentContext->m_cchText;

    pDocumentContext->Release();
    return S_OK;
    }

/*  ============================================================================
    CTemplate::GetContextOfPosition
    Given the character position & number of characters in the document,
    encapsulate this into a document context object.
*/
HRESULT CTemplate::GetContextOfPosition
(
/* [in] */ ULONG cchSourceOffset,
/* [in] */ ULONG cchText,
/* [out] */ IDebugDocumentContext **ppDocumentContext
)
    {
    if (
        (*ppDocumentContext = new CTemplateDocumentContext(this, cchSourceOffset, cchText))
        == NULL
       )
        return E_OUTOFMEMORY;

    return S_OK;
    }

/*  ****************************************************************************
    IConnectionPointContainer implementation
*/

/*  ============================================================================
    CTemplate::FindConnectionPoint
    From a character offset and length, return the document text
*/
HRESULT CTemplate::FindConnectionPoint
(
const GUID &uidConnection,
IConnectionPoint **ppCP
)
    {
    if (uidConnection == IID_IDebugDocumentTextEvents)
        return m_CPTextEvents.QueryInterface(IID_IConnectionPoint, reinterpret_cast<void **>(ppCP));
    else
        {
        *ppCP = NULL;
        return E_NOINTERFACE;
        }
    }

/*  ============================================================================
    CTemplate::AttachTo
    attach this to the debugger UI tree view.
*/
HRESULT CTemplate::AttachTo
(
CAppln *pAppln
)
    {
    if (!m_fDontAttach && pAppln->FDebuggable())
        {
        // If we are already attached to this application, then ignore 2nd request
        CDblLink *pNodeCurr = m_listDocNodes.PNext();
        while (pNodeCurr != &m_listDocNodes)
            {
            if (pAppln == static_cast<CDocNodeElem *>(pNodeCurr)->m_pAppln)
                return S_OK;

            pNodeCurr = pNodeCurr->PNext();
            }

        // Create the node and store it in the linked list.
        HRESULT hr;
        IDebugApplicationNode *pDocRoot;
        CDocNodeElem *pDocNodeElem;

        // Create a document tree, showing the include file hierarchy
        if (FAILED(hr = CreateDocumentTree(m_rgpFilemaps[0], &pDocRoot)))
            return hr;

        if (FAILED(hr = pDocRoot->Attach(pAppln->PAppRoot())))
            return hr;

        if ((pDocNodeElem = new CDocNodeElem(pAppln, pDocRoot)) == NULL)
            return E_OUTOFMEMORY;

        pDocNodeElem->AppendTo(m_listDocNodes);
        pDocRoot->Release();
        m_fDebuggable = TRUE;
        }

    return S_OK;
    }

/*  ============================================================================
    CTemplate::DetachFrom
    detach this from the debugger UI tree view.
*/
HRESULT CTemplate::DetachFrom
(
CAppln *pAppln
)
    {
    // Enter the CS to prevent Detach() from detaching while we are scanning
    // the list (causes application ptr to be deleted twice if this occurs)
    DBG_ASSERT(m_fDebuggerDetachCSInited);
    EnterCriticalSection(&m_csDebuggerDetach);

    // Look for the node that has this application
    CDblLink *pNodeCurr = m_listDocNodes.PNext();
    while (pNodeCurr != &m_listDocNodes)
        {
        if (pAppln == static_cast<CDocNodeElem *>(pNodeCurr)->m_pAppln)
            break;

        pNodeCurr = pNodeCurr->PNext();
        }

    // If not found (pNodeCurr points back to head), then fail
    if (pNodeCurr == &m_listDocNodes)
        {
        LeaveCriticalSection(&m_csDebuggerDetach);
        return E_FAIL;
        }

    // Detach the node by deleting the current element
    delete pNodeCurr;

    // Turn off "Debuggable" flag if last application is detached
    m_fDebuggable = !m_listDocNodes.FIsEmpty();

    // At this point CS not needed
    LeaveCriticalSection(&m_csDebuggerDetach);

    // If we have just removed ourselves from the last application,
    // then we call Detach(), to remove all cached script engines now.
    if (!m_fDebuggable)
         Detach();

    return S_OK;
    }

/*  ============================================================================
    CTemplate::Detach
    detach this from the debugger UI tree view.
*/
HRESULT CTemplate::Detach
(
)
    {
    // Enter the CS to prevent DetachFrom() from detaching while we are clearing
    // the list (causes application ptr to be deleted twice if this occurs)
    if (m_fDebuggerDetachCSInited)
                EnterCriticalSection(&m_csDebuggerDetach);

    // Detach all nodes
    while (! m_listDocNodes.FIsEmpty())
        delete m_listDocNodes.PNext();

    // Done with CS
    if (m_fDebuggerDetachCSInited)
                LeaveCriticalSection(&m_csDebuggerDetach);

    // Since we are not debuggable now, remove any script engines we may
    // be holding on to.  If we are detaching from change notification
    // thread, queue engines to be released from debugger thread.
    //
    if (m_rgpDebugScripts)
        {
        Assert (g_dwDebugThreadId != 0);
        BOOL fCalledFromDebugActivity = GetCurrentThreadId() == g_dwDebugThreadId;

        for (UINT i = 0; i < m_cScriptEngines; i++)
            {
            CActiveScriptEngine *pEngine = m_rgpDebugScripts[i];
            if (pEngine)
                {
                if (fCalledFromDebugActivity)
                    {
                    pEngine->FinalRelease();
                    }
                else
                    {
                    g_ApplnMgr.AddEngine(pEngine);
                    pEngine->Release();
                    }
                }
            }
        delete[] m_rgpDebugScripts;
        m_rgpDebugScripts = NULL;
        }

    m_fDebuggable = FALSE;
    return S_OK;
    }

/*  ============================================================================
    CTemplate::CreateDocumentTree
    Traverse the tree that we have embedded in the filemap structures,
    and use it to create the include file structure
*/
HRESULT CTemplate::CreateDocumentTree
(
CFileMap *pfilemapRoot,
IDebugApplicationNode **ppDocRoot
)
    {
    IDebugApplicationNode *pDocNode;
    HRESULT hr = S_OK;

    if (pfilemapRoot == NULL || ppDocRoot == NULL)
        return E_POINTER;

    // Create the root node
    if (FAILED(hr = g_pDebugApp->CreateApplicationNode(ppDocRoot)))
        return hr;

    // From the filemap information, match it up with the correct provider
    //  "This" is the provider for the root document, others come from Inc file cache
    if (pfilemapRoot == m_rgpFilemaps[0])
        {
        if (FAILED(hr = (*ppDocRoot)->SetDocumentProvider(this)))
            return hr;
        }
    else
        {
        CIncFile *pIncFile;
        if (FAILED(hr = g_IncFileMap.GetIncFile(pfilemapRoot->m_szPathTranslated, &pIncFile)))
            return hr;

        if (FAILED(hr = (*ppDocRoot)->SetDocumentProvider(pIncFile)))
            return hr;

        // SetDocumentProvider AddRef'ed
        pIncFile->Release();
        }

    // Create a node from all of the children and attach it to this node
    CFileMap *pfilemapChild = pfilemapRoot->m_pfilemapChild;
    while (pfilemapChild != NULL)
        {
        IDebugApplicationNode *pDocChild;
        if (FAILED(hr = CreateDocumentTree(pfilemapChild, &pDocChild)))
            return hr;

        if (FAILED(hr = pDocChild->Attach(*ppDocRoot)))
            return hr;

        pfilemapChild = pfilemapChild->m_fHasSibling? pfilemapChild->m_pfilemapSibling : NULL;
        }

    return S_OK;
    }

/*  ============================================================================
    CTemplate::End

    Place template in non-usable state (after this is called, last ref. should
    be the any currently executing scripts.  The count will naturally vanish
    as the scripts finish.  The template should never be recycled in cache after
    this call.)

    REF COUNTING NOTE:
        Since debugging client has a reference to the template, the template needs
        to dis-associate with the debugger at a point in time before destruction.
        Otherwise, the reference will never go to zero.
*/
ULONG
CTemplate::End
(
)
    {
    // Flag template as non-usable (for debugging)
    m_fIsValid = FALSE;

    Detach();

    if (!m_CPTextEvents.FIsEmpty() && g_pDebugApp != NULL)
        {
        IEnumConnections *pConnIterator;
        if (SUCCEEDED(m_CPTextEvents.EnumConnections(&pConnIterator)))
            {
            CONNECTDATA ConnectData;
            while (pConnIterator->Next(1, &ConnectData, NULL) == S_OK)
                {
                IDebugDocumentTextEvents *pTextEventSink;
                if (SUCCEEDED(ConnectData.pUnk->QueryInterface(IID_IDebugDocumentTextEvents, reinterpret_cast<void **>(&pTextEventSink))))
                    {
                    InvokeDebuggerWithThreadSwitch(g_pDebugApp, DEBUGGER_ON_DESTROY, pTextEventSink);
                    pTextEventSink->Release();
                    }
                ConnectData.pUnk->Release();
                }

            pConnIterator->Release();
            }
        }

    return Release();
    }

/*  ============================================================================
    CTemplate::NotifyDebuggerOnPageEvent
    Let debugger know about page start/end
*/
HRESULT
CTemplate::NotifyDebuggerOnPageEvent
(
BOOL fStart     // TRUE = StartPage, FALSE = EndPage
)
    {
    CTemplateDocumentContext *pDebugContext = new CTemplateDocumentContext(this, 0, 0);
    if (pDebugContext == NULL)
        return E_OUTOFMEMORY;

    HRESULT hr = S_OK;

    if (g_pDebugApp)
        hr = InvokeDebuggerWithThreadSwitch
            (
            g_pDebugApp,
            fStart ? DEBUGGER_EVENT_ON_PAGEBEGIN : DEBUGGER_EVENT_ON_PAGEEND,
            static_cast<IUnknown *>(pDebugContext)
            );

    pDebugContext->Release();
    return hr;
    }

/*  ============================================================================
    CTemplate::ReleaseTypeLibs
    Release all typelibs collected from metadata
*/
void
CTemplate::ReleaseTypeLibs()
    {
    if (m_rgpTypeLibs.length() > 0)
        {
        for (UINT i = 0; i < m_rgpTypeLibs.length(); i++)
            {
            m_rgpTypeLibs[i]->Release();
            }

        m_rgpTypeLibs.reshape(0);
        }
    }

/*  ============================================================================
    CTemplate::WrapTypeLibs
    Wrap all typelibs collected from metadata into single IDispatch *
*/
void
CTemplate::WrapTypeLibs(CHitObj *pHitObj)
    {
    HRESULT hr = S_OK;

    Assert(m_pdispTypeLibWrapper == NULL);

    if (m_rgpTypeLibs.length() > 0)
        {
        hr = ::WrapTypeLibs
            (
            m_rgpTypeLibs.begin(),
            m_rgpTypeLibs.length(),
            &m_pdispTypeLibWrapper
            );

        ReleaseTypeLibs();
        }

    if (FAILED(hr))
        {
        m_pbErrorLocation = NULL;
        m_idErrMsg = IDE_TEMPLATE_WRAP_TYPELIB_FAILED;
        ProcessSpecificError(*(m_rgpFilemaps[0]), pHitObj);
        THROW(E_TEMPLATE_COMPILE_FAILED_DONT_CACHE);
        }
    }

/*  ============================================================================
    CTemplate::Release449
    Release all 449-echo-cookie objects collected from metadata
*/
void
CTemplate::Release449()
    {
    if (m_rgp449.length() > 0)
        {
        for (UINT i = 0; i < m_rgp449.length(); i++)
            {
            m_rgp449[i]->Release();
            }

        m_rgp449.reshape(0);
        }
    }

/*  ============================================================================
    CTemplate::Do449Processing
    Generate 449 response in cookie negotiations with IE when needed
*/
HRESULT
CTemplate::Do449Processing
(
CHitObj *pHitObj
)
    {
    if (m_rgp449.length() == 0 || pHitObj->F449Done())
        return S_OK;

    HRESULT hr = ::Do449Processing
        (
        pHitObj,
        m_rgp449.begin(),
        m_rgp449.length()
        );

    pHitObj->Set449Done();
    return hr;
    }
#if 0
/*  ============================================================================
    CTemplate::OutputDebugTables
    print the debugging data structures to the debug window
*/
void
CTemplate::OutputDebugTables()
    {
    unsigned        i, j;
    wchar_t         wszDebugLine[256];
    CWCharToMBCS    convTarget;
    CWCharToMBCS    convSource;

    // print line mapping table

    DBGPRINTF((DBG_CONTEXT, "\nEngine HTML? Line# SourceOffset Length TargetOffset TargetText__________ SourceText__________ File\n"));

    for (i = 0; i < m_cScriptEngines; ++i)
        for (j = 0; j < m_rgrgSourceInfos[i].length(); ++j)
            {
            wchar_t wszSourceText[SNIPPET_SIZE + 1], wszTargetText[SNIPPET_SIZE + 1];
            CSourceInfo *pSourceInfo = &m_rgrgSourceInfos[i][j];

            // DON'T display sample script text on last line of each engine
            if (j == m_rgrgSourceInfos[i].length() - 1)
                {
                wszTargetText[0] = 0;
                wszSourceText[0] = 0;
                }
            else
                {
                // Get source & target text sample
                GetScriptSnippets(
                                pSourceInfo->m_cchSourceOffset, pSourceInfo->m_pfilemap,
                                pSourceInfo->m_cchTargetOffset, i,
                                wszSourceText, wszTargetText
                                 );

                // Actually display each line
#if 0
#ifndef _NO_TRACING_
                convTarget.Init(wszTargetText);
                convSource.Init(wszSourceText);

                DBGINFO((DBG_CONTEXT,
                         "%-6d %-5s %-5d %-12d %-6d %-12d %-20s %-20s %s\n",
                         i,
                         pSourceInfo->m_fIsHTML? "Yes" : "No",
                         pSourceInfo->m_idLine,
                         pSourceInfo->m_cchSourceOffset,
                         pSourceInfo->m_cchSourceText,
                         pSourceInfo->m_cchTargetOffset,
                         convTarget.GetString(),
                         convSource.GetString(),
                         pSourceInfo->m_pfilemap->m_szPathTranslated));
#else
                CMBCSToWChar    convPath;
                convPath.Init(pSourceInfo->m_pfilemap->m_szPathTranslated);
                wsprintfW(
                        wszDebugLine,
                        L"%-6d %-5s %-5d %-12d %-6d %-12d %-20s %-20s %s\n",
                        i,
                        pSourceInfo->m_fIsHTML? L"Yes" : L"No",
                        pSourceInfo->m_idLine,
                        pSourceInfo->m_cchSourceOffset,
                        pSourceInfo->m_cchSourceText,
                        pSourceInfo->m_cchTargetOffset,
                        wszTargetText,
                        wszSourceText,
                        convPath.GetString());

                OutputDebugStringW(wszDebugLine);
#endif
#endif
            }
            }

        OutputDebugStringA("\n\n");

    for (i = 0; i < m_cFilemaps; ++i)
        {
        CFileMap *pFilemap = m_rgpFilemaps[i];

#if UNICODE
        DBGPRINTF((DBG_CONTEXT, "DBCS mapping table for File %S:\n", pFilemap->m_szPathTranslated));
#else
        DBGPRINTF((DBG_CONTEXT, "DBCS mapping table for File %s:\n", pFilemap->m_szPathTranslated));
#endif
        DBGPRINTF((DBG_CONTEXT, "ByteOffset CharOffset\n"));

        for (COffsetInfo *pOffsetInfo = pFilemap->m_rgByte2DBCS.begin();
             pOffsetInfo < pFilemap->m_rgByte2DBCS.end();
             ++pOffsetInfo)
            DebugPrintf("%-10d %-10d\n", pOffsetInfo->m_cbOffset, pOffsetInfo->m_cchOffset);

        DBGPRINTF((DBG_CONTEXT, "\n\n"));
    }

    DBGPRINTF((DBG_CONTEXT, "Include File Hierarchy\n"));
    OutputIncludeHierarchy(m_rgpFilemaps[0], 0);
    DBGPRINTF((DBG_CONTEXT, "\n"));
}

/*  ============================================================================
    CTemplate::OutputIncludeHierarchy
    print the lineage information that we keep around for include files.
    Print all nodes on one level at the current indentation, then descend for
    nested includes.
*/

void
CTemplate::OutputIncludeHierarchy
(
CFileMap*   pfilemap,
int         cchIndent
)
    {
    TCHAR szDebugString[256], *pchEnd;

    for (;;)
        {
        pchEnd = szDebugString;
        for (int i = 0; i < cchIndent; ++i)
            *pchEnd++ = _T(' ');

        pchEnd = strcpyEx(pchEnd, pfilemap->m_szPathTranslated);
        *pchEnd++ = _T('\n');
        *pchEnd = _T('\0');

        DBGPRINTF((DBG_CONTEXT, szDebugString));

        // Print anything that this file includes
        if (pfilemap->m_pfilemapChild)
            OutputIncludeHierarchy(pfilemap->m_pfilemapChild, cchIndent + 3);

        // Stop when there are no more siblings on this level
        if (! pfilemap->m_fHasSibling)
            break;

        // Advance to next sibling
        pfilemap = pfilemap->m_pfilemapSibling;
        }
    }

/*  ============================================================================
    CTemplate::OutputScriptSnippets
    print some script from both the source offset & its corresponding target.
    Good way to visually see if the offset conversions are working.
*/

void
CTemplate::GetScriptSnippets
(
ULONG cchSourceOffset,
CFileMap *pFilemapSource,
ULONG cchTargetOffset,
ULONG idTargetEngine,
wchar_t *wszSourceText,
wchar_t *wszTargetText
)
    {
    // Get target text sample
    if (wszTargetText)
        {
        char *szEngineName;
        PROGLANG_ID *pProgLangID;
        const wchar_t *wszScriptText;

        GetScriptBlock(idTargetEngine, &szEngineName, &pProgLangID, &wszScriptText);
        wszScriptText += cchTargetOffset;
        int cch = wcslen(wszScriptText);
        wcsncpy(wszTargetText, wszScriptText, min(cch, SNIPPET_SIZE) + 1);
        wszTargetText[min(cch, SNIPPET_SIZE)] = 0;

        // Convert newlines to space
        wchar_t *pwch = wszTargetText;
        while (*pwch != 0)
            if (iswspace(*pwch++))
                pwch[-1] = ' ';
        }

    // Get source text sample
    if (wszSourceText)
        {
        ULONG cchMax = 0;
        pFilemapSource->GetText((WORD)m_wCodePage, cchSourceOffset, wszSourceText, NULL, &cchMax, SNIPPET_SIZE);
        wszSourceText[cchMax] = 0;

        // Convert newlines to space
        wchar_t *pwch = wszSourceText;
        while (*pwch != 0)
            if (iswspace(*pwch++))
                pwch[-1] = ' ';
        }
    }
#endif
/*  ============================================================================
    CTemplate::BuildPersistedDACL

    Builds a DACL based on the SECURITY_DESCRIPTOR already
    associated with the template.  The PersistedDACL is modified to include
    full access for administrators and delete access for everyone.
*/

HRESULT  CTemplate::BuildPersistedDACL(PACL  *ppRetDACL)
{
    HRESULT                     hr = S_OK;
    BOOL                        bDaclPresent;
    BOOL                        bDaclDefaulted;
    PACL                        pSrcDACL = NULL;
    EXPLICIT_ACCESS             ea;
    SID_IDENTIFIER_AUTHORITY    WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;

    *ppRetDACL = NULL;

    ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));

    ea.grfAccessPermissions = SYNCHRONIZE | DELETE;
    ea.grfAccessMode = GRANT_ACCESS;
    ea.grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;

    if (m_rgpFilemaps[0]->m_pSecurityDescriptor == NULL) {
        return S_OK;
    }

    if (!AllocateAndInitializeSid(&WorldAuthority,
                                  1,
                                  SECURITY_WORLD_RID,
                                  0,0,0,0,0,0,0,
                                  (PSID *)(&ea.Trustee.ptstrName)))

        hr = HRESULT_FROM_WIN32(GetLastError());

    else if (!GetSecurityDescriptorDacl(m_rgpFilemaps[0]->m_pSecurityDescriptor,
                                   &bDaclPresent,
                                   &pSrcDACL,
                                   &bDaclDefaulted))

        hr = HRESULT_FROM_WIN32(GetLastError());

    else if ((hr = SetEntriesInAcl(1, 
                                   &ea, 
                                   bDaclPresent ? pSrcDACL : NULL, 
                                   ppRetDACL)) != ERROR_SUCCESS)

        hr = HRESULT_FROM_WIN32(hr);

    if (ea.Trustee.ptstrName)
        FreeSid(ea.Trustee.ptstrName);

    return hr;
}

/*  ============================================================================
    CTemplate::PersistData
    Attempts to write the contents of the template memory to disk.  Note that
    the memory isn't freed here but later when the template ref count falls to
    1 (indicating that the only reference to the template is the one that the
    cache has on it).
*/

HRESULT  CTemplate::PersistData(char    *pszTempFilePath)
{
    HRESULT                 hr = S_OK;
    DWORD                   winErr = 0;
    HANDLE                  hFile = NULL;
    DWORD                   dwWritten;
    HANDLE                  hImpersonationToken = NULL;
    HANDLE                  hThread;
    PACL                    pPersistDACL = NULL;

#if DBG_PERSTEMPL    
    DBGPRINTF((DBG_CONTEXT, 
               "CTemplate::PersistData() enterred.\n\tTemplate is %s\n\tPersistTempName is %s\n",
               GetSourceFileName(),
               m_szPersistTempName ? m_szPersistTempName : "<none>"));
#endif
              
    // if for some reason this template has been marked as invalid, then it is
    // not persistable

    if (m_fIsValid == FALSE) {
        hr = E_FAIL;
        goto end;
    }

    // if it is already persisted, there is nothing to do

    if (m_fIsPersisted) {
        goto end;
    }

    // check to see if we already have a persist temp name.  If a template moves
    // from the persisted cache back to the memory cache, then the persisted flag
    // will have been lifted but the cache name will remain as an optimization for
    // future persisting.

    if (m_szPersistTempName == NULL) {

        hThread = GetCurrentThread();

        if (OpenThreadToken( hThread,
                             TOKEN_READ | TOKEN_IMPERSONATE,
                             TRUE,           
                             &hImpersonationToken )) {

           RevertToSelf();
        }

        // allocate memory for this temp path
    
        if (!(m_szPersistTempName = (LPSTR)CTemplate::LargeMalloc(MAX_PATH))) {
            hr = E_OUTOFMEMORY;
        }

        // create the temp file.  The location of the temp directory was passed
        // in as an argument.  The resulting tempfile name in m_szPersistTempName
        // will include this path.

        else if (GetTempFileNameA(pszTempFilePath,
                                 "ASPTemplate",
                                 0,
                                 m_szPersistTempName) == 0) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        // build a security descriptor to use with this persisted file.  It is
        // comprised of the .asp's security descriptor plus a couple of DACLs
        // to allow administrators full access and everyone delete access.

        else if (FAILED(hr = BuildPersistedDACL(&pPersistDACL)));

        else if (pPersistDACL
                 && (winErr = SetNamedSecurityInfoA((LPSTR)m_szPersistTempName,
                                                    SE_FILE_OBJECT,
                                                    DACL_SECURITY_INFORMATION,
                                                    NULL,
                                                    NULL,
                                                    pPersistDACL,
                                                    NULL)))
            hr = HRESULT_FROM_WIN32(winErr);

        // create the file

        else if ((hFile = CreateFileA(m_szPersistTempName, 
                                     GENERIC_WRITE,
                                     0,
                                     NULL,
                                     CREATE_ALWAYS,
                                     FILE_ATTRIBUTE_NORMAL,
                                     NULL)) == INVALID_HANDLE_VALUE) {

            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        // slam out the entire contents of the template memory to the file

        else if (WriteFile(hFile,
                           m_pbStart,
                           m_cbTemplate,
                           &dwWritten,
                           NULL) == 0) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        // close

        else if (CloseHandle(hFile) == 0) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else {
            hFile = NULL;
        }
        if (FAILED(hr));

        // make sure that the entire amount was written out

        else if (dwWritten != m_cbTemplate) {
            hr = E_FAIL;
        }

        if (hImpersonationToken) {
            SetThreadToken(&hThread, hImpersonationToken);
            CloseHandle(hImpersonationToken);
        }
    }
    
    if (FAILED(hr));

    else {

        // if successfull, then note that the template is now persisted.
        // Do an AddRef and Release as a safe way to check to see if the
        // template memory can be freed.
        
        m_fIsPersisted = TRUE;
        AddRef();
        Release();
    }
    
    // if errors occurred, clean up any resources.

    if (hr != S_OK) {
        if (hFile)
            CloseHandle(hFile);
        if (m_szPersistTempName)
            CTemplate::LargeFree(m_szPersistTempName);
        m_szPersistTempName = NULL;
    }

    // free the persisted SECURITY_DESCRIPTOR if allocated

    if (pPersistDACL) {
        LocalFree(pPersistDACL);
    }

end:

#if DBG_PERSTEMPL
    if (hr == S_OK) {
        DBGPRINTF((DBG_CONTEXT,
                   "Persist Successful.  TempName is %s\n",
                   m_szPersistTempName));
    }
    else {
        DBGPRINTF((DBG_CONTEXT,
                   "Persist failed.  hr = %x",
                   hr));
    }
#endif

    return hr;
}

/*  ============================================================================
    CTemplate::UnPersistData
    Restores the template memory from disk.
*/

HRESULT  CTemplate::UnPersistData()
{
    HRESULT     hr = S_OK;
    HANDLE      hFile = NULL;
    DWORD       dwRead;
    HANDLE      hImpersonationToken = NULL;
    HANDLE      hThread;

#if DEB_PERSTEMPL
    DBGPRINTF((DBG_CONTEXT,
               "CTemplate::UnPersistData() enterred.\n\tTemplate is %s\n\tTempName is %s\n",
               m_rgpFilemaps[0]->m_szPathTranslated,
               m_szPersistTempName));
#endif

    // check to see if the template is already loaded into memory.  If so, then
    // all this routine needs to do is lift the IsPersisted flag.

    if (m_pbStart != NULL) {
        m_fIsPersisted = FALSE;
        goto end;
    }

    hThread = GetCurrentThread();

    if (OpenThreadToken( hThread,
                         TOKEN_READ | TOKEN_IMPERSONATE,
                         TRUE,           
                         &hImpersonationToken )) {

       RevertToSelf();
    }

    // open the temp file for read

    if ((hFile = CreateFileA(m_szPersistTempName, 
                            GENERIC_READ,
                            0,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL)) == INVALID_HANDLE_VALUE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    // allocate the template memory

    else if (!(m_pbStart = (BYTE *)CTemplate::LargeMalloc(m_cbTemplate))) {
        hr = E_OUTOFMEMORY;
    }

    // read in the entire file

    else if (ReadFile(hFile,
                      m_pbStart,
                      m_cbTemplate,
                      &dwRead,
                      NULL) == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    // we're done with the file

    else if (CloseHandle(hFile) == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else {
        hFile = NULL;
    }

    if (FAILED(hr));

    // check to make sure we got everything

    else if (m_cbTemplate != dwRead) {
        hr = E_FAIL;
    }
    else {

        // if not, pretend like this is no longer persisted.  Prevents errors
        // in the future.

        m_fIsPersisted = FALSE;
    }

    if (hr != S_OK) {

        // make sure that the file handle was cleaned up

        if (hFile)
            CloseHandle(hFile);
    }
end:

    if (hImpersonationToken) {
        SetThreadToken(&hThread, hImpersonationToken);
        CloseHandle(hImpersonationToken);
    }

#if DBG_PERSTEMPL
    if (hr == S_OK) {
        DBGPRINTF((DBG_CONTEXT,
                   "UnPersist Successful\n"));
    }
    else {
        DBGPRINTF((DBG_CONTEXT,
                   "UnPersist failed.  hr = %x",
                   hr));
    }
#endif

    return hr;
}

/*  ============================================================================
    CTemplate::PersistCleanup
    Cleans up the temp file and the memory holding the temp file name.
*/

HRESULT CTemplate::PersistCleanup()
{
    HRESULT     hr = S_OK;
    HANDLE      hImpersonationToken = NULL;
    HANDLE      hThread;

    if (m_szPersistTempName == NULL) {
        return (S_OK);
    }


    hThread = GetCurrentThread();

    if (OpenThreadToken( hThread,
                         TOKEN_READ | TOKEN_IMPERSONATE,
                         TRUE,           
                         &hImpersonationToken )) {

       RevertToSelf();
    }

    if (DeleteFileA(m_szPersistTempName) == 0) {
        hr = GetLastError();
    }
    else {
        m_fIsPersisted = FALSE;
        CTemplate::LargeFree(m_szPersistTempName);
        m_szPersistTempName = NULL;
    }   

    if (hImpersonationToken) {
        SetThreadToken(&hThread, hImpersonationToken);
        CloseHandle(hImpersonationToken);
    }

    return hr;
}

/*  ****************************************************************************
    CIncFile member functions
*/

/*  ============================================================================
    CIncFile::CIncFile
    Constructor

    Returns:
        Nothing
    Side effects:
        None
*/
CIncFile::CIncFile
(
)
: m_szIncFile(NULL),
  m_fCsInited(FALSE),
  m_CPTextEvents(this, IID_IDebugDocumentTextEvents),
  m_cRefs(0)
    {   }

/*  ============================================================================
    CIncFile::Init
    Inits the CIncFile object

    Returns:
        HRESULT
    Side effects:
        None
*/
HRESULT
CIncFile::Init
(
const TCHAR* szIncFile   // file name
)
{
    HRESULT                     hr = S_OK;
    WIN32_FILE_ATTRIBUTE_DATA   fad;                // win32 file attributes data structure

    ErrInitCriticalSection(&m_csUpdate, hr);
    m_fCsInited = TRUE;

    if(NULL == (m_szIncFile = (LPTSTR) CTemplate::SmallMalloc((_tcslen(szIncFile) + 1)*sizeof(TCHAR)))) {
        hr = E_OUTOFMEMORY;
        goto LExit;
    }

    _tcscpy(m_szIncFile, szIncFile);

    // init hash table element base class
    if(FAILED(hr = CLinkElem::Init(m_szIncFile, _tcslen(m_szIncFile)*sizeof(TCHAR))))
        goto LExit;

LExit:
    return hr;
}

/*  ============================================================================
    CIncFile::~CIncFile
    Destructor

    Returns:
        Nothing
    Side effects:
        None
*/
CIncFile::~CIncFile
(
)
    {
#if UNICODE
    DBGPRINTF((DBG_CONTEXT, "Include file deleted: %S\n", m_szIncFile));
#else
    DBGPRINTF((DBG_CONTEXT, "Include file deleted: %s\n", m_szIncFile));
#endif
    Assert(m_cRefs == 0);
    SmallTemplateFreeNullify((void**) &m_szIncFile);
    if(m_fCsInited)
        DeleteCriticalSection(&m_csUpdate);
    }

/*  ============================================================================
    CIncFile::GetTemplate
    Get i'th template user from CIncFile

    Returns:
        NULL if "iTemplate" is out of range, m_rgpTemplates[iTemplate] otherwise

    Side effects:
        None
*/
CTemplate*
CIncFile::GetTemplate
(
int iTemplate
)
    {
    if (iTemplate < 0 || iTemplate >= (signed int) m_rgpTemplates.length())
        return NULL;

    else
        return m_rgpTemplates[iTemplate];
    }

/*  ============================================================================
    CIncFile::QueryInterface
    Provides QueryInterface implementation for CIncFile

    NOTE: It is arbitrary which vtable we return for IDebugDocument & IDebugDocumentInfo.
*/
HRESULT
CIncFile::QueryInterface(const GUID &uidInterface, void **ppvObj)
    {
    if (uidInterface == IID_IUnknown || uidInterface == IID_IDebugDocumentProvider)
        *ppvObj = static_cast<IDebugDocumentProvider *>(this);

    else if (uidInterface == IID_IDebugDocument || uidInterface == IID_IDebugDocumentInfo || uidInterface == IID_IDebugDocumentText)
        *ppvObj = static_cast<IDebugDocumentText *>(this);

    else if (uidInterface == IID_IConnectionPointContainer)
        *ppvObj = static_cast<IConnectionPointContainer *>(this);

    else
        *ppvObj = NULL;

    if (*ppvObj)
        {
        AddRef();
        return S_OK;
        }
    else
        return E_NOINTERFACE;
    }

/*  ============================================================================
    CIncFile::AddRef
    Adds a ref to this IncFile, thread-safely
*/
ULONG
CIncFile::AddRef()
    {
    InterlockedIncrement(&m_cRefs);
    return m_cRefs;
    }

/*  ============================================================================
    CIncFile::Release
    Releases a ref to this IncFile, thread-safely
*/
ULONG
CIncFile::Release()
{
    if (InterlockedDecrement(&m_cRefs) == 0)
        {
        delete this;
        return 0;
        }

    return m_cRefs;
}

/*  ****************************************************************************
    IDebugDocumentProvider implementation for includes
*/

/*  ============================================================================
    CIncFile::GetDocument
    Return a pointer to the IDebugDocument implementation. (same object in this case)

    Returns:
        *ppDebugDoc is set to "this".
    Notes:
        always succeeds
*/
HRESULT CIncFile::GetDocument
(
IDebugDocument **ppDebugDoc
)
    {
    return QueryInterface(IID_IDebugDocument, reinterpret_cast<void **>(ppDebugDoc));
    }

/*  ============================================================================
    CIncFile::GetName
    Return the various names of a document.
*/

HRESULT CIncFile::GetName
(
/* [in] */ DOCUMENTNAMETYPE doctype,
/* [out] */ BSTR *pbstrName
)
{
    switch (doctype) {
        case DOCUMENTNAMETYPE_APPNODE:
        case DOCUMENTNAMETYPE_FILE_TAIL:
        case DOCUMENTNAMETYPE_TITLE:
            // Use the name of the include file (char after last back-slash) converted to lower case.
        {
            TCHAR *szFilePart = _tcsrchr(m_szIncFile, _T('\\'));
            Assert (szFilePart != NULL);

#if UNICODE
            *pbstrName = SysAllocString(szFilePart + 1);
            if (*pbstrName == NULL) {
                return E_OUTOFMEMORY;
            }
#else
            if (FAILED(SysAllocStringFromSz(szFilePart + 1, 0, pbstrName, CP_ACP)))
                return E_FAIL;
#endif
            if (*pbstrName != NULL)
                _wcslwr(*pbstrName);
            return S_OK;
        }

        case DOCUMENTNAMETYPE_URL:
            // prefix with the URL, use szPathInfo for the rest of the path
        {
            CTemplate::CFileMap *pFilemap = GetFilemap();
            if (pFilemap->FHasVirtPath()) {
                STACK_BUFFER( tempName, MAX_PATH );

                CTemplate *pTemplate = m_rgpTemplates[0];
                int cbURLPrefix = DIFF(pTemplate->m_szApplnVirtPath - pTemplate->m_szApplnURL)*sizeof(TCHAR);

                if (!tempName.Resize(cbURLPrefix + ((_tcslen(pFilemap->m_szPathInfo) + 1)*sizeof(TCHAR)))) {
                    return E_OUTOFMEMORY;
                }

                TCHAR *szURL = (TCHAR *)tempName.QueryPtr();

                memcpy(szURL, pTemplate->m_szApplnURL, cbURLPrefix);
                _tcscpy(&szURL[cbURLPrefix/sizeof(TCHAR)], pFilemap->m_szPathInfo);
#if UNICODE
                *pbstrName = SysAllocString(szURL);
                if (*pbstrName == NULL) {
                    return (E_OUTOFMEMORY);
                }
                return S_OK;
#else
                return SysAllocStringFromSz(szURL, 0, pbstrName, pTemplate->m_wCodePage);
#endif
            }
            else {
                *pbstrName = NULL;
                return E_FAIL;
            }
        }

        default:
            return E_FAIL;
        }
}

/*  ****************************************************************************
    IDebugDocumentText implementation
*/

/*  ============================================================================
    CIncFile::GetSize
    Return the number of lines & characters in the document
*/
HRESULT CIncFile::GetSize
(
/* [out] */ ULONG *pcLines,
/* [out] */ ULONG *pcChars
)
    {
    CTemplate::CFileMap *pfilemap = GetFilemap();

    *pcLines = ULONG_MAX;
    *pcChars = pfilemap->m_cChars;
#if UNICODE
    DBGPRINTF((DBG_CONTEXT, "GetSize(\"%S\") returns %lu characters (%lu lines)\n", pfilemap->m_szPathTranslated, *pcChars, *pcLines));
#else
    DBGPRINTF((DBG_CONTEXT, "GetSize(\"%s\") returns %lu characters (%lu lines)\n", pfilemap->m_szPathTranslated, *pcChars, *pcLines));
#endif
    return S_OK;
    }

/*  ============================================================================
    CTemplate::GetDocumentAttributes
    Return doc attributes
*/
HRESULT CIncFile::GetDocumentAttributes
(
/* [out] */ TEXT_DOC_ATTR *ptextdocattr
)
    {
    // Easy way to tell debugger that we don't support editing.
    *ptextdocattr = TEXT_DOC_ATTR_READONLY;
    return S_OK;
    }

/*  ============================================================================
    CIncFile::GetPositionOfLine
    From a line number, return the character offset of the beginning

    I don't think we need this function.  It is meant to support line oriented
    debuggers, of which Caesar is not one.
*/
HRESULT CIncFile::GetPositionOfLine
(
/* [in] */ ULONG cLineNumber,
/* [out] */ ULONG *pcCharacterPosition
)
    {
    return m_rgpTemplates[0]->GetPositionOfLine(GetFilemap(), cLineNumber, pcCharacterPosition);
    }

/*  ============================================================================
    CIncFile::GetLineOfPosition
    From a character offset, return the line number and offset within the line

    I don't think we need this function.  It is meant to support line oriented
    debuggers, of which Caesar is not one.
*/
HRESULT CIncFile::GetLineOfPosition
(
/* [in] */ ULONG cCharacterPosition,
/* [out] */ ULONG *pcLineNumber,
/* [out] */ ULONG *pcCharacterOffsetInLine
)
    {
    return m_rgpTemplates[0]->GetLineOfPosition(GetFilemap(), cCharacterPosition, pcLineNumber, pcCharacterOffsetInLine);
    }

/*  ============================================================================
    CIncFile::GetText
    From a character offset and length, return the document text
*/
HRESULT CIncFile::GetText
(
ULONG cchSourceOffset,
WCHAR *pwchText,
SOURCE_TEXT_ATTR *pTextAttr,
ULONG *pcChars,
ULONG cMaxChars
)
    {
    return GetFilemap()->GetText((WORD)m_rgpTemplates[0]->m_wCodePage, cchSourceOffset, pwchText, pTextAttr, pcChars, cMaxChars);
    }

/*  ============================================================================
    CIncFile::GetPositionOfContext
    Decompose a document context into the document offset & length
*/
HRESULT CIncFile::GetPositionOfContext
(
/* [in] */ IDebugDocumentContext *pUnknownDocumentContext,
/* [out] */ ULONG *pcchSourceOffset,
/* [out] */ ULONG *pcchText
)
    {
    // Make sure that the context is one of ours
    CIncFileDocumentContext *pDocumentContext;
    if (FAILED(pUnknownDocumentContext->QueryInterface(IID_IDenaliIncFileDocumentContext, reinterpret_cast<void **>(&pDocumentContext))))
        return E_FAIL;

    if (pcchSourceOffset)
        *pcchSourceOffset = pDocumentContext->m_cchSourceOffset;

    if (pcchText)
        *pcchText = pDocumentContext->m_cchText;

    pDocumentContext->Release();
    return S_OK;
    }

/*  ============================================================================
    CIncFile::GetContextOfPosition
    Given the character position & number of characters in the document,
    encapsulate this into a document context object.
*/
HRESULT CIncFile::GetContextOfPosition
(
/* [in] */ ULONG cchSourceOffset,
/* [in] */ ULONG cchText,
/* [out] */ IDebugDocumentContext **ppDocumentContext
)
    {
    if (
        (*ppDocumentContext = new CIncFileDocumentContext(this, cchSourceOffset, cchText))
        == NULL
       )
        return E_OUTOFMEMORY;

    return S_OK;
    }

/*  ****************************************************************************
    IConnectionPointContainer implementation
*/

/*  ============================================================================
    CIncFile::FindConnectionPoint
    From a character offset and length, return the document text
*/
HRESULT CIncFile::FindConnectionPoint
(
const GUID &uidConnection,
IConnectionPoint **ppCP
)
    {
    if (uidConnection == IID_IDebugDocumentTextEvents)
        return m_CPTextEvents.QueryInterface(IID_IConnectionPoint, reinterpret_cast<void **>(ppCP));
    else
        {
        *ppCP = NULL;
        return E_NOINTERFACE;
        }
    }

/*  ============================================================================
    CIncFile::GetFilemap
    Returns a CFileMap pointer for this include file.  (Note: There are several
    CFileMaps that may be used, corresponding to each template.  This function
    selects one of them.)

    Returns:
        Corresponding CFileMap
    Side effects:
        None
*/
CTemplate::CFileMap *
CIncFile::GetFilemap
(
)
    {
    // Get pointer to first template's filemaps
    CTemplate::CFileMap **ppFilemapInc = &m_rgpTemplates[0]->m_rgpFilemaps[1];
    BOOL fFoundInc = FALSE;

    // Look for the filemap whose name corresponds to this IncFile.  It had better exist
    // in all template filemaps.
    //    NOTE: Start searching at position 1, because position 0 is the template itself.
    //
    for (unsigned i = 1; i < m_rgpTemplates[0]->m_cFilemaps && !fFoundInc; ++i)
        if (_tcscmp(m_szIncFile, (*ppFilemapInc++)->m_szPathTranslated) == 0)
            fFoundInc = TRUE;

    Assert (fFoundInc);
    return ppFilemapInc[-1];
    }

/*  ============================================================================
    CIncFile::AddTemplate
    Adds a template to the list of templates that include this inc-file

    Returns:
        HRESULT
    Side effects:
        None
*/
HRESULT
CIncFile::AddTemplate
(
CTemplate*  pTemplate
)
    {
    EnterCriticalSection(&m_csUpdate);

    // Add the template to the list only if it does not exist
    if (m_rgpTemplates.find(pTemplate) == -1)
        {
        if (FAILED(m_rgpTemplates.append(pTemplate)))
            {
            LeaveCriticalSection(&m_csUpdate);
            return E_OUTOFMEMORY;
            }

        // Notify the debugger that template dependency has changed
        //  (Ignore failure)
        //
        if (g_pDebugApp)
            {
            IF_DEBUG(SCRIPT_DEBUGGER)
                                DBGPRINTF((DBG_CONTEXT, "AddTemplate: Notifying debugger to refresh breakpoints\n"));

            InvokeDebuggerWithThreadSwitch
                                    (
                                    g_pDebugApp,
                                    DEBUGGER_EVENT_ON_REFRESH_BREAKPOINT,
                                    static_cast<IDebugDocument *>(this)
                                    );
            }
        }

    LeaveCriticalSection(&m_csUpdate);
    return S_OK;
    }

/*  ============================================================================
    CIncFile::RemoveTemplate
    Removes a template from the template list

    Returns:
        Nothing
    Side effects:
        Compresses the removed template's ptr out of template ptrs array (see "back-copy", below)
        Decrements template count
*/
void
CIncFile::RemoveTemplate
(
CTemplate*  pTemplate
)
    {
    EnterCriticalSection(&m_csUpdate);

    // find the template in list
    int i = m_rgpTemplates.find(pTemplate);

    // Remove the element (If we found it - possible that this is 2nd instance of #include and was previously removed)
    if (i != -1)
        {
        m_rgpTemplates.removeAt(i);

        // Notify the debugger that template dependency has changed
        //  (Ignore failure)
        //
        if (g_pDebugApp)
            {
            IF_DEBUG(SCRIPT_DEBUGGER)
                DBGPRINTF((DBG_CONTEXT, "RemoveTemplate: Notifying debugger to refresh breakpoints\n"));

            InvokeDebuggerWithThreadSwitch
                                    (
                                    g_pDebugApp,
                                    DEBUGGER_EVENT_ON_REFRESH_BREAKPOINT,
                                    static_cast<IDebugDocument *>(this)
                                    );
            }
        }

    LeaveCriticalSection(&m_csUpdate);
    }

/*  ============================================================================
    CIncFile::FlushTemplates
    Flushes all of this inc-file's templates from the global template cache

    Returns:
        TRUE if all templates flushed, FALSE if some left
    Side effects:
        None
*/
BOOL
CIncFile::FlushTemplates
(
)
    {
    /*  NOTE we have a cross-dependency with RemoveTemplate() because the following call chain
        occurs when an inc-file gets flushed:

            CIncFileMap::Flush
                CIncFile::FlushTemplates
                    CTemplateCacheManager::Flush
                        CTemplate::RemoveFromIncFiles
                            CIncFile::RemoveTemplate

        The problem is that RemoveTemplate() updates m_cTemplates and m_rgTemplates, so these members
        will not be stable during the loop within FlushTemplates.

        To get around this, we make a local copy of m_rgTemplates.
    */
    EnterCriticalSection(&m_csUpdate);

    STACK_BUFFER( tempTemplates, 128 );

    STACK_BUFFER( tempFile, MAX_PATH );

    UINT        cTemplates = m_rgpTemplates.length();

    if (!tempTemplates.Resize(cTemplates * sizeof(CTemplate*))) {

        // failed to get memory.  The best we can do is return FALSE to indicate
        // that not all templates where flushed.

        LeaveCriticalSection(&m_csUpdate);

        return FALSE;
    }

    CTemplate** rgpTemplates = static_cast<CTemplate**> (tempTemplates.QueryPtr());
    memcpy(rgpTemplates, m_rgpTemplates.vec(), sizeof(CTemplate *) * cTemplates);
    UINT cTemplatesFlushed = 0;

    for(UINT i = 0; i < cTemplates; i++)
        {
        // If the template is ready now, flush it
        if(rgpTemplates[i]->m_fReadyForUse && !(rgpTemplates[i]->m_fDontCache))
            {
            // bug 917: make a local copy of template file name, since the member gets freed part way through g_TemplateCache.Flush
            TCHAR*   szTemp = NULL;
            szTemp = rgpTemplates[i]->GetSourceFileName();
            if (szTemp)
                {

                if (!tempFile.Resize((_tcslen(szTemp) + 1)*sizeof(TCHAR))) {

                    // failed on this one.  Continue and try to flush as many
                    // as we can.
                    continue;
                }
                TCHAR *szTemplateFile = (TCHAR *)tempFile.QueryPtr();
                _tcscpy(szTemplateFile, szTemp);
                g_TemplateCache.Flush(szTemplateFile, MATCH_ALL_INSTANCE_IDS);
                cTemplatesFlushed++;
                }
            }

         // If the template was not ready, we don't flush. It will probably
         // pick up the current include file anyway
        }

    LeaveCriticalSection(&m_csUpdate);

    return (cTemplates == cTemplatesFlushed);
    }

/*  ============================================================================
    CIncFile::OnIncFileDecache

    Callback which we use to call onDestroy events in the debugger just before
    we are removed from the IncFile cache.

    REF COUNTING NOTE:
        Since debugging client has a reference to the IDebugDocument, the include needs
        to dis-associate with the debugger at a point in time before destruction.
        Otherwise, the reference will never go to zero.
*/
void
CIncFile::OnIncFileDecache
(
)
    {
    if (m_CPTextEvents.FIsEmpty() || g_pDebugApp == NULL)
        return;

    IEnumConnections *pConnIterator;
    if (SUCCEEDED(m_CPTextEvents.EnumConnections(&pConnIterator)))
        {
        CONNECTDATA ConnectData;
        while (pConnIterator->Next(1, &ConnectData, NULL) == S_OK)
            {
            IDebugDocumentTextEvents *pTextEventSink;
            if (SUCCEEDED(ConnectData.pUnk->QueryInterface(IID_IDebugDocumentTextEvents, reinterpret_cast<void **>(&pTextEventSink))))
                {
                InvokeDebuggerWithThreadSwitch(g_pDebugApp, DEBUGGER_ON_DESTROY, pTextEventSink);
                pTextEventSink->Release();
                }
            ConnectData.pUnk->Release();
            }

        pConnIterator->Release();
        }
    }

/*  ****************************************************************************
    CTemplate::CBuffer member functions
*/

/*  ============================================================================
    CTemplate::CBuffer::CBuffer
    Ctor
*/
CTemplate::CBuffer::CBuffer()
:
  m_pItems(NULL),
  m_cSlots(0),
  m_cItems(0),
  m_pbData(NULL),
  m_cbData(0),
  m_cbDataUsed(0)
    {
    }

/*  ============================================================================
    CTemplate::CBuffer::~CBuffer
    Dtor
*/
CTemplate::CBuffer::~CBuffer()
    {
    if(m_pItems)
        CTemplate::SmallFree(m_pItems);
    if(m_pbData)
        CTemplate::LargeFree(m_pbData);
    }

/*  ============================================================================
    CTemplate::CBuffer::Init
    Inits a CBuffer
*/
void
CTemplate::CBuffer::Init
(
USHORT cSlots,
ULONG cbData
)
    {
    m_cSlots = cSlots;
    m_cbData = cbData;

    // Allocate space for storing byte range items
    if(!(m_pItems = (CByteRange*) CTemplate::SmallMalloc(m_cSlots * sizeof(CByteRange))))
        THROW(E_OUTOFMEMORY);

    // Allocate space for storing local data, if there is any
    if(m_cbData > 0)
        {
        if(!(m_pbData = (BYTE*) CTemplate::LargeMalloc(m_cbData)))
            THROW(E_OUTOFMEMORY);
        }

    }

/*  ============================================================================
    CTemplate::CBuffer::Append
    Appends to a CBuffer
*/
void
CTemplate::CBuffer::Append
(
const CByteRange&   br,             // byte range to append
BOOL                fLocal,         // append local?
UINT                idSequence,     // segment sequence id
CFileMap*           pfilemap,
BOOL                fLocalString    // append local as a string? (length-prefixed, null-terminated)
)
    {
    // calc bytes required to store byte range; allow for length prefix and null if a local string
    ULONG cbRequired = (ULONG)(br.m_cb + (fLocalString ? sizeof(br.m_cb) + 1 : 0));

    // If caller passed a non-local zero-length byte range, no-op and return;
    // allows callers to ignore byte range size
    // NOTE we store empty local byte ranges - required by token list
    if(!fLocal && br.m_cb == 0)
        return;

    if(fLocal)
        {
        if((m_cbData - m_cbDataUsed) < cbRequired)
            {
            // Reallocate space for storing local data - we grab twice what we had before
            // or twice current requirement, whichever is more
            m_cbData = 2 * (m_cbData > cbRequired ? m_cbData : cbRequired);
            if(!(m_pbData = (BYTE*) CTemplate::LargeReAlloc(m_pbData, m_cbData)))
                THROW(E_OUTOFMEMORY);
            }

        // if appending as a local string, copy length-prefix to buffer
        if(fLocalString)
            {
            memcpy(m_pbData + m_cbDataUsed, &(br.m_cb), sizeof(br.m_cb));
            m_cbDataUsed += sizeof(br.m_cb);
            }

        // copy data to buffer
        memcpy(m_pbData + m_cbDataUsed, br.m_pb, br.m_cb);
        m_cbDataUsed += br.m_cb;

        // if appending as a local string, copy null terminator to buffer
        if(fLocalString)
            *(m_pbData + m_cbDataUsed++) = NULL;

        }

    if(m_cItems >= m_cSlots)
        {
        // Reallocate space for storing byte range items - we grab twice what we had before
        m_cSlots *= 2;
        if(!(m_pItems = (CByteRange*) CTemplate::SmallReAlloc(m_pItems, m_cSlots * sizeof(*m_pItems))))
            THROW(E_OUTOFMEMORY);
        }

    // Set the (new) last item to this byte range
    SetItem(m_cItems++, br, fLocal, idSequence, pfilemap, fLocalString);
    }

/*  ============================================================================
    CTemplate::CBuffer::GetItem
    Gets an item from a CBuffer, as a byte range

    Returns:
        Nothing

    Side effects:
        None
*/
void
CTemplate::CBuffer::GetItem
(
UINT        i,  // index of item
CByteRange& br  // byte range containing returned item (out-parameter)
)
    {
    Assert(i < m_cItems);

    // for local data, ptr is offset only; must add it to base ptr
    br.m_pb =  m_pItems[i].m_pb + (m_pItems[i].m_fLocal ? (DWORD_PTR) m_pbData : 0);

    br.m_cb = m_pItems[i].m_cb;
    br.m_fLocal = m_pItems[i].m_fLocal;
    br.m_idSequence = m_pItems[i].m_idSequence;
    br.m_pfilemap = m_pItems[i].m_pfilemap;
    }

/*  ============================================================================
    CTemplate::CBuffer::SetItem
    Sets a CBuffer item to a new value

    Returns
        Nothing
    Side effects
        Throws error on non-existent item index
*/
void
CTemplate::CBuffer::SetItem
(
UINT                i,
const CByteRange&   br,             // byte range to set item to
BOOL                fLocal,         // is item local in buffer?
UINT                idSequence,     // segment sequence id
CFileMap *          pfilemap,       // file where segment came from
BOOL                fLocalString    // append local as a string? (length-prefixed, null-terminated)
)
    {
    // If buffer item i does not exist, fail
    if(i >= m_cSlots)
        THROW(E_FAIL);

    // for local data, store ptr as offset only - avoids fixup after realloc
    // NOTE offset == data used offset - length of data - null terminator (if local string)
    m_pItems[i].m_pb = (fLocal
                        ? (BYTE*)(m_cbDataUsed - br.m_cb -
                            (fLocalString
                             ? sizeof(BYTE)
                             : 0
                            ))
                        : (BYTE*)br.m_pb);

    m_pItems[i].m_cb = br.m_cb;
    m_pItems[i].m_fLocal = fLocal;
    m_pItems[i].m_idSequence = idSequence;
    m_pItems[i].m_pfilemap = pfilemap;
    }

/*  ============================================================================
    CTemplate::CBuffer::PszLocal
    Gets i-th locally-buffered string within the buffer.

    Returns:
        Ptr to locally-buffered string; NULL if not found
    Side effects:
        None
*/
LPSTR
CTemplate::CBuffer::PszLocal
(
UINT i  // index of item to retrieve
)
    {
    CByteRange  br;

    GetItem(i, br);

    if(!br.m_fLocal)
        return NULL;

    return (LPSTR) br.m_pb;
    }

/*  ****************************************************************************
    CTemplate::CScriptStore member functions
*/

/*  ============================================================================
    CTemplate::CScriptStore::~CScriptStore
    Destructor - frees memory

    Returns:
        nothing
    Side effects:
        none
*/
CTemplate::CScriptStore::~CScriptStore()
    {
    UINT i;

    for(i = 0; i < m_cSegmentBuffers; i++)
        delete m_ppbufSegments[i];

    if(m_ppbufSegments != NULL)
        CTemplate::SmallFree(m_ppbufSegments);
    if(m_rgProgLangId != NULL)
        CTemplate::SmallFree(m_rgProgLangId);
    }

/*  ============================================================================
    CTemplate::CScriptStore::Init
    Inits the script store

    Returns:
        nothing
    Side effects:
        allocates memory
*/
HRESULT
CTemplate::CScriptStore::Init
(
LPCSTR szDefaultScriptLanguage,
CLSID *pCLSIDDefaultEngine
)
    {
    HRESULT hr = S_OK;
    UINT    i;
    CByteRange  brDefaultScriptLanguage;

        // Check for NULL pointers - can happen if Application has invalid default lang
        if (szDefaultScriptLanguage == NULL || pCLSIDDefaultEngine == NULL)
                return TYPE_E_ELEMENTNOTFOUND;

    /*  init segment buffers count based on:
        - two for default engine (one primary, one tagged)
        - one each for other engines (tagged only)
    */
    m_cSegmentBuffers = C_SCRIPTENGINESDEFAULT + 1;

    // init segments buffers
    if(NULL == (m_ppbufSegments = (CBuffer**) CTemplate::SmallMalloc(m_cSegmentBuffers * sizeof(CBuffer*))))
        {
        hr = E_OUTOFMEMORY;
        goto LExit;
        }

    for(i = 0; i < m_cSegmentBuffers; i++)
        {
        if(NULL == (m_ppbufSegments[i] = new CBuffer))
            {
            hr = E_OUTOFMEMORY;
            goto LExit;
            }
        m_ppbufSegments[i]->Init((C_SCRIPTSEGMENTSDEFAULT), 0);
        }

    // Append default engine to script store
    brDefaultScriptLanguage.m_cb = strlen(szDefaultScriptLanguage);
    brDefaultScriptLanguage.m_pb = (unsigned char *)szDefaultScriptLanguage;
    hr = AppendEngine(brDefaultScriptLanguage, pCLSIDDefaultEngine, /* idSequence */ 0);

LExit:
    return hr;
    }

/*  ============================================================================
    CTemplate::CScriptStore::AppendEngine
    Appends a script engine to the script store

    Returns:
        HRESULT
    Side effects:
        None
*/
HRESULT
CTemplate::CScriptStore::AppendEngine
(
CByteRange&     brEngine,       // engine name
PROGLANG_ID*    pProgLangId,    // ptr to prog lang id - pass NULL to have this function get proglangid from registry
UINT            idSequence      // segment sequence id
)
    {
    HRESULT     hr = S_OK;
    USHORT      cEngines;   // count of engines

    TRY
        // if no engines yet, init engine names buffer
        if(CountPreliminaryEngines() == 0)
            m_bufEngineNames.Init(C_SCRIPTENGINESDEFAULT, 0);

        // Append engine name to buffer
        m_bufEngineNames.Append(brEngine, FALSE, idSequence, NULL);

    CATCH(hrException)
        hr = hrException;
        goto LExit;
    END_TRY

    Assert(CountPreliminaryEngines() >= 1);

    //  malloc or realloc prog lang ids array
    if((cEngines = CountPreliminaryEngines()) == 1)
        m_rgProgLangId = (PROGLANG_ID*) CTemplate::SmallMalloc(cEngines * sizeof(PROGLANG_ID));
    else
        m_rgProgLangId = (PROGLANG_ID*) CTemplate::SmallReAlloc(m_rgProgLangId, cEngines * sizeof(PROGLANG_ID));

    if(NULL == m_rgProgLangId)
        {
        hr = E_OUTOFMEMORY;
        goto LExit;
        }

    if(NULL == pProgLangId)
        // caller passed null progid ptr - get prog id from registry
        hr = GetProgLangId(brEngine, &(m_rgProgLangId[cEngines - 1]));
    else
        // caller passed non-null progid ptr - set prog id from it
        m_rgProgLangId[cEngines - 1] = *pProgLangId;

LExit:
    return hr;
    }

/*  ============================================================================
    CTemplate::CScriptStore::IdEngineFromBr
    Determines the id of a script engine from its engine name

    Returns:
        id of script engine whose name is passed in
    Side effects:
        appends a new script engine name to engine names buffer
*/
USHORT
CTemplate::CScriptStore::IdEngineFromBr
(
CByteRange& brEngine,   // engine name
UINT        idSequence  // segment sequence id
)
    {
    Assert(!brEngine.IsNull()); // NOTE we trap/error null engine name earlier

    USHORT cKnownEngines = CountPreliminaryEngines();

    // search existing names for a match; return id if found
    for(USHORT i = 0; i < cKnownEngines; i++)
        {
        Assert(m_bufEngineNames[i]);
        Assert(m_bufEngineNames[i]->m_pb);
        if(FByteRangesAreEqual(*(m_bufEngineNames[i]), brEngine))
            return i;
        }

    // if not found by name try to find by engine id
    // (some engines with different names share the same id, like J[ava]Script)

    if (cKnownEngines > 0)
        {
        PROGLANG_ID ProgLandId;

        // we will get the prog lang id again inside AppendEngine() but
        // because it's cached and this only happens when > 1 engine,  it's alright

        if (SUCCEEDED(GetProgLangId(brEngine, &ProgLandId)))
            {
            for(i = 0; i < cKnownEngines; i++)
                {
                // If matches don't append -- just return the index
                if (m_rgProgLangId[i] == ProgLandId)
                    return i;
                }
            }
        }

    /*  if we did not find engine among those already buffered
        - append engine to script store
        - realloc segment buffers array if necessary
        - return index of last engine (the one we just appended)
    */

    // append engine to script store
    HRESULT hr = AppendEngine(brEngine, NULL, idSequence);

    if(hr == TYPE_E_ELEMENTNOTFOUND)
        // if prog lang not found, throw bad prog lang error id
        THROW(IDE_TEMPLATE_BAD_PROGLANG);
    else if(FAILED(hr))
        // other failure: re-throw hresult
        THROW(hr);

    // realloc segment buffers array if necessary
    if(CountPreliminaryEngines() > (m_cSegmentBuffers - 1))
        {
        // increment count of segment buffers
        m_cSegmentBuffers++;
        Assert(CountPreliminaryEngines() == m_cSegmentBuffers - 1);

        // realloc array of ptrs
        if(NULL == (m_ppbufSegments = (CBuffer**) CTemplate::SmallReAlloc(m_ppbufSegments, m_cSegmentBuffers * sizeof(CBuffer*))))
            THROW(E_OUTOFMEMORY);

        // allocate the new buffer
        if(NULL == (m_ppbufSegments[m_cSegmentBuffers - 1] = new CBuffer))
            THROW(E_OUTOFMEMORY);

        // init the new buffer
        m_ppbufSegments[m_cSegmentBuffers - 1]->Init(C_SCRIPTSEGMENTSDEFAULT, 0);
        }

    // return index of last engine (the one we just appended)
    return (CountPreliminaryEngines() - 1);

    }

/*  ============================================================================
    CTemplate::CScriptStore::AppendScript
    Appends a script/engine pair to the store.

    Returns:
        Nothing
    Side effects:
        None
*/
void
CTemplate::CScriptStore::AppendScript
(
CByteRange& brScript,   // script text
CByteRange& brEngine,   // script engine name
BOOLB       fPrimary,   // primary or tagged script?
UINT        idSequence, // segment sequence id
CFileMap*   pfilemapCurrent
)
    {
    USHORT  iBuffer;    // buffer id

    Assert(fPrimary || !brEngine.IsNull()); // NOTE we trap/error null engine name earlier
    Assert(m_bufEngineNames[0]);            // page's primary engine must be known by this point
    Assert(m_bufEngineNames[0]->m_pb);

    if(fPrimary)
        // if primary script (not tagged), buffer id is 0
        iBuffer = 0;
    else if((!fPrimary) && FByteRangesAreEqual(brEngine, /* bug 1008: primary script engine name */ *(m_bufEngineNames[0])))
        // if tagged script and engine is primary, buffer id is 1
        iBuffer = 1;
    else
        // else, buffer id is engine id plus 1
        iBuffer = IdEngineFromBr(brEngine, idSequence) + 1;

    // append script segment to iBuffer-th segments buffer
    m_ppbufSegments[iBuffer]->Append(brScript, FALSE, idSequence, pfilemapCurrent);
    }

/*  ****************************************************************************
    CTemplate::CObjectInfoStore member functions
*/
/*  ============================================================================
    CTemplate::CObjectInfoStore::~CObjectInfoStore
*/
CTemplate::CObjectInfoStore::~CObjectInfoStore
(
)
    {
    if(m_pObjectInfos)
        CTemplate::SmallFree(m_pObjectInfos);
    }

/*  ============================================================================
    CTemplate::CObjectInfoStore::Init
    Inits the object-info store
*/
void
CTemplate::CObjectInfoStore::Init()
    {
    m_bufObjectNames.Init(C_OBJECTINFOS_DEFAULT, 0);

    // init object-infos array
    if(NULL == (m_pObjectInfos = (CObjectInfo*) CTemplate::SmallMalloc(m_bufObjectNames.CountSlots() * sizeof(CObjectInfo))))
        THROW(E_OUTOFMEMORY);

    }

/*  ============================================================================
    CTemplate::CObjectInfoStore::AppendObject
    Appends an object-info to the object-info store
*/
void
CTemplate::CObjectInfoStore::AppendObject
(
CByteRange& brObjectName,
CLSID       clsid,
CompScope   scope,
CompModel   model,
UINT        idSequence
)
    {

    USHORT iObject = m_bufObjectNames.Count();
    if(iObject >= m_bufObjectNames.CountSlots())
        {
        // Reallocate space for storing object-infos - we grab twice what we had before
        // NOTE we keep no object count in CObjectInfoStore, but instead use count in object names buffer
        (m_pObjectInfos = (CObjectInfo*)CTemplate::SmallReAlloc(m_pObjectInfos,
                                                2 * m_bufObjectNames.CountSlots() * sizeof(CObjectInfo)));

                if (m_pObjectInfos == NULL)
                        THROW(E_OUTOFMEMORY);
        }

    m_pObjectInfos[iObject].m_clsid = clsid;
    m_pObjectInfos[iObject].m_scope = scope;
    m_pObjectInfos[iObject].m_model = model;

    m_bufObjectNames.Append(brObjectName, FALSE, idSequence, NULL);
    }

/*  ****************************************************************************
    CTemplate::CWorkStore member functions
*/

/*  ============================================================================
    CTemplate::CWorkStore::CWorkStore
    Constructor

    Returns:
        Nothing
    Side effects:
        None
*/
CTemplate::CWorkStore::CWorkStore
(
)
:
  m_idCurSequence(0),
  m_fPageCommandsExecuted(FALSE),
  m_fPageCommandsAllowed(TRUE),
  m_szWriteBlockOpen(g_szWriteBlockOpen),
  m_szWriteBlockClose(g_szWriteBlockClose),
  m_szWriteOpen(g_szWriteOpen),
  m_szWriteClose(g_szWriteClose)
    {   }

/*  ============================================================================
    CTemplate::CWorkStore::~CWorkStore
    Destructor

    Returns:
        Nothing
    Side effects:
        None
*/
CTemplate::CWorkStore::~CWorkStore
(
)
    {
    /*  if language element ptrs are anything but their constant defaults or null,
        they must have been allocated during compilation - free them now
    */
    if(m_szWriteBlockOpen != g_szWriteBlockOpen  && m_szWriteBlockOpen != NULL)
        CTemplate::SmallFree(m_szWriteBlockOpen);

    if(m_szWriteBlockClose != g_szWriteBlockClose  && m_szWriteBlockClose != NULL)
        CTemplate::SmallFree(m_szWriteBlockClose);

    if(m_szWriteOpen != g_szWriteOpen  && m_szWriteOpen != NULL)
        CTemplate::SmallFree(m_szWriteOpen);

    if(m_szWriteClose != g_szWriteClose  && m_szWriteClose != NULL)
        CTemplate::SmallFree(m_szWriteClose);
    }



/*  ============================================================================
    CTemplate::CWorkStore::Init
    Inits the workstore

    Returns:
        Nothing
    Side effects:
        None
*/
void
CTemplate::CWorkStore::Init
(
)
    {
/*
        NOTE init we the scriptstore separately from rest of workstore
        because try-catch in CTemplate::Init() apparently doesn't work to detect
        bogus script engine name; we need to get an hr back instead.

    m_ScriptStore.Init(brDefaultEngine);
*/
    m_ObjectInfoStore.Init();
    m_bufHTMLSegments.Init(C_HTMLSEGMENTSDEFAULT, 0);
    }

/*  ============================================================================
    CTemplate::CWorkStore::CRequiredScriptEngines
    Returns the count of script engines in the script store that are required
    to run the template.

    NOTE this function is part of the fix for bug 933

    Returns:
        Count of non-empty script engines
    Side effects:
        None
*/
USHORT
CTemplate::CWorkStore::CRequiredScriptEngines
(
BOOL    fGlobalAsa  // bug 1394: is template global.asa?
)
    {
    USHORT  cPreliminaryEngines = m_ScriptStore.CountPreliminaryEngines();
    USHORT  cRequiredEngines =  0;

    for(USHORT i = 0; i < cPreliminaryEngines; i++)
        {
        if(FScriptEngineRequired(i, fGlobalAsa))
            cRequiredEngines++;
        }

    return cRequiredEngines;
    }

/*  ============================================================================
    CTemplate::CWorkStore::FScriptEngineRequired
    Is a given preliminary script engine required to run the template?

    NOTE this function is part of the fix for bug 933

    Returns:
        TRUE or FALSE
    Side effects:
        None
*/
BOOLB
CTemplate::CWorkStore::FScriptEngineRequired
(
USHORT  idEnginePrelim,
BOOL    fGlobalAsa      // bug 1394: is template global.asa?
)
    {
    if(idEnginePrelim == 0)
        return (                                                        // primary engine (id 0) required if
                    (m_ScriptStore.m_ppbufSegments[0]->Count() > 0)     // ... script buffer 0 has segments
                    || (m_ScriptStore.m_ppbufSegments[1]->Count() > 0)  // ... or script buffer 1 has segments
                    || ((m_bufHTMLSegments.Count() > 0) && !fGlobalAsa) // ... or html buffer has segments and (bug 1394) template is not global.asa
                );

    // non-primary engine required if script buffer id+1 has segments
    return (m_ScriptStore.m_ppbufSegments[idEnginePrelim + 1]->Count() > 0);
    }


/*  ****************************************************************************
    CTemplate::CFileMap member functions
*/

/*  ============================================================================
    CTemplate::CFileMap::CFileMap
    Constructor

    Returns
        Nothing
    Side effects
        None
*/
CTemplate::CFileMap::CFileMap()
:
  m_szPathInfo(NULL),
  m_szPathTranslated(NULL),
  m_pfilemapSibling(NULL),
  m_pfilemapChild(NULL),
  m_hFile(NULL),
  m_hMap(NULL),
  m_pbStartOfFile(NULL),
  m_pIncFile(NULL),
  m_pSecurityDescriptor(NULL),
  m_dwSecDescSize(0),
  m_cChars(0),
  m_pDME(NULL)
    {
    m_ftLastWriteTime.dwLowDateTime = 0;
    m_ftLastWriteTime.dwHighDateTime = 0;
    }

/*  ============================================================================
    CTemplate::CFileMap::~CFileMap
    Destructor

    Returns
        Nothing
    Side effects
        None
*/
CTemplate::CFileMap::~CFileMap()
    {
    if (m_pDME)
        {
        m_pDME->Release();
        m_pDME = NULL;
        }
    if(m_szPathInfo != NULL)
        CTemplate::SmallFree(m_szPathInfo);
    if(m_szPathTranslated != NULL)
        CTemplate::SmallFree(m_szPathTranslated);
    if(m_pSecurityDescriptor != NULL)
        CTemplate::SmallFree(m_pSecurityDescriptor);
    if (m_pIncFile != NULL)
        m_pIncFile->Release();
    }

/*  ============================================================================
    CTemplate::CFileMap::MapFile
    Memory-maps a file.

    Returns
        Nothing
    Side effects
        Throws **overloaded** exception on error: exception code can sometimes be
        an error message id, sometimes a true exception.  Caller must handle.
*/
void
CTemplate::CFileMap::MapFile
(
LPCTSTR     szFileSpec,     // file spec for this file
LPCTSTR     szApplnPath,    // application path (in case its global.asa)
CFileMap*   pfilemapParent, // ptr to filemap of parent file
BOOL        fVirtual,       // is file spec virtual or relative?
CHitObj*    pHitObj,        // ptr to template's hit object
BOOL        fGlobalAsa      // is this file the global.asa file?
)
    {
    BOOL        fMustNormalize = TRUE;
    BOOL        fImpersonatedUser = FALSE;
    HANDLE      hImpersonationToken = NULL;
    HANDLE      hCurrentImpersonationToken = NULL;

    Assert((pfilemapParent != NULL) || (pHitObj->PIReq() != NULL) || fGlobalAsa);

    /*  three possible cases:
        1) we are processing global.asa file
        2) we are processing the "main" .asp file
        3) we are processing an include file
    */
    if(fGlobalAsa)
        {
        // case 1) we are processing global.asa file
        Assert(pHitObj->GlobalAspPath());

        DWORD cchPathTranslated = _tcslen(pHitObj->GlobalAspPath());
        m_szPathTranslated = (TCHAR *)CTemplate::SmallMalloc((cchPathTranslated+1)*sizeof(TCHAR));
        if (!m_szPathTranslated)
            THROW(E_OUTOFMEMORY);
        _tcscpy(m_szPathTranslated, pHitObj->GlobalAspPath());

        DWORD cchPathInfo = _tcslen(szApplnPath) + 11; // "/global.asa"
        m_szPathInfo = (TCHAR *)CTemplate::SmallMalloc((cchPathInfo+1) * sizeof(TCHAR));
        if (!m_szPathInfo)
            THROW(E_OUTOFMEMORY);
        _tcscpy(strcpyEx(m_szPathInfo, szApplnPath), _T("/global.asa"));

        // no need to normalize in this case, since global.asa path is already normalized
        Assert(IsNormalized((const TCHAR*)m_szPathTranslated));
        fMustNormalize = FALSE;
        m_fHasVirtPath = TRUE;
        }
    else if(pfilemapParent == NULL)
        {
        // case 2) we are processing the "main" .asp file: get path-info and path-tran from ecb
        Assert(pHitObj->PIReq());

        TCHAR *szVirtPath = pHitObj->PSzCurrTemplateVirtPath();
        TCHAR *szPhysPath = pHitObj->PSzCurrTemplatePhysPath();

        m_szPathInfo       = static_cast<LPTSTR>(CTemplate::SmallMalloc((_tcslen(szVirtPath) + 1)*sizeof(TCHAR)));
        m_szPathTranslated = static_cast<LPTSTR>(CTemplate::SmallMalloc((_tcslen(szPhysPath) + 1)*sizeof(TCHAR)));
        if (!m_szPathInfo || !m_szPathTranslated)
            THROW(E_OUTOFMEMORY);

        _tcscpy(m_szPathInfo,       szVirtPath);
        _tcscpy(m_szPathTranslated, szPhysPath);

        // no need to normalize in this case, since ecb's path-tran is already normalized
        Assert(IsNormalized((const TCHAR*)m_szPathTranslated));
        fMustNormalize = FALSE;
        m_fHasVirtPath = TRUE;
        }
    else
        {
        /*  case 3) we are processing an include file: resolve filespec into path-info and path-tran
            based on whether file was included with VIRTUAL tag or FILE tag
        */
        Assert(szFileSpec);

        // in this case, we don't know path lengths up front so we alloc the max and realloc below
        m_szPathInfo = static_cast<LPTSTR> (CTemplate::SmallMalloc((MAX_PATH + 1)*sizeof(TCHAR)));
        m_szPathTranslated = static_cast<LPTSTR> (CTemplate::SmallMalloc((MAX_PATH + 1)*sizeof(TCHAR)));
        if (!m_szPathInfo || !m_szPathTranslated)
            THROW(E_OUTOFMEMORY);

        STACK_BUFFER(tempPathT, MAX_PATH  );

        if (!tempPathT.Resize((_tcslen(szFileSpec) + 1)*sizeof(TCHAR))) {
            THROW(E_OUTOFMEMORY);
        }

        LPTSTR szPathTranslatedT = (TCHAR *)tempPathT.QueryPtr();   // temp path-tran

        if(fVirtual) {
            DWORD   dwSzLength = tempPathT.QuerySize();  // length of path string buffer

			if (_tcslen(szFileSpec) > MAX_PATH)
				THROW(E_FAIL);
			
            // VIRTUAL: path-info is simply virtual filespec
            _tcscpy(m_szPathInfo, szFileSpec);

            // VIRTUAL: path-tran is translation of path-info
            _tcscpy(szPathTranslatedT, m_szPathInfo);

            if (!pHitObj->PIReq()->MapUrlToPath(szPathTranslatedT, &dwSzLength))
                THROW(E_FAIL);

            // Check the translated path for a UNC specified path

            if ((dwSzLength >= (2*sizeof(TCHAR)))
                && (szPathTranslatedT[0] == _T('\\'))
                && (szPathTranslatedT[1] == _T('\\'))) {

                // if UNC, then ask WAM for the impersonation token for
                // this UNC VRoot.  Silently fail.

                if (pHitObj->PIReq()->ServerSupportFunction(
                                        HSE_REQ_GET_VIRTUAL_PATH_TOKEN,
                                        (void *)szFileSpec,
                                        (DWORD *) &hImpersonationToken,
                                        NULL))
                    {

                    // set the impersonation token and note that we did so                    
                    AspDoRevertHack(&hCurrentImpersonationToken);     
                    
                    fImpersonatedUser = ImpersonateLoggedOnUser(hImpersonationToken)
                                            ? TRUE
                                            : FALSE;

                    if (!fImpersonatedUser) {
                    	AspUndoRevertHack(&hCurrentImpersonationToken);
                     }

                    }
                }

            m_fHasVirtPath = TRUE;
            }
        else
            {
            TCHAR szParentDir[MAX_PATH], *szT;
            _tcscpy(szParentDir, pfilemapParent->m_szPathInfo);
            if ((szT = _tcsrchr(szParentDir, _T('/'))) != NULL)
                *szT = _T('\0');

            // If we don't allow parent paths, we can save lots of time (Always have a valid virtual path)
            if (!pHitObj->QueryAppConfig()->fEnableParentPaths())
                {
                int strlen_szParentDir = (int)(szT - szParentDir);
                if ((strlen_szParentDir + 1 + _tcslen(szFileSpec)) > MAX_PATH)
                	THROW(E_FAIL);
                
                strcpyEx(strcpyEx(strcpyEx(m_szPathInfo, szParentDir), _T("/")), szFileSpec);
                m_fHasVirtPath = TRUE;
                }
            else
                {
                // NOTE: If we must translate ".." paths, there is no need to verify them (by remapping)
                //       because: If the file does not exist, that case will show up when the file is mapped
                //       If we ".." ourselves out of the vroot space, (out of the app or into another app)
                //          DotPathToPath will detect this.
                //
                if (DotPathToPath(m_szPathInfo, szFileSpec, szParentDir))
                    m_fHasVirtPath = TRUE;
                else
                    {
                    GetPathFromParentAndFilespec(pfilemapParent->m_szPathTranslated, szFileSpec, &m_szPathInfo);
                    m_fHasVirtPath = FALSE;
                    }

                }

            GetPathFromParentAndFilespec(pfilemapParent->m_szPathTranslated, szFileSpec, &szPathTranslatedT);
            }

        // bug 1214: get canonical path-tran, without . and ..
        // CONSIDER check for . or .. in name before calling GetFullPathName?  UNCs?  what else?
        GetFullPathName(
                        szPathTranslatedT,  // LPCSTR lpFileName,  // address of name of file to find path for
                        MAX_PATH + 1,       // DWORD nBufferLength, // size, in characters, of path buffer
                        m_szPathTranslated, // LPSTR lpBuffer,     // address of path buffer
                        NULL                // LPSTR *lpFilePart   // address of filename in path
                        );

        // realloc path strings to only use required memory (see note above)
        m_szPathInfo = static_cast<LPTSTR> (CTemplate::SmallReAlloc(m_szPathInfo, (_tcslen(m_szPathInfo) + 1)*sizeof(TCHAR)));
        m_szPathTranslated = static_cast<LPTSTR> (CTemplate::SmallReAlloc(m_szPathTranslated, (_tcslen(m_szPathTranslated) + 1)*sizeof(TCHAR)));
        if (!m_szPathInfo || !m_szPathTranslated)
            {
            if (fImpersonatedUser)
                {
                AspUndoRevertHack(&hCurrentImpersonationToken);
                }
            if (hImpersonationToken)
                {
                CloseHandle(hImpersonationToken);
                }
            THROW(E_OUTOFMEMORY);
            }
        }

    // if required, normalize path-tran so that
    // a) cyclic include check can ignore case; b) inc-file cache lookups will work
    if(fMustNormalize)
        Normalize(m_szPathTranslated);

    Assert(IsNormalized(m_szPathTranslated));

    // Bug 99071: Attempt to open the file **BEFORE** we add it to the tree of file
    //            dependencies.  Otherwise if it fails to open, we will have
    //            dangling references.  Since FCyclicInclude depends on us adding
    //            to the tree, if it is cyclic, we need to unmap then.  Since that
    //            is a very uncommon error case, the extra overhead is probably OK
    //
    // RemapFile will throw if it fails. If the exception is that the source file is empty
    // and we are trying to process an include file, we will handle the exception here.
    // in all other cases, rethrow the exception. We do this so that an empty include file
    // will be harmless, but an empty primary file will fail.
    TRY

        RemapFile();

    CATCH(hrException)

        if (hrException != E_SOURCE_FILE_IS_EMPTY || pfilemapParent == NULL)
            {
            if (fImpersonatedUser)
                {
                AspUndoRevertHack(&hCurrentImpersonationToken);
                }
            if (hImpersonationToken)
                {
                CloseHandle(hImpersonationToken);
                }
            THROW(hrException);
            }

    END_TRY

    if (fImpersonatedUser)
        {
		AspUndoRevertHack(&hCurrentImpersonationToken);
        }
    if (hImpersonationToken)
        {
        CloseHandle(hImpersonationToken);
        }

    // Create the tree structure for this file
    if (pfilemapParent != NULL)
        {
        // See if this file is already included once on this level. (Don't show duplicates in the
        // debugger tree view)
        //
        BOOL fDuplicateExists = FALSE;
        CFileMap *pFilemap = pfilemapParent->m_pfilemapChild;
        while (pFilemap != NULL && !fDuplicateExists)
            {
            if (_tcscmp(pFilemap->m_szPathTranslated, m_szPathTranslated) == 0)
                fDuplicateExists = TRUE;

            pFilemap = pFilemap->m_fHasSibling? pFilemap->m_pfilemapSibling : NULL;
            }

        // If the include file is #include'd more than once, don't add it as a sibling.
        // Rather orphan the pfilemap and just set the parent pointer.
        //
        if (!fDuplicateExists)
            {
            if (pfilemapParent->m_pfilemapChild == NULL)
                pfilemapParent->m_pfilemapChild = this;
            else
                pfilemapParent->m_pfilemapChild->AddSibling(this);
            }
        }

    // in both of the above code paths, we are always added as the LAST child, (or we are an orphan node)
    // so it is safe to set the parent without calling SetParent()
    m_fHasSibling = FALSE; // Paranoia
    m_pfilemapParent = pfilemapParent;

    // hurl if this file is being included by itself (perhaps indirectly)
    if(FCyclicInclude(m_szPathTranslated))
        {
        UnmapFile();
        THROW(IDE_TEMPLATE_CYCLIC_INCLUDE);
        }
    }

/*  ============================================================================
    CTemplate::CFileMap::RemapFile
    map a file that was previously mapped.

    Returns
        Nothing
    Side effects
        Throws **overloaded** exception on error: exception code can sometimes be
        an error message id, sometimes a true exception.  Caller must handle.

    Does not decrypt EASPs on remapping. Caller must decrypt if required.  This
    function is called by the debugger, and the debugger does not allow access
    to decrypted files, so decryption is a waste of time.
*/
void
CTemplate::CFileMap::RemapFile
(
)
    {
    WIN32_FILE_ATTRIBUTE_DATA   fad;    // win32 file attributes data structure

    if (FIsMapped())
        return;

    if(INVALID_HANDLE_VALUE == (m_hFile =
                                CreateFile(
                                            m_szPathTranslated,     // file name
                                            GENERIC_READ,           // access (read-write) mode
                                            FILE_SHARE_READ,        // share mode
                                            NULL,                   // pointer to security descriptor
                                            OPEN_EXISTING,          // how to create
                                            FILE_ATTRIBUTE_NORMAL,  // file attributes
                                            NULL                    // handle to file with attributes to copy
                                           )))
        {
        DWORD dwLastError = GetLastError();
        if(dwLastError == ERROR_ACCESS_DENIED)
            {
            // typically, we end up here if the user has no permissions on the file
            // bug 1007: however, we also end up here if the user gave us a directory name, instead of a file name

            if(FAILED(AspGetFileAttributes(m_szPathTranslated, &fad)))
                {
                // bug 1495: file in a secured directory will end up here - we need to re-GetLastError to see if access is denied
                dwLastError = GetLastError();
                if(dwLastError == ERROR_ACCESS_DENIED)
                    {
                    THROW(E_USER_LACKS_PERMISSIONS);
                    }
                // GetFileAttributes call failed; don't know why
                THROW(E_FAIL);
                }
            else if(FILE_ATTRIBUTE_DIRECTORY & fad.dwFileAttributes)
                {
                // bug 1007: the user gave us a directory name
#if UNICODE
                DBGPRINTF((DBG_CONTEXT, "Failed to open file %S because it is a directory.\n", m_szPathTranslated));
#else
                DBGPRINTF((DBG_CONTEXT, "Failed to open file %s because it is a directory.\n", m_szPathTranslated));
#endif
                THROW(E_COULDNT_OPEN_SOURCE_FILE);
                }
            else
                {
                THROW(E_USER_LACKS_PERMISSIONS);
                }
            }
        else
                        {
#if DBG
			char szError[128];
			if (!FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM,
								NULL,
								dwLastError,
								0L,			// lang ID - defaults to LANG_NEUTRAL
								szError,
								sizeof szError,
								NULL) )
				{
				sprintf(szError, "%d", dwLastError);
				}
#if UNICODE
            DBGPRINTF((DBG_CONTEXT, "Failed to open file %S\n", m_szPathTranslated));
#else
            DBGPRINTF((DBG_CONTEXT, "Failed to open file %s\n", m_szPathTranslated));
#endif
            DBGPRINTF((DBG_CONTEXT, "  The error returned was: %s\n", szError));
#endif
            THROW(E_COULDNT_OPEN_SOURCE_FILE);
            }
        }

    // Get the file's last access time. Only do this for NT
    if (Glob(fWinNT))
        {
        if (SUCCEEDED(AspGetFileAttributes(m_szPathTranslated, &fad)))
            {
            m_ftLastWriteTime.dwLowDateTime = fad.ftLastWriteTime.dwLowDateTime;
            m_ftLastWriteTime.dwHighDateTime = fad.ftLastWriteTime.dwHighDateTime;
            }
        }

    // get file's security descriptor
    if(!GetSecurityDescriptor())
        THROW(E_COULDNT_OPEN_SOURCE_FILE);

    // map the file
    if(NULL == (m_hMap =
                CreateFileMapping(
                                    m_hFile,        // handle to file to map
                                    NULL,           // optional security attributes
                                    PAGE_READONLY,  // protection for mapping object
                                    0,              // high-order 32 bits of object size
                                    0,              // low-order 32 bits of object size
                                    NULL            // name of file-mapping object
                                )))
        {
        if (SUCCEEDED(AspGetFileAttributes(m_szPathTranslated, &fad)))
            {
           if(fad.nFileSizeHigh == 0 && fad.nFileSizeLow == 0)
                {
#if UNICODE
                DBGPRINTF((DBG_CONTEXT, "Empty source file %S\n", m_szPathTranslated));
#else
                DBGPRINTF((DBG_CONTEXT, "Empty source file %s\n", m_szPathTranslated));
#endif
                THROW(E_SOURCE_FILE_IS_EMPTY);
                }
            }
        else
            {
            THROW(E_COULDNT_OPEN_SOURCE_FILE);
            }
        }

    // set file's start-of-file ptr
    if(NULL == (m_pbStartOfFile =
                (PBYTE) MapViewOfFile(
                                        m_hMap,         // file-mapping object to map into address space
                                        FILE_MAP_READ,  // access mode
                                        0,              // high-order 32 bits of file offset
                                        0,              // low-order 32 bits of file offset
                                        0               // number of bytes to map
                                    )))
        THROW(E_COULDNT_OPEN_SOURCE_FILE);
    }

/*  ============================================================================
    CTemplate::CFileMap::SetParent
    Set the parent for this filemap
*/
void
CTemplate::CFileMap::SetParent
(
CFileMap* pfilemapParent
)
    {
    CFileMap *pfilemap = this;

    while (pfilemap->m_fHasSibling)
        pfilemap = pfilemap->m_pfilemapSibling;

    pfilemap->m_pfilemapParent = pfilemapParent;
    }

/*  ============================================================================
    CTemplate::CFileMap::GetParent
    Get the parent for this filemap
*/
CTemplate::CFileMap*
CTemplate::CFileMap::GetParent
(
)
    {
    register CFileMap *pfilemap = this;

    while (pfilemap->m_fHasSibling)
        pfilemap = pfilemap->m_pfilemapSibling;

    return pfilemap->m_pfilemapParent;
    }

/*  ============================================================================
    CTemplate::CFileMap::AddSibling
    Add a new node as a sibling of this
*/
void
CTemplate::CFileMap::AddSibling
(
register CFileMap* pfilemapSibling
)
    {
    register CFileMap *pfilemap = this;

    while (pfilemap->m_fHasSibling)
        pfilemap = pfilemap->m_pfilemapSibling;

    pfilemapSibling->m_fHasSibling = FALSE;
    pfilemapSibling->m_pfilemapParent = pfilemap->m_pfilemapParent;

    pfilemap->m_fHasSibling = TRUE;
    pfilemap->m_pfilemapSibling = pfilemapSibling;
    }

/*  ============================================================================
    CTemplate::CFileMap::FCyclicInclude
    Is a file among this filemap's ancestors?  (i.e. does it occur anywhere
    in the filemap's parent chain?)

    Returns
        TRUE or FALSE
    Side effects
        None
*/
BOOL
CTemplate::CFileMap::FCyclicInclude
(
LPCTSTR  szPathTranslated
)
    {
    CFileMap *pfilemapParent = GetParent();

    if(pfilemapParent == NULL)
        return FALSE;

    // NOTE we ignore case because path-tran was normalized
    if(_tcscmp(szPathTranslated, pfilemapParent->m_szPathTranslated) == 0)
        return TRUE;

    return pfilemapParent->FCyclicInclude(szPathTranslated);
    }

/*  ============================================================================
    CTemplate::CFileMap::GetSecurityDescriptor
    Gets a file's security descriptor

    Returns
        TRUE if we got security descriptor, else FALSE
    Side effects
        allocates memory
*/
BOOL
CTemplate::CFileMap::GetSecurityDescriptor
(
)
    // ACLs: the following code should in future be shared with IIS (see creatfil.cxx in IIS project)
    {
    BOOL                    fRet = TRUE;                            // return value
    BOOL                    fGotSecurityDescriptor;                 // did we get a security descriptor?
    DWORD                   dwSecDescSizeNeeded = 0;                // required size of security descriptor
    DWORD                   dwLastError;                            // last error code
    const SECURITY_INFORMATION  si =    OWNER_SECURITY_INFORMATION      // security info struct
                                        | GROUP_SECURITY_INFORMATION
                                        | DACL_SECURITY_INFORMATION;

    // we dont support security on win95
    if (!Glob(fWinNT))
        return(TRUE);

    // get required buffer size before malloc
    // NOTE this costs us an extra system call, but means the cached template will often use less memory
    // we must do this up front by passing 0 buffer size because when the call succeeds it returns
    // dwSecDescSizeNeeded == 0 (i.e. we can't realloc to shrink after successful call)
    GetKernelObjectSecurity(
                            m_hFile,                // handle of object to query
                            si,                     // requested information
                            NULL,                   // address of security descriptor
                            0,                      // size of buffer for security descriptor
                            &dwSecDescSizeNeeded    // address of required size of buffer
                            );

    if((dwLastError = GetLastError()) != ERROR_INSUFFICIENT_BUFFER)
        {
        // pretend everything's fine -- just NULL security descriptor
        if(m_pSecurityDescriptor != NULL)
            CTemplate::SmallFree(m_pSecurityDescriptor);
        m_pSecurityDescriptor = NULL;
        m_dwSecDescSize = 0;
        if (dwLastError == ERROR_NOT_SUPPORTED)
            return TRUE;
        else
            return FALSE;
        }

    // set member buffer size to just enough chunks to accommodate security descriptor size needed
    m_dwSecDescSize = ((dwSecDescSizeNeeded + SECURITY_DESC_GRANULARITY - 1) / SECURITY_DESC_GRANULARITY)
                                * SECURITY_DESC_GRANULARITY;

    // allocate memory for security descriptor
    //  (Note: security descriptor may already be allocated if this is a remap)
    if (m_pSecurityDescriptor == NULL)
        if(NULL == (m_pSecurityDescriptor = (PSECURITY_DESCRIPTOR) CTemplate::SmallMalloc(m_dwSecDescSize)))
            THROW(E_OUTOFMEMORY);

    // try to get security descriptor until we succeed, or until we fail for some reason other than buffer-too-small
    while(TRUE)
        {
        // attempt to get security descriptor
        fGotSecurityDescriptor = GetKernelObjectSecurity(
                                    m_hFile,                // handle of object to query
                                    si,                     // requested information
                                    m_pSecurityDescriptor,  // address of security descriptor
                                    m_dwSecDescSize,        // size of buffer for security descriptor
                                    &dwSecDescSizeNeeded    // address of required size of buffer
                                );

        // get last error immediately after call
        dwLastError =   fGotSecurityDescriptor
                        ?   0                       // we got a security descriptor: set last error to 0
                        :   GetLastError();         // we didn't get a security descriptor: get last error

        if(fGotSecurityDescriptor)
            // we got a security descriptor, so break
            // NOTE we can't realloc m_pSecurityDescriptor to free its unused memory
            // because dwSecDescSizeNeeded is 0 after successful call
            break;

        else if(dwLastError == ERROR_INSUFFICIENT_BUFFER)
            {
            // we didn't get a security descriptor because buffer was too small: increase buffer size, realloc and continue.
            Assert(m_dwSecDescSize < dwSecDescSizeNeeded);

            // set member buffer size to just enough chunks to accommodate security descriptor size needed
            m_dwSecDescSize = ((dwSecDescSizeNeeded + SECURITY_DESC_GRANULARITY - 1) / SECURITY_DESC_GRANULARITY)
                                    * SECURITY_DESC_GRANULARITY;

            if(NULL == (m_pSecurityDescriptor = (PSECURITY_DESCRIPTOR) CTemplate::SmallReAlloc(m_pSecurityDescriptor, m_dwSecDescSize)))
                THROW(E_OUTOFMEMORY);
            }

        else
            {
            // we didn't get a security descriptor for some random reason: return failure
            fRet = FALSE;
            break;
            }

        }

    return fRet;
    }


/*  ============================================================================
    CTemplate::CFileMap::UnmapFile
    Unmaps a memory-mapped file
    NOTE this leaves the filemap's path-info and path-tran members intact

    Returns
        Nothing
    Side effects
        None
*/
void
CTemplate::CFileMap::UnmapFile
(
)
    {
    if(m_pbStartOfFile != NULL)
        if(!UnmapViewOfFile(m_pbStartOfFile)) THROW(E_FAIL);

    if(m_hMap!= NULL)
        if(!CloseHandle(m_hMap)) THROW(E_FAIL);

    if(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE)
        if(!CloseHandle(m_hFile)) THROW(E_FAIL);

    // Null-ify ptr and handles, since MapFile checks for non-null
    m_pbStartOfFile = NULL;
    m_hMap = NULL;
    m_hFile = NULL;
    }

/*  ============================================================================
    CTemplate::CFileMap::CountChars
    Count the number of characters in the (open) filemap

    Returns:
        # of characters in the file
*/
DWORD
CTemplate::CFileMap::CountChars
(
WORD wCodePage
)
    {
    // Bug 84284: Scripts containing object tags only do not have the DBCS table built
    //             (Because there is no line mapping table to base it from)
    //
    CTemplate::COffsetInfo *pOffsetInfoLast, oiZero;
    pOffsetInfoLast = (m_rgByte2DBCS.length() == 0)
                            ? &oiZero
                            : &m_rgByte2DBCS[m_rgByte2DBCS.length() - 1];

    // If GetSize() fails don't count the remaining DBCS characters - otherwise an AV
    DWORD cchFilemap = GetSize();
    if (cchFilemap != 0xFFFFFFFF && cchFilemap != 0)
        {
        // Count DBCS characters
        m_cChars = pOffsetInfoLast->m_cchOffset +
                      CharAdvDBCS(wCodePage,
                                  reinterpret_cast<char *>(m_pbStartOfFile + pOffsetInfoLast->m_cbOffset),
                                  reinterpret_cast<char *>(m_pbStartOfFile + cchFilemap),
                                  INFINITE, NULL);

        }
    else
        {
        m_cChars = 0;
        }

    // Done counting DBCS characters
    return m_cChars;
    }

/*  ============================================================================
    CTemplate::CFileMap::GetText
    From a character offset and length, return the document text

    File must be mapped
*/
HRESULT CTemplate::CFileMap::GetText
(
WORD wCodePage,
ULONG cchSourceOffset,
WCHAR *pwchText,
SOURCE_TEXT_ATTR *pTextAttr,
ULONG *pcChars,
ULONG cMaxChars
)
    {
    ULONG cCharsCopied;
    if (pcChars == NULL)
        pcChars = &cCharsCopied;

    // Map the file (temporarily) if not mapped
    BOOL fRemapFile = !FIsMapped();
    TRY
        RemapFile();
    CATCH (dwException)
        return E_FAIL;
    END_TRY

    /* Find the byte offset closest to cchSourceOffset.  This will be
     * the place where we start looping with CharNext() to get the full
     * byte offset.
     */
    COffsetInfo *pOffsetInfoLE = NULL, OffsetInfoT;

    /*
     * NOTE: compilation is done in two phases.
     *          Errors are detected and reported in phase 1.
     *          The DBCS mapping is created in phase 2.
     *
     * If an error occurred during compilation, the DBCS table does not exist.
     * If there is no DBCS mapping table, then pretend like we found entry with
     * nearest offset == 0.  (unless this is SBCS in which case nearest
     * offset == cchSourceOffset)
     */
    if (m_rgByte2DBCS.length() == 0)
        {
        CPINFO  CpInfo;
        GetCPInfo(wCodePage, &CpInfo);
        OffsetInfoT.m_cbOffset = OffsetInfoT.m_cchOffset = (CpInfo.MaxCharSize == 1)? cchSourceOffset : 0;
        pOffsetInfoLE = &OffsetInfoT;
        }
    else
        GetBracketingPair(
                cchSourceOffset,                        // value to search for
                m_rgByte2DBCS.begin(),                  // beginning of array to search
                m_rgByte2DBCS.end(),                    // end of array
                CCharOffsetOrder(),                     // order by character offsets
                &pOffsetInfoLE,                         // desired offset
                static_cast<COffsetInfo **>(NULL)       // don't care
                );

    /* OK - pOffsetLE->cbOffset contains the closest offset not exceeding
     *      cchSourceOffset.  Iterate over the remainder of the characters
     *      to convert the cch to a cb.  It had better exist!
     */
    Assert (pOffsetInfoLE != NULL);

    // Advance over remaining characters
    char *pchStart;
    CharAdvDBCS(wCodePage,
                reinterpret_cast<char *>(m_pbStartOfFile + pOffsetInfoLE->m_cbOffset),
                reinterpret_cast<char *>(m_pbStartOfFile + GetSize()),
                cchSourceOffset - pOffsetInfoLE->m_cchOffset,
                &pchStart
                );

    // Compute # of Characters to copy
    Assert (m_cChars >= cchSourceOffset);
    *pcChars = min(cMaxChars, m_cChars - cchSourceOffset);

    // Compute # of Bytes to copy
    char *pchEnd;
    CharAdvDBCS(wCodePage,
                pchStart,
                reinterpret_cast<char *>(m_pbStartOfFile + GetSize()),
                *pcChars,
                &pchEnd
                );

    if (pwchText)
        MultiByteToWideChar(
                        (WORD)wCodePage,
                        0,
                        pchStart,
                        DIFF(pchEnd - pchStart),
                        pwchText,
                        cMaxChars
                        );

    // We don't support syntax coloring, so set all the character attributes to
    // default color (black)
    if (pTextAttr)
        memset(pTextAttr, 0, *pcChars);

    // Unmap the file (but only if we previously remapped it)
    if (fRemapFile)
        TRY
            UnmapFile();
        CATCH (dwException)
            return E_FAIL;
        END_TRY

    return S_OK;
    }

/*  ****************************************************************************
    CTemplate::CTokenList member functions
*/

/*  ============================================================================
    CTemplate::CTokenList::Init
    Populates token list with tokens

    Returns
        Nothing
    Side effects
        None
*/
void
CTemplate::CTokenList::Init
(
)
    {
    // Init tokens buffer for local storage
    m_bufTokens.Init(tkncAll, CB_TOKENS_DEFAULT);

    // append tokens to buffer
    // NOTE *** TOKENS MUST BE IN SAME ORDER AS ENUM TYPE VALUES ***
    // NOTE 'superset' token must precede 'subset' token (e.g. <!--#INCLUDE before <!--)
    AppendToken(tknOpenPrimaryScript,   "<%");
    AppendToken(tknOpenTaggedScript,    "<SCRIPT");
    AppendToken(tknOpenObject,          "<OBJECT");
    AppendToken(tknOpenHTMLComment,     "<!--");

    AppendToken(tknNewLine,             SZ_NEWLINE);

    AppendToken(tknClosePrimaryScript,  "%>");
    AppendToken(tknCloseTaggedScript,   "</SCRIPT>");
    AppendToken(tknCloseObject,         "</OBJECT>");
    AppendToken(tknCloseHTMLComment,    "-->");
    AppendToken(tknEscapedClosePrimaryScript,   "%\\>");

    AppendToken(tknCloseTag,            ">");

    AppendToken(tknCommandINCLUDE,      "#INCLUDE");

    AppendToken(tknTagRunat,            "RUNAT");
    AppendToken(tknTagLanguage,         "LANGUAGE");
    AppendToken(tknTagCodePage,         "CODEPAGE");
    AppendToken(tknTagCodePage,         "LCID");
    AppendToken(tknTagTransacted,       "TRANSACTION");
    AppendToken(tknTagSession,          "ENABLESESSIONSTATE");
    AppendToken(tknTagID,               "ID");
    AppendToken(tknTagClassID,          "CLASSID");
    AppendToken(tknTagProgID,           "PROGID");
    AppendToken(tknTagScope,            "SCOPE");
    AppendToken(tknTagVirtual,          "VIRTUAL");
    AppendToken(tknTagFile,             "FILE");
    AppendToken(tknTagMETADATA,         "METADATA");
//  AppendToken(tknTagSetPriScriptLang, "@");
    AppendToken(tknTagName,             "NAME");
    AppendToken(tknValueTypeLib,        "TYPELIB");
    AppendToken(tknTagType,             "TYPE");
    AppendToken(tknTagUUID,             "UUID");
    AppendToken(tknTagVersion,          "VERSION");
    AppendToken(tknTagStartspan,        "STARTSPAN");
    AppendToken(tknTagEndspan,          "ENDSPAN");
    AppendToken(tknValueCookie,         "COOKIE");
    AppendToken(tknTagSrc,              "SRC");

    AppendToken(tknValueServer,         "Server");
    AppendToken(tknValueApplication,    "Application");
    AppendToken(tknValueSession,        "Session");
    AppendToken(tknValuePage,           "Page");

    AppendToken(tknVBSCommentSQuote,    "'");
    AppendToken(tknVBSCommentRem,       "REM ");    // NOTE ends with space character
    AppendToken(tknTagFPBot,            "webbot");

    AppendToken(tknEOF,                 "");

    AppendToken(tkncAll,                "");

    }

/*  ============================================================================
    CTemplate::CTokenList::AppendToken
    Appends a string to tokens buffer
    NOTE we keep the unused tkn parameter because it enforces consistency and
    readability in CTemplate::CTokenList::Init(), e.g.
        AppendToken(tknOpenPrimaryScript,   "<%");
    rather than
        AppendToken("<%");

    Returns:
        Nothing
    Side effects:
        None
*/
void
CTemplate::CTokenList::AppendToken
(
_TOKEN  tkn,    // token value
char*   sz      // token string
)
    {
    // construct byte range from token string
    CByteRange  br;
    br.m_pb = (BYTE*) sz;
    br.m_cb = strlen(sz);

    // append to tokens buffer as local string
    m_bufTokens.Append(br, TRUE, 0, NULL, TRUE);
    }

/*  ============================================================================
    CTemplate::CTokenList::NextOpenToken
    Returns value of next open token in search range

    Returns
        token value of next open token in search range; ptr to ptr to open token (out-parameter)
    Side effects
        None
*/
_TOKEN
CTemplate::CTokenList::NextOpenToken
(
CByteRange& brSearch,       // search byte range
TOKEN*      rgtknOpeners,   // array of permitted open tokens
UINT        ctknOpeners,    // count of permitted open tokens
BYTE**      ppbToken,       // ptr to ptr to open token (out-parameter)
LONG        lCodePage
)
    {
    BYTE*       pbTemp = NULL;  // temp pointer
    _TOKEN      tkn = tknEOF;   // return value
    USHORT      i;              // loop index

    // Init caller's token ptr to null
    *ppbToken = NULL;

    // If input is empty, return
    if (brSearch.IsNull())
        return tkn;

    // Prepare array of LPSTR pointers to tokens.
    // Do it here once, because to get LPSTR is not free.
    LPSTR rgszTokens[TOKEN_OPENERS_MAX];
    UINT  rgcchTokens[TOKEN_OPENERS_MAX];
    Assert(ctknOpeners <= TOKEN_OPENERS_MAX);

    for (i = 0; i < ctknOpeners; i++)
        {
        LPSTR pszStr = m_bufTokens.PszLocal((UINT)(rgtknOpeners[i]));
        rgszTokens[i]  = pszStr;
        rgcchTokens[i] = (pszStr != NULL) ? strlen(pszStr) : 0;
        }

    // Call a method to find one of the strings in the range
    UINT idToken;
    pbTemp = brSearch.PbOneOfAspOpenerStringTokens(
        rgszTokens, rgcchTokens, ctknOpeners, &idToken);
    if (pbTemp != NULL)
        {
        *ppbToken = pbTemp;
        tkn = rgtknOpeners[idToken];
        }

    // If we found no open token, position token pointer at end of search range
    if (tkn == tknEOF)
        *ppbToken = brSearch.m_pb + brSearch.m_cb;

    return tkn;
    }

/*  ============================================================================
    CTemplate::CTokenList::MovePastToken
    Moves a byte range past a token contained within it
*/
void
CTemplate::CTokenList::MovePastToken
(
_TOKEN      tkn,
BYTE*       pbToken,
CByteRange& brSearch
)
    {
    Assert(pbToken >= brSearch.m_pb);
    Assert(brSearch.m_cb >= (DIFF(pbToken - brSearch.m_pb) + CCH_TOKEN_X(tkn)));
    brSearch.Advance(DIFF(pbToken - brSearch.m_pb) + CCH_TOKEN_X(tkn));
    }

/*  ============================================================================
    CTemplate::CTokenList::GetToken
    Gets the next occurrence of a token within a byte range.

    Returns:
        ptr to token
    Side effects
        none
*/
BYTE*
CTemplate::CTokenList::GetToken
(
TOKEN       tkn,
CByteRange& brSearch,
LONG        lCodePage
)
    {
    return brSearch.PbString(m_bufTokens.PszLocal((UINT)tkn), lCodePage);
    }

/*  ============================================================================
    The Big Three for CTemplateConnPt

    NOTES:
        Since this interface is embedded in CTemplate,
        AddRef() and Release() delegate to the container object (because that
        is the CTemplate pointer)
*/
HRESULT
CTemplateConnPt::QueryInterface(const GUID &uidInterface, void **ppvObj)
    {
    if (uidInterface == IID_IUnknown || uidInterface == IID_IConnectionPoint)
        {
        *ppvObj = this;
        AddRef();
        return S_OK;
        }
    else
        {
        *ppvObj = NULL;
        return E_NOINTERFACE;
        }
    }

ULONG
CTemplateConnPt::AddRef()
    {
    return m_pUnkContainer->AddRef();
    }

ULONG
CTemplateConnPt::Release()
    {
    return m_pUnkContainer->Release();
    }

/*  ============================================================================
    Constructor for CDocNode
*/
CTemplate::CDocNodeElem::CDocNodeElem(CAppln *pAppln, IDebugApplicationNode *pDocRoot)
    {
    Assert (pAppln != NULL);
    Assert (pDocRoot != NULL);

    (m_pAppln = pAppln)->AddRef();
    (m_pDocRoot = pDocRoot)->AddRef();
    }

/*  ============================================================================
    Destructor for CDocNode
*/
CTemplate::CDocNodeElem::~CDocNodeElem()
    {
    m_pAppln->Release();
    DestroyDocumentTree(m_pDocRoot);
    }

/*  ============================================================================
    CTemplate::fIsLangVBScriptOrJScript(USHORT idEngine)

    This function returns T/F to determine if the requested script engine
    is VBScript or JScript. This function is used as an indicator to determin
    if spaces need to be preserved for non MS Scripting languages

    There is an assumption here that the GUIDs for VBScript and JScript will not change

    Inputs
        Index to a script engine

    Returns
        BOOL
*/
BOOLB CTemplate::FIsLangVBScriptOrJScript(USHORT idEngine)
    {
    // {b54f3741-5b07-11cf-a4b0-00aa004a55e8} VBScript
    static const GUID uid_VBScript  = {0xb54f3741, 0x5b07, 0x11cf, {0xa4, 0xb0, 0x00, 0xaa, 0x00, 0x4a, 0x55, 0xe8}};

    // {f414c260-6ac0-11cf-b6d1-00aa00bbbb58} JavaScript
    static const GUID uid_JScript   = {0xf414c260, 0x6ac0, 0x11cf, {0xb6, 0xd1, 0x00, 0xaa, 0x00, 0xbb, 0xbb, 0x58}};

        // {b54f3743-5b07-11cf-a4b0-00aa004a55e8} VBScript.Encode
        static const GUID uid_VBScriptEncode = {0xb54f3743, 0x5b07, 0x11cf, {0xa4, 0xb0, 0x00, 0xaa, 0x00, 0x4a, 0x55, 0xe8}};

        // {f414c262-6ac0-11cf-b6d1-00aa00bbbb58} JavaScript.Encode
        static const GUID uid_JScriptEncode = {0xf414c262, 0x6ac0, 0x11cf, {0xb6, 0xd1, 0x00, 0xaa, 0x00, 0xbb, 0xbb, 0x58}};

        GUID &uidLang = m_pWorkStore->m_ScriptStore.m_rgProgLangId[idEngine];
        return
                uidLang == uid_VBScript || uidLang == uid_VBScriptEncode ||
                uidLang == uid_JScript  || uidLang == uid_JScriptEncode;
    }


SIZE_T
_RoundUp(
    SIZE_T dwBytes)
{
#if 1
    // 16KB <= dwBytes? Round up to next multiple of 4KB
    if (16*1024 <= dwBytes)
        dwBytes = ((dwBytes + (1<<12) - 1) >> 12) << 12;

    // 4KB <= dwBytes < 16KB? Round up to next multiple of 1KB
    else if (4*1024 <= dwBytes)
        dwBytes = ((dwBytes + (1<<10) - 1) >> 10) << 10;

    // 1KB <= dwBytes < 4KB? Round up to next multiple of 256 bytes
    else if (1024 <= dwBytes)
        dwBytes = ((dwBytes + (1<<8) - 1) >> 8) << 8;

    // dwBytes < 1KB? Round up to next multiple of 32 bytes
    else
        dwBytes = ((dwBytes + (1<<5) - 1) >> 5) << 5;
#endif

    return dwBytes;
}

void*
CTemplate::SmallMalloc(SIZE_T dwBytes)
{
    DBG_ASSERT(sm_hSmallHeap != NULL);
    dwBytes = _RoundUp(dwBytes);
    return ::HeapAlloc(sm_hSmallHeap, 0, dwBytes);
}


void*
CTemplate::SmallReAlloc(void* pvMem, SIZE_T dwBytes)
{
    DBG_ASSERT(sm_hSmallHeap != NULL);
    dwBytes = _RoundUp(dwBytes);
    return ::HeapReAlloc(sm_hSmallHeap, 0, pvMem, dwBytes);
}


void
CTemplate::SmallFree(void* pvMem)
{
    DBG_ASSERT(sm_hSmallHeap != NULL);
    ::HeapFree(sm_hSmallHeap, 0, pvMem);
}

void*
CTemplate::LargeMalloc(SIZE_T dwBytes)
{
    DBG_ASSERT(sm_hLargeHeap != NULL);
    dwBytes = _RoundUp(dwBytes);
    return ::HeapAlloc(sm_hLargeHeap, 0, dwBytes);
}


void*
CTemplate::LargeReAlloc(void* pvMem, SIZE_T dwBytes)
{
    DBG_ASSERT(sm_hLargeHeap != NULL);
    dwBytes = _RoundUp(dwBytes);
    return ::HeapReAlloc(sm_hLargeHeap, 0, pvMem, dwBytes);
}


void
CTemplate::LargeFree(void* pvMem)
{
    DBG_ASSERT(sm_hLargeHeap != NULL);
    ::HeapFree(sm_hLargeHeap, 0, pvMem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\vecimpl.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: misc

File: vector.h

Owner: DGottner

This file contains a dynamic array
===================================================================*/

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright 1994, David Gottner
 *
 *                    All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice, this permission notice and
 * the following disclaimer notice appear unmodified in all copies.
 *
 * I DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL I
 * BE LIABLE FOR ANY SPECIAL, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
 * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef VECIMPL_H
#define VECIMPL_H


#define VEC_GROW_SIZE 64		// grow in chunks of this many items
#define __vec_rounded_size(s) \
			(((s) + (VEC_GROW_SIZE - 1)) & ~(VEC_GROW_SIZE - 1))


template <class TYPE>
vector<TYPE>::vector() : m_rgData(NULL), m_cItems(0), m_cCells(0)
{
}


template <class TYPE>
HRESULT vector<TYPE>::Init(const TYPE *anArray, size_t theSize)
{
	m_cCells = __vec_rounded_size(theSize);

	register size_t      n     = m_cItems = theSize;
	register TYPE *      pDest = m_rgData = new TYPE[m_cCells];
	register const TYPE *pSrc  = anArray;

	if (pDest == NULL)
		{
		m_cItems = m_cCells = 0;
		return E_OUTOFMEMORY;
		}

	while (n--)
		*pDest++ = *pSrc++;

	return S_OK;
}


template <class TYPE>
HRESULT vector<TYPE>::Init(size_t n)
{
	m_rgData = new TYPE[m_cCells = __vec_rounded_size(m_cItems = n)];
	if (m_rgData == NULL)
		{
		m_cItems = m_cCells = 0;
		return E_OUTOFMEMORY;
		}

	return S_OK;
}


template <class TYPE>
vector<TYPE>::~vector()
{
	delete[] m_rgData;
}


template <class TYPE>
HRESULT vector<TYPE>::resize(size_t cNewCells)
{
	cNewCells = __vec_rounded_size(cNewCells);
	if (m_cCells == cNewCells)
		return S_OK;

	TYPE *rgData = new TYPE[cNewCells];
	if (rgData == NULL)
		return E_OUTOFMEMORY;

	register size_t      n     = (m_cItems < cNewCells)? m_cItems : cNewCells;
	register TYPE *      pDest = rgData;
	register const TYPE *pSrc  = m_rgData;

	m_cItems = n;
	m_cCells = cNewCells;

	while (n--)
		*pDest++ = *pSrc++;

	delete[] m_rgData;
	m_rgData = rgData;

	return S_OK;
}


template <class TYPE>
HRESULT vector<TYPE>::reshape(size_t cNewItems)
{
	HRESULT hrRet = S_OK;
	if (cNewItems > m_cCells)
		hrRet = resize(cNewItems);

	if (SUCCEEDED(hrRet))
		m_cItems = cNewItems;

	return hrRet;
}


template <class TYPE>
HRESULT vector<TYPE>::insertAt(size_t pos, const TYPE &item)
{
	Assert (pos <= m_cItems);

	HRESULT hrRet = S_OK;
	if ((m_cItems + 1) > m_cCells)
		hrRet = resize(m_cCells + VEC_GROW_SIZE);

	if (SUCCEEDED(hrRet))
		{
		TYPE *pDest = &m_rgData[pos];
		for (register TYPE *ptr = &m_rgData[m_cItems];
			 ptr > pDest;
			 --ptr)
			*ptr = *(ptr - 1);

		*pDest = item;
		++m_cItems;
		}

	return hrRet;
}


template <class TYPE>
TYPE vector<TYPE>::removeAt(size_t pos)
{
	Assert (pos < m_cItems);

	TYPE *         end = &m_rgData[--m_cItems];
	register TYPE *ptr = &m_rgData[pos];
	TYPE           val = *ptr;

	for (; ptr < end; ++ptr)
		*ptr = *(ptr + 1);

	return val;
}


template <class TYPE>
int vector<TYPE>::find(const TYPE &item) const
{
	for (register unsigned i = 0; i < m_cItems; ++i)
		if (item == m_rgData[i])
			return i;

	return -1;
}

#endif /* VECIMPL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\templcap.h ===
/*==============================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996-1999 Microsoft Corporation. All Rights Reserved.

File:			templcap.h
Maintained by:	DaveK
Component:		include file for CTemplate 'captive' classes
				'captive' == only used internally within CTemplate
	
==============================================================================*/

// forward refs
class CBuffer;
class CFileMap;
class DIR_MONTIOR_ENTRY;

/*	============================================================================
	Enum type:	SOURCE_SEGMENT
	Synopsis:	A contiguous segment of a source template, e.g. primary script, html, etc.
*/
enum SOURCE_SEGMENT
	{
	ssegHTML,
	ssegPrimaryScript,
	ssegTaggedScript,
	ssegObject,
	ssegInclude,
	ssegMetadata,
	ssegHTMLComment,
        ssegFPBot,
	};

/*	****************************************************************************
	Class:		CSourceInfo
	Synopsis:	Info on the source of an output

	NOTE: The target offsets are strictly increasing, so it is binary
	      searchable.  (This is good because this is the search key
	      used by the debugger workhorse API, GetSourceContextOfPosition)
	      Beware, however, that source offsets and line #s are not, in
	      general, binary searchable because of #include files being thrown
	      into the mix.

		TODO DBCS:
	      Both the corresponding byte AND character offsets for the source are
	      stored in this table.  Character offsets are used by all of the API
	      interfaces, but the GetText() API must know what byte offset corresponds
	      to a character offset.  To figure this out, GetText() looks for the
	      closest character offset in the file and uses that as its base for
	      figuring out the byte offset.
*/
class CSourceInfo
	{
	public:
		CFileMap *		m_pfilemap;			// filemap to source file
		unsigned		m_cchTargetOffset;	// target offset (target line # implicit)
		unsigned		m_cchSourceOffset;	// character offset of the source line
		unsigned		m_cchSourceText;	// # of characters in the source statement
		unsigned		m_idLine:31;		// line number in source file
		unsigned		m_fIsHTML:1;		// line number is start of HTML block

		// UNSAFE if virtual functions ever added to this class!
		CSourceInfo() { memset(this, 0, sizeof(*this)); }
	};

/*	****************************************************************************
	Class:		CTargetOffsetOrder
	Synopsis:	provides ordering function for GetBracketingPair() based on
	            target offsets in the CSourceInfo array
*/
class CTargetOffsetOrder
	{
	public:
		BOOL operator()(const CSourceInfo &si, ULONG ul)
			{ return si.m_cchTargetOffset < ul; }

		BOOL operator()(ULONG ul, const CSourceInfo &si)
			{ return ul < si.m_cchTargetOffset; }
	};

/*	****************************************************************************
	Class:		CBuffer
	Synopsis:	A self-sizing memory buffer
*/
class CBuffer
	{
	private:
		CByteRange*	m_pItems;		// ptr to items (i.e. byte ranges)
		USHORT		m_cSlots;		// count of item slots allocated
		USHORT		m_cItems;		// count of items actually stored
		BYTE*		m_pbData;		// ptr to local data storage for items
		ULONG		m_cbData;		// size of local data storage for items
		ULONG		m_cbDataUsed;	// amount of local data storage actually used

	public:
		CBuffer();
		~CBuffer();
		void		Init(USHORT cItems, ULONG cbData);
		USHORT		Count()	{	return m_cItems;	}
		USHORT		CountSlots()	{	return m_cSlots;	}
		void		GetItem(UINT i, CByteRange& br);
		CByteRange* operator[](UINT i) { return &m_pItems[i]; }
		void		SetItem(UINT i, const CByteRange& br, BOOL fLocal, UINT idSequence, CFileMap *pfilemap, BOOL fLocalString = FALSE);
		void		Append(const CByteRange& br, BOOL fLocal, UINT idSequence, CFileMap *pfilemap, BOOL fLocalString = FALSE);
		LPSTR		PszLocal(UINT i);

        // Cache on per-class basis
        // ACACHE_INCLASS_DEFINITIONS()
	};

/*	****************************************************************************
	Class:		CScriptStore
	Synopsis:	Working storage for script segments during compilation.

	Terminology
	-----------
	Engine		== a particular script engine (VBScript, JavaScript, etc)
	Segment		== a contiguous chunk of script text in the source file
*/
class CScriptStore
	{
public:
	CBuffer**		m_ppbufSegments;	// ptr to array of ptrs to script segment buffers, one per engine
	UINT			m_cSegmentBuffers;	// count of script segment buffers
	CBuffer			m_bufEngineNames;	// buffer of engine names, one per engine
	PROGLANG_ID* 	m_rgProgLangId;		// array of prog lang ids, one per engine
	
	CScriptStore(): m_ppbufSegments(NULL), m_cSegmentBuffers(0), m_rgProgLangId(NULL) {}
	~CScriptStore();
	HRESULT	Init(LPCSTR szDefaultScriptLanguage, CLSID *pCLSIDDefaultEngine);
	USHORT 	CountPreliminaryEngines() { return m_bufEngineNames.Count(); }
	HRESULT	AppendEngine(CByteRange& brEngine, PROGLANG_ID*	pProgLangId, UINT idSequence);
	USHORT 	IdEngineFromBr(CByteRange& brEngine, UINT idSequence);
	void	AppendScript(CByteRange& brScript, CByteRange& brEngine, BOOLB fPrimary, UINT idSequence, CFileMap* pfilemap);

	};

/*	****************************************************************************
	Class:		CObjectInfo
	Synopsis:	Information about an object which can be determined at compile time
*/
class CObjectInfo
	{
public:
	CLSID	    m_clsid;	// clsid
	CompScope	m_scope;	// scope: application, session, page
	CompModel	m_model;	// threading model: single, apt, free
	};

/*	****************************************************************************
	Class:		CObjectInfoStore
	Synopsis:	Working storage for object-infos during compilation.
*/
class CObjectInfoStore
	{
public:
	CObjectInfo*	m_pObjectInfos;		// array of object infos
	CBuffer			m_bufObjectNames;	// buffer of object names

	CObjectInfoStore(): m_pObjectInfos(NULL) {}
	~CObjectInfoStore();
	void	Init();
	void	AppendObject(CByteRange& brObjectName, CLSID clsid, CompScope scope, CompModel model, UINT idSequence);
	USHORT	Count() { return m_bufObjectNames.Count(); }

	};

/*	****************************************************************************
	Class:		CWorkStore
	Synopsis:	Working storage for template components
*/
class CWorkStore
	{
public:
	CBuffer				m_bufHTMLSegments;	// buffer of HTML segments
	CObjectInfoStore	m_ObjectInfoStore;	// object-infos store
	CScriptStore		m_ScriptStore;		// script store
	UINT				m_idCurSequence;	// sequence number for current segment
	CByteRange			m_brCurEngine;		// current script engine
	BOOLB				m_fPageCommandsExecuted;	// have we executed page-level @ commands yet?
	BOOLB				m_fPageCommandsAllowed;		// are we allowed to execute page-level @ commands?
													// (will be true iff we have not yet compiled any line of script)
	LPSTR				m_szWriteBlockOpen;			// open  for Response.WriteBlock() equivalent
	LPSTR				m_szWriteBlockClose;		// close for Response.WriteBlock() equivalent
	LPSTR				m_szWriteOpen;				// open  for Response.Write() equivalent
	LPSTR				m_szWriteClose;				// close for Response.Write() equivalent

	
	
	
			CWorkStore();
			~CWorkStore();
	void 	Init();
	USHORT 	CRequiredScriptEngines(BOOL	fGlobalAsa);
	BOOLB 	FScriptEngineRequired(USHORT idEnginePrelim, BOOL	fGlobalAsa);

	};

/*	****************************************************************************
	Class:		COffsetInfo
	Synopsis:	map byte offsets to character offsets (different for DBCS)
				on line boundaries

	Each CFileMap has an array of these COffsetInfo structures at each line boundary.
	It stores these at the same offsets in the CSourceInfo array so that a simple
	binary search is all that's needed to convert offsets.
*/
class COffsetInfo
	{
	public:
		unsigned		m_cchOffset;		// character offset in file
		unsigned		m_cbOffset;			// byte offset in file

		// UNSAFE if virtual functions ever added to this class!
		COffsetInfo() { memset(this, 0, sizeof(*this)); }
	};

/*	****************************************************************************
	Class:		CByteOffsetOrder
	Synopsis:	provides ordering function for GetBracketingPair() based on
				byte offsets in the COffsetInfo array
*/
class CByteOffsetOrder
	{
	public:
		BOOL operator()(const COffsetInfo &oi, ULONG ul)
			{ return oi.m_cbOffset < ul; }

		BOOL operator()(ULONG ul, const COffsetInfo &oi)
			{ return ul < oi.m_cbOffset; }
	};

/*	****************************************************************************
	Class:		CCharOffsetOrder
	Synopsis:	provides ordering function for GetBracketingPair() based on
				character offsets in the COffsetInfo array
*/
class CCharOffsetOrder
	{
	public:
		BOOL operator()(const COffsetInfo &oi, ULONG ul)
			{ return oi.m_cchOffset < ul; }

		BOOL operator()(ULONG ul, const COffsetInfo &oi)
			{ return ul < oi.m_cchOffset; }
	};

/*	****************************************************************************
	Class:		CFileMap
	Synopsis:	A memory-mapping of a file

	NOTE: We store an incfile-template dependency by storing an incfile ptr in m_pIncFile.
	This is efficient but ***will break if we ever change Denali to move its memory around***
*/
class CFileMap
	{
public:
	TCHAR *					m_szPathInfo;			// file's virtual path (from www root)
	TCHAR *					m_szPathTranslated;		// file's actual file system path
	union {											// NOTE: m_fHasSibling is used to disambiguate these two
		CFileMap*			m_pfilemapParent;		// ptr to filemap of parent file
		CFileMap*			m_pfilemapSibling;		// ptr to next filemap in same level of hierarchy
	};
	CFileMap*				m_pfilemapChild;		// index of first filemap in next lower level of hierarchy
	HANDLE					m_hFile;				// file handle
	HANDLE					m_hMap;					// file map handle
	BYTE*					m_pbStartOfFile;		// ptr to start of file
	CIncFile*				m_pIncFile;				// ptr to inc-file object
	PSECURITY_DESCRIPTOR	m_pSecurityDescriptor;	// ptr to file's security descriptor
	unsigned long			m_dwSecDescSize:30;		// size of security descriptor
	unsigned long			m_fHasSibling:1;		// Does a sibling exist for this node?
	unsigned long			m_fHasVirtPath:1;		// Is m_szPathInfo the virtual or physical path?
	FILETIME	            m_ftLastWriteTime;		// last time the file was written to
	DWORD					m_cChars;				// # of characters in the file
	vector<COffsetInfo>		m_rgByte2DBCS;			// line-by-line map of byte offsets to DBCS
	CDirMonitorEntry*		m_pDME;				// pointer to directory monitor entry for this file

				CFileMap();
				~CFileMap();
	void 		MapFile(LPCTSTR szFileSpec, LPCTSTR szApplnPath, CFileMap* pfilemapParent, BOOL fVirtual, CHitObj* pRequest, BOOL fGlobalAsp);
	void		RemapFile();
	void 		UnmapFile();

	CFileMap*	GetParent();
	void		SetParent(CFileMap *);

	void		AddSibling(CFileMap *);
	CFileMap*	NextSibling() { return m_fHasSibling? m_pfilemapSibling : NULL; }

	BOOL		FIsMapped()
					{ return m_pbStartOfFile != NULL; }

	BOOL		FHasVirtPath() 
					{ return m_fHasVirtPath; }

	BOOL		FCyclicInclude(LPCTSTR szPathTranslated);
	BOOL		GetSecurityDescriptor();
	DWORD       GetSize() { return GetFileSize(m_hFile, NULL); }		// return # of bytes
	DWORD		CountChars(WORD wCodePage);							// return # of chars

	// implementation of debugging iterface - CTemplate & CIncFile eventually delegate to this function
	HRESULT		GetText(WORD wCodePage, ULONG cchSourceOffset, WCHAR *pwchText, SOURCE_TEXT_ATTR *pTextAttr, ULONG *pcChars, ULONG cMaxChars);

	// Cache on per-class basis
	ACACHE_INCLASS_DEFINITIONS()
	};

/*	****************************************************************************
	Class:		CTokenList
	Synopsis:	A list of tokens.
*/
class CTokenList
{
public:
	/*	========================================================================
	Enum type:	TOKEN
	Synopsis:	Token type.
				NOTE: keep sync'ed with CTokenList::Init()
	*/
	enum TOKEN
	{
		//======== Opener tokens ==================================
		tknOpenPrimaryScript,	// open primary script segment
		tknOpenTaggedScript,	// open tagged script segment
		tknOpenObject,			// open object segment
		tknOpenHTMLComment,		// open HTML comment
		
		//======== Non-opener tokens ==============================
		tknNewLine,				// new line

		tknClosePrimaryScript,	// close primary script segment
		tknCloseTaggedScript,	// close primary script segment
		tknCloseObject,			// close object segment
		tknCloseHTMLComment,	// close HTML comment
		tknEscapedClosePrimaryScript,	// escaped close-primary-script symbol

		tknCloseTag,			// close object or script tag

		tknCommandINCLUDE,		// server-side include (SSI) INCLUDE command
		
		tknTagRunat,			// RUNAT script/object attribute
		tknTagLanguage,			// LANGUAGE tag: page-level compiler directive or script block attribute
		tknTagCodePage,			// CODEPAGE tag: page-level compiler directive
		tknTagLCID,				// LCID tag: page-level compiler directive
		tknTagTransacted,		// TRANSACTED tag: page-level compiler directive
		tknTagSession,		    // SESSION tag: page-level compiler directive
		tknTagID,				// ID object attribute
		tknTagClassID,			// CLASSID object attribute
		tknTagProgID,			// PROGID object attribute
		tknTagScope,			// SCOPE object attribute
		tknTagVirtual,			// VIRTUAL include file attribute
		tknTagFile,				// FILE include file attribute
		tknTagMETADATA,			// METADATA tag - used by IStudio
//		tknTagSetPriScriptLang,	// sets primary script language, as in <% @ LANGUAGE = VBScript %>
        tknTagName,             // NAME inside METADATA
		tknValueTypeLib,        // TypeLib inside METADATA (has to be before TYPE in the list)
        tknTagType,             // TYPE inside METADATA
        tknTagUUID,             // UUID inside METADATA
        tknTagVersion,          // VERSION inside METADATA
        tknTagStartspan,        // STARTSPAN inside METADATA
        tknTagEndspan,          // ENDSPAN inside METADATA
        tknValueCookie,         // TYPE=Cookie inside METADATA
        tknTagSrc,              // SRC= inside METADATA
		
		tknValueServer,			// Server value - e.g. RUNAT=Server
		tknValueApplication,	// SCOPE=Application
		tknValueSession,		// SCOPE=Session
		tknValuePage,			// SCOPE=Page

		tknVBSCommentSQuote,	// VBS comment symbol
		tknVBSCommentRem,		// VBS comment symbol (alternate)

        tknTagFPBot,            // Front Page webbot tag
		
		tknEOF,					// end-of-file pseudo-token

		tkncAll					// pseudo-token: count of all tokens
	};

	void		Init();
	CByteRange* operator[](UINT i) { return m_bufTokens[i]; }
	CByteRange* operator[](TOKEN tkn) { return operator[]((UINT) tkn); }
	void		AppendToken(TOKEN	tkn, char* psz);
	TOKEN		NextOpenToken(CByteRange& brSearch, TOKEN* rgtknOpeners, UINT ctknOpeners, BYTE** ppbToken, LONG lCodePage);
	void		MovePastToken(TOKEN tkn, BYTE* pbToken, CByteRange& brSearch);
	BYTE*		GetToken(TOKEN tkn, CByteRange& brSearch, LONG lCodePage);

public:
	CBuffer		m_bufTokens;	// tokens buffer
};

/*	****************************************************************************
	Class:		CDocNodeElem
	Synopsis:	contains a pair of document nodes & application it belongs to
*/
class CDocNodeElem : public CDblLink
{
public:
	CAppln                *m_pAppln;
//	IDebugApplicationNode *m_pFileRoot;					// root of directory hierarchy
	IDebugApplicationNode *m_pDocRoot;					// root of template document hierarchy

	// ctor
	CDocNodeElem(CAppln *pAppln, /*IDebugApplicationNode *pFileRoot,*/ IDebugApplicationNode *pDocRoot);

	// dtor
	~CDocNodeElem();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\txnsupp.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Transascted Scripts Object

File: txnsupp.h

Declaration of the Transacted Script Context object

===================================================================*/

#ifndef __TXNSUPP_H_
#define __TXNSUPP_H_

#include <txnscrpt.h>
#include "viperint.h"

HRESULT TxnSupportInit();

HRESULT TxnSupportUnInit();

inline const CLSID & CLSIDObjectContextFromTransType(TransType tt)
    {
    switch (tt)
        {
    case ttRequired:
        return CLSID_ASPObjectContextTxRequired;
    case ttRequiresNew:
        return CLSID_ASPObjectContextTxRequiresNew;
    case ttSupported:
        return CLSID_ASPObjectContextTxSupported;
    case ttNotSupported:
        return CLSID_ASPObjectContextTxNotSupported;
        }

    DBG_ASSERT(FALSE);
    return CLSID_NULL;
    }

extern IASPObjectContext *  g_pIASPObjectContextZombie;

#endif //__TXNSUPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\txnsupp.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Transascted Scripts Context Object

File: TxnScrpt.cpp

Implementation of CASPObjectContext

Owner: AndrewS
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "resource.h"
#include <txnsupp.h>

#include <atlbase.h>
#if _IIS_5_1
extern CWamModule _Module;
#elif _IIS_6_0
extern CComModule _Module;
#else
#error "Neither _IIS_6_0 nor _IIS_5_1 is defined"
#endif
#include <atlcom.h>

#include <txnobj.h>

#include <initguid.h>
#include <txnscrpt_i.c>

#include <atlimpl.cpp>

// From denali.h
extern HINSTANCE g_hinstDLL;

class CASPObjectContextZombie :
    public CComObject<CASPObjectContext>
{
public:

    // These methods fail on a zombie context
	STDMETHOD(SetAbort)();
	STDMETHOD(SetComplete)();
#ifdef _WIN64
        // Win64 fix -- use UINT64 instead of LONG_PTR since LONG_PTR is broken for Win64 1/21/2000
	STDMETHOD(Call)(UINT64 pvScriptEngine, LPCOLESTR strEntryPoint, boolean *pfAborted);
	STDMETHOD(ResetScript)(UINT64 pvScriptEngine);
#else
	STDMETHOD(Call)(LONG_PTR pvScriptEngine, LPCOLESTR strEntryPoint, boolean *pfAborted);
	STDMETHOD(ResetScript)(LONG_PTR pvScriptEngine);
#endif

private:

};

//
// atl requires that these be defined. I need to be able to load the 
// typelib from asptxn.dll in order to make the local declaration of 
// CASPObjectContextZombie
//
BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

/*===================================================================
    Globals
===================================================================*/

/*
 * bug 86404: We want to have one "zombie" ObjectContext object that always
 * gives errors on all its methods.
 */
IASPObjectContext *     g_pIASPObjectContextZombie = NULL;
static HINSTANCE        g_hTxnModule = NULL;

const char szTxnModuleName[] = "asptxn.dll";

HRESULT TxnSupportInit()
{
    DBG_ASSERT( g_pIASPObjectContextZombie == NULL );
    DBG_ASSERT( g_hTxnModule == NULL );

    HRESULT hr = S_OK;
    
    // Because we are in either inetinfo or dllhost, we need
    // to use the full library path to load the asptxn.dll.
    
    do // Protected block
    {
        DBG_ASSERT( g_hinstDLL );
    
        // Assume that we are in the same directory as asp.dll.
        char   szTxnModulePath[MAX_PATH];
    
        DWORD dwErr = GetModuleFileNameA( g_hinstDLL, 
                                         szTxnModulePath, 
                                         sizeof(szTxnModulePath)/sizeof(szTxnModulePath[0])
                                         );
        if( dwErr == 0 )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            break;
        }

        char * psz = strrchr( szTxnModulePath, '\\' );
        if( psz != NULL )
        {
            strcpy( psz + 1, szTxnModuleName );
        }
        else
        {
            DBG_ASSERT(FALSE);
            strcpy( szTxnModulePath, szTxnModuleName );
        }

        g_hTxnModule = LoadLibraryA( szTxnModulePath );

        if( g_hTxnModule == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            DBG_ASSERT( FAILED(hr) );
            break;
        }

        // This is a somewhat sleazy way of allowing us to declare
        // the zombie context locally. If at some point the _Module
        // can be initied without a HINSTANCE, that would probably
        // be a good idea.

        _Module.Init( ObjectMap, g_hTxnModule );

        CASPObjectContextZombie * pZombie = new CASPObjectContextZombie();
        
        if( !pZombie )
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        hr = pZombie->QueryInterface( IID_IASPObjectContext,
                                      (void **)&g_pIASPObjectContextZombie
                                      );

    } while(FALSE); // Protected block
    
    // This should NOT fail!!
    if( FAILED(hr) )
    {
        DBGPRINTF(( DBG_CONTEXT, "TxnSupportInit Failed: %08x", hr ));
    }
    DBG_ASSERT(SUCCEEDED(hr));

    return hr;
}

HRESULT TxnSupportUnInit()
{
    DBG_ASSERT( g_pIASPObjectContextZombie != NULL );
    DBG_ASSERT( g_hTxnModule != NULL );

    if( g_pIASPObjectContextZombie )
    {
        g_pIASPObjectContextZombie->Release();
        g_pIASPObjectContextZombie = NULL;
    }

    if( g_hTxnModule )
    {
        FreeLibrary( g_hTxnModule );
        g_hTxnModule = NULL;
    }

    return S_OK;
}

STDMETHODIMP CASPObjectContextZombie::Call
(
#ifdef _WIN64
// Win64 fix -- use UINT64 instead of LONG_PTR since LONG_PTR is broken for Win64 1/21/2000
UINT64  pvScriptEngine /*CScriptEngine*/,
#else
LONG_PTR  pvScriptEngine /*CScriptEngine*/,
#endif
LPCOLESTR strEntryPoint,
boolean *pfAborted
)
{
    DBGPRINTF(( DBG_CONTEXT, "Invalid call on Zombie Context.\n" ));
    DBG_ASSERT(FALSE);
    
    return E_FAIL;
}

STDMETHODIMP CASPObjectContextZombie::ResetScript
(
#ifdef _WIN64
// Win64 fix -- use UINT64 instead of LONG_PTR since LONG_PTR is broken for Win64 1/21/2000
UINT64 pvScriptEngine /*CScriptEngine*/
#else
LONG_PTR pvScriptEngine /*CScriptEngine*/
#endif

)
{
    DBGPRINTF(( DBG_CONTEXT, "Invalid call on Zombie Context.\n" ));
    DBG_ASSERT(FALSE);
    
    return E_FAIL;
}

STDMETHODIMP CASPObjectContextZombie::SetComplete()
{
    DBGPRINTF(( DBG_CONTEXT, "Invalid call on Zombie Context.\n" ));

    ExceptionId(IID_IASPObjectContext, IDE_OBJECTCONTEXT, IDE_OBJECTCONTEXT_NOT_TRANSACTED);
    return E_FAIL;
}

STDMETHODIMP CASPObjectContextZombie::SetAbort()
{
    DBGPRINTF(( DBG_CONTEXT, "Invalid call on Zombie Context.\n" ));

    ExceptionId(IID_IASPObjectContext, IDE_OBJECTCONTEXT, IDE_OBJECTCONTEXT_NOT_TRANSACTED);
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\vector.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: misc

File: vector.h

Owner: DGottner

This file contains a dynamic array
===================================================================*

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright 1994, David Gottner
 *
 *                    All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice, this permission notice and
 * the following disclaimer notice appear unmodified in all copies.
 *
 * I DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL I
 * BE LIABLE FOR ANY SPECIAL, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
 * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef VECTOR_H
#define VECTOR_H

 /*---------------------------------------------------------------------------*
 ** The vector class is a thin encapsulation of a C style array, which
 ** allows dynamic sizing of the array and bounds checking; you can also use
 ** this array as a stack.  This is a value-based collection.
 */

template <class TYPE>
class vector {
	TYPE *	m_rgData;
	size_t	m_cItems;
	size_t	m_cCells;

public:
	vector<TYPE>();
	~vector();

	HRESULT Init(const TYPE *, size_t);
	HRESULT Init(size_t n);

	vector<TYPE> &operator= (const vector<TYPE> &);

	size_t length() const	 { return m_cItems; }
	const TYPE *vec() const	 { return m_rgData; }

	// STL iterators (const)
	const TYPE *begin() const { return &m_rgData[0]; }
	const TYPE *end() const   { return &m_rgData[m_cItems]; }

	// STL iterators (non-const)
	TYPE *begin()             { return &m_rgData[0]; }
	TYPE *end()               { return &m_rgData[m_cItems]; }

	TYPE operator[](unsigned i) const
	{
		Assert (i < m_cItems);
		return m_rgData[i];
	}

	TYPE &operator[](unsigned i)
	{
		Assert (i < m_cItems);
		return m_rgData[i];
	}

	HRESULT resize(size_t);
	HRESULT reshape(size_t);

	HRESULT append(const TYPE &a)   { return insertAt(m_cItems, a); }
	HRESULT prepend(const TYPE &a)  { return insertAt(0, a);         }

	HRESULT insertAt(size_t, const TYPE &);
	TYPE removeAt(size_t);

	HRESULT push(const TYPE &a)	{ return append(a); }
	TYPE pop()					{ return m_rgData[--m_cItems]; }

	int find(const TYPE &) const;
};

#endif /* VECTOR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\wraptlib.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Thu Jul 24 14:01:48 1997
 */
/* Compiler settings for D:\VBScript\src\idl\wraptlib.idl, all.acf:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wraptlib_h__
#define __wraptlib_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IWrapTypeLibs_FWD_DEFINED__
#define __IWrapTypeLibs_FWD_DEFINED__
typedef interface IWrapTypeLibs IWrapTypeLibs;
#endif 	/* __IWrapTypeLibs_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Thu Jul 24 14:01:48 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 


//=--------------------------------------------------------------------------=
// WrapTLib.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
//
// Declarations for ActiveX Script Type Library Wrapping.
//

#ifndef __WrapTLib_h
#define __WrapTLib_h

/* GUIDs
 ********/

// {62238910-C1C9-11d0-ABF7-00A0C911E8B2}
DEFINE_GUID(IID_IWrapTypeLibs, 0x62238910, 0xc1c9, 0x11d0, 0xab, 0xf7, 0x00, 0xa0, 0xc9, 0x11, 0xe8, 0xb2);

/* Interfaces
 *************/






extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IWrapTypeLibs_INTERFACE_DEFINED__
#define __IWrapTypeLibs_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWrapTypeLibs
 * at Thu Jul 24 14:01:48 1997
 * using MIDL 3.00.44
 ****************************************/
/* [object][unique][uuid] */ 



EXTERN_C const IID IID_IWrapTypeLibs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IWrapTypeLibs : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE WrapTypeLib( 
            /* [in] */ ITypeLib __RPC_FAR *__RPC_FAR *prgptlib,
            /* [in] */ UINT ctlibs,
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWrapTypeLibsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWrapTypeLibs __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWrapTypeLibs __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWrapTypeLibs __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WrapTypeLib )( 
            IWrapTypeLibs __RPC_FAR * This,
            /* [in] */ ITypeLib __RPC_FAR *__RPC_FAR *prgptlib,
            /* [in] */ UINT ctlibs,
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdisp);
        
        END_INTERFACE
    } IWrapTypeLibsVtbl;

    interface IWrapTypeLibs
    {
        CONST_VTBL struct IWrapTypeLibsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWrapTypeLibs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWrapTypeLibs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWrapTypeLibs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWrapTypeLibs_WrapTypeLib(This,prgptlib,ctlibs,ppdisp)	\
    (This)->lpVtbl -> WrapTypeLib(This,prgptlib,ctlibs,ppdisp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWrapTypeLibs_WrapTypeLib_Proxy( 
    IWrapTypeLibs __RPC_FAR * This,
    /* [in] */ ITypeLib __RPC_FAR *__RPC_FAR *prgptlib,
    /* [in] */ UINT ctlibs,
    /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdisp);


void __RPC_STUB IWrapTypeLibs_WrapTypeLib_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWrapTypeLibs_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0137
 * at Thu Jul 24 14:01:48 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 



#endif  // __WrapTLib_h



extern RPC_IF_HANDLE __MIDL__intf_0137_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0137_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\xor.cpp ===
#include <wtypes.h>
#include <winbase.h>
#include <malloc.h>
#include <stdlib.h>
#include "c:\denali\inc\magic.h"

void WriteFileAsAsciiCodes(HANDLE hOutFile, BYTE pBuffer[], DWORD cbBuffer)
	{
	DWORD	cbWritten;
	char szCode[5];

	for(DWORD i = 0; i < cbBuffer; i++)
		{
		_itoa((int)pBuffer[i], szCode, 10);
		WriteFile(hOutFile, szCode, strlen(szCode), &cbWritten, NULL);
		if(i == (cbBuffer - 1))
			break;
		WriteFile(hOutFile, ",", 1, &cbWritten, NULL);
		if(0 == i % 20 && i > 0)
			WriteFile(hOutFile, "\r\n", 2, &cbWritten, NULL);
		}
	}

void main(int argc, char** argv)
	{
/*	char*	szText =	"Now is the time for us to sell a lot of Denali.";
	int	cchText = lstrlen(szText);
	DWORD	cbWritten;
*/
	int		cchKey = strlen(SZ_MAGICKEY);
	LPVOID	pBuffer;
	DWORD	cbBuffer;
	DWORD	cbRead;

  	HANDLE hInFile = CreateFile(argv[1], GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if(hInFile == INVALID_HANDLE_VALUE && hInFile == NULL)
		return;
  	
	HANDLE hOutFile = CreateFile(argv[2], GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if(hOutFile == INVALID_HANDLE_VALUE && hOutFile == NULL)
		return;

	cbBuffer = GetFileSize(hInFile, NULL);
	pBuffer = _alloca(cbBuffer);

	if(!ReadFile(hInFile, pBuffer, cbBuffer, &cbRead, NULL))
		return;
	CloseHandle(hInFile);

	xor(pBuffer, cbBuffer, SZ_MAGICKEY, cchKey);

	WriteFileAsAsciiCodes(hOutFile, (BYTE*) pBuffer, cbBuffer);

/*	if(!WriteFile(hOutFile, pBuffer, cbBuffer, &cbWritten, NULL))
		return;

	xor(szText, cchText, SZ_MAGICKEY, cchKey);
	OutputDebugString(szText);
	OutputDebugString("\r\n");
	xor(szText, cchText, SZ_MAGICKEY, cchKey);
	OutputDebugString(szText);
	OutputDebugString("\r\n");
*/
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\tlbcache.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Typelibrary cache

File: tlbcache.cpp

Owner: DmitryR

This is the typelibrary cache source file.
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "tlbcache.h"
#include "memchk.h"

/*===================================================================
  Globals
===================================================================*/

CTypelibCache g_TypelibCache;

/*===================================================================
  C  T y p e l i b  C a c h e  E n t r y
===================================================================*/

/*===================================================================
CTypelibCacheEntry::CTypelibCacheEntry

Constructor
===================================================================*/
CTypelibCacheEntry::CTypelibCacheEntry()
    :
    m_fInited(FALSE), m_fIdsCached(FALSE), m_fStrAllocated(FALSE),
    m_wszProgId(NULL), m_clsid(CLSID_NULL), m_cmModel(cmUnknown), 
    m_idOnStartPage(DISPID_UNKNOWN), m_idOnEndPage(DISPID_UNKNOWN),
    m_gipTypelib(NULL_GIP_COOKIE)
    {
    }

/*===================================================================
CTypelibCacheEntry::~CTypelibCacheEntry

Destructor
===================================================================*/
CTypelibCacheEntry::~CTypelibCacheEntry()
    {
    if (m_gipTypelib != NULL_GIP_COOKIE)
        {
        g_GIPAPI.Revoke(m_gipTypelib);
        }
        
    if (m_fStrAllocated)
        {
        Assert(m_wszProgId);
		free(m_wszProgId);
        }
    }

/*===================================================================
CTypelibCacheEntry::StoreProgID

Store ProgID with the structure

Parameters
    wszProgId       ProgId
    cbProgId        ProgId byte length

Returns
    HRESULT
===================================================================*/
HRESULT CTypelibCacheEntry::StoreProgID
(
LPWSTR wszProgId, 
DWORD  cbProgId
)
    {
    Assert(wszProgId);
    Assert(*wszProgId != L'\0');
    Assert(cbProgId == (wcslen(wszProgId) * sizeof(WCHAR)));

    // required buffer length
    DWORD cbBuffer = cbProgId + sizeof(WCHAR);
    WCHAR *wszBuffer = (WCHAR *)m_rgbStrBuffer;

    if (cbBuffer > sizeof(m_rgbStrBuffer))
        {
        // the prog id doesn't fit into the member buffer -> allocate
        wszBuffer = (WCHAR *)malloc(cbBuffer);
        if (!wszBuffer)
            return E_OUTOFMEMORY;
        m_fStrAllocated = TRUE;
        }
    
    memcpy(wszBuffer, wszProgId, cbBuffer);
    m_wszProgId = wszBuffer;
    return S_OK;
    }

/*===================================================================
CTypelibCacheEntry::InitByProgID

Real constructor.
Store ProgID. Init CLinkElem portion with ProgID.

Parameters
    wszProgId       ProgId
    cbProgId        ProgId byte length

Returns
    HRESULT
===================================================================*/
HRESULT CTypelibCacheEntry::InitByProgID
(
LPWSTR wszProgId, 
DWORD  cbProgId
)
    {
    StoreProgID(wszProgId, cbProgId);
    
    // init link with prog id as key (length excludes null term)
	CLinkElem::Init(m_wszProgId, cbProgId);
	m_fInited = TRUE;
	return S_OK;
    }


/*===================================================================
CTypelibCacheEntry::InitByCLSID

Real constructor.
Store ProgID. Init CLinkElem portion with CLSID.

Parameters
    clsid           CLSID
    wszProgId       ProgId

Returns
    HRESULT
===================================================================*/
HRESULT CTypelibCacheEntry::InitByCLSID
(
const CLSID &clsid, 
LPWSTR wszProgid
)
    {
    StoreProgID(wszProgid, CbWStr(wszProgid));
    m_clsid = clsid;
        
    // init link with CLSID id as key
	CLinkElem::Init(&m_clsid, sizeof(m_clsid));
	m_fInited = TRUE;
	return S_OK;
    }

/*===================================================================
  C  T y p e l i b  C a c h e
===================================================================*/

/*===================================================================
CTypelibCache::CTypelibCache

Constructor
===================================================================*/
CTypelibCache::CTypelibCache()
    :
    m_fInited(FALSE)
    {
    }
    
/*===================================================================
CTypelibCache::~CTypelibCache

Destructor
===================================================================*/
CTypelibCache::~CTypelibCache()
    {
    UnInit();
    }

/*===================================================================
CTypelibCache::Init

Init

Returns
    HRESULT
===================================================================*/
HRESULT CTypelibCache::Init()
    {
    HRESULT hr;

    hr = m_htProgIdEntries.Init(199);
    if (FAILED(hr))
        return hr;

    hr = m_htCLSIDEntries.Init(97);
    if (FAILED(hr))
        return hr;

    ErrInitCriticalSection(&m_csLock, hr);
    if (FAILED(hr))
        return(hr);
        
    m_fInited = TRUE;
    return S_OK;
    }
    
/*===================================================================
CTypelibCache::UnInit

UnInit

Returns
    HRESULT
===================================================================*/
HRESULT CTypelibCache::UnInit()
    {
    CTypelibCacheEntry *pEntry;
    CLinkElem *pLink;

    // ProgID Hash table
    pLink = m_htProgIdEntries.Head();
    while (pLink)
        {
        pEntry = static_cast<CTypelibCacheEntry *>(pLink);
        pLink = pLink->m_pNext;

        // remove the entry
        delete pEntry;
        }
    m_htProgIdEntries.UnInit();

    // CLSID Hash table
    pLink = m_htCLSIDEntries.Head();
    while (pLink)
        {
        pEntry = static_cast<CTypelibCacheEntry *>(pLink);
        pLink = pLink->m_pNext;

        // remove the entry
        delete pEntry;
        }
    m_htCLSIDEntries.UnInit();

    // Critical section
    if (m_fInited)
        {
        DeleteCriticalSection(&m_csLock);
        m_fInited = FALSE;
        }

    return S_OK;
    }

/*===================================================================
CTypelibCache::CreateComponent

Create the component using the cached info.
Adds cache entry if needed.
To be called from Server.CreateObject

Parameters
    bstrProgID      prog id
    pHitObj         HitObj needed for creation
    ppdisp          [out] IDispatch *
    pclsid          [out] CLSID

Returns
    HRESULT
===================================================================*/
HRESULT CTypelibCache::CreateComponent
(
BSTR         bstrProgID,
CHitObj     *pHitObj,
IDispatch  **ppdisp,
CLSID       *pclsid
)
    {
    HRESULT hr;
    CLinkElem *pElem;
    CTypelibCacheEntry *pEntry;
    CComponentObject *pObj;
    COnPageInfo OnPageInfo;
    CompModel cmModel; 

    *pclsid = CLSID_NULL;
    *ppdisp = NULL;

    if (bstrProgID == NULL || *bstrProgID == L'\0')
        return E_FAIL;

    WCHAR *wszProgId = bstrProgID;
    DWORD  cbProgId  = CbWStr(wszProgId);    // do strlen once

    BOOL fFound = FALSE;
    BOOL bDispIdsCached = FALSE;
    
    Lock();
    pElem = m_htProgIdEntries.FindElem(wszProgId, cbProgId);
    if (pElem)
        {
        // remember the elements of the entry while inside lock
        pEntry = static_cast<CTypelibCacheEntry *>(pElem);

        // return clsid
        *pclsid = pEntry->m_clsid;

        // prepate OnPageInfo with DispIds to pass to the creation function
        if (pEntry->m_fIdsCached)
            {
            OnPageInfo.m_rgDispIds[ONPAGEINFO_ONSTARTPAGE] = pEntry->m_idOnStartPage;
            OnPageInfo.m_rgDispIds[ONPAGEINFO_ONENDPAGE] = pEntry->m_idOnEndPage;
            bDispIdsCached = TRUE;
            }
        // remember the model
        cmModel = pEntry->m_cmModel;

        fFound = TRUE;
        }
    UnLock();

    if (fFound)
        {
        // create the object
        hr = pHitObj->PPageComponentManager()->AddScopedUnnamedInstantiated
            (
            csPage,
            *pclsid,
            cmModel,
            bDispIdsCached ? &OnPageInfo : NULL,
            &pObj
            );

        // get IDispatch*
        if (SUCCEEDED(hr))
            hr = pObj->GetAddRefdIDispatch(ppdisp);

        // return if succeeded
        if (SUCCEEDED(hr))
            {
            // don't keep the object around unless needed
            if (pObj->FEarlyReleaseAllowed())
                pHitObj->PPageComponentManager()->RemoveComponent(pObj);
            return S_OK;
            }

        // on failure remove from the cache and pretend
        // as if it was never found

        Lock();
        pElem = m_htProgIdEntries.DeleteElem(wszProgId, cbProgId);
        UnLock();

        if (pElem)
            {
            // Element removed from cache - delete the CacheEntry
            pEntry = static_cast<CTypelibCacheEntry *>(pElem);
            delete pEntry;
            }

        // don't return bogus CLSID
        *pclsid = CLSID_NULL;
        }

    // Not found in the cache. Create the object, get the info, and
    // insert the new cache entry.

   	hr = CLSIDFromProgID((LPCOLESTR)wszProgId, pclsid);
   	if (FAILED(hr))
   	    return hr;  // couldn't even get clsid - don't cache

    hr = pHitObj->PPageComponentManager()->AddScopedUnnamedInstantiated
        (
        csPage,
        *pclsid,
        cmUnknown,
        NULL,
        &pObj
        );
   	if (FAILED(hr))
   	    return hr;  // couldn't create object - don't cache

    // object created - get IDispatch*
    if (SUCCEEDED(hr))
        hr = pObj->GetAddRefdIDispatch(ppdisp);
   	if (FAILED(hr))
   	    return hr;  // couldn't get IDispatch* - don't cache

    // create new CTypelibCacheEntry
    pEntry = new CTypelibCacheEntry;
    if (!pEntry)
        return S_OK; // no harm

    // init link entry
    if (FAILED(pEntry->InitByProgID(wszProgId, cbProgId)))
        {
        delete pEntry;
        return S_OK; // no harm
        }
        
    // remember stuff in pEntry
    pEntry->m_clsid = *pclsid;
    pEntry->m_cmModel = pObj->GetModel();

    const COnPageInfo *pOnPageInfo = pObj->GetCachedOnPageInfo();
    if (pOnPageInfo)
        {
        pEntry->m_fIdsCached = TRUE;
        pEntry->m_idOnStartPage = pOnPageInfo->m_rgDispIds[ONPAGEINFO_ONSTARTPAGE];
        pEntry->m_idOnEndPage = pOnPageInfo->m_rgDispIds[ONPAGEINFO_ONENDPAGE];
        }
    else
        {
        pEntry->m_fIdsCached = FALSE;
        pEntry->m_idOnStartPage = DISPID_UNKNOWN;
        pEntry->m_idOnEndPage = DISPID_UNKNOWN;
        }

    // try to get the typelib
    pEntry->m_gipTypelib = NULL_GIP_COOKIE;
    if (FIsWinNT())  // don't do GIP cookies on Win95
        {
        ITypeInfo *ptinfo;
        if (SUCCEEDED((*ppdisp)->GetTypeInfo(0, 0, &ptinfo)))
            {
            ITypeLib *ptlib;
            UINT idx;
            if (SUCCEEDED(ptinfo->GetContainingTypeLib(&ptlib, &idx)))
                {
                // got it! convert to gip cookie
                DWORD gip;
                if (SUCCEEDED(g_GIPAPI.Register(ptlib, IID_ITypeLib, &gip)))
                    {
                    // remember the gip cookie with pEntry
                    pEntry->m_gipTypelib = gip;
                    }
                
                ptlib->Release();
                }
            ptinfo->Release();
            }
        }
        
    // pEntry is ready -- try to insert it into cache
    BOOL fInserted = FALSE;
    Lock();
    // make sure some other thread didn't insert it already
    if (m_htProgIdEntries.FindElem(wszProgId, cbProgId) == NULL)
        {
        if (m_htProgIdEntries.AddElem(pEntry))
            fInserted = TRUE;
        }
    UnLock();

    // cleanup
    if (!fInserted)
        delete pEntry;
        
    // don't keep the object around unless needed
    if (pObj->FEarlyReleaseAllowed())
        pHitObj->PPageComponentManager()->RemoveComponent(pObj);

    return S_OK;
    }

/*===================================================================
CTypelibCache::RememberProgidToCLSIDMapping

Adds an entry to CLSID hashtable.
To be called from template after mapping ProgId to CLSID.

Parameters
    wszProgID      prog id
    clsid          clsid

Returns
    HRESULT
===================================================================*/
HRESULT CTypelibCache::RememberProgidToCLSIDMapping
(
WCHAR *wszProgid, 
const CLSID &clsid
)
    {
    HRESULT hr;
    CLinkElem *pElem;
    CTypelibCacheEntry *pEntry;

    // check if already there first
    BOOL fFound = FALSE;
    Lock();
    if (m_htCLSIDEntries.FindElem(&clsid, sizeof(CLSID)) != NULL)
        fFound = TRUE;
    UnLock();
    if (fFound)
        return S_OK;
    
    // create new entry    
    pEntry = new CTypelibCacheEntry;
    if (!pEntry)
        return E_OUTOFMEMORY;

    BOOL fInserted = FALSE;
    
    // remember prog id and init link entry
    hr = pEntry->InitByCLSID(clsid, wszProgid);
    
    if (SUCCEEDED(hr))
        {
        Lock();
        // make sure some other thread didn't insert it already
        if (m_htCLSIDEntries.FindElem(&clsid, sizeof(CLSID)) == NULL)
            {
            if (m_htCLSIDEntries.AddElem(pEntry))
                fInserted = TRUE;
            }
        UnLock();
        }

    // cleanup
    if (!fInserted)
        delete pEntry;
        
    return hr;
    }

/*===================================================================
CTypelibCache::UpdateMappedCLSID

Update CLSID since remembered.

To be called from object creation code to update CLSID
if the object creation failed.

Parameters
    *pclsid         [in, out] CLSID

Returns
    HRESULT
        S_FALSE = didn't change
        S_OK    = did change and the new one found
===================================================================*/
HRESULT CTypelibCache::UpdateMappedCLSID
(
CLSID *pclsid
)
    {
    HRESULT hr = S_FALSE; // not found
    CLinkElem *pElem;
    CTypelibCacheEntry *pEntry;
    CLSID clsidNew;
    
    Lock();
    // Do everything under lock so the ProgID stored in
    // the entry is still valid.
    // Not very perfomant -- but is is an error path anyway
    
    pElem = m_htCLSIDEntries.FindElem(pclsid, sizeof(CLSID));
    if (pElem)
        {
        pEntry = static_cast<CTypelibCacheEntry *>(pElem);

        // find new mapping
        if (SUCCEEDED(CLSIDFromProgID(pEntry->m_wszProgId, &clsidNew)))
            {
            // compare with the old one
            if (!IsEqualCLSID(clsidNew, *pclsid))
                {
                // the mapping did change!
                *pclsid = clsidNew;
                hr = S_OK;
                }
            }
        }
        
    UnLock();

    return hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\thrdgate.cpp ===
/*===================================================================
Microsoft IIS 5.0 (ASP)

Microsoft Confidential.
Copyright 1998 Microsoft Corporation. All Rights Reserved.

Component: Thread Gate

The thread gate limits number of threads executing at the
moment by sleeping some of them.

File: thrdgate.cpp

Owner: DmitryR

This file contains the code for the Thread Gate
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "thrdgate.h"
#include "memchk.h"

/*===================================================================
  Constants for tuning
===================================================================*/

/*===================================================================
  Class to track the processor load
===================================================================*/

inline DWORD GetNumberOfProcessors() {
    SYSTEM_INFO si;
    GetSystemInfo(&si);
    return si.dwNumberOfProcessors;
}

inline LONG GetPercentage(LARGE_INTEGER part, LARGE_INTEGER total) {

    if (total.HighPart == 0 && total.LowPart == 0) {
        return 100;
    }
    
    ULONG ul;
    LARGE_INTEGER t1, t2, t3;
    if (total.HighPart == 0) {
        t1 = RtlEnlargedIntegerMultiply(part.LowPart, 100);
        t2 = RtlExtendedLargeIntegerDivide(t1, total.LowPart, &ul);
    } else {
        t1 = RtlExtendedLargeIntegerDivide(total, 100, &ul);
        t2 = RtlLargeIntegerDivide(part, t1, &t3);
    }
    return t2.LowPart;
}

class CCPULoad {

private:
    DWORD m_cCPU;
    DWORD m_cbData;  // data struct length
    SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION *m_psppiOld;
    SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION *m_psppiNew;

public:

/*===================================================================
Constructor
===================================================================*/
CCPULoad() {

    // get the CPU count
    m_cCPU = GetNumberOfProcessors();

    m_cbData = m_cCPU * sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION);
    
    m_psppiOld = new SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION[m_cCPU];
    m_psppiNew = new SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION[m_cCPU];
    if (m_psppiOld == NULL || m_psppiNew == NULL) {
        return;
    }

    // get the original snapshot
    NtQuerySystemInformation(
        SystemProcessorPerformanceInformation,
        m_psppiOld,
        m_cbData,
        NULL
        );
}
    
/*===================================================================
Destructor
===================================================================*/
~CCPULoad() {

    if (m_psppiOld != NULL) {
        delete m_psppiOld;
    }
    if (m_psppiNew != NULL) {
        delete m_psppiNew;
    }
}

/*===================================================================
GetReading
get the current reading as a percentage of CPU load
averaged across processors
===================================================================*/
DWORD GetReading() {

    if (m_psppiOld == NULL || m_psppiNew == NULL) {
        return 0;
    }
    
    // get the new snapshot
    NtQuerySystemInformation(
        SystemProcessorPerformanceInformation,
        m_psppiNew,
        m_cbData,
        NULL
        );

    // calculate
    LARGE_INTEGER cpuIdleTime, cpuUserTime, cpuKernelTime, 
                  cpuBusyTime, cpuTotalTime,
                  sumBusyTime = RtlConvertLongToLargeInteger(0),
                  sumTotalTime = RtlConvertLongToLargeInteger(0);

    for (DWORD i = 0; i < m_cCPU; i++) {
    
        cpuIdleTime   = RtlLargeIntegerSubtract(m_psppiNew[i].IdleTime, m_psppiOld[i].IdleTime);
        cpuUserTime   = RtlLargeIntegerSubtract(m_psppiNew[i].UserTime, m_psppiOld[i].UserTime);
        cpuKernelTime = RtlLargeIntegerSubtract(m_psppiNew[i].KernelTime, m_psppiOld[i].KernelTime);

        cpuTotalTime  = RtlLargeIntegerAdd(cpuUserTime, cpuKernelTime);
        cpuBusyTime   = RtlLargeIntegerSubtract(cpuTotalTime, cpuIdleTime);

        IF_DEBUG(THREADGATE)
            {
            LONG p = GetPercentage(cpuBusyTime, cpuTotalTime);
            DBGPRINTF((DBG_CONTEXT, "ThreadGate: load(%d)=%d", i+1, p));
            }

        sumBusyTime = RtlLargeIntegerAdd(sumBusyTime, cpuBusyTime);
        sumTotalTime = RtlLargeIntegerAdd(sumTotalTime, cpuTotalTime);
    }

    LONG nPercentage = GetPercentage(sumBusyTime, sumTotalTime);

    IF_DEBUG(THREADGATE)
        {
        DBGPRINTF((DBG_CONTEXT, "ThreadGate: **** load = %d\r\n", nPercentage));
        }

    // move new to old
    memcpy(m_psppiOld, m_psppiNew, m_cbData);

    return nPercentage;
}

/*=================================================================*/

}; // class CCPULoad


/*===================================================================
  The thread gate class
===================================================================*/

class CThreadGate {

private:

    DWORD m_msSlice;         // granularity
    DWORD m_msSleep;         // sleep length
    DWORD m_cSleepsMax;      // max wait 50 sleeps
    LONG  m_nLowLoad;        // low CPU load is < 75%
    LONG  m_nHighLoad;       // hight CPU load is > 90%
 
    LONG  m_cThreadLimitMin; // hunting range low
    LONG  m_cThreadLimitMax; // hunting range high

    LONG  m_cThreadLimit;    // current limit
    LONG  m_nTrend;          // last change

    DWORD m_msT0;            // starting time
    LONG  m_iCurrentSlice;   // current time slice index
    LONG  m_nRequests;       // number of active requests

    CCPULoad m_CPULoad;      // track the CPU load
    
public:

/*===================================================================
Constructor
===================================================================*/
CThreadGate(
    DWORD msSlice,
    DWORD msSleep,
    DWORD cSleepsMax,
    DWORD nLowLoad,
    DWORD nHighLoad,
    DWORD cLimitMin,
    DWORD cLimitMax
    ) {

    m_msSlice    = msSlice;
    m_msSleep    = msSleep;
    m_cSleepsMax = cSleepsMax;
    m_nLowLoad   = nLowLoad,
    m_nHighLoad  = nHighLoad;

    m_cThreadLimitMin = cLimitMin;
    m_cThreadLimitMax = cLimitMax;

    m_cThreadLimit = m_cThreadLimitMin;
    m_nTrend = 0;

    m_msT0 = GetTickCount();
    m_iCurrentSlice = 0;
    m_nRequests = 0;
}

/*===================================================================
Destructor
===================================================================*/
~CThreadGate()  {

}

/*===================================================================
HuntLoad

Do the load hunting
===================================================================*/
void HuntLoad() {

    LONG nLoad = m_CPULoad.GetReading();

    if (m_nRequests == 0) {
        // no requests - don't change
        m_nTrend = 0;
        return;
    }
    
    LONG cThreadLimit = m_cThreadLimit;
    LONG nTrend = m_nTrend;

    if (nLoad < m_nLowLoad) {
        nTrend = nTrend <= 0 ? 1 : nTrend+3;  // grow faster
        cThreadLimit += nTrend;
        
        if (cThreadLimit >= m_cThreadLimitMax) {
            cThreadLimit = m_cThreadLimitMax;
            nTrend = 0;
        }
    }
    else if (nLoad > m_nHighLoad) {
        nTrend = nTrend > 0 ? -1 : nTrend-1;
        cThreadLimit += nTrend;
        
        if (cThreadLimit <= m_cThreadLimitMin) {
            cThreadLimit = m_cThreadLimitMin;
            nTrend = 0;
        }
    }
    
    // set the new limit and trend
    m_cThreadLimit = cThreadLimit;
    m_nTrend = nTrend;
}

/*===================================================================
Enter

Pass through the gate. Can make the thread sleep

Returns
    Thread Gate Pass
===================================================================*/
void Enter(DWORD msCurrentTickCount) {

    DWORD cSleeps = 0;
    
    while (cSleeps++ < m_cSleepsMax) {

        // if shutting down, let the request go.  Later it will find
        // out again that the server is shutting down and not actually
        // fire the request.

        if (IsShutDownInProgress()) {
            break;
        }
		
    
        // calculate the current time slice
        DWORD msElapsedSinceT0 = (msCurrentTickCount >= m_msT0) ?
            (msCurrentTickCount - m_msT0) :
            ((0xffffffff - m_msT0) + msCurrentTickCount);
        LONG iSlice = msElapsedSinceT0 / m_msSlice;

        if (iSlice > m_iCurrentSlice) {
            // set it as the new one
            if (InterlockedExchange(&m_iCurrentSlice, iSlice) != iSlice) {

                // this is the first thread to jump the time slice - go hunting
                HuntLoad();
            }
        }

        // enforce the gate limit
        if (m_nRequests < m_cThreadLimit) {
            break;
        }

        // Too many active threads -- sleep
        Sleep(m_msSleep);
    }
    
    // let it through
    InterlockedIncrement(&m_nRequests);
}

/*===================================================================
Leave

Return. The user lets us know that the request finished.
===================================================================*/
void Leave() {

    InterlockedDecrement(&m_nRequests);
}

/*=================================================================*/

}; // class CThreadGate


// Pointer to the sole instance of the above
static CThreadGate *gs_pThreadGate = NULL;


/*===================================================================
  E x t e r n a l  A P I
===================================================================*/

/*===================================================================
InitThreadGate

Initialization

Parameters
    ptgc     configuration

Returns:
    HRESULT
===================================================================*/
HRESULT InitThreadGate(THREADGATE_CONFIG *ptgc) {

    DWORD cCPU = GetNumberOfProcessors();

    if (ptgc->fEnabled) {
        gs_pThreadGate = new CThreadGate(
            ptgc->msTimeSlice,
            ptgc->msSleepDelay,
            ptgc->nSleepMax,
            ptgc->nLoadLow,
            ptgc->nLoadHigh,
            ptgc->nMinProcessorThreads * cCPU,
            ptgc->nMaxProcessorThreads * cCPU
            );

        return (gs_pThreadGate != NULL) ? S_OK : E_OUTOFMEMORY;
        
    }
    
    gs_pThreadGate = NULL;
    return S_OK;
}


/*===================================================================
UnInitThreadGate

To be called from DllUnInit()

Parameters

Returns:
    n/a
===================================================================*/
void UnInitThreadGate() {

    if (gs_pThreadGate)  {
        delete gs_pThreadGate;
        gs_pThreadGate = NULL;
    }
}


/*===================================================================
PassThroughThreadGate

Pass through the gate. The current thread could be delayed in
case there are too many running threads at this moment

Parameters
    msCurrentTickCount      current tick count
===================================================================*/
void EnterThreadGate(DWORD msCurrentTickCount) {

    if (gs_pThreadGate) {
        gs_pThreadGate->Enter(msCurrentTickCount);
    }
}


/*===================================================================
LeaveThreadGate

Request done executing
===================================================================*/
void LeaveThreadGate() {

    if (gs_pThreadGate) {
        gs_pThreadGate->Leave();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\util.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: misc

File: util.cpp

Owner: AndrewS

This file contains random useful utility functions
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "MemChk.h"
#include "locale.h"
#include <malloc.h>
#include <mbstring.h>
#include <mbctype.h>

extern  CPINFO  g_SystemCPInfo;     // global System CodePage default info.

// ***************************************************************************
// M I S C
// ***************************************************************************

/*===================================================================
Server_ValSize
Server_FindKey

This helper function assists in the implementation of the
SERVER_GET macro

Parameters:
    PIReq        pointer to CIsapiReqInfo
    szBuffer    Buffer to write to
    pdwBufLen   On entry: size of the buffer
                On Exit, actual size of the buffer
                    (required size if buffer was too small)
    szKey       Key to search for

Returns:
    TRUE - it succeeded, string in szBuffer
    FALSE - buffer was too small, *pdwBufLen has required size
===================================================================*/
BOOL Server_FindKey
(
CIsapiReqInfo *PIReq,
char *szBuffer,
DWORD *pdwBufLen,
const char *szKey
)
    {
    // If no buffer, then just calculate the size (old behavior)
    Assert (szBuffer != NULL);

    if (PIReq && PIReq->GetServerVariableA(const_cast<char *>(szKey), szBuffer, pdwBufLen))
        return TRUE;

    szBuffer[0] = '\0';

    // Bug 965: If malicious request comes, do not _alloca, and pretend like we
    //          didn't get anything.  This is OK - the rest of Denali will just assume
    //          there were no cookies, request parameters or client headers.
    //
    if (!PIReq || GetLastError() == ERROR_INVALID_INDEX || *pdwBufLen > REQUEST_ALLOC_MAX)
        {
        *pdwBufLen = 1;
        return TRUE;
        }

    return FALSE;
    }


/*===================================================================
 * F i n d A p p l i c a t i o n P a t h
 *
 * Get application path from CIsapiReqInfo. It gets the metabase key and
 * strips it of prefix.
 *
 * Parameters:
 *    PIReq      - CIsapiReqInfo
 *    pszPath   - [out] the application path (URL)
 *
 * Returns:
 *    HRESULT
 *
 * Allocates pszPath using malloc()
===================================================================*/
HRESULT FindApplicationPath
(
CIsapiReqInfo *PIReq,
TCHAR *szPath,
int cbPath
)
    {
    if (!PIReq)
        return E_FAIL;

    // Extract virtual path from the metabase path
    TCHAR *pch = NULL;
    int   cch = 0;

    // Get the metabase path
    TCHAR *szMDPath = PIReq->QueryPszApplnMDPath();
    if (szMDPath)
        {
        Assert(szMDPath[0] == _T('/'));

        pch = szMDPath;

        // find 4th '/' in "/LM/w3svc/X/root/vroot" after starting '/'
        for (int i = 0; i < 4 && pch != NULL; i++)
            pch = _tcschr(pch+1, _T('/'));

        if (pch)
            cch = _tcslen(pch);
        else
            cch = 1;  // special case of default app -- assume /
        }
    else
        {
        // assume /
        pch = NULL;
        cch = 1;
        }

    if (cch >= (int)(cbPath/sizeof(TCHAR)))
        return E_FAIL;

    _tcscpy(szPath, pch ? pch : _T("/"));

    // remove trailing / if any
    if (cch > 1)
        {
        pch = &szPath[cch - 1];
        if (*pch == _T('/'))
            *pch = _T('\0');
        }

    return S_OK;
    }

/*===================================================================
VariantResolveDispatch

    Convert an IDispatch VARIANT to a (non-Dispatch) VARIANT by
    invoking its default property until the object that remains
    is not an IDispatch.  If the original VARIANT is not an IDispatch
    then the behavior is identical to VariantCopyInd(), with the
    exception that arrays are copied.

Parameters:
    pVarOut      - if successful, the return value is placed here
    pVarIn       - the variant to copy
    GUID *iidObj - the calling interface (for error reporting)
    nObjID       - the Object's name from the resource file

    pVarOut need not be initialized.  Since pVarOut is a new
    variant, the caller must VariantClear this object.

Returns:
    The result of calling IDispatch::Invoke.  (either S_OK or
    the error resulting from the call to Invoke)   may also return
    E_OUTOFMEMORY if an allocation fails

    This function always calls Exception() if an error occurs -
    this is because we need to call Exception() if an IDispatch
    method raises an exception.  Instead of having the client
    worry about whether we called Exception() on its behalf or
    not, we always raise the exception.
===================================================================*/

HRESULT VariantResolveDispatch(VARIANT *pVarOut, VARIANT *pVarIn, const GUID &iidObj, int nObjID)
    {
    VARIANT     varResolved;        // value of IDispatch::Invoke
    DISPPARAMS  dispParamsNoArgs = {NULL, NULL, 0, 0};
    EXCEPINFO   ExcepInfo;
    HRESULT     hrCopy;

    Assert (pVarIn != NULL && pVarOut != NULL);

    VariantInit(pVarOut);
    if (V_VT(pVarIn) & VT_BYREF)
        hrCopy = VariantCopyInd(pVarOut, pVarIn);
    else
        hrCopy = VariantCopy(pVarOut, pVarIn);

    if (FAILED(hrCopy))
        {
        ExceptionId(iidObj, nObjID, (hrCopy == E_OUTOFMEMORY)? IDE_OOM : IDE_UNEXPECTED);
        return hrCopy;
        }

    // follow the IDispatch chain.
    //
    while (V_VT(pVarOut) == VT_DISPATCH)
        {
        HRESULT hrInvoke = S_OK;

        // If the variant is equal to Nothing, then it can be argued
        // with certainty that it does not have a default property!
        // hence we return DISP_E_MEMBERNOTFOUND for this case.
        //
        if (V_DISPATCH(pVarOut) == NULL)
            hrInvoke = DISP_E_MEMBERNOTFOUND;
        else
            {
            VariantInit(&varResolved);
            hrInvoke = V_DISPATCH(pVarOut)->Invoke(
                                                DISPID_VALUE,
                                                IID_NULL,
                                                LOCALE_SYSTEM_DEFAULT,
                                                DISPATCH_PROPERTYGET | DISPATCH_METHOD,
                                                &dispParamsNoArgs,
                                                &varResolved,
                                                &ExcepInfo,
                                                NULL);
            }

        if (FAILED(hrInvoke))
            {
            if (hrInvoke == DISP_E_EXCEPTION)
                {
                //
                // forward the ExcepInfo from Invoke to caller's ExcepInfo
                //
                Exception(iidObj, ExcepInfo.bstrSource, ExcepInfo.bstrDescription);
                SysFreeString(ExcepInfo.bstrHelpFile);
                }

            else
                ExceptionId(iidObj, nObjID, IDE_UTIL_NO_VALUE);

            VariantClear(pVarOut);
            return hrInvoke;
            }

        // The correct code to restart the loop is:
        //
        //      VariantClear(pVar)
        //      VariantCopy(pVar, &varResolved);
        //      VariantClear(&varResolved);
        //
        // however, the same affect can be achieved by:
        //
        //      VariantClear(pVar)
        //      *pVar = varResolved;
        //      VariantInit(&varResolved)
        //
        // this avoids a copy.  The equivalence rests in the fact that
        // *pVar will contain the pointers of varResolved, after we
        // trash varResolved (WITHOUT releasing strings or dispatch
        // pointers), so the net ref count is unchanged. For strings,
        // there is still only one pointer to the string.
        //
        // NOTE: the next interation of the loop will do the VariantInit.
        //
        VariantClear(pVarOut);
        *pVarOut = varResolved;
        }

    return S_OK;
    }

/*===================================================================
VariantGetBSTR

    Gets BSTR from the variant (does one possible indirection)

Parameters:
    var          - VARIANT

Returns:
    BSTR or NULL if none
===================================================================*/   
BSTR VariantGetBSTR(const VARIANT *pvar)
    {
    if (V_VT(pvar) == VT_BSTR)                      // straight BSTR
        return V_BSTR(pvar);

    if (V_VT(pvar) == (VT_BYREF|VT_VARIANT))
        {
        VARIANT *pvarRef = V_VARIANTREF(pvar);      // Variant by ref
        if (pvarRef && V_VT(pvarRef) == VT_BSTR)
            return V_BSTR(pvarRef);
        }

    return NULL;
    }

/*===================================================================
Normalize

    Converts a filename IN PLACE to a normalized form so that we don't
    cache identical files with different names (i.e. Foo, foo,
    .\foo, etc)

Algorithm:
    The file is translated to uppercase and forward slash (/)
    characters are converted to backward slash (\)

Return Value:
    cch of normalized string
Note:  This function is used for PathInfo only, and using system ANSI codepage.
===================================================================*/
int Normalize
(
char*   szSrc  // source string
)
{
    char    *szDest = szSrc;

    CPINFO CpInfo;
    BOOL    fReturn;

    Assert(szSrc != NULL);

    fReturn = GetCPInfo(CP_ACP, (LPCPINFO)&CpInfo);
    Assert(fReturn == TRUE);

    // CONSIDER reinstate LCMapString
    // NOTE LCMapString should return string length but it returns 0? - could avoid call to lstrlen
    int cchRet = lstrlen(szSrc);

/*  bug 1236: CONSIDER reinstate LCMapString
    if(FIsWinNT())
        {
        LCMapString(
                    LOCALE_SYSTEM_DEFAULT,  // LCID     locale identifier
                    LCMAP_UPPERCASE,        // DWORD    mapping transformation type
                    szSrc,                  // LPCTSTR  address of source string
                    -1,                     // int      number of characters in source string
                    szDest,                 // LPTSTR   address of destination buffer
                    cchRet                  // int      size of destination buffer
                   );
        }
    else
*/
        {

        if (szDest == szSrc)
            {   //convert source string IN PLACE
            while(*szDest)
                {
                if (CpInfo.MaxCharSize == 2 && IsDBCSLeadByte((BYTE)*szDest))
                    {
                    szDest += 2;
                    continue;
                    }
                *szDest = (char)toupper(*szDest);
                szDest++;
                }
            szDest = szSrc;
            }
        else
            {
            CHAR *szDestT;
            CHAR *szSrcT;
            szDestT = szDest;
            szSrcT  = szSrc;
            while(*szSrcT)
                {
                if (CpInfo.MaxCharSize == 2 && IsDBCSLeadByte((BYTE)*szSrcT))
                    {
                    *szDestT++ = *szSrcT++;
                    *szDestT++ = *szSrcT++;
                    continue;
                    }
                *szDestT = (CHAR)toupper(*szSrcT);
                szSrcT++;
                szDestT++;
                }
            }
        }
    szDest[cchRet] = '\0';

    char *szTemp = szDest;
    while (*szTemp)
        {
        if (CpInfo.MaxCharSize == 2 && IsDBCSLeadByte((BYTE)*szTemp))
            {
            szTemp += 2;
            continue;
            }
        // DBCSLeadByte can not be any printable char
        if (*szTemp == '/')
            *szTemp = '\\';
        ++szTemp;
        }

    return cchRet;
    }

#ifdef DBG
BOOLB IsNormalized(const char *_sz)
    {
    CPINFO CpInfo;
    BOOL fReturn;

    fReturn = GetCPInfo(CP_ACP, (LPCPINFO)&CpInfo);
    Assert(fReturn == TRUE);

    const unsigned char *sz = reinterpret_cast<const unsigned char *>(_sz);
    while (*sz)
        {
        if (CpInfo.MaxCharSize == 2 &&IsDBCSLeadByte((BYTE)*sz))
            {
            sz += 2;
            continue;
            }
        if (*sz != toupper(*sz) || *sz == '/')
            return FALSE;
        ++sz;
        }
    return TRUE;
    }
#endif  // DBG

/*===================================================================
HTMLEncodeLen

HTML Encode len returns an int representing the string size
required to HTMLEncode a string.

Note: This returned value might be exceeds the actually string size needed to
HTMLEncode a string.(since we are going to drop the leading zeros in &#00257; 
case.,
the returned value includes the 2 chars for the leading zeros)

Parameters:
    szSrc  - Pointer to the source buffer
    fEncodeExtCharOnly - FALSE, Normal encoding
                 TRUE, encodes extended chars, does not encode '<', '>', '&',
and '"'.
    uCodePage - system code page

Returns:
    int storage required to encode string.
===================================================================*/
int HTMLEncodeLen(const char *szSrc, UINT uCodePage, BSTR bstrIn, BOOL fEncodeExtCharOnly)
    {
    int nstrlen = 1;        // Add NUL space now
    int i       = 0;

    // Bug 97049 return 0 on NULL instead of crashing
    if (!szSrc)
        return 0;

    while (*szSrc)
        {
        // The original condition is unsuitable for DBCS.
        // It is possible that new one allows to encode extended character
        // even if running system is DBCS.
        //

        // if bstrIn == NULL, chech DBCS
        // if bstrIn != NULL and Unicode is latin-1 area(<0x100), check DBCS
        // else skip to check DBCS
        if (!(bstrIn && bstrIn[i] < 0x100) && ::IsDBCSLeadByteEx(uCodePage, (BYTE)*szSrc))	
            {
            // this is a DBCS code page do not encode the data copy 2 bytes
            // no incremnt because of using CharNextExA at the end of the loop
            nstrlen += 2;
            }
            
        // Japanese only.
        // Do not encode if character is half-width katakana character.
        // We should use GetStringTypeA to detect half-width katakana char instead of _ismbbkana()???
        // (I used _ismbbkana at this time for performance reason...)
        //
        else if ((uCodePage == 932 || uCodePage == CP_ACP && ::GetACP() == 932 ) && _ismbbkana(*szSrc))
            {
            nstrlen++;
            }

        // Special case character encoding
        //
        else if (*szSrc == '<')
            if (fEncodeExtCharOnly)
                nstrlen++;
            else
                nstrlen += 4;

        else if (*szSrc == '>')
            if (fEncodeExtCharOnly)
                nstrlen++;
            else
                nstrlen += 4;

        else if (*szSrc == '&')
            if (fEncodeExtCharOnly)
                nstrlen++;
            else
                nstrlen += 5;

        else if (*szSrc == '"')
            if (fEncodeExtCharOnly)
                nstrlen++;
            else
                nstrlen += 6;

        // According RFC, if character code is greater than equal 0xa0, encode it.
        //
        // Note: For &#00257;, we might drop the leading zeros, therefore, we are not
        // going to use all 8 chars.  We will need only 6 digits in this case.(&#257;).
        // We need at most 8 chars.
        else if ( bstrIn && (bstrIn[i] >= 0xa0) )
       		{
   		    nstrlen += 8;
       		}
		else if ((unsigned char)*szSrc >= 0xa0 )
			{
			nstrlen += 6;
            }
        else
            {
            nstrlen++;
            }

            
       	// increment szSrc and i (they must be kept in sync)
		szSrc = AspCharNextA(WORD(uCodePage), szSrc);
		i++;
        }
        
    return nstrlen;
    }

/*===================================================================
HTMLEncode

HTML Encode a string containing the following characters

less than           <       &lt;
greater than        >       &gt;
ampersand           &       &amp;
quote               "       &quot;
any Ascii           ?       &#xxx   (where xxx is the ascii char val)

Parameters:
    szDest - Pointer to the buffer to store the HTMLEncoded string
    szSrc  - Pointer to the source buffer
    fEncodeExtCharOnly - FALSE, Normal encoding
                 TRUE, encodes extended chars, does not encode '<', '>', '&',
and '"'.
    uCodePage - system code page

Returns:
    A pointer to the NUL terminated string.
===================================================================*/
char *HTMLEncode(char *szDest, const char *szSrc, UINT uCodePage, BSTR bstrIn, BOOL fEncodeExtCharOnly)
    {
    char *pszDest = szDest;
	int   i       = 0;

    // Bug 97049 return on NULL instead of crashing
    if (!szDest)
        return NULL;
    if (!szSrc)
        {
        *szDest = '\0';
        return pszDest;
        }

    while (*szSrc)
        {
        //
        // The original condition is unsuitable for DBCS.
        // It is possible that new one allows to encode extended character
        // even if running system is DBCS.
        //
		// if Unicode is latin-1 area(<0x100), skip to check DBCS
		// bstrIn == NULL to handle the case were HTMLEncode is called internally 
		// and bstrIn is NULL
		//
        // if bstrIn == NULL, chech DBCS
        // if bstrIn != NULL and Unicode is latin-1 area(<0x100), check DBCS
        // else skip to check DBCS
        if (!(bstrIn && bstrIn[i] < 0x100) && ::IsDBCSLeadByteEx(uCodePage, (BYTE)*szSrc))	
            {
            // this is a DBCS code page do not encode the data copy 2 bytes
            // no incremnt because of using CharNextExA at the end of the loop
            *szDest++ = *szSrc;  
            *szDest++ = *(szSrc + 1);
            }
        //
        // Japanese only.
        // Do not encode if character is half-width katakana character.
        //
        else if ( (uCodePage == 932 || uCodePage == CP_ACP && ::GetACP() == 932) && _ismbbkana(*szSrc))
            {
            *szDest++ = *szSrc;
            }

        // Special case character encoding
        else if (*szSrc == '<')
            if (fEncodeExtCharOnly)
                *szDest++ = *szSrc;
            else
                szDest = strcpyExA(szDest, "&lt;");

        else if (*szSrc == '>')
            if (fEncodeExtCharOnly)
                *szDest++ = *szSrc;
            else
                szDest = strcpyExA(szDest, "&gt;");

        else if (*szSrc == '&')
            if (fEncodeExtCharOnly)
                *szDest++ = *szSrc;
            else
                szDest = strcpyExA(szDest, "&amp;");

        else if (*szSrc == '"')
            if (fEncodeExtCharOnly)
                *szDest++ = *szSrc;
            else
                szDest = strcpyExA(szDest, "&quot;");

        // According RFC, if character code is greater than equal 0xa0, encode it.
        //
	    // BUG 153089 - WideCharToMultiByte would incorrectly convert some
	    // characters above the range of 0xA0 so we now use the BSTR as our source
	    // to check for characters that should be encoded.
	    //
	    else if ( bstrIn && (bstrIn[i] >= 0xa0))
	    {
	        BOOL fSurrogate = FALSE;
	      	WORD count = 1;
	      	// Check if the bstrIn currently points to a surrogate Pair 
	      	// Surrogate pairs would account for 2 bytes in the BSTR.
            // High Surrogate = U+D800 <==> U+DBFF
            // Low Surrogate = U+DC00 <==> U+DFFF
	      	if ((bstrIn[i] >= 0xd800 && bstrIn[i] <= 0xdfff) 		// Check the higher byte.
	      	    && (bstrIn[i+1] >= 0xd800 && bstrIn[i+1] <= 0xdfff)) // Check the lower byte too.
	      	{	     	
	      	    // Surrogate Pair exists so iterate through the code twice.
	      	    fSurrogate = TRUE;
	      	    count++;	      		      	    
	      	}

	      	for (WORD iter = 0; iter < count ; iter ++)
	      	{
                WORD    wTemp = *(bstrIn+i+iter);
    	      	INT     iTemp;
    	      	BOOL    fLeadZero = TRUE;
    	      	
    	        *szDest++ = '&';
    	        *szDest++ = '#';
    	        for (WORD Index = 10000; Index > 0; Index /= 10) 
   	        	{
    	        	iTemp = ((unsigned char) (wTemp / Index));
    	        	if (fLeadZero == TRUE)
   	        	    {
    	        	    if (iTemp == 0 && Index > 100)
   	        	        {
    	        	        continue;
   	        	        }
    	        	    else
   	        	        {
    	        	        fLeadZero = FALSE;
   	        	        }
   	        	    }
    	       		*szDest++ =  iTemp + '0';
    	       		wTemp = wTemp % Index;
   		       	}
      	     	*szDest++ = ';';     	     		     	      	     	
    	    }
	      	
	      	if (fSurrogate) 
	      	    i++; // Increment bstrIn index as surrogatepair was detected.

	    }
	    else if ((unsigned char)*szSrc >= 0xa0)
	      	{
	      	// Since this is unsigned char casting, the value of WORD wTemp
	      	// is not going to exceed 0xff(255).  So, 3 digit is sufficient here.
	      	WORD wTemp = (unsigned char)*szSrc;

	        *szDest++ = '&';
	        *szDest++ = '#';
	        for (WORD Index = 100; Index > 0; Index /= 10) 
	        	{
	       		*szDest++ = ((unsigned char) (wTemp / Index)) + '0';
	       		wTemp = wTemp % Index;
		       	}
  	     	*szDest++ = ';';
    	    }
       else
            *szDest++ = *szSrc;

    	// increment szSrc and i (they must be kept in sync)
		szSrc = AspCharNextA(WORD(uCodePage), szSrc);  
    	
		i++;	// Regular increment of the bstrIn index.
        }

    *szDest = '\0';
    return pszDest;
    }

/*===================================================================
strcpyExA

Copy one string to another, returning a pointer to the NUL character
in the destination

Parameters:
    szDest - pointer to the destination string
    szSrc - pointer to the source string

Returns:
    A pointer to the NUL terminator is returned.
===================================================================*/
char *strcpyExA(char *szDest, const char *szSrc)
    {
    while (*szDest++ = *szSrc++)
        ;

    return szDest - 1;
    }



/*===================================================================
strcpyExW

Copy one wide string to another, returning a pointer to the NUL character
in the destination

Parameters:
    wszDest - pointer to the destination string
    wszSrc - pointer to the source string

Returns:
    A pointer to the NUL terminator is returned.
===================================================================*/

wchar_t *strcpyExW(wchar_t *wszDest, const wchar_t *wszSrc)
    {
    while (*wszDest++ = *wszSrc++)
        ;

    return wszDest - 1;
    }



/*===================================================================
URLEncodeLen

Return the storage requirements for a URL-Encoded string

Parameters:
    szSrc  - Pointer to the string to URL Encode

Returns:
    the number of bytes required to encode the string
===================================================================*/

int URLEncodeLen(const char *szSrc)
    {
    int cbURL = 1;      // add terminator now

    // Bug 97049 return 0 on NULL instead of crashing
    if (!szSrc)
        return 0;

    while (*szSrc)
        {
        if (*szSrc & 0x80)              // encode foreign characters
            cbURL += 3;

        else if (*szSrc == ' ')         // encoded space requires only one character
            ++cbURL;

        else if (!isalnum((UCHAR)(*szSrc)))  // encode non-alphabetic characters
            cbURL += 3;

        else
            ++cbURL;

        ++szSrc;
        }

    return cbURL;
    }



/*===================================================================
URLEncode

URL Encode a string by changing space characters to '+' and escaping
non-alphanumeric characters in hex.

Parameters:
    szDest - Pointer to the buffer to store the URLEncoded string
    szSrc  - Pointer to the source buffer

Returns:
    A pointer to the NUL terminator is returned.
===================================================================*/

char *URLEncode(char *szDest, const char *szSrc)
    {
    char hex[] = "0123456789ABCDEF";

    // Bug 97049 return on NULL instead of crashing
    if (!szDest)
        return NULL;
    if (!szSrc)
        {
        *szDest = '\0';
        return szDest;
        }

    while (*szSrc)
        {
        if (*szSrc == ' ')
            {
            *szDest++ = '+';
            ++szSrc;
            }
        else if ( (*szSrc & 0x80) || !isalnum((UCHAR)(*szSrc)) )
            {
            *szDest++ = '%';
            *szDest++ = hex[BYTE(*szSrc) >> 4];
            *szDest++ = hex[*szSrc++ & 0x0F];
            }

        else
            *szDest++ = *szSrc++;
        }

    *szDest = '\0';
    return szDest;
    }



/*===================================================================
DBCSEncodeLen

Return the storage requirements for a DBCS encoded string
(url-encoding of characters with the upper bit set ONLY)

Parameters:
    szSrc  - Pointer to the string to URL Encode

Returns:
    the number of bytes required to encode the string
===================================================================*/

int DBCSEncodeLen(const char *szSrc)
    {
    int cbURL = 1;      // add terminator now

    // Bug 97049 return 0 on NULL instead of crashing
    if (!szSrc)
        return 0;

    while (*szSrc)
        {
        cbURL += ((*szSrc & 0x80) || (!isalnum((UCHAR)(*szSrc)) && !strchr("/$-_.+!*'(),", *szSrc)))? 3 : 1;
        ++szSrc;
        }

    return cbURL;
    }



/*===================================================================
DBCSEncode

DBCS Encode a string by escaping characters with the upper bit
set - Basically used to convert 8 bit data to 7 bit in contexts
where full encoding is not needed.

Parameters:
    szDest - Pointer to the buffer to store the URLEncoded string
    szSrc  - Pointer to the source buffer

Returns:
    A pointer to the NUL terminator is returned.
===================================================================*/

char *DBCSEncode(char *szDest, const char *szSrc)
    {
    char hex[] = "0123456789ABCDEF";

    // Bug 97049 return on NULL instead of crashing
    if (!szDest)
        return NULL;
    if (!szSrc)
        {
        *szDest = '\0';
        return szDest;
        }

    while (*szSrc)
        {
        if ((*szSrc & 0x80) || (!isalnum((UCHAR)(*szSrc)) && !strchr("/$-_.+!*'(),", *szSrc)))
            {
            *szDest++ = '%';
            *szDest++ = hex[BYTE(*szSrc) >> 4];
            *szDest++ = hex[*szSrc++ & 0x0F];
            }

        else
            *szDest++ = *szSrc++;
        }

    *szDest = '\0';
    return szDest;
    }


/*===================================================================
URLPathEncodeLen

Return the storage requirements for a URLPath-Encoded string

Parameters:
    szSrc  - Pointer to the string to URL Path Encode

Returns:
    the number of bytes required to encode the string
===================================================================*/

int URLPathEncodeLen(const char *szSrc)
    {
    int cbURL = 1;      // count terminator now

    // Bug 97049 return 0 on NULL instead of crashing
    if (!szSrc)
        return 0;

    while ((*szSrc) && (*szSrc != '?'))
        {
        switch (*szSrc)
            {
            // Ignore safe characters
            case '$' :  case '_' :  case '-' :
            case '+' :  case '.' :  case '&' :
            // Ignore URL syntax elements
            case '/' :  case ':' :  case '@' :
            case '#' :  case '*' :  case '!' :
                ++cbURL;
                break;

            default:
                if (!isalnum((UCHAR)(*szSrc)) || // encode non-alphabetic characters
                    (*szSrc & 0x80))    // encode foreign characters
                    cbURL += 3;
                else
                    ++cbURL;
            }
        ++szSrc;
        }

    if (*szSrc == '?')
        {
        while (*szSrc)
            {
            ++cbURL;
            ++szSrc;
            }
        }

    return cbURL;
    }



/*===================================================================
URLPathEncode

Encodes the path portion of a URL.  All characters up to the first
'?' are encoded with the following rules:
    o Charcters that are needed to parse the URL are left alone:
        '/' '.' ':' '@' '#' '*' '!'
    o Non-foreign alphanumberic characters are left alone
    o Anything else is escape encoded
Everything after the '?' is ignored.

Parameters:
    szDest - Pointer to the buffer to store the URLPathEncoded string
    szSrc  - Pointer to the source buffer

Returns:
    A pointer to the NUL terminator is returned.
===================================================================*/

char *URLPathEncode(char *szDest, const char *szSrc)
    {
    char hex[] = "0123456789ABCDEF";

    // Bug 97049 return on NULL instead of crashing
    if (!szDest)
        return NULL;
    if (!szSrc)
        {
        *szDest = '\0';
        return szDest;
        }

    while ((*szSrc) && (*szSrc != '?'))
        {
        switch (*szSrc)
            {
            // Ignore safe characters
            case '$' :  case '_' :  case '-' :
            case '+' :  case '.' :  case '~' :
            case '&' :
            // Ignore URL syntax elements
            case '/' :  case ':' :  case '@' :
            case '#' :  case '*' :  case '!' :
                *szDest++ = *szSrc++;
                break;

            default:
                if (!isalnum((UCHAR)(*szSrc)) || (*szSrc & 0x80))
                    {
                    *szDest++ = '%';
                    *szDest++ = hex[BYTE(*szSrc) >> 4];
                    *szDest++ = hex[*szSrc++ & 0x0F];
                    }
                else
                    *szDest++ = *szSrc++;
            }
        }

    if (*szSrc == '?')
        {
        while (*szSrc)
            {
            *szDest++ = *szSrc++;
            }
        }

    *szDest = '\0';

    return szDest;
    }



// ***************************************************************************
// T I M E    C O N V E R S I O N    S U P P O R T
// ***************************************************************************

/*===================================================================
CTimeToVariantDate

Converts a time_t structure to a Variant Date structure

Parameters:
    ptNow     - date & time to convert
    pdtResult - DATE output of this function

Returns:
    E_FAIL if things go wrong.
===================================================================*/

HRESULT CTimeToVariantDate(const time_t *ptNow, DATE *pdtResult)
    {
    struct tm *ptmNow = localtime(ptNow);
    if (ptmNow == NULL)
        return E_FAIL;

    return
        DosDateTimeToVariantTime(
                ptmNow->tm_mday | ((ptmNow->tm_mon + 1) << 5) | ((ptmNow->tm_year - 80) << 9),
                (unsigned(ptmNow->tm_sec) >> 1) | (ptmNow->tm_min << 5) | (ptmNow->tm_hour << 11),
                pdtResult);
    }



/*===================================================================
VariantDateToCTime

Converts a variant date to a time_t structure used by the "C"
language

Parameters:
    dt       - date to convert to "time_t"
    ptResult - pointer to result which has the value

Returns:
    E_FAIL if things go wrong.
===================================================================*/

HRESULT VariantDateToCTime(DATE dt, time_t *ptResult)
    {
    // Convert the variant time to a documented time format
    //
    unsigned short wDOSDate, wDOSTime;
    if (! VariantTimeToDosDateTime(dt, &wDOSDate, &wDOSTime))
        return E_FAIL;

    // populate a "tm" struct
    //
    struct tm tmConverted;

    tmConverted.tm_sec   = (wDOSTime & 0x1F) << 1;
    tmConverted.tm_min   = (wDOSTime >> 5) & 0x3F;
    tmConverted.tm_hour  = wDOSTime >> 11;
    tmConverted.tm_mday  = wDOSDate & 0x1F;
    tmConverted.tm_mon   = ((wDOSDate >> 5) & 0x0F) - 1;
    tmConverted.tm_year  = (wDOSDate >> 9) + 80;    // adjust for offset from 1980
    tmConverted.tm_isdst = -1;

    // convert the "tm" struct to the number of seconds since Jan 1, 1980
    //
    *ptResult = mktime(&tmConverted);
    return (*ptResult == -1)? E_FAIL : S_OK;
    }



/*===================================================================
CTimeToStringGMT

Converts a C language time_t to a string of the form:

    "Wed, 09-Nov-1999 23:12:40 GMT"

Parameters:
    ptNow    - the time to convert
    szBuffer - pointer to the destination buffer

Returns:
    E_FAIL if something goes wrong

Notes:
    The longest day of the week (in terms of spelling) is "Wednesday";
    the other fields are fixed length. This means that we can
    guarantee the maximum length of szBuffer - there is no need
    for client code to dynamically allocate a buffer.
===================================================================*/
HRESULT CTimeToStringGMT(const time_t *ptNow, char szBuffer[DATE_STRING_SIZE], BOOL fFunkyCookieFormat)
    {
    // The internet standard explicitly says that
    // month and weekday names are in english.
    const char rgstrDOW[7][4] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
    const char rgstrMonth[12][4] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};

    // convert time to GMT
    struct tm *ptmGMT = gmtime(ptNow);
    if (ptmGMT == NULL)
        {
        return E_FAIL;
        }

    // send output in internet format
    const char *szDateFormat = fFunkyCookieFormat?
                  "%s, %02d-%s-%d %02d:%02d:%02d GMT"
                : "%s, %02d %s %d %02d:%02d:%02d GMT";

    sprintf(szBuffer, szDateFormat, rgstrDOW[ptmGMT->tm_wday], ptmGMT->tm_mday,
                rgstrMonth[ptmGMT->tm_mon], ptmGMT->tm_year+1900,
                ptmGMT->tm_hour, ptmGMT->tm_min, ptmGMT->tm_sec);

    return S_OK;
    }

/*
// there is a bug in the C-runtime function strftime that will cause
// an AV on the ALPHA on multi-threaded stress the function has been
// re-written to work around this problem
//
HRESULT CTimeToStringGMT(const time_t *ptNow, char szBuffer[DATE_STRING_SIZE], BOOL fFunkyCookieFormat)
    {
    // convert time to GMT
    //
    struct tm *ptmGMT = gmtime(ptNow);
    if (ptmGMT == NULL)
        return E_FAIL;

    // Set locale to "C" locale.  The internet standard explicitly says that
    // month and weekday names are in english.
    //
    char *lcTimeCurrent = setlocale(LC_TIME, "C");
    if (lcTimeCurrent == NULL)
        return E_FAIL;

    // send output in internet format
    //
    const char *szDateFormat = fFunkyCookieFormat?
                                      "%a, %d-%b-%Y %H:%M:%S GMT"
                                    : "%a, %d %b %Y %H:%M:%S GMT";

    strftime(szBuffer, DATE_STRING_SIZE, szDateFormat, ptmGMT);

    // Restore locale
    //
    if (! setlocale(LC_TIME, lcTimeCurrent))
        return E_FAIL;

    // done
    return S_OK;
    }
*/


// ***************************************************************************
// W I D E    C H A R A C T E R    S U P P O R T
// ***************************************************************************

/*============================================================================
WstrToMBstrEx

Copies a wide character string into an ansi string.

Parameters:
    LPSTR dest      - The string to copy  into
    LPWSTR src      - the input BSTR
    cchBuffer      - the number of CHARs allocated for the destination string.
    lCodePage       - the codepage used in conversion, default to CP_ACP

============================================================================*/
UINT WstrToMBstrEx(LPSTR dest, INT cchDest, LPCWSTR src, int cchSrc, UINT lCodePage)
    {
    UINT cch;

    DBG_ASSERT(cchDest > 0);

    // if the src length was specified, then reserve room for the NULL terminator.
    // This is necessary because WideCharToMultiByte doesn't add or account for
    // the NULL terminator if a source is specified.

    if (cchSrc != -1)
        cchDest--;

    cch = WideCharToMultiByte(lCodePage, 0, src, cchSrc, dest, cchDest, NULL, NULL);
    if (cch == 0)
        {
        dest[0] = '\0';
        if(ERROR_INSUFFICIENT_BUFFER == GetLastError())
            {
            cch = WideCharToMultiByte(lCodePage, 0, src, cchSrc, dest, 0, NULL, NULL);

            // if a src length was specified, then WideCharToMultiByte does not include
            // it in it's resulting length.  Bump the count so that the caller does
            // account for the NULL.

            if (cchSrc != -1)
                cch++;         
            }
        else
            {
            DBG_ASSERT(FALSE);
            DBGERROR((DBG_CONTEXT, "Last error is %d\n", GetLastError()));
            cch = 1;
            }
        }
    else if (cchSrc != -1)
        {

        // if a src length was specified, then WideCharToMultiByte does not include
        // it in it's resulting length nor does it add the NULL terminator.  So add 
        // it and bump the count.

        dest[cch++] = '\0';
        }

    DBG_ASSERT(cch != 0);
    return cch;
    }

/*============================================================================
MBstrToWstrEx

Copies a ansi string into an wide character string.

Parameters:
    LPWSTR dest    - The string to copy  into
    LPSTR src      - the input ANSI string
    cchDest        - the number of Wide CHARs allocated for the destination string.
    cchSrc         - the length of the source ANSI string
    lCodePage      - the codepage used in conversion, default to CP_ACP

============================================================================*/
UINT MBstrToWstrEx(LPWSTR dest, INT cchDest, LPCSTR src, int cchSrc, UINT lCodePage)
    {
    UINT cch;

    DBG_ASSERT(cchDest > 0);

    // if the src length was specified, then reserve room for the NULL terminator.
    // This is necessary because WideCharToMultiByte doesn't add or account for
    // the NULL terminator if a source is specified.

    if (cchSrc != -1)
        cchDest--;

    cch = MultiByteToWideChar(lCodePage, 0, src, cchSrc, dest, cchDest);
    if (cch == 0)
        {
        dest[0] = '\0';
        if(ERROR_INSUFFICIENT_BUFFER == GetLastError())
            {
            cch = MultiByteToWideChar(lCodePage, 0, src, cchSrc, dest, 0);

            // if a src length was specified, then WideCharToMultiByte does not include
            // it in it's resulting length.  Bump the count so that the caller does
            // account for the NULL.

            if (cchSrc != -1)
                cch++;         
            }
        else
            {
            DBG_ASSERT(FALSE);
            DBGERROR((DBG_CONTEXT, "Last error is %d\n", GetLastError()));
            cch = 1;
            }
        }
    else if (cchSrc != -1)
        {

        // if a src length was specified, then WideCharToMultiByte does not include
        // it in it's resulting length nor does it add the NULL terminator.  So add 
        // it and bump the count.

        dest[cch++] = '\0';
        }

    DBG_ASSERT(cch != 0);
    return cch;
    }


/*============================================================================
SysAllocStringFromSz

Allocate a System BSTR and copy the given ANSI string into it.

Parameters:
    sz              - The string to copy (Note: this IS an "sz", we will stop at the first NULL)
    cch             - the number of ANSI characters in szT.  If 0, will calculate size.
    BSTR *pbstrRet  - the returned BSTR
    lCodePage       - the codepage for conversion

Returns:
    Allocated BSTR in return value
    S_OK on success, E_OUTOFMEMORY on OOM

Side effects:
    Allocates memory.  Caller must deallocate
============================================================================*/
HRESULT SysAllocStringFromSz
(
CHAR *sz,
DWORD cch,
BSTR *pbstrRet,
UINT lCodePage
)
    {
    BSTR bstrRet;

    Assert(pbstrRet != NULL);

    if (sz == NULL)
        {
        *pbstrRet = NULL;
        return(S_OK);
        }

    // initialize this because callers look at this to see if the routine was
    // successful

    *pbstrRet = NULL;

    // If they passed 0, then determine string length
    if (cch == 0)
        cch = strlen(sz);

    // Allocate a string of the desired length
    // SysAllocStringLen allocates enough room for unicode characters plus a null
    // Given a NULL string it will just allocate the space
    bstrRet = SysAllocStringLen(NULL, cch);
    if (bstrRet == NULL)
        return(E_OUTOFMEMORY);

    // If we were given "", we will have cch=0.  return the empty bstr
    // otherwise, really copy/convert the string
    // NOTE we pass -1 as 4th parameter of MulitByteToWideChar for DBCS support
    if (cch != 0)
        {
        UINT cchTemp = 0;
        if (MultiByteToWideChar(lCodePage, 0, sz, -1, bstrRet, cch+1) == 0)
            return(HRESULT_FROM_WIN32(GetLastError()));

        // If there are some DBCS characters in the sz(Input), then, the character count of BSTR(DWORD) is
        // already set to cch(strlen(sz)) in SysAllocStringLen(NULL, cch), we cannot change the count,
        // and later call of SysStringLen(bstr) always returns the number of characters specified in the
        // cch parameter at allocation time.  Bad, because one DBCS character(2 bytes) will convert
        // to one UNICODE character(2 bytes), not 2 UNICODE characters(4 bytes).
        // Example: For input sz contains only one DBCS character, we want to see SysStringLen(bstr)
        // = 1, not 2.
        bstrRet[cch] = 0;
        cchTemp = wcslen(bstrRet);
        if (cchTemp < cch)
            {
            BSTR bstrTemp = SysAllocString(bstrRet);
			if (bstrTemp == NULL)
				return(E_OUTOFMEMORY);
            SysFreeString(bstrRet);
            bstrRet = bstrTemp;
            cch = cchTemp;
            }
        }
    bstrRet[cch] = 0;
    *pbstrRet = bstrRet;

    return(S_OK);
    }

/*============================================================================
StringDupA

Duplicate a string.  An empty string will only be duplicated if the fDupEmpty
flag is set, else a NULL is returned.

Parameter
    CHAR *pszStrIn      string to duplicate

Returns:
    NULL if failed.
    Otherwise, the duplicated string.

Side Effects:
    ***ALLOCATES MEMORY -- CALLER MUST FREE***
============================================================================*/

CHAR *StringDupA
(
CHAR    *pszStrIn,
BOOL    fDupEmpty
)
    {
    CHAR *pszStrOut;
    INT  cch, cBytes;

    if (NULL == pszStrIn)
        return NULL;

    cch = strlen(pszStrIn);
    if ((0 == cch) && !fDupEmpty)
        return NULL;

    cBytes = sizeof(CHAR) * (cch+1);
    pszStrOut = (CHAR *)malloc(cBytes);
    if (NULL == pszStrOut)
        return NULL;

    memcpy(pszStrOut, pszStrIn, cBytes);
    return pszStrOut;
    }

/*============================================================================
StringDupW

Same as StrDup but for WCHAR strings

Parameter
    WCHAR *pwszStrIn      string to duplicate

Returns:
    NULL if failed.
    Otherwise, the duplicated string.

Side Effects:
    ***ALLOCATES MEMORY -- CALLER MUST FREE***
============================================================================*/

WCHAR *StringDupW
(
WCHAR *pwszStrIn,
BOOL  fDupEmpty
)
{
    WCHAR *pwszStrOut;
    INT  cch, cBytes;

    if (NULL == pwszStrIn)
        return NULL;

    cch = wcslen(pwszStrIn);
    if ((0 == cch) && !fDupEmpty)
        return NULL;

    cBytes = sizeof(WCHAR) * (cch+1);
    pwszStrOut = (WCHAR *)malloc(cBytes);
    if (NULL == pwszStrOut)
        return NULL;

    memcpy(pwszStrOut, pwszStrIn, cBytes);
    return pwszStrOut;
}


/*============================================================================
StringDupUTF8

Same as StrDup but for WCHAR strings that need to be Dup'd to UTF8

Parameter
    WCHAR *pwszStrIn      string to duplicate

Returns:
    NULL if failed.
    Otherwise, the duplicated UTF8 string.

Side Effects:
    ***ALLOCATES MEMORY -- CALLER MUST FREE***
============================================================================*/

CHAR *StringDupUTF8
(
WCHAR *pwszStrIn,
BOOL  fDupEmpty
)
{
    CWCharToMBCS convStr;

    if ((pwszStrIn == NULL) || (*pwszStrIn == L'\0')) {

        goto returnEmpty;
    }

    if (FAILED(convStr.Init(pwszStrIn))) {
        goto returnEmpty;
    }
    else {

        CHAR *pRetStr = convStr.GetString(TRUE);
        
        if (!pRetStr)
            goto returnEmpty;

        return pRetStr;
    }

returnEmpty:

    if (fDupEmpty)
        return StringDupA(NULL, TRUE);
    else
        return NULL;
}
/*===================================================================
CbWStr

Get byte length of WCHAR string (needed to manipulate hash keys)

Parameter
    LPWSTR pwszString   WCHAR string

Returns
    length in bytes
===================================================================*/
DWORD CbWStr
(
WCHAR *pwszString
)
    {
    return (pwszString ? (sizeof(WCHAR) * wcslen(pwszString)) : 0);
    }


/*===================================================================
DotPathToPath

This function offers support for parent path translation. for example
szFileSpec = "../foo/bar.asp"
szParentDirectory = "/scripts/more/stuff"

result = "/scripts/more/foo/bar.asp"

Parameter
    char *szDest                        - destination string
    const char *szFileSpec              - input path mask
    const char *szParentDirectory       - path to map from

Notes
    No more than "MAX_PATH" bytes are written into szDest.
    Returns FALSE when this happens.

Returns
    int TRUE/FALSE
===================================================================*/
BOOL
DotPathToPath
(
TCHAR *szDest,
const TCHAR *szFileSpec,
const TCHAR *szParentDirectory
)
{

    STACK_BUFFER( tempFileSpec, MAX_PATH );

    if (szFileSpec[0] == _T('\0')) {
        _tcscpy(szDest, szParentDirectory);
        return TRUE;
    }

    if (szFileSpec[0] == _T('/') || szFileSpec[0] == _T('\\'))
        return FALSE;

    // Make a copy of the FileSpec to allow for
    //    a. szDest == szFileSpec (inplace) should work
    //    b. Algorithm below works if szFileSpec ends with a '/' (or '\\')
    //

    if (!tempFileSpec.Resize((_tcslen(szFileSpec) + 2)*sizeof(TCHAR))) {
        return FALSE;
    }

    TCHAR *szFileSpecT = (TCHAR *)(tempFileSpec.QueryPtr());
    TCHAR *szT = strcpyEx(szFileSpecT, szFileSpec);
    szT = CharPrev(szFileSpecT, szT);
    if( *szT != _T('/') && *szT != _T('\\')) {
        szT = CharNext(szT);
        *szT++ = _T('/');
        *szT = _T('\0');
    }

    // Initialize "cchDest" - count of characters in destination
    int cchDest = _tcslen(szParentDirectory) + 1;
    if (cchDest > MAX_PATH)
        return FALSE;

    // OK if szParentDirectory is rewritten in place
    TCHAR *pchDestEnd;
    if (szDest == szParentDirectory)
        pchDestEnd = const_cast<TCHAR *>(&szParentDirectory[_tcslen(szParentDirectory)]);
    else
        pchDestEnd = strcpyEx(szDest, szParentDirectory);

    // Loop through each component in "szFileSpec", then do the following:
    //       for ".", do nothing
    //       for "..", delete rightmost dir from szDest
    //       otherwise, append the component.
    //

    const TCHAR *pchBegin = szFileSpecT;
    while (*pchBegin != _T('\0')) {
        // Calculate end of this segment
        const TCHAR *pchEnd = _tcspbrk(pchBegin,_T("\\/"));

        // check for parent path
        if ((_tcsncmp(pchBegin, _T(".."), 2) == 0) 
            && ((pchBegin[2] == _T('/')) || (pchBegin[2] == _T('\\')))) {
            // Delete rightmost path in dest
            while ((pchDestEnd > szDest) 
                    && (*pchDestEnd != _T('/'))
                    && (*pchDestEnd != _T('\\'))) {
                pchDestEnd = CharPrev(szDest, pchDestEnd);
            }

            if (pchDestEnd == szDest)   // we ".."'ed too many levels
                return FALSE;

            *pchDestEnd = _T('\0');
        }

        // Make sure this is not ".". If it is not, append the path
        else if (! (pchBegin[0] == _T('.') && (pchBegin[1] == _T('/') || pchBegin[1] == _T('\\')))) {
            cchDest += 1 + (int)(pchEnd - pchBegin);
            if (cchDest > MAX_PATH)
                return FALSE;

            *pchDestEnd++ = _T('/');
            _tcsncpy(pchDestEnd, pchBegin, pchEnd - pchBegin);
            pchDestEnd += (pchEnd - pchBegin);
            *pchDestEnd = _T('\0');
        }

        // Prepare for next iteration
        pchBegin = pchEnd + 1;
    }

    // It's possible that if the relative path is something like "..", and parent path is a single path
    // (either "/" or "C:/", then the root directory is indicator is missing - szDest is either the
    // empty string or something like "C:"
    //
#if UNICODE
    if (szDest[0] == '\0' 
        || ((szDest[1] == L':') && (szDest[2] == L'\0'))) {
        szDest[2] = L'/';
        szDest[3] = L'\0';
    }
#else
    if (szDest[0] == '\0' ||
        (!IsDBCSLeadByte(szDest[0]) && szDest[1] == ':' && szDest[2] == '\0') ||
        (IsDBCSLeadByte(szDest[0]) && szDest[2] == ':' && szDest[3] == '\0')) {
        strcat(szDest, "/");
    }
#endif
    return TRUE;
}

/*===================================================================
FIsGlobalAsa

Check if the given path points to GLOBAL.ASA

Parameter
    szPath      the path to check

Returns
    TRUE/FALSE
===================================================================*/
BOOL FIsGlobalAsa
(
const TCHAR *szPath,
DWORD cchPath
)
    {
    if (cchPath == 0)
        cchPath = _tcslen(szPath);
    return (cchPath >= CCH_GLOBAL_ASA &&
            !_tcsicmp(szPath+(cchPath-CCH_GLOBAL_ASA), SZ_GLOBAL_ASA));
    }

/*===================================================================
EncodeSessionIdCookie

Convert 3 DWORDs into a SessionID cookie string

Parameters
    dw1, dw2, dw3       DWORDs
    pszCookie           cookie to fill in

Returns
    HRESULT
===================================================================*/
HRESULT EncodeSessionIdCookie
(
DWORD dw1, DWORD dw2, DWORD dw3,
char *pszCookie
)
    {
    DWORD dw = dw1;

    for (int idw = 0; idw < 3; idw++)
        {
        for (int i = 0; i < 8; i++)
            {
            *(pszCookie++) = (char)('A' + (dw & 0xf));
            dw >>= 4;
            }
        dw = (idw == 0) ? dw2 : dw3;
        }

    *pszCookie = '\0';
    return S_OK;
    }

/*===================================================================
DecodeSessionIdCookie

Convert SessionID cookie string into 3 DWORDs

Parameters
    pszCookie           cookie string
    pdw1, pdw2, pdw3    [out] DWORDs

Returns
    HRESULT
===================================================================*/
HRESULT DecodeSessionIdCookie
(
const char *pszCookie,
DWORD *pdw1, DWORD *pdw2, DWORD *pdw3
)
    {
    if (strlen(pszCookie) != SESSIONID_LEN)
        return E_FAIL;

    DWORD *pdw = pdw1;

    for (int idw = 0; idw < 3; idw++)
        {
        *pdw = 0;

        for (int i = 0; i < 8; i++)
            {
            int ch = pszCookie[idw*8+7-i];
            if (ch < 'A' || ch > ('A'+0xf))
                return E_FAIL;

            *pdw <<= 4;
            *pdw |= (ch - 'A');
            }

        pdw = (idw == 0) ? pdw2 : pdw3;
        }

    return S_OK;
    }

/*===================================================================
GetTypelibFilenameFromRegistry

Find a typelib filename (path) from the registry using GUID, version,
and LCID. The algorithm taken from VBA. Does some tricky matching.

Parameters
    szUUID      GUID
    szVersion   Version
    lcid        LCID
    szName      [out] TYPELIB Path
    cbName      buffer length of szName

Returns
    HRESULT
===================================================================*/
HRESULT GetTypelibFilenameFromRegistry
(
const char *szUUID,
const char *szVersion,
LCID lcid,
char *szName,
DWORD cbName
)
    {
    szName[0] = '\0';

    LONG iRet;
    HKEY hkeyTLib = NULL;
    HKEY hkeyGuid = NULL;

    // Open up the typelib section of the registry.

    iRet = RegOpenKeyExA(HKEY_CLASSES_ROOT, "TypeLib", 0, KEY_READ, &hkeyTLib);
    if (iRet != ERROR_SUCCESS)
        return E_FAIL;

    // Now open up the guid, if it is registered.

    iRet = RegOpenKeyExA(hkeyTLib, szUUID, 0, KEY_READ, &hkeyGuid);
    if (iRet != ERROR_SUCCESS)
        {
        RegCloseKey(hkeyTLib);
        return E_FAIL;
        }

    // Iterate through the versions trying to find the exact match
    // or get the latest (max version number)

    char  szMaxVersion[16];
    DWORD dwMaxVersion = 0; // to calculate max version number

    BOOL fLookForExactMatch = (szVersion && *szVersion);

    int iVer = 0;
    szMaxVersion[0] = '\0';

    while (1)
        {
        char szEnumVer[16];

        iRet = RegEnumKeyA(hkeyGuid, iVer++, szEnumVer, sizeof(szEnumVer));
        if (iRet != ERROR_SUCCESS)
            break;

        // check for the exact match first
        if (fLookForExactMatch && strcmp(szEnumVer, szVersion))
            {
            strcpy(szMaxVersion, szEnumVer);
            break;
            }

        // calc the version number
        char *pchDot = strchr(szEnumVer, '.');
        if (!pchDot) // ignore if not #.#
            continue;

        DWORD dwVer = (strtoul(szEnumVer, NULL, 16) << 16) |
                       strtoul(pchDot+1, NULL, 16);

        if (dwVer && szMaxVersion[0] == '\0' || dwVer > dwMaxVersion)
            {
            strcpy(szMaxVersion, szEnumVer);
            dwMaxVersion = dwVer;
            }
        }

    // szMaxVersion (if not empty now has the desired version number)

    if (szMaxVersion[0])
        {
        HKEY hkeyVer = NULL;
        iRet = RegOpenKeyExA(hkeyGuid, szMaxVersion, 0, KEY_READ, &hkeyVer);

        if (iRet == ERROR_SUCCESS)
            {
            HKEY hkeyWin32 = NULL;  // "win32" under LCID is for TYPELIB name
            BOOL fLcidFound = FALSE;

            // Now there's a version key.
            // We need to find the best matching lcid

            for (int iTry = 1; !fLcidFound && iTry <= 3; iTry++)
                {
                char szLcid[10];

                switch (iTry)
                    {
                case 1:
                    // if the passed lcid is not 0, try it
                    if (!lcid)
                        continue;
                    _ultoa(lcid, szLcid, 16);
                    break;

                case 2:
                    // passed lcid stripped to primary language
                    if (!lcid)
                        continue;
                    _ultoa(PRIMARYLANGID(lcid), szLcid, 16);
                    break;

                case 3:
                    // "0"
                    szLcid[0] = '0';
                    szLcid[1] = '\0';
                    break;
                    }

                HKEY hkeyLcid  = NULL;
                iRet = RegOpenKeyExA(hkeyVer, szLcid, 0, KEY_READ, &hkeyLcid);
                if (iRet == ERROR_SUCCESS)
                    {
                    iRet = RegOpenKeyExA(hkeyLcid, "win32", 0, KEY_READ, &hkeyWin32);
                    if (iRet == ERROR_SUCCESS)
                        fLcidFound = TRUE;
                    RegCloseKey(hkeyLcid);
                    }
                }

            if (fLcidFound)
                {
                // LCID has been found - get the TYPELIB name
                Assert(hkeyWin32);
                LONG lName = cbName;
                iRet = RegQueryValueA(hkeyWin32, NULL, szName, &lName);

                if (iRet != ERROR_SUCCESS)
                    szName[0] = '\0';

                RegCloseKey(hkeyWin32);
                }

            RegCloseKey(hkeyVer);
            }
        }

    RegCloseKey(hkeyGuid);
    RegCloseKey(hkeyTLib);
    return (szName[0] == '\0') ? E_FAIL : S_OK;
    }

/*============================================================================
GetSecDescriptor

Get a file's Security Descriptor

Parameters:
    LPCSTR                  lpFileName              - file name
    PSECURITY_DESCRIPTOR    &pSecurityDescriptor    - security descriptor
    DWORD                   &nLength                - size of security descriptor

Returns:
    0 = No error
    or this will return the GetLastError results.

    Allocates memory.  Caller must deallocate (pSecurityDescriptor)
============================================================================*/

DWORD   GetSecDescriptor(LPCTSTR lpFileName, PSECURITY_DESCRIPTOR *ppSecurityDescriptor, DWORD *pnLength)
    {

    if (!FIsWinNT())
        return 0;

    // this should always be NULL
    Assert(*ppSecurityDescriptor == NULL);

    const SECURITY_INFORMATION  RequestedInformation =
                                          OWNER_SECURITY_INFORMATION        // security info struct
                                        | GROUP_SECURITY_INFORMATION
                                        | DACL_SECURITY_INFORMATION;

    DWORD                   nLastError  = 0;
    int                     fDidItWork  = TRUE;
    DWORD                   nLengthNeeded = 0;

    *ppSecurityDescriptor = (PSECURITY_DESCRIPTOR) malloc( *pnLength );

    if (*ppSecurityDescriptor == NULL) {
        return E_OUTOFMEMORY;
    }

    while(TRUE)
        {
        fDidItWork = GetFileSecurity
            (lpFileName,                // address of string for file name
            RequestedInformation,       // requested information
            *ppSecurityDescriptor,      // address of security descriptor
            *pnLength,                  // size of security descriptor buffer
            &nLengthNeeded              // address of required size of buffer
            );

        if(!fDidItWork)
            {
            nLastError = GetLastError();
            if (ERROR_INSUFFICIENT_BUFFER == nLastError)
                {
                *ppSecurityDescriptor = (PSECURITY_DESCRIPTOR) realloc(*ppSecurityDescriptor, nLengthNeeded );
                *pnLength = nLengthNeeded;
                nLastError = 0;
                }
            else
                {
                break;
                }
            }
        else
            {
            *pnLength = GetSecurityDescriptorLength( *ppSecurityDescriptor );
            break;
            }
        }

    // deal with errors and free the SD if needed
    //
    if (nLastError != 0)
        {
        if(*ppSecurityDescriptor)
            {
            free(*ppSecurityDescriptor);
            *ppSecurityDescriptor = NULL;
            }
        }
    return nLastError;
    }

/*============================================================================
AspGetFileAttributes

Wraps GetFileAttributes() and GetFileAttributesEx()

Parameters:
    pfad -- optional WIN32_FILE_ATTRIBUTE_DATA structure

Returns:
    S_OK or E_FAIL
============================================================================*/
HRESULT AspGetFileAttributes
(
LPCTSTR szFileName,
WIN32_FILE_ATTRIBUTE_DATA *pfad
)
    {
    // Take care of NT first (GetFileAttributesEx exists)
    if (Glob(fWinNT))
        {
        WIN32_FILE_ATTRIBUTE_DATA fad;

        BOOL fRet = GetFileAttributesEx
            (
            szFileName,
            GetFileExInfoStandard,
            pfad ? pfad : &fad
            );

        return fRet ? S_OK : E_FAIL;
        }

    // Win9x case
    DWORD dwAttributes = GetFileAttributes(szFileName);
    if (dwAttributes == 0xffffffff)
        return E_FAIL;

    // simulate the return of FAD if requested
    if (pfad)
        {
        memset(pfad, 0, sizeof(WIN32_FILE_ATTRIBUTE_DATA));
        pfad->dwFileAttributes = dwAttributes;
        }

    return S_OK;
    }



/*============================================================================
AspCharNextA

UTF-8 aware CharNext()
============================================================================*/

char *AspCharNextA(WORD wCodePage, const char *sz)
	{
	if (wCodePage != CP_UTF8)
		return CharNextExA(wCodePage, sz, 0);
	else
		{
		// CharNextExA won't work correctly in UTF-8.

		// Add support for UTF-8 encoding for Surrogate pairs
		// 110110wwwwzzzzyyyyyyxxxxxx gets encoded as 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx
		// where uuuuu = wwww + 1 (to account for addition of 10000(b16) )
		// For further information refer : Page A-7 of "The Unicode Standard 2.0" ISBN-0-201-48345-9
		if ((*sz & 0xf8) == 0xF0)
		    return const_cast<char *>(sz + 4);  

		//zzzzyyyyyyxxxxxx = 1110zzzz 10yyyyyy 10xxxxxx
		if ((*sz & 0xF0) == 0xE0)
		    return const_cast<char *>(sz + 3);

        //00000yyyyyxxxxxx = 110yyyyy 10xxxxxx
		else if ((*sz & 0xE0) == 0xC0)
			return const_cast<char *>(sz + 2);

        //000000000xxxxxxx = 0xxxxxxx
		else
			return const_cast<char *>(sz + 1);
		}
	}

/*============================================================================
CWCharToMBCS::~CWCharToMBCS

The destructor has to be in the source file to ensure that it gets the right
memory allocation routines defined.
============================================================================*/
CWCharToMBCS::~CWCharToMBCS() 
{
    if(m_pszResult && (m_pszResult != m_resMemory)) 
        free(m_pszResult); 
}

/*============================================================================
CWCharToMBCS::Init

Converts the passed in WideChar string to MultiByte in the code page
specified.  Uses memory declared in the object if it can, else allocates
from the heap.
============================================================================*/
HRESULT CWCharToMBCS::Init(LPCWSTR pWSrc, UINT lCodePage /* = CP_ACP */, int cchWSrc /* = -1 */)
{
    INT cbRequired;

    // don't even try to convert if we get a NULL pointer to the source.  This
    // condition could be handled by setting by just initing an empty string.

    if (pWSrc == NULL) {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    // The init method can be called multiple times on the same object.  Check
    // to see if memory was allocated the last time it was called.  If so,
    // free it and restore the result pointer to the object memory.  Note that
    // an allocation failure could have occurred in a previous call.  The result
    // would be a NULL m_pszResult.

    if (m_pszResult != m_resMemory) {
        if (m_pszResult)
            free(m_pszResult);
        m_pszResult = m_resMemory;
        m_cbResult = 0;
    }

    // set the first byte of the result string to NULL char.  This should help
    // to ensure that nothing wacky happens if this function fails.

    *m_pszResult = '\0';

    // attempt translation into object memory.

    cbRequired = WstrToMBstrEx(m_pszResult, sizeof(m_resMemory), pWSrc, cchWSrc, lCodePage);

    // if the conversion fit, then we're done.  Note the final result size and 
    // return.

    if (cbRequired <= sizeof(m_resMemory)) {
        m_cbResult = cbRequired;
        return NO_ERROR;
    }

    // if it didn't fit, allocate memory.  Return E_OUTOFMEMORY if it fails.

    m_pszResult = (LPSTR)malloc(cbRequired);
    if (m_pszResult == NULL) {
        return E_OUTOFMEMORY;
    }

    // try the convert again.  It should work.

    cbRequired = WstrToMBstrEx(m_pszResult, cbRequired, pWSrc, cchWSrc, lCodePage);

    // store the final char count in the object.

    m_cbResult = cbRequired;

    return NO_ERROR;
}

/*============================================================================
CWCharToMBCS::GetString

Returns a pointer to the converted string.

If the fTakeOwnerShip parameter is FALSE, then the pointer in the object is
simply returned to the caller.

If the fTakeOwnerShip parameter is TRUE, then the caller is expecting to be
returned a pointer to heap memory that they have to manage.  If the converted
string is in the object's memory, then the string is duplicated into the heap.
If it's already heap memory, then the pointer is handed off to the caller.

NOTE - Taking ownership essentially destroys the current contents of the 
object.  GetString cannot be called on the object again to get the same value.
The result will be a pointer to a empty string.

============================================================================*/
LPSTR CWCharToMBCS::GetString(BOOL fTakeOwnerShip)
{
    LPSTR retSz;

    // return the pointer stored in m_psz_Result if not being
    // requested to give up ownership on the memory or the
    // current value is NULL.

    if ((fTakeOwnerShip == FALSE) || (m_pszResult == NULL)) {
        retSz = m_pszResult;
    }

    // ownership is being requested and the pointer is non-NULL.

    // if the pointer is pointing to the object's memory, dup
    // the string and return that.

    else if (m_pszResult == m_resMemory) {

        retSz = StringDupA(m_pszResult, TRUE);
    }

    // if not pointing to the object's memory, then this is allocated
    // memory and we can relinquish it to the caller.  However, re-establish
    // the object's memory as the value for m_pszResult.

    else {
        retSz = m_pszResult;
        m_pszResult = m_resMemory;
        *m_pszResult = '\0';
        m_cbResult = 0;
    }

    return(retSz);
}

/*============================================================================
CMBCSToWChar::~CMBCSToWChar

The destructor has to be in the source file to ensure that it gets the right
memory allocation routines defined.
============================================================================*/
CMBCSToWChar::~CMBCSToWChar() 
{
    if(m_pszResult && (m_pszResult != m_resMemory)) 
        free(m_pszResult); 
}

/*============================================================================
CMBCSToWChar::Init

Converts the passed in MultiByte string to UNICODE in the code page
specified.  Uses memory declared in the object if it can, else allocates
from the heap.
============================================================================*/
HRESULT CMBCSToWChar::Init(LPCSTR pASrc, UINT lCodePage /* = CP_ACP */, int cchASrc /* = -1 */)
{
    INT cchRequired;

    // don't even try to convert if we get a NULL pointer to the source.  This
    // condition could be handled by setting by just initing an empty string.

    if (pASrc == NULL) {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    // The init method can be called multiple times on the same object.  Check
    // to see if memory was allocated the last time it was called.  If so,
    // free it and restore the result pointer to the object memory.  Note that
    // an allocation failure could have occurred in a previous call.  The result
    // would be a NULL m_pszResult.

    if (m_pszResult != m_resMemory) {
        if (m_pszResult)
            free(m_pszResult);
        m_pszResult = m_resMemory;
        m_cchResult = 0;
    }

    // set the first byte of the result string to NULL char.  This should help
    // to ensure that nothing wacky happens if this function fails.

    *m_pszResult = '\0';

    // attempt translation into object memory.  NOTE - MBstrToWstrEx returns the
    // count of characters, not bytes.

    cchRequired = MBstrToWstrEx(m_pszResult, sizeof(m_resMemory)/sizeof(WCHAR), pASrc, cchASrc, lCodePage);

    // if the conversion fit, then we're done.  Note the final result size and 
    // return.

    if (cchRequired <= (sizeof(m_resMemory)/sizeof(WCHAR))) {
        m_cchResult = cchRequired;
        return NO_ERROR;
    }

    // if it didn't fit, allocate memory.  Return E_OUTOFMEMORY if it fails.

    m_pszResult = (LPWSTR)malloc(cchRequired*sizeof(WCHAR));
    if (m_pszResult == NULL) {
        return E_OUTOFMEMORY;
    }

    // try the convert again.  It should work.

    cchRequired = MBstrToWstrEx(m_pszResult, cchRequired, pASrc, cchASrc, lCodePage);

    // store the final char count in the object.

    m_cchResult = cchRequired;

    return NO_ERROR;
}

/*============================================================================
CMBCSToWChar::GetString

Returns a pointer to the converted string.

If the fTakeOwnerShip parameter is FALSE, then the pointer in the object is
simply returned to the caller.

If the fTakeOwnerShip parameter is TRUE, then the caller is expecting to be
returned a pointer to heap memory that they have to manage.  If the converted
string is in the object's memory, then the string is duplicated into the heap.
If it's already heap memory, then the pointer is handed off to the caller.

NOTE - Taking ownership essentially destroys the current contents of the 
object.  GetString cannot be called on the object again to get the same value.
The result will be a pointer to a empty string.

============================================================================*/
LPWSTR CMBCSToWChar::GetString(BOOL fTakeOwnerShip)
{
    LPWSTR retSz;

    // return the pointer stored in m_psz_Result if not being
    // requested to give up ownership on the memory or the
    // current value is NULL.

    if ((fTakeOwnerShip == FALSE) || (m_pszResult == NULL)) {
        retSz = m_pszResult;
    }

    // ownership is being requested and the pointer is non-NULL.

    // if the pointer is pointing to the object's memory, dup
    // the string and return that.

    else if (m_pszResult == m_resMemory) {

        retSz = StringDupW(m_pszResult, TRUE);
    }

    // if not pointing to the object's memory, then this is allocated
    // memory and we can relinquish it to the caller.  However, re-establish
    // the object's memory as the value for m_pszResult.

    else {
        retSz = m_pszResult;
        m_pszResult = m_resMemory;
        *m_pszResult = '\0';
        m_cchResult = 0;
    }

    return(retSz);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\util.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: misc

File: util.h

Owner: AndrewS

This file contains random useful utility macros.
===================================================================*/

#ifndef _UTIL_H
#define _UTIL_H

#include <dbgutil.h>

// Generally useful
#define PPVOID VOID **
#define BOOLB BYTE

/* S E R V E R _ G E T
 *
 * Get a server variable from ISAPI.  Automatically queries for the buffer
 * size and increases the BUFFER object.
 *
 * Usage:
 *		DWORD dwLen;
 *		char *szValue = SERVER_GET(<ecb>, <szKey>, bufferObj, &dwLen)
 *
 * bufferObj is a STACK_BUFFER object than can be dynamically resized as necessary
 *
 * On return,
 *       bufferObj.QueryPtr() points to data.  dwLen is the real length of the variable.
 */
class CIsapiReqInfo;
BOOL Server_FindKey(CIsapiReqInfo *pIReq, char *szBuffer, DWORD *dwBufLen, const char *szKey);

inline BOOL SERVER_GET(CIsapiReqInfo *pIReq, const char *szKey, BUFFER *pBuffer, DWORD *pdwBufLen) {

    DWORD   dwBufLen = pBuffer->QuerySize();

    if (Server_FindKey(pIReq, (char *)pBuffer->QueryPtr(), &dwBufLen, szKey)) {
        *pdwBufLen = dwBufLen;
        return TRUE;
    }

    if (!pBuffer->Resize(dwBufLen)) {
        SetLastError(E_OUTOFMEMORY);
        return FALSE;
    }

    *pdwBufLen = dwBufLen;

    return Server_FindKey(pIReq, (char *)pBuffer->QueryPtr(), pdwBufLen, szKey);
}

/* V a r i a n t R e s o l v e D i s p a t c h
 *
 * Convert an IDispatch pointer to a Variant by calling IDispatch::Invoke
 * on dispid(0) repeatedly until a non-IDispatch Variant is returned
 */

HRESULT VariantResolveDispatch(VARIANT *pVarOut, VARIANT *pVarIn, const GUID &iidObj, int nObjId);

/* V a r i a n t G e t B S T R
 *
 * Get BSTR from a variant when available
 */

BSTR VariantGetBSTR(const VARIANT *pvar);

/* F i n d A p p l i c a t i o n P a t h
 *
 *  Find the application path for this request.
 */

HRESULT FindApplicationPath(CIsapiReqInfo *pIReq, TCHAR *szPath, int cbPath);

/* N o r m a l i z e
 *
 * Convert filenames to a uniform format
 */
int Normalize(TCHAR *szSrc);
#ifdef DBG
BOOLB IsNormalized(const TCHAR* sz);
#endif	// DBG

/* H T M L E n c o d e L e n
 *
 * Returns the storage requirements to HTML encode a string.
 */
int HTMLEncodeLen(const char *szSrc, UINT uCodePage, BSTR bstrIn, BOOL fEncodeExtCharOnly = FALSE);


/* H T M L E n c o d e
 *
 * HTML encoeds a string.
 */
char *HTMLEncode(char *szDest, const char *szSrc, UINT uCodePage, BSTR bstrIn, BOOL fEncodeExtCharOnly = FALSE);


/* U R L E n c o d e L e n
 *
 * Returns the storage requirements to URL encode a string
 */
int URLEncodeLen(const char *szSrc);


/* U R L E n c o d e
 *
 * Hex escape non alphanumeric characters and change spaces to '+'.
 */
char *URLEncode(char *szDest, const char *szSrc);


/* D B C S E n c o d e L e n
 *
 * Returns the storage requirements to DBCS encode a string
 */

int DBCSEncodeLen(const char *szSrc);

/* D B C S E n c o d e
 *
 * Hex escape characters with the upper bit set - this will encode DBCS.
 */
char *DBCSEncode(char *szDest, const char *szSrc);


/* U R L P a t h E n c o d e L e n
 *
 * Returns the storage requirements to URL path encode a string
 */
int URLPathEncodeLen(const char *szSrc);


/* U R L P a t h E n c o d e
 *
 * Hex escape non alphanumeric or syntax characters until a ? is reached.
 */
char *URLPathEncode(char *szDest, const char *szSrc);


/* s t r c p y E x
 *
 * Like strcpy() but returns a pointer to the NUL character on return
 */
char *strcpyExA(char *szDest, const char *szSrc);


/* w c s c p y E x
 *
 * strcpyEx for wide strings
 */
wchar_t *strcpyExW(wchar_t *szDest, const wchar_t *szSrc);

#if UNICODE
#define strcpyEx    strcpyExW
#else
#define strcpyEx    strcpyExA
#endif

/* G e t B r a c k e t i n g P a i r
 *
 * searches an ordered array and returns the bracketing pair of 'n', i.e.
 * the largest value <= 'n', and the smallest value >= 'n', or points
 * to end() if no bracketing pair exists.
 *
 * Note: STL is not supported with NT build - when such support is added,
 *       replace this function with either 'lower_bound' or 'upper_bound'.
 */
template<class EleType, class ValType, class Ordering>
void GetBracketingPair(const ValType &value, EleType *pBegin, EleType *pEnd, Ordering FIsLess, EleType **ppLB, EleType **ppUB)
	{
	EleType *pT1, *pT2;
	if (ppLB == NULL) ppLB = &pT1;
	if (ppUB == NULL) ppUB = &pT2;

	*ppLB = pBegin;					// Temporary use to see if we've moved pBegin
	*ppUB = pEnd;					// Temporary use to see if we've moved pEnd

	while (pBegin < pEnd)
		{
		EleType *pMidpt = &pBegin[(pEnd - pBegin) >> 1];
		if (FIsLess(*pMidpt, value))
			pBegin = pMidpt + 1;

		else if (FIsLess(value, *pMidpt))
			pEnd = pMidpt;

		else
			{
			*ppLB = *ppUB = pMidpt;
			return;
			}
		}

	if (pBegin == *ppUB)		// at end, no upper bound
		{
		if (pBegin == *ppLB)	// low bound was initially equal to upper bound
			*ppLB = NULL;		// lower bound does not exits
		else
			*ppLB = pEnd - 1;	// lower bound is pEnd - 1

		*ppUB = NULL;
		}

	else if (pBegin != *ppLB)	// pBegin was moved; pBegin-1 is the lower bound
		{
		*ppLB = pBegin - 1;
		*ppUB = pBegin;
		}

	else						// pBegin was not moved - no lower bound exists
		{
		*ppLB = NULL;
		*ppUB = pBegin;
		}
	}


/* V a r i a n t D a t e T o C T i m e
 *
 * Converts a timestamp stored as a Variant date to the format C && C++ use.
 */
HRESULT VariantDateToCTime(DATE dt, time_t *ptResult);


/* C T i m e T o V a r i a n t D a t e
 *
 * Converts a timestamp stored as a time_t to a Variant Date
 */
HRESULT CTimeToVariantDate(const time_t *ptNow, DATE *pdtResult);


/* C T i m e T o S t r i n g G M T
 *
 * Converts a C language time_t value to a string using the format required for
 * the internet
 */
const DATE_STRING_SIZE = 30;	// date strings will not be larger than this size
HRESULT CTimeToStringGMT(const time_t *ptNow, char szBuffer[DATE_STRING_SIZE], BOOL fFunkyCookieFormat = FALSE);


//DeleteInterfaceImp calls 'delete' and NULLs the pointer
#define DeleteInterfaceImp(p)\
			{\
			if (NULL!=p)\
				{\
				delete p;\
				p=NULL;\
				}\
			}

//ReleaseInterface calls 'Release' and NULLs the pointer
#define ReleaseInterface(p)\
			{\
			if (NULL!=p)\
				{\
				p->Release();\
				p=NULL;\
				}\
			}

/*
 * String handling stuff
 */
HRESULT SysAllocStringFromSz(CHAR *sz, DWORD cch, BSTR *pbstrRet, UINT lCodePage = CP_ACP);

/*
 * A simple class to convert WideChar to Multibyte.  Uses object memory, if sufficient,
 * else allocates memory from the heap.  Intended to be used on the stack.
 */

class CWCharToMBCS
{
private:

    LPSTR    m_pszResult;
    char     m_resMemory[256];
    INT      m_cbResult;

public:

    CWCharToMBCS() { m_pszResult = m_resMemory; m_cbResult = 0; }
    ~CWCharToMBCS();
    
    // Init(): converts the widechar string at pWSrc to an MBCS string in memory 
    // managed by CWCharToMBCS

    HRESULT Init(LPCWSTR  pWSrc, UINT lCodePage = CP_ACP, int cch = -1);

    // GetString(): returns a pointer to the converted string.  Passing TRUE
    // gives the ownership of the memory to the caller.  Passing TRUE has the
    // side effect of clearing the object's contents with respect to the
    // converted string.  Subsequent calls to GetString(). after which a TRUE
    // value was passed, will result in a pointer to an empty string being
    // returned.

    LPSTR GetString(BOOL fTakeOwnerShip = FALSE);

    // returns the number of bytes in the converted string - NOT including the
    // NULL terminating byte.  Note that this is the number of bytes in the
    // string and not the number of characters.

    INT   GetStringLen() { return (m_cbResult ? m_cbResult - 1 : 0); }
};

/*
 * A simple class to convert Multibyte to Widechar.  Uses object memory, if sufficient,
 * else allocates memory from the heap.  Intended to be used on the stack.
 */

class CMBCSToWChar
{
private:

    LPWSTR   m_pszResult;
    WCHAR    m_resMemory[256];
    INT      m_cchResult;

public:

    CMBCSToWChar() { m_pszResult = m_resMemory; m_cchResult = 0; }
    ~CMBCSToWChar();
    
    // Init(): converts the MBCS string at pSrc to a Wide string in memory 
    // managed by CMBCSToWChar

    HRESULT Init(LPCSTR  pSrc, UINT lCodePage = CP_ACP, int cch = -1);

    // GetString(): returns a pointer to the converted string.  Passing TRUE
    // gives the ownership of the memory to the caller.  Passing TRUE has the
    // side effect of clearing the object's contents with respect to the
    // converted string.  Subsequent calls to GetString(). after which a TRUE
    // value was passed, will result in a pointer to an empty string being
    // returned.

    LPWSTR GetString(BOOL fTakeOwnerShip = FALSE);

    // returns the number of WideChars in the converted string, not bytes.

    INT   GetStringLen() { return (m_cchResult ? m_cchResult - 1 : 0); }
};

/*
 * Output Debug String should occur in Debug only
 */

inline void DebugOutputDebugString(LPCSTR x)
    {
#ifndef _NO_TRACING_
    DBGPRINTF((DBG_CONTEXT, x));
#else
#ifdef DBG
    OutputDebugStringA(x); 
#endif
#endif
    }

inline void __cdecl DebugFilePrintf(LPCSTR fname, LPCSTR fmt, ...)
    {
#ifdef DBG
    FILE *f = fopen(fname, "a");
    if (f)
        {
        va_list marker;
        va_start(marker, fmt);
        vfprintf(f, fmt, marker);
        va_end(marker);
        fclose(f);
        }
#endif
    }

/*
 * Duplicate CHAR String using proper malloc (moved from error.h)
 */

CHAR *StringDupA(CHAR *pszStrIn, BOOL fDupEmpty = FALSE);


/*
 * Duplicate WCHAR String using proper malloc
 */

WCHAR *StringDupW(WCHAR *pwszStrIn, BOOL fDupEmpty = FALSE);

#if UNICODE
#define StringDup   StringDupW
#else
#define StringDup   StringDupA
#endif

/*
 * Duplicate WCHAR String into a UTF-8 string
 */
CHAR *StringDupUTF8(WCHAR  *pwszStrIn, BOOL fDupEmpty = FALSE);

/*
 * The same using macro to allocate memory from stack:

WSTR_STACK_DUP
(
wsz     -- string to copy
buf     -- user supplied buffer (to use before trying alloca())
pwszDup -- [out] the pointer to copy (could be buffer or alloca())
)
    
 *
 */

inline HRESULT WSTR_STACK_DUP(WCHAR *wsz, BUFFER *buf, WCHAR **ppwszDup) {

    HRESULT     hr = S_OK;
    DWORD cbwsz = wsz && *wsz ? (wcslen(wsz)+1)*sizeof(WCHAR) : 0;

    *ppwszDup = NULL;

    if (cbwsz == 0);

    else if (!buf->Resize(cbwsz)) {

        hr = E_OUTOFMEMORY;
    }
    else {
        *ppwszDup = (WCHAR *)buf->QueryPtr();
        memcpy(*ppwszDup, wsz, cbwsz);
    }

    return hr;
}

/*
 * String length (in bytes) of a WCHAR String
 */

DWORD CbWStr(WCHAR *pwszStrIn);

/*
 * Parent path support function
 */

BOOL DotPathToPath(TCHAR *szDest, const TCHAR *szFileSpec, const TCHAR *szParentDirectory);

/*
 * Check if is global.asa
 */

BOOL FIsGlobalAsa(const TCHAR *szPath, DWORD cchPath = 0);

/*
 * Encode/decode cookie
 */

HRESULT EncodeSessionIdCookie(DWORD dw1, DWORD dw2, DWORD dw3, char *pszCookie);
HRESULT DecodeSessionIdCookie(const char *pszCookie, DWORD *pdw1, DWORD *pdw2, DWORD *pdw3);

/*
 * Typelibrary name from the registry
 */

HRESULT GetTypelibFilenameFromRegistry(const char *szUUID, const char *szVersion,
                                       LCID lcid, char *szName, DWORD cbName);

/*
 * Get security descriptor for file
 */
DWORD GetSecDescriptor(LPCTSTR lpFileName, PSECURITY_DESCRIPTOR *ppSecurityDescriptor, DWORD *pnLength);


/*
 * Get File Attributes (Ex)
 */
HRESULT AspGetFileAttributes(LPCTSTR szFileName, WIN32_FILE_ATTRIBUTE_DATA *pfad = NULL);

/*
 * Fix for UTF8 CharNext
 */
char *AspCharNextA(WORD wCodePage, const char *pchNext);

#endif // _UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\adfile.cpp ===
// AdFile.cpp: implementation of the CAdFile class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#undef max
#include "AdRot.h"
#include "AdFile.h"
#include "RotObj.h"
#include "sinstrm.h"

extern CMonitor* g_pMonitor;

#ifdef DBG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//--------------------------------------------------------------------
//  CAdFileNotify
//--------------------------------------------------------------------
CAdFileNotify::CAdFileNotify()
    :   m_isNotified(0)
{
}

void
CAdFileNotify::Notify()
{
    ::InterlockedExchange( &m_isNotified, 1 );
}

bool
CAdFileNotify::IsNotified()
{
    return ( ::InterlockedExchange( &m_isNotified, 0 ) ? true : false );
}


//--------------------------------------------------------------------
//  CAdFile
//--------------------------------------------------------------------

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CAdFile::CAdFile()
    :   m_nBorder(defaultBorder),
        m_nHeight(defaultHeight),
        m_nWidth(defaultWidth),
        m_nVSpace(defaultVSpace),
        m_nHSpace(defaultHSpace),
        m_strRedirector( _T("")),
        m_fUTF8(false)
{
    m_pNotify = new CAdFileNotify;
}

CAdFile::~CAdFile()
{
    if ( g_pMonitor )
    {
        g_pMonitor->StopMonitoringFile( m_strFile.c_str() );
    }
}

//---------------------------------------------------------------------------
//
//  ProcessAdFile will check the given filename, if it matches the one it
//  knows it currently has in memory, it will do nothing.  If the filename
//  differs, the old ad information will be dumped, and the new information
//  parsed and stored.
//
//---------------------------------------------------------------------------
bool
CAdFile::ProcessAdFile(
    String  strAdFile )
{
    USES_CONVERSION;

    bool rc = false;
    UINT    weightSum = 0;

    // block all other readers and writers
    CWriter wtr( *this );

    m_ads.erase( m_ads.begin(), m_ads.end() );

    // parse the file
    FileInStream fs( T2CA(strAdFile.c_str()) );
    if ( fs.is_open() )
    {       
        if ( ReadHeader( fs ) )
        {
            while ( !fs.eof() )
            {
                // read one "ad record"
                String strGif;
                String strLink;
                String strAlt;
                String strWeight;
                ULONG lWeight = 0;
                fs >> strGif >> strLink;
                // this just gets us past the new line
                fs.readLine( strAlt );
                fs >> strWeight;

                // check for a negative impression value.  RaiseException if
                // negative

                if (strWeight[0] == '-') {
                    CAdRotator::RaiseException( IDS_ERROR_BAD_WEIGHT_VALUE );
                    goto err;
                }
                lWeight = strWeight.toUInt32();

                weightSum += lWeight;

                if (weightSum > 10000) {
                    CAdRotator::RaiseException( IDS_ERROR_WEIGHT_SUM_TOO_LARGE );
                    goto err;
                }
                
                if ( lWeight != 0 )
                {
                    CAdDescPtr pAd = new CAdDescriptor( lWeight, strLink, strGif, strAlt );
                    if ( pAd.IsValid() )
                    {
                        // add one reference to the ad for each weight
                        for( int i = 0; i < lWeight; i++ )
                        {
                            m_ads.push_back( pAd );
                        }
                    }
                }
            }
            if ( m_ads.size() > 0 )
            {
                if ( m_strFile != strAdFile )
                {
                    g_pMonitor->StopMonitoringFile( m_strFile.c_str() );
                    m_strFile = strAdFile;
                    g_pMonitor->MonitorFile( m_strFile.c_str(), m_pNotify );
                }
                rc = true;
            }
        }
        else
        {
            CAdRotator::RaiseException( IDS_ERROR_CANNOT_READ_ROTATION_SCHEDULE_FILE );
        }
    }
    else
    {
        CAdRotator::RaiseException( IDS_ERROR_CANNOT_LOAD_ROTATION_SCHEDULE_FILE );
    }

err:
    
    return rc;
}

//---------------------------------------------------------------------------
//
//  Refresh will check to see if the cached information is out of date, if so
//  it will re-read the file
//
//---------------------------------------------------------------------------
bool
CAdFile::Refresh()
{
    bool rc = false;
    if ( m_pNotify->IsNotified() )
    {
        ProcessAdFile( m_strFile );
        rc = true;
    }
    return rc;
}


//---------------------------------------------------------------------------
//
//  ReadHeader will parse the header portion of the file.  The header includes
//  some or all of the following fields: HEIGHT, WIDTH, BORDER, REDIRECT,
//  HSPACE, VSPACE.  The fields are separated by newlines and the header is
//  terminated by an asterix.
//
//---------------------------------------------------------------------------
bool
CAdFile::ReadHeader(
    FileInStream&   fs )
{
    bool rc = false;

    // set defaults
    m_nHeight = defaultHeight;
    m_nWidth = defaultWidth;
    m_nHSpace = defaultHSpace;
    m_nVSpace = defaultVSpace;

    m_fUTF8 = fs.is_UTF8();

    bool done = false;
    while ( !fs.eof() && !done )
    {
        String strLine;
        String strName;
        fs.readLine( strLine );
        StringInStream sis( strLine );
        sis >> strName;
        HRESULT hr = S_OK;
        if ( _tcsicmp( strName.c_str(), _T("HEIGHT") ) == 0 )
        {
            hr = sis.readInt( m_nHeight );
        }
        else if ( _tcsicmp( strName.c_str(), _T("WIDTH") ) == 0 )
        {
            hr = sis.readInt( m_nWidth );
        }
        else if ( _tcsicmp( strName.c_str(), _T("VSPACE") ) == 0 )
        {
            hr = sis.readInt( m_nVSpace );
        }
        else if ( _tcsicmp( strName.c_str(), _T("HSPACE") ) == 0 )
        {
            hr = sis.readInt( m_nHSpace );
        }
        else if ( _tcsicmp( strName.c_str(), _T("REDIRECT") ) == 0 )
        {
            hr = sis.readString( m_strRedirector );
        }
        else if ( _tcsicmp( strName.c_str(), _T("BORDER" ) ) == 0 )
        {
            hr = sis.readInt16( m_nBorder );
        }
        else if ( _tcsicmp( strName.c_str(), _T("*") ) == 0 )
        {
            rc = true;
            done = true;
        }
        else
        {
            CAdRotator::RaiseException( IDS_ERROR_UNKNOWN_HEADER_NAME );
        }
/*
        if ( hr != S_OK )
        {
            CAdRotator::RaiseException( IDS_ERROR_HEADER_HAS_NO_ASSOCIATED_VALUE );
        }
*/      
    }
    return rc;
}

//---------------------------------------------------------------------------
//
//  RandomAd chooses and ad at random from the list of ads.  Since there
//  are multiple references to ads based on the weight, we need only produce
//  a random number between 0 and one less than the size of the list.
//
//---------------------------------------------------------------------------
CAdDescPtr
CAdFile::RandomAd() const
{
    if (m_ads.size() > 0)
        return m_ads[ rand() % m_ads.size() ];
    else
        return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\addesc.cpp ===
// AdDesc.cpp: implementation of the CAdDescriptor class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "AdRot.h"
#include "AdDesc.h"

#ifdef DBG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CAdDescriptor::CAdDescriptor(
	ULONG	lWeight,
	String	strLink,
	String	strGif,
	String	strAlt )
	:	m_lWeight( lWeight ),
		m_strLink( strLink ),
		m_strGif( strGif ),
		m_strAlt( strAlt )
{

}

CAdDescriptor::~CAdDescriptor()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\viperint.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Viper Integration Objects

File: viperint.h

Owner: DmitryR

This file contains the definiton of viper integration classes
===================================================================*/

#ifndef VIPERINT_H
#define VIPERINT_H

#include "mtx.h"
#include "mtxpriv.h"
#include "package.h"

#include "asptlb.h"     // needed to define interface pointers

#include "memcls.h"

class CHitObj;  // forward decl

/*===================================================================
  Transaction Support Types
===================================================================*/
#define TransType       DWORD

#define ttUndefined     0x00000000
#define ttNotSupported  0x00000001
#define ttSupported     0x00000002
#define ttRequired      0x00000004
#define ttRequiresNew   0x00000008

/*===================================================================
CViperAsyncRequest class implements IMTSCall interface.
Its OnCall() method does HitObj processing.
This is a private class used in CViperActivity class
===================================================================*/

class CViperAsyncRequest : public IMTSCall
	{
private:
	DWORD          m_cRefs;	          // reference count
	CHitObj       *m_pHitObj;         // request
	
private:
	CViperAsyncRequest();
	~CViperAsyncRequest();

	HRESULT Init(CHitObj *pHitObj);

public:
#ifdef DBG
	virtual void AssertValid() const;
#else
	virtual void AssertValid() const {}
#endif

public:
	// IUnknown Methods
	STDMETHODIMP		 QueryInterface(REFIID iid, void **ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	// IMTSCall Method
	STDMETHODIMP OnCall();

friend class CViperActivity;

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

extern volatile LONG g_nViperRequests;

#ifdef UNUSED
/*===================================================================
CViperThreadEvents class implements IThreadEvents interface.
It allows us to do work on each thread that Viper starts up in their
threadpool.
===================================================================*/

class CViperThreadEvents : public IThreadEvents
	{
private:
	DWORD          m_cRefs;	          // reference count
	
public:
	CViperThreadEvents();
	~CViperThreadEvents() {};

public:
	// IUnknown Methods
	STDMETHODIMP		 QueryInterface(REFIID iid, void **ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	// IThreadEvents Method
	STDMETHODIMP OnStartup();
	STDMETHODIMP OnShutdown();

private:
#ifdef DBG
	virtual void AssertValid() const;
#else
	virtual void AssertValid() const {}
#endif


	};
#endif //UNUSED

/*===================================================================
CViperActivity corresponds to a Session.
It creates MTS activity, and launches async requests
===================================================================*/

class CViperActivity
    {
private:
    IMTSActivity *m_pActivity;
    DWORD m_cBind;    // inited-flag + bind-to-thread count

    inline BOOL FInited() const { return (m_cBind > 0); }

public:
    CViperActivity();
    ~CViperActivity();

    // Create Viper activity
    HRESULT Init(BOOL  fCreateInMTA = FALSE);
    
    // Clone Viper activity
    HRESULT InitClone(CViperActivity *pActivity);

    // Bind/Unbind
    HRESULT BindToThread();
    HRESULT UnBindFromThread();

    // Release Viper activity
    HRESULT UnInit(); 

    // Check if thread-bound
    inline BOOL FThreadBound() const { return (m_cBind > 1); }

    // Post async request within this activity
    HRESULT PostAsyncRequest(CHitObj *pHitObj);

    // post async request without an activity
    static HRESULT PostGlobalAsyncRequest(CHitObj *pHitObj);

public:
#ifdef DBG
	virtual void AssertValid() const;
#else
	virtual void AssertValid() const {}
#endif

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

/*===================================================================
Misc. Functions
===================================================================*/

HRESULT ViperAttachIntrinsicsToContext
    (
    IApplicationObject *pAppln,
    ISessionObject     *pSession  = NULL,
    IRequest           *pRequest  = NULL,
    IResponse          *pResponse = NULL,
    IServer            *pServer   = NULL
    );

HRESULT ViperGetObjectFromContext
    (
    BSTR bstrName,
    IDispatch **ppdisp
    );

HRESULT ViperGetHitObjFromContext
    (
    CHitObj **ppHitObj
    );

HRESULT ViperCreateInstance
    (
    REFCLSID rclsid,
    REFIID   riid,
    void   **ppv
    );

HRESULT ViperConfigure(DWORD cThreads, BOOL fAllowOopComponents);

#ifdef UNUSED
HRESULT SetViperThreadEvents();
#endif //UNUSED

/*===================================================================
COM Helper API
===================================================================*/

BOOL ViperCoObjectIsaProxy
    (
    IUnknown *pUnk
    );

BOOL ViperCoObjectAggregatesFTM
    (
    IUnknown *pUnk
    );

#endif // VIPERINT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\addesc.h ===
// AdDesc.h: interface for the CAdDescriptor class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ADDESC_H__78FFAFF3_E0E1_11D0_8A81_00C0F00910F9__INCLUDED_)
#define AFX_ADDESC_H__78FFAFF3_E0E1_11D0_8A81_00C0F00910F9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "RefCount.h"
#include "RefPtr.h"

class CAdDescriptor : public CRefCounter  
{
public:
	CAdDescriptor( ULONG lWeight, String strLink, String strGif, String strAlt );

	const ULONG		m_lWeight;
	const String	m_strLink;
	const String	m_strGif;
	const String	m_strAlt;

private:
	virtual ~CAdDescriptor();
};

typedef TRefPtr< CAdDescriptor > CAdDescPtr;

#endif // !defined(AFX_ADDESC_H__78FFAFF3_E0E1_11D0_8A81_00C0F00910F9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\adfile.h ===
// AdFile.h: interface for the CAdFile class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ADFILE_H__4792C231_E8B3_11D0_8A87_00C0F00910F9__INCLUDED_)
#define AFX_ADFILE_H__4792C231_E8B3_11D0_8A87_00C0F00910F9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "RefCount.h"
#include "AdDesc.h"
#include "Monitor.h"
#include "rdwrt.h"

class CAdFileNotify : public CMonitorNotify
{
public:
                    CAdFileNotify();
    virtual void    Notify();
            bool    IsNotified();
private:
    long            m_isNotified;
};

DECLARE_REFPTR( CAdFileNotify,CMonitorNotify )

class CAdFile : public CRefCounter, public CReadWrite
{
public:
	enum
	{
		defaultHeight	= 60,
		defaultWidth	= 440,
		defaultHSpace	= 0,
		defaultVSpace	= 0,
		defaultBorder	= 1
	};

	CAdFile();
	CAdDescPtr	RandomAd() const;
    bool        Refresh();
	bool		ProcessAdFile( String strAdFile );
	short		Border() const { return m_nBorder; }
	int			Height() const { return m_nHeight; }
	int			Width() const { return m_nWidth; }
	int			VSpace() const { return m_nVSpace; }
	int			HSpace() const { return m_nHSpace; }
	const String&	Redirector() const { return m_strRedirector; }
    bool        fUTF8() const { return m_fUTF8; }

private:
	typedef TVector< CAdDescPtr > AdListT;

	bool	ReadHeader( FileInStream& fs );

	virtual ~CAdFile();

    String             m_strFile;
	short		        m_nBorder;
	int			        m_nHeight;
	int			        m_nWidth;
	int			        m_nVSpace;
	int			        m_nHSpace;
	String		        m_strRedirector;
	AdListT		        m_ads;
    CAdFileNotifyPtr    m_pNotify;
    bool                m_fUTF8;
};

typedef TRefPtr<CAdFile> CAdFilePtr;

#endif // !defined(AFX_ADFILE_H__4792C231_E8B3_11D0_8A87_00C0F00910F9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp51\viperint.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Viper Integration Objects

File: viperint.cpp

Owner: DmitryR

This file contains the implementation of viper integration classes
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "Context.h"
#include "package.h"
#include "memchk.h"
#include "svcintfs.h"

extern HDESK ghDesktop;

//
// COM holds the last reference to a CViperAsyncRequest
// we need to track these objects to ensure that we don't
// exit before the activity threads have released them.
//

volatile LONG g_nViperRequests = 0;

/*===================================================================
  C  V i p e r  A s y n c R e q u e s t
===================================================================*/

/*===================================================================
CViperAsyncRequest::CViperAsyncRequest

CViperAsyncRequest constructor

Parameters:

Returns:
===================================================================*/	
CViperAsyncRequest::CViperAsyncRequest()
    : m_cRefs(1), m_pHitObj(NULL)
{
    InterlockedIncrement( (LONG *)&g_nViperRequests );
}

/*===================================================================
CViperAsyncRequest::~CViperAsyncRequest

CViperAsyncRequest destructor

Parameters:

Returns:
===================================================================*/	
CViperAsyncRequest::~CViperAsyncRequest()
{
    InterlockedDecrement( (LONG *)&g_nViperRequests );
}

/*===================================================================
CViperAsyncRequest::Init

Initialize CViperAsyncRequest with CHitObj object

Parameters:
    CHitObj       *pHitObj       Denali HitObj

Returns:
    HRESULT
===================================================================*/	
HRESULT CViperAsyncRequest::Init
(
CHitObj *pHitObj
)
    {
    Assert(m_pHitObj == NULL);

    m_pHitObj = pHitObj;
    return S_OK;
    }

#ifdef DBG
/*===================================================================
CViperAsyncRequest::AssertValid

Test to make sure that this is currently correctly formed
and assert if it is not.

Returns:
===================================================================*/
void CViperAsyncRequest::AssertValid() const
    {
    Assert(m_pHitObj);
    Assert(m_cRefs > 0);
    }
#endif

/*===================================================================
CViperAsyncRequest::QueryInterface

Standard IUnknown method

Parameters:
    REFIID iid
    void **ppv

Returns:
    HRESULT
===================================================================*/
STDMETHODIMP CViperAsyncRequest::QueryInterface
(
REFIID iid, 
void **ppv
)
    {
	if (iid == IID_IUnknown || iid == IID_IMTSCall)
	    {
		*ppv = this;
	    AddRef();
		return S_OK;
		}

	return E_NOINTERFACE;
    }

/*===================================================================
CViperAsyncRequest::AddRef

Standard IUnknown method

Parameters:

Returns:
    Ref count
===================================================================*/
STDMETHODIMP_(ULONG) CViperAsyncRequest::AddRef()
    {
	return ++m_cRefs;
    }

/*===================================================================
CViperAsyncRequest::Release

Standard IUnknown method

Parameters:

Returns:
    Ref count
===================================================================*/
STDMETHODIMP_(ULONG) CViperAsyncRequest::Release()
    {
	if (--m_cRefs != 0)
		return m_cRefs;

	delete this;
	return 0;
    }
    
/*===================================================================
CViperAsyncRequest::OnCall

IMTSCall method implementation. This method is called by Viper
from the right thread when it's time to process a request

Parameters:

Returns:
    HRESULT
===================================================================*/
STDMETHODIMP CViperAsyncRequest::OnCall()
    {
    Assert(m_pHitObj);
    CIsapiReqInfo *pIReq = m_pHitObj->PIReq();

    BOOL fRequestReposted = FALSE;

    // add an extra addref here to prevent the deletion of the
    // hitobj deleting the CIsapiReqInfo for this request.

    if (pIReq)
        pIReq->AddRef();

    // Bracket ViperAsyncCallback

    if (SUCCEEDED(StartISAThreadBracket(pIReq)))
        {

        m_pHitObj->ViperAsyncCallback(&fRequestReposted);

        // Make sure there always is DONE_WITH_SESSION
        if (m_pHitObj->FIsBrowserRequest() && !fRequestReposted)
            {
            if (!m_pHitObj->FDoneWithSession())
                m_pHitObj->ReportServerError(IDE_UNEXPECTED);
            }

        if (!fRequestReposted)
            delete m_pHitObj;   // don't delete if reposted

        EndISAThreadBracket(pIReq);
        
        }
    else
        {
        // DONE_WITH_SESSION -- ServerSupportFunction
        // does not need bracketing
        if (m_pHitObj->FIsBrowserRequest())
            m_pHitObj->ReportServerError(0);

        // We never called to process request, there should
        // be no state and it's probably save to delete it
        // outside of bracketing
        delete m_pHitObj;
        }

    m_pHitObj = NULL;       // set to NULL even if not deleted
    Release();              // release this, Viper holds another ref

    if (pIReq)
        pIReq->Release();

    return S_OK;
    }

/*===================================================================
  C  V i p e r  A c t i v i t y
===================================================================*/

/*===================================================================
CViperActivity::CViperActivity

CViperActivity constructor

Parameters:

Returns:
===================================================================*/	
CViperActivity::CViperActivity()
    : m_pActivity(NULL), m_cBind(0)
    {
    }

/*===================================================================
CViperActivity::~CViperActivity

CViperActivity destructor

Parameters:

Returns:
===================================================================*/	
CViperActivity::~CViperActivity()
    {
    UnInit();
    }

/*===================================================================
CViperActivity::Init

Create actual Viper activity using MTSCreateActivity()

Parameters:

Returns:
    HRESULT
===================================================================*/	
HRESULT CViperActivity::Init(BOOL  fCreateInMTA /* = FALSE */)
    {
    Assert(!FInited());

    HRESULT hr = S_OK;

    if (fCreateInMTA) {

        hr = CreateActivityInMTA
            (
            IID_IMTSActivity,
            (void **)&m_pActivity
            );
    }
    else {
        hr = MTSCreateActivity
            (
            IID_IMTSActivity,
            (void **)&m_pActivity
            );
    }        
    if (FAILED(hr))
        return hr;

    m_cBind = 1;
    return S_OK;
    }

/*===================================================================
CViperActivity::InitClone

Clone Viper activity (AddRef() it)

Parameters:
    CViperActivity *pActivity   activity to clone from

Returns:
    HRESULT
===================================================================*/
HRESULT CViperActivity::InitClone
(
CViperActivity *pActivity
)
    {
    Assert(!FInited());
    Assert(pActivity);
    pActivity->AssertValid();

    m_pActivity = pActivity->m_pActivity;
    m_pActivity->AddRef();

    m_cBind = 1;
    return S_OK;
    }

/*===================================================================
CViperActivity::UnInit

Release Viper activity

Parameters:

Returns:
    HRESULT
===================================================================*/	
HRESULT CViperActivity::UnInit()
    {
    if (m_pActivity)
        {
        while (m_cBind > 1)  // 1 is for inited flag
            {
            m_pActivity->UnbindFromThread();
            m_cBind--;
            }
                
        m_pActivity->Release();
        m_pActivity = NULL;
        }

    m_cBind = 0;
    return S_OK;
    }

/*===================================================================
CViperActivity::BindToThread

Bind Activity to current thread using IMTSActivity method

Parameters:

Returns:
    HRESULT
===================================================================*/	
HRESULT CViperActivity::BindToThread()
    {
    Assert(FInited());
    
    m_pActivity->BindToCurrentThread();
    m_cBind++;
    
    return S_OK;
    }
    
/*===================================================================
CViperActivity::UnBindFromThread

UnBind Activity from using IMTSActivity method

Parameters:

Returns:
    HRESULT
===================================================================*/	
HRESULT CViperActivity::UnBindFromThread()
    {
    Assert(FInited());
    Assert(m_cBind > 1);

    m_pActivity->UnbindFromThread();
    m_cBind--;

    return S_OK;
    }
    
/*===================================================================
CViperActivity::PostAsyncRequest

Call HitObj Async.
Creates IMTSCCall object to do it.

Parameters:
    CHitObj      *pHitObj    Denali's HitObj

Returns:
    HRESULT
===================================================================*/	
HRESULT CViperActivity::PostAsyncRequest
(
CHitObj *pHitObj
)
    {
    AssertValid();

    HRESULT hr = S_OK;

    CViperAsyncRequest *pViperCall = new CViperAsyncRequest;
    if (!pViperCall)
         hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
        hr = pViperCall->Init(pHitObj);

	RevertToSelf();

    if (SUCCEEDED(hr))
        hr = m_pActivity->AsyncCall(pViperCall);

    if (FAILED(hr) && pViperCall)  // cleanup if failed
        pViperCall->Release();
        
    return hr;
    }

/*===================================================================
CViperActivity::PostGlobalAsyncRequest

Static method.
Post async request without an activity.
Creates temporary activity

Parameters:
    CHitObj *pHitObj    Denali's HitObj

Returns:
    HRESULT
===================================================================*/	
HRESULT CViperActivity::PostGlobalAsyncRequest
(
CHitObj *pHitObj
)
    {
    HRESULT hr = S_OK;
    
    CViperActivity *pTmpActivity = new CViperActivity;
    if (!pTmpActivity)
         hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
        hr = pTmpActivity->Init();

    if (SUCCEEDED(hr))
        {
        // remember this activity as HitObj's activity
        // HitObj will get rid of it on its destructor
        pHitObj->SetActivity(pTmpActivity);

        hr = pTmpActivity->PostAsyncRequest(pHitObj);
        
        pTmpActivity = NULL; // don't delete, HitObj will
        }

    if (pTmpActivity)
        delete pTmpActivity;

    return hr;
    }

#ifdef DBG
/*===================================================================
CViperAsyncRequest::AssertValid

Test to make sure that this is currently correctly formed
and assert if it is not.

Returns:
===================================================================*/
void CViperActivity::AssertValid() const
	{
    Assert(FInited());
	Assert(m_pActivity);
	}
#endif

#ifdef UNUSED
/*===================================================================
  C  V i p e r  T h r e a d E v e n t s
===================================================================*/

/*===================================================================
CViperThreadEvents::CViperThreadEvents

CViperThreadEvents constructor

Parameters:

Returns:
===================================================================*/	
CViperThreadEvents::CViperThreadEvents()
    : m_cRefs(1)
    {
    }

#ifdef DBG
/*===================================================================
CViperThreadEvents::AssertValid

Test to make sure that this is currently correctly formed
and assert if it is not.

Returns:
===================================================================*/
void CViperThreadEvents::AssertValid() const
    {
    Assert(m_cRefs > 0);
    Assert(ghDesktop != NULL);
    }
#endif

/*===================================================================
CViperThreadEvents::QueryInterface

Standard IUnknown method

Parameters:
    REFIID iid
    void **ppv

Returns:
    HRESULT
===================================================================*/
STDMETHODIMP CViperThreadEvents::QueryInterface
(
REFIID iid, 
void **ppv
)
    {
	if (iid == IID_IUnknown || iid == IID_IThreadEvents)
	    {
		*ppv = this;
	    AddRef();
		return S_OK;
		}

	return E_NOINTERFACE;
    }

/*===================================================================
CViperThreadEvents::AddRef

Standard IUnknown method

Parameters:

Returns:
    Ref count
===================================================================*/
STDMETHODIMP_(ULONG) CViperThreadEvents::AddRef()
    {
    DWORD cRefs = InterlockedIncrement((LPLONG)&m_cRefs);
    return cRefs;
    }

/*===================================================================
CViperThreadEvents::Release

Standard IUnknown method

Parameters:

Returns:
    Ref count
===================================================================*/
STDMETHODIMP_(ULONG) CViperThreadEvents::Release()
    {
    DWORD cRefs = InterlockedDecrement((LPLONG)&m_cRefs);
    if (cRefs)
        return cRefs;

	delete this;
	return 0;
    }
    
/*===================================================================
CViperThreadEvents::OnStartup

IThreadEvents method implementation. This method is called by Viper
whenever they start up a thread.

Parameters:
	None

Returns:
    HRESULT
===================================================================*/
STDMETHODIMP CViperThreadEvents::OnStartup()
    {
    HRESULT hr;
    
    AssertValid();

	// Set the desktop for this thread
	hr = SetDesktop();
	
    return hr;
    }

/*===================================================================
CViperThreadEvents::OnShutdown

IThreadEvents method implementation. This method is called by Viper
whenever they shut down a thread.

Parameters:
	None
	
Returns:
    HRESULT
===================================================================*/
STDMETHODIMP CViperThreadEvents::OnShutdown()
    {
    AssertValid();

    return S_OK;
    }
#endif //UNUSED


/*===================================================================
  G l o b a l  F u n c t i o n s
===================================================================*/

/*===================================================================
ViperSetContextProperty

Static utility function.

Set Viper context property by BSTR and IDispatch*.
The real interface takes BSTR and VARIANT.

Parameters
    IContextProperties *pContextProperties       Context
    BSTR                bstrPropertyName         Name
    IDispatch          *pdispPropertyValue       Value

Returns:
    HRESULT
===================================================================*/
static HRESULT ViperSetContextProperty
(
IContextProperties *pContextProperties,
BSTR                bstrPropertyName, 
IDispatch          *pdispPropertyValue
)
    {
    // Make VARIANT from IDispatch*

    pdispPropertyValue->AddRef();

    VARIANT Variant;
    VariantInit(&Variant);
    V_VT(&Variant) = VT_DISPATCH;
    V_DISPATCH(&Variant) = pdispPropertyValue;

    // Call Viper to set the property
    
    HRESULT hr = pContextProperties->SetProperty
        (
        bstrPropertyName, 
        Variant
        );

    // Cleanup

    VariantClear(&Variant);

    return hr;
    }

/*===================================================================
ViperAttachIntrinsicsToContext

Attach ASP intrinsic objects as Viper context properties

Parameters - Intrinsics as interface pointers
    IApplicationObject *pAppln      Application   (required)
    ISessionObject     *pSession    Session       (optional)
    IRequest           *pRequest    Request       (optional)
    IResponse          *pResponse   Response      (optional)
    IServer            *pServer     Server        (optional)

Returns:
    HRESULT
===================================================================*/
HRESULT ViperAttachIntrinsicsToContext
(
IApplicationObject *pAppln,
ISessionObject     *pSession,
IRequest           *pRequest,
IResponse          *pResponse,
IServer            *pServer
)
    {
    Assert(pAppln);
    
    HRESULT hr = S_OK;

    // Get Viper Context
    
    IObjectContext *pViperContext = NULL;
    hr = GetObjectContext(&pViperContext);

    // Get IContextPoperties interface

    IContextProperties *pContextProperties = NULL;
    if (SUCCEEDED(hr))
   		hr = pViperContext->QueryInterface
   		    (
   		    IID_IContextProperties, 
   		    (void **)&pContextProperties
   		    );

    // Set properties

    if (SUCCEEDED(hr))
        hr = ViperSetContextProperty
            (
            pContextProperties,
            BSTR_OBJ_APPLICATION,
            pAppln
            );

    if (SUCCEEDED(hr) && pSession)
        hr = ViperSetContextProperty
            (
            pContextProperties,
            BSTR_OBJ_SESSION,
            pSession
            );
        
    if (SUCCEEDED(hr) && pRequest)
        hr = ViperSetContextProperty
            (
            pContextProperties,
            BSTR_OBJ_REQUEST,
            pRequest
            );

    if (SUCCEEDED(hr) && pResponse)
        hr = ViperSetContextProperty
            (
            pContextProperties,
            BSTR_OBJ_RESPONSE, 
            pResponse
            );

    if (SUCCEEDED(hr) && pServer)
        hr = ViperSetContextProperty
            (
            pContextProperties,
            BSTR_OBJ_SERVER, 
            pServer
            );

    // Cleanup

    if (pContextProperties)
        pContextProperties->Release();

    if (pViperContext)
        pViperContext->Release();

    return hr;
    }
    
/*===================================================================
ViperGetObjectFromContext

Get Viper context property by LPWSTR and
return it as IDispatch*.
The real interface takes BSTR and VARIANT.

Parameters
    BSTR       bstrName      Property Name
    IDispatch  **ppdisp       [out] Object (Property Value)

Returns:
    HRESULT
===================================================================*/
HRESULT ViperGetObjectFromContext
(
BSTR bstrName,
IDispatch **ppdisp
)
    {
    Assert(ppdisp);

    HRESULT hr = S_OK;

    // Get Viper Context
    
    IObjectContext *pViperContext = NULL;
    hr = GetObjectContext(&pViperContext);

    // Get IContextPoperties interface

    IContextProperties *pContextProperties = NULL;
    if (SUCCEEDED(hr))
   		hr = pViperContext->QueryInterface
   		    (
   		    IID_IContextProperties, 
   		    (void **)&pContextProperties
   		    );

    // Get property Value as variant

    VARIANT Variant;
    VariantInit(&Variant);

    if (SUCCEEDED(hr))
        hr = pContextProperties->GetProperty(bstrName, &Variant);

    // Convert Variant to IDispatch*

    if (SUCCEEDED(hr))
        {
        IDispatch *pDisp = NULL;
        if (V_VT(&Variant) == VT_DISPATCH)
            pDisp = V_DISPATCH(&Variant);

        if (pDisp)
            {
            pDisp->AddRef();
            *ppdisp = pDisp;
            }
        else
            hr = E_FAIL;
        }
    
    // Cleanup

    VariantClear(&Variant);

    if (pContextProperties)
        pContextProperties->Release();

    if (pViperContext)
        pViperContext->Release();

    if (FAILED(hr))
        *ppdisp = NULL;

    return hr;
    }

/*===================================================================
ViperGetHitObjFromContext

Get Server from Viper context property and get
it's current HitObj

Parameters
    CHitObj **ppHitObj  [out]

Returns:
    HRESULT
===================================================================*/
HRESULT ViperGetHitObjFromContext
(
CHitObj **ppHitObj
)
    {
    *ppHitObj = NULL;
    
    IDispatch *pdispServer = NULL;
    HRESULT hr = ViperGetObjectFromContext(BSTR_OBJ_SERVER, &pdispServer);
    if (FAILED(hr))
        return hr;

    if (pdispServer)
        {
        CServer *pServer = static_cast<CServer *>(pdispServer);
        *ppHitObj = pServer->PHitObj();
        pdispServer->Release();
        }

    return *ppHitObj ? S_OK : S_FALSE;
    }
    
/*===================================================================
ViperCreateInstance

Viper's implementation of CoCreateInstance

Parameters
    REFCLSID rclsid         class id
    REFIID   riid           interface
    void   **ppv            [out] pointer to interface

Returns:
    HRESULT
===================================================================*/
HRESULT ViperCreateInstance
(
REFCLSID rclsid,
REFIID   riid,
void   **ppv
)
{
    /*
    DWORD dwClsContext = (Glob(fAllowOutOfProcCmpnts)) ? 
            CLSCTX_INPROC_SERVER | CLSCTX_SERVER : 
            CLSCTX_INPROC_SERVER;
    */

    // The reasons for supporting ASPAllowOutOfProcComponents seem to have
    // vanished. Because this only partially worked in II4 and we changed
    // the default in IIS5 this was causing problems with upgrades. So
    // we're going to ignore the fAllowOutOfProcCmpnts setting.

    DWORD dwClsContext = CLSCTX_INPROC_SERVER | CLSCTX_SERVER;
	return CoCreateInstance(rclsid, NULL, dwClsContext, riid, ppv);
}
/*
    {
    HRESULT hr = S_OK;
   	DWORD dwClsContext;

    IObjectContext *pViperContext = NULL;
    hr = GetObjectContext(&pViperContext);

    if (SUCCEEDED(hr))
        {
        hr = pViperContext->CreateInstance(rclsid, riid, ppv);
        pViperContext->Release();
        
        // If we got back CLASSNOTREG, it might be an OOP Non-MTS component.  
        // If so, and we are allowing OOP components, then try again with CoCreateInstance
        if (hr == REGDB_E_CLASSNOTREG && Glob(fAllowOutOfProcCmpnts))
            {
			dwClsContext = (FIsWinNT()) ? CLSCTX_SERVER : CLSCTX_LOCAL_SERVER;
    		hr = CoCreateInstance(rclsid, NULL, dwClsContext,
    		                            riid, ppv);
            }
        }
    else
        {
        // no Viper context -> use regular CoCreateInstance
        // (set flag to allow any server type)
		dwClsContext = CLSCTX_INPROC_SERVER;
		if (Glob(fAllowOutOfProcCmpnts))
			{
			// If out of proc is allowed, or in the appropriate flag
			dwClsContext |= (FIsWinNT()) ? CLSCTX_SERVER : CLSCTX_LOCAL_SERVER;
			}
    	
    	hr = CoCreateInstance(rclsid, NULL, dwClsContext, riid, ppv);
        }


    return hr;
    }
*/

#ifdef UNUSED
/*===================================================================
SetViperThreadEvents

Give Viper a pair of callbacks to call when the startup and shutdown
their threads

Parameters
	None
	
Returns:
    HRESULT

To use the latter, take your IMTSPackage and QI for IID_IThreadEventSource.  (If not there,
you don't yet have the feature.)  Then do:
	IThreadEvents* psink = new CAndrewsThreadEventSink;
	psource->RegisterThreadEventSink(psink);

===================================================================*/
HRESULT SetViperThreadEvents()
	{
	HRESULT hr = S_OK;
	IMTSPackage *pPackage = NULL;
	IThreadEventSource *pSource = NULL;
	IThreadEvents *pSink = NULL;

	// Get hold of the package
	hr = CoCreateInstance(CLSID_MTSPackage,
						NULL,
						CLSCTX_INPROC_SERVER,
						IID_IMTSPackage,
						(void **)&pPackage);
	if (FAILED(hr) || !pPackage)
		goto LErr;

	hr = pPackage->QueryInterface(IID_IThreadEventSource, 
								(void **)&pSource);
	if (hr == E_NOINTERFACE)
		{
		// This error means that we are running against a version of MTX that doesnt
		// support this.  Oh well.
		hr = S_OK;
		goto LErr;
		}
	if (FAILED(hr))
		goto LErr;

	pSink = new CViperThreadEvents;
	if (pSink == NULL)
		{
		hr = E_OUTOFMEMORY;
		goto LErr;
		}

	pSource->RegisterThreadEventSink(pSink);

LErr:
	if (pSource)
		pSource->Release();
	if (pPackage)
		pPackage->Release();
		
	return hr;
	}
#endif //UNUSED

/*===================================================================
ViperConfigure

Viper settings:  # of threads, queue len, 
                 in-proc failfast, 
                 allow oop components

Parameters
	cThreads                --  number of threads
	fAllowOopComponents     --  TRUE or FALSE
	
Returns:
    HRESULT
===================================================================*/
HRESULT ViperConfigure
(
DWORD cThreads,
BOOL  fAllowOopComponents
)
    {
    HRESULT hr = S_OK;
    IMTSPackage *pPackage = NULL;

    //
    // Get hold of the package
    //

    hr = CoCreateInstance(CLSID_MTSPackage,
			  NULL,
			  CLSCTX_INPROC_SERVER,
			  IID_IMTSPackage,
			  (void **)&pPackage);
    if (SUCCEEDED(hr) && !pPackage)
    	hr = E_FAIL;

    //
    // Set knobs
    //

    if (SUCCEEDED(hr))
        {
#define MTS_STYLE_THREAD_POOL

#ifdef MTS_STYLE_THREAD_POOL
    	IComStaThreadPoolKnobs *pKnobs = NULL;
	    hr = pPackage->QueryInterface(IID_IComStaThreadPoolKnobs, (void **)&pKnobs);
#else
    	IThreadPoolKnobs *pKnobs = NULL;
	    hr = pPackage->QueryInterface(IID_IThreadPoolKnobs, (void **)&pKnobs);
#endif

    	if (SUCCEEDED(hr) && pKnobs)
    	    {
    	    // number of threads
    		SYSTEM_INFO si;
	    	GetSystemInfo(&si);
		    cThreads *= si.dwNumberOfProcessors;
#ifdef MTS_STYLE_THREAD_POOL
    		pKnobs->SetMaxThreadCount(cThreads);
    		pKnobs->SetMinThreadCount(si.dwNumberOfProcessors + 7);

    		// queue length
    		pKnobs->SetQueueDepth(30000);

    		pKnobs->SetActivityPerThread(1);
#else
    		pKnobs->SetMaxThreads(cThreads);
    		pKnobs->SetMinThreads(si.dwNumberOfProcessors + 7);

    		// queue length
    		pKnobs->SetMaxQueuedRequests(30000);
#endif
    		
    	    pKnobs->Release();
    	    }
        }

    //
    // Bug 111008: Tell Viper that we do impersonations
    //
 
    if (SUCCEEDED(hr)) 
        {
    	IImpersonationControl *pImpControl = NULL;
        hr = pPackage->QueryInterface(IID_IImpersonationControl, (void **)&pImpControl);

    	if (SUCCEEDED(hr) && pImpControl) 
    	    {
            hr = pImpControl->ClientsImpersonate(TRUE);
    	    pImpControl->Release();
	        }
        }

    //
    // Disable FAILFAST for in-proc case
    //

    if (SUCCEEDED(hr) && !g_fOOP)
        {
    	IFailfastControl *pFFControl = NULL;
    	hr = pPackage->QueryInterface(IID_IFailfastControl, (void **)&pFFControl);

    	if (SUCCEEDED(hr) && pFFControl) 
    	    {
    	    pFFControl->SetApplFailfast(FALSE);
	        pFFControl->Release();
	        }
    	}

/*
    //
    // Set Allow OOP Components
    //
    if (SUCCEEDED(hr)) 
        {
	    INonMTSActivation *pNonMTSActivation = NULL;
    	hr = pPackage->QueryInterface(IID_INonMTSActivation, (void **)&pNonMTSActivation);
    	
    	if (SUCCEEDED(hr) && pNonMTSActivation) 
    	    {
        	pNonMTSActivation->OutOfProcActivationAllowed(fAllowOopComponents);
    		pNonMTSActivation->Release();
    	    }
   	    }
*/

    //
    // Clean-up
    //

    if (pPackage) 
    	pPackage->Release();

    return hr;
    }


/*===================================================================
  C O M  H e l p e r  A P I
===================================================================*/

/*===================================================================
ViperCoObjectIsaProxy

Checks if the given IUnknown* points to a proxy

Parameters
    IUnknown* pUnk      pointer to check

Returns:
    BOOL    (TRUE if Proxy)
===================================================================*/
BOOL ViperCoObjectIsaProxy
(
IUnknown* pUnk
)
    {
	HRESULT hr;
	IUnknown *pUnk2;

	hr = pUnk->QueryInterface(IID_IProxyManager, (void**)&pUnk2);
	if (FAILED(hr))
		return FALSE;

	pUnk2->Release();
	return TRUE;
    }

/*===================================================================
ViperCoObjectAggregatesFTM

Checks if the given object agregates free threaded marshaller
(is agile)

Parameters
    IUnknown* pUnk      pointer to check

Returns:
    BOOL    (TRUE if Agile)
===================================================================*/
BOOL ViperCoObjectAggregatesFTM
(
IUnknown *pUnk
)
    {
	HRESULT hr;
	IMarshal *pMarshal;
	GUID guidClsid;

	hr = pUnk->QueryInterface(IID_IMarshal, (void**)&pMarshal);
	if (FAILED(hr))
		return FALSE;

	hr = pMarshal->GetUnmarshalClass(IID_IUnknown, pUnk, MSHCTX_INPROC,
	                                 NULL, MSHLFLAGS_NORMAL, &guidClsid);
	pMarshal->Release();

	if (FAILED(hr))
		return FALSE;

	return (guidClsid == CLSID_InProcFreeMarshaler);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\adrot.cpp ===
// AdRot.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f AdRotps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "AdRot.h"
#include <time.h>

#include "AdRot_i.c"
#include <initguid.h>
#include "RotObj.h"
#include "Monitor.h"

#ifdef DBG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

CAdRotModule _Module;
CMonitor* g_pMonitor = NULL;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_AdRotator, CAdRotator)
END_OBJECT_MAP()

LONG
CAdRotModule::Lock()
{
    _ASSERT( g_pMonitor != NULL );
    return CComModule::Lock();
}

LONG
CAdRotModule::Unlock()
{
	LONG lc;
	CLock l(m_cs);
	if ( ( lc = CComModule::Unlock() ) == 0 )
	{
		// final unlock
		_ASSERT( g_pMonitor != NULL );
        g_pMonitor->StopAllMonitoring();
        CAdRotator::ClearAdFiles();
	}
	return lc;
}
		
/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		DEBUG_START;
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
    	srand( static_cast<unsigned int>( time( NULL ) ) );

        _ASSERT( g_pMonitor == NULL );
		try
		{
            g_pMonitor = new CMonitor();
		}
		catch ( std::bad_alloc& )
		{
			// nothing we can do about it here
		}
	}
	else if (dwReason == DLL_PROCESS_DETACH)
    {
        _ASSERT( g_pMonitor != NULL );
        delete g_pMonitor;
        g_pMonitor = NULL;

		CAdRotator::ClearAdFiles();
		_Module.Term();
		_ASSERT( g_pMonitor == NULL );
		DEBUG_STOP;
    }
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\context.cpp ===
#include "stdafx.h"
#include "..\shared\src\context.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\monitor.cpp ===
#include "stdafx.h"
#include "..\shared\src\monitor.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\finstrm.cpp ===
#include "stdafx.h"
#include "..\shared\src\FInStrm.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\mem.cpp ===
#include "stdafx.h"
#include "..\shared\src\mem.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\outstrm.cpp ===
#include "stdafx.h"
#include "..\shared\src\OutStrm.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\instrm.cpp ===
#include "stdafx.h"
#include "..\shared\src\InStrm.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\mystring.cpp ===
#include "stdafx.h"
#include "..\shared\src\MyString.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\rdwrt.cpp ===
#include "stdafx.h"
#include "..\shared\src\RdWrt.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\soutstrm.cpp ===
#include "stdafx.h"
#include "..\shared\src\SOutStrm.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by adrot.rc
//
#define DLL_VER                         0
#define IDS_PROJNAME                    100
#define IDR_ADROTATOR                   101
#define IDS_ADROT                       102
#define IDS_ERROR_NOSVR                 103
#define IDS_ERROR_UNKNOWN_HEADER_NAME   104
#define IDS_ERROR_HEADER_HAS_NO_ASSOCIATED_VALUE 105
#define IDS_ERROR_CANNOT_LOAD_ROTATION_SCHEDULE_FILE 106
#define IDS_ERROR_CANNOT_READ_ROTATION_SCHEDULE_FILE 107
#define IDS_ERROR_SOURCE                108
#define IDS_ERROR_BAD_WEIGHT_VALUE      109
#define IDS_ERROR_WEIGHT_SUM_TOO_LARGE  110

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\rotobj.h ===
// RotObj.h : Declaration of the CAdRotator

#ifndef __ADROTATOR_H_
#define __ADROTATOR_H_

#include "resource.h"       // main symbols
#include <asptlb.h>         // Active Server Pages Definitions
#include "AdDesc.h"
#include "AdFile.h"
#include "lock.h"

/////////////////////////////////////////////////////////////////////////////
// CAdRotator
class ATL_NO_VTABLE CAdRotator : 
	public CComObjectRoot,
	public CComCoClass<CAdRotator, &CLSID_AdRotator>,
	public ISupportErrorInfo,
	public IDispatchImpl<IAdRotator, &IID_IAdRotator, &LIBID_AdRotator>
{
public:
	CAdRotator();
    ~CAdRotator() { if (m_strTargetFrame) ::SysFreeString(m_strTargetFrame); }

public:

DECLARE_REGISTRY_RESOURCEID(IDR_ADROTATOR)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CAdRotator)
	COM_INTERFACE_ENTRY(IAdRotator)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p );
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IAdRotator
public:
	STDMETHOD(get_GetAdvertisement)(BSTR, /*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_TargetFrame)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_TargetFrame)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Border)(/*[out, retval]*/ short *pVal);
	STDMETHOD(put_Border)(/*[in]*/ short newVal);
	STDMETHOD(get_Clickable)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_Clickable)(/*[in]*/ BOOL newVal);

	static void	ClearAdFiles();

	static void RaiseException( LPOLESTR );
	static void RaiseException( UINT );
private:

	typedef TSafeStringMap< CAdFilePtr > AdFileMapT;

	CAdFilePtr      AdFile( const String& strFile );

    CComAutoCriticalSection m_cs;
	bool	            	m_bClickable;
	short		            m_nBorder;
    bool                    m_bBorderSet;
	BSTR		            m_strTargetFrame;
	String		            m_strAdFile;
	CComPtr<IUnknown>		m_pUnkMarshaler;
	static AdFileMapT	    s_adFiles;

};

#endif //__ADROTATOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\rotobj.cpp ===
// RotObj.cpp : Implementation of CAdRotator
#include "stdafx.h"
#include "AdRot.h"
#include "RotObj.h"
#include "RdWrt.h"
#include "context.h"

#ifdef DBG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define MAX_RESSTRINGSIZE 512

/////////////////////////////////////////////////////////////////////////////
// CAdRotator

CAdRotator::AdFileMapT	CAdRotator::s_adFiles;

CAdRotator::CAdRotator()
	:	m_bClickable( true ),
		m_nBorder(-1),
		m_strAdFile( _T("") ),
		m_strTargetFrame( NULL ),
        m_bBorderSet( false )
{
}


STDMETHODIMP CAdRotator::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IAdRotator,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP CAdRotator::get_Clickable(BOOL * pVal)
{
    CLock l(m_cs);
	*pVal = m_bClickable?TRUE:FALSE;
	return S_OK;
}

STDMETHODIMP CAdRotator::put_Clickable(BOOL newVal)
{
    CLock l(m_cs);
	m_bClickable = newVal?true:false;
	return S_OK;
}

STDMETHODIMP CAdRotator::get_Border(short * pVal)
{
	*pVal = m_nBorder;
	return S_OK;
}

STDMETHODIMP CAdRotator::put_Border(short newVal)
{
    CLock l(m_cs);
	m_nBorder = newVal;
    m_bBorderSet = true;
	return S_OK;
}

STDMETHODIMP CAdRotator::get_TargetFrame(BSTR * pVal)
{
	HRESULT rc = E_FAIL;
	USES_CONVERSION;

	try
	{
		if ( pVal )
		{
			CLock l(m_cs);
			if ( *pVal )
			{
				::SysFreeString( *pVal );
			}
            *pVal = ::SysAllocString(m_strTargetFrame);
			THROW_IF_NULL( *pVal );

			rc = S_OK;
		}
		else
		{
			rc = E_POINTER;
		}
	}
	catch ( _com_error& ce )
	{
		rc = ce.Error();
	}
	catch ( ... )
	{
		rc = E_FAIL;
	}
	return rc;
}

STDMETHODIMP CAdRotator::put_TargetFrame(BSTR newVal)
{
	HRESULT rc = E_FAIL;

	try
	{
		CLock l(m_cs);
        m_strTargetFrame = ::SysAllocString(newVal);
		rc = S_OK;
	}
	catch ( _com_error& ce )
	{
		rc = ce.Error();
	}
	catch ( ... )
	{
		rc = E_FAIL;
	}
	return rc;
}

STDMETHODIMP CAdRotator::get_GetAdvertisement(BSTR bstrVirtualPath, BSTR * pVal)
{
	SCODE rc = E_FAIL;
    
    USES_CONVERSION;

	try
	{
		CContext cxt;
		rc = cxt.Init( CContext::get_Server );
		if ( !FAILED(rc) )
		{
			CComBSTR bstrPhysicalPath;
			// determine the physical path
			if ( ( rc = cxt.Server()->MapPath( bstrVirtualPath, &bstrPhysicalPath ) ) == S_OK )
			{
				_TCHAR* szPath = OLE2T( bstrPhysicalPath );

				CAdFilePtr pAdFile = AdFile( szPath );
				
				if ( pAdFile.IsValid() )
				{
					// refresh the ad file (make sure it's up to date)
					pAdFile->Refresh();

					// block all writers
					CReader rdr( *pAdFile );

					// if the border hasn't been set, use the default from the ad file
					short nBorder;
					if ( m_bBorderSet == false )
					{
						nBorder = pAdFile->Border();
					}
					else
					{
						nBorder = m_nBorder;
					}

					CAdDescPtr pAd = pAdFile->RandomAd();
					if ( pAd.IsValid() )
					{
						// write out the HTML line for this ad
						StringOutStream ss;

                        // only write in HREF format if bClickable was set and
                        // there is a link URL that is not "-"

						if ( m_bClickable 
                             && ( pAd->m_strLink.size() > 0 )
                             && ( pAd->m_strLink != "-") )
						{
							// use the href format
							ss	<< _T("<A HREF=\"") << pAdFile->Redirector()
								<< _T("?url=") << pAd->m_strLink
								<< _T("&image=") << pAd->m_strGif 
                                << _T("\" ");
                                
                            if (m_strTargetFrame) {

                                CWCharToMBCS  convStr;

                                if (rc = convStr.Init(m_strTargetFrame, pAdFile->fUTF8() ? 65001 : CP_ACP)) {
                                    throw _com_error(rc);
                                }
                                ss << _T("TARGET=\"") << convStr.GetString() << _T("\"");
                            }
                            
                            ss << _T(">");
						}
						
						// now fill in the rest
						ss	<< _T("<IMG SRC=\"") << pAd->m_strGif
							<< _T("\" ALT=\"") << pAd->m_strAlt
							<< _T("\" WIDTH=") << pAdFile->Width()
							<< _T(" HEIGHT=") << pAdFile->Height();

						if ( pAdFile->HSpace() != CAdFile::defaultHSpace )
						{
							ss << _T(" HSPACE=") << pAdFile->HSpace();
						}
						if ( pAdFile->VSpace() != CAdFile::defaultVSpace )
						{
							ss << _T(" VSPACE=") << pAdFile->VSpace();
						}

						ss << _T(" BORDER=") << nBorder << _T(">");

						if ( m_bClickable 
                             && ( pAd->m_strLink.size() > 0 )
                             && ( pAd->m_strLink != "-") )
						{
							// put the trailing tag on
							ss << _T("</A>");
						}

						String str = ss.toString();
						
						if ( pVal )
						{
                            CMBCSToWChar    convStr;
                            HRESULT         hr;
							if ( *pVal )
							{
								::SysFreeString( *pVal );
							}

                            if (hr = convStr.Init(str.c_str(), pAdFile->fUTF8() ? 65001 : CP_ACP)) {
                                throw _com_error(hr);
                            }
							*pVal = ::SysAllocString( convStr.GetString() );
							THROW_IF_NULL( *pVal );
							rc = S_OK;
						}
						else
						{
							rc = E_POINTER;
						}
					}
				}
			}
		}
		else
		{
			_ASSERT(0);
			RaiseException( IDS_ERROR_NOSVR );
		}   // end if got server
	}
	catch ( _com_error& ce )
	{
		rc = ce.Error();
	}
	catch ( ... )
	{
		rc = E_FAIL;
	}
	return rc;
}



CAdFilePtr
CAdRotator::AdFile(
	const String& strFile )
{
	CAdFilePtr pAdFile;
	CLock l( s_adFiles );
	CAdFilePtr& rpAdFile = s_adFiles[ strFile ];
	if ( !rpAdFile.IsValid() )
	{
		pAdFile = new CAdFile;
		if ( pAdFile->ProcessAdFile( strFile ) )
		{
			rpAdFile = pAdFile;
		}
	}
	else
	{
		pAdFile = rpAdFile;
	}
	return pAdFile;
}



/////////////////////////////////////////////////////////////////////////////
//	ClearAdFiles
//
//	Release all of the ad files from the map
/////////////////////////////////////////////////////////////////////////////
void
CAdRotator::ClearAdFiles()
{
	CLock l( s_adFiles );
	s_adFiles.clear();
}

//---------------------------------------------------------------------------
//	RaiseException
//
//	Raises an exception using the given source and description
//---------------------------------------------------------------------------
void
CAdRotator::RaiseException (
	LPOLESTR strDescr
)
{
	HRESULT hr;
	ICreateErrorInfo *pICreateErr;
	IErrorInfo *pIErr;
	LANGID langID = LANG_NEUTRAL;

	/*
	 * Thread-safe exception handling means that we call
	 * CreateErrorInfo which gives us an ICreateErrorInfo pointer
	 * that we then use to set the error information (basically
	 * to set the fields of an EXCEPINFO structure.	We then
	 * call SetErrorInfo to attach this error to the current
	 * thread.	ITypeInfo::Invoke will look for this when it
	 * returns from whatever function was invokes by calling
	 * GetErrorInfo.
	 */

	_TCHAR tstrSource[MAX_RESSTRINGSIZE];
	if ( ::LoadString(
		_Module.GetResourceInstance(),
		IDS_ERROR_SOURCE,
		tstrSource,
		MAX_RESSTRINGSIZE ) > 0 )
	{
		USES_CONVERSION;

		LPOLESTR strSource = T2OLE( tstrSource );

		//Not much we can do if this fails.
		if (!FAILED(CreateErrorInfo(&pICreateErr)))
		{
			pICreateErr->SetGUID(CLSID_AdRotator);
			pICreateErr->SetHelpFile(L"");
			pICreateErr->SetHelpContext(0L);
			pICreateErr->SetSource(strSource);
			pICreateErr->SetDescription(strDescr);

			hr = pICreateErr->QueryInterface(IID_IErrorInfo, (void**)&pIErr);

			if (SUCCEEDED(hr))
			{
				if(SUCCEEDED(SetErrorInfo(0L, pIErr)))
				{
					pIErr->Release();
				}
			}
			pICreateErr->Release();
		}
	}

	::RaiseException(E_FAIL, 0, 0, NULL);
}

void 
CAdRotator::RaiseException(
	UINT DescrID
)
{
	_TCHAR tstrDescr[MAX_RESSTRINGSIZE];

	if ( ::LoadString(
		_Module.GetResourceInstance(),
		DescrID,
		tstrDescr,
		MAX_RESSTRINGSIZE) > 0 )
	{
		USES_CONVERSION;
		LPOLESTR strDescr = T2OLE( tstrDescr );
		RaiseException( strDescr );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\sinstrm.cpp ===
#include "stdafx.h"
#include "..\shared\src\SInStrm.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\browser\context.cpp ===
#include "stdafx.h"
#include "..\shared\src\context.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__78FFAFE8_E0E1_11D0_8A81_00C0F00910F9__INCLUDED_)
#define AFX_STDAFX_H__78FFAFE8_E0E1_11D0_8A81_00C0F00910F9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


//#define _ATL_APARTMENT_THREADED

#pragma warning( disable : 4786 )
#include <atlbase.h>
#include <mtx.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CAdRotModule : public CComModule
{
public:
	LONG	Lock();
	LONG	Unlock();

private:
	CComAutoCriticalSection	m_cs;
};

extern CAdRotModule _Module;
#include <atlcom.h>
#include <comdef.h>

#include <algorithm>

using namespace std;

#include "myvector.h"
#include "strmap.h"
#include "MyDebug.h"
#include "MyString.h"
#include "SOutStrm.h"
#include "FInStrm.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__78FFAFE8_E0E1_11D0_8A81_00C0F00910F9__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\browser\mem.cpp ===
#include "stdafx.h"
#include "..\shared\src\mem.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\browser\browcap.h ===
// BrowCap.h : Declaration of the CBrowserCap

#ifndef __BROWSERCAP_H_
#define __BROWSERCAP_H_

#include "resource.h"       // main symbols
#include <asptlb.h>         // Active Server Pages Definitions
#include "Lock.h"

/////////////////////////////////////////////////////////////////////////////
// CBrowserFactory
//         --- Create BrowsCap objects from cache.
class CBrowserFactory : public CComClassFactory
	{
	LONG m_cRefs;

public:
	HRESULT STDMETHODCALLTYPE QueryInterface(const IID &, void **);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

	HRESULT STDMETHODCALLTYPE CreateInstance(IUnknown *, const IID &, void **);
	};



/////////////////////////////////////////////////////////////////////////////
// CBrowserCap
class ATL_NO_VTABLE CBrowserCap : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CBrowserCap, &CLSID_BrowserCap>,
	public ISupportErrorInfo,
	public IDispatchImpl<IBrowserCap, &IID_IBrowserCap, &LIBID_BrowserType>
{
public:
	CBrowserCap();
    ~CBrowserCap();

public:

DECLARE_REGISTRY_RESOURCEID(IDR_BROWSERCAP)
DECLARE_GET_CONTROLLING_UNKNOWN()
DECLARE_CLASSFACTORY_EX(CBrowserFactory)

BEGIN_COM_MAP(CBrowserCap)
	COM_INTERFACE_ENTRY(IBrowserCap)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p );
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

// methods to build property DB
	void AddProperty(TCHAR *szName, TCHAR *szValue, BOOL fOverwriteProperty = FALSE);

// Clone the object
	HRESULT Clone(CBrowserCap **ppBrowserCapCopy);

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// Load string resource
	void LoadString(UINT, TCHAR *szText);

public:
// IUnknown methods
	HRESULT STDMETHODCALLTYPE QueryInterface(const IID &, void **);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

// IDispatch Methods
    STDMETHOD(Invoke)(DISPID,REFIID,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,UINT*);
    STDMETHOD(GetIDsOfNames)( REFIID, LPOLESTR*, UINT, LCID, DISPID* );

//Active Server Pages Methods
	STDMETHOD(get_Value)(BSTR, /*[out, retval]*/ VARIANT *pVal);

private:
	DISPID                  		DispatchID( LPOLESTR );
	CComPtr< IUnknown >				m_pUnkMarshaler;
	TSafeStringMap< CComVariant >	m_strmapProperties;
};

#endif //__BROWSERCAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\browser\monitor.cpp ===
#include "stdafx.h"
#include "..\shared\src\monitor.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\browser\mystring.cpp ===
#include "stdafx.h"
#include "..\shared\src\MyString.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\browser\browcap.cpp ===
// BrowCap.cpp : Implementation of CBrowserCap
#include "stdafx.h"
#include "BrwCap.h"
#include "BrowCap.h"
#include "CapMap.h"
#include "context.h"

static const DISPID FIRST_DYNAMIC_DISPID = 10000;

#ifdef DBG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define MAX_RESSTRINGSIZE 512

/////////////////////////////////////////////////////////////////////////////
// CBrowserFactory

HRESULT CBrowserFactory::QueryInterface(const IID &riid, void **ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IClassFactory)
	{
		*ppvObj = this;
		AddRef();
		return S_OK;
	}
	else
	{
		*ppvObj = NULL;
		return E_NOINTERFACE;
	}
}

ULONG CBrowserFactory::AddRef()
{
	InterlockedIncrement(&m_cRefs);
	return m_cRefs;
}

ULONG CBrowserFactory::Release()
{
	if (InterlockedDecrement(&m_cRefs) == 0)
	{
		delete this;
		return 0;
	}
	else
		return m_cRefs;
}

HRESULT CBrowserFactory::CreateInstance(IUnknown *pUnkOuter, const IID &riid, void **ppvObj)
{
	USES_CONVERSION;
	HRESULT hr;
	CContext cxt;
	IRequestDictionary *pDictCookies = NULL;

	if (FAILED(hr = cxt.Init(CContext::get_Request)))
		return hr;

	String				strBrowser;
	CComPtr<IDispatch>	piDispUserAgent;
	CComVariant			varUserAgent;

	if (FAILED(hr = cxt.Request()->get_Item(L"HTTP_USER_AGENT", &piDispUserAgent)))
		return hr;

	varUserAgent = piDispUserAgent;
	varUserAgent.ChangeType(VT_BSTR);
	strBrowser = OLE2T(V_BSTR(&varUserAgent));

	_Module.Lock();
	CBrowserCap *pBrowserCapObj = _Module.CapMap()->LookUp(strBrowser.c_str());
	_Module.Unlock();

	if (pBrowserCapObj == NULL)
		return E_FAIL;

	// IF there is a cookie, then clone the browscap object we got and add cookie properties
	// Otherwise, when there is no cookie, QueryInterface for "riid".
	//
	CComVariant varBrowscapCookie;
	if (SUCCEEDED(cxt.Request()->get_Cookies(&pDictCookies)))
	{
		IReadCookie *pReadCookie = NULL;		// Intermediate dictionary ptr
		CComVariant varCookieName;				// current key
		CComVariant varCookieValue;				// value of "varCookieName"
		IEnumVARIANT *pEnumKeys;


		// Get the BROWSCAP cookie
		if (FAILED(pDictCookies->get_Item(CComVariant(L"BROWSCAP"), &varBrowscapCookie)))
			goto LReleaseDict;

		// If the cookie exists, it will be an IDispatch. Otherwise it will be VT_EMPTY
		if (V_VT(&varBrowscapCookie) == VT_DISPATCH)
		{
			// Clone the cookie.  Since LookUp DID NOT AddRef(), we don't need to Release()
			// the pBrowserCapObj.  Thus cloning to the same pointer is OK here.
			// the clone will have a refcount of zero, so the QueryInterface call at the
			// end is also correct.
			//
			if (FAILED(hr = pBrowserCapObj->Clone(&pBrowserCapObj)))
				goto LReleaseDict;

			hr = V_DISPATCH(&varBrowscapCookie)->QueryInterface(IID_IReadCookie, reinterpret_cast<void **>(&pReadCookie));
			_ASSERT (SUCCEEDED(hr));

			// Iterate over all cookie values
			if (FAILED(hr = pReadCookie->get__NewEnum(reinterpret_cast<IUnknown **>(&pEnumKeys))))
				goto LReleaseDict;

			while (pEnumKeys->Next(1, &varCookieName, NULL) == S_OK)
			{
				// Expecting a string
				_ASSERT (V_VT(&varCookieName) == VT_BSTR);

				// read the cookie value -- better succeed
				hr = pReadCookie->get_Item(varCookieName, &varCookieValue);
				_ASSERT (SUCCEEDED(hr) && V_VT(&varCookieValue) == VT_BSTR);

				// Store key & value in dictionary (over-rides previous settings)
				pBrowserCapObj->AddProperty(OLE2T(V_BSTR(&varCookieName)), OLE2T(V_BSTR(&varCookieValue)), TRUE);

				// Clear "varCookieName" to prevent leak. Since we pass address to Next(), C++ cleanup won't happen on its own
				varCookieName.Clear();
			}

			pEnumKeys->Release();
		}

LReleaseDict:
		pDictCookies->Release();
		if (pReadCookie)
			pReadCookie->Release();

		if (FAILED(hr))
			return hr;
	}

	return pBrowserCapObj->QueryInterface(riid, ppvObj);
}


/////////////////////////////////////////////////////////////////////////////
// CBrowserCap

CBrowserCap::CBrowserCap()
{
}

CBrowserCap::~CBrowserCap()
{
}

STDMETHODIMP CBrowserCap::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IBrowserCap,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP
CBrowserCap::Invoke(
    DISPID      dispidMember,
    REFIID      riid,
    LCID        lcid,
    WORD        wFlags,
    DISPPARAMS* pdispparams,
    VARIANT*    pvarResult,
    EXCEPINFO*  pexcepinfo,
    UINT*       puArgErr )
{
	HRESULT rc;
	try
	{
		USES_CONVERSION;

		if ( dispidMember >= FIRST_DYNAMIC_DISPID )
		{
			if (wFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF))
			{
				char szClass[25], szDescription[80];
				LoadString(IDS_ERROR_SOURCE, szClass);
				LoadString(IDS_ERROR_PROP_RO, szDescription);

				pexcepinfo->scode = E_FAIL;
				pexcepinfo->bstrSource = SysAllocString(T2OLE(szClass));
				pexcepinfo->bstrDescription = SysAllocString(T2OLE(szDescription));
				pexcepinfo->wCode = WORD(dispidMember);

				return DISP_E_EXCEPTION;
			}

			UINT i = dispidMember - FIRST_DYNAMIC_DISPID;
			CLock csT(m_strmapProperties);

			if (i < m_strmapProperties.size())		// dynamic property -- get value
				{
				rc = VariantCopy(pvarResult, &m_strmapProperties[i]);
				}
			else									// property does not exist, return empty
				{
				V_VT(pvarResult) = VT_BSTR;
				V_BSTR(pvarResult) = SysAllocString(L"unknown");
				rc = S_OK;
				}
		}
		else
		{
			rc = IDispatchImpl<IBrowserCap, &IID_IBrowserCap, &LIBID_BrowserType>::Invoke(
					dispidMember,
					riid,
					lcid,
					wFlags,
					pdispparams,
					pvarResult,
					pexcepinfo,
					puArgErr);
		}
	}
	catch( _com_error& ce )
	{
		rc = ce.Error();
	}
	catch( ... )
	{
		rc = E_FAIL;
	}
	return rc;
}

STDMETHODIMP
CBrowserCap::GetIDsOfNames(
    REFIID      riid,
    LPOLESTR*   rgszNames,
    UINT        cNames,
    LCID        lcid,
    DISPID*     rgdispid )
{
	HRESULT rc = E_FAIL;
	try
	{
		// first get the disp IDs of the known methods
		rc = IDispatchImpl<IBrowserCap, &IID_IBrowserCap, &LIBID_BrowserType>::GetIDsOfNames(
				riid,
				rgszNames,
				cNames,
				lcid,
				rgdispid);

		if (rc == DISP_E_UNKNOWNNAME)
		{
			// IDs for other methods are based on property list ID offset after last known method ID
			// this allows a client to say browsercap.Cookies instead of browsercap( "Cookies" ).
			// A property that does not exist is set to a value beyond the end of the strmap.
			// (this tells Invoke not to bother with "get_Value")  This trick only works because
			// properties are all set at creation time and cannot be added later.
			//
			rc = S_OK;
			for (UINT i = 0; i < cNames; i++)
				if (rgdispid[i] == DISPID_UNKNOWN &&
					(rgdispid[i] = DispatchID(rgszNames[i])) == DISPID_UNKNOWN)
						rc = DISP_E_UNKNOWNNAME;
		}
	}
	catch (_com_error& ce)
	{
		rc = ce.Error();
	}
	catch (...)
	{
		rc = E_FAIL;
	}
    return rc;
}

void CBrowserCap::AddProperty(TCHAR *szKey, TCHAR *szValue, BOOL fOverwriteProperty)
{
	USES_CONVERSION;
	CComVariant varT;

	// See if the key already exists, since the first key written into the
	// dictionary wins.  (This is to make sure that the  parent UA string property
	// never overwrites the child.)
	//
	_tcslwr(szKey);
	if (!fOverwriteProperty && m_strmapProperties.find(szKey) != m_strmapProperties.end())
		return;

	if (szValue[0] == _T('#'))
		varT = _ttol(szValue+1);

    else if (_tcsncicmp(szValue, _T("TRUE"), 5) == 0)
        varT = true;

    else if (_tcsncicmp(szValue, _T("FALSE"), 6) == 0)
        varT = false;

	else
		varT = T2CW(szValue);

	m_strmapProperties[szKey] = varT;
}

STDMETHODIMP CBrowserCap::get_Value(BSTR bstrName, VARIANT * pVal)
{
	USES_CONVERSION;
	CLock csT(m_strmapProperties);

	TSafeStringMap<CComVariant>::iterator itProp = m_strmapProperties.find(_tcslwr(OLE2T(bstrName)));
	if (itProp == m_strmapProperties.end())
		{
		V_VT(pVal) = VT_BSTR;
		V_BSTR(pVal) = SysAllocString(L"unknown");
		return V_BSTR(pVal) != NULL? S_OK : E_OUTOFMEMORY;
		}
	else
		return VariantCopy(pVal, &(*itProp).second);
}

DISPID
CBrowserCap::DispatchID(
    LPOLESTR szName )
{
    USES_CONVERSION;

    static const TCHAR *szOnStartPage = _T("onstartpage");
    static const TCHAR *szOnEndPage = _T("onendpage");

    TCHAR *szT = _tcslwr(OLE2T(szName));
    if ((szT == NULL)
        || (_tcscmp(szT, szOnStartPage) == 0) 
        || (_tcscmp(szT, szOnEndPage) == 0))
		return DISPID_UNKNOWN;

	CLock csT(m_strmapProperties);
	String strName = szT;
	TSafeStringMap<CComVariant>::iterator iter = m_strmapProperties.find(strName);
	if (iter == m_strmapProperties.end())
		return m_strmapProperties.size() + FIRST_DYNAMIC_DISPID;

	else
		return (iter - m_strmapProperties.begin()) + FIRST_DYNAMIC_DISPID;
}

HRESULT CBrowserCap::Clone(CBrowserCap **ppBrowserCapCopy)
{
	if ((*ppBrowserCapCopy = new CComObject<CBrowserCap>) == NULL)
		return E_OUTOFMEMORY;

	(*ppBrowserCapCopy)->FinalConstruct();		// Create FTM

	CLock csT(m_strmapProperties);
	TSafeStringMap<CComVariant>::iterator iter;

	for (iter = m_strmapProperties.begin(); iter < m_strmapProperties.end(); ++iter)
		(*ppBrowserCapCopy)->m_strmapProperties[(*iter).first] = (*iter).second;

	return S_OK;
}

void 
CBrowserCap::LoadString(
	UINT nID,
	TCHAR *szText
)
{
	if (::LoadString(_Module.GetResourceInstance(), nID, szText, MAX_RESSTRINGSIZE) == 0)
	{
		_tcscpy(szText, _T("?? Unknown (Can't find resource)"));
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\browser\rdwrt.cpp ===
#include "stdafx.h"
#include "..\shared\src\RdWrt.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\browser\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\browser\brwcap.cpp ===
// BrwCap.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f BrwCapps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "BrwCap.h"

#include "BrwCap_i.c"
#include <initguid.h>
#include "BrowCap.h"
#include "CapMap.h"
#include "Monitor.h"

#ifdef DBG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

CBrwCapModule _Module;

/////////////////////////////////////////////////////////////////////////////
//  CPgCntModule methods
//
CBrwCapModule::CBrwCapModule()
    :   m_pMonitor(NULL),
        m_pCapMap(NULL)
{
}


void
CBrwCapModule::Init(
    _ATL_OBJMAP_ENTRY*  p,
    HINSTANCE           h )
{
    CComModule::Init(p,h);

    _ASSERT( m_pMonitor == NULL);
    m_pMonitor = new CMonitor();
    
    _ASSERT( m_pCapMap == NULL);
    m_pCapMap = new CCapMap();
}

void
CBrwCapModule::Term()
{
    _ASSERT( m_pMonitor != NULL);
    delete m_pMonitor;
    m_pMonitor = NULL;

    _ASSERT( m_pCapMap != NULL);
    delete m_pCapMap;
    m_pCapMap = NULL;

    CComModule::Term();
}

LONG
CBrwCapModule::Lock()
{
    _ASSERT( m_pMonitor != NULL );
    _ASSERT( m_pCapMap != NULL );

	CLock l(m_cs);
	LONG lc = CComModule::Lock();
    ATLTRACE("CBrwCapModule::Lock(%d)\n", lc);

    if (lc == 1)
    {
        m_pCapMap->StartMonitor();
    }

    return lc;
}

LONG
CBrwCapModule::Unlock()
{
	CLock l(m_cs);
	LONG lc = CComModule::Unlock();
    ATLTRACE("CBrwCapModule::Unlock(%d)\n", lc);

	if ( lc == 0 )
	{
        _ASSERT( m_pMonitor != NULL);
        m_pCapMap->StopMonitor();
        m_pMonitor->StopAllMonitoring();
        
        _ASSERT( m_pCapMap != NULL);
	}

	return lc;
}

CMonitor*
CBrwCapModule::Monitor()
{
    _ASSERT( m_pMonitor != NULL);
    return m_pMonitor;
}

CCapMap*
CBrwCapModule::CapMap()
{
    _ASSERT( m_pCapMap != NULL);
    return m_pCapMap;
}


BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_BrowserCap, CBrowserCap)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		DEBUG_START;
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
    {
        ATLTRACE( _T("BrowsCap.dll unloading\n") );
		_Module.Term();
		DEBUG_STOP;
    }
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\browser\makefile.inc ===
#
# Supplemental rules for generating Type library.
#

# CDROOT=$(_NTTREE)\inetsrv
CDROOT=$(_NTTREE)

#CopyFiles
#copy .ini files
CopyFiles:
	if not exist "$(CDROOT)" mkdir $(CDROOT)
	xcopy /d /i browscap.ini $(CDROOT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\browser\capmap.h ===
// CapMap.h: interface for the CCapMap class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CAPMAP_H__2AE59261_E295_11D0_8A81_00C0F00910F9__INCLUDED_)
#define AFX_CAPMAP_H__2AE59261_E295_11D0_8A81_00C0F00910F9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "Monitor.h"
#include "RdWrt.h"
#include "StrMap.h"
#include "BrowCap.h"


class CCapNotify : public CMonitorNotify
{
public:
                    CCapNotify();
    virtual void    Notify();
            bool    IsNotified();
private:
    long            m_isNotified;
};

DECLARE_REFPTR( CCapNotify,CMonitorNotify )


// The capabilites map is a singleton object (only one instance will exist).
// It provides each BrowserCap object with access to the stored capabilites
// while storing it in a central location (increasing the benifit of caching
// and decreasing memory requirements)

typedef TVector< String >		StringVecT;

class CCapMap
{
public:
            	CCapMap();

	CBrowserCap *			LookUp(const String& szBrowser);

    void        			StartMonitor();
    void        			StopMonitor();

private:
	enum {
		DWSectionBufSize = 16384		// max size of an entire BrowsCap.INI section that we allow
	};

    bool    Refresh();

	String					m_strIniFile;
    CCapNotifyPtr           m_pSink;
};

#endif // !defined(AFX_CAPMAP_H__2AE59261_E295_11D0_8A81_00C0F00910F9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\browser\capmap.cpp ===
// CapMap.cpp: implementation of the CCapMap class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "asptlb.h"
#include "context.h"
#include "BrwCap.h"
#include "CapMap.h"

#define MAX_RESSTRINGSIZE 512

#ifdef DBG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

// Global Browser Capabilities Cache.
//
// This is a doubly indexed list --
//    the outer level contains the HTTP_USER_AGENT string.  The sub-array is the property in question
// 
// Example: g_strmapBrowsCapINI["Mozilla 3.0"]["VBScript"] retrieves VBScript property of browser
//          "Mozilla 3.0".  (of course, in practice HTTP_USER_AGENT strings are quite long.)
//
// 
// A note about the data structure choice:
//
//  Many of the keys in BrowsCap.INI are very similiar to each other.  Examples:
//
//       [Mozilla/2.0 (compatible; MSIE 3.0B3; Windows 95)]
//       [Mozilla/2.0 (compatible; MSIE 3.0B3; Windows NT)]
//
// or
//
//       [Mozilla/1.22 (compatible; MSIE 2.0; Windows 95)]
//       [Mozilla/1.22 (compatible; MSIE 2.0c; Windows 95)]
//
// It's likely that excessive hash collisions could occur (these are hardly random keys!), especially
// with small hash modulus (and the table size would be relatively small.)  Therefore, the binary search
// array of the pre-existing TStringMap class seems best.
//
// The subkeys that store the properties could probably be hash tables, but there are so few of them,
// it probably does not matter.  We also use the TStringMap class purely for convenience (it happens to
// exist.)
//
// UNDONE: Cleanup must Release() the pointers (since they are not "smart" CComPtr's)
//
typedef TSafeStringMap<CBrowserCap *>	CacheMapT;

static CacheMapT  		g_strmapBrowsCapINI;	// cache of BrowsCap objects
static TVector<String>	g_rgstrWildcard;		// list of wildcards in BrowsCap.INI
static CReadWrite       g_rwWildcardLock;		// lock for wildcard array


//---------------------------------------------------------------------
// read in wildcards from browscap.ini into g_rgstrWildcard
//---------------------------------------------------------------------
void ReadWildcards(const String &strIniFile)
{
	// PERF NOTE: caller should check if rgstrWildcard[] is empty before
	// calling this function.  However, here we do one extra check
	// when we have the lock because caller should not bother to
	// secure a write lock when checking rgstrWildcard[].
	//
	g_rwWildcardLock.EnterWriter();
	if (g_rgstrWildcard.size() != 0)
	{
		g_rwWildcardLock.ExitWriter();
		return;
	}

	// first get all of the profiles sections into a buffer
	DWORD  dwAllocSize = 16384;
	TCHAR *szBuffer = new TCHAR[dwAllocSize];
	*szBuffer = _T('\0');
    DWORD dwSize;

    // ATLTRACE("ReadWildcards(%s)\n", strIniFile.c_str());

	while ((dwSize = GetPrivateProfileSectionNames(szBuffer, dwAllocSize, strIniFile.c_str())) == dwAllocSize-2  &&  dwSize > 0)
	{
		// reallocate the buffer and try again
		delete[] szBuffer;
		szBuffer = new TCHAR[dwAllocSize *= 2];
        *szBuffer = _T('\0');
	}

    if (dwSize == 0)
        ATLTRACE("ReadWildcards(%s) failed, err=%d\n", 
                 strIniFile.c_str(), GetLastError());

	TCHAR *szSave = szBuffer;

	// now put all wild-card containing entries into the list 
	while( *szBuffer != _T('\0') )
	{
		if (_tcspbrk(szBuffer, "[*?") != NULL)
			g_rgstrWildcard.push_back(szBuffer);

		// advance to the beginning of the next string
		while (*szBuffer != _T('\0'))
			szBuffer = CharNext(szBuffer);

		// now advance once more to get to the next string
		++szBuffer;
	}

	delete[] szSave;
	g_rwWildcardLock.ExitWriter();
}

//---------------------------------------------------------------------
// compare names to templates, *, ?, [, ], not legal filename characters
//
// Also compute # of matching wildcard characters.
//     FOR THIS TO WORK: caller must pass in an initialized counter!
//---------------------------------------------------------------------
bool
match(
    LPCTSTR szPattern,
    LPCTSTR szSubject,
    int *pcchWildcardMatched)
{
    LPTSTR rp;
    _TCHAR tc;

    if (*szPattern == '*')
    {
        ++szPattern;

        do
        {
            int cchWildcardSubMatch = 0;
            if (match(szPattern, szSubject, &cchWildcardSubMatch) == true)
            {
            	*pcchWildcardMatched += cchWildcardSubMatch;
                return true;
            }
        } while (++*pcchWildcardMatched, *szSubject++ != '\0');
    }

    else if (*szSubject == '\0')
        return *szPattern == '\0';

    else if (*szPattern == '[' && (rp = _tcschr(szPattern, ']')) != NULL)
    {
        while (*++szPattern != ']')
            if ((tc = *szPattern) == *szSubject
                    || (szPattern[1] == '-'
                    && (*(szPattern += 2) >= *szSubject && tc <= *szSubject)))
            {
                ++*pcchWildcardMatched;
                return match(rp + 1, ++szSubject, pcchWildcardMatched);
            }

        return false;
    }

    else if (*szPattern == '?')
    {
        ++*pcchWildcardMatched;
        return match(++szPattern, ++szSubject, pcchWildcardMatched);
    }

    else if (tolower(*szPattern) == tolower(*szSubject))
        return match(++szPattern, ++szSubject, pcchWildcardMatched);

    return false;
}

//---------------------------------------------------------------------
//  FindBrowser
//
// match the User Agent against all the wildcards in browscap.ini and
// return the best match. "Best Match" is defined here to mean the match
// requiring the fewest amount of wildcard substitutions.
//---------------------------------------------------------------------

#define INT_MAX int(unsigned(~0) >> 1)
String FindBrowser(const String &strUserAgent, const String &strIniFile)
{
	TVector<String>::iterator iter;
	String strT;

	if (g_rgstrWildcard.size() == 0)
		ReadWildcards(strIniFile);

	g_rwWildcardLock.EnterReader();

	int cchWildMatchMin = INT_MAX;
	for (iter = g_rgstrWildcard.begin(); iter < g_rgstrWildcard.end(); ++iter)
	{
		int cchWildMatchCurrent = 0;
		if (match((*iter).c_str(), strUserAgent.c_str(), &cchWildMatchCurrent) &&
			cchWildMatchCurrent < cchWildMatchMin)
		{
			cchWildMatchMin = cchWildMatchCurrent;
			strT = *iter;
		}
	}

	g_rwWildcardLock.ExitReader();

	// Backward compatibility: If nothing matches, then use
	// "Default Browser Capability Settings".  In the new
	// model, the catch all rule, "*" can also be used.
	//
	if (strT.length() == 0)
		strT = "Default Browser Capability Settings";

	return strT;
}

//---------------------------------------------------------------------
//  CCapNotify
//---------------------------------------------------------------------
CCapNotify::CCapNotify()
    :   m_isNotified(0)
{
}

void
CCapNotify::Notify()
{
    ::InterlockedExchange( &m_isNotified, 1 );
}

bool
CCapNotify::IsNotified()
{
    return ( ::InterlockedExchange( &m_isNotified, 0 ) ? true : false );
}

//---------------------------------------------------------------------
//  CCapMap
//---------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCapMap::CCapMap()
{
	static const String cszIniFile = _T("Browscap.ini");

	// get the path to the inifile containing the browser cap info
	_TCHAR szModule[ _MAX_PATH ];
	::GetModuleFileName(_Module.GetModuleInstance(), szModule, sizeof(szModule));
    ATLTRACE("CapMap: Module(%s)\n", szModule);
    
	// remove the filename and tack on the ini file name
	_TCHAR* pch = _tcsrchr(szModule, '\\');
	if (pch == NULL)
	{
		// the path should have at least one backslash
		_ASSERT(0);
		pch = szModule;
	}
	*(pch+1) = _T('\0');

	m_strIniFile = szModule + cszIniFile;
    ATLTRACE("CCapMap::CCapMap(%s)\n", m_strIniFile.c_str());

    // start monitoring the file
    m_pSink = new CCapNotify();
}

void
CCapMap::StartMonitor()
{
    if ( _Module.Monitor() )
    {
        _Module.Monitor()->MonitorFile( m_strIniFile.c_str(), m_pSink );
        ATLTRACE("CCapMap::StartMonitor(%s)\n", m_strIniFile.c_str());
    }
    else
        ATLTRACE("CCapMap::StartMonitor -- no monitor\n");
}

void
CCapMap::StopMonitor()
{
    if ( _Module.Monitor() )
    {
        _Module.Monitor()->StopMonitoringFile( m_strIniFile.c_str() );
        ATLTRACE("CCapMap::StopMonitor(%s)\n", m_strIniFile.c_str());
    }
    else
        ATLTRACE("CCapMap::StopMonitor -- no monitor\n");
}

CBrowserCap *
CCapMap::LookUp(
	const String& szBrowser)
{
	Refresh();

	CLock csT(g_strmapBrowsCapINI);
	CacheMapT::referent_type &rpBCobj = g_strmapBrowsCapINI[szBrowser];

	if (rpBCobj == NULL)
	{
		rpBCobj = new CComObject<CBrowserCap>;

		// Complete construction and AddRef copy we keep in cache.
		// NOTE: Since caller (class factory) does implicit AddRef via QueryInterface,
		//       the convention of this function is slightly different from COM std.
		//       CALLER IS RESPONSIBLE TO ADDREF RETURNED OBJECT
		//
		rpBCobj->FinalConstruct();
		rpBCobj->AddRef();

        // ATLTRACE("LookUp(%s)\n", szBrowser.c_str());

		// Get Browser Properties
		_TCHAR szSection[DWSectionBufSize];
		if (GetPrivateProfileSection
				(
				szBrowser.c_str(),		// section
				szSection,				// return buffer
				DWSectionBufSize,		// size of return buffer
				m_strIniFile.c_str()	// .INI name
				) == 0)
		{
			// If this call fails, that means the default browser does not exist either, so
			// everything is "unknown".
			//
			String szT = FindBrowser(szBrowser, m_strIniFile);
			if (GetPrivateProfileSection
					(
					szT.c_str(),			// section
					szSection,				// return buffer
					DWSectionBufSize,		// size of return buffer
					m_strIniFile.c_str()	// .INI name
					) == 0)
            {
                ATLTRACE("GPPS(%s) failed, err=%d\n", 
                         szT.c_str(), GetLastError());
                return rpBCobj;
            }
		}

		// Loop through szSection, which contains all the key=value pairs and add them
		// to the browser instance property list.  If we find a "Parent=" Key, save the
		// value to add the parent's properties later.
		//
		TCHAR *szParent;
		do
		{
			szParent = NULL;
			TCHAR *szKeyAndValue = szSection;
			while (*szKeyAndValue)
			{
				TCHAR *szKey = szKeyAndValue;					// save the key
				TCHAR *szValue = _tcschr(szKey, '=');			// find address of value part (-1)
				szKeyAndValue += _tcslen(szKeyAndValue) + 1;	// advance KeyAndValue to the next pair

				if (szValue == NULL)
					continue;

				*szValue++ = '\0';								// separate key and value with NUL; advance

				if (_tcsicmp(szKey, _T("Parent")) == 0)
					szParent = szValue;
				else
					rpBCobj->AddProperty(szKey, szValue);
			}

			// We stored all the attributes on this level.  Ascend to parent level (if it exists)
			if (szParent)
			{
				if (GetPrivateProfileSection
						(
						szParent,				// section
						szSection,				// return buffer
						DWSectionBufSize,		// size of return buffer
						m_strIniFile.c_str()	// .INI name
						) == 0)
				{
					// If this call fails, quit now.
					//
					String szT = FindBrowser(szParent, m_strIniFile);
					if (GetPrivateProfileSection
							(
							szT.c_str(),			// section
							szSection,				// return buffer
							DWSectionBufSize,		// size of return buffer
							m_strIniFile.c_str()	// .INI name
							) == 0)
                    {
                        ATLTRACE("GPPS(%s) failed, err=%d\n", 
                                 szT.c_str(), GetLastError());
                        return rpBCobj;
                    }
				}
			}
		} while (szParent);
	}

	return rpBCobj;
}

//---------------------------------------------------------------------------
//
//  Refresh will check to see if the cached information is out of date with
//  the ini file.  If so, the cached will be purged
//
//---------------------------------------------------------------------------
bool
CCapMap::Refresh()
{
    bool rc = false;
    if ( m_pSink->IsNotified() )
    {
        // Clear the cache

        CLock csT(g_strmapBrowsCapINI);
        g_strmapBrowsCapINI.clear();
        rc = true;

        // clear the list of wildcards.
        // NOTE: each browser request creates new CCapMap object.
        //       the constructor will see the size is zero and reconstruct

        g_rwWildcardLock.EnterWriter();
        g_rgstrWildcard.clear();
        g_rwWildcardLock.ExitWriter();
    }
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\browser\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by BrwCap.rc
//
#define IDS_PROJNAME                    100
#define IDR_BROWSERCAP                  101
#define IDS_ERROR_NOSVR					102
#define IDS_ERROR_SOURCE				103
#define IDS_ERROR_PROP_RO				104

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\controt\context.cpp ===
#include "stdafx.h"
#include "..\shared\src\context.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\browser\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__78FFB015_E0E1_11D0_8A81_00C0F00910F9__INCLUDED_)
#define AFX_STDAFX_H__78FFB015_E0E1_11D0_8A81_00C0F00910F9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


//#define _ATL_APARTMENT_THREADED

#pragma warning( disable : 4786 )
#include <atlbase.h>
#include <mtx.h>
#include <comdef.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CMonitor;
class CCapMap;
class CBrwCapModule : public CComModule
{
public:
                CBrwCapModule();

    // CComModule methods
    void        Init( _ATL_OBJMAP_ENTRY*, HINSTANCE );
    void        Term();
	LONG		Lock();
	LONG		Unlock();

    // CPgCntModule methods
    CMonitor*   Monitor();
    CCapMap*    CapMap();

private:
	CComAutoCriticalSection	m_cs;
    CMonitor*               m_pMonitor;
    CCapMap*                m_pCapMap;
};

extern CBrwCapModule _Module;

#include <atlcom.h>

//#include <list>
//#include <vector>
#include <algorithm>

using namespace std;

#include "myvector.h"
#include "strmap.h"


#include "MyDebug.h"
#include "MyString.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__78FFB015_E0E1_11D0_8A81_00C0F00910F9__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\controt\controt.cpp ===
// ContRot.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this 
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f ContRotps.mak in the project directory.

#include "stdafx.h"
#include <new>
#include "resource.h"
#include "initguid.h"
#include "ContRot.h"
#include "RotObj.h"
#include "debug.h"
#include "Monitor.h"
#include "lock.h"

#define IID_DEFINED
#include "ContRot_i.c"

CMonitor*   g_pMonitor = NULL;

CContRotModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_ContentRotator, CContentRotator)
END_OBJECT_MAP()

LONG
CContRotModule::Lock()
{
    _ASSERT( g_pMonitor != NULL );
    return CComModule::Lock();
}

LONG
CContRotModule::Unlock()
{
	LONG lc;
	CLock l(m_cs);

	if ( ( lc = CComModule::Unlock() ) == 0 )
	{
        // final unlock
        _ASSERT( g_pMonitor != NULL );
        g_pMonitor->StopAllMonitoring();
	}
	return lc;
}

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
        DEBUG_START;
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
        DEBUG_INIT();

        _ASSERT( g_pMonitor == NULL );
		try
		{
            g_pMonitor = new CMonitor();
		}
		catch ( std::bad_alloc& )
		{
			// nothing we can do about it here
		}
	}
	else if (dwReason == DLL_PROCESS_DETACH)
    {
        _ASSERT( g_pMonitor != NULL );
        delete g_pMonitor;
        g_pMonitor = NULL;

        DEBUG_TERM();
		_Module.Term();
        DEBUG_STOP;
    }
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\controt\mem.cpp ===
#include "stdafx.h"
#include "..\shared\src\mem.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\controt\monitor.cpp ===
#include "stdafx.h"
#include "..\shared\src\monitor.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\controt\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\controt\debug.cpp ===
#include "stdafx.h"

#include <stdio.h>
#include <stdarg.h>
#include "debug.h"


#define ACTIVE_SERVER_PAGES 1


#if DBG

// taken from <crtdbg.h> -- it's too much trouble to include this file
// (lots of errors due to their use of _DEBUG vs. DBG macro, multiple inclusions & dependencies & such)
//
#define _CRT_WARN           0
#define _CRT_ERROR          1
#define _CRT_ASSERT         2
#define _CRT_ERRCNT         3

void __cdecl
Trace(
    LPCTSTR ptszFormat,
    ...)
{
    TCHAR tszBuff[2048];
    va_list args;
    
    va_start(args, ptszFormat);
    _vstprintf(tszBuff, ptszFormat, args);
    va_end(args);

    OutputDebugString(tszBuff);
}



# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)


#  ifdef ACTIVE_SERVER_PAGES

// The default assertion mechanism set up by Visual C++ 4 will not
// work with Active Server Pages because it's running inside a service
// and there is no desktop to interact with.

// Note: for this to work properly, #define _WIN32_WINNT 0x400 before
// including <winuser.h> or MB_SERVICE_NOTIFICATION won't be #define'd.

int __cdecl
AspAssertHandler(
    int   nReportType,
    char* pszErrorText,
    int*  pnReturn)
{
    const char szInfo[] = " (Press ABORT to terminate IIS,"
                          " RETRY to debug this failure,"
                          " or IGNORE to continue.)";
    char* pszMessageTitle = NULL;
    
    // These flags enable message boxes to show up on the user's console
    switch (nReportType)
    {
    case _CRT_WARN:
        pszMessageTitle = "Warning";
        break;
    case _CRT_ERROR:
        pszMessageTitle = "Fatal Error";
        break;
    case _CRT_ASSERT:
        pszMessageTitle = "Assertion Failed";
        break;
    }   
    
    char* pszMessageText =
        static_cast<char*>(_alloca(strlen(pszErrorText) + strlen(szInfo) + 1));

    strcpy(pszMessageText, pszErrorText);
    strcat(pszMessageText, szInfo);
    
    const int n = MessageBoxA(NULL, pszMessageText, pszMessageTitle,
                              (MB_SERVICE_NOTIFICATION | MB_TOPMOST
                               | MB_ABORTRETRYIGNORE | MB_ICONEXCLAMATION));

    if (n == IDABORT)
    {
        exit(1);
    }
    else if (n == IDRETRY)
    {
        *pnReturn = 1;   // tell _CrtDbgReport to start the debugger
        return TRUE;     // tell _CrtDbgReport to run
    }
    
    *pnReturn = 0;       // nothing for _CrtDbgReport to do

    return FALSE;
}

#  endif // ACTIVE_SERVER_PAGES
# endif // _MSC_VER >= 1000



void
DebugInit()
{
# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef ACTIVE_SERVER_PAGES
    // If we end up in _CrtDbgReport, don't put up a message box
    _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_WARN,   _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_ERROR,  _CRTDBG_MODE_DEBUG);

    // Use AspAssertHandler to put up a message box instead
    _CrtSetReportHook(AspAssertHandler);
#  endif // ACTIVE_SERVER_PAGES

    // Enable debug heap allocations & check for memory leaks at program exit
    // The memory leak check will not be performed if inetinfo.exe is
    // run directly under a debugger, only if it is run as a service.
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF
                   | _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG));
# endif // _MSC_VER >= 1000
}



void
DebugTerm()
{
# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef ACTIVE_SERVER_PAGES
    // Turn off AspAssertHandler, so that we don't get numerous message boxes
    // if there are memory leaks on shutdown
    _CrtSetReportHook(NULL);
#  endif // ACTIVE_SERVER_PAGES
# endif // _MSC_VER >= 1000
}

#endif //DBG



BOOL
IsValidString(
    LPCTSTR ptsz,
    int nLength /* =-1 */)
{
    if (ptsz == NULL)
        return FALSE;

    return !IsBadStringPtr(ptsz, nLength);
}



BOOL
IsValidAddress(
    LPCVOID pv,
    UINT nBytes,
    BOOL fReadWrite /* =TRUE */)
{
    return (pv != NULL
            &&  !IsBadReadPtr(pv, nBytes)
            &&  (!fReadWrite  ||  !IsBadWritePtr((LPVOID) pv, nBytes)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\controt\mystring.cpp ===
#include "stdafx.h"
#include "..\shared\src\mystring.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\controt\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ContRot.rc
//
#define IDS_CONTENTROTATOR_DESC	1



// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\context.cpp ===
#include "stdafx.h"
#include "..\shared\src\context.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\finstrm.cpp ===
#include "stdafx.h"
#include "..\shared\src\FInStrm.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\controt\debug.h ===
/*
 * Some simple debugging macros that look and behave a lot like their
 * namesakes in MFC.  These macros should work in both C and C++ and
 * do something useful with almost any Win32 compiler.
 *
 * George V. Reilly  <georger@microcrafts.com>  <a-georgr@microsoft.com>
 */

#ifndef __DEBUG_H__
#define __DEBUG_H__

#if DBG

# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
   /* Use the new debugging tools in Visual C++ 4.x */
#  include <crtdbg.h>
   /* _ASSERTE will give a more meaningful message, but the string takes
    * space.  Use _ASSERT if this is an issue. */
#  define ASSERT(f) _ASSERTE(f)
# else
#  include <assert.h>
#  define ASSERT(f) assert(f)
# endif

# define VERIFY(f)               ASSERT(f)
# define DEBUG_ONLY(f)           (f)
# define TRACE                   Trace
# define TRACE0(psz)             Trace(_T("%s"), _T(psz))
# define TRACE1(psz, p1)         Trace(_T(psz), p1)
# define TRACE2(psz, p1, p2)     Trace(_T(psz), p1, p2)
# define TRACE3(psz, p1, p2, p3) Trace(_T(psz), p1, p2, p3)
# define DEBUG_INIT()            DebugInit()
# define DEBUG_TERM()            DebugTerm()

#else /* !DBG */

  /* These macros should all compile away to nothing */
# define ASSERT(f)               ((void)0)
# define VERIFY(f)               ((void)(f))
# define DEBUG_ONLY(f)           ((void)0)
# define TRACE                   NOP_FUNCTION
# define TRACE0(psz)
# define TRACE1(psz, p1)
# define TRACE2(psz, p1, p2)
# define TRACE3(psz, p1, p2, p3)
# define DEBUG_INIT()            ((void)0)
# define DEBUG_TERM()            ((void)0)

#endif /* !DBG */


#define ASSERT_POINTER(p, type) \
    ASSERT(((p) != NULL)  &&  IsValidAddress((p), sizeof(type), FALSE))

#define ASSERT_NULL_OR_POINTER(p, type) \
    ASSERT(((p) == NULL)  ||  IsValidAddress((p), sizeof(type), FALSE))


/* Declarations for non-Windows apps */

#ifndef _WINDEF_
typedef void*           LPVOID;
typedef const void*     LPCVOID;
typedef unsigned int    UINT;
typedef int             BOOL;
typedef const char*     LPCTSTR;
#endif /* _WINDEF_ */

#ifndef TRUE
# define FALSE  0
# define TRUE   1
#endif


#ifdef __cplusplus
extern "C" {

/* Low-level sanity checks for memory blocks */
BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite = TRUE);
BOOL IsValidString(LPCTSTR ptsz, int nLength = -1);

#else /* !__cplusplus */

/* Low-level sanity checks for memory blocks */
BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite);
BOOL IsValidString(LPCTSTR ptsz, int nLength);

#endif /* !__cplusplus */

/* in debug version, writes trace messages to debug stream */
void __cdecl
Trace(
    LPCTSTR pszFormat,
    ...);

/* should be called from main(), WinMain(), or DllMain() */
void
DebugInit();

void
DebugTerm();

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* __DEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\instrm.cpp ===
#include "stdafx.h"
#include "..\shared\src\InStrm.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\mem.cpp ===
#include "stdafx.h"
#include "..\shared\src\mem.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\controt\rotobj.cpp ===
// RotObj.cpp : Implementation of CContentRotator class, which does all the
// interesting work

// George V. Reilly  a-georgr@microsoft.com georger@microcrafts.com  Nov/Dec 96

// Shortcomings: this works fine for small-to-medium sized tip files
// (under 2000 lines), but it's not very efficient for large ones.


#include "stdafx.h"
#include <new>
#include "ContRot.h"
#include "RotObj.h"

#include "debug.h"
#include <time.h>
#include "Monitor.h"

#define MAX_WEIGHT      10000
#define INVALID_WEIGHT  0xFFFFFFFF


extern CMonitor* g_pMonitor;

//
// forward declaration of some utility functions
//

LPTSTR  TcsDup(LPCTSTR ptsz);
LPTSTR  GetLine(LPTSTR& rptsz);
BOOL    IsBlankString(LPCTSTR ptsz);
UINT    GetWeight(LPTSTR& rptsz);
LPTSTR  GetTipText(LPTSTR& rptsz);
HRESULT ReportError(DWORD dwErr);
HRESULT ReportError(HRESULT hr);


#if DBG
 #define ASSERT_VALID(pObj)  \
    do {ASSERT(pObj != NULL); pObj->AssertValid();} while (0)
#else
 #define ASSERT_VALID(pObj)  ((void)0)
#endif


class CTipNotify : public CMonitorNotify
{
public:
                    CTipNotify();
    virtual void    Notify();
            bool    IsNotified();
private:
    long            m_isNotified;
};

DECLARE_REFPTR( CTipNotify,CMonitorNotify )

CTipNotify::CTipNotify()
    :   m_isNotified(0)
{
}

void
CTipNotify::Notify()
{
    ::InterlockedExchange( &m_isNotified, 1 );
}

bool
CTipNotify::IsNotified()
{
    return ( ::InterlockedExchange( &m_isNotified, 0 ) ? true : false );
}


//
// "Tip", as in tip of the day
//

class CTip
{
public:
    CTip(
        LPCTSTR ptszTip,
        UINT    uWeight)
        : m_ptsz(ptszTip),
          m_uWeight(uWeight),
          m_cServingsLeft(uWeight),
          m_pPrev(NULL),
          m_pNext(NULL)
    {
        ASSERT_VALID(this);
    }
    
    ~CTip()
    {
        ASSERT_VALID(this);
        if (m_pPrev != NULL)
            m_pPrev->m_pNext = NULL;
        if (m_pNext != NULL)
            m_pNext->m_pPrev = NULL;
    }

#if DBG
    void
    AssertValid() const;
#endif

    LPCTSTR m_ptsz;         // data string
    UINT    m_uWeight;      // weight of this tip, 1 <= m_uWeight <= MAX_WEIGHT
    UINT    m_cServingsLeft;// how many servings left: no more than m_uWeight
    CTip*   m_pPrev;        // Previous in tips list
    CTip*   m_pNext;        // Next in tips list
};


//
// A list of CTips, which are read from a datafile
//

class CTipList
{
public:
    CTipList()
        : m_ptszFilename(NULL),
          m_ptszData(NULL),
          m_cTips(0),
          m_uTotalWeight(0),
          m_pTipsListHead(NULL),
          m_pTipsListTail(NULL),
          m_fUTF8(false)
    {
        m_pNotify = new CTipNotify;
        ASSERT_VALID(this);
    }

    ~CTipList()
    {
        ASSERT_VALID(this);

        // check for both a valid Filename ptr as well as a valid Monitor ptr.
        // If the ContRotModule::Unlock is called prior to this destructor,then
        // the Monitor object has already been cleaned up and deleted.

        DeleteTips();
        ASSERT_VALID(this);
    }

    HRESULT
    ReadDataFile(
        LPCTSTR ptszFilename);

    HRESULT
    SameAsCachedFile(
        LPCTSTR ptszFilename,
        BOOL&   rfIsSame);

    UINT
    Rand() const;

    void
    AppendTip(
        CTip* pTip);

    void
    RemoveTip(
        CTip* pTip);

    HRESULT
    DeleteTips();

#if DBG
    void
    AssertValid() const;
#endif

    LPTSTR          m_ptszFilename;     // Name of tips file
    LPTSTR          m_ptszData;         // Buffer containing contents of file
    UINT            m_cTips;            // # tips
    UINT            m_uTotalWeight;     // sum of all weights
    CTip*           m_pTipsListHead;    // Head of list of tips
    CTip*           m_pTipsListTail;    // Tail of list of tips
    CTipNotifyPtr   m_pNotify;
    bool            m_fUTF8;
};



//
// A class that allows you to enter a critical section and automatically
// leave when the object of this class goes out of scope.  Also provides
// the means to leave and re-enter as needed while protecting against
// entering or leaving out of sync.
//

class CAutoLeaveCritSec
{
public:
    CAutoLeaveCritSec(
        CRITICAL_SECTION* pCS)
        : m_pCS(pCS), m_fInCritSec(FALSE)
    {Enter();}
    
    ~CAutoLeaveCritSec()
    {Leave();}
    
    // Use this function to re-enter the critical section.
    void Enter()
    {if (!m_fInCritSec) {EnterCriticalSection(m_pCS); m_fInCritSec = TRUE;}}

    // Use this function to leave the critical section before going out
    // of scope.
    void Leave()
    {if (m_fInCritSec)  {LeaveCriticalSection(m_pCS); m_fInCritSec = FALSE;}}

protected:    
    CRITICAL_SECTION*   m_pCS;
    BOOL                m_fInCritSec;
};



//
// Wrapper class for handles to files opened for reading
//

class CHFile
{
public:
    CHFile(LPCTSTR ptszFilename)
    {
        m_hFile = ::CreateFile(ptszFilename, GENERIC_READ, FILE_SHARE_READ,
                               NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                               NULL);
    }

    ~CHFile()
    {
        if (m_hFile != INVALID_HANDLE_VALUE)
            ::CloseHandle(m_hFile);
    }

    operator HANDLE() const
    {return m_hFile;}

    BOOL
    operator!() const
    {return (m_hFile == INVALID_HANDLE_VALUE);}

private:
    // private, unimplemented default ctor, copy ctor, and op= to prevent
    // compiler synthesizing them
    CHFile();
    CHFile(const CHFile&);
    CHFile& operator=(const CHFile&);

    HANDLE m_hFile;
};



/////////////////////////////////////////////////////////////////////////////
// CContentRotator Public Methods

//
// ctor
//

CContentRotator::CContentRotator()
    : m_ptl(NULL),
      m_ptlUsed(NULL)
{
    TRACE0("CContentRotator::CContentRotator\n");

    InitializeCriticalSection(&m_CS);
#if (_WIN32_WINNT >= 0x0403)
    SetCriticalSectionSpinCount(&m_CS, 1000);
#endif

    // Seed the random-number generator with the current time so that
    // the numbers will be different each time that we run
    ::srand((unsigned) time(NULL));

    ATLTRY(m_ptl = new CTipList);
    ATLTRY(m_ptlUsed = new CTipList);
}



//
// dtor
//

CContentRotator::~CContentRotator()
{
    TRACE0("CContentRotator::~CContentRotator\n");

    DeleteCriticalSection(&m_CS);
    delete m_ptl;
    delete m_ptlUsed;
}



//
// ATL Wizard generates this
//

STDMETHODIMP CContentRotator::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_IContentRotator,
    };

    for (int i=0; i<sizeof(arr)/sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}



//
// Read in the tips in bstrDataFile (a logical name), and return a random
// tip in pbstrRetVal
//

STDMETHODIMP
CContentRotator::ChooseContent(
    BSTR  bstrDataFile,
    BSTR* pbstrRetVal)
{
    HRESULT  hr = E_FAIL;

    try
    {
    //    TRACE1("ChooseContent(%ls)\n", bstrDataFile);

        if (bstrDataFile == NULL  ||  pbstrRetVal == NULL)
            return ::ReportError(E_POINTER);
        else
            *pbstrRetVal = NULL;

        CContext cxt;
        hr = cxt.Init( CContext::get_Server );
        if ( !FAILED(hr) )
        {
            // Do we have valid CTipLists?
            if ((m_ptl != NULL) && (m_ptlUsed != NULL))
            {
                // Map bstrDataFile (a logical name such as /controt/tips.txt) to
                // a physical filesystem name such as d:\inetpub\controt\tips.txt.
                CComBSTR bstrPhysicalDataFile;
                hr = cxt.Server()->MapPath(bstrDataFile, &bstrPhysicalDataFile);

                if (SUCCEEDED(hr))
                    hr = _ChooseContent(bstrPhysicalDataFile, pbstrRetVal);
            }
            else
            {
                hr = ::ReportError(E_OUTOFMEMORY);
            }
        }
        else
        {
            hr = ::ReportError(E_NOINTERFACE);
        }
    }
    catch ( std::bad_alloc& )
    {
        hr = ::ReportError(E_OUTOFMEMORY);
    }
    catch ( ... )
    {
        hr = E_FAIL;
    }
    return hr;
}



//
// Writes all of the entries in the tip file, each separated by an <hr>, back
// to the user's browser.  This can be used to proofread all of the entries.
//

STDMETHODIMP
CContentRotator::GetAllContent(
    BSTR bstrDataFile)
{
    HRESULT hr = E_FAIL;
    try
    {
        if (bstrDataFile == NULL)
            return ::ReportError(E_POINTER);

        CContext cxt;
        hr = cxt.Init( CContext::get_Server | CContext::get_Response );
        // Do we have valid Server and Response objects?
        if ( !FAILED( hr ) )
        {
            // Do we have valid CTipLists?
            if ( (m_ptl != NULL)  &&  (m_ptlUsed != NULL))
            {
                // Map bstrDataFile (a logical name such as /IISSamples/tips.txt) to
                // a physical filesystem name such as d:\inetpub\IISSamples\tips.txt.
                CComBSTR bstrPhysicalDataFile;
                hr = cxt.Server()->MapPath(bstrDataFile, &bstrPhysicalDataFile);

                // See note below about critical sections
                CAutoLeaveCritSec alcs(&m_CS);

                if (SUCCEEDED(hr))
                    hr = _ReadDataFile(bstrPhysicalDataFile, TRUE);

                if (SUCCEEDED(hr))
                {
                    const CComVariant cvHR(OLESTR("\n<hr>\n\n"));
                    BOOL  bFirstTip = TRUE;

                    for (CTip* pTip = m_ptl->m_pTipsListHead;
                         pTip != NULL;
                         pTip = pTip->m_pNext)
                    {
                        // Write the leading HR only on the first pass

                        if (bFirstTip == TRUE) {
                            cxt.Response()->Write(cvHR);
                            bFirstTip = FALSE;
                        }

                        // Write back to the user's browser, one tip at a time.
                        // This is more efficient than concatenating all of the
                        // tips into a potentially huge string and returning that.

                        CMBCSToWChar    convStr;
                        BSTR            pbstrTip;

                        // need to convert the string to Wide based on the UTF8 flag

                        if (hr = convStr.Init(pTip->m_ptsz, m_ptl->m_fUTF8 ? 65001 : CP_ACP)) {
                            break;
                        }

                        // make a proper BSTR out of the wide version

                        if (!(pbstrTip = ::SysAllocString(convStr.GetString()))) {
                            hr = ::ReportError( E_OUTOFMEMORY );
                            break;
                        }

                        cxt.Response()->Write(CComVariant(pbstrTip)); 
                        cxt.Response()->Write(cvHR);

                        ::SysFreeString(pbstrTip);
                    }
                }
            }
            else
            {
                hr = ::ReportError(E_OUTOFMEMORY);
            }

        }
        else
        {
            hr = ::ReportError(E_NOINTERFACE);
        }
    }
    catch ( std::bad_alloc& )
    {
        hr = ::ReportError( E_OUTOFMEMORY );
    }
    catch ( ... )
    {
        hr = E_FAIL;
    }
    return hr;
}



/////////////////////////////////////////////////////////////////////////////
// CContentRotator Private Methods

//
// Do the work of ChooseContent, but with a real filename, not with a
// virtual filename
//

HRESULT
CContentRotator::_ChooseContent(
    BSTR  bstrPhysicalDataFile,
    BSTR* pbstrRetVal)
{
    ASSERT(bstrPhysicalDataFile != NULL  &&  pbstrRetVal != NULL);
    
    // The critical section ensures that the remaining code in this
    // function is executing on only one thread at a time.  This ensures
    // that the cached contents of the tip list are consistent for the
    // duration of a call.

    // Actually, the critical section is not needed at all.  Because we
    // need to call Server.MapPath to map the virtual path of
    // bstrDataFile to a physical filesystem path, the OnStartPage method
    // must be called, as this is the only way that we can get access to
    // the ScriptingContext object and thereby the Server object.
    // However, the OnStartPage method is only called for page-level
    // objects (object is created and destroyed in a single page) and for
    // session-level objects.  Page-level objects don't have to worry
    // about protecting their data from multiple access (unless it's
    // global data shared between several objects) and neither do
    // session-level objects.  Only application-level objects need worry
    // about protecting their private data, but application-level objects
    // don't give us any way to map the virtual path.

    // The Content Rotator might be more useful it it were an
    // application-level object.  We would get better distribution of the
    // tips (see below) and do a lot less rereading of the data file.  The
    // trivial changes necessary to accept a filesystem path, such as
    // "D:\ContRot\tips.txt", instead of a virtual path, such as
    // "/IISSamples/tips.txt",are left as an exercise for the reader.

    CAutoLeaveCritSec alcs(&m_CS);

    HRESULT hr = _ReadDataFile(bstrPhysicalDataFile, FALSE);

    if (SUCCEEDED(hr))
    {
        const UINT uRand = m_ptl->Rand();
        UINT       uCumulativeWeight = 0;
        CTip*      pTip = m_ptl->m_pTipsListHead;
        LPCTSTR    ptszTip = NULL;
        
        for ( ; ; )
        {
            ASSERT_VALID(pTip);
            
            ptszTip = pTip->m_ptsz;
            uCumulativeWeight += pTip->m_uWeight;

            if (uCumulativeWeight <= uRand)
                pTip = pTip->m_pNext;
            else
            {
                // Found the tip.  Now we go through a bit of work to make
                // sure that each tip is served up with the correct
                // probability.  If the tip has already been served up as
                // many times as it's allowed (i.e., m_uWeight times), then
                // it's moved to the Used List.  Otherwise, it's (probably)
                // moved to the end of the Tips List, to reduce the
                // likelihood of it turning up too soon again and to
                // randomize the order of the tips in the list.  When all
                // tips have been moved to the Used List, we start afresh.

                // If the object is created, used, and destroyed in a
                // single page (i.e., it's not a session-level object),
                // then none of this does us any good.  The list is in
                // exactly the same order as it is in the data file and
                // we just have to hope that Rand() does give us
                // well-distributed random numbers.

                // If you expect a single user to see more than one tip,
                // you should use a session-level object, to benefit from
                // the better distribution of tips.  This would be the case
                // if you're serving up tips from the same file on multiple
                // pages, or if you have a page that automatically
                // refreshes itself, such as the one included in the
                // Samples directory.

                if (--pTip->m_cServingsLeft > 0)
                {
                    // Move it to the end of the list some of the time.
                    // If we move it there all of the time, then a heavily
                    // weighted tip is more likely to turn up a lot
                    // as the main list nears exhaustion.
                    if (rand() % 3 == 0)
                    {
                        // TRACE1("Move to End\n%s\n", ptszTip);
                        m_ptl->RemoveTip(pTip);
                        m_ptl->AppendTip(pTip);
                    }
                }
                else
                {
                    // TRACE1("Move to Used\n%s\n", ptszTip);
                    pTip->m_cServingsLeft = pTip->m_uWeight;  // reset
                    m_ptl->RemoveTip(pTip);
                    m_ptlUsed->AppendTip(pTip);

                    if (m_ptl->m_cTips == 0)
                    {
                        TRACE0("List exhausted; swapping\n");
                        
                        CTipList* const ptlTemp = m_ptl;
                        m_ptl = m_ptlUsed;
                        m_ptlUsed = ptlTemp;
                    }
                }

                break;
            }
        }

        //  TRACE2("total weight = %u, rand = %u\n",
        //         m_ptl->m_uTotalWeight, uRand);
        //  TRACE1("tip = `%s'\n", ptszTip);
        
        CMBCSToWChar    convStr;

        if (hr = convStr.Init(ptszTip, m_ptl->m_fUTF8 ? 65001 : CP_ACP));

        else {
            *pbstrRetVal = ::SysAllocString(convStr.GetString());
        }
    }

    return hr;
}




HRESULT
CContentRotator::_ReadDataFile(
    BSTR bstrPhysicalDataFile,
    BOOL fForceReread)
{
    USES_CONVERSION;    // needed for OLE2T
    LPCTSTR ptszFilename = OLE2T(bstrPhysicalDataFile);
    HRESULT hr = S_OK;

    if (ptszFilename == NULL) {
        hr = E_OUTOFMEMORY;
    }

    // Have we cached this tips file already?
    if (!fForceReread)
    {
        BOOL    fIsSame;
        HRESULT hr = m_ptl->SameAsCachedFile(ptszFilename, fIsSame);

        TRACE(_T("%same file\n"), fIsSame ? _T("S") : _T("Not s"));

        if (FAILED(hr)  ||  fIsSame)
            return hr;
    }
    
    // destroy any old tips
    m_ptl->DeleteTips();
    m_ptlUsed->DeleteTips();

    hr = m_ptl->ReadDataFile(ptszFilename);

    if (FAILED(hr)) {
        m_ptl->DeleteTips();
        m_ptlUsed->DeleteTips();
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTipList Public Methods

//
// Read a collection of tips from ptszDataFile
//
// The file format is zero or more copies of the following:
//  One or more lines starting with "%%"
//  Each %% line contains zero or more directives:
//      #<weight>   (positive integer, 1 <= weight <= MAX_WEIGHT)
//      //<comment> (a comment that runs to the end of the line)
//  The tip text follows, spread out over several lines
//

HRESULT
CTipList::ReadDataFile(
    LPCTSTR ptszFilename)
{
    TRACE1("ReadDataFile(%s)\n", ptszFilename);

    UINT    weightSum = 0;

    if ( m_ptszFilename != NULL )
    {
        g_pMonitor->StopMonitoringFile( m_ptszFilename );
        delete [] m_ptszFilename;
    }

    m_ptszFilename = TcsDup(ptszFilename);

    if (m_ptszFilename == NULL)
        return ::ReportError(E_OUTOFMEMORY);

    // Open the file
    CHFile hFile(m_ptszFilename);

    if (!hFile)
        return ::ReportError(::GetLastError());

    // Get the last-write-time and the filesize
    BY_HANDLE_FILE_INFORMATION bhfi;

    if (!::GetFileInformationByHandle(hFile, &bhfi))
        return ::ReportError(::GetLastError());

    // If it's more than 4GB, let's not even think about it!
    if (bhfi.nFileSizeHigh != 0)
        return ::ReportError(E_OUTOFMEMORY);

    // Calculate the number of TCHARs in the file
    const DWORD cbFile = bhfi.nFileSizeLow;
    const DWORD ctc    = cbFile / sizeof(TCHAR);

    // Allocate a buffer for the file's contents
    m_ptszData = NULL;
    ATLTRY(m_ptszData = new TCHAR [ctc + 2]);
    if (m_ptszData == NULL)
        return ::ReportError(E_OUTOFMEMORY);

    // Read the file into the memory buffer.  Let's be paranoid and
    // not assume that ReadFile gives us the whole file in one chunk.
    DWORD cbSeen = 0;

    do
    {
        DWORD cbToRead = cbFile - cbSeen;
        DWORD cbRead   = 0;

        if (!::ReadFile(hFile, ((LPBYTE) m_ptszData) + cbSeen,
                        cbToRead, &cbRead, NULL))
            return ::ReportError(::GetLastError());

        cbSeen += cbRead;
    } while (cbSeen < cbFile);

    m_ptszData[ctc] = _T('\0');   // Nul-terminate the string

    LPTSTR ptsz = m_ptszData;

#ifdef _UNICODE

#error "This file should NOT be compiled with _UNICODE defined!!!

    // Check for byte-order mark
    if (*ptsz == 0xFFFE)
    {
        // Byte-reversed Unicode file.  Swap the hi- and lo-bytes in each wchar
        for ( ;  ptsz < m_ptszData + ctc;  ++ptsz)
        {
            BYTE* pb = (BYTE*) ptsz;
            const BYTE bHi = pb[1];
            pb[1] = pb[0];
            pb[0] = bHi;
        }
        ptsz = m_ptszData;
    }

    if (*ptsz == 0xFEFF)
        ++ptsz; // skip the byte-order mark
#endif

    // check for the UTF-8 BOM
    if ((ctc > 3) 
        && (ptsz[0] == (TCHAR)0xef) 
        && (ptsz[1] == (TCHAR)0xbb) 
        && (ptsz[2] == (TCHAR)0xbf)) {

        // note its presence and advance the file pointer past it.

        m_fUTF8 = true;
        ptsz += 3;
    }

    // Finally, parse the file
    while (ptsz < m_ptszData + ctc)
    {
        UINT   uWeight     = GetWeight(ptsz);

        // a value of INVALID_WEIGHT for weight indicates that no weight was found,
        // i.e. an invalid data file, or the value was not valid.

        if (uWeight == INVALID_WEIGHT) {
            return ::ReportError((DWORD)ERROR_INVALID_DATA);
        }

        weightSum += uWeight;

        if (weightSum > MAX_WEIGHT) {
            return ::ReportError((DWORD)ERROR_INVALID_DATA);
        }

        LPTSTR ptszTipText = GetTipText(ptsz);

        if (!IsBlankString(ptszTipText)  &&  uWeight > 0)
        {
            CTip* pTip = NULL;
            ATLTRY(pTip = new CTip(ptszTipText, uWeight));
            if (pTip == NULL)
                return ::ReportError(E_OUTOFMEMORY);
            AppendTip(pTip);
        }
        else if (ptsz < m_ptszData + ctc)
        {
            // not at a terminating "%%" line at the end of the data file
            TRACE2("bad tip: tip = `%s', weight = %u\n", ptszTipText, uWeight);
        }
    }

    g_pMonitor->MonitorFile( m_ptszFilename, m_pNotify );

    if (m_uTotalWeight == 0  ||  m_cTips == 0)
        return ::ReportError((DWORD)ERROR_INVALID_DATA);

    return S_OK;
}



//
// Is ptszFilename the same file as m_ptszFilename in both its name
// and timestamp?
//

HRESULT
CTipList::SameAsCachedFile(
    LPCTSTR ptszFilename,
    BOOL&   rfIsSame)
{
    rfIsSame = FALSE;
    
    // Have we cached a file at all?
    if (m_ptszFilename == NULL)
        return S_OK;
    
    // Are the names the same?
    if (_tcsicmp(ptszFilename, m_ptszFilename) != 0)
        return S_OK;

#if 1
//    FILETIME ftLastWriteTime;
//    CHFile   hFile(ptszFilename);
//
//    if (!hFile)
//        return ::ReportError(::GetLastError());
//
//    if (!::GetFileTime(hFile, NULL, NULL, &ftLastWriteTime))
//        return ::ReportError(::GetLastError());
//
//    rfIsSame = (::CompareFileTime(&ftLastWriteTime, &m_ftLastWriteTime) == 0);
    if ( !m_pNotify->IsNotified() )
    {
        rfIsSame = TRUE;
    }
#else
    // The following is more efficient, but it won't work on Win95 with
    // Personal Web Server because GetFileAttributesEx is new to NT 4.0.

    WIN32_FILE_ATTRIBUTE_DATA wfad;

    if (!::GetFileAttributesEx(ptszFilename, GetFileExInfoStandard,
                              (LPVOID) &wfad))
        return ::ReportError(::GetLastError());

    rfIsSame = (::CompareFileTime(&wfad.ftLastWriteTime,
                                  &m_ftLastWriteTime) == 0);
#endif

    return S_OK;
}



//
// Generate a random number in the range 0..m_uTotalWeight-1
//

UINT
CTipList::Rand() const
{
    UINT u;
    
    ASSERT(m_uTotalWeight > 0);
    
    if (m_uTotalWeight == 1)
        return 0;
    else if (m_uTotalWeight <= RAND_MAX + 1)
        u = rand() % m_uTotalWeight;
    else
    {
        // RAND_MAX is only 32,767.  This gives us a bigger range
        // of random numbers if the weights are large.
        u = ((rand() << 15) | rand()) % m_uTotalWeight;
    }
    
    ASSERT(0 <= u  &&  u < m_uTotalWeight);
    
    return u;
}



//
// Append a tip to the list
//

void
CTipList::AppendTip(
    CTip* pTip)
{
    ASSERT_VALID(this);

    pTip->m_pPrev = pTip->m_pNext = NULL;
    ASSERT_VALID(pTip);

    pTip->m_pPrev = m_pTipsListTail;

    if (m_pTipsListTail == NULL)
        m_pTipsListHead = pTip;
    else
        m_pTipsListTail->m_pNext = pTip;

    m_pTipsListTail = pTip;
    ++m_cTips;
    m_uTotalWeight += pTip->m_uWeight;

    ASSERT_VALID(this);
}



//
// Remove a tip from somewhere in the list
// 

void
CTipList::RemoveTip(
    CTip* pTip)
{
    ASSERT_VALID(this);
    ASSERT_VALID(pTip);

    ASSERT(m_cTips > 0);

    if (m_cTips == 1)
    {
        ASSERT(m_pTipsListHead == pTip  &&  pTip == m_pTipsListTail);
        m_pTipsListHead = m_pTipsListTail = NULL;
    }
    else if (pTip == m_pTipsListHead)
    {
        ASSERT(m_pTipsListHead->m_pNext != NULL);
        m_pTipsListHead = m_pTipsListHead->m_pNext;
        m_pTipsListHead->m_pPrev = NULL;
    }
    else if (pTip == m_pTipsListTail)
    {
        ASSERT(m_pTipsListTail->m_pPrev != NULL);
        m_pTipsListTail = m_pTipsListTail->m_pPrev;
        m_pTipsListTail->m_pNext = NULL;
    }
    else
    {
        ASSERT(m_cTips >= 3);
        pTip->m_pPrev->m_pNext = pTip->m_pNext;
        pTip->m_pNext->m_pPrev = pTip->m_pPrev;
    }

    pTip->m_pPrev = pTip->m_pNext = NULL;
    --m_cTips;
    m_uTotalWeight -= pTip->m_uWeight;

    ASSERT_VALID(this);
}



//
// Destroy the list of tips and reset all member variables
//

HRESULT
CTipList::DeleteTips()
{
    ASSERT_VALID(this);

    CTip* pTip = m_pTipsListHead;
    
    for (UINT i = 0;  i < m_cTips;  ++i)
    {
        pTip = pTip->m_pNext;
        delete m_pTipsListHead;
        m_pTipsListHead = pTip;
    }

    ASSERT(pTip == NULL  &&  m_pTipsListHead == NULL);

    // check for both a valid Filename ptr as well as a valid Monitor ptr.
    // If the ContRotModule::Unlock is called prior to this destructor,then
    // the Monitor object has already been cleaned up and deleted.

    if ( (m_ptszFilename != NULL) && (g_pMonitor != NULL) )
    {
        g_pMonitor->StopMonitoringFile( m_ptszFilename );
    }
    delete [] m_ptszFilename;
    delete [] m_ptszData;

    m_ptszFilename = m_ptszData = NULL;
//    m_ftLastWriteTime.dwLowDateTime = m_ftLastWriteTime.dwHighDateTime = 0;
    m_cTips = m_uTotalWeight = 0;
    m_pTipsListHead = m_pTipsListTail = NULL;

    ASSERT_VALID(this);

    return S_OK;
}



#if DBG

// Paranoia: check that Tips and TipLists are internally consistent.
// Very useful in catching bugs.

void
CTip::AssertValid() const
{
    ASSERT(m_ptsz != NULL  &&  m_uWeight > 0);
    ASSERT(0 < m_cServingsLeft  &&  m_cServingsLeft <= m_uWeight);
    ASSERT(m_pPrev == NULL  ||  m_pPrev->m_pNext == this);
    ASSERT(m_pNext == NULL  ||  m_pNext->m_pPrev == this);
}



void
CTipList::AssertValid() const
{
    if (m_cTips == 0)
    {
        ASSERT(m_pTipsListHead == NULL  &&  m_pTipsListTail == NULL);
        ASSERT(m_uTotalWeight == 0);
    }
    else
    {
        ASSERT(m_pTipsListHead != NULL  &&  m_pTipsListTail != NULL);
        ASSERT(m_pTipsListHead->m_pPrev == NULL);
        ASSERT(m_pTipsListTail->m_pNext == NULL);
        ASSERT(m_uTotalWeight > 0);

        if (m_cTips == 1)
            ASSERT(m_pTipsListHead == m_pTipsListTail);
        else
            ASSERT(m_pTipsListHead != m_pTipsListTail);
    }

    UINT  uWeight = 0;
    CTip* pTip = m_pTipsListHead;
    UINT  i;
    
    for (i = 0;  i < m_cTips;  ++i)
    {
        ASSERT_VALID(pTip);
        uWeight += pTip->m_uWeight;

        if (i < m_cTips - 1)
            pTip = pTip->m_pNext;
    }

    ASSERT(uWeight == m_uTotalWeight);
    ASSERT(pTip == m_pTipsListTail);
}

#endif

/////////////////////////////////////////////////////////////////////////////
// Utility functions

//
// Make a copy of a TSTR that can be deleted with operator delete[]
//

static LPTSTR
TcsDup(
    LPCTSTR ptsz)
{
    LPTSTR ptszNew = NULL;
    ATLTRY(ptszNew = new TCHAR [_tcslen(ptsz) + 1]);
    if (ptszNew != NULL)
        _tcscpy(ptszNew, ptsz);
    return ptszNew;
}



//
// reads a \n-terminated string from rptsz and modifies rptsz to
// point after the end of that string
//

static LPTSTR
GetLine(
    LPTSTR& rptsz)
{
    LPTSTR ptszOrig = rptsz;
    LPTSTR ptszEol = _tcspbrk(rptsz, _T("\n"));

    if (ptszEol != NULL)
    {
        // is it "\r\n"?
        if (ptszEol > ptszOrig  &&  ptszEol[-1] == _T('\r'))
            ptszEol[-1] = _T('\0');
        else
            ptszEol[0] = _T('\0');

        rptsz = ptszEol + 1;
    }   
    else
    {
        // no newline, so point past the end of the string
        rptsz += _tcslen(rptsz);
    }

    // TRACE1("GetLine: `%s'\n", ptszOrig);
    return ptszOrig;
}



//
// Is the string blank?
//

static BOOL
IsBlankString(
    LPCTSTR ptsz)
{
    if (ptsz == NULL)
        return TRUE;

    while (*ptsz != _T('\0'))
        if (!_istspace(*ptsz))
            return FALSE;
        else
            ptsz++;

    return TRUE;
}



//
// Read a weight line from rptsz and update rptsz to point after the
// end of any %% lines.
//

static UINT
GetWeight(
    LPTSTR& rptsz)
{
    UINT u = INVALID_WEIGHT; // default to invalid weight
    
    while (*rptsz == _T('%'))
    {
        LPTSTR ptsz = GetLine(rptsz);

        if (ptsz[1] == _T('%'))
        {
            u = 1;          // now that the format is correct, default to 1

            ptsz +=2;   // Skip "%%"

            while (*ptsz != _T('\0'))
            {
                while (_istspace(*ptsz))
                    ptsz++;

                if (*ptsz == _T('/')  &&  ptsz[1] == _T('/'))
                {
                    // TRACE1("// `%s'\n", ptsz+2);
                    break;  // a comment: ignore the rest of the line
                }
                else if (*ptsz == _T('#'))
                {
                    ptsz++;

                    if (_T('0') <= *ptsz  &&  *ptsz <= _T('9'))
                    {
                        LPTSTR ptsz2;
                        u = _tcstoul(ptsz, &ptsz2, 10);
                        ptsz = ptsz2;
                        // TRACE1("#%u\n", u);

                        if (u > MAX_WEIGHT)
                            u = MAX_WEIGHT; // clamp
                    }
                    else    // ignore word
                    {
                        while (*ptsz != _T('\0')  &&  !_istspace(*ptsz))
                            ptsz++;
                    }
                }
                else    // ignore word
                {
                    while (*ptsz != _T('\0')  &&  !_istspace(*ptsz))
                        ptsz++;
                }
            }
        }
    }

    return u;
}



//
// Read the multiline tip text.  Updates rptsz to point past the end of it.
//

static LPTSTR
GetTipText(
    LPTSTR& rptsz)
{
    LPTSTR ptszOrig = rptsz;
    LPTSTR ptszEol = _tcsstr(rptsz, _T("\n%%"));

    if (ptszEol != NULL)
    {
        // is it "\r\n"?
        if (ptszEol > rptsz  &&  ptszEol[-1] == _T('\r'))
            ptszEol[-1] = _T('\0');
        else
            ptszEol[0] = _T('\0');

        rptsz = ptszEol + 1;
    }   
    else
    {
        // no "\n%%", so point past the end of the string
        rptsz += _tcslen(rptsz);
    }

    // TRACE1("GetTipText: `%s'\n", ptszOrig);
    return ptszOrig;
}



//
// Set the Error Info.  It's up to the calling application to
// decide what to do with it.  By default, Denali/VBScript will
// print the error number (and message, if there is one) and
// abort the page.
//

static HRESULT
ReportError(
    HRESULT hr,
    DWORD   dwErr)
{
    HLOCAL pMsgBuf = NULL;

    // If there's a message associated with this error, report that
    if (::FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL, dwErr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &pMsgBuf, 0, NULL)
        > 0)
    {
        AtlReportError(CLSID_ContentRotator, (LPCTSTR) pMsgBuf,
                       IID_IContentRotator, hr);
    }

    // TODO: add some error messages to the string resources and
    // return those, if FormatMessage doesn't return anything (not
    // all system errors have associated error messages).
    
    // Free the buffer, which was allocated by FormatMessage
    if (pMsgBuf != NULL)
        ::LocalFree(pMsgBuf);

    return hr;
}



//
// Report a Win32 error code
//

static HRESULT
ReportError(
    DWORD dwErr)
{
    return ::ReportError(HRESULT_FROM_WIN32(dwErr), dwErr);
}



//
// Report an HRESULT error
//

static HRESULT
ReportError(
    HRESULT hr)
{
    return ::ReportError(hr, (DWORD) hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\controt\rotobj.h ===
// RotObj.h : Declaration of the CContentRotator


#include "resource.h"       // main symbols
#include <asptlb.h>
#include "context.h"

class CTipList;  // forward declaration

/////////////////////////////////////////////////////////////////////////////
// ContRot

class CContentRotator : 
    public CComDualImpl<IContentRotator, &IID_IContentRotator, &LIBID_ContentRotator>,
    public ISupportErrorInfo,
    public CComObjectRoot,
    public CComCoClass<CContentRotator,&CLSID_ContentRotator>
{
public:
    CContentRotator();
    ~CContentRotator();

BEGIN_COM_MAP(CContentRotator)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IContentRotator)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

//DECLARE_NOT_AGGREGATABLE(CContentRotator) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CContentRotator,
                 _T("MSWC.ContentRotator.1"),
                 _T("MSWC.ContentRotator"),
                 IDS_CONTENTROTATOR_DESC,
                 THREADFLAGS_BOTH)

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IContentRotator
public:
	// for free-threaded marshalling
DECLARE_GET_CONTROLLING_UNKNOWN()
	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p );
	}
	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}


    STDMETHOD(ChooseContent)(
        BSTR bstrDataFile,
        BSTR* pbstrRetVal);

    STDMETHOD(GetAllContent)(
        BSTR bstrDataFile);
    
private:
    CTipList*           m_ptl;
    CTipList*           m_ptlUsed;              // List of tips already sent
    CRITICAL_SECTION    m_CS;

    HRESULT
    _ChooseContent(
        BSTR bstrPhysicalDataFile,
        BSTR* pbstrRetVal);

    HRESULT
    _ReadDataFile(
        BSTR bstrPhysicalDataFile,
        BOOL fForceReread);

	CComPtr<IUnknown>		m_pUnkMarshaler;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\mystring.cpp ===
#include "stdafx.h"
#include "..\shared\src\MyString.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\controt\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#pragma once
#ifndef _STDAFX_H_
#define _STDAFX_H_

#define STRICT

#include <atlbase.h>
#include <mtx.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CContRotModule : public CComModule
{
public:
	LONG	Lock();
	LONG	Unlock();

private:
	CComAutoCriticalSection	m_cs;
};

extern CContRotModule _Module;

#include <algorithm>
using namespace std;

#include <atlcom.h>
#include "mystring.h"
#include "strmap.h"
#include "myvector.h"
#include "mydebug.h"

#define ARRAYSIZE(a)	(sizeof(a)/sizeof(*(a)))

#endif	// !_STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\link.cpp ===
// Link.cpp: implementation of the CLink class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "NxtLnk.h"
#include "Link.h"
#include "NextLink.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CLink::CLink(
	const String&	strLink,
	const String&	strDesc )
	:	m_strLink( strLink, false ),    // set case sensitive to false
		m_strDesc( strDesc, false )     // set case sensitive to false
{
	m_urlType = UrlType( m_strLink );
}

CLink::~CLink()
{
}

bool
CLink::IsEqual(
	const String&	strLink ) const
{
	bool rc = false;

	switch ( m_urlType )
	{
		case urlType_LocalAbsolute:
		{
			rc = ( strLink == m_strLink );
		} break;

		case urlType_Relative:
		{
			String strRel(strLink,false); // set case sensitive to false
			String::size_type p = strLink.find_last_of( _T('/') );
			if ( p != String::npos )
			{
				strRel = strLink.substr( p + 1, strLink.length() );
			}
			else
			{
				p = strLink.find_last_of( _T('\\') );
				if ( p != String::npos )
				{
					strRel = strLink.substr( p + 1, strLink.length() );
				}
			}
			if ( strRel == m_strLink )
			{
				rc = true;
			}
		} break;

		case urlType_Absolute:
		{
			CNextLink::RaiseException( IDS_ERROR_CANT_MATCH_ABSOLUTE_URLS );
		} break;

		default:
		{
		} break;
	}
	return rc;
}

int
CLink::UrlType(
	const String&	strUrl )
{
	int urlType;

	const String slashSlash = _T("//");
	const String bslashBslash = _T("\\\\");

	if ( ( strUrl.compare( 0, 2, slashSlash ) == 0 ) ||
		( strUrl.compare( 0, 2, bslashBslash ) == 0 ) )
	{
		urlType = urlType_Absolute;
	}
	else if ( ( strUrl[0] == _T('\\') ) || ( strUrl[0] == _T('/') ) )
	{
		urlType = urlType_LocalAbsolute;
	}
	else
	{
		if ( strUrl.find( _T(':') ) != String::npos )
		{
			urlType = urlType_Absolute;
		}
		else
		{
			urlType = urlType_Relative;
		}
	}

	return urlType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\outstrm.cpp ===
#include "stdafx.h"
#include "..\shared\src\OutStrm.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\rdwrt.cpp ===
#include "stdafx.h"
#include "..\shared\src\RdWrt.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\linkfile.h ===
// LinkFile.h: interface for the CLinkFile class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LINKFILE_H__253413CE_E71F_11D0_8A84_00C0F00910F9__INCLUDED_)
#define AFX_LINKFILE_H__253413CE_E71F_11D0_8A84_00C0F00910F9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "RefCount.h"
#include "RefPtr.h"
#include "Link.h"
#include "Monitor.h"
#include "RdWrt.h"

class CLinkNotify : public CMonitorNotify
{
public:
                    CLinkNotify();
    virtual void    Notify();
            bool    IsNotified();
private:
    long            m_isNotified;
};

DECLARE_REFPTR( CLinkNotify,CMonitorNotify )

class CLinkFile : public CRefCounter, public CReadWrite
{
public:
	CLinkFile( const String& strFile );

	int			LinkIndex( const String& strPage );
	CLinkPtr	Link( int nIndex );
	CLinkPtr	NextLink( const String& strPage );
	CLinkPtr	PreviousLink( const String& strPage );
	int			NumLinks(){ return m_links.size(); }
    bool        Refresh();
	bool		IsOkay() const { return m_bIsOkay; }
    bool        fUTF8() const { return m_fUTF8; }

private:
    bool        LoadFile();
	virtual     ~CLinkFile();

	TVector< CLinkPtr >		m_links;
    String                  m_strFile;
    CLinkNotifyPtr          m_pNotify;
	bool					m_bIsOkay;
    bool                    m_fUTF8;
};

typedef TRefPtr< CLinkFile > CLinkFilePtr;

#endif // !defined(AFX_LINKFILE_H__253413CE_E71F_11D0_8A84_00C0F00910F9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\link.h ===
// Link.h: interface for the CLink class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LINK_H__253413CF_E71F_11D0_8A84_00C0F00910F9__INCLUDED_)
#define AFX_LINK_H__253413CF_E71F_11D0_8A84_00C0F00910F9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "RefCount.h"
#include "RefPtr.h"

class CLink : public CRefCounter  
{
public:
	enum {
		urlType_Absolute,
		urlType_LocalAbsolute,
		urlType_Relative
	};

	CLink( const String& strLink, const String& strDesc );
	int				UrlType() const { return m_urlType; }
	const String&	Link() const { return m_strLink; }
	const String&	Desc() const { return m_strDesc; }
	bool			IsEqual( const String& strLink ) const;

	static int UrlType( const String& strUrl );

private:
	virtual ~CLink();

	int				m_urlType;
	const String	m_strLink;
	const String	m_strDesc;
};

typedef TRefPtr<CLink> CLinkPtr;

#endif // !defined(AFX_LINK_H__253413CF_E71F_11D0_8A84_00C0F00910F9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\monitor.cpp ===
#include "stdafx.h"
#include "..\shared\src\Monitor.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\sinstrm.cpp ===
#include "stdafx.h"
#include "..\shared\src\SInStrm.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\soutstrm.cpp ===
#include "stdafx.h"
#include "..\shared\src\SOutStrm.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\nextlink.h ===
// NextLink.h : Declaration of the CNextLink

#ifndef __NEXTLINK_H_
#define __NEXTLINK_H_

#include "resource.h"       // main symbols
#include <asptlb.h>         // Active Server Pages Definitions
#include "LinkFile.h"
#include "lock.h"
#include "context.h"

/////////////////////////////////////////////////////////////////////////////
// CNextLink
class ATL_NO_VTABLE CNextLink : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CNextLink, &CLSID_NextLink>,
	public ISupportErrorInfo,
	public IDispatchImpl<INextLink, &IID_INextLink, &LIBID_NextLink>
{
public:
	CNextLink()
	{ 
	}

public:

DECLARE_REGISTRY_RESOURCEID(IDR_NEXTLINK)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CNextLink)
	COM_INTERFACE_ENTRY(INextLink)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p );
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// INextLink
public:
	STDMETHOD(get_About)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_GetListIndex)(BSTR bstrLinkFile, /*[out, retval]*/ int *pVal);
	STDMETHOD(get_GetListCount)(BSTR bstrLinkFile, /*[out, retval]*/ int *pVal);
	STDMETHOD(get_GetNthDescription)(BSTR bstrLinkFile, int nIndex, /*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_GetNthURL)(BSTR bstrLinkFile, int nIndex, /*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_GetPreviousDescription)(BSTR bstrLinkFile, /*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_GetPreviousURL)(BSTR bstrLinkFile, /*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_GetNextDescription)(BSTR bstrLinkFile, /*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_GetNextURL)(BSTR, /*[out, retval]*/ BSTR *pVal);

	static	void	ClearLinkFiles();
	static	void	RaiseException( LPOLESTR );
	static	void	RaiseException( UINT );

private:
    CLinkFilePtr            LinkFile( UINT, BSTR );
	CLinkFilePtr            LinkFile( CContext&, UINT, BSTR );
    bool                    GetPage( CContext&, String& );
    bool                    GetFileAndPage( UINT, BSTR, CLinkFilePtr&, String& );

	typedef TSafeStringMap<CLinkFilePtr>	LinkFileMapT;

	CComPtr<IUnknown>		m_pUnkMarshaler;
	static LinkFileMapT		s_linkFileMap;

};

#endif //__NEXTLINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\linkfile.cpp ===
// LinkFile.cpp: implementation of the CLinkFile class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "NxtLnk.h"
#include "LinkFile.h"
#include "NextLink.h"

extern CMonitor* g_pMonitor;

//--------------------------------------------------------------------
//  IsTab
//
//  Function object to read a stream until a tab is encounterd
//
//--------------------------------------------------------------------
struct IsTab : public CharCheck
{
    virtual bool    operator()(_TCHAR);
};

bool
IsTab::operator()(
    _TCHAR  c )
{
    return ( c == _T('\t') );
}

//--------------------------------------------------------------------
//  CLinkNotify
//--------------------------------------------------------------------
CLinkNotify::CLinkNotify()
    :   m_isNotified(0)
{
}

void
CLinkNotify::Notify()
{
    ::InterlockedExchange( &m_isNotified, 1 );
}

bool
CLinkNotify::IsNotified()
{
    return ( ::InterlockedExchange( &m_isNotified, 0 ) ? true : false );
}

//---------------------------------------------------------------------
//  CLinkFile
//---------------------------------------------------------------------

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CLinkFile::CLinkFile(
    const String&   strFile )
    :   m_bIsOkay( false ),
        m_strFile( strFile ),
        m_fUTF8(false)
{
    m_pNotify = new CLinkNotify;

    if ( LoadFile() )
    {
        g_pMonitor->MonitorFile( m_strFile.c_str(), m_pNotify );
    }
}

CLinkFile::~CLinkFile()
{
    if ( g_pMonitor )
    {
        g_pMonitor->StopMonitoringFile( m_strFile.c_str() );
    }
}

int
CLinkFile::LinkIndex(
    const String&   strPage )
{
    int rc = 0;
    for ( int i = 0; i < m_links.size(); i++ )
    {
        if ( m_links[i]->IsEqual( strPage ) )
        {
            rc = i+1;
            i = m_links.size();
        }
    }
    return rc;
}

CLinkPtr
CLinkFile::Link(
    int nIndex )
{
    CLinkPtr pLink = NULL;

    if ( m_links.size() > 0 )
    {
        if ( nIndex > m_links.size() )
        {
            pLink = m_links.front();
        }
        else if ( nIndex < 1 )
        {
            pLink = m_links.back();
        }
        else
        {
            pLink = m_links[nIndex-1];
        }
    }
    return pLink;
}

CLinkPtr
CLinkFile::NextLink(
    const String&   strPage )
{
    CLinkPtr pLink;
    int nIndex = LinkIndex( strPage );
    if ( nIndex > 0 )
    {
        pLink = Link( nIndex + 1 );
    }
    else if ( m_links.size() > 0 )
    {
        pLink = m_links.back();
    }

    return pLink;
}

CLinkPtr
CLinkFile::PreviousLink(
    const String&   strPage )
{
    CLinkPtr pLink;
    int nIndex = LinkIndex( strPage );
    if (nIndex > 0)
    {
        pLink = Link( nIndex - 1 );
    }
    else if ( m_links.size() > 0 )
    {
        pLink = m_links.front();
    }
    return pLink;
}

//---------------------------------------------------------------------------
//
//  Refresh will check to see if the cached information is out of date with
//  the ini file.  If so, the cached will be purged
//
//---------------------------------------------------------------------------
bool
CLinkFile::Refresh()
{
    bool rc = false;
    if ( m_pNotify->IsNotified() )
    {
        LoadFile();
        rc = true;
    }
    return rc;
}

bool
ValidateURL(String &url)
{
    if (!url.compare(0, 2, "//")
        || !url.compare(0, 2, "\\\\")
        || !url.compare(0, 5, "http:")
        || !url.compare(0, 6, "https:"))

        return false;
    else
        return true;
}

bool
CLinkFile::LoadFile()
{
    USES_CONVERSION;

    bool rc = false;

    CWriter wtr( *this );
    m_links.clear();

    // parse the file for the links
    FileInStream fs( m_strFile.c_str() );
    if ( fs.is_open() )
    {
        m_fUTF8 = fs.is_UTF8();

        while ( !fs.eof() )
        {
            String strLine;
            fs.readLine( strLine );
            if ( strLine != _T("") )
            {
                StringInStream ss( strLine );
                String strURL = _T(""), strDesc = _T("");
                ss.read( IsTab(), strURL );
                ss.read( IsTab(), strDesc );
                // anything following description is just a comment which is discarded

                if (ValidateURL(strURL)) {
                    CLinkPtr pLink = new CLink( strURL, strDesc );
                    m_links.push_back( pLink );
                }
            }
        }
        if (m_links.size()) 
        {
            rc = true;
        }
        else
        {
            rc = false;
            CNextLink::RaiseException( IDS_ERROR_INVALID_LINKFILE );
        }
    }
    else
    {
        CNextLink::RaiseException( IDS_ERROR_CANNOT_OPEN_FILE );
    }
    m_bIsOkay = rc;
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\nextlink.cpp ===
// NextLink.cpp : Implementation of CNextLink
#include "stdafx.h"
#include "NxtLnk.h"
#include "NextLink.h"

#define MAX_RESSTRINGSIZE 512

CNextLink::LinkFileMapT CNextLink::s_linkFileMap;

/////////////////////////////////////////////////////////////////////////////
// CNextLink

STDMETHODIMP CNextLink::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_INextLink,
    };
    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

STDMETHODIMP CNextLink::get_GetNextURL(BSTR bstrLinkFile, BSTR * pVal)
{
    SCODE rc = E_FAIL;

    try
    {
        CLinkFilePtr    pLinkFile;
        String         strPage;
        if ( GetFileAndPage( IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETNEXTURL, bstrLinkFile, pLinkFile, strPage ) )
        {
            if ( pLinkFile.IsValid() )
            {
                CReader rdr(*pLinkFile);
                CLinkPtr pLink = pLinkFile->NextLink( strPage );
                if ( pLink.IsValid() )
                {
                    if ( pVal )
                    {
                        if ( *pVal )
                        {
                            ::SysFreeString( *pVal );
                        }
                        HRESULT hr;
                        CMBCSToWChar    convStr;
                        if (hr = convStr.Init(pLink->Link().c_str(), 
                                              pLinkFile->fUTF8() ? 65001 : CP_ACP)) {
                            throw _com_error(hr);
                        }
                        *pVal = ::SysAllocString(convStr.GetString());
                        THROW_IF_NULL(*pVal);
                        rc = S_OK;
                    }
                    else
                    {
                        rc = E_POINTER;
                    }
                }
            }
        }
    }
    catch ( _com_error& ce )
    {
        rc = ce.Error();
    }
    catch ( ... )
    {
        rc = E_FAIL;
    }
    return rc;
}

STDMETHODIMP CNextLink::get_GetNextDescription(BSTR bstrLinkFile, BSTR * pVal)
{
    SCODE rc = E_FAIL;

    try
    {
        CLinkFilePtr    pLinkFile;
        String         strPage;
        if ( GetFileAndPage( IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETNEXTDESCRIPTION, bstrLinkFile, pLinkFile, strPage ) )
        {
            if ( pLinkFile.IsValid() )
            {
                CReader rdr(*pLinkFile);
                CLinkPtr pLink = pLinkFile->NextLink( strPage );
                if ( pLink.IsValid() )
                {
                    if ( pVal )
                    {
                        if ( *pVal )
                        {
                            ::SysFreeString( *pVal );
                        }
                        HRESULT hr;
                        CMBCSToWChar    convStr;
                        if (hr = convStr.Init(pLink->Desc().c_str(), 
                                              pLinkFile->fUTF8() ? 65001 : CP_ACP)) {
                            throw _com_error(hr);
                        }
                        *pVal = ::SysAllocString(convStr.GetString());
                        THROW_IF_NULL(*pVal);
                        rc = S_OK;
                    }
                    else
                    {
                        rc = E_POINTER;
                    }
                }
            }
        }
    }
    catch ( _com_error& ce )
    {
        rc = ce.Error();
    }
    catch ( ... )
    {
        rc = E_FAIL;
    }
    return rc;
}

STDMETHODIMP CNextLink::get_GetPreviousURL(BSTR bstrLinkFile, BSTR * pVal)
{
    SCODE rc = E_FAIL;

    try
    {
        CLinkFilePtr    pLinkFile;
        String         strPage;
        if ( GetFileAndPage( IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETPREVIOUSURL, bstrLinkFile, pLinkFile, strPage ) )
        {
            if ( pLinkFile.IsValid() )
            {
                CReader rdr(*pLinkFile);
                CLinkPtr pLink = pLinkFile->PreviousLink( strPage );
                if ( pLink.IsValid() )
                {
                    if ( pVal )
                    {
                        if ( *pVal )
                        {
                            ::SysFreeString( *pVal );
                        }
                        HRESULT hr;
                        CMBCSToWChar    convStr;
                        if (hr = convStr.Init(pLink->Link().c_str(), 
                                              pLinkFile->fUTF8() ? 65001 : CP_ACP)) {
                            throw _com_error(hr);
                        }
                        *pVal = ::SysAllocString(convStr.GetString());
                        THROW_IF_NULL( *pVal );
                        rc = S_OK;
                    }
                    else
                    {
                        rc = E_POINTER;
                    }
                }
            }
        }
    }
    catch ( _com_error& ce )
    {
        rc = ce.Error();
    }
    catch ( ... )
    {
        rc = E_FAIL;
    }
    return rc;
}

STDMETHODIMP CNextLink::get_GetPreviousDescription(BSTR bstrLinkFile, BSTR * pVal)
{
    SCODE rc = E_FAIL;

    try
    {
        CLinkFilePtr    pLinkFile;
        String         strPage;
        if ( GetFileAndPage( IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETPREVIOUSDDESCRIPTION, bstrLinkFile, pLinkFile, strPage ) )
        {
            if ( pLinkFile.IsValid() )
            {
                CReader rdr(*pLinkFile);
                CLinkPtr pLink = pLinkFile->PreviousLink( strPage );
                if ( pLink.IsValid() )
                {
                    if ( pVal )
                    {
                        if ( *pVal )
                        {
                            ::SysFreeString( *pVal );
                        }
                        HRESULT hr;
                        CMBCSToWChar    convStr;
                        if (hr = convStr.Init(pLink->Desc().c_str(), 
                                              pLinkFile->fUTF8() ? 65001 : CP_ACP)) {
                            throw _com_error(hr);
                        }
                        *pVal = ::SysAllocString(convStr.GetString());
                        THROW_IF_NULL( *pVal );
                        rc = S_OK;
                    }
                    else
                    {
                        rc = E_POINTER;
                    }
                }
            }
        }
    }
    catch ( _com_error& ce )
    {
        rc = ce.Error();
    }
    catch ( ... )
    {
        rc = E_FAIL;
    }
    return rc;
}

STDMETHODIMP CNextLink::get_GetNthURL(BSTR bstrLinkFile, int nIndex, BSTR * pVal)
{
    SCODE rc = E_FAIL;

    try
    {
        CLinkFilePtr pLinkFile = LinkFile( IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETNTHURL, bstrLinkFile );
        if ( pLinkFile.IsValid() )
        {
            CReader rdr(*pLinkFile);

            if ( (nIndex <= 0) || (nIndex > pLinkFile->NumLinks()) ) {
                RaiseException( IDS_ERROR_INVALID_NTH_INDEX );
                goto err;
            }   
            CLinkPtr pLink = pLinkFile->Link( nIndex );
            if ( pLink.IsValid() )
            {
                if ( pVal )
                {
                    if (*pVal)
                    {
                        ::SysFreeString(*pVal);
                    }
                    HRESULT hr;
                    CMBCSToWChar    convStr;
                    if (hr = convStr.Init(pLink->Link().c_str(), 
                                          pLinkFile->fUTF8() ? 65001 : CP_ACP)) {
                        throw _com_error(hr);
                    }
                    *pVal = ::SysAllocString(convStr.GetString());
                    THROW_IF_NULL(*pVal);
                    rc = S_OK;
                }
                else
                {
                    rc = E_POINTER;
                }
            }
        }
    }
    catch ( _com_error& ce )
    {
        rc = ce.Error();
    }
    catch ( ... )
    {
        rc = E_FAIL;
    }
err:
    return rc;
}

STDMETHODIMP CNextLink::get_GetNthDescription(BSTR bstrLinkFile, int nIndex, BSTR * pVal)
{
    SCODE rc = E_FAIL;

    try
    {
        CLinkFilePtr pLinkFile = LinkFile( IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETNTHDESCRIPTION, bstrLinkFile );
        if ( pLinkFile.IsValid() )
        {
            CReader rdr(*pLinkFile);
            if ( (nIndex <= 0) || (nIndex > pLinkFile->NumLinks()) ) {
                RaiseException( IDS_ERROR_INVALID_NTH_INDEX );
                goto err;
            }   
            CLinkPtr pLink = pLinkFile->Link( nIndex );
            if ( pLink.IsValid() )
            {
                if ( pVal )
                {
                    if ( *pVal )
                    {
                        ::SysFreeString( *pVal );
                    }
                    HRESULT hr;
                    CMBCSToWChar    convStr;
                    if (hr = convStr.Init(pLink->Desc().c_str(), 
                                          pLinkFile->fUTF8() ? 65001 : CP_ACP)) {
                        throw _com_error(hr);
                    }
                    *pVal = ::SysAllocString(convStr.GetString());
                    THROW_IF_NULL( *pVal );
                    rc = S_OK;
                }
                else
                {
                    rc = E_POINTER;
                }
            }
        }
    }
    catch ( _com_error& ce )
    {
        rc = ce.Error();
    }
    catch ( ... )
    {
        rc = E_FAIL;
    }
err:
    return rc;
}

STDMETHODIMP CNextLink::get_GetListCount(BSTR bstrLinkFile, int * pVal)
{
    SCODE rc = E_FAIL;

    try
    {
        CLinkFilePtr pLinkFile = LinkFile( IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETLISTCOUNT, bstrLinkFile );
        if ( pLinkFile.IsValid() )
        {
            CReader rdr(*pLinkFile);
            *pVal = pLinkFile->NumLinks();
            rc = S_OK;
        }
    }
    catch ( _com_error& ce )
    {
        rc = ce.Error();
    }
    catch ( ... )
    {
        rc = E_FAIL;
    }
    return rc;
}


STDMETHODIMP CNextLink::get_GetListIndex(BSTR bstrLinkFile, int * pVal)
{
    SCODE rc = E_FAIL;

    try
    {
        CLinkFilePtr    pLinkFile;
        String         strPage;
        if ( GetFileAndPage( IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETLISTINDEX, bstrLinkFile, pLinkFile, strPage ) )
        {
            if ( pLinkFile.IsValid() )
            {
                CReader rdr(*pLinkFile);
                *pVal = pLinkFile->LinkIndex( strPage );
                rc = S_OK;
            }
        }
    }
    catch ( _com_error& ce )
    {
        rc = ce.Error();
    }
    catch ( ... )
    {
        rc = E_FAIL;
    }
    return rc;
}

STDMETHODIMP CNextLink::get_About(BSTR * pVal)
{
    USES_CONVERSION;

#ifdef _DEBUG
    LPCTSTR szVersion = _T("Debug");
#else
    LPCTSTR szVersion = _T("Release");
#endif
    const int kAboutSize = 1024;
    _TCHAR  szAboutFmt[kAboutSize];
    _TCHAR  szBuffer[ kAboutSize + sizeof(__DATE__) + sizeof(__TIME__) + sizeof(szVersion) ];
    
    ::LoadString( _Module.GetResourceInstance(), IDS_ABOUT_FMT, szAboutFmt, kAboutSize );
    _stprintf(szBuffer, szAboutFmt, szVersion, __DATE__, __TIME__);

    if ( pVal )
    {
        if ( *pVal )
        {
            ::SysFreeString( *pVal );
        }
        *pVal = T2BSTR( szBuffer );
        if ( *pVal == NULL )
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        return E_POINTER;
    }

    return S_OK;
}

bool
CNextLink::GetPage(
    CContext&   cxt,
    String&     strPage )
{
    USES_CONVERSION;

    bool rc = false;
    if ( cxt.Request() != NULL )
    {
        CComPtr<IDispatch> piPathInfo;
        HRESULT hr = cxt.Request()->get_Item( L"PATH_INFO", &piPathInfo );
        if ( !FAILED(hr) )
        {
            CComVariant vt = piPathInfo;
            hr = vt.ChangeType( VT_BSTR );
            if ( !FAILED( hr ) )
            {
                strPage = OLE2T(vt.bstrVal);
                rc = true;
            }
        }
    }
    return rc;
}

CLinkFilePtr
CNextLink::LinkFile(
    CContext&           cxt,
    UINT                errorID,
    BSTR                bstrFile )
{
    USES_CONVERSION;
    
    CLinkFilePtr pLinkFile;

    if ( cxt.Server() != NULL )
    {
        CComBSTR bstrPath;
        HRESULT hr = cxt.Server()->MapPath( bstrFile, &bstrPath );
        if ( !FAILED( hr ) )
        {
            String strFile = OLE2T(bstrPath);
            CLock l( s_linkFileMap );
            CLinkFilePtr& rpLinkFile = s_linkFileMap[strFile];
            if ( !rpLinkFile.IsValid() )
            {
                rpLinkFile = new CLinkFile( strFile );
            }
            else
            {
                // make sure the file is up to date
                rpLinkFile->Refresh();
            }
            if ( rpLinkFile->IsOkay() )
            {
            }
            else
            {
                rpLinkFile = NULL;
            }
            pLinkFile = rpLinkFile;
        }
        else
        {
            RaiseException( errorID );
        }
    }
    return pLinkFile;
}

CLinkFilePtr
CNextLink::LinkFile(
    UINT    errorID,
    BSTR    bstrFile )
{
    CLinkFilePtr pLinkFile;

    CContext cxt;
    HRESULT hr = cxt.Init( CContext::get_Server );
    if ( !FAILED(hr) )
    {
        pLinkFile = LinkFile( cxt, errorID, bstrFile );
    }
    else
    {
        RaiseException( IDS_ERROR_NOSVR );
    }

    return pLinkFile;
}

bool
CNextLink::GetFileAndPage(
    UINT            errorID,
    BSTR            bstrFile,
    CLinkFilePtr&   pLinkFile,
    String&         strPage )
{
    bool rc = false;

    CContext cxt;
    HRESULT hr = cxt.Init( CContext::get_Server | CContext::get_Request );
    if ( !FAILED( hr ) )
    {
        pLinkFile = LinkFile( cxt, errorID, bstrFile );

        if ( pLinkFile.IsValid() )
        {
            rc = GetPage( cxt, strPage );
        }
    }
    else
    {
        RaiseException( IDS_ERROR_NOSVR );
    }

    return rc;
}

void
CNextLink::ClearLinkFiles()
{
    CLock l(s_linkFileMap);
    s_linkFileMap.clear();
}

//---------------------------------------------------------------------------
//  RaiseException
//
//  Raises an exception using the given source and description
//---------------------------------------------------------------------------
void
CNextLink::RaiseException (
    LPOLESTR strDescr
)
{
    HRESULT hr;
    ICreateErrorInfo *pICreateErr;
    IErrorInfo *pIErr;
    LANGID langID = LANG_NEUTRAL;

    /*
     * Thread-safe exception handling means that we call
     * CreateErrorInfo which gives us an ICreateErrorInfo pointer
     * that we then use to set the error information (basically
     * to set the fields of an EXCEPINFO structure. We then
     * call SetErrorInfo to attach this error to the current
     * thread.  ITypeInfo::Invoke will look for this when it
     * returns from whatever function was invokes by calling
     * GetErrorInfo.
     */

    _TCHAR tstrSource[MAX_RESSTRINGSIZE];
    if ( ::LoadString(
        _Module.GetResourceInstance(),
        IDS_ERROR_SOURCE,
        tstrSource,
        MAX_RESSTRINGSIZE ) > 0 )
    {
        USES_CONVERSION;
        LPOLESTR strSource = T2OLE(tstrSource);
        //Not much we can do if this fails.
        if (!FAILED(CreateErrorInfo(&pICreateErr)))
        {
            pICreateErr->SetGUID(CLSID_NextLink);
            pICreateErr->SetHelpFile(L"");
            pICreateErr->SetHelpContext(0L);
            pICreateErr->SetSource(strSource);
            pICreateErr->SetDescription(strDescr);

            hr = pICreateErr->QueryInterface(IID_IErrorInfo, (void**)&pIErr);

            if (SUCCEEDED(hr))
            {
                if(SUCCEEDED(SetErrorInfo(0L, pIErr)))
                {
                    pIErr->Release();
                }
            }
            pICreateErr->Release();
        }
    }
}

void 
CNextLink::RaiseException(
    UINT DescrID
)
{
    _TCHAR tstrDescr[MAX_RESSTRINGSIZE];

    if ( ::LoadString(
        _Module.GetResourceInstance(),
        DescrID,
        tstrDescr,
        MAX_RESSTRINGSIZE) > 0 )
    {
        USES_CONVERSION;
        LPOLESTR strDescr = T2OLE(tstrDescr);
        RaiseException( strDescr );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\nxtlnk.cpp ===
// NxtLnk.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f NxtLnkps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "NxtLnk.h"

#include "NxtLnk_i.c"
#include <initguid.h>
#include "NextLink.h"
#include "Monitor.h"

CNextLinkModule _Module;
CMonitor*   g_pMonitor = NULL;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_NextLink, CNextLink)
END_OBJECT_MAP()

LONG
CNextLinkModule::Lock()
{
    _ASSERT( g_pMonitor != NULL );
    return CComModule::Lock();
}

LONG
CNextLinkModule::Unlock()
{
	LONG lc;
	CLock l(m_cs);
	if ( ( lc = CComModule::Unlock() ) == 0 )
	{
		// final unlock
		_ASSERT( g_pMonitor != NULL );
        g_pMonitor->StopAllMonitoring();
        CNextLink::ClearLinkFiles();
	}
	return lc;
}

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		DEBUG_START;
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);

        _ASSERT( g_pMonitor == NULL );
		try
		{
            g_pMonitor = new CMonitor();
		}
		catch ( std::bad_alloc& )
		{
			// nothing we can do about it here
		}
	}
	else if (dwReason == DLL_PROCESS_DETACH)
    {
        _ASSERT( g_pMonitor != NULL );
        delete g_pMonitor;
        g_pMonitor = NULL;

		_Module.Term();
		DEBUG_STOP;
    }
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\pagecnt\context.cpp ===
#include "stdafx.h"
#include "..\shared\src\context.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\pagecnt\mem.cpp ===
#include "stdafx.h"
#include "..\shared\src\mem.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\pagecnt\monitor.cpp ===
#include "stdafx.h"
#include "..\shared\src\monitor.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\pagecnt\mystring.cpp ===
#include "stdafx.h"
#include "..\shared\src\mystring.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by nxtlnk.rc
//
#define DLL_VER                         0
#define IDS_PROJNAME                    100
#define IDR_NEXTLINK                    101
#define IDS_ABOUT_FMT                   101
#define IDS_ERROR_SOURCE                102
#define IDS_ERROR_NOSVR                 103
#define IDS_ERROR_CANT_MATCH_ABSOLUTE_URLS 104
#define IDS_ERROR_CANNOT_OPEN_FILE      105
#define IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETLISTCOUNT 106
#define IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETLISTINDEX 107
#define IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETNEXTDESCRIPTION 108
#define IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETNEXTURL 109
#define IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETNTHDESCRIPTION 110
#define IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETNTHURL 111
#define IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETPREVIOUSDDESCRIPTION 112
#define IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETPREVIOUSURL 113
#define IDS_ERROR_INVALID_LINKFILE      114
#define IDS_ERROR_INVALID_NTH_INDEX     115

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__253413C2_E71F_11D0_8A84_00C0F00910F9__INCLUDED_)
#define AFX_STDAFX_H__253413C2_E71F_11D0_8A84_00C0F00910F9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


//#define _ATL_APARTMENT_THREADED


#pragma warning( disable : 4786 )
#include <atlbase.h>
#include <mtx.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

class CNextLinkModule : public CComModule
{
public:
	LONG	Lock();
	LONG	Unlock();

private:
	CComAutoCriticalSection	m_cs;
};

extern CNextLinkModule _Module;
#include <atlcom.h>
#include <comdef.h>
#include <algorithm>

using namespace std;

#include "myvector.h"
#include "strmap.h"
#include "MyDebug.h"
#include "MyString.h"
#include "FInStrm.h"
#include "SInStrm.h"
#include "SOutStrm.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__253413C2_E71F_11D0_8A84_00C0F00910F9__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\pagecnt\critsec.h ===
//
// A class that allows you to enter a critical section and automatically
// leave when the object of this class goes out of scope.  Also provides
// the means to leave and re-enter as needed while protecting against
// entering or leaving out of sync.
//

class CAutoLeaveCritSec
{
public:
    CAutoLeaveCritSec(
        CComAutoCriticalSection& rCS)
        : m_CS(rCS), m_fInCritSec(FALSE)
    {Lock();}
    
    ~CAutoLeaveCritSec()
    {Unlock();}
    
    // Use this function to re-enter the critical section.
    void Lock()
    {if (!m_fInCritSec) {m_CS.Lock();   m_fInCritSec = TRUE;}}

    // Use this function to leave the critical section before going out
    // of scope.
    void Unlock()
    {if (m_fInCritSec)  {m_CS.Unlock(); m_fInCritSec = FALSE;}}

protected:    
    CComAutoCriticalSection& m_CS;
    BOOL                     m_fInCritSec;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\pagecnt\debug.h ===
/*
 * Some simple debugging macros that look and behave a lot like their
 * namesakes in MFC.  These macros should work in both C and C++ and
 * do something useful with almost any Win32 compiler.
 *
 * George V. Reilly  <georger@microcrafts.com>  <a-georgr@microsoft.com>
 */

#ifndef __DEBUG_H__
#define __DEBUG_H__

#ifdef _DEBUG

# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
   /* Use the new debugging tools in Visual C++ 4.x */
#  include <crtdbg.h>
   /* _ASSERTE will give a more meaningful message, but the string takes
    * space.  Use _ASSERT if this is an issue. */
#  define ASSERT(f) _ASSERTE(f)
# else
#  include <assert.h>
#  define ASSERT(f) assert(f)
# endif

# define VERIFY(f)               ASSERT(f)
# define DEBUG_ONLY(f)           (f)
# define TRACE                   Trace
# define TRACE0(psz)             Trace(_T("%s"), _T(psz))
# define TRACE1(psz, p1)         Trace(_T(psz), p1)
# define TRACE2(psz, p1, p2)     Trace(_T(psz), p1, p2)
# define TRACE3(psz, p1, p2, p3) Trace(_T(psz), p1, p2, p3)
# define DEBUG_INIT()            DebugInit()
# define DEBUG_TERM()            DebugTerm()

#else /* !_DEBUG */

  /* These macros should all compile away to nothing */
# define ASSERT(f)               ((void)0)
# define VERIFY(f)               ((void)(f))
# define DEBUG_ONLY(f)           ((void)0)
# define TRACE                   1 ? (void)0 : Trace
# define TRACE0(psz)
# define TRACE1(psz, p1)
# define TRACE2(psz, p1, p2)
# define TRACE3(psz, p1, p2, p3)
# define DEBUG_INIT()            ((void)0)
# define DEBUG_TERM()            ((void)0)

#endif /* !_DEBUG */


#define ASSERT_POINTER(p, type) \
    ASSERT(((p) != NULL)  &&  IsValidAddress((p), sizeof(type), FALSE))

#define ASSERT_NULL_OR_POINTER(p, type) \
    ASSERT(((p) == NULL)  ||  IsValidAddress((p), sizeof(type), FALSE))


/* Declarations for non-Windows apps */

#ifndef _WINDEF_
typedef void*           LPVOID;
typedef const void*     LPCVOID;
typedef unsigned int    UINT;
typedef int             BOOL;
typedef const char*     LPCTSTR;
#endif /* _WINDEF_ */

#ifndef TRUE
# define FALSE  0
# define TRUE   1
#endif


#ifdef __cplusplus
extern "C" {

/* Low-level sanity checks for memory blocks */
BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite = TRUE);
BOOL IsValidString(LPCTSTR ptsz, int nLength = -1);

#else /* !__cplusplus */

/* Low-level sanity checks for memory blocks */
BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite);
BOOL IsValidString(LPCTSTR ptsz, int nLength);

#endif /* !__cplusplus */

/* in debug version, writes trace messages to debug stream */
void __cdecl
Trace(
    LPCTSTR pszFormat,
    ...);

/* should be called from main(), WinMain(), or DllMain() */
void
DebugInit();

void
DebugTerm();

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* __DEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\pagecnt\ccm.h ===
#ifndef _CCM_H_
#define _CCM_H_


// ccm.h : Declaration of CCM, the Central Management Object
#include "resource.h"       // main symbols
#include "page.h"
#include "Monitor.h"

// Registry Keys
#define HITCNT_HKEY      HKEY_CLASSES_ROOT
#define HITCNT_KEYNAME   _T("MSWC.PageCounter")
#define HITCNT_FILELOCN  _T("File_Location")
#define HITCNT_DFLT_FILE _T("%windir%\\system32\\inetsrv\\data\\HitCnt.cnt")
#define HITCNT_SAVECNT   _T("Save_Count")
#define HITCNT_DFLT_SAVE 25

// Registry notification class.
class CRegNotify : public CMonitorNotify
{
public:
                            CRegNotify();
    virtual void            Notify();
            String          FileName();
            DWORD           SaveCount();

private:
            //Looks in Registry to get the Save Count
            bool            GetSaveCount();
            //Looks in Registry to get the file path and name
            bool            GetFileName();

    String                  m_strFileName; //path and filename for persisting
    DWORD                   m_dwSaveCount; //threshold to trigger persisting
    CComAutoCriticalSection m_cs;
};

DECLARE_REFPTR( CRegNotify,CMonitorNotify )

/////////////////////////////////////////////////////////////////////////////
// Central Counter Manager

class CCM
{
public:
    CCM();
    ~CCM();

    //---- Object Methods ----

    //Increments hit count for this page
    DWORD IncrementAndGetHits(const BSTR bstrURL);

    // Get the hit count for this page
    LONG GetHits(const BSTR bstrURL);

    // Reset the hit count for this page to zero
    void Reset(const BSTR bstrURL);

    //---- Helper Functions ----
    
    //Initializes Page Counter
    BOOL Initialize();

    //Writes the data to disk
    BOOL Persist();

private:
    //Loads the persisted data into an array
    BOOL LoadData();

    CRegNotifyPtr   m_pRegKey;
    UINT            m_cUnsavedHits;          //hits since we last persisted
    CPageArray      m_pages;                 //array of pages
    volatile bool   m_bInitialized;
    CComAutoCriticalSection m_critsec;   //Critical Section to protect data

};

extern CCM CountManager;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\pagecnt\ccm.cpp ===
// ccm.cpp : Implementation of CCM, the Central Counter Manager
// that persists as long as this DLL is loaded.  It manages the loading and
// updating of the Hit Count Data file.

#include "stdafx.h"
#include "ccm.h"
#include "debug.h"
#include "critsec.h"
#include <stdio.h>

extern CMonitor* g_pMonitor;

//---------------------------------------------------------------------------
//  CRegNotify
//---------------------------------------------------------------------------
CRegNotify::CRegNotify()
    :   m_dwSaveCount(HITCNT_DFLT_SAVE)
{
    GetFileName();
    GetSaveCount();
}

void
CRegNotify::Notify()
{
    GetFileName();
    GetSaveCount();
}

String
CRegNotify::FileName()
{
    CAutoLeaveCritSec l(m_cs);
    return m_strFileName;
}

DWORD
CRegNotify::SaveCount()
{
    return m_dwSaveCount;
}

bool
CRegNotify::GetFileName()
{
    bool rc = false;

    //Open the HitCnt Key
    CRegKey regKey;
    long retValue = regKey.Open(HITCNT_HKEY, HITCNT_KEYNAME, KEY_READ);

    DWORD dwType = REG_EXPAND_SZ;
    TCHAR tszTemp[MAX_PATH];
    DWORD dwSize = sizeof(tszTemp);

    if(retValue == ERROR_SUCCESS)
    {
      //Get the File_Location from the Registry
      retValue = RegQueryValueEx(regKey,
        HITCNT_FILELOCN,
        NULL,
        &dwType,
        (LPBYTE) tszTemp,
        &dwSize);
    }
     
    // If there's an error, use the default
    if(retValue != ERROR_SUCCESS
       || (dwType != REG_EXPAND_SZ && dwType != REG_SZ))
    {
        _tcscpy(tszTemp, HITCNT_DFLT_FILE);
    }

    //tszTemp contains an embedded environment variable (%windir%),
    //so expand it
    TCHAR tszFileName[MAX_PATH];
    ExpandEnvironmentStrings(tszTemp, tszFileName, ARRAYSIZE(tszFileName));

    // lock the object, and copy it into the permenant string
    CAutoLeaveCritSec l(m_cs);
    m_strFileName = tszFileName;

    ATLTRACE(_T("GetFileName %s\n"), m_strFileName.c_str());

    return TRUE;
}

//Get the threshold for updating the persistent data from the registry
bool
CRegNotify::GetSaveCount()
{

  //Open the HitCnt Key
  CRegKey regKey;
  long retValue = regKey.Open(HITCNT_HKEY, HITCNT_KEYNAME, KEY_READ);

  if(retValue == ERROR_SUCCESS)
  {

    DWORD dwType, dwSaveCount, dwSize = sizeof(dwSaveCount);  

    //Get the Save_Count from the Registry
    retValue = RegQueryValueEx(regKey,
        HITCNT_SAVECNT,
        NULL,
        &dwType,
        (LPBYTE)&dwSaveCount,
        &dwSize);

    if(retValue == ERROR_SUCCESS && dwType == REG_DWORD && dwSaveCount > 0)
    {
       ::InterlockedExchange(
        reinterpret_cast<long*>(&m_dwSaveCount),
        static_cast<long>(dwSaveCount) );
       return true;
    }

  } 

  //Registry Lookup Failed so set Default to HITCNT_DFLT_SAVE
  ::InterlockedExchange( reinterpret_cast<long*>(&m_dwSaveCount), HITCNT_DFLT_SAVE );
  return true;
}

/////////////////////////////////////////////////////////////////////////////
//

CCM::CCM()
    :   m_cUnsavedHits(0),
        m_bInitialized( false )
{
}

CCM::~CCM()
{
}

//Initialize Page Counter Component
BOOL CCM::Initialize()
{
    BOOL Result = FALSE;

    if ( m_bInitialized )
    {
        // do nothing
        Result = TRUE;
    }
    else
    {
        CAutoLeaveCritSec l(m_critsec);
        
        // re-check, in case it was inited while we were gaining a lock
        if ( !m_bInitialized )
        {
            m_pRegKey = new CRegNotify();

            if ( _Module.Monitor() )
            {
                _Module.Monitor()->MonitorRegKey( HITCNT_HKEY, HITCNT_KEYNAME, m_pRegKey );
            }

            //Read File
            Result = LoadData() && Result;

            m_bInitialized = true;
        }
    }
    return Result;
}

////////////////// Start Object Methods //////////////////

DWORD CCM::IncrementAndGetHits(const BSTR bstrURL)
{
    Initialize();

    CAutoLeaveCritSec alcs(m_critsec);

    UINT retval = m_pages.IncrementPage(bstrURL);
    if (retval == BAD_HITS)
        retval = 0;

    if(++m_cUnsavedHits >= m_pRegKey->SaveCount() )
    {
        if (!Persist())
            retval = 0; //failure
        m_cUnsavedHits = 0;
    }

    return retval;
}


LONG CCM::GetHits (const BSTR bstrURL)
{
    Initialize();

    CAutoLeaveCritSec alcs(m_critsec);

    LONG retval = m_pages.GetHits(bstrURL);
    if (retval == BAD_HITS)
        retval = 0;

    return retval;
}


void CCM::Reset (const BSTR bstrURL)  
{
    Initialize();

    CAutoLeaveCritSec alcs(m_critsec);

    m_pages.Reset(bstrURL);
}

////////////////// Helper Methods //////////////////


//Load URLs and Hit Counts from Disk
BOOL CCM::LoadData()
{
    String strFileName = m_pRegKey->FileName();

    ATLTRACE(_T("LoadData(%s)\n"), strFileName.c_str() );

    BOOL retval = TRUE;

    //Attempt to Open File
    FILE* fp = _tfopen(strFileName.c_str(), _T("r"));

    if(fp == NULL)
        return FALSE;

    for (;;)
    {
      char buffer[1024+15];
      UINT Hits;

      if (fgets(buffer, sizeof buffer, fp) == NULL)
      {
          // fgets returns NULL both on error and on EOF
          retval = (feof(fp) != 0);
          break;
      }
      if (sscanf(buffer, "%u%1024s", &Hits, buffer) != 2)
      {
          retval = FALSE;
          break;
      }
 
      USES_CONVERSION; //needed by A2OLE
      if (m_pages.AddPage(A2OLE(buffer), Hits) == BAD_HITS)
      {
          retval = FALSE;
          break;
      };
    }

    fclose(fp);
    
    return retval;
}


//Write out URLs and Hit Counts to Disk
BOOL CCM::Persist()
{
    Initialize();

    String strFileName = m_pRegKey->FileName();
    ATLTRACE(_T("Persist(%s)\n"), strFileName.c_str());

    //Attempt to Open File
    FILE* fp = _tfopen(strFileName.c_str(), _T("w+"));

    if(fp == NULL)
        return TRUE;

//  BOOL retval = TRUE;
    
    for(UINT count = 0; count < m_pages.Size(); count++)
    {
        USES_CONVERSION;
        int cch = fprintf(fp, "%i\t%s\n", m_pages[count].GetHits(),
                          OLE2CA(m_pages[count].GetURL()));
        if (cch < 0)
        {
//          retval = FALSE;
        }
    }

    fclose(fp);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\pagecnt\debug.cpp ===
#include "stdafx.h"

#include <stdio.h>
#include <stdarg.h>
#include "debug.h"


#define ACTIVE_SERVER_PAGES 1


#ifdef _DEBUG

void __cdecl
Trace(
    LPCTSTR ptszFormat,
    ...)
{
    TCHAR tszBuff[2048];
    va_list args;
    
    va_start(args, ptszFormat);
    _vstprintf(tszBuff, ptszFormat, args);
    va_end(args);

    OutputDebugString(tszBuff);
}



# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)


#  ifdef ACTIVE_SERVER_PAGES

// The default assertion mechanism set up by Visual C++ 4 will not
// work with Active Server Pages because it's running inside a service
// and there is no desktop to interact with.

// Note: for this to work properly, #define _WIN32_WINNT 0x400 before
// including <winuser.h> or MB_SERVICE_NOTIFICATION won't be #define'd.

int
__cdecl
AspAssertHandler(
    int   nReportType,
    char* pszErrorText,
    int*  pnReturn)
{
    const char szInfo[] = " (Press ABORT to terminate IIS,"
                          " RETRY to debug this failure,"
                          " or IGNORE to continue.)";
    char* pszMessageTitle = NULL;
    
    // These flags enable message boxes to show up on the user's console
    switch (nReportType)
    {
    case _CRT_WARN:
        pszMessageTitle = "Warning";
        break;
    case _CRT_ERROR:
        pszMessageTitle = "Fatal Error";
        break;
    case _CRT_ASSERT:
        pszMessageTitle = "Assertion Failed";
        break;
    }   
    
    char* pszMessageText =
        static_cast<char*>(_alloca(strlen(pszErrorText) + strlen(szInfo) + 1));

    strcpy(pszMessageText, pszErrorText);
    strcat(pszMessageText, szInfo);
    
    const int n = MessageBoxA(NULL, pszMessageText, pszMessageTitle,
                              (MB_SERVICE_NOTIFICATION | MB_TOPMOST
                               | MB_ABORTRETRYIGNORE | MB_ICONEXCLAMATION));

    if (n == IDABORT)
    {
        exit(1);
    }
    else if (n == IDRETRY)
    {
        *pnReturn = 1;   // tell _CrtDbgReport to start the debugger
        return TRUE;     // tell _CrtDbgReport to run
    }
    
    *pnReturn = 0;       // nothing for _CrtDbgReport to do

    return FALSE;
}

#  endif // ACTIVE_SERVER_PAGES
# endif // _MSC_VER >= 1000



void
DebugInit()
{
# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef ACTIVE_SERVER_PAGES
    // If we end up in _CrtDbgReport, don't put up a message box
    _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_WARN,   _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_ERROR,  _CRTDBG_MODE_DEBUG);

    // Use AspAssertHandler to put up a message box instead
    _CrtSetReportHook(AspAssertHandler);
#  endif // ACTIVE_SERVER_PAGES

    // Enable debug heap allocations & check for memory leaks at program exit
    // The memory leak check will not be performed if inetinfo.exe is
    // run directly under a debugger, only if it is run as a service.
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF
                   | _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG));
# endif // _MSC_VER >= 1000
}



void
DebugTerm()
{
# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef ACTIVE_SERVER_PAGES
    // Turn off AspAssertHandler, so that we don't get numerous message boxes
    // if there are memory leaks on shutdown
    _CrtSetReportHook(NULL);
#  endif // ACTIVE_SERVER_PAGES
# endif // _MSC_VER >= 1000
}

#endif //_DEBUG



BOOL
IsValidString(
    LPCTSTR ptsz,
    int nLength /* =-1 */)
{
    if (ptsz == NULL)
        return FALSE;

    return !IsBadStringPtr(ptsz, nLength);
}



BOOL
IsValidAddress(
    LPCVOID pv,
    UINT nBytes,
    BOOL fReadWrite /* =TRUE */)
{
    return (pv != NULL
            &&  !IsBadReadPtr(pv, nBytes)
            &&  (!fReadWrite  ||  !IsBadWritePtr((LPVOID) pv, nBytes)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\pagecnt\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\pagecnt\page.cpp ===
// Page.cpp: Implementation of CPage and CPageArray

#include "stdafx.h"
#include "page.h"
#include "debug.h"


//Default Constructor
CPage::CPage()
    : m_Hits(0)
{
}


// Is the URL the same as this page's?
BOOL CPage::operator==(BSTR bstrURL) const
{
    //case-insensitive comparison
    return (_wcsicmp(m_URL, bstrURL) == 0);
}


//Default Constructor
CPageArray::CPageArray()
    : m_iMax(0), m_cAlloc(0), m_aPages(NULL)
{
}


//Destructor
CPageArray::~CPageArray()
{
    delete [] m_aPages;
}


// non-const operator[]
CPage& CPageArray::operator[](UINT iPage)
{
    ASSERT(0 <= iPage  &&  iPage < (UINT) m_iMax);

    return m_aPages[iPage];
}


// const operator[]
const CPage& CPageArray::operator[](UINT iPage) const
{
    ASSERT(0 <= iPage  &&  iPage < (UINT) m_iMax);

    return m_aPages[iPage];
}


// Find a URL in the array and return its index, or -1 if it's not present.
int CPageArray::FindURL(const BSTR bstrURL) const
{
    for (int i = 0; i < m_iMax; i++)
        if (m_aPages[i] == bstrURL)
            return i;

    return -1;
}


//Add a page to the array (if it's not already present) and
//increase its hitcount by ExtraHits.
UINT CPageArray::AddPage(const BSTR bstrURL, UINT ExtraHits)
{
    int i = FindURL(bstrURL);

    if (i >= 0)
    {
        // There are no duplicate URLs in this array; just adjust m_Hits
        ASSERT(i < m_iMax);
        m_aPages[i].m_Hits += ExtraHits;
    }
    else
    {
        // Not present, so append it
        ASSERT(0 <= m_iMax  &&  m_iMax <= m_cAlloc);
    
        if (m_iMax == m_cAlloc)
        {
            // grow the array because it's full
            CPage* pOldPages = m_aPages;
            m_cAlloc += CHUNK_SIZE;

            m_aPages = NULL;
            ATLTRY(m_aPages = new CPage[m_cAlloc]);
            
            if (m_aPages == NULL)
            {
                m_aPages = pOldPages;
                return BAD_HITS;
            }
            
            for (i = 0; i < m_iMax; i++)
                m_aPages[i] = pOldPages[i];

            delete [] pOldPages;
        }

        i = m_iMax++;
        m_aPages[i].m_URL  = bstrURL;
        m_aPages[i].m_Hits = ExtraHits;
    }

    return m_aPages[i].GetHits();
}


//Increment a page's hitcount by one
UINT CPageArray::IncrementPage(const BSTR bstrURL)
{
    // If the page is present, just add one to its count;
    // if it's not present, append it and set its count to one.
    return AddPage(bstrURL, 1);
}


//Get a page's hitcount
UINT CPageArray::GetHits(const BSTR bstrURL)
{
    const int i = FindURL(bstrURL);

    if (i >= 0)
    {
        ASSERT(i < m_iMax);
        return m_aPages[i].GetHits();
    }
    else
    {
        // Not present, so append it and zero its hitcount
        return AddPage(bstrURL, 0);
    }
}


//Reset a page's hitcount
void CPageArray::Reset(const BSTR bstrURL)
{
    const int i = FindURL(bstrURL);

    if (i >= 0)
    {
        ASSERT(i < m_iMax);
        m_aPages[i].ResetHits();
    }
    else
    {
        // Not present, so append it and zero its hitcount
        AddPage(bstrURL, 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\pagecnt\pgcnt.cpp ===
// PgCnt.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this 
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f PgCntps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "PgCnt.h"
#include "PgCntObj.h"
#include "ccm.h"
#include "debug.h"
#include "Monitor.h"
#include "Lock.h"

#define IID_DEFINED
#include "PgCnt_i.c"


CPgCntModule _Module;

//Declare Global CCM Object
CCM CountManager;

/////////////////////////////////////////////////////////////////////////////
//  CPgCntModule methods
//
CPgCntModule::CPgCntModule()
    :   m_pMonitor(NULL)
{
}

void
CPgCntModule::Init(
    _ATL_OBJMAP_ENTRY*  p,
    HINSTANCE           h )
{
    _ASSERT( m_pMonitor == NULL);
    m_pMonitor = new CMonitor();
    
    CComModule::Init(p,h);
}

void
CPgCntModule::Term()
{
    _ASSERT( m_pMonitor != NULL);
    delete m_pMonitor;
    m_pMonitor = NULL;

    CComModule::Term();
}

LONG
CPgCntModule::Lock()
{
    _ASSERT( m_pMonitor != NULL );
    return CComModule::Lock();
}

LONG
CPgCntModule::Unlock()
{
	LONG lc;
	CLock l(m_cs);
	if ( ( lc = CComModule::Unlock() ) == 0 )
	{
		// final unlock
		_ASSERT( m_pMonitor != NULL );
        m_pMonitor->StopAllMonitoring();
	}
	return lc;
}


CMonitor*
CPgCntModule::Monitor()
{
    _ASSERT( m_pMonitor != NULL );
    return m_pMonitor;
}


BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_PageCounter, CPgCntObj)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
	DEBUG_START;
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
        DEBUG_INIT();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        DEBUG_TERM();
        _Module.Term();

        //Persist Page Hits Information
        CountManager.Persist();
	DEBUG_STOP;
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	if (_Module.GetLockCount() == 0)
	{
		CountManager.Persist();
		return S_OK;
	}
	else
		return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    //Add Registry Value for File_Location & Save_Count
            
    CRegKey regKey;
    LONG retVal = regKey.Create(HITCNT_HKEY, HITCNT_KEYNAME);

    ATLTRACE(_T("Create = %x\n"), retVal);

    //Set the Default File_Location
    if (retVal == ERROR_SUCCESS)
    {
        retVal = RegSetValueEx(
            regKey,
            HITCNT_FILELOCN,
            0,
            REG_EXPAND_SZ,
            (LPBYTE)HITCNT_DFLT_FILE,
            (_tcslen(HITCNT_DFLT_FILE)+1)*sizeof(TCHAR));
        ATLTRACE(_T("Set %s %s = %x\n"),
                 HITCNT_FILELOCN, HITCNT_DFLT_FILE, retVal);
    }
    
    //Set the Default Save_Cnt
    if (retVal == ERROR_SUCCESS)
    {
        const DWORD SaveCount = HITCNT_DFLT_SAVE;
        retVal = RegSetValueEx(
            regKey,
            HITCNT_SAVECNT,
            0,
            REG_DWORD,
            (LPBYTE)&SaveCount,
            sizeof(DWORD));
        ATLTRACE(_T("Set %s %d = %x\n"), HITCNT_SAVECNT, SaveCount, retVal);
    }
    
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\pagecnt\pgcntobj.cpp ===
// PgCntObj.cpp : Implementation of CPgCntObj

#include "stdafx.h"
#include "PgCnt.h"
#include "PgCntObj.h"

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CPgCntObj::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_IPgCntObj,
    };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}


///////////// Custom Component Methods ////////////////

STDMETHODIMP CPgCntObj::Hits (/*in,optional*/ VARIANT varURL,
                            /*out,retval*/  LONG* plNumHits)  
{   
    //Check the parameters
    if (plNumHits == NULL)
        return E_POINTER;

    // if the optional URL isn't empty, use that; otherwise, use the
    // one for this page
    if (V_VT(&varURL) != VT_ERROR)
    {
		VARIANT varBstrURL;
        VariantInit(&varBstrURL);
		HRESULT hr = VariantChangeType(&varBstrURL, &varURL, 0, VT_BSTR);
		if (FAILED(hr))
			return hr;

        *plNumHits = CountManager.GetHits(V_BSTR(&varBstrURL));

		VariantClear(&varBstrURL);
    }
    else
    {
        CComVariant vtPathInfo;
        if ( GetPathInfo( vtPathInfo ) )
        {
            *plNumHits = CountManager.GetHits(vtPathInfo.bstrVal);
        }
        else
        {
            return E_FAIL;
        }
    }
    
    return S_OK;
}

STDMETHODIMP CPgCntObj::Reset (/*in,optional*/ VARIANT varURL)
{
    ATLTRACE(_T("Reset Called\n"));
    
    // if the optional URL isn't empty, use that; otherwise, use the
    // one for this page
    if (V_VT(&varURL) != VT_ERROR)
    {
		/* For some reason VariantChangeType refused to work in this function,
		 * returning DISP_E_BADVARTYPE for VT_BSTR!  Go figure.
		 */
		if (V_VT(&varURL) == VT_BSTR)
			CountManager.Reset(V_BSTR(&varURL));
			
		else if (V_VT(&varURL) == (VT_BSTR | VT_BYREF))
			CountManager.Reset(*V_BSTRREF(&varURL));

		else
			return DISP_E_TYPEMISMATCH;
    }
    else
    {
        CComVariant vtPathInfo;
        if ( GetPathInfo( vtPathInfo ) )
        {
            CountManager.Reset(vtPathInfo.bstrVal);
        }
        else
        {
            return E_FAIL;
        }
    }

    return S_OK;
}


STDMETHODIMP CPgCntObj::PageHit(
    LONG*   plNumHits )
{
    CComVariant vtPathInfo;
    if ( GetPathInfo( vtPathInfo ) )
    {
        //Increment Count for this Page by Passing PATH_INFO to the CountManager
        *plNumHits = CountManager.IncrementAndGetHits(vtPathInfo.bstrVal);

        //Check for Error
        if (*plNumHits == 0)
        {
            ATLTRACE( _T("Error in page counter\n") );
            return E_FAIL;
        }
        else
        {
            ATLTRACE( _T("Page hits: %d\n"), *plNumHits );
        }
    }
	return S_OK;
}

// retrieves path information using the current object context
bool
CPgCntObj::GetPathInfo(
    CComVariant&    rvt )
{
    bool rc = false;

	CContext cxt;
	if ( !FAILED( cxt.Init( CContext::get_Request ) ) )
	{
        HRESULT hr;

        //Get the ServerVariables Collection
        CComPtr<IRequestDictionary> piServerVariables;
        hr = cxt.Request()->get_ServerVariables(&piServerVariables);

        if (FAILED(hr))
        {
            ATLTRACE(_T("Couldn't get ServerVariables\n"));
            return rc;
        }

        //Get the PATH_INFO item from the ServerVariables collection
        CComVariant vtIn(OLESTR("PATH_INFO")), vtOut;
        hr = piServerVariables->get_Item(vtIn, &vtOut);

        if (FAILED(hr))
        {
            ATLTRACE(_T("Couldn't get PATH_INFO\n"));
            return rc;
        }

        // vtOut Contains an IDispatch Pointer.  To fetch the value
        // for PATH_INFO, you must get the Default Value for the 
        // Object stored in vtOut using VariantChangeType.
        hr = VariantChangeType(&rvt, &vtOut, 0, VT_BSTR);
  
        if (FAILED(hr))
        {
            return rc;
        }
        else
        {
            rc = true;
        }
    }
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\permchk\context.cpp ===
#include "stdafx.h"
#include "..\shared\src\context.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\permchk\mem.cpp ===
#include "stdafx.h"
#include "..\shared\src\mem.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\pagecnt\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PgCnt.rc
//
#define IDS_PGCNTOBJ_DESC	1



// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\pagecnt\page.h ===
#ifndef __PAGE__
#define __PAGE__

// CPage: remember the URL of a page and the number of hits it's received
class CPage {

public:

    CPage();

    UINT GetHits() const            { return m_Hits; }
    UINT IncrementHits()            { return ++m_Hits; }
    void ResetHits()                { m_Hits = 0; }

    const CComBSTR& GetURL() const  { return m_URL; }
    BOOL operator==(BSTR bstrURL) const;

public:
    CComBSTR m_URL;                 //URL for this page
    UINT     m_Hits;                //Number of hits for this page

private:
    
    //Not Implemented 
    CPage(CPage& copy);             //copy constructor

};

#define BAD_HITS ((UINT) -1)


// CPageArray: a dynamic array of CPages
class CPageArray
{
public:
    CPageArray();
    ~CPageArray();

    CPage& operator[](UINT iPage);
    const CPage& operator[](UINT iPage) const;

    int  FindURL(const BSTR bstrURL) const;
    UINT AddPage(const BSTR bstrURL, UINT Hits);
    UINT IncrementPage(const BSTR bstrURL);
    UINT GetHits(const BSTR bstrURL);
    void Reset(const BSTR bstrURL);
    UINT Size() const               {return m_iMax;}

private:
    enum {CHUNK_SIZE = 200};
    
    int     m_iMax;         // current max index
    int     m_cAlloc;       // number of CPages in m_aPages
    CPage*  m_aPages;       // array of CPages

    //not implemented
    CPageArray(CPageArray& copy);                   //copy constructor
    CPageArray& operator=(const CPageArray& copy);  //assignment operator
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\permchk\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\permchk\chkobj.cpp ===
// ChkObj.cpp : Implementation of CPermChkApp and DLL registration.

#include "stdafx.h"
#include <new>
#include "PermChk.h"
#include "ChkObj.h"
#include "util.h"
#include "context.h"

////////////////////////////////////////////////////////////////
//
// Utility functions

//
// Try to open file to see if read access is allowed
//

static VARIANT_BOOL DoesUserHaveAccessToFile(LPCTSTR ptszFilename)
{
    HANDLE hFile = 
        ::CreateFile(ptszFilename, GENERIC_READ, FILE_SHARE_READ,
                     NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                     NULL);
    if (hFile == INVALID_HANDLE_VALUE)
        return VARIANT_FALSE;
    ::CloseHandle(hFile);
    return VARIANT_TRUE;
}

static VARIANT_BOOL DoesUserHaveAccessToFile(BSTR bstrFilename)
{
    USES_CONVERSION;    // needed for OLE2T
    LPCTSTR ptszFilename = OLE2T(bstrFilename);
    return DoesUserHaveAccessToFile(ptszFilename);
}

////////////////////////////////////////////////////////////////
//

//
//

CPermissionChecker::CPermissionChecker()
{
}

//
//

CPermissionChecker::~CPermissionChecker()
{
}

//
//  Generated by ATL wizard
//

STDMETHODIMP CPermissionChecker::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_IPermissionChecker,
    };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}


//
// Checks the persmissions for the context user to access
// a page, or a file
//

STDMETHODIMP CPermissionChecker::HasAccess(
    BSTR bstrLocalUrl,
    VARIANT_BOOL *pfRetVal)
{
	HRESULT rc = E_FAIL;

	try
	{
		if (bstrLocalUrl == NULL || pfRetVal == NULL)
			return ::ReportError(E_POINTER);

		*pfRetVal = VARIANT_FALSE;

		CContext cxt;
		if ( cxt.Init( CContext::get_Server ) != S_OK )
		{
			return ::ReportError( E_NOINTERFACE );
		}

		// Map logical filename to a physical filesystem name
		CComBSTR bstrPhysicalFile;
		HRESULT  hr = cxt.Server()->MapPath(bstrLocalUrl, &bstrPhysicalFile);

		if (SUCCEEDED(hr))
			*pfRetVal = ::DoesUserHaveAccessToFile(bstrPhysicalFile);
		else // failed to map as URL, try as regular path
			*pfRetVal = ::DoesUserHaveAccessToFile(bstrLocalUrl);

	    rc = S_OK;
	}
	catch( std::bad_alloc &)
	{
		rc = E_OUTOFMEMORY;
	}
	catch( ... )
	{
		rc = E_FAIL;
	}
	return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\pagecnt\pgcntobj.h ===
// PgCntObj.h : Declaration of the CPgCntObj


#include "resource.h"       // main symbols
#include <asptlb.h>         // Active Server Pages Definitions
#include "ccm.h"            // Central Counter Manager Definition
#include "context.h"


/////////////////////////////////////////////////////////////////////////////
// PgCnt

class CPgCntObj : 
    public CComDualImpl<IPgCntObj, &IID_IPgCntObj, &LIBID_PageCounter>, 
    public ISupportErrorInfo,
    public CComObjectRoot,
    public CComCoClass<CPgCntObj,&CLSID_PageCounter>
{
public:
DECLARE_GET_CONTROLLING_UNKNOWN()

    CPgCntObj()
    { 
    }

    ~CPgCntObj() {}

BEGIN_COM_MAP(CPgCntObj)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPgCntObj)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()
	// for free-threaded marshalling
	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p );
	}
	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

//DECLARE_NOT_AGGREGATABLE(CPgCntObj) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

    DECLARE_REGISTRY(CPgCntObj, _T("MSWC.PageCounter.1"),
                     _T("MSWC.PageCounter"), IDS_PGCNTOBJ_DESC,
                     THREADFLAGS_BOTH)

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IPgCntObj
public:

    //Custom Component Methods
	STDMETHOD(PageHit)(LONG* plNumHits);
    STDMETHOD (Hits)  (VARIANT varURL, LONG* plNumHits);
    STDMETHOD (Reset) (VARIANT varURL);

private:
    bool GetPathInfo( CComVariant& rvt );
	CComPtr<IUnknown>		m_pUnkMarshaler;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\pagecnt\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
#pragma once
#ifndef _STDAFX_H_
#define _STDAFX_H_

#define STRICT

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CMonitor;
class CPgCntModule : public CComModule
{
public:
                CPgCntModule();

    // CComModule methods
    void        Init( _ATL_OBJMAP_ENTRY*, HINSTANCE );
    void        Term();
    LONG        Lock();
    LONG        Unlock();

    // CPgCntModule methods
    CMonitor*   Monitor();

private:
    CComAutoCriticalSection m_cs;
    CMonitor*               m_pMonitor;
};

extern CPgCntModule _Module;
#include <atlcom.h>
#include <mtx.h>

#include <algorithm>
using namespace std;

#include "myvector.h"
#include "MyString.h"
#include "strmap.h"
#include "mydebug.h"

#define ARRAYSIZE(a)	(sizeof(a)/sizeof(*(a)))

#endif  // !_STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\permchk\chkobj.h ===
// ChkObj.h : Declaration of the CPermissionChecker


#include "resource.h"       // main symbols
#include <asptlb.h>

/////////////////////////////////////////////////////////////////////////////
// PermChk

class CPermissionChecker : 
    public CComDualImpl<IPermissionChecker, &IID_IPermissionChecker, &LIBID_PermissionChecker>, 
    public ISupportErrorInfo,
    public CComObjectRoot,
    public CComCoClass<CPermissionChecker,&CLSID_PermissionChecker>
{
public:
    CPermissionChecker();
    ~CPermissionChecker();

BEGIN_COM_MAP(CPermissionChecker)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPermissionChecker)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

//DECLARE_NOT_AGGREGATABLE(CPermissionChecker) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CPermissionChecker, 
                 _T("MSWC.PermissionChecker.1"), 
                 _T("MSWC.PermissionChecker"),
                 IDS_PERMCHK_DESC,
                 THREADFLAGS_BOTH)

// support for free-threaded marshaling
DECLARE_GET_CONTROLLING_UNKNOWN()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p );
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}


// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IPermissionChecker
public:
    STDMETHOD(HasAccess)(BSTR bstrLocalUrl, 
                         VARIANT_BOOL *pfRetVal);
    
private:
	CComPtr<IUnknown>	m_pUnkMarshaler;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\permchk\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PermChk.rc
//
#define IDS_PERMCHK_DESC	1



// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\permchk\permchk.cpp ===
// PermChk.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this 
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f PermChkps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "PermChk.h"
#include "ChkObj.h"

#define IID_DEFINED
#include "PermChk_i.c"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_PermissionChecker, CPermissionChecker)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\permchk\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <mtx.h>
#include <xstddef>
#include "mydebug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\permchk\util.h ===
// Util.h : Header for utility functions used by control code

#ifndef __UTIL_H__
#define __UTIL_H__

HRESULT ReportError(DWORD dwErr);
HRESULT ReportError(HRESULT hr);

#endif /* __UTIL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\permchk\util.cpp ===
// Util.cpp : Utility functions used by control code

#include "stdafx.h"
#include "PermChk.h"
#include "util.h"

//
//

static HRESULT ReportError(HRESULT hr, DWORD dwErr)
{
    HLOCAL pMsgBuf = NULL;

    // If there's a message associated with this error, report that
    if (FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL, dwErr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &pMsgBuf, 0, NULL)
        > 0)
    {
        AtlReportError(CLSID_PermissionChecker,
			           (LPCTSTR) pMsgBuf,
                       IID_IPermissionChecker, hr);
    }

    // Free the buffer, which was allocated by FormatMessage
    if (pMsgBuf != NULL)
        ::LocalFree(pMsgBuf);
    return hr;
}

//
// Report a Win32 error code
//

HRESULT ReportError(DWORD dwErr)
{
    return ReportError(HRESULT_FROM_WIN32(dwErr), dwErr);
}

//
// Report an HRESULT error
//

HRESULT ReportError(HRESULT hr)
{
    return ReportError(hr, (DWORD) hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\inc\context.h ===
/*++

	Copyright	(c)    1997    Microsoft Corporation

	Module  Name :

		context.h

	Abstract:
		A class to retrieve and release ASP intrinsics

	Author:

		Neil Allain	  ( a-neilal )	   August-1997 

	Revision History:

--*/
#pragma once
#ifndef _CONTEXT_H_
#define _CONTEXT_H_

class CContext
{
public:
	enum {
		get_Server		= 0x0001,
		get_Response	= 0x0002,
		get_Request		= 0x0004,
		get_Session		= 0x0008,
		get_Application	= 0x0010
	};
	
	HRESULT	            Init( DWORD );

	IRequest*			Request(){ _ASSERT(m_piRequest!=NULL); return m_piRequest; }
	IResponse*			Response(){ _ASSERT(m_piResponse!=NULL); return m_piResponse; }
	ISessionObject*		Session(){ _ASSERT(m_piSession!=NULL); return m_piSession; }
	IServer*			Server(){ _ASSERT(m_piServer!=NULL); return m_piServer; }
	IApplicationObject*	Application(){ _ASSERT(m_piApplication!=NULL); return m_piApplication; }

	static HRESULT		GetServerObject( IGetContextProperties*, BSTR, const IID&, void** );

private:
	CComPtr<IRequest>			m_piRequest;			//Request Object
	CComPtr<IResponse>			m_piResponse;			//Response Object
	CComPtr<ISessionObject>		m_piSession;			//Session Object
	CComPtr<IServer>			m_piServer;				//Server Object
	CComPtr<IApplicationObject> m_piApplication;		//Application Object
};


#endif	// !_CONTEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\inc\finstrm.h ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       FInStrm.h

   Abstract:
		A lightweight implementation of input streams using files

   Author:

       Neil Allain    ( a-neilal )     August-1997 

   Revision History:

--*/
#pragma once
#include "InStrm.h"

class FileInStream : public InStream
{
public:
						FileInStream();
						FileInStream( LPCTSTR );
						~FileInStream();
	virtual	HRESULT		readChar( _TCHAR& );
	virtual	HRESULT		read( CharCheck&, String& );
	virtual	HRESULT		skip( CharCheck& );
	virtual HRESULT		back( size_t );
			bool		is_open() const { return m_bIsOpen; }
			HANDLE		handle() const { return m_hFile; }
            bool        is_UTF8() const { return m_bIsUTF8; }

private:
	HANDLE	m_hFile;
	bool	m_bIsOpen;
    bool    m_bIsUTF8;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\inc\instrm.h ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       InStrm.h

   Abstract:
		A lightweight implementation of input streams.  This class provides
		the interface, as well as a basic skeleton for input streams.

   Author:

       Neil Allain    ( a-neilal )     August-1997 

   Revision History:

--*/
#pragma once

#include "MyString.h"

struct CharCheck
{
	virtual	bool	operator()( _TCHAR )=0;
};

struct IsWhiteSpace : public CharCheck
{
	virtual	bool	operator()( _TCHAR );
};

struct IsNewLine : public CharCheck
{
	virtual	bool	operator()( _TCHAR );
};

class InStream
{
public:
	enum{
		EndOfFile = E_FAIL
	};

						InStream();
							
			bool		eof() const { return m_bEof; }
			HRESULT		lastError() const { return m_lastError; }
	virtual	HRESULT		skip( CharCheck& )=0;
	virtual HRESULT		back( size_t )=0;
	virtual HRESULT		read( CharCheck&, String& )=0;
	virtual	HRESULT		readChar( _TCHAR& )=0;
	virtual	HRESULT		readInt16( SHORT& );
	virtual	HRESULT		readInt( int& );
	virtual	HRESULT		readInt32( LONG& );
	virtual	HRESULT		readUInt32( ULONG& );
	virtual	HRESULT		readFloat( float& );
	virtual	HRESULT		readDouble( double& );
	virtual	HRESULT		readString( String& );
	virtual	HRESULT		readLine( String& );
	virtual	HRESULT		skipWhiteSpace();
			
			InStream&	operator>>( _TCHAR& );
			InStream&	operator>>( SHORT& );
			InStream&	operator>>( int& );
			InStream&	operator>>( LONG& );
			InStream&	operator>>( ULONG& );
			InStream&	operator>>( float& );
			InStream&	operator>>( double& );
			InStream&	operator>>( String& );
	
protected:
			void		setLastError( HRESULT );
private:
	bool	m_bEof;
	HRESULT	m_lastError;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\inc\lock.h ===
// lock.h : locking classes for BrowserCap

#pragma once

#ifndef _LOCK_H_
#define _LOCK_H_

// a lockable map template
template< class T >
class TSafeStringMap : public TStringMap<T>, public CComAutoCriticalSection
{
};

template< class T >
class TSafeVector : public TVector<T>, public CComAutoCriticalSection
{
};

// a stack-based auto-lock template
template< class T >
class TLock
{
public:

	TLock( T& t )
		:	m_t( t )
	{
		m_t.Lock();
	}
	~TLock()
	{
		m_t.Unlock();
	}
private:
	T&	m_t;
};

typedef TLock<CComAutoCriticalSection>	CLock;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\inc\monitor.h ===
#pragma once

#ifndef _MONITOR_H_
#define _MONITOR_H_

#include "RefCount.h"
#include "RefPtr.h"
#include "MyString.h"


#undef STRING_TRACE_LOG

#ifdef STRING_TRACE_LOG
# include <strlog.hxx>
# define STL_PRINTF      m_stl.Printf
# define STL_PUTS(s)     m_stl.Puts(s)
#else
# define STL_PRINTF
# define STL_PUTS(s)
#endif

// a client supplies it's own derviation of CMonitorNotify to the monitor.
// the notify method is called when the monitored object has changed
class CMonitorNotify : public CRefCounter
{
public:
    virtual void    Notify() = 0;
};

typedef TRefPtr<CMonitorNotify> CMonitorNotifyPtr;

// the base object of anything that can be monitored
class CMonitorNode : public CRefCounter
{
public:
    virtual void    Notify() = 0;
    virtual HANDLE  NotificationHandle() const = 0;
};

typedef TRefPtr<CMonitorNode> CMonitorNodePtr;

// since we can only monitor directories, the file class,
// preserves information about each file in a particular
// directory
class CMonitorFile : public CRefCounter
{
public:
                            CMonitorFile( const String&, const CMonitorNotifyPtr& );
            bool            CheckNotify();
            const String&  FileName() const;

private:
    virtual                 ~CMonitorFile();
            bool            GetFileTime( FILETIME& );


    FILETIME            m_ft;
    const String       m_strFile;
    CMonitorNotifyPtr   m_pNotify;
};

typedef TRefPtr<CMonitorFile> CMonitorFilePtr;

// an implementaiton of CMonitorNode's interface for montioring directories
class CMonitorDir : public CMonitorNode
{
public:
                            CMonitorDir( const String& );

        // CMonitorNode interface
    virtual void            Notify();
    virtual HANDLE          NotificationHandle() const;

            void            AddFile( const String&, const CMonitorNotifyPtr& );
            void            RemoveFile( const String& );
            const String&  Dir() const;
            ULONG           NumFiles() const;
private:
    virtual                 ~CMonitorDir();

    const String				m_strDir;
    TVector<CMonitorFilePtr>	m_files;
    HANDLE						m_hNotification;

};

DECLARE_REFPTR(CMonitorDir,CMonitorNode);


// an implementation of CMonitorNode's interface for monitoring a registry key
class CMonitorRegKey : public CMonitorNode
{
public:
                            CMonitorRegKey( HKEY, const String&, const CMonitorNotifyPtr& );

        // CMonitorNode interface
    virtual void            Notify();
    virtual HANDLE          NotificationHandle() const;

        // CMonitorRegKey interface
    const String&          m_strKey;
    const HKEY              m_hBaseKey;

private:
    virtual                 ~CMonitorRegKey();

    HKEY                    m_hKey;
    HANDLE                  m_hEvt;
    CMonitorNotifyPtr       m_pNotify;
};

DECLARE_REFPTR(CMonitorRegKey, CMonitorNode);

// the main monitoring object
class CMonitor
{
public:
                        CMonitor();
                        ~CMonitor();
            void        MonitorFile( LPCTSTR, const CMonitorNotifyPtr& );
            void        StopMonitoringFile( LPCTSTR );
            void        MonitorRegKey( HKEY, LPCTSTR, const CMonitorNotifyPtr& );
            void        StopMonitoringRegKey( HKEY, LPCTSTR );
            void        StopAllMonitoring();

private:
    static  unsigned __stdcall ThreadFunc( void* );
            bool        StartUp();
            DWORD       DoMonitoring();

    TVector<CMonitorDirPtr>		m_dirs;
    TVector<CMonitorRegKeyPtr>	m_regKeys;

    CComAutoCriticalSection     m_cs;
    HANDLE                      m_hevtBreak;
    HANDLE                      m_hevtShutdown;
    HANDLE                      m_hThread;
    volatile bool               m_bRunning;
    volatile bool               m_bStopping;

#ifdef STRING_TRACE_LOG
public:
    CStringTraceLog             m_stl;
#endif
};

#endif // ! _MONITOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\inc\mydebug.h ===
#pragma once
#ifndef _MYDEBUG_H_
#define _MYDEBUG_H_
#include <malloc.h>

class _com_error;

#define THROW_IF_NULL(x) if ( x ) {} else throw _com_error(E_OUTOFMEMORY)

#ifdef DBG

#include <crtdbg.h>

#define THIS_FILE __FILE__
#define DEBUG_NEW	new(THIS_FILE, __LINE__)
#define DEBUG_START		DebugStart()
#define DEBUG_STOP		DebugStop()

void* __cdecl operator new( size_t s, const char* file, long line ) _THROW1(_com_error);

#if _MSC_VER >= 1200
void __cdecl operator delete(void *p, const char* file, long line) _THROW0();
#endif

void	DebugStart();
void	DebugStop();

#else	// !DBG

#define DEBUG_NEW	new
#define	DEBUG_START
#define	DEBUG_STOP

#endif	// #ifdef DBG


#endif	// #ifndef _MYDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\inc\rdwrt.h ===
// RdWrt.h
#pragma once

#ifndef _READWRITE_H_
#define _READWRITE_H_

// this class handles a single-writer, multi-reader threading model

class CReadWrite
{
public:
            CReadWrite();
            ~CReadWrite();

    void    EnterReader();
    void    ExitReader();
    void    EnterWriter();
    void    ExitWriter();

private:
    HANDLE              m_hevtNoReaders;
    HANDLE              m_hmtxWriter;
    HANDLE              m_handles[2];
    LONG                m_cReaders;
};

class CReader
{
public:
    CReader( CReadWrite& rw )
        :   m_rrw( rw )
    {
        m_rrw.EnterReader();
    }
    ~CReader()
    {
        m_rrw.ExitReader();
    }
private:
    CReadWrite& m_rrw;
};

class CWriter
{
public:
    CWriter( CReadWrite& rw )
        :   m_rrw( rw )
    {
        m_rrw.EnterWriter();
    }
    ~CWriter()
    {
        m_rrw.ExitWriter();
    }
private:
    CReadWrite& m_rrw;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\inc\outstrm.h ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       OutStrm.h

   Abstract:
		A lightweight interface of output streams.  This class provides
		the interface, as well as a basic skeleton for output streams.

   Author:

       Neil Allain    ( a-neilal )     August-1997 

   Revision History:

--*/
#pragma once

#include "MyString.h"

struct OutToken
{
	LONG	val;
};

struct EndLineToken : public OutToken
{
};

extern EndLineToken	endl;

class OutStream
{
public:
						OutStream();
	virtual				~OutStream();
			HRESULT		lastError() const { return m_lastError; }
	virtual	HRESULT		writeChar( _TCHAR )=0;
	virtual	HRESULT		writeString( LPCTSTR, size_t )=0;
	virtual	HRESULT		writeString( LPCTSTR );
	virtual	HRESULT		writeString( const String& );
	virtual HRESULT		writeLine( LPCTSTR, ... );
	virtual	HRESULT		writeInt16( SHORT );
	virtual HRESULT		writeInt( int );
	virtual	HRESULT		writeInt32( LONG );
	virtual	HRESULT		writeFloat( float );
	virtual	HRESULT		writeDouble( double );
	virtual HRESULT		writeToken( const OutToken& );
	virtual HRESULT		writeEolToken( const EndLineToken& );
	virtual	HRESULT		flush();
	
			OutStream&	operator<<( _TCHAR );
			OutStream&	operator<<( SHORT );
			OutStream&	operator<<( int );
			OutStream&	operator<<( LONG );
			OutStream&	operator<<( float );
			OutStream&	operator<<( double );
			OutStream&	operator<<( const String& );
			OutStream&	operator<<( LPCTSTR );
			OutStream&	operator<<( const OutToken& );
			OutStream&	operator<<( const EndLineToken& );
			
protected:
			void		setLastError( HRESULT );
private:
	HRESULT	m_lastError;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\inc\refcount.h ===
#ifndef _REFCOUNTER_H_
#define _REFCOUNTER_H_

//----------------------------------------------------------------------------
//
//	CRefCounter
//
//	This class is supplementary to the TRefPtr template.  It provides an
//	easy way to mix in reference counting properties with other classes
//
//	Note that the destructor is protected.  It must be protected so derivatives
//	can use it, but derivatives should not have a public destructor (since
//	this violates the reference counting pattern)
//
//---------------------------------------------------------------------------
class CRefCounter
{
public:
	CRefCounter();

	void AddRef();
	void Release();

protected:
	virtual ~CRefCounter();

private:
	long m_lRefCount;
};

inline
CRefCounter::CRefCounter()
	:	m_lRefCount(0)
{}

inline
CRefCounter::~CRefCounter()
{
	_ASSERT( m_lRefCount == 0 );
}

inline void
CRefCounter::AddRef()
{
	::InterlockedIncrement( &m_lRefCount );
}

inline void
CRefCounter::Release()
{
	if ( ::InterlockedDecrement( &m_lRefCount ) == 0 )
	{
		delete this;
	}
}
#endif	// !_REFCOUNTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\inc\sinstrm.h ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       SInStrm.h

   Abstract:
		A lightweight implementation of input streams using strings

   Author:

       Neil Allain    ( a-neilal )     August-1997 

   Revision History:

--*/
#pragma once
#include "InStrm.h"

class StringInStream : public InStream, public BaseStringBuffer
{
public:
					StringInStream( const String& );
	virtual	HRESULT	readChar( _TCHAR& );
	virtual	HRESULT	read( CharCheck&, String& );
	virtual	HRESULT	skip( CharCheck& );
	virtual	HRESULT	back( size_t );
	
private:
	LPTSTR	m_pos;
	LPTSTR	m_end;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\inc\refptr.h ===
#ifndef _REFPTR_H_
#define _REFPTR_H_

/////////////////////////////////////////////////////////////////////////////
//
//	TRefPtr
//
//	This ref pointer template is useful for any objects that are referenced
//	multiple times.
//
//	The ref pointer depends on AddRef and Release being defined in the class
//	type T. ( AddRef should increment a reference counter, release should
//	decrement it and delete itself if the count is 0).  AddRef is called
//	upon construction and Release is called upon destruction.  Much care should
//	go into defining AddRef and Release if the smart pointer is used across
//	thread boundaries, since smart pointer don't force thread-safety.  In
//	particular, an object could get deleted twice if smart pointers in
//	seperate threads release it at the same time.
//
/////////////////////////////////////////////////////////////////////////////
template< class T >
class TRefPtr
{
public:
	TRefPtr();
	TRefPtr( T* pT );
	TRefPtr( const TRefPtr<T>& sp );
	~TRefPtr();

	T&			operator*();
	const T&	operator*() const;
	T*			operator->();
	const T*	operator->() const;

	TRefPtr<T>& operator=(const TRefPtr<T>&);
	bool	IsValid();
	T*		Get(){ return m_pT; }
	const T* Get() const { return m_pT; }
	void	Set( T* );
 	bool	operator==( const TRefPtr<T>& sp ) const;
 	bool	operator!=( const TRefPtr<T>& sp ) const;
	bool	operator<( const TRefPtr<T>& sp ) const;
	bool	operator>( const TRefPtr<T>& sp ) const;

//    template<class newType>
//    operator TRefPtr<newType>()
//    {
//        return TRefPtr<newType>(m_pT);
//    }

protected:
	T*		m_pT;
};

template< class T >
TRefPtr<T>::TRefPtr<T>()
	:	m_pT( NULL )
{
}

template< class T >
TRefPtr<T>::TRefPtr<T>(
	T*	pT )
	:	m_pT( pT )
{
	if ( m_pT )
	{
		m_pT->AddRef();
	}
}

template< class T >
TRefPtr<T>::TRefPtr<T>(
	const TRefPtr<T>&	sp )
	: m_pT( sp.m_pT )
{
	if ( m_pT )
	{
		m_pT->AddRef();
	}
}

template< class T >
TRefPtr<T>::~TRefPtr<T>()
{
	if ( m_pT )
	{
		m_pT->Release();
	}
}

template< class T >
void
TRefPtr<T>::Set(
	T*	pT )
{
	if ( m_pT )
	{
		m_pT->Release();
	}

	m_pT = pT;

	if ( m_pT )
	{
		m_pT ->AddRef();
	}
}

template< class T >
T&
TRefPtr<T>::operator*()
{
	return *m_pT;
}

template< class T >
const T&
TRefPtr<T>::operator*() const
{
	return *m_pT;
}

template< class T >
T*
TRefPtr<T>::operator->()
{
	return m_pT;
}

template< class T >
const T*
TRefPtr<T>::operator->() const
{
	return m_pT;
}

template< class T >          
bool                         
TRefPtr<T>::operator==(    
	const TRefPtr<T>& sp ) const
{                            
	return ( m_pT == sp.m_pT ); 
}                            

template< class T >          
bool                         
TRefPtr<T>::operator!=(    
	const TRefPtr<T>& sp ) const
{                            
	return ( m_pT != sp.m_pT ); 
}                            

template< class T >
bool
TRefPtr<T>::operator<(
	const TRefPtr<T>& sp ) const
{
	return ( (long)m_pT < (long)sp.m_pT );
}
                             
template< class T >
bool
TRefPtr<T>::operator>(
	const TRefPtr<T>& sp ) const
{
	return ( (long)m_pT > (long)sp.m_pT );
}
                             

template< class T >
TRefPtr<T>&
TRefPtr<T>::operator=(const TRefPtr<T>& rhs)
{
	if ( m_pT )
	{
		m_pT->Release();
	}

	m_pT = rhs.m_pT;

	if ( m_pT )
	{
		m_pT->AddRef();
	}

	return *this;
}

template< class T >
bool
TRefPtr<T>::IsValid()
{
	return ( m_pT != NULL );
}

// This macro helps solve the up-casting problems associated with smart pointers
// If you have class B inheriting from class A.  Then you can do the following
// typedef TRefPtr<A> APtr;
// DECLARE_REFPTR( B, A )
// Now you have can safe cast a BPtr to an APtr (BPtr is derived from APtr)

#define DECLARE_REFPTR( iclass, bclass ) \
class iclass##Ptr : public bclass##Ptr                                      \
{                                                                           \
public:                                                                     \
	                        iclass##Ptr()                                   \
                            : bclass##Ptr(){};                              \
                      	    iclass##Ptr( iclass * pT )                      \
                            : bclass##Ptr(pT){};                            \
                    	    iclass##Ptr( const iclass##Ptr & sp )           \
                            : bclass##Ptr(sp){};                            \
                                                                            \
	iclass &                operator*()                                     \
                            { return *((iclass *)m_pT); };                  \
  	const iclass &          operator*() const                               \
                            { return *((const iclass *)m_pT); };            \
	iclass *  	            operator->()                                    \
                            { return (iclass *)m_pT; };                     \
	const iclass *          operator->() const                              \
                            { return (const iclass *)m_pT; };               \
	iclass *                Get()                                           \
                            { return (iclass *)m_pT; };                     \
};

#endif	// !_SMARTPTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\inc\myvector.h ===
#pragma once
#ifndef _MYVECTOR_H_
#define _MYVECTOR_H_

#include <new>

template< class T >
class TVector
{
public:	
	typedef T&			reference;
	typedef const T&	const_reference;

// iterators
	typedef T*			iterator;
	typedef const T*	const_iterator;
	class const_reverse_iterator;

	class reverse_iterator
	{
	public:
							reverse_iterator() : m_iter(NULL) {}
		explicit			reverse_iterator( iterator iter ) : m_iter( iter ) {}

		reverse_iterator&	operator++() { --m_iter; return *this;}
		reverse_iterator	operator++(int) { return reverse_iterator(m_iter--); }
		reverse_iterator&	operator--() { ++m_iter; return *this;}
		reverse_iterator	operator--(int) { return reverse_iterator(m_iter++); }
		reverse_iterator	operator+(size_t s) const { return reverse_iterator(m_iter - s); }
		reverse_iterator	operator-(size_t s) const { return reverse_iterator(m_iter + s); }
		reverse_iterator&	operator+=(size_t s) { m_iter -= s; return *this; }
		reverse_iterator&	operator-=(size_t s) { m_iter += s; return *this; }
		bool				operator==( iterator iter ) const { return ( m_iter == iter ); }
		bool				operator!=( iterator iter ) const { return ( m_iter != iter ); }
		reference			operator*() const { return *m_iter; }
	private:
		iterator			m_iter;
		friend				const_reverse_iterator;
	};					

	class const_reverse_iterator
	{
	public:
								const_reverse_iterator() : m_iter(NULL) {}
								const_reverse_iterator( const reverse_iterator& riter ) : m_iter( riter.m_iter ) {}
		explicit				const_reverse_iterator( const_iterator iter ) : m_iter( iter ) {}

		const_reverse_iterator&	operator++() { --m_iter; return *this;}
		const_reverse_iterator	operator++(int) { return const_reverse_iterator(m_iter--); }
		const_reverse_iterator&	operator--() { ++m_iter; return *this;}
		const_reverse_iterator	operator--(int) { return const_reverse_iterator(m_iter++); }
		const_reverse_iterator	operator+(size_t s) const { return const_reverse_iterator(m_iter - s); }
		const_reverse_iterator	operator-(size_t s) const { return const_reverse_iterator(m_iter + s); }
		const_reverse_iterator&	operator+=(size_t s) { m_iter -= s; return *this; }
		const_reverse_iterator&	operator-=(size_t s) { m_iter += s; return *this; }
		bool					operator==( iterator iter ) const { return ( m_iter == iter ); }
		bool					operator!=( iterator iter ) const { return ( m_iter != iter ); }
		const_reference			operator*() const { return *m_iter; }

	private:
		const_iterator			m_iter;
	};					

// constructor / destructor
	TVector();
	~TVector();

// iteration
	iterator				begin(){ return m_pFirst; }
	const_iterator			begin() const { return m_pFirst; }
	iterator				end() { return m_pAfterLast; }
	const_iterator			end() const { return m_pAfterLast; }
	reverse_iterator		rbegin() { return reverse_iterator(m_pAfterLast-1); }
	const_reverse_iterator	rbegin() const { return const_reverse_iterator(m_pAfterLast-1); }
	reverse_iterator		rend() { return reverse_iterator(m_pFirst-1); }
	const_reverse_iterator	rend() const { return const_reverse_iterator(m_pFirst-1); }

// insertion / deletion
	void					push_back( const T& );
	void					pop_back();
	iterator				insert( iterator, const T& );
	void					insert( iterator, size_t, const T& );
	void					insert( iterator, const_iterator, const_iterator );
	iterator				erase( iterator );
	iterator				erase( iterator, iterator );
	void					clear(){ erase( begin(), end() ); }

// element access
	reference 				operator[]( size_t s){ return *(m_pFirst+s); }
	const_reference			operator[]( size_t s) const { return *(m_pFirst+s); };
	reference				front() { return *m_pFirst; }
	const_reference			front() const { return *m_pFirst; }
	reference				back() { return *(m_pAfterLast-1); }
	const_reference			back() const { return *(m_pAfterLast-1); }

// size
	size_t				 	size() const{ return ( m_pAfterLast - m_pFirst ); }
	bool					empty() const{ return ( m_pAfterLast == m_pFirst ); }

private:
	enum {
		defaultSpace = 64
	};

	void					growSpace(size_t s);
	void					growSpace(iterator&,size_t);
	void					checkSpace(size_t s=1){if((size()+s)>=m_space) growSpace(s); }
	void					checkSpace(iterator& iter, size_t s=1){if((size()+s)>=m_space) growSpace(iter,s); }
	size_t					bytes(size_t s) const { return (s * sizeof(T)); }
	
	size_t	m_space;
	T*		m_pFirst;
	T*		m_pAfterLast;
};

template< class T >
inline
TVector<T>::TVector()
{
	m_space = 0;
	m_pFirst = m_pAfterLast = NULL;
}

template< class T >
inline
TVector<T>::~TVector()
{
	for( T* p = m_pFirst; p != m_pAfterLast; ++p )
	{
		p->~T();
	}
	operator delete( m_pFirst );
}

template< class T >
inline
void
TVector<T>::push_back(
	const T&	x
)
{
	checkSpace();
	new(m_pAfterLast) T(x);
	++m_pAfterLast;
}

template< class T >
inline
void
TVector<T>::pop_back()
{
	m_pAfterLast -= 1;
	m_pAfterLast->~T();
}

template< class T >
inline
TVector<T>::iterator
TVector<T>::insert(
	TVector<T>::iterator	iter,
	const T&				x
)
{
	checkSpace(iter);
	if ( iter != m_pAfterLast )
	{
		::memmove( iter+1, iter, bytes( m_pAfterLast - iter ) );
	}
	new(iter) T(x);
	++m_pAfterLast;
	return iter;
}

template< class T >
inline
void
TVector<T>::insert(
	TVector<T>::iterator	iter,
	size_t					n,
	const T&				x
)
{
	checkSpace(iter,n);
	if ( iter != m_pAfterLast )
	{
		::memmove( iter+n, iter, bytes( m_pAfterLast - iter ) );
	}
	for ( int i = 0; i < n; i++ )
	{
		new(iter+i) T(x);
	}
	m_pAfterLast += n;
}

template< class T >
inline
void
TVector<T>::insert(
	TVector<T>::iterator		insIter,
	TVector<T>::const_iterator	begIter,
	TVector<T>::const_iterator	endIter
)
{
	size_t n = endIter - begIter;
	checkSpace( insIter,n );
	if ( insIter != m_pAfterLast )
	{
		::memmove( insIter+n, insIter, bytes(m_pAfterLast-insIter) );
	}
	for( int i = 0; i < n; i++ )
	{
		new(insIter+i) T(*(begIter+i));
	}
	m_pAfterLast += n;
}

template< class T >
inline
TVector<T>::iterator
TVector<T>::erase(
	TVector<T>::iterator	iter
)
{
	iter->~T();
	::memmove( iter, iter+1, bytes(m_pAfterLast-(iter+1)) );
	m_pAfterLast -= 1;
	return iter;
}

template< class T >
inline
TVector<T>::iterator
TVector<T>::erase(
	TVector<T>::iterator	begIter,
	TVector<T>::iterator	endIter
)
{
	size_t n = endIter - begIter;
	for ( int i = 0; i < n; i++ )
	{
		(begIter+i)->~T();
	}
	::memmove( begIter, endIter, bytes(m_pAfterLast-(endIter)) );
	m_pAfterLast -= n;
	return begIter;
}

template< class T >
void
TVector<T>::growSpace(
	size_t	n
)
{
	size_t s = size();
	size_t newSpace = (m_space == 0)? defaultSpace : m_space * 2;
	while ( newSpace < (n + m_space) )
		newSpace *= 2;

	T *pBuffer = static_cast<T *>( operator new( bytes( newSpace ) ) );
	::memmove( pBuffer, m_pFirst, bytes(m_pAfterLast-m_pFirst) );
	operator delete( m_pFirst );
	m_space = newSpace;
	m_pFirst = pBuffer;
	m_pAfterLast = m_pFirst + s;
}

// this will grow the space as well as fixup the given iterator (since memory is moving)
template< class T >
void
TVector<T>::growSpace(
	TVector<T>::iterator&	iter,	// fix up this iterator
	size_t					n
)
{
	size_t iterOff = iter - m_pFirst;
	growSpace(n);
	iter = m_pFirst + iterOff;
}

#endif	// !_MYVECTOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\inc\soutstrm.h ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       SOutStrm.h

   Abstract:
		A lightweight implementation of output streams using strings

   Author:

       Neil Allain    ( a-neilal )     August-1997 

   Revision History:

--*/
#pragma once

#include "OutStrm.h"

class StringOutStream : public OutStream, public BaseStringBuffer
{
public:
						StringOutStream();
	virtual				~StringOutStream();
						
	virtual	HRESULT		writeChar( _TCHAR );
	virtual	HRESULT		writeString( LPCTSTR, size_t );
	
			String		toString() const;
private:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\inc\mystring.h ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       MyString.h

   Abstract:
		A lightweight string class which supports UNICODE/MCBS.

   Author:

       Neil Allain    ( a-neilal )     August-1997 

   Revision History:

--*/
#pragma once
#ifndef _MYSTRING_H_
#define _MYSTRING_H_

//==========================================================================================
//	Dependencies
//==========================================================================================
#include <string.h>
#include "RefPtr.h"
#include "RefCount.h"

//==========================================================================================
//	Classes
//==========================================================================================

class BaseStringBuffer
{
// interface
public:
	typedef size_t size_type;
	enum {
		npos = -1
	};

	BaseStringBuffer( LPCTSTR	inString );
	BaseStringBuffer( LPCTSTR s1, LPCTSTR s2 );
	BaseStringBuffer( size_t	bufferSize );
	~BaseStringBuffer();
	
	LPTSTR		c_str()
		{ _ASSERT( m_pString ); return m_pString; }
	LPCTSTR		c_str() const
		{ _ASSERT( m_pString ); return m_pString; }
	size_t		length() const
		{ return m_length; }
	size_t		bufferSize() const
		{ return m_bufferSize; }
	HRESULT		copy( LPCTSTR );
	HRESULT		concatenate( LPCTSTR );
	HRESULT		concatenate( _TCHAR );

	size_type	find_last_of(_TCHAR c) const;
	size_type	find_first_of(_TCHAR c) const;
	LPTSTR		substr( size_type b, size_type e ) const;

// implementation
protected:
	
	HRESULT	growBuffer( size_t inMinSize );
	size_t	m_bufferSize;
	size_t	m_length;
	LPTSTR	m_pString;
};

class StringBuffer : public BaseStringBuffer, public CRefCounter
{
public:
	StringBuffer( LPCTSTR inString ) : BaseStringBuffer( inString ){};
	StringBuffer( size_t bufferSize ) : BaseStringBuffer( bufferSize ){};
	StringBuffer( LPCTSTR s1, LPCTSTR s2 ) : BaseStringBuffer( s1, s2 ){};
	~StringBuffer(){};
};

class String : public TRefPtr< StringBuffer >
{
public:

	typedef BaseStringBuffer::size_type size_type;
	enum {
		npos = BaseStringBuffer::npos
	};

							String(bool fCaseSensitive = true);
							String( const String&, bool fCaseSensitive = true );
							String( LPCTSTR, bool fCaseSensitive = true );
							String( StringBuffer* pT, bool fCaseSensitive = true )
                            {   m_fCaseSensitive = fCaseSensitive;
                                Set( pT ); 
                            }
				String&		operator=( StringBuffer* );
				String&		operator=( const String& );
				String&		operator=( LPCTSTR );
				String&		operator+=( const String& );
				String&		operator+=( LPCTSTR );
				String		operator+( const String& ) const;
				String		operator+( LPCTSTR ) const;
				String		operator+( _TCHAR ) const;
				bool		operator==( const String& ) const;
				bool		operator==( LPCTSTR ) const;
				bool		operator!=( const String& s ) const { return !( *this == s ); }
				bool		operator!=( LPCTSTR s ) const { return !( *this == s ); }
				bool		operator<( const String& ) const;
				bool		operator<( LPCTSTR ) const;
				int			compare( const String& s) const { return _tcscmp( c_str(), s.c_str() ); }
				int			compare( LPCTSTR s ) const { return _tcscmp( c_str(), s ); }
				int			compare( size_t, size_t, const String& ) const;
				size_t		find( _TCHAR ) const;
				LPCTSTR		c_str() const { return m_pT->c_str(); };
				LPTSTR		c_str(){ return m_pT->c_str(); }
				size_t		length() const { return m_pT->length(); }
				size_t		size() const { return length(); }
				size_t		bufferSize() const { return m_pT->bufferSize(); }
				_TCHAR		operator[](size_t s) const { return c_str()[s]; }
				_TCHAR		charAt( size_t s ) const { return c_str()[ s ]; }
				SHORT		toInt16() const { return (SHORT)_ttoi(c_str()); }
				LONG		toInt32() const { return _ttol(c_str()); }
				ULONG		toUInt32() const { return (ULONG)_ttol(c_str()); }
				float		toFloat() const { USES_CONVERSION; return (float)atof(T2CA(c_str())); }
				double		toDouble() const { USES_CONVERSION; return atof(T2CA(c_str())); }
				
				size_type	find_last_of(_TCHAR c) const
				{
					return m_pT->find_last_of(c);
				}
				size_type	find_first_of(_TCHAR c) const
				{
					return m_pT->find_first_of(c);
				}
				String		substr( size_type b, size_type e ) const
				{
					LPTSTR pStr = m_pT->substr(b,e);
					String s( pStr );
					delete[] pStr;
					return s;
				}

	static		String		fromInt16( SHORT );
	static		String		fromInt32( LONG );
	static		String		fromFloat( float );
	static		String		fromDouble( double );
			
private:
			StringBuffer&	operator*(){ return *m_pT; }
			StringBuffer*	operator->(){ return m_pT; }
    bool    m_fCaseSensitive;
};

String operator+( LPCTSTR lhs, const String& rhs );

/*
 * A simple class to convert Multibyte to Widechar.  Uses object memory, if sufficient,
 * else allocates memory from the heap.  Intended to be used on the stack.
 */

class CMBCSToWChar
{
private:

    LPWSTR   m_pszResult;
    WCHAR    m_resMemory[1024];
    INT      m_cchResult;

public:

    CMBCSToWChar() { m_pszResult = m_resMemory; m_cchResult = 0; }
    ~CMBCSToWChar();
    
    // Init(): converts the MBCS string at pSrc to a Wide string in memory 
    // managed by CMBCSToWChar

    HRESULT Init(LPCSTR  pSrc, UINT lCodePage = CP_ACP, int cch = -1);

    // GetString(): returns a pointer to the converted string.  Passing TRUE
    // gives the ownership of the memory to the caller.  Passing TRUE has the
    // side effect of clearing the object's contents with respect to the
    // converted string.  Subsequent calls to GetString(). after which a TRUE
    // value was passed, will result in a pointer to an empty string being
    // returned.

    LPWSTR GetString(BOOL fTakeOwnerShip = FALSE);

    // returns the number of bytes in the converted string - NOT including the
    // NULL terminating byte.  Note that this is the number of bytes in the
    // string and not the number of characters.

    INT   GetStringLen() { return (m_cchResult ? m_cchResult - 1 : 0); }
};

/*
 * A simple class to convert WideChar to Multibyte.  Uses object memory, if sufficient,
 * else allocates memory from the heap.  Intended to be used on the stack.
 */

class CWCharToMBCS
{
private:

    LPSTR    m_pszResult;
    char     m_resMemory[1024];
    INT      m_cbResult;

public:

    CWCharToMBCS() { m_pszResult = m_resMemory; m_cbResult = 0; }
    ~CWCharToMBCS();
    
    // Init(): converts the widechar string at pWSrc to an MBCS string in memory 
    // managed by CWCharToMBCS

    HRESULT Init(LPCWSTR  pWSrc, UINT lCodePage = CP_ACP, int cch = -1);

    // GetString(): returns a pointer to the converted string.  Passing TRUE
    // gives the ownership of the memory to the caller.  Passing TRUE has the
    // side effect of clearing the object's contents with respect to the
    // converted string.  Subsequent calls to GetString(). after which a TRUE
    // value was passed, will result in a pointer to an empty string being
    // returned.

    LPSTR GetString(BOOL fTakeOwnerShip = FALSE);

    // returns the number of bytes in the converted string - NOT including the
    // NULL terminating byte.  Note that this is the number of bytes in the
    // string and not the number of characters.

    INT   GetStringLen() { return (m_cbResult ? m_cbResult - 1 : 0); }
};

#endif // !_MYSTRING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\src\finstrm.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       FInStrm.cpp

   Abstract:
		A lightweight implementation of input streams using files

   Author:

       Neil Allain    ( a-neilal )     August-1997

   Revision History:

--*/
#include "stdafx.h"
#include "FInStrm.h"

FileInStream::FileInStream()
	:	m_bIsOpen( false ),
		m_hFile(NULL),
        m_bIsUTF8( false )
{
}


FileInStream::FileInStream(
	LPCTSTR			path
)	:	m_bIsOpen( false ),
        m_bIsUTF8( false )
{
	m_hFile = ::CreateFile(
		path,
		GENERIC_READ,
		FILE_SHARE_READ,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL );
	if ( ( m_hFile != NULL ) && ( m_hFile != INVALID_HANDLE_VALUE ) )
	{
		m_bIsOpen = true;

        // check for the UTF8 signature

        _TCHAR   c;
        size_t  numRead = 0;
        _TCHAR   UTF8Sig[3] = { (_TCHAR)0xef, (_TCHAR)0xbb, (_TCHAR)0xbf };
        int     i;

        m_bIsUTF8 = true;

        // this loop will attempt to disprove that the file is saved as a
        // UTF8 file

        for (i=0; (i < 3) && (m_bIsUTF8 == true); i++) {
            if (readChar(c) != S_OK) {
                m_bIsUTF8 = false;
            }
            else {
                numRead++;
                if (c != UTF8Sig[i]) {
                    m_bIsUTF8 = false;
                }
            }
        }

        // if not a UTF8 file, move the file pointer back to the start of the file.
        // if it is a UTF8 file, then leave the pointer alone.

        if (m_bIsUTF8 == false)
            back(numRead);
	}
	else
	{
		ATLTRACE( _T("Couldn't open file: %s\n"), path );
		m_hFile = NULL;
		setLastError( E_FAIL );
	}
}

FileInStream::~FileInStream()
{
	if ( m_hFile )
	{
		::CloseHandle( m_hFile );
	}
}

HRESULT
FileInStream::readChar(
	_TCHAR&	c
)
{
	HRESULT rc = E_FAIL;
	DWORD readSize;
	if ( ::ReadFile(
		m_hFile,
		(void*)(&c),
		sizeof( _TCHAR ),
		&readSize,
		NULL ) )
	{
		if ( readSize == sizeof( _TCHAR ) )
		{
			rc = S_OK;
		}
		else if ( readSize < sizeof( _TCHAR ) )
		{
			rc = EndOfFile;
		}
	}
	else
	{
		rc = E_FAIL;
	}
	setLastError( rc );
	return rc;
}


HRESULT
FileInStream::read(
	CharCheck&	cc,
	String&		str
)
{
	HRESULT rc = E_FAIL;
	if ( skipWhiteSpace() == S_OK )
	{
#if defined(_M_IX86) && _MSC_FULL_VER <= 13008806
        volatile
#endif
		size_t length = 0;
		_TCHAR c;
		bool done = false;
		while ( !done )
		{
			HRESULT stat = readChar(c);
			if ( ( stat == S_OK ) || ( stat == EndOfFile ) )
			{
				if ( !cc(c) && ( stat != EndOfFile ) )
				{
					length++;
				}
				else
				{
					done = true;
					if ( stat != EndOfFile )
					{
						::SetFilePointer(m_hFile, -(length+1), NULL, FILE_CURRENT );
					}
					else
					{
						::SetFilePointer( m_hFile, -length, NULL, FILE_CURRENT );
					}
					_ASSERT( length > 0 );

					// old code
					// if ( length > 0 )
					
					// new code, work around for compiler bug, should be fixed in future.
					if ( length >= 1 )
					{
						LPTSTR pBuffer = reinterpret_cast<LPTSTR>(_alloca( length + 1 ));
						if ( pBuffer )
						{
							DWORD dwReadSize;
							::ReadFile(
								m_hFile,
								(void*)(pBuffer),
								length,
								&dwReadSize,
								NULL);
							pBuffer[ length ] = '\0';
							str = pBuffer;
							rc = stat;
						}
						else
						{
							rc = E_OUTOFMEMORY;
						}
					}
				}
			}
		}
	}
	setLastError( rc );
	return rc;
}


HRESULT
FileInStream::skip(
	CharCheck&	cc
)
{
	HRESULT rc = E_FAIL;
	_TCHAR c;
	DWORD readSize;
	BOOL b = ::ReadFile( m_hFile, (void*)(&c), sizeof(_TCHAR), &readSize, NULL );
	while ( ( readSize == sizeof( _TCHAR ) ) && ( b == TRUE ) )
	{
		if ( !cc( c ) )
		{
			rc = S_OK;
			b = FALSE;
			::SetFilePointer( m_hFile, -1, NULL, FILE_CURRENT );
		}
		else
		{
			b = ::ReadFile( m_hFile, (void*)(&c), sizeof(_TCHAR), &readSize, NULL );
		}
	}
	if ( readSize < sizeof( _TCHAR ) )
	{
		rc = EndOfFile;
	}
	setLastError( rc );
	return rc;
}

HRESULT
FileInStream::back(
	size_t	s
)
{
	::SetFilePointer( m_hFile, -s, NULL, FILE_CURRENT );
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\src\context.cpp ===
/*++

	Copyright	(c)    1997    Microsoft Corporation

	Module	Name :

		context.h

	Abstract:
		A class to retrieve and release ASP intrinsics

	Author:

		Neil Allain   ( a-neilal )	   August-1997 

	Revision History:

--*/
#include "stdafx.h"
#include <asptlb.h>
#include "context.h"


//---------------------------------------------------------------------------
//	GetServerObject
//
//	Get an instrinic object from the current Object context
//---------------------------------------------------------------------------
HRESULT
CContext::GetServerObject(
	IGetContextProperties*	pProps,
	BSTR					bstrObjName,
	const IID&				iid,
	void**					ppObj
)
{
	HRESULT rc = E_FAIL;
	_ASSERT( pProps );
	_ASSERT( bstrObjName );
	_ASSERT( ppObj );
	if ( pProps && bstrObjName && ppObj )
	{
		*ppObj = NULL;
		CComVariant vt;
		if ( !FAILED( pProps->GetProperty( bstrObjName, &vt ) ) )
		{
			if ( V_VT(&vt) == VT_DISPATCH )
			{
				IDispatch* pDispatch = V_DISPATCH(&vt);
				if ( pDispatch )
				{
					rc = pDispatch->QueryInterface( iid, ppObj );
				}
			}
		}
	}
	return rc;
}


HRESULT
CContext::Init(
	DWORD	dwFlags // which instrinsics to initialize
)
{
	HRESULT rc = E_FAIL;
	CComPtr<IObjectContext> pObjContext;

	rc = ::GetObjectContext( &pObjContext );
	if ( !FAILED( rc ) )
	{
		CComPtr<IGetContextProperties> pProps;
		rc = pObjContext->QueryInterface( IID_IGetContextProperties, (void**)&pProps );
		if ( !FAILED( rc ) )
		{
			CComBSTR bstrObj;
			if ( dwFlags & get_Request )
			{
				bstrObj = L"Request";
				rc = GetServerObject( pProps, bstrObj, IID_IRequest, (void**)&m_piRequest );
			}
			if ( !FAILED(rc) && ( dwFlags & get_Response ) )
			{
				bstrObj = L"Response";
				rc = GetServerObject( pProps, bstrObj, IID_IResponse, (void**)&m_piResponse );
			}

			if ( !FAILED(rc) && ( dwFlags & get_Session ) )
			{
				bstrObj = L"Session";
				rc = GetServerObject( pProps, bstrObj, IID_ISessionObject, (void**)&m_piSession );
			}

			if ( !FAILED(rc) && ( dwFlags & get_Server ) )
			{
				bstrObj = L"Server";
				rc = GetServerObject( pProps, bstrObj, IID_IServer, (void**)&m_piServer );
			}

			if ( !FAILED(rc) && ( dwFlags & get_Application ) )
			{
				bstrObj = L"Application";
				rc = GetServerObject( pProps, bstrObj, IID_IApplicationObject, (void**)&m_piApplication );
			}
		}
	}
	return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\inc\strmap.h ===
//---------------------------------------------------------------------------
//	StrMap.h
//
//	Template class for a map of strings to something
//---------------------------------------------------------------------------
#pragma once
#ifndef _STRMAP_H_
#define _STRMAP_H_

#include "MyString.h"
#include <utility>
#include <algorithm>
#include "myvector.h"

template< class T >
struct StringPairEqual
{
	StringPairEqual( const String& str)
		:	m_rstr( str ) {}
	bool	operator()(
		const pair<String, T>& rhs )
	{
		return ( m_rstr == rhs.first );
	}
private:
	const String&	m_rstr;
};

template< class T >
struct StringPairCompare
{
	int operator()(
		const pair<String, T>&	lhs,
		const pair<String, T>&	rhs )
	{
		return lhs.first.compare( rhs.first );
	}
};

// template function--finds the first element n for which cmp(val,vec[n]) is true and
// cmp(val,vec[n-1]) is false
template< class T, class Compare >
TVector<T>::iterator
binary_find(
	TVector<T>&	vec,
	const T&	val,
	Compare&	cmp )
{
	TVector<T>::iterator iter = vec.begin();

	if ( vec.size() > 0 )
	{
		size_t top = vec.size() - 1;
		size_t bot = 0;
		size_t mid = top >> 1;

		while ( top != bot )
		{
			int c = cmp( val, vec[mid] );
			if ( c > 0 )
			{
				// val > vec[mid]
				bot = mid + 1;
				mid = ( top + bot ) >> 1;
			}
			else if ( c < 0 )
			{
				// val < vec[mid]
				top = mid;
				mid = ( top + bot ) >> 1;
			}
			else
			{
				// val == vec[mid]
				top = bot = mid;
			}
		}
		iter = vec.begin() + mid;
		if ( cmp( val, vec[mid] ) > 0 )
		{
			iter++;
		}
	}
	
	return iter;
}

template< class T >
class TStringMap
{
public:
	typedef String								key_type;
	typedef	T									referent_type;
	typedef pair<key_type,referent_type>	value_type;
	typedef TVector<value_type>					vector_type;
	typedef vector_type::reference				reference;
	typedef vector_type::iterator				iterator;
	typedef vector_type::const_iterator			const_iterator;

	TStringMap(){};
	~TStringMap(){};

	iterator				begin() { return m_vec.begin(); }
	const_iterator			begin() const { return m_vec.begin(); }
	iterator				end() {return m_vec.end();}
	const_iterator			end() const {return m_vec.end();}
	iterator				find( const String& );
	pair<iterator, bool>	insert(const value_type& x);

	referent_type& 			operator[]( const String& );
	referent_type& 			operator[]( size_t n ) { return m_vec[n].second; }

	const referent_type& 	operator[]( const String& ) const ;
	const referent_type& 	operator[]( size_t n ) const { return m_vec[n].second; }

	void					clear(){ m_vec.clear(); }
	size_t					size() const { return m_vec.size(); }
private:
	vector_type				m_vec;
};

#if 0
template<class T>
inline
TStringMap<T>::iterator
TStringMap<T>::begin()
{
	return m_vec.begin();
}

template<class T>
inline
TStringMap<T>::const_iterator
TStringMap<T>::begin()
const
{
	return m_vec.begin();
}

template<class T>
inline
TStringMap<T>::iterator
TStringMap<T>::end()
{
	return m_vec.end();
}

template<class T>
inline
TStringMap<T>::const_iterator
TStringMap<T>::end()
const
{
	return m_vec.end();
}

#endif

template<class T>
inline
TStringMap<T>::iterator
TStringMap<T>::find(
	const String& str )
{
	value_type vt(str,T());
	iterator iter = binary_find( m_vec, vt, StringPairCompare<T>() );
	StringPairEqual<T> spe(str);
	if ( ( iter != m_vec.end() ) && spe(*iter) )
	{
	}
	else
	{
		iter = m_vec.end();
	}
	return iter;
}

template<class T>
inline
pair< TStringMap<T>::iterator, bool >
TStringMap<T>::insert(
	const TStringMap<T>::value_type&	val )
{
	bool inserted = false;
	iterator iter = binary_find( m_vec, val, StringPairCompare<T>() );
	StringPairEqual<T> spe(val.first);
	if ( ( iter != m_vec.end() ) && spe(*iter) )
	{
	}
	else
	{
		inserted = true;
		iter = m_vec.insert( iter, val );
	}
	return pair<TStringMap<T>::iterator, bool>( iter, inserted );
}

template<class T>
inline
T&
TStringMap<T>::operator[](
	const String&	s )
{
	value_type vt(s,T());
	iterator iter = binary_find( m_vec, vt, StringPairCompare<T>() );
	StringPairEqual<T> spe(s);
	if ( ( iter != m_vec.end() ) && spe(*iter) )
	{
	}
	else
	{
		iter = m_vec.insert( iter, vt );
	}
	return (*iter).second;
}

		
#endif	// !_STRMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\src\mem.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       mem.cpp

   Abstract:
		A new and delete operator that will throw excecptions

   Author:

       Neil Allain    ( a-neilal )     August-1997

   Revision History:

--*/

#include "stdafx.h"
#include <comdef.h>
#include "mydebug.h"

#ifdef DBG	// debug memory managment

void
DebugStart()
{
	// Enable debug heap allocations & check for memory leaks at program exit
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF
				   | _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG));
}

void
DebugStop()
{
	_CrtCheckMemory();
}


void* __cdecl operator new( size_t s, const char* file, long line ) _THROW1(_com_error)
{
	void* p = _malloc_dbg( s, _NORMAL_BLOCK, file, line );
	THROW_IF_NULL(p);
	return p;
}

void *__cdecl operator new(size_t s) _THROW1(_com_error)
{
	void* p = malloc( s );
	THROW_IF_NULL(p);
	return p;
}

void __cdecl operator delete(void *p) _THROW0()
{
	if ( p )
	{
		free(p);
	}
}

#if _MSC_VER >= 1200
void __cdecl operator delete(void *p, const char* file, long line) _THROW0()
{
	if ( p )
	{
		_free_dbg(p, _NORMAL_BLOCK);
	}
}
#endif

#else

// release memory management
void __cdecl operator delete(void *p) _THROW0()
{
	if ( p )
	{
		free( p );
	}
}

void *__cdecl operator new(size_t s) _THROW1(_com_error)
{
	void* p = malloc( s );
	THROW_IF_NULL(p);
	return p;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\src\outstrm.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       OutStrm.cpp

   Abstract:
		A lightweight interface of output streams.  This class provides
		the interface, as well as a basic skeleton for output streams.

   Author:

       Neil Allain    ( a-neilal )     August-1997 

   Revision History:

--*/
#include "stdafx.h"
#include "OutStrm.h"

EndLineToken	endl;


OutStream::OutStream()
	:	m_lastError( S_OK )
{
}

OutStream::~OutStream()
{
}

HRESULT
OutStream::writeToken(
	const OutToken&
)
{
	return S_OK;
}

HRESULT
OutStream::writeEolToken(
	const EndLineToken&
)
{
	HRESULT rc = writeChar( '\n' );
	if ( rc == S_OK )
	{
		rc = flush();
	}
	setLastError( rc );
	return rc;
}

HRESULT
OutStream::flush()
{
	return S_OK;
}

HRESULT
OutStream::writeString(
	const String&	str )
{
	HRESULT rc = writeString( str.c_str(), str.length() );
	setLastError( rc );
	return rc;
}

HRESULT
OutStream::writeString(
	LPCTSTR	str )
{
	HRESULT rc = writeString( str, _tcsclen(str) );
	setLastError( rc );
	return rc;
}

HRESULT
OutStream::writeLine(
	LPCTSTR	format,
	... )
{
	va_list args;
	va_start( args, format );
	_TCHAR buf[ 1024 ];
	_vstprintf( buf, format, args );
	HRESULT rc = writeString( buf );
	setLastError( rc );
	return rc;
}

HRESULT
OutStream::writeInt16(
	SHORT	i
)
{
	HRESULT rc = writeString( String::fromInt16(i) );
	setLastError( rc );
	return rc;
}

HRESULT
OutStream::writeInt(
	int	i
)
{
	HRESULT rc = writeString( String::fromInt32(i) );
	setLastError( rc );
	return rc;
}


HRESULT
OutStream::writeInt32(
	LONG	i
)
{
	HRESULT rc = writeString( String::fromInt32(i) );
	setLastError( rc );
	return rc;
}

HRESULT
OutStream::writeFloat(
	float	f
)
{
	HRESULT rc = writeString( String::fromFloat(f) );
	setLastError( rc );
	return rc;
}

HRESULT
OutStream::writeDouble(
	double	d
)
{
	HRESULT rc = writeString( String::fromDouble(d) );
	setLastError( rc );
	return rc;
}

OutStream&
OutStream::operator<<(
	_TCHAR	c
) 
{
	setLastError( writeChar( c ) );
	return *this;
}

OutStream&
OutStream::operator<<(
	SHORT	i
)
{
	setLastError( writeInt16( i ) );
	return *this;
}

OutStream&
OutStream::operator<<(
	int	i
)
{
	setLastError( writeInt( i ) );
	return *this;
}

OutStream&
OutStream::operator<<(
	LONG	i
) 
{
	setLastError( writeInt32( i ) );
	return *this;
}

OutStream&
OutStream::operator<<(
	float	f
) 
{
	setLastError( writeFloat( f ) );
	return *this;
}

OutStream&
OutStream::operator<<(
	double	d
) 
{
	setLastError( writeDouble( d ) );
	return *this;
}

OutStream&
OutStream::operator<<(
	const String&	str
) 
{
	setLastError( writeString( str ) );
	return *this;
}

OutStream&
OutStream::operator<<(
	LPCTSTR		str
) 
{
	setLastError( writeString( str ) );
	return *this;
}

OutStream&
OutStream::operator<<(
	const OutToken&	ot
) 
{
	setLastError( writeToken( ot ) );
	return *this;
}

OutStream&
OutStream::operator<<(
	const EndLineToken&	elt
) 
{
	setLastError( writeEolToken( elt ) );
	return *this;
}

void
OutStream::setLastError(
	HRESULT	hr )
{
	if ( hr == S_OK )
	{
	}
	else
	{
		m_lastError = hr;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\src\mystring.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       MyString.h

   Abstract:
		A lightweight string class which supports UNICODE/MCBS.

   Author:

       Neil Allain    ( a-neilal )     August-1997 

   Revision History:

--*/

#include "stdafx.h"
#include "MyString.h"
#include <comdef.h>
#include "MyDebug.h"

#ifdef DBG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


BaseStringBuffer::BaseStringBuffer(
	LPCTSTR	inString )
{
	if ( inString )
	{
		m_length = _tcsclen( inString );
	}
	else
	{
		m_length = 0;
	}
	m_bufferSize = m_length + 1;
	m_pString = new _TCHAR[ m_bufferSize ];
	if ( inString )
	{
		_tcscpy( m_pString, inString );
	}
	else
	{
		m_pString[0] = _T('\0');
	}
}

BaseStringBuffer::BaseStringBuffer(
	size_t	bufferSize )
{
	if ( bufferSize <= 0 )
	{
		bufferSize = 1;
	}
	
	m_length=0;
	m_bufferSize = bufferSize;
	m_pString = new _TCHAR[ m_bufferSize ];
	_ASSERT( m_pString );
	m_pString[0] = '\0';
}
	
BaseStringBuffer::BaseStringBuffer(
	LPCTSTR	s1,
	LPCTSTR	s2
)
{
	m_length = _tcsclen( s1 ) + _tcsclen( s2 );
	m_bufferSize = m_length + 1;
	m_pString = new _TCHAR[ m_bufferSize ];
	_ASSERT( m_pString );
	_tcscpy( m_pString, s1 );
	_tcscat( m_pString, s2 );
}

BaseStringBuffer::~BaseStringBuffer()
{
	delete[] m_pString;
}

HRESULT
BaseStringBuffer::copy(
	LPCTSTR	str
)
{
	HRESULT rc;
	size_t len = _tcsclen( str );
	rc = growBuffer( len + 1 );
	_ASSERT( m_pString );
    if (SUCCEEDED(rc)) {
	    _tcscpy( m_pString, str );
	    m_length = len;
    }
	return rc;
}

HRESULT
BaseStringBuffer::concatenate(
	LPCTSTR	str
)
{
	HRESULT rc;
	size_t len = _tcsclen( str );
	rc = growBuffer( m_length + len + 1 );
	_ASSERT( m_pString );
    if (SUCCEEDED(rc)) {
	    _tcscat( m_pString, str );
	    m_length = m_length + len;
    }
    return rc;
}

HRESULT
BaseStringBuffer::concatenate(
	_TCHAR	c
)
{
	HRESULT rc;
	_TCHAR sz[2];
	sz[0] = c;
	sz[1] = _T('\0');
	rc = growBuffer( m_length + 2 );
	_ASSERT( m_pString );
    if (SUCCEEDED(rc)) {
	    _tcscat( m_pString, sz );
	    m_length += 1;
    }
	return rc;
}

HRESULT
BaseStringBuffer::growBuffer(
	size_t	inMinSize )
{
	HRESULT rc = E_OUTOFMEMORY;
	if ( m_bufferSize < inMinSize )
	{
        try {

		    LPTSTR newStringP = new _TCHAR[ inMinSize ];
		    _ASSERT( newStringP );
		    if ( newStringP )
		    {
			    if ( m_pString )
			    {
				    _tcscpy( newStringP, m_pString );
				    delete[] m_pString;
			    }
			    m_pString = newStringP;
			    m_bufferSize = inMinSize;
			    rc = S_OK;
		    }
		    else
		    {
			    delete m_pString;
			    m_pString = NULL;
			    m_bufferSize = 0;
			    m_length = 0;
		    }
        }
	    catch ( _com_error& ce ) {
		    rc = ce.Error();
	    }
	    catch ( ... ) {
		    rc = E_FAIL;
	    }        
	}
	return rc;
}

BaseStringBuffer::size_type
BaseStringBuffer::find_last_of(
	_TCHAR c) const
{
	size_type pos = npos;
	LPTSTR p = _tcsrchr(m_pString,c);
	if ( p != NULL )
	{
		pos = p - m_pString;
	}
	return pos;
}

BaseStringBuffer::size_type
BaseStringBuffer::find_first_of(
	_TCHAR c) const
{
	size_type pos = npos;
	_ASSERT( m_pString );
	LPTSTR p = _tcschr(m_pString,c);
	if ( p != NULL )
	{
		pos = p - m_pString;
	}
	return pos;
}

LPTSTR
BaseStringBuffer::substr(
	size_type b,
	size_type e ) const
{
	LPTSTR pStr = NULL;
	_ASSERT( m_pString );
	if ( m_pString )
	{
		LPCTSTR pB = m_pString + b;
		pStr = new _TCHAR[e-b+1];
		_ASSERT( pStr );
		if ( pStr )
		{
			_tcsnccpy( pStr, pB, e-b );
			pStr[e-b] = _T('\0');
		}
	}
	return pStr;
}

String::String(bool fCaseSensitive /* = true */)
{
    m_fCaseSensitive = fCaseSensitive;
	Set( new StringBuffer(_T("") ) );
}

String::String(
	const String&	str,
          bool      fCaseSensitive /* = true */
)	:	m_fCaseSensitive(fCaseSensitive),
        TRefPtr< StringBuffer >( str )
{
}

String::String(
	LPCTSTR		str,
    bool        fCaseSensitive /* = true */
)	:	m_fCaseSensitive(fCaseSensitive),
        TRefPtr< StringBuffer >( new StringBuffer( str ) )
{
}

String&
String::operator=(
	const String&	str
)
{
	Set( const_cast< StringBuffer* >(str.Get()) );
	return *this;
}

String&
String::operator=(
	LPCTSTR		str
)
{
	Set( new StringBuffer( str ) );
	return *this;
}

String&
String::operator=(
	StringBuffer*	pBuf
)
{
	Set( pBuf );
	return *this;
}

String&
String::operator+=(
	const String&	str
)
{
	StringBuffer* pb = new StringBuffer( c_str(), str.c_str() );
	Set( pb );
	return *this;
}

String&
String::operator+=(
	LPCTSTR		str
)
{
	StringBuffer* pb = new StringBuffer( c_str(), str );
	Set( pb );
	return *this;
}

String
String::operator+(
	const String&	str
) const
{
	StringBuffer* pb = new StringBuffer( c_str(), str.c_str() );
	String s;
	s.Set( pb );
	return s;
}

String
String::operator+(
	LPCTSTR		str
) const
{
	StringBuffer* pb = new StringBuffer( c_str(), str );
	String s;
	s.Set( pb );
	return s;
}

String
String::operator+(
	_TCHAR	c
) const
{
	StringBuffer* pb = new StringBuffer( c_str() );
	if ( pb )
	{
        HRESULT  rc;
        rc = pb->concatenate( c );
        if (FAILED(rc)) {
            delete pb;
            throw _com_error(rc);
        }
	}
	String s( pb );
	return s;
}

bool
String::operator==(
	const String&	str
) const
{
    if (m_fCaseSensitive)
	    return ( _tcscmp( c_str(), str.c_str() ) != 0 ) ? false : true;
    else
	    return ( _tcsicmp( c_str(), str.c_str() ) != 0 ) ? false : true;
}

bool
String::operator==(
	LPCTSTR		str
) const
{
    if (m_fCaseSensitive)
    	return ( _tcscmp( c_str(), str ) != 0 ) ? false : true;
    else
    	return ( _tcsicmp( c_str(), str ) != 0 ) ? false : true;

}

bool
String::operator<(
	const String&	str
) const
{
    if (m_fCaseSensitive)
	    return ( _tcscmp( c_str(), str.c_str() ) < 0 ) ? true : false;
    else
	    return ( _tcsicmp( c_str(), str.c_str() ) < 0 ) ? true : false;

}

bool
String::operator<(
	LPCTSTR		str
) const
{
    if (m_fCaseSensitive)
    	return ( _tcscmp( c_str(), str ) < 0 ) ? true : false;
    else
    	return ( _tcsicmp( c_str(), str ) < 0 ) ? true : false;

}

int
String::compare(
	size_t			b,
	size_t			e,
	const String&	str
) const
{
	return _tcsncmp( c_str() + b, str.c_str(), e - b );
}

size_t
String::find(
	_TCHAR	c
) const
{
	size_t pos = npos;
	LPCTSTR p = _tcschr( c_str(), c );
	if ( p != NULL )
	{
		pos = p - c_str();
	}
	return pos;
}

String
String::fromInt16(
	SHORT	i
)
{
	_TCHAR buf[256];
	_stprintf( buf, _T("%d"), (LONG)i);
	return String(buf);
}

String
String::fromInt32(
	LONG	i
)
{
	_TCHAR buf[256];
	_stprintf( buf, _T("%d"), i);
	return String(buf);
}

String
String::fromFloat(
	float	f
)
{
	_TCHAR buf[256];
	_stprintf( buf, _T("%g"), f );
	return String(buf);
}

String
String::fromDouble(
	double	d
)
{
	_TCHAR buf[256];
	_stprintf( buf, _T("%g"), d );
	return String(buf);
}

String
operator+(
LPCTSTR			lhs,
const String&	rhs )
{
	return String( new StringBuffer(lhs,rhs.c_str()) );
}

/*============================================================================
StrDup

Duplicate a string.  An empty string will only be duplicated if the fDupEmpty
flag is set, else a NULL is returned.

Parameter
    CHAR *pszStrIn      string to duplicate

Returns:
    NULL if failed.
    Otherwise, the duplicated string.

Side Effects:
    ***ALLOCATES MEMORY -- CALLER MUST FREE***
============================================================================*/

CHAR *StrDup
(
CHAR    *pszStrIn,
BOOL    fDupEmpty
)
    {
    CHAR *pszStrOut;
    INT  cch, cBytes;

    if (NULL == pszStrIn)
        return NULL;

    cch = strlen(pszStrIn);
    if ((0 == cch) && !fDupEmpty)
        return NULL;

    cBytes = sizeof(CHAR) * (cch+1);
    pszStrOut = (CHAR *)malloc(cBytes);
    if (NULL == pszStrOut)
        return NULL;

    memcpy(pszStrOut, pszStrIn, cBytes);
    return pszStrOut;
    }

/*============================================================================
WStrDup

Same as StrDup but for WCHAR strings

Parameter
    CHAR *pwszStrIn      string to duplicate

Returns:
    NULL if failed.
    Otherwise, the duplicated string.

Side Effects:
    ***ALLOCATES MEMORY -- CALLER MUST FREE***
============================================================================*/

WCHAR *WStrDup
(
WCHAR *pwszStrIn,
BOOL  fDupEmpty
)
    {
    WCHAR *pwszStrOut;
    INT  cch, cBytes;

    if (NULL == pwszStrIn)
        return NULL;

    cch = wcslen(pwszStrIn);
    if ((0 == cch) && !fDupEmpty)
        return NULL;

    cBytes = sizeof(WCHAR) * (cch+1);
    pwszStrOut = (WCHAR *)malloc(cBytes);
    if (NULL == pwszStrOut)
        return NULL;

    memcpy(pwszStrOut, pwszStrIn, cBytes);
    return pwszStrOut;
    }
/*============================================================================
WstrToMBstrEx

Copies a wide character string into an ansi string.

Parameters:
    LPSTR dest      - The string to copy  into
    LPWSTR src      - the input BSTR
    cchBuffer      - the number of CHARs allocated for the destination string.
    lCodePage       - the codepage used in conversion, default to CP_ACP

============================================================================*/
UINT WstrToMBstrEx(LPSTR dest, INT cchDest, LPCWSTR src, int cchSrc, UINT lCodePage)
    {
    UINT cch;

    // if the src length was specified, then reserve room for the NULL terminator.
    // This is necessary because WideCharToMultiByte doesn't add or account for
    // the NULL terminator if a source is specified.

    if (cchSrc != -1)
        cchDest--;

    cch = WideCharToMultiByte(lCodePage, 0, src, cchSrc, dest, cchDest, NULL, NULL);
    if (cch == 0)
        {
        dest[0] = '\0';
        if(ERROR_INSUFFICIENT_BUFFER == GetLastError())
            {
            cch = WideCharToMultiByte(lCodePage, 0, src, cchSrc, dest, 0, NULL, NULL);

            // if a src length was specified, then WideCharToMultiByte does not include
            // it in it's resulting length.  Bump the count so that the caller does
            // account for the NULL.

            if (cchSrc != -1)
                cch++;         
            }
        else
            {
            cch = 1;
            }
        }
    else if (cchSrc != -1)
        {

        // if a src length was specified, then WideCharToMultiByte does not include
        // it in it's resulting length nor does it add the NULL terminator.  So add 
        // it and bump the count.

        dest[cch++] = '\0';
        }

    return cch;
    }

/*============================================================================
MBstrToWstrEx

Copies a ansi string into an wide character string.

Parameters:
    LPWSTR dest    - The string to copy  into
    LPSTR src      - the input ANSI string
    cchDest        - the number of Wide CHARs allocated for the destination string.
    cchSrc         - the length of the source ANSI string
    lCodePage      - the codepage used in conversion, default to CP_ACP

============================================================================*/
UINT MBstrToWstrEx(LPWSTR dest, INT cchDest, LPCSTR src, int cchSrc, UINT lCodePage)
    {
    UINT cch;

    // if the src length was specified, then reserve room for the NULL terminator.
    // This is necessary because WideCharToMultiByte doesn't add or account for
    // the NULL terminator if a source is specified.

    if (cchSrc != -1)
        cchDest--;

    cch = MultiByteToWideChar(lCodePage, 0, src, cchSrc, dest, cchDest);
    if (cch == 0)
        {
        dest[0] = '\0';
        if(ERROR_INSUFFICIENT_BUFFER == GetLastError())
            {
            cch = MultiByteToWideChar(lCodePage, 0, src, cchSrc, dest, 0);

            // if a src length was specified, then WideCharToMultiByte does not include
            // it in it's resulting length.  Bump the count so that the caller does
            // account for the NULL.

            if (cchSrc != -1)
                cch++;         
            }
        else
            {
            cch = 1;
            }
        }
    else if (cchSrc != -1)
        {

        // if a src length was specified, then WideCharToMultiByte does not include
        // it in it's resulting length nor does it add the NULL terminator.  So add 
        // it and bump the count.

        dest[cch++] = '\0';
        }

    return cch;
    }

/*============================================================================
CMBCSToWChar::~CMBCSToWChar

The destructor has to be in the source file to ensure that it gets the right
memory allocation routines defined.
============================================================================*/
CMBCSToWChar::~CMBCSToWChar() 
{
    if(m_pszResult && (m_pszResult != m_resMemory)) 
        free(m_pszResult); 
}

/*============================================================================
CMBCSToWChar::Init

Converts the passed in MultiByte string to UNICODE in the code page
specified.  Uses memory declared in the object if it can, else allocates
from the heap.
============================================================================*/
HRESULT CMBCSToWChar::Init(LPCSTR pASrc, UINT lCodePage /* = CP_ACP */, int cchASrc /* = -1 */)
{
    INT cchRequired;

    // don't even try to convert if we get a NULL pointer to the source.  This
    // condition could be handled by setting by just initing an empty string.

    if (pASrc == NULL) {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    // The init method can be called multiple times on the same object.  Check
    // to see if memory was allocated the last time it was called.  If so,
    // free it and restore the result pointer to the object memory.  Note that
    // an allocation failure could have occurred in a previous call.  The result
    // would be a NULL m_pszResult.

    if (m_pszResult != m_resMemory) {
        if (m_pszResult)
            free(m_pszResult);
        m_pszResult = m_resMemory;
        m_cchResult = 0;
    }

    // set the first byte of the result string to NULL char.  This should help
    // to ensure that nothing wacky happens if this function fails.

    *m_pszResult = '\0';

    // attempt translation into object memory.  NOTE - MBstrToWstrEx returns the
    // count of characters, not bytes.

    cchRequired = MBstrToWstrEx(m_pszResult, sizeof(m_resMemory), pASrc, cchASrc, lCodePage);

    // if the conversion fit, then we're done.  Note the final result size and 
    // return.

    if (cchRequired <= (sizeof(m_resMemory)/sizeof(WCHAR))) {
        m_cchResult = cchRequired;
        return NO_ERROR;
    }

    // if it didn't fit, allocate memory.  Return E_OUTOFMEMORY if it fails.

    m_pszResult = (LPWSTR)malloc(cchRequired*sizeof(WCHAR));
    if (m_pszResult == NULL) {
        return E_OUTOFMEMORY;
    }

    // try the convert again.  It should work.

    cchRequired = MBstrToWstrEx(m_pszResult, cchRequired, pASrc, cchASrc, lCodePage);

    // store the final char count in the object.

    m_cchResult = cchRequired;

    return NO_ERROR;
}

/*============================================================================
CMBCSToWChar::GetString

Returns a pointer to the converted string.

If the fTakeOwnerShip parameter is FALSE, then the pointer in the object is
simply returned to the caller.

If the fTakeOwnerShip parameter is TRUE, then the caller is expecting to be
returned a pointer to heap memory that they have to manage.  If the converted
string is in the object's memory, then the string is duplicated into the heap.
If it's already heap memory, then the pointer is handed off to the caller.

NOTE - Taking ownership essentially destroys the current contents of the 
object.  GetString cannot be called on the object again to get the same value.
The result will be a pointer to a empty string.

============================================================================*/
LPWSTR CMBCSToWChar::GetString(BOOL fTakeOwnerShip)
{
    LPWSTR retSz;

    // return the pointer stored in m_psz_Result if not being
    // requested to give up ownership on the memory or the
    // current value is NULL.

    if ((fTakeOwnerShip == FALSE) || (m_pszResult == NULL)) {
        retSz = m_pszResult;
    }

    // ownership is being requested and the pointer is non-NULL.

    // if the pointer is pointing to the object's memory, dup
    // the string and return that.

    else if (m_pszResult == m_resMemory) {

        retSz = WStrDup(m_pszResult, TRUE);
    }

    // if not pointing to the object's memory, then this is allocated
    // memory and we can relinquish it to the caller.  However, re-establish
    // the object's memory as the value for m_pszResult.

    else {
        retSz = m_pszResult;
        m_pszResult = m_resMemory;
        *m_pszResult = '\0';
        m_cchResult = 0;
    }

    return(retSz);
}

/*============================================================================
CWCharToMBCS::~CWCharToMBCS

The destructor has to be in the source file to ensure that it gets the right
memory allocation routines defined.
============================================================================*/
CWCharToMBCS::~CWCharToMBCS() 
{
    if(m_pszResult && (m_pszResult != m_resMemory)) 
        free(m_pszResult); 
}

/*============================================================================
CWCharToMBCS::Init

Converts the passed in WideChar string to MultiByte in the code page
specified.  Uses memory declared in the object if it can, else allocates
from the heap.
============================================================================*/
HRESULT CWCharToMBCS::Init(LPCWSTR pWSrc, UINT lCodePage /* = CP_ACP */, int cchWSrc /* = -1 */)
{
    INT cbRequired;

    // don't even try to convert if we get a NULL pointer to the source.  This
    // condition could be handled by setting by just initing an empty string.

    if (pWSrc == NULL) {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    // The init method can be called multiple times on the same object.  Check
    // to see if memory was allocated the last time it was called.  If so,
    // free it and restore the result pointer to the object memory.  Note that
    // an allocation failure could have occurred in a previous call.  The result
    // would be a NULL m_pszResult.

    if (m_pszResult != m_resMemory) {
        if (m_pszResult)
            free(m_pszResult);
        m_pszResult = m_resMemory;
        m_cbResult = 0;
    }

    // set the first byte of the result string to NULL char.  This should help
    // to ensure that nothing wacky happens if this function fails.

    *m_pszResult = '\0';

    // attempt translation into object memory.

    cbRequired = WstrToMBstrEx(m_pszResult, sizeof(m_resMemory), pWSrc, cchWSrc, lCodePage);

    // if the conversion fit, then we're done.  Note the final result size and 
    // return.

    if (cbRequired <= sizeof(m_resMemory)) {
        m_cbResult = cbRequired;
        return NO_ERROR;
    }

    // if it didn't fit, allocate memory.  Return E_OUTOFMEMORY if it fails.

    m_pszResult = (LPSTR)malloc(cbRequired);
    if (m_pszResult == NULL) {
        return E_OUTOFMEMORY;
    }

    // try the convert again.  It should work.

    cbRequired = WstrToMBstrEx(m_pszResult, cbRequired, pWSrc, cchWSrc, lCodePage);

    // store the final char count in the object.

    m_cbResult = cbRequired;

    return NO_ERROR;
}

/*============================================================================
CWCharToMBCS::GetString

Returns a pointer to the converted string.

If the fTakeOwnerShip parameter is FALSE, then the pointer in the object is
simply returned to the caller.

If the fTakeOwnerShip parameter is TRUE, then the caller is expecting to be
returned a pointer to heap memory that they have to manage.  If the converted
string is in the object's memory, then the string is duplicated into the heap.
If it's already heap memory, then the pointer is handed off to the caller.

NOTE - Taking ownership essentially destroys the current contents of the 
object.  GetString cannot be called on the object again to get the same value.
The result will be a pointer to a empty string.

============================================================================*/
LPSTR CWCharToMBCS::GetString(BOOL fTakeOwnerShip)
{
    LPSTR retSz;

    // return the pointer stored in m_psz_Result if not being
    // requested to give up ownership on the memory or the
    // current value is NULL.

    if ((fTakeOwnerShip == FALSE) || (m_pszResult == NULL)) {
        retSz = m_pszResult;
    }

    // ownership is being requested and the pointer is non-NULL.

    // if the pointer is pointing to the object's memory, dup
    // the string and return that.

    else if (m_pszResult == m_resMemory) {

        retSz = StrDup(m_pszResult, TRUE);
    }

    // if not pointing to the object's memory, then this is allocated
    // memory and we can relinquish it to the caller.  However, re-establish
    // the object's memory as the value for m_pszResult.

    else {
        retSz = m_pszResult;
        m_pszResult = m_resMemory;
        *m_pszResult = '\0';
        m_cbResult = 0;
    }

    return(retSz);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\src\monitor.cpp ===
#include "stdafx.h"
#include "Monitor.h"
#include "Lock.h"
#include "MyDebug.h"
#include "pudebug.h"
#include <process.h>

#ifdef DBG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

static String FileToDir( const String& );

// function objects for comparisons
struct DirCompare
{
    DirCompare( const String& strDir )
        :   m_strDir( strDir ) {}
    bool operator()( CMonitorDirPtr& pDir )
    {
        return ( m_strDir == pDir->Dir() );
    }
    String m_strDir;
};

struct FileCompare
{
    FileCompare( const String& strFile )
        :   m_strFile( strFile ) {}
    bool operator()( const CMonitorFilePtr& pFile )
    {
        return ( m_strFile == pFile->FileName() );
    }
    String m_strFile;
};

struct RegKeyCompare
{
    RegKeyCompare( HKEY hKey, const String strSubKey )
        :   m_hKey(hKey), m_strSubKey( strSubKey ) {}
    bool operator()( const CMonitorRegKeyPtr& pRegKey )
    {
        bool rc = false;
        if ( m_hKey == pRegKey->m_hBaseKey )
        {
            rc = ( m_strSubKey == pRegKey->m_strKey );
        }
        return rc;
    }
    const HKEY      m_hKey;
    const String   m_strSubKey;
};


String
FileToDir(
    const String&  strFile )
{
    String strDir;
    String::size_type pos = strFile.find_last_of( _T('\\') );
    if ( pos != String::npos )
    {
    }
    else
    {
        pos = strFile.find_first_of( _T(':') );
        if ( pos != String::npos )
        {
            pos++;
        }
    }

    if ( pos != String::npos )
    {
        strDir = strFile.substr( 0, pos );
    }
    return strDir;
}

//---------------------------------------------------------------------------
//  CMonitorFile
//---------------------------------------------------------------------------
CMonitorFile::CMonitorFile(
    const String&              strFile,
    const CMonitorNotifyPtr&    pNotify )
    :   m_strFile( strFile ),
        m_pNotify( pNotify )
{
    GetFileTime( m_ft );
}

CMonitorFile::~CMonitorFile()
{
}

const String&
CMonitorFile::FileName() const
{
    return m_strFile;
}

bool
CMonitorFile::GetFileTime(
    FILETIME&   ft )
{
    bool                        rc = false;
    WIN32_FILE_ATTRIBUTE_DATA   fileInfo;

    if (GetFileAttributesEx(m_strFile.c_str(),
                            GetFileExInfoStandard,
                            (LPVOID)&fileInfo)) {
        ft = fileInfo.ftLastWriteTime;
        rc = true;
    }

    return rc;
}

bool
CMonitorFile::CheckNotify()
{
    bool rc = false;

    FILETIME ft;

    if ( (GetFileTime( ft) == false) || (::CompareFileTime( &ft, &m_ft ) != 0) )
    {
        ATLTRACE( _T("File %s has changed...notifying\n"), m_strFile.c_str() );
        if ( m_pNotify.IsValid() )
        {
            m_pNotify->Notify();
        }
        rc = true;
    }
    m_ft = ft;
    return rc;
}


//---------------------------------------------------------------------------
//  CMonitorDir
//---------------------------------------------------------------------------
CMonitorDir::CMonitorDir(
    const String&  strDir )
    :   m_strDir( strDir )
{
    m_hNotification = ::FindFirstChangeNotification(
        m_strDir.c_str(),
        FALSE,
        FILE_NOTIFY_CHANGE_LAST_WRITE );
}

CMonitorDir::~CMonitorDir()
{
    m_files.clear();
    ::FindCloseChangeNotification( m_hNotification );
}

void
CMonitorDir::AddFile(
    const String&              strFile,
    const CMonitorNotifyPtr&    pNotify )
{
//    ATLTRACE( _T("Monitoring file %s\n"), strFile.c_str() );
    m_files.push_back( new CMonitorFile( strFile, pNotify ) );
}

void
CMonitorDir::RemoveFile(
    const String&   strFile )
{
    TVector<CMonitorFilePtr>::iterator iter = find_if(
        m_files.begin(),
        m_files.end(),
        FileCompare( strFile ) );
    if ( iter != m_files.end() )
    {
//        ATLTRACE( _T("Stopped monitoring file %s\n"), strFile.c_str() );
        m_files.erase( iter );
    }
    else
    {
//        ATLTRACE( _T("Not monitoring file %s\n"), strFile.c_str() );
    }
}

void
CMonitorDir::Notify()
{
    for ( UINT i = 0; i < m_files.size(); i++ )
    {
        m_files[i]->CheckNotify();
    }
    ::FindNextChangeNotification( m_hNotification );
}

ULONG
CMonitorDir::NumFiles() const
{
    return m_files.size();
}

HANDLE
CMonitorDir::NotificationHandle() const
{
    return m_hNotification;
}

const String&
CMonitorDir::Dir() const
{
    return m_strDir;
}

//---------------------------------------------------------------------------
//  CMonitorRegKey
//---------------------------------------------------------------------------
CMonitorRegKey::CMonitorRegKey(
    HKEY                        hBaseKey,
    const String&              strKey,
    const CMonitorNotifyPtr&    pNotify )
    :   m_hEvt(NULL),
        m_hKey(NULL),
        m_pNotify( pNotify ),
        m_strKey( strKey ),
        m_hBaseKey( hBaseKey )
{
    LONG l = ::RegOpenKeyEx(
        hBaseKey,
        strKey.c_str(),
        0,
        KEY_NOTIFY,
        &m_hKey );
    if ( l == ERROR_SUCCESS )
    {
        m_hEvt = IIS_CREATE_EVENT(
                     "CMonitorRegKey::m_hEvt",
                     this,
                     TRUE,
                     FALSE
                     );
        if ( m_hEvt != NULL )
        {
#if 0   // not available in Win95
            // ask for notification when the key changes
            l = ::RegNotifyChangeKeyValue(
                m_hKey,
                FALSE,
                REG_NOTIFY_CHANGE_LAST_SET,
                m_hEvt,
                TRUE );
            if ( l == ERROR_SUCCESS )
            {
                // okay
            }
            else
            {
                ATLTRACE( _T("Couldn't get reg key notification\n") );
            }
#endif // if 0
        }
        else
        {
            ATLTRACE( _T("Couldn't create event\n") );
        }
    }
    else
    {
        ATLTRACE( _T("Couldn't open subkey: %s\n"), strKey.c_str() );
    }
}

CMonitorRegKey::~CMonitorRegKey()
{
    ::RegCloseKey( m_hKey );
    ::CloseHandle( m_hEvt );
}

void
CMonitorRegKey::Notify()
{
    if ( m_pNotify.IsValid() )
    {
        m_pNotify->Notify();
    }
    ::ResetEvent( m_hEvt );
#if 0 // not available in Win95
    ::RegNotifyChangeKeyValue(
        m_hKey,
        FALSE,
        REG_NOTIFY_CHANGE_LAST_SET,
        m_hEvt,
        TRUE );
#endif
}

HANDLE
CMonitorRegKey::NotificationHandle() const
{
    return m_hEvt;
}

//---------------------------------------------------------------------------
//  CMonitor
//---------------------------------------------------------------------------

#include <irtldbg.h>

CMonitor::CMonitor()
    :   m_hevtBreak( NULL ),
        m_hevtShutdown( NULL ),
        m_hThread( NULL ),
        m_bRunning( false ),
        m_bStopping( false )
#ifdef STRING_TRACE_LOG
        , m_stl(100, 1000)
#endif
{
    SET_CRITICAL_SECTION_SPIN_COUNT(&m_cs.m_sec, IIS_DEFAULT_CS_SPIN_COUNT);
    STL_PRINTF("Created monitor, %p", this);
#ifdef STRING_TRACE_LOG
    IrtlTrace("Monitor::m_stl = %p\n", &m_stl);
#endif
}

CMonitor::~CMonitor()
{
    StopAllMonitoring();
    if ( m_hevtBreak != NULL )
    {
        ::CloseHandle( m_hevtBreak );
    }
    if ( m_hevtShutdown != NULL )
    {
        ::CloseHandle( m_hevtShutdown );
    }
    if ( m_hThread != NULL )
    {
        ::CloseHandle( m_hThread );
    }
    STL_PRINTF("Destroying monitor, %p", this);
}

void
CMonitor::MonitorFile(
    LPCTSTR                     szFile,
    const CMonitorNotifyPtr&    pMonNotify )
{
    CLock l(m_cs);

    if (m_bStopping)
        return;

    STL_PRINTF("MonitorFile(%s), Run=%d, Stop=%d, Thread=%p",
               szFile, (int) m_bRunning, (int) m_bStopping, m_hThread);

    String strFile( szFile );
    String strDir = FileToDir( strFile );

    CMonitorDirPtr pDir;
    TVector<CMonitorDirPtr>::iterator iter = find_if(
        m_dirs.begin(),
        m_dirs.end(),
        DirCompare( strDir ) );
    if ( iter == m_dirs.end() )
    {
//        ATLTRACE( _T("Request to monitor new directory: %s\n"), strDir.c_str() );
        pDir = new CMonitorDir( strDir );
        m_dirs.push_back( pDir );
    }
    else
    {
        pDir = (*iter);
    }

    if ( pDir.IsValid() )
    {
        pDir->AddFile( strFile, pMonNotify );
        if ( !m_bRunning )
        {
            StartUp();
        }
        else
        {
            ::SetEvent( m_hevtBreak );
        }
    }
}

void
CMonitor::StopMonitoringFile(
    LPCTSTR szFile )
{
    String strFile( szFile );
    String strDir = FileToDir( strFile );

    CLock l(m_cs);

    if (m_bStopping)
        return;

    STL_PRINTF("StopMonitoringFile(%s), Run=%d, Stop=%d, Thread=%p",
               szFile, (int) m_bRunning, (int) m_bStopping, m_hThread);

    TVector<CMonitorDirPtr>::iterator iter = find_if(
        m_dirs.begin(),
        m_dirs.end(),
        DirCompare( strDir ) );
    if ( iter != m_dirs.end() )
    {
        if ( (*iter).IsValid() )
        {
            (*iter)->RemoveFile( strFile );
            if ( (*iter)->NumFiles() == 0 )
            {
                // no more files to monitor in this directory, remove it
                m_dirs.erase(iter);
                ::SetEvent( m_hevtBreak );
            }
        }
    }
    else
    {
//        ATLTRACE( _T("Not monitorying file %s\n"), szFile );
    }
}

void
CMonitor::MonitorRegKey(
    HKEY                        hBaseKey,
    LPCTSTR                     szSubKey,
    const CMonitorNotifyPtr&    pNotify )
{
    String strSubKey = szSubKey;

//    ATLTRACE( _T( "Request to monitor new key: %s\n"), szSubKey );

    CLock l(m_cs);

    if (m_bStopping)
        return;

    if ( find_if(
            m_regKeys.begin(),
            m_regKeys.end(),
            RegKeyCompare( hBaseKey, szSubKey ) )
        == m_regKeys.end() )
    {
        // not already begin monitored, add a new one
        CMonitorRegKeyPtr pRegKey = new CMonitorRegKey( hBaseKey, szSubKey, pNotify );
        m_regKeys.push_back(pRegKey);

        // either start the monitoring thread or, inform it of a new key to monitor
        if ( !m_bRunning )
        {
            StartUp();
        }
        else
        {
            ::SetEvent( m_hevtBreak );
        }
    }
}

void
CMonitor::StopMonitoringRegKey(
    HKEY    hBaseKey,
    LPCTSTR szSubKey )
{
    String strSubKey = szSubKey;

    CLock l(m_cs);

    if (m_bStopping)
        return;

    TVector<CMonitorRegKeyPtr>::iterator iter = find_if(
        m_regKeys.begin(),
        m_regKeys.end(),
        RegKeyCompare( hBaseKey, szSubKey ) );
    if ( iter != m_regKeys.end() )
    {
//        ATLTRACE( _T( "Stopping monitoring of key: %s\n"), szSubKey );
        m_regKeys.erase( iter );
        ::SetEvent( m_hevtBreak );
    }
    else
    {
//        ATLTRACE( _T("Not monitoring key: %s\n"), szSubKey );
    }
}

void
CMonitor::StopAllMonitoring()
{
    m_cs.Lock();

    STL_PRINTF("StopAllMonitoring, Run=%d, Stop=%d, Thread=%p",
               (int) m_bRunning, (int) m_bStopping, m_hThread);

    if ( m_bRunning )
    {
// clear all types of nodes here
        m_bStopping = true;
        m_regKeys.clear();
        m_dirs.clear();
        m_cs.Unlock(); // must unlock or DoMonitoring will deadlock

        ::SetEvent( m_hevtShutdown );
        ::WaitForSingleObject( m_hThread, INFINITE );

        m_cs.Lock();
        ::CloseHandle( m_hThread );
        m_hThread = NULL;
        m_bRunning = false;
        m_bStopping = false;
    }
    m_cs.Unlock();
}


bool
CMonitor::StartUp()
{
    CLock l(m_cs);

    bool rc = false;

    STL_PRINTF("Startup, Run=%d, Stop=%d, Thread=%p",
               (int) m_bRunning, (int) m_bStopping, m_hThread);

    if (m_bStopping)
        return false;

    // Have we already started the thread?
    if (m_bRunning)
    {
        _ASSERT(m_hevtBreak != NULL);
        _ASSERT(m_hevtShutdown != NULL);
        _ASSERT(m_hThread != NULL);

        // Notify the thread that something has changed
        ::SetEvent( m_hevtBreak );
        return true;
    }

    _ASSERT(m_hThread == NULL);

    if ( m_hevtBreak == NULL )
    {
        m_hevtBreak = IIS_CREATE_EVENT(
                          "CMonitor::m_hevtBreak",
                          this,
                          FALSE,    // auto event
                          FALSE
                          );
    }

    if ( m_hevtShutdown == NULL )
    {
        m_hevtShutdown = IIS_CREATE_EVENT(
                          "CMonitor::m_hevtShutdown",
                          this,
                          FALSE,    // auto event
                          FALSE
                          );
    }

    if ( m_hevtBreak != NULL )
    {
        unsigned int iThreadID;

#if DBG
        if( m_hThread != NULL || m_bRunning)
        {
            DebugBreak();
        }
#endif

        m_hThread = (HANDLE)_beginthreadex(
            NULL,
            0,
            ThreadFunc,
            this,
            0,
            &iThreadID );

        STL_PRINTF("Startup, Thread=%p, Break=%p, Shutdown=%p",
                   m_hThread, m_hevtBreak, m_hevtShutdown);

        if ( m_hThread != NULL )
        {
            ATLTRACE( _T("Started monitor (%p) thread %p\n"),
                      this, m_hThread );
            m_bRunning = true;
            rc = true;
        }
    }
    return rc;
}

DWORD
CMonitor::DoMonitoring()
{
    HANDLE* phEvt = NULL;
    TVector<CMonitorNodePtr> nodes;

    while ( 1 )
    {
        DWORD dwTimeOut = INFINITE;

        if ( phEvt == NULL )
        {
            CLock l(m_cs);

            // build the complete list of monitored nodes
            nodes.clear();
            nodes.insert( nodes.end(), m_dirs.begin(), m_dirs.end() );
            nodes.insert( nodes.end(), m_regKeys.begin(), m_regKeys.end() );
// insert other types of nodes to monitor here

            // Lazily shut down if there are no nodes to monitor
            if ( nodes.size() == 0 )
            {
                // Since thread creation and destruction is a fairly
                // expensive operation, wait for 5 minutes before killing
                // thread
                dwTimeOut = 5 * 60 * 1000;
            }

            // now create the array of event handles
            phEvt = new HANDLE[ nodes.size() + 2 ];
            phEvt[ 0 ] = m_hevtBreak;
            phEvt[ 1 ] = m_hevtShutdown;
            for ( UINT i = 0; i < nodes.size(); i++ )
            {
                phEvt[i+2] = nodes[i]->NotificationHandle();
            }
        }
        else
            STL_PUTS("phEvt != NULL");

        DWORD dw = ::WaitForMultipleObjects(
            nodes.size() + 2,
            phEvt,
            FALSE, // any event will do
            dwTimeOut );

        if ( dw == WAIT_TIMEOUT)
        {
            STL_PUTS("WAIT_TIMEOUT");
            if ( nodes.size() == 0 )
            {
                STL_PRINTF("Nothing to watch: Shutting down, Stopping=%d",
                           (int) m_bStopping);
                ATLTRACE( _T("Nothing to watch... ")
                          _T("stopping monitoring (%p) thread %p\n"),
                          this, m_hThread);
                m_bRunning = false;
                ::CloseHandle( m_hThread );
                m_hThread = NULL;
                return 0;
            }
        }
        // Was one of the events in phEvt signalled?
        C_ASSERT( WAIT_OBJECT_0 == 0 );
        if ( dw < ( WAIT_OBJECT_0 + nodes.size() + 2 ) )
        {
            CLock l(m_cs);

            if ( dw >= WAIT_OBJECT_0 + 2)
            {
                // a monitored item has changed
                nodes[ dw - ( WAIT_OBJECT_0 + 2 ) ]->Notify();
                STL_PRINTF("Notifying object %d", dw - (WAIT_OBJECT_0 + 2));
            }
            else
            {
                // m_hevtBreak or m_hevtShutdown were signalled.  If
                // m_hevtBreak, then there was a manual break, and a node
                // was probably added or removed, so the vector of nodes
                // needs to be regenerated
                nodes.clear();
                delete[] phEvt;
                phEvt = NULL;

                // m_hevtShutdown was signalled
                if ( dw == WAIT_OBJECT_0 + 1)
                {
                    _ASSERT(m_bStopping);
                    STL_PRINTF("Shutting down, Stopping=%d",
                               (int) m_bStopping);

                    ATLTRACE(_T("Shutting down monitoring (%p) thread %p\n"),
                              this, m_hThread);
                    m_bRunning = false;
                    // Must NOT CloseHandle(m_hThread) because
                    // StopAllMonitoring is waiting on it
                    return 0;
                }
                else
                    STL_PUTS("m_hevtBreak");
            }
        }
        else if ( dw == WAIT_FAILED )
        {
            CLock l(m_cs);

            // something's wrong, we'll just clean up and exit
            DWORD err = ::GetLastError();
            ATLTRACE( _T("CMonitor: WaitForMultipleObjects error: 0x%x\n"),
                      err );
            ATLTRACE( _T( "CMonitor: abandoning wait thread\n") );
            nodes.clear();
            delete[] phEvt;
            phEvt = NULL;

            m_dirs.clear();
            m_regKeys.clear();
            m_bRunning = false;
            ::CloseHandle( m_hThread );
            m_hThread = NULL;

            return err;
        }
    }   // end infinite while
}


unsigned
__stdcall
CMonitor::ThreadFunc(
    void* pv)
{
    CMonitor* pMon = (CMonitor*) pv;
    DWORD rc = -1;
    try
    {
        if ( pMon )
        {
            rc = pMon->DoMonitoring();
        }
    }
    catch( ... )
    {
    }

    _endthreadex(rc);
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\src\instrm.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       InStrm.cpp

   Abstract:
		A lightweight implementation of input streams.  This class provides
		the interface, as well as a basic skeleton for input streams.

   Author:

       Neil Allain    ( a-neilal )     August-1997 

   Revision History:

--*/
#include "stdafx.h"
#include "InStrm.h"

static void throwIOException( HRESULT s );

void
throwIOException(
	HRESULT	s
)
{
	if ( s != InStream::EndOfFile )
	{
		ATLTRACE( _T("InStream error: %d\n"), s );
	}
}

bool
IsWhiteSpace::operator()(
	_TCHAR	c
)
{
	bool rc = false;
	switch ( c )
	{
		case _T('\r'):
		case _T(' '):
		case _T('\t'):
		case _T('\n'):
		{
			rc = true;
		} break;
	}
	return rc;
}

bool
IsNewLine::operator()(
	_TCHAR	c
)
{
	bool rc = false;
	if ( ( c != _T('\n') ) && ( c != _T('\r') ) )
	{
	}
	else
	{
		rc = true;
	}
	return rc;
}

InStream::InStream()
	:	m_bEof(false),
		m_lastError( S_OK )
{
}

HRESULT
InStream::readInt16(
	SHORT&	i
)
{
	String str;
	HRESULT rc = readString( str );
	if ( ( rc == S_OK ) || rc == EndOfFile )
	{
		i = str.toInt16();
	}
	setLastError( rc );
	return rc;
}

HRESULT
InStream::readInt(
	int&	i
)
{
	String str;
	HRESULT rc = readString( str );
	if ( ( rc == S_OK ) || rc == EndOfFile )
	{
		i = str.toInt32();
	}
	setLastError( rc );
	return rc;
}

HRESULT
InStream::readInt32(
	LONG&	i
)
{
	String str;
	HRESULT rc = readString( str );
	if ( ( rc == S_OK ) || rc == EndOfFile )
	{
		i = str.toInt32();
	}
	setLastError( rc );
	return rc;
}

HRESULT
InStream::readUInt32(
	ULONG&	i
)
{
	String str;
	HRESULT rc = readString( str );
	if ( ( rc == S_OK ) || rc == EndOfFile )
	{
		i = str.toUInt32();
	}
	setLastError( rc );
	return rc;
}

HRESULT
InStream::readFloat(
	float&	f
)
{
	String str;
	HRESULT rc = readString( str );
	if ( ( rc == S_OK ) || rc == EndOfFile )
	{
		f = str.toFloat();
	}
	setLastError( rc );
	return rc;
}

HRESULT
InStream::readDouble(
	double&	f
)
{
	String str;
	HRESULT rc = readString( str );
	if ( ( rc == S_OK ) || rc == EndOfFile )
	{
		f = str.toDouble();
	}
	setLastError( rc );
	return rc;
}

HRESULT
InStream::readString(
	String&	str
)
{
	return read( IsWhiteSpace(), str );
}

HRESULT
InStream::readLine(
	String&	str
)
{
	return read( IsNewLine(), str );
}

HRESULT
InStream::skipWhiteSpace()
{
	return skip( IsWhiteSpace() );
}

InStream&
InStream::operator>>(
	_TCHAR&	c
)
{
	HRESULT s = readChar(c);
	if ( s == S_OK )
	{
	}
	else
	{
		throwIOException(s);
	}
	return *this;
}

InStream&
InStream::operator>>(
	SHORT&	i
)
{
	HRESULT s = readInt16(i);
	if ( s == S_OK )
	{
	}
	else
	{
		throwIOException(s);
	}
	return *this;
}

InStream&
InStream::operator>>(
	int&	i
)
{
	HRESULT s = readInt(i);
	if ( s == S_OK )
	{
	}
	else
	{
		throwIOException(s);
	}
	return *this;
}

InStream&
InStream::operator>>(
	LONG&	i
)
{
	HRESULT s = readInt32(i);
	if ( s == S_OK )
	{
	}
	else
	{
		throwIOException(s);
	}
	return *this;
}

InStream&
InStream::operator>>(
	ULONG&	i
)
{
	HRESULT s = readUInt32(i);
	if ( s == S_OK )
	{
	}
	else
	{
		throwIOException(s);
	}
	return *this;
}


InStream&
InStream::operator>>(
	float&	f
)
{
	HRESULT s = readFloat(f);
	if ( s == S_OK )
	{
	}
	else
	{
		throwIOException(s);
	}
	return *this;
}

InStream&
InStream::operator>>(
	double&	f
)
{
	HRESULT s = readDouble(f);
	if ( s == S_OK )
	{
	}
	else
	{
		throwIOException(s);
	}
	return *this;
}

InStream&
InStream::operator>>(
	String&	str
)
{
	HRESULT s = readString(str);
	if ( s == S_OK )
	{
	}
	else
	{
		throwIOException(s);
	}
	return *this;
}

void
InStream::setLastError(
	HRESULT	hr )
{
	if ( hr == S_OK )
	{
	}
	else
	{
		if ( hr = EndOfFile )
		{
			m_bEof = true;
		}
		m_lastError = hr;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\src\rdwrt.cpp ===
// RdWrt.cpp

#include "stdafx.h"
#include "RdWrt.h"
#include "pudebug.h"

CReadWrite::CReadWrite()
    :   m_cReaders(0)
{
    // set up reader and writer events
    m_hevtNoReaders = IIS_CREATE_EVENT(
                          "CReadWrite::m_hevtNoReaders",
                          this,
                          TRUE,
                          TRUE
                          );

    m_hmtxWriter = IIS_CREATE_MUTEX(
                       "CReadWrite::m_hmtxWriter",
                       this,
                       FALSE
                       );

    m_handles[0] = m_hevtNoReaders;
    m_handles[1] = m_hmtxWriter;
}

CReadWrite::~CReadWrite()
{
    ::CloseHandle( m_hmtxWriter );
    ::CloseHandle( m_hevtNoReaders );
}


void
CReadWrite::EnterReader()
{
    ::WaitForSingleObject( m_hmtxWriter, INFINITE );

    if ( ++m_cReaders == 1 )
    {
        ::ResetEvent( m_hevtNoReaders );
    }
//    ATLTRACE( _T("Reader entered: %d\n"), m_cReaders );
    ::ReleaseMutex( m_hmtxWriter );
}

void
CReadWrite::ExitReader()
{
    ::WaitForSingleObject( m_hmtxWriter, INFINITE );

    if ( --m_cReaders == 0 )
    {
        ::SetEvent( m_hevtNoReaders );
    }
//    ATLTRACE( _T("Reader exited: %d\n"), m_cReaders );
    ::ReleaseMutex( m_hmtxWriter );
}

void
CReadWrite::EnterWriter()
{
    // this implementation could possibly starve writers
    ::WaitForMultipleObjects(
        2,
        m_handles,
        TRUE,
        INFINITE );

//    ATLTRACE( _T("Writer entered\n") );
    _ASSERT( m_cReaders == 0 );
}

void
CReadWrite::ExitWriter()
{
    _ASSERT( m_cReaders == 0 );
//    ATLTRACE( _T("Writer exited\n") );
    ::ReleaseMutex( m_hmtxWriter );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\tracing\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Tracing.rc
//
#define IDS_PROJNAME                    100
#define IDR_TRACE                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\src\soutstrm.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       SOutStrm.cpp

   Abstract:
		A lightweight implementation of output streams using strings

   Author:

       Neil Allain    ( a-neilal )     August-1997 

   Revision History:

--*/
#include "stdafx.h"
#include "SOutStrm.h"

StringOutStream::StringOutStream()
	:	BaseStringBuffer( _T("") )
{
}

StringOutStream::~StringOutStream()
{
}

HRESULT
StringOutStream::writeChar(
	_TCHAR	c
)
{
	HRESULT rc = concatenate( c );
	return rc;
}

HRESULT
StringOutStream::writeString(
	LPCTSTR	str,
	size_t	/* length */
)
{
	HRESULT rc = concatenate( str );
	return rc;
}

String
StringOutStream::toString() const
{
	String s( c_str() );
	return s;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\src\sinstrm.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       SInStrm.cpp

   Abstract:
        A lightweight implementation of input streams using strings

   Author:

       Neil Allain    ( a-neilal )     August-1997 

   Revision History:

--*/
#include "stdafx.h"
#include "SInStrm.h"
#include "MyDebug.h"

#ifdef DBG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

StringInStream::StringInStream(
    const String&   str
)   :   BaseStringBuffer( str.c_str() )
{
    m_pos = m_pString;
    if ( m_pos != NULL )
    {
        m_end = c_str() + length();
    }
    else
    {
        m_end = NULL;
        setLastError( EndOfFile );
    }
}

HRESULT
StringInStream::readChar(
    _TCHAR& c
)
{
    HRESULT rc = EndOfFile;
    
    if ( m_pos != m_end )
    {
        c = *m_pos++;
        rc = S_OK;
    }
    setLastError( rc );
    return rc;
}

HRESULT
StringInStream::read(
    CharCheck&  cc,
    String&     str
)
{
    HRESULT rc = E_FAIL;
    if ( skipWhiteSpace() == S_OK )
    {
        size_t length = 0;
        _TCHAR c;
        bool done = false;
        while ( !done )
        {
            HRESULT stat = readChar(c);
            if ( ( stat == S_OK ) || ( stat == EndOfFile ) )
            {
                if ( !cc(c) && ( stat != EndOfFile ) )
                {
                    length++;
                }
                else
                {
                    done = true;
                    LPTSTR pCpy;
                    if ( stat != EndOfFile )
                    {
                        pCpy = m_pos - (length+1);
                    }
                    else
                    {
                        pCpy = m_pos - length;
                    }
                    _ASSERT( length > 0 );
                    if ( length > 0 )
                    {
                        LPTSTR pBuffer = new _TCHAR[ length + 1 ];
                        if ( pBuffer )
                        {
                            _tcsncpy( pBuffer,  pCpy, length );
                            pBuffer[ length ] = _T('\0');
                            str = pBuffer;
                            rc = stat;
                            delete[] pBuffer;
                        }
                        else
                        {
                            rc = E_OUTOFMEMORY;
                        }
                    }
                }
            }
        }
    }
    setLastError( rc );
    return rc;
}

HRESULT
StringInStream::skip(
    CharCheck&  cc
)
{
    HRESULT rc = E_FAIL;
    _TCHAR c;
    bool done = false;
    while ( ( m_pos != m_end ) && ( !done ) )
    {
        c = *m_pos;
        if ( !cc( c ) )
        {
            rc = S_OK;
            done = true;
        }
        else
        {
            m_pos++;
        }
    }
    setLastError( rc );
    return rc;
}

HRESULT
StringInStream::back(
    size_t s
)
{
    m_pos -= s;
    if ( (ULONG_PTR)m_pos < (ULONG_PTR)m_pString )
    {
        m_pos = m_pString;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\tracing\stdafx.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    stdafx.h

Abstract:

    Include file for standard system include files, or project specific include 
    files that are used frequently, but are changed infrequently.

Author:

    Jason Andre (JasAndre)      18-March-1999

Revision History:

--*/

#if !defined(AFX_STDAFX_H__E9513B52_8A3D_11D2_B9FE_00C04F72D90E__INCLUDED_)
#define AFX_STDAFX_H__E9513B52_8A3D_11D2_B9FE_00C04F72D90E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#define UNICODE

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <pudebug.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__E9513B52_8A3D_11D2_B9FE_00C04F72D90E__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\tracing\stdafx.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    stdafx.cpp

Abstract:

    Source file that includes just the standard includes.
    stdafx.pch will be the pre-compiled header
    stdafx.obj will contain the pre-compiled type information

Author:

    Jason Andre (JasAndre)      18-March-1999

Revision History:

--*/

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\tracing\trace.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    trace.h

Abstract:

    Declaration of the CTrace class

Author:

    Jason Andre (JasAndre)      18-March-1999

Revision History:

--*/

#ifndef __TRACE_H_
#define __TRACE_H_

#include "resource.h"       // main symbols

#define TRACE_FLAG_ENABLE_ACTIVATE_ODS      0x00000001

/////////////////////////////////////////////////////////////////////////////
// CTrace
class ATL_NO_VTABLE CTrace : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CTrace, &CLSID_Trace>,
    public ISupportErrorInfo,
    public IDispatchImpl<ITrace, &IID_ITrace, &LIBID_TRACINGLib>
{
public:
    CTrace();
    ~CTrace();

DECLARE_CLASSFACTORY_SINGLETON(CTrace);

DECLARE_REGISTRY_RESOURCEID(IDR_TRACE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTrace)
    COM_INTERFACE_ENTRY(ITrace)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

private:
// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ITrace
public:
    STDMETHOD(AddMessage)(/*[in]*/ BSTR bstrModuleName, 
                          /*[in]*/ BSTR bstrMessage);
};

#endif //__TRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\tracing\trace.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    trace.cpp

Abstract:

    Implementation of the CTrace class

Author:

    Jason Andre (JasAndre)      18-March-1999

Revision History:

--*/

#include "stdafx.h"

#include "Tracing.h"
#include "Trace.h"

#include "atlimpl.cpp"

CTrace::CTrace()
{
}

CTrace::~CTrace()
{
}

STDMETHODIMP CTrace::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_ITrace
    };
    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

STDMETHODIMP CTrace::AddMessage(IN BSTR bstrModuleName, 
                                IN BSTR bstrMessage)
{
    char szModuleName[MAX_PATH+1];
    DWORD dwModuleSize = sizeof(szModuleName);

    // See if there is a module name 
    if (*bstrModuleName) {
        // There isn't, so don't bother with it
        DBGINFOW((g_pDebug, "-", 0, L"%s\n", bstrMessage));
    }
    // There is so convert it to ASCII so that we can use it as the file name
    else if (WideCharToMultiByte(CP_ACP, 0, 
                            bstrModuleName, -1, 
                            szModuleName, 
                            dwModuleSize,
                            NULL, NULL))
    {
        // Output the users message
        DBGINFOW((g_pDebug, szModuleName, 0, L"%s\n", bstrMessage));
    }
    else {
        // We couldn't convert the module name for some reason so try to add it
        // to the content
        DBGINFOW((g_pDebug, "???", 0, L"%s: %s\n", bstrModuleName, bstrMessage));
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asptxn\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspcmp\tracing\tracing.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    tracing.cpp

Abstract:

    Implementation of DLL Exports.

Author:

    Jason Andre (JasAndre)      18-March-1999

Revision History:

--*/

#include "stdafx.h"
#include "resource.h"

// The WMI Tracing Guid which uniquely identifies ASP logging
#include <initguid.h>
DEFINE_GUID(IisITraceGuid, 
0x784d8938, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);

DECLARE_DEBUG_PRINTS_OBJECT();

#include "Tracing.h"
#include "Trace.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Trace, CTrace)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        CREATE_DEBUG_PRINT_OBJECT("AspTrace", IisITraceGuid);
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH) {
        DELETE_DEBUG_PRINT_OBJECT();
        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asptxn\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__E9642BCE_0968_11D3_A7F6_0000F8085B95__INCLUDED_)
#define AFX_DLLDATAX_H__E9642BCE_0968_11D3_A7F6_0000F8085B95__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__E9642BCE_0968_11D3_A7F6_0000F8085B95__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asptxn\makefile.inc ===
#
# Supplemental rules for generating Type library.
#
iCPU=$(PROCESSOR_ARCHITECTURE)
!IF "$(iCPU)"=="x86"
iCPU=I386
!ENDIF

CPP             = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) \
                   $(C_DEFINES) $(NET_C_DEFINES)

# MIDL for TxnScript object
$(O)\txnscrpt.h $(O)\txnscrpt.tlb $(O)\txnscrpt_i.c $(O)\txnscrpt_p.c $(O)\dlldata.c: .\txnscrpt.idl
	midl /Oicf /I $(SDK_INC_PATH) $(CPP) /dlldata $(O)\dlldata.c /h $(O)\txnscrpt.h /iid $(O)\txnscrpt_i.c /proxy $(O)\txnscrpt_p.c /tlb $(O)\txnscrpt.tlb txnscrpt.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asptxn\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "txnscrpt_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\aspidl\makefile.inc ===
#
# Supplemental rules for generating Type library.
#
iCPU=$(PROCESSOR_ARCHITECTURE)
!IF "$(iCPU)"=="x86"
iCPU=I386
!ENDIF

ASPTLB_H        = ..\..\..\inc\$(O)\asptlb.h
CDROOT=$(_NTTREE)\inetsrv

# MkTypeLib Stuff
$(O)\_asptlb.h $(O)\asp.tlb: .\asp.idl
	midl /mktyplib203 /Oicf /out .\$(O) /I $(SDK_INC_PATH) /h _asptlb.h  /tlb asp.tlb asp.idl

$(ASPTLB_H): $(O)\_asptlb.h
	echo // This file was generated by mktyplib.exe, then munged by Active Server Pages build. > $@
	echo // Changes: >> $@
	echo // - we include "dispatch.h" (our standard IDispatch implementation) >> $@
	echo // >> $@
	echo // - we #define "NO_BASEINTERFACE_FUNCS" to prevent pure virtual >> $@
	echo // redefinitions of the four IDispatch members that CDispatch defines. >> $@
	echo // >> $@
	echo // - we change the derivation of the classes from "IDispatch" to "CDispatch" >> $@
	echo // >> $@
	echo #include "dispatch.h" >> $@
	echo #define NO_BASEINTERFACE_FUNCS >> $@
	echo // >> $@
	perl -n -e "s/\: public IDispatch/\: public CDispatch/g;print $_;" $(O)\_asptlb.h >> $@

# MIDL for asptxn object
$(O)\asptxn.h: $(O)\_asptxn.h
	echo // This file was generated by mktyplib.exe, then munged by Active Server Pages build. > $@
	echo // Changes: >> $@
	echo // - we include "dispatch.h" (our standard IDispatch implementation) >> $@
	echo // >> $@
	echo // - we #define "NO_BASEINTERFACE_FUNCS" to prevent pure virtual >> $@
	echo // redefinitions of the four IDispatch members that CDispatch defines. >> $@
	echo // >> $@
	echo // - we change the derivation of the classes from "IDispatch" to "CDispatch" >> $@
	echo // >> $@
	echo #include "dispatch.h" >> $@
	echo #define NO_BASEINTERFACE_FUNCS >> $@
	echo // >> $@
	perl -n -e "s/\: public IDispatch/\: public CDispatch/g;print $_;" $(O)\_asptxn.h >> $@


$(O)\_asptxn.h : .\asptxn.idl
	midl /Oicf /I $(SDK_INC_PATH) /out .\$(O) /h _asptxn.h /tlb asptxn.tlb asptxn.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asptxn\asptxn.cpp ===
// asptxn.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for asptxn.idl by adding the following 
//      files to the Outputs.
//          asptxn_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f asptxnps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "txnscrpt.h"
#include "dlldatax.h"

#include "txnscrpt_i.c"
#include "txnobj.h"

#include <dbgutil.h>
#include <comadmin.h>

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_ASPObjectContextTxRequired,      CASPObjectContext)
    OBJECT_ENTRY(CLSID_ASPObjectContextTxRequiresNew,   CASPObjectContext)
    OBJECT_ENTRY(CLSID_ASPObjectContextTxSupported,     CASPObjectContext)
    OBJECT_ENTRY(CLSID_ASPObjectContextTxNotSupported,  CASPObjectContext)
END_OBJECT_MAP()

LPCSTR  g_szModuleName = "ASPTXN";

#ifdef _NO_TRACING_
DECLARE_DEBUG_VARIABLE();
#else
#include <initguid.h>
DEFINE_GUID(IisAspTxnGuid, 
0x784d8908, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#endif
DECLARE_DEBUG_PRINTS_OBJECT();

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        CREATE_DEBUG_PRINT_OBJECT( g_szModuleName, IisAspTxnGuid );
        if( !VALID_DEBUG_PRINT_OBJECT() )
        {
            return FALSE;
        }

        _Module.Init(ObjectMap, hInstance /*, ATL21 &LIBID_ASPTXNLib */);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
        DELETE_DEBUG_PRINT_OBJECT();
    }

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

// Forward references
HRESULT ViperizeContextObject();
HRESULT AddViperUtilPackage();
HRESULT RemoveViperUtilPackage(ICatalogCollection* pPkgCollectionT);
HRESULT AddContextObjectToViperPackage();


STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    
    HRESULT hr = NOERROR;

    // registers object, typelib and all interfaces in typelib
    hr = _Module.RegisterServer(TRUE);

    // create the iis utilities package
    if( SUCCEEDED(hr) )
    {
        HRESULT hrCoInit = CoInitialize( NULL );

        // This is kinda dopey, but remove the package if it exists
        // so we don't get bogus errors when we add. Ignore the return.
        RemoveViperUtilPackage(NULL);

        hr = ViperizeContextObject();

        if( SUCCEEDED(hrCoInit) )
        {
            CoUninitialize();
        }
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    
    HRESULT hr = NOERROR;

    HRESULT hrCoInit = CoInitialize( NULL );

    // Remove the iis utilities package before unregistering the objects
    hr = RemoveViperUtilPackage(NULL);

    if( SUCCEEDED(hrCoInit) )
    {
        CoUninitialize();
    }

    // We don't really care about failures...
    hr = _Module.UnregisterServer(/* ATL21 TRUE */);

    // NOTE: ATL doesn't unregister the typelibrary. Since
    // the interfaces we are exposing are internal to asp we should
    // consider removing the typelibrary registry entries.

    return hr;
}


// Registration code to be pulled from asp.dll

#define RELEASE(p) if ( p ) { p->Release(); p = NULL; }
#define FREEBSTR(p) SysFreeString( p ); p = NULL;

const WCHAR wszCLSID_ASPObjectContextTxRequired[]     = L"{14D0916D-9CDC-11D1-8C4A-00C04FC324A4}";
const WCHAR wszCLSID_ASPObjectContextTxRequiresNew[]  = L"{14D0916E-9CDC-11D1-8C4A-00C04FC324A4}";
const WCHAR wszCLSID_ASPObjectContextTxSupported[]    = L"{14D0916F-9CDC-11D1-8C4A-00C04FC324A4}";
const WCHAR wszCLSID_ASPObjectContextTxNotSupported[] = L"{14D09170-9CDC-11D1-8C4A-00C04FC324A4}";

const WCHAR wszASPUtilitiesPackageID[] = L"{ADA44581-02C1-11D1-804A-0000F8036614}";

/*===================================================================
GetSafeArrayOfCLSIDs

Get a SafeArray contains one ComponentCLSID

Parameter:
szComponentCLSID    the CLSID need to be put in the safe array
paCLSIDs            pointer to a pointer of safe array(safe array provided by
caller).

Return:        HRESULT
Side Affect:

Note:
===================================================================*/
HRESULT GetSafeArrayOfCLSIDs
(
IN LPCWSTR      szComponentCLSID,
OUT SAFEARRAY** paCLSIDs
)
{
    SAFEARRAY*          aCLSIDs = NULL;
    SAFEARRAYBOUND      rgsaBound[1];
    LONG                Indices[1];
    VARIANT             varT;
    HRESULT             hr = NOERROR;

    DBG_ASSERT(szComponentCLSID && paCLSIDs);
    DBG_ASSERT(*paCLSIDs == NULL);

    // PopulateByKey is expecting a SAFEARRAY parameter input,
    // Create a one element SAFEARRAY, the one element of the SAFEARRAY contains
    // the packageID.
    rgsaBound[0].cElements = 1;
    rgsaBound[0].lLbound = 0;
    aCLSIDs = SafeArrayCreate(VT_VARIANT, 1, rgsaBound);

    if (aCLSIDs)
        {
        Indices[0] = 0;

        VariantInit(&varT);
        varT.vt = VT_BSTR;
        varT.bstrVal = SysAllocString(szComponentCLSID);
        hr = SafeArrayPutElement(aCLSIDs, Indices, &varT);
        VariantClear(&varT);

        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Failed to call SafeArrayPutElement, CLSID is %S, hr %08x\n",
                szComponentCLSID,
                hr));

            if (aCLSIDs != NULL)
                {
                HRESULT hrT = SafeArrayDestroy(aCLSIDs);
                if (FAILED(hrT))
                    {
                    DBGPRINTF((DBG_CONTEXT, "Failed to call SafeArrayDestroy(aCLSIDs), hr = %08x\n",
                        hr));
                    }
                aCLSIDs = NULL;
                }
            }
        }
    else
        {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DBGPRINTF((DBG_CONTEXT, "Failed to call SafeArrayCreate, hr %08x\n",
                hr));
        }

    *paCLSIDs = aCLSIDs;
    return hr;
}

/*===================================================================
ViperizeContextObject

Creates a Viper package, and adds the Context object to that
package, and marks the object as "InProc".

Returns:
        HRESULT - NOERROR on success

Side effects:
        Creates Viper package, Viperizes Context object
===================================================================*/
HRESULT ViperizeContextObject(void)
        {
        HRESULT         hr;

        // Add the IIS utility package
        hr = AddViperUtilPackage();

        // Add the context object to the package
        if (SUCCEEDED(hr))
                hr = AddContextObjectToViperPackage();

        return hr;
        }

/*===================================================================
AddViperUtilPackage

Creates a Viper package named "IIS Utility"

Returns:
        HRESULT - NOERROR on success

Side effects:
        Creates Viper package
===================================================================*/
HRESULT AddViperUtilPackage(void)
        {
        HRESULT         hr;
        BSTR bstr       = NULL;
        VARIANT         varT;
        ICatalogCollection* pPkgCollection = NULL;
        ICatalogObject*         pPackage = NULL;
        ICOMAdminCatalog*   pCatalog = NULL;

        long lPkgCount, lChanges, i;

        VariantInit(&varT);

        // Create instance of the catalog object
        hr = CoCreateInstance(CLSID_COMAdminCatalog
                                        , NULL
                                        , CLSCTX_INPROC_SERVER
                                        , IID_ICOMAdminCatalog
                                        , (void**)&pCatalog);
        if (FAILED(hr))
                goto LErr;

        // Get the Packages collection
        bstr = SysAllocString(L"Applications");
        hr = pCatalog->GetCollection(bstr, (IDispatch**)&pPkgCollection);
        FREEBSTR(bstr);
        if (FAILED(hr))
                goto LErr;

        // Add new IIS Utilities package
        hr = pPkgCollection->Add((IDispatch**)&pPackage);
        if (FAILED(hr))
                goto LErr;

        // Set package ID to L"{ADA44581-02C1-11D1-804A-0000F8036614}",
        // MTS replication code looks for This fixed packageID
        bstr = SysAllocString(L"ID");
        varT.vt = VT_BSTR;
        varT.bstrVal = SysAllocString(wszASPUtilitiesPackageID);
        hr = pPackage->put_Value(bstr, varT);
        FREEBSTR(bstr);
        VariantClear(&varT);
        if (FAILED(hr))
                goto LErr;

        // Set package "Name" property to "IIS Utilities"
        bstr = SysAllocString(L"Name");
        varT.vt = VT_BSTR;
        varT.bstrVal = SysAllocString(L"IIS Utilities");
        hr = pPackage->put_Value(bstr, varT);
        FREEBSTR(bstr);
        VariantClear(&varT);
        if (FAILED(hr))
                goto LErr;

        // Set activation to InProc
        bstr = SysAllocString(L"Activation");
        varT.vt = VT_BSTR;
        varT.bstrVal = SysAllocString(L"InProc");
        hr = pPackage->put_Value(bstr, varT);
        FREEBSTR(bstr);
        VariantClear(&varT);
        if (FAILED(hr))
                goto LErr;

        // Set CreatedBy to MS IIS
        bstr = SysAllocString(L"CreatedBy");
        varT.vt = VT_BSTR;
        varT.bstrVal = SysAllocString(L"Microsoft Internet Information Services (tm)");
        hr = pPackage->put_Value(bstr, varT);
        FREEBSTR(bstr);
        VariantClear(&varT);
        if (FAILED(hr))
                goto LErr;

        // Set Deleteable = N property on package
        bstr = SysAllocString(L"Deleteable");
        varT.vt = VT_BSTR;
        varT.bstrVal = SysAllocString(L"N");
        hr = pPackage->put_Value(bstr, varT);
        FREEBSTR(bstr);
        VariantClear(&varT);
        if (FAILED(hr))
                goto LErr;

    	bstr = SysAllocString(L"AccessChecksLevel");
        varT.vt = VT_BSTR;
        varT.bstrVal = SysAllocString(L"0");
        hr = pPackage->put_Value(bstr, varT);
        FREEBSTR(bstr);
        VariantClear(&varT);
        if (FAILED(hr))
                goto LErr;

        // Save changes
        hr = pPkgCollection->SaveChanges(&lChanges);
        if (FAILED(hr))
                goto LErr;

LErr:
        RELEASE(pPkgCollection);
        RELEASE(pPackage);
        RELEASE(pCatalog);

        return hr;
        }

/*===================================================================
RemoveViperUtilPackage

Removes the Viper package named "IIS Utility"

Parameters:
        ICatalogCollection* pPkgCollection
                If non-null, will use this collection.  Otherwise, will
                open its own collection

Returns:
        HRESULT - NOERROR on success

Side effects:
        Removes Viper package
===================================================================*/
HRESULT RemoveViperUtilPackage(ICatalogCollection* pPkgCollectionT)
        {
        HRESULT                 hr;
    ICatalogCollection* pPkgCollection = NULL;
        ICatalogObject*         pPackage = NULL;
        ICOMAdminCatalog*       pCatalog = NULL;
        LONG                lPkgCount, lChanges, i;
        SAFEARRAY*          aCLSIDs = NULL;

        // if package collection was passed, use it
        if (pPkgCollectionT != NULL)
                {
                pPkgCollection = pPkgCollectionT;
                }
        else
                {
                BSTR                bstr = NULL;

                // Create instance of the catalog object
                hr = CoCreateInstance(CLSID_COMAdminCatalog
                                                , NULL
                                                , CLSCTX_INPROC_SERVER
                                                , IID_ICOMAdminCatalog
                                                , (void**)&pCatalog);
                if (FAILED(hr))
                        goto LErr;

                // Get the Packages collection
                bstr = SysAllocString(L"Applications");
                hr = pCatalog->GetCollection(bstr, (IDispatch**)&pPkgCollection);
                FREEBSTR(bstr);
                if (FAILED(hr))
                        goto LErr;
                }

    hr = GetSafeArrayOfCLSIDs(wszASPUtilitiesPackageID, &aCLSIDs);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to get SafeArrayofCLSIDs, szPackageID is %S, hr %08x",
            wszASPUtilitiesPackageID,
            hr));
        goto LErr;
        }

    //
    // Populate it
    //
    hr = pPkgCollection->PopulateByKey(aCLSIDs);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to call PopulateByKey(), hr = %08x\n",
            hr));
        goto LErr;
        }

        // Delete any existing "IIS Utilities" package
    hr = pPkgCollection->get_Count(&lPkgCount);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "pPkgCollection->Populate() failed, hr = %08x\n",
            hr));
        goto LErr;
        }

    if (SUCCEEDED(hr) && lPkgCount == 1)
        {
        hr = pPkgCollection->get_Item(0, (IDispatch**)&pPackage);
        if (FAILED(hr))
            {
            goto LErr;
            }

        BSTR    bstr = NULL;
        VARIANT varT;

        // Found it - remove it and call Save Changes
        // First, Set Deleteable = Y property on package
        bstr = SysAllocString(L"Deleteable");
        VariantInit(&varT);
        varT.vt = VT_BSTR;
        varT.bstrVal = SysAllocString(L"Y");
        hr = pPackage->put_Value(bstr, varT);
        FREEBSTR(bstr);
        VariantClear(&varT);
        if (FAILED(hr))
            {
            goto LErr;
            }

        RELEASE(pPackage);

        // Let save the Deletable settings
        hr = pPkgCollection->SaveChanges(&lChanges);
        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Save the Deletable settings failed, hr = %08x\n",
                hr));
            goto LErr;
            }

        // Now we can delete
        hr = pPkgCollection->Remove(0);
        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Remove the Component from package failed, hr = %08x\n",
                hr));
            goto LErr;
            }

        // Aha, we should be able to delete now.
        hr = pPkgCollection->SaveChanges(&lChanges);
        if (FAILED(hr))
            {
            DBGPRINTF((DBG_CONTEXT, "Save changes failed, hr = %08x\n",
                hr));
            goto LErr;
            }
        }
LErr:

    if (aCLSIDs != NULL)
        {
        HRESULT hrT = SafeArrayDestroy(aCLSIDs);
        aCLSIDs = NULL;
        }

    if (pPkgCollectionT == NULL)
                RELEASE(pPkgCollection);
        RELEASE(pCatalog);
        RELEASE(pPackage);

        return hr;
        }

/*===================================================================
AddContextObjectToViperPackage

Adds the Context object to the Viper package named "IIS Utility"

Returns:
        HRESULT - NOERROR on success

Side effects:
        Adds the object to the Viper package
===================================================================*/
HRESULT AddContextObjectToViperPackage()
{
        HRESULT         hr;
        BSTR bstr                   = NULL;
        BSTR bstrAppGUID    = NULL;
        BSTR bstrGUID       = NULL;
        VARIANT varName;
        VARIANT varKey;
        VARIANT varT;
        ICatalogCollection* pPkgCollection = NULL;
        ICatalogCollection* pCompCollection = NULL;
        ICatalogObject*         pComponent = NULL;
        ICatalogObject*         pPackage = NULL;
        ICOMAdminCatalog*       pCatalog = NULL;
        long                lPkgCount, lCompCount, lChanges, iT;
    BOOL                fFound;
        SAFEARRAY*          aCLSIDs = NULL;

        VariantInit(&varKey);
        VariantClear(&varKey);
        VariantInit(&varName);
        VariantClear(&varName);
        VariantInit(&varT);
        VariantClear(&varT);

        // Create instance of the catalog object
        hr = CoCreateInstance(CLSID_COMAdminCatalog
                                        , NULL
                                        , CLSCTX_INPROC_SERVER
                                        , IID_ICOMAdminCatalog
                                        , (void**)&pCatalog);
        if (FAILED(hr))
                goto LErr;

        // Get the Packages collection
        bstr = SysAllocString(L"Applications");
        hr = pCatalog->GetCollection(bstr, (IDispatch**)&pPkgCollection);
        SysFreeString(bstr);
        if (FAILED(hr))
                goto LErr;

    hr = GetSafeArrayOfCLSIDs(wszASPUtilitiesPackageID, &aCLSIDs);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to get SafeArrayofCLSIDs, szPackageID is %S, hr %08x",
            wszASPUtilitiesPackageID,
            hr));
        goto LErr;
        }

    bstrAppGUID = SysAllocString(wszASPUtilitiesPackageID);

        // Actually put the components in the package
        bstrGUID = SysAllocString(wszCLSID_ASPObjectContextTxRequired);
        hr = pCatalog->ImportComponent(bstrAppGUID ,bstrGUID);
        SysFreeString(bstrGUID);
        if (FAILED(hr))
                goto LErr;
        bstrGUID = SysAllocString(wszCLSID_ASPObjectContextTxRequiresNew);
        hr = pCatalog->ImportComponent(bstrAppGUID ,bstrGUID);
        SysFreeString(bstrGUID);
        if (FAILED(hr))
                goto LErr;
        bstrGUID = SysAllocString(wszCLSID_ASPObjectContextTxSupported);
        hr = pCatalog->ImportComponent(bstrAppGUID ,bstrGUID);
        SysFreeString(bstrGUID);
        if (FAILED(hr))
                goto LErr;
        bstrGUID = SysAllocString(wszCLSID_ASPObjectContextTxNotSupported);
        hr = pCatalog->ImportComponent(bstrAppGUID ,bstrGUID);
        SysFreeString(bstrGUID);
        if (FAILED(hr))
                goto LErr;

    varKey.vt = VT_BSTR;
    varKey.bstrVal = SysAllocString(wszASPUtilitiesPackageID);

    //
    // Populate packages
    //
    hr = pPkgCollection->PopulateByKey(aCLSIDs);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "Failed to call PopulateByKey(), hr = %08x\n",
            hr));
        goto LErr;
        }

        // Find "IIS Utilities" package
    hr = pPkgCollection->get_Count(&lPkgCount);
    if (FAILED(hr))
        {
        DBGPRINTF((DBG_CONTEXT, "pPkgCollection->Populate() failed, hr = %08x\n",
            hr));
        goto LErr;
        }

    if (SUCCEEDED(hr) && lPkgCount == 1)
        {
        hr = pPkgCollection->get_Item(0, (IDispatch**)&pPackage);
        if (FAILED(hr))
            {
            goto LErr;
            }
        }

        DBG_ASSERT(pPackage != NULL);

        // Get the "ComponentsInPackage" collection.
        bstr = SysAllocString(L"Components");
        hr = pPkgCollection->GetCollection(bstr, varKey, (IDispatch**)&pCompCollection);
        SysFreeString(bstr);
        if (FAILED(hr))
                goto LErr;

        // Repopulate the collection so we can find our object and set properties on it
        hr = pCompCollection->Populate();
        if (FAILED(hr))
                goto LErr;

        // Find our components in the list (should be four)

        hr = pCompCollection->get_Count(&lCompCount);
        if (FAILED(hr))
                goto LErr;
        DBG_ASSERT(lCompCount == 4);
        RELEASE(pComponent);
        VariantClear(&varKey);

        for (iT = (lCompCount-1); iT >= 0 ; iT--)
                {
                hr = pCompCollection->get_Item(iT, (IDispatch**)&pComponent);
                if (FAILED(hr))
                        goto LErr;

                hr = pComponent->get_Key(&varKey);
                if (FAILED(hr))
                        goto LErr;
                DBG_ASSERT(varKey.bstrVal);
                fFound = FALSE;

                if (_wcsicmp(varKey.bstrVal, wszCLSID_ASPObjectContextTxRequired) == 0)
                        {
            // Required
                bstr = SysAllocString(L"3");
                fFound = TRUE;
                        }
                else if (_wcsicmp(varKey.bstrVal, wszCLSID_ASPObjectContextTxRequiresNew) == 0)
                    {
                    // Requires New
                bstr = SysAllocString(L"4");
                fFound = TRUE;
                    }
                else if (_wcsicmp(varKey.bstrVal, wszCLSID_ASPObjectContextTxSupported) == 0)
                    {
                    // Supported
                bstr = SysAllocString(L"2");
                fFound = TRUE;
                    }
                else if (_wcsicmp(varKey.bstrVal, wszCLSID_ASPObjectContextTxNotSupported) == 0)
                    {
                    // Not Supported
                bstr = SysAllocString(L"1");
                fFound = TRUE;
                    }

        if (fFound)
            {
                varT.vt = VT_BSTR;
                varT.bstrVal = bstr;
                bstr = SysAllocString(L"Transaction");
                hr = pComponent->put_Value(bstr, varT);
                FREEBSTR(bstr);
                VariantClear(&varT);
                if (FAILED(hr))
                        goto LErr;

                bstr = SysAllocString(L"Description");
                varT.vt = VT_BSTR;
                varT.bstrVal = SysAllocString(L"ASP Tx Script Context");
                hr = pComponent->put_Value(bstr, varT);
                FREEBSTR(bstr);
                VariantClear(&varT);
                if (FAILED(hr))
                        goto LErr;

                bstr = SysAllocString(L"EventTrackingEnabled");
                varT.vt = VT_BSTR;
                varT.bstrVal = SysAllocString(L"N");
                hr = pComponent->put_Value(bstr, varT);
                FREEBSTR(bstr);
                VariantClear(&varT);
                if (FAILED(hr))
                        goto LErr;
            }

                VariantClear(&varKey);
                RELEASE(pComponent);
                }

        // Save changes
        hr = pCompCollection->SaveChanges(&lChanges);
        if (FAILED(hr))
                goto LErr;

        bstr = SysAllocString(L"Activation");
        varT.vt = VT_BSTR;
        varT.bstrVal = SysAllocString(L"InProc");
        hr = pPackage->put_Value(bstr, varT);
        FREEBSTR(bstr);
        VariantClear(&varT);
        if (FAILED(hr))
                goto LErr;

        // Save changes
        hr = pPkgCollection->SaveChanges(&lChanges);
        if (FAILED(hr))
                goto LErr;

        hr = pPkgCollection->Populate();
        if (FAILED(hr))
                goto LErr;

        // Now that our one object is added to the package, set the Changeable property
        // on the package to "No", so no one can mess with it
        bstr = SysAllocString(L"Changeable");
        varT.vt = VT_BSTR;
        varT.bstrVal = SysAllocString(L"N");
        hr = pPackage->put_Value(bstr, varT);
        FREEBSTR(bstr);
        VariantClear(&varT);
        if (FAILED(hr))
                goto LErr;

        // Save changes
        hr = pPkgCollection->SaveChanges(&lChanges);
        if (FAILED(hr))
                goto LErr;

LErr:
        DBG_ASSERT(SUCCEEDED(hr));
    if (aCLSIDs)
        {
        SafeArrayDestroy(aCLSIDs);
        aCLSIDs = NULL;
        }

        RELEASE(pCompCollection);
        RELEASE(pPkgCollection);
        RELEASE(pComponent);
        RELEASE(pPackage);
        RELEASE(pCatalog);
    FREEBSTR(bstrAppGUID);
        FREEBSTR(bstr);
        VariantClear(&varName);
        VariantClear(&varKey);
        VariantClear(&varT);

        return hr;

} // AddContextObjectToViperPackage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asptxn\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by asptxn.rc
//
#define IDS_PROJNAME                    100
#define IDR_ASPOBJECTCONTEXT            101
#define IDR_ACCELERATOR1                201
#define ID_ACCEL32768                   32768

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32769
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asptxn\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__E9642BC6_0968_11D3_A7F6_0000F8085B95__INCLUDED_)
#define AFX_STDAFX_H__E9642BC6_0968_11D3_A7F6_0000F8085B95__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__E9642BC6_0968_11D3_A7F6_0000F8085B95__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asptxn\txnobj.h ===
// txnobj.h : Declaration of the CASPObjectContext

#ifndef __TXNOBJ_H_
#define __TXNOBJ_H_

#include "resource.h"       // main symbols
#include <mtx.h>

/////////////////////////////////////////////////////////////////////////////
// CASPObjectContext
//
class ATL_NO_VTABLE CASPObjectContext 
	: public IObjectControl
    , public IASPObjectContextCustom
	, public ISupportErrorInfo
	, public CComObjectRootEx<CComMultiThreadModel>
	, public CComCoClass<CASPObjectContext, &CLSID_ASPObjectContextTxRequired>
	, public IDispatchImpl<IASPObjectContext, &IID_IASPObjectContext, &LIBID_ASPTxnTypeLibrary, 2, 0>
{
public:
	CASPObjectContext() 
        : m_fAborted(FALSE)
	{
	}

    DECLARE_REGISTRY_RESOURCEID(IDR_ASPOBJECTCONTEXT)

    BEGIN_COM_MAP(CASPObjectContext)
	    COM_INTERFACE_ENTRY(IASPObjectContextCustom)
	    COM_INTERFACE_ENTRY(IASPObjectContext)
	    COM_INTERFACE_ENTRY(IObjectControl)
    	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP()


// IObjectControl
public:
	STDMETHOD(Activate)();
	STDMETHOD_(BOOL, CanBePooled)();
	STDMETHOD_(void, Deactivate)();

// ISupportsErrorInfo
public:
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

private:
	CComPtr<IObjectContext> m_spObjectContext;
    BOOL                    m_fAborted;

// IASPObjectContext & IASPObjectContextCustom
public:

	STDMETHOD(SetAbort)();
	STDMETHOD(SetComplete)();
#ifdef _WIN64
	// Win64 fix -- use UINT64 instead of LONG_PTR since LONG_PTR is broken for Win64 1/21/2000
	STDMETHOD(Call)(UINT64 pvScriptEngine, LPCOLESTR strEntryPoint, boolean *pfAborted);
	STDMETHOD(ResetScript)(UINT64 pvScriptEngine);
#else
	STDMETHOD(Call)(LONG_PTR pvScriptEngine, LPCOLESTR strEntryPoint, boolean *pfAborted);
	STDMETHOD(ResetScript)(LONG_PTR pvScriptEngine);
#endif

};

#endif //__TXNOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asptxn\txnobj.cpp ===
// txnobj.cpp : Implementation of CASPObjectContext


#include "stdafx.h"
#include "txnscrpt.h"
#include "txnobj.h"
#include <hostinfo.h>
#include <scrpteng.h>

/////////////////////////////////////////////////////////////////////////////
// CASPObjectContext

HRESULT CASPObjectContext::Activate()
{
	HRESULT hr = GetObjectContext(&m_spObjectContext);
	if (SUCCEEDED(hr))
		return S_OK;
	return hr;
} 

BOOL CASPObjectContext::CanBePooled()
{
	return FALSE;
} 

void CASPObjectContext::Deactivate()
{
	m_spObjectContext.Release();
} 

STDMETHODIMP CASPObjectContext::Call
(
#ifdef _WIN64
// Win64 fix -- use UINT64 instead of LONG_PTR since LONG_PTR is broken for Win64 1/21/2000
UINT64  pvScriptEngine /*CScriptEngine*/,
#else
LONG_PTR  pvScriptEngine /*CScriptEngine*/,
#endif
LPCOLESTR strEntryPoint,
// BUGBUG - ASP uses this BOOLB type that resolves to a unsigned char. I changed things
// to boolean for simplicity, but this requires some strange casts.
boolean *pfAborted
)
{
    HRESULT hr = NOERROR;

    CScriptEngine *pScriptEngine = (CScriptEngine *)pvScriptEngine;
    m_fAborted = FALSE;

    hr = pScriptEngine->Call(strEntryPoint);

    // If the script timed out or there was an unhandled error, then autoabort
    if (SUCCEEDED(hr) && (pScriptEngine->FScriptTimedOut() || pScriptEngine->FScriptHadError()))
        {
        hr = SetAbort();
        m_fAborted = TRUE;
        }

    // If the script author did not do an explicit SetComplete or SetAbort
    // then do a SetComplete here so Viper will return the transaction
    // completion status to the caller
    if (SUCCEEDED(hr) && !m_fAborted)
        {
        hr = SetComplete();
        }

    *pfAborted = (boolean)m_fAborted;
    return hr;
}

STDMETHODIMP CASPObjectContext::ResetScript
(
#ifdef _WIN64
// Win64 fix -- use UINT64 instead of LONG_PTR since LONG_PTR is broken for Win64 1/21/2000
UINT64 pvScriptEngine /*CScriptEngine*/
#else
LONG_PTR pvScriptEngine /*CScriptEngine*/
#endif
)
{
    HRESULT hr = NOERROR;

    CScriptEngine *pScriptEngine = (CScriptEngine *)pvScriptEngine;
    hr = pScriptEngine->ResetScript();

    return hr;
}

STDMETHODIMP CASPObjectContext::SetComplete()
{
    HRESULT             hr = E_NOTIMPL;
    IObjectContext *    pContext = NULL;

    hr = GetObjectContext(&pContext);
    if( SUCCEEDED(hr) )
    {
        hr = pContext->SetComplete();

        pContext->Release();
        m_fAborted = FALSE;     // If it was aborted, its not any more
    }
    
    return hr;
}

STDMETHODIMP CASPObjectContext::SetAbort()
{
    IObjectContext *    pContext = NULL;
    HRESULT             hr = NOERROR;

    hr = GetObjectContext(&pContext);

    if( SUCCEEDED(hr) )
    {
        hr = pContext->SetAbort();
        pContext->Release();

        m_fAborted = TRUE;      // transaction was esplicitly aborted
    }

    return hr;
}

STDMETHODIMP CASPObjectContext::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		  &IID_IASPObjectContextCustom
        , &IID_IASPObjectContext
        , &IID_IObjectControl
        , &IID_IDispatch
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\devsmpl\controt\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ContRot.rc
//
#define IDS_CONTENTROTATOR_DESC	1



// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\devsmpl\controt\controt.cpp ===
// ContRot.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this 
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f ContRotps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "ContRot.h"
#include "RotObj.h"
#include "debug.h"

#define IID_DEFINED
#include "ContRot_i.c"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CContentRotator, CContentRotator)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
        DEBUG_INIT();
	}
	else if (dwReason == DLL_PROCESS_DETACH)
    {
        DEBUG_TERM();
		_Module.Term();
    }
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\devsmpl\controt\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\devsmpl\controt\debug.cpp ===
#include "stdafx.h"

#include <stdio.h>
#include <stdarg.h>
#include "debug.h"


#define ACTIVE_SERVER_PAGES 1


#ifdef _DEBUG

void __cdecl
Trace(
    LPCTSTR ptszFormat,
    ...)
{
    TCHAR tszBuff[2048];
    va_list args;
    
    va_start(args, ptszFormat);
    _vstprintf(tszBuff, ptszFormat, args);
    va_end(args);

    OutputDebugString(tszBuff);
}



# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)


#  ifdef ACTIVE_SERVER_PAGES

// The default assertion mechanism set up by Visual C++ 4 will not
// work with Active Server Pages because it's running inside a service
// and there is no desktop to interact with.

// Note: for this to work properly, #define _WIN32_WINNT 0x400 before
// including <winuser.h> or MB_SERVICE_NOTIFICATION won't be #define'd.

int __cdecl
AspAssertHandler(
    int   nReportType,
    char* pszErrorText,
    int*  pnReturn)
{
    const char szInfo[] = " (Press ABORT to terminate IIS,"
                          " RETRY to debug this failure,"
                          " or IGNORE to continue.)";
    char* pszMessageTitle = NULL;
    
    // These flags enable message boxes to show up on the user's console
    switch (nReportType)
    {
    case _CRT_WARN:
        pszMessageTitle = "Warning";
        break;
    case _CRT_ERROR:
        pszMessageTitle = "Fatal Error";
        break;
    case _CRT_ASSERT:
        pszMessageTitle = "Assertion Failed";
        break;
    }   
    
    char* pszMessageText =
        static_cast<char*>(_alloca(strlen(pszErrorText) + strlen(szInfo) + 1));

    strcpy(pszMessageText, pszErrorText);
    strcat(pszMessageText, szInfo);
    
    const int n = MessageBoxA(NULL, pszMessageText, pszMessageTitle,
                              (MB_SERVICE_NOTIFICATION | MB_TOPMOST
                               | MB_ABORTRETRYIGNORE | MB_ICONEXCLAMATION));

    if (n == IDABORT)
    {
        exit(1);
    }
    else if (n == IDRETRY)
    {
        *pnReturn = 1;   // tell _CrtDbgReport to start the debugger
        return TRUE;     // tell _CrtDbgReport to run
    }
    
    *pnReturn = 0;       // nothing for _CrtDbgReport to do

    return FALSE;
}

#  endif // ACTIVE_SERVER_PAGES
# endif // _MSC_VER >= 1000



void
DebugInit()
{
# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef ACTIVE_SERVER_PAGES
    // If we end up in _CrtDbgReport, don't put up a message box
    _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_WARN,   _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_ERROR,  _CRTDBG_MODE_DEBUG);

    // Use AspAssertHandler to put up a message box instead
    _CrtSetReportHook(AspAssertHandler);
#  endif // ACTIVE_SERVER_PAGES

    // Enable debug heap allocations & check for memory leaks at program exit
    // The memory leak check will not be performed if inetinfo.exe is
    // run directly under a debugger, only if it is run as a service.
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF
                   | _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG));
# endif // _MSC_VER >= 1000
}



void
DebugTerm()
{
# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef ACTIVE_SERVER_PAGES
    // Turn off AspAssertHandler, so that we don't get numerous message boxes
    // if there are memory leaks on shutdown
    _CrtSetReportHook(NULL);
#  endif // ACTIVE_SERVER_PAGES
# endif // _MSC_VER >= 1000
}

#endif //_DEBUG



BOOL
IsValidString(
    LPCTSTR ptsz,
    int nLength /* =-1 */)
{
    if (ptsz == NULL)
        return FALSE;

    return !IsBadStringPtr(ptsz, nLength);
}



BOOL
IsValidAddress(
    LPCVOID pv,
    UINT nBytes,
    BOOL fReadWrite /* =TRUE */)
{
    return (pv != NULL
            &&  !IsBadReadPtr(pv, nBytes)
            &&  (!fReadWrite  ||  !IsBadWritePtr((LPVOID) pv, nBytes)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\devsmpl\controt\debug.h ===
/*
 * Some simple debugging macros that look and behave a lot like their
 * namesakes in MFC.  These macros should work in both C and C++ and
 * do something useful with almost any Win32 compiler.
 *
 * George V. Reilly  <georger@microcrafts.com>  <a-georgr@microsoft.com>
 */

#ifndef __DEBUG_H__
#define __DEBUG_H__

#ifdef _DEBUG

# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
   /* Use the new debugging tools in Visual C++ 4.x */
#  include <crtdbg.h>
   /* _ASSERTE will give a more meaningful message, but the string takes
    * space.  Use _ASSERT if this is an issue. */
#  define ASSERT(f) _ASSERTE(f)
# else
#  include <assert.h>
#  define ASSERT(f) assert(f)
# endif

# define VERIFY(f)               ASSERT(f)
# define DEBUG_ONLY(f)           (f)
# define TRACE                   Trace
# define TRACE0(psz)             Trace(_T("%s"), _T(psz))
# define TRACE1(psz, p1)         Trace(_T(psz), p1)
# define TRACE2(psz, p1, p2)     Trace(_T(psz), p1, p2)
# define TRACE3(psz, p1, p2, p3) Trace(_T(psz), p1, p2, p3)
# define DEBUG_INIT()            DebugInit()
# define DEBUG_TERM()            DebugTerm()

#else /* !_DEBUG */

  /* These macros should all compile away to nothing */
# define ASSERT(f)               ((void)0)
# define VERIFY(f)               ((void)(f))
# define DEBUG_ONLY(f)           ((void)0)
# define TRACE                   NOP_FUNCTION
# define TRACE0(psz)
# define TRACE1(psz, p1)
# define TRACE2(psz, p1, p2)
# define TRACE3(psz, p1, p2, p3)
# define DEBUG_INIT()            ((void)0)
# define DEBUG_TERM()            ((void)0)

#endif /* !_DEBUG */


#define ASSERT_POINTER(p, type) \
    ASSERT(((p) != NULL)  &&  IsValidAddress((p), sizeof(type), FALSE))

#define ASSERT_NULL_OR_POINTER(p, type) \
    ASSERT(((p) == NULL)  ||  IsValidAddress((p), sizeof(type), FALSE))


/* Declarations for non-Windows apps */

#ifndef _WINDEF_
typedef void*           LPVOID;
typedef const void*     LPCVOID;
typedef unsigned int    UINT;
typedef int             BOOL;
typedef const char*     LPCTSTR;
#endif /* _WINDEF_ */

#ifndef TRUE
# define FALSE  0
# define TRUE   1
#endif


#ifdef __cplusplus
extern "C" {

/* Low-level sanity checks for memory blocks */
BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite = TRUE);
BOOL IsValidString(LPCTSTR ptsz, int nLength = -1);

#else /* !__cplusplus */

/* Low-level sanity checks for memory blocks */
BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite);
BOOL IsValidString(LPCTSTR ptsz, int nLength);

#endif /* !__cplusplus */

/* in debug version, writes trace messages to debug stream */
void __cdecl
Trace(
    LPCTSTR pszFormat,
    ...);

/* should be called from main(), WinMain(), or DllMain() */
void
DebugInit();

void
DebugTerm();

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* __DEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\devsmpl\controt\rotobj.h ===
// RotObj.h : Declaration of the CContentRotator


#include "resource.h"       // main symbols
#include <asptlb.h>


class CTipList;  // forward declaration

/////////////////////////////////////////////////////////////////////////////
// ContRot

class CContentRotator : 
    public CComDualImpl<IContentRotator, &IID_IContentRotator, &LIBID_ContentRotator>,
    public ISupportErrorInfo,
    public CComObjectRoot,
    public CComCoClass<CContentRotator,&CLSID_CContentRotator>
{
public:
    CContentRotator();
    ~CContentRotator();

BEGIN_COM_MAP(CContentRotator)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IContentRotator)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//DECLARE_NOT_AGGREGATABLE(CContentRotator) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CContentRotator,
                 _T("MSWC.ContentRotator.1"),
                 _T("MSWC.ContentRotator"),
                 IDS_CONTENTROTATOR_DESC,
                 THREADFLAGS_BOTH)

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IContentRotator
public:
    STDMETHOD(OnStartPage)(
            IUnknown* pUnk);

    STDMETHOD(OnEndPage)();

    STDMETHOD(ChooseContent)(
        BSTR bstrDataFile,
        BSTR* pbstrRetVal);

    STDMETHOD(GetAllContent)(
        BSTR bstrDataFile);
    
private:
    CTipList*           m_ptl;
    CTipList*           m_ptlUsed;              // List of tips already sent
    CRITICAL_SECTION    m_CS;

    CComPtr<IServer>    m_piServer;             // Server Object
    CComPtr<IResponse>  m_piResponse;           // Response Object

    HRESULT
    _ChooseContent(
        BSTR bstrPhysicalDataFile,
        BSTR* pbstrRetVal);

    HRESULT
    _ReadDataFile(
        BSTR bstrPhysicalDataFile,
        BOOL fForceReread);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\devsmpl\controt\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently


#define STRICT
// #define WIN32_LEAN_AND_MEAN
// #define _WIN32_WINNT 0x400 // needed for MB_SERVICE_NOTIFICATION

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#define ARRAYSIZE(a)	(sizeof(a)/sizeof(*(a)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\devsmpl\controt\rotobj.cpp ===
// RotObj.cpp : Implementation of CContentRotator class, which does all the
// interesting work

// George V. Reilly  a-georgr@microsoft.com georger@microcrafts.com  Nov/Dec 96

// Shortcomings: this works fine for small-to-medium sized tip files
// (under 2000 lines), but it's not very efficient for large ones.


#include "stdafx.h"
#include "ContRot.h"
#include "RotObj.h"

#include "debug.h"
#include <time.h>


#define MAX_WEIGHT 65535


//
// forward declaration of some utility functions
//

LPTSTR  TcsDup(LPCTSTR ptsz);
LPTSTR  GetLine(LPTSTR& rptsz);
BOOL    IsBlankString(LPCTSTR ptsz);
UINT    GetWeight(LPTSTR& rptsz);
LPTSTR  GetTipText(LPTSTR& rptsz);
HRESULT ReportError(DWORD dwErr);
HRESULT ReportError(HRESULT hr);


#ifdef _DEBUG
 #define ASSERT_VALID(pObj)  \
    do {ASSERT(pObj != NULL); pObj->AssertValid();} while (0)
#else
 #define ASSERT_VALID(pObj)  ((void)0)
#endif



//
// "Tip", as in tip of the day
//

class CTip
{
public:
    CTip(
        LPCTSTR ptszTip,
        UINT    uWeight)
        : m_ptsz(ptszTip),
          m_uWeight(uWeight),
          m_cServingsLeft(uWeight),
          m_pPrev(NULL),
          m_pNext(NULL)
    {
        ASSERT_VALID(this);
    }
    
    ~CTip()
    {
        ASSERT_VALID(this);
        if (m_pPrev != NULL)
            m_pPrev->m_pNext = NULL;
        if (m_pNext != NULL)
            m_pNext->m_pPrev = NULL;
    }

#ifdef _DEBUG
    void
    AssertValid() const;
#endif

    LPCTSTR m_ptsz;         // data string
    UINT    m_uWeight;      // weight of this tip, 1 <= m_uWeight <= MAX_WEIGHT
    UINT    m_cServingsLeft;// how many servings left: no more than m_uWeight
    CTip*   m_pPrev;        // Previous in tips list
    CTip*   m_pNext;        // Next in tips list
};



//
// A list of CTips, which are read from a datafile
//

class CTipList
{
public:
    CTipList()
        : m_ptszFilename(NULL),
          m_ptszData(NULL),
          m_cTips(0),
          m_uTotalWeight(0),
          m_pTipsListHead(NULL),
          m_pTipsListTail(NULL)
    {
        ASSERT_VALID(this);
    }

    ~CTipList()
    {
        ASSERT_VALID(this);
        DeleteTips();
        ASSERT_VALID(this);
    }

    HRESULT
    ReadDataFile(
        LPCTSTR ptszFilename);

    HRESULT
    SameAsCachedFile(
        LPCTSTR ptszFilename,
        BOOL&   rfIsSame);

    UINT
    Rand() const;

    void
    AppendTip(
        CTip* pTip);

    void
    RemoveTip(
        CTip* pTip);

    HRESULT
    DeleteTips();

#ifdef _DEBUG
    void
    AssertValid() const;
#endif

    LPTSTR      m_ptszFilename;     // Name of tips file
    FILETIME    m_ftLastWriteTime;  // Timestamp (needed to invalidate cache)
    LPTSTR      m_ptszData;         // Buffer containing contents of file
    UINT        m_cTips;            // # tips
    UINT        m_uTotalWeight;     // sum of all weights
    CTip*       m_pTipsListHead;    // Head of list of tips
    CTip*       m_pTipsListTail;    // Tail of list of tips
};



//
// A class that allows you to enter a critical section and automatically
// leave when the object of this class goes out of scope.  Also provides
// the means to leave and re-enter as needed while protecting against
// entering or leaving out of sync.
//

class CAutoLeaveCritSec
{
public:
    CAutoLeaveCritSec(
        CRITICAL_SECTION* pCS)
        : m_pCS(pCS), m_fInCritSec(FALSE)
    {Enter();}
    
    ~CAutoLeaveCritSec()
    {Leave();}
    
    // Use this function to re-enter the critical section.
    void Enter()
    {if (!m_fInCritSec) {EnterCriticalSection(m_pCS); m_fInCritSec = TRUE;}}

    // Use this function to leave the critical section before going out
    // of scope.
    void Leave()
    {if (m_fInCritSec)  {LeaveCriticalSection(m_pCS); m_fInCritSec = FALSE;}}

protected:    
    CRITICAL_SECTION*   m_pCS;
    BOOL                m_fInCritSec;
};



//
// Wrapper class for handles to files opened for reading
//

class CHFile
{
public:
    CHFile(LPCTSTR ptszFilename)
    {
        m_hFile = ::CreateFile(ptszFilename, GENERIC_READ, FILE_SHARE_READ,
                               NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                               NULL);
    }

    ~CHFile()
    {
        if (m_hFile != INVALID_HANDLE_VALUE)
            ::CloseHandle(m_hFile);
    }

    operator HANDLE() const
    {return m_hFile;}

    BOOL
    operator!() const
    {return (m_hFile == INVALID_HANDLE_VALUE);}

private:
    // private, unimplemented default ctor, copy ctor, and op= to prevent
    // compiler synthesizing them
    CHFile();
    CHFile(const CHFile&);
    CHFile& operator=(const CHFile&);

    HANDLE m_hFile;
};



/////////////////////////////////////////////////////////////////////////////
// CContentRotator Public Methods

//
// ctor
//

CContentRotator::CContentRotator()
    : m_ptl(NULL),
      m_ptlUsed(NULL)
{
    TRACE0("CContentRotator::CContentRotator\n");

    InitializeCriticalSection(&m_CS);
#if (_WIN32_WINNT >= 0x0403)
    SetCriticalSectionSpinCount(&m_CS, 1000);
#endif

    // Seed the random-number generator with the current time so that
    // the numbers will be different each time that we run
    ::srand((unsigned) time(NULL));

    ATLTRY(m_ptl = new CTipList);
    ATLTRY(m_ptlUsed = new CTipList);
}



//
// dtor
//

CContentRotator::~CContentRotator()
{
    TRACE0("CContentRotator::~CContentRotator\n");

    DeleteCriticalSection(&m_CS);
    delete m_ptl;
    delete m_ptlUsed;
}



//
// ATL Wizard generates this
//

STDMETHODIMP CContentRotator::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_IContentRotator,
    };

    for (int i=0; i<sizeof(arr)/sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}



//
// This is called by ASP whenever a page containing a ContentRotator
// object is loaded by the user's browser.
//

STDMETHODIMP
CContentRotator::OnStartPage(
    IUnknown* pUnk)
{
    TRACE0("OnStartPage\n");

    if (pUnk == NULL)
        return ::ReportError(E_POINTER);

    // Get the IScriptingContext Interface
    CComQIPtr<IScriptingContext, &IID_IScriptingContext> pContext(pUnk);

    if (!pContext)
        return ::ReportError(E_NOINTERFACE);

    // Get Server Object Pointer
    HRESULT hr = pContext->get_Server(&m_piServer);
    
    // Get Response Object Pointer
    if (SUCCEEDED(hr))
        hr = pContext->get_Response(&m_piResponse);
    
    if (FAILED(hr))
    {
        // Release all pointers upon failure
        m_piServer.Release();
        m_piResponse.Release();
        ::ReportError(hr);
    }

    return hr;
}



//
// This is called by ASP whenever a page containing a ContentRotator
// object is unloaded by the user's browser.
//

STDMETHODIMP
CContentRotator::OnEndPage()
{
    TRACE0("OnEndPage\n");

    m_piServer.Release();
    m_piResponse.Release();

    return S_OK;
}



//
// Read in the tips in bstrDataFile (a logical name), and return a random
// tip in pbstrRetVal
//

STDMETHODIMP
CContentRotator::ChooseContent(
    BSTR  bstrDataFile,
    BSTR* pbstrRetVal)
{
    TRACE1("ChooseContent(%ls)\n", bstrDataFile);

    if (bstrDataFile == NULL  ||  pbstrRetVal == NULL)
        return ::ReportError(E_POINTER);
    else
        *pbstrRetVal = NULL;

    // Do we have a valid Server object?
    if (!m_piServer)
        return ::ReportError(E_NOINTERFACE);

    // Do we have valid CTipLists?
    if (m_ptl == NULL  ||  m_ptlUsed == NULL)
        return ::ReportError(E_OUTOFMEMORY);

    // Map bstrDataFile (a logical name such as /controt/tips.txt) to
    // a physical filesystem name such as d:\inetpub\controt\tips.txt.
    CComBSTR bstrPhysicalDataFile;
    HRESULT  hr = m_piServer->MapPath(bstrDataFile, &bstrPhysicalDataFile);

    if (SUCCEEDED(hr))
        hr = _ChooseContent(bstrPhysicalDataFile, pbstrRetVal);

    return hr;
}



//
// Writes all of the entries in the tip file, each separated by an <hr>, back
// to the user's browser.  This can be used to proofread all of the entries.
//

STDMETHODIMP
CContentRotator::GetAllContent(
    BSTR bstrDataFile)
{
    TRACE1("GetAllContent(%ls)\n", bstrDataFile);

    if (bstrDataFile == NULL)
        return ::ReportError(E_POINTER);

    // Do we have valid Server and Response objects?
    if (!m_piServer  ||  !m_piResponse)
        return ::ReportError(E_NOINTERFACE);

    // Do we have valid CTipLists?
    if (m_ptl == NULL  ||  m_ptlUsed == NULL)
        return ::ReportError(E_OUTOFMEMORY);

    // Map bstrDataFile (a logical name such as /IISSamples/tips.txt) to
    // a physical filesystem name such as d:\inetpub\IISSamples\tips.txt.
    CComBSTR bstrPhysicalDataFile;
    HRESULT  hr = m_piServer->MapPath(bstrDataFile, &bstrPhysicalDataFile);

    // See note below about critical sections
    CAutoLeaveCritSec alcs(&m_CS);

    if (SUCCEEDED(hr))
        hr = _ReadDataFile(bstrPhysicalDataFile, TRUE);

    if (SUCCEEDED(hr))
    {
        const CComVariant cvHR(OLESTR("\n<hr>\n\n"));
        m_piResponse->Write(cvHR);

        for (CTip* pTip = m_ptl->m_pTipsListHead;
             pTip != NULL;
             pTip = pTip->m_pNext)
        {
            // Write back to the user's browser, one tip at a time.
            // This is more efficient than concatenating all of the
            // tips into a potentially huge string and returning that.
            m_piResponse->Write(CComVariant(pTip->m_ptsz)); 
            m_piResponse->Write(cvHR);
        }
    }

    return hr;
}



/////////////////////////////////////////////////////////////////////////////
// CContentRotator Private Methods

//
// Do the work of ChooseContent, but with a real filename, not with a
// virtual filename
//

HRESULT
CContentRotator::_ChooseContent(
    BSTR  bstrPhysicalDataFile,
    BSTR* pbstrRetVal)
{
    ASSERT(bstrPhysicalDataFile != NULL  &&  pbstrRetVal != NULL);
    
    // The critical section ensures that the remaining code in this
    // function is executing on only one thread at a time.  This ensures
    // that the cached contents of the tip list are consistent for the
    // duration of a call.

    // Actually, the critical section is not needed at all.  Because we
    // need to call Server.MapPath to map the virtual path of
    // bstrDataFile to a physical filesystem path, the OnStartPage method
    // must be called, as this is the only way that we can get access to
    // the ScriptingContext object and thereby the Server object.
    // However, the OnStartPage method is only called for page-level
    // objects (object is created and destroyed in a single page) and for
    // session-level objects.  Page-level objects don't have to worry
    // about protecting their data from multiple access (unless it's
    // global data shared between several objects) and neither do
    // session-level objects.  Only application-level objects need worry
    // about protecting their private data, but application-level objects
    // don't give us any way to map the virtual path.

    // The Content Rotator might be more useful it it were an
    // application-level object.  We would get better distribution of the
    // tips (see below) and do a lot less rereading of the data file.  The
    // trivial changes necessary to accept a filesystem path, such as
    // "D:\ContRot\tips.txt", instead of a virtual path, such as
    // "/IISSamples/tips.txt",are left as an exercise for the reader.

    CAutoLeaveCritSec alcs(&m_CS);

    HRESULT hr = _ReadDataFile(bstrPhysicalDataFile, FALSE);

    if (SUCCEEDED(hr))
    {
        const UINT uRand = m_ptl->Rand();
        UINT       uCumulativeWeight = 0;
        CTip*      pTip = m_ptl->m_pTipsListHead;
        LPCTSTR    ptszTip = NULL;
        
        for ( ; ; )
        {
            ASSERT_VALID(pTip);
            
            ptszTip = pTip->m_ptsz;
            uCumulativeWeight += pTip->m_uWeight;

            if (uCumulativeWeight <= uRand)
                pTip = pTip->m_pNext;
            else
            {
                // Found the tip.  Now we go through a bit of work to make
                // sure that each tip is served up with the correct
                // probability.  If the tip has already been served up as
                // many times as it's allowed (i.e., m_uWeight times), then
                // it's moved to the Used List.  Otherwise, it's (probably)
                // moved to the end of the Tips List, to reduce the
                // likelihood of it turning up too soon again and to
                // randomize the order of the tips in the list.  When all
                // tips have been moved to the Used List, we start afresh.

                // If the object is created, used, and destroyed in a
                // single page (i.e., it's not a session-level object),
                // then none of this does us any good.  The list is in
                // exactly the same order as it is in the data file and
                // we just have to hope that Rand() does give us
                // well-distributed random numbers.

                // If you expect a single user to see more than one tip,
                // you should use a session-level object, to benefit from
                // the better distribution of tips.  This would be the case
                // if you're serving up tips from the same file on multiple
                // pages, or if you have a page that automatically
                // refreshes itself, such as the one included in the
                // Samples directory.

                if (--pTip->m_cServingsLeft > 0)
                {
                    // Move it to the end of the list some of the time.
                    // If we move it there all of the time, then a heavily
                    // weighted tip is more likely to turn up a lot
                    // as the main list nears exhaustion.
                    if (rand() % 3 == 0)
                    {
                        // TRACE1("Move to End\n%s\n", ptszTip);
                        m_ptl->RemoveTip(pTip);
                        m_ptl->AppendTip(pTip);
                    }
                }
                else
                {
                    // TRACE1("Move to Used\n%s\n", ptszTip);
                    pTip->m_cServingsLeft = pTip->m_uWeight;  // reset
                    m_ptl->RemoveTip(pTip);
                    m_ptlUsed->AppendTip(pTip);

                    if (m_ptl->m_cTips == 0)
                    {
                        TRACE0("List exhausted; swapping\n");
                        
                        CTipList* const ptlTemp = m_ptl;
                        m_ptl = m_ptlUsed;
                        m_ptlUsed = ptlTemp;
                    }
                }

                break;
            }
        }

        //  TRACE2("total weight = %u, rand = %u\n",
        //         m_ptl->m_uTotalWeight, uRand);
        //  TRACE1("tip = `%s'\n", ptszTip);
        
        *pbstrRetVal = T2BSTR(ptszTip);
    }

    return hr;
}




HRESULT
CContentRotator::_ReadDataFile(
    BSTR bstrPhysicalDataFile,
    BOOL fForceReread)
{
    USES_CONVERSION;    // needed for OLE2T
    LPCTSTR ptszFilename = OLE2T(bstrPhysicalDataFile);

    // Have we cached this tips file already?
    if (!fForceReread)
    {
        BOOL    fIsSame;
        HRESULT hr = m_ptl->SameAsCachedFile(ptszFilename, fIsSame);

        TRACE(_T("%same file\n"), fIsSame ? _T("S") : _T("Not s"));

        if (FAILED(hr)  ||  fIsSame)
            return hr;
    }
    
    // destroy any old tips
    m_ptl->DeleteTips();
    m_ptlUsed->DeleteTips();

    return m_ptl->ReadDataFile(ptszFilename);
}



/////////////////////////////////////////////////////////////////////////////
// CTipList Public Methods

//
// Read a collection of tips from ptszDataFile
//
// The file format is zero or more copies of the following:
//  One or more lines starting with "%%"
//  Each %% line contains zero or more directives:
//      #<weight>   (positive integer, 1 <= weight <= MAX_WEIGHT)
//      //<comment> (a comment that runs to the end of the line)
//  The tip text follows, spread out over several lines
//

HRESULT
CTipList::ReadDataFile(
    LPCTSTR ptszFilename)
{
    TRACE1("ReadDataFile(%s), %d\n", ptszFilename);

    m_ptszFilename = TcsDup(ptszFilename);
    if (m_ptszFilename == NULL)
        return ::ReportError(E_OUTOFMEMORY);

    // Open the file
    CHFile hFile(m_ptszFilename);

    if (!hFile)
        return ::ReportError(::GetLastError());

    // Get the last-write-time and the filesize
    BY_HANDLE_FILE_INFORMATION bhfi;

    if (!::GetFileInformationByHandle(hFile, &bhfi))
        return ::ReportError(::GetLastError());

    // If it's more than 4GB, let's not even think about it!
    if (bhfi.nFileSizeHigh != 0)
        return ::ReportError(E_OUTOFMEMORY);

    m_ftLastWriteTime = bhfi.ftLastWriteTime;

    // Calculate the number of TCHARs in the file
    const DWORD cbFile = bhfi.nFileSizeLow;
    const DWORD ctc    = cbFile / sizeof(TCHAR);

    // Allocate a buffer for the file's contents
    m_ptszData = NULL;
    ATLTRY(m_ptszData = new TCHAR [ctc + 2]);
    if (m_ptszData == NULL)
        return ::ReportError(E_OUTOFMEMORY);

    // Read the file into the memory buffer.  Let's be paranoid and
    // not assume that ReadFile gives us the whole file in one chunk.
    DWORD cbSeen = 0;

    do
    {
        DWORD cbToRead = cbFile - cbSeen;
        DWORD cbRead   = 0;

        if (!::ReadFile(hFile, ((LPBYTE) m_ptszData) + cbSeen,
                        cbToRead, &cbRead, NULL))
            return ::ReportError(::GetLastError());

        cbSeen += cbRead;
    } while (cbSeen < cbFile);

    m_ptszData[ctc] = _T('\0');   // Nul-terminate the string

    LPTSTR ptsz = m_ptszData;

#ifdef _UNICODE
    // Check for byte-order mark
    if (*ptsz == 0xFFFE)
    {
        // Byte-reversed Unicode file.  Swap the hi- and lo-bytes in each wchar
        for ( ;  ptsz < m_ptszData + ctc;  ++ptsz)
        {
            BYTE* pb = (BYTE*) ptsz;
            const BYTE bHi = pb[1];
            pb[1] = pb[0];
            pb[0] = bHi;
        }
        ptsz = m_ptszData;
    }

    if (*ptsz == 0xFEFF)
        ++ptsz; // skip the byte-order mark
#endif

    // Finally, parse the file
    while (ptsz < m_ptszData + ctc)
    {
        UINT   uWeight     = GetWeight(ptsz);
        LPTSTR ptszTipText = GetTipText(ptsz);

        if (!IsBlankString(ptszTipText)  &&  uWeight > 0)
        {
            CTip* pTip = NULL;
            ATLTRY(pTip = new CTip(ptszTipText, uWeight));
            if (pTip == NULL)
                return ::ReportError(E_OUTOFMEMORY);
            AppendTip(pTip);
        }
        else if (ptsz < m_ptszData + ctc)
        {
            // not at a terminating "%%" line at the end of the data file
            TRACE2("bad tip: tip = `%s', weight = %u\n", ptszTipText, uWeight);
        }
    }

    if (m_uTotalWeight == 0  ||  m_cTips == 0)
        return ::ReportError(ERROR_INVALID_DATA);

    return S_OK;
}



//
// Is ptszFilename the same file as m_ptszFilename in both its name
// and timestamp?
//

HRESULT
CTipList::SameAsCachedFile(
    LPCTSTR ptszFilename,
    BOOL&   rfIsSame)
{
    rfIsSame = FALSE;
    
    // Have we cached a file at all?
    if (m_ptszFilename == NULL)
        return S_OK;
    
    // Are the names the same?
    if (_tcsicmp(ptszFilename, m_ptszFilename) != 0)
        return S_OK;

#if 1
    FILETIME ftLastWriteTime;
    CHFile   hFile(ptszFilename);

    if (!hFile)
        return ::ReportError(::GetLastError());

    if (!::GetFileTime(hFile, NULL, NULL, &ftLastWriteTime))
        return ::ReportError(::GetLastError());

    rfIsSame = (::CompareFileTime(&ftLastWriteTime, &m_ftLastWriteTime) == 0);
#else
    // The following is more efficient, but it won't work on Win95 with
    // Personal Web Server because GetFileAttributesEx is new to NT 4.0.

    WIN32_FILE_ATTRIBUTE_DATA wfad;

    if (!::GetFileAttributesEx(ptszFilename, GetFileExInfoStandard,
                              (LPVOID) &wfad))
        return ::ReportError(::GetLastError());

    rfIsSame = (::CompareFileTime(&wfad.ftLastWriteTime,
                                  &m_ftLastWriteTime) == 0);
#endif

    return S_OK;
}



//
// Generate a random number in the range 0..m_uTotalWeight-1
//

UINT
CTipList::Rand() const
{
    UINT u;
    
    ASSERT(m_uTotalWeight > 0);
    
    if (m_uTotalWeight == 1)
        return 0;
    else if (m_uTotalWeight <= RAND_MAX + 1)
        u = rand() % m_uTotalWeight;
    else
    {
        // RAND_MAX is only 32,767.  This gives us a bigger range
        // of random numbers if the weights are large.
        u = ((rand() << 15) | rand()) % m_uTotalWeight;
    }
    
    ASSERT(0 <= u  &&  u < m_uTotalWeight);
    
    return u;
}



//
// Append a tip to the list
//

void
CTipList::AppendTip(
    CTip* pTip)
{
    ASSERT_VALID(this);

    pTip->m_pPrev = pTip->m_pNext = NULL;
    ASSERT_VALID(pTip);

    pTip->m_pPrev = m_pTipsListTail;

    if (m_pTipsListTail == NULL)
        m_pTipsListHead = pTip;
    else
        m_pTipsListTail->m_pNext = pTip;

    m_pTipsListTail = pTip;
    ++m_cTips;
    m_uTotalWeight += pTip->m_uWeight;

    ASSERT_VALID(this);
}



//
// Remove a tip from somewhere in the list
// 

void
CTipList::RemoveTip(
    CTip* pTip)
{
    ASSERT_VALID(this);
    ASSERT_VALID(pTip);

    ASSERT(m_cTips > 0);

    if (m_cTips == 1)
    {
        ASSERT(m_pTipsListHead == pTip  &&  pTip == m_pTipsListTail);
        m_pTipsListHead = m_pTipsListTail = NULL;
    }
    else if (pTip == m_pTipsListHead)
    {
        ASSERT(m_pTipsListHead->m_pNext != NULL);
        m_pTipsListHead = m_pTipsListHead->m_pNext;
        m_pTipsListHead->m_pPrev = NULL;
    }
    else if (pTip == m_pTipsListTail)
    {
        ASSERT(m_pTipsListTail->m_pPrev != NULL);
        m_pTipsListTail = m_pTipsListTail->m_pPrev;
        m_pTipsListTail->m_pNext = NULL;
    }
    else
    {
        ASSERT(m_cTips >= 3);
        pTip->m_pPrev->m_pNext = pTip->m_pNext;
        pTip->m_pNext->m_pPrev = pTip->m_pPrev;
    }

    pTip->m_pPrev = pTip->m_pNext = NULL;
    --m_cTips;
    m_uTotalWeight -= pTip->m_uWeight;

    ASSERT_VALID(this);
}



//
// Destroy the list of tips and reset all member variables
//

HRESULT
CTipList::DeleteTips()
{
    ASSERT_VALID(this);

    CTip* pTip = m_pTipsListHead;
    
    for (UINT i = 0;  i < m_cTips;  ++i)
    {
        pTip = pTip->m_pNext;
        delete m_pTipsListHead;
        m_pTipsListHead = pTip;
    }

    ASSERT(pTip == NULL  &&  m_pTipsListHead == NULL);

    delete [] m_ptszFilename;
    delete [] m_ptszData;

    m_ptszFilename = m_ptszData = NULL;
    m_ftLastWriteTime.dwLowDateTime = m_ftLastWriteTime.dwHighDateTime = 0;
    m_cTips = m_uTotalWeight = 0;
    m_pTipsListHead = m_pTipsListTail = NULL;

    ASSERT_VALID(this);

    return S_OK;
}



#ifdef _DEBUG

// Paranoia: check that Tips and TipLists are internally consistent.
// Very useful in catching bugs.

void
CTip::AssertValid() const
{
    ASSERT(m_ptsz != NULL  &&  m_uWeight > 0);
    ASSERT(0 < m_cServingsLeft  &&  m_cServingsLeft <= m_uWeight);
    ASSERT(m_pPrev == NULL  ||  m_pPrev->m_pNext == this);
    ASSERT(m_pNext == NULL  ||  m_pNext->m_pPrev == this);
}



void
CTipList::AssertValid() const
{
    if (m_cTips == 0)
    {
        ASSERT(m_pTipsListHead == NULL  &&  m_pTipsListTail == NULL);
        ASSERT(m_uTotalWeight == 0);
    }
    else
    {
        ASSERT(m_pTipsListHead != NULL  &&  m_pTipsListTail != NULL);
        ASSERT(m_pTipsListHead->m_pPrev == NULL);
        ASSERT(m_pTipsListTail->m_pNext == NULL);
        ASSERT(m_uTotalWeight > 0);

        if (m_cTips == 1)
            ASSERT(m_pTipsListHead == m_pTipsListTail);
        else
            ASSERT(m_pTipsListHead != m_pTipsListTail);
    }

    UINT  uWeight = 0;
    CTip* pTip = m_pTipsListHead;
    UINT  i;
    
    for (i = 0;  i < m_cTips;  ++i)
    {
        ASSERT_VALID(pTip);
        uWeight += pTip->m_uWeight;

        if (i < m_cTips - 1)
            pTip = pTip->m_pNext;
    }

    ASSERT(uWeight == m_uTotalWeight);
    ASSERT(pTip == m_pTipsListTail);
}

#endif

/////////////////////////////////////////////////////////////////////////////
// Utility functions

//
// Make a copy of a TSTR that can be deleted with operator delete[]
//

static LPTSTR
TcsDup(
    LPCTSTR ptsz)
{
    LPTSTR ptszNew = NULL;
    ATLTRY(ptszNew = new TCHAR [_tcslen(ptsz) + 1]);
    if (ptszNew != NULL)
        _tcscpy(ptszNew, ptsz);
    return ptszNew;
}



//
// reads a \n-terminated string from rptsz and modifies rptsz to
// point after the end of that string
//

static LPTSTR
GetLine(
    LPTSTR& rptsz)
{
    LPTSTR ptszOrig = rptsz;
    LPTSTR ptszEol = _tcspbrk(rptsz, _T("\n"));

    if (ptszEol != NULL)
    {
        // is it "\r\n"?
        if (ptszEol > ptszOrig  &&  ptszEol[-1] == _T('\r'))
            ptszEol[-1] = _T('\0');
        else
            ptszEol[0] = _T('\0');

        rptsz = ptszEol + 1;
    }   
    else
    {
        // no newline, so point past the end of the string
        rptsz += _tcslen(rptsz);
    }

    // TRACE1("GetLine: `%s'\n", ptszOrig);
    return ptszOrig;
}



//
// Is the string blank?
//

static BOOL
IsBlankString(
    LPCTSTR ptsz)
{
    if (ptsz == NULL)
        return TRUE;

    while (*ptsz != _T('\0'))
        if (!_istspace(*ptsz))
            return FALSE;
        else
            ptsz++;

    return TRUE;
}



//
// Read a weight line from rptsz and update rptsz to point after the
// end of any %% lines.
//

static UINT
GetWeight(
    LPTSTR& rptsz)
{
    UINT u = 1; // default weight
    
    while (*rptsz == _T('%'))
    {
        LPTSTR ptsz = GetLine(rptsz);

        if (ptsz[1] == _T('%'))
        {
            ptsz +=2;   // Skip "%%"

            while (*ptsz != _T('\0'))
            {
                while (_istspace(*ptsz))
                    ptsz++;

                if (*ptsz == _T('/')  &&  ptsz[1] == _T('/'))
                {
                    // TRACE1("// `%s'\n", ptsz+2);
                    break;  // a comment: ignore the rest of the line
                }
                else if (*ptsz == _T('#'))
                {
                    ptsz++;

                    if (_T('0') <= *ptsz  &&  *ptsz <= _T('9'))
                    {
                        LPTSTR ptsz2;
                        u = _tcstoul(ptsz, &ptsz2, 10);
                        ptsz = ptsz2;
                        // TRACE1("#%u\n", u);

                        if (u > MAX_WEIGHT)
                            u = MAX_WEIGHT; // clamp
                    }
                    else    // ignore word
                    {
                        while (*ptsz != _T('\0')  &&  !_istspace(*ptsz))
                            ptsz++;
                    }
                }
                else    // ignore word
                {
                    while (*ptsz != _T('\0')  &&  !_istspace(*ptsz))
                        ptsz++;
                }
            }
        }
    }

    return u;
}



//
// Read the multiline tip text.  Updates rptsz to point past the end of it.
//

static LPTSTR
GetTipText(
    LPTSTR& rptsz)
{
    LPTSTR ptszOrig = rptsz;
    LPTSTR ptszEol = _tcsstr(rptsz, _T("\n%%"));

    if (ptszEol != NULL)
    {
        // is it "\r\n"?
        if (ptszEol > rptsz  &&  ptszEol[-1] == _T('\r'))
            ptszEol[-1] = _T('\0');
        else
            ptszEol[0] = _T('\0');

        rptsz = ptszEol + 1;
    }   
    else
    {
        // no "\n%%", so point past the end of the string
        rptsz += _tcslen(rptsz);
    }

    // TRACE1("GetTipText: `%s'\n", ptszOrig);
    return ptszOrig;
}



//
// Set the Error Info.  It's up to the calling application to
// decide what to do with it.  By default, Denali/VBScript will
// print the error number (and message, if there is one) and
// abort the page.
//

static HRESULT
ReportError(
    HRESULT hr,
    DWORD   dwErr)
{
    HLOCAL pMsgBuf = NULL;

    // If there's a message associated with this error, report that
    if (::FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL, dwErr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &pMsgBuf, 0, NULL)
        > 0)
    {
        AtlReportError(CLSID_CContentRotator, (LPCTSTR) pMsgBuf,
                       IID_IContentRotator, hr);
    }

    // TODO: add some error messages to the string resources and
    // return those, if FormatMessage doesn't return anything (not
    // all system errors have associated error messages).
    
    // Free the buffer, which was allocated by FormatMessage
    if (pMsgBuf != NULL)
        ::LocalFree(pMsgBuf);

    return hr;
}



//
// Report a Win32 error code
//

static HRESULT
ReportError(
    DWORD dwErr)
{
    return ::ReportError(HRESULT_FROM_WIN32(dwErr), dwErr);
}



//
// Report an HRESULT error
//

static HRESULT
ReportError(
    HRESULT hr)
{
    return ::ReportError(hr, (DWORD) hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\devsmpl\pagecnt\critsec.h ===
//
// A class that allows you to enter a critical section and automatically
// leave when the object of this class goes out of scope.  Also provides
// the means to leave and re-enter as needed while protecting against
// entering or leaving out of sync.
//

class CAutoLeaveCritSec
{
public:
    CAutoLeaveCritSec(
        CComAutoCriticalSection& rCS)
        : m_CS(rCS), m_fInCritSec(FALSE)
    {Lock();}
    
    ~CAutoLeaveCritSec()
    {Unlock();}
    
    // Use this function to re-enter the critical section.
    void Lock()
    {if (!m_fInCritSec) {m_CS.Lock();   m_fInCritSec = TRUE;}}

    // Use this function to leave the critical section before going out
    // of scope.
    void Unlock()
    {if (m_fInCritSec)  {m_CS.Unlock(); m_fInCritSec = FALSE;}}

protected:    
    CComAutoCriticalSection& m_CS;
    BOOL                     m_fInCritSec;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\devsmpl\pagecnt\debug.cpp ===
#include "stdafx.h"

#include <stdio.h>
#include <stdarg.h>
#include "debug.h"


#define ACTIVE_SERVER_PAGES 1


#ifdef _DEBUG

void __cdecl
Trace(
    LPCTSTR ptszFormat,
    ...)
{
    TCHAR tszBuff[2048];
    va_list args;
    
    va_start(args, ptszFormat);
    _vstprintf(tszBuff, ptszFormat, args);
    va_end(args);

    OutputDebugString(tszBuff);
}



# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)


#  ifdef ACTIVE_SERVER_PAGES

// The default assertion mechanism set up by Visual C++ 4 will not
// work with Active Server Pages because it's running inside a service
// and there is no desktop to interact with.

// Note: for this to work properly, #define _WIN32_WINNT 0x400 before
// including <winuser.h> or MB_SERVICE_NOTIFICATION won't be #define'd.

int
__cdecl
AspAssertHandler(
    int   nReportType,
    char* pszErrorText,
    int*  pnReturn)
{
    const char szInfo[] = " (Press ABORT to terminate IIS,"
                          " RETRY to debug this failure,"
                          " or IGNORE to continue.)";
    char* pszMessageTitle = NULL;
    
    // These flags enable message boxes to show up on the user's console
    switch (nReportType)
    {
    case _CRT_WARN:
        pszMessageTitle = "Warning";
        break;
    case _CRT_ERROR:
        pszMessageTitle = "Fatal Error";
        break;
    case _CRT_ASSERT:
        pszMessageTitle = "Assertion Failed";
        break;
    }   
    
    char* pszMessageText =
        static_cast<char*>(_alloca(strlen(pszErrorText) + strlen(szInfo) + 1));

    strcpy(pszMessageText, pszErrorText);
    strcat(pszMessageText, szInfo);
    
    const int n = MessageBoxA(NULL, pszMessageText, pszMessageTitle,
                              (MB_SERVICE_NOTIFICATION | MB_TOPMOST
                               | MB_ABORTRETRYIGNORE | MB_ICONEXCLAMATION));

    if (n == IDABORT)
    {
        exit(1);
    }
    else if (n == IDRETRY)
    {
        *pnReturn = 1;   // tell _CrtDbgReport to start the debugger
        return TRUE;     // tell _CrtDbgReport to run
    }
    
    *pnReturn = 0;       // nothing for _CrtDbgReport to do

    return FALSE;
}

#  endif // ACTIVE_SERVER_PAGES
# endif // _MSC_VER >= 1000



void
DebugInit()
{
# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef ACTIVE_SERVER_PAGES
    // If we end up in _CrtDbgReport, don't put up a message box
    _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_WARN,   _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_ERROR,  _CRTDBG_MODE_DEBUG);

    // Use AspAssertHandler to put up a message box instead
    _CrtSetReportHook(AspAssertHandler);
#  endif // ACTIVE_SERVER_PAGES

    // Enable debug heap allocations & check for memory leaks at program exit
    // The memory leak check will not be performed if inetinfo.exe is
    // run directly under a debugger, only if it is run as a service.
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF
                   | _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG));
# endif // _MSC_VER >= 1000
}



void
DebugTerm()
{
# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef ACTIVE_SERVER_PAGES
    // Turn off AspAssertHandler, so that we don't get numerous message boxes
    // if there are memory leaks on shutdown
    _CrtSetReportHook(NULL);
#  endif // ACTIVE_SERVER_PAGES
# endif // _MSC_VER >= 1000
}

#endif //_DEBUG



BOOL
IsValidString(
    LPCTSTR ptsz,
    int nLength /* =-1 */)
{
    if (ptsz == NULL)
        return FALSE;

    return !IsBadStringPtr(ptsz, nLength);
}



BOOL
IsValidAddress(
    LPCVOID pv,
    UINT nBytes,
    BOOL fReadWrite /* =TRUE */)
{
    return (pv != NULL
            &&  !IsBadReadPtr(pv, nBytes)
            &&  (!fReadWrite  ||  !IsBadWritePtr((LPVOID) pv, nBytes)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\devsmpl\pagecnt\debug.h ===
/*
 * Some simple debugging macros that look and behave a lot like their
 * namesakes in MFC.  These macros should work in both C and C++ and
 * do something useful with almost any Win32 compiler.
 *
 * George V. Reilly  <georger@microcrafts.com>  <a-georgr@microsoft.com>
 */

#ifndef __DEBUG_H__
#define __DEBUG_H__

#ifdef _DEBUG

# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
   /* Use the new debugging tools in Visual C++ 4.x */
#  include <crtdbg.h>
   /* _ASSERTE will give a more meaningful message, but the string takes
    * space.  Use _ASSERT if this is an issue. */
#  define ASSERT(f) _ASSERTE(f)
# else
#  include <assert.h>
#  define ASSERT(f) assert(f)
# endif

# define VERIFY(f)               ASSERT(f)
# define DEBUG_ONLY(f)           (f)
# define TRACE                   Trace
# define TRACE0(psz)             Trace(_T("%s"), _T(psz))
# define TRACE1(psz, p1)         Trace(_T(psz), p1)
# define TRACE2(psz, p1, p2)     Trace(_T(psz), p1, p2)
# define TRACE3(psz, p1, p2, p3) Trace(_T(psz), p1, p2, p3)
# define DEBUG_INIT()            DebugInit()
# define DEBUG_TERM()            DebugTerm()

#else /* !_DEBUG */

  /* These macros should all compile away to nothing */
# define ASSERT(f)               ((void)0)
# define VERIFY(f)               ((void)(f))
# define DEBUG_ONLY(f)           ((void)0)
# define TRACE                   1 ? (void)0 : Trace
# define TRACE0(psz)
# define TRACE1(psz, p1)
# define TRACE2(psz, p1, p2)
# define TRACE3(psz, p1, p2, p3)
# define DEBUG_INIT()            ((void)0)
# define DEBUG_TERM()            ((void)0)

#endif /* !_DEBUG */


#define ASSERT_POINTER(p, type) \
    ASSERT(((p) != NULL)  &&  IsValidAddress((p), sizeof(type), FALSE))

#define ASSERT_NULL_OR_POINTER(p, type) \
    ASSERT(((p) == NULL)  ||  IsValidAddress((p), sizeof(type), FALSE))


/* Declarations for non-Windows apps */

#ifndef _WINDEF_
typedef void*           LPVOID;
typedef const void*     LPCVOID;
typedef unsigned int    UINT;
typedef int             BOOL;
typedef const char*     LPCTSTR;
#endif /* _WINDEF_ */

#ifndef TRUE
# define FALSE  0
# define TRUE   1
#endif


#ifdef __cplusplus
extern "C" {

/* Low-level sanity checks for memory blocks */
BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite = TRUE);
BOOL IsValidString(LPCTSTR ptsz, int nLength = -1);

#else /* !__cplusplus */

/* Low-level sanity checks for memory blocks */
BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite);
BOOL IsValidString(LPCTSTR ptsz, int nLength);

#endif /* !__cplusplus */

/* in debug version, writes trace messages to debug stream */
void __cdecl
Trace(
    LPCTSTR pszFormat,
    ...);

/* should be called from main(), WinMain(), or DllMain() */
void
DebugInit();

void
DebugTerm();

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* __DEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\devsmpl\pagecnt\page.cpp ===
// Page.cpp: Implementation of CPage and CPageArray

#include "stdafx.h"
#include "page.h"
#include "debug.h"


//Default Constructor
CPage::CPage()
    : m_Hits(0)
{
}


// Is the URL the same as this page's?
BOOL CPage::operator==(BSTR bstrURL) const
{
    //case-insensitive comparison
    return (_wcsicmp(m_URL, bstrURL) == 0);
}


//Default Constructor
CPageArray::CPageArray()
    : m_iMax(0), m_cAlloc(0), m_aPages(NULL)
{
}


//Destructor
CPageArray::~CPageArray()
{
    delete [] m_aPages;
}


// non-const operator[]
CPage& CPageArray::operator[](UINT iPage)
{
    ASSERT(0 <= iPage  &&  iPage < (UINT) m_iMax);

    return m_aPages[iPage];
}


// const operator[]
const CPage& CPageArray::operator[](UINT iPage) const
{
    ASSERT(0 <= iPage  &&  iPage < (UINT) m_iMax);

    return m_aPages[iPage];
}


// Find a URL in the array and return its index, or -1 if it's not present.
int CPageArray::FindURL(const BSTR bstrURL) const
{
    for (int i = 0; i < m_iMax; i++)
        if (m_aPages[i] == bstrURL)
            return i;

    return -1;
}


//Add a page to the array (if it's not already present) and
//increase its hitcount by ExtraHits.
UINT CPageArray::AddPage(const BSTR bstrURL, UINT ExtraHits)
{
    int i = FindURL(bstrURL);

    if (i >= 0)
    {
        // There are no duplicate URLs in this array; just adjust m_Hits
        ASSERT(i < m_iMax);
        m_aPages[i].m_Hits += ExtraHits;
    }
    else
    {
        // Not present, so append it
        ASSERT(0 <= m_iMax  &&  m_iMax <= m_cAlloc);
    
        if (m_iMax == m_cAlloc)
        {
            // grow the array because it's full
            CPage* pOldPages = m_aPages;
            m_cAlloc += CHUNK_SIZE;

            m_aPages = NULL;
            ATLTRY(m_aPages = new CPage[m_cAlloc]);
            
            if (m_aPages == NULL)
            {
                m_aPages = pOldPages;
                return BAD_HITS;
            }
            
            for (i = 0; i < m_iMax; i++)
                m_aPages[i] = pOldPages[i];

            delete [] pOldPages;
        }

        i = m_iMax++;
        m_aPages[i].m_URL  = bstrURL;
        m_aPages[i].m_Hits = ExtraHits;
    }

    return m_aPages[i].GetHits();
}


//Increment a page's hitcount by one
UINT CPageArray::IncrementPage(const BSTR bstrURL)
{
    // If the page is present, just add one to its count;
    // if it's not present, append it and set its count to one.
    return AddPage(bstrURL, 1);
}


//Get a page's hitcount
UINT CPageArray::GetHits(const BSTR bstrURL)
{
    const int i = FindURL(bstrURL);

    if (i >= 0)
    {
        ASSERT(i < m_iMax);
        return m_aPages[i].GetHits();
    }
    else
    {
        // Not present, so append it and zero its hitcount
        return AddPage(bstrURL, 0);
    }
}


//Reset a page's hitcount
void CPageArray::Reset(const BSTR bstrURL)
{
    const int i = FindURL(bstrURL);

    if (i >= 0)
    {
        ASSERT(i < m_iMax);
        m_aPages[i].ResetHits();
    }
    else
    {
        // Not present, so append it and zero its hitcount
        AddPage(bstrURL, 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\devsmpl\pagecnt\page.h ===
#ifndef __PAGE__
#define __PAGE__

// CPage: remember the URL of a page and the number of hits it's received
class CPage {

public:

    CPage();

    UINT GetHits() const            { return m_Hits; }
    UINT IncrementHits()            { return ++m_Hits; }
    void ResetHits()                { m_Hits = 0; }

    const CComBSTR& GetURL() const  { return m_URL; }
    BOOL operator==(BSTR bstrURL) const;

public:
    CComBSTR m_URL;                 //URL for this page
    UINT     m_Hits;                //Number of hits for this page

private:
    
    //Not Implemented 
    CPage(CPage& copy);             //copy constructor

};

#define BAD_HITS ((UINT) -1)


// CPageArray: a dynamic array of CPages
class CPageArray
{
public:
    CPageArray();
    ~CPageArray();

    CPage& operator[](UINT iPage);
    const CPage& operator[](UINT iPage) const;

    int  FindURL(const BSTR bstrURL) const;
    UINT AddPage(const BSTR bstrURL, UINT Hits);
    UINT IncrementPage(const BSTR bstrURL);
    UINT GetHits(const BSTR bstrURL);
    void Reset(const BSTR bstrURL);
    UINT Size() const               {return m_iMax;}

private:
    enum {CHUNK_SIZE = 200};
    
    int     m_iMax;         // current max index
    int     m_cAlloc;       // number of CPages in m_aPages
    CPage*  m_aPages;       // array of CPages

    //not implemented
    CPageArray(CPageArray& copy);                   //copy constructor
    CPageArray& operator=(const CPageArray& copy);  //assignment operator
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\devsmpl\pagecnt\ccm.h ===
#ifndef __COUNTER__
#define __COUNTER__


// ccm.h : Declaration of CCM, the Central Management Object
#include "resource.h"       // main symbols
#include "page.h"

// Registry Keys
#define HITCNT_HKEY      HKEY_CLASSES_ROOT
#define HITCNT_KEYNAME   _T("MSWC.PageCounter")
#define HITCNT_FILELOCN  _T("File_Location")
#define HITCNT_DFLT_FILE _T("%windir%\\HitCnt.cnt")
#define HITCNT_SAVECNT   _T("Save_Count")
#define HITCNT_DFLT_SAVE 25

/////////////////////////////////////////////////////////////////////////////
// Central Counter Manager

class CCM
{
public:
    CCM();
    ~CCM();

    //---- Object Methods ----

    //Increments hit count for this page
    DWORD IncrementAndGetHits(const BSTR bstrURL);

    // Get the hit count for this page
    LONG GetHits(const BSTR bstrURL);

    // Reset the hit count for this page to zero
    void Reset(const BSTR bstrURL);

    //---- Helper Functions ----
    
    //Initializes Page Counter
    BOOL Initialize();

    //Writes the data to disk
    BOOL Persist();

private:
    //Looks in Registry to get the file path and name
    BOOL GetFileName();

    //Looks in Registry to get the Save Count
    BOOL GetSaveCount();

    //Loads the persisted data into an array
    BOOL LoadData();

    TCHAR       m_tszFileName[MAX_PATH]; //path and filename for persisting
    DWORD       m_dwSaveCount;           //threshold to trigger persisting
    UINT        m_cUnsavedHits;          //hits since we last persisted
    CPageArray  m_pages;                 //array of pages
    CComAutoCriticalSection m_critsec;   //Critical Section to protect data

};

extern CCM CountManager;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\devsmpl\pagecnt\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PgCnt.rc
//
#define IDS_PGCNTOBJ_DESC	1



// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\devsmpl\pagecnt\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\devsmpl\pagecnt\ccm.cpp ===
// ccm.cpp : Implementation of CCM, the Central Counter Manager
// that persists as long as this DLL is loaded.  It manages the loading and
// updating of the Hit Count Data file.

#include "stdafx.h"
#include "ccm.h"
#include "debug.h"
#include "critsec.h"
#include <stdio.h>


/////////////////////////////////////////////////////////////////////////////
//

CCM::CCM()
    : m_dwSaveCount(HITCNT_DFLT_SAVE), m_cUnsavedHits(0)
{
    *m_tszFileName = _T('\0');
}

CCM::~CCM()
{
}

//Initialize Page Counter Component
BOOL CCM::Initialize()
{
    //Check Registry For File
    BOOL Result = GetFileName(); 

    //Read File
    Result = LoadData() && Result;

    //Check Registry For Persistence Threshold
    Result = GetSaveCount() && Result;

    return Result;
}

////////////////// Start Object Methods //////////////////

DWORD CCM::IncrementAndGetHits(const BSTR bstrURL)
{
    //Update m_dwSaveCount, in case it's been changed in registry
    GetSaveCount();

    CAutoLeaveCritSec alcs(m_critsec);

    UINT retval = m_pages.IncrementPage(bstrURL);
    if (retval == BAD_HITS)
        retval = 0;

    if(++m_cUnsavedHits >= m_dwSaveCount)
    {
        if (!Persist())
            retval = 0; //failure
        m_cUnsavedHits = 0;
    }

    return retval;
}


LONG CCM::GetHits (const BSTR bstrURL)
{
    CAutoLeaveCritSec alcs(m_critsec);

    LONG retval = m_pages.GetHits(bstrURL);
    if (retval == BAD_HITS)
        retval = 0;

    return retval;
}


void CCM::Reset (const BSTR bstrURL)  
{
    CAutoLeaveCritSec alcs(m_critsec);

    m_pages.Reset(bstrURL);
}

////////////////// Helper Methods //////////////////

//Get the filename for the persistent data from the registry
BOOL CCM::GetFileName()
{

    //Open the HitCnt Key
    CRegKey regKey;
    long retValue = regKey.Open(HITCNT_HKEY, HITCNT_KEYNAME, KEY_READ);

    DWORD dwType = REG_EXPAND_SZ;
    TCHAR tszTemp[MAX_PATH];
    DWORD dwSize = sizeof(tszTemp);

    if(retValue == ERROR_SUCCESS)
    {
      //Get the File_Location from the Registry
      retValue = RegQueryValueEx(regKey,
        HITCNT_FILELOCN,
        NULL,
        &dwType,
        (LPBYTE) tszTemp,
        &dwSize);
    }
     
    // If there's an error, use the default
    if(retValue != ERROR_SUCCESS
       || (dwType != REG_EXPAND_SZ && dwType != REG_SZ))
    {
        _tcscpy(tszTemp, HITCNT_DFLT_FILE);
    }

    //tszTemp contains an embedded environment variable (%windir%),
    //so expand it
    ExpandEnvironmentStrings(tszTemp, m_tszFileName, ARRAYSIZE(m_tszFileName));

    ATLTRACE(_T("GetFileName %s\n"), m_tszFileName);

    return TRUE;
    
}

//Get the threshold for updating the persistent data from the registry
BOOL CCM::GetSaveCount()
{

  //Open the HitCnt Key
  CRegKey regKey;
  long retValue = regKey.Open(HITCNT_HKEY, HITCNT_KEYNAME, KEY_READ);

  if(retValue == ERROR_SUCCESS)
  {

    DWORD dwType, dwSaveCount, dwSize = sizeof(dwSaveCount);  

    //Get the Save_Count from the Registry
    retValue = RegQueryValueEx(regKey,
        HITCNT_SAVECNT,
        NULL,
        &dwType,
        (LPBYTE)&dwSaveCount,
        &dwSize);

    if(retValue == ERROR_SUCCESS && dwType == REG_DWORD && dwSaveCount > 0)
    {
       m_dwSaveCount = dwSaveCount;
       return TRUE;
    }

  } 

  //Registry Lookup Failed so set Default to HITCNT_DFLT_SAVE
  m_dwSaveCount = HITCNT_DFLT_SAVE;
  return TRUE;

}

//Load URLs and Hit Counts from Disk
BOOL CCM::LoadData()
{
    //Update m_tszFileName, in case it's been changed in registry
    GetFileName();

    ATLTRACE(_T("LoadData(%s)\n"), m_tszFileName);

    BOOL retval = TRUE;

    //Attempt to Open File
    FILE* fp = _tfopen(m_tszFileName, _T("r+"));

    if(fp == NULL)
        return FALSE;

    for (;;)
    {
      char buffer[1024+15];
      UINT Hits;

      if (fgets(buffer, sizeof buffer, fp) == NULL)
      {
          // fgets returns NULL both on error and on EOF
          retval = (feof(fp) != 0);
          break;
      }
      if (sscanf(buffer, "%u%1024s", &Hits, buffer) != 2)
      {
          retval = FALSE;
          break;
      }
 
      USES_CONVERSION; //needed by A2OLE
      if (m_pages.AddPage(A2OLE(buffer), Hits) == BAD_HITS)
      {
          retval = FALSE;
          break;
      };
    }

    fclose(fp);
    
    return retval;
}


//Write out URLs and Hit Counts to Disk
BOOL CCM::Persist()
{
    //Update m_tszFileName, in case it's been changed in registry
    GetFileName();

    ATLTRACE(_T("Persist(%s)\n"), m_tszFileName);

    //Attempt to Open File
    FILE* fp = _tfopen(m_tszFileName, _T("w+"));

    if(fp == NULL)
        return FALSE;

    BOOL retval = TRUE;
    
    for(UINT count = 0; count < m_pages.Size(); count++)
    {
        USES_CONVERSION;
        int cch = fprintf(fp, "%i\t%s\n", m_pages[count].GetHits(),
                          OLE2CA(m_pages[count].GetURL()));
        if (cch < 0)
        {
            retval = FALSE;
        }
    }

    fclose(fp);

    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\devsmpl\pagecnt\pgcntobj.h ===
// PgCntObj.h : Declaration of the CPgCntObj


#include "resource.h"       // main symbols
#include <asptlb.h>         // Active Server Pages Definitions
#include "ccm.h"            // Central Counter Manager Definition


/////////////////////////////////////////////////////////////////////////////
// PgCnt

class CPgCntObj : 
    public CComDualImpl<IPgCntObj, &IID_IPgCntObj, &LIBID_PageCounter>, 
    public ISupportErrorInfo,
    public CComObjectRoot,
    public CComCoClass<CPgCntObj,&CLSID_CPgCntObj>
{
public:
    CPgCntObj()
    { 
        m_bOnStartPageCalled = FALSE; 
    }

    ~CPgCntObj() {}

BEGIN_COM_MAP(CPgCntObj)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPgCntObj)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CPgCntObj) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

    DECLARE_REGISTRY(CPgCntObj, _T("MSWC.PageCounter.1"),
                     _T("MSWC.PageCounter"), IDS_PGCNTOBJ_DESC,
                     THREADFLAGS_BOTH)

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IPgCntObj
public:
    //Standard Server Side Component Methods
    STDMETHOD  (OnStartPage) (IUnknown* piUnk);
    STDMETHOD  (OnEndPage)   ();

    //Custom Component Methods
    STDMETHOD (Hits)  (VARIANT varURL, LONG* plNumHits);
    STDMETHOD (Reset) (VARIANT varURL);

    BOOL         m_bOnStartPageCalled; // Safety Flag
    CComVariant  m_vtPathInfo;         // Path Information
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\devsmpl\pagecnt\pgcnt.cpp ===
// PgCnt.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this 
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f PgCntps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "PgCnt.h"
#include "PgCntObj.h"
#include "ccm.h"
#include "debug.h"

#define IID_DEFINED
#include "PgCnt_i.c"


CComModule _Module;

//Declare Global CCM Object
CCM CountManager;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CPgCntObj, CPgCntObj)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);

        DEBUG_INIT();

        //Initialize Global CountManager
        CountManager.Initialize();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        DEBUG_TERM();
        _Module.Term();

        //Persist Page Hits Information
        CountManager.Persist();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    //Add Registry Value for File_Location & Save_Count
            
    CRegKey regKey;
    LONG retVal = regKey.Create(HITCNT_HKEY, HITCNT_KEYNAME);

    ATLTRACE(_T("Create = %x\n"), retVal);

    //Set the Default File_Location
    if (retVal == ERROR_SUCCESS)
    {
        retVal = RegSetValueEx(
            regKey,
            HITCNT_FILELOCN,
            0,
            REG_EXPAND_SZ,
            (LPBYTE)HITCNT_DFLT_FILE,
            (_tcslen(HITCNT_DFLT_FILE)+1)*sizeof(TCHAR));
        ATLTRACE(_T("Set %s %s = %x\n"),
                 HITCNT_FILELOCN, HITCNT_DFLT_FILE, retVal);
    }
    
    //Set the Default Save_Cnt
    if (retVal == ERROR_SUCCESS)
    {
        const DWORD SaveCount = HITCNT_DFLT_SAVE;
        retVal = RegSetValueEx(
            regKey,
            HITCNT_SAVECNT,
            0,
            REG_DWORD,
            (LPBYTE)&SaveCount,
            sizeof(DWORD));
        ATLTRACE(_T("Set %s %d = %x\n"), HITCNT_SAVECNT, SaveCount, retVal);
    }
    
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\devsmpl\pagecnt\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently


#define STRICT
//#define WIN32_LEAN_AND_MEAN
//#define _WIN32_WINNT 0x400 // needed for MB_SERVICE_NOTIFICATION

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#define ARRAYSIZE(a)	(sizeof(a)/sizeof(*(a)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\devsmpl\pagecnt\pgcntobj.cpp ===
// PgCntObj.cpp : Implementation of CPgCntObj

#include "stdafx.h"
#include "PgCnt.h"
#include "PgCntObj.h"

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CPgCntObj::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_IPgCntObj,
    };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}


///////////// Standard Server-Side Component Methods ////////////////

STDMETHODIMP CPgCntObj::OnStartPage (IUnknown* piUnk)  
{
    //OnStartPage Called by Active Server Pages
    ATLTRACE(_T("OnStartPage Called\n"));
    
    // Initialize the PathInfo
    VariantInit(&m_vtPathInfo);

    if (!piUnk)
    {
        ATLTRACE(_T("OnStartPage: Bad pointer\n"));
        return E_POINTER;
    }

    // Get the IScriptingContext Interface
    CComQIPtr<IScriptingContext, &IID_IScriptingContext> piContext(piUnk);

    if (!piContext)
    {
        ATLTRACE(_T("OnStartPage: Can't get IScriptingContext\n"));
        return E_NOINTERFACE;
    }

    //Get the Request Object Pointer
    CComPtr<IRequest> piRequest;
    HRESULT hr = piContext->get_Request(&piRequest);

    if (FAILED(hr))
    {
        ATLTRACE(_T("OnStartPage: Can't get IRequest\n"));
        return hr;
    }

    //Get the ServerVariables Collection
    CComPtr<IRequestDictionary> piServerVariables;
    hr = piRequest->get_ServerVariables(&piServerVariables);

    if (FAILED(hr))
    {
        ATLTRACE(_T("Couldn't get ServerVariables\n"));
        return hr;
    }

    //Get the PATH_INFO item from the ServerVariables collection
    CComVariant vtIn(OLESTR("PATH_INFO")), vtOut;
    hr = piServerVariables->get_Item(vtIn, &vtOut);

    if (FAILED(hr))
    {
        ATLTRACE(_T("Couldn't get PATH_INFO\n"));
        return hr;
    }

    // vtOut Contains an IDispatch Pointer.  To fetch the value
    // for PATH_INFO, you must get the Default Value for the 
    // Object stored in vtOut using VariantChangeType.
    hr = VariantChangeType(&m_vtPathInfo, &vtOut, 0, VT_BSTR);
  
    if (FAILED(hr))
    {
        ATLTRACE(_T("OnStartPage: Couldn't change variant type\n"));
        return hr;
    }
    
    //Increment Count for this Page by Passing PATH_INFO to the CountManager
    int retCount = CountManager.IncrementAndGetHits(m_vtPathInfo.bstrVal);

    //Check for Error
    if (retCount == 0)
    {
        //Get Response Object Pointer
        CComPtr<IResponse> piResponse;
        hr = piContext->get_Response(&piResponse);
        
        if (FAILED(hr))
        {
            ATLTRACE(_T("OnStartPage: Can't get IResponse\n"));
            return hr;
        }
        
        piResponse->Write(CComVariant(
            OLESTR("<CENTER>An Error Has Occurred in")
            OLESTR("the PageCounter Object</CENTER>")));
        return E_FAIL;
    }

    //Set Safety Flag
    m_bOnStartPageCalled = TRUE;

    return S_OK;
}

STDMETHODIMP CPgCntObj::OnEndPage ()  
{
    ATLTRACE(_T("OnEndPage Called\n"));

    m_bOnStartPageCalled = FALSE;
    VariantClear(&m_vtPathInfo);

    return S_OK;
}

///////////// Custom Component Methods ////////////////

STDMETHODIMP CPgCntObj::Hits (/*in,optional*/ VARIANT varURL,
                            /*out,retval*/  LONG* plNumHits)  
{   
    ATLTRACE(_T("Hits Called\n"));

    //Check to make sure OnStartPage has been called
    if (!m_bOnStartPageCalled)
        return E_FAIL;

    //Check the parameters
    if (plNumHits == NULL)
        return E_POINTER;

    // if the optional URL isn't empty, use that; otherwise, use the
    // one for this page
    if (V_VT(&varURL) != VT_ERROR)
    {
		VARIANT varBstrURL;
		HRESULT hr = VariantChangeType(&varBstrURL, &varURL, 0, VT_BSTR);
		if (FAILED(hr))
			return hr;

        *plNumHits = CountManager.GetHits(V_BSTR(&varBstrURL));

		VariantClear(&varBstrURL);
    }
    else
        *plNumHits = CountManager.GetHits(m_vtPathInfo.bstrVal);
    
    return S_OK;
}

STDMETHODIMP CPgCntObj::Reset (/*in,optional*/ VARIANT varURL)
{
    ATLTRACE(_T("Reset Called\n"));

    //Check to make sure OnStartPage has been called
    if (!m_bOnStartPageCalled)
        return E_FAIL;
    
    // if the optional URL isn't empty, use that; otherwise, use the
    // one for this page
    if (V_VT(&varURL) != VT_ERROR)
    {
		VARIANT varBstrURL;
		HRESULT hr = VariantChangeType(&varBstrURL, &varURL, 0, VT_BSTR);
		if (FAILED(hr))
			return hr;

        CountManager.Reset(V_BSTR(&varBstrURL));

		VariantClear(&varBstrURL);
    }
    else
        CountManager.Reset(m_vtPathInfo.bstrVal);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\devsmpl\permchk\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PermChk.rc
//
#define IDS_PERMCHK_DESC	1



// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\devsmpl\permchk\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\devsmpl\permchk\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\devsmpl\permchk\chkobj.cpp ===
// ChkObj.cpp : Implementation of CPermChkApp and DLL registration.

#include "stdafx.h"
#include "PermChk.h"
#include "ChkObj.h"
#include "util.h"

////////////////////////////////////////////////////////////////
//
// Utility functions

//
// Try to open file to see if read access is allowed
//

static VARIANT_BOOL DoesUserHaveAccessToFile(LPCTSTR ptszFilename)
{
    HANDLE hFile = 
        ::CreateFile(ptszFilename, GENERIC_READ, FILE_SHARE_READ,
                     NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                     NULL);
    if (hFile == INVALID_HANDLE_VALUE)
        return VARIANT_FALSE;
    ::CloseHandle(hFile);
    return VARIANT_TRUE;
}

static VARIANT_BOOL DoesUserHaveAccessToFile(BSTR bstrFilename)
{
    USES_CONVERSION;    // needed for OLE2T
    LPCTSTR ptszFilename = OLE2T(bstrFilename);
    return DoesUserHaveAccessToFile(ptszFilename);
}

////////////////////////////////////////////////////////////////
//

//
//

CPermissionChecker::CPermissionChecker()
{
}

//
//

CPermissionChecker::~CPermissionChecker()
{
}

//
//  Generated by ATL wizard
//

STDMETHODIMP CPermissionChecker::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_IPermissionChecker,
    };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

//
// ASP gets loaded.
// Keep pointer to the Server object from Scripting Context.
//

STDMETHODIMP CPermissionChecker::OnStartPage(IUnknown* pUnk)
{
    if (pUnk == NULL)
        return ::ReportError(E_POINTER);

    // Get the IScriptingContext Interface
    CComQIPtr<IScriptingContext, &IID_IScriptingContext> pContext(pUnk);

    if (!pContext)
        return ::ReportError(E_NOINTERFACE);

    // Get Server Object Pointer
    return pContext->get_Server(&m_piServer);
}

//
// ASP goes out of context.
// Release script context.
//

STDMETHODIMP CPermissionChecker::OnEndPage()
{
    m_piServer.Release();
    return S_OK;
}

//
// Checks the persmissions for the context user to access
// a page, or a file
//

STDMETHODIMP CPermissionChecker::HasAccess(
    BSTR bstrLocalUrl,
    VARIANT_BOOL *pfRetVal)
{
    if (bstrLocalUrl == NULL || pfRetVal == NULL)
        return ::ReportError(E_POINTER);

    *pfRetVal = VARIANT_FALSE;

    // Do we have a valid Server object?
    if (!m_piServer)
        return ::ReportError(E_NOINTERFACE);

    // Map logical filename to a physical filesystem name
    CComBSTR bstrPhysicalFile;
    HRESULT  hr = m_piServer->MapPath(bstrLocalUrl, &bstrPhysicalFile);

    if (SUCCEEDED(hr))
        *pfRetVal = ::DoesUserHaveAccessToFile(bstrPhysicalFile);
    else // failed to map as URL, try as regular path
        *pfRetVal = ::DoesUserHaveAccessToFile(bstrLocalUrl);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\devsmpl\permchk\util.h ===
// Util.h : Header for utility functions used by control code

#ifndef __UTIL_H__
#define __UTIL_H__

HRESULT ReportError(DWORD dwErr);
HRESULT ReportError(HRESULT hr);

#endif /* __UTIL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\devsmpl\permchk\chkobj.h ===
// ChkObj.h : Declaration of the CPermissionChecker


#include "resource.h"       // main symbols
#include <asptlb.h>

/////////////////////////////////////////////////////////////////////////////
// PermChk

class CPermissionChecker : 
    public CComDualImpl<IPermissionChecker, &IID_IPermissionChecker, &LIBID_PermissionChecker>, 
    public ISupportErrorInfo,
    public CComObjectRoot,
    public CComCoClass<CPermissionChecker,&CLSID_CPermissionChecker>
{
public:
    CPermissionChecker();
    ~CPermissionChecker();

BEGIN_COM_MAP(CPermissionChecker)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPermissionChecker)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//DECLARE_NOT_AGGREGATABLE(CPermissionChecker) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CPermissionChecker, 
                 _T("MSWC.PermissionChecker.1"), 
                 _T("MSWC.PermissionChecker"),
                 IDS_PERMCHK_DESC,
                 THREADFLAGS_BOTH)

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IPermissionChecker
public:
    STDMETHOD(OnStartPage)(IUnknown* pUnk);
    STDMETHOD(OnEndPage)();

    STDMETHOD(HasAccess)(BSTR bstrLocalUrl, 
                         VARIANT_BOOL *pfRetVal);
    
private:
    CComPtr<IServer>    m_piServer;          // Server Object
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\devsmpl\permchk\permchk.cpp ===
// PermChk.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this 
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f PermChkps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "PermChk.h"
#include "ChkObj.h"

#define IID_DEFINED
#include "PermChk_i.c"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CPermissionChecker, CPermissionChecker)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\devsmpl\permchk\util.cpp ===
// Util.cpp : Utility functions used by control code

#include "stdafx.h"
#include "PermChk.h"
#include "util.h"

//
//

static HRESULT ReportError(HRESULT hr, DWORD dwErr)
{
    HLOCAL pMsgBuf = NULL;

    // If there's a message associated with this error, report that
    if (FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL, dwErr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &pMsgBuf, 0, NULL)
        > 0)
    {
        AtlReportError(CLSID_CPermissionChecker,
			           (LPCTSTR) pMsgBuf,
                       IID_IPermissionChecker, hr);
    }

    // Free the buffer, which was allocated by FormatMessage
    if (pMsgBuf != NULL)
        ::LocalFree(pMsgBuf);
    return hr;
}

//
// Report a Win32 error code
//

HRESULT ReportError(DWORD dwErr)
{
    return ReportError(HRESULT_FROM_WIN32(dwErr), dwErr);
}

//
// Report an HRESULT error
//

HRESULT ReportError(HRESULT hr)
{
    return ReportError(hr, (DWORD) hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\easp\comp\src\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\easp\comp\src\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\makevers\makevers.cpp ===
/*
 * Program to make verdep.h
 
   Owner:
   Lei Jin(leijin)
   
   Borrowed from Access team.(Andrew)
 */
#pragma hdrstop
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "windows.h"

main()
	{
	// need to collect the current date, the version number, the version
	// type, and the volume label.
	struct tm *tmTime;
	char szVersNum[120];
	char szbuf[256];
	char *szMakeType, *szUserName;
	time_t tt;

	static char *szMonth[] =
		{
		"January",
		"February",
		"March",
		"April",
		"May",
		"June",
		"July",
		"August",
		"September",
		"October",
		"November",
		"December"
		};


	// Get the time
	time(&tt);
	tmTime = localtime(&tt);
  

	// Get the types from environment
	szMakeType = getenv("MAKETYPE");

	if (!szMakeType)
		szMakeType = "Unknown";


	// Get the user name
	szUserName = getenv("USERNAME");

	if (!szUserName)
		{
		//unsigned long dw;

		if (!GetVolumeInformation(NULL, szbuf, 255, NULL, NULL, NULL, NULL, 0))
			szUserName = "NOBODY";
		else
			szUserName = szbuf;
		}

	// Get the version number from stdin
	//gets(szVersNum);
	sprintf(szVersNum, "2");	
	

	printf("#define vszMakeDate\t\"%s %d, 19%d\"\n", szMonth[tmTime->tm_mon], tmTime->tm_mday, tmTime->tm_year);
	printf("#define vszMakeVers\t\"Version %s - %s - %s\"\n", szVersNum, szMakeType, szUserName);
	printf("#define vszVersNum\t\"%s\"\n", szVersNum, szMakeType);
	printf("#define vszCopyright\t\"Copyright \251 1996 Microsoft Corp.\"\n");
	printf("#define vszVersName\t\"%s (%s)\"\n", szUserName, szMakeType);
	printf("#define vszMakeSerial\t\"%02d-%02d-%02d-%02d%02d%02d\"\n", tmTime->tm_mon + 1, tmTime->tm_mday, tmTime->tm_year, 
		tmTime->tm_hour, tmTime->tm_min, tmTime->tm_sec);
	printf("#define vszDenaliVersion\t%s.%02d.%02d.0\n", szVersNum, (tmTime->tm_year - 96)*12 + tmTime->tm_mon + 1, tmTime->tm_mday);
	printf("#define vszDenaliVersionNULL\t\"%s.%02d.%02d.0\\0\"\n", szVersNum, (tmTime->tm_year - 96)*12 + tmTime->tm_mon + 1, tmTime->tm_mday);
	
	// the following block is for the version stamp resource
	{
	#include <string.h>
	char *sz;
	// major
	if(sz = strtok(szVersNum, ".\n \t"))
		printf("#define rmj\t\t%0u\n", atoi(sz));
	// minor
	if(sz = strtok(NULL, ".\n \t"))
		printf("#define rmm\t\t%01u\n", atoi(sz));
	else
		printf("#define rmm\t\t0\n");
	// release
	if(sz = strtok(NULL, ""))
		printf("#define rup\t\t%0u\n", atoi(sz));
	else
		printf("#define rup\t\t0\n");
	}

	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\easp\cmd\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by easp.rc
//

#define IDS_USAGE1                      1001
#define IDS_USAGE2                      1002
#define IDS_USAGE3                      1003
#define IDS_USAGE4                      1004
#define IDS_USAGE5                      1005
#define IDS_USAGE6                      1006
#define IDS_USAGE7                      1007
#define IDS_ERR_INVALID_ARGS            1008
#define IDS_ERR_ALREADY_ENCRYPTED       1009
#define IDS_ERR_FAILED_TO_ENCRYPT       1010
#define IDS_ERR_FAILED_TO_DECRYPT       1011
#define IDS_STATUS_OK                   1012
#define IDS_STATUS_IO_ERROR             1013
#define IDS_STATUS_UNENCRYPTED          1014
#define IDS_STATUS_INVALID_PASSWORD     1015
#define IDS_STATUS_FILE_CORRUPTED       1016
#define IDS_MSG_ENCRYPTED_OK            1017
#define IDS_MSG_DECRYPTED_OK            1018
#define IDS_MSG_TEST                    1019
#define IDS_EASP_PRINTABLE_HEADER	    1020

#define MAX_IDS_USAGE   IDS_USAGE7
#define NUM_IDS_USAGE   MAX_IDS_USAGE-IDS_USAGE1+1

#define FIRST_IDS       IDS_USAGE1
#define LAST_IDS        IDS_EASP_PRINTABLE_HEADER
#define NUM_IDS         LAST_IDS-FIRST_IDS+1


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        10001
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         20000
#define _APS_NEXT_SYMED_VALUE           10001
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\easp\cmd\src\easpmain.cpp ===
// easpmain.cpp : Implementation of the command line utility for EASP

#include <stdio.h>
#include <mbstring.h>
#include <windows.h>

#include "easpcore.h"
#include "resource.h"

/////////////////////////////////////////////////////////////////////////

typedef enum { OP_ENCRYPT, OP_DECRYPT, OP_TEST } EASP_OP;

#define MAX_EASP_PASSWORD_LEN    32
#define MAX_EASP_FILENAME_LEN    1024
#define MAX_EASP_STATUS_LEN      30

/////////////////////////////////////////////////////////////////////////
// local function prototypes

void FatalError();
void LoadResourceStrings();

void PrintUsageAndExit(BOOL fError = TRUE);
void PrintAlreadyEncryptError(LPCSTR pszFile);
void PrintEncryptError(LPCSTR pszFile);
void GetStatusString(EASP_STATUS esStatus, LPSTR lpszStatus);
void PrintDecryptError(LPCSTR pszFile, EASP_STATUS esStatus);
void PrintEncryptSuccess(LPCSTR pszFile);
void PrintDecryptSuccess(LPCSTR pszFile);
void PrintTestMessage(LPCSTR pszFile, EASP_STATUS esStatus, BOOL fVerbose);

void DoOneFile(LPCSTR pszFile, LPCSTR pszPassword, EASP_OP op, BOOL fVerbose);
void DoDirRecursively(LPCSTR pszDir, LPCSTR pszPattern, LPCSTR pszPassword, EASP_OP op, BOOL fVerbose);
void GetPathAndNameFromFilename(LPCSTR pszFilename, LPSTR pszPath, LPSTR pszFile);

/////////////////////////////////////////////////////////////////////////
// strings from resources

#define RESOURCE_STR_LEN    128

CHAR g_szStrings[NUM_IDS][2*RESOURCE_STR_LEN+1];

static void FatalError()
{
    fprintf(stderr, "easp: fatal error\n");
    exit(1);
}

static void LoadResourceStrings()
{
    HMODULE hInst = GetModuleHandle(NULL);
    if (hInst == NULL)
        FatalError();

    for (int i = 0; i < NUM_IDS; i++)
        {
        if (LoadString(hInst,
                       FIRST_IDS+i,
                       g_szStrings[i],
                       RESOURCE_STR_LEN) == 0)
            FatalError();
        }
}

static inline LPSTR ResStr(UINT id)
{
    if (id >= FIRST_IDS && id <= LAST_IDS)
        return g_szStrings[id-FIRST_IDS];
    return NULL;
}

// for use from outside
int LoadCmdResourceString(UINT id, BYTE *lpBuf, int nBufLen)
{
    LPSTR lpStr = ResStr(id);
    if (lpStr == NULL)
        return 0;
    _mbsncpy(lpBuf, (UCHAR *)lpStr, nBufLen);
    return _mbslen(lpBuf);
}

/////////////////////////////////////////////////////////////////////////
// functions that print

static void PrintUsageAndExit(BOOL fError)
{
    if (fError)
        fprintf(stderr, ResStr(IDS_ERR_INVALID_ARGS));
        
    for (int i = 0; i < NUM_IDS_USAGE; i++)
        fprintf(stderr, ResStr(IDS_USAGE1+i));
        
    exit(0);
}

static void PrintAlreadyEncryptError(LPCSTR pszFile)
{
    fprintf(stderr, ResStr(IDS_ERR_ALREADY_ENCRYPTED), pszFile);
}

static void PrintEncryptError(LPCSTR pszFile)
{
    fprintf(stderr, ResStr(IDS_ERR_FAILED_TO_ENCRYPT), pszFile);
}

static void GetStatusString(EASP_STATUS esStatus, LPSTR lpszStatus)
{
    switch (esStatus)
        {
        default:
        case EASP_OK:
            _mbscpy((UCHAR *)lpszStatus, (UCHAR *)ResStr(IDS_STATUS_OK));
            break;
        case EASP_FAILED:
            _mbscpy((UCHAR *)lpszStatus, (UCHAR *)ResStr(IDS_STATUS_IO_ERROR));
            break;
        case EASP_BAD_MAGIC:
            _mbscpy((UCHAR *)lpszStatus, (UCHAR *)ResStr(IDS_STATUS_UNENCRYPTED));
            break;
        case EASP_BAD_PASSWORD:
            _mbscpy((UCHAR *)lpszStatus, (UCHAR *)ResStr(IDS_STATUS_INVALID_PASSWORD));
            break;
        case EASP_BAD_HEADER:
        case EASP_BAD_CONTENT:
            _mbscpy((UCHAR *)lpszStatus, (UCHAR *)ResStr(IDS_STATUS_FILE_CORRUPTED));
            break;
        }
}

static void PrintDecryptError(LPCSTR pszFile, EASP_STATUS esStatus)
{
    CHAR szStatus[2*MAX_EASP_STATUS_LEN+1];
    GetStatusString(esStatus, szStatus);

    fprintf(stderr, ResStr(IDS_ERR_FAILED_TO_DECRYPT), pszFile, szStatus);
}

static void PrintEncryptSuccess(LPCSTR pszFile)
{
    printf(ResStr(IDS_MSG_ENCRYPTED_OK), pszFile);
}

static void PrintDecryptSuccess(LPCSTR pszFile)
{
    printf(ResStr(IDS_MSG_DECRYPTED_OK), pszFile);
}

static void PrintTestMessage(LPCSTR pszFile, EASP_STATUS esStatus, BOOL fVerbose)
{
    if (esStatus == EASP_OK && !fVerbose)
        return;

    char szStatus[2*MAX_EASP_STATUS_LEN+1];
    GetStatusString(esStatus, szStatus);
    printf(ResStr(IDS_MSG_TEST), pszFile, szStatus);
}

/////////////////////////////////////////////////////////////////////////
// process a single file

static void DoOneFile(LPCSTR pszFile, LPCSTR pszPassword, EASP_OP op, BOOL fVerbose)
{
    HRESULT hr;
    EASP_STATUS esStatus;

    switch (op)
        {
        case OP_ENCRYPT:
            {
            // test if already encrypted
            hr = TestPage(pszPassword, pszFile, &esStatus);
            if (SUCCEEDED(hr) && esStatus != EASP_BAD_MAGIC)
                {
                PrintAlreadyEncryptError(pszFile);
                break;
                }
            hr = EncryptPageInplace(pszPassword, pszFile);
            if (!SUCCEEDED(hr))
                PrintEncryptError(pszFile);
            else if (fVerbose)
                PrintEncryptSuccess(pszFile);
            }
            break;
        case OP_DECRYPT:
            {
            hr = DecryptPageInplace(pszPassword, pszFile, &esStatus);
            if (!SUCCEEDED(hr))
                PrintDecryptError(pszFile, esStatus);
            else if (fVerbose)
                PrintDecryptSuccess(pszFile);
            }
            break;
        case OP_TEST:
            {
            TestPage(pszPassword, pszFile, &esStatus);
            PrintTestMessage(pszFile, esStatus, fVerbose);
            }
            break;
        }
}

/////////////////////////////////////////////////////////////////////////

static void DoDirRecursively(LPCSTR pszDir, LPCSTR pszPattern, LPCSTR pszPassword, EASP_OP op, BOOL fVerbose)
{
    WIN32_FIND_DATA finddata;
    HANDLE hFind;
    CHAR szFile[2*MAX_EASP_FILENAME_LEN+1];

    // first go through files in this directory

    _mbscpy((UCHAR *)szFile, (UCHAR *)pszDir);
    _mbscat((UCHAR *)szFile, (UCHAR *)pszPattern);
    hFind = FindFirstFile(szFile, &finddata);
    if (hFind != INVALID_HANDLE_VALUE)
        {
        do // go through files and do 'op' on each of them
            if ((finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
                {
                _mbscpy((UCHAR *)szFile, (UCHAR *)pszDir);
                _mbscat((UCHAR *)szFile, (UCHAR *)finddata.cFileName);
                DoOneFile(szFile, pszPassword, op, fVerbose);
                }
        while (FindNextFile(hFind, &finddata));
        FindClose(hFind);
        }
        
    // go through sub directories and call itself recursively
    
    _mbscpy((UCHAR *)szFile, (UCHAR *)pszDir);
    _mbscat((UCHAR *)szFile, (UCHAR *)"*.*");
    hFind = FindFirstFile(szFile, &finddata);
    if (hFind != INVALID_HANDLE_VALUE)
        {
        do // go through directories
            if ((finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0
                && finddata.cFileName[0] != '.') // to avoid . and ..
                {
                _mbscpy((UCHAR *)szFile, (UCHAR *)pszDir);
                _mbscat((UCHAR *)szFile, (UCHAR *)finddata.cFileName);
                _mbscat((UCHAR *)szFile, (UCHAR *)"\\");
                DoDirRecursively(szFile, pszPattern, pszPassword, op, fVerbose);
                }
        while (FindNextFile(hFind, &finddata));
        FindClose(hFind);
        }
}

/////////////////////////////////////////////////////////////////////////

static void GetPathAndNameFromFilename(LPCSTR pszFilename, LPSTR pszPath, LPSTR pszFile)
{
    _mbscpy((UCHAR *)pszPath, (UCHAR *)pszFilename);
    UCHAR *p = _mbsrchr((UCHAR *)pszPath, '\\');
    if (p != NULL)
        {
        _mbscpy((UCHAR *)pszFile, p+1);
        *(p+1) = '\0';
        }
    else
        {
        pszPath[0] = '\0';
        _mbscpy((UCHAR *)pszFile, (UCHAR *)pszFilename);
        }
}

/////////////////////////////////////////////////////////////////////////
// main

int main(int argc, char *argv[])
{
    LoadResourceStrings();

    if (argc == 1)
        PrintUsageAndExit(FALSE);

    // parse options

    EASP_OP op;
    CHAR    szPassword[2*MAX_EASP_PASSWORD_LEN+1];
    BOOL    fVerbose = FALSE;
    BOOL    fRecurse = FALSE;

    BOOL fOpSet       = FALSE;
    BOOL fPasswordSet = FALSE;

    int iarg = 1;

    while (iarg < argc && *(argv[iarg]) == '-')
        {
        CHAR *arg = argv[iarg++];
        UCHAR *uarg = (UCHAR *)arg;
        int argl = _mbslen(uarg);
        uarg = _mbsinc(uarg); // skip -

        for (int ic = 1; ic < argl; ic++, uarg = _mbsinc(uarg))
            {
            switch (*uarg)
                {
                case 'e':
                    if (fOpSet)
                        break;
                    op = OP_ENCRYPT; 
                    fOpSet = TRUE;
                    continue;
                case 'd':
                    if (fOpSet)
                        break;
                    op = OP_DECRYPT;
                    fOpSet = TRUE;
                    continue;
                case 't':
                    if (fOpSet)
                        break;
                    op = OP_TEST;
                    fOpSet = TRUE;
                    continue;
                case 'p':
                    if (fPasswordSet)
                        break;
                    if (iarg >= argc)
                        break;
                    ic = argl;
                    _mbsncpy((UCHAR *)szPassword, 
                             (UCHAR *)argv[iarg++], 
                             MAX_EASP_PASSWORD_LEN);
                    fPasswordSet = TRUE;
                    continue;
                case 'v':
                    fVerbose = TRUE;
                    continue;
                case 'r':
                    fRecurse = TRUE;
                    continue;
                }
            PrintUsageAndExit();
            }
        }

    if (!fPasswordSet || !fOpSet || iarg >= argc)
       PrintUsageAndExit();

    // files

    CHAR szFile[2*MAX_EASP_FILENAME_LEN+1];
    CHAR szPath[2*MAX_EASP_FILENAME_LEN+1];

    for (int i = iarg; i < argc; i++)
        {
        CHAR *arg = argv[i];
        GetPathAndNameFromFilename(arg, szPath, szFile);
        
        if (fRecurse)
            {
            // do files and then recurse
            DoDirRecursively(szPath, szFile, szPassword, op, fVerbose);
            continue;
            }

        // for each file argument expand wildcards

        WIN32_FIND_DATA finddata;
        HANDLE hFind = FindFirstFile(arg, &finddata);
        if (hFind == INVALID_HANDLE_VALUE)
            {
            // nothing matches -> interpret as filename
            _mbscpy((UCHAR *)szFile, (UCHAR *)arg);
            DoOneFile(szFile, szPassword, op, fVerbose);
            continue; 
            }

        do // go through files and do 'op' on each of them
            if ((finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
                {
                _mbscpy((UCHAR *)szFile, (UCHAR *)szPath);
                _mbscat((UCHAR *)szFile, (UCHAR *)finddata.cFileName);
                DoOneFile(szFile, szPassword, op, fVerbose);
                }
        while (FindNextFile(hFind, &finddata));
        
        FindClose(hFind);
        }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\easp\comp\src\compobj.cpp ===
// CompObj.cpp : Implementation of CeaspcompApp and DLL registration.

#include "stdafx.h"
#include "easpcomp.h"
#include "CompObj.h"

#include "easpcore.h"

/////////////////////////////////////////////////////////////////////////////
//

STDMETHODIMP CASPEncryption::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IASPEncryption,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Constructor/Destructor

CASPEncryption::CASPEncryption() : m_fOnPage(FALSE)
{
}

CASPEncryption::~CASPEncryption()
{
}

/////////////////////////////////////////////////////////////////////////////
// OnStart/End

STDMETHODIMP CASPEncryption::OnStartPage(IUnknown* pUnk)
{
    m_fOnPage = TRUE;
    
    if (pUnk == NULL)
        return ReportError(E_POINTER);

    // Get the IScriptingContext Interface
    CComQIPtr<IScriptingContext, &IID_IScriptingContext> pContext(pUnk);

    if (!pContext)
        return ReportError(E_NOINTERFACE);

    // Get Server Object Pointer
    return pContext->get_Server(&m_piServer);
}

//
// ASP goes out of context.
// Release script context.
//

STDMETHODIMP CASPEncryption::OnEndPage()
{
    m_piServer.Release();
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Unitility methods

HRESULT CASPEncryption::MapVirtualPath(BSTR bstrPage, CComBSTR &bstrFile)
{
    if (!bstrFile)
        bstrFile.Empty();

    if (bstrPage != NULL)
        {
        BOOL fMapped = FALSE;
        if (m_fOnPage)
            {
            if (!m_piServer)
               return ReportError(E_NOINTERFACE);
            HRESULT hr = m_piServer->MapPath(bstrPage, &bstrFile);
            if (SUCCEEDED(hr))
                fMapped = TRUE;
            }
        if (!fMapped)
            bstrFile = bstrPage;
        }

    return S_OK;
}

HRESULT CASPEncryption::ReportError(HRESULT hr, DWORD dwErr)
{
    HLOCAL pMsgBuf = NULL;
    // If there's a message associated with this error, report that
    if (FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL, dwErr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &pMsgBuf, 0, NULL)
        > 0)
        {
        AtlReportError(CLSID_CASPEncryption,
			           (LPCTSTR) pMsgBuf,
                       IID_IASPEncryption, hr);
        }

    // Free the buffer, which was allocated by FormatMessage
    if (pMsgBuf != NULL)
        ::LocalFree(pMsgBuf);
    return hr;
}

HRESULT CASPEncryption::ReportError(DWORD dwErr)
{
    return ReportError(HRESULT_FROM_WIN32(dwErr), dwErr);
}

HRESULT CASPEncryption::ReportError(HRESULT hr)
{
    return ReportError(hr, (DWORD) hr);
}

/////////////////////////////////////////////////////////////////////////////
// Inteface methods

HRESULT CASPEncryption::EncryptInplace(
    BSTR bstrPassword,
    BSTR bstrPage,
    VARIANT_BOOL* pfRetVal)
{
    if (bstrPassword == NULL || bstrPage == NULL || pfRetVal == NULL)
        return ReportError(E_POINTER);
    *pfRetVal = VARIANT_FALSE;

    // map virtual path
    
    HRESULT hr;
    CComBSTR bstrFile;
    hr = MapVirtualPath(bstrPage, bstrFile);
    if (FAILED(hr))
        return ReportError(hr);

    // call easpcore function to encrypt

    USES_CONVERSION;    // needed for OLE2T
    hr = EncryptPageInplace(OLE2T(bstrPassword), OLE2T(bstrFile));
    if (FAILED(hr))
        return ReportError(hr);

    *pfRetVal = VARIANT_TRUE;
    return S_OK;
}

////////////////////////////////////////
	                
HRESULT CASPEncryption::EncryptCopy(
    BSTR bstrPassword,
    BSTR bstrFromPage,
    BSTR bstrToPage,
    VARIANT_BOOL* pfRetVal)
{
    if (bstrPassword == NULL || bstrFromPage == NULL || bstrToPage == NULL || pfRetVal == NULL)
        return ReportError(E_POINTER);
    *pfRetVal = VARIANT_FALSE;

    // map virtual paths
    
    HRESULT hr;
    CComBSTR bstrFile1, bstrFile2;
    hr = MapVirtualPath(bstrFromPage, bstrFile1);
    if (FAILED(hr))
        return ReportError(hr);
    hr = MapVirtualPath(bstrToPage, bstrFile2);
    if (FAILED(hr))
        return ReportError(hr);

    // call easpcore function to encrypt

    USES_CONVERSION;    // needed for OLE2T
    hr = EncryptPage(OLE2T(bstrPassword), OLE2T(bstrFile1), OLE2T(bstrFile2));
    if (FAILED(hr))
        return ReportError(hr);

    *pfRetVal = VARIANT_TRUE;
    return S_OK;
}                	

////////////////////////////////////////

HRESULT CASPEncryption::TestEncrypted(
    BSTR bstrPassword,
    BSTR bstrPage,
    VARIANT_BOOL* pfRetVal)
{
    if (bstrPassword == NULL || bstrPage == NULL || pfRetVal == NULL)
        return ReportError(E_POINTER);
    *pfRetVal = VARIANT_FALSE;

    // map virtual path
    
    HRESULT hr;
    CComBSTR bstrFile;
    hr = MapVirtualPath(bstrPage, bstrFile);
    if (FAILED(hr))
        return ReportError(hr);

    // call easpcore function to test

    EASP_STATUS esStatus = EASP_FAILED;
    USES_CONVERSION;    // needed for OLE2T
    hr = TestPage(OLE2T(bstrPassword), OLE2T(bstrFile), &esStatus);
    if (FAILED(hr))
        return ReportError(hr);

    if (esStatus == EASP_OK)
       *pfRetVal = VARIANT_TRUE;
    return S_OK;
}

////////////////////////////////////////

HRESULT CASPEncryption::IsEncrypted(
    BSTR bstrPage,
    VARIANT_BOOL* pfRetVal)
{
    if (bstrPage == NULL || pfRetVal == NULL)
        return ReportError(E_POINTER);
    *pfRetVal = VARIANT_FALSE;

    // map virtual path
    
    HRESULT hr;
    CComBSTR bstrFile;
    hr = MapVirtualPath(bstrPage, bstrFile);
    if (FAILED(hr))
        return ReportError(hr);

    // call easpcore function to test with blank password

    CComBSTR bstrPassword("");
    EASP_STATUS esStatus = EASP_FAILED;
    USES_CONVERSION;    // needed for OLE2T
    hr = TestPage(OLE2T(bstrPassword), OLE2T(bstrFile), &esStatus);
    if (FAILED(hr))
        return ReportError(hr);
    if (esStatus == EASP_OK || esStatus == EASP_BAD_PASSWORD)
       *pfRetVal = VARIANT_TRUE;
    return S_OK;
}

////////////////////////////////////////

HRESULT CASPEncryption::VerifyPassword(
    BSTR bstrPassword,
    BSTR bstrPage,
    VARIANT_BOOL* pfRetVal)
{
    if (bstrPassword == NULL || bstrPage == NULL || pfRetVal == NULL)
        return ReportError(E_POINTER);
    *pfRetVal = VARIANT_FALSE;

    // map virtual path
    
    HRESULT hr;
    CComBSTR bstrFile;
    hr = MapVirtualPath(bstrPage, bstrFile);
    if (FAILED(hr))
        return ReportError(hr);

    // call easpcore function to test

    EASP_STATUS esStatus = EASP_FAILED;
    USES_CONVERSION;    // needed for OLE2T
    hr = TestPage(OLE2T(bstrPassword), OLE2T(bstrFile), &esStatus);
    if (FAILED(hr))
        return ReportError(hr);

    if (esStatus == EASP_OK || esStatus == EASP_BAD_CONTENT)
       *pfRetVal = VARIANT_TRUE;
    return S_OK;
}

////////////////////////////////////////
	                
HRESULT CASPEncryption::DecryptInplace(
    BSTR bstrPassword,
    BSTR bstrPage,
    VARIANT_BOOL* pfRetVal)
{
    if (bstrPassword == NULL || bstrPage == NULL || pfRetVal == NULL)
        return ReportError(E_POINTER);
    *pfRetVal = VARIANT_FALSE;

    // map virtual path
    
    HRESULT hr;
    CComBSTR bstrFile;
    hr = MapVirtualPath(bstrPage, bstrFile);
    if (FAILED(hr))
        return ReportError(hr);

    // call easpcore function to decrypt

    EASP_STATUS esStatus = EASP_FAILED;
    USES_CONVERSION;    // needed for OLE2T
    hr = DecryptPageInplace(OLE2T(bstrPassword), OLE2T(bstrFile), &esStatus);
    if (FAILED(hr))
        {
        // return bad HRESULT only if really failed
        if (esStatus == EASP_FAILED)
            return ReportError(hr);
        // other cases (unencrypted, etc.) RetVal FALSE
        }
    else
        *pfRetVal = VARIANT_TRUE;
    return S_OK;
}

////////////////////////////////////////
	                
HRESULT CASPEncryption::DecryptCopy(
    BSTR bstrPassword, 
    BSTR bstrFromPage, 
    BSTR bstrToPage,
    VARIANT_BOOL *pfRetVal)
{
    if (bstrPassword == NULL || bstrFromPage == NULL || bstrToPage == NULL || pfRetVal == NULL)
        return ReportError(E_POINTER);
    *pfRetVal = VARIANT_FALSE;

    // map virtual paths
    
    HRESULT hr;
    CComBSTR bstrFile1, bstrFile2;
    hr = MapVirtualPath(bstrFromPage, bstrFile1);
    if (FAILED(hr))
        return ReportError(hr);
    hr = MapVirtualPath(bstrToPage, bstrFile2);
    if (FAILED(hr))
        return ReportError(hr);

    // call easpcore function to decrypt

    EASP_STATUS esStatus = EASP_FAILED;
    USES_CONVERSION;    // needed for OLE2T
    hr = DecryptPage(OLE2T(bstrPassword), OLE2T(bstrFile1),
                     OLE2T(bstrFile2), &esStatus);
    if (FAILED(hr))
        {
        // return bad HRESULT only if really failed
        if (esStatus == EASP_FAILED)
            return ReportError(hr);
        // other cases (unencrypted, etc.) RetVal FALSE
        }
    else
        *pfRetVal = VARIANT_TRUE;
        
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\easp\comp\src\compobj.h ===
// CompObj.h : Declaration of the CASPEncryption


#include "resource.h"       // main symbols
#include <asptlb.h>

/////////////////////////////////////////////////////////////////////////////
// easpcomp

class CASPEncryption : 
	public CComDualImpl<IASPEncryption, &IID_IASPEncryption, &LIBID_EASPCOMPLib>, 
	public ISupportErrorInfo,
	public CComObjectRoot,
	public CComCoClass<CASPEncryption,&CLSID_CASPEncryption>
{
public:
	CASPEncryption();
	~CASPEncryption();
	
BEGIN_COM_MAP(CASPEncryption)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IASPEncryption)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

//DECLARE_NOT_AGGREGATABLE(CASPEncryption) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CASPEncryption,
				 _T("IIS.ASPEncryption.1"),
				 _T("IIS.ASPEncryption"), 
				 IDS_EASPCOMP_DESC, 
				 THREADFLAGS_BOTH)
				 
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IASPEncryption
public:
    STDMETHOD(OnStartPage)(IUnknown* pUnk);
    STDMETHOD(OnEndPage)();
    
	STDMETHOD(EncryptInplace)(
				BSTR bstrPassword, 
				BSTR bstrPage,
                VARIANT_BOOL *pfRetVal);
	STDMETHOD(EncryptCopy)(
				BSTR bstrPassword, 
				BSTR bstrFromPage, 
				BSTR bstrToPage,
                VARIANT_BOOL *pfRetVal);
	STDMETHOD(TestEncrypted)(
				BSTR bstrPassword,
				BSTR bstrPage,
                VARIANT_BOOL *pfRetVal);
	STDMETHOD(IsEncrypted)(
				BSTR bstrPage,
                VARIANT_BOOL *pfRetVal);
	STDMETHOD(VerifyPassword)(
				BSTR bstrPassword,
				BSTR bstrPage,
                VARIANT_BOOL *pfRetVal);
	STDMETHOD(DecryptInplace)(
				BSTR bstrPassword,
				BSTR bstrPage,
                VARIANT_BOOL *pfRetVal);
	STDMETHOD(DecryptCopy)(
				BSTR bstrPassword,
				BSTR bstrFromPage,
				BSTR bstrToPage,
                VARIANT_BOOL *pfRetVal);
private:
    HRESULT MapVirtualPath(BSTR bstrPath, CComBSTR &bstrFile);
    HRESULT ReportError(HRESULT hr, DWORD dwErr);
    HRESULT ReportError(DWORD dwErr);
    HRESULT ReportError(HRESULT hr);

    BOOL                m_fOnPage;  // TRUE after OnStartPage() called
    CComPtr<IServer>    m_piServer; // Server Object (for path translation)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\easp\comp\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by easpcomp.rc
//
#define IDS_EASPCOMP_DESC	1
#define IDS_EASP_PRINTABLE_HEADER   11



// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\counters\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\easp\comp\src\easpcomp.cpp ===
// easpcomp.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this 
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f easpcompps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "easpcomp.h"
#include "CompObj.h"

#define IID_DEFINED
#include "easpcomp_i.c"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CASPEncryption, CASPEncryption)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\counters\counter.cpp ===
// Counter.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f Counterps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "Counter.h"

#include "Counter_i.c"
#include <initguid.h>
#include "CountCtl.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_Counters, CCounterCtl)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
        CCounter::LoadCounters();
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
        CCounter::Terminate();
		_Module.Term();
	}
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	// When the DLL unregisers, clean up the Counters.txt file that we use to store the data.

	char fileNameBuffer[MAX_PATH];

    GetSystemDirectory(fileNameBuffer, MAX_PATH-sizeof(COUNTERS_TXT));
	strcat(fileNameBuffer, COUNTERS_TXT );

	DeleteFile(fileNameBuffer); 

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\counters\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Counter.rc
//
#define IDS_PROJNAME                    100
#define IDR_COUNTERCTL                  101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\counters\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__89B9D281_AAEB_11D0_9796_00A0C908612D__INCLUDED_)
#define AFX_STDAFX_H__89B9D281_AAEB_11D0_9796_00A0C908612D__INCLUDED_

#if _MSC_VER >= 1020
#pragma once
#endif // _MSC_VER >= 1000

#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif

#define STRICT


#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__89B9D281_AAEB_11D0_9796_00A0C908612D__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\counters\countctl.cpp ===
// CounterCtl.cpp : Implementation of CCounterCtl


#include "stdafx.h"
#include "TCHAR.h"
#include "Counter.h"
#include "CountCtl.h"
#include <stdio.h>
#include <pudebug.h>

////////////////////////////////////////////////////////////////////////////
// CCounterCtl

STDMETHODIMP CCounterCtl::Get(
								   BSTR counterName,
								   unsigned long *value)  
{
	CCounter *theCounter = CCounter::GetCounter(counterName);

	if(theCounter == NULL)
	{
		theCounter = new CCounter();
		if (theCounter == NULL)
			return E_OUTOFMEMORY;

		if (! CCounter::AddCounter(counterName, theCounter))
			{
			delete theCounter;
			return E_FAIL;
			}
	}

	*value = theCounter->Get();
	return S_OK;
}

STDMETHODIMP CCounterCtl::Set(
								   BSTR counterName,
								   unsigned long newValue,
								   unsigned long *value)
{
	CCounter *theCounter = CCounter::GetCounter(counterName);

	if(theCounter == NULL)
	{
		theCounter = new CCounter();
		if (theCounter == NULL)
			return E_OUTOFMEMORY;

		if (! CCounter::AddCounter(counterName, theCounter))
			{
			delete theCounter;
			return E_FAIL;
			}
	}

	*value = theCounter->Set(newValue);
	return S_OK;
}

STDMETHODIMP CCounterCtl::Increment(
									BSTR counterName,
									unsigned long *value)  
{
	CCounter *theCounter = CCounter::GetCounter(counterName);

	if(theCounter == NULL)
	{
		theCounter = new CCounter();
		if (theCounter == NULL)
			return E_OUTOFMEMORY;

		if (! CCounter::AddCounter(counterName, theCounter))
			{
			delete theCounter;
			return E_FAIL;
			}
	}

	*value = theCounter->IncrementValue();
	return S_OK;
}

STDMETHODIMP CCounterCtl::Remove (BSTR counterName)  
{
	CCounter *theCounter = CCounter::GetCounter(counterName);

	if(theCounter != NULL)
	{
		theCounter->Remove();
		delete theCounter;
	}

	return S_OK;
}

CRITICAL_SECTION CCounter::m_HashCriticalSection;
bool CCounter::myCountersLoaded = false;
bool CCounter::myCountersDirty = false;
DWORD CCounter::myLastSaveTime = 0;

const int kMaxCounters = 512;
CCounter *	CCounter::myCounterList[kMaxCounters];
long CCounter::myNumCounters = 0;

// AddCounter
// name in double byte characters (unicode)
// nameLength is the number of characters (NOT BYTES).
//  The byte size of the name parameter is nameLength * sizeof(OLECHAR).

bool CCounter::AddCounter(
						  OLECHAR *name,
						  UINT nameLength,
						  CCounter *theCounter)
{
	bool fAddedCounter = false;
	if(myNumCounters < kMaxCounters)
	{
		theCounter->myName = SysAllocStringLen(name, nameLength);
		myCounterList[myNumCounters++] = theCounter;
		fAddedCounter = true;
	}

	return fAddedCounter;
}
bool CCounter::AddCounter(BSTR name, CCounter *theCounter)
{
	bool fAddedCounter = false;
    EnterCriticalSection(&m_HashCriticalSection);
	if(myCountersLoaded && myNumCounters < kMaxCounters)
	{
		myCounterList[myNumCounters++] = theCounter;
		theCounter->myName = SysAllocString(name);
		fAddedCounter = true;
	}
    LeaveCriticalSection(&m_HashCriticalSection);

	return fAddedCounter;
}

CCounter * CCounter::GetCounter(BSTR name)
{
	CCounter *theCounter = NULL;

    EnterCriticalSection(&m_HashCriticalSection);
	for(long i = 0; i < myNumCounters; i++)
        if(!wcsicmp(myCounterList[i]->myName, name))
            theCounter = myCounterList[i];
    LeaveCriticalSection(&m_HashCriticalSection);

	return theCounter;
}

CCounter::CCounter()
{
	myValue = 0;
	myName = NULL;
}

CCounter::~CCounter()
{
	if(myName != NULL)
		SysFreeString(myName);
}

void CCounter::Remove()
{
	long fromindex;
	long toindex = 0;
	long newCount;

    EnterCriticalSection(&m_HashCriticalSection);
    newCount = myNumCounters;

	for(fromindex = 0, toindex = 0; fromindex < myNumCounters; fromindex++)
	{
		if(myCounterList[fromindex] != this)
			myCounterList[toindex++] = myCounterList[fromindex];
		else
			newCount--;
	}
	myNumCounters = newCount;
    LeaveCriticalSection(&m_HashCriticalSection);

	DirtyCounters();
}

void UTF8ToUCS2(char *utf8String, OLECHAR *ucs2String, long *length);
void UCS2ToUTF8(OLECHAR *ucs2String, long length, char *utf8String);
/*
void TestUTF8ToUCS2(void)
{
	OLECHAR wbuffer1[512];
	OLECHAR wbuffer2[512];
	long length;
	char ubuffer[1024];

	for(long i = 0; i < 5000; i++)
	{
		length = 100;
		for(long j = 0; j < length; j++)
		{
			wbuffer1[j] = rand();
			if(wbuffer1[j] == 0)
				wbuffer1[j] = 0xf38d;
		}

		UCS2ToUTF8(wbuffer1, length, ubuffer);
		length = 0;
		UTF8ToUCS2(ubuffer, wbuffer2, &length);
		if(length != 100)
		{
			break;	// Error!
		}

		for(j = 0; j < length; j++)
			if(wbuffer1[j] != wbuffer2[j])
			{
				break;	// Error!
			}
	}
}*/

void UTF8ToUCS2(char *utf8String, OLECHAR *ucs2String, long *length)
{
	char *currentChar = utf8String;
	*length = 0;

	while(*currentChar != 0)
	{
		if((*currentChar & 0xe0) == 0xe0)
		{
			ucs2String[*length] = ((currentChar[0] & 0x0f) << 12) | (((currentChar[1]) & 0x3f) << 6) | (currentChar[2] & 0x3f);
			currentChar += 2;
		}
		else if((*currentChar & 0xc0) == 0xc0)
		{
			ucs2String[*length] = (((currentChar[0]) & 0x1f) << 6) | (currentChar[1] & 0x3f);
			currentChar += 1;
		}
		else
		{
			ucs2String[*length] = *currentChar;
		}

		currentChar++;
		(*length)++;

		if(*length > 254)
			break;
	}
}

void UCS2ToUTF8(OLECHAR *ucs2String, long length, char *utf8String)
{
	char *currentChar = utf8String;
	long pos = 0;

	while(pos < length)
	{
		if(ucs2String[pos] > 0x7ff)
		{
			*(currentChar++) = (char) 0xe0 | (ucs2String[pos] >> 12);
			*(currentChar++) = (char) 0x80 | ((ucs2String[pos] >> 6) & 0x3f);
			*(currentChar++) = (char) 0x80 | (ucs2String[pos++] & 0x3f);
		}
		else if(ucs2String[pos] > 0x7f)
		{
			*(currentChar++) = (char) 0xc0 | (ucs2String[pos] >>6);
			*(currentChar++) = (char) 0x80 | (ucs2String[pos++] & 0x3f);
		}
		else
		{
			*(currentChar++) = (char) ucs2String[pos++];
		}
	}
	*currentChar = 0;
}

void CCounter::LoadCounters(void)
{
	// Notes:
	// This function does not require any additional syncronization since
	// the use of the CreateFile with no sharing permission effectively
	// prevents multiple access to the same file.

	//TestUTF8ToUCS2();
	if(!myCountersLoaded)
	{
		HANDLE hFile;
 
                char fileNameBuffer[MAX_PATH] = {0};

        GetSystemDirectory(fileNameBuffer, MAX_PATH-sizeof(COUNTERS_TXT));
		strcat(fileNameBuffer, COUNTERS_TXT);

		hFile = CreateFile( fileNameBuffer,			// open MyInfo.xml 
							GENERIC_READ,			// open for reading
							0,						// don't share 
							NULL,					// no security 
							OPEN_EXISTING,			// overwrite existing
													//    file
							FILE_ATTRIBUTE_NORMAL,	// normal file 
							NULL);					// no attr. template 
 
		if (hFile != INVALID_HANDLE_VALUE)
		{
			long currentPos = 0;

			while(true)
			{
				long length;
				DWORD bytesRead;
				OLECHAR buffer[256];
				char diskBuffer[300];
				long theValue = 0;

				SetFilePointer(	hFile,
								currentPos,
								0,
								FILE_BEGIN);

				if(!ReadFile(	hFile,
								diskBuffer,
								300,
								&bytesRead,
								NULL))
				{	// Done
					break;
				}
				diskBuffer[bytesRead] = 0;

				for(long i = 0; i < 300 && diskBuffer[i] && diskBuffer[i] != ':'; i++);

				if(diskBuffer[i] != ':')
					break;
				
				for(long j = i + 1; j < 300 && diskBuffer[j] && diskBuffer[j] != '\r'; j++);

				if(diskBuffer[j] != '\r')
					break;

				diskBuffer[j++] = 0;
				while(diskBuffer[j] == '\r' || diskBuffer[j] == '\n')
					j++;
				currentPos += j;

				diskBuffer[i] = 0;

				UTF8ToUCS2(diskBuffer, buffer, &length);
				for(i = i + 1; diskBuffer[i] >= '0' && diskBuffer[i] <= '9'; i++)
				{
					theValue = theValue * 10 + diskBuffer[i] - '0';
				}

				CCounter *theCounter = new CCounter();
				if (theCounter == NULL)
					return;

				theCounter->Set(theValue);
				if (! AddCounter(buffer, length, theCounter))
					{
					delete theCounter;
					return;
					}
			}
			CloseHandle(hFile);
		}

		INITIALIZE_CRITICAL_SECTION(&m_HashCriticalSection);
		myCountersLoaded = true;
		myCountersDirty = false;
		myLastSaveTime = GetTickCount();
	}
}


void CCounter::Terminate(void)
{
    SaveCounters();
	for (int i = 0;  i < myNumCounters;  ++i)
    {
        delete myCounterList[i];
    }
    DeleteCriticalSection(&m_HashCriticalSection);
}


void CCounter::SaveCounters(void)
{
	// Notes:
	// This function does not require any additional syncronization since
	// the use of the CreateFile with no sharing permission effectively
	// prevents multiple access to the same file. The behavior
	// of a failed CreateFile call is important. We should
	// not set any of the flags for whether the file has been written or not.

	HANDLE hFile;
 
    char fileNameBuffer[MAX_PATH];

    GetSystemDirectory(fileNameBuffer, MAX_PATH-sizeof(COUNTERS_TXT));
    strcat(fileNameBuffer, COUNTERS_TXT);

	hFile = CreateFile( fileNameBuffer,			// open MyInfo.xml 
						GENERIC_WRITE,            // open for writing 
						0,						// don't share 
						NULL,					// no security 
						CREATE_ALWAYS,			// overwrite existing file
						FILE_ATTRIBUTE_NORMAL,	// normal file 
						NULL);					// no attr. template 
 
	if (hFile == INVALID_HANDLE_VALUE)
	{ 
	//		ErrorHandler("Could not open file.");   // process error
		return;
	}
	
	unsigned long index = 0;

	for(long theIndex = 0; theIndex < myNumCounters; theIndex++)
	{
		CCounter *theCounter = myCounterList[theIndex];

		if(theCounter != NULL && theCounter->myName != NULL)
		{
			UINT length;
			DWORD bytesWritten;

			char utfString[800];
			UCS2ToUTF8(theCounter->myName, SysStringLen(theCounter->myName), utfString);
			

			char outputLine[900];
			sprintf(outputLine, "%s:%ld\r\n", utfString, theCounter->myValue);
			length = strlen(outputLine);

			WriteFile(	hFile, outputLine, length,
							&bytesWritten, NULL);
		}
		index++;
	}
	CloseHandle(hFile);

	myCountersLoaded = true;
	myCountersDirty = false;
	myLastSaveTime = GetTickCount();
}

void CCounter::DirtyCounters(void)
{
	myCountersDirty = true;

	if(myCountersLoaded && myLastSaveTime + 15 * 1000 < GetTickCount())
		SaveCounters();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\myinfo\myinfctl.cpp ===
// MyInfoCtl.cpp : Implementation of CMyInfoCtl
#include "stdafx.h"
#include "MyInfo.h"
#include "MyInfCtl.h"
#include "WCParser.h"
#include <stdio.h>
#include <pudebug.h>

class CMyInfoLock
{
public:
	CMyInfoLock()
	{
		CMyInfoCtl::Lock();
	}
	~CMyInfoLock()
	{
		CMyInfoCtl::Unlock();
	}
};

/////////////////////////////////////////////////////////////////////////////
// CMyInfoCtl

static long gCMyInfoCtlCount = 0;

// Initialize will handle one-time class initialization, it should be called in DllMain
bool
CMyInfoCtl::Initialize()
{
	::InitializeCriticalSection( &s_cs );
    SET_CRITICAL_SECTION_SPIN_COUNT(&s_cs, IIS_DEFAULT_CS_SPIN_COUNT);
	return true;
}

// Uninitialize will handle one-time class unitialization, it should be called in DllMain
bool
CMyInfoCtl::Uninitialize()
{
	if ( s_pInfoBase )
	{
		delete s_pInfoBase;
	}
	::DeleteCriticalSection( &s_cs  );
	return true;
}

// lock the shared critical section
void
CMyInfoCtl::Lock()
{
	::EnterCriticalSection( &s_cs );
}

// unlock the shared critical section
void
CMyInfoCtl::Unlock()
{
	::LeaveCriticalSection( &s_cs );
}

// Constructor for CMyInfoCtl
// The myInfoTop parameter is set to true when the object is the toplevel CMyInfoCtl
// (created by the Class factory), and false for the objects that make up the rest
// of the tree.
CMyInfoCtl::CMyInfoCtl(bool myInfoTop)
{
	long numInstances = ::InterlockedIncrement(&gCMyInfoCtlCount);
	ATLTRACE( _T("CMyInfoCtl(): %ld instances\n"), numInstances );
	m_bIsMyInfoTop = myInfoTop;
	if(m_bIsMyInfoTop)
		m_cRef = 1;
	else
		m_cRef = 0;
}

CMyInfoCtl::~CMyInfoCtl(void)
{
	if(this == s_pInfoBase)	// If we are deleting the top, first save it
	{
		CMyInfoLock lock;

		CMyInfoCtl::SaveFile();
		s_pInfoBase = NULL;
	}

	long numInstances = ::InterlockedDecrement(&gCMyInfoCtlCount);
	ATLTRACE( _T("~CMyInfoCtl(): %ld instances\n"), numInstances );
}

CWDNode * CMyInfoCtl::WDClone()
{
	CMyInfoCtl *newObject = new CMyInfoCtl(false);
	newObject->AddRef();

	return newObject;
}

STDMETHODIMP CMyInfoCtl::QueryInterface(REFIID iid, void ** ppv)
{
	*ppv = NULL;
	if(iid == IID_IUnknown || iid == IID_IDispatch || iid == IID_IMyInfoCtl)
	{
		*ppv = static_cast<IMyInfoCtl *>(this);
	}
    else if (iid == IID_IMarshal) {
        *ppv = m_pUnkMarshaler;
    }
	else
		return ResultFromScode(E_NOINTERFACE);

	if (*ppv != NULL)
        ((LPUNKNOWN)*ppv)->AddRef();

	return NOERROR;
}

STDMETHODIMP_(ULONG) CMyInfoCtl::AddRef(void)
{
	ULONG rc = ::InterlockedIncrement( &m_cRef );
//	ATLTRACE( _T("CMyInfoCtl::AddRef: %d\n"), rc );
	if(rc == 1)
		NodeAddRef();
	return rc;
}

STDMETHODIMP_(ULONG) CMyInfoCtl::Release(void)
{
	ULONG rc = ::InterlockedDecrement( &m_cRef );
//	ATLTRACE( _T("CMyInfoCtl::Release: %d\n"), rc );
	if(rc == 0)
	{
		NodeReleaseRef();
		return 0;
	}
	return m_cRef;
}


STDMETHODIMP CMyInfoCtl::GetIDsOfNames(REFIID /*riid*/, LPOLESTR* rgszNames,
	UINT cNames, LCID lcid, DISPID* rgdispid)
{
	CMyInfoLock	lock;
	// Make sure the file is loaded. This routine does nothing if its already loaded.
	LoadFile();

	CMyInfoCtl *theNode;

	if(m_bIsMyInfoTop)
		theNode = s_pInfoBase;
	else
		theNode = this;

	ITypeInfo* pInfo;
	HRESULT hRes = GetTI(lcid, &pInfo);
	if (pInfo != NULL)
	{
		OLECHAR *namestr = rgszNames[0];
		char name[256];

		if(!wcsicmp(namestr, L"OnStartPage") ||
			!wcsicmp(namestr, L"OnEndPage"))
		{
			*rgdispid = 0;
			hRes = DISP_E_UNKNOWNNAME;
		}
		else
		{
			for(int i = 0; namestr[i] != 0; i++)
				name[i] = (char) namestr[i];
			name[i] = 0;

			CMyInfoCtl *subNode = static_cast<CMyInfoCtl *>(theNode->GetChild(name, 0));

			if(subNode == NULL)
			{
				subNode = new CMyInfoCtl(false);
				theNode->AddChild(name, subNode);
				DirtyMyInfo();
			}

			// The collection member referenced is in subNode. Calculate
			// a dispid to return by finding out its index inside its parent (theNode).
			// The indexes are 0 based, while the dispid needs to be 1 based, so add 1.
			*rgdispid = (DISPID) theNode->GetChildNumber(subNode) + 1;
			hRes = S_OK;
		}
		pInfo->Release();
	}
	return hRes;
}

HRESULT CMyInfoCtl::PutVariant(CWDNode *theNode, VARIANT *data)
{
	CSimpleUTFString value;

	if(data->vt != VT_BSTR)
	{
		VARIANTARG dest;

		VariantInit(&dest);
		
		HRESULT result = VariantChangeType(&dest, data, 0, VT_BSTR);

		if(result != S_OK)
			return DISP_E_TYPEMISMATCH;

		value.Copy(dest.bstrVal, SysStringLen(dest.bstrVal));
	}
	else
		value.Copy(data->bstrVal, SysStringLen(data->bstrVal));

	if(theNode->NumValues() == 0)
		theNode->AddValue(&value, false);
	else
		theNode->ReplaceValue(0, &value, false);
	DirtyMyInfo();

	return S_OK;
}

STDMETHODIMP CMyInfoCtl::Invoke(DISPID dispidMember, REFIID /*riid*/,
	LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
	EXCEPINFO* pexcepinfo, UINT* puArgErr)
{
	CMyInfoLock	lock;

	CWDNode *theNode;
	CMyInfoCtl *subNode = NULL;

	if(m_bIsMyInfoTop)
		theNode = s_pInfoBase;
	else
		theNode = this;

	if(dispidMember > 0)
	{
		subNode = static_cast<CMyInfoCtl *>(theNode->GetChildIndex(dispidMember - 1));
	}

	SetErrorInfo(0, NULL);
	ITypeInfo* pInfo;
	HRESULT hRes = GetTI(lcid, &pInfo);
	if (pInfo != NULL)
	{
		short extraArgs = 0;

		if(wFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF))
			extraArgs++;	// Skip the value to store in the beginning

		if(dispidMember == DISPID_NEWENUM)
		{
			// An enumerator for this collection has been requested

			CMyInfoEnum *theEnum = NULL;

			theEnum = CMyInfoEnum::Create(theNode);

			if(theEnum == NULL)
			{
				// Error
				return E_OUTOFMEMORY;
			}
			IUnknown *theEnumUnknown = NULL;
			theEnum->QueryInterface(IID_IUnknown, (void **) &theEnumUnknown);

			V_VT(pvarResult) = VT_UNKNOWN;
			V_UNKNOWN(pvarResult) = theEnumUnknown;

			return S_OK;
		}

		if(dispidMember != DISPID_VALUE || pdispparams->cArgs > (unsigned short) extraArgs)
		{
			bool lastArgName = false;
			if(dispidMember != DISPID_VALUE)
			{
				theNode = subNode;
				lastArgName = true;
			}
			// Note: The following would NOT work if argNum were not signed!
			// Since pdispparams->cArgs is unsigned we cast it to a signed int first
			for(int argNum = ((int) pdispparams->cArgs) - 1; argNum >= extraArgs; argNum--)
			{
				// Collection reference
//				VARTYPE theType = pdispparams->rgvarg[argNum].vt;
				VARIANTARG dest;

				VariantInit(&dest);
				
				hRes = VariantChangeType(&dest, &(pdispparams->rgvarg[argNum]), 0, VT_I4);

				if(hRes != S_OK)
				{
					hRes = VariantChangeType(&dest, &(pdispparams->rgvarg[argNum]), 0, VT_BSTR);
					if(hRes != S_OK)
					{
						// Error;
						theNode = NULL;
						break;	// for loop
					}
					else
					{
						// String
						OLECHAR *namestr = dest.bstrVal;
						char name[256];

                        // BOYDM - Convert the wide character string down to ansi taking
                        // into account any dbcs conversions and special character conversions.
                        int i = WideCharToMultiByte(
                            CP_ACP,            // code page
                            0,                  // performance and mapping flags
                            namestr,            // address of wide-character string
                            -1,                 // number of characters in string -> -1 means null terminated
                            name,               // address of buffer for new string
                            256,                // size of buffer
                            NULL,               // address of default for unmappable characters
                            NULL                // address of flag set when default char. used
                            );
//						for(int i = 0; i < 255 && namestr[i] != 0; i++)
//							name[i] = (char) namestr[i];
//						name[i] = 0;

						CWDNode *oldNode = theNode;
						theNode = static_cast<CMyInfoCtl *>(theNode->GetChild(name, 0));
						if(!theNode)
						{
							theNode = new CMyInfoCtl(false);

							oldNode->AddChild(name, theNode);
							DirtyMyInfo();
						}
						lastArgName = true;
					}
				}
				else
				{
					if(lastArgName)
					{
						// If the previous item is a name then we retrieve the
						// nth item with that name
						CWDNode *subNode = NULL;
						subNode = static_cast<CMyInfoCtl *>(theNode->GetSibling(dest.lVal));
						if(subNode == NULL && (wFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF)))
						{
							while(theNode->GetParent()->GetChild(theNode->GetMyName(), dest.lVal) == NULL)
							{
								subNode = new CMyInfoCtl(false);
								theNode->GetParent()->AddChild(theNode->GetMyName(), subNode);
								DirtyMyInfo();
							}
						}
						theNode = subNode;
					}
					else
					{
						theNode = theNode->GetChildIndex(dest.lVal);
					}
					lastArgName = false;
				}
				if(theNode == NULL)
				{
					return DISP_E_MEMBERNOTFOUND;
				}
			}

			if(wFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF))
			{
				hRes = PutVariant(theNode, &pdispparams->rgvarg[0]);
			}
			else
			{
				CMyInfoCtl *theInfo = static_cast<CMyInfoCtl *> (theNode);
				IDispatch *theInfoDispatch = NULL;
				theInfo->QueryInterface(IID_IDispatch, (void **) &theInfoDispatch);

				V_VT(pvarResult) = VT_DISPATCH;
				V_DISPATCH(pvarResult) = theInfoDispatch;
			}
		}
		else if(wFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF))
		{
			if(dispidMember == DISPID_VALUE)
			{
				hRes = PutVariant(this, &pdispparams->rgvarg[0]);
			}
			else
			{
				hRes = PutVariant(subNode, &pdispparams->rgvarg[0]);
			}
		}
		else if(wFlags & DISPATCH_PROPERTYGET)
		{
			if(dispidMember == DISPID_VALUE && pdispparams->cArgs == 0)
			{
				CSimpleUTFString *theStr = theNode->GetValue(0);

				if(theStr == NULL)
				{
					VariantInit(pvarResult);
				}
				else
				{
					V_VT(pvarResult) = VT_BSTR;
					V_BSTR(pvarResult) = SysAllocStringLen((OLECHAR *) theStr->getData(), theStr->Length());
				}
			}
		}

		pInfo->Release();
	}
	return hRes;
}

void CMyInfoCtl::SaveFile(void)
{
	// Notes:
	// This function does not require any additional syncronization since
	// the use of the CreateFile with no sharing permission effectively
	// prevents multiple access to the same file. The behavior
	// of a failed CreateFile call is important. We should
	// not set any of the flags for whether the file has been written or not.

	HANDLE hFile;

    _TCHAR fileNameBuffer[MAX_PATH];

    GetSystemDirectory(fileNameBuffer, MAX_PATH-16);
    _tcscat(fileNameBuffer, _T("\\inetsrv\\Data\\MyInfo.xml"));

	hFile = CreateFile( fileNameBuffer,			// open MyInfo.xml 
						GENERIC_WRITE,           // open for writing 
						0,						// don't share 
						NULL,					// no security 
						CREATE_ALWAYS,			// overwrite existing file
						FILE_ATTRIBUTE_NORMAL,	// normal file 
						NULL);					// no attr. template 
 
	if (hFile == INVALID_HANDLE_VALUE)
	{ 
	//		ErrorHandler("Could not open file.");   // process error
		return;
	}
	
	CMyInfoCtl *clone = new CMyInfoCtl(false);
	clone->AddRef();

	CWDParser *theParser = new CWDParser(clone);
	theParser->StartOutput(s_pInfoBase);

	while(true)
	{
		char buffer[1026];
		unsigned long size = 1024;

		bool more = theParser->Output(buffer, &size);
		if(size > 0)
		{
			DWORD bytesWritten;
			WriteFile(	hFile, buffer, size,
							&bytesWritten, NULL);
		}
		if(!more)
			break;
	}
	
	CloseHandle(hFile);
	clone->Release();
	delete theParser;

	s_bInfoDirty = false;
	s_dwLastSaveTime = GetTickCount();
}

void CMyInfoCtl::DirtyMyInfo(void)
{
	s_bInfoDirty = true;

	if(s_pInfoBase != NULL && s_dwLastSaveTime + 15 * 1000 < GetTickCount())
		SaveFile();
}

void CMyInfoCtl::LoadFile(void)
{
	// Once we have already loaded the file, s_pInfoBase is set to point to the properties
	if(s_pInfoBase != NULL)
		return;		// Only load the file once at startup

	CWCParser *theParser;

	CMyInfoCtl *clone = new CMyInfoCtl(false);
	clone->AddRef();

	theParser = new CWDParser(clone);

	CWDNode *theNode = theParser->StartParse();
	s_pInfoBase = static_cast<CMyInfoCtl *> (theNode);

	HANDLE hFile;

	// Calculate the file location- Always put it in Windows\System32\inetsrv\MyInfo.xml
    _TCHAR fileNameBuffer[MAX_PATH];

    GetSystemDirectory(fileNameBuffer, MAX_PATH-16);
    _tcscat(fileNameBuffer, _T("\\inetsrv\\Data\\MyInfo.xml"));

	hFile = CreateFile( fileNameBuffer,			// open MyInfo.xml
						GENERIC_READ,			// open for reading
						0,						// don't share 
						NULL,					// no security 
						OPEN_EXISTING,			// overwrite existing
												//    file
						FILE_ATTRIBUTE_NORMAL,	// normal file 
						NULL);					// no attr. template 

	if (hFile != INVALID_HANDLE_VALUE)
	{
		while(true)
		{
			DWORD bytesRead;
			unsigned char buffer[256];

			if(!ReadFile(	hFile,
							buffer,
							256,
							&bytesRead,
							NULL) || bytesRead == 0)
			{	// Done
				break;
			}
			theParser->Parse(buffer, bytesRead);
		}
		CloseHandle(hFile);
	}
		
	theParser->EndParse();
	clone->Release();
	delete theParser;

	s_bInfoDirty = false;
	s_dwLastSaveTime = GetTickCount();
}

CMyInfoCtl*			CMyInfoCtl::s_pInfoBase = NULL;
bool				CMyInfoCtl::s_bInfoDirty = false;
DWORD				CMyInfoCtl::s_dwLastSaveTime = 0;
CRITICAL_SECTION	CMyInfoCtl::s_cs;

// Implementation of CMyInfoEnum. This lets you enumerate over the contents of the collection.

STDMETHODIMP CMyInfoEnum::QueryInterface(REFIID iid, void ** ppv)
{
	*ppv = NULL;
	if(iid == IID_IUnknown || iid == IID_IEnumVARIANT)
		*ppv = this;
	else
		return ResultFromScode(E_NOINTERFACE);
	AddRef();
	return NOERROR;
}

STDMETHODIMP_(ULONG) CMyInfoEnum::AddRef(void)
{
	return ::InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CMyInfoEnum::Release(void)
{
	ULONG rc = ::InterlockedDecrement(&m_cRef);
	if(rc == 0)
	{
		delete this;
	}
	return rc;
}

static long gCMyInfoEnumCount = 0;

CMyInfoEnum::CMyInfoEnum(CWDNode *theInfo)
{
	_Module.Lock();
//	ATLTRACE( _T("CMyInfo: new enumeration\n") );
	::InterlockedIncrement(&gCMyInfoEnumCount);
	m_Info = theInfo;
	m_Index = 0;
	m_cRef = 0;
}

CMyInfoEnum::~CMyInfoEnum(void)
{
//	ATLTRACE( _T("CMyInfo: enumeration destroyed\n") );
	::InterlockedDecrement(&gCMyInfoEnumCount);
	_Module.Unlock();
}

STDMETHODIMP CMyInfoEnum::Next(ULONG cElements, VARIANT * pvar, ULONG * pcElementFetched)
{
	CMyInfoLock lock;

	if(m_Index >= m_Info->NumChildren())
	{
		if(pcElementFetched)
			*pcElementFetched = 0;
		return ResultFromScode(S_FALSE);
	}
	CWDNode *theNode = NULL;
	
	theNode = m_Info->GetChildIndex(m_Index);

	if ( pcElementFetched )
	{
		*pcElementFetched = 0;
	}
	for ( ULONG i = 0; ( i < cElements ) && ( m_Index < m_Info->NumChildren() ); i++ )
	{	
		if(pcElementFetched)
		{
			(*pcElementFetched)++;
		}

		CMyInfoCtl *theInfo = static_cast<CMyInfoCtl *> (theNode);
		IDispatch *theInfoDispatch = static_cast<IDispatch *>(theInfo);
		theInfoDispatch->AddRef();
		pvar[i].vt = VT_DISPATCH;
		pvar[i].pdispVal = theInfoDispatch;
		Skip(1);
	}
	
	return NOERROR;
}

STDMETHODIMP CMyInfoEnum::Skip(ULONG cElements)
{
	m_Index += cElements;
	
	CMyInfoLock	lock;

	if(m_Index >= m_Info->NumChildren())
	{
		m_Index = m_Info->NumChildren();
		return ResultFromScode(S_FALSE);
	}
	else
	{
		return NOERROR;
	}
}

STDMETHODIMP CMyInfoEnum::Reset()
{
	m_Index = 0;
	return NOERROR;
}

STDMETHODIMP CMyInfoEnum::Clone(IEnumVARIANT **ppenum)
{
	CMyInfoEnum *newEnum = CMyInfoEnum::Create(m_Info);
	if (newEnum == NULL)
		return E_OUTOFMEMORY;

	newEnum->m_Index = m_Index;
	*ppenum = newEnum;
	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\counters\countctl.h ===
// CounterCtl.h : Declaration of the CCounterCtl

#pragma warning (disable : 4786)
#ifndef __COUNTERCTL_H_
#define __COUNTERCTL_H_

#include "resource.h"       // main symbols
#include <asptlb.h>         // Active Server Pages Definitions
//#include "Store.h"
//#include "HashStore.h"

#define COUNTERS_TXT _T("\\inetsrv\\Data\\Counters.txt")

#define bool BOOL
#define true TRUE
#define false FALSE

class CCounter;

class BSTRLess
{
public:
	bool operator() (const BSTR& p, const BSTR& q) const
	{
		int i = 0;

		while(true)
		{
			if(p[i] < q[i])
				return true;
			else if(p[i] > q[i])
				return false;
			if(p[i] == 0 && q[i] == 0)
				return false;
			i++;
		}
	}
};

class CCounter
{
public:
						CCounter();
						~CCounter();
	unsigned long		Get() { return myValue; };
	unsigned long		Set(unsigned long newValue)
	{
		myValue = newValue;
		DirtyCounters();
		return newValue;
	};
	unsigned long		IncrementValue()
	{
		unsigned long value = InterlockedIncrement((long *)&myValue);
		DirtyCounters();
		return value;
	};
	void				Remove();
	static CCounter *	GetCounter(BSTR name);
	static bool			AddCounter(
								   BSTR name,
								   CCounter *theCounter);
	static void			LoadCounters(void);
	static void			SaveCounters(void);
	static void			DirtyCounters(void);
	static void			Terminate(void);

private:
	static bool			AddCounter(
								   OLECHAR *name,
								   UINT nameLength,
								   CCounter *theCounter);

	unsigned long					myValue;
	BSTR							myName;
	static CCounter *				myCounterList[];
	static long						myNumCounters;
	
	static CRITICAL_SECTION			m_HashCriticalSection;
	static bool						myCountersLoaded;
	static bool						myCountersDirty;
	static DWORD					myLastSaveTime;
};
///////////////////////////////////////////////////////////////////////////
// CCounterCtl

class ATL_NO_VTABLE CCounterCtl : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CCounterCtl, &CLSID_Counters>,
	public IDispatchImpl<ICounterCtl, &IID_ICounterCtl, &LIBID_Counters>
{
public:
	CCounterCtl()
	{ 
		m_bOnStartPageCalled = FALSE;
	}
	~CCounterCtl()
	{
		CCounter::SaveCounters();
	}

public:

DECLARE_REGISTRY_RESOURCEID(IDR_COUNTERCTL)

BEGIN_COM_MAP(CCounterCtl)
	COM_INTERFACE_ENTRY(ICounterCtl)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

// ICounterCtl
public:
	//Active Server Pages Methods
	STDMETHOD(Get)(BSTR counterName, unsigned long *value);
	STDMETHOD(Set)(BSTR counterName, unsigned long newValue, unsigned long *value);
	STDMETHOD(Increment)(BSTR counterName, unsigned long *value);
	STDMETHOD(Remove)(BSTR counterName);

	// for free-threaded marshalling
DECLARE_GET_CONTROLLING_UNKNOWN()
	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p );
	}
	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

private:
	CComPtr<IRequest> m_piRequest;				//Request Object
	CComPtr<IResponse> m_piResponse;			//Response Object
	CComPtr<ISessionObject> m_piSession;		//Session Object
	CComPtr<IServer> m_piServer;				//Server Object
	CComPtr<IApplicationObject> m_piApplication;//Application Object
	BOOL m_bOnStartPageCalled;					//OnStartPage successful?
	CComPtr<IUnknown>		m_pUnkMarshaler;

};

#endif //__COUNTERCTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\myinfo\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\myinfo\myinfctl.h ===
// MyInfoCtl.h : Declaration of the CMyInfoCtl
#pragma warning (disable : 4786)

#ifndef __MYINFOCTL_H_
#define __MYINFOCTL_H_


#include "resource.h"       // main symbols
#include <asptlb.h>         // Active Server Pages Definitions
#include "WCNode.h"

class CMyInfo;

class BSTRLess
{
public:
	bool operator() (const BSTR& p, const BSTR& q) const
	{
		int i = 0;

		while(true)
		{
			if(p[i] < q[i])
				return true;
			else if(p[i] > q[i])
				return false;
			if(p[i] == 0 && q[i] == 0)
				return false;
			i++;
		}
	}
};


class CMyInfoComTypeInfoHolder
{
// Should be 'protected' but can cause compiler to generate fat code.
public:
	const GUID* m_pguid;
	const GUID* m_plibid;
	WORD m_wMajor;
	WORD m_wMinor;

	ITypeInfo* m_pInfo;
	long m_dwRef;

public:
	HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo);

	void AddRef();
	void Release();
	HRESULT GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
	HRESULT GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgdispid);
	HRESULT Invoke(IDispatch* p, DISPID dispidMember, REFIID riid,
		LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
		EXCEPINFO* pexcepinfo, UINT* puArgErr);
};

/////////////////////////////////////////////////////////////////////////////
// CMyInfoCtl
class /*ATL_NO_VTABLE*/ CMyInfoCtl : 
	public CWDNode,
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMyInfoCtl, &CLSID_MyInfo>,
	public IDispatchImpl<IMyInfoCtl,
						&IID_IMyInfoCtl,
						&LIBID_MyInfo>
//						,1, 0, CMyInfoComTypeInfoHolder>
{
public:
	CMyInfoCtl(bool myInfoTop = true);
	~CMyInfoCtl(void);
public:

DECLARE_REGISTRY_RESOURCEID(IDR_MYINFOCTL)

BEGIN_COM_MAP(CMyInfoCtl)
	COM_INTERFACE_ENTRY(IMyInfoCtl)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

// IMyInfoCtl
public:
	static bool	Initialize();
	static bool	Uninitialize();
	static void Lock();
	static void Unlock();

	// for free-threaded marshalling
DECLARE_GET_CONTROLLING_UNKNOWN()
	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p );
	}
	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}


// CWDNode
	virtual CWDNode * WDClone(void);

// IDispatch
	STDMETHOD(QueryInterface)(REFIID iid, void * * ppv);
	STDMETHOD_(ULONG, AddRef)(void);// { return CComCoClass<CMyInfoCtl, &CLSID_MyInfoCtl>::AddRef(); };
	STDMETHOD_(ULONG, Release)(void);
	STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgdispid);
	STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
		LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
		EXCEPINFO* pexcepinfo, UINT* puArgErr);

private:
	HRESULT	PutVariant(CWDNode *theNode, VARIANT *data);

	static void	DirtyMyInfo(void);
	static CMyInfoCtl*		s_pInfoBase;
	static DWORD			s_dwLastSaveTime;
	static bool				s_bInfoDirty;
	static CRITICAL_SECTION	s_cs;

	boolean					m_bIsMyInfoTop;
	long					m_cRef;
	CComPtr<IUnknown>		m_pUnkMarshaler;

public:
	static void LoadFile(void);
	static void SaveFile(void);
	};

class CMyInfoEnum;

class CMyInfoEnum : public IEnumVARIANT
{
public:
	CMyInfoEnum(CWDNode *theInfo);
	virtual ~CMyInfoEnum(void);

	// IUnknown
	STDMETHOD(QueryInterface)(REFIID iid, void * * ppv);
	STDMETHOD_(ULONG, AddRef)(void);
	STDMETHOD_(ULONG, Release)(void);
	
	// IEnumVARIANT
	STDMETHOD(Next)(ULONG cElements, VARIANT * pvar, ULONG * pcElementFetched);
	STDMETHOD(Skip)(ULONG cElements);
	STDMETHOD(Reset)();
	STDMETHOD(Clone)(IEnumVARIANT **ppenum);

	static CMyInfoEnum * Create(CWDNode *theInfo) { return new CMyInfoEnum(theInfo); };

private:
	CWDNode *	m_Info;
	long		m_Index;
	long		m_cRef;
};


#endif //__MYINFOCTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\myinfo\myinfo.cpp ===
// MyInfo.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f MyInfops.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "MyInfo.h"

#include "MyInfo_i.c"
#include <initguid.h>
#include "MyInfCtl.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_MyInfo, CMyInfoCtl)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		CMyInfoCtl::Initialize();
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		CMyInfoCtl::Uninitialize();
		_Module.Term();
	}
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	if (_Module.GetLockCount() == 0)
	{
		CMyInfoCtl::SaveFile();
		return S_OK;
	}
	else
		return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();

	// When the DLL unregisers, clean up the MyInfo.xml file that we use to store the data.

	_TCHAR fileNameBuffer[MAX_PATH-16];

	GetSystemDirectory(fileNameBuffer, 230);
	_tcscat(fileNameBuffer, _T("\\inetsrv\\Data\\MyInfo.xml") );

	DeleteFile(fileNameBuffer); 

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\myinfo\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#pragma warning (disable : 4786)

#if !defined(AFX_STDAFX_H__4682C820_B2FF_11D0_95A8_00A0C92B77A9__INCLUDED_)
#define AFX_STDAFX_H__4682C820_B2FF_11D0_95A8_00A0C92B77A9__INCLUDED_

#if _MSC_VER >= 1020
#pragma once
#endif // _MSC_VER >= 1020

#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif

#define STRICT

#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#if _MSC_VER<1020
#define bool BOOL
#define true TRUE
#define false FALSE
#endif // _MSC_VER > 1020


#endif // !defined(AFX_STDAFX_H__4682C820_B2FF_11D0_95A8_00A0C92B77A9__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\myinfo\wcnode.h ===
#ifndef _WCNODE_
#define _WCNODE_

class CSimpleUTFString;

class CWDNode;

class CWDNode
{
public:
					CWDNode();
	virtual 		~CWDNode();
	virtual void		AddChild(char *name, CWDNode *childNode);
	virtual void		AddValue(CSimpleUTFString *value, bool isReference);
	virtual void		ReplaceValue(unsigned int valueNumber, CSimpleUTFString *value, bool isReference);
	virtual CWDNode *	GetParent(void) { return pParentNode; };
	virtual CSimpleUTFString *	GetValue(unsigned int valueNumber);
	virtual CWDNode *	GetChild(char *name, unsigned int childNumber);
	virtual CWDNode *	GetChildIndex(unsigned int childNumber);
	virtual unsigned int GetChildNumber(CWDNode *childNode);
	virtual CWDNode *	GetSibling(unsigned int childNumber);	// Gets sibling with same name but different index #
	virtual	CWDNode *	GetNextSibling(void); // Get next sibling (not necessarily same name)
	virtual char *		GetMyName(void);
	virtual long		NumChildren() { return uNumChildren; };
	virtual long		NumValues() { return uNumValues; };
	virtual CSimpleUTFString *	GetValueExp(char *expression);

	virtual void	DebugPrintTree(int indent = 0);
	virtual CWDNode * WDClone(void);

	void			NodeAddRef(void) { ::InterlockedIncrement(&m_cRef); };
	void			NodeReleaseRef(void);


private:
	struct CChildren
	{
		char *pwszName;
		CWDNode *pChildNode;
	};

	struct CValues
	{
		CSimpleUTFString *pValue;
	};

	CValues			*pValues;  // The values associated with this node
	unsigned int	uNumValues;   // Count
	CChildren		*pChildArray; // Array of Children-Name pairs to allow search by Name
	unsigned int	uNumChildren; // Count
	unsigned int	uAllocChildren; // Current size of the child array
	char			*pwszProfile; // attribute Profile as string 
	
	bool			fIsReference; // Is this a reference 
	char			*pwszHRef;

	CWDNode			*pParentNode;
	long			m_cRef;
	
	//PCIDLISTNODE	pIdListNode; // Pointer into IDList. NULL indicates ID attribute is missing

};


#endif // _WCNODE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\myinfo\simplstr.cpp ===
#include "stdafx.h"
#include <string.h>
#include <assert.h>
#include "WCNode.h"
#include "WCParser.h"

// A simple string class
// This one is designed for minimal footprint, lack of virtual functions
// and UTF8/Unicode support


//--- commented out by atsusk
//--- this function doesn't support UNICDOE/DBCS.
//
//short strcasecmp(const char *a, const char *b)
//{
//  for( ; ((*a > 96 ? *a - 32 : *a) == (*b > 96 ? *b - 32 : *b)) && *a; a++, b++)
//  {}
//
//  return (*a > 96 ? *a - 32 : *a) - (*b > 96 ? *b - 32 : *b);
//}

CSimpleString::CSimpleString()
{
    myData = 0;
    myLength = 0;
    myActualLength = 16;    // Not true when myData == 0, but an optimization
}

CSimpleUTFString::CSimpleUTFString()
{
    myData = 0;
    myLength = 0;
    myActualLength = 16;    // Not true when myData == 0, but an optimization
    myUTFPos = 0;
}

CSimpleString::~CSimpleString()
{
    if(myData)
        delete [] myData;
}

CSimpleUTFString::~CSimpleUTFString()
{
    if(myData)
        delete [] myData;
}

void CSimpleString::Grow(unsigned newSize)
{
    if(!myData || newSize > myActualLength)
    {
        while(myActualLength < newSize)
            myActualLength *= 2;
        
        char *newData = new char[myActualLength];

        assert(newData != 0);

        if (newData == NULL)
            return;

        if(myData != 0 && myLength > 0)
        {
            assert(newData != 0);
            assert(myData != 0);
            assert(myLength > 0);
            assert(myLength < 0x01000000);  // Sanity checking

            memmove(newData, myData, myLength);
            delete [] myData;
        }
        myData = newData;
    }
}

void CSimpleUTFString::Grow(unsigned newSize)
{
    if(!myData || newSize > myActualLength)
    {
        while(myActualLength < newSize)
            myActualLength *= 2;
        
        unsigned short *newData = new unsigned short[myActualLength];

        assert(newData != 0);

        if (newData == NULL)
            return;
        if(myData != 0 && myLength > 0)
        {
            assert(newData != 0);
            assert(myData != 0);
            assert(myLength > 0);
            assert(myLength < 0x01000000);  // Sanity checking

            memmove(newData, myData, myLength * 2);
            delete [] myData;
        }
        myData = newData;
    }
}

void CSimpleString::Copy(CSimpleString *val)
{
    Grow(val->myLength);
    myLength = val->myLength;
    if (myData)
        memmove(myData, val->myData, myLength);
}

void CSimpleUTFString::Copy(unsigned short *unicodeChars, unsigned long length)
{
    Grow(length);
    myLength = length;
    if (myData)
        memmove(myData, unicodeChars, length * sizeof(unsigned short));
}

void CSimpleUTFString::Copy(CSimpleUTFString *val)
{
    Grow(val->myLength);
    myLength = val->myLength;
    if (myData)
        memmove(myData, val->myData, myLength * 2);
}

void CSimpleString::Cat(unsigned char theChar)
{
    Grow(myLength + 1);
    if (myData)
        myData[myLength++] = theChar;
}

// atsusk fix
void CSimpleUTFString::Cat(unsigned char theChar)
{
    if (myUTFPos == 0)
        Grow(myLength + 1);

    if (myData == NULL)
        return;

    if (myUTFPos == 0)
    {
        if (IsDBCSLeadByte(theChar))
        {
            // This is 1st byte of DBCS
            // save 1st byte
            myData[myLength] = theChar;     // temporaly store
            myUTFPos = 1;
        } else {
            // convert to Unicode
            MultiByteToWideChar(CP_ACP,0,(char*)&theChar,1,&myData[myLength],1);
            myLength++;
        }
    } else {
        // This is 2nd byte of DBCS
        // convert to Unicode
        unsigned char   mbcs[2];
        mbcs[0] = (unsigned char)myData[myLength];
        mbcs[1] = theChar;
        MultiByteToWideChar(CP_ACP,0,(char*)mbcs,2,&myData[myLength],1);
        myLength++;
        myUTFPos = 0;
    }
}

// The caller must call delete [] on the return value
char * CSimpleString::toString(void)
{
    char *newData = new char[myLength + 1];
    if (newData == NULL)
        return NULL;
    memmove(newData, myData, myLength);
    newData[myLength] = 0;

    return newData;
}

char * CSimpleUTFString::toString(void)
{
// atsusk fix: support DBCS
    char *newData = new char[myLength*2+1];
    if (newData == NULL)
        return NULL;
    int i;
    i = WideCharToMultiByte(CP_ACP,0,myData,myLength,newData,myLength*2,NULL,NULL);
    newData[i] = 0;
// atsusk fix

    return newData;
}

//--- commented out by atsusk
//--- not used (should use WideCharToMultiByte)
//
//void CSimpleUTFString::Extract(char *into)
//{
//  unsigned long i;
//  for(i = 0; i < myLength; i++)
//      into[i] = (char) myData[i];
//  into[myLength] = 0;
//}

long CSimpleString::Cmp(char *compareString, bool caseSensitive)
{
    Grow(myLength + 1);

    // return !0 to indicate that the strings don't match in the
    // event there was an allocation failure.

    if (myData == NULL)
        return(!0);

    myData[myLength] = 0;
    if(caseSensitive)
        return strcmp(compareString, myData);
    else
        // atsusk fix: use lstrcmpi instead of strcasecmp
        return lstrcmpi(compareString, myData);
}

long CSimpleUTFString::Cmp(char *compareString, bool caseSensitive)
{
    char *val = toString();
    long result;

    // return !0 to indicate that the strings don't match in the
    // event there was an allocation failure.

    if (val == NULL)
        return (!0);

    if(caseSensitive)
        result = strcmp(compareString, val);
    else
        // atsusk fix: use lstrcmpi instead of strcasecmp
        result = lstrcmpi(compareString, val);

    delete [] val;
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\myinfo\wcparser.cpp ===
#include "stdafx.h"
#include <string.h>
#include <assert.h>
#include "WCNode.h"
#include "WCParser.h"

#include <stdio.h>


// Use this define to determine if unknown attributes become sub-nodes.
// For example <FOO VALUE="xxx" BAR="yyy"/> would be rendered as:
// foo = xxx
//    bar = yyy
//
// Note: if this is set to zero unknown attributes are ignored
#define WCMAKEATTRSCHILDREN 1
#define WCVERBOSE 0


CWCParser::~CWCParser()
{
}


// CHTMLWCParser
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\myinfo\wcnode.cpp ===
#include "stdafx.h"
#include <string.h>
#include <assert.h>
#include <stdio.h>
#include "WCNode.h"
#include "WCParser.h"

// Diagostic counter - Total # of nodes allocated in memory
static long gWDNodeCount = 0;

CWDNode::CWDNode()
{
	gWDNodeCount++;

	uNumChildren = 0;
	uAllocChildren = 4;
	pChildArray = new CChildren[uAllocChildren];
	pParentNode = 0;
	pValues = 0;
	uNumValues = 0;
	m_cRef = 0;
}

CWDNode::~CWDNode()
{
	unsigned int i;

	// When deleting a node

	// For each of the child nodes...
	for(i = 0; i < uNumChildren; i++)
	{
		// Get a pointer to it
		CWDNode *currentNode = pChildArray[i].pChildNode;
		if(currentNode)
		{
			// Release our reference to it
			currentNode->pParentNode = NULL;
			currentNode->NodeReleaseRef();
			pChildArray[i].pChildNode = 0;

			// Free the name
			delete [] pChildArray[i].pwszName;
			pChildArray[i].pwszName = 0;
		}
	}
	// Delete the array of children
	delete [] pChildArray;
	pChildArray = 0;

	// Delete all of the storage for our values
	for(i = 0; i < uNumValues; i++)
	{
		CSimpleUTFString *aValue = pValues[i].pValue;
		delete aValue;
		pValues[i].pValue = 0;
	}
	// Delete the array of values
	delete [] pValues;
	pValues = 0;

	// If we have a parent, remove this node from the parents list of children
	if(pParentNode != NULL)
	{
		for(i = 0; i < pParentNode->uNumChildren; i++)
			if(pParentNode->pChildArray[i].pChildNode == this)
				pParentNode->pChildArray[i].pChildNode = NULL;
	}

	gWDNodeCount--;
}

CSimpleUTFString * CWDNode::GetValueExp(char *expression)
{
	char *pos = expression;

	while(*pos != 0 && *pos != '.' && *pos != '[')
		pos++;

	if(*pos == 0)
	{
		CWDNode *subNode = GetChild(expression, 0);
		if(!subNode)
			return 0;	// Error

		return subNode->GetValue(0);
	}
	else if(*pos == '.')
	{
		*(pos++) = 0;
		CWDNode *subNode = GetChild(expression, 0);
		if(!subNode)
			return 0;	// Error
		
		return subNode->GetValueExp(pos);
		
	}
	else if(*pos == '[')
	{
		int theNum = 0;
		*(pos++) = 0;
		char *fieldnum = pos;
		while(*pos != 0 && *pos != ']')
		{
			theNum = theNum * 10 + (*pos - '0');
			pos++;
		}
		CWDNode *subNode = GetChild(expression, theNum);
		if(!subNode)
			return 0;	// Error
		if(pos[0] == 0 || pos[1] == 0)
		{
			return subNode->GetValue(0);
		}
		else
		{
			return subNode->GetValueExp(pos + 2);
		}
	}
	return 0;
}

void CWDNode::AddChild(char *name, CWDNode *childNode)
{
	assert(uNumChildren <= uAllocChildren);

	if(uNumChildren >= uAllocChildren)
	{
		// Double the size of the children array when we run out of space
		uAllocChildren *= 2;
		CChildren *newArray = new CChildren[uAllocChildren];
		assert(newArray != 0);
        if (newArray == NULL) {
            return;
        }
		if(uNumChildren)
			memmove(newArray, pChildArray, sizeof(CChildren) * uNumChildren);
		
		assert(pChildArray != 0);
		delete [] pChildArray;
		pChildArray = newArray;
	}

	pChildArray[uNumChildren].pwszName = new char[strlen(name) + 1];
    if (pChildArray[uNumChildren].pwszName == NULL) {
        return;
    }
	strcpy(pChildArray[uNumChildren].pwszName, name);
	pChildArray[uNumChildren].pChildNode = childNode;
	childNode->NodeAddRef();

	childNode->pParentNode = this;

	uNumChildren++;
}

void CWDNode::ReplaceValue(unsigned int valueNumber,
						   CSimpleUTFString *value,
						   bool isReference)
{
	assert(valueNumber < uNumValues);
	if(valueNumber >= uNumValues)
		return;
	delete pValues[valueNumber].pValue;
	pValues[valueNumber].pValue = new CSimpleUTFString();
    if (pValues[valueNumber].pValue == NULL) {
        return;
    }
	pValues[valueNumber].pValue->Copy(value);
}

void CWDNode::AddValue(CSimpleUTFString *value, bool isReference)
{		
	CValues *newArray = new CValues[uNumValues + 1];
	assert(newArray != 0);
    if (newArray == NULL) {
        return;
    }
	if(uNumValues > 0 && pValues != NULL)
		memmove(newArray, pValues, sizeof(CValues) * uNumValues);

	if(pValues != 0)
	{
		assert(pValues != 0);
		delete [] pValues;
	}
	pValues = newArray;

	pValues[uNumValues].pValue = new CSimpleUTFString();
    if (pValues[uNumValues].pValue == NULL) {
        return;
    }
	pValues[uNumValues].pValue->Copy(value);
	uNumValues++;
}

void CWDNode::DebugPrintTree(int indent)
{
	for(unsigned int i = 0; i < uNumChildren; i++)
	{
		for(int j = 0; j < indent; j++)
			printf("  ");
		printf("%s", pChildArray[i].pwszName);
		CWDNode *currentNode = pChildArray[i].pChildNode;
		if(currentNode->uNumValues > 0)
		{
			char *val = currentNode->pValues[0].pValue->toString();
			printf(" : %s", val);
			delete [] val;
		}

		printf("\n");

		currentNode->DebugPrintTree(indent + 1);
	}
}

CWDNode * CWDNode::GetChildIndex(unsigned int childNumber)
{
	if(childNumber < uNumChildren)
		return pChildArray[childNumber].pChildNode;
	else
		return 0;
}

unsigned int CWDNode::GetChildNumber(CWDNode *childNode)
{
	for(unsigned int i = 0; i < uNumChildren; i++)
	{
		if(pChildArray[i].pChildNode == childNode)
		{
			return i;
		}
	}

	return 0xffffffff;
}

CWDNode * CWDNode::GetChild(char *name, unsigned int childNumber)
{
	for(unsigned int i = 0; i < uNumChildren; i++)
	{
		if(!_stricmp(pChildArray[i].pwszName, name))
		{
			if(childNumber > 0)
				childNumber--;
			else
			{
				return pChildArray[i].pChildNode;
			}
		}
	}

	return 0;
}

CSimpleUTFString * CWDNode::GetValue(unsigned int valueNumber)
{
	if(valueNumber < uNumValues)
		return (pValues[valueNumber].pValue);
	else
		return 0;
}

char * CWDNode::GetMyName(void)
{
	assert(pParentNode != NULL);
	if(pParentNode == NULL)
		return NULL;

	for(unsigned int childNum = 0; childNum < pParentNode->uNumChildren; childNum++)
	{
		if(pParentNode->pChildArray[childNum].pChildNode == this)
		{
			return pParentNode->pChildArray[childNum].pwszName;
		}
	}
	return NULL;
}

CWDNode * CWDNode::GetSibling(unsigned int childNumber)
{
	assert(pParentNode != NULL);
	if(pParentNode == NULL)
		return NULL;

	char *name = GetMyName();
	return pParentNode->GetChild(name, childNumber);
}

CWDNode * CWDNode::GetNextSibling(void)
{
	assert(pParentNode != NULL);
	if(pParentNode == NULL)
		return NULL;

	for(unsigned int childNum = 0; childNum + 1 < pParentNode->uNumChildren; childNum++)
	{
		if(pParentNode->pChildArray[childNum].pChildNode == this)
		{
			return pParentNode->pChildArray[childNum + 1].pChildNode;
		}
	}
	return NULL;
}

CWDNode * CWDNode::WDClone()
{
	return new CWDNode();
}

void CWDNode::NodeReleaseRef(void)
{
	if ( ::InterlockedDecrement( &m_cRef ) < 1 )
	{
		delete this;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\myinfo\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MyInfo.rc
//
#define IDS_PROJNAME                    100
#define IDR_MYINFOCTL                   101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\status\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\myinfo\wcparser.h ===
#include "stdafx.h"
#include "WCNode.h"

class CWDNode;

// A simple string class
// This one is designed for minimal footprint, lack of virtual functions
// and no UTF8/Unicode support
// Note that this is similar to CSimpleUTFString but they are kept
// seperate for better inlining, lack of virutal functions and performance
short strcasecmp(const char *a, const char *b);

class CSimpleString
{
public:
			CSimpleString();
			~CSimpleString(void);
	void	Cat(unsigned char theChar);
	void	Clear(void) { myLength = 0; };
	void	Copy(CSimpleString *val);
	char *	toString(void);
	long	Cmp(char *compareString, bool caseSensitive);
	unsigned long	Length(void) { return myLength; };

private:
	void	Grow(unsigned newSize);
	char *myData;
	unsigned long myLength;
	unsigned long myActualLength;
};

// A simple string class
// This one is designed for minimal footprint, lack of virtual functions
// and UTF8/Unicode support
class CSimpleUTFString
{
public:
			CSimpleUTFString();
			~CSimpleUTFString(void);
	void	Cat(unsigned char theChar);
	void	Copy(unsigned short *unicodeChars, unsigned long length);
	void	Copy(CSimpleUTFString *val);
	void	Clear(void) { myLength = 0; };
	char *	toString(void);
	void	Extract(char *into);
	long	Cmp(char *compareString, bool caseSensitive);
	unsigned long	Length(void) { return myLength; };
	unsigned short *getData(void) { return myData; };

private:
	void	Grow(unsigned newSize);
	unsigned short *myData;
	unsigned long myLength;
	unsigned long myActualLength;
	short myUTFPos;	// In 1st (0) 2nd (1) or 3rd (2) byte of UTF8 character
};

class CWCParser
{
public:
// It is the caller's responsibility to free cloneNode when it is done with the WCParser
// Note that one cloneNode could be shared by several parser.
						CWCParser(CWDNode *cloneNode)
						{
							m_CloneNode = cloneNode;
						}
	virtual				~CWCParser();
	virtual	CWDNode *	StartParse() = 0;
	virtual	void		Parse(unsigned char *data, unsigned long size) = 0;
	virtual	void		EndParse() = 0;

	virtual	void		StartOutput(CWDNode *theNode) = 0;
	virtual bool		Output(char *buffer, unsigned long *size) = 0;
protected:
	CWDNode			*	m_CloneNode;
};

// This is for the 'Web Data' syntax
// The web data syntax is an application of XML
class CWDParser : public CWCParser
{
public:
						CWDParser(CWDNode *cloneNode);
	virtual				~CWDParser();
	virtual	CWDNode *	StartParse();
	virtual	void		Parse(unsigned char *data, unsigned long size);
	virtual	void		EndParse();

	virtual	void		StartOutput(CWDNode *theNode);
	virtual bool		Output(char *buffer, unsigned long *size);

private:
	CWDNode				*pCurrentNode;
	bool				fIsFirst; // Is this a reference

	// Note: myElementName and myAttributeName are currently not supporting
	// non-ascii characters. This can be fixed by changing the class they are in
	CSimpleString		myElementName;
	CSimpleString		myAttributeName;
	CSimpleUTFString	myAttributeValue;
	bool				myEncounteredWS;
	bool				myAtStart;
	int state;
	bool isClose;
};

// This is for the more "pure XML" syntax.
class CXMLWCParser : public CWCParser
{
public:
						CXMLWCParser(CWDNode *cloneNode);
	virtual				~CXMLWCParser();
	virtual	CWDNode *	StartParse();
	virtual	void		Parse(unsigned char *data, unsigned long size);
	virtual	void		EndParse();

	virtual	void		StartOutput(CWDNode *theNode);
	virtual bool		Output(char *buffer, unsigned long *size);

private:
	CWDNode				*pCurrentNode;
	bool				fIsFirst; // Is this a reference

	// Note: myElementName and myAttributeName are currently not supporting
	// non-ascii characters. This can be fixed by changing the class they are in
	CSimpleString		myElementName;
	CSimpleString		myAttributeName;
	CSimpleUTFString	myAttributeValue;
	int state;
	bool isClose;
};

class CHTMLWCParser : public CWCParser
{
public:
						CHTMLWCParser(CWDNode *cloneNode);
	virtual				~CHTMLWCParser();
	virtual	CWDNode *	StartParse();
	virtual	void		Parse(unsigned char *data, unsigned long size);
	virtual	void		EndParse();

	virtual	void		StartOutput(CWDNode *theNode);
	virtual bool		Output(char *buffer, unsigned long *size);

private:
	CWDNode				*pCurrentNode;
	bool				fIsFirst; // Is this a reference

	// Note: myElementName and myAttributeName are currently not supporting
	// non-ascii characters. This can be fixed by changing the class they are in
	CSimpleString		myElementName;
	CSimpleString		myAttributeName;
	CSimpleUTFString	myAttributeValue;
	int state;
	bool isClose;
	bool isContainer;
};

class CSALWCParser : public CWCParser
{
public:
						CSALWCParser(CWDNode *cloneNode);
	virtual				~CSALWCParser();
	virtual	CWDNode *	StartParse();
	virtual	void		Parse(unsigned char *data, unsigned long size);
	virtual	void		EndParse();

	virtual	void		StartOutput(CWDNode *theNode);
	virtual bool		Output(char *buffer, unsigned long *size);

private:
	CWDNode				*pCurrentNode;
	bool				fIsFirst; // Is this a reference

	// Note: myElementName and myAttributeName are currently not supporting
	// non-ascii characters. This can be fixed by changing the class they are in
	CSimpleString		myElementName;
	CSimpleString		myAttributeName;
	CSimpleUTFString	myAttributeValue;
	int state;
	bool isClose;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\status\statctl.h ===
// StatusCtl.h : Declaration of the CStatusCtl

#pragma warning (disable : 4786)
#ifndef __STATUSCTL_H_
#define __STATUSCTL_H_

#include "resource.h"       // main symbols
#include <asptlb.h>         // Active Server Pages Definitions

/////////////////////////////////////////////////////////////////////////////
// CStatusCtl

class CStatusComTypeInfoHolder
{
// Should be 'protected' but can cause compiler to generate fat code.
public:
	const GUID* m_pguid;
	const GUID* m_plibid;
	WORD m_wMajor;
	WORD m_wMinor;

	ITypeInfo* m_pInfo;
	long m_dwRef;

public:
	HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo);

	void AddRef();
	void Release();
	HRESULT GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
	HRESULT GetIDsOfNames(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgdispid);
	HRESULT Invoke(IDispatch* p, DISPID dispidMember, REFIID riid,
		LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
		EXCEPINFO* pexcepinfo, UINT* puArgErr);
};

class ATL_NO_VTABLE CStatusCtl : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CStatusCtl, &CLSID_Status>,
	public IDispatchImpl<IStatusCtl,
						&IID_IStatusCtl,
						&LIBID_Status,
						1, 0, CStatusComTypeInfoHolder>
{
public:
	CStatusCtl()
	{ 
	}

public:

DECLARE_REGISTRY_RESOURCEID(IDR_STATUSCTL)

BEGIN_COM_MAP(CStatusCtl)
	COM_INTERFACE_ENTRY(IStatusCtl)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IStatusCtl
public:
	STDMETHOD(Unimplemented)(/*[out, retval]*/ BSTR* pbstrRetVal);
};

#endif //__STATUSCTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\status\status.cpp ===
// Status.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f Statusps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "Status.h"

#include "Status_i.c"
#include <initguid.h>
#include "StatCtl.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_Status, CStatusCtl)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\status\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Status.rc
//
#define IDS_PROJNAME                    100
#define IDR_STATUSCTL                   101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\status\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__4682C811_B2FF_11D0_95A8_00A0C92B77A9__INCLUDED_)
#define AFX_STDAFX_H__4682C811_B2FF_11D0_95A8_00A0C92B77A9__INCLUDED_

#if _MSC_VER >= 1020
//#pragma once
#endif // _MSC_VER >= 1020

#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif

#define STRICT


#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__4682C811_B2FF_11D0_95A8_00A0C92B77A9__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\myinfo\wdparser.cpp ===
#include "stdafx.h"
#include <string.h>
#include <assert.h>
#include "WCNode.h"
#include "WCParser.h"

#include <stdio.h>


// Use this define to determine if unknown attributes become sub-nodes.
// For example <FOO VALUE="xxx" BAR="yyy"/> would be rendered as:
// foo = xxx
//    bar = yyy
//
// Note: if this is set to zero unknown attributes are ignored
#define WCMAKEATTRSCHILDREN 1
#define WCVERBOSE 0

// CWDParser

CWDParser::CWDParser(CWDNode *cloneNode) : CWCParser(cloneNode)
{
}

CWDParser::~CWDParser()
{
}

CWDNode * CWDParser::StartParse()
{
	fIsFirst = true;
	pCurrentNode = m_CloneNode->WDClone();
	state = 0;
	isClose = false;
	myEncounteredWS = false;
	return pCurrentNode;
}


char wdcharlookuparray[256] =
{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x03, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x03, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x05, 0x02, 0x00, // 0x30
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
// char lookups:
// 0 - alphanum
// 1 - '<'
// 2 - '>'
// 3 - whitespace
// 4 - '/'
// 5 - '='
// 6 - '"'

unsigned char wdnextstatetable[16][16] =
{
	{	// State 0- Not inside an element
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00
	},
	{	// State 1- Inside an element First character
	0x02, 0x02, 0x00, 0x01, 0x0a, 0x02, 0x00
	},
	{	// State 2- Inside an element name After the first character
	0x02, 0x02, 0x00, 0x03, 0x02, 0x02, 0x00 },
	{	// State 3- After the element name
	0x04, 0x03, 0x00, 0x03, 0x09, 0x03, 0x00 },
	{	// State 4- Attribute name
	0x04, 0x04, 0x00, 0x05, 0x09, 0x06, 0x00 },
	{	// State 5- After Attribute name
	0x05, 0x05, 0x00, 0x05, 0x09, 0x06, 0x00 },
	{	// State 6- In attribute value first char (no quotes yet)
	0x07, 0x06, 0x00, 0x04, 0x09, 0x06, 0x08 },
	{	// State 7- In attribute value after first char (no quotes)
	0x07, 0x06, 0x00, 0x04, 0x09, 0x06, 0x00 },
	{	// State 8- In attribute value (quotes)
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x03 },
	{	// State 9- After receiving a '/' that should be at the end of the tag
	0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00 },
	{	// State 0x0a- Received initial '/'. Close tag
	0x0a, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00 },
	{	// State 0x0b- Received initial '/'. After element name. Close tag
	0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00 },
};

// char lookups:
// 0 - alphanum
// 1 - '<'
// 2 - '>'
// 3 - whitespace
// 4 - '/'
// 5 - '='
// 6 - '"'
unsigned char wdactionstatetable[16][16] =
{
	{	// State 0- Not inside an element
	0x0a, 0x01, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a },
	{	// State 1- Inside an element First character
	0x03, 0x80, 0x00, 0x00, 0x02, 0x00, 0x80 },
	{	// State 2- Inside an element name After the first character
	0x03, 0x80, 0x24, 0x04, 0x00, 0x00, 0x80 },
	{	// State 3- After the element name
	0x09, 0x80, 0x20, 0x00, 0x00, 0x00, 0x80 },
	{	// State 4- Attribute name
	0x05, 0x80, 0x20, 0x06, 0x00, 0x06, 0x80 },
	{	// State 5- After Attribute name
	0x00, 0x80, 0x20, 0x00, 0x00, 0x00, 0x80 },
	{	// State 6- In attribute value first char (no quotes yet)
	0x07, 0x80, 0x20, 0x00, 0x80, 0x00, 0x00 },
	{	// State 7- In attribute value after first char (no quotes)
	0x07, 0x80, 0x28, 0x08, 0x08, 0x80, 0x80 },
	{	// State 8- In attribute value (quotes)
	0x07, 0x07, 0x27, 0x07, 0x07, 0x07, 0x08 },
	{	// State 9- After receiving a '/' that should be at the end of the tag
	0x80, 0x80, 0x10, 0x00, 0x80, 0x80, 0x80 },
	{	// State 0x0a- Inside an element name After the first character (close tag)
	0x03, 0x80, 0x44, 0x00, 0x80, 0x80, 0x80 },
	{	// State 0x0b- Inside an element name After the first character (close tag)
	0x80, 0x80, 0x44, 0x00, 0x80, 0x80, 0x80 },
};
// Actions
// 0 - nothing
// 1 - Beginning of a tag
// 2 - This is a close tag
// 3 - Add to element name
// 4 - Done with element name
// 5 - Add to attribute name
// 6 - Done with attribute name
// 7 - Add to attribute value
// 8 - Done with attribute value
// 9 - Add first character to attribute value
// a - Add to attribute value (CDATA)
// 0x10 - Done with tag not container
// 0x20 - Done with tag container
// 0x40 - Close tag
// 0x80 - Signal error condition

void CWDParser::Parse(unsigned char *data, unsigned long size)
{
	unsigned long pos = 0;

	while(pos < size)
	{
		char value = wdcharlookuparray[data[pos]];
		int newstate = wdnextstatetable[state][value];
		int action = wdactionstatetable[state][value];

		switch(action & 0x0f)
		{
		case 0:
			break;
		case 1: // Begin new element
			myElementName.Clear();
			myAttributeName.Clear();
			if(myAttributeValue.Length() > 0)
				pCurrentNode->AddValue(&myAttributeValue, false);
			myAttributeValue.Clear();
			myEncounteredWS = false;
			isClose = false;
			break;
		case 2:	// This is a close element
			isClose = true;
			break;
		case 3:
			{
				myElementName.Cat(data[pos]);
				break;
			}
		case 4:
			{
			if(isClose)
				break;
			char *val = myElementName.toString();
			
#if WCVERBOSE
			printf("Found element: %s\n", val);
#endif // WCVERBOSE
			delete [] val;
			if(!myElementName.Cmp("XML", false))
			{
				fIsFirst = true;
				break;
			}
	//		else if(fIsFirst)
	//		{
	//			fIsFirst = false;
	//		}
			else
			{
				CWDNode *parent = pCurrentNode;

				pCurrentNode = m_CloneNode->WDClone();
				char *val = myElementName.toString();
				parent->AddChild(val, pCurrentNode);
				delete [] val;
			}
			break;
			}

		case 5:
			{
				myAttributeName.Cat(data[pos]);
				break;
			}
		case 6:
			{
				char *val = myAttributeName.toString();
#if WCVERBOSE
				printf("Found attribute: %s\n", val);
#endif // WCVERBOSE
				delete [] val;
				break;
			}
		case 7:
			{
				myAttributeValue.Cat(data[pos]);
				break;
			}
		case 10:
			{
				if(data[pos] == ' ' || data[pos] == '\r' || data[pos] == '\n')
				{
					if(myAttributeValue.Length() > 0)
						myEncounteredWS = true;
				}
				else
				{
					if(myEncounteredWS)
					{
						myAttributeValue.Cat(' ');
						myEncounteredWS = false;
					}
					myAttributeValue.Cat(data[pos]);
				}
				break;
			}
		case 8:
			{
			//	char *attrValue = myAttributeValue.toString();
#if WCVERBOSE
				printf("Found attribute value: %s\n", attrValue);
#endif // WCVERBOSE

				if(!myAttributeName.Cmp("profile", false))
				{
				}
				else if(!myAttributeName.Cmp("id", false))
				{
				}
				else if(!myAttributeName.Cmp("about", false))
				{
				}
				else if(!myAttributeName.Cmp("value", false))
				{
					pCurrentNode->AddValue(&myAttributeValue, false);
				}
				else if(!myAttributeName.Cmp("href", false))
				{
				}
				else if(!myAttributeName.Cmp("type", false))
				{
				}
#if WCMAKEATTRSCHILDREN
				else
				{
					CWDNode *newNode;

					newNode = m_CloneNode->WDClone();
					char *val = myAttributeName.toString();
					pCurrentNode->AddChild(val, newNode);
					newNode->AddValue(&myAttributeValue, false);
					delete [] val;
				}
#endif // WCMAKEATTRSCHILDREN

			//	delete [] attrValue;
				myAttributeValue.Clear();
				myEncounteredWS = false;
				myAttributeName.Clear();
				break;
			}
		case 9:
			myAttributeName.Clear();
			myAttributeName.Cat(data[pos]);
			break;
		}

		switch(action & 0xf0)
		{
		case 0x10:
#if WCVERBOSE
			printf("Done with element, not container.\n");
#endif // WCVERBOSE
			if(pCurrentNode->GetParent())
				pCurrentNode = pCurrentNode->GetParent();
			break;
		case 0x20:
#if WCVERBOSE
			printf("Done with element, container.\n");
#endif // WCVERBOSE
			break;
		case 0x40:
#if WCVERBOSE
			printf("Done with element. Close tag.\n");
#endif // WCVERBOSE
			if(pCurrentNode->GetParent())
				pCurrentNode = pCurrentNode->GetParent();
			break;
		case 0x80:
#if WCVERBOSE
			printf("Error!\n");
#endif // WCVERBOSE
			break;
		}

	//	printf("%c %ld %ld %ld\n", data[pos], value, newstate, action);
		state = newstate;
		pos++;
	}
}


void CWDParser::EndParse()
{
}

void CWDParser::StartOutput(CWDNode *theNode)
{
	myAtStart = true;
	pCurrentNode = theNode;
}

// Returns true if there is more data
bool CWDParser::Output(char *buffer, unsigned long *size)
{
	unsigned long curPos = 0;

	if(myAtStart)
	{
		myAtStart = false;
		if(*size > 7)
		{
			strcpy(buffer, "<XML>\r\n");
			curPos += 7;
		}
		if(pCurrentNode->NumChildren() < 1)
		{
			strcpy(buffer + curPos, "</XML>\r\n");
			curPos += 8;
			*size = curPos;
			return false;
		}
		pCurrentNode = pCurrentNode->GetChildIndex(0);	// Get started parsing
	}
	while(*size - curPos > 500 && pCurrentNode != NULL && pCurrentNode->GetParent() != NULL)
	{
		buffer[curPos++] = '<';
		char *currentName = pCurrentNode->GetMyName();
		strcpy(buffer + curPos, currentName);
		curPos += strlen(currentName);
		buffer[curPos++] = '>';

		// Now put the value in
		if(pCurrentNode->NumValues() > 0)
		{
			CSimpleUTFString *theValue = pCurrentNode->GetValue(0);
			char *theStr = theValue->toString();

            if (theStr) {
			    strcpy(buffer + curPos, theStr);
			    curPos += strlen(theStr);
			    delete [] theStr;
            }
			// We don't need to delete theValue- It is the one used in the node itself
		}

		// Advance pCurrentNode
		if(pCurrentNode->NumChildren() > 0)
			pCurrentNode = pCurrentNode->GetChildIndex(0);
		else
		{
			while(pCurrentNode != NULL && pCurrentNode->GetParent() != NULL)
			{
				buffer[curPos++] = '<';
				buffer[curPos++] = '/';
				buffer[curPos++] = '>';
				buffer[curPos++] = '\r';
				buffer[curPos++] = '\n';
				CWDNode *nextNode = pCurrentNode->GetNextSibling();
				if(nextNode == NULL)
				{
					pCurrentNode = pCurrentNode->GetParent();
				}
				else
				{
					pCurrentNode = nextNode;
					break;
				}
			}
		}
	}
	*size = curPos;

	if(pCurrentNode == NULL || pCurrentNode->GetParent() == NULL)
	{
		strcpy(buffer + curPos, "</XML>\r\n");
		*size += 8;
		return false;
	}
	else
		return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\tools\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\tools\ascrsite.cpp ===
#include "stdafx.h"
#include "ToolsCtl.h"
#include "AScrSite.h"

/////////////////////////////////////////////////////////////////////////////
//	CToolsActiveScriptSite

CToolsActiveScriptSite::~CToolsActiveScriptSite()
{
	CloseOutputFile();
}

STDMETHODIMP
CToolsActiveScriptSite::Write(
	BSTR data )
{
	if ( data == NULL )
	{
		return E_POINTER;
	}

	ULONG length = SysStringLen(data);
	unsigned char *buffer = new unsigned char[length];
	if ( buffer == NULL )
	{
		return E_OUTOFMEMORY;
	}

	ULONG bufIdx = 0;
	bool bEscape = false;
	for(ULONG i = 0; i < length; i++)
	{
        if ( !bEscape )
        {
            if ( data[i] != '\\' )
            {
                buffer[bufIdx++] = static_cast<char>( data[i] );
            }
            else
            {
                bEscape = true;
            }
        }
        else    // escape sequence
        {
            switch ( data[i] )
            {
                case 'n':
                {
                    buffer[bufIdx] = '\n';
                } break;

                case 'r':
                {
                    buffer[bufIdx] = '\r';
                } break;

                case '\\':
                {
                    buffer[bufIdx] = '\\';
                } break;

                case '\"':
                {
                    buffer[bufIdx] = '\"';
                } break;
                
                default:
                {
                    ATLTRACE( _T( "CToolsActiveScriptSite::Write: unhandled escape sequence" ) );
                    buffer[bufIdx] = static_cast<char>( data[i] );
                }
            }
            bEscape = false;
            bufIdx++;
        }
	}

	ULONG bytesWritten;
	WriteFile(m_hOutputFile, buffer, bufIdx, &bytesWritten, NULL);
	delete [] buffer;

	return S_OK;
}

STDMETHODIMP
CToolsActiveScriptSite::WriteSafe(
	BSTR data )
{
	if ( data == NULL )
	{
		return E_POINTER;
	}

	ULONG length = SysStringLen(data);
	unsigned char *buffer = new unsigned char[length];
	if ( buffer == NULL )
	{
		return E_OUTOFMEMORY;
	}

	BOOL prevLT = FALSE;

	for(ULONG i = 0; i < length; i++)
	{
		if(data[i] == '<')
			prevLT = TRUE;
		else if(data[i] == '%' && prevLT)
		{
			buffer[i] = ' ';
			prevLT = FALSE;
			continue;
		}
		else
			prevLT = FALSE;
		buffer[i] = (unsigned char) (data[i]);
	}

	ULONG bytesWritten;
	WriteFile(m_hOutputFile, buffer, length, &bytesWritten, NULL);
	delete [] buffer;

	return S_OK;
}


STDMETHODIMP
CToolsActiveScriptSite::GetLCID(
	LCID *pclid )
{
	HRESULT rc = S_OK;
	if ( pclid )
	{
		*pclid = LOCALE_SYSTEM_DEFAULT;
	}
	else
	{
		rc = E_POINTER;
	}
	return rc;
}

STDMETHODIMP
CToolsActiveScriptSite::GetItemInfo(
	LPCOLESTR pwszName,
	DWORD dwReturnMask,
	IUnknown **ppunkItem,
	ITypeInfo** ppTypeInfo )
{
	HRESULT hr = S_OK;

	if (ppunkItem)
		*ppunkItem = 0;
	if (ppTypeInfo) 
		*ppTypeInfo = 0;
				
	if (pwszName && _wcsicmp(pwszName, L"response") == 0)
	{
		if (dwReturnMask & SCRIPTINFO_IUNKNOWN)
		{
			// is AddRef needed?
			*ppunkItem = GetUnknown();
		}
	}
	else if (pwszName && _wcsicmp(pwszName, L"request") == 0)
	{
		if (dwReturnMask & SCRIPTINFO_IUNKNOWN)
		{
			*ppunkItem = m_tc.m_piRequest;
		}
	}
	else if (pwszName && _wcsicmp(pwszName, L"session") == 0)
	{
		if (dwReturnMask & SCRIPTINFO_IUNKNOWN)
		{
			*ppunkItem = m_tc.m_piSession;
		}
	}
	else if (pwszName && _wcsicmp(pwszName, L"server") == 0)
	{
		if (dwReturnMask & SCRIPTINFO_IUNKNOWN)
		{
			*ppunkItem = m_tc.m_piServer;
		}
	}
	else if (pwszName && _wcsicmp(pwszName, L"application") == 0)
	{
		if (dwReturnMask & SCRIPTINFO_IUNKNOWN)
		{
			*ppunkItem = m_tc.m_piApplication;
		}
	}
	else
	{
		hr = TYPE_E_ELEMENTNOTFOUND;
	}

	if (ppunkItem && *ppunkItem)
		(*ppunkItem)->AddRef();

	return hr;
}


STDMETHODIMP CToolsActiveScriptSite::GetDocVersionString(BSTR *pstrVersionString)
{
	HRESULT rc = E_FAIL;
	*pstrVersionString = ::SysAllocString(L"Tools");
	if ( pstrVersionString )
	{
		rc = S_OK;
	}
	else
	{
		rc = E_OUTOFMEMORY;
	}
	return rc;
}

STDMETHODIMP CToolsActiveScriptSite::OnScriptTerminate(const VARIANT *pvarRest,
						const EXCEPINFO *pexcepinfo)
{
	return S_OK;
}


STDMETHODIMP CToolsActiveScriptSite::OnStateChange(SCRIPTSTATE ssScriptState)
{
	return S_OK;
}


STDMETHODIMP CToolsActiveScriptSite::OnScriptError(IActiveScriptError* perror)
{
	HRESULT			hr = S_OK;
#if 0
	EXCEPINFO       excepinfo;
	DWORD           dwSourceContext;
	ULONG           ulLineNumber;
	LONG            lChPos;

	memset(&excepinfo, 0, sizeof(excepinfo));
	perror->GetExceptionInfo(&excepinfo);
	perror->GetSourcePosition(&dwSourceContext,
		&ulLineNumber, &lChPos);

	if ( excepinfo.bstrDescription )
	{
		CToolsCtl::RaiseException( excepinfo.bstrDescription )
	}
#endif
	CToolsCtl::RaiseException( IDS_ERROR_TEMPLATESCRIPT );

	return hr;
}


STDMETHODIMP CToolsActiveScriptSite::OnEnterScript()
{
	return S_OK;
}


STDMETHODIMP CToolsActiveScriptSite::OnLeaveScript()
{
	return S_OK;
}

bool
CToolsActiveScriptSite::OpenOutputFile(
	BSTR	bstrFile )
{
	bool rc = false;

	m_hOutputFile = CreateFileW(
		bstrFile, // pointer to name of the file 
		GENERIC_WRITE, // access (read-write) mode 
		0, // share mode
		NULL, // pointer to security attributes 
		CREATE_ALWAYS, // how to create 
		0, // file attributes 
		NULL // handle to file with attributes to copy 
	);

	if(m_hOutputFile != INVALID_HANDLE_VALUE)
	{
		rc = true;
	}
	else
	{
		CToolsCtl::RaiseException( IDS_ERROR_OUTPUTFILE );
		m_hOutputFile = NULL;
	}

	return rc;
}

void
CToolsActiveScriptSite::CloseOutputFile()
{
	if ( m_hOutputFile )
	{
		::CloseHandle( m_hOutputFile );
		m_hOutputFile = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\status\statctl.cpp ===
// StatusCtl.cpp : Implementation of CStatusCtl
#include "TCHAR.h"
#include "stdafx.h"
#include "Status.h"
#include "StatCtl.h"

/////////////////////////////////////////////////////////////////////////////
// CStatusCtl
STDMETHODIMP CStatusCtl::Unimplemented(BSTR * pbstrRetVal)
{
	// TODO: Add your implementation code here

	*pbstrRetVal = SysAllocString(L"Unavailable");

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CStatusComTypeInfoHolder

void CStatusComTypeInfoHolder::AddRef()
{
	EnterCriticalSection(&_Module.m_csTypeInfoHolder);
	m_dwRef++;
	LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
}

void CStatusComTypeInfoHolder::Release()
{
	EnterCriticalSection(&_Module.m_csTypeInfoHolder);
	if (--m_dwRef == 0)
	{
		if (m_pInfo != NULL)
			m_pInfo->Release();
		m_pInfo = NULL;
	}
	LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
}

HRESULT CStatusComTypeInfoHolder::GetTI(LCID lcid, ITypeInfo** ppInfo)
{
	//If this assert occurs then most likely didn't initialize properly
	_ASSERTE(m_plibid != NULL && m_pguid != NULL);
	_ASSERTE(ppInfo != NULL);
	*ppInfo = NULL;

	HRESULT hRes = E_FAIL;
	EnterCriticalSection(&_Module.m_csTypeInfoHolder);
	if (m_pInfo == NULL)
	{
		ITypeLib* pTypeLib;
		hRes = LoadRegTypeLib(*m_plibid, m_wMajor, m_wMinor, lcid, &pTypeLib);
		if (SUCCEEDED(hRes))
		{
			ITypeInfo* pTypeInfo;
			hRes = pTypeLib->GetTypeInfoOfGuid(*m_pguid, &pTypeInfo);
			if (SUCCEEDED(hRes))
				m_pInfo = pTypeInfo;
			pTypeLib->Release();
		}
	}
	*ppInfo = m_pInfo;
	if (m_pInfo != NULL)
	{
		m_pInfo->AddRef();
		hRes = S_OK;
	}
	LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
	return hRes;
}

HRESULT CStatusComTypeInfoHolder::GetTypeInfo(UINT /*itinfo*/, LCID lcid,
	ITypeInfo** pptinfo)
{
	HRESULT hRes = E_POINTER;
	if (pptinfo != NULL)
		hRes = GetTI(lcid, pptinfo);
	return hRes;
}

HRESULT CStatusComTypeInfoHolder::GetIDsOfNames(REFIID /*riid*/, LPOLESTR* rgszNames,
	UINT cNames, LCID lcid, DISPID* rgdispid)
{
	ITypeInfo* pInfo;
	HRESULT hRes = GetTI(lcid, &pInfo);
	if (pInfo != NULL)
	{
		if(!wcsicmp(rgszNames[0], L"OnStartPage") ||
			!wcsicmp(rgszNames[0], L"OnEndPage"))
		{
			*rgdispid = 0;
			hRes = DISP_E_UNKNOWNNAME;
		}
		else
		{
			*rgdispid = 1;
			hRes = S_OK;
		}
		pInfo->Release();
	}
	return hRes;
}

HRESULT CStatusComTypeInfoHolder::Invoke(IDispatch* p, DISPID dispidMember, REFIID /*riid*/,
	LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
	EXCEPINFO* pexcepinfo, UINT* puArgErr)
{
	SetErrorInfo(0, NULL);
	ITypeInfo* pInfo;
	HRESULT hRes = GetTI(lcid, &pInfo);
	if (pInfo != NULL)
	{
		hRes = pInfo->Invoke(p, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
		pInfo->Release();
	}
	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\tools\ascrsite.h ===
// AScrSite.h : Declaration of the CToolsActiveScriptSite
// this supplies and envirorment for a script to be run (needed for CToolsCtl.ProcessForm)

#pragma once

#ifndef _ASCRSITE_H_
#define _ASCRSITE_H_

#include "ToolsCxt.h"
#include "activscp.h"

/////////////////////////////////////////////////////////////////////////////
//	CToolsActiveScriptSite

class CToolsActiveScriptSite : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CToolsActiveScriptSite, &CLSID_ToolsResponse>,
	public IDispatchImpl<IToolsResponse, &IID_IToolsResponse, &LIBID_Tools>,
	public IActiveScriptSite
{
public:

DECLARE_NO_REGISTRY()

BEGIN_COM_MAP(CToolsActiveScriptSite)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IActiveScriptSite)
	COM_INTERFACE_ENTRY(IToolsResponse)
END_COM_MAP()

	CToolsActiveScriptSite(CToolsContext& tc)
		:	m_tc( tc ){}
	CToolsActiveScriptSite(){}
	~CToolsActiveScriptSite();

    virtual HRESULT STDMETHODCALLTYPE GetLCID( 
        /* [out] */ LCID __RPC_FAR *plcid);
    
    virtual HRESULT STDMETHODCALLTYPE GetItemInfo( 
        /* [in] */ LPCOLESTR pstrName,
        /* [in] */ DWORD dwReturnMask,
        /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppiunkItem,
        /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppti);
    
    virtual HRESULT STDMETHODCALLTYPE GetDocVersionString( 
        /* [out] */ BSTR __RPC_FAR *pbstrVersion);
    
    virtual HRESULT STDMETHODCALLTYPE OnScriptTerminate( 
        /* [in] */ const VARIANT __RPC_FAR *pvarResult,
        /* [in] */ const EXCEPINFO __RPC_FAR *pexcepinfo);
    
    virtual HRESULT STDMETHODCALLTYPE OnStateChange( 
        /* [in] */ SCRIPTSTATE ssScriptState);
    
    virtual HRESULT STDMETHODCALLTYPE OnScriptError( 
        /* [in] */ IActiveScriptError __RPC_FAR *pscripterror);
    
    virtual HRESULT STDMETHODCALLTYPE OnEnterScript( void);
    
    virtual HRESULT STDMETHODCALLTYPE OnLeaveScript( void);

// IUnknown
	STDMETHOD_(ULONG, AddRef)() {return 1;}
	STDMETHOD_(ULONG, Release)()
	{
		return 1;
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}

// IToolsResponse method
	STDMETHOD(Write)(BSTR data);
	STDMETHOD(WriteSafe)(BSTR data);

public:
	bool			OpenOutputFile( BSTR );
	void			CloseOutputFile();

private:
	CToolsContext	m_tc;
	HANDLE			m_hOutputFile;
};


#endif	// !_ASCRSITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\tools\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Tools.rc
//
#define IDS_PROJNAME                    100
#define IDR_TOOLSCTL                    101

#define IDS_ERROR_FILENOTFOUND			102
#define IDS_ERROR_TEMPLATESCRIPT		103
#define IDS_ERROR_OUTPUTFILE			104
#define IDS_ERROR_SOURCE				105
#define IDS_ERROR_CREATESCRIPTINGENGINE	106
#define IDS_ERROR_CREATE				107

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\tools\simplstr.h ===
#ifndef __SIMPLSTR_H
#define __SIMPLSTR_H

#include "stdafx.h"

// A simple string class
// This one is designed for minimal footprint, lack of virtual functions
// and no UTF8/Unicode support
// Note that this is similar to CSimpleUTFString but they are kept
// seperate for better inlining, lack of virutal functions and performance
short strcasecmp(const char *a, const char *b);

class CSimpleString
{
public:
			CSimpleString();
			~CSimpleString(void);
	HRESULT	Cat(unsigned char theChar);
	void	Clear(void) { myLength = 0; };
	HRESULT	Copy(CSimpleString *val);
	char *	toString(void);
	long	Cmp(char *compareString, BOOL caseSensitive);
	unsigned long	Length(void) { return myLength; };

private:
	HRESULT	Grow(unsigned newSize);
	char *myData;
	unsigned long myLength;
	unsigned long myActualLength;
	short myUTFPos;	// In 1st (0) 2nd (1) or 3rd (2) byte of UTF8 character
};

// A simple string class
// This one is designed for minimal footprint, lack of virtual functions
// and UTF8/Unicode support
class CSimpleUTFString
{
public:
			CSimpleUTFString();
			~CSimpleUTFString(void);
	HRESULT	Cat(unsigned short theChar);
	HRESULT	Cat(unsigned char theChar);
	HRESULT	Cat(char *theChars);
	HRESULT	Copy(unsigned short *unicodeChars, unsigned long length);
	HRESULT	Copy(CSimpleUTFString *val);
	void	Clear(void) { myLength = 0; };
	char *	toString(void);
	HRESULT	Extract(char *into);
	long	Cmp(char *compareString, BOOL caseSensitive);
	unsigned long	Length(void) { return myLength; };
	unsigned short *getData(void) { return myData; };

private:
	HRESULT	Grow(unsigned newSize);
	unsigned short *myData;
	unsigned long myLength;
	unsigned long myActualLength;
	short myUTFPos;	// In 1st (0) 2nd (1) or 3rd (2) byte of UTF8 character
};


#endif //__SIMPLSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\tools\simplstr.cpp ===
#include "stdafx.h"
#include <string.h>
#include <assert.h>
#include "SimplStr.h"

// A simple string class
// This one is designed for minimal footprint, lack of virtual functions
// and UTF8/Unicode support


short strcasecmp(const char *a, const char *b)
{
	for( ; ((*a > 96 ? *a - 32 : *a) == (*b > 96 ? *b - 32 : *b)) && *a; a++, b++)
	{}

	return (*a > 96 ? *a - 32 : *a) - (*b > 96 ? *b - 32 : *b);
}

CSimpleString::CSimpleString()
{
	myData = 0;
	myLength = 0;
	myActualLength = 16;	// Not true when myData == 0, but an optimization
	myUTFPos = 0;
}

CSimpleUTFString::CSimpleUTFString()
{
	myData = 0;
	myLength = 0;
	myActualLength = 16;	// Not true when myData == 0, but an optimization
}

CSimpleString::~CSimpleString()
{
	if(myData)
		delete [] myData;
}

CSimpleUTFString::~CSimpleUTFString()
{
	if(myData)
		delete [] myData;
}

HRESULT CSimpleString::Grow(unsigned newSize)
{
	HRESULT rc = S_OK;

	if(!myData || newSize > myActualLength)
	{
		while(myActualLength < newSize)
			myActualLength *= 2;
		
		char *newData = new char[myActualLength];
		if ( newData )
		{
			assert(newData != 0);
			if(myData != 0 && myLength > 0)
			{
				assert(newData != 0);
				assert(myData != 0);
				assert(myLength > 0);
				assert(myLength < 0x01000000);	// Sanity checking

				memmove(newData, myData, myLength);
				delete [] myData;
			}
			myData = newData;
		}
		else
		{
			rc = E_OUTOFMEMORY;
		}
	}
	return rc;
}

HRESULT CSimpleUTFString::Grow(unsigned newSize)
{
	HRESULT rc = S_OK;
	if(!myData || newSize > myActualLength)
	{
		while(myActualLength < newSize)
			myActualLength *= 2;
		
		unsigned short *newData = new unsigned short[myActualLength];
		if ( newData )
		{
			assert(newData != 0);
			if(myData != 0 && myLength > 0)
			{
				assert(newData != 0);
				assert(myData != 0);
				assert(myLength > 0);
				assert(myLength < 0x01000000);	// Sanity checking

				memmove(newData, myData, myLength * 2);
				delete [] myData;
			}
			myData = newData;
		}
		else
		{
			rc = E_OUTOFMEMORY;
		}
	}
	return rc;
}

HRESULT CSimpleString::Copy(CSimpleString *val)
{
	HRESULT rc = Grow(val->myLength);
	if ( !FAILED( rc ) )
	{
		myLength = val->myLength;
		memmove(myData, val->myData, myLength);
	}
	return rc;
}

HRESULT CSimpleUTFString::Copy(unsigned short *unicodeChars, unsigned long length)
{
	HRESULT rc = Grow(length);
	if ( !FAILED( rc ) )
	{
		myLength = length;
		memmove(myData, unicodeChars, length * sizeof(unsigned short));
	}
	return rc;
}

HRESULT CSimpleUTFString::Copy(CSimpleUTFString *val)
{
	HRESULT rc = Grow(val->myLength);
	if ( !FAILED(rc) )
	{
		myLength = val->myLength;
		memmove(myData, val->myData, myLength * 2);
	}
	return rc;
}

HRESULT CSimpleString::Cat(unsigned char theChar)
{
	HRESULT rc = Grow(myLength + 1);
	if ( !FAILED(rc) )
	{
		myData[myLength++] = theChar;
	}
	return rc;
}

HRESULT CSimpleUTFString::Cat(unsigned short theChar)
{
	HRESULT rc = Grow(myLength + 1);
	if ( !FAILED(rc) )
	{
		myData[myLength++] = theChar;
	}
	return rc;
}

HRESULT CSimpleUTFString::Cat(char * theChars)
{
	HRESULT rc = S_OK;
	while(*theChars)
	{
		rc = Grow(myLength + 1);
		if ( FAILED(rc) )
		{
			return rc;
		}
		myData[myLength++] = *theChars;
		theChars++;
	}
	return rc;
}

HRESULT CSimpleUTFString::Cat(unsigned char theChar)
{
	HRESULT rc = S_OK;
	// So that it will inline better
	if(!(theChar & 0x80) || myUTFPos == 0)
	{
		rc = Grow(myLength + 1);
		if ( FAILED(rc) )
		{
			return rc;
		}
	}

	if(theChar & 0x80)
	{
		if(myUTFPos == 0)
		{
			if(theChar & 0x20)	// 1st byte of three byte sequence
			{
				myData[myLength] = (theChar & 0x0f) << 12;
				myUTFPos = 2;
			}
			else	// 1st byte of a two byte sequence
			{
				myData[myLength] = (theChar & 0x1f) << 6;
				myUTFPos = 1;
			}
		}
		else if(myUTFPos == 1)	// 2nd byte of a two byte sequence
		{
			myData[myLength++] |= (theChar & 0x3f);
			myUTFPos = 0;
		}
		else if(myUTFPos == 2)
		{
			myData[myLength] |= (theChar & 0x3f) << 6;
			myUTFPos = 3;
		}
		else
		{
			myData[myLength++] |= (theChar & 0x3f);
			myUTFPos = 0;
		}
	}
	else
	{
		myData[myLength++] = theChar;
	}
	return rc;
}

// The caller must call delete [] on the return value
char * CSimpleString::toString(void)
{
	char *newData = new char[myLength + 1];
	if ( newData )
	{
		memmove(newData, myData, myLength);
		newData[myLength] = 0;
	}
	return newData;
}

char * CSimpleUTFString::toString(void)
{
	char *newData = new char[myLength + 2];
	if ( newData )
	{
		unsigned long i;
		for(i = 0; i < myLength; i++)
			newData[i] = (char) myData[i];
		newData[myLength] = 0;
		newData[myLength + 1] = 0;
	}
	return newData;
}

HRESULT CSimpleUTFString::Extract(char *into)
{
	unsigned long i;
	for(i = 0; i < myLength; i++)
		into[i] = (char) myData[i];
	into[myLength] = 0;
	return S_OK;
}

long CSimpleString::Cmp(char *compareString, BOOL caseSensitive)
{
	if ( FAILED( Grow(myLength + 1) ) )
	{
		return -1;
	}
	myData[myLength] = 0;
	if(caseSensitive)
		return strcmp(compareString, myData);
	else
		return strcasecmp(compareString, myData);
}

long CSimpleUTFString::Cmp(char *compareString, BOOL caseSensitive)
{
	char *val = toString();
	short result = -1;

	if ( val )
	{
		if(caseSensitive)
			result = strcmp(compareString, val);
		else
			result = strcasecmp(compareString, val);

		delete [] val;
	}
	return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\tools\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__64D91635_BA0F_11D0_979C_00A0C908612D__INCLUDED_)
#define AFX_STDAFX_H__64D91635_BA0F_11D0_979C_00A0C908612D__INCLUDED_

#if _MSC_VER >= 1020
#pragma once
#endif // _MSC_VER >= 1020

#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif

#define STRICT


#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
#include <mtx.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__64D91635_BA0F_11D0_979C_00A0C908612D__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\tools\tools.cpp ===
// Tools.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f Toolsps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "Tools.h"

#include "Tools_i.c"
#include <initguid.h>
#include "ToolsCtl.h"
#include "AScrSite.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_Tools, CToolsCtl)
	OBJECT_ENTRY(CLSID_ToolsResponse, CToolsActiveScriptSite)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\tools\toolsctl.cpp ===
// ToolsCtl.cpp : Implementation of CToolsCtl
#include "stdafx.h"
#include "Tools.h"
#include "ToolsCtl.h"
#include <activscp.h>
#include "SimplStr.h"
#include "AScrSite.h"

#define MAX_RESSTRINGSIZE   512



/////////////////////////////////////////////////////////////////////////////
// CToolsCtl

STDMETHODIMP CToolsCtl::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_IToolsCtl,
    };
    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

STDMETHODIMP CToolsCtl::Random(long *randomRetVal)
{
    HRESULT rc = E_FAIL;
    unsigned short theRandomNumber = rand() + (rand() << 15);
    if ( randomRetVal )
    {
        *randomRetVal = *((short *) (&theRandomNumber));
        rc = S_OK;
    }
    else
    {
        rc = E_POINTER;
    }
    return rc;
}

STDMETHODIMP CToolsCtl::Owner(VARIANT_BOOL * ownerRetVal)
{
    *ownerRetVal = VARIANT_FALSE;

    /*
    // Code to get authentication info once it exists
    IRequestDictionary *theDictionary;

    m_piRequest->get_ServerVariables(&theDictionary);

    VARIANT varName;

    varName.vt = VT_BSTR;
    varName.bstrVal = L"HTTP_AUTHORIZATION";

    VARIANT returnVal;
    VariantInit(&returnVal);
    VARIANT returnBStr;
    VariantInit(&returnBStr);

    theDictionary->get_Item(varName, &returnVal);

    VariantChangeType(&returnBStr, &returnVal, 0, VT_BSTR);*/

    return S_OK;
}

STDMETHODIMP CToolsCtl::FileExists(BSTR fileURL, VARIANT_BOOL * existsRetVal)
{
// initialize context data
    HRESULT rc = E_FAIL;

    if ( existsRetVal && fileURL )
    {
        CToolsContext tc;
        if ( tc.Init() )
        {
            CComBSTR    thePath;
            HANDLE      fileHandle = INVALID_HANDLE_VALUE;
            rc = tc.m_piServer->MapPath(fileURL, &thePath);

            if (SUCCEEDED(rc)) { 
                fileHandle = ::CreateFileW(
                    thePath, // pointer to name of the file 
                    GENERIC_READ, // access (read-write) mode 
                    FILE_SHARE_READ, // share mode
                    NULL, // pointer to security attributes 
                    OPEN_EXISTING, // how to create 
                    0, // file attributes 
                    NULL // handle to file with attributes to copy 
                );
            }

            rc = S_OK;

            if(fileHandle == INVALID_HANDLE_VALUE)
            {
                *existsRetVal = VARIANT_FALSE;
            }
            else
            {
                ::CloseHandle(fileHandle);
                *existsRetVal = VARIANT_TRUE;
            }
        }
    }
    else
    {
        rc = E_POINTER;
    }

    return rc;
}

STDMETHODIMP CToolsCtl::PluginExists(BSTR pluginName, VARIANT_BOOL * existsRetVal)
{
    // TODO: Add your implementation code here

    *existsRetVal = VARIANT_FALSE;
    return S_OK;
}


HRESULT
CToolsCtl::ProcessTemplateFile(
    BSTR    templatePath,
    char*&  rpData )
{
    HRESULT rc = E_FAIL;
    HANDLE fileHandle = CreateFileW(
        templatePath, // pointer to name of the file 
        GENERIC_READ, // access (read-write) mode 
        FILE_SHARE_READ, // share mode
        NULL, // pointer to security attributes 
        OPEN_EXISTING, // how to create 
        0, // file attributes 
        NULL // handle to file with attributes to copy 
    );

    if(fileHandle != INVALID_HANDLE_VALUE)
    {
        ULONG highWord = 0;
        ULONG fileSize = ::GetFileSize(fileHandle, &highWord);

        rpData = new char[fileSize + 16];
        if ( rpData != NULL )
        {
            ULONG bytesRead;

            if (::ReadFile(fileHandle, rpData, fileSize, &bytesRead, NULL) == 0) {
                rc = HRESULT_FROM_WIN32(GetLastError());
            }
            else {
                rpData[fileSize++] = 0;
                rc = S_OK;
            }
        }
        else
        {
            rc = E_OUTOFMEMORY;
        }
        ::CloseHandle(fileHandle);
    }
    else
    {
        RaiseException( IDS_ERROR_FILENOTFOUND );
        rc = E_FAIL;
    }
    return rc;
}



STDMETHODIMP CToolsCtl::ProcessForm(BSTR outputFile, BSTR templateFile, VARIANT insertionPoint)
{
    HRESULT             hr = S_OK;
    const WCHAR         wszDelimiter[] = L"\"";
    VARIANT             varResult;
    EXCEPINFO           excepinfo;
    CSimpleUTFString    wszCode;
    CLSID               m_classinfoLanguageCLSID;
    LPWSTR              m_pwszItem = 0;

    CToolsContext tc;
    if ( tc.Init() )
    {
        CComBSTR outputPath;
        hr = tc.m_piServer->MapPath(outputFile, &outputPath);
        if ( FAILED(hr) )
        {
            return hr;
        }
        CComBSTR templatePath;
        hr = tc.m_piServer->MapPath(templateFile,&templatePath);
        if ( FAILED(hr) )
        {
            return hr;
        }

        char *templateFileData = NULL;
        hr = ProcessTemplateFile(templatePath, templateFileData);
        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = ParseCode( tc,templateFileData, wszCode );
        delete[] templateFileData;
        if ( FAILED(hr) )
        {
            return hr;
        }

        if ( tc.m_st == CToolsContext::ScriptType_JScript )
        {
            hr = CLSIDFromProgID(L"JavaScript", &m_classinfoLanguageCLSID);
        }
        else
        {
            hr = CLSIDFromProgID(L"VBScript", &m_classinfoLanguageCLSID);
        }
        if ( FAILED( hr ) )
        {
            RaiseException( IDS_ERROR_CREATESCRIPTINGENGINE );
            return E_FAIL;
        }

        VariantInit(&varResult);

        // Create the Active Scripting object
        CComPtr<IActiveScript>  theActiveScript;
        hr = CoCreateInstance(m_classinfoLanguageCLSID,
                         0,
                         CLSCTX_INPROC,
                         IID_IActiveScript,
                         (LPVOID*) &theActiveScript);
        if ( FAILED(hr) )
        {
            RaiseException( IDS_ERROR_CREATESCRIPTINGENGINE );
            return E_FAIL;
        }

        CToolsActiveScriptSite  myActiveScriptSite(tc);
        if ( !myActiveScriptSite.OpenOutputFile(outputPath) )
        {
            // exception was already raised by OpenOutputFile()
            return E_FAIL;
        }

        IActiveScriptSite* theActiveScriptSite = &myActiveScriptSite;

        hr = theActiveScript->SetScriptSite(theActiveScriptSite);
        if ( FAILED( hr ) )
        {
            return hr;
        }

        CComPtr<IActiveScriptParse> pasp;
        hr = theActiveScript->QueryInterface(IID_IActiveScriptParse, (LPVOID *) &pasp);
        if ( FAILED( hr ) ) return hr;
        
        hr = pasp->InitNew();
        if ( FAILED(hr) ) return hr;

        hr = theActiveScript->SetScriptState(SCRIPTSTATE_STARTED);
        if ( FAILED(hr) ) return hr;
        
        theActiveScript->AddNamedItem(L"response", SCRIPTITEM_ISVISIBLE | 
                SCRIPTITEM_ISSOURCE);
        theActiveScript->AddNamedItem(L"request", SCRIPTITEM_ISVISIBLE | 
                SCRIPTITEM_ISSOURCE);
        theActiveScript->AddNamedItem(L"server", SCRIPTITEM_ISVISIBLE | 
                SCRIPTITEM_ISSOURCE);
        theActiveScript->AddNamedItem(L"session", SCRIPTITEM_ISVISIBLE | 
                SCRIPTITEM_ISSOURCE);
        theActiveScript->AddNamedItem(L"application", SCRIPTITEM_ISVISIBLE | 
                SCRIPTITEM_ISSOURCE);

        memset(&excepinfo, 0, sizeof(excepinfo));

        wszCode.Cat((unsigned short) 0);
        hr = pasp->ParseScriptText(
                        wszCode.getData(), 
                        NULL, 
                        NULL, 
                        wszDelimiter,
                        0, // sourceContextCookie ???
                        0L, // startingLineNumber!
                        0,  // Flags
                        &varResult,
                        &excepinfo);
        if ( FAILED( hr ) ) return hr;

        myActiveScriptSite.CloseOutputFile();
        
        VariantClear(&varResult);

        if (theActiveScript)
        {
            theActiveScript->Close();
            theActiveScript = NULL;
        }
        
    //  theActiveScriptSite->Release();
    }
    return hr;
}


STDMETHODIMP CToolsCtl::Test(BSTR * result)
{
    HRESULT rc;
    if ( result )
    {
        CToolsContext tc;
        tc.Init();

        BSTR testPath = SysAllocString(L"/testfile");
        if ( testPath )
        {
            CComBSTR mapresult;
            rc = tc.m_piServer->MapPath(testPath,&mapresult);
            if ( !FAILED( rc ) )
            {
                *result = mapresult.Detach();
            }
        }
        else
        {
            rc = E_OUTOFMEMORY;
        }
    }
    else
    {
        rc = E_POINTER;
    }

    return rc;
}

static char g_pszDelStart[] = "<%%";
static char g_pszDelEnd[] = "%%>";

HRESULT
CToolsCtl::PrintConstant(
    CToolsContext&      tc,
    CSimpleUTFString*   theResult,
    char*               data )
{
    HRESULT rc = S_OK;

    BOOL lastCharCR = FALSE;

    rc = theResult->Cat("response.write(\"");
    if ( FAILED(rc) ) return rc;

    while(*data)
    {
        if(*data == '\r' || *data == '\n')
        {
            if(*data == '\r')
                lastCharCR = TRUE;
            else if(lastCharCR)
            {
                data++;
                continue;
            }

            rc = theResult->Cat("\\r\\n\")\r\nresponse.write(\"");
            if ( FAILED(rc) ) return rc;
            data++;
        }
        else if(*data == '\"')
        {
            if ( tc.m_st == CToolsContext::ScriptType_JScript )
            {
                rc = theResult->Cat(static_cast<unsigned short>('\\'));
                if ( FAILED(rc) ) return rc;
            }
            else
            {
                rc = theResult->Cat(static_cast<unsigned short>('\"'));
                if ( FAILED(rc) ) return rc;
            }
            rc = theResult->Cat((unsigned short) '\"');
            if ( FAILED(rc) ) return rc;
            data++;
        }
        else
        {
            rc = theResult->Cat((unsigned short) (*data));
            if ( FAILED(rc) ) return rc;
            data++;
        }
    }

    rc = theResult->Cat("\")\r\n");

    return rc;
}

HRESULT
CToolsCtl::ParseCode(
    CToolsContext&      tc,
    char                *pszTemplate,
    CSimpleUTFString&   theResult )
{
    HRESULT rc = E_FAIL;
    if ( pszTemplate )
    {
        int iPos = 0;
        BOOL fPrintCode;
        LPTSTR pszScan = pszTemplate;
        LPTSTR pszScanAhead = pszScan;
        while (pszScanAhead = strstr(pszScan, g_pszDelStart))
        {
            // text before code block goes in a print statement
            *pszScanAhead = 0;
            rc = PrintConstant(tc, &theResult, pszScan );
            if ( FAILED( rc ) ) return rc;

            // Skip over the delimiter
            pszScan = pszScanAhead + strlen(g_pszDelStart);
            
            // text in code block goes in a print statement
            // or just as block code depending on = statement
            while (*pszScan == ' ' || *pszScan == '\r' || *pszScan == '\n')
            {
                pszScan ++;
            }
            if (*pszScan == '=')
            {
                pszScan += 1;
                fPrintCode = TRUE;
            }
            else
                fPrintCode = FALSE;
            
            // output the code
            if (pszScanAhead = strstr(pszScan, g_pszDelEnd))
            {
                *pszScanAhead = 0;
                if (fPrintCode)
                {
                    rc = theResult.Cat("response.writeSafe(");
                    if ( FAILED( rc ) ) return rc;
                }
                rc = theResult.Cat(pszScan);
                if ( FAILED( rc ) ) return rc;

                if(fPrintCode)
                    rc = theResult.Cat(")\r\n");
                else
                    rc = theResult.Cat("\r\n");
                if ( FAILED( rc ) ) return rc;

                pszScan = pszScanAhead + strlen(g_pszDelEnd);
            }
        }
        
        rc = PrintConstant( tc, &theResult, pszScan );
    }

    return rc;
}


//---------------------------------------------------------------------------
//  RaiseException
//
//  Raises an exception using the given source and description
//---------------------------------------------------------------------------
void
CToolsCtl::RaiseException (
    LPOLESTR strDescr
)
{
    HRESULT hr;
    ICreateErrorInfo *pICreateErr;
    IErrorInfo *pIErr;
    LANGID langID = LANG_NEUTRAL;

    /*
     * Thread-safe exception handling means that we call
     * CreateErrorInfo which gives us an ICreateErrorInfo pointer
     * that we then use to set the error information (basically
     * to set the fields of an EXCEPINFO structure. We then
     * call SetErrorInfo to attach this error to the current
     * thread.  ITypeInfo::Invoke will look for this when it
     * returns from whatever function was invokes by calling
     * GetErrorInfo.
     */

    WCHAR strSource[MAX_RESSTRINGSIZE];
    if ( ::LoadStringW(
        _Module.GetResourceInstance(),
        IDS_ERROR_SOURCE,
        strSource,
        MAX_RESSTRINGSIZE ) > 0 )
    {
        //Not much we can do if this fails.
        if (!FAILED(CreateErrorInfo(&pICreateErr)))
        {
            pICreateErr->SetGUID(CLSID_Tools);
            pICreateErr->SetHelpFile(L"");
            pICreateErr->SetHelpContext(0L);
            pICreateErr->SetSource(strSource);
            pICreateErr->SetDescription(strDescr);

            hr = pICreateErr->QueryInterface(IID_IErrorInfo, (void**)&pIErr);

            if (SUCCEEDED(hr))
            {
                if(SUCCEEDED(SetErrorInfo(0L, pIErr)))
                {
                    pIErr->Release();
                }
            }
        }
        pICreateErr->Release();
    }
}

void 
CToolsCtl::RaiseException (
    UINT DescrID
)
{
    WCHAR strDescr[MAX_RESSTRINGSIZE];

    if ( ::LoadStringW(
        _Module.GetResourceInstance(),
        DescrID,
        strDescr,
        MAX_RESSTRINGSIZE) > 0 )
    {
        RaiseException( strDescr );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\tools\toolsctl.h ===
// ToolsCtl.h : Declaration of the CToolsCtl

#ifndef __TOOLSCTL_H_
#define __TOOLSCTL_H_

#include "resource.h"       // main symbols
#include <asptlb.h>         // Active Server Pages Definitions
#include "SimplStr.h"
#include "tools.h"
#include "toolscxt.h"

#if 0
struct processResult
{
    WCHAR *resultBuffer;
    ULONG resultSize;
};
#endif

/////////////////////////////////////////////////////////////////////////////
// CToolsCtl
class /*ATL_NO_VTABLE*/ CToolsCtl : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CToolsCtl, &CLSID_Tools>,
    public IDispatchImpl<IToolsCtl, &IID_IToolsCtl, &LIBID_Tools>,
    public ISupportErrorInfo
{
public:
    CToolsCtl()
    { 
        m_pUnkMarshaler = NULL;
    }

public:

DECLARE_REGISTRY_RESOURCEID(IDR_TOOLSCTL)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CToolsCtl)
    COM_INTERFACE_ENTRY(IToolsCtl)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

    HRESULT FinalConstruct()
    {
        return CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(),
            &m_pUnkMarshaler.p);
    }

    void FinalRelease()
    {
        m_pUnkMarshaler.Release();
    }

    CComPtr<IUnknown>  m_pUnkMarshaler;

public:
// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IToolsCtl
    STDMETHOD(ProcessForm)(/*[in]*/ BSTR outputFile, /*[in]*/ BSTR templateFile, /*[in, optional]*/ VARIANT insertionPoint);
    STDMETHOD(PluginExists)(/*[in]*/ BSTR pluginName, /*[out, retval]*/ VARIANT_BOOL *existsRetVal);
    STDMETHOD(FileExists)(/*[in]*/ BSTR fileURL, /*[out, retval]*/ VARIANT_BOOL *existsRetVal);
    STDMETHOD(Owner)(/*[out, retval]*/ VARIANT_BOOL *ownerRetVal);
    STDMETHOD(Random)(long *randomRetVal);
    STDMETHOD(Test)(BSTR *result);

    static HRESULT ParseCode( CToolsContext&, char *pszTemplate, CSimpleUTFString& rCode );
    static void RaiseException( LPOLESTR );
    static void RaiseException( UINT );
private:
    static HRESULT  PrintConstant( CToolsContext&, CSimpleUTFString *theResult, char *data );
    static HRESULT  ProcessTemplateFile(BSTR templatePath, char*& rpData);
};

#endif //__TOOLSCTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\tools\toolscxt.cpp ===
// ToolsCxt.cpp

#include "stdafx.h"
#include "ToolsCtl.h"
#include "toolscxt.h"

/////////////////////////////////////////////////////////////////////////////
// Helper functions

HRESULT	GetServerObject( IGetContextProperties*, BSTR, const IID&, void** );

//---------------------------------------------------------------------------
//	GetServerObject
//
//	Get an instrinic object from the current Object context
//---------------------------------------------------------------------------
HRESULT
GetServerObject(
	IGetContextProperties*	pProps,
	BSTR					bstrObjName,
	const IID&				iid,
	void**					ppObj
)
{
	HRESULT rc = E_FAIL;
	_ASSERT( pProps );
	_ASSERT( bstrObjName );
	_ASSERT( ppObj );
	if ( pProps && bstrObjName && ppObj )
	{
		*ppObj = NULL;
		CComVariant vt;
        if ( !FAILED( pProps->GetProperty( bstrObjName, &vt ) ) )
        {
            if ( V_VT(&vt) == VT_DISPATCH )
            {
                IDispatch* pDispatch = V_DISPATCH(&vt);
                if ( pDispatch )
                {
                    pDispatch->QueryInterface( iid, ppObj );
					rc = S_OK;
                }
            }
        }
	}
	return rc;
}

/////////////////////////////////////////////////////////////////////////////
// CToolsContext
//

// retrieve all instrinsic server objects
bool
CToolsContext::Init()
{
	bool rc = false;

    CComPtr<IObjectContext> pObjContext;

    if ( !FAILED( ::GetObjectContext( &pObjContext ) ) )
    {
        CComPtr<IGetContextProperties> pProps;
        if ( !FAILED( pObjContext->QueryInterface( IID_IGetContextProperties, (void**)&pProps ) ) )
        {
            CComBSTR bstrObj = "Request";
			::GetServerObject( pProps, bstrObj, IID_IRequest, (void**)&m_piRequest );
			bstrObj = "Response";
			::GetServerObject( pProps, bstrObj, IID_IResponse, (void**)&m_piResponse );
			bstrObj = "Session";
			::GetServerObject( pProps, bstrObj, IID_ISessionObject, (void**)&m_piSession );
			bstrObj = "Server";
			::GetServerObject( pProps, bstrObj, IID_IServer, (void**)&m_piServer );
			bstrObj = "Application";
			::GetServerObject( pProps, bstrObj, IID_IApplicationObject, (void**)&m_piApplication );
			if ( m_piRequest && m_piResponse && m_piSession && m_piServer && m_piApplication )
			{
				rc = true;
			}
			else
			{
				// object probably not created with Server.CreateObject
				CToolsCtl::RaiseException( IDS_ERROR_CREATE );
			}
		}
	}
	// need get current scripting language
	m_st = ScriptType_VBScript;
	return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\mco\tools\toolscxt.h ===
// ToolsCxt.h
#pragma once

#ifndef _TOOLSCXT_H_
#define _TOOLSCXT_H_

// a struct to contain the current execution context
struct CToolsContext
{
	typedef enum {
		ScriptType_JScript,
		ScriptType_VBScript
	} ScriptType;

	bool	Init();

	CComPtr<IRequest>			m_piRequest;			//Request Object
	CComPtr<IResponse>			m_piResponse;			//Response Object
	CComPtr<ISessionObject>		m_piSession;			//Session Object
	CComPtr<IServer>			m_piServer;				//Server Object
	CComPtr<IApplicationObject> m_piApplication;		//Application Object
	ScriptType					m_st;
};


#endif	// !__TOOLSCXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\perfmon\axctrnm.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Main

File: axctrnm.h

Owner: LeiJin


  Abstract:

  Offset definition file for counter objects and counters.

  These relative offsets must start at 0 and be multiples of 2. (i.e.)
  even numbers). In the Open Procedure, they will be added to the "First 
  Counter" and "First Help" values for the device they belong to, in order
  to determine the absolute location of the counter and object names and 
  corresponding Explain text in the registry.

  This file is used by the extensible counter DLL code as well as the 
  counter name and Explain text definition (.INI) file that is used
  by LODCTR to load the names into the registry.
===================================================================*/

#define AXSOBJ 			 0
#define DEBUGDOCREQ      2
#define REQERRRUNTIME    4
#define REQERRPREPROC    6
#define REQERRCOMPILE    8
#define REQERRORPERSEC   10
#define REQTOTALBYTEIN   12
#define REQTOTALBYTEOUT  14
#define REQEXECTIME      16
#define REQWAITTIME      18
#define REQCOMFAILED     20
#define REQBROWSEREXEC   22
#define REQFAILED        24
#define REQNOTAUTH       26
#define REQNOTFOUND      28
#define REQCURRENT       30
#define REQREJECTED      32
#define REQSUCCEEDED     34
#define REQTIMEOUT       36
#define REQTOTAL         38
#define REQPERSEC        40
#define SCRIPTFREEENG    42
#define SESSIONLIFETIME  44
#define SESSIONCURRENT   46
#define SESSIONTIMEOUT   48
#define SESSIONSTOTAL    50
#define TEMPLCACHE       52
#define TEMPLCACHEHITS   54
#define TEMPLCACHETRYS   56
#define TEMPLFLUSHES     58
#define TRANSABORTED     60
#define TRANSCOMMIT      62
#define TRANSPENDING     64
#define TRANSTOTAL       66
#define TRANSPERSEC      68
#define MEMORYTEMPLCACHE   70
#define MEMORYTEMPLCACHEHITS 72
#define MEMORYTEMPLCACHETRYS 74
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\misc\bsrchtst.cxx ===
#include "denpre.h"
#include "util.h"

template <class T>
class less
	{
public:
	BOOL operator()(const T &a, const T &b)
		{
		return a < b;
		}
	};


int vec[10] = { 33, 251, 253, 254, 263, 272, 274, 302, 305, 307 };

void PrintPair(int value, int *pLB, int *pUB)
	{
	if (pLB == NULL && pUB == NULL)
		printf("Array is Empty or Bug in bsearch!\n");

	else if (pLB == NULL)
		printf("%d < %d\n", value, *pUB);

	else if (pUB == NULL)
		printf("%d > %d\n", value, *pLB);

	else
		printf("%d <= %d <= %d\n", *pLB, value, *pUB);
	}

void main()
	{
	int *pLB, *pUB;

	bsearch(&vec[0], &vec[10], 253, less<int>(), &pLB, &pUB);
	PrintPair(253, pLB, pUB);

	bsearch(&vec[0], &vec[10], 267, less<int>(), &pLB, &pUB);
	PrintPair(267, pLB, pUB);

	bsearch(&vec[0], &vec[10], 399, less<int>(), &pLB, &pUB);
	PrintPair(399, pLB, pUB);

	bsearch(&vec[0], &vec[10], 2, less<int>(), &pLB, &pUB);
	PrintPair(2, pLB, pUB);

	bsearch(&vec[0], &vec[0], 39, less<int>(), &pLB, &pUB);
	PrintPair(39, pLB, pUB);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\perfmon\axperf.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Main

File: axperf.cpp

Owner: LeiJin

Abstract:

    This file implements the Extensible Objects for the ActiveX Server
    object type
===================================================================*/

//--------------------------------------------------------------------
//  Include Files
//
//--------------------------------------------------------------------


#include "denpre.h"
#pragma hdrstop

#include "windows.h"
#include "winperf.h"

#include "axpfdata.h"

#include <perfdef.h>            // from denali
#include <perfutil.h>

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)

extern AXPD g_AxDataDefinition;

DWORD   g_dwOpenCount = 0;
BOOL    bInitOK = FALSE;        // true = DLL Initialized OK

// WinSE 5901
CRITICAL_SECTION g_CS;

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

WCHAR NULL_STRING[] = L"\0";    // pointer to null string


/*
 * Output Debug String should occur in Debug only
 */
#ifdef _DEBUG
BOOL gfOutputDebugString = TRUE;
#else
BOOL gfOutputDebugString = FALSE;
#endif
#define DebugOutputDebugString(x) \
    {\
    if (gfOutputDebugString) \
        { \
        OutputDebugString(x); \
        } \
    }

//-------------------------------------------------------------------
//  Function Prototypes
//
//  these are used to insure that the data collection functions accessed
//  by Perf lib will have the correct calling format
//-------------------------------------------------------------------

DWORD APIENTRY      OpenASPPerformanceData(LPWSTR lpDeviceNames);
DWORD APIENTRY      CollectASPPerformanceData(LPWSTR lpValueName,
                                              LPVOID *lppData,
                                              LPDWORD lpcbTotalBytes,
                                              LPDWORD lpNumObjectTypes
                                              );
DWORD APIENTRY      CloseASPPerformanceData(void);
DWORD APIENTRY      RegisterAXS(void);
DWORD APIENTRY      UnRegisterAXS(void);

DWORD   GetQueryType (IN LPWSTR lpValue);
BOOL    IsNumberInUnicodeList ( IN DWORD   dwNumber,
                                IN LPWSTR  lpwszUnicodeList);

CPerfMainBlock g_Shared;        // shared global memory block

//--------------------------------------------------------------------
//
//  OpenASPPerformanceData
//
//  This routine will open and map the memory used by the ActiveX Server
//  to pass performance data in.  This routine also initializes the data
//  structure used to pass data back to the registry.
//
//  Arguments:
//
//      Pointer to object ID to be opened.
//
//  Return Value:
//
//      None.
//--------------------------------------------------------------------
//extern "C" DWORD APIENTRY OpenASPPerformanceData(LPWSTR   lpDeviceNames)
DWORD APIENTRY OpenASPPerformanceData(LPWSTR    lpDeviceNames)
{
    int status;
    DWORD RetCode = ERROR_SUCCESS;
    PERF_COUNTER_DEFINITION *pCounterDef;
    DWORD   size = sizeof(DWORD);

    DebugOutputDebugString("Open");

    // WinSE  5901    
    EnterCriticalSection(&g_CS);
    
    LONG nOpenCount = InterlockedIncrement((LONG *)&g_dwOpenCount);
    if (nOpenCount > 1){
        goto ExitPathSuccess;
    };

    // Hold the counter to 1, even if we are no sure to have this 
    // initialized correctly
    
    // open shared memory to pass performance values
    if (FAILED(g_Shared.Init())) {
        RetCode = ERROR_INVALID_HANDLE;
        goto ExitPath;
    }

    // get counter and help index base values from registry
    //  Open key to registry entry
    //  read first counter and first help values
    //  update static data structures by adding base to offset
    //  value in structure

    HKEY    hKeyServerPerf;

    status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
        "SYSTEM\\CurrentControlSet\\Services\\ASP\\Performance",
        0L,
        KEY_READ,
        &hKeyServerPerf);

    if (ERROR_SUCCESS != status) {
        RetCode = status;
        goto ExitPath;
    }
    
    DWORD   type;
    DWORD   dwFirstCounter;
    DWORD   dwFirstHelp;

    status = RegQueryValueEx(hKeyServerPerf,
        "First Counter",
        0L,
        &type,
        (LPBYTE)&dwFirstCounter,
        &size);

    if (ERROR_SUCCESS != status || size != sizeof(DWORD)) {

        RegCloseKey(hKeyServerPerf);
        RetCode = status;
        goto ExitPath;        
    }

    status = RegQueryValueEx(hKeyServerPerf,
        "First Help",
        0L,
        &type,
        (LPBYTE)&dwFirstHelp,
        &size);

    if (ERROR_SUCCESS != status || size != sizeof(DWORD)) {

        RegCloseKey(hKeyServerPerf);
        RetCode = status;
        goto ExitPath;
    }

    //
    //  NOTE:   the initialiation could also retrieve
    //          LastCounter and LastHelp if they wanted
    //          to do bounds checking on the new number
    //

    g_AxDataDefinition.AXSObjectType.ObjectNameTitleIndex += dwFirstCounter;
    g_AxDataDefinition.AXSObjectType.ObjectHelpTitleIndex += dwFirstHelp;

    pCounterDef = (PERF_COUNTER_DEFINITION *)&(g_AxDataDefinition.Counters[0]);

    int i;
    for (i = 0; i < AX_NUM_PERFCOUNT; i++, pCounterDef++) {
        pCounterDef->CounterNameTitleIndex += dwFirstCounter;
        pCounterDef->CounterHelpTitleIndex += dwFirstHelp;
    }

    RegCloseKey(hKeyServerPerf); // close key to registry

    bInitOK = TRUE; // ok to use this function
    // we have already incremented g_dwOpenCount
    // before going through this path
ExitPathSuccess:
    LeaveCriticalSection(&g_CS);
    return ERROR_SUCCESS;

ExitPath:
    InterlockedDecrement((LONG *)&g_dwOpenCount);
    LeaveCriticalSection(&g_CS);
    return RetCode;
}

//--------------------------------------------------------------------
//  DWORD   CollectASPPerformanceData
//
//  Description:
//
//      This routine will return the data for the AxctiveX Server counters.
//
//  Arguments:
//
//      IN  LPWSTR  lpValueName
//          pointer to a wide chacter string passed by registry
//
//      IN  OUT LPVOID  *lppData
//          IN: pointer to the address of the buffer to receive the completed
//              PerfDataBlock and subordinate structures.  This routine will
//              append its data to the buffer starting at the point referenced
//              by the *lppData
//          OUT:points to the first byte after the data structure added by
//              this routine.  This routine updated the value at lppdata after
//              appending its data.
//
//      IN OUT  LPDWORD lpcbTotalBytes
//          IN: the address of the DWORD that tells the size in bytes of the
//              buffer referenced by the lppData argument
//          OUT:the number of bytes added by this routine is written to the
//              DWORD pointed to by this argument
//
//      IN OUT  LPDWORD NumObjectTypes
//          IN: the address of the DWORD that receives the number of the objects
//              added by this routine
//          OUT:the number of objects added by this routine is written to
//              the DWORD pointed to by this argument
//
//
//  Return Value:
//
//      ERROR_MORE_DATA if buffer passed is too small to hold data
//
//      ERROR_SUCCESS   if success or any other error.
//
//--------------------------------------------------------------------
DWORD APIENTRY CollectASPPerformanceData(IN     LPWSTR  lpValueName,
                                IN OUT  LPVOID  *lppData,
                                IN OUT  LPDWORD lpcbTotalBytes,
                                IN OUT  LPDWORD lpNumObjectTypes)
{

    // before doing anything else, see if Open went Ok.
    DebugOutputDebugString("collect");
    if(!bInitOK) {
        //unable to continue because open failed
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }

    //
    //  variables used for error logging

    DWORD   dwQueryType;

    // see if this is a foreign(i.e. non-NT) computer data request

    dwQueryType = GetQueryType(lpValueName);

    if (QUERY_FOREIGN == dwQueryType) {
        // this routine does not service requests for data from
        // Non-NT computers
        *lpcbTotalBytes = (DWORD)0;
        *lpNumObjectTypes = (DWORD)0;

        return ERROR_SUCCESS;
    }

    if (QUERY_ITEMS == dwQueryType) {
        if (!(IsNumberInUnicodeList(g_AxDataDefinition.AXSObjectType.ObjectNameTitleIndex,
            lpValueName))) {

            // request received for data object not provided by this routine
            *lpcbTotalBytes = (DWORD)0;
            *lpNumObjectTypes = (DWORD)0;

            return ERROR_SUCCESS;

        }
    }

    if (QUERY_GLOBAL == dwQueryType) {
        /* Comment the following code out, looks like that it is for
            debugging only.

        int i;
        i++;
        */
    }

     AXPD *pAxDataDefinition = (AXPD *)*lppData;

    ULONG SpaceNeeded = QWORD_MULTIPLE((sizeof(AXPD) + SIZE_OF_AX_PERF_DATA));

    if ( *lpcbTotalBytes < SpaceNeeded) {
        *lpcbTotalBytes = (DWORD)0;
        *lpNumObjectTypes = (DWORD)0;

        return ERROR_MORE_DATA;
    }

    //
    //Copy the (constant, initialized) Object Type and counter defintions to the caller's
    //data buffer
    //

    memmove(pAxDataDefinition, &g_AxDataDefinition, sizeof(AXPD));

    //
    //  Format and collect Active X server performance data from shared memory
    //

    PERF_COUNTER_BLOCK *pPerfCounterBlock = (PERF_COUNTER_BLOCK *)&pAxDataDefinition[1];


    pPerfCounterBlock->ByteLength = SIZE_OF_AX_PERF_DATA;

    PDWORD pdwCounter = (PDWORD)(&pPerfCounterBlock[1]);

    // Get statistics from shared memory

    if (FAILED(g_Shared.GetStats(pdwCounter))) {
        *lpcbTotalBytes = (DWORD)0;
        *lpNumObjectTypes = (DWORD)0;

        return ERROR_SUCCESS;
    }

    pdwCounter += AX_NUM_PERFCOUNT;


    // update arguments for return

    *lpNumObjectTypes = 1;
    *lpcbTotalBytes = QWORD_MULTIPLE((DIFF((PBYTE)pdwCounter - (PBYTE)pAxDataDefinition)));
    *lppData = (PBYTE)(*lppData) + *lpcbTotalBytes;

    return ERROR_SUCCESS;
}


//-------------------------------------------------------------------
//  DWORD   CloseASPPerformanceData
//
//  Description:
//
//      This routine closes the open handles to ActiveX Server performance
//      counters.
//
//  Arguments:
//
//      None.
//
//  Return Value:
//
//      ERROR_SUCCESS
//
//--------------------------------------------------------------------
DWORD APIENTRY CloseASPPerformanceData(void)
{
    DebugOutputDebugString("Close");

    EnterCriticalSection(&g_CS);

    LONG nLeft = InterlockedDecrement((LONG *)&g_dwOpenCount);
    
    if (nLeft == 0) {
        g_Shared.UnInit();
        bInitOK = FALSE;
    };
    LeaveCriticalSection(&g_CS);

    return ERROR_SUCCESS;
}

static const TCHAR  szPerformance[]     = TEXT("SYSTEM\\CurrentControlSet\\Services\\ASP\\Performance");
static const TCHAR  szAXS[]     = TEXT("SYSTEM\\CurrentControlSet\\Services\\ASP");

static const TCHAR  szLibrary[]     = TEXT("Library");
static const TCHAR  szOpen[]        = TEXT("Open");
static const TCHAR  szClose[]       = TEXT("Close");
static const TCHAR  szCollect[]     = TEXT("Collect");

static const TCHAR  szLibraryValue[]    = TEXT("aspperf.dll");
static const TCHAR  szOpenValue[]       = TEXT("OpenASPPerformanceData");
static const TCHAR  szCloseValue[]      = TEXT("CloseASPPerformanceData");
static const TCHAR  szCollectValue[]    = TEXT("CollectASPPerformanceData");
//--------------------------------------------------------------------
//
//
//--------------------------------------------------------------------
DWORD APIENTRY      RegisterAXS(void)
{
    HKEY    hkey;

    if ((RegCreateKey(HKEY_LOCAL_MACHINE, szPerformance, &hkey)) != ERROR_SUCCESS)
        return E_FAIL;
    if ((RegSetValueEx(hkey, szLibrary, 0, REG_SZ, (const unsigned char *)&szLibraryValue, lstrlen(szLibraryValue))) != ERROR_SUCCESS)
        goto LRegErr;
    if ((RegSetValueEx(hkey, szOpen, 0, REG_SZ, (const unsigned char *)&szOpenValue, lstrlen(szOpenValue))) != ERROR_SUCCESS)
        goto LRegErr;
    if ((RegSetValueEx(hkey, szClose, 0, REG_SZ, (const unsigned char *)&szCloseValue, lstrlen(szCloseValue))) != ERROR_SUCCESS)
        goto LRegErr;
    if ((RegSetValueEx(hkey, szCollect, 0, REG_SZ, (const unsigned char *)&szCollectValue, lstrlen(szCollectValue))) != ERROR_SUCCESS)
        goto LRegErr;

    RegCloseKey(hkey);
    return NOERROR;

LRegErr:
    RegCloseKey(hkey);
    return E_FAIL;

}
//--------------------------------------------------------------------
//
//
//--------------------------------------------------------------------
DWORD APIENTRY      UnRegisterAXS(void)
{
    if ((RegDeleteKey(HKEY_LOCAL_MACHINE, szPerformance)) != ERROR_SUCCESS)
        return (E_FAIL);
    if ((RegDeleteKey(HKEY_LOCAL_MACHINE, szAXS)) != ERROR_SUCCESS)
        return (E_FAIL);
    else
        return NOERROR;
}

DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL        bNewItem;
    //BOOL    bReturnValue;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList

STDAPI DLLRegisterServer(void)
{
    return RegisterAXS();
}

BOOL WINAPI DllMain(HINSTANCE hInstDLL,  // handle to the DLL module
                    DWORD  dwReason,     // reason for calling function
                    LPVOID lpvReserved   // reserved
                    )
{
    switch(dwReason){
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls(hInstDLL);
            InitializeCriticalSection(&g_CS);
            return TRUE;
        case DLL_PROCESS_DETACH:
            DeleteCriticalSection(&g_CS);
            return TRUE;   
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\perfmon\denpre.h ===
#pragma warning(disable:4237)
#undef _WIN32_WINNT
#define _WIN32_WINNT    0x0400
#define _CRYPT32_

#include <ctype.h>
#include <stdlib.h>     // for itow
#include <crtdbg.h>
#include <malloc.h>
#include <time.h>
#include <stdio.h>
#include <limits.h>
#include <windows.h>
#include <winerror.h>
#include <wtypes.h>
#include <process.h>

#include <rpc.h>
#include <rpcndr.h>
#include <ole2.h>
#include <olectl.h>
#include <oleauto.h>
#include <cguid.h>      // for GUID_NULL

#include <iis64.h>

#include "except.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\perfmon\axpfdata.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Main

File: axpfdata.h

Owner: LeiJin

 Abstract:

	header file for the Denali Extensible Object data definitions.
===================================================================*/

#ifndef _AXPFDATA_H_
#define _AXPFDATA_H_

// AX is shortcut for ActiveX

#define AX_NUM_PERF_OBJECT_TYPES		1
#define AX_NUM_PERFCOUNT				37

#pragma pack (4)

struct AXPD
    {
	PERF_OBJECT_TYPE			AXSObjectType;
	PERF_COUNTER_DEFINITION		Counters[AX_NUM_PERFCOUNT];
    };

#pragma pack ()

// Counter offset in the Perf Counter Block
// Note: those offsets are not the offsets in the counter defintion data structure.
//		 that is, not the offsets in the AXPD.

#define AX_DEBUGDOCREQ_OFFSET      sizeof(DWORD)
#define AX_REQERRRUNTIME_OFFSET    2*sizeof(DWORD)
#define AX_REQERRPREPROC_OFFSET    3*sizeof(DWORD)
#define AX_REQERRCOMPILE_OFFSET    4*sizeof(DWORD)
#define AX_REQERRORPERSEC_OFFSET   5*sizeof(DWORD)
#define AX_REQTOTALBYTEIN_OFFSET   6*sizeof(DWORD)
#define AX_REQTOTALBYTEOUT_OFFSET  7*sizeof(DWORD)
#define AX_REQEXECTIME_OFFSET      8*sizeof(DWORD)
#define AX_REQWAITTIME_OFFSET      9*sizeof(DWORD)
#define AX_REQCOMFAILED_OFFSET     10*sizeof(DWORD)
#define AX_REQBROWSEREXEC_OFFSET   11*sizeof(DWORD)
#define AX_REQFAILED_OFFSET        12*sizeof(DWORD)
#define AX_REQNOTAUTH_OFFSET       13*sizeof(DWORD)
#define AX_REQNOTFOUND_OFFSET      14*sizeof(DWORD)
#define AX_REQCURRENT_OFFSET       15*sizeof(DWORD)
#define AX_REQREJECTED_OFFSET      16*sizeof(DWORD)
#define AX_REQSUCCEEDED_OFFSET     17*sizeof(DWORD)
#define AX_REQTIMEOUT_OFFSET       18*sizeof(DWORD)
#define AX_REQTOTAL_OFFSET         19*sizeof(DWORD)
#define AX_REQPERSEC_OFFSET        20*sizeof(DWORD)
#define AX_SCRIPTFREEENG_OFFSET    21*sizeof(DWORD)
#define AX_SESSIONLIFETIME_OFFSET  22*sizeof(DWORD)
#define AX_SESSIONCURRENT_OFFSET   23*sizeof(DWORD)
#define AX_SESSIONTIMEOUT_OFFSET   24*sizeof(DWORD)
#define AX_SESSIONSTOTAL_OFFSET    25*sizeof(DWORD)
#define AX_TEMPLCACHE_OFFSET       26*sizeof(DWORD)
#define AX_TEMPLCACHEHITS_OFFSET   27*sizeof(DWORD)
#define AX_TEMPLCACHETRYS_OFFSET   28*sizeof(DWORD)
#define AX_TEMPLFLUSHES_OFFSET     29*sizeof(DWORD)
#define AX_TRANSABORTED_OFFSET     30*sizeof(DWORD)
#define AX_TRANSCOMMIT_OFFSET      31*sizeof(DWORD)
#define AX_TRANSPENDING_OFFSET     32*sizeof(DWORD)
#define AX_TRANSTOTAL_OFFSET       33*sizeof(DWORD)
#define AX_TRANSPERSEC_OFFSET      34*sizeof(DWORD)
#define AX_MEMORYTEMPLCACHE_OFFSET   35*sizeof(DWORD)
#define AX_MEMORYTEMPLCACHEHITS_OFFSET 36*sizeof(DWORD)
#define AX_MEMORYTEMPLCACHETRYS_OFFSET   37*sizeof(DWORD)

#define	AX_PERF_LASTOFFSET				AX_MEMORYTEMPLCACHETRYS_OFFSET
#define SIZE_OF_AX_PERF_DATA			AX_PERF_LASTOFFSET + sizeof(DWORD)

#endif // _AXPFDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\misc\vectest.cxx ===
// vi: set ts=4

#include <assert.h>
#define Assert(e) assert(e)

#include <string.h>
#include <stdlib.h>
//#include <iostream.h>
#include <stdio.h>
#include "vector.h"

#define ELEMENTS(s)  (sizeof(s) / sizeof(s[0]))

void CreateString(char *str, vector<char> &s)
{
	register char *ptr;
	for (ptr = str; *ptr != '\0'; ptr++)
		s.append(*ptr);
}



void StringCons(char *str, vector<char> &s)
{
	register char *ptr;
	for (ptr = strchr(str, '\0') - 1; ptr >= str; --ptr)
		s.prepend(*ptr);
}



void StringPrint(vector<char> &s, FILE *o)
{
	for (register int i = 0; i < s.length(); ++i)
		fputc(s[i], o);
}



void RemoveChar(char ch, vector<char> &s)
{
	int i = 0;
	while (i < s.length())
		if (s[i] == ch)
			s.removeAt(i);
		else
			++i;
}



void InsertBefore(char newchar, char findchar, vector<char> &s)
{
	for (register int i = 0; i < s.length(); ++i)
		if (s[i] == findchar)
			s.insertAt(i++, newchar);
}


vector<char> reverse(vector<char> &s)
{
	if (s.length() <= 1)
		return s;
	else
		return reverse(s(1, s.length())) + s[0];
}



void RadixSort(vector<char> &s)
{
	vector<char> queue[256];

	for (register const char *ptr = s.vec() + (s.length() - 1);
		 ptr >= s.vec();
		 --ptr)
		queue[*ptr].append(*ptr);

	s.reshape(0);
	for (register int i = 0; i < ELEMENTS(queue); ++i)
		s += queue[i];
}


void main()
{
	int i;
	char merge_q[2] = {'!', '?'};
	vector<char> string_q;

	CreateString("for thought", string_q);
	StringCons("Food ", string_q);

	fputs("List contents = ", stdout);
	StringPrint(string_q, stdout);
	fputc('\n', stdout);

	string_q = reverse(string_q);

	fputs("List reverse  = ", stdout);
	StringPrint(string_q, stdout);
	fputc('\n', stdout);

	string_q += vector<char>(merge_q, ELEMENTS(merge_q));

	fputs("List merge    = ", stdout);
	StringPrint(string_q, stdout);
	fputc('\n', stdout);

	RemoveChar('o', string_q);

	fputs("Remove 'o'    = ", stdout);
	StringPrint(string_q, stdout);
	fputc('\n', stdout);

	InsertBefore('%', 'u', string_q);
	InsertBefore('&', 't', string_q);

	fputs("u->%u, t->&t  = ", stdout);
	StringPrint(string_q, stdout);
	fputc('\n', stdout);

	RadixSort(string_q);

	fputs("Sorted List   = ", stdout);
	StringPrint(string_q, stdout);
	fputc('\n', stdout);

	string_q.insertAt(3, '@');
	string_q.insertAt(0, '@');
	string_q.insertAt(string_q.length(), '@');

	fputs("@ after '!'   = ", stdout);
	StringPrint(string_q, stdout);
	fputc('\n', stdout);

	while ((i = string_q.find('@')) >= 0)
		string_q[i] = '*';

	fputs("@ -> '*'      = ", stdout);
	StringPrint(string_q, stdout);
	fputc('\n', stdout);

	assert (string_q.find('Z') == -1);
	assert (string_q.find('u') == 18);

//	cout << "Remove '*'    = " << string_q << endl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\perfmon\axpfdata.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Main

File: axpfdata.cpp

Owner: LeiJin

Abstract:

	Define the data structures used by the Performance Monitor data for the Denali Objects.
	Also include shared memory functions used by both perfmon dll and denali dll.
===================================================================*/


//-------------------------------------------------------------------------------------
//	Include Files
//
//-------------------------------------------------------------------------------------
#include "denpre.h"
#pragma hdrstop
#include "windows.h"
#include "winperf.h"

#include "axctrnm.h"
#include "axpfdata.h"
#include <perfutil.h>

//-------------------------------------------------------------------------------------
//	Constant structure initializations
//	defined in ActiveXPerfData.h
//-------------------------------------------------------------------------------------

AXPD g_AxDataDefinition = {
	{
		QWORD_MULTIPLE(sizeof(AXPD) + SIZE_OF_AX_PERF_DATA),
		sizeof(AXPD),
		sizeof(PERF_OBJECT_TYPE),
		AXSOBJ,
		0,
		AXSOBJ,
		0,
		PERF_DETAIL_NOVICE,
		(sizeof(AXPD) - sizeof(PERF_OBJECT_TYPE))/
			sizeof(PERF_COUNTER_DEFINITION),
		0,
		-1,
		0,
		1,	// NOTE: PerfTime ?
		1,	// NOTE: PerfFreq ?
	},
    { // Counters[]

        // DEBUGDOCREQ
        {
            sizeof(PERF_COUNTER_DEFINITION),
            DEBUGDOCREQ,
            0,
            DEBUGDOCREQ,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_DEBUGDOCREQ_OFFSET
        },

        // REQERRRUNTIME
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQERRRUNTIME,
            0,
            REQERRRUNTIME,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQERRRUNTIME_OFFSET
        },

        // REQERRPREPROC
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQERRPREPROC,
            0,
            REQERRPREPROC,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQERRPREPROC_OFFSET
        },

        // REQERRCOMPILE
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQERRCOMPILE,
            0,
            REQERRCOMPILE,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQERRCOMPILE_OFFSET
        },

        // REQERRORPERSEC
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQERRORPERSEC,
            0,
            REQERRORPERSEC,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_COUNTER,
            sizeof(DWORD),
            AX_REQERRORPERSEC_OFFSET
        },

        // REQTOTALBYTEIN
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQTOTALBYTEIN,
            0,
            REQTOTALBYTEIN,
            0,
            -4,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQTOTALBYTEIN_OFFSET
        },

        // REQTOTALBYTEOUT
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQTOTALBYTEOUT,
            0,
            REQTOTALBYTEOUT,
            0,
            -4,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQTOTALBYTEOUT_OFFSET
        },

        // REQEXECTIME
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQEXECTIME,
            0,
            REQEXECTIME,
            0,
            -3,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQEXECTIME_OFFSET
        },

        // REQWAITTIME
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQWAITTIME,
            0,
            REQWAITTIME,
            0,
            -3,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQWAITTIME_OFFSET
        },

        // REQCOMFAILED
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQCOMFAILED,
            0,
            REQCOMFAILED,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQCOMFAILED_OFFSET
        },

        // REQBROWSEREXEC
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQBROWSEREXEC,
            0,
            REQBROWSEREXEC,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQBROWSEREXEC_OFFSET
        },

        // REQFAILED
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQFAILED,
            0,
            REQFAILED,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQFAILED_OFFSET
        },

        // REQNOTAUTH
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQNOTAUTH,
            0,
            REQNOTAUTH,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQNOTAUTH_OFFSET
        },

        // REQNOTFOUND
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQNOTFOUND,
            0,
            REQNOTFOUND,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQNOTFOUND_OFFSET
        },

        // REQCURRENT
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQCURRENT,
            0,
            REQCURRENT,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQCURRENT_OFFSET
        },

        // REQREJECTED
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQREJECTED,
            0,
            REQREJECTED,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQREJECTED_OFFSET
        },

        // REQSUCCEEDED
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQSUCCEEDED,
            0,
            REQSUCCEEDED,
            0,
            -1,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQSUCCEEDED_OFFSET
        },

        // REQTIMEOUT
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQTIMEOUT,
            0,
            REQTIMEOUT,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQTIMEOUT_OFFSET
        },

        // REQTOTAL
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQTOTAL,
            0,
            REQTOTAL,
            0,
            -1,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_REQTOTAL_OFFSET
        },

        // REQPERSEC
        {
            sizeof(PERF_COUNTER_DEFINITION),
            REQPERSEC,
            0,
            REQPERSEC,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_COUNTER,
            sizeof(DWORD),
            AX_REQPERSEC_OFFSET
        },

        // SCRIPTFREEENG
        {
            sizeof(PERF_COUNTER_DEFINITION),
            SCRIPTFREEENG,
            0,
            SCRIPTFREEENG,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_SCRIPTFREEENG_OFFSET
        },

        // SESSIONLIFETIME
        {
            sizeof(PERF_COUNTER_DEFINITION),
            SESSIONLIFETIME,
            0,
            SESSIONLIFETIME,
            0,
            3,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_SESSIONLIFETIME_OFFSET
        },

        // SESSIONCURRENT
        {
            sizeof(PERF_COUNTER_DEFINITION),
            SESSIONCURRENT,
            0,
            SESSIONCURRENT,
            0,
            -1,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_SESSIONCURRENT_OFFSET
        },

        // SESSIONTIMEOUT
        {
            sizeof(PERF_COUNTER_DEFINITION),
            SESSIONTIMEOUT,
            0,
            SESSIONTIMEOUT,
            0,
            -1,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_SESSIONTIMEOUT_OFFSET
        },

        // SESSIONSTOTAL
        {
            sizeof(PERF_COUNTER_DEFINITION),
            SESSIONSTOTAL,
            0,
            SESSIONSTOTAL,
            0,
            -1,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_SESSIONSTOTAL_OFFSET
        },

        // TEMPLCACHE
        {
            sizeof(PERF_COUNTER_DEFINITION),
            TEMPLCACHE,
            0,
            TEMPLCACHE,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_TEMPLCACHE_OFFSET
        },

        // TEMPLCACHEHITS
        {
            sizeof(PERF_COUNTER_DEFINITION),
            TEMPLCACHEHITS,
            0,
            TEMPLCACHEHITS,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_RAW_FRACTION,
            sizeof(DWORD),
            AX_TEMPLCACHEHITS_OFFSET
        },

        // TEMPLCACHETRYS
        {
            sizeof(PERF_COUNTER_DEFINITION),
            TEMPLCACHETRYS,
            0,
            TEMPLCACHETRYS,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_RAW_BASE,
            sizeof(DWORD),
            AX_TEMPLCACHETRYS_OFFSET
        },

        // TEMPLFLUSHES
        {
            sizeof(PERF_COUNTER_DEFINITION),
            TEMPLFLUSHES,
            0,
            TEMPLFLUSHES,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_TEMPLFLUSHES_OFFSET
        },

        // TRANSABORTED
        {
            sizeof(PERF_COUNTER_DEFINITION),
            TRANSABORTED,
            0,
            TRANSABORTED,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_TRANSABORTED_OFFSET
        },

        // TRANSCOMMIT
        {
            sizeof(PERF_COUNTER_DEFINITION),
            TRANSCOMMIT,
            0,
            TRANSCOMMIT,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_TRANSCOMMIT_OFFSET
        },

        // TRANSPENDING
        {
            sizeof(PERF_COUNTER_DEFINITION),
            TRANSPENDING,
            0,
            TRANSPENDING,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_TRANSPENDING_OFFSET
        },

        // TRANSTOTAL
        {
            sizeof(PERF_COUNTER_DEFINITION),
            TRANSTOTAL,
            0,
            TRANSTOTAL,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_TRANSTOTAL_OFFSET
        },

        // TRANSPERSEC
        {
            sizeof(PERF_COUNTER_DEFINITION),
            TRANSPERSEC,
            0,
            TRANSPERSEC,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_COUNTER,
            sizeof(DWORD),
            AX_TRANSPERSEC_OFFSET
        },

        // MEMORYTEMPLCACHE
        {
            sizeof(PERF_COUNTER_DEFINITION),
            MEMORYTEMPLCACHE,
            0,
            MEMORYTEMPLCACHE,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_COUNTER_RAWCOUNT,
            sizeof(DWORD),
            AX_MEMORYTEMPLCACHE_OFFSET
        },

        // MEMORYTEMPLCACHEHITS
        {
            sizeof(PERF_COUNTER_DEFINITION),
            MEMORYTEMPLCACHEHITS,
            0,
            MEMORYTEMPLCACHEHITS,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_RAW_FRACTION,
            sizeof(DWORD),
            AX_MEMORYTEMPLCACHEHITS_OFFSET
        },
        // MEMORYTEMPLCACHETRYS
        {
            sizeof(PERF_COUNTER_DEFINITION),
            MEMORYTEMPLCACHETRYS,
            0,
            MEMORYTEMPLCACHETRYS,
            0,
            0,
            PERF_DETAIL_NOVICE,
            PERF_RAW_BASE,
            sizeof(DWORD),
            AX_MEMORYTEMPLCACHETRYS_OFFSET
        }

    }  // Counters[]
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\perfmon\denver.h ===
#include <winver.h>
#include "iisver.h"

/*------------------------------------------------------------------------------*/
/* the following section defines values used in the version     		*/
/* data structure for all files, and which do not change.            		*/
/*------------------------------------------------------------------------------*/

/* default is nodebug */
#ifndef DEBUG
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS32
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"

#ifndef DLL_VER
#undef	VER_PRODUCTNAME_STR
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows(TM) Operating System\0"
#endif //DLL_VER

#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"

#define	VER_FILETYPE            	VFT_DLL
#define	VER_FILESUBTYPE         	0

#define	VER_LEGALCOPYRIGHT_YEARS 	"1996"

#ifndef DLL_VER
#undef	VER_PRODUCTNAME_STR
#define	VER_PRODUCTNAME_STR 		"Active Server Pages"
#undef	VER_FILEDESCRIPTION_STR
#define	VER_FILEDESCRIPTION_STR	 	"Active Server Pages Performance Counters"
#undef	VER_INTERNALNAME_STR
#define	VER_INTERNALNAME_STR		"Active Server Pages"
#undef	VER_ORIGINALFILENAME_STR
#define	VER_ORIGINALFILENAME_STR 	"ASPPERF.DLL"

#endif //DLL_VER

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\perfmon\makefile.inc ===
#
# Supplemental rules for generating Type library.
#

iCPU=$(PROCESSOR_ARCHITECTURE)
!IF "$(iCPU)"=="x86"
iCPU=I386
!ENDIF

!ifdef _NTTREE
CDROOT=$(_NTTREE)\inetsrv

CopyFiles:
	if not exist "$(CDROOT)" mkdir $(CDROOT)
	xcopy /d /i axperf.ini $(_NTTREE)
	xcopy /d /i axctrnm.h  $(CDROOT)
!else
CopyFiles:
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\sso\adrot\adrot.cpp ===
/*
**	ADROT.CPP
**	Sean P. Nolan
**
**	Ad Rotator SSO Real Work

  Abstract:
    Reads in an advertising schedule file and creates html for displaying
    advertising images based on the "percentages" configured in that file.
    
  Authors:
    seanp      Sean P. Nolan
    davidme     David Messner

  History
	~02/xx/96   seanp
        Created

    07/25/96    davidme
        Object taken over by the advertising group within MSN.
        Original adrot.dll version at time of split: 1.0.0.6
        No longer an arbitrary number of sched file entries
        An href field consisting of a single character now implies that the
            image should not be href'ed
        Use 32 bit ints instead of 16 for the ad "percentage" values; had to
            use floating point math to avoid overflow when determining random ad
        Change to wcsutil.cpp fixing rename notification bug so that when schedule
            file is renamed, it forces schedule to be flushed from memory
        Add optional attributes .Clickable, .Border, .FrameTarget
*/

#pragma warning(disable: 4237)		// disable "bool" reserved

#include "ssobase.h"
#include "adrot.h"
#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>

/*--------------------------------------------------------------------------+
|	Local Prototypes														|
+--------------------------------------------------------------------------*/

HRESULT SSOGetAdvertisement(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff);
HRESULT SSOClickable(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff);
HRESULT SSOTargetFrame(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff);
HRESULT SSOBorder(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff);
HRESULT SSOAbout(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff);

/*--------------------------------------------------------------------------+
|	Globals We Have To Provide												|
+--------------------------------------------------------------------------*/

SSOMETHOD g_rgssomethod[] = { { L"GetAdvertisement",
							    (PFNSSOMETHOD) SSOGetAdvertisement,
								0									},

                              { L"Clickable",
                                (PFNSSOMETHOD) SSOClickable,
                                0                                   },

                              { L"Border",
                                (PFNSSOMETHOD) SSOBorder,
                                0                                   },

                              { L"TargetFrame",
                                (PFNSSOMETHOD) SSOTargetFrame,
                                0                                   },

 							  { L"About",
								(PFNSSOMETHOD) SSOAbout,
								0									},

							  { NULL,
							    NULL,
								0									}};

PFNSSOMETHOD g_pfnssoDynamic = NULL;

LPSTR g_szSSOProgID = "MSWC.AdRotator";

BOOL g_fPersistentSSO = TRUE;

GUID CDECL g_clsidSSO = 
		{ 0x1621f7c0, 0x60ac, 0x11cf,
		{ 0x94, 0x27, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00 } };

/*--------------------------------------------------------------------------+
|	Constants																|
+--------------------------------------------------------------------------*/

#define CAE_NIL	(0xFFFF)

#define DXP_AD_DEFAULT			(440)
#define DYP_AD_DEFAULT			(60)
#define HSPACE_AD_DEFAULT		(0)
#define VSPACE_AD_DEFAULT		(0)
#define DP_AD_BORDER_DEFAULT	(1)
#define DP_BORDER_UNSPECIFIED   (0xFF)

const char *c_szHrefFormat = "<A HREF=\"%s?url=%s&image=%s\" %s><IMG SRC=\"%s\" ALT=\"%s\" WIDTH=%d HEIGHT=%d %s %s BORDER=%d></A>";
const char *c_szHtmlFormat = "<IMG SRC=\"%s\" ALT=\"%s\" WIDTH=%d HEIGHT=%d %s %s BORDER=%d>";

const char *c_szHeaderHeight	= "HEIGHT";
const char *c_szHeaderWidth		= "WIDTH";
const char *c_szHeaderBorder	= "BORDER";
const char *c_szHeaderRedirect	= "REDIRECT";
const char *c_szHeaderHspace	= "HSPACE";
const char *c_szHeaderVspace	= "VSPACE";

/*--------------------------------------------------------------------------+
|	CAdRotator																|
+--------------------------------------------------------------------------*/

#define MAX_HTML_LENGTH          (2048) // maximum length of entire html output
#define MAX_URL_LENGTH           (256)  // storage for Link and Gif Image attributes
#define MAX_ALT_LENGTH           (128)  // storage for Alt text for image
#define AD_BLOCK_SIZE            (16)   // Allocation block size (in Ad Entries)
#define DEFAULTSTRSIZE			 1024	// size of localized text string

HANDLE g_hAdHeap;                // Heap for storing the Ad Entry Lists

typedef struct _AdElement
	{
	ULONG	Percentage;
    CHAR    szLink[2*MAX_URL_LENGTH];
    CHAR    szGif[2*MAX_URL_LENGTH];
    CHAR    szAlt[2*MAX_ALT_LENGTH];
	}
	AE;

class CAdRotator : public CDataFile
	{
	private:
		USHORT			m_cae;
		AE				*m_rgae;
		ULONG			m_PercentageTotal;

		USHORT			m_dxp;
		USHORT			m_dyp;
		USHORT			m_dpBorder;
		CHAR			m_szAdRedirector[MAX_PATH];
        CHAR            m_szHspace[25];
        CHAR            m_szVspace[25];

	public:
		CAdRotator(LPSTR szDataPath, CDataFileGroup *pdfg);
		~CAdRotator(void);

		HRESULT		GetAdvertisement(BSTR *pbstrResult, SSSTUFF *pstuff);

		virtual void FreeDataFile(void)	{ delete this; }

	private:
		HRESULT		BuildAEList(void);
		LPSTR		PchReadHeaders(LPSTR sz);
        BSTR        FormatAdvertisement(AE *pae, SSSTUFF *pstuff);
	};

/*--------------------------------------------------------------------------+
|	CAdRotGroup																|
+--------------------------------------------------------------------------*/

class CAdRotGroup : public CDataFileGroup
	{
	public:
		virtual CDataFile *CreateDataFile(LPSTR szDataPath)
			{ return((CDataFile*)(new CAdRotator(szDataPath, this))); }
	};

CAdRotGroup g_dfg;

/*--------------------------------------------------------------------------+
|	AdVariant                                                               |
+--------------------------------------------------------------------------*/

// These attributes are controllable from the content.  Advariant structures
// maintain state information associated with an instance of a script rather
// than with an instance of an AdRotator, which might serve many scripts
//
typedef struct _AdVariant
    {
    BOOL    fClickable;
    USHORT  dpBorder;
    CHAR    szTarget[MAX_URL_LENGTH];
    }
    ADVARIANT;

/*--------------------------------------------------------------------------+
|	CAdRotator																|
+--------------------------------------------------------------------------*/

CAdRotator::CAdRotator(LPSTR szDataPath, CDataFileGroup *pdfg)
	: CDataFile(szDataPath, pdfg)
{
	m_dxp = DXP_AD_DEFAULT;
	m_dyp = DYP_AD_DEFAULT;
	m_dpBorder = DP_AD_BORDER_DEFAULT;
	m_szAdRedirector[0] = 0;

    m_rgae = NULL;
	m_cae = CAE_NIL;
}

CAdRotator::~CAdRotator()
{
    // Free the advertising entry list that was allocated in BuildAEList
    if (m_rgae && g_hAdHeap)
        ::HeapFree(g_hAdHeap, 0, m_rgae);  

#ifdef DEBUG
	::FillMemory(this, sizeof(this), 0xAC);
#endif
}
		
LPSTR		
CAdRotator::PchReadHeaders(LPSTR sz)
{
	LPSTR pch = sz;
	LPSTR pchWalk, pchValue;
    DWORD dxpHspace = HSPACE_AD_DEFAULT;
	DWORD dypVspace = VSPACE_AD_DEFAULT;

	while (*pch && *pch != '*')
		{
		// terminate this line
		pchWalk = _FindEndOfLine(pch);
		if (*pchWalk)
			*pchWalk++ = 0;

		// deal with this header line
		for (pchValue = pch; *pchValue && *pchValue != ' ' && *pchValue != '\t'; pchValue = CharNext(pchValue))
			/* nothing */ ;

		if (*pchValue)
			{
			*pchValue++ = 0;
			while (*pchValue && (*pchValue == ' ' || *pchValue == '\t'))
				pchValue = CharNext(pchValue);

			if (*pchValue)
				{
				// ok! we have pch pointing to the name and pchValue pointing
				// at the value... hoooooray!
				if (!lstrcmpi(pch, c_szHeaderHeight))
					{
					m_dyp = (USHORT) _atoi(pchValue);
					}
				else if (!lstrcmpi(pch, c_szHeaderWidth))
					{
					m_dxp = (USHORT) _atoi(pchValue);
					}
				else if (!lstrcmpi(pch, c_szHeaderHspace))
					{
					dxpHspace = (USHORT) _atoi(pchValue);
					}
				else if (!lstrcmpi(pch, c_szHeaderVspace))
					{
					dypVspace = (USHORT) _atoi(pchValue);
					}
				else if (!lstrcmpi(pch, c_szHeaderBorder))
					{
					m_dpBorder = (USHORT) _atoi(pchValue);
					}
				else if (!lstrcmpi(pch, c_szHeaderRedirect))
					{
					lstrcpy(m_szAdRedirector, pchValue);
					}
                else
					{
					ExceptionId(g_clsidSSO, SSO_ADROT, SSO_UNKNOWN_HEADER_NAME);
					}
				}
			}
            else
				ExceptionId(g_clsidSSO, SSO_ADROT, SSO_HEADER_HAS_NO_ASSOCIATED_VALUE);

		// advance to next line
		pch = _SkipWhiteSpace(pchWalk);
		}

    // Format the Hspace and Vspace attributes for this rotator instance
    if (dxpHspace)
        wsprintf(m_szHspace, "HSPACE=%d", dxpHspace);
    else
        m_szHspace[0] = 0;
    if (dypVspace)
        wsprintf(m_szVspace, "VSPACE=%d", dypVspace);
    else
        m_szVspace[0] = 0;

	pch = _FindEndOfLine(pch);
	return(pch);
}

HRESULT
CAdRotator::BuildAEList()
{
	LPSTR	pch;
	LPSTR	szGif, szLink, szAlt, szPercent;
	AE		*pae;
	HANDLE	hfile = INVALID_HANDLE_VALUE;
	LPSTR	szData = NULL;
	HRESULT	hr;
	DWORD	cb, cbRead;
    DWORD   dwBlocks = 1;

	// this happens when there was a problem loading the file
	if (!m_cae)
		{
		hr = E_FAIL;
		goto LBuildRet;
		}

	// already loaded ok
	if (m_cae != CAE_NIL)
		{
		hr = NOERROR;
		goto LBuildRet;
		}

	// hasn't been loaded yet ... try to load the file into memory
	hfile = ::CreateFile(m_szDataPath,
						 GENERIC_READ,
						 FILE_SHARE_READ,
						 NULL,
						 OPEN_EXISTING,
						 FILE_ATTRIBUTE_NORMAL,
						 NULL);

	if (hfile == INVALID_HANDLE_VALUE)
		{
		hr = HRESULT_FROM_WIN32(::GetLastError());
		ExceptionId(g_clsidSSO, SSO_ADROT, SSO_CANNOT_LOAD_ROTATION_SCHEDULE_FILE);
		goto LBuildRet;
		}

	// allocate memory for the advertising entry list
    if (!(m_rgae = (AE *)::HeapAlloc(g_hAdHeap, 0, sizeof(AE) * AD_BLOCK_SIZE)))
    {
        hr = E_OUTOFMEMORY;
        goto LBuildRet;
    }

	if ((cb = ::GetFileSize(hfile, NULL)) == 0xFFFFFFFF)
		{
		hr = HRESULT_FROM_WIN32(::GetLastError());
		goto LBuildRet;
		}

	if (!(szData = (LPSTR) ::HeapAlloc(::GetProcessHeap(), 0, cb + 1)))
		{
		hr = HRESULT_FROM_WIN32(::GetLastError());
		goto LBuildRet;
		}

	if (!::ReadFile(hfile, szData, cb, &cbRead, NULL))
		{
		hr = HRESULT_FROM_WIN32(::GetLastError());
		goto LBuildRet;
		}

	szData[cb] = 0;

	// ok, so we've got a pointer to it ... first read the header info
	pch = this->PchReadHeaders(szData);
    if (!pch || !*pch)
		{
		hr = E_FAIL;
		ExceptionId(g_clsidSSO, SSO_ADROT, SSO_CANNOT_READ_ROTATION_SCHEDULE_FILE);
		goto LBuildRet;
		}

	// now read in the entries
	m_PercentageTotal = 0;

	for (m_cae = 0, pae = m_rgae; *pch; ++m_cae, ++pae)
        {
        
        // Memory is allocated incrementally as needed
        // check to see if we've filled the last block and need to
        // allocate a bigger chunk and adjust pointers.
        if (m_cae == dwBlocks * AD_BLOCK_SIZE)
        {
            m_rgae = (AE *)::HeapReAlloc(g_hAdHeap, 0, m_rgae,
                (dwBlocks+1) * AD_BLOCK_SIZE * sizeof(AE));
            if (NULL == m_rgae)
            {
                hr = E_OUTOFMEMORY;
                goto LBuildRet;
            }
            pae = m_rgae + AD_BLOCK_SIZE * dwBlocks++;
        }

		// get the url to the gif
		szGif = _SkipWhiteSpace(pch);
		pch = _FindEndOfLine(szGif);
		if (*pch)
			*pch++ = 0;

		// get the url for the link
		szLink = _SkipWhiteSpace(pch);
		pch = _FindEndOfLine(szLink);
		if (*pch)
			*pch++ = 0;

		// get the alt text
		szAlt = _SkipWhiteSpace(pch);
		pch = _FindEndOfLine(szAlt);
		if (*pch)
			*pch++ = 0;

		// get the percentage count
		szPercent = _SkipWhiteSpace(pch);
		pch = _FindEndOfLine(szPercent);
		if (*pch)
			*pch++ = 0;

		if (*szGif && *szLink && *szAlt && *szPercent)
			{

            // We now ignore entries with a zeroed "percentage" value
            pae->Percentage = _atoi(szPercent);
            if (0 == pae->Percentage)
            {
                --m_cae;
                --pae;
                continue;
            }
            m_PercentageTotal += pae->Percentage;

            strncpy(pae->szGif, szGif, MAX_URL_LENGTH);
            strncpy(pae->szLink, szLink, MAX_URL_LENGTH);
            strncpy(pae->szAlt, szAlt, MAX_ALT_LENGTH);

			}
		else
			{
			// error out if we got a gif but not one of the others
			if (*szGif)
				{
				m_cae = 0;
                hr = E_FAIL;
                goto LBuildRet;
				}
			else
                break;
        }
            

		pch = _SkipWhiteSpace(pch);
		}

	// this happens when there was a problem loading the file
	if (!m_cae)
		{
		hr = E_FAIL;
		goto LBuildRet;
		}

	// everything went well ... register for change notifications
	// on the file so that we can flush our cache appropriately
	if (!this->FWatchFile())
		{
		hr = E_FAIL;
		goto LBuildRet;
		}

	hr = NOERROR;

LBuildRet:
	if (szData)
		::HeapFree(::GetProcessHeap(), 0, szData);

	if (hfile != INVALID_HANDLE_VALUE)
		::CloseHandle(hfile);

	return(hr);
}

BSTR CAdRotator::FormatAdvertisement(AE *pae, SSSTUFF *pstuff)
{
    ADVARIANT *padVariant;
    CHAR      szHtml[MAX_HTML_LENGTH];
    BSTR      bstr;
    DWORD     cbHtml;
    CHAR      *pszTarget = "";
    BOOL      fClickable;
    USHORT    dpBorder = m_dpBorder;

    if (padVariant = (ADVARIANT *)pstuff->lUser)
	    {
        fClickable = (*((pae->szLink)+1) && padVariant->fClickable);
        pszTarget = padVariant->szTarget;
        if (padVariant->dpBorder != DP_BORDER_UNSPECIFIED)
            dpBorder = padVariant->dpBorder;
		}
    else
	    {
        dpBorder = m_dpBorder;
        fClickable = (*((pae->szLink)+1));
		}


    if (fClickable)        // if the link is > 1 character, href the image
        wsprintf(szHtml, c_szHrefFormat, m_szAdRedirector, 
	        pae->szLink, pae->szGif, pszTarget, pae->szGif,
		    pae->szAlt, m_dxp, m_dyp, 
			m_szHspace, m_szVspace, dpBorder);
    else                    // otherwise display only the image
        wsprintf(szHtml, c_szHtmlFormat,
		        pae->szGif, pae->szAlt, m_dxp, m_dyp, 
				m_szHspace, m_szVspace, dpBorder);

    // Allocate a BSTR for passing back the result
	cbHtml = strlen(szHtml);

	if (!(bstr = SysAllocStringLen(NULL, cbHtml)))
		return NULL;

	::MultiByteToWideChar(CP_ACP, 0, szHtml, -1, bstr, cbHtml);
    bstr[cbHtml] = 0;

    return bstr;
}


CCritSec g_csRand;

HRESULT		
CAdRotator::GetAdvertisement(BSTR *pbstrResult, SSSTUFF *pstuff)
{
	HRESULT	hr;
	ULONG	Target, Current;
	USHORT  iae;
	AE		*pae;

	m_cs.Lock();
	if (SUCCEEDED(hr = this->BuildAEList()))
		{
		// Note that the random number is based
		// off of m_PercentageTotal and NOT 100.
		g_csRand.Lock();

        // This ugly casting is needed to prevent overflow when large "percentages"
        // are used
        Target = (ULONG)(
            ((double)rand()/(double)RAND_MAX)*m_PercentageTotal);

		g_csRand.Unlock();
		
		pae = m_rgae;
		iae = 0;
		Current = pae->Percentage;
		while (Current <= Target)
			{
			if (++iae == m_cae)
			    break;
			++pae;
			Current += pae->Percentage;
			}

		// heeeere we go!
		*pbstrResult = this->FormatAdvertisement(pae, pstuff);
		}

	m_cs.Unlock();
	return(hr);
}


ADVARIANT *GetAdVariant(SSSTUFF *pstuff)
{
    ADVARIANT *padVariant;

    if (pstuff->lUser)
        padVariant = (ADVARIANT *)pstuff->lUser;
    else
    {
        if (!(padVariant = (ADVARIANT *)new ADVARIANT))
            return NULL;

        // Set up defaults for the new state object
        padVariant->fClickable = TRUE;
        padVariant->dpBorder = DP_BORDER_UNSPECIFIED;
        *(padVariant->szTarget) = '\0';
    }
    return padVariant;
}


/*--------------------------------------------------------------------------+
|	External Interface														|
+--------------------------------------------------------------------------*/

HRESULT
SSOGetAdvertisement(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff)
{

	HRESULT		hr;
	BSTR		bstrResult;
	CAdRotator	*par = NULL;
	char		szPathTranslated[MAX_PATH];

	if (pdispparams->cArgs == 0)
		return(DISP_E_PARAMNOTOPTIONAL);

	if (pdispparams->cArgs > 1)
		return(DISP_E_PARAMNOTFOUND);

	if (FAILED(hr = SSOTranslateVirtualRoot(pdispparams->rgvarg, pstuff->punk,
											szPathTranslated, 
											sizeof(szPathTranslated))))
		{
		return(hr);
		}
		

	if (!(par = (CAdRotator*) g_dfg.GetDataFile(szPathTranslated)))
		return(E_FAIL);
		
	if (SUCCEEDED(hr = par->GetAdvertisement(&bstrResult, pstuff)))
		{
		::VariantInit(pvarResult);
		pvarResult->vt = VT_BSTR;
		V_BSTR(pvarResult) = bstrResult;
		}
	else
    	{
	    // Forget this file, there was an error.
	    //
	    // g_dfg.ForgetDataFile(par);
	    // 
	    // BUG FIX: if ForgetDataFile is called under load it will cause
	    // a GP Fault, the code is not needed, the clean up is done on
	    // control release.
	  }

    
	par->Release();
    
	return(hr);
}

HRESULT 
SSOClickable(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff)
{
	ADVARIANT *padVariant;

	if (pdispparams->cArgs == 0)
		return(DISP_E_PARAMNOTOPTIONAL);

	if (pdispparams->cArgs > 1)
		return(DISP_E_PARAMNOTFOUND);

	if (!(padVariant = GetAdVariant(pstuff)))
		return E_OUTOFMEMORY;

	padVariant->fClickable = V_BOOL(pdispparams->rgvarg);
	pstuff->lUser = (LONG)padVariant;

	return NOERROR;
}

HRESULT 
SSOBorder(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff)
{
    ADVARIANT *padVariant;

	if (pdispparams->cArgs == 0)
		return(DISP_E_PARAMNOTOPTIONAL);

	if (pdispparams->cArgs > 1)
		return(DISP_E_PARAMNOTFOUND);

    if (!(padVariant = GetAdVariant(pstuff)))
        return E_OUTOFMEMORY;

	padVariant->dpBorder = V_I2(pdispparams->rgvarg);
    pstuff->lUser = (LONG)padVariant;

    return NOERROR;
}

HRESULT 
SSOTargetFrame(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff)
{
    ADVARIANT *padVariant;
    BSTR      szwFrame;
    UINT      cch;
    CHAR      szBuf[MAX_URL_LENGTH];

	if (pdispparams->cArgs == 0)
		return(DISP_E_PARAMNOTOPTIONAL);

	if (pdispparams->cArgs > 1)
		return(DISP_E_PARAMNOTFOUND);

    if (!(padVariant = GetAdVariant(pstuff)))
        return E_OUTOFMEMORY;

    // Get the string argument and make sure it won't overflow our buffers
    szwFrame = V_BSTR(pdispparams->rgvarg);
    cch = SysStringLen(szwFrame);
    if (cch >= MAX_URL_LENGTH-9)        // 9 == strlen("target=''")
        cch = MAX_URL_LENGTH-10;
    
    ::WideCharToMultiByte(CP_ACP, 0, szwFrame, cch, szBuf, cch, NULL, NULL);
    szBuf[cch] = '\0';

    wsprintf(padVariant->szTarget, "target=\"%s\"", szBuf);

    pstuff->lUser = (LONG)padVariant;

    return NOERROR;
}

HRESULT 
SSOAbout(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff)
{
	char	sz[MAX_PATH];
	CHAR	szAdRotAboutFormat[DEFAULTSTRSIZE];
	OLECHAR	wsz[MAX_PATH];

#ifdef _DEBUG
	char	*szVersion = "Debug";
#else
	char	*szVersion = "Release";
#endif

	CchLoadStringOfId(SSO_ADROT_ABOUT_FORMAT, szAdRotAboutFormat, DEFAULTSTRSIZE);
	wsprintf(sz, szAdRotAboutFormat, szVersion, __DATE__, __TIME__);
	::MultiByteToWideChar(CP_ACP, 0, sz, -1, wsz, sizeof(wsz) / sizeof(OLECHAR));

    ::VariantInit(pvarResult);
	pvarResult->vt = VT_BSTR;
	V_BSTR(pvarResult) = ::SysAllocString(wsz);

	return(NOERROR);
}


/*--------------------------------------------------------------------------+
|	DllMain																	|
+--------------------------------------------------------------------------*/

BOOL WINAPI 
DllMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pvReserved)
{
	if (!SSODllMain(hInstance, ulReason, pvReserved))
		return(FALSE);

	if (DLL_PROCESS_ATTACH == ulReason)
		{
#ifdef _DEBUG
		srand(1);
#else
		srand(::GetTickCount());
#endif // _DEBUG

        if (!(g_hAdHeap = ::HeapCreate(0, 8192, 0)))
           return FALSE;
	    }
    else if (DLL_PROCESS_DETACH == ulReason)
		{
        if (g_hAdHeap)
            ::HeapDestroy(g_hAdHeap);
        g_hAdHeap = NULL;
		}

	return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\sso\adrot\adrot.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Resources

File: adrot.h

Owner: v-charca

This file contains constants for all resources used by AdRotator

===================================================================*/


#define SSO_BEGIN					100

//
// General errors
//
#define SSO_GENERAL_BEGIN							100
#define SSO_NOSVR									SSO_GENERAL_BEGIN
#define SSO_ADROT									SSO_GENERAL_BEGIN + 1
#define SSO_UNKNOWN_HEADER_NAME						SSO_GENERAL_BEGIN + 2
#define SSO_HEADER_HAS_NO_ASSOCIATED_VALUE			SSO_GENERAL_BEGIN + 3
#define SSO_CANNOT_LOAD_ROTATION_SCHEDULE_FILE		SSO_GENERAL_BEGIN + 4
#define SSO_CANNOT_READ_ROTATION_SCHEDULE_FILE		SSO_GENERAL_BEGIN + 5	

#define	SSO_ADROT_ABOUT_FORMAT						SSO_GENERAL_BEGIN + 6
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\sso\browser\browser.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Resources

File: browser.h

Owner: v-charca

This file contains constants for all resources used by Browser Capability

===================================================================*/


#define SSO_BEGIN					100

//
// General errors
//
#define SSO_GENERAL_BEGIN							100
#define SSO_NOSVR									SSO_GENERAL_BEGIN
#define SSO_BROWSER									SSO_GENERAL_BEGIN + 1
#define	SSO_BROWSER_ABOUT_FORMAT					SSO_GENERAL_BEGIN + 2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\sso\browser\browser.cpp ===
/*
**  BROWSER.CPP
**  Sean P. Nolan
**
**  Browser Capabilities SSO
*/

#pragma warning(disable: 4237)      // disable "bool" reserved
#include    "ssobase.h"
#include    "browser.h"
#include    <iis64.h>

/*--------------------------------------------------------------------------+
|   Local Prototypes                                                        |
+--------------------------------------------------------------------------*/

HRESULT SSOOnFreeTemplate(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff);
HRESULT SSOAbout(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff);
HRESULT SSODynamic(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff);

/*--------------------------------------------------------------------------+
|   Globals We Have To Provide                                              |
+--------------------------------------------------------------------------*/

SSOMETHOD g_rgssomethod[] = { { c_wszOnFreeTemplate,
                                (PFNSSOMETHOD) SSOOnFreeTemplate,
                                0                                   },

                              { L"About",
                                (PFNSSOMETHOD) SSOAbout,
                                0                                   },

                              { NULL,
                                NULL,
                                0                                   }};

PFNSSOMETHOD g_pfnssoDynamic = (PFNSSOMETHOD) SSODynamic;

LPSTR g_szSSOProgID = "MSWC.BrowserType";

BOOL g_fPersistentSSO = TRUE;

GUID CDECL g_clsidSSO =
        { 0xace4881, 0x8305, 0x11cf,
        { 0x94, 0x27, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0 } };

/*--------------------------------------------------------------------------+
|   Constants                                                               |
+--------------------------------------------------------------------------*/

#define SN_BLOCK_SIZE    1024   // Allocation block size for Section Names
#define DEFAULTSTRSIZE   1024   // size of localized text string
const CHAR      *c_szUnknown = "Unknown";
const OLECHAR   *c_wszUnknown = L"Unknown";
const CHAR      *c_szTrue = "TRUE";
const CHAR      *c_szFalse = "FALSE";
const OLECHAR   *c_wszParent = L"Parent";
const CHAR      *c_szDefault = "Default Browser Capability Settings";
const CHAR      c_chWildCard = '*';
const char      *c_szIniExt = ".INI";
const OLECHAR   *c_wszUA_OS = L"UA_OS";
const OLECHAR   *c_wszUA_Color = L"UA_Color";
const OLECHAR   *c_wszUA_Pixels = L"UA_Pixels";
const OLECHAR   *c_wszUA_CPU = L"UA_CPU";

/*--------------------------------------------------------------------------+
|   CIniDataFile                                                            |
+--------------------------------------------------------------------------*/

class CVariantHash;

class CIniDataFile : public CDataFile
    {
    private:
        CVariantHash *m_pvh;

    public:
        CIniDataFile(LPSTR szDataPath, CDataFileGroup *pfg, CVariantHash *pvh);
        void ResetVariantHash(void);
        BOOL FWatchIt(void);
        virtual void FreeDataFile(void) { delete this; }

    };

/*--------------------------------------------------------------------------+
|   CVariantHash                                                            |
+--------------------------------------------------------------------------*/

class CVariantHash : public CGenericHash
    {
    private:
        CIniDataFile    *m_pdf;
        BOOL            m_fInited;
        CHAR            m_szIniFile[MAX_PATH];

    public:
        CVariantHash(DWORD cBuckets);
        ~CVariantHash(void);

        BOOL FInit(void);
        void Uninit(void);
        VARIANT *GetVariant(OLECHAR *wszUserAgent, OLECHAR *wszAttribute);

        virtual void FreeHashData(LPVOID pv);
    };

CVariantHash::CVariantHash(DWORD cBuckets)
    : CGenericHash(cBuckets)
{
    m_pdf = NULL;
    m_fInited = FALSE;
}

CVariantHash::~CVariantHash()
{
    if (m_pdf)
        m_pdf->Release();
}

void
CVariantHash::Uninit()
{
    this->Lock();

    m_fInited = FALSE;

    if (m_pdf)
        {
        m_pdf->Release();
        m_pdf = NULL;
        }

    this->RemoveAll();

    this->Unlock();
}

BOOL
CVariantHash::FInit()
{
    char *pch;

    this->Lock();

    if (!m_fInited)
        {
        // even if we fail
        m_fInited = TRUE;

        // get the path to the datafile
        ::GetModuleFileName(g_hinst, m_szIniFile, sizeof(m_szIniFile));
        pch = m_szIniFile + lstrlen(m_szIniFile) - 1;
        while (pch != m_szIniFile && *pch != '.')
            pch = ::CharPrev(m_szIniFile, pch);

        if (*pch == '.')
            lstrcpy(pch, c_szIniExt);

        // create the data file and start watching it
        if (m_pdf = new CIniDataFile(m_szIniFile, NULL, this))
            {
            m_pdf->AddRef();
            m_pdf->FWatchIt();
            }
        }

    this->Unlock();
    return(m_fInited);
}

void
CVariantHash::FreeHashData(LPVOID pv)
{
    ::VariantClear((VARIANT*)pv);
    _MsnFree(pv);
}

VARIANT *
CVariantHash::GetVariant(OLECHAR *wszInUserAgent, OLECHAR *wszAttribute)
{
    OLECHAR wszUserAgent[1024];
    CHAR    szUserAgent[1024];
    CHAR    szAttribute[1024];
    OLECHAR wszTag[1024];
    CHAR    szValue[1024];
    OLECHAR wszValue[1024];
    OLECHAR wszPrefix[2];
    OLECHAR *wszValReal;
    VARIANT *pvar, *pvarNew, *pvarParent, *pvarT;
    BOOL    fNum = FALSE;
    CHAR    *szSecName = NULL;
    DWORD   dwBlocks = 8;
    CHAR    *pszSecName=NULL;
    CHAR    *pszStarLoc=NULL;
    USHORT  ccLeft;
    USHORT  ccRight;

    if (!this->FInit())
        return(NULL);

    wcscpy(wszTag, wszInUserAgent);
    wcscat(wszTag, L"-");
    wcscat(wszTag, wszAttribute);

    if (!(pvar = (VARIANT *) this->PvFind(wszTag)))
        {
        // Haven't seen this yet combination yet.
        // First let's see if the user agent string is an exact match
        // or if we need to get a wildcard match
        wcstombs(szUserAgent, wszInUserAgent, sizeof(szUserAgent));
        wcstombs(szAttribute, wszAttribute, sizeof(szAttribute));

        if (0 ==::GetPrivateProfileSectionA(szUserAgent,
                                        szValue,
                                        sizeof(szValue) / sizeof(CHAR),
                                        m_szIniFile))
            {   // no exact match for User Agent found
            szSecName = (CHAR*)_MsnAlloc((dwBlocks*SN_BLOCK_SIZE*sizeof(CHAR)));
            if (NULL == szSecName)
                return(NULL);

            while ((::GetPrivateProfileSectionNamesA(szSecName,
                                                    (dwBlocks*SN_BLOCK_SIZE),
                                                    m_szIniFile)) == dwBlocks*SN_BLOCK_SIZE-2)
                {
                dwBlocks++;
                szSecName = (CHAR *)_MsnRealloc(szSecName, (dwBlocks*SN_BLOCK_SIZE*sizeof(CHAR)));
                if (!szSecName)
                    return(NULL);
                }

            for (pszSecName=szSecName; *pszSecName!='\0'; pszSecName+=lstrlen(pszSecName)+1)
                {
                if ((pszStarLoc=strchr(pszSecName, c_chWildCard)) &&
                    (lstrlen(szUserAgent)>=(lstrlen(pszSecName)-1)))
                    {   // If there's a wildcard character in the section name,
                        // and the User-Agent string is long enough to match,
                        // then try to match the strings on both sides of the
                        // wildcard character.  If no wildcard character, then
                        // do nothing, since we've already failed the exact match.
                    ccLeft = DIFF(pszStarLoc-pszSecName);
                    ccRight = lstrlen(pszSecName) - ccLeft - 1;
                    if ((CompareString(LOCALE_USER_DEFAULT,
                                     NORM_IGNORECASE,
                                     pszSecName,
                                     ccLeft,
                                     szUserAgent,
                                     ccLeft)==2) &&
                        (CompareString(LOCALE_USER_DEFAULT,
                                    NORM_IGNORECASE,
                                    (CHAR*)(pszStarLoc+1),
                                    ccRight,
                                    (CHAR*)(szUserAgent+(lstrlen(szUserAgent)-ccRight)),
                                    ccRight)==2))
                        {
                        lstrcpy(szUserAgent, pszSecName);
                        break;
                        }
                    }
                }
            if (szSecName)
                _MsnFree(szSecName);
            }


        //  See if an entry exists in the ini file
        ::GetPrivateProfileStringA(szUserAgent,
                                  szAttribute,
                                  c_szUnknown,
                                  szValue,
                                  sizeof(szValue) / sizeof(CHAR),
                                  m_szIniFile);

        pvarT = NULL;
        if (!stricmp(szValue, c_szUnknown) &&
            wcsicmp(wszAttribute, c_wszParent))
            {
            // ok .. tried to read it out of the ini file,
            // but it wasn't there. see if there's a parent entry
            // for this guy and, if so, query the parent for it
            // and then munge it into place here. if not, just go
            // on about our business as usual
            mbstowcs(wszUserAgent, szUserAgent, sizeof(wszUserAgent) / sizeof(OLECHAR));
            if (pvarParent = this->GetVariant(wszUserAgent, (OLECHAR*) c_wszParent))
                {
                if (pvarParent->vt == VT_BSTR &&
                    wcsicmp(V_BSTR(pvarParent), c_wszUnknown))
                    {
                    // if this fails, no sweat. If it succeeds, we'll use it instead
                    // of what's in szValue later
                    pvarT = this->GetVariant(V_BSTR(pvarParent), wszAttribute);
                    }
                }
            }

        if (!stricmp(szValue, c_szUnknown) && !pvarT)
            {
            // ok .. tried to read it out of the ini file,
            // but it wasn't there. Also tried looking for
            // a parent entry, but there was none.  See if
            // there's a default entry
            ::GetPrivateProfileStringA((CHAR*) c_szDefault,
                                       szAttribute,
                                       c_szUnknown,
                                       szValue,
                                       sizeof(szValue) / sizeof(CHAR),
                                       m_szIniFile);
            }

        if (!(pvarNew = (VARIANT*) _MsnAlloc(sizeof(VARIANT))))
            return(NULL);

        if (pvarT)
            {
            // pulled from parent or default
            ::VariantInit(pvarNew);
            ::VariantCopy(pvarNew, pvarT);
            }
        else if (!stricmp(szValue, c_szTrue))
            {
            // bool true
            pvarNew->vt = VT_BOOL;
            V_BOOL(pvarNew) = VARIANT_TRUE;
            }
        else if (!stricmp(szValue, c_szFalse))
            {
            // bool false
            pvarNew->vt = VT_BOOL;
            V_BOOL(pvarNew) = VARIANT_FALSE;
            }
        else
            {
            mbstowcs(wszValue, szValue, sizeof(wszValue) / sizeof(OLECHAR));
            wszPrefix[0] = wszValue[0];
            wszPrefix[1] = 0;
            if (!wcsicmp(wszPrefix, L"#"))
                {
                // number
                fNum = TRUE;
                wszValReal = &(wszValue[1]);
                }
            else
                {
                // string
                fNum = FALSE;
                wszValReal = wszValue;
                }

            pvarNew->vt = VT_BSTR;
            if (!(V_BSTR(pvarNew) = ::SysAllocString(wszValReal)))
                {
                _MsnFree(pvarNew);
                return(NULL);
                }

            if (fNum)
                ::VariantChangeType(pvarNew, pvarNew, 0, VT_I4);
            }

        if (!this->FAdd(wszTag, (LPVOID) pvarNew))
            {
            ::VariantClear(pvarNew);
            _MsnFree(pvarNew);
            return(NULL);
            }

        pvar = pvarNew;
        }

    return(pvar);
}

/*--------------------------------------------------------------------------+
|   CIniDataFile Implementation                                             |
+--------------------------------------------------------------------------*/

CIniDataFile::CIniDataFile(LPSTR szDataPath, CDataFileGroup *pfg, CVariantHash *pvh)
    : CDataFile(szDataPath, pfg)
{
    m_pvh = pvh;
}

void
CIniDataFile::ResetVariantHash()
{
    m_pvh->Uninit();
}

void
IniFileChanged(LPSTR szFile, LONG lUser)
{
    CIniDataFile *pdf = (CIniDataFile*) lUser;
    pdf->ResetVariantHash();
}

BOOL
CIniDataFile::FWatchIt()
{
    return(this->FWatchFile((PFNFILECHANGED)IniFileChanged));
}

/*--------------------------------------------------------------------------+
|   Private Globals                                                         |
+--------------------------------------------------------------------------*/

CVariantHash g_vh(1023);

/*--------------------------------------------------------------------------+
|   External Interface                                                      |
+--------------------------------------------------------------------------*/



HRESULT
SSOOnFreeTemplate(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff)
{
    if (pstuff->lUser)
        ::SysFreeString((BSTR)(pstuff->lUser));

    return(NOERROR);
}

HRESULT
SSODynamic(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff)
{
    VARIANT             *pvar = NULL;
    VARIANT             varUserAgent;
    IDispatch           *pDispUserAgent = NULL;
    IRequest            *preq = NULL;
    IDispatch           *pDispIEProperty = NULL;
    VARIANT             varIEProperty;
    HRESULT             hr = NOERROR;
    OLECHAR             *wszName = NULL;
    IScriptingContext   *pcxt = NULL;

    ::VariantInit(&varUserAgent);

    if (!wcsicmp(pstuff->wszMethodName, c_wszOnNewTemplate))
        goto end;

    if (pvarResult)
        ::VariantInit(pvarResult);
    else
        goto end;

    if (wInvokeFlags & DISPATCH_PROPERTYPUT)
        {
        hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        goto end;
        }

    // get the user-agent string
    if (FAILED(hr = pstuff->punk->QueryInterface(IID_IScriptingContext, reinterpret_cast<void **>(&pcxt))))
        goto end;

    if (FAILED(hr = pcxt->get_Request(&preq)))
        goto end;

    hr = preq->get_Item(L"HTTP_USER_AGENT", &pDispUserAgent);
    if (FAILED(hr))
        {
        pvarResult->vt = VT_BSTR;
        V_BSTR(pvarResult) = ::SysAllocString(c_wszUnknown);
        hr = NOERROR;
        goto end;
        }


    V_VT(&varUserAgent) = VT_DISPATCH;
    V_DISPATCH(&varUserAgent) = pDispUserAgent;
    if (FAILED(hr = VariantChangeType(&varUserAgent, &varUserAgent, 0, VT_BSTR)))
        goto end;

    // now get it out of the hash table
    if (pstuff->wszMethodName[0])
        {
        // dynamic property
        wszName = pstuff->wszMethodName;
        }
    else
        {
        // default method
        if (pdispparams->cArgs == 0)
        {
            hr = DISP_E_PARAMNOTOPTIONAL;
            goto end;
        }

        if (pdispparams->cArgs > 1)
        {
            hr = DISP_E_PARAMNOTFOUND;
            goto end;
        }

        wszName = V_BSTR(pdispparams->rgvarg);
        }

    if (!wcsicmp(wszName, c_wszUA_OS) ||
        !wcsicmp(wszName, c_wszUA_Pixels) ||
        !wcsicmp(wszName, c_wszUA_Color) ||
        !wcsicmp(wszName, c_wszUA_CPU))
        {
        ::VariantInit(&varIEProperty);
        OLECHAR wszTag[1024];
        wcscpy(wszTag, L"HTTP_");
        wcscat(wszTag, wszName);
        hr = preq->get_Item(wszTag, &pDispIEProperty);
        if (SUCCEEDED(hr))
            {
            V_VT(&varIEProperty) = VT_DISPATCH;
            V_DISPATCH(&varIEProperty) = pDispIEProperty;
            if (SUCCEEDED(hr = VariantChangeType(&varIEProperty, &varIEProperty, 0, VT_BSTR)))
                {
                ::VariantCopy(pvarResult, &varIEProperty);
                goto end;
                }
            }
        }
    g_vh.Lock();
    if (!(pvar = g_vh.GetVariant(V_BSTR(&varUserAgent), wszName)))
        {
        g_vh.Unlock();
        pvarResult->vt = VT_BSTR;
        V_BSTR(pvarResult) = ::SysAllocString(c_wszUnknown);
        hr = NOERROR;
        goto end;
        }

    ::VariantCopy(pvarResult, pvar);
    g_vh.Unlock();


end:
    if (pcxt)
        pcxt->Release();

    if (preq != NULL)
        preq->Release();
    ::VariantClear(&varUserAgent);
    return hr;
}

HRESULT
SSOAbout(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff)
{
    char    sz[MAX_PATH];
    CHAR    szBrowserAboutFormat[DEFAULTSTRSIZE];
    OLECHAR wsz[MAX_PATH];

#ifdef _DEBUG
    char    *szVersion = "Debug";
#else
    char    *szVersion = "Release";
#endif

    CchLoadStringOfId(SSO_BROWSER_ABOUT_FORMAT, szBrowserAboutFormat, DEFAULTSTRSIZE);
    wsprintf(sz, szBrowserAboutFormat, szVersion, __DATE__, __TIME__);
    ::MultiByteToWideChar(CP_ACP, 0, sz, -1, wsz, sizeof(wsz) / sizeof(OLECHAR));

    VariantInit(pvarResult);
    pvarResult->vt = VT_BSTR;
    V_BSTR(pvarResult) = ::SysAllocString(wsz);

    return(NOERROR);
}

/*--------------------------------------------------------------------------+
|   DllMain                                                                 |
+--------------------------------------------------------------------------*/

BOOL WINAPI
DllMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pvReserved)
{
    return(SSODllMain(hInstance, ulReason, pvReserved));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\sso\browser\makefile.inc ===
#
# Supplemental rules for generating Type library.
#

CDROOT=$(_NTTREE)\inetsrv

#CopyFiles
#copy .ini files
CopyFiles:
	if not exist "$(CDROOT)" mkdir $(CDROOT)
	xcopy /d /i browscap.ini $(CDROOT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\sso\nextlink\nextlink.cpp ===
/*
**	nextlink.CPP
**	davidsan
**
**	Next Link SSO
*/

#pragma warning(disable: 4237)		// disable "bool" reserved

#include "ssobase.h"
#include "nextlink.h"
//#include "resource.h"

//#define DEBUGMEMLEAK
#ifdef DEBUGMEMLEAK
#include "crtdbg.h"
_CrtMemState g_s1;
#endif
/*--------------------------------------------------------------------------+
|	Local Prototypes														|
+--------------------------------------------------------------------------*/

HRESULT SSOGetNextURL(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff);
HRESULT SSOGetNextDescription(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff);
HRESULT SSOGetPreviousURL(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff);
HRESULT SSOGetPreviousDescription(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff);
HRESULT SSOGetNthURL(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff);
HRESULT SSOGetNthDescription(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff);
HRESULT SSOGetListCount(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff);
HRESULT SSOGetListIndex(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff);
HRESULT SSOAbout(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff);
HRESULT OnNewTemplate(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, LONG *plUser);
HRESULT OnFreeTemplate(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, LONG *plUser);

/*--------------------------------------------------------------------------+
|	Globals We Have To Provide												|
+--------------------------------------------------------------------------*/

SSOMETHOD g_rgssomethod[] =
{
	{
		L"GetNextURL",
		(PFNSSOMETHOD) SSOGetNextURL,
		0
	},
	{
		L"GetNextDescription",
		(PFNSSOMETHOD) SSOGetNextDescription,
		0
	},
	{
		L"GetPreviousURL",
		(PFNSSOMETHOD) SSOGetPreviousURL,
		0
	},
	{
		L"GetPreviousDescription",
		(PFNSSOMETHOD) SSOGetPreviousDescription,
		0
	},
	{
		L"GetNthURL",
		(PFNSSOMETHOD) SSOGetNthURL,
		0
	},
	{
		L"GetNthDescription",
		(PFNSSOMETHOD) SSOGetNthDescription,
		0
	},
	{
		L"GetListCount",
		(PFNSSOMETHOD) SSOGetListCount,
		0
	},
	{
		L"GetListIndex",
		(PFNSSOMETHOD) SSOGetListIndex,
		0
	},
	{
		L"About",
		(PFNSSOMETHOD) SSOAbout,
		0
	},
	{c_wszOnNewTemplate,			(PFNSSOMETHOD) OnNewTemplate,		0},
	{c_wszOnFreeTemplate,			(PFNSSOMETHOD) OnFreeTemplate,		0},
	{
		NULL,
		NULL,
		0
	}
};

PFNSSOMETHOD g_pfnssoDynamic = NULL;

LPSTR g_szSSOProgID = "MSWC.NextLink";

BOOL g_fPersistentSSO = TRUE;

GUID CDECL g_clsidSSO = CLSID_SSONextLink;

/*--------------------------------------------------------------------------+
|	Constants																|
+--------------------------------------------------------------------------*/

#define cnleNil			-1

#define cchLinkMax		256
#define cchDescrMax		1024
#define DEFAULTSTRSIZE	1024	// size of localized text string

/*--------------------------------------------------------------------------+
|	CLinkFile																|
+--------------------------------------------------------------------------*/

// We use the CDataFile/CDataFileGroup classes from WCSUTIL.LIB to get
// file lookup and hashing based on filename and notification when a file
// is changed.  Our CDataFile-derived CLinkFile builds a doubly-linked list
// of NLE structures, one per line of the data file.

typedef struct _nextlinkentry
{
	struct _nextlinkentry	*pnlePrev;
	struct _nextlinkentry	*pnleNext;
	int						inle;
	int						urltype;
	char					*szLink;
	OLECHAR					*wszLink;
	char					*szDescr;
	OLECHAR					*wszDescr;
} NLE, *PNLE;

class CLinkFile : public CDataFile
{
public:
	CLinkFile(LPSTR szDataPath, CDataFileGroup *pdfg);
	~CLinkFile();

	PNLE				NthPnle(int n);
	PNLE				PnleForCurrentPage(SSSTUFF *pstuff);

	PNLE				PnleHead()			{return m_pnleHead;};
	PNLE				PnleTail()			{return m_pnleTail;};
	int					Cnle();

	virtual void		FreeDataFile(void)	{ delete this; }

private:
	int					m_cnle;
	PNLE				m_pnleHead;
	PNLE				m_pnleTail;
	
	BOOL				FLoadFile();
	BOOL				FParseData(char *szData);
	BOOL				FAddEntry(char *szLink, char *szDescr);
	
	PNLE				PnleForLink(char *szLink);
	void				DeletePnleChain(PNLE pnle);
};

/*--------------------------------------------------------------------------+
|	CLinkFileGroup																|
+--------------------------------------------------------------------------*/

class CLinkFileGroup : public CDataFileGroup
	{
	public:
		virtual CDataFile *CreateDataFile(LPSTR szDataPath)
			{ return((CDataFile*)(new CLinkFile(szDataPath, this))); }
	};

CLinkFileGroup g_dfg;

/*--------------------------------------------------------------------------+
|	CLinkFile																|
+--------------------------------------------------------------------------*/

CLinkFile::CLinkFile(LPSTR szDataPath, CDataFileGroup *pdfg)
	: CDataFile(szDataPath, pdfg)
{
	m_cnle = cnleNil;
	m_pnleHead = NULL;
	m_pnleTail = NULL;
}

CLinkFile::~CLinkFile()
{
	this->DeletePnleChain(m_pnleHead);

#ifdef DEBUG
	::FillMemory(this, sizeof(this), 0xAC);
#endif
}

void
CLinkFile::DeletePnleChain(PNLE pnle)
{
	PNLE pnleNext;

	while (pnle)
		{
		pnleNext = pnle->pnleNext;
		
		if (pnle->wszLink)
			_MsnFree(pnle->wszLink);
		if (pnle->wszDescr)
			_MsnFree(pnle->wszDescr);
		if (pnle->szLink)
			_MsnFree(pnle->szLink);
		if (pnle->szDescr)
			_MsnFree(pnle->szDescr);
		_MsnFree(pnle);

		pnle = pnleNext;
		}
}

BOOL
CLinkFile::FAddEntry(char *szLink, char *szDescr)
{
	PNLE pnle = NULL;
	int cchLink = lstrlen(szLink);
	int cchDescr = lstrlen(szDescr);
	
	pnle = new NLE;
	if (!pnle)
		return FALSE;

	FillMemory(pnle, sizeof(NLE), 0);
	pnle->szLink = (char *)_MsnAlloc(cchLink + 1);
	pnle->szDescr = (char *)_MsnAlloc(cchDescr + 1);
	pnle->wszLink = (OLECHAR *)_MsnAlloc(sizeof(OLECHAR) * (cchLink + 1));
	pnle->wszDescr = (OLECHAR *)_MsnAlloc(sizeof(OLECHAR) * (cchDescr + 1));
	if (!pnle->wszLink || !pnle->wszDescr || !pnle->szLink || !pnle->szDescr)
		{
		if (pnle->wszLink)
			_MsnFree(pnle->wszLink);
		if (pnle->wszDescr)
			_MsnFree(pnle->wszDescr);
		if (pnle->szLink)
			_MsnFree(pnle->szLink);
		if (pnle->szDescr)
			_MsnFree(pnle->szDescr);
		_MsnFree(pnle);
		return FALSE;
		}

	lstrcpy(pnle->szLink, szLink);
	lstrcpy(pnle->szDescr, szDescr);
	MultiByteToWideChar(CP_ACP, 0, szLink, -1, pnle->wszLink, cchLink + 1);
	MultiByteToWideChar(CP_ACP, 0, szDescr, -1, pnle->wszDescr, cchDescr + 1);
	pnle->inle = ++m_cnle;
	pnle->urltype = UrlType(szLink);
	
	// possible cases:  1) no elements yet
	if (!m_pnleHead)
		{
		AssertSz(!m_pnleTail, "nice list handling");
		AssertSz(m_cnle == 1, "nice list handling, doofus");
		m_pnleHead = m_pnleTail = pnle;
		return TRUE;
		}
	else
		{
		AssertSz(m_pnleTail, "how can this be NULL");
		}
		
	// 2) only one element
	if (m_pnleHead == m_pnleTail)
		{
		AssertSz(m_cnle == 2, "more nice list handling");
		m_pnleTail = pnle;
		pnle->pnlePrev = m_pnleHead;
		m_pnleHead->pnleNext = pnle;
		return TRUE;
		}

	// 3) two or more elements
	AssertSz(m_cnle > 2, "ut oh, why do we have fewer than 3 elements in our list");
	m_pnleTail->pnleNext = pnle;
	pnle->pnlePrev = m_pnleTail;
	m_pnleTail = pnle;
	return TRUE;
}

// The data file consists of a series of lines.  Each line has at least two fields,
// separated by exactly one tab character.  The second field can be terminated either
// by a tab character or by the end of the line.
BOOL
CLinkFile::FParseData(char *szData)
{
	char *pch;
	char *pchLine;
	char *pchTab;
	char *szLink;
	char *szDescr;
	
	pch = szData;
	
	while (*pch)
		{
		pchLine = pch;
		while (*pch && (*pch != '\n' && *pch != '\r'))
			pch = CharNext(pch);
		
		// skip blank lines (this will also take care of crlf line termination)
		if (pch - pchLine <= 1)
			{
			pch++;
			continue;
			}

		pchTab = pchLine;
		while (pchTab < pch)
			{
			if (*pchTab == '\t')
				break;
			pchTab = CharNext(pchTab);
			}

		// there were no tabs on this line.  skip the whole line.
		if (pchTab >= pch)
			continue;
			
		*pchTab++ = 0;
		szLink = pchLine;
		
		szDescr = pchTab;
		while (pchTab < pch)
			{
			if (*pchTab == '\t')
				break;
			pchTab = CharNext(pchTab);
			}
		if ((pchTab == pch) && *pch)
			pch++;
		*pchTab++ = 0;
		
		if (!this->FAddEntry(szLink, szDescr))
			return FALSE;
		}

	return TRUE;
}

BOOL
CLinkFile::FLoadFile()
{
	BOOL	fRet = FALSE;
	char	*szData = NULL;
	DWORD	cb;
	DWORD	cbRead;
	HANDLE	hfile = INVALID_HANDLE_VALUE;

	m_cs.Lock();
	
	if (!m_cnle)
		{
		// there was a problem loading the file.
		goto LBail;
		}
	if (m_cnle != cnleNil)
		{
		// we've already successfully loaded!
		fRet = TRUE;
		goto LBail;
		}
	
	hfile = CreateFile(m_szDataPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hfile == INVALID_HANDLE_VALUE)
		goto LBail;
	
	cb = GetFileSize(hfile, NULL);
	if (cb == 0xFFFFFFFF)
		goto LBail;
		
	szData = (char *)_MsnAlloc(cb + 1);
	if (!szData)
		goto LBail;
		
	if (!ReadFile(hfile, szData, cb, &cbRead, NULL) || cb != cbRead)
		goto LBail;
	szData[cb] = 0;
	
	m_cnle = 0;
	fRet = this->FParseData(szData);
	
	if (fRet)
		{
		if (!this->FWatchFile())
			fRet = FALSE;
		}
		
LBail:
	m_cs.Unlock();
	
	if (szData)
		_MsnFree(szData);
	if (hfile != INVALID_HANDLE_VALUE)
		CloseHandle(hfile);
	
	return fRet;
}

// returns pointer within szLink after any path info, so after the last
// '/' or '\\'
char *
SzRelLink(char *szLink)
{
	char *pchLastSlash = szLink - 1;
	
	while (*szLink)
		{
		if (*szLink == '/' || *szLink == '\\')
			pchLastSlash = szLink;
		szLink = CharNext(szLink);
		}
	return pchLastSlash + 1;
}

PNLE
CLinkFile::PnleForLink(char *szLink)
{
	PNLE pnle;
	char *szRelLink = NULL;

	if (!m_pnleHead || !m_pnleTail || !m_cnle)
		return NULL;

	pnle = m_pnleHead;
	
	while (pnle)
		{
		switch (pnle->urltype)
			{
			case URL_TYPE_ABSOLUTE:
				// we can't ever match absolute URLs
				ExceptionId(g_clsidSSO, SSO_NEXTLINK, SSO_CANT_MATCH_ABSOLUTE_URLS);
				break;

			case URL_TYPE_LOCAL_ABSOLUTE:
				if (!lstrcmp(pnle->szLink, szLink))
					return pnle;
				break;
		
			case URL_TYPE_RELATIVE:
				// only compute this once
				if (!szRelLink)
					szRelLink = SzRelLink(szLink);
				if (!lstrcmp(pnle->szLink, szRelLink))
					return pnle;
				break;
			}
		
		pnle = pnle->pnleNext;
		}
	return NULL;
}

PNLE
CLinkFile::PnleForCurrentPage(SSSTUFF *pstuff)
{
	PNLE pnle = NULL;
	char *szLink;
	DWORD cb;
	IRequest *preq;
	VARIANT varPathInfo;
	IDispatch *pDispPathInfo;
	IScriptingContext *pcxt= NULL;
	HRESULT hr;

	m_cs.Lock();
	if (this->FLoadFile())
		{
		cb = MAX_PATH;
		if (FAILED(pstuff->punk->QueryInterface(IID_IScriptingContext, reinterpret_cast<void **>(&pcxt))))
			goto LBail;

		if (FAILED(pcxt->get_Request(&preq)))
			goto LBail;

		hr = preq->get_Item(L"PATH_INFO", &pDispPathInfo);
		preq->Release();
		if (FAILED(hr))
			goto LBail;

		V_VT(&varPathInfo) = VT_DISPATCH;
		V_DISPATCH(&varPathInfo) = pDispPathInfo;
		szLink = _SzFromVariant(&varPathInfo);

		if (!szLink)
			goto LBail;
		pnle = this->PnleForLink(szLink);
		_MsnFree(szLink);
		}
	else {
		//char	szError[256];
		ExceptionId(g_clsidSSO, SSO_NEXTLINK, SSO_CANNOT_OPEN_FILE);
		DebugOutputDebugString("MSWC.NextLink, bogus file, exception raised.\n");
		
	}
LBail:
	if (pcxt) {
		pcxt->Release();
	}

	::VariantClear(&varPathInfo);
	
	m_cs.Unlock();
	return pnle;
}

// n is 1-based!
PNLE
CLinkFile::NthPnle(int n)
{
	PNLE pnle = NULL;
	
	m_cs.Lock();
	if (this->FLoadFile())
		{
		pnle = m_pnleHead;
		while (pnle)
			{
			if (pnle->inle == n)
				break;
				
			pnle = pnle->pnleNext;
			}
		}
	m_cs.Unlock();
	return pnle;
}

int
CLinkFile::Cnle()
{
	int cnle = 0;

	m_cs.Lock();
	if (this->FLoadFile())
		cnle = m_cnle;

	m_cs.Unlock();
	return cnle;
}

/*--------------------------------------------------------------------------+
|	External Interface														|
+--------------------------------------------------------------------------*/

// This is weird, but i hate checking cArgs all over the place.  So since all
// my exported APIs have one of two arg formats [either function("data file")
// or function("data file", number)], I do all the arg checking in this
// routine.  If pn is non-NULL, it means we're expecting a number as a second
// argument (note that since the args come in in reverse order, we look at
// rgvarg[0]).
HRESULT
HrCheckParams(DISPPARAMS *pdispparams, int *pn)
{
	unsigned int cArgs = 1;

	if (pn)
		cArgs = 2;

	if (pdispparams->cArgs < cArgs)
		return DISP_E_PARAMNOTOPTIONAL;

	if (pdispparams->cArgs > cArgs)
		return DISP_E_PARAMNOTFOUND;

	if (pn)
		{
		if (!_FIntFromVariant(&pdispparams->rgvarg[0], pn))
			return E_FAIL;
		}

	return NOERROR;
}

HRESULT
SSOGetNextURL(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff)
{
	HRESULT		hr;
	char		szPathTranslated[MAX_PATH];
	CLinkFile	*plf;
	PNLE		pnle;
	
	
	
	hr = HrCheckParams(pdispparams, NULL);
	if (FAILED(hr))
		return hr;

	hr = SSOTranslateVirtualRoot(pdispparams->rgvarg, pstuff->punk, szPathTranslated, sizeof(szPathTranslated));
	if (FAILED(hr)) {
		ExceptionId(g_clsidSSO, SSO_NEXTLINK, SSO_CANNOT_XLATE_VIRT_ROOT_GETNEXTURL);
		return hr;
	}

	plf = (CLinkFile *)g_dfg.GetDataFile(szPathTranslated);
	if (!plf)
		return E_FAIL;

	pnle = plf->PnleForCurrentPage(pstuff);
	if (pnle)
		{
		pnle = pnle->pnleNext;
		// if no more, loop
		if (!pnle)
			pnle = plf->PnleHead();
		}
	else
		{
		pnle = plf->PnleTail();
		}
		
	if (!pnle)
		return E_FAIL;

	::VariantInit(pvarResult);
	pvarResult->vt = VT_BSTR;
	V_BSTR(pvarResult) = ::SysAllocString(pnle->wszLink);

	return NOERROR;
}

HRESULT
SSOGetNextDescription(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff)
{
	HRESULT		hr;
	char		szPathTranslated[MAX_PATH];
	CLinkFile	*plf;
	PNLE		pnle;
	
	hr = HrCheckParams(pdispparams, NULL);
	if (FAILED(hr)) {
		ExceptionId(g_clsidSSO, SSO_NEXTLINK, SSO_BAD_PARAMETERS_GETNEXTDESCRIPTION);
		return hr;
	}

	hr = SSOTranslateVirtualRoot(pdispparams->rgvarg, pstuff->punk, szPathTranslated, sizeof(szPathTranslated));
	if (FAILED(hr)) {
		ExceptionId(g_clsidSSO, SSO_NEXTLINK, SSO_CANNOT_XLATE_VIRT_ROOT_GETNEXTDESCRIPTION);
		return hr;
	}

	plf = (CLinkFile *)g_dfg.GetDataFile(szPathTranslated);
	if (!plf)
		return E_FAIL;

	pnle = plf->PnleForCurrentPage(pstuff);
	if (pnle)
		{
		pnle = pnle->pnleNext;
		// if no more, loop
		if (!pnle)
			pnle = plf->PnleHead();
		}
	else
		{
		pnle = plf->PnleTail();
		}
		
	if (!pnle)
		return E_FAIL;

	::VariantInit(pvarResult);
	pvarResult->vt = VT_BSTR;
	V_BSTR(pvarResult) = ::SysAllocString(pnle->wszDescr);

	return NOERROR;
}

HRESULT
SSOGetPreviousURL(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff)
{
	HRESULT		hr;
	char		szPathTranslated[MAX_PATH];
	CLinkFile	*plf;
	PNLE		pnle;
	
	hr = HrCheckParams(pdispparams, NULL);
	if (FAILED(hr)) {
		ExceptionId(g_clsidSSO, SSO_NEXTLINK, SSO_BAD_PARAMETERS_SSOGETPREVIOUSURL);
		return hr;
	}

	hr = SSOTranslateVirtualRoot(pdispparams->rgvarg, pstuff->punk, szPathTranslated, sizeof(szPathTranslated));
	if (FAILED(hr)) {
		ExceptionId(g_clsidSSO, SSO_NEXTLINK, SSO_CANNOT_XLATE_VIRT_ROOT_GETPREVIOUSURL);
		return hr;
	}

	plf = (CLinkFile *)g_dfg.GetDataFile(szPathTranslated);
	if (!plf)
		return E_FAIL;

	pnle = plf->PnleForCurrentPage(pstuff);
	if (pnle)
		{
		pnle = pnle->pnlePrev;
		// if no more, loop
		if (!pnle)
			pnle = plf->PnleTail();
		}
	else
		{
		pnle = plf->PnleHead();
		}
		
	if (!pnle)
		return E_FAIL;

	::VariantInit(pvarResult);
	pvarResult->vt = VT_BSTR;
	V_BSTR(pvarResult) = ::SysAllocString(pnle->wszLink);

	return NOERROR;
}

HRESULT
SSOGetPreviousDescription(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff)
{
	HRESULT		hr;
	char		szPathTranslated[MAX_PATH];
	CLinkFile	*plf;
	PNLE		pnle;
	
	hr = HrCheckParams(pdispparams, NULL);
	if (FAILED(hr)) {
		ExceptionId(g_clsidSSO, SSO_NEXTLINK, SSO_BAD_PARAMETERS_GETPREVDESCRIPTION);
		return hr;
	}

	hr = SSOTranslateVirtualRoot(pdispparams->rgvarg, pstuff->punk, szPathTranslated, sizeof(szPathTranslated));
	if (FAILED(hr)) {
		ExceptionId(g_clsidSSO, SSO_NEXTLINK, SSO_CANNOT_XLATE_VIRT_ROOT_GETPREVIOUSDDESCRIPTION);
		return hr;
	}

	plf = (CLinkFile *)g_dfg.GetDataFile(szPathTranslated);
	if (!plf)
		return E_FAIL;

	pnle = plf->PnleForCurrentPage(pstuff);
	if (pnle)
		{
		pnle = pnle->pnlePrev;
		// if no more, loop
		if (!pnle)
			pnle = plf->PnleTail();
		}
	else
		{
		pnle = plf->PnleHead();
		}
		
	if (!pnle)
		return E_FAIL;

	::VariantInit(pvarResult);
	pvarResult->vt = VT_BSTR;
	V_BSTR(pvarResult) = ::SysAllocString(pnle->wszDescr);

	return NOERROR;
}

HRESULT
SSOGetNthURL(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff)
{
	HRESULT		hr;
	char		szPathTranslated[MAX_PATH];
	CLinkFile	*plf;
	PNLE		pnle;
	int			n;
	
	hr = HrCheckParams(pdispparams, &n);
	if (FAILED(hr)) {
		ExceptionId(g_clsidSSO, SSO_NEXTLINK, SSO_BAD_PARAMETERS_GETNTHURL);
		return hr;
	}

	hr = SSOTranslateVirtualRoot(&pdispparams->rgvarg[1], pstuff->punk, szPathTranslated, sizeof(szPathTranslated));
	if (FAILED(hr)) {
		ExceptionId(g_clsidSSO, SSO_NEXTLINK, SSO_CANNOT_XLATE_VIRT_ROOT_GETNTHURL);
		return hr;
	}

	plf = (CLinkFile *)g_dfg.GetDataFile(szPathTranslated);
	if (!plf)
		return E_FAIL;

	pnle = plf->NthPnle(n);
	if (!pnle)
		pnle = plf->PnleTail();
		
	if (!pnle)
		return E_FAIL;

	::VariantInit(pvarResult);
	pvarResult->vt = VT_BSTR;
	V_BSTR(pvarResult) = ::SysAllocString(pnle->wszLink);

	return NOERROR;
}

HRESULT
SSOGetNthDescription(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff)
{
	HRESULT		hr;
	char		szPathTranslated[MAX_PATH];
	CLinkFile	*plf;
	PNLE		pnle;
	int			n;
	
	hr = HrCheckParams(pdispparams, &n);
	if (FAILED(hr)) {
		ExceptionId(g_clsidSSO, SSO_NEXTLINK, SSO_BAD_PARAMETERS_GETNTHDESCRIPTION);
		return hr;
	}

	hr = SSOTranslateVirtualRoot(&pdispparams->rgvarg[1], pstuff->punk, szPathTranslated, sizeof(szPathTranslated));
	if (FAILED(hr)) {
		ExceptionId(g_clsidSSO, SSO_NEXTLINK, SSO_CANNOT_XLATE_VIRT_ROOT_GETNTHDESCRIPTION);
		return hr;
	}

	plf = (CLinkFile *)g_dfg.GetDataFile(szPathTranslated);
	if (!plf)
		return E_FAIL;

	pnle = plf->NthPnle(n);
	if (!pnle)
		pnle = plf->PnleTail();
		
	if (!pnle)
		return E_FAIL;

	::VariantInit(pvarResult);
	pvarResult->vt = VT_BSTR;
	V_BSTR(pvarResult) = ::SysAllocString(pnle->wszDescr);

	return NOERROR;
}

HRESULT
SSOGetListCount(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff)
{
	HRESULT		hr;
	char		szPathTranslated[MAX_PATH];
	CLinkFile	*plf;
	
	hr = HrCheckParams(pdispparams, NULL);
	if (FAILED(hr)) {
		ExceptionId(g_clsidSSO, SSO_NEXTLINK, SSO_BAD_PARAMETERS_GETLISTCOUNT);
		return hr;
	}

	hr = SSOTranslateVirtualRoot(pdispparams->rgvarg, pstuff->punk, szPathTranslated, sizeof(szPathTranslated));
	if (FAILED(hr)) {
		ExceptionId(g_clsidSSO, SSO_NEXTLINK, SSO_CANNOT_XLATE_VIRT_ROOT_GETLISTCOUNT);
		return hr;
	}

	plf = (CLinkFile *)g_dfg.GetDataFile(szPathTranslated);
	if (!plf)
		return E_FAIL;

	::VariantInit(pvarResult);
	pvarResult->vt = VT_I4;
	V_I4(pvarResult) = plf->Cnle();

	return NOERROR;
}

HRESULT
SSOGetListIndex(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff)
{
	HRESULT		hr;
	char		szPathTranslated[MAX_PATH];
	CLinkFile	*plf;
	PNLE		pnle;
	int			inle;
	
	hr = HrCheckParams(pdispparams, NULL);
	if (FAILED(hr)) {
		ExceptionId(g_clsidSSO, SSO_NEXTLINK, SSO_BAD_PARAMETERS_GETLISTINDEX);
		return hr;
	}

	hr = SSOTranslateVirtualRoot(pdispparams->rgvarg, pstuff->punk, szPathTranslated, sizeof(szPathTranslated));
	if (FAILED(hr)) {
		ExceptionId(g_clsidSSO, SSO_NEXTLINK, SSO_CANNOT_XLATE_VIRT_ROOT_GETLISTINDEX);
		return hr;
	}

	plf = (CLinkFile *)g_dfg.GetDataFile(szPathTranslated);
	if (!plf)
		return E_FAIL;

	pnle = plf->PnleForCurrentPage(pstuff);
		
	if (pnle)
		inle = pnle->inle;
	else
		inle = 0;

	::VariantInit(pvarResult);
	pvarResult->vt = VT_I4;
	V_I4(pvarResult) = inle;

	return NOERROR;
}

HRESULT 
SSOAbout(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, SSSTUFF *pstuff)
{
	char	sz[MAX_PATH];
	CHAR	szNextLinkAboutFormat[DEFAULTSTRSIZE];
	OLECHAR	wsz[MAX_PATH];

#ifdef _DEBUG
	char	*szVersion = "Debug";
#else
	char	*szVersion = "Release";
#endif

	CchLoadStringOfId(SSO_NEXTLINK_ABOUT_FORMAT, szNextLinkAboutFormat, DEFAULTSTRSIZE);
	wsprintf(sz, szNextLinkAboutFormat, szVersion, __DATE__, __TIME__);
	::MultiByteToWideChar(CP_ACP, 0, sz, -1, wsz, sizeof(wsz) / sizeof(OLECHAR));

	VariantInit(pvarResult);
	pvarResult->vt = VT_BSTR;
	V_BSTR(pvarResult) = ::SysAllocString(wsz);


	return(NOERROR);
}
// ============================== OnNewTemplate ===============================
HRESULT 
OnNewTemplate(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, LONG *plUser)
{
#ifdef DEBUGMEMLEAK
//	_MsnAlloc(100);
#endif
	return NOERROR;
}

// ============================== OnFreeTemplate ==============================
HRESULT 
OnFreeTemplate(WORD wInvokeFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, LONG *plUser)
{
	return NOERROR;
}

/*--------------------------------------------------------------------------+
|	DllMain																	|
+--------------------------------------------------------------------------*/

BOOL WINAPI 
DllMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pvReserved)
{
	switch (ulReason)
		{
		case DLL_PROCESS_ATTACH:
		#ifdef DEBUGMEMLEAK
			 int tmpDbgFlag;

			tmpDbgFlag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
			tmpDbgFlag |= _CRTDBG_LEAK_CHECK_DF;
			_CrtSetDbgFlag(tmpDbgFlag);
			_CrtMemCheckpoint(&g_s1);		
		#endif
			break;
		case DLL_PROCESS_DETACH:
			#ifdef DEBUGMEMLEAK
			_CrtMemDumpAllObjectsSince(&g_s1);
			#endif
			break;
			
		default:
			break;
		}

	if (!SSODllMain(hInstance, ulReason, pvReserved))
		return(FALSE);

	return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\sso\ssobase\bldver.h ===
/*bldver.h*/

/******************************************************************
**
**  This file is automatically generated by BLDVER.EXE.
**  Do not attempt to change this file manually. Your changes will
**  be overwritten during the next build
**
*******************************************************************/

#if !defined(_BLDVER_H_)
#define _BLDVER_H_

#define BUILD_NUMBER              "70.12"         /* String version */
#define BUILD_NUM                 7012              /* int version */

#define MSN_CLIENT_VERSION        "5.00.7012\0" /* VERSIONINFO string */
#define MSN_CLIENT_VERSION_BINARY 5,0,0,7012        /* VERSIONINFO binary */
#define MSN_SERVER_VERSION        "5.00.7012\0" /* VERSIONINFO string */
#define MSN_SERVER_VERSION_BINARY 5,0,0,7012        /* VERSIONINFO binary */
#define MSN_ICPSRV_VERSION        "1.0.0.7012\0" /* VERSIONINFO string */
#define MSN_ICPSRV_VERSION_BINARY 1,0,0,7012        /* VERSIONINFO binary */



#if (defined(DEBUG) || defined(_DEBUG))
	#define BUILD_VERSION "70.12"
#else
	#define BUILD_VERSION BUILD_NUMBER
#endif

#endif // !defined(_BLDVER_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\sso\nextlink\nextlink.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Resources

File: nextlink.h

Owner: v-charca

This file contains constants for all resources used by NextLink

===================================================================*/


#define SSO_BEGIN					100

//
// General errors
//
#define SSO_GENERAL_BEGIN									100
#define SSO_NOSVR											SSO_GENERAL_BEGIN
#define SSO_ADROT									
#define	SSO_NEXTLINK										SSO_GENERAL_BEGIN + 1
#define	SSO_CANT_MATCH_ABSOLUTE_URLS						SSO_GENERAL_BEGIN + 2
#define	SSO_CANNOT_OPEN_FILE								SSO_GENERAL_BEGIN + 3
#define	SSO_BAD_PARAMETERS_GETLISTCOUNT						SSO_GENERAL_BEGIN + 4
#define	SSO_CANNOT_XLATE_VIRT_ROOT_GETLISTCOUNT				SSO_GENERAL_BEGIN + 5
#define	SSO_BAD_PARAMETERS_GETLISTINDEX						SSO_GENERAL_BEGIN + 6
#define	SSO_CANNOT_XLATE_VIRT_ROOT_GETLISTINDEX				SSO_GENERAL_BEGIN + 7
#define	SSO_BAD_PARAMETERS_GETNEXTDESCRIPTION				SSO_GENERAL_BEGIN + 8
#define	SSO_CANNOT_XLATE_VIRT_ROOT_GETNEXTDESCRIPTION		SSO_GENERAL_BEGIN + 9
#define	SSO_BAD_PARAMETERS_GETNEXTURL						SSO_GENERAL_BEGIN + 10
#define	SSO_CANNOT_XLATE_VIRT_ROOT_GETNEXTURL				SSO_GENERAL_BEGIN + 11
#define	SSO_BAD_PARAMETERS_GETNTHDESCRIPTION				SSO_GENERAL_BEGIN + 12
#define	SSO_CANNOT_XLATE_VIRT_ROOT_GETNTHDESCRIPTION		SSO_GENERAL_BEGIN + 13
#define	SSO_BAD_PARAMETERS_GETNTHURL						SSO_GENERAL_BEGIN + 14
#define	SSO_CANNOT_XLATE_VIRT_ROOT_GETNTHURL				SSO_GENERAL_BEGIN + 15
#define	SSO_BAD_PARAMETERS_GETPREVDESCRIPTION				SSO_GENERAL_BEGIN + 16
#define	SSO_CANNOT_XLATE_VIRT_ROOT_GETPREVIOUSDDESCRIPTION	SSO_GENERAL_BEGIN + 17
#define	SSO_BAD_PARAMETERS_SSOGETPREVIOUSURL				SSO_GENERAL_BEGIN + 18
#define	SSO_CANNOT_XLATE_VIRT_ROOT_GETPREVIOUSURL			SSO_GENERAL_BEGIN + 19

#define	SSO_NEXTLINK_ABOUT_FORMAT							SSO_GENERAL_BEGIN + 20
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\sso\nextlink\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by nextlink.rc
//

// Next default values for new objects
// 

#define	IDE_UNEXPECTED					8000

#define IDE_ERROR_FILENOTFOUND			8100

#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\sso\ssobase\makefile.inc ===
#
# Supplemental rules for generating Type library.
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\sso\ssobase\denpre.h ===
#pragma warning(disable:4237)
#undef _WIN32_WINNT
#define _WIN32_WINNT    0x0400
#define _CRYPT32_

#include <ctype.h>
#include <stdlib.h>     // for itow
#include <crtdbg.h>
#include <malloc.h>
#include <time.h>
#include <stdio.h>
#include <limits.h>
#include <windows.h>
#include <winerror.h>
#include <wtypes.h>
#include <process.h>

#include <rpc.h>
#include <rpcndr.h>
#include <ole2.h>
#include <olectl.h>
#include <oleauto.h>
#include <cguid.h>      // for GUID_NULL


#include "except.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\sso\ssobase\genhash.cpp ===
/*
**	GENHASH.CPP
**	Sean P. Nolan
**	
**	Generic UNICODE-tagged hash table.
*/

#pragma warning(disable: 4237)		// disable "bool" reserved

#include "wcsutil.h"

/*--------------------------------------------------------------------------+
|	CGenericHash															|
+--------------------------------------------------------------------------*/

CGenericHash::CGenericHash(DWORD cBuckets)
{
	m_chi = cBuckets;
	m_rgphi = NULL;
}

CGenericHash::~CGenericHash()
{
	if (m_rgphi)
		{
		this->RemoveAll();
		_MsnFree(m_rgphi);
		}
}

LPVOID
CGenericHash::PvFind(OLECHAR *wszName)
{
	HITEM *phi = this->FindItem(wszName, NULL);

	return(phi ? phi->pvData : NULL);
}

BOOL 
CGenericHash::FAdd(OLECHAR *wszName, LPVOID pv)
{
	BOOL fRet = FALSE;
	HITEM	**pphiHead, *phiNew;

	this->Lock();

	this->FEnsureBuckets();

	if (m_rgphi &&
		(phiNew = (HITEM*) _MsnAlloc(sizeof(HITEM))))
		{
		// values
		if (!(phiNew->bstrName = ::SysAllocString(wszName)))
			{
			_MsnFree(phiNew);
			this->Unlock();
			return(FALSE);
			}

		phiNew->pvData = pv;

		// link it into the list
		pphiHead = &(m_rgphi[this->GetHashValue(wszName)]);

		phiNew->phiPrev = NULL;
		phiNew->phiNext = *pphiHead;

		if (*pphiHead)
			(*pphiHead)->phiPrev = phiNew;

		*pphiHead = phiNew;
		fRet = TRUE;
		}

	this->Unlock();
	return(fRet);
}

void 
CGenericHash::Remove(OLECHAR *wszName)
{
	HITEM *phi, **pphiHead;

	this->Lock();
	if (phi = this->FindItem(wszName, &pphiHead))
		this->RemoveItem(pphiHead, phi);
	this->Unlock();
}

void 
CGenericHash::RemoveAll()
{
	HITEM	**pphi;
	DWORD	ihi;

	this->Lock();
	if (m_rgphi)
		{
		for (pphi = m_rgphi, ihi = 0; ihi < m_chi; ++ihi, ++pphi)
			{
			while (*pphi)
				this->RemoveItem(pphi, *pphi);
			}
		}
	this->Unlock();
}

BOOL
CGenericHash::FEnsureBuckets()
{
	if (!m_rgphi)
		{
		if (m_rgphi = (HITEM**) _MsnAlloc(m_chi * sizeof(HITEM*)))
			::FillMemory(m_rgphi, m_chi * sizeof(HITEM*), 0);
		}

	return(m_rgphi != NULL);
}

DWORD	
CGenericHash::GetHashValue(OLECHAR *wsz)
{
	DWORD	dwSum = 0;
	OLECHAR	*pwch;

	// nyi - a real hash function
	for (pwch = wsz; *pwch; ++pwch)
		dwSum += (DWORD) *pwch;

	return(dwSum % m_chi); 
}

void	
CGenericHash::FreeHashData(LPVOID pv)
{
	// default is to do nothing
	return;
}

HITEM*
CGenericHash::FindItem(OLECHAR *wszName, HITEM ***ppphiHead)
{
	HITEM	**pphiHead;
	HITEM	*phi;

	if (!m_rgphi)
		{
		if (ppphiHead)
			*ppphiHead = NULL;

		return(NULL);
		}

	pphiHead = &(m_rgphi[this->GetHashValue(wszName)]);

	if (ppphiHead)
		*ppphiHead = pphiHead;

	phi = *pphiHead;
	while (phi && wcsicmp(wszName, phi->bstrName))
		phi = phi->phiNext;

	return(phi);
}

void	
CGenericHash::RemoveItem(HITEM **pphiHead, HITEM *phi)
{
	if (phi->phiPrev)
		phi->phiPrev->phiNext = phi->phiNext;

	if (phi->phiNext)
		phi->phiNext->phiPrev = phi->phiPrev;

	if (phi == *pphiHead)
		*pphiHead = phi->phiNext;

	::SysFreeString(phi->bstrName);
	this->FreeHashData(phi->pvData);
	_MsnFree(phi);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\sso\ssobase\osinfo.h ===
//	Glob data object
class COSInfo
	{
private:
	//Private Data
	BOOL 		m_fWinNT;				// TRUE if this is Windows NT; false otherwise
	BOOL		m_fInited;	
public:
	BOOL 		fWinNT()						{return m_fWinNT;};					// TRUE if this is Windows NT; false otherwise
	HRESULT 	Init(void);
	};

#define OSInfo(elem)				(gOSInfo.elem())
#define FIsWinNT() 				(OSInfo(fWinNT))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\sso\ssobase\sockets.cpp ===
/*
**  SOCKETS.CPP
**  Davidsan
**  
**  Winsock-related utilities
*/

#pragma warning(disable: 4237)      // disable "bool" reserved

#include "wcsutil.h"

/*--------------------------------------------------------------------------+
|   CSocketCollection                                                       |
+--------------------------------------------------------------------------*/
// note!  this assumes that WSAStartup() has been called before ::FInit()!

// public
BOOL
CSocketCollection::FInit(int cRsrc, char *szServer, USHORT usPort)
{
    if (!CResourceCollection::FInit(cRsrc))
        return FALSE;
        
    return this->FReinit(szServer, usPort);
}

// public
BOOL
CSocketCollection::FReinit(char *szServer, USHORT usPort)
{
    PHOSTENT phe;

    this->CleanupAll((PVOID)INVALID_SOCKET);
    
    if (lstrlen(szServer) >= MAX_PATH)
        return FALSE;

    lstrcpy(m_szServer, szServer);
    m_usPort = usPort;
    FillMemory(&m_sin, 0, sizeof(m_sin));
    m_sin.sin_family = AF_INET;
    m_sin.sin_port = htons(usPort);
    if (*szServer >= '0' && *szServer <= '9')
        {
        m_sin.sin_addr.s_addr = inet_addr(szServer);
        if (m_sin.sin_addr.s_addr == INADDR_NONE)
            return FALSE;
        }
    else
        {
        phe = gethostbyname(szServer);
        if (!phe)
            return FALSE;
        CopyMemory(&m_sin.sin_addr, phe->h_addr, phe->h_length);
        }

    return TRUE;
}

SOCKET
CSocketCollection::ScFromHrs(HRS hrs)
{
    PRS prs = (PRS) hrs;
    
    if (!prs || !prs->fValid)
        return INVALID_SOCKET;
    
    return HANDLE_TO_SOCKET(prs->pv);
}

BOOL
CSocketCollection::FInitResource(PRS prs)
{
    SOCKET sc;

    if (!prs)
        return FALSE;
    prs->pv = (PVOID)INVALID_SOCKET;
    sc = socket(PF_INET, SOCK_STREAM, 0);
    if (sc < 0)
        return FALSE;
    if (connect(sc, (PSOCKADDR)&m_sin, sizeof(m_sin)) < 0)
        return FALSE;
    
    prs->pv = (PVOID)sc;
    return TRUE;
}

void
CSocketCollection::CleanupResource(PRS prs)
{
    if (!prs)
        return;
    
    if (HANDLE_TO_SOCKET(prs->pv) != INVALID_SOCKET)
        closesocket(HANDLE_TO_SOCKET(prs->pv));
        
    prs->pv = (PVOID)INVALID_SOCKET;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\sso\ssobase\ssobase.cpp ===
/*
**  SSOBASE.CPP
**  Sean P. Nolan
**
**  Guts of the SSO Framework
*/

#pragma warning(disable: 4237)      // disable "bool" reserved

#define INITGUID
#include <stdio.h>
#include <stdlib.h>
#include "denpre.h"
#include "osinfo.h"
#include "ssobase.h"
#define MAX_RESSTRINGSIZE       1024
#define DEFAULTSTRSIZE          1024    // size of localized text string
/*--------------------------------------------------------------------------+
|   Perfmon Counter Stuff                                                   |
+--------------------------------------------------------------------------*/

extern void FreePerfGunk();
extern void InitPerfSource();

// add new externs here for other counters.  these should all go in the
// shared MMF.
extern int *g_rgcInvokes;
extern int *g_rgcGetNames;
extern DWORD *g_rgctixLatencyMax;
extern int *g_rgcTimeSamples;
extern int *g_rgiTimeSampleCurrent;
extern DWORD *g_rgTimeSamples;
CCritSec g_csTimeCounter;

// forward reference
INT CwchLoadStringOfId(UINT id, WCHAR *sz, INT cchMax);

/*--------------------------------------------------------------------------+
|   Globals                                                                 |
+--------------------------------------------------------------------------*/

DWORD       g_cObjs = 0;
HINSTANCE   g_hinst = (HINSTANCE) NULL;
COSInfo gOSInfo;

OLECHAR *c_wszOnNewTemplate = L"OnStartPage";
OLECHAR *c_wszOnFreeTemplate = L"OnEndPage";

#define DISPID_ONNEWTEMPLATE    ((DISPID)10)

// Control of OutputDebugString
#ifdef _DEBUG
BOOL gfOutputDebugString = TRUE;
#else
BOOL gfOutputDebugString = FALSE;
#endif

/*--------------------------------------------------------------------------+
|   SSO Dispatch Interface                                                  |
+--------------------------------------------------------------------------*/

class CSSODispatch : public IDispatch
    {
    private:
        ULONG           m_cRef;
        LPUNKNOWN       m_punkOuter;

        LONG            m_lUser;
        IUnknown        *m_punk;            // IUnknown of the denali Context object
        SSOMETHOD       *m_rgssomethodDynamic;
        DWORD           m_cDynMethCur;
        DWORD           m_cDynMethMax;
        CSSODispatchSupportErr  m_SSODispatchSupportErrInfo;
        int             m_fInNewTemplate;

    public:
        CSSODispatch(LPUNKNOWN punkOuter);
        ~CSSODispatch(void);

        // IUnknown methods
        STDMETHODIMP            QueryInterface(REFIID riid,
                                               LPVOID FAR* ppvObj);
        STDMETHODIMP_(ULONG)    AddRef(void);
        STDMETHODIMP_(ULONG)    Release(void);

        // IDispatch methods
        STDMETHODIMP    GetTypeInfoCount(UINT FAR* pctinfo);

        STDMETHODIMP    GetTypeInfo(UINT itinfo, LCID lcid,
                                    ITypeInfo FAR* FAR* pptinfo);

        STDMETHODIMP    GetIDsOfNames(REFIID riid,
                                      OLECHAR FAR* FAR* rgwszNames,
                                      UINT cNames,
                                      LCID lcid,
                                      DISPID FAR* rgdispid);

        STDMETHODIMP    Invoke(DISPID dispidMember,
                               REFIID riid,
                               LCID lcid,
                               WORD wFlags,
                               DISPPARAMS FAR* pdispparams,
                               VARIANT FAR* pvarResult,
                               EXCEPINFO FAR* pexcepinfo,
                               UINT FAR* puArgErr);

    private:
        // Helper Methods
        HRESULT GetDynamicDispid(OLECHAR *wszName, DISPID *pdispid);
        HRESULT FreeDynamicMethods(void);
    };

/*--------------------------------------------------------------------------+
|   SSO Dispatch Implementation                                             |
+--------------------------------------------------------------------------*/

#pragma warning (disable : 4355)
CSSODispatch::CSSODispatch(LPUNKNOWN punkOuter)
    : m_SSODispatchSupportErrInfo(this)
#pragma warning (default : 4355)

{
    m_cRef = 0;
    m_punkOuter = punkOuter;

    m_lUser = 0;
    m_punk = NULL;
    m_rgssomethodDynamic = NULL;
    m_cDynMethCur = 0;
    m_cDynMethMax = 0;
    m_fInNewTemplate = FALSE;

    ++g_cObjs;
}

CSSODispatch::~CSSODispatch()
{
    this->FreeDynamicMethods();

    if (m_punk)
        m_punk->Release();

    --g_cObjs;

#ifdef DEBUG
    ::FillMemory(this, sizeof(this), 0xAC);
#endif
}

/*--------------------------------------------------------------------------+
|   IUnknown                                                                |
+--------------------------------------------------------------------------*/

STDMETHODIMP
CSSODispatch::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;

   /* if (IsEqualIID(riid, IID_IUnknown)    ||
        IsEqualIID(riid, IID_IDispatch))
        {
        *ppvObj = (LPVOID) this;
        }
    */

    if (IsEqualIID(riid, IID_IUnknown)) {
        DebugOutputDebugString("IID_IUnknown Queried\n");
        *ppvObj = (LPVOID) this;
    } else if (IsEqualIID(riid, IID_IDispatch)) {
        DebugOutputDebugString("IID_IDispatch Queried\n");
        *ppvObj = (LPVOID) this;
    }

    else if (IsEqualIID(riid, IID_ISupportErrorInfo)) {
        DebugOutputDebugString("IID_ISupportErrorInfo Queried\n");
        *ppvObj = &m_SSODispatchSupportErrInfo;
    }
    else
        {
        // dunno
        return(E_NOINTERFACE);
        }

    ((LPUNKNOWN)*ppvObj)->AddRef();
    return(NOERROR);
}

STDMETHODIMP_(ULONG)
CSSODispatch::AddRef()
{
    return(++m_cRef);
}

STDMETHODIMP_(ULONG)
CSSODispatch::Release()
{
    if (!--m_cRef)
        {
        delete this;
        return(0);
        }

    return(m_cRef);
}

/*--------------------------------------------------------------------------+
|   IDispatch                                                               |
+--------------------------------------------------------------------------*/

STDMETHODIMP
CSSODispatch::GetTypeInfoCount(UINT FAR* pctinfo)
{
    return(E_NOTIMPL);
}

STDMETHODIMP
CSSODispatch::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo)
{
    return(E_NOTIMPL);
}

STDMETHODIMP
CSSODispatch::GetIDsOfNames(REFIID riid, OLECHAR FAR* FAR* rgwszNames,
                        UINT cNames, LCID lcid, DISPID FAR* rgdispid)
{
    SSOMETHOD   *psm;
    DISPID      *pdispid;
    OLECHAR     **pwsz;
    UINT        iName;
    HRESULT     hr = NOERROR;

    for (pwsz = rgwszNames, iName = 0, pdispid = rgdispid;
         iName < cNames;
         ++pwsz, ++iName, ++pdispid)
        {
        if (!m_fInNewTemplate && !wcsicmp(*pwsz, c_wszOnNewTemplate))
            {
            // special-case OnNewTemplate until we get an invoke on
            // it... we do this so that we can tuck away the IHTMLTemplate
            *pdispid = DISPID_ONNEWTEMPLATE;
            }
        else
            {
            for (psm = (SSOMETHOD*) g_rgssomethod; psm->wszName; ++psm)
                if (!wcsicmp(psm->wszName, *pwsz))
                    break;

            if (psm->wszName)
                {
                if (g_rgcGetNames)
                    InterlockedIncrement((long *)&g_rgcGetNames[psm->iMethod]);

                *pdispid = (DISPID) psm;
                }
            else
                {
                if (SUCCEEDED(this->GetDynamicDispid(*pwsz, pdispid)))
                    {
                    if (g_rgcGetNames)
                        InterlockedIncrement((long*)&g_rgcGetNames[0]);
                    }
                else
                    {
                    hr = DISP_E_UNKNOWNNAME;
                    *pdispid = DISPID_UNKNOWN;
                    }
                }
            }
        }

    return(hr);
}

STDMETHODIMP
CSSODispatch::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
                 DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult,
                 EXCEPINFO FAR* pexcepinfo, UINT FAR* puArgErr)
{
    HRESULT     hr;
    SSOMETHOD   sm;
    SSOMETHOD   *psm;
    SSSTUFF     ssstuff;
    DWORD       ctixBefore, ctix;
    DWORD       *rgSamples;
    int         i;
    OLECHAR     wszNoServer[DEFAULTSTRSIZE];

    InitPerfSource();

    if (puArgErr)
        *puArgErr = 0;

    /*
     * Bug 1147:  If VBS does an invoke on the object with
     * wFlags == DISPATCH_PROPERTYPUTREF, cNamedArgs == 1 (as
     * required by PUT and PUTREF), the object should return
     * something like DISP_E_MEMBERNOTFOUND.
     */

    if ((wFlags & DISPATCH_PROPERTYPUTREF) &&
        (pdispparams->cNamedArgs == 1))
        return(DISP_E_MEMBERNOTFOUND);

    if (pdispparams->cNamedArgs)
        return(DISP_E_NONAMEDARGS);

    if (dispidMember == DISPID_ONNEWTEMPLATE)
        {
        // careful!!! We lied and said that there was an OnNewTemplate,
        // but we really don't know.

        // first, remember the ecb thing

        // remove existing
        if (m_punk)
            m_punk->Release();

        if (m_punk = V_UNKNOWN(pdispparams->rgvarg))
            m_punk->AddRef();

        // now, see if there really IS an OnNewTemplate. If so, make
        // dispidMember point at it and use that. If not, return NOERROR.
        m_fInNewTemplate = TRUE;
        hr = this->GetIDsOfNames(g_clsidSSO,
                                       &c_wszOnNewTemplate,
                                       1,
                                       LOCALE_USER_DEFAULT,
                                       &dispidMember);
        m_fInNewTemplate = FALSE;
        if (FAILED(hr))
            {
            return(NOERROR);
            }
        }

    if (dispidMember == DISPID_VALUE)
        {
        if (!g_pfnssoDynamic)
            return(DISP_E_MEMBERNOTFOUND);

        psm = &sm;

        sm.wszName[0] = 0;
        sm.iMethod = 0;
        sm.pfn = g_pfnssoDynamic;
        }
    else
        {
        psm = (SSOMETHOD*) dispidMember;
        }


    if (::IsBadReadPtr(psm, sizeof(SSOMETHOD)))
        return(E_FAIL);

    /*
     * Bug 792:  If we were created by the VBS command
     * "CreateObject", instead of Denali's Server.CreateObject method
     * then the pUnk to Denali's context object will be null, and we cant
     * do anything.  In that case, fail any invoke.
     *
     * CONSIDER: can any SSO control live under these circumstances?
     */
    if (m_punk == NULL)
        {

        pexcepinfo->bstrSource = NULL;          // UNDONE: Can we fill something in here?
        CwchLoadStringOfId(SSO_NOSVR, wszNoServer, DEFAULTSTRSIZE);
        pexcepinfo->bstrDescription = SysAllocString(wszNoServer);
        pexcepinfo->scode = E_UNEXPECTED;

        return(DISP_E_EXCEPTION);
        }

    if (g_rgcInvokes)
        InterlockedIncrement((long *)&g_rgcInvokes[psm->iMethod]);

    ssstuff.lUser = m_lUser;
    ssstuff.punk = m_punk;
    ssstuff.wszMethodName = psm->wszName;

    ctixBefore = GetTickCount();
    hr = (psm->pfn)(wFlags, pdispparams, pvarResult, &ssstuff);
    ctix = GetTickCount() - ctixBefore;

    if (g_rgctixLatencyMax)
        {
        if (ctix > g_rgctixLatencyMax[psm->iMethod])
            g_rgctixLatencyMax[psm->iMethod] = ctix;
        }
    // there's weird code in the following section.  we do it that way because
    // we are NOT sharing a critsec with the code in SSOPerfCollect that looks
    // at these arrays.  so we want to update the arrays in such an order that
    // there is never inconsistent data.
    if (g_rgTimeSamples)
        {
        g_csTimeCounter.Lock();
        rgSamples = &g_rgTimeSamples[psm->iMethod * cTimeSamplesMax];
        if (g_rgcTimeSamples[psm->iMethod] == cTimeSamplesMax)
            {
            i = g_rgiTimeSampleCurrent[psm->iMethod];
            rgSamples[i] = ctix;
            i = (i++) % cTimeSamplesMax;
            g_rgiTimeSampleCurrent[psm->iMethod] = i;
            }
        else
            {
            i = (g_rgcTimeSamples[psm->iMethod]);
            rgSamples[i++] = ctix;
            g_rgcTimeSamples[psm->iMethod] = i;
            }
        g_csTimeCounter.Unlock();
        }

    m_lUser = ssstuff.lUser;


    if (FAILED(hr)){
        IErrorInfo *pIErr;

        // BUG FIX: 1111 removed SysAllocString calls, the GetSource and
        // GetDescription allocate memory that is released in Denali's error.cpp
        // the string allocated by SysAllocString were overwritten and leaked.

        if(SUCCEEDED(GetErrorInfo(0L, &pIErr))) {

            if (NULL != pIErr)
            {
                pIErr->GetSource(&pexcepinfo->bstrSource);
                pIErr->GetDescription(&pexcepinfo->bstrDescription);

                pIErr->Release();
                pexcepinfo->scode = hr;
                hr = DISP_E_EXCEPTION;
            }
        }

    }

    return(hr);
}

/*--------------------------------------------------------------------------+
|   Helper Methods                                                          |
+--------------------------------------------------------------------------*/

#define cDynMethChunk   (16)

HRESULT
CSSODispatch::GetDynamicDispid(OLECHAR *wszName, DISPID *pdispid)
{
    SSOMETHOD   *psm;
    DWORD       imeth;
    SSOMETHOD   *rgsmT;
    DWORD       cb;
    OLECHAR     *wszNew;

    if (!g_pfnssoDynamic)
        return(E_NOTIMPL);

    for (psm = m_rgssomethodDynamic, imeth = 0;
        imeth < m_cDynMethCur;
        ++psm, ++imeth)
        {
        if (!wcsicmp(psm->wszName, wszName))
            break;
        }

    if (imeth == m_cDynMethCur)
        {
        // see if there's room in the array
        if (m_cDynMethCur == m_cDynMethMax)
            {
            cb = ((m_cDynMethCur + cDynMethChunk) * sizeof(SSOMETHOD));

            if (m_rgssomethodDynamic)
                rgsmT = (SSOMETHOD*) _MsnRealloc(m_rgssomethodDynamic, cb);
            else
                rgsmT = (SSOMETHOD*) _MsnAlloc(cb);

            if (!rgsmT)
                {
                // safe to return here because we haven't dinked
                // with the array or counter members at all so it's
                // all still consistent
                return(E_OUTOFMEMORY);
                }

            m_rgssomethodDynamic = rgsmT;
            m_cDynMethMax += cDynMethChunk;
            }

        // method name not found; add it to the array
        psm = &(m_rgssomethodDynamic[m_cDynMethCur]);

        cb = ((lstrlenW(wszName) + 1) * sizeof(OLECHAR));
        if (!(wszNew = (OLECHAR*) _MsnAlloc(cb)))
            {
            // safe to return here because m_rgssomethodDynamic
            // and m_cDynMethMax are in sync; we haven't changed
            // m_cDynMethCur yet, so we can bail.
            // all still consistent
            return(E_OUTOFMEMORY);
            }

        ::CopyMemory(wszNew, wszName, cb);
        psm->wszName = wszNew;
        psm->pfn = g_pfnssoDynamic;
        psm->iMethod = 0;

        ++m_cDynMethCur;
        }

    // ok, now psm is pointing at the right thing. return it!
    *pdispid = (DISPID) psm;
    return(NOERROR);
}

HRESULT
CSSODispatch::FreeDynamicMethods(void)
{
    SSOMETHOD   *psm;
    DWORD       imeth;

    if (m_rgssomethodDynamic)
        {
        for (psm = m_rgssomethodDynamic, imeth = 0;
            imeth < m_cDynMethCur;
            ++psm, ++imeth)
            {
            if (psm->wszName)
                _MsnFree(psm->wszName);
            }

        _MsnFree(m_rgssomethodDynamic);
        }

    return(NOERROR);
}

/*--------------------------------------------------------------------------+
|   Class Factory Interface                                                 |
+--------------------------------------------------------------------------*/

class CSSOClassFactory : public IClassFactory
    {
    protected:
        ULONG m_cRef;

    public:
        CSSOClassFactory(void);
        ~CSSOClassFactory(void);

        // IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, LPVOID*);
        STDMETHODIMP         LockServer(BOOL);
    };

/*--------------------------------------------------------------------------+
|   Class Factory Implementation
+--------------------------------------------------------------------------*/

CSSOClassFactory::CSSOClassFactory()
{
    m_cRef = 0;
    ++g_cObjs;
}

CSSOClassFactory::~CSSOClassFactory()
{
    --g_cObjs;
}

STDMETHODIMP
CSSOClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!IsEqualIID(riid, IID_IUnknown) &&
        !IsEqualIID(riid, IID_IClassFactory))
        {
        *ppv = NULL;
        return(E_NOINTERFACE);
        }

    *ppv = (LPVOID) this;
    this->AddRef();
    return(NOERROR);
}

STDMETHODIMP_(ULONG)
CSSOClassFactory::AddRef(void)
{
    return(++m_cRef);
}

STDMETHODIMP_(ULONG)
CSSOClassFactory::Release(void)
{
    if (!(--m_cRef))
        {
        delete this;
        return(0);
        }
    else
        return m_cRef;
}

STDMETHODIMP
CSSOClassFactory::CreateInstance(LPUNKNOWN punkOuter, REFIID riid,
                                 LPVOID *ppvObj)
{
    CSSODispatch    *psso;
    HRESULT         hr;

    *ppvObj = NULL;

    // Verify that a controlling unknown asks for IUnknown
    if (NULL != punkOuter && !IsEqualIID(riid, IID_IUnknown))
        return(E_NOINTERFACE);

    // Create the object passing function to notify on destruction.
    if (!(psso = new CSSODispatch(punkOuter)))
        return(E_OUTOFMEMORY);

    hr = psso->QueryInterface(riid, ppvObj);

    // Kill the object if initial creation or HrInit failed.
    if (FAILED(hr))
        delete psso;

    return(hr);
}

STDMETHODIMP
CSSOClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        ++g_cObjs;
    else
        --g_cObjs;

    return(NOERROR);
}

/*--------------------------------------------------------------------------+
|   OLE Entrypoints                                                         |
+--------------------------------------------------------------------------*/

HRESULT FAR PASCAL
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    if (!IsEqualCLSID(rclsid, g_clsidSSO))
        return(ResultFromScode(E_FAIL));

    // Check that we can provide the interface
    if (!IsEqualIID(riid, IID_IUnknown) &&
        !IsEqualIID(riid, IID_IClassFactory))
        return(ResultFromScode(E_NOINTERFACE));

    // Return our IClassFactory for MosShell objects
    *ppv= (LPVOID) new CSSOClassFactory;

    if (NULL == *ppv)
        return(ResultFromScode(E_OUTOFMEMORY));

    // AddRef the object through any interface we return
    ((LPUNKNOWN)*ppv)->AddRef();

    return(NOERROR);
}

STDAPI
DllCanUnloadNow(void)
{
    return(ResultFromScode((g_fPersistentSSO || g_cObjs) ? S_FALSE : S_OK));
}

/*--------------------------------------------------------------------------+
|   Self-Registration                                                       |
+--------------------------------------------------------------------------*/

const char *g_szClsidKey = "CLSID\\";
const char *g_szServerKey = "CLSID\\%s\\InProcServer32";
const char *g_szServerProgIDKey = "CLSID\\%s\\ProgID";
const char *g_szThreadingModel = "ThreadingModel";
const char *g_szApartment = "Apartment";
const char *g_szProgIDKey = "%s\\CLSID";

STDAPI
DllRegisterServer(void)
{
    HKEY    hkey;
    LONG    dwErr;
    char    szKey[MAX_PATH];
    char    szModule[MAX_PATH];
    char    szClsid[MAX_PATH];

    // create the "inprocserver32" key
    _AnsiStringFromGuid(g_clsidSSO, szClsid);
    wsprintf(szKey, g_szServerKey, szClsid);
    dwErr = ::RegCreateKey(HKEY_CLASSES_ROOT, szKey, &hkey);
    if (dwErr != ERROR_SUCCESS)
        return(HRESULT_FROM_WIN32(dwErr));

    // set the default value (path to server)
    ::GetModuleFileName(g_hinst, szModule, sizeof(szModule));
    ::GetShortPathName(szModule, szModule, sizeof(szModule));
    dwErr = ::RegSetValueEx(hkey, NULL, 0, REG_SZ,
            (LPBYTE) szModule, lstrlen(szModule) + 1);
    if (dwErr != ERROR_SUCCESS)
        {
        ::RegCloseKey(hkey);
        return(HRESULT_FROM_WIN32(dwErr));
        }

    // set the threadng model
    dwErr = ::RegSetValueEx(hkey, g_szThreadingModel, 0, REG_SZ,
            (LPBYTE) g_szApartment, lstrlen(g_szApartment) + 1);
    if (dwErr != ERROR_SUCCESS)
        {
        ::RegCloseKey(hkey);
        return(HRESULT_FROM_WIN32(dwErr));
        }

    ::RegCloseKey(hkey);

    // create the progid key
    wsprintf(szKey, g_szServerProgIDKey, szClsid);
    dwErr = ::RegCreateKey(HKEY_CLASSES_ROOT, szKey, &hkey);
    if (dwErr != ERROR_SUCCESS)
        return(HRESULT_FROM_WIN32(dwErr));

    // set the default value (progid)
    dwErr = ::RegSetValueEx(hkey, NULL, 0, REG_SZ,
            (LPBYTE) g_szSSOProgID, lstrlen(g_szSSOProgID) + 1);
    if (dwErr != ERROR_SUCCESS)
        {
        ::RegCloseKey(hkey);
        return(HRESULT_FROM_WIN32(dwErr));
        }

    ::RegCloseKey(hkey);

    // create the sso key
    wsprintf(szKey, g_szProgIDKey, g_szSSOProgID);
    dwErr = ::RegCreateKey(HKEY_CLASSES_ROOT, szKey, &hkey);
    if (dwErr != ERROR_SUCCESS)
        return(HRESULT_FROM_WIN32(dwErr));

    // set the default value (clsid)
    dwErr = ::RegSetValueEx(hkey, NULL, 0, REG_SZ,
            (LPBYTE) szClsid, lstrlen(szClsid) + 1);
    if (dwErr != ERROR_SUCCESS)
        {
        ::RegCloseKey(hkey);
        return(HRESULT_FROM_WIN32(dwErr));
        }

    ::RegCloseKey(hkey);
    return(NOERROR);
}

STDAPI
DllUnregisterServer(void)
{
    char szClsid[MAX_PATH];
    char szKey[MAX_PATH];

    // remove the inprocserver32 key
    _AnsiStringFromGuid(g_clsidSSO, szClsid);
    wsprintf(szKey, g_szServerKey, szClsid);
    ::RegDeleteKey(HKEY_CLASSES_ROOT, szKey);

    // remove the progid key
    wsprintf(szKey, g_szServerProgIDKey, szClsid);
    ::RegDeleteKey(HKEY_CLASSES_ROOT, szKey);

    // remove the clsid key
    lstrcpy(szKey, g_szClsidKey);
    lstrcat(szKey, szClsid);
    ::RegDeleteKey(HKEY_CLASSES_ROOT, szKey);

    // remove the sso clsid key
    wsprintf(szKey, g_szProgIDKey, g_szSSOProgID);
    ::RegDeleteKey(HKEY_CLASSES_ROOT, szKey);

    // remove the sso key
    ::RegDeleteKey(HKEY_CLASSES_ROOT, g_szSSOProgID);

    return(NOERROR);
}

/*--------------------------------------------------------------------------+
|   SSODllMain                                                              |
+--------------------------------------------------------------------------*/

BOOL
SSODllMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pvReserved)
{
    switch (ulReason)
        {
        case DLL_PROCESS_ATTACH:
            DisableThreadLibraryCalls(hInstance);
            g_hinst = hInstance;
            gOSInfo.Init();
            break;

        case DLL_PROCESS_DETACH:
            FreePerfGunk();
            break;

        default:
            break;
        }

    return(TRUE);
}

/*--------------------------------------------------------------------------+
|   SSO Utilities                                                           |
+--------------------------------------------------------------------------*/

HRESULT
SSOTranslateVirtualRoot(VARIANT *pvarIn, IUnknown *punk, LPSTR szOut, DWORD cbOut)
{
    HRESULT hr;
    BSTR    bstrIn = NULL;
    BSTR    bstrOut = NULL;
    BOOL    fFree = FALSE;
    IServer *psrv = NULL;
    IScriptingContext *pcxt = NULL;

    if (!(bstrIn = _BstrFromVariant(pvarIn, &fFree)))
        return(E_OUTOFMEMORY);

    if (FAILED(hr = punk->QueryInterface(IID_IScriptingContext, reinterpret_cast<void **>(&pcxt))))
        goto LTransRet;

    if (FAILED(hr = pcxt->get_Server(&psrv)))
        {
        psrv = NULL;
        goto LTransRet;
        }

    if (FAILED(hr = psrv->MapPath(bstrIn, &bstrOut)))
        {
        bstrOut = NULL;
        goto LTransRet;
        }

    if (!::WideCharToMultiByte(CP_ACP, 0, bstrOut, -1,
                               szOut, cbOut, NULL, NULL))
        {
        hr = HRESULT_FROM_WIN32(::GetLastError());
        goto LTransRet;
        }

    hr = NOERROR;

LTransRet:

    if (pcxt)
        pcxt->Release();

    if (psrv)
        psrv->Release();

    if (bstrIn && fFree)
        ::SysFreeString(bstrIn);

    if (bstrOut)
        ::SysFreeString(bstrOut);

    return(hr);
}

CSSODispatchSupportErr::CSSODispatchSupportErr(CSSODispatch *pSSODispatch)
    {
    m_pSSODispatch = pSSODispatch;
    }

STDMETHODIMP CSSODispatchSupportErr::QueryInterface(const IID &idInterface, void **ppvObj)
    {
    return m_pSSODispatch->QueryInterface(idInterface, ppvObj);
    }

STDMETHODIMP_(ULONG) CSSODispatchSupportErr::AddRef()
    {
    return m_pSSODispatch->AddRef();
    }

STDMETHODIMP_(ULONG) CSSODispatchSupportErr::Release()
    {
    return m_pSSODispatch->Release();
    }

STDMETHODIMP CSSODispatchSupportErr::InterfaceSupportsErrorInfo(const GUID &idInterface)
    {
    if (idInterface == IID_IDispatch) {
        DebugOutputDebugString("IDispatch supports error info");
        return S_OK;
    }

    if (idInterface == IID_IUnknown) {
        DebugOutputDebugString("IUnknown supports error info");
    }

    return S_FALSE;
    }


/*===================================================================
CchLoadStringOfId

Loads a string from the string table.

Returns:
    sz - the returned string
    INT - 0 if string load failed, otherwise number of characters loaded.
===================================================================*/
INT CchLoadStringOfId
(
UINT id,
CHAR *sz,
INT cchMax
)
    {
    INT cchRet;

    // The handle to the DLL instance should have been set up when we were loaded
    if (g_hinst == (HINSTANCE)0)
        {
        // Totally bogus
        Assert(FALSE);
        return(0);
        }

    cchRet = LoadString(g_hinst, id, sz, cchMax);

#ifdef DEBUG
    // For debugging purposes, if we get back 0, get the last error info
    if (cchRet == 0)
        {
        DWORD err = GetLastError();
        CHAR szDebug[100];
        sprintf(szDebug, "Failed to load string resource.  Id = %d, error = %d\n", id, err);
        DebugOutputDebugString(szDebug);
        Assert(FALSE);
        }
#endif

    return(cchRet);
    }


/*===================================================================
CwchLoadStringOfId

Loads a string from the string table as a UNICODE string.

Returns:
    sz - the returned string
    INT - 0 if string load failed, otherwise number of characters loaded.
===================================================================*/
INT CwchLoadStringOfId
(
UINT id,
WCHAR *sz,
INT cchMax
)
    {
    INT cchRet;

    // The handle to the DLL instance should have been set up when we were loaded
    if (g_hinst == (HINSTANCE)0)
        {
        // Totally bogus
        Assert(FALSE);
        return(0);
        }

    if (FIsWinNT())
        {
        cchRet = LoadStringW(g_hinst, id, sz, cchMax);
        }
    else
        {
        //LoadStringW returns ERROR_CALL_NOT_IMPLEMENTED in Win95, work around
        CHAR szTemp[MAX_RESSTRINGSIZE];
        cchRet = CchLoadStringOfId(id, szTemp, cchMax);
        if (cchRet > 0)
            {
            //strcpyWfromA(sz, szTemp);
            //Bug fix 1445: _mbstrlen(szTemp) + 1 to null terminate sz
            mbstowcs(sz, szTemp, _mbstrlen(szTemp) + 1);
            }
        }

#ifdef DEBUG
    // For debugging purposes, if we get back 0, get the last error info
    if (cchRet == 0)
        {
        DWORD err = GetLastError();
        CHAR szDebug[100];
        sprintf(szDebug, "Failed to load string resource.  Id = %d, error = %d\n", id, err);
        DebugOutputDebugString(szDebug);
        Assert(FALSE);
        }
#endif

    return(cchRet);
    }


void Exception
(
REFIID ObjID,
LPOLESTR strSource,
LPOLESTR strDescr
)
    {
    HRESULT hr;
    ICreateErrorInfo *pICreateErr;
    IErrorInfo *pIErr;
    LANGID langID = LANG_NEUTRAL;

#ifdef USE_LOCALE
    LANGID *pLangID;

    pLangID = (LANGID *)TlsGetValue(g_dwTLS);

    if (NULL != pLangID)
        langID = *pLangID;
#endif

    /*
     * Thread-safe exception handling means that we call
     * CreateErrorInfo which gives us an ICreateErrorInfo pointer
     * that we then use to set the error information (basically
     * to set the fields of an EXCEPINFO structure. We then
     * call SetErrorInfo to attach this error to the current
     * thread.  ITypeInfo::Invoke will look for this when it
     * returns from whatever function was invokes by calling
     * GetErrorInfo.
     */

    //Not much we can do if this fails.
    if (FAILED(CreateErrorInfo(&pICreateErr)))
        return;

    /*
     * UNDONE: Help file and help context?
     * UNDONE: Should take an IDS and load error info from resources
     */
    pICreateErr->SetGUID(ObjID);
    pICreateErr->SetHelpFile(L"");
    pICreateErr->SetHelpContext(0L);
    pICreateErr->SetSource(strSource);
    pICreateErr->SetDescription(strDescr);

    hr = pICreateErr->QueryInterface(IID_IErrorInfo, (PPVOID)&pIErr);

    if (SUCCEEDED(hr))
        {
        if(SUCCEEDED(SetErrorInfo(0L, pIErr))) {
            pIErr->Release();
        }
        }

    //SetErrorInfo holds the object's IErrorInfo
    pICreateErr->Release();
    return;
    }

/*===================================================================
ExceptionId

Raises an exception using the CreateErrorInfo API and the
ICreateErrorInfo interface.

Note that this method doesn't allow for deferred filling
of an EXCEPINFO structure.

Parameters:
    SourceID    Resource ID for the source string
    DescrID     Resource ID for the description string

Returns:
    Nothing
===================================================================*/

void ExceptionId
(
REFIID ObjID,
UINT SourceID,
UINT DescrID,
HRESULT hrCode
)
    {
    HRESULT hr;
    ICreateErrorInfo *pICreateErr;
    IErrorInfo *pIErr;
    LANGID langID = LANG_NEUTRAL;

#ifdef USE_LOCALE
    LANGID *pLangID;

    pLangID = (LANGID *)TlsGetValue(g_dwTLS);

    if (NULL != pLangID)
        langID = *pLangID;
#endif

    /*
     * Thread-safe exception handling means that we call
     * CreateErrorInfo which gives us an ICreateErrorInfo pointer
     * that we then use to set the error information (basically
     * to set the fields of an EXCEPINFO structure. We then
     * call SetErrorInfo to attach this error to the current
     * thread.  ITypeInfo::Invoke will look for this when it
     * returns from whatever function was invokes by calling
     * GetErrorInfo.
     */

    //Not much we can do if this fails.
    if (FAILED(CreateErrorInfo(&pICreateErr)))
        return;

    /*
     * UNDONE: Help file and help context?
     */
    DWORD cch;
    WCHAR strSource[MAX_RESSTRINGSIZE];
    WCHAR strDescr[MAX_RESSTRINGSIZE];
    WCHAR strDescrWithHRESULT[MAX_RESSTRINGSIZE+10];

    pICreateErr->SetGUID(ObjID);
    pICreateErr->SetHelpFile(L"");
    pICreateErr->SetHelpContext(0L);

    cch = CwchLoadStringOfId(SourceID, strSource, MAX_RESSTRINGSIZE);
    if (cch > 0)
        pICreateErr->SetSource(strSource);

    cch = CwchLoadStringOfId(DescrID, strDescr, MAX_RESSTRINGSIZE);
    swprintf(strDescrWithHRESULT, strDescr, hrCode);

    if (cch > 0)
        pICreateErr->SetDescription(strDescrWithHRESULT);

    hr = pICreateErr->QueryInterface(IID_IErrorInfo, (PPVOID)&pIErr);

    if (SUCCEEDED(hr))
        {
        SetErrorInfo(0L, pIErr);
        pIErr->Release();
        }

    //SetErrorInfo holds the object's IErrorInfo
    pICreateErr->Release();
    return;
    }

HRESULT COSInfo::Init(void)
    {

    OSVERSIONINFO osv;
    BOOL fT;

    // Check the OS we are running on
    osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    fT = GetVersionEx( &osv );

    m_fWinNT = ( osv.dwPlatformId == VER_PLATFORM_WIN32_NT );
    m_fInited = TRUE;
    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\sso\ssobase\wcguids.h ===
/*
**	wcguids.h
**
**	the MSN WC guid block starts at 4d9e4500-6de1-11cf-87a7-444553540000
**	and goes through 4d9e45ff.
*/

#define DEFINE_WC_GUID(clsname, num) \
	DEFINE_GUID(clsname, 0x4d9e45##num, 0x6de1, 0x11cf, \
				0x87, 0xa7, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00)


DEFINE_WC_GUID(CLSID_MSNUserPrefs,				00);	// CLSID:	MSN User Prefs object
DEFINE_WC_GUID(CLSID_SSOChatQuery,				01);	// CLSID:	SSO Chat Client Object
DEFINE_WC_GUID(CLSID_SSOVote,					02);	// CLSID:	SSO Vote Object
DEFINE_WC_GUID(CLSID_SSOSMail,					03);	// CLSID:	SSO SMail.DLL
DEFINE_WC_GUID(CLSID_SSOChatMonitor,			04);	// CLSID:	SSO Chat transcript -> SQL object
DEFINE_WC_GUID(CLSID_SSONextLink,				05);	// CLSID:	NextLink SSO
DEFINE_WC_GUID(CLSID_SSOChatTranscript,			06);	// CLSID:	SSO SQL -> IIS object
DEFINE_WC_GUID(CLSID_SSOAcctBill,				07);	// CLSID:	SSO OLS & Change Payments
DEFINE_WC_GUID(CLSID_SSOUserSurvey,				08);	// CLSID:	SSO User Survey
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\sso\ssobase\ssoperf.h ===
/*
**	ssoperf.h
**
**	definitions of offsets of perf data.  these must start at 0 and be even #s.
*/

#define SSO_PERF_OBJECT			0
#define SSO_NUM_INVOKES			2
#define SSO_NUM_INVOKES_TOTAL	4
#define SSO_NUM_GETNAMES		6
#define SSO_NUM_GETNAMES_TOTAL	8
#define SSO_LATENCY_INVOKES_AVG	10
#define SSO_LATENCY_INVOKES_MAX	12
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\sso\ssobase\ssoperf.cpp ===
/*
**  SSOPERF.CPP
**
**  Perfmon Counters for the SSO Framework
**
**  davidsan -- 03/01/96
*/

#pragma warning(disable: 4237)      // disable "bool" reserved

#include <ssobase.h>
#include <winperf.h>
#include <iis64.h>
#include "ssoperf.h"

// Okay, this is how the perfmon gunk works.  Some of this is distilled from
// the MSDN documentation on perfmon counters (in the win32 SDK and the win32
// DDK).  Other parts of it are explanations of how this implementation works.
//
// Basically, the API to provide perfmon counters works like this:  assuming
// everything's set up correctly in the registry, when your object is selected
// by a perfmon client, SSOPerfOpen() is called.  Then SSOPerfCollect() is
// repeatedly called to provide the actual counter data.
//
// SSOPerfCollect() is given a buffer, which it's supposed to fill with a
// PERF_OBJECT_TYPE structure, followed by a set of PERF_COUNTER_DEFINITION
// structures (one per counter), which are in turn followed by a set of
// PERF_INSTANCE_DEFINITION structures, one per instance, which contain
// the actual counter data.  Whew.  Since this huge structure has to be
// spewed into the buffer for every SSOPerfCollect() call, we keep as much
// of it as we can pre-initialized and just ready to go.  The main structure
// we use is the SPD structure, which is pre-initialized below.  The only
// problem is that there's some stuff we don't know at compile time.  The
// really important one is:  as part of this perfmon API, every
// perfmon counter source gets two magic reg values put into its reg key
// as part of installation of the counter.  The reg values are a "first
// counter" and "first help" index.  At SSOPerfOpen() time, these values
// have to be added to every index in the SPD structure (there are two counter
// indices per object and two per counter).
//
// Perfmon objects can provide COUNTERS and INSTANCES.  A counter is an
// abstract measurement of some quantity, like # of times Invoke() is called
// per second.  An instance is an instantiation of a counter.  In this code,
// we map "instance" onto "SSO method".  One limitation of the perfmon API
// is that every counter must have data for every instance.  This means that
// every counter in this code has to compute its value PER SSO METHOD.  We
// can't add global counters without adding a second PERF_OBJECT_TYPE, which
// just isn't worth it no matter what.
//
// The only other real complication is the fact that the perfmon.exe process
// and the Gibraltar process have to share the perfmon counter data via a
// shared memory-mapped file.  The way we do this is to export a set of
// pointers to arrays of counter data within the MMF.  That way, once the
// Gibraltar side has called InitPerfSource(), it can just do things like
//          g_rgcInvokes[instance]++;
// to set the counters.  The perfmon.exe side of the MMF uses the same names
// for the variables and everything, so once InitPerfSink() is called, it
// can get the value by just accessing g_rgcInvokes[instance] directly.

// Steps to add a new counter:
//  1) add a PERF_COUNTER_DEFINITION to g_spd
//  2) increase g_cCounters
//  3) add its instance computations in Open
//  4) add entry in ssoperf.h and ssoperf.ini
//  5) add new arrays for the shared memory block, if necessary
//  6) add their computation/storage in Collect
//  7) add code in ssobase.cpp to actually touch the counter values
//  8) add setting of arrays in InitPerfSource/FInitPerfSink

#include <pshpack4.h>
typedef struct _SSO_PERF_DATA
{
    PERF_OBJECT_TYPE        potSSO;
    PERF_COUNTER_DEFINITION pcdInvokes;
    PERF_COUNTER_DEFINITION pcdInvokesTotal;
    PERF_COUNTER_DEFINITION pcdGetNames;
    PERF_COUNTER_DEFINITION pcdGetNamesTotal;
    PERF_COUNTER_DEFINITION pcdLatency;
    PERF_COUNTER_DEFINITION pcdMaxLatency;
} SPD, *PSPD;
#include <poppack.h>

const int g_cCounters = 6;

// This structure is preinitialized here, but there are some adjustments that
// have to be made in the Open routine, because at compile time we don't know
// how many instances (SSO methods) we have.  Also, the Index pieces are
// relative to some values that get stored in the registry by lodctr.exe, so
// those have to be adjusted also.  Here's a list of everything to adjust:
//      TotalByteLength += size of instance defs (includes data)
//      ObjectNameTitleIndex/ObjectHelpTitleIndex += base offset from registry
//      NumInstances
//      each CounterNameTitleIndex/CounterHelpTitleIndex
SPD g_spd =
{
    {
        sizeof(SPD),                        // TotalByteLength
        sizeof(SPD),                        // DefinitionLength
        sizeof(PERF_OBJECT_TYPE),           // HeaderLength
        SSO_PERF_OBJECT,                    // ObjectNameTitleIndex
        0,                                  // ObjectNameTitle
        SSO_PERF_OBJECT,                    // ObjectHelpTitleIndex
        0,                                  // ObjectHelpTitle
        PERF_DETAIL_NOVICE,                 // DetailLevel
        g_cCounters,                        // NumCounters
        0,                                  // DefaultCounter
        0,                                  // NumInstances
        0,                                  // CodePage
    },
    {
        sizeof(PERF_COUNTER_DEFINITION),    // ByteLength
        SSO_NUM_INVOKES,                    // CounterNameTitleIndex
        0,                                  // CounterNameTitle
        SSO_NUM_INVOKES,                    // CounterHelpTitleIndex
        0,                                  // CounterHelpTitle
        0,                                  // DefaultScale
        PERF_DETAIL_NOVICE,                 // DetailLevel
        PERF_COUNTER_COUNTER,               // CounterType -- means dword rate counter with per/sec display
        sizeof(DWORD),                      // CounterSize
        sizeof(DWORD),                      // CounterOffset
    },
    {
        sizeof(PERF_COUNTER_DEFINITION),    // ByteLength
        SSO_NUM_INVOKES_TOTAL,              // CounterNameTitleIndex
        0,                                  // CounterNameTitle
        SSO_NUM_INVOKES_TOTAL,              // CounterHelpTitleIndex
        0,                                  // CounterHelpTitle
        0,                                  // DefaultScale
        PERF_DETAIL_NOVICE,                 // DetailLevel
        PERF_COUNTER_RAWCOUNT,              // CounterType -- means dword counter
        sizeof(DWORD),                      // CounterSize
        2 * sizeof(DWORD),                  // CounterOffset
    },
    {
        sizeof(PERF_COUNTER_DEFINITION),    // ByteLength
        SSO_NUM_GETNAMES,                   // CounterNameTitleIndex
        0,                                  // CounterNameTitle
        SSO_NUM_GETNAMES,                   // CounterHelpTitleIndex
        0,                                  // CounterHelpTitle
        0,                                  // DefaultScale
        PERF_DETAIL_NOVICE,                 // DetailLevel
        PERF_COUNTER_COUNTER,               // CounterType -- means dword rate counter with per/sec display
        sizeof(DWORD),                      // CounterSize
        3 * sizeof(DWORD),                  // CounterOffset
    },
    {
        sizeof(PERF_COUNTER_DEFINITION),    // ByteLength
        SSO_NUM_GETNAMES_TOTAL,             // CounterNameTitleIndex
        0,                                  // CounterNameTitle
        SSO_NUM_GETNAMES_TOTAL,             // CounterHelpTitleIndex
        0,                                   // CounterHelpTitle
        0,                                  // DefaultScale
        PERF_DETAIL_NOVICE,                 // DetailLevel
        PERF_COUNTER_RAWCOUNT,              // CounterType -- means dword counter
        sizeof(DWORD),                      // CounterSize
        4 * sizeof(DWORD),                  // CounterOffset
    },
    {
        sizeof(PERF_COUNTER_DEFINITION),    // ByteLength
        SSO_LATENCY_INVOKES_AVG,            // CounterNameTitleIndex
        0,                                  // CounterNameTitle
        SSO_LATENCY_INVOKES_AVG,            // CounterHelpTitleIndex
        0,                                  // CounterHelpTitle
        0,                                  // DefaultScale
        PERF_DETAIL_NOVICE,                 // DetailLevel
        PERF_COUNTER_RAWCOUNT,              // CounterType -- just a number, don't munge it
        sizeof(DWORD),                      // CounterSize
        5 * sizeof(DWORD),                  // CounterOffset
    },
    {
        sizeof(PERF_COUNTER_DEFINITION),    // ByteLength
        SSO_LATENCY_INVOKES_MAX,            // CounterNameTitleIndex
        0,                                  // CounterNameTitle
        SSO_LATENCY_INVOKES_MAX,            // CounterHelpTitleIndex
        0,                                  // CounterHelpTitle
        0,                                  // DefaultScale
        PERF_DETAIL_NOVICE,                 // DetailLevel
        PERF_COUNTER_RAWCOUNT,              // CounterType -- just a number, don't munge it
        sizeof(DWORD),                      // CounterSize
        6 * sizeof(DWORD),                  // CounterOffset
    },
};

BOOL g_fInited = FALSE;
int g_cInstances = 0;

// add new counter arrays here
int *g_rgcInvokes = NULL;
int *g_rgcGetNames = NULL;
DWORD *g_rgctixLatencyMax = NULL;
int *g_rgcTimeSamples = NULL;
int *g_rgiTimeSampleCurrent = NULL;
DWORD *g_rgTimeSamples = NULL;

extern BOOL FInitPerfSink();

PERF_INSTANCE_DEFINITION **g_rgppid = NULL;

BOOL
_FAddInstance(OLECHAR *wszName, int *pcbInstanceData, int iInstance, int iFirstCounter)
{
    int cchName, cbName;
    int cbThisInstance;
    void *pv;

    cchName = lstrlenW(wszName) + 1;
    // pad to 4-byte (2-wchar) boundary
    if (cchName & 1)
        cchName++;
    cbName = 2 * cchName;

    // allocate space for PID + name + PERF_COUNTER_BLOCK + data
    cbThisInstance = sizeof(PERF_INSTANCE_DEFINITION) + cbName + sizeof(DWORD) + (sizeof(DWORD) * g_cCounters);

    if (!(pv = (void *)new BYTE[cbThisInstance]))
        return(FALSE);

    *pcbInstanceData += cbThisInstance;
    g_rgppid[iInstance] = (PERF_INSTANCE_DEFINITION *)pv;
    g_rgppid[iInstance]->ByteLength = sizeof(PERF_INSTANCE_DEFINITION) + cbName;
    g_rgppid[iInstance]->ParentObjectTitleIndex = iFirstCounter;
    g_rgppid[iInstance]->ParentObjectInstance = iFirstCounter;
    g_rgppid[iInstance]->UniqueID = PERF_NO_UNIQUE_ID;
    g_rgppid[iInstance]->NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
    g_rgppid[iInstance]->NameLength = cbName;

    lstrcpyW((WORD *)(((char *)pv) + sizeof(PERF_INSTANCE_DEFINITION)), wszName);
    return(TRUE);
}

extern "C" DWORD APIENTRY
SSOPerfOpen(LPWSTR lpDeviceNames)
{
    LONG lRet = ERROR_SUCCESS;
    char szKey[MAX_PATH];
    HKEY hkey;
    DWORD dwType;
    DWORD cb;
    DWORD iFirstCounter;
    DWORD iFirstHelp;
    SSOMETHOD *psm;
    int iInstance = 0;
    int cbInstanceData;

    if (!g_fInited)
        {
        // count the number of methods (instances) we have
        psm = g_rgssomethod;
        while (psm->wszName)
            {
            g_cInstances++;
            psm++;
            }

        if (g_pfnssoDynamic)
            ++g_cInstances; // one for the dynamic method

        g_spd.potSSO.NumInstances = g_cInstances;

        if (!FInitPerfSink())
            {
            return ERROR_NOT_ENOUGH_MEMORY;
            }

        // get the magic counter offset values from the registry
        wsprintf(szKey, "SYSTEM\\CurrentControlSet\\Services\\%s\\Performance", g_szSSOProgID);
        lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ | KEY_WRITE, &hkey);
        if (ERROR_SUCCESS != lRet)
            goto LBail;

        cb = sizeof(DWORD);
        lRet = RegQueryValueEx(hkey, "First Counter", 0, &dwType, (LPBYTE)&iFirstCounter, &cb);
        if (ERROR_SUCCESS != lRet || cb != sizeof(DWORD))
            {
            RegCloseKey(hkey);
            goto LBail;
            }

        lRet = RegQueryValueEx(hkey, "First Help", 0, &dwType, (LPBYTE)&iFirstHelp, &cb);
        if (ERROR_SUCCESS != lRet || cb != sizeof(DWORD))
            {
            RegCloseKey(hkey);
            goto LBail;
            }

        // add the magic counter offset values to all our indices
        g_spd.potSSO.ObjectNameTitleIndex += iFirstCounter;
        g_spd.potSSO.ObjectHelpTitleIndex += iFirstHelp;
        g_spd.pcdInvokes.CounterNameTitleIndex += iFirstCounter;
        g_spd.pcdInvokes.CounterHelpTitleIndex += iFirstHelp;
        g_spd.pcdInvokesTotal.CounterNameTitleIndex += iFirstCounter;
        g_spd.pcdInvokesTotal.CounterHelpTitleIndex += iFirstHelp;
        g_spd.pcdGetNames.CounterNameTitleIndex += iFirstCounter;
        g_spd.pcdGetNames.CounterHelpTitleIndex += iFirstHelp;
        g_spd.pcdGetNamesTotal.CounterNameTitleIndex += iFirstCounter;
        g_spd.pcdGetNamesTotal.CounterHelpTitleIndex += iFirstHelp;
        g_spd.pcdLatency.CounterNameTitleIndex += iFirstCounter;
        g_spd.pcdLatency.CounterHelpTitleIndex += iFirstHelp;
        g_spd.pcdMaxLatency.CounterNameTitleIndex += iFirstCounter;
        g_spd.pcdMaxLatency.CounterHelpTitleIndex += iFirstHelp;

        RegCloseKey(hkey);

        // build up an array of pointers to PERF_INSTANCE_DEFINITION structures,
        // one per instance.
        g_rgppid = new PERF_INSTANCE_DEFINITION *[g_cInstances];
        if (!g_rgppid)
            {
            lRet = ERROR_NOT_ENOUGH_MEMORY;
            goto LBail;
            }

        iInstance = 0;
        cbInstanceData = 0;

        // dynamic method
        if (g_pfnssoDynamic)
            {
            if (!_FAddInstance(L"Dynamic Methods", &cbInstanceData, iInstance, iFirstCounter))
                {
                lRet = ERROR_NOT_ENOUGH_MEMORY;
                goto LBail;
                }

            iInstance++;
            }

        // static methods
        psm = g_rgssomethod;
        while (psm->wszName)
            {
            if (!_FAddInstance(psm->wszName, &cbInstanceData, iInstance, iFirstCounter))
                {
                lRet = ERROR_NOT_ENOUGH_MEMORY;
                goto LBail;
                }

            psm++;
            iInstance++;
            }

        g_spd.potSSO.TotalByteLength += cbInstanceData;
        g_fInited = TRUE;
        }

LBail:
    return lRet;
}

extern "C" DWORD APIENTRY
SSOPerfClose()
{
    return ERROR_SUCCESS;
}

const WCHAR *g_wszGlobal = L"Global";
const WCHAR *g_wszForeign = L"Foreign";
const WCHAR *g_wszCostly = L"Costly";

BOOL
FWszStartsWith(LPWSTR wsz, LPCWSTR wszPrefix)
{
    WCHAR *pwc;
    WCHAR *pwcPrefix;

    if (!wsz)
        return FALSE;

    pwc = wsz;
    pwcPrefix = (WCHAR *)wszPrefix;
    while (*pwc && *pwcPrefix)
        {
        if (*pwc++ != *pwcPrefix++)
            return FALSE;
        }
    if (!*pwc && *pwcPrefix)
        return FALSE;
    return TRUE;
}

BOOL
FWszNumberListContains(LPWSTR wsz, DWORD dw)
{
    WCHAR *pwc;
    DWORD dwCur;

    if (!wsz)
        return FALSE;

    pwc = wsz;
    dwCur = 0;

    while (*pwc)
        {
        if (*pwc >= (WCHAR)'0' && *pwc <= (WCHAR)'9')
            {
            dwCur *= 10;
            dwCur += *pwc - (WCHAR)'0';
            }
        else if (*pwc == (WCHAR)' ')
            {
            if (dw == dwCur)
                return TRUE;
            dwCur = 0;
            }
        else
            return FALSE; // if not digit or space, bail

        pwc++;
        }
    if (dw == dwCur)
        return TRUE;
    return FALSE;
}

DWORD
DwAvgLatency(int iInstance)
{
    DWORD *rgSamples = &g_rgTimeSamples[iInstance * cTimeSamplesMax];
    int i;
    int iMax = g_rgcTimeSamples[iInstance]; // only take this out of the array once,
                                            // because it can change in the array
                                            // during this loop!
    __int64 i64Sum = 0;

    if (iMax == 0)
        return 0;

    for (i = 0; i < iMax; i++)
        i64Sum += rgSamples[i];

    return (DWORD)(unsigned __int64)(i64Sum / (__int64)iMax);
}


// In order to specify what object(s) the perfmon client wants data for, the
// API passes information in in the form of lpwszValue.  Yes, that's right,
// a string.  This string can be:
//      L"global"   -- meaning give me all the objects you have
//      L"foreign"  -- give me data on another computer.  we ignore this.
//      L"costly"   -- give me everything that's hard to compute.  we ignore this also.
// Or, my favorite, it can be a list of object indices, provided as a space-
// separated list of stringized numbers which we're supposed to grovel through
// to find our ObjectNameTitleIndex value.
extern "C" DWORD APIENTRY
SSOPerfCollect(LPWSTR lpwszValue, LPVOID *lppData, LPDWORD lpcbBytes, LPDWORD lpcObjectTypes)
{
    int iInstance;
    BYTE *pb = (BYTE *)*lppData;

    if (!g_fInited)
        {
        *lpcbBytes = 0;
        *lpcObjectTypes = 0;
        return ERROR_SUCCESS; // can't return any errors from this routine, whee
        }

    if (FWszStartsWith(lpwszValue, g_wszForeign) || FWszStartsWith(lpwszValue, g_wszCostly))
        {
        // we don't handle foreign requests, and i don't know what `costly' means
        *lpcbBytes = 0;
        *lpcObjectTypes = 0;
        return ERROR_SUCCESS; // can't return any errors from this routine, whee
        }
    if (!FWszStartsWith(lpwszValue, g_wszGlobal))
        {
        // not a global request, so it better be a list of object indices.  if ours isn't
        // in the list, bail out.
        if (!FWszNumberListContains(lpwszValue, g_spd.potSSO.ObjectNameTitleIndex))
            {
            *lpcbBytes = 0;
            *lpcObjectTypes = 0;
            return ERROR_SUCCESS; // can't return any errors from this routine, whee
            }
        }

    if (*lpcbBytes < g_spd.potSSO.TotalByteLength)
        {
        *lpcbBytes = 0;
        *lpcObjectTypes = 0;
        return ERROR_MORE_DATA;
        }

    // okay, if we got to here, it means that perfmon really wants our data
    // and that we have enough room to put it in.  first, copy the SPD into
    // the buffer.
    CopyMemory(pb, &g_spd, sizeof(g_spd));
    pb += sizeof(g_spd);

    // then, for each instance, put in the PERF_INSTANCE_DEFINITION and all
    // the counter data.
    for (iInstance = 0; iInstance < g_cInstances; iInstance++)
        {
        CopyMemory(pb, g_rgppid[iInstance], g_rgppid[iInstance]->ByteLength);
        pb += g_rgppid[iInstance]->ByteLength;

        // this is the ByteLength of the PERF_COUNTER_BLOCK
        *(DWORD *)pb = sizeof(DWORD) + (g_cCounters * sizeof(DWORD));
        pb += sizeof(DWORD);

        // first two counters are same value with different representations
        *(DWORD *)pb = g_rgcInvokes[iInstance];
        pb += sizeof(DWORD);
        *(DWORD *)pb = g_rgcInvokes[iInstance];
        pb += sizeof(DWORD);

        // second two counters are same value with different representations
        *(DWORD *)pb = g_rgcGetNames[iInstance];
        pb += sizeof(DWORD);
        *(DWORD *)pb = g_rgcGetNames[iInstance];
        pb += sizeof(DWORD);

        // next: avg latency.  this one is medium-hard to compute, so we don't
        // do it here.
        *(DWORD *)pb = DwAvgLatency(iInstance);
        pb += sizeof(DWORD);

        // max latency
        *(DWORD *)pb = g_rgctixLatencyMax[iInstance];
        pb += sizeof(DWORD);

        // add other counters here!
        }
    *lpcbBytes = DIFF(pb - (BYTE *)*lppData);
    *lppData = pb;
    *lpcObjectTypes = 1;

    return ERROR_SUCCESS;
}

const char *g_szMMFFormat = "%s.PerfData";
HANDLE g_hmmf = NULL;

// the shared MMF has the following chunks, in order:
//      list of invokes counters (one DWORD per instance)
//      list of getnames counters (one DWORD per instance)
//      list of max latency values (one DWORD per instance)
//      list of counts of time samples (one DWORD per instance)
//      list of indices of current time samples (one DWORD per instance)
//      list of arrays of time samples (one array of cTimeSamplesMax DWORDS per instance)
HANDLE
HmmfShared()
{
    char szMMF[MAX_PATH];
    SECURITY_DESCRIPTOR sd;
    SECURITY_ATTRIBUTES sa;
    int cbChunk = g_cInstances * sizeof(DWORD);

    // 5 in next line is the number of one-dword-per-instance things we have
    int cbMMF = (5 * cbChunk) + (cTimeSamplesMax * cbChunk);

    if (g_hmmf)
        return g_hmmf;

    wsprintf(szMMF, g_szMMFFormat, g_szSSOProgID);
    g_hmmf = OpenFileMapping(FILE_MAP_ALL_ACCESS, FALSE, szMMF);
    if (!g_hmmf)
        {
        InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
        SetSecurityDescriptorDacl(&sd, TRUE, (PACL)NULL, FALSE);
        sa.nLength = sizeof(sa);
        sa.lpSecurityDescriptor = &sd;
        sa.bInheritHandle = FALSE;
        g_hmmf = CreateFileMapping(INVALID_HANDLE_VALUE, &sa, PAGE_READWRITE, 0, cbMMF, szMMF);
        }
    return g_hmmf;
}

BOOL
FInitPerfSink()
{
    char *pch;
    int cbChunk = (g_cInstances * sizeof(DWORD));

    if (g_rgcInvokes)
        return TRUE;

    if (!HmmfShared())
        return FALSE;

    pch = (char *)MapViewOfFile(g_hmmf,
                                FILE_MAP_ALL_ACCESS,
                                0, 0, 0);
    if (!pch)
        return FALSE;
    g_rgcInvokes = (int *)pch;
    pch += cbChunk;
    g_rgcGetNames = (int *)pch;
    pch += cbChunk;
    g_rgctixLatencyMax = (DWORD *)pch;
    pch += cbChunk;
    g_rgcTimeSamples = (int *)pch;
    pch += cbChunk;
    g_rgiTimeSampleCurrent = (int *)pch;
    pch += cbChunk;
    g_rgTimeSamples = (DWORD *)pch;

    return TRUE;
}

void
InitPerfSource()
{
    SSOMETHOD *psm;
    char *pch;
    int cbChunk;
    int cbMMF;

    if (g_rgcInvokes)
        return;

    g_cInstances = (g_pfnssoDynamic ? 1 : 0);

    psm = g_rgssomethod;
    while (psm->wszName)
        {
        psm->iMethod = g_cInstances++;
        psm++;
        }

    if (!HmmfShared())
        return;

    cbChunk = (g_cInstances * sizeof(DWORD));
    cbMMF = (4 * cbChunk) + (cTimeSamplesMax * cbChunk);

    pch = (char *)MapViewOfFile(g_hmmf,
                                FILE_MAP_ALL_ACCESS,
                                0, 0, 0);
    if (!pch)
        return;

    g_rgcInvokes = (int *)pch;
    pch += cbChunk;
    g_rgcGetNames = (int *)pch;
    pch += cbChunk;
    g_rgctixLatencyMax = (DWORD *)pch;
    pch += cbChunk;
    g_rgcTimeSamples = (int *)pch;
    pch += cbChunk;
    g_rgiTimeSampleCurrent = (int *)pch;
    pch += cbChunk;
    g_rgTimeSamples = (DWORD *)pch;

    FillMemory(g_rgcInvokes, g_cInstances * g_cCounters * sizeof(DWORD), 0);
}

void
FreePerfGunk()
{
    if (g_rgcInvokes)
        UnmapViewOfFile(g_rgcInvokes);
    if (g_hmmf)
        CloseHandle(g_hmmf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\sso\ssobase\wcsdbg.cpp ===
/*
**	WCSDBG.CPP
**	davidsan
**	
**	Web Component Team Server-Side debug gunk
*/

#pragma warning(disable: 4237)		// disable "bool" reserved

#include "wcsutil.h"
#include "crtdbg.h"

#ifdef _DEBUG // whole file

/*--------------------------------------------------------------------------+
|	Debug Printing   														|
+--------------------------------------------------------------------------*/
int dbgprintf(PCSTR pFormat, ...)
{
    va_list	args;
	char	sBuffer[2049];
	int		cb;

	ZeroMemory(sBuffer, 2049);

	//  Initialize the variable argument list.
    va_start(args, pFormat);

	//  Write out the formatted string to our local buffer.
    cb = wvsprintf(sBuffer, pFormat, args);

	OutputDebugString(sBuffer);

	return cb;
}

BOOL
FW3SvcRunning()
{
	SC_HANDLE schMgr;
	SC_HANDLE sch;
	SERVICE_STATUS stat;
	BOOL fRet;
	
	schMgr = OpenSCManager(NULL, NULL, GENERIC_READ);
	if (!schMgr)
		return FALSE;
	sch = OpenService(schMgr, "w3svc", SERVICE_INTERROGATE);
	if (!sch)
		return FALSE;
	if (!ControlService(sch, SERVICE_CONTROL_INTERROGATE, &stat))
		return FALSE;
	fRet = stat.dwCurrentState != SERVICE_STOPPED;
	CloseServiceHandle(sch);
	CloseServiceHandle(schMgr);
	return fRet;
}

void
AssertProc(PCSTR szFile, DWORD dwLine, PCSTR szMsg, DWORD dwFlags)
{
	char szMsgEx[1024];
	PSTR pszBuffer = NULL;
	LONG lErr;
	DWORD dwRet;

	if (dwFlags & AP_GETLASTERROR)
		{
		lErr = GetLastError();
		FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER, NULL, lErr, 0, (PSTR) &pszBuffer, 0, NULL);
		if (pszBuffer)
			{
			wsprintf(szMsgEx, "Assertion failure: file %s line %d (GLE == `%s')", szFile, dwLine, pszBuffer);
			LocalFree(pszBuffer);
			}
		else
			wsprintf(szMsgEx, "Assertion failure: file %s line %d (GLE == %d)", szFile, dwLine, lErr);
		}
	else
		wsprintf(szMsgEx, "Assertion failure: file %s line %d", szFile, dwLine);

	if (szMsg)
		{
		lstrcat(szMsgEx, ": ");
		lstrcat(szMsgEx, szMsg);
		}

	LogEvent(EVENTLOG_ERROR_TYPE, 0x1003, szMsgEx);
	if (FW3SvcRunning())
		{
		__try
			{
			_CrtDbgBreak();
			}
		__except (EXCEPTION_EXECUTE_HANDLER)
			{
			}
		}
	else
		{
		// we can show u/i and let the developer decide what to do!
		dwRet = MessageBox(NULL, szMsgEx, "Assertion failure", MB_ABORTRETRYIGNORE);
		if (dwRet == IDRETRY)
			{
			__try
				{
				_CrtDbgBreak();
				}
			__except (EXCEPTION_EXECUTE_HANDLER)
				{
				}
			}
		else if (dwRet == IDABORT)
			ExitProcess(0);
		}
}

#endif //_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\sso\ssobase\ssobase.h ===
/*
**  SSOBASE.H
**  Sean P. Nolan
**  
**  Simple MSN SSS Object Framework
*/

#ifndef _SSOBASE_H_
#define _SSOBASE_H_

#include "wcsutil.h"
#include "asptlb.h"
#include <dbgutil.h>

// Control of OutputDebugString
extern BOOL gfOutputDebugString;

/*--------------------------------------------------------------------------+
|   Constants                                                               |
+--------------------------------------------------------------------------*/
#define SSO_BEGIN                   100

//
// General errors
//
#define SSO_GENERAL_BEGIN                           100
#define SSO_NOSVR                                   SSO_GENERAL_BEGIN

/*--------------------------------------------------------------------------+
|   Types                                                                   |
+--------------------------------------------------------------------------*/
typedef struct _SsoSupportStuff
    {
    LONG            lUser;
    IUnknown        *punk;
    OLECHAR         *wszMethodName;
    }
    SSSTUFF;

typedef HRESULT (*PFNSSOMETHOD)(WORD, DISPPARAMS *, VARIANT *, SSSTUFF *pssstuff);

typedef struct _SSOMethod
    {
    OLECHAR         *wszName;
    PFNSSOMETHOD    pfn;
    int             iMethod;
    }
    SSOMETHOD;

/*--------------------------------------------------------------------------+
|   Globals !!! Provided by the SSO !!!                                     |
+--------------------------------------------------------------------------*/

extern PFNSSOMETHOD g_pfnssoDynamic;
extern SSOMETHOD g_rgssomethod[];
extern LPSTR g_szSSOProgID;
extern GUID g_clsidSSO;
extern BOOL g_fPersistentSSO;

/*--------------------------------------------------------------------------+
|   Globals Provided by the Framework                                       |
+--------------------------------------------------------------------------*/

extern HINSTANCE g_hinst;

extern OLECHAR *c_wszOnNewTemplate;
extern OLECHAR *c_wszOnFreeTemplate;

/*--------------------------------------------------------------------------+
|   Routines Provided by the Framework                                      |
+--------------------------------------------------------------------------*/

extern HRESULT  SSOTranslateVirtualRoot(VARIANT *, IUnknown*, LPSTR, DWORD);
extern BOOL     SSODllMain(HINSTANCE, ULONG, LPVOID);

/*--------------------------------------------------------------------------+
|   Other Data Needed by the Framework                                      |
+--------------------------------------------------------------------------*/

const int cTimeSamplesMax = 100;

class CSSODispatch;

class CSSODispatchSupportErr : public ISupportErrorInfo
{
    private:

        CSSODispatch * m_pSSODispatch;

    public:

        CSSODispatchSupportErr(CSSODispatch *pSSODispatch);

        //
    STDMETHODIMP         QueryInterface(const GUID &, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ISupportErrorInfo members
    //
    STDMETHODIMP InterfaceSupportsErrorInfo(const GUID &);
};

int CchLoadStringOfId(UINT id, CHAR *sz, INT cchMax);
void Exception(REFIID ObjID,LPOLESTR strSource,LPOLESTR strDescr);

/*
 * Output Debug String should occur in Debug only
 */
#define DebugOutputDebugString(x) \
    {\
    if (gfOutputDebugString) \
        { \
        OutputDebugString(x); \
        } \
    }

#endif // _SSOBASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\sso\ssobase\wcsole.cpp ===
/*
**	WCSOLE.CPP
**
**	OLE-requiring bits of wcsutil
*/

#pragma warning(disable: 4237)		// disable "bool" reserved

#include "wcsutil.h"

LPSTR
_SzFromVariant(VARIANT *pvar)
{
	LPSTR	sz = NULL;
	OLECHAR	*pwch;
	DWORD	cch, cb;
	BOOL	fFree;
	BSTR	bstr;

	if (!(bstr = _BstrFromVariant(pvar, &fFree)))
		return(NULL);

	for (pwch = bstr, cch = 0; *pwch; ++pwch, ++cch)
		/* nothing */ ;

	cb = (cch + 1) * 2;
	if (sz = (LPSTR) _MsnAlloc(cb))
		::WideCharToMultiByte(CP_ACP, 0, bstr, -1, sz, cb, NULL, NULL);

	if (fFree)	  
		::SysFreeString(bstr);	

	return(sz);
}

BSTR
_BstrFromVariant(VARIANT *pvar, BOOL *pfFree)
{
	VARIANT varTemp;

	if (pvar->vt == VT_BSTR)
		{
		*pfFree = FALSE;
		return(V_BSTR(pvar));
		}
	else
		{
		::VariantInit(&varTemp);
		if (FAILED(::VariantChangeType(&varTemp, pvar, 0, VT_BSTR)))
			{
			::VariantClear(&varTemp);
			return(NULL);
			}

		*pfFree = TRUE;
		return(V_BSTR(&varTemp));
		}
}

BOOL
_FIntFromVariant(VARIANT *pvar, int *pi)
{
	VARIANT varTemp;
	varTemp.vt = VT_I4;
	
	if (pvar->vt == VT_I4)
		{
		*pi = (int)V_I4(pvar);
		return TRUE;
		}
	
	if (FAILED(::VariantChangeType(&varTemp, pvar, 0, VT_I4)))
		return FALSE;
	*pi = V_I4(&varTemp);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\tools\src\regset.cpp ===
#include <stdio.h>
#include "wtypes.h"

HRESULT RegisterProp(CHAR *szName, DWORD dwValue);

int main(int argc, char *argv[])
{
	DWORD dwValue;
	HRESULT hr;

	if (argc != 3)
	{
		printf("\nUsage:\n");
		printf("   regset RegistryValue Value\n");
		printf("   e.g.\n");
		printf("   regset ThreadCreationThreshold 2\n\n");
		return(-1);
	}

	dwValue = atol(argv[2]);
	hr = RegisterProp(argv[1], dwValue);

	return(0);
}

HRESULT RegisterProp(CHAR *szName, DWORD dwValue)
{
	HKEY		hkeyT = NULL;
	static const CHAR szW3SVC[] = TEXT("System\\CurrentControlSet\\Services\\W3SVC\\AXS\\Parameters");
	
	// Open the key for W3SVC so we can add denali under it
	if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szW3SVC, 0, KEY_ALL_ACCESS, &hkeyT) != ERROR_SUCCESS)
		return(E_FAIL);

	// Create the value
	if (RegSetValueEx(hkeyT, szName, 0, REG_DWORD, (BYTE *)&dwValue, sizeof(DWORD)) != ERROR_SUCCESS)
			goto LErrExit;
		
	if (RegCloseKey(hkeyT) != ERROR_SUCCESS)
		return(E_FAIL);
	return NOERROR;

LErrExit:
	RegCloseKey(hkeyT);
	return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\sso\ssobase\wcsutil.h ===
/*
**	wcsutil.h
**	Sean P. Nolan
**	
**	server-side utils
*/

#ifndef _WCSUTIL_H_
#define _WCSUTIL_H_

#include <windows.h>
#include <ole2.h>
#include <winsock.h>
#include <httpext.h>
#include "wcguids.h"

/*--------------------------------------------------------------------------+
|	Utilities Provided by the Framework										|
+--------------------------------------------------------------------------*/

extern LPSTR g_szSSOProgID;

// Logging to application event log -- see ReportEvent() in win32 sdk
// documentation for information on wType and dwEventID.
void LogEvent(WORD wType, DWORD dwEventID, char *sz);

#define PPVOID VOID **

// Asserts
#ifdef _DEBUG
extern void AssertProc(PCSTR szFile, DWORD dwLine, PCSTR szMsg, DWORD dwFlags);
#define AssertSzFlg(f, sz, dwFlag)		( (f) ? 0 : AssertProc(__FILE__, __LINE__, sz, dwFlag))
#else // !DEBUG
#define AssertSzFlg(f, sz, dwFlg)
#endif // !DEBUG

#define AP_GETLASTERROR		0x00000001

// under non-debug, AssertSzFlg is defined away, so these #defines don't
// have to be #ifdef _DEBUG
#define AssertSz(f, sz)				AssertSzFlg(f, sz, 0)
#define AssertEx(f)					AssertSz((f), "!(" #f ")")
#define Assert(f)					AssertEx(f)
#define AssertSzGLE(f, sz)			AssertSzFlg(f, sz, AP_GETLASTERROR)
#define AssertExGLE(f)				AssertSzGLE((f), "!(" #f ")")

// Debug Printing
#ifdef _DEBUG
int dbgprintf(PCSTR pFormat, ...);
#else
#define dbgprintf()
#endif

// Memory Mgmt
LPVOID _MsnAlloc(DWORD cb);
LPVOID _MsnRealloc(LPVOID pv, DWORD cb);
void _MsnFree(LPVOID pv);

// Data Munging
LPSTR _SzFromVariant(VARIANT *pvar);
BSTR _BstrFromVariant(VARIANT *pvar, BOOL *pfFree);
BOOL _FIntFromVariant(VARIANT *pvar, int *pi);

// String Manipulation / Parsing											
void _AnsiStringFromGuid(REFGUID rguid, LPSTR sz);
LPSTR _SkipWhiteSpace(LPSTR sz);
LPSTR _FindEndOfLine(LPSTR sz);
DWORD _atoi(LPSTR sz);

// URL Fiddling
int UrlType(char *szUrl);
#define URL_TYPE_ABSOLUTE		0		// e.g. http://foo/bar or just //foo.com/bar.htm
#define URL_TYPE_LOCAL_ABSOLUTE	1		// e.g. /foo/bar/baz.htm
#define URL_TYPE_RELATIVE		2		// e.g. xyzzy/plugh.html

// IIS Hacks
#ifdef _HTTPEXT_H_
BOOL _FTranslateVirtualRoot(EXTENSION_CONTROL_BLOCK *pecb, LPSTR szPathIn, 
							LPSTR szPathTranslated, DWORD cbPathTranslated);
#endif // _HTTPEXT_H_

// Critical Sections
class CCritSec
	{
	private:
		CRITICAL_SECTION	m_cs;

	public:
		CCritSec(void)		{ ::InitializeCriticalSection(&m_cs);	}
		~CCritSec(void)		{ ::DeleteCriticalSection(&m_cs);		}
		void Lock(void)		{ ::EnterCriticalSection(&m_cs);		}
		void Unlock(void)	{ ::LeaveCriticalSection(&m_cs);		}
	};

/*--------------------------------------------------------------------------+
|	CThingWatcher/CFileWatcher/CRegKeyWatcher								|
+--------------------------------------------------------------------------*/

typedef void (*PFNFILECHANGED)(LPSTR szFile, LONG lUser);
typedef void (*PFNREGKEYCHANGED)(HKEY hkey, LONG lUser);

typedef int (__stdcall *PFNCLOSEHEVTNOTIFY)(HANDLE hevtNotify);

class CThingWatcher
{
	friend DWORD ThingWatcherThread(CThingWatcher *pfw);

public:
	CThingWatcher(PFNCLOSEHEVTNOTIFY pfnCloseHevtNotify);
	~CThingWatcher();
	
	BOOL				FWatchHandle(HANDLE hevtNotify);

private:	
	virtual BOOL		FireChange(DWORD dwWait)			= 0;

	HANDLE				m_rghWait[2];
	HINSTANCE           m_hModule;
	PFNCLOSEHEVTNOTIFY	m_pfnCloseHevtNotify;
};

class CFileWatcher : public CThingWatcher
{
private:
	char			m_szPath[MAX_PATH];
	FILETIME		m_ftLastWrite;
	LONG			m_lUser;
	PFNFILECHANGED	m_pfnChanged;
	BOOL			m_fDirectory;
	HANDLE			m_hevtNotify;

public:
	CFileWatcher(void);
	~CFileWatcher(void);

	BOOL FStartWatching(LPSTR szPath, LONG lUser, PFNFILECHANGED pfnChanged); 

private:
	virtual BOOL FireChange(DWORD dwWait);
};
	
class CRegKeyWatcher : public CThingWatcher
{
public:
	CRegKeyWatcher();
	~CRegKeyWatcher();

	BOOL				FStartWatching(HKEY hkey, BOOL fSubTree, DWORD dwNotifyFilter, LONG lUser, PFNREGKEYCHANGED pfnChanged);

private:
	virtual BOOL		FireChange(DWORD dwWait);
	
	HKEY				m_hkey;
	LONG				m_lUser;
	PFNREGKEYCHANGED	m_pfnChanged;
	HANDLE				m_hevtNotify;
};

/*--------------------------------------------------------------------------+
|	CDataFile																|
+--------------------------------------------------------------------------*/

class CDataFile
	{
	friend class CDataFileGroup;
	friend void DataFileChanged(LPSTR szFile, LONG lUser);

	private:
		ULONG			m_cRef;

		CDataFile	   *m_pdfNext;
		CDataFile	   *m_pdfPrev;
		CDataFileGroup *m_pfg;

	protected:
		CCritSec		m_cs;
		char			m_szDataPath[MAX_PATH];
		CFileWatcher	m_fw;

	public:
		CDataFile(LPSTR szDataPath, CDataFileGroup *pfg);
		~CDataFile(void);

		ULONG		AddRef(void);
		ULONG		Release(void);

		BOOL		FWatchFile(PFNFILECHANGED pfnChanged = NULL);

		virtual void FreeDataFile(void) { delete this; }

	private:
		ULONG		GetRefCount(void);
		BOOL		FMatch(LPSTR szDataPath);

		CDataFile	*GetNext(void)				{ return(m_pdfNext);	}
		CDataFile	*GetPrev(void)				{ return(m_pdfPrev);	}
		void		SetNext(CDataFile *pdf)		{ m_pdfNext = pdf;		}
		void		SetPrev(CDataFile *pdf)		{ m_pdfPrev = pdf;		}
	};

/*--------------------------------------------------------------------------+
|	CDataFileGroup															|
+--------------------------------------------------------------------------*/

#define NUM_GROUP_BUCKETS (1024)

typedef struct _HashBucket
	{
	CDataFile *pdfHead;
	CDataFile *pdfTail;
	}
	HB;

class CDataFileGroup
	{
	private:
		CCritSec	m_cs;
		HB			m_rghb[NUM_GROUP_BUCKETS];
				
	public:
		CDataFileGroup(void);
		~CDataFileGroup(void);

		CDataFile  *GetDataFile(LPSTR szDataPath);
		void		ForgetDataFile(CDataFile *pdf);

		virtual CDataFile *CreateDataFile(LPSTR szDataPath) = 0;

	private:
		void		RememberDataFile(CDataFile *pdf, HB *phb = NULL);
		HB		   *GetHashBucket(LPSTR szDataPath);
	};
	
/*--------------------------------------------------------------------------+
|	CGenericHash															|
+--------------------------------------------------------------------------*/

typedef struct _HashItem
	{
	BSTR				bstrName;
	LPVOID				pvData;
	struct _HashItem	*phiNext;
	struct _HashItem	*phiPrev;
	}
	HITEM;

class CGenericHash
	{
	protected:
		DWORD		m_chi;
		HITEM		**m_rgphi;
		CCritSec	m_cs;

	public:
		CGenericHash(DWORD cBuckets);
		~CGenericHash(void);

		LPVOID PvFind(OLECHAR *wszName);

		BOOL FAdd(OLECHAR *wszName, LPVOID pv);
		void Remove(OLECHAR *wszName);
		void RemoveAll(void);

		void Lock(void)		{ m_cs.Lock(); }
		void Unlock(void)	{ m_cs.Unlock(); }

		virtual DWORD	GetHashValue(OLECHAR *wsz);
		virtual void	FreeHashData(LPVOID pv);

	private:
		HITEM	*FindItem(OLECHAR *wszName, HITEM ***ppphiHead);
		void	RemoveItem(HITEM **pphiHead, HITEM *phi);
		BOOL	FEnsureBuckets(void);
	};

/*--------------------------------------------------------------------------+
|	CResourceCollection														|
+--------------------------------------------------------------------------*/

typedef struct _resource
{
	BOOL			fInUse;
	BOOL			fValid;
	PVOID			pv;
} RS, *PRS;

typedef PRS HRS;
#define hrsNil NULL

class CResourceCollection
{
public:
	CResourceCollection();
	~CResourceCollection();
	
	BOOL			FInit(int cRsrc);
	BOOL			FTerm();
	
	HRS				HrsGetResource();
	void			ReleaseResource(BOOL fReset, HRS hrs);

	void			CleanupAll(PVOID pvNil);
	BOOL			FValid(HRS hrs);

private:
	PRS				PrsFree();
	void			WaitForRs();

	CCritSec		m_cs;
	HANDLE			m_hsem;
	
	int				m_crs;
	PRS				m_rgrs;

	virtual BOOL	FInitResource(PRS prs)		= 0;
	virtual void	CleanupResource(PRS prs)	= 0;
};

/*--------------------------------------------------------------------------+
|	CSocketCollection														|
+--------------------------------------------------------------------------*/

class CSocketCollection : public CResourceCollection
{
public:
	CSocketCollection() : CResourceCollection()		{};
	~CSocketCollection()							{};
	
	BOOL			FInit(int cRsrc, char *szServer, USHORT usPort); // usPort should be in host byte order
	BOOL			FReinit(char *szServer, USHORT usPort);
	
	SOCKET			ScFromHrs(HRS hrs);
	
private:
	char			m_szServer[MAX_PATH];
	int				m_usPort;
	SOCKADDR_IN		m_sin;

	virtual BOOL	FInitResource(PRS prs);
	virtual void	CleanupResource(PRS prs);
};

#endif // _WCSUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\sso\ssobase\wcsutil.cpp ===
/*
**  WCSUTIL.CPP
**  Sean Q. Nolan
**
**  Web Component Team Server-Side Utilities
*/

#pragma warning(disable: 4237)      // disable "bool" reserved

#include <ssobase.h>
#include "wcsutil.h"

/*--------------------------------------------------------------------------+
|   Types & Constants                                                       |
+--------------------------------------------------------------------------*/

#define chLF    (0xA)
#define chCR    (0xD)
#define chSpace ' '
#define chTab   '\t'

/*--------------------------------------------------------------------------+
|   Memory Management                                                       |
+--------------------------------------------------------------------------*/

LPVOID
_MsnAlloc(DWORD cb)
{
    return(::HeapAlloc(::GetProcessHeap(), 0, cb));
}

LPVOID
_MsnRealloc(LPVOID pv, DWORD cb)
{
    return(::HeapReAlloc(::GetProcessHeap(), 0, pv, cb));
}

void
_MsnFree(LPVOID pv)
{
    ::HeapFree(::GetProcessHeap(), 0, pv);
}

/*--------------------------------------------------------------------------+
|   Logging to event logs                                                   |
+--------------------------------------------------------------------------*/

void
LogEvent(WORD wType, DWORD dwEventID, char *sz)
{
    HANDLE hsrc;

    hsrc = RegisterEventSource(NULL, g_szSSOProgID);
    if (!hsrc)
        return;

    ReportEvent(hsrc, wType, 0, dwEventID, NULL, 1, 0, (const char **)&sz, NULL);
    DeregisterEventSource(hsrc);
}

/*--------------------------------------------------------------------------+
|   Data Munging                                                            |
+--------------------------------------------------------------------------*/

void
_AnsiStringFromGuid(REFGUID rguid, LPSTR sz)
{
    wsprintf(sz, "{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
             rguid.Data1, rguid.Data2, rguid.Data3,
             rguid.Data4[0], rguid.Data4[1],
             rguid.Data4[2], rguid.Data4[3],
             rguid.Data4[4], rguid.Data4[5],
             rguid.Data4[6], rguid.Data4[7]);
}

/*--------------------------------------------------------------------------+
|   String Manipulation / Parsing                                           |
+--------------------------------------------------------------------------*/

LPSTR
_SkipWhiteSpace(LPSTR sz)
{
    while (*sz && (*sz == chLF ||
                   *sz == chCR ||
                   *sz == chSpace ||
                   *sz == chTab))
        {
        sz = CharNext(sz);
        }

    return(sz);
}

LPSTR
_FindEndOfLine(LPSTR sz)
{
    while (*sz && *sz != chLF && *sz != chCR)
        sz = CharNext(sz);

    return(sz);
}


// UNDONE:  Consider using built-in atoi or atol rather than reinventing the wheel below.

DWORD
_atoi(LPSTR sz)
{
    DWORD dwRet = 0;

    while (*sz &&
            ((*sz) >= '0') &&
            ((*sz) <= '9'))
        {
        dwRet *= 10;
        dwRet += (*sz) - '0';
        sz++;
        }

    return(dwRet);
}

/*--------------------------------------------------------------------------+
|   URL Fiddling                                                            |
+--------------------------------------------------------------------------*/

int
UrlType(char *szUrl)
{
    // do the easy ones first
    if (*szUrl == '/' && *(szUrl + 1) == '/')
        return URL_TYPE_ABSOLUTE;
    if (*szUrl == '\\' && *(szUrl + 1) == '\\')
        return URL_TYPE_ABSOLUTE;

    if (*szUrl == '/' || *szUrl == '\\')
        return URL_TYPE_LOCAL_ABSOLUTE;

    // okay, now we just need to distinguish between http:stuff and
    // foo/bar/baz.html.  we do this by looking for a colon.
    // it will be good enough for now.
    while (*szUrl)
        {
        if (*szUrl == ':')
            return URL_TYPE_ABSOLUTE;
        szUrl++;
        }
    return URL_TYPE_RELATIVE;
}

/*--------------------------------------------------------------------------+
|   IIS Hacks                                                               |
+--------------------------------------------------------------------------*/

BOOL
_FTranslateVirtualRoot(EXTENSION_CONTROL_BLOCK *pecb, LPSTR szPathIn,
                       LPSTR szPathTranslated, DWORD cbPathTranslated)
{
    BOOL fRet;

    lstrcpy(szPathTranslated, szPathIn);

    fRet = pecb->ServerSupportFunction(pecb->ConnID,
                                       HSE_REQ_MAP_URL_TO_PATH,
                                       szPathTranslated,
                                       &cbPathTranslated, NULL);

    return(fRet);
}

/*--------------------------------------------------------------------------+
|   CThingWatcher/CFileWatcher/CRegKeyWatcher                               |
+--------------------------------------------------------------------------*/

#define ihNotify    0
#define ihSuicide   1

DWORD
ThingWatcherThread(CThingWatcher *ptw)
{
    HANDLE      rghWait[2];
    HINSTANCE   hModule;
    DWORD       dwErr;
    PFNCLOSEHEVTNOTIFY pfnCloseHevtNotify;

    if (DuplicateHandle(GetCurrentProcess(),
                        ptw->m_rghWait[ihSuicide],
                        GetCurrentProcess(),
                        &(rghWait[ihSuicide]),
                        0,
                        FALSE,
                        DUPLICATE_SAME_ACCESS) == FALSE)
    {
        return 0;
    }

    hModule = ptw->m_hModule; ptw->m_hModule = NULL;

    // I own this handle now
    //
    rghWait[ihNotify] = ptw->m_rghWait[ihNotify]; ptw->m_rghWait[ihNotify] = INVALID_HANDLE_VALUE;
    pfnCloseHevtNotify = ptw->m_pfnCloseHevtNotify;

LWaitSomeMore:
    dwErr = ::WaitForMultipleObjects(2, rghWait, FALSE, INFINITE);

    // careful! We only signal our pfn if the NOTIFY handle
    // gets set... if we error out, or the SUICIDE handle is set,
    // or any other cruft, we just go away quietly.
    if (dwErr == (WAIT_OBJECT_0 + ihNotify))
        {
        // Wait again ?
        if (ptw->FireChange(dwErr) == TRUE)
            goto LWaitSomeMore;
        }

    // Close the notify handle
    //
    pfnCloseHevtNotify(rghWait[ihNotify]);

    // Close the suicide handle
    //
    CloseHandle(rghWait[ihSuicide]);

    // Unload the library
    //
    FreeLibraryAndExitThread(hModule, 0);
    return(0);
}

CThingWatcher::CThingWatcher(PFNCLOSEHEVTNOTIFY pfnCloseHevtNotify)
{
    m_rghWait[ihNotify] = INVALID_HANDLE_VALUE;
    m_rghWait[ihSuicide] = NULL;
    m_hModule = NULL;

    m_pfnCloseHevtNotify = pfnCloseHevtNotify;
}

CThingWatcher::~CThingWatcher()
{
    if (m_rghWait[ihSuicide] != NULL)
    {
        ::SetEvent(m_rghWait[ihSuicide]);
        ::CloseHandle(m_rghWait[ihSuicide]);
    }

    // If the thread is already running, this will not happen.
    //
    if (m_rghWait[ihNotify] != INVALID_HANDLE_VALUE)
        m_pfnCloseHevtNotify(m_rghWait[ihNotify]);

#ifdef DEBUG
    ::FillMemory(this, sizeof(this), 0xAC);
#endif
}

BOOL
CThingWatcher::FWatchHandle(HANDLE hevtNotify)
{
    HANDLE  hThread;
    DWORD   dwTid;
    char    szModulePath[512];

    if (m_rghWait[ihSuicide] == NULL)
        m_rghWait[ihSuicide] = IIS_CREATE_EVENT(
                                   "CThingWatcher::m_rghWait[ihSuicide]",
                                   this,
                                   TRUE,
                                   FALSE
                                   );

    m_rghWait[ihNotify] = hevtNotify;
    if (!m_rghWait[ihSuicide] || m_rghWait[ihNotify] == INVALID_HANDLE_VALUE)
        {
        return(FALSE);
        }

    if (GetModuleFileName(g_hinst, szModulePath, sizeof(szModulePath)) == 0)
        return FALSE;

    m_hModule = LoadLibrary(szModulePath);
    if (m_hModule == NULL)
        return FALSE;

    hThread = ::CreateThread(NULL,
                             0,
                             (LPTHREAD_START_ROUTINE) ThingWatcherThread,
                             (LPVOID) this,
                             0,
                             &dwTid);

    if (hThread == NULL)
    {
        FreeLibrary(m_hModule);
        return(FALSE);
    }

    ::CloseHandle(hThread);

    return TRUE;
}


CFileWatcher::CFileWatcher() : CThingWatcher(FindCloseChangeNotification)
{
    m_szPath[0] = 0;
}

CFileWatcher::~CFileWatcher()
{
#ifdef DEBUG
    ::FillMemory(this, sizeof(this), 0xAC);
#endif
}

BOOL
CFileWatcher::FStartWatching(LPSTR szPath, LONG lUser, PFNFILECHANGED pfnChanged)
{
    HANDLE  hfile;
    DWORD   dwAttr;
    char    szPathDir[MAX_PATH];
    char    *pch;

    // remember settings
    lstrcpy(m_szPath, szPath);
    m_lUser = lUser;
    m_pfnChanged = pfnChanged;

    // see if it's a directory
    dwAttr = ::GetFileAttributes(szPath);
    if (dwAttr == 0xFFFFFFFF)
        return(FALSE);

    if (dwAttr & FILE_ATTRIBUTE_DIRECTORY)
        {
        m_fDirectory = TRUE;
        lstrcpy(szPathDir, m_szPath);
        }
    else
        {
        m_fDirectory = FALSE;
        hfile = ::CreateFile(m_szPath,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL);

        if (hfile == INVALID_HANDLE_VALUE)
            return(FALSE);

        ::GetFileTime(hfile, NULL, NULL, &m_ftLastWrite);
        ::CloseHandle(hfile);

        lstrcpy(szPathDir, m_szPath);
        pch = szPathDir + lstrlen(szPathDir) - 1;
        while (*pch != '\\')
            pch = ::CharPrev(szPathDir, pch);

        *pch = 0;
        }

    m_hevtNotify = ::FindFirstChangeNotification(szPathDir,
                                                 FALSE,
                                                 FILE_NOTIFY_CHANGE_LAST_WRITE);

    return this->FWatchHandle(m_hevtNotify);
}

// note: most of this was moved out of FileWatcherThread
BOOL
CFileWatcher::FireChange(DWORD dwWait)
{
    HANDLE      hfile;
    FILETIME    ftLastWriteNow;

    if (m_fDirectory)
        {
        // just watching a directory. If they say something
        // changed, then something changed!
        goto LDoChange;
        }
    else
        {
        // watching a specific file ... check last write times
        hfile = ::CreateFile(m_szPath,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL);

        if (hfile == INVALID_HANDLE_VALUE)
            {
            // file is gone; that sure is changed now, isn't it...
            goto LDoChange;
            }
        else
            {
            ::GetFileTime(hfile, NULL, NULL, &ftLastWriteNow);
            ::CloseHandle(hfile);

            if (ftLastWriteNow.dwLowDateTime != m_ftLastWrite.dwLowDateTime ||
                ftLastWriteNow.dwHighDateTime != m_ftLastWrite.dwHighDateTime)
                {
                // file has changed...
                goto LDoChange;
                }
            else
                {
                // oh great; some other file changed.
                ::FindNextChangeNotification(m_hevtNotify);
                return TRUE;
                }
            }
        }
LDoChange:
    if (m_pfnChanged)
        (m_pfnChanged)(m_szPath, m_lUser);
    return FALSE;
}

CRegKeyWatcher::CRegKeyWatcher() : CThingWatcher(CloseHandle)
{
}

CRegKeyWatcher::~CRegKeyWatcher()
{
#ifdef DEBUG
    ::FillMemory(this, sizeof(this), 0xAC);
#endif
}

//$ note: if the RegNotifyChangeKeyValue fails, it's because we're on win95.
//$ i could do a polling fallback!
BOOL
CRegKeyWatcher::FStartWatching(HKEY hkey, BOOL fSubTree, DWORD dwNotifyFilter, LONG lUser, PFNREGKEYCHANGED pfnChanged)
{
    m_hkey = hkey;
    m_lUser = lUser;
    m_pfnChanged = pfnChanged;

    m_hevtNotify = IIS_CREATE_EVENT(
                       "CRegKeyWatcher::m_hevtNotify",
                       this,
                       FALSE,
                       FALSE
                       );
    if (ERROR_SUCCESS != RegNotifyChangeKeyValue(hkey, fSubTree, dwNotifyFilter, m_hevtNotify, TRUE))
        return FALSE;

    return this->FWatchHandle(m_hevtNotify);
}

BOOL
CRegKeyWatcher::FireChange(DWORD dwWait)
{
//  CloseHandle(m_hevtNotify);
    if (m_pfnChanged)
        m_pfnChanged(m_hkey, m_lUser);
    return FALSE;
}

/*--------------------------------------------------------------------------+
|   CDataFile                                                               |
+--------------------------------------------------------------------------*/

CDataFile::CDataFile(LPSTR szDataPath, CDataFileGroup *pfg)
{
    m_cRef = 0;
    m_pdfNext = m_pdfPrev = NULL;

    lstrcpy(m_szDataPath, szDataPath);
    m_pfg = pfg;
}

CDataFile::~CDataFile()
{
#ifdef DEBUG
    ::FillMemory(this, sizeof(this), 0xAC);
#endif
}

ULONG
CDataFile::AddRef()
{
    ULONG cRefNew;

    m_cs.Lock();
    cRefNew = ++m_cRef;
    m_cs.Unlock();

    return(cRefNew);
}

ULONG
CDataFile::Release()
{
    ULONG cRefNew;

    m_cs.Lock();
    cRefNew = --m_cRef;
    m_cs.Unlock();

    if (!cRefNew)
        this->FreeDataFile();

    return(cRefNew);
}

ULONG
CDataFile::GetRefCount()
{
    return(m_cRef);
}

void
DataFileChanged(LPSTR szFile, LONG lUser)
{
    CDataFile *pdf = (CDataFile*) lUser;
    pdf->m_pfg->ForgetDataFile(pdf);
}

BOOL
CDataFile::FWatchFile(PFNFILECHANGED pfnChanged)
{
    PFNFILECHANGED  pfn;

    pfn = (pfnChanged ? pfnChanged : (PFNFILECHANGED) DataFileChanged);
    return(m_fw.FStartWatching(m_szDataPath, (LONG) this, pfn));
}

BOOL
CDataFile::FMatch(LPSTR szDataPath)
{
    return(lstrcmpi(szDataPath, m_szDataPath) == 0);
}

/*--------------------------------------------------------------------------+
|   CDataFileGroup                                                          |
+--------------------------------------------------------------------------*/

CDataFileGroup::CDataFileGroup()
{
    ::FillMemory(m_rghb, NUM_GROUP_BUCKETS * sizeof(HB), 0);
}

CDataFileGroup::~CDataFileGroup()
{
    HB      *phb;
    DWORD   ihb;

    // clean up leftovers
    for (ihb = 0, phb = m_rghb; ihb < NUM_GROUP_BUCKETS; ++ihb, ++phb)
        {
        while (phb->pdfHead)
            this->ForgetDataFile(phb->pdfHead);
        }

#ifdef DEBUG
    ::FillMemory(this, sizeof(this), 0xAC);
#endif
}

CDataFile *
CDataFileGroup::GetDataFile(LPSTR szDataPath)
{
    HB          *phb;
    CDataFile   *pdf = NULL;

    phb = this->GetHashBucket(szDataPath);

    m_cs.Lock();

    // try to find it
    for (pdf = phb->pdfHead; pdf && !pdf->FMatch(szDataPath); pdf = pdf->GetNext())
        /* nothing */ ;

    // if not on the list, create a new one and remember it
    if (!pdf)
        {
        if (pdf = this->CreateDataFile(szDataPath))
            this->RememberDataFile(pdf, phb);
        }

    // if we got one, addref it
    if (pdf)
        pdf->AddRef();

    m_cs.Unlock();
    return(pdf);
}

void
CDataFileGroup::RememberDataFile(CDataFile *pdf, HB *phb)
{
    if (!phb)
        phb = this->GetHashBucket(pdf->m_szDataPath);

    m_cs.Lock();

    pdf->SetNext(phb->pdfHead);
    pdf->SetPrev(NULL);

    if (phb->pdfHead)
        phb->pdfHead->SetPrev(pdf);

    phb->pdfHead = pdf;

    if (!phb->pdfTail)
        phb->pdfTail = pdf;

    m_cs.Unlock();

    pdf->AddRef();
}

void
CDataFileGroup::ForgetDataFile(CDataFile *pdf)
{
    HB *phb = this->GetHashBucket(pdf->m_szDataPath);

    m_cs.Lock();

    if (pdf->GetNext())
        pdf->GetNext()->SetPrev(pdf->GetPrev());

    if (pdf->GetPrev())
        pdf->GetPrev()->SetNext(pdf->GetNext());

    if (phb->pdfHead == pdf)
        phb->pdfHead = pdf->GetNext();

    if (phb->pdfTail == pdf)
        phb->pdfTail = pdf->GetPrev();

    m_cs.Unlock();

    pdf->Release();
}

HB*
CDataFileGroup::GetHashBucket(LPSTR szDataPath)
{
    DWORD   dwSum = 0;
    char    *pch;

    // nyi - a real hash function
    for (pch = szDataPath; *pch; ++pch)
        dwSum += (DWORD) *pch;

    return(&(m_rghb[dwSum % NUM_GROUP_BUCKETS]));
}

/*--------------------------------------------------------------------------+
|   CResourceCollection                                                     |
+--------------------------------------------------------------------------*/

CResourceCollection::CResourceCollection()
{
    m_crs = 0;
    m_rgrs = NULL;
}

CResourceCollection::~CResourceCollection()
{
    //$ Assert(!m_rgrs);
}

// public
BOOL
CResourceCollection::FInit(int cRsrc)
{
    m_rgrs = (PRS)_MsnAlloc(cRsrc * sizeof(RS));
    if (!m_rgrs)
        return FALSE;
    FillMemory(m_rgrs, cRsrc * sizeof(RS), 0);
    m_crs = cRsrc;

    m_hsem = IIS_CREATE_SEMAPHORE(
                 "CResourceCollection::m_hsem",
                 this,
                 cRsrc,
                 cRsrc
                 );

    if (!m_hsem)
        {
        _MsnFree(m_rgrs);
        m_rgrs = NULL;
        return FALSE;
        }

    return TRUE;
}

// public
BOOL
CResourceCollection::FTerm()
{
    if (m_rgrs)
        {
        this->CleanupAll(NULL); // pvNil value doesn't matter here

        _MsnFree(m_rgrs);
        m_rgrs = NULL;
        }
    return TRUE;
}

// private
// returns a free rs if there is one; otherwise returns NULL.
// if there is a free rs, but it's not yet inited, tries to init.
PRS
CResourceCollection::PrsFree()
{
    PRS prs = NULL;
    int irs;

    m_cs.Lock();

    for (irs = 0; irs < m_crs; irs++)
        {
        if (!(m_rgrs[irs].fInUse))
            {
            prs = &m_rgrs[irs];
            prs->fInUse = TRUE;
            break;
            }
        }

    if (prs && !prs->fValid)
        {
        prs->fValid = this->FInitResource(prs);
        //$ if this fails, should i just return null?  or let the client decide?
        }
    m_cs.Unlock();
    return prs;
}

// public
//$ maybe limit # of retries?
//$ maybe have way to retry the FInitResource if it fails?
HRS
CResourceCollection::HrsGetResource()
{
    PRS prs;

LTryAgain:
    this->WaitForRs();
    prs = this->PrsFree();
    if (prs && !prs->fValid)
        {
        this->ReleaseResource(FALSE, (HRS)prs);
        return hrsNil;
        }

    if (prs)
        return (HRS)prs;

    this->WaitForRs();
    goto LTryAgain;
}

// private
// waits until the release-resource semaphore goes off
//$ timeouts?  way to stop waiting?
void
CResourceCollection::WaitForRs()
{
    WaitForSingleObject(m_hsem, INFINITE);
}

// public
void
CResourceCollection::ReleaseResource(BOOL fReset, HRS hrs)
{
    PRS prs = (PRS)hrs;

    if (!prs)
        return;

    if (fReset && prs->fValid)
        {
        m_cs.Lock();
        this->CleanupResource(prs);
        prs->fValid = FALSE;
        m_cs.Unlock();
        }

    m_cs.Lock();
    prs->fInUse = FALSE;
    m_cs.Unlock();
    ReleaseSemaphore(m_hsem, 1, NULL);
}

// public
void
CResourceCollection::CleanupAll(VOID *pvNil)
{
    int i;
    PRS prs;

    m_cs.Lock();
    for (i = 0, prs = m_rgrs; i < m_crs; i++, prs++)
        {
        this->CleanupResource(prs);
        prs->fInUse = FALSE;
        prs->fValid = FALSE;
        prs->pv = pvNil;
        }
    m_cs.Unlock();
}

// public
BOOL
CResourceCollection::FValid(HRS hrs)
{
    PRS prs = (PRS) hrs;

    if (!prs)
        return FALSE;
    return prs->fValid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\tools\src\ismoke\ismkdlg.h ===
// ISmokeDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CISmokeDlg dialog

typedef BOOL (WINAPI *pfnHttpExtVer) (HSE_VERSION_INFO*);
typedef DWORD (WINAPI *pfnHttpExtProc) (EXTENSION_CONTROL_BLOCK*);
typedef BOOL (WINAPI *pfnHttpTermExt) (DWORD);

class CISmokeDlg : public CDialog
{
// Construction
public:
	CISmokeDlg(CWnd* pParent = NULL);	// standard constructor

	BOOL GetServerVariable(LPSTR pszVarName, LPVOID pvAnswer, LPDWORD pcchAnswer);
	BOOL ServerSupportFunction(DWORD dwHSERRequest, LPVOID lpvBuffer, LPDWORD lpdwSize, LPDWORD lpdwDataType);
	BOOL WriteClient(LPVOID lpvBuffer, LPDWORD lpdwBytes, DWORD dwReserved);
	BOOL ReadClient(LPVOID lpvBuffer, LPDWORD lpdwSize);

// Dialog Data
	//{{AFX_DATA(CISmokeDlg)
	enum { IDD = IDD_ISMOKE_DIALOG };
	CString	m_strMethod;
	CString	m_strStatement;
	CString	m_strPath;
	CString	m_strDLLName;
	CString	m_strResult;
	BOOL	m_fDLLLoaded;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CISmokeDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	BOOL Submit(const CString& strMethod, const CString& strStatement, const CString& strPath);
	BOOL ClearResult();
	BOOL RefreshResult();
	BOOL LoadDLL();
	void UnLoadDLL();
	BOOL DLLLoaded() const;

	EXTENSION_CONTROL_BLOCK	m_ecb;
	pfnHttpExtVer	m_pfnVer;
	pfnHttpExtProc	m_pfnProc;
	pfnHttpTermExt	m_pfnTermExt;
	HINSTANCE		m_hDLL;
	char			m_szQuery[512];
	char			m_szPath[512];
	char			m_szMeth[10];
	char			m_szContentType[2];
	DWORD			m_dwExtensionVersion;
	BOOL			m_fNeedsUpdate;

	HICON	m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CISmokeDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	virtual void OnOK();
	afx_msg void OnGetRightDLL();
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\tools\src\ismoke\httpext.h ===
/********
*
*  Copyright (c) 1995  Process Software Corporation
*
*  Copyright (c) 1995  Microsoft Corporation
*
*
*  Module Name  : HttpExt.h
*
*  Abstract :
*
*     This module contains  the structure definitions and prototypes for the
*     version 2.0 HTTP Server Extension interface.
*
******************/

#ifndef _HTTPEXT_H_
#define _HTTPEXT_H_

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif

#define   HSE_VERSION_MAJOR           2      // major version of this spec
#define   HSE_VERSION_MINOR           0      // minor version of this spec
#define   HSE_LOG_BUFFER_LEN         80
#define   HSE_MAX_EXT_DLL_NAME_LEN  256

typedef   LPVOID  HCONN;

// the following are the status codes returned by the Extension DLL

#define   HSE_STATUS_SUCCESS                       1
#define   HSE_STATUS_SUCCESS_AND_KEEP_CONN         2
#define   HSE_STATUS_PENDING                       3
#define   HSE_STATUS_ERROR                         4

// The following are the values to request services with the ServerSupportFunction.
//  Values from 0 to 1000 are reserved for future versions of the interface

#define   HSE_REQ_BASE                             0
#define   HSE_REQ_SEND_URL_REDIRECT_RESP           ( HSE_REQ_BASE + 1 )
#define   HSE_REQ_SEND_URL                         ( HSE_REQ_BASE + 2 )
#define   HSE_REQ_SEND_RESPONSE_HEADER             ( HSE_REQ_BASE + 3 )
#define   HSE_REQ_DONE_WITH_SESSION                ( HSE_REQ_BASE + 4 )
#define   HSE_REQ_END_RESERVED                     1000

//
//  These are Microsoft specific extensions
//

#define   HSE_REQ_MAP_URL_TO_PATH                  (HSE_REQ_END_RESERVED+1)
#define   HSE_REQ_GET_SSPI_INFO                    (HSE_REQ_END_RESERVED+2)
#define   HSE_APPEND_LOG_PARAMETER                 (HSE_REQ_END_RESERVED+3)
#define   HSE_REQ_SEND_URL_EX                      (HSE_REQ_END_RESERVED+4)

//
//  Bit Flags for TerminateExtension
//
//    HSE_TERM_ADVISORY_UNLOAD - Server wants to unload the extension,
//          extension can return TRUE if OK, FALSE if the server should not
//          unload the extension
//
//    HSE_TERM_MUST_UNLOAD - Server indicating the extension is about to be
//          unloaded, the extension cannot refuse.
//

#define HSE_TERM_ADVISORY_UNLOAD                   0x00000001
#define HSE_TERM_MUST_UNLOAD                       0x00000002

//
// passed to GetExtensionVersion
//

typedef struct   _HSE_VERSION_INFO {

    DWORD  dwExtensionVersion;
    CHAR   lpszExtensionDesc[HSE_MAX_EXT_DLL_NAME_LEN];

} HSE_VERSION_INFO, *LPHSE_VERSION_INFO;

//
// passed to extension procedure on a new request
//
typedef struct _EXTENSION_CONTROL_BLOCK {

    DWORD     cbSize;                 // size of this struct.
    DWORD     dwVersion;              // version info of this spec
    HCONN     ConnID;                 // Context number not to be modified!
    DWORD     dwHttpStatusCode;       // HTTP Status code
    CHAR      lpszLogData[HSE_LOG_BUFFER_LEN];// null terminated log info specific to this Extension DLL

    LPSTR     lpszMethod;             // REQUEST_METHOD
    LPSTR     lpszQueryString;        // QUERY_STRING
    LPSTR     lpszPathInfo;           // PATH_INFO
    LPSTR     lpszPathTranslated;     // PATH_TRANSLATED

    DWORD     cbTotalBytes;           // Total bytes indicated from client
    DWORD     cbAvailable;            // Available number of bytes
    LPBYTE    lpbData;                // pointer to cbAvailable bytes

    LPSTR     lpszContentType;        // Content type of client data

    BOOL (WINAPI * GetServerVariable) ( HCONN       hConn,
                                        LPSTR       lpszVariableName,
                                        LPVOID      lpvBuffer,
                                        LPDWORD     lpdwSize );

    BOOL (WINAPI * WriteClient)  ( HCONN      ConnID,
                                   LPVOID     Buffer,
                                   LPDWORD    lpdwBytes,
                                   DWORD      dwReserved );

    BOOL (WINAPI * ReadClient)  ( HCONN      ConnID,
                                  LPVOID     lpvBuffer,
                                  LPDWORD    lpdwSize );

    BOOL (WINAPI * ServerSupportFunction)( HCONN      hConn,
                                           DWORD      dwHSERRequest,
                                           LPVOID     lpvBuffer,
                                           LPDWORD    lpdwSize,
                                           LPDWORD    lpdwDataType );

} EXTENSION_CONTROL_BLOCK, *LPEXTENSION_CONTROL_BLOCK;

//
//  these are the prototypes that must be exported from the extension DLL
//

BOOL  WINAPI   GetExtensionVersion( HSE_VERSION_INFO  *pVer );
DWORD WINAPI   HttpExtensionProc(  EXTENSION_CONTROL_BLOCK *pECB );
BOOL  WINAPI   TerminateExtension( DWORD dwFlags );

// the following type declarations is for the server side

typedef BOOL  (WINAPI * PFN_GETEXTENSIONVERSION)( HSE_VERSION_INFO  *pVer );
typedef DWORD (WINAPI * PFN_HTTPEXTENSIONPROC )( EXTENSION_CONTROL_BLOCK *pECB );
typedef BOOL  (WINAPI * PFN_TERMINATEEXTENSION )( DWORD dwFlags );

#ifdef __cplusplus
}
#endif

#endif  // end definition _HTTPEXT_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\tools\src\ismoke\ismoke.cpp ===
// ISmoke.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "ISmoke.h"
#include "ISmkDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CISmokeApp

BEGIN_MESSAGE_MAP(CISmokeApp, CWinApp)
	//{{AFX_MSG_MAP(CISmokeApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CISmokeApp construction

CISmokeApp::CISmokeApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CISmokeApp object

CISmokeApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CISmokeApp initialization

BOOL CISmokeApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CISmokeDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\tools\src\ismoke\ismoke.h ===
// ISmoke.h : main header file for the ISMOKE application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CISmokeApp:
// See ISmoke.cpp for the implementation of this class
//

class CISmokeApp : public CWinApp
{
public:
	CISmokeApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CISmokeApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CISmokeApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\tools\src\ismoke\ismkdlg.cpp ===
// ISmokeDlg.cpp : implementation file
//

#include "stdafx.h"
#include "ISmoke.h"
#include "ISmkDlg.h"
#include "ole2.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CISmokeDlg dialog

CISmokeDlg::CISmokeDlg(CWnd* pParent /*=NULL*/)
		  : CDialog(CISmokeDlg::IDD, pParent),
			m_hDLL(NULL),
			m_pfnProc(NULL),
			m_pfnVer(NULL),
			m_fDLLLoaded(FALSE),
			m_fNeedsUpdate(FALSE)
{
	*m_szQuery = '\0';
	*m_szPath = '\0';
	*m_szMeth = '\0';
	*m_szContentType = '\0';
	m_dwExtensionVersion = 0;

	//{{AFX_DATA_INIT(CISmokeDlg)
	m_strMethod = _T("");
	m_strStatement = _T("");
	m_strPath = _T("");
	m_strDLLName = _T("");
	m_strResult = _T("");
	m_fDLLLoaded = FALSE;
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CISmokeDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CISmokeDlg)
	DDX_CBString(pDX, IDC_COMBO_METHOD, m_strMethod);
	DDX_CBString(pDX, IDC_COMBO_STATEMENT, m_strStatement);
	DDX_CBString(pDX, IDC_COMBO_PATH, m_strPath);
	DDX_CBString(pDX, IDC_COMBO_DLLNAME, m_strDLLName);
	DDX_Text(pDX, IDC_EDIT_RESULT, m_strResult);
	DDX_Check(pDX, IDC_CHECK_LOADED, m_fDLLLoaded);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CISmokeDlg, CDialog)
	//{{AFX_MSG_MAP(CISmokeDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_CHECK_LOADED, OnGetRightDLL)
	ON_WM_RBUTTONDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CISmokeDlg message handlers

BOOL CISmokeDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "Clear" menu item to system menu.
//	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
//	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	CString strClearMenuItem;
	strClearMenuItem.LoadString(IDS_DOCLEAR);
	if (!strClearMenuItem.IsEmpty())
	{
		pSysMenu->AppendMenu(MF_SEPARATOR);
		pSysMenu->AppendMenu(MF_STRING, ID_CLEAR, strClearMenuItem);
	}

	// Add "Refresh" menu item to system menu.
	CString strRefreshMenuItem;
	strRefreshMenuItem.LoadString(IDS_DOREFRESH);
	if (!strRefreshMenuItem.IsEmpty())
	{
		pSysMenu->AppendMenu(MF_SEPARATOR);
		pSysMenu->AppendMenu(MF_STRING, ID_REFRESH, strRefreshMenuItem);
	}

	// Add "About..." menu item to system menu.
	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	//CMenu* pSysMenu = GetSystemMenu(FALSE);
	CString strAboutMenu;
	strAboutMenu.LoadString(IDS_ABOUTBOX);
	if (!strAboutMenu.IsEmpty())
	{
		pSysMenu->AppendMenu(MF_SEPARATOR);
		pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon

	/*
	 * Since we are pretending to be IIS, and IIS does an OleInitialize
	 * we'd better do one too.
	 */
	if (!SUCCEEDED(OleInitialize(NULL)))
		return(FALSE);

	/*
	 * If the ISAPI DLL is going to do impersonation (which it should do
	 * if it is multi-threaded) then we will need to have set up
	 * and impersonation token. We do this with the oddly named ImpersonateSelf() 
	 * call.
	 */
	if (!ImpersonateSelf(SecurityImpersonation))
		{
			DWORD err;
			CHAR szT[256];
	
			// what went wrong?
			err = GetLastError();
			sprintf(szT, "Failed to impersonate self, err = %d\n", err);
			OutputDebugString(szT);
		}

	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CISmokeDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else if (nID == ID_CLEAR)
	{
		ClearResult();
	}
	else if (nID == ID_REFRESH)
	{
		RefreshResult();
	}
	else
	{
		if (nID == SC_CLOSE)
		{
			UnLoadDLL();
		}
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CISmokeDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		if (m_fNeedsUpdate)
		{
			m_fNeedsUpdate = FALSE;
			UpdateData(FALSE);
		}
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CISmokeDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CISmokeDlg::OnOK() 
{
	OnGetRightDLL();
	BOOL fSuccess = Submit(m_strMethod, m_strStatement, m_strPath);

	// write whatever happened back to the dialog
	UpdateData(FALSE);

	// todo: something with the success or failure!

	//CDialog::OnOK();
}

BOOL WINAPI ServerSupportFunction( HCONN      hConn,
                                   DWORD      dwHSERRequest,
                                   LPVOID     lpvBuffer,
                                   LPDWORD    lpdwSize,
                                   LPDWORD    lpdwDataType )
{
	return ((CISmokeDlg*)hConn)->ServerSupportFunction(dwHSERRequest, lpvBuffer, lpdwSize, lpdwDataType);
}

BOOL WINAPI WriteClient(HCONN      ConnID,
						LPVOID     lpvBuffer,
						LPDWORD    lpdwBytes,
						DWORD      dwReserved)
{
	return ((CISmokeDlg*)ConnID)->WriteClient(lpvBuffer, lpdwBytes, dwReserved);
}

BOOL WINAPI ReadClient(HCONN      ConnID,
						LPVOID     lpvBuffer,
						LPDWORD    lpdwBytes)
{
	return ((CISmokeDlg*)ConnID)->ReadClient(lpvBuffer, lpdwBytes);
}

BOOL WINAPI GetServerVariable(HCONN       ConnID,
						char*       pszVarName,
						void*       pvAnswer,
						DWORD*      pcchAnswer)
{
	return ((CISmokeDlg*)ConnID)->GetServerVariable(pszVarName, pvAnswer, pcchAnswer);
}

BOOL CISmokeDlg::Submit(const CString& strMethod, const CString& strStatement, const CString& strPath)
{
	OnGetRightDLL();
	if (m_fDLLLoaded)
	{
		strcpy(m_szMeth, strMethod);
		strcpy(m_szQuery, strStatement);
		strcpy(m_szPath, strPath);
		strcpy(m_szContentType, "");

		m_ecb.cbSize = sizeof(m_ecb);
		m_ecb.dwVersion = m_dwExtensionVersion;
		m_ecb.ConnID = (HCONN) this;
		m_ecb.dwHttpStatusCode = 0;
		m_ecb.lpszLogData[0] = '\0';
		m_ecb.lpszMethod = m_szMeth;
		m_ecb.lpszQueryString = m_szQuery;
		m_ecb.lpszPathInfo = m_szPath;
		m_ecb.lpszPathTranslated = m_szPath;
		m_ecb.cbTotalBytes = strlen(m_szQuery);
		m_ecb.cbAvailable = 0;
		m_ecb.lpbData = NULL;
		m_ecb.lpszContentType = m_szContentType;
		m_ecb.GetServerVariable = ::GetServerVariable;
		m_ecb.WriteClient = ::WriteClient;
		m_ecb.ReadClient = ::ReadClient;
		m_ecb.ServerSupportFunction = ::ServerSupportFunction;

		return m_pfnProc(&m_ecb);
	}
	return FALSE;
}

BOOL CISmokeDlg::ClearResult()
{
	m_strResult = _T("");
	UpdateData(FALSE);
	return(TRUE);
}

BOOL CISmokeDlg::RefreshResult()
{
	UpdateData(FALSE);
	return(TRUE);
}

BOOL CISmokeDlg::LoadDLL()
{
	BOOL fRet = TRUE;

	if(!m_hDLL)
	{
		if(!m_hDLL)
			m_hDLL = LoadLibrary(m_strDLLName);
		if(m_hDLL)
		{
			m_pfnVer = (pfnHttpExtVer)GetProcAddress(m_hDLL, "GetExtensionVersion");
			m_pfnProc = (pfnHttpExtProc)GetProcAddress(m_hDLL, "HttpExtensionProc");
			m_pfnTermExt = (pfnHttpTermExt)GetProcAddress(m_hDLL, "TerminateExtension");
		}
		if(!m_hDLL || !m_pfnVer || !m_pfnProc)
		{
			UnLoadDLL();
			return FALSE;
		}

		HSE_VERSION_INFO	hvi;
		fRet = m_pfnVer(&hvi);
		if (fRet)
		{
			m_dwExtensionVersion = hvi.dwExtensionVersion;
		}

	}
	return(fRet);
}

void CISmokeDlg::UnLoadDLL()
{
	if(m_hDLL)
	{
		if (m_pfnTermExt)
		{
			BOOL fT;
			fT = m_pfnTermExt(HSE_TERM_MUST_UNLOAD);
		}
		VERIFY(FreeLibrary(m_hDLL));
	}
	m_hDLL = NULL;
	m_pfnVer = NULL;
	m_pfnProc = NULL;
}

BOOL CISmokeDlg::GetServerVariable(LPSTR pszVarName, LPVOID pvAnswer, LPDWORD pcchAnswer)
{
	WORD ix;
	CHAR *(rgszVarName[19]) = 
			{
			"AUTH_TYPE",
			"AUTH_PASS",
			"CONTENT_LENGTH",
			"CONTENT_TYPE",
			"GATEWAY_INTERFACE",
			"PATH_INFO",
			"PATH_TRANSLATED",
			"QUERY_STRING",
			"SCRIPT_NAME",
			"SERVER_NAME",
			"SERVER_PORT",
			"SERVER_PROTOCOL",
			"SERVER_SOFTWARE",
			"HTTP_ACCEPT",
			"REMOTE_ADDR",
			"REMOTE_HOST",
			"REMOTE_USER",
			"ALL_HTTP",
			"HTTP_COOKIE"
			};
	
	CHAR *(rgszVarValue[26]) = 
			{
			"ISmoke:AUTH_TYPE",
			"ISmoke:AUTH_PASS",
			"ISmoke:CONTENT_LENGTH",
			"ISmoke:CONTENT_TYPE",
			"CGI/1.1",
			m_szPath,
			m_szPath,
			m_szQuery,
			"ISmoke:SCRIPT_NAME",
			"157.61.555.55",
			"80",
			"HTTP/1.0",
			"Microsoft-Internet-Information-Server/1.0",
			"*/*, q=0.300,audio/x-aiff,audio/basic,image/jpeg,image/gif,text/plain,text/html",
			"157.61.666.66",
			"157.61.666.66",
			"ISmoke:REMOTE_USER",
			"HTTP_ACCEPT:*/*, q=0.300,audio/x-aiff,audio/basic,image/jpeg,image/gif,text/plain,text/html\nHTTP_USER_AGENT:Mozilla/1.22 (compatible; MSIE1.5; Windows NT)\nHTTP_PRAGMA:no-cache",
			"DENALISESSIONID=ABC1234567890ABC"
			};
#define CVAR_MAX 19
	
	if(!pszVarName || !pvAnswer || !pcchAnswer)
		return FALSE;

	for (ix = 0; ix < CVAR_MAX; ix++)
		{
		if (0 == lstrcmp(pszVarName, rgszVarName[ix]))
			{
			DWORD cch = *pcchAnswer;
			
			strncpy((CHAR * const)pvAnswer, rgszVarValue[ix], *pcchAnswer);
			*pcchAnswer = lstrlen((CHAR *)pvAnswer) + 1;
			if (*pcchAnswer > cch)
				{
				*pcchAnswer = lstrlen(rgszVarValue[ix]) + 1;
				SetLastError(ERROR_INSUFFICIENT_BUFFER);
				return(FALSE);
				}
			else
				{
				return(TRUE);
				}
			}
		}
			
	*pcchAnswer = 0;
	SetLastError(ERROR_INVALID_INDEX);
	return FALSE;
}

BOOL CISmokeDlg::ServerSupportFunction(DWORD dwHSERRequest, LPVOID lpvBuffer, LPDWORD lpdwSize, LPDWORD lpdwDataType)
{
	switch(dwHSERRequest)
	{
	case HSE_REQ_DONE_WITH_SESSION:
		{
			// write whatever happened back to the dialog
			m_fNeedsUpdate = TRUE;
			PostMessage(WM_PAINT, 0, 0);

			// CONSIDER: We should be allocating and deallocating ECB's.  If
			// we do so, we would dealloc here.
			return TRUE;
			break;
		}
	case HSE_REQ_SEND_RESPONSE_HEADER:
		{
			m_strResult += (char*)lpdwDataType;
			return TRUE;
		}

	case HSE_REQ_SEND_URL_REDIRECT_RESP:
		{
			// UNDONE: NYI
			ASSERT(FALSE);
			return FALSE;
		}

	case HSE_REQ_SEND_URL:
		{
			// UNDONE: NYI
			ASSERT(FALSE);
			return FALSE;
		}

	default:
		{
			// Some unknown request.  An error
			ASSERT(FALSE);
			return FALSE;
		}
	}
}

BOOL CISmokeDlg::WriteClient(LPVOID lpvBuffer, LPDWORD lpdwBytes, DWORD dwReserved)
{
	if(lpvBuffer)
	{
		UINT cb = strlen((char*)lpvBuffer);
		ASSERT(cb == *lpdwBytes);
		m_strResult += (const char*)lpvBuffer;
		m_strResult += "\r\n";
	}
	return TRUE;
}

BOOL CISmokeDlg::ReadClient(LPVOID lpvBuffer, LPDWORD lpdwSize)
{
	if (lpvBuffer && *lpdwSize > 0)
		{
		strncpy((char *)lpvBuffer, m_szQuery, *lpdwSize);
		*lpdwSize = strlen((char *)lpvBuffer);
		}
	return TRUE;
}


void CISmokeDlg::OnGetRightDLL()
{
	CString	strOldDll = m_strDLLName;
	UpdateData(TRUE);
	if(!m_fDLLLoaded || m_strDLLName != strOldDll)
	{
		// if the name has changed, or they unchecked the checkbox,
		UnLoadDLL();
	}

	if(m_fDLLLoaded)
	{
		// if the checkbox is checked, try and load the named DLL.
		if(FALSE == (m_fDLLLoaded = LoadDLL()))
		{
			// if we failed, set the checkbox back
			UpdateData(FALSE);
		}
	}
}


void CISmokeDlg::OnRButtonDown(UINT nFlags, CPoint point) 
{
	// TODO: Add your message handler code here and/or call default
	
	CDialog::OnRButtonDown(nFlags, point);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\tools\src\ismoke\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	ISmoke.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\tools\src\ismoke\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

//#include "wininet.h"
#include "HTTPExt.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\tools\src\ismoke\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ismoke.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_ISMOKE_DIALOG               102
#define IDS_DOCLEAR                     102
#define IDS_DOREFRESH                   103
#define IDR_MAINFRAME                   128
#define IDR_CLEAR                       131
#define IDC_COMBO_PATH                  1001
#define IDC_EDIT_RESULT                 1002
#define IDC_COMBO_METHOD                1003
#define IDC_COMBO_STATEMENT             1004
#define IDC_COMBO_DLLNAME               1007
#define IDC_CHECK_LOADED                1008
#define ID_CLEAR                        32772
#define ID_REFRESH                      32773

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        133
#define _APS_NEXT_COMMAND_VALUE         32773
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\davcdata\_davcdata.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	_ D A V C D A T A . C P P 
//
//		DAV process precompiled header
//
//
//	Copyright 2000 Microsoft Corporation, All Rights Reserved
//

#include <_davcdata.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\davcdata\_davcdata.h ===
/*
 *	_ D A V C D A T A . H
 *
 *	Precompiled header sources
 *
 *	Copyright 2000 Microsoft Corporation, All Rights Reserved
 */

#ifndef	__DAVCDATA_H_
#define __DAVCDATA_H_

#pragma warning(disable:4001)	/* single line comments */
#pragma warning(disable:4050)	/* different code attributes */
#pragma warning(disable:4100)	/* unreferenced formal parameter */
#pragma warning(disable:4115)	/* named type definition in parentheses */
#pragma warning(disable:4127)	/* conditional expression is constant */
#pragma warning(disable:4201)	/* nameless struct/union */
#pragma warning(disable:4206)	/* translation unit is empty */
#pragma warning(disable:4209)	/* benign typedef redefinition */
#pragma warning(disable:4214)	/* bit field types other than int */
#pragma warning(disable:4514)	/* unreferenced inline function */
#pragma warning(disable:4200)	/* zero-sized array in struct/union */
#pragma warning(disable:4710)	//	(inline) function not expanded

//	Windows headers
//
//$HACK!
//
//	Define _WINSOCKAPI_ to keep windows.h from including winsock.h,
//	whose declarations would be redefined in winsock2.h,
//	which is included by iisextp.h,
//	which we include in davimpl.h!
//
#define _WINSOCKAPI_
#include <windows.h>
#include <winnls.h>

#endif	// __DAVCDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\davutil.cpp ===
/*
 *  d a v u t i l . c p p
 *
 *  Purpose:
 *      Little tools for DAVFS.
 *
 *  Owner:
 *      zyang.
 *
 *  Copyright (C) Microsoft Corp 1996 - 1997. All rights reserved.
 */


#include "_davfs.h"

BOOL FSucceededColonColonCheck(
	/* [in] */  LPCWSTR pwszURI)
{
	return !wcschr (pwszURI, L':');
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\diriter.cpp ===
/*
 *	D I R I T E R . C P P
 *
 *	Sources for directory ineration object
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"

DEC_CONST WCHAR gc_wszGlobbing[] = L"**";
DEC_CONST UINT gc_cchwszGlobbing = CElems(gc_wszGlobbing) - 1;

//	CDirState -----------------------------------------------------------------
//
SCODE
CDirState::ScFindNext (void)
{
	SCODE sc = S_OK;

	//	If the find has not yet been established, then
	//	do so here
	//
	if (m_hFind == INVALID_HANDLE_VALUE)
	{
		//	Establish the find handle
		//
		m_rpPathSrc.Extend (gc_wszGlobbing, gc_cchwszGlobbing, FALSE);
		m_hFind = FindFirstFileW (m_rpPathSrc.PszPath(), &m_fd);
		if (m_hFind == INVALID_HANDLE_VALUE)
		{
			sc = HRESULT_FROM_WIN32(GetLastError());
			goto ret;
		}
	}
	else
	{
		//	Just find the next file
		//
		if (!FindNextFileW (m_hFind, &m_fd))
		{
			sc = S_FALSE;
			goto ret;
		}
	}

	//	Extend the resource paths with the new values
	//
	Extend (m_fd);

ret:
	return sc;
}

//	CDirIter ------------------------------------------------------------------
//
SCODE
CDirIter::ScGetNext(
	/* [in] */ BOOL fSubDirectoryAccess,
	/* [in] */ LPCWSTR pwszNewDestinationPath,
	/* [in] */ CVRoot* pvrDestinationTranslation)
{
	SCODE sc = S_OK;

	//	If the current item is a directory, and we intend to
	//	do subdirectory iteration, then go ahead and try and
	//	push our context down to the child directory
	//
	if (m_fSubDirectoryIteration &&
		fSubDirectoryAccess &&
		FDirectory() &&
		!FSpecial())
	{
		//	Add a reference to the current directory state
		//	and push it onto the stack
		//
		m_pds->AddRef();
		m_stack.push_back (m_pds.get());

		//	Replace the current directory state with the new one
		//
		m_pds = new CDirState (m_sbUriSrc,
							   m_sbPathSrc,
							   m_sbUriDst,
							   pwszNewDestinationPath
								   ? pwszNewDestinationPath
								   : m_pds->PwszDestination(),
							   pvrDestinationTranslation
								   ? pvrDestinationTranslation
								   : m_pds->PvrDestination(),

							   m_fd);
	}

	//	Find the next file in the current context
	//
	sc = m_pds->ScFindNext();

	//	If S_FALSE was returned, then there were no more
	//	resources to process within the current context.
	//	Pop the previous context off the stack and use it
	//
	while ((sc != S_OK) && !m_stack.empty())
	{
		//	Get a reference to the topmost context on the
		//	stack and pop it off
		//
		m_pds = const_cast<CDirState*>(m_stack.back());
		m_stack.pop_back();

		//	Release the reference held by the stack
		//
		m_pds->Release();

		//	Clear and/or reset the find data
		//
		memset (&m_fd, 0, sizeof(WIN32_FIND_DATAW));

		//	See if this context had anything left
		//
		sc = m_pds->ScFindNext();
	}

	//	If we have completely exhausted the files to process
	//	make sure that we are not holding onto anything still!
	//
	if (sc != S_OK)
	{
		//	This should perform the last release of anything
		//	we still have open.
		//
		m_pds.clear();
	}

	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\crtfile.cpp ===
/*
 *	C R T F I L E . C P P
 *
 *	Wrapper for CreateFileW() such that path the "\\?\" path extension
 *	is prefixed onto each path before a call to CreateFileW() is made.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"

//$	REVIEW: undefine the following to have DAV not prefix the paths
//	passed to the WIN32 file system APIs.
//
#define	DAV_PREFIX_PATHS
//
//$	REVIEW: end.

//	Dav path prefix -----------------------------------------------------------
//
DEC_CONST WCHAR gc_wszPathPrefix[] = L"\\\\?\\";
DEC_CONST WCHAR gc_wszUncPathPrefix[] = L"UNC";


//	Prefixing macro -----------------------------------------------------------
//
//	Note that this is a macro so that the stack buffer legitmately remains
//	in scope for the duration of the macro's calling function
//
#define DavPrefix(_v)															\
	CStackBuffer<WCHAR,MAX_PATH> lpPrefixed ## _v;								\
	{																			\
		/*	Trim off the trailing slash if need be... */						\
		UINT cch = static_cast<UINT>(wcslen(lp ## _v));							\
		if (L'\\' == lp ## _v[cch - 1])											\
		{																		\
			/* Allow for "drive roots" */										\
			if ((cch < 2) || (L':' != lp ## _v[cch - 2]))						\
				cch -= 1;														\
		}																		\
																				\
		/*	Adjust for UNC paths */												\
		UINT cchUnc = 0;														\
		if ((L'\\' == *(lp ## _v) && (L'\\' == lp ## _v[1])))					\
		{																		\
			/*	Skip past the first of the two slashes */						\
			lp ## _v += 1;														\
			cch -= 1;															\
			cchUnc = CchConstString(gc_wszUncPathPrefix);						\
		}																		\
																				\
		/*	Prefix the path */													\
		UINT cchT = cch + CchConstString(gc_wszPathPrefix) + cchUnc;			\
																				\
		if (NULL == lpPrefixed ## _v.resize(CbSizeWsz(cchT)))					\
		{ SetLastError(ERROR_NOT_ENOUGH_MEMORY); return FALSE; }				\
																				\
		memcpy (lpPrefixed ## _v.get(),											\
				gc_wszPathPrefix,												\
				sizeof(gc_wszPathPrefix));										\
		memcpy (lpPrefixed ## _v.get() + CchConstString(gc_wszPathPrefix),		\
				gc_wszUncPathPrefix,											\
				cchUnc * sizeof(WCHAR));										\
		memcpy (lpPrefixed ## _v.get() +										\
					CchConstString(gc_wszPathPrefix) +							\
					cchUnc,														\
				lp ## _v,														\
				CbSizeWsz(cch));												\
																				\
		/*	Terminate the path */												\
		lpPrefixed ## _v[cchT] = 0;												\
	}																			\

//	DavCreateFile() -----------------------------------------------------------
//
HANDLE __fastcall DavCreateFile (
	/* [in] */ LPCWSTR lpFileName,
	/* [in] */ DWORD dwDesiredAccess,
	/* [in] */ DWORD dwShareMode,
	/* [in] */ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	/* [in] */ DWORD dwCreationDisposition,
	/* [in] */ DWORD dwFlagsAndAttributes,
	/* [in] */ HANDLE hTemplateFile)
{
#ifdef	DAV_PREFIX_PATHS

	DavPrefix(FileName);
	return CreateFileW (lpPrefixedFileName.get(),
						dwDesiredAccess,
						dwShareMode,
						lpSecurityAttributes,
						dwCreationDisposition,
						dwFlagsAndAttributes,
						hTemplateFile);

#else

	return CreateFileW (lpFileName,
						dwDesiredAccess,
						dwShareMode,
						lpSecurityAttributes,
						dwCreationDisposition,
						dwFlagsAndAttributes,
						hTemplateFile);

#endif	// DAV_PREFIX_PATHS
}

//	DavDeleteFile() -----------------------------------------------------------
//
BOOL __fastcall DavDeleteFile (
	/* [in] */ LPCWSTR lpFileName)
{
#ifdef	DAV_PREFIX_PATHS

	DavPrefix(FileName);
	return DeleteFileW (lpPrefixedFileName.get());

#else

	return DeleteFileW (lpFileName);

#endif	// DAV_PREFIX_PATHS
}

//	DavCopyFile() -------------------------------------------------------------
//
BOOL __fastcall DavCopyFile (
	/* [in] */ LPCWSTR lpExistingFileName,
	/* [in] */ LPCWSTR lpNewFileName,
	/* [in] */ BOOL bFailIfExists)
{
#ifdef	DAV_PREFIX_PATHS

	DavPrefix(NewFileName);
	DavPrefix(ExistingFileName);
	return CopyFileW (lpPrefixedExistingFileName.get(),
					  lpPrefixedNewFileName.get(),
					  bFailIfExists);

#else

	return CopyFileW (lpExistingFileName,
					  lpNewFileName,
					  bFailIfExists);

#endif	// DAV_PREFIX_PATHS
}

//	DavMoveFile() -------------------------------------------------------------
//
BOOL __fastcall DavMoveFile (
	/* [in] */ LPCWSTR lpExistingFileName,
	/* [in] */ LPCWSTR lpNewFileName,
	/* [in] */ DWORD dwReplace)
{
#ifdef	DAV_PREFIX_PATHS

	DavPrefix(NewFileName);
	DavPrefix(ExistingFileName);
	return MoveFileExW (lpPrefixedExistingFileName.get(),
						lpPrefixedNewFileName.get(),
						dwReplace);

#else

	return MoveFileExW (lpExistingFileName,
						lpNewFileName,
						dwReplace);

#endif	// DAV_PREFIX_PATHS
}

//	DavCreateDirectory() ------------------------------------------------------
//
BOOL __fastcall DavCreateDirectory (
	/* [in] */ LPCWSTR lpFileName,
	/* [in] */ LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
#ifdef	DAV_PREFIX_PATHS

	DavPrefix(FileName);
	return CreateDirectoryW (lpPrefixedFileName.get(),
							 lpSecurityAttributes);

#else

	return CreateDirectoryW (lpFileName,
							 lpSecurityAttributes);

#endif	// DAV_PREFIX_PATHS
}

//	DavRemoveDirectory() ------------------------------------------------------
//
BOOL __fastcall DavRemoveDirectory (
	/* [in] */ LPCWSTR lpFileName)
{
#ifdef	DAV_PREFIX_PATHS

	DavPrefix(FileName)
	return RemoveDirectoryW (lpPrefixedFileName.get());

#else

	return RemoveDirectoryW (lpFileName);

#endif	// DAV_PREFIX_PATHS
}

//	DavGetFileAttributes() ----------------------------------------------------
//
BOOL __fastcall DavGetFileAttributes (
	/* [in] */ LPCWSTR lpFileName,
	/* [in] */ GET_FILEEX_INFO_LEVELS fInfoLevelId,
	/* [out] */ LPVOID lpFileInformation)
{
#ifdef	DAV_PREFIX_PATHS

	DavPrefix(FileName);
	return GetFileAttributesExW (lpPrefixedFileName.get(),
								 fInfoLevelId,
								 lpFileInformation);

#else

	return GetFileAttributesExW (lpFileName,
								 fInfoLevelId,
								 lpFileInformation);

#endif	// DAV_PREFIX_PATHS
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\davcdata\davcdata.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	D A V C D A T A . C P P
//
//		HTTP 1.1/DAV 1.0 request handling via ISAPI
//
//      DAVCDATA is the dav process executable for storing handles that should
//      not be recycled when worker process recycle.  It also contains the timing
//      code for timing out locks, and it establishes the shared memory for 
//      the DAV worker processes.
//
//      This process must run under the same identity as the worker processes.
//
//	Copyright 2000 Microsoft Corporation, All Rights Reserved
//
/////////////////////////////////////////////////////////////////////////////

#include "_davcdata.h"
#include <shlkcache.h>
#include <caldbg.h>

// Code borrowed from htpext mem.cpp so we have use of the global heap.
#define g_szMemDll L"staxmem.dll"
#include <autoptr.h>
#include <mem.h>
#include <memx.h>
#include <implstub.h>


//	Mapping the exdav non-throwing allocators to something local
//
LPVOID __fastcall ExAlloc( UINT cb )				{ return g_heap.Alloc( cb ); }
LPVOID __fastcall ExRealloc( LPVOID pv, UINT cb )	{ return g_heap.Realloc( pv, cb ); }
VOID __fastcall ExFree( LPVOID pv )					{ g_heap.Free( pv ); }

VOID IncrementGlobalPerfCounter( UINT iCounter )
{
    // exceptions in DAVCData are not counted in perf counters (for now)
    // BUGBUG:  Decide if they should be.
}

#ifdef	DBG
BOOL g_fDavTrace = FALSE;
const CHAR gc_szDbgIni[] = "DAVCData.INI";
#endif

// Signature must match that of HTTPEXT's so that the shared memory heap is
// shared between the two processes.
//
EXTERN_C const WCHAR gc_wszSignature[]	= L"HTTPEXT";

// Timer constants and globals.
//
const DWORD WAIT_PERIOD = 60000;   // 1 min = 60 sec = 60,000 milliseconds

//	Event used to notify the existence of davcdata process
//
HANDLE	g_hEventDavCDataUp = NULL;

//	Array of handles we could wait on
//
class CDavCDataHandles
{
	enum
	{
		MAX_TIMER_HANDLE = 8,
		MAX_WAIT_HANDLE = 128
	};
	enum
	{
		ih_new_wp,
		ih_delete_timer,
		c_events,
		ih_wp = c_events
	};
				
		
private:
			
	HANDLE		m_rgHandles[MAX_WAIT_HANDLE];	//	Array of handles	
	ULONG		m_cHandlesWaiting;
	ULONG		m_uiAddStart;		// Start index of handles added
	ULONG		m_uiAdd;			// next index to add a handle

	//	Array of timers to be deleted. 
	//	Using a fixed array, I don't believe we have more
	//	
	HANDLE		m_rgTimers[MAX_TIMER_HANDLE];
	ULONG		m_cTimersToDelete;
	

	LONG	m_lInUse;
	
public:
	CDavCDataHandles() :
			m_cHandlesWaiting(0),
			m_cTimersToDelete(0),
			m_uiAddStart(0),
			m_uiAdd(0),
			m_lInUse(0)
	{}

	VOID	Lock()
	{
		//	Simple spinlock
		//
		while (1 == InterlockedCompareExchange (&m_lInUse, 1, 0))
		{
			Sleep(1);	// Sleep 1 millisecond
		}		
	}
	
	VOID	Unlock()
	{
		Assert (1 == m_lInUse);
		InterlockedDecrement(&m_lInUse);
	}

	ULONG	CHandlesWaiting() { return m_cHandlesWaiting; }
	HANDLE * PHandlesWaiting() { return m_rgHandles; }
	
	SCODE	ScInit();
	BOOL	FAddNewWP(DWORD dwClientProcess);
	VOID	Refresh();
	BOOL	FDeleteWPHandle (ULONG ulIndex);
	VOID	AddTimerToDelete (HANDLE hTimer);
	VOID	DeleteTimer();

	static DWORD __stdcall DwWaitForWPShutdown (PVOID pvThreadData);
};

CDavCDataHandles	g_handles;

// ===============================================================
// Supporting class definitions
// ===============================================================

#include "shlkcache.h"

//  CWasLockCache holds the global information needed to handle
//  any requests that the pipeline receives (or that bypass the pipeline)
//  for setting up and maintaining the Shared Memory Lock Cache.
//
class CWasLockCache
{
private:
	
    // Private functions for processing
	//
    LONG    m_lTimerLaunched;
    HANDLE  m_hNewTimer;
	
    // Shared Memory objects
	//
    SharedPtr<CInShLockCache> m_spCache;
    SharedPtr<CInShCacheStatic> m_spStatic; 

    //	NOT IMPLEMENTED
	//
	CWasLockCache& operator=( const CWasLockCache& );
	CWasLockCache( const CWasLockCache& );

public:

    CWasLockCache() {};

	// Initialize sets up all variables that would normally be set in the constructor.
	// It is done this way to avoid linking issues surronding when the global object
	// g_wlc's constructor would be called.
	//
    VOID Initialize() 
	{
        m_lTimerLaunched = 0;
		m_hNewTimer = INVALID_HANDLE_VALUE;
	};

    HRESULT SetupSharedCache();
    HANDLE SaveHandle(DWORD OrigProcess, HANDLE SavingHandle);
    VOID LaunchLockTimer();
	VOID DeleteLockTimer();
    VOID ExpireLocks();

	BOOL FEmpty() { return m_spCache.FIsNull() || m_spCache->FEmpty(); }
};

CWasLockCache g_wlc;

//	Implement a waiting thread listens to WP shutdown event
//
DWORD __stdcall
CDavCDataHandles::DwWaitForWPShutdown(PVOID pvThreadData)
{	
	DWORD dwRet;

	while (1)
	{
		dwRet = WaitForMultipleObjects (g_handles.CHandlesWaiting(),	//	nCount
										g_handles.PHandlesWaiting(),	// lpHandles,
										FALSE,			// fWaitAll,
										INFINITE);		// wait forever
		switch (dwRet)
		{
			case WAIT_OBJECT_0 + ih_new_wp:
				g_handles.Refresh();
				break;

			case WAIT_OBJECT_0 + ih_delete_timer:
				g_handles.DeleteTimer();
				break;

			default:
				if (FALSE == g_handles.FDeleteWPHandle(dwRet - WAIT_OBJECT_0))
				{
					//	This means WaitForMultipleObject fails for some unknown reason
					//
					DebugTrace ("WaitForMultipleObject returns %d, last error = %d\n",
								dwRet, GetLastError());
				}
				break;
		}
	};
	
	return 0;
}
			
//	CDavCDataHandles functions

//	CDavCDataHandles::ScInit
//
SCODE
CDavCDataHandles::ScInit()
{
	SCODE	sc = S_OK;
	HANDLE	hWaitingThread;
	
	//	Create the event that used to notify the arrival of new event
	//
	m_rgHandles[ih_new_wp] =  CreateEvent (NULL,		// lpEventAttributes
										   FALSE,			// bManualReset
										   FALSE,	// bInitialState
										   NULL);
	if (m_rgHandles[ih_new_wp] == NULL)
	{
		DebugTrace ("CreateEvent failed %d\n", GetLastError());
		sc = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}

	//	Create the event that listens for timer deletion
	//
	m_rgHandles[ih_delete_timer] =  CreateEvent (NULL,		// lpEventAttributes
												FALSE,		// bManualReset
												FALSE,	// bInitialState
												NULL);	// lpName
	if (m_rgHandles[ih_delete_timer] == NULL)
	{
		DebugTrace ("CreateEvent failed %d\n", GetLastError());
		sc = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}

	m_cHandlesWaiting = c_events;

	//	Now create thread that waits on these events and wp handles
	//
	hWaitingThread = CreateThread (NULL,	// lpThreadAttributes
								   0,		// dwStackSize, ignored
								   CDavCDataHandles::DwWaitForWPShutdown,	// lpStartAddress
								   NULL,				// lpParam
								   0,				// Start immediately
								   NULL);			// lpThreadId
	if (NULL == hWaitingThread)
	{
		DebugTrace ("HandleNewWorkerProcess - Failed to create thread\n");
		sc = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}
	
	//	We don't need to thread handle. but we need to close the handle to avoid
	//	having the thread object remains in the system forever.
	//
	CloseHandle(hWaitingThread);

	m_uiAddStart = c_events;
	m_uiAdd = c_events;
	
ret:
	return sc;
}

//	CDavCDataHandles::FAddNewWP
//
//	The only thread call this function is ScNamedPipeListener,
//
BOOL
CDavCDataHandles::FAddNewWP (DWORD dwClientProcess)
{
	//	Open the worker process handle so that we can synchronize on
	//
	HANDLE hWP = OpenProcess(SYNCHRONIZE, false, dwClientProcess);

	if (NULL == hWP)
	{
		DebugTrace ("Failed to open worker process, last error %d\n", GetLastError());
		return FALSE;
	}
	
	Lock();
	
	m_rgHandles[m_uiAdd++] = hWP;

	Unlock();

	//	Now inform the waiting thread we have one more WP to wait for
	//
	SetEvent (m_rgHandles[ih_new_wp]);

	return TRUE;
}

//	CDavCDataHandles::Refresh
//
//	This method is called from waiting thread
//
VOID
CDavCDataHandles::Refresh ()
{
	Lock();
	for (ULONG i=m_uiAddStart; i<m_uiAdd; i++)
		m_rgHandles[m_cHandlesWaiting++] = m_rgHandles[i];

	m_uiAddStart = m_cHandlesWaiting;
	m_uiAdd = m_uiAddStart;
	
	Unlock();
}

//	CDavCDataHandles::DeleteWPHandle
//
//	This is called from the waiting thread
//
BOOL
CDavCDataHandles::FDeleteWPHandle(ULONG ulIndex)
{
	if ((ulIndex < c_events) ||
		(ulIndex >= m_cHandlesWaiting))
	{
		//	This must be an error in WaitForMultpleObject.
		//	Don't think we can do anything here
		//
		return FALSE;
	}

	//	Close the process handle
	//
	CloseHandle (m_rgHandles[ulIndex]);
				 
	//	No need to lock this operation, because we are the only
	//	thread that could touch m_chandlesWaiting
	
	//	Move the rest of handles forward
	//	
	for (ULONG i = ulIndex; i < m_cHandlesWaiting-1; i++)
		m_rgHandles[i] = m_rgHandles[i+1];

	m_cHandlesWaiting--;

	if ((m_cHandlesWaiting == c_events) && g_wlc.FEmpty())
	{
		//$REVIEW: Is this the right way to stop this process?
		//
		//$REVIEW: Another problem is that there may be outstanding
		// worker processes whose first DO_NEW_WP request is on
		// its way but we haven't finished processing it. 
		// To cover this problem, we try ScStartDavCData twice
		// from the worker process side.
		//
		ExitProcess (0);
	}

	return TRUE;
}

//	CDavCDataHandles::AddTimerToDelete
//
//		This method is called from the timer callback
//
VOID
CDavCDataHandles::AddTimerToDelete(HANDLE h)
{
	Lock();
	m_rgTimers[m_cTimersToDelete++] = h;
	Unlock();

	//	Notify waiting thread that a timer needs to be deleted
	//
	SetEvent (m_rgHandles[ih_delete_timer]);
}

//	CDavCDataHandles::DeleteTimer
//
//		This method is called from the waiting thread
//
VOID
CDavCDataHandles::DeleteTimer()
{
	HANDLE	rgTimers[MAX_TIMER_HANDLE];
	LONG	cTimers;
	LONG	i;

	//	Copy the timer handles locally, so that we can do
	//	the DeleteTimerQueueTimer outside the lock
	//	Otherwise, we may form a deadlock with timer callback
	//
	Lock();
	
	cTimers = m_cTimersToDelete;
	
	for (i=0; i<cTimers; i++)
	{
		rgTimers[i] = m_rgTimers[i];
	}

	m_cTimersToDelete = 0;
	
	Unlock();
	
	for (i=0; i<cTimers; i++)
	{
		if (!DeleteTimerQueueTimer(NULL,		//default timer queue
								   rgTimers[i],	// timer
								   INVALID_HANDLE_VALUE))	// blocking call
		{
			DebugTrace ("DeleteTimerQueueTimer failed %d\n", GetLastError());
		}
	}

	if ((m_cHandlesWaiting == c_events) && g_wlc.FEmpty())
	{
		//$REVIEW: Is this the right way to stop this process?
		//
		//$REVIEW: Another problem is that there may be outstanding
		// worker processes whose first DO_NEW_WP request is on
		// its way but we haven't finished processing it. 
		// To cover this problem, we try ScStartDavCData twice
		// from the worker process side.
		//
		ExitProcess (0);
	}
}


///////////////////////////////////////////////////////////////////
// Stub Functions used for supporting skipping of pipeline calls
///////////////////////////////////////////////////////////////////

//
//  Used to by-pass the named pipe calls when asking DAVCData to save
//  a handle value.  This is because we are all ready in the DAVCData
//  process.  It is useful when _shmem is trying to save it's handles.
//
VOID __fastcall
IMPLSTUB::SaveHandle(HANDLE h)
{
    g_wlc.SaveHandle(GetCurrentProcessId(), h);
}

VOID
PIPELINE::SaveHandle(HANDLE h)
{
    g_wlc.SaveHandle(GetCurrentProcessId(), h);
}
//
//  Used to by-pass the named pipe calls when asking DAVCData to release
//  a handle.  This is because we are all ready in the DAVCData
//  process.  This is useful during timing out of locks.
//
VOID
PIPELINE::RemoveHandle(HANDLE hDAVHandle)
{
    CloseHandle(hDAVHandle);
}

//
//  Stub function for Duplicating handles.  DAVCData should not use
//  but needs a definition since pipeline.h defines it.
//
HRESULT DupHandle(HANDLE i_hOwningProcess
                  , HANDLE i_hOwningProcessHandle
                  , HANDLE* o_phCreatedHandle)
{
    Assert(0);
    return E_FAIL;
}

// ===============================================================
// Lock Timer Callback function
// ===============================================================

//
//  Function is a callback function that CreateTimerQueueTimer routine
//  will call when the timer queue fires.  It's purpose is to run 
//  through all the locks and validate they are still valid, or release
//  the handles associated with them, and then reset the timer.
//
VOID WINAPI CheckLocks(void* pvIgnored, BOOLEAN fIgnored)
{
    g_wlc.ExpireLocks();

    DebugTrace("Done Expiring Locks\r\n");
}


// ===============================================================
// CWasLockCache (public functions)
// ===============================================================

//
//  Function expires any locks that have timed out
//
VOID CWasLockCache::ExpireLocks()
{
    // Assuming we have a valid cache, tell the cache to do it's house cleaning.
	//
    if (!m_spCache.FIsNull())
	{
		//	Do the real work
		//
        m_spCache->ExpireLocks();

		if (m_spCache->FEmpty())
		{
			HANDLE hTimerToDelete = m_hNewTimer;

			//	Allow new timer to be created
			//
			InterlockedExchange (&m_lTimerLaunched, 0);

			if (!m_spCache->FEmpty())
			{
				//	Some new locks just added into the cache, and we 
				//	don't know for sure if a new timer was started.
				//	Try to launch one anyway
				//
				LaunchLockTimer();
			}

			//	We must delete the old timer, however, we can't do this
			//	in the time callback
			//
			g_handles.AddTimerToDelete (hTimerToDelete);
		}
	}
}

//
//  Function launches the time if the timer has not been launched yet.
//
VOID CWasLockCache::LaunchLockTimer()
{
    if (InterlockedCompareExchange(&m_lTimerLaunched, 1, 0) == 0)
    {
		if (!CreateTimerQueueTimer(&m_hNewTimer, // timer that we created
								   NULL,         // use default timer queue
								   &CheckLocks,  // function that will check the locks in the cache 
												 // and release any expired locks.
								   NULL,         // parameter to the callback function
								   WAIT_PERIOD,  // how long to wait before calling the callback function 
												 // the first time.
								   WAIT_PERIOD,  // how long to wait between calls to the callback function
								   WT_EXECUTEINIOTHREAD))  // where to execute the function call..
        {
            DebugTrace("Failed to CreateTimerQueueTimer last error = %d\r\n", GetLastError());

            // Set back the flags so we know that the timer isn't running.
			//
            InterlockedExchange(&m_lTimerLaunched, 0);
        }
    }
}

//
//  Routine initilizes the shared cache and causes the m_spCache
//  and m_spStatic variables to be linked to their shared memory 
//  objects.
//
HRESULT CWasLockCache::SetupSharedCache()
{
    return InitalizeSharedCache(m_spCache, m_spStatic, TRUE);
}

//
//  Routine will duplicate the handle that is passed in, using the
//  original process that owns the passed in handle.  It will then 
//  return the handle to the caller.  Any failure and INVALID_HANDLE_VALUE
//  will be returned.
//
//  CODEWORK:  Could return errors via LastError if neccessary.
//
HANDLE CWasLockCache::SaveHandle(DWORD OrigProcess, HANDLE SavingHandle)
{
    HANDLE h = INVALID_HANDLE_VALUE;

    HANDLE hOrigProcess = OpenProcess(PROCESS_DUP_HANDLE, false, OrigProcess);
    if (hOrigProcess==NULL)
    {
        DebugTrace ("Getting Orig Process Failed \r\n");
        return h;
    }

    if (!DuplicateHandle(hOrigProcess, SavingHandle, GetCurrentProcess(), &h, 0, FALSE, DUPLICATE_SAME_ACCESS))
    {
        DebugTrace("Failed to Dup Handle \r\n");
    }

	DebugTrace("SaveHandle - Handle %x from process %d is duplicated to %x\n", SavingHandle, OrigProcess, h);

	CloseHandle (hOrigProcess);
	
    return h;
}


//
//  Function is used to initalize the shared memory.  Once it has 
//  created the global heap for the process and has initalized the 
//  shared memory heap, it will then use the InitalizeSharedCache 
//  routine to setup the shared memory as expected for a lock cache.
//
HRESULT ScInitialize()
{
    HRESULT hr = S_OK;

	g_wlc.Initialize();

    // Setup the global heap for the process.
	//
    if (!g_heap.FInit())
    {
        DebugTrace("Initalizing Heap Failed \r\n");
		hr = E_OUTOFMEMORY;
        goto ret;
    }

	//	Initialize waiting handles
	//
	hr = g_handles.ScInit();
	if (FAILED(hr))
		goto ret;
	
    // Now we can setup the shared memory appropriately.
	//
    hr = g_wlc.SetupSharedCache();
    if (FAILED(hr))
		goto ret;

	//	Create the event thread that can be used to inform work processes
	//
	g_hEventDavCDataUp = CreateEvent (NULL,		// lpEventAttributes
									  TRUE,		// bManualReset
									  FALSE,	// bInitialState
									  g_szEventDavCData);
	if (NULL == g_hEventDavCDataUp)
	{
		DebugTrace ("Davcdata - Failed to create event\n");
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ret;
	}	

	
ret:
    return hr;
}

//
//  Routine will duplicate the handle that is passed in, using the
//  original process that owns the passed in handle.  It will then 
//  save the handle in the appropriate shared memory location.  
//
VOID LockFile(DWORD OrigProcess, HANDLE SavingHandle, LPVOID pshLockData)
{
	if (pshLockData)
	{
		HANDLE h = g_wlc.SaveHandle(OrigProcess, SavingHandle);

		if (h != INVALID_HANDLE_VALUE)
		{
			// CODEWORK:  Could also set in the davprocess id here, but then we would have issues 
			//            with each lock data needing to open it's own davcdata process.  Might be nice
			//            to save it anywhere here, and then use it as a way to tell if DAVCData recycled
			//            and a wp kept shared memory open.

			// Get a shared pointer to the object.
			//
			SharedPtr<CInShLockData> spLockData;

			// If we succeed in binding to the object then we can go ahead and set the value in.
			//
			if (spLockData.FBind(*(SharedHandle<CInShLockData>*)pshLockData))
			{
				spLockData->SetDAVProcFileHandle(h);
				g_wlc.LaunchLockTimer();
			}
			else
			{
				// If we think that we are saving a file for a lock, but the lock data
				// is gone, then we best just release our hold on the file.
				//
				CloseHandle(h);
			}
		}
    }

}

// ===============================================================
// Named pipe routines.
// ===============================================================

//
//  Function handles listening for named pipe communications from the
//  worker process and sends the requests to there supporting functions.
//
SCODE ScNamedPipeListener()
{
    SCODE sc = S_OK;
    DWORD dwAction = 0;
    DWORD dwClientProcess = 0;
    HANDLE hClientHandle = 0;
    DWORD dwErr = 0;
    DWORD outBufSize    =0;
    LPVOID pVoid = NULL;

    // Buffer for retrieving data from the caller.
	//
    BYTE outBuf[PIPE_MESSAGE_SIZE];

    // Create the named pipe communication.
	//
    HANDLE hNamedPipe = CreateNamedPipe("\\\\.\\pipe\\SaveHandle"                   // pipe name
                                        , PIPE_ACCESS_DUPLEX       // pipe open mode
                                        , PIPE_TYPE_MESSAGE   | PIPE_WAIT      // pipe-specific modes
                                        , 1                         // maximum number of instances
                                        , 0                         // output buffer size (bytes)
                                        , 32                        // input buffer size (bytes)
                                        , 3000                      // time-out interval (milliseconds = 3 seconds)
                                        , NULL);                      // Security Descriptor

    if (hNamedPipe == INVALID_HANDLE_VALUE)
    {
        sc = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

	//	No inform the worker processes that DAVCData is available
	//
	Assert (g_hEventDavCDataUp);
	if (!SetEvent (g_hEventDavCDataUp))
	{
        sc = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
	}

    do
    {
        // Wait for the client to signal that data is on the line.
		//
        if (!ConnectNamedPipe(hNamedPipe, NULL))
        {
			//	The function may still return zero even if client connects in the interval
			//	between the call to CreateNamedPipe() and the call to ConnectNamedPipe().
			//	In that case the last error will be ERROR_PIPE_CONNECTED that will indicate that
			//	there is already good connection between the client and server processes
			//
			if (ERROR_PIPE_CONNECTED != GetLastError())
			{
	            DebugTrace("ScNamedPipeListener() - ConnectNamedPipe() failed with error 0x%08lX, retrying.\r\n", GetLastError());

	            // Loop and try again to wait.
				//
		        continue;
			}
        }

        // Get the data from the line.
		//
        if (!ReadFile(hNamedPipe, (LPVOID) outBuf, PIPE_MESSAGE_SIZE, &outBufSize, NULL))
        { 
            // CODEWORK:  Do we still need this special error case, now that we are not reading the 
            //            data in two passes?
            // On the first call into read (per instance of the holder object) ERROR_MORE_DATA
            // is returned from ReadFile, which is expected.  However, on subsequent client 
            // sessions it is not returned (which is strange since there is more data in 
            // to be read below.  In either case if we continue on, everything works correctly.
			//
            dwErr = GetLastError();
            if (dwErr != ERROR_MORE_DATA)
            {
                sc = HRESULT_FROM_WIN32(dwErr);
                goto disconnect;
            }
        }

        // Verify we got the size of the data we expected.
		//
        if (outBufSize != PIPE_MESSAGE_SIZE)
        {
            DebugTrace("Output buffer size did not equal the # of dwords expected \r\n");
            goto disconnect;
        }

        // Break the data out into the appropriate variables.
		//
        dwAction = *((DWORD*)outBuf);
        dwClientProcess = *((DWORD*) (outBuf+sizeof(DWORD)));
        hClientHandle = *((HANDLE*) (outBuf+2*sizeof(DWORD)));
        pVoid = (LPVOID)(outBuf+2*sizeof(DWORD)+sizeof(HANDLE));

		DebugTrace("Action = %d, Client Handle = %x, Client Process = %d\n",
				   dwAction,
				   hClientHandle,
				   dwClientProcess);

        // End of code to be removed (see BUGBUG above)
		
        // Launch the appropriate function to process the request.
        // NOTE: handles are duplicated here and PREFIX finds the path
        // that we are not releasing them on error (DisconnectNamedPipe()
        // failure), but the thing is that on error we will terminate the
        // process and the handles will still be released, so does not
        // help us if we try to handle that in any way.
        //
        switch (dwAction)
        {
			case DO_NEW_WP:
				(VOID)g_handles.FAddNewWP(dwClientProcess);
				break;
				
            case DO_SAVE:
                g_wlc.SaveHandle(dwClientProcess, hClientHandle);
				break;

            case DO_LOCK:
                LockFile(dwClientProcess, hClientHandle, pVoid);
				break;

            case DO_REMOVE:
                CloseHandle (hClientHandle);
			    break;

            default:
                DebugTrace("Invalid action %i sent in \r\n", dwAction);
        }


disconnect:

        // Release the client from the named pipe so another client can call in.
		//
        if (!DisconnectNamedPipe(hNamedPipe))
        {
            sc = HRESULT_FROM_WIN32(GetLastError());
            goto cleanup;
        }
		
    } while (TRUE);

cleanup:

	return sc;
}

// ===============================================================
// Main Routine
// ===============================================================

//
//	Setting up the shared memory for the lock cache and 
//  establishing the listener who will support the worker processes
//  storing and releasing file handles.
//
int _cdecl main ()
{
	CSmhInit	si;
    SCODE	sc = S_OK;

	//	Initlize shared memory
	//
	if (FALSE == si.FInitialize(gc_wszSignature))
	{
		DebugTrace ("Failed to initialize shared memory\n");
		sc = E_FAIL;
		goto ret;
	}		
		
    sc = ScInitialize();
    if (FAILED(sc))
		goto ret;

    // If we have setup the shared memory then we are ready to take request
	// to save handles, and start timing out locks.
	//
    sc = ScNamedPipeListener();
    if (FAILED(sc))
		goto ret;


ret:  
	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\entry.cpp ===
/*
 *	E N T R Y . C P P
 *
 *	Entrypoints for Caligula DLLs
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"
#include "_shlkmgr.h"
#include <langtocpid.h>
#include <ex\idlethrd.h>
#include <ntverp.h>
#include <iisver.h>

//	Global items --------------------------------------------------------------
//
EXTERN_C const CHAR gc_szSignature[]	= "HTTPEXT";
EXTERN_C const WCHAR gc_wszSignature[]	= L"HTTPEXT";
HINSTANCE g_hinst						= NULL;
WCHAR gc_wszDllPath[MAX_PATH+1];

CHAR gc_szVersion[] = VER_PRODUCTVERSION_STR;

//	Per process instance data -------------------------------------------------
//
class CImplInst : private RefCountedGlobal<CImplInst, HSE_VERSION_INFO *>
{
	//
	//	Friend declarations required by RefCountedGlobal template
	//
	friend class Singleton<CImplInst>;
	friend class RefCountedGlobal<CImplInst, HSE_VERSION_INFO *>;

	//
	//	Flags to track initialization progress so we know
	//	how much to uninitialize if initialization fails overall
	//
	BOOL m_fInitializedHeap;

	//	CREATORS
	//
	//	Declared private to ensure that arbitrary instances
	//	of this class cannot be created.  The Singleton
	//	template (declared as a friend above) controls
	//	the sole instance of this class.
	//
	CImplInst() :
		m_fInitializedHeap(FALSE)
	{
	}
	BOOL FInit( HSE_VERSION_INFO * pver );
	~CImplInst();

	//
	//	Array of strings used in service state change
	//	event log messages.
	//
	static LPCSTR mc_rgszLogServiceStateChange[];

	//	NOT IMPLEMENTED
	//
	CImplInst( const CImplInst& );
	CImplInst& operator=( const CImplInst& );

public:
	using RefCountedGlobal<CImplInst, HSE_VERSION_INFO *>::DwInitRef;
	using RefCountedGlobal<CImplInst, HSE_VERSION_INFO *>::DeinitRef;
};

LPCSTR CImplInst::mc_rgszLogServiceStateChange[] = { gc_szSignature, gc_szVersion };

STGOPENSTORAGEONHANDLE		g_pfnStgOpenStorageOnHandle = NULL;

#ifdef	DBG
BOOL g_fDavTrace = FALSE;
const CHAR gc_szDbgIni[] = "HTTPEXT.INI";
#endif

//	------------------------------------------------------------------------
//
//	CImplInst::FInit()
//
//	Second-phase (failable) CImplInst constructor.  Code that instantiates
//	the CImplInst should call this function after instantiation.  If the
//	call returns FALSE, calling code should immediately destroy the
//	CImplInst.
//
BOOL
CImplInst::FInit( HSE_VERSION_INFO * pver )
{
	BOOL fSuccess = FALSE;

	//
	//	Handle exceptions locally.  If anything below throws
	//	an exception then fail the initialization.
	//
	try
	{
		HINSTANCE hLib;

		//	First and foremost, check to ensure that
		//	our resources are well attached and accessible
		//	if this fails, then we want to fail our loading.
		//
		if (!LoadStringA (g_hinst,
						  IDS_ExtensionName,
						  pver->lpszExtensionDesc,
						  sizeof(pver->lpszExtensionDesc)))
			goto Exit;

		//	Setup the HSE version numbering
		//
		pver->dwExtensionVersion = MAKELONG (HSE_VERSION_MINOR, HSE_VERSION_MAJOR);

#ifdef	DBG
		//	Do the DBG tracing initialization
		//
		g_fDavTrace = GetPrivateProfileIntA (gc_szDbgTraces,
											 gc_szSignature,
											 FALSE,
											 gc_szDbgIni);
#endif	// DBG

		//	Init the heap allocators
		//
		if ( !g_heap.FInit() )
			goto Exit;
		m_fInitializedHeap = TRUE;

		//	Initialize the resource string cache
		//
		if ( !FInitResourceStringCache() )
			goto Exit;

		//	Open the Caligula performance counters
		//
		if ( !FInitPerfCounters( NULL ) )
			goto Exit;

		//	Init the volume type cache
		//
		if ( !FInitVolumeTypeCache() )
			goto Exit;

		//	Init the parser
		//
		if ( !CDAVExt::FVersion (pver) )
			goto Exit;

		//	Create shared lock mgr
		//
		CSharedLockMgr::CreateInstance();
				
		//	Create the thread pool
		//
		if (!CPoolManager::FInit())
			goto Exit;

		//	Start the idle thread
		//
		if ( !FInitIdleThread() )
			goto Exit;

		//	Init the cache mapping accept language string to cpid
		//	cache used to decode non-UTF8 characters in URLs
		//
		if (!CLangToCpidCache::FCreateInstance())
			goto Exit;

		//	If this API is not available on ole32.dll. we'll not be able
		//	to operate properties, but we should still work to some extent
		//	so we'll take care of the NULL function pointer in our code.
		//	don't fail now
		//
		hLib = LoadLibraryA ("ole32.dll");
		if (hLib)
		{
			g_pfnStgOpenStorageOnHandle = (STGOPENSTORAGEONHANDLE)
										  GetProcAddress (hLib, "StgOpenStorageOnHandle");
		}

		// 	Start up event log message takes two parameters
		//	the signature and the version
		//
		#undef	LOG_STARTUP_EVENT
		#ifdef	LOG_STARTUP_EVENT
		LogEvent (DAVPRS_SERVICE_STARTUP,
				  EVENTLOG_INFORMATION_TYPE,
				  sizeof(mc_rgszLogServiceStateChange) / sizeof(LPCSTR),
				  mc_rgszLogServiceStateChange,
				  0,
				  NULL);
		#endif	// LOG_STARTUP_EVENT
	}
	catch ( CDAVException& )
	{
		goto Exit;
	}

	fSuccess = TRUE;

Exit:
	return fSuccess;
}

//	------------------------------------------------------------------------
//
//	CImplInst::~CImplInst()
//
CImplInst::~CImplInst()
{
	//
	//	DO NOT allow exceptions to propagate out of this call.
	//	This is intended as a safety valve only.  In order to
	//	avoid leaking instance data, individual instance data
	//	components should handle any exceptions themselves.
	//
	try
	{
		//
		//	If we logged a startup message, then log a shutdown message
		//
		#undef	LOG_STARTUP_EVENT
		#ifdef	LOG_STARTUP_EVENT
		LogEvent (DAVPRS_SERVICE_SHUTDOWN,
				  EVENTLOG_INFORMATION_TYPE,
				  sizeof(mc_rgszLogServiceStateChange) / sizeof(LPCSTR),
				  mc_rgszLogServiceStateChange,
				  0,
				  NULL);
		#endif	// LOG_STARTUP_EVENT

		//
		//	Deinit the idle thread.  Do this before taking down the
		//	thread pool there may be delayed thread pool work items
		//	pending on the idle thread.
		//
		DeleteIdleThread();

		//
		//	Deinit the thread pool
		//
		CPoolManager::Deinit();

		//	Deinit the language string to cpid cache
		//
		CLangToCpidCache::DestroyInstance();

		//
		//	remove the IDBCreateCommand if exist
		//
		ReleaseDBCreateCommandObject();

		//	Destroy shared lock mgr
		//
		CSharedLockMgr::DestroyInstance();

		//	Shutdown the parser
		//
		(void) CDAVExt::FTerminate ();

		//	Deinit the volume type cache
		//
		DeinitVolumeTypeCache();

		//	Clean out the security-thread-token cache.
		//
		CleanupSecurityToken();

		//	Close the caligula performance counters
		//
		DeinitPerfCounters();

		//	Deinit the resource string cache
		//
		DeinitResourceStringCache();

		//	Destroy allocators
		//
		if ( m_fInitializedHeap )
			g_heap.Deinit();
	}
	catch ( CDAVException& )
	{
	}
}

//	------------------------------------------------------------------------
//
//	Instance refcounting callouts from _davprs
//
VOID AddRefImplInst()
{
	HSE_VERSION_INFO lVer;
	DWORD cRef;

	cRef = CImplInst::DwInitRef(&lVer);

	//
	//	We should already have at least one ref on the instance
	//	before we called DwInitRef(), so we should more than one
	//	ref after the call.
	//
	Assert( cRef > 1 );
}

VOID ReleaseImplInst()
{
	CImplInst::DeinitRef();
}

//	IIS Entrypoints -----------------------------------------------------------
//
EXTERN_C BOOL WINAPI
FGetExtensionVersion (HSE_VERSION_INFO * pver)
{
	CWin32ExceptionHandler win32ExceptionHandler;

	//
	//	Initialize one instance reference and return whether it succeeded.
	//
	return !!CImplInst::DwInitRef( pver );
}

EXTERN_C BOOL WINAPI
FTerminateDavFS (DWORD)
{
	CWin32ExceptionHandler win32ExceptionHandler;

	//
	//	Deinitialize one instance reference
	//
	CImplInst::DeinitRef();

	//
	//	After the instance data has been released, we are ready to terminate.
	//
	return TRUE;
}

EXTERN_C DWORD WINAPI
DwDavFSExtensionProc (LPEXTENSION_CONTROL_BLOCK pecb)
{
	HSE_VERSION_INFO lVer;

	DWORD dwHSEStatusRet = HSE_STATUS_ERROR;

	if ( CImplInst::DwInitRef(&lVer) )
	{
		dwHSEStatusRet = CDAVExt::DwMain(pecb);

		CImplInst::DeinitRef();
	}

	return dwHSEStatusRet;
}

//	Win32 DLL Entrypoints -----------------------------------------------------
//
EXTERN_C BOOL WINAPI
FInitHttpExtDll (HINSTANCE hinst, DWORD dwReason, LPVOID lpvReserved)
{
	switch (dwReason)
	{
		default:
		{
			DebugTrace ("FInitHttpExtDll(), unknown reason\n");
			return FALSE;
		}

		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		{
			//
			//	We disable thread library calls (see below),
			//	so we should never see DLL_THREAD_ATTACH or
			//	DLL_THREAD_DETACH.
			//
			Assert (FALSE);

			//
			//	But if we do, it doesn't harm anything.
			//
			return TRUE;
		}

		case DLL_PROCESS_ATTACH:
		{
			//
			//	Init .INI file tagged debug traces
			//
			InitTraces();

			//	Cache the inst
			//
			g_hinst = hinst;

			//	And the full path to the DLL
			//
			if ( !GetModuleFileNameW( hinst, gc_wszDllPath, sizeof(gc_wszDllPath)/sizeof(WCHAR) ) )
			{
				DebugTrace( "FInitHttpExtDll() - GetModuleFileName() failed in DLL_PROCESS_ATTACH\n" );
				return FALSE;
			}

			//	Call the parser's initialization for every call into our
			//	DLL initialization proc.  The order of operations here is
			//	fairly important.  The parser should be called after we do
			//	our processing in the non-DETACH case.
			//
			if ( !CDAVExt::FInitializeDll (hinst, dwReason) )
				return FALSE;

			//	We are going to disable thread library calls.  If the parser
			//	really ever needs these then the this needs to change.
			//
			DisableThreadLibraryCalls (hinst);

			return TRUE;
		}

		case DLL_PROCESS_DETACH:
		{
			//	And in the detach case, the impl. gets the last word.
			//	Ignore any failures -- the DLL is being unloaded and
			//	the process is going away whether we like it or not.
			//
			(void) CDAVExt::FInitializeDll (hinst, dwReason);

			return TRUE;
		}
	}
}

//	OLE Entrypoints -----------------------------------------------------------
//
STDAPI
HrDllCanUnloadNowDavFS (VOID)
{

	return S_OK;
}

STDAPI
HrDllGetClassObjectDavFS (REFCLSID rclsid, REFIID riid, LPVOID * ppv)
{
	return E_NOINTERFACE;
}

STDAPI
HrDllRegisterServerDavFS (VOID)
{
	HRESULT hr;

	//	This is a "first line" entrypoint into our dll.  Need to init some stuff.
	//	Right now, the heap is the only important piece.
	//
	g_heap.FInit();

	//	Everybody gets to register regardless of failures
	//
	hr = EventLogDllRegisterServer( gc_wszDllPath );

	return hr;
}

STDAPI
HrDllUnregisterServerDavFS (VOID)
{
	HRESULT	hr;

	//	This is a "first line" entrypoint into our dll.  Need to init some stuff.
	//	Right now, the heap is the only important piece.
	//
	g_heap.FInit();

	//	Everybody gets to unregister regardless of failures
	//
	hr = EventLogDllUnregisterServer();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\tools\src\ismoke\wininet.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    wininet.h

Abstract:

    Contains manifests, macros, types and prototypes for Microsoft Windows
    Internet Extensions

--*/

#if !defined(_WININET_)
#define _WININET_

#if defined(__cplusplus)
extern "C" {
#endif

#if !defined(_WINX32_)
#define INTERNETAPI DECLSPEC_IMPORT
#else
#define INTERNETAPI
#endif

//
// internet types
//

typedef LPVOID HINTERNET;
typedef HINTERNET * LPHINTERNET;

typedef WORD INTERNET_PORT;
typedef INTERNET_PORT * LPINTERNET_PORT;

//
// Internet APIs
//

//
// manifests
//

#define INTERNET_INVALID_PORT_NUMBER    0           // use the protocol-specific default

#define INTERNET_DEFAULT_FTP_PORT       21          // default for FTP servers
#define INTERNET_DEFAULT_GOPHER_PORT    70          //    "     "  gopher "
#define INTERNET_DEFAULT_HTTP_PORT      80          //    "     "  HTTP   "

//
// maximum field lengths (arbitrary)
//

#define INTERNET_MAX_HOST_NAME_LENGTH   256
#define INTERNET_MAX_USER_NAME_LENGTH   128
#define INTERNET_MAX_PASSWORD_LENGTH    128
#define INTERNET_MAX_PORT_NUMBER_LENGTH 5           // INTERNET_PORT is unsigned short
#define INTERNET_MAX_PORT_NUMBER_VALUE  65535       // maximum unsigned short value
#define INTERNET_MAX_PATH_LENGTH        1024
#define INTERNET_MAX_PROTOCOL_NAME      "gopher"    // longest protocol name
#define INTERNET_MAX_URL_LENGTH         ((sizeof(INTERNET_MAX_PROTOCOL_NAME) - 1) \
                                        + sizeof("://") \
                                        + INTERNET_MAX_PATH_LENGTH)

//
// values returned by InternetQueryOption() with INTERNET_OPTION_KEEP_CONNECTION:
//

#define INTERNET_KEEP_ALIVE_UNKNOWN     ((DWORD)-1)
#define INTERNET_KEEP_ALIVE_ENABLED     1
#define INTERNET_KEEP_ALIVE_DISABLED    0

//
// flags returned by InternetQueryOption() with INTERNET_OPTION_REQUEST_FLAGS
//

#define INTERNET_REQFLAG_FROM_CACHE     0x00000001
#define INTERNET_REQFLAG_ASYNC          0x00000002

//
// flags common to open functions (not InternetOpen()):
//

#define INTERNET_FLAG_RELOAD            0x80000000  // retrieve the original item

//
// flags for InternetOpenUrl():
//

#define INTERNET_FLAG_RAW_DATA          0x40000000  // receive the item as raw data
#define INTERNET_FLAG_EXISTING_CONNECT  0x20000000  // do not create new connection object

//
// flags for InternetOpen():
//

#define INTERNET_FLAG_ASYNC             0x10000000  // this request is asynchronous (where supported)

//
// protocol-specific flags:
//

#define INTERNET_FLAG_PASSIVE           0x08000000  // used for FTP connections

//
// additional cache flags
//

#define INTERNET_FLAG_DONT_CACHE        0x04000000  // don't add this item to the cache
#define INTERNET_FLAG_MAKE_PERSISTENT   0x02000000  // make this item persistent in cache

//
// flags field masks
//

#define INTERNET_FLAGS_MASK             (INTERNET_FLAG_RELOAD \
                                        | INTERNET_FLAG_RAW_DATA \
                                        | INTERNET_FLAG_EXISTING_CONNECT \
                                        | INTERNET_FLAG_ASYNC \
                                        | INTERNET_FLAG_PASSIVE \
                                        | INTERNET_FLAG_DONT_CACHE \
                                        | INTERNET_FLAG_MAKE_PERSISTENT \
                                        )

#define INTERNET_OPTIONS_MASK           (~INTERNET_FLAGS_MASK)

//
// INTERNET_NO_CALLBACK - if this value is presented as the dwContext parameter
// then no call-backs will be made for that API
//

#define INTERNET_NO_CALLBACK            0

//
// structures/types
//

//
// INTERNET_ASYNC_RESULT - this structure is returned to the application via
// the callback with INTERNET_STATUS_REQUEST_COMPLETE. It is not sufficient to
// just return the result of the async operation. If the API failed then the
// app cannot call GetLastError() because the thread context will be incorrect.
// Both the value returned by the async API and any resultant error code are
// made available. The app need not check dwError if dwResult indicates that
// the API succeeded (it will be ERROR_SUCCESS)
//

typedef struct {

    //
    // dwResult - the HINTERNET, DWORD or BOOL return code from an async API
    //

    DWORD dwResult;

    //
    // dwError - the error code if the API failed
    //

    DWORD dwError;
} INTERNET_ASYNC_RESULT, * LPINTERNET_ASYNC_RESULT;

//
// prototypes
//

INTERNETAPI
HINTERNET
WINAPI
InternetOpenA(
    IN LPCSTR lpszCallerName,
    IN DWORD dwAccessType,
    IN LPCSTR lpszServerName OPTIONAL,
    IN INTERNET_PORT nServerPort,
    IN DWORD dwFlags
    );
INTERNETAPI
HINTERNET
WINAPI
InternetOpenW(
    IN LPCWSTR lpszCallerName,
    IN DWORD dwAccessType,
    IN LPCWSTR lpszServerName OPTIONAL,
    IN INTERNET_PORT nServerPort,
    IN DWORD dwFlags
    );
#ifdef UNICODE
#define InternetOpen  InternetOpenW
#else
#define InternetOpen  InternetOpenA
#endif // !UNICODE

//
// access types for InternetOpen()
//

#define PRE_CONFIG_INTERNET_ACCESS  0   // use default
#define LOCAL_INTERNET_ACCESS       1   // direct to Internet
#define GATEWAY_INTERNET_ACCESS     2   // Internet via gateway
#define CERN_PROXY_INTERNET_ACCESS  3   // Internet via CERN proxy

INTERNETAPI
BOOL
WINAPI
InternetCloseHandle(
    IN HINTERNET hInternet
    );

INTERNETAPI
HINTERNET
WINAPI
InternetConnectA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCSTR lpszUsername OPTIONAL,
    IN LPCSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
HINTERNET
WINAPI
InternetConnectW(
    IN HINTERNET hInternet,
    IN LPCWSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCWSTR lpszUsername OPTIONAL,
    IN LPCWSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define InternetConnect  InternetConnectW
#else
#define InternetConnect  InternetConnectA
#endif // !UNICODE

//
// service types for InternetConnect()
//

#define INTERNET_SERVICE_FTP    1
#define INTERNET_SERVICE_GOPHER 2
#define INTERNET_SERVICE_HTTP   3

INTERNETAPI
HINTERNET
WINAPI
InternetOpenUrlA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
HINTERNET
WINAPI
InternetOpenUrlW(
    IN HINTERNET hInternet,
    IN LPCWSTR lpszUrl,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define InternetOpenUrl  InternetOpenUrlW
#else
#define InternetOpenUrl  InternetOpenUrlA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
InternetReadFile(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    );

INTERNETAPI
BOOL
WINAPI
InternetWriteFile(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten
    );

INTERNETAPI
BOOL
WINAPI
InternetFindNextFileA(
    IN HINTERNET hFind,
    OUT LPVOID lpvFindData
    );
INTERNETAPI
BOOL
WINAPI
InternetFindNextFileW(
    IN HINTERNET hFind,
    OUT LPVOID lpvFindData
    );
#ifdef UNICODE
#define InternetFindNextFile  InternetFindNextFileW
#else
#define InternetFindNextFile  InternetFindNextFileA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
InternetQueryOption(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );

INTERNETAPI
BOOL
WINAPI
InternetSetOption(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    );

//
// options manifests for Internet{Query|Set}Option
//

#define INTERNET_OPTION_CALLBACK                1
#define INTERNET_OPTION_CONNECT_TIMEOUT         2
#define INTERNET_OPTION_CONNECT_RETRIES         3
#define INTERNET_OPTION_CONNECT_BACKOFF         4
#define INTERNET_OPTION_SEND_TIMEOUT            5
#define INTERNET_OPTION_CONTROL_SEND_TIMEOUT    INTERNET_OPTION_SEND_TIMEOUT
#define INTERNET_OPTION_RECEIVE_TIMEOUT         6
#define INTERNET_OPTION_CONTROL_RECEIVE_TIMEOUT INTERNET_OPTION_RECEIVE_TIMEOUT
#define INTERNET_OPTION_DATA_SEND_TIMEOUT       7
#define INTERNET_OPTION_DATA_RECEIVE_TIMEOUT    8
#define INTERNET_OPTION_HANDLE_TYPE             9
#define INTERNET_OPTION_CONTEXT_VALUE           10
#define INTERNET_OPTION_NAME_RES_THREAD         11
#define INTERNET_OPTION_READ_BUFFER_SIZE        12
#define INTERNET_OPTION_WRITE_BUFFER_SIZE       13
#define INTERNET_OPTION_GATEWAY_NAME            14
#define INTERNET_OPTION_ASYNC_ID                15
#define INTERNET_OPTION_ASYNC_PRIORITY          16
#define INTERNET_OPTION_ASYNC_REQUEST_COUNT     17
#define INTERNET_OPTION_MAXIMUM_WORKER_THREADS  18
#define INTERNET_OPTION_ASYNC_QUEUE_DEPTH       19
#define INTERNET_OPTION_WORKER_THREAD_TIMEOUT   20
#define INTERNET_OPTION_PARENT_HANDLE           21
#define INTERNET_OPTION_KEEP_CONNECTION         22
#define INTERNET_OPTION_REQUEST_FLAGS           23

#define INTERNET_FIRST_OPTION                   INTERNET_OPTION_CALLBACK
#define INTERNET_LAST_OPTION                    INTERNET_OPTION_KEEP_CONNECTION

//
// values for INTERNET_OPTION_PRIORITY
//

#define INTERNET_PRIORITY_FOREGROUND            1000

//
// handle types
//

#define INTERNET_HANDLE_TYPE_INTERNET           1
#define INTERNET_HANDLE_TYPE_CONNECT_FTP        2
#define INTERNET_HANDLE_TYPE_CONNECT_GOPHER     3
#define INTERNET_HANDLE_TYPE_CONNECT_HTTP       4
#define INTERNET_HANDLE_TYPE_FTP_FIND           5
#define INTERNET_HANDLE_TYPE_FTP_FIND_HTML      6
#define INTERNET_HANDLE_TYPE_FTP_FILE           7
#define INTERNET_HANDLE_TYPE_FTP_FILE_HTML      8
#define INTERNET_HANDLE_TYPE_GOPHER_FIND        9
#define INTERNET_HANDLE_TYPE_GOPHER_FIND_HTML   10
#define INTERNET_HANDLE_TYPE_GOPHER_FILE        11
#define INTERNET_HANDLE_TYPE_GOPHER_FILE_HTML   12
#define INTERNET_HANDLE_TYPE_HTTP_REQUEST       13

INTERNETAPI
BOOL
WINAPI
InternetGetLastResponseInfoA(
    OUT LPDWORD lpdwError,
    OUT LPSTR lpszBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );
INTERNETAPI
BOOL
WINAPI
InternetGetLastResponseInfoW(
    OUT LPDWORD lpdwError,
    OUT LPWSTR lpszBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );
#ifdef UNICODE
#define InternetGetLastResponseInfo  InternetGetLastResponseInfoW
#else
#define InternetGetLastResponseInfo  InternetGetLastResponseInfoA
#endif // !UNICODE


//
// callback function for InternetSetStatusCallback
//

typedef
VOID
(CALLBACK * INTERNET_STATUS_CALLBACK)(
    IN HINTERNET hInternet,
    IN DWORD dwContext,
    IN DWORD dwInternetStatus,
    IN LPVOID lpvStatusInformation OPTIONAL,
    IN DWORD dwStatusInformationLength
    );

typedef INTERNET_STATUS_CALLBACK * LPINTERNET_STATUS_CALLBACK;

INTERNETAPI
INTERNET_STATUS_CALLBACK
WINAPI
InternetSetStatusCallback(
    IN HINTERNET hInternet,
    IN INTERNET_STATUS_CALLBACK lpfnInternetCallback
    );

//
// status manifests for Internet status callback
//

#define INTERNET_STATUS_RESOLVING_NAME          10
#define INTERNET_STATUS_NAME_RESOLVED           11
#define INTERNET_STATUS_CONNECTING_TO_SERVER    20
#define INTERNET_STATUS_CONNECTED_TO_SERVER     21
#define INTERNET_STATUS_SENDING_REQUEST         30
#define INTERNET_STATUS_REQUEST_SENT            31
#define INTERNET_STATUS_RECEIVING_RESPONSE      40
#define INTERNET_STATUS_RESPONSE_RECEIVED       41
#define INTERNET_STATUS_CTL_RESPONSE_RECEIVED   42  // FTP-only: response on control channel
#define INTERNET_STATUS_CLOSING_CONNECTION      50
#define INTERNET_STATUS_CONNECTION_CLOSED       51
#define INTERNET_STATUS_HANDLE_CREATED          60
#define INTERNET_STATUS_REQUEST_COMPLETE        100

//
// if the following value is returned by InternetSetStatusCallback, then
// probably an invalid (non-code) address was supplied for the callback
//

#define INTERNET_INVALID_STATUS_CALLBACK        ((INTERNET_STATUS_CALLBACK)(-1L))

INTERNETAPI
BOOL
WINAPI
InternetCancelAsyncRequest(
    IN DWORD dwAsyncId
    );

//
// FTP
//

//
// manifests
//

#define FTP_TRANSFER_TYPE_UNKNOWN   0x00000000
#define FTP_TRANSFER_TYPE_ASCII     0x00000001
#define FTP_TRANSFER_TYPE_BINARY    0x00000002

#define FTP_TRANSFER_TYPE_MASK      0x00000003

//
// prototypes
//

INTERNETAPI
HINTERNET
WINAPI
FtpFindFirstFileA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszSearchFile OPTIONAL,
    OUT LPWIN32_FIND_DATA lpFindFileData OPTIONAL,
    IN DWORD dwContext
    );
INTERNETAPI
HINTERNET
WINAPI
FtpFindFirstFileW(
    IN HINTERNET hFtpSession,
    IN LPCWSTR lpszSearchFile OPTIONAL,
    OUT LPWIN32_FIND_DATA lpFindFileData OPTIONAL,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define FtpFindFirstFile  FtpFindFirstFileW
#else
#define FtpFindFirstFile  FtpFindFirstFileA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
FtpGetFileA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszRemoteFile,
    IN LPCSTR lpszNewFile,
    IN BOOL fFailIfExists,
    IN DWORD dwFlagsAndAttributes,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
BOOL
WINAPI
FtpGetFileW(
    IN HINTERNET hFtpSession,
    IN LPCWSTR lpszRemoteFile,
    IN LPCWSTR lpszNewFile,
    IN BOOL fFailIfExists,
    IN DWORD dwFlagsAndAttributes,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define FtpGetFile  FtpGetFileW
#else
#define FtpGetFile  FtpGetFileA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
FtpPutFileA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszLocalFile,
    IN LPCSTR lpszNewRemoteFile,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
BOOL
WINAPI
FtpPutFileW(
    IN HINTERNET hFtpSession,
    IN LPCWSTR lpszLocalFile,
    IN LPCWSTR lpszNewRemoteFile,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define FtpPutFile  FtpPutFileW
#else
#define FtpPutFile  FtpPutFileA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
FtpDeleteFileA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszFileName
    );
INTERNETAPI
BOOL
WINAPI
FtpDeleteFileW(
    IN HINTERNET hFtpSession,
    IN LPCWSTR lpszFileName
    );
#ifdef UNICODE
#define FtpDeleteFile  FtpDeleteFileW
#else
#define FtpDeleteFile  FtpDeleteFileA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
FtpRenameFileA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszExisting,
    IN LPCSTR lpszNew
    );
INTERNETAPI
BOOL
WINAPI
FtpRenameFileW(
    IN HINTERNET hFtpSession,
    IN LPCWSTR lpszExisting,
    IN LPCWSTR lpszNew
    );
#ifdef UNICODE
#define FtpRenameFile  FtpRenameFileW
#else
#define FtpRenameFile  FtpRenameFileA
#endif // !UNICODE

INTERNETAPI
HINTERNET
WINAPI
FtpOpenFileA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
HINTERNET
WINAPI
FtpOpenFileW(
    IN HINTERNET hFtpSession,
    IN LPCWSTR lpszFileName,
    IN DWORD dwAccess,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define FtpOpenFile  FtpOpenFileW
#else
#define FtpOpenFile  FtpOpenFileA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
FtpCreateDirectoryA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszDirectory
    );
INTERNETAPI
BOOL
WINAPI
FtpCreateDirectoryW(
    IN HINTERNET hFtpSession,
    IN LPCWSTR lpszDirectory
    );
#ifdef UNICODE
#define FtpCreateDirectory  FtpCreateDirectoryW
#else
#define FtpCreateDirectory  FtpCreateDirectoryA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
FtpRemoveDirectoryA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszDirectory
    );
INTERNETAPI
BOOL
WINAPI
FtpRemoveDirectoryW(
    IN HINTERNET hFtpSession,
    IN LPCWSTR lpszDirectory
    );
#ifdef UNICODE
#define FtpRemoveDirectory  FtpRemoveDirectoryW
#else
#define FtpRemoveDirectory  FtpRemoveDirectoryA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
FtpSetCurrentDirectoryA(
    IN HINTERNET hFtpSession,
    IN LPCSTR lpszDirectory
    );
INTERNETAPI
BOOL
WINAPI
FtpSetCurrentDirectoryW(
    IN HINTERNET hFtpSession,
    IN LPCWSTR lpszDirectory
    );
#ifdef UNICODE
#define FtpSetCurrentDirectory  FtpSetCurrentDirectoryW
#else
#define FtpSetCurrentDirectory  FtpSetCurrentDirectoryA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
FtpGetCurrentDirectoryA(
    IN HINTERNET hFtpSession,
    OUT LPSTR lpszCurrentDirectory,
    IN OUT LPDWORD lpdwCurrentDirectory
    );
INTERNETAPI
BOOL
WINAPI
FtpGetCurrentDirectoryW(
    IN HINTERNET hFtpSession,
    OUT LPWSTR lpszCurrentDirectory,
    IN OUT LPDWORD lpdwCurrentDirectory
    );
#ifdef UNICODE
#define FtpGetCurrentDirectory  FtpGetCurrentDirectoryW
#else
#define FtpGetCurrentDirectory  FtpGetCurrentDirectoryA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
FtpCommandA(
    IN HINTERNET hFtpSession,
    IN BOOL fExpectResponse,
    IN DWORD dwFlags,
    IN LPCSTR lpszCommand,
    IN DWORD dwContext
    );
INTERNETAPI
BOOL
WINAPI
FtpCommandW(
    IN HINTERNET hFtpSession,
    IN BOOL fExpectResponse,
    IN DWORD dwFlags,
    IN LPCWSTR lpszCommand,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define FtpCommand  FtpCommandW
#else
#define FtpCommand  FtpCommandA
#endif // !UNICODE

//
// Gopher
//

//
// manifests
//

//
// string field lengths (in characters, not bytes)
//

#define MAX_GOPHER_DISPLAY_TEXT     128
#define MAX_GOPHER_SELECTOR_TEXT    256
#define MAX_GOPHER_HOST_NAME        INTERNET_MAX_HOST_NAME_LENGTH
#define MAX_GOPHER_LOCATOR_LENGTH   (1                                  \
                                    + MAX_GOPHER_DISPLAY_TEXT           \
                                    + 1                                 \
                                    + MAX_GOPHER_SELECTOR_TEXT          \
                                    + 1                                 \
                                    + MAX_GOPHER_HOST_NAME              \
                                    + 1                                 \
                                    + INTERNET_MAX_PORT_NUMBER_LENGTH   \
                                    + 1                                 \
                                    + 1                                 \
                                    + 2                                 \
                                    )

//
// structures/types
//

//
// GOPHER_FIND_DATA - returns the results of a GopherFindFirstFile()/
// InternetFindNextFile() request
//

typedef struct {

    //
    // DisplayString - points to the string to be displayed by the client (i.e.
    // the file or directory name)
    //

    TCHAR DisplayString[MAX_GOPHER_DISPLAY_TEXT + 1];

    //
    // GopherType - bitmap which describes the item returned. See below
    //

    DWORD GopherType;

    //
    // SizeLow and SizeHigh - (approximate) size of the item, if the gopher
    // server reports it
    //

    DWORD SizeLow;
    DWORD SizeHigh;

    //
    // LastModificationTime - time in Win32 format that this item was last
    // modified, if the gopher server reports it
    //

    FILETIME LastModificationTime;

    //
    // Locator - the gopher locator string returned from the server, or created
    // via GopherCreateLocator
    //

    TCHAR Locator[MAX_GOPHER_LOCATOR_LENGTH + 1];

} GOPHER_FIND_DATA, *LPGOPHER_FIND_DATA;

//
// manifests for GopherType
//

#define GOPHER_TYPE_TEXT_FILE       0x00000001
#define GOPHER_TYPE_DIRECTORY       0x00000002
#define GOPHER_TYPE_CSO             0x00000004
#define GOPHER_TYPE_ERROR           0x00000008
#define GOPHER_TYPE_MAC_BINHEX      0x00000010
#define GOPHER_TYPE_DOS_ARCHIVE     0x00000020
#define GOPHER_TYPE_UNIX_UUENCODED  0x00000040
#define GOPHER_TYPE_INDEX_SERVER    0x00000080
#define GOPHER_TYPE_TELNET          0x00000100
#define GOPHER_TYPE_BINARY          0x00000200
#define GOPHER_TYPE_REDUNDANT       0x00000400
#define GOPHER_TYPE_TN3270          0x00000800
#define GOPHER_TYPE_GIF             0x00001000
#define GOPHER_TYPE_IMAGE           0x00002000
#define GOPHER_TYPE_BITMAP          0x00004000
#define GOPHER_TYPE_MOVIE           0x00008000
#define GOPHER_TYPE_SOUND           0x00010000
#define GOPHER_TYPE_HTML            0x00020000
#define GOPHER_TYPE_PDF             0x00040000
#define GOPHER_TYPE_CALENDAR        0x00080000
#define GOPHER_TYPE_INLINE          0x00100000
#define GOPHER_TYPE_UNKNOWN         0x20000000
#define GOPHER_TYPE_ASK             0x40000000
#define GOPHER_TYPE_GOPHER_PLUS     0x80000000

//
// gopher type macros
//

#define IS_GOPHER_FILE(type)            (BOOL)(((type) & GOPHER_TYPE_FILE_MASK) ? TRUE : FALSE)
#define IS_GOPHER_DIRECTORY(type)       (BOOL)(((type) & GOPHER_TYPE_DIRECTORY) ? TRUE : FALSE)
#define IS_GOPHER_PHONE_SERVER(type)    (BOOL)(((type) & GOPHER_TYPE_CSO) ? TRUE : FALSE)
#define IS_GOPHER_ERROR(type)           (BOOL)(((type) & GOPHER_TYPE_ERROR) ? TRUE : FALSE)
#define IS_GOPHER_INDEX_SERVER(type)    (BOOL)(((type) & GOPHER_TYPE_INDEX_SERVER) ? TRUE : FALSE)
#define IS_GOPHER_TELNET_SESSION(type)  (BOOL)(((type) & GOPHER_TYPE_TELNET) ? TRUE : FALSE)
#define IS_GOPHER_BACKUP_SERVER(type)   (BOOL)(((type) & GOPHER_TYPE_REDUNDANT) ? TRUE : FALSE)
#define IS_GOPHER_TN3270_SESSION(type)  (BOOL)(((type) & GOPHER_TYPE_TN3270) ? TRUE : FALSE)
#define IS_GOPHER_ASK(type)             (BOOL)(((type) & GOPHER_TYPE_ASK) ? TRUE : FALSE)
#define IS_GOPHER_PLUS(type)            (BOOL)(((type) & GOPHER_TYPE_GOPHER_PLUS) ? TRUE : FALSE)

#define IS_GOPHER_TYPE_KNOWN(type)      (BOOL)(((type) & GOPHER_TYPE_UNKNOWN) ? FALSE : TRUE)

//
// GOPHER_TYPE_FILE_MASK - use this to determine if a locator identifies a
// (known) file type
//

#define GOPHER_TYPE_FILE_MASK       (GOPHER_TYPE_TEXT_FILE          \
                                    | GOPHER_TYPE_MAC_BINHEX        \
                                    | GOPHER_TYPE_DOS_ARCHIVE       \
                                    | GOPHER_TYPE_UNIX_UUENCODED    \
                                    | GOPHER_TYPE_BINARY            \
                                    | GOPHER_TYPE_GIF               \
                                    | GOPHER_TYPE_IMAGE             \
                                    | GOPHER_TYPE_BITMAP            \
                                    | GOPHER_TYPE_MOVIE             \
                                    | GOPHER_TYPE_SOUND             \
                                    | GOPHER_TYPE_HTML              \
                                    | GOPHER_TYPE_PDF               \
                                    | GOPHER_TYPE_CALENDAR          \
                                    | GOPHER_TYPE_INLINE            \
                                    )

//
// structured gopher attributes (as defined in gopher+ protocol document)
//

typedef struct {
    LPCTSTR Comment;
    LPCTSTR EmailAddress;
} GOPHER_ADMIN_ATTRIBUTE_TYPE, *LPGOPHER_ADMIN_ATTRIBUTE_TYPE;

typedef struct {
    FILETIME DateAndTime;
} GOPHER_MOD_DATE_ATTRIBUTE_TYPE, *LPGOPHER_MOD_DATE_ATTRIBUTE_TYPE;

typedef struct {
    DWORD Ttl;
} GOPHER_TTL_ATTRIBUTE_TYPE, *LPGOPHER_TTL_ATTRIBUTE_TYPE;

typedef struct {
    INT Score;
} GOPHER_SCORE_ATTRIBUTE_TYPE, *LPGOPHER_SCORE_ATTRIBUTE_TYPE;

typedef struct {
    INT LowerBound;
    INT UpperBound;
} GOPHER_SCORE_RANGE_ATTRIBUTE_TYPE, *LPGOPHER_SCORE_RANGE_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR Site;
} GOPHER_SITE_ATTRIBUTE_TYPE, *LPGOPHER_SITE_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR Organization;
} GOPHER_ORGANIZATION_ATTRIBUTE_TYPE, *LPGOPHER_ORGANIZATION_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR Location;
} GOPHER_LOCATION_ATTRIBUTE_TYPE, *LPGOPHER_LOCATION_ATTRIBUTE_TYPE;

typedef struct {
    INT DegreesNorth;
    INT MinutesNorth;
    INT SecondsNorth;
    INT DegreesEast;
    INT MinutesEast;
    INT SecondsEast;
} GOPHER_GEOGRAPHICAL_LOCATION_ATTRIBUTE_TYPE, *LPGOPHER_GEOGRAPHICAL_LOCATION_ATTRIBUTE_TYPE;

typedef struct {
    INT Zone;
} GOPHER_TIMEZONE_ATTRIBUTE_TYPE, *LPGOPHER_TIMEZONE_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR Provider;
} GOPHER_PROVIDER_ATTRIBUTE_TYPE, *LPGOPHER_PROVIDER_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR Version;
} GOPHER_VERSION_ATTRIBUTE_TYPE, *LPGOPHER_VERSION_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR ShortAbstract;
    LPCTSTR AbstractFile;
} GOPHER_ABSTRACT_ATTRIBUTE_TYPE, *LPGOPHER_ABSTRACT_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR ContentType;
    LPCTSTR Language;
    DWORD Size;
} GOPHER_VIEW_ATTRIBUTE_TYPE, *LPGOPHER_VIEW_ATTRIBUTE_TYPE;

typedef struct {
    BOOL TreeWalk;
} GOPHER_VERONICA_ATTRIBUTE_TYPE, *LPGOPHER_VERONICA_ATTRIBUTE_TYPE;

typedef struct {
    LPCTSTR QuestionType;
    LPCTSTR QuestionText;
} GOPHER_ASK_ATTRIBUTE_TYPE, *LPGOPHER_ASK_ATTRIBUTE_TYPE;

//
// GOPHER_UNKNOWN_ATTRIBUTE_TYPE - this is returned if we retrieve an attribute
// that is not specified in the current gopher/gopher+ documentation. It is up
// to the application to parse the information
//

typedef struct {
    LPCTSTR Text;
} GOPHER_UNKNOWN_ATTRIBUTE_TYPE, *LPGOPHER_UNKNOWN_ATTRIBUTE_TYPE;

//
// GOPHER_ATTRIBUTE_TYPE - returned in the user's buffer when an enumerated
// GopherGetAttribute call is made
//

typedef struct {
    DWORD CategoryId;   // e.g. GOPHER_CATEGORY_ID_ADMIN
    DWORD AttributeId;  // e.g. GOPHER_ATTRIBUTE_ID_ADMIN
    union {
        GOPHER_ADMIN_ATTRIBUTE_TYPE Admin;
        GOPHER_MOD_DATE_ATTRIBUTE_TYPE ModDate;
        GOPHER_TTL_ATTRIBUTE_TYPE Ttl;
        GOPHER_SCORE_ATTRIBUTE_TYPE Score;
        GOPHER_SCORE_RANGE_ATTRIBUTE_TYPE ScoreRange;
        GOPHER_SITE_ATTRIBUTE_TYPE Site;
        GOPHER_ORGANIZATION_ATTRIBUTE_TYPE Organization;
        GOPHER_LOCATION_ATTRIBUTE_TYPE Location;
        GOPHER_GEOGRAPHICAL_LOCATION_ATTRIBUTE_TYPE GeographicalLocation;
        GOPHER_TIMEZONE_ATTRIBUTE_TYPE TimeZone;
        GOPHER_PROVIDER_ATTRIBUTE_TYPE Provider;
        GOPHER_VERSION_ATTRIBUTE_TYPE Version;
        GOPHER_ABSTRACT_ATTRIBUTE_TYPE Abstract;
        GOPHER_VIEW_ATTRIBUTE_TYPE View;
        GOPHER_VERONICA_ATTRIBUTE_TYPE Veronica;
        GOPHER_ASK_ATTRIBUTE_TYPE Ask;
        GOPHER_UNKNOWN_ATTRIBUTE_TYPE Unknown;
    } AttributeType;
} GOPHER_ATTRIBUTE_TYPE, *LPGOPHER_ATTRIBUTE_TYPE;

#define MAX_GOPHER_CATEGORY_NAME    128     // arbitrary
#define MAX_GOPHER_ATTRIBUTE_NAME   128     //     "
#define MIN_GOPHER_ATTRIBUTE_LENGTH 256     //     "

//
// known gopher attribute categories. See below for ordinals
//

#define GOPHER_INFO_CATEGORY        TEXT("+INFO")
#define GOPHER_ADMIN_CATEGORY       TEXT("+ADMIN")
#define GOPHER_VIEWS_CATEGORY       TEXT("+VIEWS")
#define GOPHER_ABSTRACT_CATEGORY    TEXT("+ABSTRACT")
#define GOPHER_VERONICA_CATEGORY    TEXT("+VERONICA")

//
// known gopher attributes. These are the attribute names as defined in the
// gopher+ protocol document
//

#define GOPHER_ADMIN_ATTRIBUTE      TEXT("Admin")
#define GOPHER_MOD_DATE_ATTRIBUTE   TEXT("Mod-Date")
#define GOPHER_TTL_ATTRIBUTE        TEXT("TTL")
#define GOPHER_SCORE_ATTRIBUTE      TEXT("Score")
#define GOPHER_RANGE_ATTRIBUTE      TEXT("Score-range")
#define GOPHER_SITE_ATTRIBUTE       TEXT("Site")
#define GOPHER_ORG_ATTRIBUTE        TEXT("Org")
#define GOPHER_LOCATION_ATTRIBUTE   TEXT("Loc")
#define GOPHER_GEOG_ATTRIBUTE       TEXT("Geog")
#define GOPHER_TIMEZONE_ATTRIBUTE   TEXT("TZ")
#define GOPHER_PROVIDER_ATTRIBUTE   TEXT("Provider")
#define GOPHER_VERSION_ATTRIBUTE    TEXT("Version")
#define GOPHER_ABSTRACT_ATTRIBUTE   TEXT("Abstract")
#define GOPHER_VIEW_ATTRIBUTE       TEXT("View")
#define GOPHER_TREEWALK_ATTRIBUTE   TEXT("treewalk")

//
// identifiers for attribute strings
//

#define GOPHER_ATTRIBUTE_ID_BASE        0xabcccc00

#define GOPHER_CATEGORY_ID_ALL          (GOPHER_ATTRIBUTE_ID_BASE + 1)

#define GOPHER_CATEGORY_ID_INFO         (GOPHER_ATTRIBUTE_ID_BASE + 2)
#define GOPHER_CATEGORY_ID_ADMIN        (GOPHER_ATTRIBUTE_ID_BASE + 3)
#define GOPHER_CATEGORY_ID_VIEWS        (GOPHER_ATTRIBUTE_ID_BASE + 4)
#define GOPHER_CATEGORY_ID_ABSTRACT     (GOPHER_ATTRIBUTE_ID_BASE + 5)
#define GOPHER_CATEGORY_ID_VERONICA     (GOPHER_ATTRIBUTE_ID_BASE + 6)
#define GOPHER_CATEGORY_ID_ASK          (GOPHER_ATTRIBUTE_ID_BASE + 7)

#define GOPHER_CATEGORY_ID_UNKNOWN      (GOPHER_ATTRIBUTE_ID_BASE + 8)

#define GOPHER_ATTRIBUTE_ID_ALL         (GOPHER_ATTRIBUTE_ID_BASE + 9)

#define GOPHER_ATTRIBUTE_ID_ADMIN       (GOPHER_ATTRIBUTE_ID_BASE + 10)
#define GOPHER_ATTRIBUTE_ID_MOD_DATE    (GOPHER_ATTRIBUTE_ID_BASE + 11)
#define GOPHER_ATTRIBUTE_ID_TTL         (GOPHER_ATTRIBUTE_ID_BASE + 12)
#define GOPHER_ATTRIBUTE_ID_SCORE       (GOPHER_ATTRIBUTE_ID_BASE + 13)
#define GOPHER_ATTRIBUTE_ID_RANGE       (GOPHER_ATTRIBUTE_ID_BASE + 14)
#define GOPHER_ATTRIBUTE_ID_SITE        (GOPHER_ATTRIBUTE_ID_BASE + 15)
#define GOPHER_ATTRIBUTE_ID_ORG         (GOPHER_ATTRIBUTE_ID_BASE + 16)
#define GOPHER_ATTRIBUTE_ID_LOCATION    (GOPHER_ATTRIBUTE_ID_BASE + 17)
#define GOPHER_ATTRIBUTE_ID_GEOG        (GOPHER_ATTRIBUTE_ID_BASE + 18)
#define GOPHER_ATTRIBUTE_ID_TIMEZONE    (GOPHER_ATTRIBUTE_ID_BASE + 19)
#define GOPHER_ATTRIBUTE_ID_PROVIDER    (GOPHER_ATTRIBUTE_ID_BASE + 20)
#define GOPHER_ATTRIBUTE_ID_VERSION     (GOPHER_ATTRIBUTE_ID_BASE + 21)
#define GOPHER_ATTRIBUTE_ID_ABSTRACT    (GOPHER_ATTRIBUTE_ID_BASE + 22)
#define GOPHER_ATTRIBUTE_ID_VIEW        (GOPHER_ATTRIBUTE_ID_BASE + 23)
#define GOPHER_ATTRIBUTE_ID_TREEWALK    (GOPHER_ATTRIBUTE_ID_BASE + 24)

#define GOPHER_ATTRIBUTE_ID_UNKNOWN     (GOPHER_ATTRIBUTE_ID_BASE + 25)

//
// prototypes
//

INTERNETAPI
BOOL
WINAPI
GopherCreateLocatorA(
    IN LPCSTR lpszHost,
    IN INTERNET_PORT nServerPort,
    IN LPCSTR lpszDisplayString OPTIONAL,
    IN LPCSTR lpszSelectorString OPTIONAL,
    IN DWORD dwGopherType,
    OUT LPSTR lpszLocator OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );
INTERNETAPI
BOOL
WINAPI
GopherCreateLocatorW(
    IN LPCWSTR lpszHost,
    IN INTERNET_PORT nServerPort,
    IN LPCWSTR lpszDisplayString OPTIONAL,
    IN LPCWSTR lpszSelectorString OPTIONAL,
    IN DWORD dwGopherType,
    OUT LPWSTR lpszLocator OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    );
#ifdef UNICODE
#define GopherCreateLocator  GopherCreateLocatorW
#else
#define GopherCreateLocator  GopherCreateLocatorA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
GopherGetLocatorTypeA(
    IN LPCSTR lpszLocator,
    OUT LPDWORD lpdwGopherType
    );
INTERNETAPI
BOOL
WINAPI
GopherGetLocatorTypeW(
    IN LPCWSTR lpszLocator,
    OUT LPDWORD lpdwGopherType
    );
#ifdef UNICODE
#define GopherGetLocatorType  GopherGetLocatorTypeW
#else
#define GopherGetLocatorType  GopherGetLocatorTypeA
#endif // !UNICODE

INTERNETAPI
HINTERNET
WINAPI
GopherFindFirstFileA(
    IN HINTERNET hGopherSession,
    IN LPCSTR lpszLocator OPTIONAL,
    IN LPCSTR lpszSearchString OPTIONAL,
    OUT LPGOPHER_FIND_DATA lpFindData OPTIONAL,
    IN DWORD dwContext
    );
INTERNETAPI
HINTERNET
WINAPI
GopherFindFirstFileW(
    IN HINTERNET hGopherSession,
    IN LPCWSTR lpszLocator OPTIONAL,
    IN LPCWSTR lpszSearchString OPTIONAL,
    OUT LPGOPHER_FIND_DATA lpFindData OPTIONAL,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define GopherFindFirstFile  GopherFindFirstFileW
#else
#define GopherFindFirstFile  GopherFindFirstFileA
#endif // !UNICODE

INTERNETAPI
HINTERNET
WINAPI
GopherOpenFileA(
    IN HINTERNET hGopherSession,
    IN LPCSTR lpszLocator,
    IN LPCSTR lpszView OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
HINTERNET
WINAPI
GopherOpenFileW(
    IN HINTERNET hGopherSession,
    IN LPCWSTR lpszLocator,
    IN LPCWSTR lpszView OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define GopherOpenFile  GopherOpenFileW
#else
#define GopherOpenFile  GopherOpenFileA
#endif // !UNICODE

typedef
BOOL
(CALLBACK * GOPHER_ATTRIBUTE_ENUMERATOR)(
    LPGOPHER_ATTRIBUTE_TYPE lpAttributeInfo,
    DWORD dwError
    );

INTERNETAPI
BOOL
WINAPI
GopherGetAttributeA(
    IN HINTERNET hGopherSession,
    IN LPCSTR lpszLocator,
    IN LPCSTR lpszAttributeName OPTIONAL,
    OUT LPBYTE lpBuffer,
    IN DWORD dwBufferLength,
    OUT LPDWORD lpdwCharactersReturned,
    IN GOPHER_ATTRIBUTE_ENUMERATOR lpfnEnumerator OPTIONAL,
    IN DWORD dwContext
    );
INTERNETAPI
BOOL
WINAPI
GopherGetAttributeW(
    IN HINTERNET hGopherSession,
    IN LPCWSTR lpszLocator,
    IN LPCWSTR lpszAttributeName OPTIONAL,
    OUT LPBYTE lpBuffer,
    IN DWORD dwBufferLength,
    OUT LPDWORD lpdwCharactersReturned,
    IN GOPHER_ATTRIBUTE_ENUMERATOR lpfnEnumerator OPTIONAL,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define GopherGetAttribute  GopherGetAttributeW
#else
#define GopherGetAttribute  GopherGetAttributeA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
GopherSendDataA(
    IN HINTERNET hGopherSession,
    IN LPCSTR lpszLocator,
    IN LPCSTR lpszBuffer,
    IN DWORD dwNumberOfCharactersToSend,
    OUT LPDWORD lpdwNumberOfCharactersSent,
    IN DWORD dwContext
    );
INTERNETAPI
BOOL
WINAPI
GopherSendDataW(
    IN HINTERNET hGopherSession,
    IN LPCWSTR lpszLocator,
    IN LPCWSTR lpszBuffer,
    IN DWORD dwNumberOfCharactersToSend,
    OUT LPDWORD lpdwNumberOfCharactersSent,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define GopherSendData  GopherSendDataW
#else
#define GopherSendData  GopherSendDataA
#endif // !UNICODE

//
// HTTP
//

//
// manifests
//

//
//  The default HTTP port for TCP/IP connections.
//

#define HTTP_TCPIP_PORT         80


//
//  The default major/minor HTTP version numbers.
//

#define HTTP_MAJOR_VERSION      1
#define HTTP_MINOR_VERSION      0

#define HTTP_VERSION            TEXT("HTTP/1.0")

//
//  HttpQueryInfo info levels. Generally, there is one info level
//  for each potential RFC822/HTTP/MIME header that an HTTP server
//  may send as part of a request response.
//
//  The HTTP_QUERY_RAW_HEADERS info level is provided for clients
//  that choose to perform their own header parsing.
//

#define HTTP_QUERY_MIN                          0x0000
#define HTTP_QUERY_MIME_VERSION                 0x0000
#define HTTP_QUERY_CONTENT_TYPE                 0x0001
#define HTTP_QUERY_CONTENT_TRANSFER_ENCODING    0x0002
#define HTTP_QUERY_CONTENT_ID                   0x0003
#define HTTP_QUERY_CONTENT_DESCRIPTION          0x0004
#define HTTP_QUERY_CONTENT_LENGTH               0x0005
#define HTTP_QUERY_CONTENT_LANGUAGE             0x0006
#define HTTP_QUERY_ALLOW                        0x0007
#define HTTP_QUERY_PUBLIC                       0x0008
#define HTTP_QUERY_DATE                         0x0009
#define HTTP_QUERY_EXPIRES                      0x000A
#define HTTP_QUERY_LAST_MODIFIED                0x000B
#define HTTP_QUERY_MESSAGE_ID                   0x000C
#define HTTP_QUERY_URI                          0x000D
#define HTTP_QUERY_DERIVED_FROM                 0x000E
#define HTTP_QUERY_COST                         0x000F
#define HTTP_QUERY_LINK                         0x0010
#define HTTP_QUERY_PRAGMA                       0x0011
#define HTTP_QUERY_VERSION                      0x0012
#define HTTP_QUERY_STATUS_CODE                  0x0013
#define HTTP_QUERY_STATUS_TEXT                  0x0014
#define HTTP_QUERY_RAW_HEADERS                  0x0015
#define HTTP_QUERY_RAW_HEADERS_CRLF             0x0016
#define HTTP_QUERY_CONNECTION                   0x0017
#define HTTP_QUERY_MAX                          0x0017


//
//  HTTP Response Status Codes:
//

#define HTTP_STATUS_OK              200     // request completed
#define HTTP_STATUS_CREATED         201     // object created, reason = new URI
#define HTTP_STATUS_ACCEPTED        202     // async completion (TBS)
#define HTTP_STATUS_PARTIAL         203     // partial completion

#define HTTP_STATUS_MOVED           301     // object permanently moved
#define HTTP_STATUS_REDIRECT        302     // object temporarily moved
#define HTTP_STATUS_REDIRECT_METHOD 303     // redirection w/ new access method

#define HTTP_STATUS_BAD_REQUEST     400     // invalid syntax
#define HTTP_STATUS_DENIED          401     // access denied
#define HTTP_STATUS_PAYMENT_REQ     402     // payment required
#define HTTP_STATUS_FORBIDDEN       403     // request forbidden
#define HTTP_STATUS_NOT_FOUND       404     // object not found

#define HTTP_STATUS_SERVER_ERROR    500     // internal server error
#define HTTP_STATUS_NOT_SUPPORTED   501     // required not supported

//
// prototypes
//

INTERNETAPI
HINTERNET
WINAPI
HttpOpenRequestA(
    IN HINTERNET hHttpSession,
    IN LPCSTR lpszVerb,
    IN LPCSTR lpszObjectName,
    IN LPCSTR lpszVersion,
    IN LPCSTR lpszReferrer OPTIONAL,
    IN LPCSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
INTERNETAPI
HINTERNET
WINAPI
HttpOpenRequestW(
    IN HINTERNET hHttpSession,
    IN LPCWSTR lpszVerb,
    IN LPCWSTR lpszObjectName,
    IN LPCWSTR lpszVersion,
    IN LPCWSTR lpszReferrer OPTIONAL,
    IN LPCWSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );
#ifdef UNICODE
#define HttpOpenRequest  HttpOpenRequestW
#else
#define HttpOpenRequest  HttpOpenRequestA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
HttpAddRequestHeadersA(
    IN HINTERNET hHttpRequest,
    IN LPCSTR lpszHeaders,
    IN DWORD dwHeadersLength
    );
INTERNETAPI
BOOL
WINAPI
HttpAddRequestHeadersW(
    IN HINTERNET hHttpRequest,
    IN LPCWSTR lpszHeaders,
    IN DWORD dwHeadersLength
    );
#ifdef UNICODE
#define HttpAddRequestHeaders  HttpAddRequestHeadersW
#else
#define HttpAddRequestHeaders  HttpAddRequestHeadersA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
HttpSendRequestA(
    IN HINTERNET hHttpRequest,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    );
INTERNETAPI
BOOL
WINAPI
HttpSendRequestW(
    IN HINTERNET hHttpRequest,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    );
#ifdef UNICODE
#define HttpSendRequest  HttpSendRequestW
#else
#define HttpSendRequest  HttpSendRequestA
#endif // !UNICODE

INTERNETAPI
BOOL
WINAPI
HttpQueryInfoA(
    IN HINTERNET hHttpRequest,
    IN DWORD dwInfoLevel,
    OUT LPVOID lpvBuffer,
    IN OUT LPDWORD lpdwBufferLength
    );
INTERNETAPI
BOOL
WINAPI
HttpQueryInfoW(
    IN HINTERNET hHttpRequest,
    IN DWORD dwInfoLevel,
    OUT LPVOID lpvBuffer,
    IN OUT LPDWORD lpdwBufferLength
    );
#ifdef UNICODE
#define HttpQueryInfo  HttpQueryInfoW
#else
#define HttpQueryInfo  HttpQueryInfoA
#endif // !UNICODE

//#if !defined(_WINERROR_)

//
// Internet API error returns
//

#define INTERNET_ERROR_BASE                     12000

#define ERROR_INTERNET_OUT_OF_HANDLES           (INTERNET_ERROR_BASE + 1)
#define ERROR_INTERNET_TIMEOUT                  (INTERNET_ERROR_BASE + 2)
#define ERROR_INTERNET_EXTENDED_ERROR           (INTERNET_ERROR_BASE + 3)
#define ERROR_INTERNET_INTERNAL_ERROR           (INTERNET_ERROR_BASE + 4)
#define ERROR_INTERNET_INVALID_URL              (INTERNET_ERROR_BASE + 5)
#define ERROR_INTERNET_UNRECOGNIZED_SCHEME      (INTERNET_ERROR_BASE + 6)
#define ERROR_INTERNET_NAME_NOT_RESOLVED        (INTERNET_ERROR_BASE + 7)
#define ERROR_INTERNET_PROTOCOL_NOT_FOUND       (INTERNET_ERROR_BASE + 8)
#define ERROR_INTERNET_INVALID_OPTION           (INTERNET_ERROR_BASE + 9)
#define ERROR_INTERNET_BAD_OPTION_LENGTH        (INTERNET_ERROR_BASE + 10)
#define ERROR_INTERNET_OPTION_NOT_SETTABLE      (INTERNET_ERROR_BASE + 11)
#define ERROR_INTERNET_SHUTDOWN                 (INTERNET_ERROR_BASE + 12)
#define ERROR_INTERNET_INCORRECT_USER_NAME      (INTERNET_ERROR_BASE + 13)
#define ERROR_INTERNET_INCORRECT_PASSWORD       (INTERNET_ERROR_BASE + 14)
#define ERROR_INTERNET_LOGIN_FAILURE            (INTERNET_ERROR_BASE + 15)
#define ERROR_INTERNET_INVALID_OPERATION        (INTERNET_ERROR_BASE + 16)
#define ERROR_INTERNET_OPERATION_CANCELLED      (INTERNET_ERROR_BASE + 17)
#define ERROR_INTERNET_INCORRECT_HANDLE_TYPE    (INTERNET_ERROR_BASE + 18)

#define ERROR_INTERNET_NOT_PROXY_REQUEST        (INTERNET_ERROR_BASE + 20)
#define ERROR_INTERNET_REGISTRY_VALUE_NOT_FOUND (INTERNET_ERROR_BASE + 21)
#define ERROR_INTERNET_BAD_REGISTRY_PARAMETER   (INTERNET_ERROR_BASE + 22)
#define ERROR_INTERNET_NO_DIRECT_ACCESS         (INTERNET_ERROR_BASE + 23)
#define ERROR_INTERNET_NO_CONTEXT               (INTERNET_ERROR_BASE + 24)
#define ERROR_INTERNET_NO_CALLBACK              (INTERNET_ERROR_BASE + 25)
#define ERROR_INTERNET_REQUEST_PENDING          (INTERNET_ERROR_BASE + 26)

//
// FTP API errors
//

#define ERROR_FTP_TRANSFER_IN_PROGRESS          (INTERNET_ERROR_BASE + 28)
#define ERROR_FTP_DROPPED                       (INTERNET_ERROR_BASE + 29)

//
// gopher API errors
//

#define ERROR_GOPHER_PROTOCOL_ERROR             (INTERNET_ERROR_BASE + 30)
#define ERROR_GOPHER_NOT_FILE                   (INTERNET_ERROR_BASE + 31)
#define ERROR_GOPHER_DATA_ERROR                 (INTERNET_ERROR_BASE + 32)
#define ERROR_GOPHER_END_OF_DATA                (INTERNET_ERROR_BASE + 33)
#define ERROR_GOPHER_INVALID_LOCATOR            (INTERNET_ERROR_BASE + 34)
#define ERROR_GOPHER_INCORRECT_LOCATOR_TYPE     (INTERNET_ERROR_BASE + 35)
#define ERROR_GOPHER_NOT_GOPHER_PLUS            (INTERNET_ERROR_BASE + 36)
#define ERROR_GOPHER_ATTRIBUTE_NOT_FOUND        (INTERNET_ERROR_BASE + 37)
#define ERROR_GOPHER_UNKNOWN_LOCATOR            (INTERNET_ERROR_BASE + 38)

//
// HTTP API errors
//

#define ERROR_HTTP_HEADER_NOT_FOUND             (INTERNET_ERROR_BASE + 40)
#define ERROR_HTTP_DOWNLEVEL_SERVER             (INTERNET_ERROR_BASE + 41)
#define ERROR_HTTP_INVALID_SERVER_RESPONSE      (INTERNET_ERROR_BASE + 42)

//#endif // !defined(_WINERROR_)

#if defined(__cplusplus)
}
#endif

#endif // !defined(_WININET_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\fsbase.cpp ===
/*
 *	F S B A S E . C P P
 *
 *	Sources file system implementation of DAV-Base
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"
#include "_fsmvcpy.h"

//	DAV-Base Implementation ---------------------------------------------------
//
/*
 *	DAVOptions()
 *
 *	Purpose:
 *
 *		Win32 file system implementation of the DAV OPTIONS method.	 The
 *		OPTIONS method responds with a comma separated list of supported
 *		methods by the server.
 *
 *	Parameters:
 *
 *		pmu			[in]  pointer to the method utility object
 */

const CHAR gc_szHttpBase[] = "OPTIONS, TRACE, GET, HEAD";
const CHAR gc_szHttpDelete[] = ", DELETE";
const CHAR gc_szHttpPut[] = ", PUT";
const CHAR gc_szHttpPost[] = ", POST";
const CHAR gc_szDavCopy[] = ", COPY";
const CHAR gc_szDavMove[] = ", MOVE";
const CHAR gc_szDavMkCol[] = ", MKCOL";
const CHAR gc_szDavPropfind[] = ", PROPFIND";
const CHAR gc_szDavProppatch[] = ", PROPPATCH";
const CHAR gc_szDavLocks[] = ", LOCK, UNLOCK";
const CHAR gc_szDavSearch[] = ", SEARCH";
const CHAR gc_szDavNotif[] = "";	// no notification on httpext
const CHAR gc_szDavBatchDelete[] = "";	// no batch methods on httpext
const CHAR gc_szDavBatchCopy[] = "";	// no batch methods on httpext
const CHAR gc_szDavBatchMove[] = "";	// no batch methods on httpext
const CHAR gc_szDavBatchProppatch[] = "";	// no batch methods on httpext
const CHAR gc_szDavBatchPropfind[] = "";	// no batch methods on httpext
const CHAR gc_szDavPublic[] =
		"OPTIONS, TRACE, GET, HEAD, DELETE"
		", PUT"
		", POST"
		", COPY, MOVE"
		", MKCOL"
		", PROPFIND, PROPPATCH"
		", LOCK, UNLOCK"
		", SEARCH";
const UINT gc_cbszDavPublic = sizeof(gc_szDavPublic);
const CHAR gc_szCompliance[] = "1, 2";

void
DAVOptions (LPMETHUTIL pmu)
{
	CResourceInfo cri;
	RESOURCE_TYPE rt = RT_NULL;
	SCODE sc = S_OK;
	UINT uiErrorDetail = 0;
	BOOL fFrontPageWeb = FALSE;

	//	According to spec, If the request URI is '*', the OPTIONS request
	//	is intended to apply to the server in general rather than to the
	//	specific resource. Since a Server's communication options typically
	//	depend on the resource, the '*' request is only useful as a "ping"
	//	or "no-op" type of method; it does nothing beyong allowing client
	//	to test the capabilities of the server.
	//	So here we choose to return all the methods can ever be accepted
	//	by this server.
	//	NOTE: if the request URI is '*', WININET will convert it to '/*'.
	//	Handle this case also so that WININET clients aren't left in the dust.
	//
	if (!wcscmp(pmu->LpwszRequestUrl(), L"*") ||
		!wcscmp(pmu->LpwszRequestUrl(), L"/*"))
	{
		//	 So we simply allow all methods as defined in public
		//
		pmu->SetResponseHeader (gc_szAllow, gc_szDavPublic);
		pmu->SetResponseHeader (gc_szAccept_Ranges, gc_szBytes);

		//	Set the rest of common headers
		//
		goto ret;
	}

	//	Do ISAPI application and IIS access bits checking
	//
	//$ REVIEW	- Do we really need read access?
	//
	sc = pmu->ScIISCheck (pmu->LpwszRequestUrl(), MD_ACCESS_READ);
	if (FAILED(sc) && (sc != E_DAV_NO_IIS_READ_ACCESS))
	{
		//	Either the request has been forwarded, or some bad error occurred.
		//	In either case, quit here and map the error!
		//
		goto ret;
	}

	//	We can retrieve the file information if only we have MD_ACCESS_READ
	//	access. otherwise, we better not to try and treat it as non-existing
	//	resource.
	//
	if (SUCCEEDED(sc))
	{
		//	Get the file information for this resource
		//
		sc = cri.ScGetResourceInfo (pmu->LpwszPathTranslated());
		if (!FAILED (sc))
		{
			//	If the resource exists, adjust the resource type
			//	to the one that applies, and check to see if the URL
			//	and the resource type jibe.
			//
			rt = cri.FCollection() ? RT_COLLECTION : RT_DOCUMENT;

		}
		//	OPTIONS is allowed to return non-error responses for non-existing
		//	resources.  The response should indicate what a caller could do to
		//	create a resource at that location.  Any other error is an error.
		//
		else if ((sc != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)) &&
				 (sc != HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)))
		{
			goto ret;
		}

		//	Check state headers here.
		//
		sc = HrCheckStateHeaders (pmu, pmu->LpwszPathTranslated(), FALSE);
		if (FAILED (sc))
		{
			DebugTrace ("DavFS: If-State checking failed.\n");
			goto ret;
		}
	}
	else
	{
		//	Treat E_DAV_NO_IIS_READ_ACCESS as resource not exist
		//
		Assert (sc == E_DAV_NO_IIS_READ_ACCESS);
		sc = S_OK;
	}

	//	BIG NOTE ABOUT LOCKING
	//
	//	Locktoken checking is omitted here because it can't possibly
	//	make any difference.  The "loose" interpretation of lock tokens
	//	means that we try a method anyway if an invalid lock token
	//	is provided.  Since the calls in this method impl. are
	//	UNAFFECTED by locks (GetFileAttributesEx, used by
	//	ScCheckForLocationCorrectness doesn't fail for WRITE locks)
	//	this method can't fail and the values in the locktoken header
	//	are irrelevant.
	//
	//	NOTE: We still have to consider if-state-match headers,
	//	but that is done elsewhere (above -- HrCheckIfStateHeader).
	//

	//	Pass back the "allow" header
	//
	pmu->SetAllowHeader (rt);

	//	Pass back the "accept-ranges"
	//
	pmu->SetResponseHeader (gc_szAccept_Ranges,
							(rt == RT_COLLECTION)
								? gc_szNone
								: gc_szBytes);

	//
	//	Emit an appropriate "MS_Author_Via" header.  If MD_FRONTPAGE_WEB
	//	was set at the vroot, then use frontpage.  Otherwise use "DAV".
	//
	//	MD_FRONTPAGE_WEB must be checked only at the virtual root.
	//	It is inherited, so you have to be careful in how you check it.
	//
	//	We don't care if this fails: default to author via "DAV"
	//
	(void) pmu->HrMDIsAuthorViaFrontPageNeeded(&fFrontPageWeb);

	//	Pass back the "MS_Author_Via" header
	//
	pmu->SetResponseHeader (gc_szMS_Author_Via,
							fFrontPageWeb ? gc_szMS_Author_Via_Dav_Fp : gc_szMS_Author_Via_Dav);

ret:
	if (SUCCEEDED(sc))
	{
		//	Supported query languages
		//
		pmu->SetResponseHeader (gc_szDasl, gc_szSqlQuery);

		//	Public methods
		//
		pmu->SetResponseHeader (gc_szPublic, gc_szDavPublic);

		//	Do the canned bit to the response
		//
#ifdef DBG
		if (DEBUG_TRACE_TEST(HttpExtDbgHeaders))
		{
			pmu->SetResponseHeader (gc_szX_MS_DEBUG_DAV, gc_szVersion);
			pmu->SetResponseHeader (gc_szX_MS_DEBUG_DAV_Signature, gc_szSignature);
		}
#endif
		pmu->SetResponseHeader (gc_szDavCompliance, gc_szCompliance);
		pmu->SetResponseHeader (gc_szCache_Control, gc_szCache_Control_Private);
	}

	pmu->SetResponseCode (HscFromHresult(sc), NULL, uiErrorDetail, CSEFromHresult(sc));
}

/*
 *	DAVMkCol()
 *
 *	Purpose:
 *
 *		Win32 file system implementation of the DAV MKCOL method.  The
 *		MKCOL method creates a collection in the DAV name space and
 *		optionally populates the collection with the data found in the
 *		passed in request.  The response created indicates the success of
 *		the call.
 *
 *	Parameters:
 *
 *		pmu			[in]  pointer to the method utility object
 */
void
DAVMkCol (LPMETHUTIL pmu)
{
	LPCWSTR pwszPath = pmu->LpwszPathTranslated();
	SCODE sc = S_OK;
	UINT uiErrorDetail = 0;
	LPCWSTR pwsz;

	DavTrace ("Dav: creating collection/directory '%ws'\n", pwszPath);

	//	Do ISAPI application and IIS access bits checking
	//
	sc = pmu->ScIISCheck (pmu->LpwszRequestUrl(), MD_ACCESS_WRITE);
	if (FAILED(sc))
	{
		//	Either the request has been forwarded, or some bad error occurred.
		//	In either case, quit here and map the error!
		//
		goto ret;
	}

	//	Check the content-type of the request.
	//	To quote from the DAV spec:
	//	A MKCOL request message MAY contain a message body. ...
	//	If the server receives a MKCOL request entity type it does
	//	not support or understand it MUST respond with a 415 Unsupported
	//	Media Type status code.
	//
	//	Since we don't yet support ANY media types, check for ANY
	//	Content-Type header, or ANY body of any length ('cause no Content-Type
	//	could still have a valid body of type application/octet-stream),
	//	and FAIL if found!
	//
	pwsz = pmu->LpwszGetRequestHeader (gc_szContent_Length, FALSE);
	if (pwsz && wcscmp(pwsz, gc_wsz0) ||
	    pmu->LpwszGetRequestHeader (gc_szContent_Type, FALSE))
	{
		DebugTrace ("DavFS: Found a body on MKCOL -- 415");
		sc = E_DAV_UNKNOWN_CONTENT;
		goto ret;
	}

	//	This method is gated by If-xxx headers
	//
	sc = ScCheckIfHeaders (pmu, pwszPath, FALSE);
	if (FAILED (sc))
	{
		DebugTrace ("Dav: If-xxx failed their check\n");
		goto ret;
	}

	//	Check state headers here.
	//
	sc = HrCheckStateHeaders (pmu, pwszPath, FALSE);
	if (FAILED (sc))
	{
		DebugTrace ("DavFS: If-State checking failed.\n");
		goto ret;
	}

	//	BIG NOTE ABOUT LOCKING
	//
	//	Since DAVFS does not yet support locks on directories,
	//	(and since MKCOL does not have an Overwrite: header)
	//	this method cannot be affected by passed-in locktokens.
	//	So, for now, on DAVFS, don't bother to check locktokens.
	//
	//	NOTE: We still have to consider if-state-match headers,
	//	but that is done elsewhere (above -- HrCheckIfStateHeader).
	//

	//	Create the structured resource, ie. directory
	//
	if (!DavCreateDirectory (pwszPath, NULL))
	{
		DWORD	dwError = GetLastError();

		//	If the failure was caused by non-exist path, then
		//	fail with 403
		//
		if (ERROR_PATH_NOT_FOUND == dwError)
		{
			DebugTrace ("Dav: intermediate directories do not exist\n");
			sc = E_DAV_NONEXISTING_PARENT;
		}
		else
		{
			if ((ERROR_FILE_EXISTS == dwError) || (ERROR_ALREADY_EXISTS == dwError))
				sc = E_DAV_COLLECTION_EXISTS;
			else
				sc = HRESULT_FROM_WIN32 (dwError);
		}
		goto ret;
	}

	//	Emit the location
	//
	pmu->EmitLocation (gc_szLocation, pmu->LpwszRequestUrl(), TRUE);
	sc = W_DAV_CREATED;

ret:

	//	Return the response code
	//
	pmu->SetResponseCode (HscFromHresult(sc), NULL, uiErrorDetail, CSEFromHresult(sc));
}

/*
 *	DAVDelete()
 *
 *	Purpose:
 *
 *		Win32 file system implementation of the DAV DELETE method.	The
 *		DELETE method responds with a status line and possibly an XML
 *		web collection of failed deletes.
 *
 *	Parameters:
 *
 *		pmu			[in]  pointer to the method utility object
 */
void
DAVDelete (LPMETHUTIL pmu)
{
	CResourceInfo cri;
	LPCWSTR pwsz;
	LPCWSTR pwszPath = pmu->LpwszPathTranslated();
	SCODE sc = S_OK;
	UINT uiErrorDetail = 0;
	auto_ref_ptr<CXMLEmitter> pxml;
	auto_ptr<CParseLockTokenHeader> plth;
	auto_ref_ptr<CXMLBody> pxb;
	CStackBuffer<WCHAR> pwszMBPath;

	//	We don't know if we'll have chunked XML response, defer response anyway
	//
	pmu->DeferResponse();

	//	Do ISAPI application and IIS access bits checking
	//
	sc = pmu->ScIISCheck (pmu->LpwszRequestUrl(), MD_ACCESS_WRITE);
	if (FAILED(sc))
	{
		//	Either the request has been forwarded, or some bad error occurred.
		//	In either case, quit here and map the error!
		//
		goto ret;
	}

	//	Setup the access checking mechanism for deep operations
	//
	if (NULL == pwszMBPath.resize(pmu->CbMDPathW(pmu->LpwszRequestUrl())))
	{
		sc = E_OUTOFMEMORY;
		goto ret;
	}
	pmu->MDPathFromUrlW (pmu->LpwszRequestUrl(), pwszMBPath.get());

	//	Get the resource information
	//
	sc = cri.ScGetResourceInfo (pwszPath);
	if (FAILED (sc))
		goto ret;

	//	Check to see that the location is correct
	//
	sc = ScCheckForLocationCorrectness (pmu, cri, NO_REDIRECT);
	if (FAILED (sc))
		goto ret;

	//	This method is gated ny the "if-xxx" headers
	//
	sc = ScCheckIfHeaders (pmu, cri.PftLastModified(), FALSE);
	if (FAILED (sc))
		goto ret;

	//	Check state headers here.
	//
	sc = HrCheckStateHeaders (pmu, pwszPath, FALSE);
	if (FAILED (sc))
	{
		DebugTrace ("DavFS: If-State checking failed.\n");
		goto ret;
	}

	//	If there are locktokens, feed them to a parser object.
	//
	pwsz = pmu->LpwszGetRequestHeader (gc_szLockToken, TRUE);
	if (pwsz)
	{
		plth = new CParseLockTokenHeader (pmu, pwsz);
		Assert(plth.get());
		plth->SetPaths (pwszPath, NULL);
	}

	//	If the resource is a collection, iterate through
	//	and do a recursive delete
	//
	if (cri.FCollection())
	{
		CAuthMetaOp moAuth(pmu, pwszMBPath.get(), pmu->MetaData().DwAuthorization());
		CAccessMetaOp moAccess(pmu, pwszMBPath.get(), MD_ACCESS_READ|MD_ACCESS_WRITE);
		CIPRestrictionMetaOp moIP(pmu, pwszMBPath.get());

		BOOL fDeleted = FALSE;
		DWORD dwAcc = 0;
		LONG lDepth = pmu->LDepth(DEPTH_INFINITY);

		//	The client must not submit a depth header with any value
		//	but Infinity
		//
		if ((DEPTH_INFINITY != lDepth) &&
			(DEPTH_INFINITY_NOROOT != lDepth))
		{
			sc = E_DAV_INVALID_HEADER;
			goto ret;
		}

		//	Make sure we have access.  The access will come back out and we
		//	can then pass it into the call to delete.
		//
		(void) pmu->ScIISAccess (pmu->LpwszRequestUrl(),
								 MD_ACCESS_READ|MD_ACCESS_WRITE,
								 &dwAcc,
								 ACS_INHERIT);

		//	Check for deep operation access blocking
		//
		sc = moAccess.ScMetaOp();
		if (FAILED (sc))
			goto ret;

		sc = moAuth.ScMetaOp();
		if (FAILED (sc))
			goto ret;

		sc = moIP.ScMetaOp();
		if (FAILED (sc))
			goto ret;

		//	Create an XML doc, NOT chunked
		//
		pxb.take_ownership (new CXMLBody (pmu));
		pxml.take_ownership(new CXMLEmitter(pxb.get()));

		//	Must set all the headers before XML emitting start
		//
		pmu->SetResponseHeader (gc_szContent_Type, gc_szText_XML);
		pmu->SetResponseCode (HscFromHresult(W_DAV_PARTIAL_SUCCESS),
							  NULL,
							  0,
							  CSEFromHresult(W_DAV_PARTIAL_SUCCESS));

		//	Delete the directory
		//
		DavTrace ("Dav: deleting '%ws'\n", pwszPath);
		sc = ScDeleteDirectoryAndChildren (pmu,
										   pmu->LpwszRequestUrl(),
										   pwszPath,
										   moAccess.FAccessBlocked() || moAuth.FAccessBlocked() || moIP.FAccessBlocked(),
										   dwAcc,
										   lDepth,
										   *pxml,
										   NULL, // translations are pmu based
										   &fDeleted,
										   plth.get(),
										   TRUE); // drop locks
	}
	else
	{
		//	If we have a locktoken for this file, drop the lock before
		//	trying the delete.
		//
		if (plth.get())
		{
			SCODE scSub;
			__int64 i64;
			scSub = plth->HrGetLockIdForPath (pwszPath, GENERIC_WRITE, &i64);
			if (SUCCEEDED(scSub))
			{
				Assert (i64);

				//	Drop the lock.
				//
				FDeleteLock (pmu, i64);
			}
		}

		//	Delete the file that is referred to by the URI
		//
		DavTrace ("Dav: deleting '%ws'\n", pwszPath);
		if (!DavDeleteFile (pwszPath))
		{
			DebugTrace ("Dav: failed to delete file\n");
			sc = HRESULT_FROM_WIN32 (GetLastError());

			//	Special work for 416 Locked responses -- fetch the
			//	comment & set that as the response body.
			//
			if (FLockViolation (pmu,
								GetLastError(),
								pwszPath,
								GENERIC_READ | GENERIC_WRITE))
			{
				sc = E_DAV_LOCKED;
			}
		}
	}

	if (SUCCEEDED (sc))
	{
		//	Delete the content-types
		//
		//$REVIEW	I don't believe we need to do this any longer because
		//$REVIEW	MOVE and COPY both unconditionally blow away the destination
		//$REVIEW	metadata before copying over the source, so there is no
		//$REVIEW	chance that the resulting content type will be wrong.
		//
		CContentTypeMetaOp amoContent(pmu, pwszMBPath.get(), NULL, TRUE);
		(void) amoContent.ScMetaOp();
	}

	//	Only continue on complete success
	//
	if (sc != S_OK)
		goto ret;

ret:
	if (pxml.get() && pxml->PxnRoot())
	{
		pxml->Done();

		//	Note we must not emit any headers after XML chunking starts
	}
	else
		pmu->SetResponseCode (HscFromHresult(sc), NULL, uiErrorDetail, CSEFromHresult(sc));

	pmu->SendCompleteResponse();
}

/*
 *	DAVPost()
 *
 *	Purpose:
 *
 *		Win32 file system implementation of the DAV POST method.  The
 *		POST method creates a file in the DAV name space and populates
 *		the file with the data found in the passed in request.  The
 *		response created indicates the success of the call.
 *
 *	Parameters:
 *
 *		pmu			[in]  pointer to the method utility object
 */
void
DAVPost (LPMETHUTIL pmu)
{
	//	DAVPost() is really an unknown/unsupported method
	//	at this point...
	//
	DAVUnsupported (pmu);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\fsetag.cpp ===
/*
 *	E T A G F S . C P P
 *
 *	ETags for DAV resources
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"

SCODE
CResourceInfo::ScGetResourceInfo (LPCWSTR pwszFile)
{
	if (!DavGetFileAttributes (pwszFile,
							   GetFileExInfoStandard,
							   &m_u.ad))
	{
		DebugTrace ("Dav: failed to sniff resource for attributes\n");
		return HRESULT_FROM_WIN32(GetLastError());
	}

	m_lmode = BY_ATTRIBUTE;
	return S_OK;
}

//	ETags and If-xxx headers --------------------------------------------------
//
SCODE
ScCheckIfHeaders (IMethUtil* pmu, LPCWSTR pwszPath, BOOL fGetMethod)
{
	CResourceInfo cri;
	SCODE sc = S_OK;
	LPCWSTR pwszNone;

	//	There is no reason to do any real work, if there are no
	//	"if-xxx" headers to begin with.  By the fact that the caller
	//	had no filetime to pass in, we might as well see if the headers
	//	even exist before we try and crack the file
	//
	pwszNone = pmu->LpwszGetRequestHeader (gc_szIf_None_Match, FALSE);
	if (!pwszNone &&
		!pmu->LpwszGetRequestHeader (gc_szIf_Match, FALSE) &&
		!pmu->LpwszGetRequestHeader (gc_szIf_Unmodified_Since, FALSE) &&
		!(fGetMethod && pmu->LpwszGetRequestHeader (gc_szIf_Modified_Since, FALSE)))
	{
		//	There was nothing for us to check...
		//
		return S_OK;
	}

	//	Since there was something for us to check against, go
	//	ahead and do the expensive path
	//
	//	Get the resource information
	//
	sc = cri.ScGetResourceInfo (pwszPath);
	if (FAILED (sc))
	{
		//	If we failed to get the resource info, we certainly
		//	cannot check against any of the values.  However, we
		//	do know that if the request has an "if-match", then
		//	that must fail.
		//
		if (pmu->LpwszGetRequestHeader (gc_szIf_Match, FALSE))
		{
			sc = E_DAV_IF_HEADER_FAILURE;
			goto ret;
		}

		//	Along that same line, if a if-non-match header specifies
		//	"*", then we actually should be able to perform the operation
		//
		if (sc == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
		{
			if (pwszNone)	
				sc = ScCheckEtagAgainstHeader (NULL, pwszNone);
			else
				sc = E_DAV_IF_HEADER_FAILURE;
		}		

		goto ret;
	}

	//	Check against the if-xxx headers
	//
	sc = ScCheckIfHeaders (pmu, cri.PftLastModified(), fGetMethod);
	if (FAILED (sc))
		goto ret;

ret:

	return sc;
}

BOOL
FGetLastModTime (IMethUtil * pmu, LPCWSTR pszPath, FILETIME * pft)
{
	CResourceInfo cri;

	if (FAILED (cri.ScGetResourceInfo (pszPath)))
		return FALSE;

	*pft = *cri.PftLastModified();
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\fslock.cpp ===
/*
 *	F S L O C K . C P P
 *
 *	Sources file system implementation of DAV-Lock
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"
#include "_shlkmgr.h"

#include <stdlib.h>
#include <statetok.h>
#include <xlock.h>

//	Lock prop support ---------------------------------------------------------
//

//	------------------------------------------------------------------------
//
//	DwGetSupportedLockType
//
//		Return the supported locktype flags for the resource type.
//$LATER: If/when we have more types than just coll/non-coll, change
//$LATER: the boolean parameter to an enum.
//
DWORD __fastcall DwGetSupportedLockType (RESOURCE_TYPE rt)
{
	//	DAVFS doesn't support locks on collections.
	//	On files, DAVFS supports write locks and all lockscope flags.
	return (RT_COLLECTION == rt)
			?	0
			:	GENERIC_WRITE | DAV_LOCKSCOPE_FLAGS;
}

//	------------------------------------------------------------------------
//
//	Helper function
//
//

VOID DebugDumpSidFn(SID * psid)
{
#ifdef	DBG
	CHAR rgch[1024];
	ULONG IdentifierAuthority;
	BYTE * pb = (BYTE*)&IdentifierAuthority;

	for (INT i = 0; i < sizeof(ULONG); i++)
	{
		*pb++ = psid->IdentifierAuthority.Value[5-i];
	}
	wsprintfA (rgch, "S-%d-%d",
			   psid->Revision,
			   IdentifierAuthority);

	for (i = 0; i < psid->SubAuthorityCount; i++)
	{
		CHAR rgchT[10];
		wsprintfA (rgchT, "-%d", psid->SubAuthority[i]);
		lstrcatA (rgch, rgchT);
	}

	if (1 == psid->Revision)
	{
		if (0 == IdentifierAuthority)
			lstrcatA (rgch, " (Null)");
		if (1 == IdentifierAuthority)
			lstrcatA (rgch, " (World)");
		if (2 == IdentifierAuthority)
			lstrcatA (rgch, " (Local)");
		if (3 == IdentifierAuthority)
			lstrcatA (rgch, " (Creator)");
		if (4 == IdentifierAuthority)
			lstrcatA (rgch, " (Non-Unique)");
		if (5 == IdentifierAuthority)
			lstrcatA (rgch, " (NT)");
	}

	CHAR rgchAccount[MAX_PATH];
	CHAR rgchDomain[MAX_PATH];
	DWORD cbAccount = sizeof(rgchAccount);
	DWORD cbDomain = sizeof(rgchAccount);
	SID_NAME_USE snu;
	LookupAccountSidA (NULL,
					   psid,
					   rgchAccount,
					   &cbAccount,
					   rgchDomain,
					   &cbDomain,
					   &snu);
	lstrcatA (rgch, " ");
	lstrcatA (rgch, rgchDomain);
	lstrcatA (rgch, "\\");
	lstrcatA (rgch, rgchAccount);
	FsLockTrace ("SID for lock %hs\n", rgch);
#endif	// DBG
}

#ifdef	DBG
#define DebugDumpSid		DebugDumpSidFn
#else	// DBG
#define DebugDumpSid		1?0:DebugDumpSidFn
#endif	// DBG, else

//	------------------------------------------------------------------------
//
//	CLockFS::SendLockComment
//
//		Set lock comment information from the lock object into the
//		response.
//
//$REVIEW: Does this function need to return an error now?
//
void
CLockFS::SendLockComment(LPMETHUTIL pmu) const
{
	auto_ref_ptr<CXMLEmitter> pemitter;
	auto_ref_ptr<CXMLBody> pxb;
	SCODE sc;

	Assert (pmu);

	//	Emit the Content-Type: header
	//
	pmu->SetResponseHeader (gc_szContent_Type, gc_szText_XML);

	//	Construct the root ('DAV:prop') for the lock response, not chunked
	//
	pxb.take_ownership (new CXMLBody(pmu, FALSE));
	pemitter.take_ownership (new CXMLEmitter(pxb.get()));
	sc = pemitter->ScSetRoot (gc_wszProp);
	if (FAILED (sc))
		goto ret;

	{
		CEmitterNode enLockDiscovery;
		
		//	Construct the 'DAV:lockdiscovery' node
		//
		sc = enLockDiscovery.ScConstructNode (*pemitter, pemitter->PxnRoot(), gc_wszLockDiscovery);
		if (FAILED (sc))
			goto ret;


		//	Add the 'DAV:activelock' node for this CLock
		//
		sc = ScLockDiscoveryFromCLock (pmu,
									   *pemitter,
									   enLockDiscovery,
									   const_cast<CLockFS *>(this));
		if (FAILED (sc))
			goto ret;
	}
	
	//	Emit the XML body
	//
	pemitter->Done();
	
ret:;
}

//	------------------------------------------------------------------------
//
//	CLockFS::DwCompareLockOwner
//
//		Compare the authentication info (SID) for the current request
//		(impersonation token off the pmu) with the auth info stored
//		for this lock.
//		A lock has only one owner, so if the auth info doesn't match,
//		the user isn't allowed to use this lock!
//
enum { TOKENBUFFSIZE = (88) + sizeof(TOKEN_USER)};

DWORD
CLockFS::DwCompareLockOwner(LPMETHUTIL pmu)
{
	//	Get the SID for the request from the pmu.
	//

	HANDLE hit;
	BYTE tokenbuff[TOKENBUFFSIZE];
	TOKEN_USER *ptu = reinterpret_cast<TOKEN_USER *>(tokenbuff);
	ULONG ulcbTok = sizeof(tokenbuff);
	DWORD dwErr = 0;

	hit = pmu->HitUser();
	Assert(hit);

	//	Try to get the SID on this handle.
	//
	if (GetTokenInformation	(hit,
							 TokenUser,
							 ptu,
							 ulcbTok,
							 &ulcbTok))
	{
		//	Compare with the sid for this lock.
		//
		SID * psid = reinterpret_cast<SID *>(ptu->User.Sid);

		FsLockTrace ("CLock::DwCompareLockOwner: Caller ");
		DebugDumpSid(psid);
		FsLockTrace ("CLock::DwCompareLockOwner: Lock owner ");
		DebugDumpSid(reinterpret_cast<SID *>(const_cast<VOID *>(m_spSharedLockData->GetOwnerSID())));

		if (!EqualSid(psid, const_cast<VOID *>(m_spSharedLockData->GetOwnerSID())))
		{
			//	Fail the method.
			dwErr = ERROR_ACCESS_DENIED;
			FsLockTrace ("CLock::DwCompareLockOwner: SIDs did not match, error %d (0x%08x)\n",
					   dwErr, dwErr);
			goto err;
		}
	}
	else
	{
		dwErr = GetLastError();
		FsLockTrace ("Dav: Could not query on impersonation token: %d\n", dwErr);
		goto err;
	}

err:
	return dwErr;
}

//	------------------------------------------------------------------------
//	LOCK helper functions
//

//	------------------------------------------------------------------------
//
//	HrProcessLockRefresh
//
//		pmu -- MethUtil access
//		pszLockToken -- header containing the locktoken to refresh
//		puiErrorDetail -- error detail string id, passed out on error
//		pplock -- pass back the newly-added lock
//
//	NOTE: This function still only can handle refreshing ONE locktoken.
//$REVIEW: Do we need to fix this?
//
HRESULT HrProcessLockRefresh (LPMETHUTIL pmu,
							  LPCWSTR pwszLockToken,
							  UINT * puiErrorDetail,
							  CLockFS * * pplock)
{
	LPCWSTR pwszPath = pmu->LpwszPathTranslated();
	auto_ref_ptr<CLockFS> plock;
	HRESULT hr = S_OK;
	DWORD dwTimeout;
	__int64 i64LockId;

	Assert(pmu);
	Assert(pwszLockToken);
	Assert(puiErrorDetail);
	Assert(pplock);
	*pplock = NULL;

	//	Get a lock timeout, if they specified one.
	//
	if (!FGetLockTimeout (pmu, &dwTimeout))
	{
		DebugTrace ("DavFS: LOCK fails with improper Timeout header\n");
		hr = E_DAV_INVALID_HEADER;  //HSC_BAD_REQUEST;
		*puiErrorDetail = IDS_BR_TIMEOUT_SYNTAX;
		goto ret;
	}

	//	Here's the real work.
	//	Get the lock from the cache.  If this object is not in our cache,
	//	or the lockid doesn't match, don't let them refresh the lock.
	//$REVIEW: Should this be two distinct error codes?
	//

	//	Feed the Lock-Token header string into a parser object.
	//	Then get the lockid from the parser object.
	//
	{
		CParseLockTokenHeader lth(pmu, pwszLockToken);

		//	If there is more than one token, bad request.
		if (!lth.FOneToken())
		{
			hr = HRESULT_FROM_WIN32 (ERROR_BAD_FORMAT);  //HSC_BAD_REQUEST;
			*puiErrorDetail = IDS_BR_MULTIPLE_LOCKTOKENS;
			goto ret;
		}

		lth.SetPaths (pwszPath, NULL);

		//	0 means match all access.
		//
		hr = lth.HrGetLockIdForPath (pwszPath, 0, &i64LockId);
		if (FAILED (hr))
		{
			DavTrace ("DavFS: HrGetLockIdForPath could not find the path.\n");
			goto ret;
		}
	}

	//	Fetch the lock from the cache. (This call updates the timestamp.)
	//
	hr = CSharedLockMgr::Instance().HrGetLock (pmu, i64LockId, plock.load());
	if (FAILED(hr))
	{
		DavTrace ("DavFS: Refreshing a non-locked resource constitutes an unsatisfiable request.\n");
		
		//	If it's an access violation, leave the return code unchanged.
		//	Otherwise, give "can't satisfy request" (412 Precondition Failed).
		//
		if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) != hr)
			hr = E_DAV_CANT_SATISFY_LOCK_REQUEST;
		*puiErrorDetail = IDS_BR_LOCKTOKEN_INVALID;
		goto ret;
	}

	//	Check that the storage paths match.
	//	If not, their locktoken is invalid!
	//
	if (lstrcmpiW (pwszPath, plock->GetResourceName()))
	{
		DavTrace ("DavFS: resource name did not match fetch lock -- unsatisfiable request.\n");
		hr = E_DAV_CANT_SATISFY_LOCK_REQUEST;
		*puiErrorDetail = IDS_BR_LOCKTOKEN_INVALID;
		goto ret;
	}

	if (dwTimeout)
	{
		//	Change the timeout for this lock.
		//
		plock->SetTimeout(dwTimeout);
	}

	//	Pass back the lock (with a ref for the caller).
	//	And we're done.  Go generate a valid lock response.
	//
	plock->AddRef();
	*pplock = plock.get();

ret:
	return hr;
}


//	========================================================================
//
//	CLockRequest
//
//		Used by ProcessLockRequest() below to manage possible asynchronous
//		processing of a lock request in light of the fact that one cannot
//		determine whether a request body is so large that read operations
//		on it execute asynchronously.
//
class CLockRequest :
	public CMTRefCounted,
	private IAsyncIStreamObserver
{
	//	Reference to the CMethUtil
	//
	auto_ref_ptr<CMethUtil> m_pmu;

	//	Cached translated path
	//
	LPCWSTR m_pwszPath;

	//	File backing the lock we create
	//
	auto_ref_handle m_hfile;

	//	The lock XML node factory
	//
	auto_ref_ptr<CNFLock> m_pnfl;

	//	The request body stream
	//
	auto_ref_ptr<IStream> m_pstmRequest;

	//	The XML parser used to parse the request body using
	//	the node factory above.
	//
	auto_ref_ptr<IXMLParser> m_pxprs;

	//	Flag set to TRUE if we created the file as a result of creating
	//	the lock.  Used to indicate the status code to return as well
	//	as to know whether to delete the file on error.
	//
	BOOL m_fCreatedFile;

	//	IAsyncIStreamObserver
	//
	VOID AsyncIOComplete();

	//	State functions
	//
	VOID ParseBody();
	VOID DoLock();
	VOID SendResponse( SCODE sc, UINT uiErrorDetail = 0 );

	//	NOT IMPLEMENTED
	//
	CLockRequest& operator= (const CLockRequest&);
	CLockRequest (const CLockRequest&);

public:
	//	CREATORS
	//
	CLockRequest (CMethUtil * pmu) :
		m_pmu(pmu),
		m_pwszPath(m_pmu->LpwszPathTranslated()),
		m_fCreatedFile(FALSE)
	{
	}
	~CLockRequest();

	//	MANIPULATORS
	//
	VOID Execute();
};

//	------------------------------------------------------------------------
//
//	CLockRequest::~CLockRequest
//
CLockRequest::~CLockRequest()
{
	//	We have cleaned up the old handle in CLockRequest::SendResponse()
	//	The following path could be executed only in exception stack rewinding
	//
	if ( m_hfile.get() && m_fCreatedFile )
	{
		//	WARNING: the safe_revert class should only be
		//	used in very selective situations.  It is not
		//	a "quick way to get around" impersonation.
		//
		safe_revert sr(m_pmu->HitUser());

		m_hfile.clear();

		//$REVIEW	Note if exception happened after the lock handle is duplicated,
		//$REVIEW	then we won't be able to delete the file, but this is very
		//$REVIEW	rare. not sure if we ever want to handle this.
		//
		DavDeleteFile (m_pwszPath);
		DebugTrace ("Dav: deleting partial lock (%ld)\n", GetLastError());
	}
}

//	------------------------------------------------------------------------
//
//	CLockRequest::Execute
//
VOID
CLockRequest::Execute()
{
	//
	//	First off, tell the pmu that we want to defer the response.
	//	Even if we send it synchronously (i.e. due to an error in
	//	this function), we still want to use the same mechanism that
	//	we would use for async.
	//
	m_pmu->DeferResponse();

	//	The client must not submit a depth header with any value
	//	but 0 or Infinity.
	//	NOTE: Currently, DAVFS cannot lock collections, so the
	//	depth header doesn't change anything.  So, we don't change
	//	our processing at all for the Depth: infinity case.
	//
	//$LATER: If we do want to support locking collections,
	//$LATER: need to set DAV_RECURSIVE_LOCK on depth infinity.
	//
	LONG lDepth = m_pmu->LDepth(DEPTH_ZERO);
	if ((DEPTH_ZERO != lDepth) && (DEPTH_INFINITY != lDepth))
	{
		//	If the header is anything besides 0 or infinity, bad request.
		//
		SendResponse(E_DAV_INVALID_HEADER);
		return;
	}

	//	Instantiate the XML parser
	//
	m_pnfl.take_ownership(new CNFLock);
	m_pstmRequest.take_ownership(m_pmu->GetRequestBodyIStream(*this));

	SCODE sc = ScNewXMLParser( m_pnfl.get(),
							   m_pstmRequest.get(),
							   m_pxprs.load() );

	if (FAILED(sc))
	{
		DebugTrace( "CLockRequest::Execute() - ScNewXMLParser() failed (0x%08lX)\n", sc );
		SendResponse(sc);
		return;
	}

	//	Parse the body
	//
	ParseBody();
}

//	------------------------------------------------------------------------
//
//	CLockRequest::ParseBody()
//
VOID
CLockRequest::ParseBody()
{
	SCODE sc;

	Assert( m_pxprs.get() );
	Assert( m_pnfl.get() );
	Assert( m_pstmRequest.get() );

	//	Parse XML from the request body stream.
	//
	//	Add a ref for the following async operation.
	//	Use auto_ref_ptr rather than AddRef() for exception safety.
	//
	auto_ref_ptr<CLockRequest> pRef(this);

	sc = ScParseXML (m_pxprs.get(), m_pnfl.get());

	if ( SUCCEEDED(sc) )
	{
		Assert( S_OK == sc || S_FALSE == sc );

		DoLock();
	}
	else if ( E_PENDING == sc )
	{
		//
		//	The operation is pending -- AsyncIOComplete() will take ownership
		//	ownership of the reference when it is called.
		//
		pRef.relinquish();
	}
	else
	{
		DebugTrace( "CLockRequest::ParseBody() - ScParseXML() failed (0x%08lX)\n", sc );
		SendResponse( sc );
		return;
	}
}

//	------------------------------------------------------------------------
//
//	CLockRequest::AsyncIOComplete()
//
//	Called on completion of an async operation on our stream to
//	resume parsing XML from that stream.
//
VOID
CLockRequest::AsyncIOComplete()
{
	//	Take ownership of the reference added above in ParseBody()
	//
	auto_ref_ptr<CLockRequest> pRef;
	pRef.take_ownership(this);

	//	Resume parsing
	//
	ParseBody();
}

//	------------------------------------------------------------------------
//
//	CLockRequest::DoLock()
//
VOID
CLockRequest::DoLock()
{
	auto_ref_ptr<CLockFS> plock;
	DWORD dw;
	DWORD dwAccess = 0;
	DWORD dwLockType;
	DWORD dwLockScope;
	DWORD dwSharing;
	DWORD dwTimeout;
	LPCWSTR pwszURI = m_pmu->LpwszRequestUrl();
	SCODE sc = S_OK;

	//	Pull lock flags out of the xml parser.
	//	NOTE: I'm doing special stuff here, rather than inside the xml parser.
	//	Our write locks get read access also -- I'm relying on all methods
	//	that USE a lock handle to check the metabase flags!!!
	//

	//	Rollback is not supported here.
	//	If we see this, fail explicitly.
	//
	dwLockType = m_pnfl->DwGetLockRollback();
	if (dwLockType)
	{
		SendResponse(E_DAV_CANT_SATISFY_LOCK_REQUEST);  //HSC_PRECONDITION_FAILED;
		return;
	}

	//	If the parser gives us a non-supported locktype (like rollback!)
	//	tell the user it's not supported.
	//
	dwLockType = m_pnfl->DwGetLockType();
	if (GENERIC_WRITE != dwLockType &&
		GENERIC_READ != dwLockType)
	{
		SendResponse(E_DAV_CANT_SATISFY_LOCK_REQUEST);  //HSC_PRECONDITION_FAILED;
		return;
	}

	Assert (GENERIC_WRITE == dwLockType ||
			GENERIC_READ == dwLockType);

	//	Since we KNOW (see above assumption) that our locktype is WRITE,
	//	we also KNOW that our access should be read+write.
	//
	dwAccess = GENERIC_READ | GENERIC_WRITE;
#ifdef	DBG
	//	This is needed for BeckyAn to test that our infrastructure still
	//	handles setting a read-lock. DBG ONLY.
	dwAccess = (dwLockType & GENERIC_WRITE)
			   ? GENERIC_READ | GENERIC_WRITE
			   : GENERIC_READ;
#endif	// DBG

	//	Get our lockscope from the parser.
	//
	dwLockScope = m_pnfl->DwGetLockScope();
	if (DAV_SHARED_LOCK != dwLockScope &&
		DAV_EXCLUSIVE_LOCK != dwLockScope)
	{
		SendResponse(E_DAV_CANT_SATISFY_LOCK_REQUEST);  //HSC_PRECONDITION_FAILED;
		return;
	}

	if (DAV_SHARED_LOCK == dwLockScope)
	{
		//	Shared lock -- turn on all sharing flags.
		dwSharing = FILE_SHARE_READ | FILE_SHARE_WRITE;
	}
	else
	{
		//	Our lock type is write (see above assumption).  Set the sharing
		//	flags correctly.
		//$LATER: If we have a different lock type later, fix these flags!
		//
		dwSharing = FILE_SHARE_READ;

#ifdef	DBG
		//	This is needed for BeckyAn to test that our infrastructure still
		//	handles setting a read-lock. DBG ONLY.
		dwSharing = 0;
		if (!(dwLockType & GENERIC_READ))
		{
			dwSharing |= FILE_SHARE_READ;
		}
		if (!(dwLockType & GENERIC_WRITE))
		{
			dwSharing |= FILE_SHARE_WRITE;
		}
#endif	// DBG
	}


	Assert(S_OK == sc);

	AssertSz (dwAccess, "Strange.  Lock requested with NO access (no locktypes?).");

	//	Check our LOCKTYPE against the metabase access rights.
	//	NOTE:  I'm not checking our ACCESS flags against the metabase
	//	because our access flags don't come directly from the caller's requested
	//	access.  This check just makes sure that the caller hasn't asked for
	//	anything he can't have.
	//	NOTE: I don't listen for metabase changes, so if I get a lock with
	//	more/less access than the user, I don't/can't change it for a
	//	metabase update.
	//	NOTE: This works IF we assiduously check the metabase flags on
	//	ALL other methds (which we currenly do).  If that checking ever
	//	goes missing, and we grab a lock handle that has more access than
	//	the caller rightfully is allowed, we have a security hole.
	//	(So keep checking metabase flags on all methods!)
	//
	dw = (dwLockType & GENERIC_READ) ? MD_ACCESS_READ : 0;
	dw |= (dwLockType & GENERIC_WRITE) ? MD_ACCESS_WRITE : 0;
	sc = m_pmu->ScIISAccess (pwszURI, dw);
	if (FAILED (sc))
	{
		DebugTrace( "CLockRequest::DoLock() - IMethUtil::ScIISAccess failed (0x%08lX)\n", sc );
		SendResponse(sc);
		return;
	}

	//	Check for user-specified timeout header.
	//	(The timeout header is optional, so it's okay to have no timeout
	//	header, but syntax errors in the timeout header are NOT okay.)
	//	If no timeout header is present, dw will come back ZERO.
	//
	if (!FGetLockTimeout (m_pmu.get(), &dwTimeout))
	{
		DebugTrace ("DavFS: LOCK fails with improper Time-Out header\n");
		SendResponse(HRESULT_FROM_WIN32 (ERROR_BAD_FORMAT), //HSC_BAD_REQUEST;
					 IDS_BR_TIMEOUT_SYNTAX);
		return;
	}

try_open_resource:

	//	And now lock the resource.
	//	NOTE: On WRITE operations, if the file doesn't exist, CREATE it here
	//	(OPEN_ALWAYS, not OPEN_EXISTING) and change the hsc below!
	//	NOTE: We NEVER allow delete access (no FILE_SHARE_DELETE).
	//	NOTE: All our reads/writes will be async, so open the file overlapped.
	//	NOTE: We will be reading/writing the whole file usually, so use SEQUENTIAL_SCAN.
	//
	if (!m_hfile.FCreate(
		DavCreateFile (m_pwszPath,
					   dwAccess,
					   dwSharing,
					   NULL,
					   (dwAccess & GENERIC_WRITE)
						   ? OPEN_ALWAYS
						   : OPEN_EXISTING,
					   FILE_ATTRIBUTE_NORMAL |
						   FILE_FLAG_OVERLAPPED |
						   FILE_FLAG_SEQUENTIAL_SCAN,
					   NULL)))
	{
		sc = HRESULT_FROM_WIN32 (GetLastError());

		//	Special check for NEW-STYLE write locks.
		//	We are asking for rw access when we get a write lock.
		//	IF we don't have read access (in the ACLs) for the resource,
		//	we will fail here with ERROR_ACCESS_DENIED.
		//	Catch this case and try again with just w access!
		//
		if (ERROR_ACCESS_DENIED == GetLastError() &&
			dwAccess == (GENERIC_READ | GENERIC_WRITE) &&
			dwLockType == GENERIC_WRITE)
		{
			// Try again.
			dwAccess = GENERIC_WRITE;
			goto try_open_resource;
		}

		//	Special work for 416 Locked responses -- fetch the
		//	comment & set that as the response body.
		//	(You'll hit here if someone else already has this file locked!)
		//
		if (FLockViolation (m_pmu.get(), sc, m_pwszPath, dwLockType))
		{
			sc = HRESULT_FROM_WIN32 (ERROR_SHARING_VIOLATION); //HSC_LOCKED;
		}

		DavTrace ("Dav: unable to lock resource on LOCK method\n");
		SendResponse(sc);
		return;
	}

	//	If we created the file (only for write locks),
	//	change the default error code to say so.
	//
	if (dwAccess & GENERIC_WRITE &&
		GetLastError() != ERROR_ALREADY_EXISTS)
	{
		//	Emit the location
		//
		m_pmu->EmitLocation (gc_szLocation, pwszURI, FALSE);
		m_fCreatedFile = TRUE;
	}

   	//	Create the lock, using the client-specified timeout.
	//
	plock = new CLockFS ();
	if (NULL == plock.get())
    {
		DebugTrace ("DavFS: CLockRequest::DoLock() - creating CLockFS object failed\n");

        // Low Memory !!
		SendResponse(E_ABORT); //HSC_INTERNAL_SERVER_ERROR;
		return;
    }

    // Ask the shared lock manager to create a new shared lock token
	HRESULT hr = CSharedLockMgr::Instance().GetNewLockData(m_pwszPath, 
					m_hfile.get(),
					dwAccess,
					dwLockType,
					dwLockScope,
					dwTimeout,
					m_pnfl->PwszLockOwner(),
					m_pmu->HitUser(),
					*(plock.get()));
    if (FAILED(hr))
	{
		DebugTrace ("DavFS: CLockRequest::DoLock() - CSharedLockMgr::Instance().GetNewLockData() failed 0x%08lX\n", hr);

		SendResponse(E_ABORT); //HSC_INTERNAL_SERVER_ERROR;
		return;
	}


	//	Add the lock to the cache.
	//
	if (!(CSharedLockMgr::Instance().FLock (*plock.get())))
	{
		DebugTrace ("DavFS: CLockRequest::DoLock() - CSharedLockMgr::Instance().FLock() failed\n");

		SendResponse(E_FAIL); //HSC_INTERNAL_SERVER_ERROR;
		return;
	}

	//	Emit the Lock-Token: header
	//
	m_pmu->SetResponseHeader (gc_szLockTokenHeader, plock->GetLockTokenString());

	//	Generate a valid lock response
	//
	plock->SendLockComment (m_pmu.get());

    Assert(S_OK == sc);

	SendResponse(m_fCreatedFile ? W_DAV_CREATED : S_OK);
}

//	------------------------------------------------------------------------
//
//	CLockRequest::SendResponse()
//
//	Set the response code and send the response.
//
VOID
CLockRequest::SendResponse( SCODE sc, UINT uiErrorDetail )
{
	PutTrace( "DAV: TID %3d: 0x%08lX: CLockRequest::SendResponse() called\n", GetCurrentThreadId(), this );

	
	//	We must close the file handle before we send any respose back
	//  to client. Otherwise, if the lcok failed, client may send another
	//  request immediately and expect the resource is not locked.
	//
	//	Even in the case the lock succeeded, it's still cleaner we release
	//	the file handle here. Think about the following sequence:
	//		LOCK f1, UNLOCK f1, PUT f1;
	//	the last PUT could fail if the first LOCK reqeust hangs a little longer
	//	after it sends the response.
	//
	//	Keep in mind that if locked succeeded, the handle is already duplicated
	//	in davcdata.exe. so releasing the file handle here doesn't really 'unlock'
	//	file. the file is still locked.
	//
	m_hfile.clear();

	if (FAILED(sc) && m_fCreatedFile)
	{
		//	WARNING: the safe_revert class should only be
		//	used in very selective situations.  It is not
		//	a "quick way to get around" impersonation.
		//
		safe_revert sr(m_pmu->HitUser());

		//	If we created the new file, we much delete it. Note that
		//	DoLock() would never fail after it duplicate the filehandle
		//	to davcdata, so we should be able to delete the file successfully
		//
		DavDeleteFile (m_pwszPath);
		DebugTrace ("Dav: deleting partial lock (%ld)\n", GetLastError());

		//	Now that we have cleaned up. reset m_fCreateFile so that we can
		//	skip the exception-safe code in ~CLockRequest()
		//
		m_fCreatedFile = FALSE;
	}
	
	//	Set the response code and go
	//
	m_pmu->SetResponseCode (HscFromHresult(sc), NULL, uiErrorDetail);
	m_pmu->SendCompleteResponse();
}

//
//	ProcessLockRequest
//
//		pmu -- MethUtil access
//
VOID
ProcessLockRequest (LPMETHUTIL pmu)
{
	auto_ref_ptr<CLockRequest> pRequest(new CLockRequest (pmu));

	pRequest->Execute();
}

//	DAV-Lock Implementation ---------------------------------------------------
//
/*
 *	DAVLock()
 *
 *	Purpose:
 *
 *		Win32 file system implementation of the DAV LOCK method.  The
 *		LOCK method results in the locking of a resource for a specific
 *		type of access.  The response tells whether the lock was granted
 *		or not.  If the lock was granted, it provides a lockid to be used
 *		in future methods (including UNLOCK) on the resource.
 *
 *	Parameters:
 *
 *		pmu			[in]  pointer to the method utility object
 *
 *	Notes:
 *
 *		In the file system implementation, the LOCK method maps directly
 *		to the Win32 CreateFile() method with special access flags.
 */
void
DAVLock (LPMETHUTIL pmu)
{
	HRESULT hr = S_OK;
	auto_ref_ptr<CLockFS> plock;
	UINT uiErrorDetail = 0;
	LPCWSTR pwszLockToken;
	CResourceInfo cri;

	//	Do ISAPI application and IIS access bits checking
	//
	hr = pmu->ScIISCheck (pmu->LpwszRequestUrl());
	if (FAILED(hr))
	{
		//	Either the request has been forwarded, or some bad error occurred.
		//	In either case, quit here and map the error!
		//
		goto ret;
	}

	//	Process based on resource info
	//
	hr = cri.ScGetResourceInfo (pmu->LpwszPathTranslated());
	if (!FAILED (hr))
	{
		//  Check to see if the resource is a DIRECTORY.
		//	DAVFS can lock non-existant resources, but can't lock directories.
		//
		if (cri.FCollection())
		{
			//  The resource is a directory.
			//
			DavTrace ("Dav: directory resource specified for LOCK\n");
			hr = E_DAV_PROTECTED_ENTITY;
			uiErrorDetail = IDS_BR_NO_COLL_LOCK;
			goto ret;
		}

		//	Ensure the URI and resource match
		//
		(void) ScCheckForLocationCorrectness (pmu, cri, NO_REDIRECT);

		//	Check against the "if-xxx" headers
		//
		hr = ScCheckIfHeaders (pmu, cri.PftLastModified(), FALSE);
	}
	else
		hr = ScCheckIfHeaders (pmu, pmu->LpwszPathTranslated(), FALSE);

	if (FAILED(hr))
	{
		DebugTrace ("DavFS: If-xxx checking failed.\n");
		goto ret;
	}

	//	Check If-State-Match headers.
	//
	hr = HrCheckStateHeaders (pmu, pmu->LpwszPathTranslated(), FALSE);
	if (FAILED(hr))
	{
		DebugTrace ("DavFS: If-State checking failed.\n");
		goto ret;
	}

	//	If they pass in a lock token *AND* a lockinfo header, it's a
	//	bad request.  (Lock upgrading is NOT allowed.)
	//	Just the lock token (no lockinfo) is a lock refresh request.
	//
	pwszLockToken = pmu->LpwszGetRequestHeader (gc_szLockToken, TRUE);
	if (pwszLockToken)
	{
		//	Lock-Token header present -- REFRESH request.
		//
		LPCWSTR pwsz;

		//	If we have a content-type, it better be text/xml.
		//
		pwsz = pmu->LpwszGetRequestHeader (gc_szContent_Type, FALSE);
		if (pwsz)
		{
			//	If it's not text/xml....
			//
			if (_wcsicmp(pwsz, gc_wszText_XML) && _wcsicmp(pwsz, gc_wszApplication_XML))
			{
				//	Invalid request -- has some other kind of request body
				//
				DebugTrace ("DavFS: Invalid body found on LOCK refresh method.\n");
				hr = E_DAV_UNKNOWN_CONTENT;
				uiErrorDetail = IDS_BR_LOCK_BODY_TYPE;
				goto ret;
			}
		}

		//	If we have a content length at all, it had better be zero.
		//	(Lock refreshes can't have a body!)
		//
		pwsz = pmu->LpwszGetRequestHeader (gc_szContent_Length, FALSE);
		if (pwsz)
		{
			//	If the Content-Length is anything other than zero, bad request.
			//
			if (_wcsicmp(pwsz, gc_wsz0))
			{
				//	Invalid request -- has some other kind of request body
				//
				DebugTrace ("DavFS: Invalid body found on LOCK refresh method.\n");
				hr = E_DAV_INVALID_HEADER; //HSC_BAD_REQUEST;
				uiErrorDetail = IDS_BR_LOCK_BODY_SYNTAX;
				goto ret;
			}
		}

		//	Process the refresh.
		//
		hr = HrProcessLockRefresh (pmu,
								   pwszLockToken,
								   &uiErrorDetail,
								   plock.load());
		if (FAILED(hr))
		{
			// uiErrorDetail already set in the above call.
			goto ret;
		}

		//	And we're done.  Go generate a valid lock response.
		//
	}
	else
	{
		//	No Lock-Token header present -- LOCK request.
		//
		
		//	Go get this lock.  All error handling and response
		//	generation is done inside ProcessLockRequest()
		//	so there's nothing more to do here once we call it.
		//
		ProcessLockRequest (pmu);
		return;
	}

	//	Build the response to go back to the caller.
	//

	//	We better have a lock object to work with!
	//
	Assert(plock.get());

	//	Send back the lock comment.
	//	Tell the lock to generate XML lockdiscovery prop data
	//	and emit it to the response body. 
	//
	plock->SendLockComment (pmu);
	
ret:
	pmu->SetResponseCode (HscFromHresult(hr), NULL, uiErrorDetail, CSEFromHresult(hr));
	
}


/*
 *	DAVUnlock()
 *
 *	Purpose:
 *
 *		Win32 file system implementation of the DAV UNLOCK method.  The
 *		UNLOCK method results in the moving of a resource from one location
 *		to another.	 The response is used to indicate the success of the
 *		call.
 *
 *	Parameters:
 *
 *		pmu			[in]  pointer to the method utility object
 *
 *	Notes:
 *
 *		In the file system implementation, the UNLOCK method maps directly
 *		to the Win32 CloseHandle() method.
 */
void
DAVUnlock (LPMETHUTIL pmu)
{
	LPCWSTR pwszPath = pmu->LpwszPathTranslated();
	auto_ref_ptr<CLockFS> plock;

	LPCWSTR pwsz;
	__int64 i64LockId;
	UINT uiErrorDetail = 0;
	HRESULT hr;
	CResourceInfo cri;

	//	Do ISAPI application and IIS access bits checking
	//
	hr = pmu->ScIISCheck (pmu->LpwszRequestUrl());
	if (FAILED(hr))
	{
		//	Either the request has been forwarded, or some bad error occurred.
		//	In either case, quit here and map the error!
		//
		goto ret;
	}

	//	Check what kind of lock is requested.
	//	(No lock-info header means this request is invalid.)
	//
	pwsz = pmu->LpwszGetRequestHeader (gc_szLockTokenHeader, FALSE);
	if (!pwsz)
	{
		DebugTrace ("DavFS: UNLOCK fails without Lock-Token.\n");
		hr = E_INVALIDARG;
		uiErrorDetail = IDS_BR_LOCKTOKEN_MISSING;
		goto ret;
	}

	hr = HrCheckStateHeaders (pmu,		//	methutil
							  pwszPath,	//	path
							  FALSE);	//	fGetMeth
	if (FAILED(hr))
	{
		DebugTrace ("DavFS: If-State checking failed.\n");
		goto ret;
	}

#ifdef	NEVER
	//$NEVER
	//	Old code -- the common functions use here have changed to expect
	//	If: header syntax.  We can't use this anymore.  It gives errors because
	//	the Lock-Token header doesn't have parens around the locktokens.
	//$NEVER: Remove this after Joel has a chance to test stuff!
	//

	//	Feed the Lock-Token header string into a parser object.
	//	Then get the lockid from the parser object.
	//
	{
		CParseLockTokenHeader lth(pmu, pwsz);

		//	If there is more than one token, bad request.
		//
		if (!lth.FOneToken())
		{
			DavTrace ("DavFS: More than one token in DAVUnlock.\n");
			hr = E_DAV_INVALID_HEADER;
			uiErrorDetail = IDS_BR_MULTIPLE_LOCKTOKENS;
			goto ret;
		}

		lth.SetPaths (pwszPath, NULL);

		hr = lth.HrGetLockIdForPath (pwszPath, 0, &i64LockId);
		if (FAILED(hr))
		{
			DavTrace ("Dav: Failure in DAVUnlock on davfs.\n");
			uiErrorDetail = IDS_BR_LOCKTOKEN_SYNTAX;
			goto ret;
		}
	}
#endif	// NEVER

	//	Call to fetch the lockid from the Lock-Token header.
	//
	hr = HrLockIdFromString(pmu, pwsz, &i64LockId);

	if (FAILED(hr))
	{
		DavTrace ("DavFS: Failed to fetch locktoken in UNLOCK.\n");

		//	They have a well-formed request, but their locktoken is not right.
		//	Tell the caller we can't satisfy this (un)lock request. (412 Precondition Failed)
		//
		hr = E_DAV_CANT_SATISFY_LOCK_REQUEST;
		goto ret;
	}

	Assert(i64LockId);

	//	Fetch the lock from the cache. (This call updates the timestamp.)
	//	Get the lock from the cache.  If this object is not in our cache,
	//	or the lockid doesn't match, don't let them unlock the resource.
	//$REVIEW: Should this be two distinct error codes?
	//
	hr = CSharedLockMgr::Instance().HrGetLock (pmu, i64LockId, plock.load());
	if (FAILED(hr))
	{
		DavTrace ("DavFS: Unlocking a non-locked resource constitutes an unsatisfiable request.\n");

		//	If it's an access violation, leave the return code unchanged.
		//	Otherwise, give "can't satisfy request" (412 Precondition Failed).
		//
		if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) != hr)
			hr = E_DAV_CANT_SATISFY_LOCK_REQUEST;
		uiErrorDetail = IDS_BR_LOCKTOKEN_INVALID;
		goto ret;
	}

	Assert (plock.get());

	//	Check that the storage paths match.
	//	If not, their locktoken is invalid!
	//
    if (lstrcmpiW (pwszPath, plock->GetResourceName()))
	{
		DavTrace ("DavFSUnlock: resource name did not match fetched lock -- unsatisfiable request.\n");
		hr = E_DAV_CANT_SATISFY_LOCK_REQUEST;
		uiErrorDetail = IDS_BR_LOCKTOKEN_INVALID;
		goto ret;
	}

	//	This method is gated by the "if-xxx" headers
	//
	hr = cri.ScGetResourceInfo (pwszPath);
	if (FAILED (hr))
	{
		goto ret;
	}
	hr = ScCheckIfHeaders (pmu, cri.PftLastModified(), FALSE);
	if (FAILED (hr))
	{
		goto ret;
	}

	//	Ensure the URI and resource match
	//
	(void) ScCheckForLocationCorrectness (pmu, cri, NO_REDIRECT);

	//	Delete the lock from the cache.
	//$LATER: Do we want return codes from these calls?!!
	//
	CSharedLockMgr::Instance().DeleteLock (i64LockId);
ret:

	if (!FAILED (hr))
	{
		hr = W_DAV_NO_CONTENT;
	}

	//	Setup the response
	//
	pmu->SetResponseCode (HscFromHresult(hr), NULL, uiErrorDetail, CSEFromHresult(hr));
}


//	------------------------------------------------------------------------
//
//	Utility functions for other FS methods to use when accessing locks.
//
//	------------------------------------------------------------------------


//	------------------------------------------------------------------------
//
//	FGetLockHandleFromId
//
BOOL
FGetLockHandleFromId (LPMETHUTIL pmu, __int64 i64LockId,
					  LPCWSTR pwszPath, DWORD dwAccess,
					  auto_ref_handle * phandle)
{
	auto_ref_ptr<CLockFS> plock;

	HRESULT hr;

	Assert (pmu);
	Assert (i64LockId);
	Assert (!IsBadWritePtr(phandle, sizeof(auto_ref_handle)));

	//	Fetch the lock from the cache. (This call updates the timestamp.)
	//
	hr = CSharedLockMgr::Instance().HrGetLock (pmu, i64LockId, plock.load());

	if (FAILED(hr))
	{
		DavTrace ("Dav: Failure in FGetLockHandle on davfs.\n");
		return FALSE;
	}

	//	Check the storage path passed in.
	//
	if (lstrcmpiW (pwszPath, plock->GetResourceName()))
	{
		DavTrace ("FGetLockHandleFromId: Translated path did not match -- bad request.\n");
		return FALSE;
	}

	//	Check the access type required.
	//	(If the lock is missing any single flag requested, fail.)
	//
	if ( (dwAccess & plock->GetAccess()) != dwAccess )
	{
		DavTrace ("FGetLockHandleFromId: Access did not match -- bad request.\n");
		return FALSE;
	}

    // Get a copy of the handle for the caller.
    SharedPtr<CInShLockData>& splock = plock->SharedData();

	HANDLE hTemp =  INVALID_HANDLE_VALUE;
	HANDLE hDAVProc = INVALID_HANDLE_VALUE;

	hr = CSharedLockMgr::Instance().GetDAVProcessHandle(&hDAVProc);
	if (FAILED(hr))
	{
		DavTrace("GetDAVProcessHandle failed with %x \r\n", hr);
		return FALSE;
	}

	hr = splock->GetUsableHandle(hDAVProc, &hTemp);
	if (FAILED(hr))
	{
		DavTrace("GetUsableHandle failed with %x \r\n", hr);
		return FALSE;
	}

	if (!phandle->FCreate(hTemp))
	{
		hr = E_OUTOFMEMORY;
		DavTrace("FCreate on autohandler failed \r\n");
		return FALSE;
	}

	//	HACK: Rewind the handle here -- until we get a better solution!
	//$LATER: Need a real way to handle multiple access to the same lock handle.
	//
	SetFilePointer ((*phandle).get(), 0, NULL, FILE_BEGIN);

	return TRUE;
}


//	------------------------------------------------------------------------
//
//	FGetLockHandle
//
//	Main routine for all other methods to get a handle from the cache.
//
BOOL
FGetLockHandle (LPMETHUTIL pmu, LPCWSTR pwszPath,
				DWORD dwAccess, LPCWSTR pwszLockTokenHeader,
				auto_ref_handle * phandle)
{
	__int64 i64LockId;
	HRESULT hr;

	Assert (pmu);
	Assert (pwszPath);
	Assert (pwszLockTokenHeader);
	Assert (!IsBadWritePtr(phandle, sizeof(auto_ref_handle)));


	//	Feed the Lock-Token header string into a parser object.
	//	And feed in the one path we're interested in.
	//	Then get the lockid from the parser object.
	//
	{
		CParseLockTokenHeader lth (pmu, pwszLockTokenHeader);

		lth.SetPaths (pwszPath, NULL);

		hr = lth.HrGetLockIdForPath (pwszPath, dwAccess, &i64LockId);
		if (FAILED(hr))
		{
			DavTrace ("Dav: Failure in FGetLockHandle on davfs.\n");
			return FALSE;
		}
	}

	return FGetLockHandleFromId (pmu, i64LockId, pwszPath, dwAccess, phandle);
}


//	========================================================================
//	Helper functions for locked MOVE and COPY
//

//	------------------------------------------------------------------------
//
//	ScDoOverlappedCopy
//
//		Takes two file handles that have been opened for overlapped (async)
//		processing, and copies data from the source to the dest.
//		The provided hevt is used in the async read/write operations.
//
SCODE
   ScDoOverlappedCopy (HANDLE hfSource, HANDLE hfDest, HANDLE hevtOverlapped)
{
	SCODE sc = S_OK;
	OVERLAPPED ov;
	BYTE rgbBuffer[1024];
	ULONG cbToWrite;
	ULONG cbActual;

	Assert (hfSource);
	Assert (hfDest);
	Assert (hevtOverlapped);

	ov.hEvent     = hevtOverlapped;
	ov.Offset     = 0;
	ov.OffsetHigh = 0;

	//	Big loop.  Read from one file, and write to the other.
	//

	while (1)
	{
		//	Read from the source file.
		//
		if (!ReadFromOverlapped (hfSource, rgbBuffer, sizeof(rgbBuffer),
								 &cbToWrite, &ov))
		{
			DebugTrace ("Dav: failed to write to file\n");
			sc = HRESULT_FROM_WIN32 (GetLastError());
			goto ret;
		}

		//	If no bytes were read (and no error), we're done!
		//
		if (!cbToWrite)
			break;

		//	Write the data to the destination file.
		//
		if (!WriteToOverlapped (hfDest,
								rgbBuffer,
								cbToWrite,
								&cbActual,
								&ov))
		{
			DebugTrace ("Dav: failed to write to file\n");
			sc = HRESULT_FROM_WIN32 (GetLastError());
			goto ret;
		}

		//	Adjust the starting read position.
		//
		ov.Offset += cbActual;
	}

	//	That's it.  Set the destination file's size (set EOF) and we're done.
	//
	SetFilePointer (hfDest,
					ov.Offset,
					reinterpret_cast<LONG *>(&ov.OffsetHigh),
					FILE_BEGIN);
	SetEndOfFile (hfDest);

ret:
	return sc;
}


//	------------------------------------------------------------------------
//
//	ScDoLockedCopy
//
//		Given the Lock-Token header and the source & destination paths,
//		handle copying from one file to another, with locks in the way.
//
//		The general flow is this:
//
//		First check the lock tokens for validity & fetch any valid lock handles.
//		We must have read access on the source and write access on the dest.
//		If any lock token is invalid, or doesn't have the correct access, fail.
//		We need two handles (source & dest) to do the copy, so
//		manually fetch handles that didn't have lock tokens.
//		Once we have both handles, call ScDoOverlappedCopy to copy the file data.
//		Then, copy the DAV property stream from the source to the dest.
//		Any questions?
//
//		NOTE: This routine should ONLY be called if we already tried to copy
//		the files and we hit a sharing violation.
//
//
//
SCODE
ScDoLockedCopy (LPMETHUTIL pmu,
				CParseLockTokenHeader * plth,
				LPCWSTR pwszSrc,
				LPCWSTR pwszDst)
{
	auto_handle<HANDLE> hfCreated;
	auto_handle<HANDLE>	hevt;
	BOOL fSourceLock = FALSE;
	BOOL fDestLock = FALSE;
	__int64 i64Source;
	__int64 i64Dest;
	auto_ref_handle hfLockedSource;
	auto_ref_handle hfLockedDest;
	HANDLE hfSource = INVALID_HANDLE_VALUE;
	HANDLE hfDest = INVALID_HANDLE_VALUE;
	SCODE sc;

	Assert (pmu);
	Assert (plth);
	Assert (pwszSrc);
	Assert (pwszDst);


	//	Get any lockids for these paths.
	//
	sc = plth->HrGetLockIdForPath (pwszSrc, GENERIC_READ, &i64Source);
	if (SUCCEEDED(sc))
	{
		fSourceLock = TRUE;
	}
	sc = plth->HrGetLockIdForPath (pwszDst, GENERIC_WRITE, &i64Dest);
	if (SUCCEEDED(sc))
	{
		fDestLock = TRUE;
	}

	//	If they didn't even pass in tokens for these paths, quit here.
	//	Return & tell them that there's still a sharing violation.
	//
	if (!fSourceLock && !fDestLock)
	{
		DebugTrace ("DwDoLockedCopy -- No locks apply to these paths!");
		return E_DAV_LOCKED;
	}

	if (fSourceLock)
	{
		if (FGetLockHandleFromId (pmu, i64Source, pwszSrc, GENERIC_READ,
								  &hfLockedSource))
		{
			hfSource = hfLockedSource.get();
		}
		else
		{
			//	Clear our flag -- they passed in an invalid/expired token.
			fSourceLock = FALSE;
		}
	}

	if (fDestLock)
	{
		if (FGetLockHandleFromId (pmu, i64Dest, pwszDst, GENERIC_WRITE,
								  &hfLockedDest))
		{
			hfDest = hfLockedDest.get();
		}
		else
		{
			//	Clear our flag -- they passed in an invalid/expired token.
			fDestLock = FALSE;
		}
	}

	//	Okay, now we either have NO lockhandles (they passed in locktokens
	//	but they were all expired) or one handle, or two handles.
	//

	//	NO lockhandles (all their locks were expired) -- kick 'em out.
	//	And tell 'em there's still a sharing violation to deal with.
	//$REVIEW: Or should we try the copy again???
	if (!fSourceLock && !fDestLock)
	{
		DebugTrace ("DwDoLockedCopy -- No locks apply to these paths!");
		return E_DAV_LOCKED;
	}

	//	One handle -- open up the other file manually & shove the data across.

	//	Two handles -- shove the data across.


	//	If we don't have one of these handles, open the missing one manually.
	//
	if (!fSourceLock)
	{
		//	Open up the source file manually.
		//
		hfCreated = DavCreateFile (pwszSrc,					// filename
								   GENERIC_READ,				// dwAccess
								   FILE_SHARE_READ | FILE_SHARE_WRITE,	// don't clash with OTHER locks
								   NULL,						// lpSecurityAttributes
								   OPEN_ALWAYS,				// creation flags
								   FILE_ATTRIBUTE_NORMAL |	// attributes
								   FILE_FLAG_OVERLAPPED |
								   FILE_FLAG_SEQUENTIAL_SCAN,
								   NULL);					// tenplate
		if (INVALID_HANDLE_VALUE == hfCreated.get())
		{
			DebugTrace ("DavFS: DwDoLockedCopy failed to open source file\n");
			sc = HRESULT_FROM_WIN32 (GetLastError());
			goto ret;
		}
		hfSource = hfCreated.get();
	}
	else if (!fDestLock)
	{
		//	Open up the destination file manually.
		//	This guy is CREATE_NEW becuase we should have already deleted
		//	any files that would have conflicted!
		//
		hfCreated = DavCreateFile (pwszDst,					// filename
								   GENERIC_WRITE,			// dwAccess
								   0,  //FILE_SHARE_READ | FILE_SHARE_WRITE,	// DO clash with OTHER locks -- just like PUT
								   NULL,						// lpSecurityAttributes
								   CREATE_NEW,				// creation flags
								   FILE_ATTRIBUTE_NORMAL |	// attributes
								   FILE_FLAG_OVERLAPPED |
								 FILE_FLAG_SEQUENTIAL_SCAN,
								 NULL);					// tenplate
		if (INVALID_HANDLE_VALUE == hfCreated)
		{
			DebugTrace ("DavFS: DwDoLockedCopy failed to open destination file\n");
			sc = HRESULT_FROM_WIN32 (GetLastError());
			goto ret;
		}
		hfDest = hfCreated.get();
	}

	//	Now we should have two handles.
	//
	Assert ((hfSource != INVALID_HANDLE_VALUE) && (hfDest != INVALID_HANDLE_VALUE));

	//	Setup the overlapped structure so we can read/write to async files.
	//
	hevt = CreateEvent(NULL, TRUE, FALSE, NULL);
	if (!hevt.get())
	{
		DebugTrace ("DavFS: DwDoLockedCopy failed to create event for overlapped read.\n");
		sc = HRESULT_FROM_WIN32 (GetLastError());
		goto ret;
	}

	//	Copy the file data.
	//
	sc = ScDoOverlappedCopy (hfSource, hfDest, hevt.get());
	if (FAILED (sc))
		goto ret;

	//	Copy over any property data.
	//
	if (FAILED (ScCopyProps (pmu, pwszSrc, pwszDst, FALSE, hfSource, hfDest)))
		sc = E_DAV_LOCKED;

ret:

	return sc;
}


VOID __fastcall IMPLSTUB::SaveHandle(HANDLE hHandle)
{
	PIPELINE::SaveHandle(hHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\fslnkfx.cpp ===
/*
 *	F S L N K F X . C P P
 *
 *	Link fixup impl support
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"
const WCHAR gc_wszDavDLL[] = L"httpext.dll";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\fsguid.c ===
/*
 *	F S G U I D . C
 *
 *	Filesystem GUIDs
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#pragma warning(disable:4001)	/* single line comments */
#pragma warning(disable:4050)	/* different code attributes */
#pragma warning(disable:4100)	/* unreferenced formal parameter */
#pragma warning(disable:4115)	/* named type definition in parentheses */
#pragma warning(disable:4127)	/* conditional expression is constant */
#pragma warning(disable:4201)	/* nameless struct/union */
#pragma warning(disable:4206)	/* translation unit is empty */
#pragma warning(disable:4209)	/* benign typedef redefinition */
#pragma warning(disable:4214)	/* bit field types other than int */
#pragma warning(disable:4514)	/* unreferenced inline function */

#include <windows.h>

#pragma warning(disable:4201)	/* nameless struct/union */

#define DBINITCONSTANTS

#include <oledb.h>
#include <msidxs.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\fsget.cpp ===
/*
 *	F S G E T . C P P
 *
 *	Sources file system implementation of DAV-Base
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"
#include <htmlmap.h>
#include <ex\rgiter.h>

/*
 *	ScEmitFile()
 *
 *	Purpose:
 *
 *		Helper function used to open and transmit a given
 *		file from the local dav namespace.
 *
 *	Parameters:
 *
 *		pmu				[in]  pointer to the method util obj
 *		pwszFile		[in]  name of file to emit
 *		pwszContent		[in]  content type of the file, we need it if it is a multipart response
 *
 *	Returns:
 *
 *		SCODE.
 *		S_OK (0) indicates success, and the WHOLE file was sent.
 *		W_DAV_PARTIAL_CONTENT indicates success, but only PARTIAL content was
 *			sent because of a Content-Range header.
 *		An error (FAILED(sc)) means that the file was not setn.
 */
SCODE
ScEmitFile (LPMETHUTIL pmu,
			LPCWSTR pwszFile,
			LPCWSTR pwszContent)
{
	auto_ref_handle hf;
	BOOL fMap = FALSE;
	BY_HANDLE_FILE_INFORMATION fi;
	CRangeParser riByteRange;
	LPCWSTR pwsz;
	SCODE sc = S_OK;
	UINT cch;

	//	Check validity of input
	//
	Assert (pwszFile);
	Assert (pwszContent);

	//	Check to see if we have a map file
	//
	cch = static_cast<UINT>(wcslen (pwszFile));
	if ((cch >= 4) && !lstrcmpiW (L".map", pwszFile + cch - 4))
		fMap = TRUE;

	//	If we have a locktoken, try to get the lock handle from the cache.
	//	If this fails, fall through and do the normal processing.
	//	DO NOT put LOCK handles into an auto-object!!  The CACHE still owns it!!!
	//
	pwsz = pmu->LpwszGetRequestHeader (gc_szLockToken, TRUE);
	if (!pwsz ||
		!FGetLockHandle (pmu, pmu->LpwszPathTranslated(), GENERIC_READ, pwsz, &hf))
	{
		//	Open the file and go to it
		//
		if (!hf.FCreate(
			DavCreateFile (pwszFile,						// filename
						   GENERIC_READ,					// dwAccess
						   FILE_SHARE_READ | FILE_SHARE_WRITE,
						   NULL,							// lpSecurityAttributes
						   OPEN_EXISTING,					// creation flags
						   FILE_ATTRIBUTE_NORMAL |
						   FILE_FLAG_SEQUENTIAL_SCAN |
						   FILE_FLAG_OVERLAPPED,			// attributes
						   NULL)))							// template
		{
			DWORD dwErr = GetLastError();
			sc = HRESULT_FROM_WIN32 (dwErr);

			//	Special work for 416 Locked responses -- fetch the
			//	comment & set that as the response body.
			//
			if (FLockViolation (pmu, dwErr, pwszFile, GENERIC_READ))
			{
				sc = E_DAV_LOCKED;
			}

			DebugTrace ("Dav: failed to open the file for retrieval\n");
			goto ret;
		}
	}

	//	We better have a valid handle.
	Assert (hf.get() != INVALID_HANDLE_VALUE);

	//	We are going to need the file size for both map files and
	//	ordinary files. For map files, we read the entire file into
	//	memory. For ordinary files, we need the file size to do
	//	byte range validation.
	//
	if (!GetFileInformationByHandle(hf.get(), &fi))
	{
		sc = HRESULT_FROM_WIN32 (GetLastError());
		goto ret;
	}

	//	Again, if it is a mapfile, we need to parse the map and
	//	find the right URL to redirect to, otherwise, we can just
	//	emit the file back to the client.
	//
	if (fMap && pmu->FTranslated())
	{
		auto_handle<HANDLE>	hevt(CreateEvent(NULL, TRUE, FALSE, NULL));
		auto_heap_ptr<CHAR> pszBuf;
		BOOL fRedirect = FALSE;
		LPCSTR pszPrefix;
		CHAR pszRedirect[MAX_PATH];
		OVERLAPPED ov;
		ULONG cb;

		//	The common case is that these map files are not very large.
		//	We may want to put a physical upper bound on the size of the
		//	file, but I don't see that as an imperitive thing at this
		//	point.
		//
		//	Since we are going to need to parse the whole thing, we are
		//	going to read the whole thing into memory at once. Read the file
		//	in, and then parse it out.
		//
		//	Allocate space for the file.
		//	Lets put an uper bound of 64K on it.
		//
		if ((fi.nFileSizeHigh != 0) || (fi.nFileSizeLow > (128 * 1024)))
		{
			//	Mapping is too large for our tastes
			//
			DavTrace ("Dav: mapping file too large\n");
			sc = HRESULT_FROM_WIN32 (ERROR_MORE_DATA);
			goto ret;
		}
		pszBuf = (CHAR *)g_heap.Alloc (fi.nFileSizeLow + 1);

		//	Read it in
		//
		ov.hEvent = hevt;
		ov.Offset = 0;
		ov.OffsetHigh = 0;
		if (!ReadFromOverlapped (hf.get(), pszBuf, fi.nFileSizeLow, &cb, &ov))
		{
			sc = HRESULT_FROM_WIN32 (GetLastError());
			goto ret;
		}
		Assert (cb == fi.nFileSizeLow);

		//	Ensure the file data is NULL terminated
		//
		*(pszBuf + cb) = 0;

		//	Check the map...
		//
		pmu->CchUrlPrefix(&pszPrefix);
		if (FIsMapProcessed (pmu->LpszQueryString(),
							 pszPrefix,
							 pmu->LpszServerName(),
							 pszBuf.get(),
							 &fRedirect,
							 pszRedirect,
							 MAX_PATH))
		{
			//	Redirect the request
			//
			if (fRedirect)
			{
				sc = pmu->ScRedirect (pszRedirect);
				goto ret;
			}
		}

		//	if not redirect, we should rewind the file pointer
		//	back to the beginning.
		//
		if (INVALID_SET_FILE_POINTER == SetFilePointer (hf.get(), 0, NULL, FILE_BEGIN))
		{
			sc = HRESULT_FROM_WIN32 (GetLastError());
			goto ret;
		}
	}

	//	Do any byte range (206 Partial Content) processing. The function will fail out if the
	//	we are trying to do byte ranges on the file larger than 4GB.
	//
	sc = ScProcessByteRanges (pmu, pwszFile, fi.nFileSizeLow, fi.nFileSizeHigh, &riByteRange);

	//	Tell the parser to transmit the file
	//
	//	We need to transmit the entire file
	//
	if (S_OK == sc)
	{
		//	Just add the file
		//
		pmu->AddResponseFile (hf);
	}
	else if (W_DAV_PARTIAL_CONTENT == sc)
	{
		//	It is a byte range transmission. Tranmsit the ranges.
		//
		Assert(0 == fi.nFileSizeHigh);
		TransmitFileRanges(pmu, hf, fi.nFileSizeLow, &riByteRange, pwszContent);
	}

ret:

	return sc;
}

/*
 *	TransmitFileRanges()
 *
 *	Purpose:
 *
 *		Helper function used to transmit a byte range
 *		file from the local dav namespace.
 *
 *	Parameters:
 *
 *		pmu				[in]  pointer to the method util obj
 *		hf				[in]  handle of file to emit
 *		dwSize			[in]  size of file
 *		priRanges		[in]  the ranges
 *		pszContent		[in]  content type of the file, we need it if it is a multipart response
 *
 */
VOID
TransmitFileRanges (LPMETHUTIL pmu,
					const auto_ref_handle& hf,
					DWORD dwSize,
					CRangeBase * priRanges,
					LPCWSTR pwszContent)
{
	auto_heap_ptr<WCHAR> pwszPreamble;
	WCHAR rgwchBoundary[75];
	const RGITEM * prgi = NULL;
	DWORD dwTotalRanges;

	//	Create a buffer for the preamble we tramsit before each part
	//	of the response.
	//
	pwszPreamble = static_cast<LPWSTR>(g_heap.Alloc
		((2 + CElems(rgwchBoundary) + 2 +
		gc_cchContent_Type + 2 + wcslen(pwszContent) + 2 +
		gc_cchContent_Range + 2 + gc_cchBytes + 40) * sizeof(WCHAR)));

	//	Assert that we have a at least one range to transmit
	//
	Assert (priRanges);
	dwTotalRanges = priRanges->UlTotalRanges();
	Assert (dwTotalRanges > 0);

	//	Assert that we have a content type.
	//
	Assert (pwszContent);

	//	Rewind to the first range. This is only a precautionary measure.
	//
	priRanges->Rewind();
	prgi = priRanges->PrgiNextRange();

	//	Is it a singlepart response
	//
	if ((1 == dwTotalRanges) && prgi && (RANGE_ROW == prgi->uRT))
	{
		//	Set the content range header
		//
		wsprintfW(pwszPreamble, L"%ls %u-%u/%u",
				  gc_wszBytes,
				  prgi->dwrgi.dwFirst,
				  prgi->dwrgi.dwLast,
				  dwSize);

		pmu->SetResponseHeader (gc_szContent_Range, pwszPreamble);

		//	Add the file
		//
		pmu->AddResponseFile (hf,
							  prgi->dwrgi.dwFirst,
							  prgi->dwrgi.dwLast - prgi->dwrgi.dwFirst + 1);
	}
	else
	{
		//	We have multiple byte ranges, then we need to generate a
		//	boundary and set the Content-Type header with the multipart
		//	content type and boundary.
		//
		//	Generate a boundary
		//
		GenerateBoundary (rgwchBoundary, CElems(rgwchBoundary));

		//	Create the content type header with the boundary generated
		//
		wsprintfW(pwszPreamble, L"%ls; %ls=\"%ls\"",
				  gc_wszMultipart_Byterange,
				  gc_wszBoundary,
				  rgwchBoundary);

		//	Reset the content type header with the new content type
		//
		pmu->SetResponseHeader (gc_szContent_Type, pwszPreamble);

		do {

			if (RANGE_ROW == prgi->uRT)
			{
				//	Create preamble.
				//
				wsprintfW(pwszPreamble, L"--%ls%ls%ls: %ls%ls%ls: %ls %u-%u/%u%ls%ls",
						  rgwchBoundary,
						  gc_wszCRLF,
						  gc_wszContent_Type,
						  pwszContent,
						  gc_wszCRLF,
						  gc_wszContent_Range,
						  gc_wszBytes,
						  prgi->dwrgi.dwFirst,
						  prgi->dwrgi.dwLast,
						  dwSize,
						  gc_wszCRLF,
						  gc_wszCRLF);

				pmu->AddResponseText (static_cast<UINT>(wcslen(pwszPreamble)), pwszPreamble);
				pmu->AddResponseFile (hf,
									  prgi->dwrgi.dwFirst,
									  prgi->dwrgi.dwLast - prgi->dwrgi.dwFirst + 1);

				//	Add the CRLF
				//
				pmu->AddResponseText (gc_cchCRLF, gc_szCRLF);
			}
			prgi = priRanges->PrgiNextRange();

		} while (prgi);

		//	Add the last end of response text
		//
		wsprintfW(pwszPreamble, L"--%ls--", rgwchBoundary);
		pmu->AddResponseText (static_cast<UINT>(wcslen(pwszPreamble)), pwszPreamble);
	}
}

SCODE
ScGetFile (LPMETHUTIL pmu,
	LPWSTR pwszFile,
	LPCWSTR pwszURI)
{
	SCODE sc;
	WCHAR rgwszContent[MAX_PATH];
	FILETIME ft;

	//	Get the Content-Type of the file
	//
	UINT cchContent = CElems(rgwszContent);
	if (!pmu->FGetContentType(pwszURI, rgwszContent, &cchContent))
	{
		sc = E_FAIL;
		goto ret;
	}

	//	This method is gated by If-xxx headers
	//
	sc = ScCheckIfHeaders (pmu, pwszFile, TRUE);
	if (FAILED (sc))
	{
		DebugTrace ("Dav: If-xxx failed their check\n");
		goto ret;
	}

	sc = HrCheckStateHeaders (pmu,		//	methutil
							  pwszFile,	//	path
							  TRUE);	//	fGetMeth
	if (FAILED (sc))
	{
		DebugTrace ("DavFS: If-State checking failed.\n");
		//	304 returns from get should really have an ETag....
		//SideAssert(FGetLastModTime (pmu, pwszFile, &ft));
		//hsc = HscEmitHeader (pmu, pszContent, &ft);
		goto ret;
	}

	//	Emit the headers for the file
	//
	if (FGetLastModTime (pmu, pwszFile, &ft))
	{
		sc = pmu->ScEmitHeader (rgwszContent, pwszURI, &ft);
		if (sc != S_OK)
		{
			DebugTrace ("Dav: failed to emit headers\n");
			goto ret;
		}
	}

	//	Emit the file
	//
	sc = ScEmitFile (pmu, pwszFile, rgwszContent);
	if ( (sc != S_OK) && (sc != W_DAV_PARTIAL_CONTENT) )
	{
		DebugTrace ("Dav: failed to emit file\n");
		goto ret;
	}

ret:

	return sc;
}

void
GetDirectory (LPMETHUTIL pmu, LPCWSTR pwszUrl)
{
	auto_ref_ptr<IMDData> pMDData;
	ULONG ulDirBrowsing = 0;
	LPCWSTR pwszDftDocList = NULL;
	SCODE sc = S_OK;
	UINT cchUrl = static_cast<UINT>(wcslen(pwszUrl));

	//	Before we decide to do anything, we need to check to see what
	//	kind of default behavior is expected for a directory.  Values
	//	for this level of access are cached from the metabase.  Look
	//	them up and see what to do.

	//	Get the metabase doc attributes
	//
	if (FAILED(pmu->HrMDGetData (pwszUrl, pMDData.load())))
	{
		//
		//$REVIEW	HrMDGetData() can fail for timeout reasons,
		//$REVIEW	shouldn't we just pass back the hr that it returns?
		//
		sc = E_DAV_NO_IIS_READ_ACCESS;
		goto ret;
	}

	ulDirBrowsing = pMDData->DwDirBrowsing();
	pwszDftDocList = pMDData->PwszDefaultDocList();

	//	Try to load default file if allowed, do this only when translate: t
	//
	if ((ulDirBrowsing & MD_DIRBROW_LOADDEFAULT) && pwszDftDocList && pmu->FTranslated())
	{
		HDRITER_W hit(pwszDftDocList);
		LPCWSTR pwszDoc;

		while (NULL != (pwszDoc = hit.PszNext()))
		{
			auto_com_ptr<IStream> pstm;
			CStackBuffer<WCHAR> pwszDocUrl;
			CStackBuffer<WCHAR> pwszDocUrlNormalized;
			CStackBuffer<WCHAR,MAX_PATH> pwszDocPath;
			UINT cchDocUrlNormalized;
			UINT cchDoc;

			//	What happens here is that for EVERY possible default
			//	document, we are going to see if this document is something
			//	we can legitimately process.
			//
			//	So first, we need to extend our url and normalize it
			//	in such a way that we can pin-point the document it uses.
			//
			cchDoc = static_cast<UINT>(wcslen(pwszDoc));
			pwszDocUrl.resize(CbSizeWsz(cchUrl + cchDoc));
			memcpy (pwszDocUrl.get(), pwszUrl, cchUrl * sizeof(WCHAR));
			memcpy (pwszDocUrl.get() + cchUrl, pwszDoc, (cchDoc + 1) * sizeof(WCHAR));

			//	Now, someone could have been evil and stuffed path modifiers
			//	or escaped characters in the default document name.  So we
			//	need to parse those out here -- do both in place.  You can't
			//	do this per-say in the MMC snap in, but MDUTIL does (maybe
			//	ASDUTIL too).
			//
			cchDocUrlNormalized = cchUrl + cchDoc + 1;
			pwszDocUrlNormalized.resize(cchDocUrlNormalized * sizeof(WCHAR));

			sc = ScNormalizeUrl (pwszDocUrl.get(),
								 &cchDocUrlNormalized,
								 pwszDocUrlNormalized.get(),
								 NULL);
			if (S_FALSE == sc)
			{
				pwszDocUrlNormalized.resize(cchDocUrlNormalized * sizeof(WCHAR));
				sc = ScNormalizeUrl (pwszDocUrl.get(),
									 &cchDocUrlNormalized,
									 pwszDocUrlNormalized.get(),
									 NULL);

				//	Since we've given ScNormalizeUrl() the space it asked for,
				//	we should never get S_FALSE again.  Assert this!
				//
				Assert(S_FALSE != sc);
			}

			if (FAILED (sc))
				continue;

			//	Translate this into a local path.  We should be able to
			//
			//	At most we should go through the processing below twice, as the byte
			//	count required is an out param.
			//
			do {

				pwszDocPath.resize(cchDocUrlNormalized * sizeof(WCHAR));
				sc = pmu->ScStoragePathFromUrl (pwszDocUrlNormalized.get(),
												pwszDocPath.get(),
												&cchDocUrlNormalized);

			} while (sc == S_FALSE);
			if (FAILED (sc) || (W_DAV_SPANS_VIRTUAL_ROOTS == sc))
				continue;

			//$	SECURITY:
			//
			//	Check to see if the destination is really a short
			//	filename.
			//
			sc = ScCheckIfShortFileName (pwszDocPath.get(), pmu->HitUser());
			if (FAILED (sc))
				continue;

			//$	SECURITY:
			//
			//	Check to see if the destination is really the default
			//	data stream via alternate file access.
			//
			sc = ScCheckForAltFileStream (pwszDocPath.get());
			if (FAILED (sc))
				continue;

			if (static_cast<DWORD>(-1) != GetFileAttributesW (pwszDocPath.get()))
			{
				DWORD dwAcc = 0;

				//	See if we have the right access...
				//
				(void) pmu->ScIISAccess (pwszDocUrlNormalized.get(), MD_ACCESS_READ, &dwAcc);

				//	Found the default doc, if a child ISAPI doesn't want it,
				//	then we will handle it.
				//
				//	NOTE: Pass in TRUE for fCheckISAPIAccess to tell this
				//	function to do all the special access checking.
				//
				//	NOTE: Also pass in FALSE to fKeepQueryString 'cause
				//	we're re-routing this request to a whole new URI.
				//
				sc = pmu->ScApplyChildISAPI (pwszDocUrlNormalized.get(), dwAcc, TRUE, FALSE);
				if (FAILED(sc))
				{
					//	Either the request has been forwarded, or some bad error occurred.
					//	In either case, quit here and map the error!
					//
					goto ret;
				}

				//	Emit the location of the default document
				//
				pmu->EmitLocation (gc_szContent_Location, pwszDocUrlNormalized.get(), FALSE);

				//	If we don't have any read access, then there
				//	is no point in continuing the request.
				//
				if (0 == (dwAcc & MD_ACCESS_READ))
				{
					sc = E_DAV_NO_IIS_READ_ACCESS;
					goto ret;
				}

				//	Get the file
				//
				//	NOTE: This function can give a WARNING that needs to be mapped
				//	to get our 207 Partial Content in some cases.
				//
				sc = ScGetFile (pmu, pwszDocPath.get(), pwszDocUrlNormalized.get());
				goto ret;
			}
		}
	}

	//	If we haven't emitted any other way, see if HTML
	//	is allowed...
	//
	if (ulDirBrowsing & MD_DIRBROW_ENABLED)
	{
		//	At one point in time we would generate our own HTML rendering
		//	of the directories, but at the beginning of NT beta3, the change
		//	was made to behave the same in HTTPExt as in DavEX, etc.
		//
		sc = W_DAV_NO_CONTENT;
	}
	else
	{
		//	Otherwise, report forbidden
		//	We weren't allowed to browse the dir and there was no
		//	default doc.  IIS maps this scenario to a specific
		//	suberror (403.2).
		//
		sc = E_DAV_NO_IIS_READ_ACCESS;
	}

ret:

	pmu->SetResponseCode (HscFromHresult(sc), NULL, 0, CSEFromHresult(sc));
}

/*
 *	GetInt()
 *
 *	Purpose:
 *
 *		Win32 file system implementation of the DAV GET method.	 The
 *		GET method returns a file from the DAV name space and populates
 *		the headers with the info found in the file and its meta data.	The
 *		response created indicates the success of the call and contains
 *		the data from the file.
 *
 *	Parameters:
 *
 *		pmu			[in]  pointer to the method utility object
 */
void
GetInt (LPMETHUTIL pmu)
{
	CResourceInfo cri;
	LPCWSTR pwszUrl = pmu->LpwszRequestUrl();
	LPCWSTR pwszPath = pmu->LpwszPathTranslated();
	SCODE sc = S_OK;

	//	Do ISAPI application and IIS access bits checking
	//
	sc = pmu->ScIISCheck (pwszUrl, MD_ACCESS_READ, TRUE);
	if (FAILED(sc))
	{
		//	Either the request has been forwarded, or some bad error occurred.
		//	In either case, quit here and map the error!
		//
		goto ret;
	}

	//	If we have a directory, we are going to return
	//	HTML, otherwise the extenstion of the file gives
	//	us what we need.
	//
	sc = cri.ScGetResourceInfo (pwszPath);
	if (FAILED (sc))
		goto ret;

	//	If this is a hidden object, fail with 404 Resource Not Found.  This is to be
	//	consistent with IIS (See NTRAID #247218).  They do not allow GET on resources that
	//	have the HIDDEN bit set.
	//
	if (cri.FHidden())
	{
		sc = E_DAV_HIDDEN_OBJECT;
		goto ret;
	}

	//	If this is a directory, process it as such, otherwise
	//	handle the request as if the resource was a file
	//
	if (cri.FCollection())
	{
		//	GET allows for request url's that end in a trailing slash
		//	when getting data from a directory.	 Otherwise it is a bad
		//	request.  If it does not have a trailing slash and refers
		//	to a directory, then we want to redirect.
		//
		sc = ScCheckForLocationCorrectness (pmu, cri, REDIRECT);
		if (FAILED (sc))
			goto ret;

		//	A return of S_FALSE from above means that a redirect happened
		//	so we can forego trying to do a GET on the directory.
		//
		if (S_FALSE == sc)
			return;

		GetDirectory (pmu, pwszUrl);
		return;
	}

	//	GET allows for request url's that end in a trailing slash
	//	when getting data from a directory.	 Otherwise it is not found.
	//	This matches IIS's behavior as of 9/28/98.
	//
	if (FTrailingSlash (pwszUrl))
	{
		//	Trailing slash on a non-directory just doesn't work
		//
		sc = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
		goto ret;
	}

	//	Emit the file
	//
	sc = ScGetFile (pmu, const_cast<LPWSTR>(pwszPath), pwszUrl);

ret:

	pmu->SetResponseCode (HscFromHresult(sc), NULL, 0, CSEFromHresult(sc));
}

/*
 *	DAVGet()
 *
 *	Purpose:
 *
 *		Win32 file system implementation of the DAV GET method.	 The
 *		GET method returns a file from the DAV name space and populates
 *		the headers with the info found in the file and its meta data.	The
 *		response created indicates the success of the call and contains
 *		the data from the file.
 *
 *	Parameters:
 *
 *		pmu			[in]  pointer to the method utility object
 */
void
DAVGet (LPMETHUTIL pmu)
{
	GetInt (pmu);
}

/*
 *	DAVHead()
 *
 *	Purpose:
 *
 *		Win32 file system implementation of the DAV HEAD method.  The
 *		HEAD method returns a file from the DAV name space and populates
 *		the headers with the info found in the file and its meta data.
 *		The response created indicates the success of the call and contains
 *		the data from the file.
 *
 *	Parameters:
 *
 *		pmu			[in]  pointer to the method utility object
 */
void
DAVHead (LPMETHUTIL pmu)
{
	//	The HEAD method should never return any body what so ever...
	//
	pmu->SupressBody();

	//	Otherwise, it is just the same as a GET
	//
	GetInt (pmu);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\fsmeta.cpp ===
/*
 *	F S M E T A . C P P
 *
 *	Sources file system implementation of DAV-Meta
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"

//	CFSFind -------------------------------------------------------------------
//
SCODE
CFSFind::ScAddProp (LPCWSTR, LPCWSTR pwszProp, BOOL)
{
	enum { cProps = 8 };

	//	If this is our first time in, we will need to allocate
	//	space for all of the properties we are expecting to get
	//	added over the coarse of this operation.
	//
	if (m_ft == FIND_NONE)
	{
		//	Note that we have started requesting specific properties
		//
		m_ft = FIND_SPECIFIC;
	}
	else if (m_ft != FIND_SPECIFIC)
	{
		//	If we are not finding specfic properties and somebody asked
		//	for one, then bts (by the spec) this should consititute an
		//	error.
		//
		return E_DAV_PROPFIND_TYPE_UNEXPECTED;
	}

	//	See if there is room at the in...
	//
	if (m_cMaxProps == m_cProps)
	{
		UINT cb;

		//	Allocate enough space for the next block of properties
		//
		m_cMaxProps = m_cProps + cProps;
		cb = m_cMaxProps * sizeof(PROPVARIANT);
		m_rgwszProps.realloc (cb);
	}

	//	If this is the getcontenttype property, then we need to remember
	//	its location for use when providing default values...
	//
	if (!wcscmp (pwszProp, gc_wszProp_iana_getcontenttype))
		m_ip_getcontenttype = m_cProps;

	//	Set the property up as one to process.
	//
	Assert (m_cProps < m_cMaxProps);
	m_rgwszProps[m_cProps++] = AppendChainedSz (m_csb, pwszProp);
	return S_OK;
}

SCODE
CFSFind::ScFind (CXMLEmitter& msr,
				 IMethUtil * pmu,
				 CFSProp& fpt)
{
	SCODE scFind;
	SCODE sc = S_OK;

	//	Setup the emitting of the response.  This will construct
	//	an XML node that looks like:
	//
	//	<multistatus>
	//		<response>
	//			<href>http:/www....</>
	//
	//
	CEmitterNode enItem;
	CEmitterNode en;

	sc = msr.ScSetRoot (gc_wszMultiResponse);
	if (FAILED (sc))
		goto ret;

	sc = enItem.ScConstructNode (msr, msr.PxnRoot(), gc_wszResponse);
	if (FAILED (sc))
		goto ret;

	//	If they havent asked for anything, then we should return an
	//	error
	//
	if (m_ft == FIND_NONE)
	{
		//$REVIEW: is it really correct to NOT add the HREF node here? --BeckyAn 6July1999
		return E_DAV_EMPTY_FIND_REQUEST;
	}
	//	If the request is an for a specific set of properties, then
	//	this is pretty easy...
	//
	else if (m_ft == FIND_SPECIFIC)
	{
		Assert (m_cProps);
		Assert (m_rgwszProps);

		sc = ScAddHref (enItem,
						pmu,
						fpt.PwszPath(),
						fpt.FCollection(),
						fpt.PcvrTranslation());
		if (FAILED (sc))
			goto ret;

		//	Get all the properties by name
		//
		scFind = fpt.ScGetSpecificProps (msr,
										 enItem,
										 m_cProps,
										 (LPCWSTR*)m_rgwszProps.get(),
										 m_ip_getcontenttype);
		if (FAILED (scFind))
		{
			(void) ScAddStatus (&enItem, HscFromHresult(scFind));
			goto ret;
		}
	}
	//	If the request is an for all properties or all names, then again,
	//	this is pretty easy...
	//
	else
	{
		Assert ((m_ft == FIND_ALL) || (m_ft == FIND_NAMES));

		//	Get all props or all names
		//
		scFind = fpt.ScGetAllProps (msr, enItem, m_ft == FIND_ALL);
		if (FAILED (scFind) && (scFind != E_DAV_SMB_PROPERTY_ERROR))
		{
			(void) ScAddStatus (&enItem, HscFromHresult(scFind));
			goto ret;
		}
	}

ret:
	return sc;
}


//	IPreloadNamespaces
//
SCODE
CFSFind::ScLoadNamespaces(CXMLEmitter * pmsr)
{
	SCODE	sc = S_OK;
	UINT	iProp;

	//	Load common namespaces
	//
	sc = pmsr->ScPreloadNamespace (gc_wszDav);
	if (FAILED(sc))
		goto ret;
	sc = pmsr->ScPreloadNamespace (gc_wszLexType);
	if (FAILED(sc))
		goto ret;
	sc = pmsr->ScPreloadNamespace (gc_wszXml_V);
	if (FAILED(sc))
		goto ret;

	//	Add more namespaces

	switch (m_ft)
	{
		case FIND_SPECIFIC:
			for (iProp = 0; iProp < m_cProps; iProp++)
			{
				sc = pmsr->ScPreloadNamespace (m_rgwszProps[iProp]);
				if (FAILED(sc))
					goto ret;
			}
			break;

		case FIND_ALL:
		case FIND_NAMES:
			//	Now that we don't have a way to predict what namespaces to
			//	be used.
			//	Per resource level namespaces will be added on <DAV:response>
			//	node later
			break;

		default:
			AssertSz (FALSE, "Unknown propfind type");
			// fall through

		case FIND_NONE:
			sc = E_DAV_EMPTY_FIND_REQUEST;
			goto ret;
	}

ret:
	return sc;
}


//	CFSPatch ------------------------------------------------------------------
//
SCODE
CFSPatch::ScDeleteProp (LPCWSTR, LPCWSTR pwszProp)
{
	enum { cProps = 8 };
	UINT irp;

	//	We cannot delete any reserved properties, so let's
	//	just shortcut this here and now...
	//
	if (CFSProp::FReservedProperty (pwszProp,
									CFSProp::RESERVED_SET,
									&irp))
	{
		//	Take ownership of the bstr as well
		//
		return m_csn.ScAddErrorStatus (HSC_FORBIDDEN, pwszProp);
	}

	//	Make sure there is room at the inn...
	//
	if (m_cMaxDeleteProps == m_cDeleteProps)
	{
		UINT cb;

		//	Allocate enough space for all the properties names
		//	we want to delete.
		//
		m_cMaxDeleteProps = m_cDeleteProps + cProps;
		cb = m_cMaxDeleteProps * sizeof(BSTR);
		m_rgwszDeleteProps.realloc (cb);
	}

	//	Set the property up as one to process.
	//
	Assert (m_cDeleteProps < m_cMaxDeleteProps);
	m_rgwszDeleteProps[m_cDeleteProps++] = AppendChainedSz(m_csb, pwszProp);
	return S_OK;
}

SCODE
CFSPatch::ScSetProp (LPCWSTR,
					 LPCWSTR pwszProp,
					 auto_ref_ptr<CPropContext>& pPropCtx)
{
	enum { cProps = 8 };
	UINT irp;

	//	We cannot set any reserved properties, so let's
	//	just shortcut this here and now...
	//
	if (CFSProp::FReservedProperty (pwszProp,
									CFSProp::RESERVED_SET,
									&irp))
	{
		//	Take ownership of the bstr as well
		//
		return m_csn.ScAddErrorStatus (HSC_FORBIDDEN, pwszProp);
	}

	//	Make sure there is room at the inn...
	//
	if (m_cMaxSetProps == m_cSetProps)
	{
		UINT cb;

		//	Allocate enough space for all the properties we
		//	might want to set
		//
		m_cMaxSetProps = m_cSetProps + cProps;
		cb = m_cMaxSetProps * sizeof(PROPVARIANT);
		m_rgvSetProps.realloc (cb);

		//	Make sure the VARIANT are properly initialized
		//	(only initialize the newly added space).
		//
		ZeroMemory (&m_rgvSetProps[m_cSetProps],
					sizeof(PROPVARIANT) * cProps);

		//	... and their names.
		//
		cb = m_cMaxSetProps * sizeof(LPCWSTR);
		m_rgwszSetProps.realloc (cb);
	}

	//	Set the property up as one to process.
	//
	Assert (m_cSetProps < m_cMaxSetProps);
	m_rgwszSetProps[m_cSetProps] = AppendChainedSz(m_csb, pwszProp);
	pPropCtx = new CFSPropContext(&m_rgvSetProps[m_cSetProps]);
	m_cSetProps++;

	return S_OK;
}

SCODE
CFSPatch::ScPatch (CXMLEmitter& msr,
				   IMethUtil * pmu,
				   CFSProp& fpt)
{
	SCODE sc = S_OK;
	SCODE scSet = S_OK;
	SCODE scDelete = S_OK;

	CEmitterNode enItem;

	//	If there are no properties at all, reserved or otherwise,
	//	we want to fail the call with BAD_REQUEST
	//
	if ((m_cSetProps == 0) &&
		(m_cDeleteProps == 0) &&
		m_csn.FEmpty())
	{
		return E_DAV_EMPTY_PATCH_REQUEST;
	}

	//	Setup the emitting of the response.  This will construct
	//	an XML node that looks like:
	//
	//	<multistatus>
	//		<response>
	//			<href>http:/www....</>
	//
	//
	sc = msr.ScSetRoot (gc_wszMultiResponse);
	if (FAILED (sc))
		goto ret;

	sc = enItem.ScConstructNode (msr, msr.PxnRoot(), gc_wszResponse);
	if (FAILED (sc))
		goto ret;

	sc = ScAddHref (enItem,
					pmu,
					fpt.PwszPath(),
					fpt.FCollection(),
					fpt.PcvrTranslation());
	if (FAILED (sc))
		goto ret;

	//	If the client requested any of the reserved properties, we know
	//	that they will fail and we also know that everything else will fail
	//	as well, so we might as well handle that here...
	//
	if (!m_csn.FEmpty())
	{
		//$	REVIEW:
		//
		//	If the possibly successful properties need to be
		//	marked as a failure as well (HSC_METHOD_FAILURE),
		//	then that would happen here.
		//

		//NT242086: Now that we've got a reponse node, we should
		//added to the response.
		//
		sc = m_csn.ScEmitErrorStatus (enItem);
		goto ret;
	}

	//	If there are no reserved properties we have a pretty good bet
	//	at setting these props...
	//
	scSet = fpt.ScSetProps (m_csn,
							m_cSetProps,
							m_rgwszSetProps.get(),
							m_rgvSetProps);
	if (FAILED (scSet))
	{
		sc = scSet;
		goto ret;
	}

	//	... and deleting these props.
	//
	scDelete = fpt.ScDeleteProps (m_csn,
								  m_cDeleteProps,
								  m_rgwszDeleteProps.get());
	if (FAILED (scDelete))
	{
		sc = scDelete;
		goto ret;
	}

	//	If the possibly successful properties need to be
	//	marked as a failure as well (HSC_METHOD_FAILURE),
	//	then that would happen here.  Either way, if there
	//	is a failure, then we do not want to commit the
	//	changes.
	//
	if ((scSet == S_FALSE) || (scDelete == S_FALSE))
		goto ret;

	//	Commit the changes to the property container
	//
	sc = fpt.ScPersist();
	if (FAILED (sc))
		goto ret;

	//	Emit the response,
	//
	sc = m_csn.ScEmitErrorStatus (enItem);
	if (FAILED(sc))
		goto ret;

ret:
	return sc;
}

CFSPatch::~CFSPatch()
{
	//	Make sure all the propvariants are cleaned up...
	//
	for (UINT i = 0; i < m_cSetProps; i++)
		PropVariantClear (&m_rgvSetProps[i]);
}

SCODE
CFSPatch::ScLoadNamespaces (CXMLEmitter * pmsr)
{
	SCODE	sc = S_OK;
	UINT	iProp;

	//	Load common namespaces
	//
	sc = pmsr->ScPreloadNamespace (gc_wszDav);
	if (FAILED(sc))
		goto ret;

	//	Add namespaces for set props
	//
	for (iProp = 0; iProp < m_cSetProps; iProp++)
	{
		sc = pmsr->ScPreloadNamespace (m_rgwszSetProps[iProp]);
		if (FAILED(sc))
			goto ret;
	}

	//	And delete props
	//
	for (iProp = 0; iProp < m_cDeleteProps; iProp++)
	{
		sc = pmsr->ScPreloadNamespace (m_rgwszDeleteProps[iProp]);
		if (FAILED(sc))
			goto ret;
	}


ret:
	return sc;
}

//	CFSProp -------------------------------------------------------------------
//
SCODE
CFSProp::ScGetPropsInternal (ULONG cProps,
	LPCWSTR* rgwszPropNames,
	PROPVARIANT* rgvar,
	LONG ip_getcontenttype)
{
	SCODE sc = S_OK;

	//	There really should only be one scenario where this could happen
	//	-- and it is a cheap test, so it is worth doing.  The case where
	//	we might see an invalid pbag is when the document extisted, but
	//	there was no existing property set to impose the pbag on.  Other
	//	than that, OLE is always giving us a property bag, regardless of
	//	whether the target drive can support it.
	//
	if (FInvalidPbag())
		return sc;

	//	We better be good to go...
	//
	sc = m_pbag->ReadMultiple (cProps,
							   rgwszPropNames,
							   rgvar,
							   NULL);

	//	If we succeeded, and the getcontenttype property was requested,
	//	we may need to do some special processing
	//
	if (SUCCEEDED (sc) && (ip_getcontenttype != -1))
	{
		//	We want to make sure that getcontenttype gets filled in
		//
		if (rgvar[ip_getcontenttype].vt == VT_EMPTY)
		{
			CStackBuffer<WCHAR> pwszT;
			LPWSTR pwszContentType;
			UINT cch = 40;

			//	No content type was explicitly set in the props.
			//	Fetch the default based on the file extension
			//	(fetching from our metabase-content-type-cache).
			//
			do {

				if (NULL == pwszT.resize(CbSizeWsz(cch)))
				{
					sc = E_OUTOFMEMORY;
					goto ret;
				}

			} while (!m_pmu->FGetContentType (m_pwszURI, pwszT.get(), &cch));

			//	Return the mapped content type
			//
			rgvar[ip_getcontenttype].vt = VT_LPWSTR;

			//	Must use task memory, as it will be freed by PropVariantClear
			//
			pwszContentType = (LPWSTR) CoTaskMemAlloc (cch * sizeof(WCHAR));
			if (NULL == pwszContentType)
			{
				MCDTrace ("Dav: MCD: CFSProp::ScGetPropsInternal() - CoTaskMemAlloc() failed to allocate %d bytes\n", cch * sizeof(WCHAR));

				sc = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
				goto ret;
			}

			rgvar[ip_getcontenttype].pwszVal = pwszContentType;
			memcpy(pwszContentType, pwszT.get(), cch * sizeof(WCHAR));

			//	In the case where this was the only property requested, make
			//	sure that our return code it correct.
			//
			if (cProps == 1)
			{
				Assert (ip_getcontenttype == 0);
				Assert (sc == S_FALSE);
				sc = S_OK;
			}
		}
	}
	else
	{
		//	This is the common path for when we are trying to access
		//	something over an SMB, but the host cannot support the
		//	request (it is not an NT5 NTFS machine).
		//
		if ((sc == STG_E_INVALIDNAME) || !FIsVolumeNTFS())
			sc = E_DAV_SMB_PROPERTY_ERROR;
	}

ret:

	return sc;
}

BOOL
CFSProp::FReservedProperty (LPCWSTR pwszProp, RESERVED_TYPE rt, UINT* prp)
{
	UINT irp;
	CRCWsz wsz(pwszProp);

	//	Search for the property in the list of local
	//	properties.
	//
	Assert (CElems(sc_rp) == sc_crp_set_reserved);
	for (irp = 0; irp < sc_crp_set_reserved; irp++)
	{
		//	If the crc and the strings match...
		//
		if ((wsz.m_dwCRC == sc_rp[irp].dwCRC) &&
			!wcscmp (wsz.m_pwsz, sc_rp[irp].pwsz))
		{
			break;
		}
	}

	//	Setup the return
	//
	Assert (sc_crp_set_reserved != iana_rp_content_type);
	*prp = irp;

	return (irp < static_cast<UINT>((rt == RESERVED_GET) ? sc_crp_get_reserved : sc_crp_set_reserved));
}

SCODE
CFSProp::ScGetReservedProp (CXMLEmitter& xml,
	CEmitterNode& enParent,
	UINT irp,
	BOOL fGetValues)
{
	CEmitterNode en;
	CStackBuffer<WCHAR> wszBuf;
	LARGE_INTEGER li;
	LPCWSTR pwszType = NULL;
	LPWSTR pwsz = NULL;
	SCODE sc = S_OK;
	SYSTEMTIME st;

	Assert (irp <= sc_crp_get_reserved);
	Assert (sc_crp_get_reserved == iana_rp_content_type);
	Assert (CElems(sc_rp) == sc_crp_set_reserved);

	//	Only generate values if the caller wants them
	//
	if (fGetValues)
	{
		//	Switch across the reserved properties generating
		//	a value for the property
		//
		switch (irp)
		{
			case iana_rp_etag:

				if (FETagFromFiletime (m_cri.PftLastModified(), wszBuf.get()))
				{
					pwsz = wszBuf.get();
				}
				break;

			case iana_rp_displayname:

				//	The filename/displayname is simply the name of the file
				//	and we should be able to pick it off from the path with
				//	little and/or no trouble at all.  However, we will use
				//	the URI instead.  We do this such that the displayname
				//	for a vroot is the name of the vroot and not the name of
				//	the physical disk directory.
				//
				pwsz = wcsrchr (m_pwszURI, L'/');
				if (NULL == pwsz)
				{
					//	Arrgh.  If there was no path separator in the filename
					//	I don't know that we can really give a reasonable value
					//	for this file.
					//
					TrapSz ("resource path has no slashes....");
					return S_FALSE;
				}

				//	One more check.  If this is a directory path,
				//	they might have a trailing slash.  If that is what we're
				//	pointing to right now (next char is NULL), back up to the
				//	next delimiter to get the real item name.
				//
				if (L'\0' == pwsz[1])
				{
					//	This better be a collection.  Although it may not
					//	be if the client mis-terminated his/her url
					//
					//	There is a special case that we need to check for
					//	here.  It is possible that the URI was strictly "/"
					//	which means that if we continue this processing, the
					//	displayname and/or the filename would be empty or
					//	non-existant.  In this case only, return "/" as the
					//	display name.
					//
					if (m_pwszURI == pwsz)
					{
						pwsz = L"/";
					}
					else
					{
						//	Now we have to copy the string, to rip off that
						//	trailing slash we found in the step above.
						//	We want to remove the final slash because this is the
						//	displayname, not a URI.
						//
						LPCWSTR pwszEnd;
						UINT cchNew;

						for (pwszEnd = pwsz--; pwsz > m_pwszURI; pwsz--)
							if (L'/' == *pwsz)
								break;

						if (L'/' != *pwsz)
						{
							//	Arrgh.  If there was no path separator in the
							//	filename I don't know that we can really give
							//	a reasonable value for this file.
							//
							TrapSz ("resource path has no slashes (redux)....");
							return S_FALSE;
						}

						//	At this point, the segment defined by (pwsz + 1, pwszEnd)
						//	names the resource.
						//
						cchNew = static_cast<UINT>(pwszEnd - ++pwsz);
						if (NULL == wszBuf.resize(CbSizeWsz(cchNew)))
						{
							sc = E_OUTOFMEMORY;
							goto ret;
						}
						memcpy(wszBuf.get(), pwsz, cchNew * sizeof(WCHAR));
						wszBuf[cchNew] = L'\0';
						pwsz = wszBuf.get();
					}
				}
				else
				{
					//	At this point, the segment defined by (pwsz + 1, '\0'] names
					//	the resource.
					//
					pwsz++;
				}
				break;

			case iana_rp_resourcetype:

				//	Create the element to pass back
				//
				sc = en.ScConstructNode (xml, enParent.Pxn(), sc_rp[irp].pwsz);
				if (FAILED (sc))
					goto ret;

				if (m_cri.FCollection())
				{
					CEmitterNode enSub;
					sc = en.ScAddNode (gc_wszCollection, enSub);
					if (FAILED (sc))
						goto ret;
				}
				goto ret;

			case iana_rp_content_length:

				m_cri.FileSize(li);
				pwszType = gc_wszDavType_Int;

				//$	REVIEW: negative values of _int64 seem to have problems in
				//	the __i64tow() API.  Handle those cases ourselves.
				//
				//  In this instance, we shouldn't have to worry about it because
				//  the content-length *shouldn't* ever be negative.  We'll assert
				//  that this is the case.
				//
				Assert (li.QuadPart >= 0);
				_i64tow (li.QuadPart, wszBuf.get(), 10);
				pwsz = wszBuf.get();
				break;

			case iana_rp_creation_date:

				FileTimeToSystemTime (m_cri.PftCreation(), &st);
				if (FGetDateIso8601FromSystime (&st, wszBuf.get(), wszBuf.size()))
				{
					pwszType = gc_wszDavType_Date_ISO8601;
					pwsz = wszBuf.get();
				}
				break;

			case iana_rp_last_modified:

				FileTimeToSystemTime (m_cri.PftLastModified(), &st);
				if (FGetDateRfc1123FromSystime (&st, wszBuf.get(), wszBuf.size()))
				{
					pwszType = gc_wszDavType_Date_Rfc1123;
					pwsz = wszBuf.get();
				}
				break;

			case iana_rp_supportedlock:
			case iana_rp_lockdiscovery:

				//	Get the prop from the lock cache (and related subsystem calls).
				//
				sc = HrGetLockProp (m_pmu,
									sc_rp[irp].pwsz,
									m_pwszPath,
									m_cri.FCollection() ? RT_COLLECTION : RT_DOCUMENT,
									xml,
									enParent);

				//	Regardless of error or success, we are done here.  If we
				//	succeeded, then the pel has already been constructed and
				//	is ready to pass back.  Otherwise, we just want to report
				//	the error.
				//
				goto ret;

			case iana_rp_ishidden:

				pwszType = gc_wszDavType_Boolean;
				_itow (!!m_cri.FHidden(), wszBuf.get(), 10);
				pwsz = wszBuf.get();
				break;

			case iana_rp_iscollection:

				pwszType = gc_wszDavType_Boolean;
				_itow (!!m_cri.FCollection(), wszBuf.get(), 10);
				pwsz = wszBuf.get();
				break;

			//	Special case: getcontenttype should really be stored, but there
			//	are some cases where the file may live in such a place as there
			//	would be no property stream available to store the value in.
			//
			case iana_rp_content_type:

				//	Get the content-type if it was not stored in the property
				//	stream.
				//
				for (UINT cch = wszBuf.celems();;)
				{
					if (NULL == wszBuf.resize(CbSizeWsz(cch)))
					{
						sc = E_OUTOFMEMORY;
						goto ret;
					}
					if (m_pmu->FGetContentType(m_pwszURI, wszBuf.get(), &cch))
						break;
				}
		}
	}

	//	Create the element to pass back
	//
	sc = en.ScConstructNode (xml, enParent.Pxn(), sc_rp[irp].pwsz, pwsz, pwszType);
	if (FAILED (sc))
		goto ret;

ret:
	return sc;
}

SCODE
CFSProp::ScGetSpecificProps (CXMLEmitter& msr,
	CEmitterNode& enItem,
	ULONG cProps,
	LPCWSTR* rgwszPropNames,
	LONG ip_getcontenttype)
{
	//	safe_propvariant_array ----------------------------------------------------
	//
	//	Used to make sure the array of VARIANT can always be safely freed
	//
	class safe_propvariant_array
	{
		PROPVARIANT * 	m_rgv;
		ULONG		m_cv;

	public:

		safe_propvariant_array (PROPVARIANT* rgv, ULONG cv)
				: m_rgv(rgv),
				  m_cv(cv)
		{
			memset (rgv, 0, sizeof(PROPVARIANT) * cv);
		}

		~safe_propvariant_array ()
		{
			ULONG i;

			for (i = 0; i < m_cv; i++)
				PropVariantClear(&m_rgv[i]);
		}
	};

	SCODE sc = S_OK;
	CStackBuffer<PROPVARIANT> rgv;
	UINT iv;
	CStatusCache csn;
	CEmitterNode enPropStat;
	CEmitterNode enPropOK;


	//	allocate space to hold an array of variants and stuff it into
	//	a safe_variant_array to ensure cleanup
	//
	rgv.resize(sizeof(PROPVARIANT) * cProps);
	safe_propvariant_array sva(rgv.get(), cProps);

	sc = csn.ScInit();
	if (FAILED(sc))
		goto ret;

	//	Get the properties
	//
	sc = ScGetPropsInternal (cProps, rgwszPropNames, rgv.get(), ip_getcontenttype);
	if (FAILED(sc))
	{
		//	When getting properties, it is perfectly OK to ignore SMB errors
		//	and treat the file as if it were hosted on a FAT drive
		//
		if (sc == E_DAV_SMB_PROPERTY_ERROR)
			sc = S_OK;

		//	What this means is that the default not-found processing should
		//	kick in.
		//
	}

	//	Rip through the returned properties, adding to the response as we go
	//
	for (iv = 0; iv < cProps; iv++)
	{
		//	If there is a value to the property, write the variant as
		//	an XML element and add it to the response
		//
		if (rgv[iv].vt != VT_EMPTY)
		{
			if (!enPropOK.Pxn())
			{
				//	Get the insert point for props
				//
				sc = ScGetPropNode (enItem, HSC_OK, enPropStat, enPropOK);
				if (FAILED(sc))
					goto ret;
			}

			//	Write the variant as an XML element
			//
			sc = ScEmitFromVariant (msr,
									enPropOK,
									rgwszPropNames[iv],
									rgv[iv]);
			if (FAILED (sc))
				goto ret;
		}
		else
		{
			UINT irp;

			// Check if it's a reserved property
			//
			if (FReservedProperty (rgwszPropNames[iv], RESERVED_GET, &irp) ||
				(irp == iana_rp_content_type))
			{
				if (!enPropOK.Pxn())
				{
					//	Get the insert point for props
					//
					sc = ScGetPropNode (enItem, HSC_OK, enPropStat, enPropOK);
					if (FAILED(sc))
						goto ret;
				}

				//	If the property was reserved, then extract it from
				//	the property class directly
				//
				sc = ScGetReservedProp (msr, enPropOK, irp);
				if (FAILED (sc))
					goto ret;

				continue;
			}

			//	Now, if we got here, then for CFSProp, the property
			//	must not have existed.
			//
			sc = csn.ScAddErrorStatus (HSC_NOT_FOUND, rgwszPropNames[iv]);
			if (FAILED(sc))
				goto ret;
		}
	}

	//	Need to close the previous prop stat before more status node to be emitted
	//
	if (!csn.FEmpty())
	{
		//	The order is important, inner node must be closed first
		//
		sc = enPropOK.ScDone();
		if (FAILED(sc))
			goto ret;

		sc = enPropStat.ScDone();
		if (FAILED(sc))
			goto ret;

		sc = csn.ScEmitErrorStatus (enItem);
		if (FAILED(sc))
		goto ret;
	}

ret:
	return sc;
}

SCODE
CFSProp::ScGetAllProps (CXMLEmitter& msr,
	CEmitterNode& enItem,
	BOOL fFindValues)
{
	auto_com_ptr<IEnumSTATPROPBAG> penum;
	BOOL fContentType = FALSE;
	BOOL fHrefAdded = FALSE;
	SCODE sc = S_OK;
	UINT irp;
	CEmitterNode enPropStat;
	CEmitterNode enProp;

	//	There really should only be one scenario where this could happen
	//	-- and it is a cheap test, so it is worth doing.  The case where
	//	we might see an invalid pbag is when the document extisted, but
	//	there was no existing property set to impose the pbag on.  Other
	//	than that, OLE is always giving us a property bag, regardless of
	//	whether the target drive can support it.
	//
	if (!FInvalidPbag())
	{
		sc = m_pbag->Enum (NULL, 0, &penum);
		if (FAILED(sc))
		{
			//	AddHref was delayed to be done after local namespace is loaded
			//	but in this case, we know there'll be no local namespaces at all.
			//	so add href now
			//
			(void) ScAddHref (enItem,
							  m_pmu,
							  PwszPath(),
							  FCollection(),
							  PcvrTranslation());
			if ((sc == STG_E_INVALIDNAME) || !FIsVolumeNTFS())
			{
				//	This is the common path for when we are trying to access
				//	something over an SMB, but the host cannot support the
				//	request (it is not an NT5 NTFS machine).  We want to treat
				//	this as if the operation was against a FAT drive
				//
				sc = E_DAV_SMB_PROPERTY_ERROR;
				goto get_reserved;
			}
			goto ret;
		}

		//	We must preload all the potential namespaces in the <response> node,
		//	Note that the namespace for all reserved properties is "DAV:", which
		//	has been added already in CFSFind::ScLoadNamespace()
		//
		do
		{
			safe_statpropbag ssp[PROP_CHUNK_SIZE];
			ULONG csp = 0;
			UINT isp;

			//	Get next chunk of props
			//
			sc = penum->Next (PROP_CHUNK_SIZE, ssp[0].load(), &csp);
			if (FAILED(sc))
				goto ret;

			//	At this point, we either want to call the underlying
			//	property container to retrieve all the property data
			//	or we just want to emit the names.
			//
			for (isp = 0; isp < csp; isp++)
			{
				Assert (ssp[isp].get().lpwstrName);

				sc = msr.ScPreloadLocalNamespace (enItem.Pxn(), ssp[isp].get().lpwstrName);
				if (FAILED(sc))
					goto ret;
			}

		} while (sc != S_FALSE);


		//	Addhref must be done after all the local nmespaces has been emitted
		//
		sc = ScAddHref (enItem,
						m_pmu,
						PwszPath(),
						FCollection(),
						PcvrTranslation());
		if (FAILED (sc))
			goto ret;
		fHrefAdded = TRUE;

		//	Reset the enumerator back to the beginning
		//
		sc = penum->Reset();
		if (FAILED(sc))
			goto ret;

		//	Get the insert point for props
		//
		sc = ScGetPropNode (enItem, HSC_OK, enPropStat, enProp);
		if (FAILED(sc))
			goto ret;

		//	Enumerate the props and emit
		//
		do
		{
			safe_statpropbag ssp[PROP_CHUNK_SIZE];
			safe_propvariant propvar[PROP_CHUNK_SIZE];
			LPWSTR rglpwstr[PROP_CHUNK_SIZE] = {0};
			ULONG csp = 0;
			UINT isp;

			//	Get next chunk of props
			//
			sc = penum->Next (PROP_CHUNK_SIZE, ssp[0].load(), &csp);
			if (FAILED(sc))
				goto ret;

			//	At this point, we either want to call the underlying
			//	property container to retrieve all the property data
			//	or we just want to emit the names.
			//
			for (isp = 0; isp < csp; isp++)
			{
				Assert (ssp[isp].get().lpwstrName);

				//	We need to track whether or not the getcontenttype
				//	property was actually stored or not.  If it wasn't,
				//	then, we will want to default it at a later time.
				//
				if (!fContentType)
				{
					if (!wcscmp (ssp[isp].get().lpwstrName,
								 gc_wszProp_iana_getcontenttype))
					{
						//	Note that content-type is included
						//
						fContentType = TRUE;
					}
				}

				//	If we are just asking for names, then add the
				//	name to the list now...
				//
				if (!fFindValues)
				{
					CEmitterNode en;

					//	Add the result to the response
					//
					sc = enProp.ScAddNode (ssp[isp].get().lpwstrName, en);
					if (FAILED (sc))
						goto ret;
				}
				else
					rglpwstr[isp] = ssp[isp].get().lpwstrName;
			}

			//	If we are just asking about names, then we really
			//	are done with this group of properties, otherwise
			//	we need to generate the values and emit them.
			//
			if (!fFindValues)
				continue;

			//	Read properties in chunk
			//
			if (csp)
			{
				sc = m_pbag->ReadMultiple (csp,
										   rglpwstr,
										   propvar[0].addressof(),
										   NULL);
				if (FAILED (sc))
					goto ret;
			}

			//	Emit properties
			//
			for (isp = 0; isp < csp; isp++)
			{
				//	Contstruct the pel from the variant
				//
				sc = ScEmitFromVariant (msr,
										enProp,
										ssp[isp].get().lpwstrName,
										const_cast<PROPVARIANT&>(propvar[isp].get()));
				if (FAILED (sc))
					goto ret;
			}

		} while (sc != S_FALSE);
	}

get_reserved:

	//	Render all the reserved properties, this relies on the fact that
	//	the first non-GET reserved property is "DAV:getcontenttype".
	//
	Assert (iana_rp_content_type == sc_crp_get_reserved);

	if (!fHrefAdded)
	{
		//	Need to build the HREF node because it wasn't built above.
		//	This can happen when we don't have a pbag (like on FAT16).
		//
		sc = ScAddHref (enItem,
						m_pmu,
						PwszPath(),
						FCollection(),
						PcvrTranslation());
		if (FAILED (sc))
			goto ret;
	}

	if (!enProp.Pxn())
	{
		//	Get the insert point for props
		//
		sc = ScGetPropNode (enItem, HSC_OK, enPropStat, enProp);
		if (FAILED(sc))
			goto ret;

	}

	for (irp = 0; irp <= sc_crp_get_reserved; irp++)
	{
		//	If the content-type has already been processed, then
		//	don't do it here.
		//
		if ((irp == sc_crp_get_reserved) && fContentType)
			break;

		//	Construct the pel from the reserved property
		//
		sc = ScGetReservedProp (msr, enProp, irp, fFindValues);
		if (FAILED (sc))
			goto ret;
	}

	//	We are done with all the local namespaces
	//
	msr.DoneWithLocalNamespace();

ret:
	return sc;
}

SCODE
CFSProp::ScSetProps (CStatusCache& csn,
					 ULONG cProps,
					 LPCWSTR* rgwszProps,
					 PROPVARIANT* rgvProps)
{
	UINT ip;
	SCODE sc = S_OK;
	ULONG hsc;

	//	Zero props is a no-op
	//
	if (!cProps)
		return S_OK;

	Assert (!FInvalidPbag());
	sc = m_pbag->WriteMultiple (cProps, rgwszProps, rgvProps);
	if (FAILED(sc))
	{
		//	This is the common path for when we are trying to access
		//	something over an SMB, but the host cannot support the
		//	request (it is not an NT5 NTFS machine).
		//
		if ((sc == STG_E_INVALIDNAME) || !FIsVolumeNTFS())
			return E_DAV_SMB_PROPERTY_ERROR;
	}

	//	we don't know exactly which prop failed,
	//	return same error for all props
	//
	hsc = HscFromHresult(sc);
	for (ip = 0; ip < cProps; ip++)
	{
		sc = csn.ScAddErrorStatus (hsc, rgwszProps[ip]);
		if (FAILED(sc))
			goto ret;
	}

ret:
	return FAILED(sc) ? S_FALSE : S_OK;
}

SCODE
CFSProp::ScDeleteProps (CStatusCache& csn,
						ULONG cProps,
						LPCWSTR* rgwszProps)
{
	UINT ip;
	SCODE sc = S_OK;
	ULONG hsc;

	//	Zero props is a no-op
	//
	if (!cProps)
		return S_OK;

	Assert (!FInvalidPbag());
	sc = m_pbag->DeleteMultiple (cProps, rgwszProps, 0);
	if (FAILED(sc))
	{
		//	This is the common path for when we are trying to access
		//	something over an SMB, but the host cannot support the
		//	request (it is not an NT5 NTFS machine).
		//
		if ((sc == STG_E_INVALIDNAME) || !FIsVolumeNTFS())
			return E_DAV_SMB_PROPERTY_ERROR;
	}

	//	we don't know exactly which prop failed,
	//	return same error for all props
	//
	hsc = HscFromHresult(sc);
	for (ip = 0; ip < cProps; ip++)
	{
		sc = csn.ScAddErrorStatus (hsc, rgwszProps[ip]);
		if (FAILED(sc))
			goto ret;
	}

ret:
	return FAILED(sc) ? S_FALSE : S_OK;
}

SCODE
CFSProp::ScPersist ()
{
	//	We are not transacted now, just
	//
	return S_OK;
}

//	Content properties --------------------------------------------------------
//
SCODE
ScSetContentProperties (IMethUtil * pmu, LPCWSTR pwszPath, HANDLE hFile)
{
	LPCWSTR pwszContentType;
	LPCWSTR pwszContentLanguage;
	LPCWSTR pwszContentEncoding;

	SCODE sc = S_OK;

	//	Figure out which content properties we have
	//
	pwszContentType = pmu->LpwszGetRequestHeader (gc_szContent_Type, FALSE);
	pwszContentLanguage = pmu->LpwszGetRequestHeader (gc_szContent_Language, FALSE);
	pwszContentEncoding = pmu->LpwszGetRequestHeader (gc_szContent_Encoding, FALSE);

	//	Content-Type is special -- it is always set in the metabase.
	//	It should be set *before* setting any properties in the property bag
	//	since it's OK for the property bag stuff to fail.
	//
	if (NULL != pwszContentType)
	{
		sc = pmu->ScSetContentType (pmu->LpwszRequestUrl(), pwszContentType);
		if (FAILED (sc))
			goto ret;
	}

	//	Set any content properties we have in the property bag
	//
	if (pwszContentLanguage || pwszContentEncoding)
	{
		auto_com_ptr<IPropertyBagEx> pbe;
		CStackBuffer<WCHAR> pwsz;

		//	Try to open the property bag.  If this fails because we're not
		//	on an NTFS filesystem, that's OK.  We just won't set the properties
		//	there.
		//
		//	We need to open propertybag by handle as it the main stream might
		//	be locked.
		//
		sc = ScGetPropertyBag (pwszPath,
							   STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
							   &pbe,
							   FALSE,	// not a collection
							   hFile);
		if (FAILED(sc))
		{
			//$	REVIEW:
			//
			//	We did our best here.  For DocFiles this will fail because
			//	of how we have to open the files.  What this means is that we
			//	could potentially lose the content-encoding and content-language
			//	which would put us on par with IIS (they don't store these either).
			//
			sc = S_OK;
			goto ret;
		}

		CResourceInfo cri;
		CFSProp xpt(pmu,
					pbe,
					pmu->LpwszRequestUrl(),
					pwszPath,
					NULL,
					cri);

		//	Content-Type
		//
		if (NULL != pwszContentType)
		{
			sc = xpt.ScSetStringProp (sc_rp[iana_rp_content_type].pwsz, pwszContentType);
			if (FAILED (sc))
				goto ret;
		}

		//	Content-Language
		//
		if (NULL != pwszContentLanguage)
		{
			sc = xpt.ScSetStringProp (sc_rp[iana_rp_content_language].pwsz, pwszContentLanguage);
			if (FAILED (sc))
				goto ret;
		}

		//	Content-Encoding
		//
		if (NULL != pwszContentEncoding)
		{
			sc = xpt.ScSetStringProp (sc_rp[iana_rp_content_encoding].pwsz, pwszContentEncoding);
			if (FAILED (sc))
				goto ret;
		}

		//	Persist the changes
		//
		sc = xpt.ScPersist();
		if (FAILED(sc))
			goto ret;
	}

ret:

	//	It is perfectly OK to ignore SMB errors when setting content properties.
	//
	if (sc == E_DAV_SMB_PROPERTY_ERROR)
		sc = S_OK;

	return sc;
}


//	ScFindFileProps -----------------------------------------------------------
//
SCODE
ScFindFileProps (IMethUtil* pmu,
				 CFSFind& cfc,
				 CXMLEmitter& msr,
				 LPCWSTR pwszUri,
				 LPCWSTR pwszPath,
				 CVRoot* pcvrTranslation,
				 CResourceInfo& cri,
				 BOOL fEmbedErrorsInResponse)
{
	auto_com_ptr<IPropertyBagEx> pbag;
	CFSProp fsp(pmu, pbag, pwszUri, pwszPath, pcvrTranslation, cri);
	SCODE sc = S_OK;

	//	Check access permission
	//
	sc = pmu->ScCheckMoveCopyDeleteAccess (pwszUri,
										   pcvrTranslation,
										   cri.FCollection(),
										   FALSE, // do not check against scriptmaps
										   MD_ACCESS_READ);
	if (FAILED (sc))
	{
		//	No permission to read, we certainly do not want
		//	to try and traverse down into the directory (if
		//	it was one), we do this by returning S_FALSE.
		//
		if (fEmbedErrorsInResponse)
		{
			sc = cfc.ScErrorAllProps (msr,
									  pmu,
									  pwszPath,
									  cri.FCollection(),
									  pcvrTranslation,
									  sc);
			if (FAILED (sc))
				goto ret;

			//	Pass back S_FALSE so that no further traversal of
			//	this resource is performed
			//
			sc = S_FALSE;
		}
		if (S_OK != sc)
			goto ret;
	}

	//	Don't get pbag for remote files. This would cause the files to
	//	be recalled, etc.
	//
	if (!cri.FRemote())
	{
		//	Get the IPropertyBagEx interface
		//
		//	Before call into this function, we've checked we have read access to
		//	this file. so we should always be able to read the proerties however,
		//	if the file is write locked, there may be some problems from the OLE
		//	properties code.
		//
		sc = ScGetPropertyBag (pwszPath,
							   STGM_READ | STGM_SHARE_DENY_WRITE,
							   &pbag,
							   cri.FCollection());
		if (FAILED (sc))
		{
			//	We need to check the volume of the file we are trying
			//	to read.
			//
			if (VOLTYPE_NTFS == VolumeType (pwszPath, pmu->HitUser()))
			{
				//	Report the errors for this file and come on back...
				//
				if (fEmbedErrorsInResponse)
				{
					sc = cfc.ScErrorAllProps (msr,
											  pmu,
											  pwszPath,
											  cri.FCollection(),
											  pcvrTranslation,
											  sc);
				}
				goto ret;
			}
		}
	}

	//	Find the properties
	//
	sc = cfc.ScFind (msr, pmu, fsp);
	if (FAILED (sc))
		goto ret;

ret:

	return sc;
}

SCODE
ScFindFilePropsDeep (IMethUtil* pmu,
					 CFSFind& cfc,
					 CXMLEmitter& msr,
					 LPCWSTR pwszUri,
					 LPCWSTR pwszPath,
					 CVRoot* pcvrTranslation,
					 LONG lDepth)
{
	BOOL fSubDirectoryAccess = TRUE;
	SCODE sc = S_OK;

	//	Query subdirs when do deep query
	//
	Assert ((lDepth == DEPTH_ONE) ||
			(lDepth == DEPTH_ONE_NOROOT) ||
			(lDepth == DEPTH_INFINITY));

	CDirIter di(pwszUri,
				pwszPath,
				NULL,	// no destination url
				NULL,	// no destination path
				NULL,	// no destination translation
				lDepth == DEPTH_INFINITY);

	while (S_OK == (sc = di.ScGetNext (fSubDirectoryAccess)))
	{
		CResourceInfo cri;

		//	If we found another directory, then iterate on it
		//
		fSubDirectoryAccess = FALSE;
		if (di.FDirectory())
		{
			auto_ref_ptr<CVRoot> arp;

			//	Skip the special and/or hidden directories
			//
			if (di.FSpecial())
				continue;

			//	If we happen to traverse into a directory
			//	that happens to be a vroot (as identified
			//	by url), then there is another entry in
			//	the list of child vroots that will refer
			//	to this directory.  Let that processing
			//	handle this directory instead of the
			//	doing it here.
			//
			//	This means that the file hierarchy is not
			//	strictly preserved, but I think that this
			//	is OK.
			//
			if (pmu->FFindVRootFromUrl (di.PwszUri(), arp))
				continue;

			//	Check the directory browsing bit and see
			//	if it is enabled.  And only progess down
			//	if it is set.
			//
			{
				auto_ref_ptr<IMDData> pMDData;
				if (SUCCEEDED(pmu->HrMDGetData (di.PwszUri(), pMDData.load())) &&
					(pMDData->DwDirBrowsing() & MD_DIRBROW_ENABLED))
				{
					//	Prepare to go into the subdir
					//
					fSubDirectoryAccess = TRUE;
				}
			}
		}

		//	Find the properties for the resource
		//
		*cri.PfdLoad() = di.FindData();
		sc = ScFindFileProps (pmu,
							  cfc,
							  msr,
							  di.PwszUri(),
							  di.PwszSource(),
							  pcvrTranslation,
							  cri,
							  TRUE /*fEmbedErrorsInResponse*/);
		if (FAILED (sc))
			goto ret;

		//	S_FALSE is a special return code that
		//	means we did not have access to read the
		//	resource...
		//
		if (sc == S_FALSE)
		{
			//	... and since we really didn't have access,
			//	we don't want to delve into the children of
			//	the resource.
			//
			fSubDirectoryAccess = FALSE;
		}
	}

ret:

	return sc;
}

//	ScCopyProps ---------------------------------------------------------------
//
/*
 *	ScCopyProps()
 *
 *	Purpose:
 *
 *		Copies the properties from one resource to another.  This is
 *		really only useful for copying full directories.  Standard file
 *		copies do the dirty work for us, but for directories, we need to
 *		do it ourselves.
 *		If we don't find any propstream on the source, we DELETE
 *		any propstream on the destination.
 */
SCODE
ScCopyProps (IMethUtil* pmu, LPCWSTR pwszSrc, LPCWSTR pwszDst,
			BOOL fCollection, HANDLE hSource, HANDLE hDest)
{
	enum { CHUNK_SIZE = 16 };

	auto_com_ptr<IPropertyBagEx> pbeSrc;
	auto_com_ptr<IPropertyBagEx> pbeDst;
	auto_com_ptr<IEnumSTATPROPBAG> penumSrc;
	auto_com_ptr<IEnumSTATPROPBAG> penumDst;

	SCODE sc;
	SCODE scEnum;
	ULONG cProp;

	MCDTrace ("Dav: MCD: copying props manually: %ws -> %ws\n", pwszSrc, pwszDst);

	//	Get the IPropertyBagEx on the source
	//
	sc = ScGetPropertyBag (pwszSrc,
						   STGM_READ | STGM_SHARE_DENY_WRITE,
						   &pbeSrc,
						   fCollection,
						   hSource);
	if (sc != S_OK)
		goto ret;

	MCDTrace ("Dav: MCD: opened source property bag: %ws\n", pwszSrc);

	//	Get the IPropertyBagEx on the destination
	//
	sc = ScGetPropertyBag (pwszDst,
						   STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
						   &pbeDst,
						   fCollection,
						   hDest);
	if (FAILED(sc))
		goto ret;

	MCDTrace ("Dav: MCD: opened destination property bag: %ws\n", pwszDst);

	//	Get the IEnumSTATPROPBAG interface on source
	//
	sc = pbeSrc->Enum (NULL, 0, &penumSrc);
	if (FAILED(sc))
		goto ret;

	//	Get the IEnumSTATPROPBAG interface on destination
	//
	sc = pbeDst->Enum (NULL, 0, &penumDst);
	if (FAILED(sc))
		goto ret;

	//	Delete all props from destination if there's any
	//$ COME BACK
	//$ Instead of delete props one by one, we can just delete the
	//	prop stream.
	//
	for (;;)
	{
		safe_statpropbag ssp[CHUNK_SIZE];
		safe_propvariant propvar[CHUNK_SIZE];
		ULONG csp = 0;

		//	Get next chunk of props
		//
		scEnum = penumDst->Next(CHUNK_SIZE,
								reinterpret_cast<STATPROPBAG *>(&ssp),
								&csp);
		if (FAILED(scEnum))
		{
			sc = scEnum;
			goto ret;
		}

		MCDTrace ("Dav: MCD: copying %ld props\n", csp);

		// 	Delete one by one
		//
		for (cProp = 0; cProp < csp; cProp++)
		{
			Assert (ssp[cProp].get().lpwstrName);

			//	Write to the destination
			//
			LPCWSTR pwsz = ssp[cProp].get().lpwstrName;
			sc = pbeDst->DeleteMultiple (1, &pwsz, 0);
			if (FAILED(sc))
				goto ret;
		}

		if (scEnum == S_FALSE)
			break;
	}

	//	Enumerate the props and emit
	//
	for (;;)
	{
		safe_statpropbag ssp[CHUNK_SIZE];
		safe_propvariant propvar[CHUNK_SIZE];
		LPWSTR rglpwstr[CHUNK_SIZE] = {0};
		ULONG csp = 0;

		//	Get next chunk of props
		//
		scEnum = penumSrc->Next (CHUNK_SIZE,
								 reinterpret_cast<STATPROPBAG *>(&ssp),
								 &csp);
		if (FAILED(scEnum))
		{
			sc = scEnum;
			goto ret;
		}

		// 	Prepare to call read multiple props
		//
		for (cProp=0; cProp<csp; cProp++)
		{
			Assert (ssp[cProp].get().lpwstrName);
			rglpwstr[cProp] = ssp[cProp].get().lpwstrName;
		}

		if (csp)
		{
			//	Read properties in chunk from source
			//
			sc = pbeSrc->ReadMultiple (csp, rglpwstr, &propvar[0], NULL);
			if (FAILED(sc))
				goto ret;

			//	Write to the destination
			//
			sc = pbeDst->WriteMultiple (csp, rglpwstr, propvar[0].addressof());
			if (FAILED(sc))
				goto ret;
		}

		if (scEnum == S_FALSE)
			break;
	}


ret:

	//	Copying properties is a harmless failure that
	//	we should feel free to ignore if we are not on
	//	an NFTS volume
	//
	if (FAILED(sc))
	{
		if ((sc == STG_E_INVALIDNAME) ||
			VOLTYPE_NTFS != VolumeType (pwszSrc, pmu->HitUser()) ||
			VOLTYPE_NTFS != VolumeType (pwszDst, pmu->HitUser()))
		{
			//	This is the common path for when we are trying to access
			//	something over an SMB, but the host cannot support the
			//	request (it is not an NT5 NTFS machine).
			//
			sc = S_OK;
		}
	}
	return sc;
}

//	OLE 32 IPropertyBagEx Access ----------------------------------------------
//
//	StgOpenStorageOnHandle() and StgCreateStorageOnHandle() are implemented
//	in OLE32.DLL but not exported.  We must load the library and get the proc
//	instances ourselves.  We wrap the calls to these functions with this small
//	wrapper such that we can catch when the API changes.
//
STDAPI
StgOpenStorageOnHandle (
	IN HANDLE hStream,
    IN DWORD grfMode,
    IN void *reserved1,
    IN void *reserved2,
    IN REFIID riid,
    OUT void **ppObjectOpen )
{
	Assert (g_pfnStgOpenStorageOnHandle);

	//	Yes, we've asserted.
	//	However, if it does happen, we don't want to fail and we can
	//	just treat this like we are on a FAT. (i.e. no property support)
	//
	if (!g_pfnStgOpenStorageOnHandle)
		return E_DAV_SMB_PROPERTY_ERROR;

	return (*g_pfnStgOpenStorageOnHandle) (hStream,
										   grfMode,
										   reserved1,
										   reserved2,
										   riid,
										   ppObjectOpen);
}


//	ScGetPropertyBag() --------------------------------------------------------
//
//	Helper function used to get IPropertyBagEx interface.  The important
//	thing to know about this function is that there are three interesting
//	return values:
//
//		S_OK means everything was OK, and there should be a
//		propertybag associated with the file in the out param.
//
//		S_FALSE means that the file did not exist.  There will
//		not be an associated property bag in that scenario.
//
//		FAILED(sc) means that there was a failure of some sort,
//		not all of which are fatal.  In many cases, we will simply
//		treat the file as if it was hosted on a FAT file system.
//
SCODE
ScGetPropertyBag (LPCWSTR pwszPath,
	DWORD dwAccessDesired,
	IPropertyBagEx** ppbe,
	BOOL fCollection,
	HANDLE hLockFile)
{
	SCODE sc = S_OK;
	auto_handle<HANDLE> hAlt;

	//	READ!!
	//
	//	The storage of property bag is different between docfile and flat file,
	//	In a flat file, the property bag is stored in an alternative file stream,
	//	(currently, ":Docf_\005Bagaaqy23kudbhchAaq5u2chNd"), in a docfile, the
	//	property bag is stored as a substream under the root storage.
	//
	//	We should not be concerned with where the pbag is stored.  The API with
	//	which we implement our IPropertyBagEx access is designed to have the
	//	behavior of...
	//
	//		We pass in a handle to the file that we want to get a property bag
	//		on.  If the file is a docfile, then OLE32 will dup the file handle
	//		and impose a IPropertyBagEx on the appropriate substorage.  If the
	//		file is a flat file -- directories included -- then OLE32 opens up
	//		a handle on the alternate file stream relative to the handle given
	//		in the call.
	//
	//	These are the only two combinations allowed, and we rely on this in the
	//	following flag checks.
	//
	Assert ((dwAccessDesired == (STGM_READWRITE | STGM_SHARE_EXCLUSIVE)) ||
			(dwAccessDesired == (STGM_READ | STGM_SHARE_DENY_WRITE)));

	if (hLockFile == INVALID_HANDLE_VALUE)
	{
		ULONG dwShare = 0;
		ULONG dwAccess;
		ULONG dwOpen;
		ULONG dwFile;

		//$	REVIEW: Directories are special critters and we need to
		//	open the directory with special access as not to conflict
		//	with IIS and/or ASP and their directory change notification
		//	stuff
		//
		if (fCollection)
		{
			dwAccess = 1;	// FILE_LIST_DIRECTORY
			dwShare = FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE;
			dwOpen = OPEN_EXISTING;

			//	The FILE_FLAG_BACKUP_SEMANTICS is used to open a directory handle
			//
			dwFile = FILE_FLAG_BACKUP_SEMANTICS|FILE_FLAG_OVERLAPPED;
		}
		else
		{
			//	Adjust access/open mode based on desired operation
			//
			dwAccess = GENERIC_READ;
			dwFile = FILE_ATTRIBUTE_NORMAL;
			if (dwAccessDesired & STGM_READWRITE)
			{
				dwAccess |= GENERIC_WRITE;
				dwOpen = OPEN_ALWAYS;
			}
			else
				dwOpen = OPEN_EXISTING;

			//	Adjust the sharing modes as well
			//
			if (dwAccessDesired & STGM_SHARE_DENY_WRITE)
				dwShare = FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE;
		}
		hAlt = DavCreateFile (pwszPath,
							  dwAccess,
							  dwShare,
							  NULL,
							  dwOpen,
							  dwFile,
							  NULL);
		if (INVALID_HANDLE_VALUE == hAlt.get())
		{
			DWORD dwErr = GetLastError();

			//	When open the property bag for read (PROPFIND), ERROR_FILE/PATH_NOT_FOUND
			//	could be returned if the file does not exists.
			//
			//	When open the property bag for write (PROPPATCH), ERROR_FILE/PATH_NOT_FOUND
			//	Could still be returned if the parent of the path does not exists
			//	(Such as c:\x\y\z and \x\y does not exist).
			//
			//	We need to differenciate the above two cases, when reading a file,
			//	it's not a fatal error as you could still try to read reserved
			//	properties, when write, we should treat this as a fatal error.
			//
			if ((dwErr == ERROR_FILE_NOT_FOUND) || (dwErr == ERROR_PATH_NOT_FOUND))
			{
				//	It's not a fatal error when read
				//
				if (dwAccessDesired == (STGM_READ|STGM_SHARE_DENY_WRITE))
					sc = S_FALSE;
				else
				{
					//	This is consistent with Mkcol, it will be mapped to 409
					//
					Assert (dwAccessDesired == (STGM_READWRITE|STGM_SHARE_EXCLUSIVE));
					sc = E_DAV_NONEXISTING_PARENT;
				}
			}
			else
				sc = HRESULT_FROM_WIN32 (dwErr);

			goto ret;
		}

		//	Setup the handle to use
		//
		hLockFile = hAlt.get();
	}

	//	Try to open the propertybag.
	//
	Assert (hLockFile != 0);
	Assert (hLockFile != INVALID_HANDLE_VALUE);
	sc = StgOpenStorageOnHandle (hLockFile,
								 dwAccessDesired,
								 NULL,
								 NULL,
								 IID_IPropertyBagEx,
								 reinterpret_cast<LPVOID *>(ppbe));
	if (FAILED (sc))
	{
		goto ret;
	}

	//$	WARNING
	//
	//	Argh!  The current implementation of OLE32 returns a non-failure
	//	with a NULL property bag!
	//
	if (*ppbe == NULL)
	{
		DebugTrace ("WARNING! OLE32 returned success w/NULL object!\n");
		sc = E_DAV_SMB_PROPERTY_ERROR;
	}

ret:
	return sc;
}

//	DAV-Properties Implementation ---------------------------------------------------
//

//	CPropFindRequest ----------------------------------------------------------------
//
class CPropFindRequest :
	public CMTRefCounted,
	private IAsyncIStreamObserver
{
	//
	//	Reference to the CMethUtil
	//
	auto_ref_ptr<CMethUtil> m_pmu;

	//
	//	Translated URI path
	//
	LPCWSTR m_pwszPath;

	//	Resource info
	//
	CResourceInfo m_cri;

	//	Depth
	//
	LONG m_lDepth;

	//	Contexts
	//
	CFSFind m_cfc;
	auto_ref_ptr<CNFFind> m_pcpf;

	//	Request body as an IStream.  This stream is async -- it can
	//	return E_PENDING from Read() calls.
	//
	auto_ref_ptr<IStream> m_pstmRequest;

	//	The XML parser used to parse the request body using
	//	the node factory above.
	//
	auto_ref_ptr<IXMLParser> m_pxprs;

	//	IAsyncIStreamObserver
	//
	VOID AsyncIOComplete();

	//	State functions
	//
	VOID ParseBody();
	VOID DoFind();
	VOID SendResponse( SCODE sc );

	//	NOT IMPLEMENTED
	//
	CPropFindRequest (const CPropFindRequest&);
	CPropFindRequest& operator= (const CPropFindRequest&);

public:
	//	CREATORS
	//
	CPropFindRequest(LPMETHUTIL pmu) :
		m_pmu(pmu),
		m_pwszPath(m_pmu->LpwszPathTranslated()),
		m_lDepth(DEPTH_INFINITY)
	{
	}

	//	MANIPULATORS
	//
	VOID Execute();
};

VOID
CPropFindRequest::Execute()
{
	auto_ref_handle hf;
	LPCWSTR pwsz;
	SCODE sc = S_OK;

	//
	//	First off, tell the pmu that we want to defer the response.
	//	Even if we send it synchronously (i.e. due to an error in
	//	this function), we still want to use the same mechanism that
	//	we would use for async.
	//
	m_pmu->DeferResponse();

	//	Do ISAPI application and IIS access bits checking
	//
	sc = m_pmu->ScIISCheck (m_pmu->LpwszRequestUrl(), MD_ACCESS_READ);
	if (FAILED(sc))
	{
		//	Either the request has been forwarded, or some bad error occurred.
		//	In either case, quit here and map the error!
		//
		SendResponse(sc);
		return;
	}

	//	For PropFind, content-length is required
	//
	//
	if (NULL == m_pmu->LpwszGetRequestHeader (gc_szContent_Length, FALSE))
	{
		pwsz = m_pmu->LpwszGetRequestHeader (gc_szTransfer_Encoding, FALSE);
		if (!pwsz || _wcsicmp (pwsz, gc_wszChunked))
		{
			DavTrace ("Dav: PUT: missing content-length in request\n");
			SendResponse(E_DAV_MISSING_LENGTH);
			return;
		}
	}

	//	Ensure the resource exists
	//
	sc = m_cri.ScGetResourceInfo (m_pwszPath);
	if (FAILED (sc))
	{
		SendResponse(sc);
		return;
	}

	//	Depth header only applies on directories
	//
	if (m_cri.FCollection())
	{
		//	Check the depth header only on collections
		//
		if (!FGetDepth (m_pmu.get(), &m_lDepth))
		{
			//	If Depth header is wrong, fail the operation
			//
			SendResponse(E_INVALIDARG);
			return;
		}
	}

	//	This method is gated by If-xxx headers
	//
	sc = ScCheckIfHeaders (m_pmu.get(), m_cri.PftLastModified(), FALSE);
	if (FAILED (sc))
	{
		SendResponse(sc);
		return;
	}

	//	Ensure the URI and resource match
	//
	(void) ScCheckForLocationCorrectness (m_pmu.get(), m_cri, NO_REDIRECT);

	//	Check state headers here.
	//
	//	For PROPFIND, when we check the state headers,
	//	we want to treat the request as if it were a
	//	GET-type request.
	//
	sc = HrCheckStateHeaders (m_pmu.get(), m_pwszPath, TRUE);
	if (FAILED (sc))
	{
		DebugTrace ("DavFS: If-State checking failed.\n");
		SendResponse(sc);
		return;
	}

	//	Handle locktokens and check for locks on this resource.
	//	Our locks don't lock the "secondary file stream" where we keep
	//	the properties, so we have to check manually before we do anything else.
	//$REVIEW: Joels, will this change when we switch to NT5 properties?
	//$REVIEW: If so, we need to change this code!
	//
	//	If we have a locktoken, try to get the lock handle from the cache.
	//	If this fails, fall through and do the normal processing.
	//
	pwsz = m_pmu->LpwszGetRequestHeader (gc_szLockToken, TRUE);
	if (!pwsz || !FGetLockHandle (m_pmu.get(), m_pwszPath, GENERIC_READ, pwsz, &hf))
	{
		//	Manually check for locks on this resource.
		//	(see if someone ELSE has it locked...)
		//	If a read lock exists, tell the caller that it's locked.
		//
		if (FLockViolation (m_pmu.get(), ERROR_SHARING_VIOLATION, m_pwszPath, GENERIC_READ))
		{
			SendResponse(E_DAV_LOCKED);
			return;
		}
	}

	//	If there was no request body, we want to get all props
	//
	if (!m_pmu->FExistsRequestBody())
	{
		sc = m_cfc.ScGetAllProps (m_pwszPath);
		if (FAILED (sc))
		{
			SendResponse(sc);
			return;
		}

		DoFind();
		return;
	}
	else
	{
		//	If there's a body, there must be a content-type header
		//	and the value must be text/xml
		//
		sc = ScIsContentTypeXML (m_pmu.get());
		if (FAILED(sc))
		{
			DebugTrace ("Dav: PROPFIND specific fails without specifying a text/xml contenttype\n");
			SendResponse(sc);
			return;
		}
	}

	//	Instantiate the XML parser
	//
	m_pcpf.take_ownership(new CNFFind(m_cfc));
	m_pstmRequest.take_ownership(m_pmu->GetRequestBodyIStream(*this));

	sc = ScNewXMLParser( m_pcpf.get(),
						 m_pstmRequest.get(),
						 m_pxprs.load() );

	if (FAILED(sc))
	{
		DebugTrace( "CPropFindRequest::Execute() - ScNewXMLParser() failed (0x%08lX)\n", sc );
		SendResponse(sc);
		return;
	}

	//	Parse the body
	//
	ParseBody();
}

VOID
CPropFindRequest::ParseBody()
{
	SCODE sc;

	Assert( m_pxprs.get() );
	Assert( m_pcpf.get() );
	Assert( m_pstmRequest.get() );

	//	Parse XML from the request body stream.
	//
	//	Add a ref for the following async operation.
	//	Use auto_ref_ptr rather than AddRef() for exception safety.
	//
	auto_ref_ptr<CPropFindRequest> pRef(this);

	sc = ScParseXML (m_pxprs.get(), m_pcpf.get());

	if ( SUCCEEDED(sc) )
	{
		Assert( S_OK == sc || S_FALSE == sc );

		DoFind();
	}
	else if ( E_PENDING == sc )
	{
		//
		//	The operation is pending -- AsyncIOComplete() will take ownership
		//	ownership of the reference when it is called.
		//
		pRef.relinquish();
	}
	else
	{
		DebugTrace( "CPropFindRequest::ParseBody() - ScParseXML() failed (0x%08lX)\n", sc );
		SendResponse(sc);
	}
}

VOID
CPropFindRequest::AsyncIOComplete()
{
	//	Take ownership of the reference added for the async operation.
	//
	auto_ref_ptr<CPropFindRequest> pRef;
	pRef.take_ownership(this);

	ParseBody();
}

VOID
CPropFindRequest::DoFind()
{
	LPCWSTR pwszUrl = m_pmu->LpwszRequestUrl();
	SCODE sc;

	//	At this point, make sure that they support text/xml
	//
	sc = ScIsAcceptable (m_pmu.get(), gc_wszText_XML);
	if (FAILED (sc))
	{
		SendResponse(sc);
		return;
	}

	//	All header must be emitted before chunked XML emitting starts
	//
	m_pmu->SetResponseHeader (gc_szContent_Type, gc_szText_XML);

	//	Set the response code and go
	//
	m_pmu->SetResponseCode( HscFromHresult(W_DAV_PARTIAL_SUCCESS),
							NULL,
							0,
							CSEFromHresult(W_DAV_PARTIAL_SUCCESS) );

	//	Find the properties...
	//
	auto_ref_ptr<CXMLEmitter> pmsr;
	auto_ref_ptr<CXMLBody> pxb;

	pxb.take_ownership (new CXMLBody(m_pmu.get()));
	pmsr.take_ownership (new CXMLEmitter(pxb.get(), &m_cfc));

	if (DEPTH_ONE_NOROOT != m_lDepth)
	{
		//	Get properties for root if it is not a noroot case
		//	Depth infinity,noroot is a bad request, that is why
		//	check above is valid.
		//
		sc = ScFindFileProps (m_pmu.get(),
							  m_cfc,
							  *pmsr,
							  pwszUrl,
							  m_pwszPath,
							  NULL,
							  m_cri,
							  FALSE /*fEmbeddErrorsInResponse*/);
		if (FAILED (sc))
		{
			SendResponse(sc);
			return;
		}
	}

	//	ScFindFilePropsDeep initializes the emitter root only
	//	when it sees there's an entry to emit. so we crash
	//	in the noroot empty response case, when we try to emit
	//	the response, as we have no entry to emit and the
	//	root is still NULL.
	//	so we here manually initialize the root,
	//
	sc = pmsr->ScSetRoot (gc_wszMultiResponse);
	if (FAILED (sc))
	{
		SendResponse(sc);
		return;
	}

	//	And then, if apropriate, go deep...
	//
	if (m_cri.FCollection() &&
		(m_lDepth != DEPTH_ZERO) &&
		(m_pmu->MetaData().DwDirBrowsing() & MD_DIRBROW_ENABLED))
	{
		ChainedStringBuffer<WCHAR> sb;
		CVRList vrl;

		//	Apply the property request across all the physical children
		//
		sc = ScFindFilePropsDeep (m_pmu.get(),
								  m_cfc,
								  *pmsr,
								  pwszUrl,
								  m_pwszPath,
								  NULL,
								  m_lDepth);
		if (FAILED (sc))
		{
			SendResponse(sc);
			return;
		}

		//	Enumerate the child vroots and perform the
		//	deletion of those directories as well
		//
		m_pmu->ScFindChildVRoots (pwszUrl, sb, vrl);
		for ( ; (!FAILED (sc) && !vrl.empty()); vrl.pop_front())
		{
			auto_ref_ptr<CVRoot> cvr;
			LPCWSTR pwszChildUrl;
			LPCWSTR pwszChildPath;

			if (m_pmu->FGetChildVRoot (vrl.front().m_pwsz, cvr))
			{
				//	Put the url into a multibyte string
				//
				cvr->CchGetVRoot (&pwszChildUrl);

				//	Only process the sub-vroot if we are
				//	truely are going deep or if the sub-vroot
				//	is the immediate child of the request URI
				//
				if ((m_lDepth == DEPTH_INFINITY) ||
					FIsImmediateParentUrl (pwszUrl, pwszChildUrl))
				{
					CResourceInfo criSub;

					//	Crack the vroot and go...
					//
					cvr->CchGetVRPath (&pwszChildPath);
					sc = criSub.ScGetResourceInfo (pwszChildPath);
					if (!FAILED (sc))
					{
						//	Find the properties on the vroot root
						//
						sc = ScFindFileProps (m_pmu.get(),
											  m_cfc,
											  *pmsr,
											  pwszChildUrl,
											  pwszChildPath,
											  cvr.get(),
											  criSub,
											  TRUE /*fEmbedErrorsInResponse*/);
					}
					if (FAILED (sc))
					{
						SendResponse(sc);
						return;
					}
					else if (S_FALSE == sc)
						continue;

					//	Find the properties on the vroot kids
					//
					if (m_lDepth == DEPTH_INFINITY)
					{
						auto_ref_ptr<IMDData> pMDData;

						//	See if we have directory browsing...
						//
						if (SUCCEEDED(m_pmu->HrMDGetData (pwszChildUrl, pMDData.load())) &&
							(pMDData->DwDirBrowsing() & MD_DIRBROW_ENABLED))
						{
							sc = ScFindFilePropsDeep (m_pmu.get(),
								m_cfc,
								*pmsr,
								pwszChildUrl,
								pwszChildPath,
								cvr.get(),
								m_lDepth);

							if (FAILED (sc))
							{
								SendResponse(sc);
								return;
							}
						}
					}
				}
			}
		}
	}


	//	Done with the reponse
	//
	pmsr->Done();
	m_pmu->SendCompleteResponse();
}

VOID
CPropFindRequest::SendResponse( SCODE sc )
{
	//
	//	Set the response code and go
	//
	m_pmu->SetResponseCode( HscFromHresult(sc), NULL, 0, CSEFromHresult(sc) );
	m_pmu->SendCompleteResponse();
}

/*
 *	DAVPropFind()
 *
 *	Purpose:
 *
 *		Win32 file system implementation of the DAV PROPGET method.	 The
 *		PROPGET method responds with a fully constructed XML that provides
 *		the values of the resources property/properties.
 *
 *	Parameters:
 *
 *		pmu			[in]  pointer to the method utility object
 */
void
DAVPropFind (LPMETHUTIL pmu)
{
	auto_ref_ptr<CPropFindRequest> pRequest(new CPropFindRequest(pmu));

	pRequest->Execute();
}


//	CPropPatchRequest ----------------------------------------------------------------
//
class CPropPatchRequest :
	public CMTRefCounted,
	private IAsyncIStreamObserver
{
	//
	//	Reference to the CMethUtil
	//
	auto_ref_ptr<CMethUtil> m_pmu;

	//
	//	Translated URI path
	//
	LPCWSTR m_pwszPath;

	// Holds a handle owned by the lock cache.
	//
	auto_ref_handle m_hf;

	//	Resource info
	//
	CResourceInfo m_cri;

	//	Contexts
	//
	CFSPatch m_cpc;
	auto_ref_ptr<CNFPatch> m_pnfp;

	//	Request body as an IStream.  This stream is async -- it can
	//	return E_PENDING from Read() calls.
	//
	auto_ref_ptr<IStream> m_pstmRequest;

	//	The XML parser used to parse the request body using
	//	the node factory above.
	//
	auto_ref_ptr<IXMLParser> m_pxprs;

	//	IAsyncIStreamObserver
	//
	VOID AsyncIOComplete();

	//	State functions
	//
	VOID ParseBody();
	VOID DoPatch();
	VOID SendResponse( SCODE sc );

	//	NOT IMPLEMENTED
	//
	CPropPatchRequest (const CPropPatchRequest&);
	CPropPatchRequest& operator= (const CPropPatchRequest&);

public:
	//	CREATORS
	//
	CPropPatchRequest(LPMETHUTIL pmu) :
		m_pmu(pmu),
		m_pwszPath(m_pmu->LpwszPathTranslated())
	{
	}

	SCODE	ScInit() { return m_cpc.ScInit(); }

	//	MANIPULATORS
	//
	VOID Execute();
};

VOID
CPropPatchRequest::Execute()
{
	LPCWSTR pwsz;
	SCODE sc = S_OK;

	//
	//	First off, tell the pmu that we want to defer the response.
	//	Even if we send it synchronously (i.e. due to an error in
	//	this function), we still want to use the same mechanism that
	//	we would use for async.
	//
	m_pmu->DeferResponse();

	//	Do ISAPI application and IIS access bits checking
	//
	sc = m_pmu->ScIISCheck (m_pmu->LpwszRequestUrl(), MD_ACCESS_WRITE);
	if (FAILED(sc))
	{
		//	Either the request has been forwarded, or some bad error occurred.
		//	In either case, quit here and map the error!
		//
		SendResponse(sc);
		return;
	}

	//	PropPatch must have a content-type header and the value must be text/xml
	//
	sc = ScIsContentTypeXML (m_pmu.get());
	if (FAILED(sc))
	{
		DebugTrace ("Dav: PROPPATCH fails without specifying a text/xml contenttype\n");
		SendResponse(sc);
		return;
	}

	//  Look to see the Content-length - required for this operation
	//  to continue.
	//
	if (NULL == m_pmu->LpwszGetRequestHeader (gc_szContent_Length, FALSE))
	{
		DebugTrace ("Dav: PROPPATCH fails without content\n");
		SendResponse(E_DAV_MISSING_LENGTH);
		return;
	}
	if (!m_pmu->FExistsRequestBody())
	{
		DebugTrace ("Dav: PROPPATCH fails without content\n");
		SendResponse(E_INVALIDARG);
		return;
	}

	//	This method is gated by If-xxx headers
	//
	if (!FAILED (m_cri.ScGetResourceInfo (m_pwszPath)))
	{
		//	Ensure the URI and resource match...
		//
		(void) ScCheckForLocationCorrectness (m_pmu.get(), m_cri, NO_REDIRECT);

		//	... then check the headers
		//
		sc = ScCheckIfHeaders (m_pmu.get(), m_cri.PftLastModified(), FALSE);
	}
	else
		sc = ScCheckIfHeaders (m_pmu.get(), m_pwszPath, FALSE);

	if (FAILED (sc))
	{
		SendResponse(sc);
		return;
	}

	//	Check state headers here.
	//
	sc = HrCheckStateHeaders (m_pmu.get(), m_pwszPath, FALSE);
	if (FAILED (sc))
	{
		DebugTrace ("DavFS: If-State checking failed.\n");
		SendResponse(sc);
		return;
	}

	//	Handle locktokens and check for locks on this resource.
	//	Our locks don't lock the "secondary file stream" where we keep
	//	the properties, so we have to check manually before we do anything else.
	//$REVIEW: Joels, will this change when we switch to NT5 properties?
	//$REVIEW: If so, we need to change this code!
	//
	//	If we have a locktoken, try to get the lock handle from the cache.
	//	If this fails, fall through and do the normal processing.
	//
	pwsz = m_pmu->LpwszGetRequestHeader (gc_szLockToken, TRUE);
	if (!pwsz || !FGetLockHandle (m_pmu.get(), m_pwszPath, GENERIC_WRITE, pwsz, &m_hf))
	{
		//	Manually check for any write locks on this resource.
		//	If a write lock exists, don't process the request.
		//
		if (FLockViolation (m_pmu.get(), ERROR_SHARING_VIOLATION, m_pwszPath, GENERIC_WRITE))
		{
			SendResponse(E_DAV_LOCKED);
			return;
		}
	}

	//	Instantiate the XML parser
	//
	m_pnfp.take_ownership(new CNFPatch(m_cpc));
	m_pstmRequest.take_ownership(m_pmu->GetRequestBodyIStream(*this));

	sc = ScNewXMLParser( m_pnfp.get(),
						 m_pstmRequest.get(),
						 m_pxprs.load() );

	if (FAILED(sc))
	{
		DebugTrace( "CPropPatchRequest::Execute() - ScNewXMLParser() failed (0x%08lX)\n", sc );
		SendResponse(sc);
		return;
	}

	//	Start parsing it into the context
	//
	ParseBody();
}

VOID
CPropPatchRequest::ParseBody()
{
	Assert( m_pxprs.get() );
	Assert( m_pnfp.get() );
	Assert( m_pstmRequest.get() );

	//	Parse XML from the request body stream.
	//
	//	Add a ref for the following async operation.
	//	Use auto_ref_ptr rather than AddRef() for exception safety.
	//
	auto_ref_ptr<CPropPatchRequest> pRef(this);

	SCODE sc = ScParseXML (m_pxprs.get(), m_pnfp.get());

	if ( SUCCEEDED(sc) )
	{
		Assert( S_OK == sc || S_FALSE == sc );

		DoPatch();
	}
	else if ( E_PENDING == sc )
	{
		//
		//	The operation is pending -- AsyncIOComplete() will take ownership
		//	ownership of the reference when it is called.
		//
		pRef.relinquish();
	}
	else
	{
		DebugTrace( "CPropPatchRequest::ParseBody() - ScParseXML() failed (0x%08lX)\n", sc );
		SendResponse(sc);
	}
}

VOID
CPropPatchRequest::AsyncIOComplete()
{
	//	Take ownership of the reference added for the async operation.
	//
	auto_ref_ptr<CPropPatchRequest> pRef;
	pRef.take_ownership(this);

	ParseBody();
}

VOID
CPropPatchRequest::DoPatch()
{
	SCODE sc;

	//	At this point, make sure that they support text/xml
	//
	sc = ScIsAcceptable (m_pmu.get(), gc_wszText_XML);
	if (FAILED (sc))
	{
		SendResponse(sc);
		return;
	}

	//	Get the IPropertyBagEx on the resource
	//	If the file is locked, we must use its handle to
	//	get the inteface. otherwise, access will be denied
	//
	auto_com_ptr<IPropertyBagEx> pbag;

	sc = ScGetPropertyBag (m_pwszPath,
						   STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
						   &pbag,
						   m_cri.FLoaded() ? m_cri.FCollection() : FALSE,
						   m_hf.get() ? m_hf.get() : INVALID_HANDLE_VALUE);
	if (FAILED (sc))
	{
		//	You can't set properties without a property bag...
		//
		if (VOLTYPE_NTFS != VolumeType (m_pwszPath, m_pmu->HitUser()))
			sc = E_DAV_VOLUME_NOT_NTFS;

		SendResponse(sc);
		return;
	}

	//	All header must be emitted before chunked XML emitting starts
	//
	m_pmu->SetResponseHeader (gc_szContent_Type, gc_szText_XML);

	//	Set the response code and go
	//
	m_pmu->SetResponseCode( HscFromHresult(W_DAV_PARTIAL_SUCCESS),
							NULL,
							0,
							CSEFromHresult(W_DAV_PARTIAL_SUCCESS) );

	//	Apply the request
	//
	auto_ref_ptr<CXMLEmitter> pmsr;
	auto_ref_ptr<CXMLBody>	pxb;

	pxb.take_ownership (new CXMLBody(m_pmu.get()));
	pmsr.take_ownership (new CXMLEmitter(pxb.get(), &m_cpc));

	CFSProp fsp(m_pmu.get(),
				pbag,
				m_pmu->LpwszRequestUrl(),
				m_pwszPath,
				NULL,
				m_cri);

	sc = m_cpc.ScPatch (*pmsr, m_pmu.get(), fsp);
	
	//	Make sure we close the file before sending any response
	//
	pbag.clear();
	
	if (FAILED (sc))
	{		
		SendResponse(sc);
		return;
	}

	//	Done with the reponse
	//
	pmsr->Done();

	m_pmu->SendCompleteResponse();
}

VOID
CPropPatchRequest::SendResponse( SCODE sc )
{
	//
	//	Set the response code and go
	//
	m_pmu->SetResponseCode( HscFromHresult(sc), NULL, 0, CSEFromHresult(sc) );
	m_pmu->SendCompleteResponse();
}

/*
 *	DAVPropPatch()
 *
 *	Purpose:
 *
 *		Win32 file system implementation of the DAV PROPPATCH method.  The
 *		PROPPATCH method responds with a fully constructed XML that identifies
 *		the success of each prop request.
 *
 *	Parameters:
 *
 *		pmu			[in]  pointer to the method utility object
 */
void
DAVPropPatch (LPMETHUTIL pmu)
{
	SCODE	sc;
	auto_ref_ptr<CPropPatchRequest> pRequest(new CPropPatchRequest(pmu));

	sc = pRequest->ScInit();
	if (FAILED(sc))
	{
		pmu->SetResponseCode( HscFromHresult(sc), NULL, 0, CSEFromHresult(sc) );
		pmu->SendCompleteResponse();
	}

	pRequest->Execute();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\fsmvcpy.cpp ===
/*
 *	 F S M V C P Y . C P P
 *
 *	Sources for directory ineration object
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"
#include "_fsmvcpy.h"

#include "_shlkmgr.h"

//	ScAddMultiUrl
//		Helper function for XML emitting
//
SCODE
ScAddMultiFromUrl (
	/* [in] */ CXMLEmitter& emitter,
	/* [in] */ IMethUtil * pmu,
	/* [in] */ LPCWSTR pwszUrl,
	/* [in] */ ULONG hsc,
	/* [in] */ BOOL fCollection,
	/* [in] */ BOOL fMove = FALSE)
{
	SCODE sc = S_OK;

	//	NT#403615 -- Rosebud in Office9 or in NT5 re-issues a MOVE if they
	//	see a 401 inside the 207 Multi-Status response, which can result
	//	in data loss.
	//	WORKAROUND: If we are doing a MOVE, and the User-Agent string shows
	//	that this is Rosebud from Office9 or from NT5, change all 401s to 403s
	//	to avoid the problem -- Rosebud will not re-issue the MOVE, so the
	//	data (now sitting in the destination dir) will not be wiped.
	//	This is the minimal code needed to work around the problem.
	//
	if (fMove &&
		HSC_UNAUTHORIZED == hsc &&
		(pmu->FIsOffice9Request() || pmu->FIsRosebudNT5Request()))
	{
		hsc = HSC_FORBIDDEN;
	}

	//	Supress omitting of "Method Failure" node as it is a "SHOULD NOT"
	//	item in the DAV drafts.
	//	It's possible pszUrl passed in as NULL, in these cases, simply skip
	//	the emitting, do nothing
	//
	if ((hsc != HSC_METHOD_FAILURE) && pwszUrl)
	{
		auto_heap_ptr<CHAR> pszUrlEscaped;
		CEmitterNode enRes;
		UINT cchUrl;

		//$REVIEW: This is important, we should not start a xml document
		//$REVIEW: unless we have to. Otherwise, we may end up XML body
		//$REVIEW: when not necessary.
		//$REVIEW: So it's necessary to call ScSetRoot() to make sure
		//$REVIEW: that the xml document is intialized bofore continue
		//$REVIEW:
		//$REVIEW: This model works because in fsmvcpy.cpp, all the calls to
		//$REVIEW: XML emitter are through ScAddMultiFromUrl and ScAddMulti
		//$REVIEW:
		sc = emitter.ScSetRoot (gc_wszMultiResponse);
		if (FAILED (sc))
			goto ret;

		//	Construct the response
		//
		sc = enRes.ScConstructNode (emitter, emitter.PxnRoot(), gc_wszResponse);
		if (FAILED (sc))
			goto ret;

		//	Construct the href node
		//
		{
			CEmitterNode en;
			sc = enRes.ScAddNode (gc_wszXML__Href, en);
			if (FAILED (sc))
				goto ret;
			//	Set the value of the href node.  If the url is absolute,
			//	but not fully qualified, qualify it...
			//
			if (L'/' == *pwszUrl)
			{
				LPCSTR psz;
				UINT cch;

				//	Add the prefix
				//
				cch = pmu->CchUrlPrefix (&psz);
				sc = en.Pxn()->ScSetUTF8Value (psz, cch);
				if (FAILED (sc))
					goto ret;

				//$	REVIEW:	Does the host name need escaping?
				//
				//	Add the server
				//
				cch = pmu->CchServerName (&psz);
				sc = en.Pxn()->ScSetValue (psz, cch);
				if (FAILED (sc))
					goto ret;
			}

			//	Make the url wire safe
			//
			sc = ScWireUrlFromWideLocalUrl (static_cast<UINT>(wcslen(pwszUrl)),
											pwszUrl,
											pszUrlEscaped);
			if (FAILED (sc))
				goto ret;

			//	Add the url value
			//
			cchUrl = static_cast<UINT>(strlen(pszUrlEscaped.get()));
			sc = en.Pxn()->ScSetUTF8Value (pszUrlEscaped.get(), cchUrl);
			if (FAILED (sc))
				goto ret;

			//	If this is a collection, and the last char is not a
			//	trailing slash, add one....
			//
			if (fCollection && ('/' != pszUrlEscaped.get()[cchUrl-1]))
			{
				sc = en.Pxn()->ScSetUTF8Value ("/", 1);
				if (FAILED (sc))
					goto ret;
			}
		}

		//	Add the status/error string
		//
		sc = ScAddStatus (&enRes, hsc);
		if (FAILED (sc))
			goto ret;
	}

ret:
	return sc;
}

SCODE
ScAddMulti (
	/* [in] */ CXMLEmitter& emitter,
	/* [in] */ IMethUtil * pmu,
	/* [in] */ LPCWSTR pwszPath,
	/* [in] */ LPCWSTR pwszErr,
	/* [in] */ ULONG hsc,
	/* [in] */ BOOL fCollection,
	/* [in] */ CVRoot* pcvrTrans)
{
	SCODE sc = S_OK;

	//	Supress omitting of "Method Failure" node as it is a "SHOULD NOT"
	//	item in the DAV drafts.
	//
	if (hsc != HSC_METHOD_FAILURE)
	{
		CEmitterNode enRes;

		//$REVIEW: This is important, we should not start a xml document
		//$REVIEW: unless we have to. Otherwise, we may end up XML body
		//$REVIEW: when not necessary.
		//$REVIEW: So it's necessary to call ScSetRoot() to make sure
		//$REVIEW: that the xml document is intialized bofore continue
		//$REVIEW:
		//$REVIEW: This model works because in fsmvcpy.cpp, all the calls to
		//$REVIEW: XML emitter are through ScAddMultiFromUrl and ScAddMulti
		//$REVIEW:
		sc = emitter.ScSetRoot (gc_wszMultiResponse);
		if (FAILED (sc))
			goto ret;

		sc = enRes.ScConstructNode (emitter, emitter.PxnRoot(), gc_wszResponse);
		if (FAILED (sc))
			goto ret;

		sc = ScAddHref (enRes, pmu, pwszPath, fCollection, pcvrTrans);
		if (FAILED (sc))
			goto ret;

		sc = ScAddStatus (&enRes, hsc);
		if (FAILED (sc))
			goto ret;

		if (pwszErr)
		{
			sc = ScAddError (&enRes, pwszErr);
			if (FAILED (sc))
				goto ret;
		}
	}
ret:
	return sc;
}

//	class CAccessMetaOp -------------------------------------------------------
//
SCODE __fastcall
CAccessMetaOp::ScOp(LPCWSTR pwszMbPath, UINT cch)
{
	SCODE			sc;
	METADATA_RECORD	mdrec;

	Assert (MD_ACCESS_PERM == m_dwId);
	Assert (DWORD_METADATA == m_dwType);

	//	Get the value from the metabase and don't inherit
	//
	DWORD dwAcc = 0;
	DWORD cb = sizeof(DWORD);

	mdrec.dwMDIdentifier = m_dwId;
	mdrec.dwMDAttributes = METADATA_NO_ATTRIBUTES;
	mdrec.dwMDUserType = 0;
	mdrec.dwMDDataType = m_dwType;
	mdrec.dwMDDataLen = cb;
	mdrec.pbMDData = reinterpret_cast<LPBYTE>(&dwAcc);

	sc = m_mdoh.HrGetMetaData( pwszMbPath,
							   &mdrec,
							   &cb );
	if (FAILED(sc))
	{
		MCDTrace ("CAccessMetaOp::ScOp() - CMDObjectHandle::HrGetMetaData() failed 0x%08lX\n", sc);
		sc = S_OK;
		goto ret;
	}

	//	Hey, we got a value, so let's do our quick check..
	//
	if (m_dwAcc == (dwAcc & m_dwAcc))
	{
		//	We have full required access to this node, so
		//	we can proceed.
		//
		Assert (S_OK == sc);
	}
	else
	{
		//	We do not have access to operate on this item and
		//	it's inherited children.
		//
		MCDTrace ("CAccessMetaOp::ScOp() - no access to '%S'\n", pwszMbPath);
		m_fAccessBlocked = TRUE;

		//	We know enough...
		//
		sc = S_FALSE;
	}

ret:

	return sc;
}

//	class CAuthMetaOp -------------------------------------------------------
//
SCODE __fastcall
CAuthMetaOp::ScOp(LPCWSTR pwszMbPath, UINT cch)
{
	SCODE			sc;
	METADATA_RECORD	mdrec;

	Assert (MD_AUTHORIZATION == m_dwId);
	Assert (DWORD_METADATA == m_dwType);

	//	Get the value from the metabase and don't inherit
	//
	DWORD dwAuth = 0;
	DWORD cb = sizeof(DWORD);

	mdrec.dwMDIdentifier = m_dwId;
	mdrec.dwMDAttributes = METADATA_NO_ATTRIBUTES;
	mdrec.dwMDUserType = 0;
	mdrec.dwMDDataType = m_dwType;
	mdrec.dwMDDataLen = cb;
	mdrec.pbMDData = reinterpret_cast<LPBYTE>(&dwAuth);

	sc = m_mdoh.HrGetMetaData( pwszMbPath,
							   &mdrec,
							   &cb );
	if (FAILED(sc))
	{
		MCDTrace ("CAuthMetaOp::ScOp() - CMDObjectHandle::HrGetMetaData() failed 0x%08lX\n", sc);
		sc = S_OK;
		goto ret;
	}

	//	Hey, we got a value, so let's do our quick check..
	//
	if (m_dwAuth == dwAuth)
	{
		Assert(S_OK == sc);
	}
	else
	{
		//	We do not have access to operate on this item and
		//	it's inherited children.
		//
		MCDTrace ("CAuthMetaOp::ScOp() - authorization differs, no access to '%S'\n", pwszMbPath);
		m_fAccessBlocked = TRUE;

		//	We know enough...
		//
		sc = S_FALSE;
	}

ret:

	return sc;
}

//	class CIPRestrictionMetaOp ------------------------------------------------
//
SCODE __fastcall
CIPRestrictionMetaOp::ScOp(LPCWSTR pwszMbPath, UINT cch)
{
	SCODE			sc;
	METADATA_RECORD	mdrec;

	Assert (MD_IP_SEC == m_dwId);
	Assert (BINARY_METADATA == m_dwType);

	//	Get the value from the metabase and don't inherit
	//
	DWORD cb = 0;

	mdrec.dwMDIdentifier = m_dwId;
	mdrec.dwMDAttributes = METADATA_NO_ATTRIBUTES;
	mdrec.dwMDUserType = 0;
	mdrec.dwMDDataType = m_dwType;
	mdrec.dwMDDataLen = cb;
	mdrec.pbMDData = NULL;

	sc = m_mdoh.HrGetMetaData( pwszMbPath,
							   &mdrec,
							   &cb );
	if (FAILED(sc) && (0 == cb))
	{
		MCDTrace ("CIPRestrictionMetaOp::ScOp() - CMDObjectHandle::HrGetMetaData() failed 0x%08lX, but that means success in this path\n", sc);
		sc = S_OK;
	}
	else
	{
		Assert (S_OK == sc ||
				HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == sc);

		//	Hey, we got a value, and we don't want to check here so
		//	we are going to be pessimistic about this one....
		//
		MCDTrace ("CIPRestrictionMetaOp::ScOp() - IPRestriction exists in tree '%S'\n", pwszMbPath);
		m_fAccessBlocked = TRUE;

		//	We know enough...
		//
		sc = S_FALSE;
	}

	return sc;
}

//	ScCheckMoveCopyDeleteAccess() ---------------------------------------------
//
SCODE __fastcall
ScCheckMoveCopyDeleteAccess (
	/* [in] */ IMethUtil* pmu,
	/* [in] */ LPCWSTR pwszUrl,
	/* [in] */ CVRoot* pcvr,
	/* [in] */ BOOL fDirectory,
	/* [in] */ BOOL fCheckScriptmaps,
	/* [in] */ DWORD dwAccess,
	/* [out] */ SCODE* pscItem,
	/* [in] */ CXMLEmitter& msr)
{
	SCODE sc = S_OK;

	//	Check with the CMethUtil on whether or not we have access
	//
	sc = pmu->ScCheckMoveCopyDeleteAccess (pwszUrl,
										   pcvr,
										   fDirectory,
										   fCheckScriptmaps,
										   dwAccess);

	//	Pass back the results...
	//
	*pscItem = sc;

	//	... and if the call cannot proceed, then add the item to the
	//	multi-status response.
	//
	if (FAILED (sc))
	{
		//	Add to the reponse XML
		//
		sc = ScAddMultiFromUrl (msr,
								pmu,
								pwszUrl,
								HscFromHresult(sc),
								fDirectory);
		if (!FAILED (sc))
			sc = W_DAV_PARTIAL_SUCCESS;
	}

	return sc;
}

//	Directory deletes ---------------------------------------------------------
//
/*
 *	ScDeleteDirectory()
 *
 *	Purpose:
 *
 *		Helper function used to iterate through a directory
 *		and delete all its contents as well as the directory
 *		itself.
 *
 *	Notes:
 *
 *		BIG FAT NOTE ABOUT LOCKING.
 *
 *		The Lock-Token header may contain locks that we have to use in
 *		this operation.
 *		The following code was written with these assumptions:
 *		o	Directory locks are NOT SUPPORTED on davfs.
 *		o	Locks only affect the ability to WRITE to a resource.
 *			(The only currently supported locktype on davfs is WRITE.)
 *		o	This function may be called from DELETE or other methods.
 *			(If called from DELETE, we want to DROP the locks listed.)
 *		Because of these two assumptions, we only check the passed-in
 *		locktokens when we have a write-error (destination).
 *
 *		Locking uses the final two parameters.  plth is a
 *		pointer to a locktoken header parser object.  If we have a plth,
 *		then we must check it for provided locktokens when we hit a lock
 *		conflict. If a locktoken is provided, the failed delete operation
 *		should NOT be reported as an error, but instead skipped here
 *		(to be handled by the calling routine later in the operation) OR
 *		the lock should be dropped here and the delete attempted again.
 *		The fDeleteLocks variable tells whether to drop locks (TRUE),
 *		or to skip the deleteion of locked items that have locktokens.
 *
 *		Basic logic:
 *			Try to delete.
 *			If LOCKING failure (ERROR_SHARING_VIOLATION), check the plth.
 *			If the plth has a locktoken for this path, check fDeleteLocks.
 *			If fDeleteLocks == TRUE, drop the lock and try the delte again.
 *			If fDeleteLocks == FALSE, skip this file and move on.
 */
SCODE
ScDeleteDirectory (
	/* [in] */ IMethUtil* pmu,
	/* [in] */ LPCWSTR pwszUrl,
	/* [in] */ LPCWSTR pwszDir,
	/* [in] */ BOOL fCheckAccess,
	/* [in] */ DWORD dwAcc,
	/* [in] */ LONG lDepth,
	/* [in] */ CVRoot* pcvrTranslate,
	/* [in] */ CXMLEmitter& msr,
	/* [out] */ BOOL* pfDeleted,
	/* [in] */ CParseLockTokenHeader* plth,	// Usually NULL -- no locktokens to worry about
	/* [in] */ BOOL fDeleteLocks)			// Normally FALSE -- don't drop locks
{
	BOOL fOneSkipped = FALSE;
	ChainedStringBuffer<WCHAR> sb;
	SCODE sc = S_OK;
	SCODE scItem = S_OK;
	std::list<LPCWSTR, heap_allocator<LPCWSTR> > lst;

	CDirIter di(pwszUrl,
				pwszDir,
				NULL,	// no-destination for deletes
				NULL,	// no-destination for deletes
				NULL,	// no-destination for deletes
				TRUE);	// recurse into sub-driectories

	Assert (pfDeleted);
	*pfDeleted = TRUE;

	//	A SMALL FAT NOTE ABOUT ACCESS
	//
	//	The caller of this method is required to sniff the tree
	//	prior to this call.  If there is any access block in the
	//	tree, then each item will be checked for access before the
	//	operation proceeds.
	//
	const DWORD dwDirectory = MD_ACCESS_READ | MD_ACCESS_WRITE;
	const DWORD dwFile = MD_ACCESS_WRITE;
	if (fCheckAccess & (0 == (dwAcc & MD_ACCESS_READ)))
	{
		DebugTrace ("Dav: MCD: no permissions for deleting\n");
		sc = E_DAV_NO_IIS_READ_ACCESS;
		*pfDeleted = FALSE;
		goto ret;
	}

	//	Push the current path
	//
	//$	REVIEW: if "depth: infinity,no-root" ever needs to be supported,
	//	it really is as simple as not pushing the current path.
	//
	if (DEPTH_INFINITY_NOROOT != lDepth)
	{
		Assert (DEPTH_INFINITY == lDepth);
		lst.push_back(pwszDir);
	}

	//	Iterate through the directories.  Deleting files and pushing
	//	directory names as we go.
	//
	//	We really only want to push into the child directories if the
	//	operation on the parent succeeds.
	//
	while (S_OK == di.ScGetNext(!FAILED (scItem)))
	{
		//	Check our access rights and only push down into the directory
		//	if we have access to delete its contents.
		//
		// 	Note that we need read and write access to enum and delete
		//	a directory, but we need only write access in order to delete
		//	a file.
		//
		if (fCheckAccess)
		{
			sc = ScCheckMoveCopyDeleteAccess (pmu,
											  di.PwszUri(),
											  pcvrTranslate,
											  di.FDirectory(),
											  FALSE, // don't check scriptmaps
											  di.FDirectory() ? dwDirectory : dwFile,
											  &scItem,
											  msr);
			if (FAILED (sc))
				goto ret;

			//	If things were not 100%, don't process this resource
			//
			if (S_OK != sc)
				continue;
		}

		//	Process the file
		//
		if (di.FDirectory())
		{
			auto_ref_ptr<CVRoot> pcvr;

			if (di.FSpecial())
				continue;

			//	Child virtual root scriptmappings have been
			//	handled via ScCheckMoveCopyDeleteAccess(),
			//	and the physical deleting happens after this
			//	call completes!
			//
			//	So there is no need to do any special processing
			//	other than to push the directory and move on...
			//
			lst.push_back (AppendChainedSz (sb, di.PwszSource()));
			scItem = S_OK;
		}
		else
		{
			//	Delete the file
			//
			//	NOTE: We've already checked that we have write access.
			//	Also keep in mind that the ordering in which the directory
			//	traversals occur allows us to still key off of scItem to
			//	determine if we should push down into subdirectories.
			//
			//	This is because the directory entry is processed BEFORE
			//	any children are processed.  So the iteration on the dir
			//	will reset the scItem with the appropriate scode for access.
			//
			MCDTrace ("Dav: MCD: deleting '%ws'\n", di.PwszSource());
			if (!DavDeleteFile (di.PwszSource()))
			{
				DWORD dw = GetLastError();
				DebugTrace ("Dav: MCD: failed to delete file (%d)\n", dw);

				//	If it's a sharing (lock) violation, AND we have a
				//	locktoken for this path (lth.GetToken(pwsz))
				//	skip this path.
				//
				if ((ERROR_SHARING_VIOLATION == dw) && plth)
				{
					__int64 i64;

					//	If we have a locktoken for this path, skip it.
					//
					scItem = plth->HrGetLockIdForPath (di.PwszSource(),
						GENERIC_WRITE,
						&i64);
					if (SUCCEEDED (scItem))
					{
						Assert (i64);

						//	Should we try to delete locks?
						//
						if (!fDeleteLocks)
						{
							//	Don't delete locks.  Just skip this item.
							//	Remember that we skipped it, tho, so we don't
							//	complain about deleting the parent dir below.
							//
							fOneSkipped = TRUE;
							continue;
						}
						else
						{
							//	Drop the lock & try again.
							//
							FDeleteLock (pmu, i64);
							if (DavDeleteFile (di.PwszSource()))
							{
								//	We're done with this item.  Move along.
								//
								continue;
							}
							//	else, record the error in our XML.
							//
							dw = GetLastError();
						}
					}
					//	else, record the error in our XML.
					//
				}

				//	Add to the reponse XML
				//
				sc = ScAddMultiFromUrl (msr,
										pmu,
										di.PwszUri(),
										HscFromLastError(dw),
										di.FDirectory());
				if (FAILED (sc))
					goto ret;

				sc = W_DAV_PARTIAL_SUCCESS;
			}
		}
	}

	//	Now that all the files are deleted, we can start deleting
	//	the directories.
	//
	while (!lst.empty())
	{
		MCDTrace ("Dav: MCD: removing '%ws'\n", lst.back());

		//	Try to delete the dir.  If it doesn't delete, check our
		//	"skipped because of a lock above" flag before complaining.
		//
		//$	LATER: Fix this to actually lookup the dir path in the
		//	lockcache (using "fPathLookup").
		//
		if (!DavRemoveDirectory (lst.back()) && !fOneSkipped)
		{
			DWORD dw = GetLastError();
			DebugTrace ("Dav: MCD: failed to delete directory: %ld\n", dw);

			//	Add to the reponse XML
			//
			sc = ScAddMulti (msr,
							 pmu,
							 lst.back(),
							 NULL,
							 HscFromLastError(dw),
							 TRUE,				//	We know it's a directory
							 pcvrTranslate);
			if (FAILED (sc))
				goto ret;

			sc = W_DAV_PARTIAL_SUCCESS;
			*pfDeleted = FALSE;
		}
		lst.pop_back();
	}

ret:
	return sc;
}

SCODE
ScDeleteDirectoryAndChildren (
	/* [in] */ IMethUtil* pmu,
	/* [in] */ LPCWSTR pwszUrl,
	/* [in] */ LPCWSTR pwszPath,
	/* [in] */ BOOL fCheckAccess,
	/* [in] */ DWORD dwAcc,
	/* [in] */ LONG lDepth,
	/* [in] */ CXMLEmitter& msr,
	/* [in] */ CVRoot* pcvrTranslate,
	/* [out] */ BOOL* pfDeleted,
	/* [in] */ CParseLockTokenHeader* plth,	// Usually NULL -- no locktokens to worry about
	/* [in] */ BOOL fDeleteLocks)			// Normally FALSE -- don't drop locks
{
	BOOL fPartial = FALSE;
	SCODE sc = S_OK;

	//	Delete the main body first
	//
	MCDTrace ("Dav: MCD: deleting '%ws'\n", pwszPath);
	sc = ScDeleteDirectory (pmu,
							pwszUrl,
							pwszPath,
							fCheckAccess,
							dwAcc,
							lDepth,
							pcvrTranslate, // translations are pmu based
							msr,
							pfDeleted,
							plth,
							fDeleteLocks);
	if (!FAILED (sc))
	{
		//	Enumerate the child vroots and perform the
		//	deletion of those directories as well
		//
		ChainedStringBuffer<WCHAR> sb;
		CVRList vrl;

		//	Cleanup the list such that our namespaces are in
		//	a reasonable order.
		//
		(void) pmu->ScFindChildVRoots (pwszUrl, sb, vrl);
		vrl.sort();

		for ( ; !FAILED(sc) && !vrl.empty(); vrl.pop_front())
		{
			auto_ref_ptr<CVRoot> pcvr;
			CResourceInfo cri;
			LPCWSTR pwszChildUrl;
			LPCWSTR pwszChildPath;
			SCODE scItem;

			//	Remember any partial returns
			//
			if (W_DAV_PARTIAL_SUCCESS == sc)
				fPartial = TRUE;

			if (pmu->FGetChildVRoot (vrl.front().m_pwsz, pcvr))
			{
				//	Note, only check access if required
				//
				Assert (fCheckAccess);
				pcvr->CchGetVRoot (&pwszChildUrl);
				pcvr->CchGetVRPath (&pwszChildPath);
				sc = ScCheckMoveCopyDeleteAccess (pmu,
												  pwszChildUrl,
												  pcvr.get(),
												  TRUE, // Directory
												  FALSE, // dont check scriptmaps
												  MD_ACCESS_READ|MD_ACCESS_WRITE,
												  &scItem,
												  msr);
				if (FAILED (sc))
					goto ret;

				//	If things were not 100%, don't process this resource
				//
				if (S_OK != sc)
					continue;

				//	Delete the sub-virtual roots files and and continue on
				//
				sc = ScDeleteDirectory (pmu,
										pwszChildUrl,
										pwszChildPath,
										fCheckAccess,
										dwAcc,
										DEPTH_INFINITY,
										pcvr.get(),
										msr,
										pfDeleted,
										plth,
										fDeleteLocks);
				if (FAILED (sc))
				{
					sc = ScAddMultiFromUrl (msr,
											pmu,
											pwszChildUrl,
											HscFromHresult(sc),
											TRUE); // We know it's a directory
					if (FAILED (sc))
						goto ret;

					sc = W_DAV_PARTIAL_SUCCESS;
					*pfDeleted = FALSE;
				}
			}
		}
	}

ret:

	return ((S_OK == sc) && fPartial) ? W_DAV_PARTIAL_SUCCESS : sc;
}

//	class CContentTypeMetaOp --------------------------------------------------
//
SCODE __fastcall
CContentTypeMetaOp::ScOp(LPCWSTR pwszMbPath, UINT cchSrc)
{
	Assert (MD_MIME_MAP == m_dwId);
	Assert (MULTISZ_METADATA == m_dwType);

	//	Ok, we are going to get the data and copy it across
	//	if there is a destination path.
	//
	if (NULL != m_pwszDestPath)
	{
		WCHAR prgchContentType[MAX_PATH];

		auto_heap_ptr<WCHAR> pwszContentType;
		CMDObjectHandle mdohDest(*m_pecb);
		CStackBuffer<WCHAR,128> pwsz;
		DWORD cb = sizeof(prgchContentType);
		LPBYTE pbValue = reinterpret_cast<LPBYTE>(&prgchContentType);
		LPWSTR pwszLowest;
		METADATA_RECORD	mdrec;
		SCODE sc = S_OK;
		UINT cchBase;

		MCDTrace ("CContentTypeMetaOp::ScOp() - content-type: copying for '%S%S'...\n",
				  m_pwszMetaPath,
				  pwszMbPath);

		mdrec.dwMDIdentifier = m_dwId;
		mdrec.dwMDAttributes = METADATA_NO_ATTRIBUTES;
		mdrec.dwMDUserType = 0;
		mdrec.dwMDDataType = m_dwType;
		mdrec.dwMDDataLen = cb;
		mdrec.pbMDData = pbValue;

		sc = m_mdoh.HrGetMetaData( pwszMbPath,
								   &mdrec,
								   &cb );
		if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == sc)
		{
			pwszContentType = static_cast<LPWSTR>(g_heap.Alloc(cb));
			pbValue = reinterpret_cast<LPBYTE>(pwszContentType.get());

			mdrec.dwMDIdentifier = m_dwId;
			mdrec.dwMDAttributes = METADATA_NO_ATTRIBUTES;
			mdrec.dwMDUserType = 0;
			mdrec.dwMDDataType = m_dwType;
			mdrec.dwMDDataLen = cb;
			mdrec.pbMDData = pbValue;

			sc = m_mdoh.HrGetMetaData( pwszMbPath,
									   &mdrec,
									   &cb );
		}
		if (FAILED(sc))
		{
			//$	REVIEW: should failure to copy a content-type
			//	fail the call?
			//
			sc = S_OK;
			goto ret;
		}

		//	We sucesfully read some metadata. Remember the size.
		//
		cb = mdrec.dwMDDataLen;
		m_mdoh.Close();

		//	The destination path is the comprised of the stored
		//	destination path and the tail of the original source
		//	path.
		//
		MCDTrace ("CContentTypeMetaOp::ScOp() - content-type: ...to '%S%S'\n",
				  m_pwszDestPath,
				  pwszMbPath);

		//	Construct an metabase path for lowest node construction
		//
		cchBase = static_cast<UINT>(wcslen(m_pwszDestPath));
		if (NULL == pwsz.resize(CbSizeWsz(cchBase + cchSrc)))
		{
			sc = E_OUTOFMEMORY;
			goto ret;
		}

		//	Before we construct anything, make sure that we are not
		//	doing something stupid and creating two '//' in a row.
		//
		if ((L'/' == m_pwszDestPath[cchBase - 1]) &&
			(L'/' == *pwszMbPath))
		{
				cchBase -= 1;
		}
		memcpy (pwsz.get(), m_pwszDestPath, cchBase * sizeof(WCHAR));
		memcpy (pwsz.get() + cchBase, pwszMbPath, (cchSrc + 1) * sizeof(WCHAR));

		//	Release our hold on the metabase.  We need to do this
		//	because it is possible that the common root between
		//	the two nodes, may be in the same hierarchy.
		//
		//	NOTE: this should only really happen one time per
		//	move/copy operation.  The reason being that the lowest
		//	node will be established outside of the scope of the
		//	source on the first call.
		//
		sc = HrMDOpenLowestNodeMetaObject(pwsz.get(),
										  METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
										  &pwszLowest,
										  &mdohDest);
		if (SUCCEEDED(sc))
		{
			mdrec.dwMDIdentifier = m_dwId;
			mdrec.dwMDAttributes = METADATA_INHERIT;
			mdrec.dwMDUserType = IIS_MD_UT_FILE;
			mdrec.dwMDDataType = m_dwType;
			mdrec.dwMDDataLen = cb;
			mdrec.pbMDData = pbValue;

			(void) mdohDest.HrSetMetaData(pwszLowest, &mdrec);
			mdohDest.Close();
		}

		//	Reaquire our hold on the metabase
		//
		sc = HrMDOpenMetaObject( m_pwszMetaPath,
								 m_fWrite ? METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE : METADATA_PERMISSION_READ,
								 5000,
								 &m_mdoh);
		if (FAILED (sc))
			goto ret;
	}

	//	If this is a move, then delete the source
	//
	if (m_fDelete)
	{
		MCDTrace ("Dav: MCD: content-type: deleting from '%S'\n", pwszMbPath);
		(void) m_mdoh.HrDeleteMetaData( pwszMbPath,
										m_dwId,
										m_dwType);
	}

ret:

	return S_OK;
}

//	Directory moves/copies ----------------------------------------------------
//
/*
 *	ScMoveCopyDirectory()
 *
 *	Purpose:
 *
 *		Helper function used to iterate through a directory
 *		and copy all its contents to a destination directory.
 *
 *	Notes:
 *
 *		BIG FAT NOTE ABOUT LOCKING.
 *
 *		The Lock-Token header may contain locks that we have to use in
 *		this operation.
 *		The following code was written with these assumptions:
 *		o	Directory locks are NOT SUPPORTED on davfs.
 *		o	Locks only affect the ability to WRITE to a resource.
 *			(The only currently supported locktype on davfs is WRITE.)
 *		Because of these two assumptions, we only check the passed-in
 *		locktokens when we have a write-error (destination).
 */
SCODE
ScMoveCopyDirectory (
	/* [in] */ IMethUtil* pmu,
	/* [in] */ LPCWSTR pwszUrl,
	/* [in] */ LPCWSTR pwszSrc,
	/* [in] */ LPCWSTR pwszUrlDst,
	/* [in] */ LPCWSTR pwszDst,
	/* [in] */ BOOL fMove,
	/* [in] */ DWORD dwReplace,
	/* [in] */ BOOL fCheckAccess,
	/* [in] */ BOOL fCheckDestinationAccess,
	/* [in] */ DWORD dwAcc,
	/* [in] */ CVRoot* pcvrTranslateSrc,
	/* [in] */ CVRoot* pcvrTranslateDst,
	/* [in] */ CXMLEmitter& msr,
	/* [in] */ LONG lDepth,
	/* [in] */ CParseLockTokenHeader* plth)	// Usually NULL -- no locktokens to worry about
{
	auto_ref_ptr<CVRoot> pcvrDestination(pcvrTranslateDst);
	ChainedStringBuffer<WCHAR> sb;
	LPCWSTR pwszDestinationRedirect = NULL;
	SCODE sc = S_OK;
	SCODE scItem = S_OK;
	std::list<LPCWSTR, heap_allocator<LPCWSTR> > lst;

	CDirIter di(pwszUrl,
				pwszSrc,
				pwszUrlDst,
				pwszDst,
				pcvrTranslateDst,
				TRUE);	// Traverse into sub-directories

	//	See if there is a path conflict
	//
	if (FPathConflict (pwszSrc, pwszDst))
	{
		DebugTrace ("Dav: source and dest are in conflict\n");
		sc = E_DAV_CONFLICTING_PATHS;
		goto ret;
	}

	//	Ok, for MOVE requests where there is no blocked
	//	access along the way we can do the whole thing
	//	in one big shot.
	//
	//	Otherwise we are going to try and do this piece-wise.
	//
	//$	REVIEW:
	//
	//	Normally, we would do something like the following
	//
	//		if (!fMove ||
	//			fCheckAccess ||
	//			fCheckDestinationAccess ||
	//			!DavMoveFile (pwszSrc, pwszDst, dwReplace))
	//
	//	However, if the above code is used, IIS holds a lock
	//	on the moved source directory.  This prevents further
	//	access to that physical path.  NtCreateFile() reports
	//	a status of "DELETE PENDING" on the locked directory
	//	Win32 API's report "ACCESS DENIED"
	//
	//	If we do the degenerate case of always copying the root
	//	by hand, it reduces the likely hood of the lock out.
	//
	//	When this code gets checked in, a bug should be filed
	//	against IIS over this lock issue.  If and only if they
	//	do not fix this, will we fall back to the degenerate
	//	code.
	//
	if (!fMove ||
		fCheckAccess ||
		fCheckDestinationAccess ||
		!DavMoveFile (pwszSrc, pwszDst, dwReplace))
	//
	//$	REVIEW: end
	{
		//	Create the destination directory
		//
		if (!DavCreateDirectory (pwszDst, NULL))
		{
			//	If we have locks, and the dir is already there, it's okay.
			//	Otherwise, return an error.
			//
			//$	LATER: Fix this to actually lookup the dir path in the
			//	lockcache (using "fPathLookup").
			//
			if (!plth)
			{
				DWORD dw = GetLastError();
				if ((dw ==  ERROR_FILE_EXISTS) || (dw == ERROR_ALREADY_EXISTS))
					sc = E_DAV_OVERWRITE_REQUIRED;
				else
					sc = HRESULT_FROM_WIN32(dw);

				DebugTrace ("Dav: MCD: failed to create destination\n");
				goto ret;
			}
		}

		//	Slurp the properties over for the root directory
		//	We need to copy the properties first,
		//	Note, Currently, this call must be ahead of FInstantiate,
		//	as FInstantiate will keep the src dir open, and we won't be able to
		// 	get a IPropertyBagEx with STGM_SHARE_EXCLUSIVE, which is
		//	required by current nt5 impl. as STGM_SHARE_SHARE_WRITE
		//	does not work with IPropertyBagEx::Enum.
		//
		sc = ScCopyProps (pmu, pwszSrc, pwszDst, TRUE);
		if (FAILED(sc))
		{
			//	Do our best to remove the turd directory
			//
			DavRemoveDirectory (pwszDst);
			goto ret;
		}

		//	For MOVE's, push the current path
		//
		if (fMove)
			lst.push_back (pwszSrc);
	}
	else //	!fMove || fCheckAccess || fCheckDestinationAccess || !MoveFileEx()
	{
		Assert (DEPTH_INFINITY == lDepth);

		//	Ok, this is the cool bit.  If this succeeded,
		//	there there is no more processing required.
		//
		goto ret;
	}

	//	If we are not asked to copy internal members,
	//	then we are done
	//
	if (DEPTH_INFINITY != lDepth)
	{
		Assert (!fMove);
		goto ret;
	}

	//	Iterate through the directories -- copying as we go
	//
	while (S_OK == di.ScGetNext(!FAILED (scItem),
								pwszDestinationRedirect,
							    pcvrDestination.get()))
	{
		//$	REVIEW:
		//
		//	We have a very nasty case that we need to be
		//	able to handle...
		//
		//	If a virtual root already exists along the path of
		//	the destination, we need to redirect out destination
		//	path to the vrpath of that virtual root.
		//
		//	Reset the destination redirection
		//
		pwszDestinationRedirect = di.PwszDestination();
		pcvrDestination = di.PvrDestination();
		//
		//$	REVIEW: end

		//	Before anything, if this is one of the specials,
		//	do nothing...
		//
		if (di.FSpecial())
			continue;

		if (fCheckAccess)
		{
			//	Check our access rights and only push down
			//	into the directory if and only if we have access.
			//
			sc = ScCheckMoveCopyDeleteAccess (pmu,
											  di.PwszUri(),
											  pcvrTranslateSrc,
											  di.FDirectory(),
											  TRUE, // check scriptmaps
											  dwAcc,
											  &scItem,
											  msr);
			if (FAILED (sc))
				goto ret;

			//	If things were not 100%, don't process this resource
			//
			if (S_OK != sc)
				continue;
		}

		if (fCheckDestinationAccess)
		{
			//$	REVIEW:
			//
			//	We have a very nasty case that we need to be
			//	able to handle...
			//
			//	If a virtual root already exists along the path of
			//	the destination, we need to redirect out destination
			//	path to the vrpath of that virtual root.
			//
			//	Look for a virtual root matching the destination url,
			//	and set the redirect path if need be.
			//
			if (pmu->FFindVRootFromUrl(di.PwszUriDestination(), pcvrDestination))
			{
				MCDTrace ("Dav: MCD: destination url maps to virtual root\n");

				//	All access checking, including scriptmap honors are handled
				//	by ScCheckMoveCopyDeleteAccess()
				//

				//	Redirect the destination
				//
				pcvrDestination->CchGetVRPath (&pwszDestinationRedirect);
			}
			//
			//$	REVIEW: end

			//	Same kind of deal -- check our access rights and
			//	only push down into the directory if and only if
			//	we have access.
			//
			sc = ScCheckMoveCopyDeleteAccess (pmu,
											  di.PwszUriDestination(),
											  pcvrDestination.get(),
											  di.FDirectory(),
											  TRUE, // check scriptmap on dest
											  MD_ACCESS_WRITE,
											  &scItem,
											  msr);
			if (FAILED (sc))
				goto ret;

			//	If things were not 100%, don't process this resource
			//
			if (S_OK != sc)
				continue;
		}

		MCDTrace ("Dav: MCD: moving/copying '%S' to '%S'\n",
				  di.PwszSource(),
				  pwszDestinationRedirect);

		//	If we are moving, then just try the generic MoveFileW(),
		//	and if it fails, then do it piecewise...
		//
		if (!fMove ||
			fCheckAccess ||
			fCheckDestinationAccess ||
			!DavMoveFile (di.PwszSource(),
						  pwszDestinationRedirect,
						  dwReplace))
		{
			scItem = S_OK;

			//	If we found another directory, then iterate on it
			//
			if (di.FDirectory())
			{
				//	We need to create the sister directory in
				//	the destination directory
				//
				if (DavCreateDirectory (pwszDestinationRedirect, NULL) || plth)
				{
					scItem = ScCopyProps (pmu,
										  di.PwszSource(),
										  pwszDestinationRedirect,
										  TRUE);

					if (FAILED (scItem))
					{
						//	Do our best to remove the turd directory
						//
						DavRemoveDirectory (pwszDestinationRedirect);
					}

					//	For all MOVEs push the directory
					//
					if (!FAILED (scItem) && fMove)
					{
						lst.push_back (AppendChainedSz(sb, di.PwszSource()));
					}
				}
				else
				{
					DebugTrace ("Dav: MCD: failed to create directory\n");
					scItem = HRESULT_FROM_WIN32(GetLastError());
				}

				if (FAILED (scItem))
				{
					//	Add to the reponse XML
					//
					sc = ScAddMultiFromUrl (msr,
											pmu,
											di.PwszUri(),
											HscFromHresult(scItem),
											di.FDirectory());
					if (FAILED (sc))
						goto ret;

					sc = W_DAV_PARTIAL_SUCCESS;
				}
			}
			else
			{
				//	Copy the file
				//
				if (!DavCopyFile (di.PwszSource(),
								  pwszDestinationRedirect,
								  0 != dwReplace))
				{
					DWORD dw = GetLastError();
					scItem = HRESULT_FROM_WIN32(dw);

					//	If it's a sharing (lock) violation, AND we have a
					//	locktoken parser (plth) AND it has a locktoken for
					//	this path (lth.GetToken(pwsz)), copy it manually.
					//
					if (plth &&
						(ERROR_SHARING_VIOLATION == dw || ERROR_FILE_EXISTS == dw))
					{
						scItem = ScDoLockedCopy (pmu,
							plth,
							di.PwszSource(),
							pwszDestinationRedirect);
					}
				}

				//	In the case of a move, handle the potentially
				//	locked source.
				//
				if (!FAILED (scItem) && fMove)
				{
					__int64 i64 = 0;

					//	If we have a locktoken for this path, then we really
					//	want to try and release the lock for the source and
					//	delete the file.
					//
					if (plth)
					{
						//	Find the lock...
						//
						scItem = plth->HrGetLockIdForPath (di.PwszSource(),
							GENERIC_WRITE,
							&i64);

						if (!FAILED (scItem))
						{
							//	... and drop it on the floor...
							//
							FDeleteLock (pmu, i64);
						}
					}

					//	... and try to delete the source again.
					//
					if (!DavDeleteFile (di.PwszSource()))
					{
						scItem = HRESULT_FROM_WIN32(GetLastError());
					}
				}

				if (FAILED (scItem))
				{
					//	If the file that failed to be copied was a hidden
					//	and/or system file, then it was more than likely a
					//	trigger file, but even as such, if the file has the
					//	hidden attribute, we don't want to partial report
					//	the failure.
					//
					if (!di.FHidden())
					{
						sc = ScAddMultiFromUrl (msr,
												pmu,
												di.PwszUri(),
												HscFromHresult(scItem),
												di.FDirectory(),
											    fMove);
						if (FAILED (sc))
							goto ret;

						sc = W_DAV_PARTIAL_SUCCESS;
					}
				}
			}
		}
		else //	!fMove || fCheckAccess || fCheckDestinationAccess || !MoveFileEx()
		{
			//	Again, this is the cool bit.  If we got here, then
			//	there is no need to delve down into this particular
			//	branch of the tree.
			//
			//	To accomplish this, we are going to lie in a gentle
			//	way.  By setting scItem to a failure condition we are
			//	preventing the extra work.
			//
			scItem = HRESULT_FROM_WIN32(ERROR_FILE_EXISTS);
		}
	}

	//	Now that all the files are moved or copied, the pushed directories
	//	can be removed.
	//
	while (!lst.empty())
	{
		Assert (fMove);
		MCDTrace ("Dav: MCD: removing '%S'\n", lst.back());

		//	Try to delete the dir.  If it doesn't delete, check our
		//	"skipped because of a lock above" flag before complaining.
		//
		//$	LATER: Fix this to actually lookup the dir path in the
		//	lockcache (using "fPathLookup").
		//
		if (!DavRemoveDirectory (lst.back()))
		{
			DebugTrace ("Dav: MCD: failed to delete directory\n");

			//	Add to the reponse XML
			//
			sc = ScAddMulti (msr,
							 pmu,
							 lst.back(),
							 NULL,
							 HscFromLastError(GetLastError()),
							 TRUE,				//	We know it's a directory
							 pcvrTranslateSrc);
			if (FAILED (sc))
				goto ret;

			sc = W_DAV_PARTIAL_SUCCESS;
		}

		lst.pop_back();
	}

ret:

	return sc;
}

SCODE
ScMoveCopyDirectoryAndChildren (
	/* [in] */ IMethUtil* pmu,
	/* [in] */ LPCWSTR pwszUrl,
	/* [in] */ LPCWSTR pwszSrc,
	/* [in] */ LPCWSTR pwszUrlDst,
	/* [in] */ LPCWSTR pwszDst,
	/* [in] */ BOOL fMove,
	/* [in] */ DWORD dwReplace,
	/* [in] */ BOOL fCheckAccess,
	/* [in] */ BOOL fCheckDestinationAccess,
	/* [in] */ CVRoot* pcvrTranslateDestination,
	/* [in] */ DWORD dwAcc,
	/* [in] */ CXMLEmitter& msr,
	/* [in] */ LONG lDepth,
	/* [in] */ CParseLockTokenHeader* plth)	// Usually NULL -- no locktokens to worry about
{
	BOOL fPartial = FALSE;
	SCODE sc = S_OK;

	//	Move/Copy the main body first
	//
	MCDTrace ("Dav: copying '%S' to '%S'\n", pwszSrc, pwszDst);
	sc = ScMoveCopyDirectory (pmu,
							  pwszUrl,
							  pwszSrc,
							  pwszUrlDst,
							  pwszDst,
							  fMove,
							  dwReplace,
							  fCheckAccess,
							  fCheckDestinationAccess,
							  dwAcc,
							  NULL, // translations are pmu based
							  pcvrTranslateDestination,
							  msr,
							  lDepth,
							  plth);
	if (!FAILED (sc) && (lDepth != DEPTH_ZERO))
	{
		Assert (lDepth == DEPTH_INFINITY);

		//	Enumerate the child vroots and perform the
		//	deletion of those directories as well
		//
		ChainedStringBuffer<WCHAR> sb;
		CVRList vrl;
		UINT cchUrl = static_cast<UINT>(wcslen (pwszUrl));
		UINT cchDstUrl = static_cast<UINT>(wcslen (pwszUrlDst));
		UINT cchDstPath = static_cast<UINT>(wcslen (pwszDst));

		//	Cleanup the list such that our namespaces are in
		//	a reasonable order.
		//
		(void) pmu->ScFindChildVRoots (pwszUrl, sb, vrl);
		vrl.sort();

		for ( ; !FAILED(sc) && !vrl.empty(); vrl.pop_front())
		{
			auto_ref_ptr<CVRoot> pcvrDst;
			auto_ref_ptr<CVRoot> pcvrSrc;
			CResourceInfo cri;
			CStackBuffer<WCHAR,128> pwszChildDstT;
			LPCWSTR pwszChildDst;
			LPCWSTR pwszChildPath;
			LPCWSTR pwszChildUrl;
			SCODE scItem;
			UINT cchVRoot;

			//	Remember any partial returns
			//
			if (W_DAV_PARTIAL_SUCCESS == sc)
				fPartial = TRUE;

			if (pmu->FGetChildVRoot (vrl.front().m_pwsz, pcvrSrc))
			{
				Assert (fCheckAccess);
				cchVRoot = pcvrSrc->CchGetVRoot (&pwszChildUrl);
				sc = ScCheckMoveCopyDeleteAccess (pmu,
												  pwszChildUrl,
												  pcvrSrc.get(),
												  TRUE, // directory
												  TRUE, // check scriptmaps
												  dwAcc,
												  &scItem,
												  msr);
				if (FAILED (sc))
					goto ret;

				//	If things were not 100%, don't process this resource
				//
				if (S_OK != sc)
					continue;

				//	We now have to figure out how we can really do this!
				//
				//	The source path and url bits are easy.  The destination
				//	path, on the other hand, is a pain.  It is the original
				//	destination root with the delta between the source root
				//	and the child's url path.  Huh?
				//
				//	Ok, here is an example:
				//
				//		Source url:		/misc
				//		Source root:	c:\inetpub\wwwroot\misc
				//		Dest. root:		c:\inetpub\wwwroot\copy
				//
				//		Child url:		/misc/blah
				//
				//	In this example the childs, destination path would need to
				//	be:
				//
				//		Child dest.:	c:\inetpub\wwwroot\copy\blah
				//
				//$	REVIEW:
				//
				//	And the real pain here is that the child path could already
				//	exist, but not match the namespace path.  I am not too sure
				//	how to handle that eventuality at this point.
				//
				Assert (cchUrl < cchVRoot);
				//
				//	Construct the new destination url
				//
				UINT cchDest = cchVRoot - cchUrl + cchDstUrl + 1;
				CStackBuffer<WCHAR,128> pwszChildUrlDst;
				if (NULL == pwszChildUrlDst.resize(CbSizeWsz(cchDest)))
				{
					sc = E_OUTOFMEMORY;
					goto ret;
				}
				memcpy (pwszChildUrlDst.get(), pwszUrlDst, cchDstUrl * sizeof(WCHAR));
				memcpy (pwszChildUrlDst.get() + cchDstUrl, pwszChildUrl + cchUrl, (1 + cchDest - cchDstUrl) * sizeof(WCHAR));

				if (fCheckDestinationAccess)
				{
					sc = ScCheckMoveCopyDeleteAccess (pmu,
													  pwszChildUrlDst.get(),
													  pcvrSrc.get(),
													  TRUE, // directory
													  TRUE, // check scriptmap on dest
													  MD_ACCESS_WRITE,
													  &scItem,
													  msr);
					if (FAILED (sc))
						goto ret;

					//	If things were not 100%, don't process this resource
					//
					if (S_OK != sc)
						continue;
				}

				//	And now that we have perfomed the forbidden dance... we
				//	have to go back and see if the destination url actually
				//	refers to a new child virtual root as well.
				//
				if (pmu->FFindVRootFromUrl (pwszChildUrlDst.get(), pcvrDst))
				{
					MCDTrace ("Dav: MCD: destination url maps to virtual root\n");

					//	Access checking, as always is handled in ScCheckM/C/DAccess()
					//	So all we need to do here is setup the destination path
					//
					pcvrDst->CchGetVRPath (&pwszChildDst);
				}
				else
				{
					//	We actually need to construct a physical path from
					//	the url and current destination path.
					//
					cchDest = cchDstPath + cchVRoot - cchUrl + 1;
					if (NULL == pwszChildDstT.resize(CbSizeWsz(cchDest)))
					{
						sc = E_OUTOFMEMORY;
						goto ret;
					}
					memcpy (pwszChildDstT.get(), pwszDst, cchDstPath * sizeof(WCHAR));
					memcpy (pwszChildDstT.get() + cchDstPath, pwszChildUrl + cchUrl, (cchVRoot - cchUrl) * sizeof(WCHAR));
					pwszChildDstT[cchDstPath + cchVRoot - cchUrl] = L'\0';

					//	We also now need to rip through the trailing part of the
					//	path one more time, translating all '/' to '\\' as we go.
					//
					for (WCHAR* pwch = pwszChildDstT.get() + cchDstPath;
						 NULL != (pwch = wcschr (pwch, L'/'));
						 )
					{
						*pwch++ = L'\\';
					}

					pwszChildDst = pwszChildDstT.get();
				}

				//	Well, now we should be able to continue the MOVE/COPY
				//
				pcvrSrc->CchGetVRPath (&pwszChildPath);
				sc = ScMoveCopyDirectory (pmu,
										  pwszChildUrl,
										  pwszChildPath,
										  pwszChildUrlDst.get(),
										  pwszChildDst,
										  fMove,
										  dwReplace,
										  fCheckAccess,
										  fCheckDestinationAccess,
										  dwAcc,
										  pcvrSrc.get(),
										  pcvrDst.get(),
										  msr,
										  DEPTH_INFINITY,
										  plth);
				if (FAILED (sc))
				{
					sc = ScAddMultiFromUrl (msr,
											pmu,
											pwszChildUrl,
											HscFromHresult(sc),
											TRUE); // We know it's a directory
					if (FAILED (sc))
						goto ret;

					sc = W_DAV_PARTIAL_SUCCESS;
				}
			}
		}
	}

ret:
	return ((S_OK == sc) && fPartial) ? W_DAV_PARTIAL_SUCCESS : sc;
}

//	Move/Copy -----------------------------------------------------------------
//
void
MoveCopyResource (LPMETHUTIL pmu, DWORD dwAccRequired, BOOL fDeleteSrc)
{
	auto_ptr<CParseLockTokenHeader> plth;
	auto_ref_ptr<CXMLBody> pxb;
	auto_ref_ptr<CXMLEmitter> pxml;
	BOOL fCheckDestination = FALSE;
	BOOL fCheckSource = FALSE;
	BOOL fCreateNew = TRUE;
	BOOL fDestinationExists = TRUE; // IMPORTANT: assume exists for location header processing
	CResourceInfo criDst;
	CResourceInfo criSrc;
	CStackBuffer<WCHAR> pwszMBPathDst;
	CStackBuffer<WCHAR> pwszMBPathSrc;
	CVRoot* pcvrDestination;
	DWORD dwAccDest = MD_ACCESS_WRITE;
	DWORD dwReplace = 0;
	LONG lDepth;
	LPCWSTR pwsz;
	LPCWSTR pwszDst = NULL;
	LPCWSTR pwszDstUrl = NULL;
	LPCWSTR pwszSrc = pmu->LpwszPathTranslated();
	LPCWSTR pwszSrcUrl = pmu->LpwszRequestUrl();
	SCODE sc = S_OK;
	SCODE scDest = S_OK;
	UINT cch;
	UINT uiErrorDetail = 0;

	//	We don't know if we'll have chunked XML response, defer response anyway
	//
	pmu->DeferResponse();

	//	Create an XML doc, NOT chunked
	//
	pxb.take_ownership (new CXMLBody(pmu));
	pxml.take_ownership (new CXMLEmitter(pxb.get()));

	//	Must set all headers before XML emitting starts
	//
	pmu->SetResponseHeader (gc_szContent_Type, gc_szText_XML);
	pmu->SetResponseCode (HscFromHresult(W_DAV_PARTIAL_SUCCESS),
						  NULL,
						  0,
						  CSEFromHresult(W_DAV_PARTIAL_SUCCESS));

	//	Do ISAPI application and IIS access bits checking on source
	//
	sc = pmu->ScIISCheck (pmu->LpwszRequestUrl(), dwAccRequired);
	if (FAILED(sc))
	{
		//	Either the request has been forwarded, or some bad error occurred.
		//	In either case, quit here and map the error!
		//
		MCDTrace ("Dav: Move/Copy: insufficient access\n");
		goto ret;
	}

	//	If there's no valid destination header, it's a bad request.
	//
	//	NOTE: we are asking for the translated url's virtual root if
	//	it exists.  The ECB holds the reference for us, so we do not
	//	add one or release the one we have!
	//
	sc = pmu->ScGetDestination (&pwszDstUrl, &pwszDst, &cch, &pcvrDestination);
	if (FAILED (sc))
	{
		MCDTrace ("Dav: Move/Copy: no and/or bad destination header\n");
		if (sc != E_DAV_NO_DESTINATION)
		{
			Assert (pwszDstUrl);
			sc = ScAddMultiFromUrl (*pxml,
									pmu,
									pwszDstUrl,
									HscFromHresult(sc),
									FALSE); // do not check for trailing slash
			if (!FAILED (sc))
				sc = W_DAV_PARTIAL_SUCCESS;
		}
		goto ret;
	}

	//	Get the file attributes for the passed in URI.  If it aint there, then
	//	don't do jack!
	//
	sc = criSrc.ScGetResourceInfo (pwszSrc);
	if (FAILED (sc))
		goto ret;

	//	Get the metabase for the source and destination for later use
	//
	if ((NULL == pwszMBPathSrc.resize(pmu->CbMDPathW(pwszSrcUrl))) ||
		(NULL == pwszMBPathDst.resize(pmu->CbMDPathW(pwszDstUrl))))
	{
		sc = E_OUTOFMEMORY;
		goto ret;
	}
	pmu->MDPathFromUrlW (pwszSrcUrl, pwszMBPathSrc.get());
	pmu->MDPathFromUrlW (pwszDstUrl, pwszMBPathDst.get());

	//	Get the resource info for the destination up front
	//
	sc = criDst.ScGetResourceInfo (pwszDst);
	if (FAILED (sc))
	{
		MCDTrace ("Dav: Move/Copy: destination probably did not exist prior to op\n");

		//	The destination may or may not exist.  We will just act like
		//	it doesn't.  However, if we don't have access, then we want to
		//	stick the error into a 207 body.
		//
		fDestinationExists = FALSE;
		if ((HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == sc))
		{
			sc = ScAddMultiFromUrl (*pxml,
									pmu,
									pwszDstUrl,
									HscFromHresult(sc),
									FALSE); // do not check for trailing slash
			if (!FAILED (sc))
				sc = W_DAV_PARTIAL_SUCCESS;

			goto ret;
		}
	}

	//	Again, emit all the headers before XML chunking starts
	//
	if (!fDestinationExists)
	{
		Assert (pxml->PxnRoot() == NULL);

		//$NOTE	At this time, we have only the destination URL, the destination
		//$NOTE is not created yet, but we do know whether it will be created
		//$NOTE as a collection by looking at the source
		//
		pmu->EmitLocation (gc_szLocation, pwszDstUrl, criSrc.FCollection());
	}

	//$	SECURITY:
	//
	//	Check to see if the destination is really a short
	//	filename.
	//
	sc = ScCheckIfShortFileName (pwszDst, pmu->HitUser());
	if (FAILED (sc))
	{
		DebugTrace ("Dav: MCD: destination is short-filename\n");
		sc = ScAddMultiFromUrl (*pxml,
								pmu,
								pwszDstUrl,
								HscFromHresult(sc),
								FALSE); // do not check for trailing slash
		if (!FAILED (sc))
			sc = W_DAV_PARTIAL_SUCCESS;

		goto ret;
	}
	//
	//$	SECURITY: end.

	//$	SECURITY:
	//
	//	Check to see if the destination is really the default
	//	data stream via alternate file access.
	//
	sc = ScCheckForAltFileStream (pwszDst);
	if (FAILED (sc))
	{
		DebugTrace ("Dav: MCD: destination is possible alternate filestream\n");
		sc = ScAddMultiFromUrl (*pxml,
								pmu,
								pwszDstUrl,
								HscFromHresult(sc),
								FALSE); // do not check for trailing slash
		if (!FAILED (sc))
			sc = W_DAV_PARTIAL_SUCCESS;

		goto ret;
	}
	//
	//$	SECURITY: end.

	//	See if we have move/copy access at destination
	//
	if (fDestinationExists && criDst.FCollection())
		dwAccDest |= MD_ACCESS_READ;

	sc = ScCheckMoveCopyDeleteAccess (pmu,
									  pwszDstUrl,
									  pcvrDestination,
									  fDestinationExists
										  ? criDst.FCollection()
										  : criSrc.FCollection(),
									  TRUE, // check scriptmaps on dest.
									  dwAccDest,
									  &scDest,
									  *pxml);
	if (sc != S_OK)
		goto ret;

	//	The client must not submit a depth header with any value
	//	but Infinity
	//
	lDepth = pmu->LDepth (DEPTH_INFINITY);
	if (DEPTH_INFINITY != lDepth)
	{
		if (fDeleteSrc || (DEPTH_ZERO != lDepth))
		{
			MCDTrace ("Dav: only 'Depth: inifinity' is allowed for MOVE\n"
					  "- 'Depth: inifinity' and 'Depth: 0' are allowed for COPY\n");
			sc = E_DAV_INVALID_HEADER;
			goto ret;
		}
	}

	//	See if there is a path conflict
	//
	if (FPathConflict (pwszSrc, pwszDst))
	{
		DebugTrace ("Dav: source and dest are in conflict\n");
		sc = E_DAV_CONFLICTING_PATHS;
		goto ret;
	}

	//	If we were to check either URI for correctness, the only
	//	real result would be to possibly emit a content-location
	//	header that would only be invalidated in the case of a
	//	successful move
	//
	if (!fDeleteSrc)
	{
		sc = ScCheckForLocationCorrectness (pmu, criSrc, NO_REDIRECT);
		if (FAILED (sc))
			goto ret;
	}

	//	This method is gated by If-xxx headers
	//
	sc = ScCheckIfHeaders (pmu, criSrc.PftLastModified(), FALSE);
	if (FAILED (sc))
		goto ret;

	//	Check state headers
	//
	sc = HrCheckStateHeaders (pmu, pwszSrc, FALSE);
	if (FAILED (sc))
	{
		DebugTrace ("DavFS: If-State checking failed.\n");
		goto ret;
	}

	//	If there are locktokens, feed them to a parser object.
	//
	pwsz = pmu->LpwszGetRequestHeader (gc_szLockToken, TRUE);
	if (pwsz)
	{
		plth = new CParseLockTokenHeader (pmu, pwsz);
		Assert(plth.get());

		plth->SetPaths (pwszSrc, pwszDst);
	}

	//	Check for deep access issues
	//
	//$	REVIEW: we wanted to be able to not have to check
	//	access at each level.  However, because of the semantics of
	//	MOVE/COPY, we have to check each source file for scriptmap
	//	access.  We cannot copy a file that has a scriptmap if the
	//	they do not have source access.
	//
	//	So we must always check the source of the MOVE/COPY operation.
	//
	fCheckSource = TRUE;
	//
	//$	REVIEW: end.
	//
	//	However, we still can try and be optimistic for the destination
	//
	if (NULL == pwszMBPathDst.resize(pmu->CbMDPathW(pwszDstUrl)))
	{
		sc = E_OUTOFMEMORY;
		goto ret;
	}
	pmu->MDPathFromUrlW (pwszDstUrl, pwszMBPathDst.get());
	if (fDestinationExists || (DEPTH_ONE != pmu->LDepth(DEPTH_INFINITY)))
	{
		CAccessMetaOp moAccess(pmu, pwszMBPathDst.get(), dwAccDest);
		CAuthMetaOp moAuth(pmu, pwszMBPathDst.get(), pmu->MetaData().DwAuthorization());
		CIPRestrictionMetaOp moIPRestriction(pmu, pwszMBPathDst.get());
		ChainedStringBuffer<WCHAR> sb;
		CVRList vrl;

		//	If we do not have access to COPY/MOVE or
		//	DELETE anything in the destination, then
		//	we really shouldn't blindly proceed.
		//
		sc = moAccess.ScMetaOp();
		if (FAILED (sc))
			goto ret;
		fCheckDestination |= moAccess.FAccessBlocked();

		if (!fCheckDestination)
		{
			//	If we do not have the same authorization anywhere along
			//	the destination as we do for the request url, then we
			//	really shouldn't blindly proceed.
			//
			sc = moAuth.ScMetaOp();
			if (FAILED (sc))
				goto ret;
			fCheckDestination |= moAuth.FAccessBlocked();
		}

		if (!fCheckDestination)
		{
			//	If we do not have the same authorization anywhere along
			//	the destination as we do for the request url, then we
			//	really shouldn't blindly proceed.
			//
			sc = moIPRestriction.ScMetaOp();
			if (FAILED (sc))
				goto ret;
			fCheckDestination |= moAuth.FAccessBlocked();
		}

		if (!fCheckDestination)
		{
			//	If there are any child virtual roots along
			//	the destination tree, there is some redirection
			//	that may need to happen as well.
			//
			(void) pmu->ScFindChildVRoots (pwszDstUrl, sb, vrl);
			fCheckDestination |= !vrl.empty();
		}
	}

	//	Determine if we are destructive or not.
	//
	if (pmu->LOverwrite() & OVERWRITE_YES)
	{
		dwReplace |= MOVEFILE_REPLACE_EXISTING;

		//	MoveFileEx does not seem to want to replace existing
		//	directories.. It returns E_ACCESS_DENIED so we delete
		//	the existing directory ourselves.
		//
		if (fDestinationExists)
		{
			BOOL fDeletedDestination;

			//	The destination exists already
			//
			fCreateNew = FALSE;

			//	If the destination is a directory, delete it.
			//
			if (criDst.FCollection())
			{
				//	Otherwise, go ahead and delete the directory currently at dest.
				//
				sc = ScDeleteDirectoryAndChildren (pmu,
												   pwszDstUrl,
												   pwszDst,
												   fCheckDestination,
												   dwAccDest,
												   DEPTH_INFINITY,
												   *pxml,
												   pcvrDestination,
												   &fDeletedDestination,
												   plth.get(),	// DO use locktokens, if any exist.
												   FALSE);		// Do NOT drop locks.  Just skip them.
				if (sc != S_OK)
				{
					DebugTrace("DavFS: MOVE failed to pre-delete destination directory.\n");
					goto ret;
				}
			}
			else
			{
				//	If the destination is locked (ERROR_SHARING_VIOLATION),
				//	DO NOT catch it here.  We'll handle it below....
				//
				if (!DavDeleteFile (pwszDst))
				{
					DWORD dw = GetLastError();
					if (ERROR_ACCESS_DENIED == dw)
					{
						sc = HRESULT_FROM_WIN32(dw);
						goto ret;
					}
				}
			}
		}
	}

	//	Do the move/copy.  If the operation is either a move, or the source
	//	is a collection, then call out to do the diry work.
	//
	MCDTrace ("DavFS: MCD: moving copying '%S' to '%S'\n", pwszSrc, pwszDst);
	if (criSrc.FCollection())
	{
		sc = ScMoveCopyDirectoryAndChildren (pmu,
											 pwszSrcUrl,
											 pwszSrc,
											 pwszDstUrl,
											 pwszDst,
											 fDeleteSrc,
											 dwReplace,
											 fCheckSource,
											 fCheckDestination,
											 pcvrDestination,
											 dwAccRequired,
											 *pxml,
											 lDepth,
											 plth.get());
		if (FAILED (sc))
			goto ret;
	}
	else
	{
		//	Well this should be the move/copy of a single file
		//
		if (!fDeleteSrc || !DavMoveFile (pwszSrc, pwszDst, dwReplace))
		{
			if (!DavCopyFile (pwszSrc, pwszDst, (0 == dwReplace)))
			{
				DWORD dw = GetLastError();
				DebugTrace ("Dav: failed to copy file\n");

				//	If it's a sharing violation (lock-caused error),
				//	AND we have a locktoken parser (plth), handle the copy.
				//
				if ((ERROR_SHARING_VIOLATION == dw) && plth.get())
				{
					//	Check if any locktokens apply to these file,
					//	and try the copy using the locks from the cache.
					//
					sc = ScDoLockedCopy (pmu, plth.get(), pwszSrc, pwszDst);
				}
				else
				{
					if ((dw == ERROR_FILE_EXISTS) ||
						(dw == ERROR_ALREADY_EXISTS))
					{
						sc = E_DAV_OVERWRITE_REQUIRED;
					}
					else
						sc = HRESULT_FROM_WIN32(dw);
				}

				//	If the file-manual-move failed, we'll hit here.
				//
				if (FAILED (sc))
				{
					DebugTrace("Dav: MCD: move/copy failed. Looking for lock conflicts.\n");

					//	Special work for '423 Locked' responses -- fetch the
					//	comment & set that as the response body.
					//
					if (FLockViolation (pmu, sc, pwszSrc,
										GENERIC_READ | GENERIC_WRITE))
					{
						sc = E_DAV_LOCKED;
						goto ret;
					}
					else
					{
						//	Test the destination too.
						//	However, if the dest is locked, do NOT add
						//	the lockinfo as the body -- we have to list the dest
						//	URI as the problem, so we need to have a multi-status
						//	body, and we put a plain 423 Locked node under there.
						//	(NOTE: Yes, this means we can't use FLockViolation.
						//	Instead, we have to check "by hand".)
						//

						if (CSharedLockMgr::Instance().FGetLockOnError (
							pmu,
							pwszDst,
							GENERIC_READ | GENERIC_WRITE))
						{
							sc = ScAddMultiFromUrl (*pxml,
													pmu,
													pwszDstUrl,
													HscFromHresult(E_DAV_LOCKED),
													FALSE);	//	We know it's not a directory
							if (!FAILED (sc))
								sc = W_DAV_PARTIAL_SUCCESS;

							goto ret;
						}
					}
				}
			} // end !DavCopyFile
			if (SUCCEEDED(sc) && fDeleteSrc)
			{
				//	Delete the source file by hand.
				//	(fDeleteSrc means this is a MOVE, not a COPY.)
				//
				//	Move the content-types only if the source is
				//	deleted, otherwise treat it as a copy the of
				//	the content-type
				//
				if (!DavDeleteFile (pwszSrc))
				{
					DWORD dw;
					dw = GetLastError();
					DebugTrace ("Dav: failed to delete file (%d)\n", dw);

					//	If it's a sharing (lock) violation, AND we have a
					//	locktoken for this path (lth.GetToken(pwsz))
					//	skip this path.
					//
					if ((ERROR_SHARING_VIOLATION == dw) && plth)
					{
						__int64 i64;

						//	If we have a locktoken for this path, drop
						//	the lock and try to delete the source again.
						//
						if (SUCCEEDED(plth->HrGetLockIdForPath (pwszSrc,
																GENERIC_WRITE,
																&i64)))
						{
							Assert (i64);

							//	This item is locked in our cache.
							//	We are doing a MOVE, so DO delete the lock
							//	and try again.
							//
							(void)FDeleteLock (pmu, i64);

							//	Try the delete again, and set/clear our error
							//	code for testing below.
							//	This error code will control whether we
							//	add this error to our XML.
							//
							if (DavDeleteFile(pwszSrc))
							{
								dw = ERROR_SUCCESS;
							}
							else
							{
								dw = GetLastError();
							}
						}
						//	else, record the error in our XML.
						//
					}

					if (ERROR_SUCCESS != dw)
					{
						//	We could not work around all the errors.
						//	Add this failure to the XML.
						//
						sc = ScAddMultiFromUrl (*pxml,
												pmu,
												pwszSrcUrl,
												HscFromLastError(dw),
												FALSE);	//	We know it's not a directory
						if (FAILED (sc))
							goto ret;

						//	It is partial sucess if we are here. And do not fail out
						//	yet as we still need to take care of content types.
						//
						sc = W_DAV_PARTIAL_SUCCESS;
					}
				}
			}
		}
	}

	//	Now that we're done mucking around in the filesystem,
	//	muck around in the metabase.
	//	(Delete any destination content-types, then copy/move
	//	the source content-types on over.)
	//

	//	Delete the content-types for the destination
	//
	{
		Assert (pwszMBPathDst.get());
		CContentTypeMetaOp amoContent(pmu, pwszMBPathDst.get(), NULL, TRUE);
		(void) amoContent.ScMetaOp();
	}

	//	Move/copy the content-type
	//
	//$	REVIEW: I am not so sure what can be done when this fails
	//
	{
		Assert (pwszMBPathDst.get());

		//	Only delete the source content-types if everything has been 100%
		//	successfull up to this point.
		//
		CContentTypeMetaOp amoContent(pmu,
									  pwszMBPathSrc.get(),
									  pwszMBPathDst.get(),
									  (fDeleteSrc && (S_OK == sc)));
		(void) amoContent.ScMetaOp ();
	}
	//
	//$	REVIEW: end.

ret:
	if (pxml.get() && pxml->PxnRoot())
	{
		pxml->Done();

		//	No more header can be sent after XML chunking started
	}
	else
	{
		if (SUCCEEDED (sc))
			sc = fCreateNew ? W_DAV_CREATED : W_DAV_NO_CONTENT;

		pmu->SetResponseCode (HscFromHresult(sc), NULL, uiErrorDetail, CSEFromHresult(sc));
	}

	pmu->SendCompleteResponse();
}

/*
 *	DAVMove()
 *
 *	Purpose:
 *
 *		Win32 file system implementation of the DAV MOVE method.  The
 *		MOVE method results in the moving of a resource from one location
 *		to another.	 The response is used to indicate the success of the
 *		call.
 *
 *	Parameters:
 *
 *		pmu			[in]  pointer to the method utility object
 *
 *	Notes:
 *
 *		In the file system implementation, the MOVE method maps directly
 *		to the Win32 RenameFile() method.
 */
void
DAVMove (LPMETHUTIL pmu)
{
	MoveCopyResource (pmu,
					  MD_ACCESS_READ|MD_ACCESS_WRITE,	// src access required
					  TRUE);							// fDeleteSource
}

/*
 *	DAVCopy()
 *
 *	Purpose:
 *
 *		Win32 file system implementation of the DAV COPY method.  The
 *		COPY method results in the copying of a resource from one location
 *		to another.	 The response is used to indicate the success of the
 *		call.
 *
 *	Parameters:
 *
 *		pmu			[in]  pointer to the method utility object
 *
 *	Notes:
 *
 *		In the file system implementation, the COPY method maps directly
 *		to the Win32 CopyFile() API for a single file.  Directory copies
 *		are done via a custom process.
 */
void
DAVCopy (LPMETHUTIL pmu)
{
	MoveCopyResource (pmu,
					  MD_ACCESS_READ,	// src access required
					  FALSE);			// fDeleteSource
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\fsnoimpl.cpp ===
/*
 *	F S N O I M P L . C P P
 *
 *	Sources file system implementation of DAV-Base
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved 
 */

//$IMPORTANT
//	This file is to be deleted after we seperate the request table
//	from common code.
//	The following methods are not for httpext at all, however
//	it must be implemented as "not implemented" within current structure
//
#include "_davfs.h"

/*
 * 	SUBSCRIBE, UNSUBSCRIBE and POLL are not supported in httpext 
 */
void
DAVSubscribe (LPMETHUTIL pmu)
{
	//	DAVPost() is really an unknown/unsupported method
	//	at this point...
	//
	DAVUnsupported (pmu);
}

void
DAVUnsubscribe (LPMETHUTIL pmu)
{
	//	DAVPost() is really an unknown/unsupported method
	//	at this point...
	//
	DAVUnsupported (pmu);
}

void
DAVPoll (LPMETHUTIL pmu)
{
	//	DAVPost() is really an unknown/unsupported method
	//	at this point...
	//
	DAVUnsupported (pmu);
}

void
DAVBatchMove (LPMETHUTIL pmu)
{
	//	DAVBatchMove() is really an unknown/unsupported method
	//	at this point...
	//
	DAVUnsupported (pmu);
}

void
DAVBatchCopy (LPMETHUTIL pmu)
{
	//	DAVBatchCopy() is really an unknown/unsupported method
	//	at this point...
	//
	DAVUnsupported (pmu);
}

void
DAVBatchDelete (LPMETHUTIL pmu)
{
	//	DAVBatchDelete() is really an unknown/unsupported method
	//	at this point...
	//
	DAVUnsupported (pmu);
}

void
DAVBatchPropFind (LPMETHUTIL pmu)
{
	//	DAVBatchPropFind() is really an unknown/unsupported method
	//	at this point...
	//
	DAVUnsupported (pmu);
}

void
DAVBatchPropPatch (LPMETHUTIL pmu)
{
	//	DAVBatchPropPatch() is really an unknown/unsupported method
	//	at this point...
	//
	DAVUnsupported (pmu);
}

void
DAVEnumAtts (LPMETHUTIL pmu)
{
	//	DAVEnumAtts() is really an unknown/unsupported method
	//	at this point...
	//
	DAVUnsupported (pmu);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\fsput.cpp ===
/*
 *	F S P U T . C P P
 *
 *	Copyright 1986-1998 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"


//	========================================================================
//
//	CLASS CPutRequest
//
//	Encapsulates the entire PUT request as an object which can be
//	can be reentered at various points for asynchronous processing.
//
class CPutRequest :
	public CMTRefCounted,
	private IAsyncStream,
	private IAsyncPersistObserver,
	private CDavWorkContext
{
	//
	//	Reference to the CMethUtil
	//
	auto_ref_ptr<CMethUtil> m_pmu;

	//
	//	Cached request URI
	//
	LPCWSTR m_pwszURI;

	//
	//	Cached translated URI
	//
	LPCWSTR m_pwszPath;

	//
	//	File handle of target.
	//
	auto_ref_handle m_hf;

	//
	//	Boolean flag indicating whether the file is being created
	//	as a result of this PUT.  Used to tell whether we need
	//	to delete the file on failure as well as determine
	//	whether to send back a 200 OK or a 201 Created response.
	//
	BOOL m_fCreatedFile;

	//
	//	OVERLAPPED structure with file pointer info necessary
	//	for async file I/O
	//
	OVERLAPPED m_ov;

	//
	//	Minimum number of milliseconds between polls for WriteFile()
	//	I/O completion.  This number increases geometrically by a factor
	//	(below) to minimize polling by worker threads.
	//
	DWORD m_dwMsecPollDelay;

	//
	//	Initial poll delay (in milliseconds) and factor by which
	//	that delay is increased each we poll and find that the
	//	I/O has not completed.  The factor is expressed as a
	//	fraction: POLL_DELAY_NUMERATOR/POLL_DELAY_DENOMINATOR.
	//	Note that the new value is computed using integer arithmetic
	//	so choose values such that the delay will actually increase!
	//
	//$OPT	Are these values optimal?  Ideally, we want the
	//$OPT	first poll to happen immediately after the I/O
	//$OPT	completes.
	//
	enum
	{
		MSEC_POLL_DELAY_INITIAL = 10,
		POLL_DELAY_NUMERATOR = 2,
		POLL_DELAY_DENOMINATOR = 1
	};

	//
	//	Number of bytes written in the last write operation.
	//
	DWORD m_dwcbWritten;

	//
	//	Observer passed to AsyncWrite() to notify when the
	//	write completes.
	//
	IAsyncWriteObserver * m_pobs;

	//
	//	Status
	//
	SCODE m_sc;

	//	MANIPULATORS
	//
	VOID SendResponse();

	VOID AsyncWrite( const BYTE * pbBuf,
					 UINT         cbToWrite,
					 IAsyncWriteObserver& obsAsyncWrite );

	VOID PostIOCompletionPoll();

	//	CDavWorkContext callback called to poll for I/O completion
	//
	DWORD DwDoWork();

	VOID WriteComplete();

	VOID PersistComplete( HRESULT hr );

	//	NOT IMPLEMENTED
	//
	CPutRequest& operator=( const CPutRequest& );
	CPutRequest( const CPutRequest& );

public:
	//	CREATORS
	//
	CPutRequest( CMethUtil * pmu ) :
		m_pmu(pmu),
		m_pwszURI(pmu->LpwszRequestUrl()),
		m_pwszPath(pmu->LpwszPathTranslated()),
		m_fCreatedFile(FALSE),
		m_pobs(NULL),
		m_sc(S_OK)
	{
		m_ov.hEvent = NULL;
		m_ov.Offset = 0;
		m_ov.OffsetHigh = 0;
	}

	~CPutRequest()
	{
		if ( m_ov.hEvent )
			CloseHandle( m_ov.hEvent );
	}

	//	MANIPULATORS
	//
	void AddRef() { CMTRefCounted::AddRef(); }
	void Release() { CMTRefCounted::Release(); }
	VOID Execute();
};

//	------------------------------------------------------------------------
//
//	CPutRequest::Execute()
//
//	Process the request up to the point where we persist the body.
//
VOID
CPutRequest::Execute()
{
	LPCWSTR pwsz;


	PutTrace( "DAV: TID %3d: 0x%08lX: CPutRequest::Execute() called\n", GetCurrentThreadId(), this );

	//
	//	First off, tell the pmu that we want to defer the response.
	//	Even if we send it synchronously (i.e. due to an error in
	//	this function), we still want to use the same mechanism that
	//	we would use for async.
	//
	m_pmu->DeferResponse();

	//	Do ISAPI application and IIS access bits checking
	//
	m_sc = m_pmu->ScIISCheck (m_pwszURI, MD_ACCESS_WRITE);
	if (FAILED(m_sc))
	{
		//	Either the request has been forwarded, or some bad error occurred.
		//	In either case, quit here and map the error!
		//
		DebugTrace( "Dav: ScIISCheck() failed (0x%08lX)\n", m_sc );
		SendResponse();
		return;
	}

	//	From the HTTP/1.1 draft (update to RFC2068), Section 9.6:
	//		The recipient of the entity MUST NOT ignore any Content-*
	//		(e.g. Content-Range) headers that it does not understand
	//		or implement and MUST return a 501 (Not Implemented) response
	//		in such cases.
	//	So, let's do the checking....
	//
	if (m_pmu->LpwszGetRequestHeader(gc_szContent_Range, FALSE))
	{
		m_sc = E_DAV_NO_PARTIAL_UPDATE;	// 501 Not Implemented
		SendResponse();
		return;
	}

	//	For PUT, content-length is required
	//
	if (NULL == m_pmu->LpwszGetRequestHeader (gc_szContent_Length, FALSE))
	{
		pwsz = m_pmu->LpwszGetRequestHeader (gc_szTransfer_Encoding, FALSE);
		if (!pwsz || _wcsicmp (pwsz, gc_wszChunked))
		{
			DavTrace ("Dav: PUT: missing content-length in request\n");
			m_sc = E_DAV_MISSING_LENGTH;
			SendResponse();
			return;
		}
	}

	//	See if we are trying to trash the VROOT
	//
	if (m_pmu->FIsVRoot (m_pwszURI))
	{
		m_sc = E_DAV_PROTECTED_ENTITY;
		SendResponse();
		return;
	}

	//	This method is gated by If-xxx headers
	//
	m_sc = ScCheckIfHeaders (m_pmu.get(), m_pwszPath, FALSE);
	if (m_sc != S_OK)
	{
		DebugTrace ("Dav: If-xxx failed their check\n");
		SendResponse();
		return;
	}

	//	Check state headers.
	//
	m_sc = HrCheckStateHeaders (m_pmu.get(), m_pwszPath, FALSE);
	if (FAILED (m_sc))
	{
		DebugTrace ("DavFS: If-State checking failed.\n");
		SendResponse();
		return;
	}

	//	If we have a locktoken, try to get the lock handle from the cache.
	//	If this fails, fall through and do the normal processing.
	//	DO NOT put LOCK handles into an auto-object!!  The CACHE still owns it!!!
	//
	pwsz = m_pmu->LpwszGetRequestHeader (gc_szLockToken, TRUE);
	if (!pwsz || !FGetLockHandle (m_pmu.get(),
								  m_pwszPath,
								  GENERIC_WRITE,
								  pwsz,
								  &m_hf))
	{
		//	Open the file manually.
		//
		if (!m_hf.FCreate(
				DavCreateFile (m_pwszPath,							// filename
							   GENERIC_WRITE,						// dwAccess
							   0, //FILE_SHARE_READ | FILE_SHARE_WRITE,	// DO conflict with OTHER write locks
							   NULL,									// lpSecurityAttributes
							   OPEN_ALWAYS,							// creation flags
							   FILE_ATTRIBUTE_NORMAL |				// attributes
							   FILE_FLAG_OVERLAPPED |
							   FILE_FLAG_SEQUENTIAL_SCAN,
							   NULL)))								// template
		{
			DWORD dwErr = GetLastError();

			//	Return 409 Conflict in the case we were told that
			//	path was not found, that will indicate that the parent
			//	does not exist
			//
			if (ERROR_PATH_NOT_FOUND == dwErr)
			{
				m_sc = E_DAV_NONEXISTING_PARENT;
			}
			else
			{
				m_sc = HRESULT_FROM_WIN32(dwErr);
			}

			//	Special work for 416 Locked responses -- fetch the
			//	comment & set that as the response body.
			//
			if (FLockViolation (m_pmu.get(), dwErr, m_pwszPath, GENERIC_WRITE))
			{
				m_sc = E_DAV_LOCKED;
			}
			else
			{
				DWORD	dwFileAttr;

				//$Raid
				//	Special processing to find out if the resource is an
				//	existing directory
				//
				if (static_cast<DWORD>(-1) != (dwFileAttr = GetFileAttributesW (m_pwszPath)))
				{
					if (dwFileAttr & FILE_ATTRIBUTE_DIRECTORY)
						m_sc = E_DAV_COLLECTION_EXISTS;
				}
			}

			DebugTrace ("Dav: failed to open the file for writing\n");
			SendResponse();
			return;
		}

		//	Change the default error code to indicate the
		//	creation of the file or the existance of the file.
		//
		if (GetLastError() != ERROR_ALREADY_EXISTS)
		{
			//	Emit the location
			//
			m_pmu->EmitLocation (gc_szLocation, m_pwszURI, FALSE);
			m_fCreatedFile = TRUE;
		}
		//	Make sure the content-location reflects the corrected URI
		//
		else if (FTrailingSlash (m_pwszURI))
			m_pmu->EmitLocation (gc_szContent_Location, m_pwszURI, FALSE);
	}

	//
	//	Add a ref for the async persist and sloughf the data across.
	//	Note that we use an auto_ref_ptr rather than AddRef() directly
	//	because the persist call throws on failure and we need to clean
	//	up the reference if it does.
	//
	{
		auto_ref_ptr<CPutRequest> pRef(this);

		PutTrace( "DAV: TID %3d: 0x%08lX: CPutRequest::Execute() calling AsyncPersistRequestBody()\n", GetCurrentThreadId(), this );

		m_pmu->AsyncPersistRequestBody( *this, *this );

		pRef.relinquish();
	}
}

//	------------------------------------------------------------------------
//
//	CPutRequest::AsyncWrite()
//
//	Called indirectly from AsyncPersistRequestBody() periodically to
//	write bytes to the file.
//
void
CPutRequest::AsyncWrite( const BYTE * pbBuf,
						 UINT         cbToWrite,
						 IAsyncWriteObserver& obs )
{
	PutTrace( "DAV: TID %3d: 0x%08lX: CPutRequest::AsyncWrite() writing %d bytes\n", GetCurrentThreadId(), this, cbToWrite );

	//
	//	Stash the async write observer passed to us so that
	//	we can call it when the write completes
	//
	m_pobs = &obs;

	//
	//	Start writing.  I/O may complete before WriteFile() returns
	//	in which case we continue to execute synchronously.  If I/O
	//	is pending when WriteFile() returns, we complete the I/O
	//	asynchronously.
	//
	if ( WriteFile( m_hf.get(),
					pbBuf,
					cbToWrite,
					&m_dwcbWritten,
					&m_ov ) )
	{
		PutTrace( "DAV: TID %3d: 0x%08lX: CPutRequest::AsyncWrite(): WriteFile() succeeded\n", GetCurrentThreadId(), this );

		//
		//	WriteFile() executed synchronously, so call
		//	the completion routine now and keep processing
		//	on the current thread.
		//
		WriteComplete();
	}
	else if ( ERROR_IO_PENDING == GetLastError() )
	{
		PutTrace( "DAV: TID %3d: 0x%08lX: CPutRequest::AsyncWrite(): WriteFile() executing asynchronously...\n", GetCurrentThreadId(), this );

		//
		//	Set the polling delay to its initial value.  The polling delay
		//	is the amount of time before we'll check for I/O completion.
		//	As described in the CPutRequest class definition, this delay
		//	grows geometrically each time that the I/O is still pending
		//	when polled.  The value is only a hint -- polling may actually
		//	execute before or after, depending on server load.
		//
		m_dwMsecPollDelay = MSEC_POLL_DELAY_INITIAL;

		//
		//	WriteFile() is executing asynchronously, so make sure we
		//	find out when it completes.
		//
		PostIOCompletionPoll();
	}
	else
	{
		DebugTrace( "CPutRequest::AsyncWrite() - WriteFile() failed (%d)\n", GetLastError() );
		m_sc = HRESULT_FROM_WIN32(GetLastError());
		WriteComplete();
	}
}

//	------------------------------------------------------------------------
//
//	CPutRequest::PostIOCompletionPoll()
//
//	Post a work context to poll for WriteFile() I/O completion.
//
VOID
CPutRequest::PostIOCompletionPoll()
{
	PutTrace( "DAV: TID %3d: 0x%08lX: CPutRequest::PostIOCompletionPoll() called\n", GetCurrentThreadId(), this );

	//
	//	Post ourselves as a work context that will periodically
	//	poll for async I/O completion.  If successful our DwDoWork()
	//	(inherited from CDAVWorkContext) will eventually be called
	//	at some time > m_dwMsecPollDelay to poll for completion.
	//
	{
		auto_ref_ptr<CPutRequest> pRef(this);

		if ( CPoolManager::PostDelayedWork(this, m_dwMsecPollDelay) )
		{
			PutTrace( "DAV: TID %3d: 0x%08lX: CPutRequest::PostIOCompletionPoll(): PostDelayedWork() succeeded\n", GetCurrentThreadId(), this );
			pRef.relinquish();
			return;
		}
	}

	//
	//	If we were unable to post the work context for any reason
	//	we must wait for I/O completion and then call the completion
	//	routine manually.
	//
	DebugTrace( "CPutRequest::PostIOCompletionPoll() - CPoolManager::PostDelayedWork() failed (%d).  Waiting for completion....\n", GetLastError() );
	if ( GetOverlappedResult( m_hf.get(), &m_ov, &m_dwcbWritten, TRUE ) )
	{
		PutTrace( "DAV: TID %3d: 0x%08lX: CPutRequest::PostIOCompletionPoll(): GetOverlappedResult() succeeded\n", GetCurrentThreadId(), this );
		WriteComplete();
		return;
	}

	DebugTrace( "CPutRequest::PostIOCompletionPoll() - GetOverlappedResult() failed (%d).\n", GetLastError() );
	m_sc = HRESULT_FROM_WIN32(GetLastError());
	SendResponse();
}

//	------------------------------------------------------------------------
//
//	CPutRequest::DwDoWork()
//
//	Work completion callback routine.  Called when the work context posted
//	above executes.
//
DWORD
CPutRequest::DwDoWork()
{
	PutTrace( "DAV: TID %3d: 0x%08lX: CPutRequest::DwDoWork() called\n", GetCurrentThreadId(), this );

	//
	//	Take ownership of the reference added for posting.
	//
	auto_ref_ptr<CPutRequest> pRef;
	pRef.take_ownership(this);

	//
	//	Quickly check whether the I/O has completed.  If it has,
	//	then call the completion routine.  If not, then repost
	//	the polling context with a geometrically longer delay.
	//
	if ( HasOverlappedIoCompleted(&m_ov) )
	{
		PutTrace( "DAV: TID %3d: 0x%08lX: CPutRequest::DwDoWork(): Overlapped I/O complete\n", GetCurrentThreadId(), this );

		if ( !GetOverlappedResult( m_hf.get(),
								   &m_ov,
								   &m_dwcbWritten,
								   FALSE ) )
		{
			DebugTrace( "CPutRequest::DwDoWork() - Error in overlapped I/O (%d)\n", GetLastError() );
			m_sc = HRESULT_FROM_WIN32(GetLastError());
		}

		WriteComplete();
	}
	else
	{
		m_dwMsecPollDelay = (m_dwMsecPollDelay * POLL_DELAY_NUMERATOR) / POLL_DELAY_DENOMINATOR;

		PutTrace( "DAV: TID %3d: 0x%08lX: CPutRequest::DwDoWork(): I/O still pending.  Increasing delay to %lu msec.\n", GetCurrentThreadId(), this, m_dwMsecPollDelay );

		PostIOCompletionPoll();
	}

	return 0;
}

//	------------------------------------------------------------------------
//
//	CPutRequest::WriteComplete()
//
//	Called when WriteFile() I/O completes -- either synchronously or
//	asynchronously, with or without an error.
//
void
CPutRequest::WriteComplete()
{
	PutTrace( "DAV: TID %3d: 0x%08lX: CPutRequest::WriteComplete() called.  %d bytes written\n", GetCurrentThreadId(), this, m_dwcbWritten );

	//
	//	If there was an error, then gripe about it.
	//
	if ( FAILED(m_sc) )
		DebugTrace( "CPutRequest::WriteComplete() - Write() error (as an HRESULT) 0x%08lX\n", m_sc );

	//
	//	Update the current file position
	//
	m_ov.Offset += m_dwcbWritten;

	//
	//	Resume processing by notifying the observer
	//	we registered in AsyncWrite();
	//
	Assert( m_pobs );
	m_pobs->WriteComplete( m_dwcbWritten, m_sc );
}

//	------------------------------------------------------------------------
//
//	CPutRequest::PersistComplete()
//
//	AsyncPersistRequestBody() callback called when persisting completes.
//
VOID
CPutRequest::PersistComplete( HRESULT hr )
{
	PutTrace( "DAV: TID %3d: 0x%08lX: CPutRequest::PersistComplete() called\n", GetCurrentThreadId(), this );

	//
	//	Take ownership of the reference added for the async persist.
	//
	auto_ref_ptr<CPutRequest> pRef;
	pRef.take_ownership(this);

	//
	//	If the copy operation failed, gripe and send back
	//	an appropriate response.
	//
	m_sc = hr;
	if ( FAILED(m_sc ) )
	{
		DebugTrace( "CPutRequest::PersistComplete() - Error persiting request body (0x%08lX)\n", m_sc );
		SendResponse();
		return;
	}

	//
	//	Set EOF
	//
	SetFilePointer (m_hf.get(),
					m_ov.Offset,
					NULL,
					FILE_BEGIN);

	SetEndOfFile (m_hf.get());

	//	Set the Content-xxx properties
	//
	m_sc = ScSetContentProperties (m_pmu.get(), m_pwszPath, m_hf.get());
	if ( FAILED(m_sc) )
	{
		DebugTrace( "CPutRequest::PersistComplete() - ScSetContentProperties() failed (0x%08lX)\n", m_sc );
		SendResponse();
		return;
	}

	//	Passback an allow header
	//
	m_pmu->SetAllowHeader (RT_DOCUMENT);

	//	Send the response
	//
	SendResponse();
}

//	------------------------------------------------------------------------
//
//	CPutRequest::SendResponse()
//
//	Set the response code and send the response.
//
VOID
CPutRequest::SendResponse()
{
	PutTrace( "DAV: TID %3d: 0x%08lX: CPutRequest::SendResponse() called\n", GetCurrentThreadId(), this );

	//	Clear out any old handle here.  We can't send any response
	//	back while we are still holding a handle, otherwise, there
	//	exists the chance that a client request comes immediately to
	//	access this resource and receive 423 locked.
	//
	m_hf.clear();

	//
	//	Set the response code and go
	//
	if ( SUCCEEDED(m_sc) )
	{
		if ( m_fCreatedFile )
			m_sc = W_DAV_CREATED;
	}
	else
	{
		if ( m_fCreatedFile )
		{
			//	WARNING: the safe_revert class should only be
			//	used in very selective situations.  It is not
			//	a "quick way to get around" impersonation.
			//
			safe_revert sr(m_pmu->HitUser());

			DavDeleteFile (m_pwszPath);
			DebugTrace ("Dav: deleting partial put (%ld)\n", GetLastError());
		}
	}

	m_pmu->SetResponseCode (HscFromHresult(m_sc), NULL, 0, CSEFromHresult(m_sc));

	m_pmu->SendCompleteResponse();
}

/*
 *	DAVPut()
 *
 *	Purpose:
 *
 *		Win32 file system implementation of the DAV PUT method.	 The
 *		PUT method creates a file in the DAV name space and populates
 *		the file with the data found in the passed in request.  The
 *		response created indicates the success of the call.
 *
 *	Parameters:
 *
 *		pmu			[in]  pointer to the method utility object
 */
void
DAVPut (LPMETHUTIL pmu)
{
	auto_ref_ptr<CPutRequest> pRequest(new CPutRequest(pmu));

	PutTrace( "DAV: CPutRequest: TID %3d: 0x%08lX Calling CPutRequest::Execute() \n", GetCurrentThreadId(), pRequest );

	pRequest->Execute();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\fsutil.cpp ===
/*
 *	F S U T I L . C P P
 *
 *	File system routines
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"
#include <aclapi.h>

const CHAR gc_szUncPrefix[] = "\\\\";
const UINT gc_cchszUncPrefix = CElems(gc_szUncPrefix) - 1;

//	Location checking ---------------------------------------------------------
//
//	ScCheckForLocationCorrectness() will check the url against the
//	resource and either add the appropriate location header, or it will
//	request a redirect if the url and the resource do not agree.  The
//	caller has the control over whether or not a true redirect is desired.
//	As an informational return, if a location header has been added S_FALSE
//	will be returned to the caller.
//
SCODE
ScCheckForLocationCorrectness (IMethUtil* pmu,
							   CResourceInfo& cri,
							   UINT modeRedirect)
{
	SCODE sc = S_OK;
	BOOL fTrailing;

	Assert (pmu);
	fTrailing = FTrailingSlash (pmu->LpwszRequestUrl());

	//	If the trailing slash existance does not jive with the resource type...
	//
	if (!cri.FCollection() != !fTrailing)
	{
		if (modeRedirect == REDIRECT)
		{
			auto_heap_ptr<CHAR>	pszLocation;

			//	Construct the redirect url.
			//
			sc = pmu->ScConstructRedirectUrl (cri.FCollection(),
											  pszLocation.load());
			if (FAILED (sc))
				goto ret;

			//	Redirect this badboy
			//
			sc = pmu->ScRedirect (pszLocation);
			if (FAILED (sc))
				goto ret;
		}
		else
		{
			//	EmitLocation takes care of the trailing slash checking
			//
			pmu->EmitLocation (gc_szContent_Location,
							   pmu->LpwszRequestUrl(),
							   cri.FCollection());
		}

		//	Tell the caller we had to change the location
		//
		sc = S_FALSE;
	}

ret:

	return sc;
}

//	Access checking -----------------------------------------------------------
//
//	class safe_security_revert ------------------------------------------------
//
//		Switches the current thread's impersonation token to the cached
//		"Reverted Security-enabled Thread Token" when FSecurityInit is called,
//		for the duration of the object's lifespan.
//		Unconditionally reimpersonates on exit, based on the provided handle.
//
//		NOTE: UNCONDITIONALLY reimpersonates on exit, using the impersonation
//			handle provided at construction-time.
//			(Just wanted to make that clear.)
//
//	WARNING: the safe_revert class should only be used by FChildISAPIAccessCheck
//	below.  It is not a "quick way to get around" impersonation.  If
//	you do need to do something like this, please see Becky -- she will then
//	wack you up'side the head.
//
class safe_security_revert
{
	//	Local client token to re-impersonate at dtor time.
	HANDLE		m_hClientToken;

	//	This is our cached security-enabled thread token.
	static HANDLE s_hSecurityThreadToken;

	//	NOT IMPLEMENTED
	//
	safe_security_revert (const safe_security_revert&);
	safe_security_revert& operator= (const safe_security_revert&);

public:

	explicit safe_security_revert (HANDLE h) : m_hClientToken(h)
	{
		Assert (m_hClientToken);
	}
	~safe_security_revert()
	{
		if (!ImpersonateLoggedOnUser (m_hClientToken))
		{
			DebugTrace ("ImpersonateLoggedOnUser failed with last error %d\n", GetLastError());

			//	There's not much we can do in this dtor. throw
			//
			throw CLastErrorException();
		}			
	}

	BOOL FSecurityInit (BOOL fForceRefresh);

	//	Token cache manipulators
	//
	static inline HANDLE GetToken();
	static inline VOID ClearToken();
	static inline BOOL FSetToken( HANDLE hToken );
};

//	Storage for our metaclass data (the cached thread token).
//
HANDLE safe_security_revert::s_hSecurityThreadToken = NULL;

//	Public function to clear out the cached thread token.
//	Simply calls the metaclass method.
//
void CleanupSecurityToken()
{
	safe_security_revert::ClearToken();
}

//	------------------------------------------------------------------------
//
//	GetToken()
//
//	Return the cached security token.
//
HANDLE safe_security_revert::GetToken()
{
	return s_hSecurityThreadToken;
}

//	------------------------------------------------------------------------
//
//	FSetToken()
//
//	Set the cached security token.
//
BOOL safe_security_revert::FSetToken( HANDLE hToken )
{
	//
	//	If the cache is clear then set it with this token
	//	and return whether we cache the token.
	//
	return NULL == InterlockedCompareExchangePointer(&s_hSecurityThreadToken,
													 hToken,
													 NULL);
}

//	------------------------------------------------------------------------
//
//	ClearToken()
//
//	Clear out the cached security token
//
VOID safe_security_revert::ClearToken()
{
	//
	//	Replace whatever token is cached with NULL.
	//
	HANDLE hToken = InterlockedExchangePointer(	&s_hSecurityThreadToken,
												NULL);

	//
	//	If we replaced a non-NULL token then close it.
	//
	if (hToken)
		CloseHandle (hToken);
}

//	------------------------------------------------------------------------
//
//	FSecurityInit()
//
//		Set our thread token to the cached security-enabled thread token.
//		If no security-enabled token is cached, go get one.
//
BOOL safe_security_revert::FSecurityInit (BOOL fForceRefresh)
{
	auto_handle<HANDLE> hTokenNew;
	HANDLE hToken;

	//	Clear out the cached security token if told to do so.
	//
	if (fForceRefresh)
		ClearToken();

	//	Fetch the cached security token.  Note that even if
	//	we just cleared it out, we may get back a non-NULL
	//	token here if another thread has already reloaded
	//	the cache.
	//
	hToken = GetToken();

	//
	//	If the cache was clear then create our own new token
	//	that is set up to do security access queries.
	//
	if ( NULL == hToken )
	{
		LUID SecurityPrivilegeID;
		TOKEN_PRIVILEGES tkp;

		//	RevertToSelf to get us running as system (the local diety).
		//
		if (!RevertToSelf())
			return FALSE;

		//	ImpersonateSelf copies the process token down to this thread.
		//	Then we can change the thread token's privileges without messing
		//	up the process token.
		//
		if (!ImpersonateSelf (SecurityImpersonation))
		{
			DebugTrace ("ssr::FSecurityInit--ImpersonateSelf failed with %d.\n",
						GetLastError());
			return FALSE;
		}

		//	Open our newly-copied thread token to add a privilege (security).
		//	NOTE: The adjust and query flags are needed for this operation.
		//	The impersonate flag is needed for use to use this token for
		//	impersonation -- as we do in SetThreadToken below.
		//	OpenAsSelf -- FALSE means open as thread, possibly impersonated.
		//	TRUE means open as the calling process, not as the local (impersonated) thread.
		//
		if (!OpenThreadToken (GetCurrentThread(),
							  TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY |
							  TOKEN_IMPERSONATE,
							  TRUE,
							  hTokenNew.load()))
		{
			DebugTrace ("ssr::FSecurityInit--OpenThreadToken failed with %d.\n",
						GetLastError());
			return FALSE;
		}

		//	Enable the SE_SECURITY_NAME privilege, so that we can fetch
		//	security descriptors and call AccessCheck.
		//
		if (!LookupPrivilegeValue (NULL,
								   SE_SECURITY_NAME,
								   &SecurityPrivilegeID))
		{
			DebugTrace ("ssr::FSecurityInit--LookupPrivilegeValue failed with %d\n",
						GetLastError());
			return FALSE;
		}

		tkp.PrivilegeCount = 1;
		tkp.Privileges[0].Luid = SecurityPrivilegeID;
		tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

		AdjustTokenPrivileges (hTokenNew,
							   FALSE,
							   &tkp,
							   sizeof(TOKEN_PRIVILEGES),
							   (PTOKEN_PRIVILEGES) NULL,
							   (PDWORD) NULL);

		//	The return value of AdjustTokenPrivileges cannot be tested directly...
		//	(always returns 1)
		//
		if (GetLastError() != ERROR_SUCCESS)
		{
			DebugTrace ("ssr::FSecurityInit--AdjustTokenPrivileges failed with %d\n",
						GetLastError());
			return FALSE;
		}

		//	Use this new token
		//
		hToken = hTokenNew.get();
	}

	//	At this point we must have a token
	//
	Assert (NULL != hToken);

	//	Set the current thread to use the token.
	//
	if (!SetThreadToken (NULL, hToken))
	{
		DebugTrace ("ssr::FSecurityInit--SetThreadToken failed with %d.\n",
					GetLastError());
		return FALSE;
	}

	//	Everything's cool.  We are now running with a thread token
	//	that has security-checking privileges.
	//
	//	If we created a new token along the way then attempt to cache it.
	//	We don't care if caching fails, but if it succeeds we DON'T want
	//	to close the handle because we just gave it to the cache.
	//
	if (hTokenNew.get())
	{
		if (FSetToken(hTokenNew.get()))
		{
			hTokenNew.relinquish();
		}
	}

	return TRUE;
}


GENERIC_MAPPING	gc_gmFile =
{
	FILE_GENERIC_READ,
	FILE_GENERIC_WRITE,
	FILE_GENERIC_EXECUTE,
	FILE_ALL_ACCESS
};


//	------------------------------------------------------------------------
//
//	ScChildISAPIAccessCheck
//
//	Checks if the client (our impersonation handle from off the ECB)
//	has the specified access to the specified resource.
//	NOTE: Uses a cached "security-enabled-thread-token" to query the
//	security descriptor for the specified resource.
//
SCODE __fastcall
ScChildISAPIAccessCheck (const IEcb& ecb, LPCWSTR pwsz, DWORD dwAccess, LPBYTE pbSD)
{
	SECURITY_DESCRIPTOR * pSD = NULL;
	DWORD dwRet;
	auto_handle<HANDLE>	hToken;
	BYTE	psFile[256];
	DWORD	dwPS = sizeof (psFile);
	DWORD	dwGrantedAccess = 0;
	BOOL	fAccess = FALSE;
	BOOL	fRet;

	//	pbSD is used only in DAVEX, should never be passed in from HTTPEXT
	//
	Assert (NULL == pbSD);

	//	IIS should have granted our impersonated token the proper access
	//	rights to check the ACL's on the resource.  So we are going to go
	//	after it without any change of impersonation.
	//
	dwRet = GetNamedSecurityInfoW (const_cast<LPWSTR>(pwsz),
								   SE_FILE_OBJECT,
								   OWNER_SECURITY_INFORMATION |
								   GROUP_SECURITY_INFORMATION |
								   DACL_SECURITY_INFORMATION,
								   NULL, NULL, NULL, NULL,
								   reinterpret_cast<VOID **>(&pSD));
	if (ERROR_SUCCESS != dwRet)
	{
		//	If the resource does not exist at all, as no security prevent
		//	us from trying to access a non-existing resource, so we
		//	should allow the access.
		//
		if ((dwRet == ERROR_PATH_NOT_FOUND) ||
			(dwRet == ERROR_FILE_NOT_FOUND))
		{
			fAccess = TRUE;
			goto ret;
		}

		//	Now then... If we got here, we don't really know what went wrong,
		//	so we are going to try and do things the old way.
		//
		//	BTW: We really do not expect this code to ever get run.
		//
		DebugTrace ("WARNING: WARNING: WARNING: ScChildISAPIAccessCheck() -- "
					"GetNamedSecurityInfoW() failed %d (0x%08x): falling back...\n",
					dwRet, dwRet);

		//	Scope to control the lifetime of our un-impersonation.
		//
		safe_security_revert sr (ecb.HitUser());

		//	Set us to use the cached security-enabled thread token.
		//
		if (!sr.FSecurityInit(FALSE))
		{
			//	Perhaps it failed because the cached token is out-of-date.
			//	Try again, but clear the cache (TRUE).
			//
			if (!sr.FSecurityInit(TRUE))
			{
				//	Still failed.  Give up.
				//
				dwRet = GetLastError();
				DebugTrace ("ScChildISAPIAccessCheck() -- "
							"Error from sr.FSecurityInit %d (0x%x).\n",
							dwRet, dwRet);
				goto ret;
			}
		}

		dwRet = GetNamedSecurityInfoW (const_cast<LPWSTR>(pwsz),
									   SE_FILE_OBJECT,
									   OWNER_SECURITY_INFORMATION |
									   GROUP_SECURITY_INFORMATION |
									   DACL_SECURITY_INFORMATION,
									   NULL, NULL, NULL, NULL,
									   reinterpret_cast<VOID **>(&pSD));
		if (ERROR_SUCCESS != dwRet)
		{
			//	Perhaps it failed because the cached token is out-of-date.
			//	(I have no idea what the error code would be. Put it here if/when we find out.)
			//	Try again, but clear the cache (TRUE).
			//
			if (!sr.FSecurityInit(TRUE))
			{
				DebugTrace ("ScChildISAPIAccessCheck() -- "
							"Error from second sr.FSecurityInit %d (0x%x).\n",
							dwRet, dwRet);
				goto ret;
			}

			//	If the resource does not exist at all, as no security prevent
			//	us from trying to access a non-existing resource, so we
			//	should allow the access.
			//
			if ((dwRet == ERROR_PATH_NOT_FOUND) ||
				(dwRet == ERROR_FILE_NOT_FOUND))
			{
				fAccess = TRUE;
				goto ret;
			}

			dwRet = GetNamedSecurityInfoW (const_cast<LPWSTR>(pwsz),
										   SE_FILE_OBJECT,
										   OWNER_SECURITY_INFORMATION |
										   GROUP_SECURITY_INFORMATION |
										   DACL_SECURITY_INFORMATION,
										   NULL, NULL, NULL, NULL,
										   reinterpret_cast<VOID **>(&pSD));
			if (ERROR_SUCCESS != dwRet)
			{
				DebugTrace ("ScChildISAPIAccessCheck -- "
							"Error from GetNamedSecurityInfoW %d (0x%08x).\n",
							dwRet, dwRet);
				goto ret;
			}
		}

		//	End of safe_security_revert scope.
		//	Now the safe_security_revert dtor will re-impersonate us.
		//
	}

	//	Get our thread's access token.
	//	OpenAsSelf -- TRUE means open the thread token as the process
	//	itself FALSE would mean as thread, possibly impersonated
	//	We want the impersonated access token, so we want FALSE here!
	//
	fRet = OpenThreadToken (GetCurrentThread(),
							TOKEN_QUERY,
							TRUE,
							hToken.load());
	if (!fRet)
	{
		//	This should NEVER fail.  We are impersonated, so we do have
		//	a thread-level access token.  If  conditions change, and we
		//	have a state where this can fail,  remove the TrapSz below!
		//
		//$	REVIEW: OpenThreadToken() can fail for any number of reasons
		//	not excluding resource availability.  So, this trap is a bit
		//	harsh, no?
		//
		//	TrapSz("OpenThreadToken failed while we are impersonated!");
		//
		//$	REVIEW: end.
		DebugTrace ("ScChildISAPIAccessCheck--"
					"Error from OpenThreadToken %d (0x%08x).\n",
					GetLastError(), GetLastError());
		goto ret;
	}

	//	Map the requested access to file-specific access bits....
	//
	MapGenericMask (&dwAccess, &gc_gmFile);

	//	And now check for this access on the file.
	//
	fRet = AccessCheck (pSD,
						hToken,
						dwAccess,
						&gc_gmFile,
						(PRIVILEGE_SET*)psFile,
						&dwPS,
						&dwGrantedAccess,
						&fAccess);
	if (!fRet)
	{
		DebugTrace ("ScChildISAPIAccessCheck--Error from AccessCheck %d (0x%08x).\n",
					GetLastError(), GetLastError());
		goto ret;
	}

	//	Now, fAccess tells whether the impersonated token has
	//	the requested access.  Return this to the caller.
	//

ret:
	if (pSD)
		LocalFree (pSD);

	return fAccess ? S_OK : E_ACCESSDENIED;
}

//$	SECURITY ------------------------------------------------------------------
//
//$	REVIEW/HACK: DAVEX needs to disable access to any url that has a
//	VrUserName, VrPassword enabled on it.
//
//	HTTPEXT does not care...
//
VOID ImplHackAccessPerms( LPCWSTR, LPCWSTR, DWORD * ) {}

//  DAVEX needs to be able to convert security tokens to take Universal Security Groups
//  into account.
SCODE
ScFindOrCreateTokenContext( HANDLE hTokenIn,
					  	    VOID ** ppCtx,
					  	    HANDLE *phTokenOut)
{
	*ppCtx = NULL;
	*phTokenOut = hTokenIn;

	return S_OK;
}

VOID
ReleaseTokenCtx (VOID * pCtx) {}
//
//$	END REVIEW/HACK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\mem.cpp ===
/*
 *	M E M . C P P
 *
 *	File system implementation of DAV allocators
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"

//	Use the default DAV allocator implementations
//

#define g_szMemDll L"staxmem.dll"
#include <memx.h>

//	Mapping the exdav non-throwing allocators to something local
//
LPVOID __fastcall ExAlloc( UINT cb )				{ return g_heap.Alloc( cb ); }
LPVOID __fastcall ExRealloc( LPVOID pv, UINT cb )	{ return g_heap.Realloc( pv, cb ); }
VOID __fastcall ExFree( LPVOID pv )					{ g_heap.Free( pv ); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\fssearch.cpp ===
/*
 *	F S S E A R C H . C P P
 *
 *	Sources file system implementation of DAV-Search
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"

#ifdef __cplusplus
extern "C" {
#endif
#include <msidxs.h>
#ifdef __cplusplus
}
#endif

#include "_fssrch.h"
#include <oledberr.h>
#include <cierror.h>

// 	20001801-5de6-11d1-8e38-00c04fb9386d is FMTID_PropertySet as defined
//	in pbagex.h. It's the guid of custom props,
//
static const WCHAR gsc_wszSetPropertyName[] =
	L"SET PROPERTYNAME '20001801-5de6-11d1-8e38-00c04fb9386d' PROPID '%s' AS \"%s\"";

//	gsc_wszPath is used for the Tripoli prop "Path", so don't move to common sz.cpp
//
static const WCHAR	gsc_wszSelectPath[] = L"SELECT Path ";
static const ULONG	MAX_FULLY_QUALIFIED_LENGTH = 2048;
static const WCHAR	gsc_wszShallow[] = L"Shallow";
static const ULONG	gsc_cchShallow = CchConstString(gsc_wszShallow);

//	class CDBCreateCommand ----------------------------------------------------
//
class CDBCreateCommand : private OnDemandGlobal<CDBCreateCommand, SCODE *>
{
	//
	//	Friend declarations required by OnDemandGlobal template
	//
	friend class Singleton<CDBCreateCommand>;
	friend class RefCountedGlobal<CDBCreateCommand, SCODE *>;

	//
	//	Pointer to the IDBCreateCommand object
	//
	auto_com_ptr<IDBCreateCommand> m_pDBCreateCommand;

	//	CREATORS
	//
	//	Declared private to ensure that arbitrary instances
	//	of this class cannot be created.  The Singleton
	//	template (declared as a friend above) controls
	//	the sole instance of this class.
	//
	CDBCreateCommand() {}
	BOOL FInit( SCODE * psc );

public:
	static SCODE CreateCommand( ICommandText ** ppCommandText );

	static VOID Release()
	{
		DeinitIfUsed();
	}
};

BOOL
CDBCreateCommand::FInit( SCODE * psc )
{
	SCODE sc = S_OK;

	auto_com_ptr<IDBInitialize>	pDBInit;
	auto_com_ptr<IDBCreateSession> pDBCS;

	// Get provider "MSIDXS"
	//
	sc = CoCreateInstance(CLSID_MSIDXS, NULL, CLSCTX_INPROC_SERVER,
				IID_IDBInitialize, (void **)&pDBInit);

	if (FAILED(sc))
    {
		DebugTrace ("Failed to initialized provider MSIDXS \n");
		goto ret;
	}

	//	Initialize the provider
	//
	sc = pDBInit->Initialize();
	if (FAILED(sc))
	{
		DebugTrace ("IDBInitialize::Initialize failed\n");
		goto ret;
	}

	//	Get IDBCreateSession
	//
	sc = pDBInit->QueryInterface(IID_IDBCreateSession, (void**) &pDBCS);
	if (FAILED(sc))
	{
		DebugTrace("QI for IDBCreateSession failed\n");
		goto ret;
	}

	//	Create a Session object
	//
	sc = pDBCS->CreateSession(NULL, IID_IDBCreateCommand,
							  (IUnknown**) m_pDBCreateCommand.load());
	if (FAILED(sc))
	{
		DebugTrace("pDBCS->CreateSession failed\n");
		goto ret;
	}

ret:
	*psc = sc;
	return SUCCEEDED(sc);
}

SCODE
CDBCreateCommand::CreateCommand( ICommandText ** ppCommandText )
{
	SCODE sc = S_OK;


	if ( !FInitOnFirstUse( &sc ) )
	{
		DebugTrace( "CDBCreateCommand::CreateCommand() - DwInitRef() failed (0x%08lX)\n", sc );
		goto ret;
	}

	Assert( Instance().m_pDBCreateCommand );

	sc = Instance().m_pDBCreateCommand->CreateCommand (NULL, IID_ICommandText,
					(IUnknown**) ppCommandText);

ret:
	return sc;
}

//	ReleaseDBCreateCommandObject()
//
//	Called from FSTerminate to free the DBCreateCommand object before quit
//
VOID
ReleaseDBCreateCommandObject()
{
	CDBCreateCommand::Release();
}

//	Search specifics ----------------------------------------------------------
//
BOOL IsLegalVarChar(WCHAR wch)
{
	return iswalnum(wch)
		|| (L'.' == wch)
		|| (L':' == wch)
		|| (L'-' == wch)
		|| (L'_' == wch)
		|| (L'/' == wch)
		|| (L'*' == wch);		//	* included to support 'select *'
}

//
//	FTranslateScope
//		detect whether a given URI or a path is under the
//	davfs virutal directory
//
//		pmu			  [in] 	pointer to IMethUtil object
//		pwszURIOrPath [in]	URI or the physical path, non-NULL terminated
//		cchPath	 	  [in] 	the number of chars of the path
//		ppwszPath	  [in] 	receive the pointer to the translated path
//
BOOL
FTranslateScope (LPMETHUTIL pmu,
	LPCWSTR pwszURI,
	ULONG cchURI,
	auto_heap_ptr<WCHAR>& pwszPath)
{
	SCODE sc = S_OK;

	CStackBuffer<WCHAR,MAX_PATH> pwszTerminatedURI;
	CStackBuffer<WCHAR,MAX_PATH> pwszURINormalized;
	UINT cchURINormalized;
	UINT cch;

	//	We need to make a copy of '\0' terminated URI
	//
	if (NULL == pwszTerminatedURI.resize(CbSizeWsz(cchURI)))
	{
		sc = E_OUTOFMEMORY;
		DebugTrace("FTranslatedScope() - Error while allocating memory 0x%08lX\n", sc);
		return FALSE;
	}
	memcpy(pwszTerminatedURI.get(), pwszURI, cchURI * sizeof(WCHAR));
	pwszTerminatedURI[cchURI] = L'\0';

	//	We need to unescape the scope URI before translate
	//
	cchURINormalized = pwszURINormalized.celems();
	sc = ScNormalizeUrl (pwszTerminatedURI.get(),
						 &cchURINormalized,
						 pwszURINormalized.get(),
						 NULL);
	if (S_FALSE == sc)
	{
		if (NULL == pwszURINormalized.resize(cchURINormalized * sizeof(WCHAR)))
		{
			sc = E_OUTOFMEMORY;
			DebugTrace("FTranslatedScope() - Error while allocating memory 0x%08lX\n", sc);
			return FALSE;
		}

		sc = ScNormalizeUrl (pwszTerminatedURI.get(),
							 &cchURINormalized,
							 pwszURINormalized.get(),
							 NULL);

		//	Since we've given ScNormalizeUrl() the space it asked for,
		//	we should never get S_FALSE again.  Assert this!
		//
		Assert(S_FALSE != sc);
	}
	if (FAILED (sc))
	{
		DebugTrace("FTranslatedScope() - ScNormalizeUrl() failed 0x%08lX\n", sc);
		return FALSE;
	}

	//	Do the translation and check the validation
	//
	//	At most we should go through the processing below twice, as the byte
	//	count required is an out param.
	//
	cch = MAX_PATH;
	do {

		pwszPath.realloc(cch * sizeof(WCHAR));
		sc = pmu->ScStoragePathFromUrl (pwszURINormalized.get(), pwszPath, &cch);

	} while (sc == S_FALSE);
	if (FAILED (sc))
	{
		DebugTrace ("FTranslateScope() - IMethUtil::ScStoragePathFromUrl() failed to translate scope URI 0x%08lX\n", sc);
		return FALSE;
	}

	//$	SECURITY:
	//
	//	Check to see if the scope is really a short filename.
	//
	sc = ScCheckIfShortFileName (pwszPath, pmu->HitUser());
	if (FAILED (sc))
	{
		DebugTrace ("FTranslateScope() - ScCheckIfShortFileName() failed to scope, is short filename 0x%08lX\n", sc);
		return FALSE;
	}

	//$	SECURITY:
	//
	//	Check to see if the destination is really the default
	//	data stream via alternate file access.
	//
	sc = ScCheckForAltFileStream (pwszPath);
	if (FAILED (sc))
	{
		DebugTrace ("FTranslateScope() - ScCheckForAltFileStream() failed to scope, is short filename 0x%08lX\n", sc);
		return FALSE;
	}

	return TRUE;
}

//
//	ScSetPropertyName
//
//		execute SET PROPERTYNAME command on the passed in property
//	so that Index Server will be aware of this prop
//
SCODE
ScSetPropertyName(ICommandText * pCommandText, LPWSTR pwszName)
{
	WCHAR	rgwchSet[MAX_FULLY_QUALIFIED_LENGTH];
	auto_com_ptr<IRowset> pRowset;
	SCODE	sc = S_OK;

	//	generate the SET PROPERTYNAME command
	//
	wsprintfW (rgwchSet, gsc_wszSetPropertyName, pwszName, pwszName);

	//	set the command text
	//
	sc = pCommandText->SetCommandText(DBGUID_DEFAULT, rgwchSet);
	if (FAILED(sc))
	{
		DebugTrace ("failed to set command text %ws\n", rgwchSet);
		goto ret;
	}

	//	do the actual set
	//
	sc = pCommandText->Execute(NULL, IID_IRowset, 0, 0, (IUnknown**) &pRowset);
	if (FAILED(sc))
	{
		DebugTrace ("failed to execute %ws\n", rgwchSet);
		goto ret;
	}
	Assert (DB_S_NORESULT == sc);
	Assert (!pRowset);

ret:
	return (sc == DB_S_NORESULT) ? S_OK : sc;
}

void
AddChildVrPaths (IMethUtil* pmu,
				 LPCWSTR pwszUrl,
				 ChainedStringBuffer<WCHAR>& sb,
				 CVRList& vrl,
				 CWsziList& lst)
{
	CVRList::iterator it;
	ChainedStringBuffer<WCHAR> sbLocal;

	//	See if there are child vroots to process as well.  We don't
	//	have a path at this time for scoping, so we can pass NULL and
	//	duplicates will get removed when we sort/unique.
	//
	if (S_OK == pmu->ScFindChildVRoots (pwszUrl, sbLocal, vrl))
	{
		for (it = vrl.begin(); it != vrl.end(); it++)
		{
			auto_ref_ptr<CVRoot> cvr;
			if (pmu->FGetChildVRoot (it->m_pwsz, cvr))
			{
				LPCWSTR pwszPath;
				UINT cch;

				//	Add it to the list
				//
				cch = cvr->CchGetVRPath (&pwszPath);
				lst.push_back(CRCWszi(sb.Append (CbSizeWsz(cch), pwszPath)));
			}
		}
		lst.sort();
		lst.unique();
	}
}

//	Tripoli prop names
//
static const WCHAR gsc_Tripoli_wszFilename[] 	= L"filename";
static const WCHAR gsc_Tripoli_wszSize[] 		= L"size";
static const WCHAR gsc_Tripoli_wszCreate[] 		= L"create";
static const WCHAR gsc_Tripoli_wszWrite[]		= L"write";
static const WCHAR gsc_Tripoli_wszAttrib[]		= L"attrib";

//	ScMapReservedPropInWhereClause
//
//	Helper function to map DAV reserved props to
//
SCODE
ScMapReservedPropInWhereClause (LPWSTR pwszName, UINT * pirp)
{
	UINT	irp;
	SCODE	sc = S_OK;

	Assert (pirp);

	//	We only care those properties not stored in propertybag
	//	RESERVED_GET is just for this purpose
	//
	if (CFSProp::FReservedProperty (pwszName, CFSProp::RESERVED_GET, &irp))
	{
		//	Here's our mapping table
		//
		//	DAV Prop				Tripoli prop
		//
		//	DAV:getcontentlength	size
		//	DAV:displayname			filename
		//	DAV:creationdate		create
		//	DAV:lastmodified		write
		//	DAV:ishidden			attrib
		//	DAV:iscollection		attrib
		//	DAV:resourcetype			<no mapping>
		//	DAV:getetag					<no mapping>
		//	DAV:lockdiscovery			<no mapping>
		//	DAV:supportedlock			<no mapping>

		//	Now that we are to overwrite dav reserved prop name with
		//	the Tripoli prop name in place, the buffer must have enough
		//	space
		//	Assert this fact that all the six reserved we will ever map
		//	satisfy this requirement
		//
		Assert ((wcslen(sc_rp[iana_rp_content_length].pwsz)	>= wcslen (gsc_Tripoli_wszSize)) &&
				(wcslen(sc_rp[iana_rp_creation_date].pwsz) 	>= wcslen (gsc_Tripoli_wszCreate)) &&
				(wcslen(sc_rp[iana_rp_displayname].pwsz) 	>= wcslen (gsc_Tripoli_wszFilename)) &&
				(wcslen(sc_rp[iana_rp_last_modified].pwsz) 	>= wcslen (gsc_Tripoli_wszWrite)) &&
				(wcslen(sc_rp[iana_rp_ishidden].pwsz) 		>= wcslen (gsc_Tripoli_wszAttrib)) &&
				(wcslen(sc_rp[iana_rp_iscollection].pwsz) 	>= wcslen (gsc_Tripoli_wszAttrib)));

		switch  (irp)
		{
			case iana_rp_content_length:
				wcscpy (pwszName, gsc_Tripoli_wszSize);
				break;

			case iana_rp_creation_date:
				wcscpy (pwszName, gsc_Tripoli_wszCreate);
				break;

			case iana_rp_displayname:
				wcscpy (pwszName, gsc_Tripoli_wszFilename);
				break;

			case iana_rp_last_modified:
				wcscpy (pwszName, gsc_Tripoli_wszWrite);
				break;

			case iana_rp_ishidden:
			case iana_rp_iscollection:
				wcscpy (pwszName, gsc_Tripoli_wszAttrib);
				break;

			case iana_rp_etag:
			case iana_rp_resourcetype:
			case iana_rp_lockdiscovery:
			case iana_rp_supportedlock:
				//	Among these four props, we data type of resourcetype is
				//	a XML node, no way to express that in SQL.
				//	And the rest three, we don't have a Tripoli mapping for them
				//
				// 	DB_E_ERRORSINCOMMAND will be mapped to 400 Bad Request
				//
				sc = DB_E_ERRORSINCOMMAND;
				goto ret;

			default:
				//	Catch the bad boy
				//
				AssertSz (FALSE, "Unexpected reserved props");
				break;
		}

		*pirp = irp;
	}

ret:
	return sc;
}

const WCHAR  gsc_wszStar[] = L"*";
const WCHAR	 gsc_wszAll[] = L"all";
const WCHAR	 gsc_wszDistinct[] = L"distinct";

//	FSSearch::ScSetSQL
//
//		Translate a SQL query, basically is to just replace the alias with the
//		corresponding namespace.
//
SCODE
CFSSearch::ScSetSQL (CParseNmspcCache * pnsc, LPCWSTR pwszSQL)
{
	BOOL fPropAdded = FALSE;
	BOOL fStarUsed = FALSE;
	BOOL fQuoted = FALSE;
	CStackBuffer<WCHAR,128> pwszUrlT;
	LPCWSTR pwsz;
	LPCWSTR pwszNameBegin;
	LPCWSTR pwszWordBegin;
	SCODE sc = S_OK;
	UINT cLen;
	WCHAR rgwchName[MAX_FULLY_QUALIFIED_LENGTH];

	typedef enum {

		SQL_NO_STATE,
		SQL_SELECT,
		SQL_FROM,
		SQL_WHERE,
		SQL_MORE

	} SQL_STATE;
	SQL_STATE state = SQL_NO_STATE;

	//	Create the command text object
	//
	sc = CDBCreateCommand::CreateCommand (m_pCommandText.load());
	if (FAILED(sc))
		goto ret;

	//	Parse out the SQL
	//
	pwsz = const_cast<LPWSTR>(pwszSQL);
	Assert (pwsz);

	while (*pwsz)
	{
		//	Filter out white spaces
		//
		while (*pwsz && iswspace(*pwsz))
			pwsz++;

		//	check to see if we reach the end of the string
		//
		if (!(*pwsz))
			break;

		//	remember the starting position
		//
		pwszWordBegin = pwsz;
		if (IsLegalVarChar(*pwsz))
		{
			CStackBuffer<WCHAR> pwszName;

			pwszNameBegin = pwsz;
			cLen = 0;

			//	look for a variable
			//
			if (fQuoted)
			{
				// Pick up the propname as a whole
				//
				while (*pwsz && (*pwsz != L'"'))
					pwsz++;
			}
			else
			{
				while (*pwsz && IsLegalVarChar(*pwsz))
					pwsz++;
			}

			//	Translate the name here
			//
			cLen = static_cast<UINT>(pwsz - pwszNameBegin);
			if (NULL == pwszName.resize(CbSizeWsz(cLen)))
			{
				sc = E_OUTOFMEMORY;
				goto ret;
			}
			wcsncpy (pwszName.get(), pwszNameBegin, cLen);
			pwszName[cLen] = 0;

			switch (state)
			{
				case SQL_NO_STATE:

					if (!_wcsnicmp (pwszWordBegin, gc_wszSelect, pwsz-pwszWordBegin))
						state = SQL_SELECT;

					break;

				case SQL_SELECT:

					if (!_wcsnicmp (pwszWordBegin, gc_wszFrom, pwsz-pwszWordBegin))
					{
						//	Empty select statement is an error
						//
						if (!fPropAdded && !fStarUsed)
						{
							sc = E_INVALIDARG;
							goto ret;
						}

						//	We've finished the SELECT statement.
						//	Note that all that we need is 'SELECT path '.
						//	We take care of all the rest ourselves, so restruct
						//	the SELECT path here before we continue
						//
						m_sbSQL.Reset();
						m_sbSQL.Append(gsc_wszSelectPath);

						state = SQL_FROM;
						break;
					}

					//	Add to our list of properties to retrieve
					//
					if (!wcscmp(pwszName.get(), gsc_wszStar))
					{
						sc = m_cfc.ScGetAllProps (NULL);
						if (FAILED(sc))
							goto ret;

						fStarUsed = TRUE;
					}
					else
					{
						//	Following Monarch Stage 1.
						//
						if (!fQuoted)
						{
							if (!_wcsicmp(pwszName.get(), gsc_wszAll))
								break;
							if (!_wcsicmp(pwszName.get(), gsc_wszDistinct))
							{
								//	Monarch does not allow distinct
								//
								sc = E_INVALIDARG;
								goto ret;
							}
						}

						//	Normal props
						//
						sc = m_cfc.ScAddProp (NULL, pwszName.get(), FALSE);
						if (FAILED(sc))
							goto ret;
						fPropAdded = TRUE;
					}

					break;

				case SQL_FROM:
				{
					BOOL fScopeExist = FALSE;
					CWsziList lst;
					CWsziList::iterator itPath;
					LPCWSTR pwszScopePath = m_pmu->LpwszPathTranslated();
					LPCWSTR pwszUrl = m_pmu->LpwszRequestUrl();
					BOOL fShallow = FALSE;

					//	Monarch Syntax:
					//	FROM { SCOPE( [ 'Scope_Arguments' ] ) | View_Name }
					//	Scope_Arguments =
					//		' [ Traversal_Type ] ( "Path" [ , "Path", ...]
					//	Path can be URI or physical path

					//	We verify every path should must be under our
					//	virtual directory and we allow only one path
					//	Note, if we ever want to accept multiple path, then
					//	we need some extra code, mainly another for loop.
					//	For now, talk with Joels, keep it this way.
					//
					if (!_wcsnicmp (pwszWordBegin, gc_wszScope, pwsz-pwszWordBegin))
					{
						LPCWSTR pwszStart = pwsz;
						ULONG cLevel = 0;
						BOOL fInSingleQuote = FALSE;

						wcscpy(rgwchName, pwszName.get());

						//	Parse the scope arguments list
						//
						while (*pwsz)
						{
							if (L'(' == *pwsz)
							{
								cLevel++;
							}
							else if (L')' == *pwsz)
							{
								if (NULL == (--cLevel))
									break;
							}
							else if (L'\'' == *pwsz)
							{
								//	If this is a closing single quote, flip the
								//	switch.
								//
								if (fInSingleQuote)
								{
									//	It's an error if no scope inside ''
									//
									if (!fScopeExist)
									{
										sc = E_INVALIDARG;
										goto ret;
									}

									//	The next single quote will be an
									//	opening single quote
									//
									fInSingleQuote = FALSE;
								}
								else
								{
									//	We need to find out the traversal type
									//	as we rely on Monarch to check syntax, so it
									//	is OK for us to assume the syntax is correct,
									//	Anything we missed can be caught later in
									//	Monarch.
									//
									pwsz++;
									while (*pwsz && iswspace(*pwsz))
										pwsz++;

									//	Check if it is "Shallow Traversal", again
									//	we check only the word "shallow", any syntax
									//	error can be caught later in Monarch.
									//
									if (!_wcsnicmp(pwsz, gsc_wszShallow, gsc_cchShallow))
										fShallow = TRUE;

									//	The next single quote will be a closing
									//	sinlge quote
									//
									fInSingleQuote = TRUE;

									//	we've point to the next char, so loop back
									//	immediately
									//
									continue;
								}
							}
							else if (L'"' == *pwsz)
							{
								auto_heap_ptr<WCHAR> pwszPath;
								LPCWSTR pwszPathStart;

								//	Copy over bytes up to '"'.
								//
								pwsz++;
								wcsncat (rgwchName,	pwszStart, pwsz-pwszStart);

								//	Look for the start of scope
								//
								while ((*pwsz) && iswspace(*pwsz))
									pwsz++;
								pwszPathStart = pwsz;

								//	We really only allow a single
								//	path in our scope.  Fail others
								//	with bad request
								//
								if (fScopeExist)
								{
									sc = E_INVALIDARG;
									goto ret;
								}

								//	look for the end of the path
								//
								while (*(pwsz) && *pwsz != L'"')
									pwsz++;
								if (!(*pwsz))
									break;

								fScopeExist = TRUE;

								//	Translate the scope:
								//		- forbid the physical path
								//		- translate the URI and reject
								//		  any URI beyond our VR
								//
								if (pwsz > pwszPathStart)
								{
									UINT cchUrlT;

									if (!FTranslateScope (m_pmu,
														  pwszPathStart,
														  static_cast<UINT>(pwsz-pwszPathStart),
														  pwszPath))
									{
										//	return an error that would be mapped to
										//	HSC_FORBIDDEN
										//
										sc = STG_E_DISKISWRITEPROTECTED;
										Assert (HSC_FORBIDDEN == HscFromHresult(sc));
										goto ret;
									}

									//	use the translated physical path
									//
									pwszScopePath = AppendChainedSz(m_csb, pwszPath);

									lst.push_back(CRCWszi(pwszScopePath));

									//	Allocate space for the URL and keep it hanging on
									//
									cchUrlT = static_cast<UINT>(pwsz - pwszPathStart);
									if (NULL == pwszUrlT.resize(CbSizeWsz(cchUrlT)))
									{
										sc = E_OUTOFMEMORY;
										goto ret;
									}
									memcpy(pwszUrlT.get(), pwszPathStart, cchUrlT * sizeof(WCHAR));
									pwszUrlT[cchUrlT] = L'\0';
									pwszUrl = pwszUrlT.get();
								}
								else
								{
									//	we've got a "". Insert the request URI
									//
									Assert (pwsz == pwszPathStart);
									Assert ((*pwsz == L'"') && (*(pwsz-1) == L'"'));
									lst.push_back(CRCWszi(pwszScopePath));
								}
								pwszStart = pwsz;
							}
							pwsz++;
						}

						//	Syntax check
						//
						if (fInSingleQuote || !(*pwsz))
						{
							// unbalanced ', " or )
							//
							sc = E_INVALIDARG;
							goto ret;
						}

						//	include ')'
						//
						pwsz++;

						if (!fScopeExist)
						{
							wcscat (rgwchName, L"('\"");

							//	Pickup the request uri
							//
							lst.push_back(CRCWszi(pwszScopePath));
						}

						//	Search Child Vroots only if we are doing
						//	a non-shallow traversal.
						//$ REVIEW(zyang).
						//	Here we drop the subvroot in the shallow search
						//	This is not quite right, Assume we are searching /fs
						//	and it has a sub vroot /fs/sub. we expect to see
						//	/fs/sub in the search result. but we lost it.
						//	However, if we include this sub vroot in the search
						//	path, it's even worse, as a shallow traversal on
						//	/fs/sub will give us all /fs/sub/*, which is another
						//	level deep.
						//	There's no easy fix for this, unless, we keep a list
						//	of first level vroots and emit ourselves. That's
						//	of extra code, and don't know how much it would buy us.
						//	As a compromise for now, we simply drop the sub vroot
						//	in shallow search.
						//
						if (!fShallow)
						{
							AddChildVrPaths (m_pmu,
											 pwszUrl,
											 m_csb,
											 m_vrl,
											 lst);
						}

						//	Construct the scope
						//
						Assert (!lst.empty());
						itPath = lst.begin();
						wcscat (rgwchName, itPath->m_pwsz);
						for (itPath++; itPath != lst.end(); itPath++)
						{
							wcscat (rgwchName, L"\", \"");
							wcscat (rgwchName, itPath->m_pwsz);
						}
						wcscat (rgwchName, L"\"')");
						cLen = static_cast<UINT>(wcslen (rgwchName));

						//	replace with the new string
						//
						if (NULL == pwszName.resize(CbSizeWsz(cLen)))
						{
							sc = E_OUTOFMEMORY;
							goto ret;
						}
						lstrcpyW (pwszName.get(), rgwchName);

						//	After the Scope is processed, the only thing that
						//	we want to do is the custom properties. so we don't
						//	care if the rest is a WHERE or an ORDER BY or else
						//
						state = SQL_MORE;
					}

					break;
				}
				case SQL_WHERE:
				case SQL_MORE:

					//	It's not easy for us to tell which prop is custom prop
					//	and thus need to be set to the command object.
					//	without a real parse tree, we can't tell names from
					//	operators and literals.
					//
					//	a good guess is that if the prop is quoted by double
					//	quote, we can treat it as a custom prop. Note, this
					//	imposes the requirment that all props, including
					//	namespaceless props must be quoted. all unquoted
					//	are either Tripoli props or operators/literals which
					//	we can just copy over. this makes our life easier
					//

					//	We need to map some DAV reserved properties to tripoli
					//	props when they appear in the where clause
					//
					if (fQuoted)
					{
						UINT	irp = sc_crp_set_reserved; //max value

						sc = ScMapReservedPropInWhereClause (pwszName.get(), &irp);
						if (FAILED(sc))
							goto ret;

						if (irp != sc_crp_set_reserved)
							cLen = static_cast<UINT>(wcslen(pwszName.get()));
						else
						{
							//	SET PROPERTYNAME on custom props
							//
							sc = ScSetPropertyName (m_pCommandText, pwszName.get());
							if (FAILED(sc))
							{
								DebugTrace ("Failed to set custom prop %ws to Monarch\n",
											pwszName.get());
								goto ret;
							}
						}
					}

					break;

				default:
					break;
			}

			// Append the name
			//
			m_sbSQL.Append(sizeof(WCHAR)*cLen, pwszName.get());
			if (L'"' != *pwsz)
			{
				// add seperator
				//
				m_sbSQL.Append(L" ");
			}
		}
		else if (L'\'' == *pwsz)
		{
			//	copy literals over

			pwsz++;
			while (*pwsz && (L'\'' != *pwsz))
				pwsz++;

			if (!*pwsz)
			{
				DebugTrace("unbalanced single quote\n");
				sc = E_INVALIDARG;
				goto ret;
			}
			else
			{
				Assert(L'\'' == *pwsz);

				// copy over
				//
				pwsz++;
				m_sbSQL.Append( static_cast<UINT>(pwsz-pwszWordBegin) * sizeof(WCHAR),
								pwszWordBegin);
			}

			// add seperator
			//
			m_sbSQL.Append(L" ");
		}
		else if (L'"' == *pwsz)
		{
			// toggle the flag
			//
			fQuoted = !fQuoted;
			pwsz++;
			m_sbSQL.Append(L"\"");

			//	Apeend seperator after closing '"'
			//
			if (!fQuoted)
				m_sbSQL.Append(L" ");
		}
		else
		{
			//	some char we don't have interest on, just copy over
			//
			while (*pwsz && !IsLegalVarChar(*pwsz)
					&& (L'\'' != *pwsz) && (L'"' != *pwsz))
				pwsz++;

			// Append the name
			//
			m_sbSQL.Append(	static_cast<UINT>(pwsz-pwszWordBegin) * sizeof(WCHAR),
							pwszWordBegin);

		}

	}

	//	Close the string
	//
	m_sbSQL.Append(sizeof(WCHAR), L"");
	SearchTrace ("Search: translated query is: \"%ls\"\n", PwszSQL());

ret:

	return sc;
}

static void
SafeWcsCopy (LPWSTR pwszDst, LPCWSTR pwszSrc)
{
	//	Make sure we are not doing any evil copies...
	//
	Assert (pwszDst && pwszSrc && (pwszDst <= pwszSrc));
	if (pwszDst == pwszSrc)
		return;

	while (*pwszSrc)
		*pwszDst++ = *pwszSrc++;

	*pwszDst = L'\0';

	return;
}

SCODE
CFSSearch::ScEmitRow (CXMLEmitter& emitter)
{
	auto_ref_ptr<IMDData> pMDData;
	CResourceInfo cri;
	CStackBuffer<WCHAR,128> pwszExt;
	CVRList::iterator it;
	LPWSTR pwszFile;
	SCODE sc = S_OK;
	UINT cch;

	//	Get the filename
	//
	pwszFile = reinterpret_cast<LPWSTR>(m_pData.get());
	sc = cri.ScGetResourceInfo (pwszFile);
	if (FAILED (sc))
		goto ret;

	//	FSPropTarget sort of needs the URI of the target.
	//	What is really important here, is the file extension.
	//	We can fake it out by just pretending the file
	//	is the URL name.
	//
	cch = pwszExt.celems();
	sc = m_pmu->ScUrlFromStoragePath(pwszFile, pwszExt.get(), &cch);
	if (S_FALSE == sc)
	{
		if (NULL == pwszExt.resize(cch * sizeof(WCHAR)))
		{
			sc = E_OUTOFMEMORY;
			goto ret;
		}
		sc = m_pmu->ScUrlFromStoragePath(pwszFile, pwszExt.get(), &cch);
	}
	if (S_OK != sc)
	{
		Assert (S_FALSE != sc);
		goto ret;
	}

	//	Strip the prefix
	//
	SafeWcsCopy(pwszExt.get(), PwszUrlStrippedOfPrefix(pwszExt.get()));

	//	Emit the row (ie. call ScFindFileProps()) if-and-only-if
	//	We know this url is to be indexed.  In particular, can we
	//	sniff the metabase, and is the index bit set.
	//$178052: We also need to respect the dirbrowsing bit
	//
	SearchTrace ("Search: found row at '%S'\n", pwszExt.get());
	if (SUCCEEDED (m_pmu->HrMDGetData (pwszExt.get(), pMDData.load())))
	{
		if (pMDData->FIsIndexed() &&
		    (pMDData->DwDirBrowsing() & MD_DIRBROW_ENABLED))
		{
			//	Find the properties
			//
			sc = ScFindFileProps (m_pmu,
								  m_cfc,
								  emitter,
								  pwszExt.get(),
								  pwszFile,
								  NULL,
								  cri,
								  TRUE /*fEmbedErrorsInResponse*/);
			if (FAILED (sc))
				goto ret;
		}
		else
			SearchTrace ("Search: found '%S' is not indexed\n", pwszExt);

		pMDData.clear();
	}

	//	See if any of the other translation contexts apply to this
	//	path as well.
	//
	for (it = m_vrl.begin(); it != m_vrl.end(); it++)
	{
		auto_ref_ptr<CVRoot> cvr;

		if (!m_pmu->FGetChildVRoot (it->m_pwsz, cvr))
			continue;

		cch = pwszExt.celems();
		sc = ScUrlFromSpannedStoragePath (pwszFile,
										  *(cvr.get()),
										  pwszExt.get(),
										  &cch);
		if (S_FALSE == sc)
		{
			if (NULL == pwszExt.resize(cch * sizeof(WCHAR)))
			{
				sc = E_OUTOFMEMORY;
				goto ret;
			}
			sc = ScUrlFromSpannedStoragePath (pwszFile,
											  *(cvr.get()),
											  pwszExt.get(),
											  &cch);
		}
		if (S_OK == sc)
		{
			SafeWcsCopy (pwszExt.get(), PwszUrlStrippedOfPrefix(pwszExt.get()));
			SearchTrace ("Search: found row at '%S'\n", pwszExt.get());

			//	Again, we have to see if this resource is even allowed
			//	to be indexed...
			//
			LPCWSTR pwszMbPathVRoot;
			CStackBuffer<WCHAR,128> pwszMbPathChild;
			UINT cchPrefix;
			UINT cchUrl = static_cast<UINT>(wcslen(pwszExt.get()));

			//	Map the URI to its equivalent metabase path, and make sure
			//	the URL is stripped before we call into the MDPath processing
			//
			cchPrefix = cvr->CchPrefixOfMetabasePath (&pwszMbPathVRoot);
			if (NULL == pwszMbPathChild.resize(CbSizeWsz(cchPrefix + cchUrl)))
			{
				sc = E_OUTOFMEMORY;
				goto ret;
			}
			memcpy (pwszMbPathChild.get(), pwszMbPathVRoot, cchPrefix * sizeof(WCHAR));
			memcpy (pwszMbPathChild.get() + cchPrefix, pwszExt.get(), (cchUrl + 1) * sizeof(WCHAR));

			//	As above, Emit the row (ie. call ScFindFileProps())
			//	if-and-only-if We know this url is to be indexed.
			//	In particular, can we sniff the metabase, and is
			//	the index bit set.
			//
			if (SUCCEEDED(m_pmu->HrMDGetData (pwszMbPathChild.get(),
											  pwszMbPathVRoot,
											  pMDData.load())))
			{
				if (pMDData->FIsIndexed())
				{
					//	... and get the properties
					//
					sc = ScFindFileProps (m_pmu,
										  m_cfc,
										  emitter,
										  pwszExt.get(),
										  pwszFile,
										  cvr.get(),
										  cri,
										  TRUE /*fEmbedErrorsInResponse*/);

					if (FAILED (sc))
						goto ret;
				}
				else
					SearchTrace ("Search: found '%S' is not indexed\n", pwszExt);
			}
		}
	}

	sc = S_OK;

ret:

	return sc;
}

SCODE
CFSSearch::ScCreateAccessor()
{
	SCODE sc = S_OK;
	DBORDINAL cCols = 0;

	auto_com_ptr<IColumnsInfo> pColInfo;

	// QI to the IColumnsInfo interface, with which we can get the column information
	//
	sc = m_prs->QueryInterface (IID_IColumnsInfo,
								reinterpret_cast<VOID**>(pColInfo.load()));
	if (FAILED(sc))
		goto ret;

	// get all the column information
	//
	sc = pColInfo->GetColumnInfo (&cCols, &m_rgInfo, &m_pwszBuf);
	if (FAILED(sc))
		goto ret;

	//	'Path' is the only property in our SELECT list
	//
	Assert (cCols == 1);

	m_rgBindings = (DBBINDING *) g_heap.Alloc (sizeof (DBBINDING));

	// set the m_rgBindings according to the information we know
	//
	m_rgBindings->dwPart = DBPART_VALUE | DBPART_STATUS;

	// ignored fields
	//
	m_rgBindings->eParamIO = DBPARAMIO_NOTPARAM;

	//	set column ordinal
	//
	m_rgBindings->iOrdinal = m_rgInfo->iOrdinal;

	//	set the type
	//
	m_rgBindings->wType = m_rgInfo->wType;

	//	we own the memory
	//
	m_rgBindings->dwMemOwner = DBMEMOWNER_CLIENTOWNED;

	//	set the maximum length of the column
	//
	Assert (m_rgInfo->wType == DBTYPE_WSTR);
	m_rgBindings->cbMaxLen = m_rgInfo->ulColumnSize * sizeof(WCHAR);

	//	offset to the value in the consumer's buffer
	//
	m_rgBindings->obValue = 0;

	//	offset to the status
	//
	m_rgBindings->obStatus = Align8(m_rgBindings->cbMaxLen);

	// we'll see how to deal with objects as we know more
	//
	m_rgBindings->pObject = NULL;

	// not used field
	//
	m_rgBindings->pTypeInfo = NULL;
	m_rgBindings->pBindExt = NULL;
	m_rgBindings->dwFlags = 0;

	// Create the accessor
	//
	sc = m_pAcc->CreateAccessor (DBACCESSOR_ROWDATA,	// row accessor
								 1,						// number of bindings
								 m_rgBindings,			// array of bindings
								 0,						// cbRowSize, not used
								 &m_hAcc,				// HACCESSOR *
								 NULL);					// binding status
	if (FAILED(sc))
		goto ret;

ret:
	return sc;
}

SCODE
CFSSearch::ScMakeQuery()
{
	SCODE sc = S_OK;

	//	Make sure we have a query to play with
	//	m_pCommandText is initialized in ScSetSQL, if m_pCommantText
	//	is NULL, most likely is becuase ScSetSQL is not called
	//
	if (!PwszSQL() || !m_pCommandText.get())
	{
		sc = E_DAV_NO_QUERY;
		goto ret;
	}

	// Set the command text
	//
	sc = m_pCommandText->SetCommandText (DBGUID_DEFAULT, PwszSQL());
	if (FAILED (sc))
	{
		DebugTrace("pCommandText->SetCommandText failed\n");
		goto ret;
	}

	//	Excute the query
	//
	sc = m_pCommandText->Execute (NULL,
								  IID_IRowset,
								  0,
								  0,
								  reinterpret_cast<IUnknown**>(m_prs.load()));
	if (FAILED(sc) || (!m_prs))
	{
		DebugTrace("pCommandText->Execute failed\n");

		//	Munge a few, select error codes
		//	Map these errors locally, as they may only come back from Execute
		//
		switch (sc)
		{
			case QUERY_E_FAILED:			//$REVIEW: Is this a bad request?
			case QUERY_E_INVALIDQUERY:
			case QUERY_E_INVALIDRESTRICTION:
			case QUERY_E_INVALIDSORT:
			case QUERY_E_INVALIDCATEGORIZE:
			case QUERY_E_ALLNOISE:
			case QUERY_E_TOOCOMPLEX:
			case QUERY_E_TIMEDOUT:			//$REVIEW: Is this a bad request?
			case QUERY_E_DUPLICATE_OUTPUT_COLUMN:
			case QUERY_E_INVALID_OUTPUT_COLUMN:
			case QUERY_E_INVALID_DIRECTORY:
			case QUERY_E_DIR_ON_REMOVABLE_DRIVE:
			case QUERY_S_NO_QUERY:
				sc = E_INVALIDARG;			// All query errors will be mapped to 400
				break;
		}

		goto ret;
	}

ret:
	return sc;
}

//	DAV-Search Implementation -------------------------------------------------
//
class CSearchRequest :
	public CMTRefCounted,
	private IAsyncIStreamObserver
{
	//
	//	Reference to the CMethUtil
	//
	auto_ref_ptr<CMethUtil> m_pmu;

	//	Contexts
	//
	auto_ref_ptr<CNFSearch> m_pnfs;
	CFSSearch m_csc;

	//	Request body as an IStream.  This stream is async -- it can
	//	return E_PENDING from Read() calls.
	//
	auto_ref_ptr<IStream> m_pstmRequest;

	//	The XML parser used to parse the request body using
	//	the node factory above.
	//
	auto_ref_ptr<IXMLParser> m_pxprs;

	//	IAsyncIStreamObserver
	//
	VOID AsyncIOComplete();

	//	State functions
	//
	VOID ParseBody();
	VOID DoSearch();
	VOID SendResponse( SCODE sc );

	//	NOT IMPLEMENTED
	//
	CSearchRequest (const CSearchRequest&);
	CSearchRequest& operator= (const CSearchRequest&);

public:
	//	CREATORS
	//
	CSearchRequest(LPMETHUTIL pmu) :
		m_pmu(pmu),
		m_csc(pmu)
	{
	}

	//	MANIPULATORS
	//
	VOID Execute();
};

VOID
CSearchRequest::Execute()
{
	CResourceInfo cri;
	LPCWSTR pwsz;
	LPCWSTR pwszPath = m_pmu->LpwszPathTranslated();
	SCODE sc = S_OK;

	//
	//	First off, tell the pmu that we want to defer the response.
	//	Even if we send it synchronously (i.e. due to an error in
	//	this function), we still want to use the same mechanism that
	//	we would use for async.
	//
	m_pmu->DeferResponse();

	//	Do ISAPI application and IIS access bits checking
	//
	sc = m_pmu->ScIISCheck (m_pmu->LpwszRequestUrl(), MD_ACCESS_READ);
	if (FAILED(sc))
	{
		//	Either the request has been forwarded, or some bad error occurred.
		//	In either case, quit here and map the error!
		//
		SendResponse(sc);
		return;
	}

	//  Look to see the Content-length - required for this operation
	//  to continue.
	//
	//
	if (NULL == m_pmu->LpwszGetRequestHeader (gc_szContent_Length, FALSE))
	{
		pwsz = m_pmu->LpwszGetRequestHeader (gc_szTransfer_Encoding, FALSE);
		if (!pwsz || _wcsicmp (pwsz, gc_wszChunked))
		{
			DavTrace ("Dav: PUT: missing content-length in request\n");
			SendResponse(E_DAV_MISSING_LENGTH);
			return;
		}
	}

	//	Search must have a content-type header and value must be text/xml
	//
	sc = ScIsContentTypeXML (m_pmu.get());
	if (FAILED(sc))
	{
		DebugTrace ("Dav: PROPPATCH fails without specifying a text/xml contenttype\n");
		SendResponse(sc);
		return;
	}

	//  Check to see if the resource exists
	//
	sc = cri.ScGetResourceInfo (pwszPath);
	if (FAILED (sc))
	{
		SendResponse(sc);
		return;
	}

	//	Ensure the URI and resource match
	//
	(void) ScCheckForLocationCorrectness (m_pmu.get(), cri, NO_REDIRECT);

	//	Check state headers here.
	//
	sc = HrCheckStateHeaders (m_pmu.get(), pwszPath, FALSE);
	if (FAILED (sc))
	{
		DebugTrace ("DavFS: If-State checking failed.\n");
		SendResponse(sc);
		return;
	}

	//	BIG NOTE ABOUT LOCKING
	//
	//	The mechanism we actually use to do the search doesn't
	//	have any way to access our locked files.  So we are punting
	//	on supporting locktokens passed into SEARCH.
	//	So, for now, on DAVFS, don't bother to check locktokens.
	//	(This isn't a big problem because currently DAVFS can only
	//	lock single files, not whole directories, AND becuase currently
	//	our only locktype is WRITE, so our locks won't prevent the
	//	content-indexer from READING the file!)
	//
	//	NOTE: We still have to consider if-state-match headers,
	//	but that is done elsewhere (above -- HrCheckStateHeaders).
	//

	//	Instantiate the XML parser
	//
	m_pnfs.take_ownership(new CNFSearch(m_csc));
	m_pstmRequest.take_ownership(m_pmu->GetRequestBodyIStream(*this));

	sc = ScNewXMLParser( m_pnfs.get(),
						 m_pstmRequest.get(),
						 m_pxprs.load() );

	if (FAILED(sc))
	{
		DebugTrace( "CSearchRequest::Execute() - ScNewXMLParser() failed (0x%08lX)\n", sc );
		SendResponse(sc);
		return;
	}

	//	Start parsing it into the context
	//
	ParseBody();
}

VOID
CSearchRequest::ParseBody()
{
	Assert( m_pxprs.get() );
	Assert( m_pnfs.get() );
	Assert( m_pstmRequest.get() );

	//
	//	Add a ref for the following async operation.
	//	Use auto_ref_ptr rather than AddRef() for exception safety.
	//
	auto_ref_ptr<CSearchRequest> pRef(this);

	SCODE sc = ScParseXML (m_pxprs.get(), m_pnfs.get());

	if ( SUCCEEDED(sc) )
	{
		Assert( S_OK == sc || S_FALSE == sc );

		DoSearch();
	}
	else if ( E_PENDING == sc )
	{
		//
		//	The operation is pending -- AsyncIOComplete() will take ownership
		//	ownership of the reference when it is called.
		//
		pRef.relinquish();
	}
	else
	{
		DebugTrace( "CSearchRequest::ParseBody() - ScParseXML() failed (0x%08lX)\n", sc );
		SendResponse(sc);
	}
}

VOID
CSearchRequest::AsyncIOComplete()
{
	//	Take ownership of the reference added for the async operation.
	//
	auto_ref_ptr<CSearchRequest> pRef;
	pRef.take_ownership(this);

	ParseBody();
}

VOID
CSearchRequest::DoSearch()
{
	SCODE sc;

	//	Do the search
	//
	sc = m_csc.ScMakeQuery();
	if (FAILED (sc))
	{
		SendResponse(sc);
		return;
	}

	//	All header must be emitted before chunked XML emitting starts
	//
	m_pmu->SetResponseHeader (gc_szContent_Type, gc_szText_XML);

	//	Set the response code and go
	//
	m_pmu->SetResponseCode( HscFromHresult(W_DAV_PARTIAL_SUCCESS),
							NULL,
							0,
							CSEFromHresult(W_DAV_PARTIAL_SUCCESS) );

	//	Emit the results
	//
	auto_ref_ptr<CXMLEmitter> pmsr;
	auto_ref_ptr<CXMLBody>	  pxb;

	//	Get the XML body
	//
	pxb.take_ownership (new CXMLBody (m_pmu.get()));

	pmsr.take_ownership (new CXMLEmitter(pxb.get(), m_csc.PPreloadNamespaces()));
	sc = pmsr->ScSetRoot (gc_wszMultiResponse);
	if (FAILED (sc))
	{
		SendResponse(sc);
		return;
	}

	sc = m_csc.ScEmitResults (*pmsr);
	if (FAILED (sc))
	{
		SendResponse(sc);
		return;
	}

	//	Done with the reponse
	//
	pmsr->Done();
	m_pmu->SendCompleteResponse();
}

VOID
CSearchRequest::SendResponse( SCODE sc )
{
	//
	//	Set the response code and go
	//
	m_pmu->SetResponseCode( HscFromHresult(sc), NULL, 0, CSEFromHresult(sc) );
	m_pmu->SendCompleteResponse();
}

void
DAVSearch (LPMETHUTIL pmu)
{
	auto_ref_ptr<CSearchRequest> pRequest(new CSearchRequest(pmu));

	pRequest->Execute();
}

//	class CSearchRowsetContext ------------------------------------------------
//
enum { CROW_GROUP = 16 };

//	Mapping from DBSTATUS to HSC.
//
ULONG
CSearchRowsetContext::HscFromDBStatus (ULONG ulStatus)
{
	switch (ulStatus)
	{
		case DBSTATUS_S_OK:
		case DBSTATUS_S_ISNULL:
		case DBSTATUS_S_TRUNCATED:
		case DBSTATUS_S_DEFAULT:
			return HSC_OK;

		case DBSTATUS_E_BADACCESSOR:
			return HSC_BAD_REQUEST;

		case DBSTATUS_E_UNAVAILABLE:
			return HSC_NOT_FOUND;

		case DBSTATUS_E_PERMISSIONDENIED:
			return HSC_UNAUTHORIZED;

		case DBSTATUS_E_DATAOVERFLOW:
			return HSC_INSUFFICIENT_SPACE;

		case DBSTATUS_E_CANTCONVERTVALUE:
		case DBSTATUS_E_SIGNMISMATCH:
		case DBSTATUS_E_CANTCREATE:
		case DBSTATUS_E_INTEGRITYVIOLATION:
		case DBSTATUS_E_SCHEMAVIOLATION:
		case DBSTATUS_E_BADSTATUS:

			//	What error shoud these match to?
			//	return 400 temporarily.
			//
			return HSC_BAD_REQUEST;

		default:

			TrapSz ("New DBStutus value");
			return HSC_NOT_FOUND;
	}
}

SCODE
CSearchRowsetContext::ScEmitResults (CXMLEmitter& emitter)
{
	SCODE sc = S_OK;
	BOOL fReadAll = FALSE;

	//	Allocate enough space for the data buffer
	//
	if (!m_pData)
	{
		ULONG_PTR cbSize;

		//	Get the IAccessor interface, used later to release the accessor
		//
		sc = m_prs->QueryInterface (IID_IAccessor, (LPVOID *)&m_pAcc);
		if (FAILED(sc))
			goto ret;

		// Create the accessor
		//
		sc = ScCreateAccessor();
		if (FAILED(sc))
			goto ret;

		//	Calculate the size of the buffer needed by each row.
		//	(including a ULONG for status)
		//
		cbSize = Align8(m_rgBindings->cbMaxLen) + Align8(sizeof(ULONG));

		//	allocate enough memory for the data buffer on stack
		//
		m_pData = (BYTE *)g_heap.Alloc(cbSize);
	}

	while (!fReadAll)
	{
		sc = m_prs->GetNextRows(NULL, 0, CROW_GROUP, (DBCOUNTITEM *) &m_cHRow, &m_rgHRow);
		if (sc)
		{
			if (sc == DB_S_ENDOFROWSET)
			{
				// we have read all the rows, we'll be done after this loop
				//
				fReadAll = TRUE;
			}
			else
				goto ret;
		}

		if (!m_cHRow)
		{
			// no rows available, this happens when no rows in the rowset at all
			//
			break;
		}

		AssertSz (m_rgHRow, "something really bad happened");

		// For each row we have now, get data and convert it to XML and dump to the stream.
		//
		for (ULONG ihrow = 0; ihrow < m_cHRow; ihrow++)
		{
			AssertSz(m_rgHRow[ihrow], "returned row handle is NULL");

			//	get the data of one row.
			//
			sc = m_prs->GetData(m_rgHRow[ihrow], m_hAcc, m_pData);
			if (FAILED(sc) && (sc != DB_E_ERRORSOCCURRED))
				goto ret;

			//	Emit the row
			//
			sc = ScEmitRow (emitter);
			if (FAILED(sc))
				goto ret;
		}

		// Don't forget to clean up.
		//
		sc = m_prs->ReleaseRows (m_cHRow, m_rgHRow, NULL, NULL, NULL);
		if (FAILED(sc))
			goto ret;

		// free the memory retured from OLEDB provider with IMalloc::Free
		//
		CoTaskMemFree (m_rgHRow);
		m_rgHRow = NULL;
		m_cHRow = 0;
	}

ret:

	CleanUp();
	return sc;
}

VOID
CSearchRowsetContext::CleanUp()
{
	//	Try out best to clean up

	//	clean the array of HRows
	//
	if (m_rgHRow)
	{
		m_prs->ReleaseRows (m_cHRow, m_rgHRow, NULL, NULL, NULL);
		CoTaskMemFree (m_rgHRow);
	}

	//	Release the accessor handle
	//
	if (m_hAcc != DB_INVALID_HACCESSOR)
	{
		m_pAcc->ReleaseAccessor (m_hAcc, NULL);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\lockutil.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	LOCKUTIL.CPP
//
//		HTTP 1.1/DAV 1.0 LOCK request handling UTILITIES
//
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include "_davfs.h"

#include <tchar.h>	//_strspnp
#include <statetok.h>
#include <xlock.h>

#include "_shlkmgr.h"

//	========================================================================
//
//	ScLockDiscoveryFromCLock
//
//		Takes an emitter and an already-constructed lockdiscovery node,
//		and adds an activelock node for this CLock under it.
//		May be called multiple times -- each call will add a new activelock
//		node under the lockdiscovery node in en.
//$HACK:ROSEBUD_OFFICE9_TIMEOUT_HACK
//		For the bug where rosebud waits until the last second
//		before issueing the refresh. Need to filter out this check with
//		the user agent string. The hack is to increase the timeout
//		by 30 seconds and return the actual timeout. So we
//		need the ecb/pmu to findout the user agent. If we
//		remove this	hack ever (I doubt if we can ever do that), then
//		change the interface of ScLockDiscoveryFromCLock.
//$HACK:END ROSEBUD_OFFICE9_TIMEOUT_HACK
//
SCODE
ScLockDiscoveryFromCLock (LPMETHUTIL pmu,
	CXMLEmitter& emitter,
	CEmitterNode& en,
	CLockFS* pLock)
{
	BOOL fRollback;
	BOOL fDepthInfinity;
	DWORD dwLockInfo;
	LPCWSTR wszLockScope = NULL;
	LPCWSTR wszLockType = NULL;
	SCODE sc = S_OK;
	DWORD	dwSeconds = 0;

	Assert (pLock);

	//	Get the lock flags from the lock.
	//
	dwLockInfo = pLock->GetLockType();

	//	Note if the lock is a rollback
	//
	fRollback = !!(dwLockInfo & DAV_LOCKTYPE_ROLLBACK);

	//	Note if the lock is a rollback
	//
	fDepthInfinity = !!(dwLockInfo & DAV_RECURSIVE_LOCK);

	//	Write lock?
	//
	if (dwLockInfo & GENERIC_WRITE)
		wszLockType = gc_wszLockTypeWrite;
#ifdef	DBG
	if (dwLockInfo & GENERIC_READ)
		wszLockType = L"read";
#else	// !DBG
	else
	{
		TrapSz ("unexpected lock type");
	}
#endif	// DBG, else

	//	Lock scope
	//
	dwLockInfo = pLock->GetLockScope();
	if (dwLockInfo & DAV_SHARED_LOCK)
		wszLockScope = gc_wszLockScopeShared;
	else
	{
		Assert (dwLockInfo & DAV_EXCLUSIVE_LOCK);
		wszLockScope = gc_wszLockScopeExclusive;
	}

	dwSeconds = pLock->GetTimeoutInSecs();

	//$HACK:ROSEBUD_OFFICE9_TIMEOUT_HACK
	//  For the bug where rosebud waits until the last second
	//  before issueing the refresh. Need to filter out this check with
	//  the user agent string. The hack is to increase the timeout
	//	by 30 seconds. Now decrease 30 seconds to send requested timeout.
	//
	if (pmu && pmu->FIsOffice9Request())
	{
		Assert(dwSeconds > gc_dwSecondsHackTimeoutForRosebud);
		dwSeconds -= gc_dwSecondsHackTimeoutForRosebud;
	}
	//$HACK: END: ROSEBUD_OFFICE9_TIMEOUT_HACK

	//	Construct the lockdiscovery node
	//
	sc = ScBuildLockDiscovery (emitter,
							   en,
							   pLock->GetLockTokenString(),
							   wszLockType,
							   wszLockScope,
							   fRollback,
							   fDepthInfinity,
							   dwSeconds,
							   pLock->PwszOwnerComment(),
							   NULL);
	if (FAILED (sc))
		goto ret;

ret:
	return sc;
}

//	------------------------------------------------------------------------
//
//	ScAddSupportedLockProp
//
//		Add a lockentry node with the listed information.
//		NOTE: wszExtra is currently used for rollback information.
//
SCODE
ScAddSupportedLockProp (CEmitterNode& en,
	LPCWSTR wszLockType,
	LPCWSTR wszLockScope,
	LPCWSTR wszExtra = NULL)
{
	CEmitterNode enEntry;
	SCODE sc = S_OK;

	Assert (wszLockType);
	Assert (wszLockScope);

	//	Create a lockentry node to hold this info.
	//
	sc = en.ScAddNode (gc_wszLockEntry, enEntry);
	if (FAILED (sc))
		goto ret;

	//	Create a node for the locktype under the lockentry.
	//
	{
		//	Must scope here, all sibling nodes must be constructed sequentially
		//
		CEmitterNode enType;
		sc = enEntry.ScAddNode (wszLockType, enType);
		if (FAILED (sc))
			goto ret;
	}

	//	Create a node for the locktype under the lockentry.
	//
	{
		//	Must scope here, all sibling nodes must be constructed sequentially
		//
		CEmitterNode enScope;
		sc = enEntry.ScAddNode (wszLockScope, enScope);
		if (FAILED (sc))
			goto ret;
	}

	//	If we have extra info, create a node for it under the lockentry.
	//
	if (wszExtra)
	{
		//	Must scope here, all sibling nodes must be constructed sequentially
		//
		CEmitterNode enExtra;
		sc = enEntry.ScAddNode (wszExtra, enExtra);
		if (FAILED (sc))
			goto ret;
	}

ret:
	return sc;
}

//	------------------------------------------------------------------------
//
//	HrGetLockProp
//
//		Get the requested lock property for the requested resource.
//		(The lock properties are lockdiscovery and supportedlock.)
//		Lockdiscovery and supportedlock should ALWAYS be found --
//		they are required DAV: properties.  Add an empty node if there is
//		no real data to return.
//		NOTE: This function still assumes that write is the only locktype.
//		It will NOT add read/mixed locktypes.
//
//	Returns
//		S_FALSE if prop not found/not recognized.
//		error only if something really bad happens.
//
//$REVIEW: Should I return the depth element too? -- No (for now).
//$REVIEW: Spec does NOT list depth under the lockentry XML element.
//
HRESULT
HrGetLockProp (LPMETHUTIL pmu,
	LPCWSTR wszPropName,
	LPCWSTR wszResource,
	RESOURCE_TYPE rtResource,
	CXMLEmitter& emitter,
	CEmitterNode& enParent)
{
	SCODE sc = S_OK;

	Assert (pmu);
	Assert (wszPropName);
	Assert (wszResource);

	if (!wcscmp (wszPropName, gc_wszLockDiscovery))
	{
		//	Fill in lockdiscovery info.
		//

		//	Check for any lock in our lock cache.
		//	This call will scan the lock cache for any matching items
		//	and add a 'DAV:activelock' node for each match.
		//	We pass in DAV_LOCKTYPE_FLAGS so that we will find all matches.
		//
		if (!CSharedLockMgr::Instance().FGetLockOnError (pmu,
				wszResource,
				DAV_LOCKTYPE_FLAGS,
				TRUE,			//		Emit XML body
				&emitter,
				enParent.Pxn()))
		{
			//	This resource is not in our lock cache.
			//
			FsLockTrace ("HrGetLockProp -- No locks found for lockdiscovery.\n");

			//	And return.  This is a SUCCESS case!
			//
		}
	}
	else if (!wcscmp (wszPropName, gc_wszLockSupportedlock))
	{
		DWORD dwLockType;
		CEmitterNode en;

		//	Construct the 'DAV:supportedlock' node
		//
		sc = en.ScConstructNode (emitter, enParent.Pxn(), gc_wszLockSupportedlock);
		if (FAILED (sc))
			goto ret;

		//	Get the list of supported lock flags from the impl.
		//
		dwLockType = DwGetSupportedLockType (rtResource);
		if (!dwLockType)
		{
			//	No locktypes are supported.  We already have our empty
			//	supportedlock node.
			//	Just return.  This is a SUCCESS case!
			goto ret;
		}

		//	Add a lockentry node under the supportedlock node for each
		//	combination of flags that we detect.
		//
		//	NOTE: Currently, write is the only allowed access type.
		//
		if (dwLockType & GENERIC_WRITE)
		{
			//	Add a lockentry for each lockscope in the flags.
			//
			if (dwLockType & DAV_SHARED_LOCK)
			{
				sc = ScAddSupportedLockProp (en,
											 gc_wszLockTypeWrite,
											 gc_wszLockScopeShared);
				if (FAILED (sc))
					goto ret;

				//	If we support lock rollback, add another lockentry for this combo.
				//
				if (dwLockType & DAV_LOCKTYPE_ROLLBACK)
				{
					sc = ScAddSupportedLockProp (en,
						gc_wszLockTypeWrite,
						gc_wszLockScopeShared,
						gc_wszLockRollback);
					if (FAILED (sc))
						goto ret;
				}
			}
			if (dwLockType & DAV_EXCLUSIVE_LOCK)
			{
				sc = ScAddSupportedLockProp (en,
											 gc_wszLockTypeWrite,
											 gc_wszLockScopeExclusive);
				if (FAILED (sc))
					goto ret;

				//	If we support lock rollback, add another lockentry for this combo.
				//
				if (dwLockType & DAV_LOCKTYPE_ROLLBACK)
				{
					sc = ScAddSupportedLockProp (en,
						gc_wszLockTypeWrite,
						gc_wszLockScopeExclusive,
						gc_wszLockRollback);
					if (FAILED (sc))
						goto ret;
				}
			}

		}

	}
	else
	{
		//	Unrecognized lock property.  So we clearly do not have one
		//
		sc = S_FALSE;
		goto ret;
	}

ret:
	return sc;
}

//	------------------------------------------------------------------------
//
//	FLockViolation
//
//		TRUE return here means that we found a lock, and sent the response.
//
//$LATER: Need to be able to return an error here!
//
BOOL
FLockViolation (LPMETHUTIL pmu, HRESULT hr, LPCWSTR pwszPath, DWORD dwAccess)
{
	BOOL fFound = FALSE;
	SCODE sc = S_OK;
	auto_ref_ptr<CXMLBody>		pxb;
	auto_ref_ptr<CXMLEmitter>	emitter;

	Assert (pmu);
	Assert (pwszPath);
	AssertSz (dwAccess, "FLockViolation: Looking for a lock with no access!");

	//	Construct the root ('DAV:prop') for the lock response
	//$NOTE: this xml body is created NOT chunked
	//
	pxb.take_ownership (new CXMLBody (pmu, FALSE) );
	emitter.take_ownership (new CXMLEmitter(pxb.get()));

	sc = emitter->ScSetRoot (gc_wszProp);
	if (FAILED (sc))
		goto ret;

	//	If the error code is one of the "locked" error codes,
	//	check our lock cache for a corresponding lock object.
	//
	if ((ERROR_SHARING_VIOLATION == hr ||
		 HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION) == hr ||
		 STG_E_SHAREVIOLATION == hr) &&
		 CSharedLockMgr::Instance().FGetLockOnError (pmu, pwszPath, dwAccess, TRUE, emitter.get(), emitter->PxnRoot()))
	{
		//	Set our found bit to TRUE now, so that we'll report the lock's
		//	existence, even if the emitting below fails!
		//	NOTE: This is important for scenarios, like HTTPEXT PROPPATCH
		//	and destination deletion for Overwrite handling,  that
		//	PRE-check the lock cache (protocol-enforced locks)
		//	before trying to hit the file.
		//
		fFound = TRUE;

		//	Set content type header
		//
		pmu->SetResponseHeader (gc_szContent_Type, gc_szText_XML);

		//	Must set the response code before we set the body data.
		//
		pmu->SetResponseCode (HSC_LOCKED, NULL, 0);

		//	Emit the XML body
		//
		emitter->Done();

	}

	//	Tell our caller if we found any locks on this item.
	//
ret:
	return fFound;
}


BOOL FDeleteLock (LPMETHUTIL pmu, __int64 i64LockId)
{
	Assert (pmu);
	Assert (i64LockId);

	CSharedLockMgr::Instance().DeleteLock (i64LockId);
	return TRUE;
}


//	------------------------------------------------------------------------
//
//	HrLockIdFromString
//
//		Returns S_OK on success (syntax check and conversion).
//		Returns E_DAV_INVALID_HEADER on syntax error or non-matching token guid (not ours).
//
HRESULT
HrLockIdFromString (LPMETHUTIL pmu, LPCWSTR pwszToken,
					__int64 * pi64LockId)
{
	LPCWSTR pwsz = pwszToken;
	LPCWSTR pwszGuid;

	Assert (pmu);
	Assert (pwszToken);
	Assert (pi64LockId);

	*pi64LockId = 0;

	//	Skip any initial whitespace.
	//
	pwsz = _wcsspnp (pwsz, gc_wszLWS);
	if (!pwsz)
	{
		FsLockTrace ("Dav: Invalid locktoken in HrLockIdFromString.\n");
		return E_DAV_INVALID_HEADER;
	}

	//	Skip delimiter: double-quotes or angle-brackets.
	//	It's okay if no delimiter is present.  Caller just passed us raw locktoken string.
	//
	if (L'\"' == *pwsz ||
	    L'<' == *pwsz)
		pwsz++;

	if (wcsncmp (gc_wszOpaquelocktokenPrefix, pwsz, gc_cchOpaquelocktokenPrefix))
	{
		FsLockTrace ("Dav: Lock token is missing opaquelocktoken: prefix.\n");
		return E_DAV_INVALID_HEADER;
	}

	//	Skip the opaquelocktoken: prefix.
	//
	pwsz += gc_cchOpaquelocktokenPrefix; // replaces: strchr (psz, ':'); psz++;
	if (!pwsz)
	{
		FsLockTrace ("Dav: Error skipping opaquelocktoken: tag.\n");
		return E_DAV_INVALID_HEADER;
	}

	//	Compare GUIDS here
	//
	pwszGuid = CSharedLockMgr::Instance().WszGetGuid();
	if (!pwszGuid || _wcsnicmp(pwsz, pwszGuid, wcslen(pwszGuid)))
	{
		FsLockTrace ("Dav: Error comparing guids -- not our locktoken!\n");
		return E_DAV_INVALID_HEADER;
	}

	//	Skip the GUID, go to the lockid string.
	//
	pwsz = wcschr (pwsz, L':');
	if (!pwsz)
	{
		FsLockTrace ("Dav: Error skipping guid of opaquelocktoken.\n");
		return E_DAV_INVALID_HEADER;
	}
	//	And skip the colon separator.
	//
	Assert (L':' == *pwsz);
	pwsz++;

	//	Convert the string to an int64 lockid and return.
	//
	*pi64LockId = _wtoi64 (pwsz);

	if (!*pi64LockId)
	{
		return E_DAV_INVALID_HEADER;
	}

	return S_OK;
}


//	------------------------------------------------------------------------
//
//	HrLockPathFromId
//
//		This should ONLY be used in HrCheckStateMatch (and helpers).
//		It is INEFFICIENT for all other purposes.  It loads the lock from
//		the cache in order to check the resource name.
//
//		For now, this just grabs a pointer to the name.
//		Later, for thread safety reasons, we should do the string copy.
//
//		Returns S_OK on success (lock exists).
//		Returns E_DAV_LOCK_NOT_FOUND (from ILockCache::HrGetLock) on lock not found.
//
//		This DOES update the lock's timeout on success.
//		This DOES obey the auth-checking when fetching the lock.
//
HRESULT
HrLockPathFromId (LPMETHUTIL pmu, __int64 i64LockId, LPCWSTR * ppwsz)
{
	HRESULT hr = S_OK;
	auto_ref_ptr<CLockFS> plock;

	Assert(pmu);
	Assert(i64LockId);
	Assert(ppwsz);
	*ppwsz = NULL;

	hr = CSharedLockMgr::Instance().HrGetLock (pmu, i64LockId, plock.load());
	if (FAILED(hr))
	{
		goto ret;
	}

	//	Pass back a pointer to the name.
	//	NOTE: The timeout for this lock object has just been updated
	//	(in the fetch above).  Make sure to use this pointer BEFORE
	//	timeout or delete of the lock can possibly happen!!!!!
	//
	*ppwsz = plock->GetResourceName();

ret:
	return hr;
}


//	------------------------------------------------------------------------
//	HrValidTokenExpression()
//
//	Helper function for If: header processing.
//	Once we've found a token, this function will check the path.
//	(So this function only succeeds completely if the token is still valid,
//	AND the token matches the provided path.)
//	If this token is valid, this function returns S_OK;
//	If this token is not valid, this function returns E_DAV_INVALID_HEADER.
//
HRESULT
HrValidTokenExpression (IMethUtil * pmu, LPCWSTR pwszToken, LPCWSTR pwszPath,
					    OUT __int64 * pi64LockId)
{
	HRESULT hr;
	__int64 i64LockId;
	LPCWSTR pwsz;

	Assert (pmu);
	Assert (pwszToken);
	Assert (pwszPath);

	//	Get the lock tokens
	//
	hr = HrLockIdFromString (pmu, pwszToken, &i64LockId);
	if (E_DAV_INVALID_HEADER == hr)
	{
		//	Unrecognized locktoken.  Does not match.
		//
		goto Exit;
	}
	Assert (S_OK == hr);

	//	Check if the locktoken is valid (live in the cache).
	//	E_DAV_INVALID_HEADER means the lock was not found.
	//
	hr = HrLockPathFromId (pmu, i64LockId, &pwsz);
	if (FAILED(hr))
	{
		//	Timed out locktoken.  Does not match.
		//
		hr = E_DAV_INVALID_HEADER;
		goto Exit;
	}
	Assert (S_OK == hr);

	//	Check the paths.
	//
	if (_wcsicmp (pwsz, pwszPath))
	{
		//	Path doesn't match locktoken.  Does not match.
		//
		hr = E_DAV_INVALID_HEADER;
		goto Exit;
	}

	//	If they requested the lock id back, give it to 'em.
	//
	if (pi64LockId)
		*pi64LockId = i64LockId;

Exit:
	return hr;
}


//	------------------------------------------------------------------------
//
//	HrCheckIfHeader
//
//		Check the If header.
//		Processing will check the lock cache to validate locktokens.
//
//		The pmu (IMethUtil) is provided for access to the lock cache to check tokens.
//		The pwszPath provides the path to match for untagged lists.
//
//	Format of the If header
//		If = "If" ":" ( 1*No-tag-list | 1*Tagged-list)
//		No-tag-list = List
//		Tagged-list = Resource 1*List
//		Resource = Coded-url
//		List = "(" 1*(["Not"](State-token | "[" entity-tag "]")) ")"
//		State-token = Coded-url
//		Coded-url = "<" URI ">"
//	Basically, one thing has to match in the whole header in order for the
//	entire header to be "good".
//	Each URI has a _set_ of state lists.  A list is enclosed in parentheses.
//	Each list is a logical "and".
//	A set of lists is a logical "or".
//
//	Returns:
//		S_OK			Process the method.
//		other error		Map the error
//			(412 will be handled by this case)
//
//	DAV-compliance shortfalls
//	We fall short of true DAV-compliance in three spots in this function.
//	1 -	This code does not prevent (fail) an utagged list followed by
//		a tagged list.  Strict DAV-compliance would FAIL such an If-header
//		as a bad request.
//	2 - This code does not "correctly" apply tagged lists with multiple
//		URIs.  Strict DAV-compliance would require evaluating the If-header
//		once for each URI as the method is processed, and ignore any URIs
//		in the tagged list that never were "processed".  We don't (can't)
//		process our MOVE/COPY/DELETEs that way, but instead do a pre-checking
//		pass on the If: header.  At pre-check time, we treat the If-header
//		as if the tagged lists are all AND-ed together.
//		THIS MEANS that if a URI is listed, and it doesn't have a good
//		matching (valid) list, we will FAIL the whole method with 412 Precondition Failed.
//	3 -	This code does not handle ETags in the If-header.
//
//$LATER: When we are part of the locktoken header, check the m_fPathsSet.
//$LATER: We might be able to get our info quicker if paths are already set!
//
HRESULT
HrCheckIfHeader (IMethUtil * m_pmu,	// to ease the transition later...
				 LPCWSTR pwszDefaultPath)
{
	HRESULT hr = S_OK;
	BOOL fOneMatch = FALSE;
	FETCH_TOKEN_TYPE tokenNext = TOKEN_SAME_LIST;
	LPCWSTR pwsz;
	LPCWSTR pwszToken;
	LPCWSTR pwszPath = pwszDefaultPath;
	CStackBuffer<WCHAR,MAX_PATH> pwszTranslated;
	BOOL fFirstURI;
	WCHAR rgwchEtag[MAX_PATH];

	//	Quick check -- if the header doesn't exist, just process the method.
	//
	pwsz = m_pmu->LpwszGetRequestHeader (gc_szLockToken, TRUE);
	if (!pwsz)
		return S_OK;

	IFITER iter(pwsz);

	//	Double nested loop
	//	First loop (outer loop) looks through all the "tagged lists"
	//	(tagged list = URI + set of lists of tokens)
	//	If the first list is untagged, use the default path (the request URI)
	//	for the untagged first set of lists.
	//	Second loop looks through all the token lists for a single URI.
	//
	//	NOTE: This code does NOT perfectly implement the draft.
	//	The draft says that an untagged production (no initial URI)
	//	can't have any subsequent URIs.  Frankly, that's much more complex to
	//	implement -- need to set another bool var and DISALLOW that one case.
	//	So I'm skipping it for now. --BeckyAn
	//

	fFirstURI = TRUE;
	for (pwsz = iter.PszNextToken (TOKEN_URI); // start with the first URI
		 pwsz || fFirstURI;
		 pwsz = iter.PszNextToken (TOKEN_NEW_URI))  // skip to the next URI in the list
	{

		//	If our search for the first URI came up blank, use
		//	the default path instead.
		//	NOTE: This can only happen if it's the first URI (fFirstURI is TRUE)
		//	(we explicitly check psz in the loop condition, and QUIT the loop
		//	if neither psz or fFirstURI are true).
		//
		if (!pwsz)
		{
			Assert (fFirstURI);
			pwszPath = pwszDefaultPath;
		}
		else
		{
			//	If we have a name (tag, uri), use it instead of the default name.
			//
			CStackBuffer<WCHAR,MAX_PATH>	pwszNormalized;
			SCODE sc;
			UINT cch;

			//	NOTE: Our psz is still quoted with <>.  Unescaping must ignore these chars.
			//
			Assert (L'<' == *pwsz);

			//	Get sufficient buffer for canonicalization
			//
			cch = static_cast<UINT>(wcslen(pwsz + 1));
			if (NULL == pwszNormalized.resize(CbSizeWsz(cch)))
			{
				FsLockTrace ("HrCheckIfHeader() - Error while allocating memory 0x%08lX\n", E_OUTOFMEMORY);
				return E_OUTOFMEMORY;
			}

			//	Canonicalize the URL taking into account that it may be fully qualified.
			//	Does not mater what value we pass in cch - it is out parameter only.
			//
			sc = ScCanonicalizePrefixedURL (pwsz + 1,
											pwszNormalized.get(),
											&cch);
			if (S_OK != sc)
			{
				//	We gave sufficient space
				//
				Assert(S_FALSE != sc);
				FsLockTrace ("HrCheckIfHeader() - ScCanonicalizePrefixedURL() failed 0x%08lX\n", sc);
				return sc;
			}

			//	We're in a loop, so try to use a static buffer first when
			//	converting this storage path.
			//
			cch = pwszTranslated.celems();
			sc = m_pmu->ScStoragePathFromUrl (pwszNormalized.get(),
											  pwszTranslated.get(),
											  &cch);
			if (S_FALSE == sc)
			{
				if (NULL == pwszTranslated.resize(cch))
					return E_OUTOFMEMORY;

				sc = m_pmu->ScStoragePathFromUrl (pwszNormalized.get(),
												  pwszTranslated.get(),
												  &cch);
			}
			if (FAILED (sc))
			{
				FsLockTrace ("HrCheckIfHeader -- failed to translate a URI to a path.\n");
				return sc;
			}
			Assert ((S_OK == sc) || (W_DAV_SPANS_VIRTUAL_ROOTS == sc));

			//	Sniff the last character and remove any final quoting '>' here.
			//
			cch = static_cast<UINT>(wcslen(pwszTranslated.get()));
			if (L'>' == pwszTranslated[cch - 1])
				pwszTranslated[cch - 1] = L'\0';

			//	Hold onto the path.
			//
			pwszPath = pwszTranslated.get();
		}
		Assert (pwszPath);

		//	This is no longer our first time through the URI loop.  Clear our flag.
		//
		fFirstURI = FALSE;

		//	Loop through all tokens, checking as we go.
		//$REVIEW: Right now, PszNextToken can't give different returns
		//$REVIEW: for "not found" versus "syntax error".
		//$REVIEW: That means we'll can't really give different, distinct
		//$REVEIW: codes for syntax problems -- any failure is mapped to 412 Precond Failed.
		//
		for (pwszToken = iter.PszNextToken (TOKEN_START_LIST) ;
			 pwszToken;
			 pwszToken = iter.PszNextToken (tokenNext) )
		{
			Assert (pwszToken);

			//	Check this one token for validity.
			//$LATER: These checks could be folded into the HrValidTokenExpression
			//$LATER: call.  This will be important later, when we have
			//$LATER: more different token types to work with.
			//
			if (L'<' == *pwszToken)
			{
				hr = HrValidTokenExpression (m_pmu, pwszToken, pwszPath, NULL);
			}
			else if (L'[' == *pwszToken)
			{
				FILETIME ft;

				hr = S_OK;

				//	Manually fetch the Etag for this item, and compare it
				//	against the provided Etag.   Set the error code the
				//	same way that HrValidTokenExpression does:
				//	If the Etag does NOT match, set the error code to
				//	E_DAV_INVALID_HEADER.
				//	Remember to skip the enclosing brackets ([]) when
				//	comparing the Etag strings.
				//
				if (!FGetLastModTime (NULL, pwszPath, &ft))
					hr = E_DAV_INVALID_HEADER;
				else if (!FETagFromFiletime (&ft, rgwchEtag))
					hr = E_DAV_INVALID_HEADER;
				else
				{
					//	Skip the square bracket -- this level of quoting
					//	is just for the if-header, not
					//
					pwszToken++;

					//	Since we do not do week ETAG checking, if the
					//	ETAG starts with "W/" skip those bits
					//
					if (L'W' == *pwszToken)
					{
						Assert (L'/' == *(pwszToken + 1));
						pwszToken += 2;
					}

					//	Our current Etags must be quoted.
					//
					Assert (L'\"' == pwszToken[0]);

					//	Compare these etags, INcluding the double-quotes,
					//	but EXcluding the square-brackets (those were added
					//	just for the IF: header.
					//
					if (wcsncmp (rgwchEtag, pwszToken, wcslen(rgwchEtag)))
						hr = E_DAV_INVALID_HEADER;
				}
			}
			else
				hr = E_FAIL;

			if ((S_OK == hr && !iter.FCurrentNot()) ||
				(S_OK != hr && iter.FCurrentNot()))
			{
				//	Either token matches, and this is NOT a "Not" expression,
				//	OR the token does NOT match, and this IS a "Not" expression.
				//	This one expression in the current list is true.
				//	Rember this match, and check the next token in the same list.
				//	If we don't find another token in the same list, we will
				//	drop out of the for-each-token loop with fOneMatch TRUE,
				//	and we will know that one whole list matched, so this URI
				//	has a valid list.
				//
				fOneMatch = TRUE;
				tokenNext = TOKEN_SAME_LIST;
				continue;
			}
			else
			{
				//	Either the token was not valid in a non-"Not" expression,
				//	or the token was valid in a "Not" expression.
				//	This one expression in this list is NOT true.
				//	That makes this list NOT true -- skip the rest of this
				//	list and move on to the next list for this URI.
				//
				fOneMatch = FALSE;
				tokenNext = TOKEN_NEW_LIST;
				continue;
			}

		} // rof - tokens in this list

		//	Check if we parsed a whole list with matches.
		//
		if (fOneMatch)
		{
			//	This whole list matched!  Return OK.
			//
			hr = S_OK;
		}
		else
		{
			//	This list did not match.
			//
			//	NOTE: We are quitting here if any one URI is lacking
			//	a matching list.  We are treating the URI-sets as if they
			//	are AND-ed together. This is not strictly DAV-compliant.
			//	NOTE: See the comments at the top of this function about
			//	true DAV-compliance and multi-URI Ifs.
			//
			hr = E_DAV_IF_HEADER_FAILURE;

			//	We've failed.  Quit now.
			//
			break;
		}

	} // rof - URIs in this header

	return hr;
}

HRESULT
HrCheckStateHeaders (IMethUtil * pmu,
					 LPCWSTR pwszPath,
					 BOOL fGetMeth)
{
	return HrCheckIfHeader(pmu, pwszPath);
}

//	------------------------------------------------------------------------
//	CParseLockTokenHeader::FOneToken
//	Special test -- F if not EXACTLY ONE item in the header.
BOOL
CParseLockTokenHeader::FOneToken()
{
	LPCWSTR pwsz;
	LPCWSTR pwszToken;
	BOOL fOnlyOne = FALSE;

	//	Quick check -- if the header doesn't exist, just process the method.
	//
	pwsz = m_pmu->LpwszGetRequestHeader (gc_szLockToken, TRUE);
	if (!pwsz)
		return FALSE;

	IFITER iter(pwsz);

	//	If we have LESS than one token, return FALSE.
	pwszToken = iter.PszNextToken(TOKEN_START_LIST);
	if (!pwszToken)
		goto ret;

	//	If we have MORE than one token in this list, return FALSE.
	pwszToken = iter.PszNextToken(TOKEN_SAME_LIST);
	if (pwszToken)
		goto ret;

	//	If we have other lists for this uri, return FALSE.
	pwszToken = iter.PszNextToken(TOKEN_NEW_LIST);
	if (pwszToken)
		goto ret;

	fOnlyOne = TRUE;

ret:
	//	We have exactly one token.
	return fOnlyOne;
}

//	------------------------------------------------------------------------
//	CParseLockTokenHeader::SetPaths
//	Feed the relevant paths to this lock token parser.
HRESULT
CParseLockTokenHeader::SetPaths (LPCWSTR pwszPath, LPCWSTR pwszDest)
{
	HRESULT hr = S_OK;

	//	They better be passing in at least one path.
	Assert(pwszPath);

	Assert(!m_fPathsSet);

	//	Copy the provided paths locally.
	//
	m_pwszPath = WszDupWsz (pwszPath);
	m_cwchPath = static_cast<UINT>(wcslen (m_pwszPath.get()));

	if (pwszDest)
	{
		m_pwszDest = WszDupWsz (pwszDest);
		m_cwchDest = static_cast<UINT>(wcslen (m_pwszDest.get()));
	}

	m_fPathsSet = TRUE;

	return hr;
}

//	------------------------------------------------------------------------
//	CParseLockTokenHeader::HrGetLockIdForPath
//	Get the token string for a path WITH a certain kind of access.
//$LATER: Obey fPathLookup (should be true on depth-type ops, when we add dir-locks)
//$LATER: Do back-path-lookup to find the dir-lock that is locking us.
HRESULT
CParseLockTokenHeader::HrGetLockIdForPath (LPCWSTR pwszPath,
										   DWORD dwAccess,
										   __int64 * pi64LockId,
										   BOOL fPathLookup)  // defaulted to FALSE
{
	HRESULT hr = E_DAV_LOCK_NOT_FOUND;
	FETCH_TOKEN_TYPE tokenNext = TOKEN_SAME_LIST;
	LPCWSTR pwsz;
	LPCWSTR pwszToken;

	//	Assert that we're in the correct state to call this method.
	Assert(m_fPathsSet);

	//	Init our out parameter.
	Assert(pi64LockId);
	(*pi64LockId) = 0;

	//	The requested path must be a child of one of our set paths.
	//
	Assert (!_wcsnicmp (pwszPath, m_pwszPath.get(), m_cwchPath) ||
			(m_pwszDest.get() &&
			 !_wcsnicmp (pwszPath, m_pwszDest.get(), m_cwchDest)));

	//	Quick check -- if the header doesn't exist, just process the method.
	//
	pwsz = m_pmu->LpwszGetRequestHeader (gc_szLockToken, TRUE);
	if (!pwsz)
		return hr;

	IFITER iter(pwsz);


	//	If this is a tagged production, there will be a URI here
	//	(pszToken will be non-NULL).  In that case,  search for
	//	the URI that matches (translates to match) our pwszPath.
	//	If there is NO URI here, we're a non-tagged production, and
	//	all lists & tokens are applied to the root URI of the request.
	//
	pwszToken = iter.PszNextToken (TOKEN_URI);
	if (pwszToken)
	{
		//	Loop through the tokens, looking only at uris.
		//	When we find the one that matches our given path, break out.
		//	Then the iter will hold our place, and the next set of code
		//	will search through the lists for this uri....
		//
		for (;	// already fetched first URI token above
			 pwszToken;
			 pwszToken = iter.PszNextToken (TOKEN_NEW_URI) )
		{
			CStackBuffer<WCHAR,MAX_PATH> pwszNormalized;
			CStackBuffer<WCHAR,MAX_PATH> pwszTranslated;
			SCODE sc;
			UINT cch;

			Assert (pwszToken);

			//	NOTE: Our psz is still quoted with <>.  Unescaping must ignore these chars.
			//
			Assert (L'<' == *pwszToken);

			//	Get sufficient buffer for canonicalization
			//
			cch = static_cast<UINT>(wcslen(pwszToken + 1));
			if (NULL == pwszNormalized.resize(CbSizeWsz(cch)))
			{
				FsLockTrace ("CParseLockTokenHeader::HrGetLockIdForPath()  - Error while allocating memory 0x%08lX\n", E_OUTOFMEMORY);
				return E_OUTOFMEMORY;
			}

			//	Canonicalize the URL taking into account that it may be fully qualified.
			//	Does not mater what value we pass in cch - it is out parameter only.
			//
			sc = ScCanonicalizePrefixedURL (pwszToken + 1,
											pwszNormalized.get(),
											&cch);
			if (S_OK != sc)
			{
				//	We gave sufficient space
				//
				Assert(S_FALSE != sc);
				FsLockTrace ("HrCheckIfHeader() - ScCanonicalizePrefixedURL() failed 0x%08lX\n", sc);
				return sc;
			}

			//	We're in a loop, so try to use a static buffer first when
			//	converting this storage path.
			//
			cch = pwszTranslated.celems();
			sc = m_pmu->ScStoragePathFromUrl (pwszNormalized.get(),
											  pwszTranslated.get(),
											  &cch);
			if (S_FALSE == sc)
			{
				if (NULL == pwszTranslated.resize(cch))
					return E_OUTOFMEMORY;

				sc = m_pmu->ScStoragePathFromUrl (pwszNormalized.get(),
												  pwszTranslated.get(),
												  &cch);
			}
			if (FAILED (sc))
			{
				FsLockTrace ("HrCheckIfHeader -- failed to translate a URI to a path.\n");
				return sc;
			}
			Assert ((S_OK == sc) || (W_DAV_SPANS_VIRTUAL_ROOTS == sc));

			//	Remove any final quoting '>' here.
			//
			cch = static_cast<UINT>(wcslen (pwszTranslated.get()));
			if (L'>' == pwszTranslated[cch - 1])
				pwszTranslated[cch - 1] = L'\0';

			if (!_wcsicmp (pwszPath, pwszTranslated.get()))
				break;
		}

		//	If we fall out of the loop with NO pszToken, then we didn't
		//	find ANY matching paths.... return an error.
		//
		if (!pwszToken)
		{
			hr = E_DAV_LOCK_NOT_FOUND;
			goto ret;
		}
	}
	else if (_wcsicmp (pwszPath, m_pwszPath.get()))
	{
		//	There is NO URI st the start, so we're a non-tagged production,
		//	BUT the caller was looking for some path BESIDES the root URI's path
		//	(didn't match m_pwszPath in the above test!!!).
		//	FAIL and tell them that we can't find any locktokens for this path.
		//
		hr = E_DAV_LOCK_NOT_FOUND;
		goto ret;
	}

	//	Now, the IFITER should be positioned at the start of the list
	//	that applies to this path.
	//	Look for a token under this tag that matches.
	//

	//	Loop through all tokens, checking as we go.
	//$REVIEW: Right now, PszNextToken can't give different returns
	//$REVIEW: for "not found" versus "syntax error".
	//$REVIEW: That means we'll never give "bad request" for syntax problems....
	//
	for (pwszToken = iter.PszNextToken (TOKEN_START_LIST);
		 pwszToken;
		 pwszToken = iter.PszNextToken (tokenNext) )
	{
		__int64 i64LockId;

		Assert (pwszToken);

		//	Check this one token for validity.
		//
		if (L'<' == *pwszToken)
		{
			hr = HrValidTokenExpression (m_pmu,
										 pwszToken,
										 pwszPath,
										 &i64LockId);
		}
		else
		{
			//	This is not a locktoken -- ignore it for now.
			//
			//	This list still could have our locktoken -- keep looking in
			//	this same list.
			//
			//	NTRaid#244243 -- However, this list might NOT have our locktoken.
			//	Need to look at any list for this uri.
			//
			tokenNext = TOKEN_ANY_LIST;
			continue;
		}

		//	We only want this lock token if it IS valid, AND
		//	it's not from a "Not" expression, AND it comes from a
		//	valid list.  So, if we hit an invalid token, QUIT searching
		//	this list. (Skip ahead to the next list.)
		//
		if (S_OK == hr && !iter.FCurrentNot())
		{
			//	The token matches, AND it's not from a "Not" expression.
			//	This one's good.  Send it back.
			//
			*pi64LockId = i64LockId;
			hr = S_OK;
			goto ret;
		}
		else if	(S_OK != hr && iter.FCurrentNot())
		{
			//	The token does NOT match, and this IS a "Not" expression.
			//	This list still could be true overall -- keep looking in
			//	this same list.
			//
			//	NTRaid#244243 -- However, this list might NOT have our locktoken.
			//	Need to look at any list for this uri.
			//
			tokenNext = TOKEN_ANY_LIST;
			continue;
		}
		else
		{
			//	Either the token was not valid in a non-"Not" expression,
			//	or the token was valid in a "Not" expression.
			//	This expression in this list is NOT true.
			//	Since this is not a "good" list, don't look here
			//	for a matching token -- skip to the next list.
			//
			tokenNext = TOKEN_NEW_LIST;
			continue;
		}

	}

	//	We didn't find a token for this item.
	//
	hr = E_DAV_LOCK_NOT_FOUND;

ret:

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\shlkmgr.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	S H L K M G R . C P P
//
//		HTTP 1.1/DAV 1.0 request handling via ISAPI
//
//  This file contains the CSharedLockMgr class that handles the shared
//  memory mapped file implementation of the lock cache.  It is used by
//  HTTPEXT only.
//
//	Copyright 2000 Microsoft Corporation, All Rights Reserved
//
#include <_davfs.h>
#include <smh.h>  
#include <shlkcache.h>
#include <xlock.h>
#include "_shlkmgr.h"
#include "pipeline.h"

// Structure used to send data to the callback
// function for printing data about a lock.
//
struct PrintingContext
{
     IMethUtil* pmu;
     CXMLEmitter* pemitter;
     CXNode* pxnParent;
     CEmitterNode* penLockDiscovery;
};


// ========================================================================
//	Supporting functions.
// =========================================================================

//
//  Callback function use to print out 
//  information about a lock properties.
//
void PrintOne( SharedPtr<CInShLockData>* plock
                                , LPVOID pContext )
{
    CLockFS fslock;

    // Validate we have the data we need to print with.
	//
    Assert (pContext);
    if (!pContext) return;

    // Pull out the pieces so we can use them to print.
	//
    IMethUtil* pmu = ((PrintingContext*) pContext)->pmu;
    CXMLEmitter* pemitter = ((PrintingContext*)pContext)->pemitter;
    CXNode* pxnParent = ((PrintingContext*)pContext)->pxnParent;
    CEmitterNode* penLockDiscovery = ((PrintingContext*)pContext)->penLockDiscovery;

	SCODE sc = S_OK;

	//	Construct the 'DAV:lockdiscovery' node
	//
	sc = penLockDiscovery->ScConstructNode (*pemitter, pxnParent, gc_wszLockDiscovery);
	if (FAILED (sc))
		goto ret;

    // Bind to the data represented by the plock past in.
    // This is so we can use the CLock function to print the lock.
	//
    fslock.SharedData().FBind(plock->GetHandle());

    // now pass fslock to the ScLockDiscoveryFromCLock;

	//	Add the 'DAV:activelock' property for this plock.
	//$HACK:ROSEBUD_TIMEOUT_HACK
	//  For the bug where rosebud waits until the last second
	//  before issueing the refresh. Need to filter out this check with
	//  the user agent string. The hack is to increase the timeout
	//	by 30 seconds and return the actual timeout. So we
	//	need the ecb/pmu to findout the user agent. At this point
	//	we do not know. So we pass NULL. If we remove this
	//	hack ever (I doubt if we can ever do that), then
	//	change the interface of ScLockDiscoveryFromCLock.
	//    
    sc = ScLockDiscoveryFromCLock (pmu,
	                                *pemitter,
	                                *penLockDiscovery,
	                                &fslock);

	//$HACK:END ROSEBUD_TIMEOUT_HACK
	//
	if (FAILED(sc))
		goto ret;

	sc = penLockDiscovery->ScDone();
	if (FAILED(sc))
		goto ret;
		
		
ret:
    // Ignore errors if printing the XML failed and try
    // to continue to print out the rest of the properties.

    // CodeWork:  Might want to change this to stop printing 
    //            properties if an earlier property had problems.
    return;
}

// ========================================================================
//	CLASS CSharedLockMgr (Private Functions)
// =========================================================================

//
//  class constructor
//
CSharedLockMgr::CSharedLockMgr()
: m_hDavProc(INVALID_HANDLE_VALUE)
, m_fSharedMemoryInitalized(FALSE)
{
    // Initalization of shared memory is now done on demand.
    // SharedMemoryInitalized();
}

//
//  class destructor
//
CSharedLockMgr::~CSharedLockMgr()
{
    // If we have openned the davproc process
    // then we should close it.
	//
	if (m_hDavProc != INVALID_HANDLE_VALUE)
	{
		CloseHandle(m_hDavProc);
		m_hDavProc = INVALID_HANDLE_VALUE;
	}
}

//
//  Function which will hook up the underlying shared memory cache if
//  we have not all ready hooked into it.
//
BOOL CSharedLockMgr::SharedMemoryInitalized()
{
    // check if the shared memory has been initalized.
    // if it hasn't then we need to roll back to local
    // system before we link up, because DAVProc will
    // have setup the files as local system.
	//
    if (!m_fSharedMemoryInitalized)
    {
		CSynchronizedBlock sb(m_cs);

		if (!m_fSharedMemoryInitalized)
		{
			safe_revert_self rs;

			if (FAILED(InitalizeSharedCache(m_spSharedCache, m_spSharedStatic, FALSE)))
				m_fSharedMemoryInitalized = FALSE;
			else
				m_fSharedMemoryInitalized = TRUE;
		}
    }

    if (m_fSharedMemoryInitalized)
    {
        // Assuming we have shared memory than these 
        // should be set correctly all ready.
		//
        Assert(!(m_spSharedStatic.FIsNull()));
        Assert(!(m_spSharedCache.FIsNull()));

    }

    return m_fSharedMemoryInitalized;
}

//
//  Function creates a new lock token ID
//  using information stored in the shared 
//  static class.  You should not call this
//  function unless you are creating a new
//  lock token and are going to use the value.
//
HRESULT CSharedLockMgr::GetNewLockTokenId(__int64* pi64LockID)
{
    // validate that we have linked to shared memory.
	//
    if (!SharedMemoryInitalized()) return E_OUTOFMEMORY;

	LARGE_INTEGER llLockID;

    // validate that we have got a reasonable out param in.
	//
    if (pi64LockID == NULL)
    {
        return E_INVALIDARG;
    }

    // Code copied from lockmgr implementation.
    // I assume that since the low token has to wrap all the way around to 
    // make the high token change, it is safe to assume that the high token
    // won't be changing fast enough to have race conditions.
	//
    llLockID.LowPart = InterlockedIncrement(&(m_spSharedStatic->m_lTokenLow));
    if (llLockID.LowPart == 0) 
        (m_spSharedStatic->m_lTokenHigh)++;

    llLockID.HighPart = m_spSharedStatic->m_lTokenHigh;

	*pi64LockID = llLockID.QuadPart;

    return S_OK;

};


// ========================================================================
//	CLASS CSharedLockMgr (Public Functions - not inherited)
// =========================================================================
//

//  Gets a handle to the davproc process.
//  This will open the process if we have not
//  all ready openned it.
//
HRESULT CSharedLockMgr::GetDAVProcessHandle(HANDLE* phDavProc)
{
	HRESULT hr = S_OK;

	if (phDavProc == NULL)
	{
		hr = E_INVALIDARG;
		goto ret;
	}

	if (m_hDavProc == INVALID_HANDLE_VALUE)
	{
        safe_revert_self s;

		m_hDavProc = OpenProcess(PROCESS_DUP_HANDLE, false, GetDAVProcessId());
		if (m_hDavProc==NULL)
		{
			FsLockTrace ("Openning DAV process failed\n");
			m_hDavProc=INVALID_HANDLE_VALUE;
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto ret;
		}
	}
	

	*phDavProc = m_hDavProc;
	
ret:
	return hr;
}

//  Generates a new lock data item 
//  that represents the information passed
//  in here.
//
HRESULT CSharedLockMgr::GetNewLockData(LPCWSTR wszResource
                                      , HANDLE hfile
                                      , DWORD dwAccess
                                      , DWORD dwLockType
                                      , DWORD dwLockScope
                                      , DWORD dwTimeout
                                      , LPCWSTR wszOwnerComment
                                      , HANDLE hit
                                      , CLockFS& lock)
{
    if (!SharedMemoryInitalized()) return E_OUTOFMEMORY;

    __int64 i64LockID = 0;

    // Grab a reference to the lock items shared object.
	//
    SharedPtr<CInShLockData>& spSharedLockData = lock.SharedData();

    // First make sure we can get a new lock token id.
	//
    HRESULT hr = GetNewLockTokenId(&i64LockID);
    if (FAILED(hr))
        return hr;

    // Then create the new shared memory data object.
	//
    if (!(spSharedLockData.FCreate()))
        return E_OUTOFMEMORY;

    // Then initalize the new object to hold the information
    // about the new lock.
	//
    spSharedLockData->Init(wszResource
                            , dwAccess
                            , i64LockID
                            , m_spSharedStatic->GetGuidString()
                            , dwLockType
                            , dwLockScope
                            , dwTimeout
                            , wszOwnerComment
                            , hit);

    // Need to lock the file with WAS, this will also set in the
    // appropriate DAVProcFileHandle to the LockData object.
	//
	PIPELINE::LockFile(hfile, spSharedLockData.GetHandle());

    // Lastly initalize the hash code values so we are ready 
    // to go into the cache.
	//
    spSharedLockData->SetHashes(m_spSharedCache->GetHashCodeByID(i64LockID), m_spSharedCache->GetHashCodeByName(wszResource));

    return S_OK;
};



// ========================================================================
//	CLASS CSharedLockMgr (Public Functions - inherited from ILockCache)
// =========================================================================

//
//  Return the guid string stored in shared memory
//  that is used in a lock tokens for this server.
//
LPCWSTR CSharedLockMgr::WszGetGuid() 
{
    if (!SharedMemoryInitalized()) return NULL;

    return m_spSharedStatic->GetGuidString();
}

//
//  Print out all lock token information for locks of this type on this resource.
//  If the fEmitXML is false, just return if there are any locks.
//
BOOL CSharedLockMgr::FGetLockOnError( IMethUtil * pmu,
							 LPCWSTR wszResource,
							 DWORD dwLockType,
							 BOOL	fEmitXML,
						     CXMLEmitter * pemitter,
						     CXNode * pxnParent)
{
    // If we can not get connected to the shared memory we
    // need to return that we did not find the lock.
	//
    if (!SharedMemoryInitalized()) return FALSE;

    CEmitterNode enLockDiscovery;
    PrintingContext Context;

    // Save the objects into our data structure so we can 
    // access them when we need to print them.
	//
    Context.pmu = pmu;
    Context.pemitter = pemitter;
    Context.pxnParent = pxnParent;
    Context.penLockDiscovery = &enLockDiscovery;

    // Now let the shared lock cache start looking up all the locks 
    // that match for the resource and printing them out.
	//
    BOOL fRet = m_spSharedCache->FLookUpAll(wszResource, dwLockType, fEmitXML, &Context, PrintOne);

    Context.penLockDiscovery->ScDone();

    return fRet;
}


//
//  Lock a resource
//
BOOL CSharedLockMgr::FLock (CLockFS& lock, DWORD  dwsecTimeout)
{
    // If we don't have shared memory then we can't lock anything.
	//
    if (!SharedMemoryInitalized()) return FALSE;

	//	Add, using the copy of the string stored in the lockitem as the key.
	//
    m_spSharedCache->Add (lock.SharedData() );

    return TRUE;
}

//
//  Delete a lock
//
void CSharedLockMgr::DeleteLock(__int64 i64LockId)
{
    // If we don't have shared memory then the delete is just
    // not going to happen.
	//
    if (!SharedMemoryInitalized()) return;

    m_spSharedCache->DeleteByID( i64LockId  );
}

//
//  Get a lock from the lock cache,  checking for proper authentication.
//
HRESULT CSharedLockMgr::HrGetLock (LPMETHUTIL pmu, __int64 i64LockId, CLockFS** pplock)
{

	auto_ref_ptr<CLockFS> plock;
	HRESULT hr = S_OK;
	DWORD dwErr;

    // Get the lock by the Id.
	//
	if (!FGetLockNoAuth (i64LockId, plock.load()))
	{
		hr = E_DAV_LOCK_NOT_FOUND;
		goto ret;
	}

    // Validate that we have the appropriate ownership to get the lock.
	//
	dwErr = plock->DwCompareLockOwner (pmu);
	if (dwErr)
	{
		hr = HRESULT_FROM_WIN32 (dwErr);
		goto ret;
	}

	Assert (S_OK == hr);

    // Need to AddRef the lock here so that when the auto ref goes away it
    // will not release the object.
	//
	plock->AddRef();
	*pplock = plock.get();

ret:
	return hr;
}


//
// Get a lock without worrying about the ownership of the lock.
//
BOOL CSharedLockMgr::FGetLockNoAuth( __int64 i64LockId, CLockFS** pplock )
{
    if (!SharedMemoryInitalized()) return FALSE;

    CLockFS* plock = NULL;

    // Validate out parameters
	//
    Assert(pplock);
    if (pplock==NULL)
        return FALSE;

	*pplock = NULL;

    // Allocate the a CLockFS object to hold the lock we find.
	//
    plock = new CLockFS();
    if (plock == NULL)
        return FALSE;   // out of memory

	// We need to bump up it's ref count from zero.
	//
	plock->AddRef();

    // Grab the shared lock data object to use to link
    // to the lock if we find it.
	//
    SharedPtr<CInShLockData>& splock = plock->SharedData();

    //	This Lookup happens inside a correct read-lock.
	//	If the return is non-NULL, then we are given a ref on the LOCKITEM.
	//
	if (m_spSharedCache->FLookupByID( i64LockId, splock ))
    {
		FILETIME ftNow;

		GetSystemTimeAsFileTime(&ftNow);

        // Once it is marked as expired nothing can 
        // change that setting.  However, if it's not marked as expired
        // than it is fine for last writer to win on setting the 
        // last access time, so I am not locking here.
		//
        if (splock->IsExpired(ftNow))
        {
            // Release the lock token from the cache.
			//
            m_spSharedCache->DeleteByID( i64LockId );
        }
        else
        {
            // No locking on this update, but since it
            // is a time stamp, last writer winning seems
            // pretty much ok to me.
			//
            splock->SetLastAccess(ftNow);

            // returning plock, user is responsible for deleting.
			//
            *pplock = plock;

	        return TRUE;
        }
	}

    // If we found a lock, but it was expired this will
    // release the last handle on it and we will be free of it.
	//
    delete plock;

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\sof.cpp ===
/*
 *	S O F  . C P P
 *
 *	IStream on file implementation.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"
#include "_sof.h"

HRESULT STDMETHODCALLTYPE
StmOnFile::Read (void __RPC_FAR * pb,
				 ULONG cb,
				 ULONG __RPC_FAR * pcb)
{
	SCODE sc = S_OK;
	ULONG cbr;

	//	Read from the file
	//
	if (!ReadFile (m_hf, pb, cb, &cbr, NULL))
	{
		DebugTrace ("StmOnFile: failed to read (%ld)\n", GetLastError());
		sc = HRESULT_FROM_WIN32 (GetLastError());
	}
	if (pcb)
		*pcb = cbr;

	return sc;
}

HRESULT STDMETHODCALLTYPE
StmOnFile::Write (const void __RPC_FAR * pb,
				  ULONG cb,
				  ULONG __RPC_FAR * pcb)
{
	SCODE sc = S_OK;
	ULONG cbw;

	//	Write to the file
	//
	if (!WriteFile (m_hf, pb, cb, &cbw, NULL))
	{
		DebugTrace ("StmOnFile: failed to write (%ld)\n", GetLastError());
		sc = HRESULT_FROM_WIN32 (GetLastError());
	}
	if (pcb)
		*pcb = cbw;

	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\statcode.s ===
STRINGTABLE
BEGIN
	HSC_CONTINUE					L"Continue\0"
	HSC_SWITCH_PROTOCOL				L"Switching Protocols\0"
	HSC_PROCESSING					L"Processing Request\0"

	HSC_OK							L"OK\0"
	HSC_CREATED						L"Created\0"
	HSC_ACCEPTED					L"Accepted\0"
	HSC_NON_AUTHORITATIVE_INFO		L"Non-authoritative Information\0"
	HSC_NO_CONTENT					L"No Content\0"
	HSC_RESET_CONTENT				L"Reset Content\0"
	HSC_PARTIAL_CONTENT				L"Partial Content\0"
	HSC_MULTI_STATUS				L"Multi-Status\0"

	HSC_SUBSCRIBED					L"Subscribed\0"
	HSC_SUBSCRIPTION_FAILED			L"Subscription Failed\0"
	HSC_NOTIFICATION_FAILED				L"Notification Failed\0"
	HSC_NOTIFICATION_ACKNOWLEDGED			L"Notification Acknowledged\0"
	HSC_EVENTS_FOLLOW				L"Events Follow\0"
	HSC_NO_EVENTS_PENDING				L"No Events Pending\0"

	HSC_MULTIPLE_CHOICE				L"Multiple Choices\0"
	HSC_MOVED_PERMANENTLY			L"Moved Permanently\0"
	HSC_MOVED_TEMPORARILY			L"Moved Temporarily\0"
	HSC_SEE_OTHER					L"See Other\0"
	HSC_NOT_MODIFIED				L"Not Modified\0"
	HSC_USE_PROXY					L"Use Proxy\0"

	HSC_BAD_REQUEST					L"Bad Request\0"
	HSC_UNAUTHORIZED				L"Unauthorized\0"
	HSC_PAYMENT_REQUIRED			L"Payment Required\0"
	HSC_FORBIDDEN					L"Forbidden\0"
	HSC_NOT_FOUND					L"Resource Not Found\0"
	HSC_METHOD_NOT_ALLOWED			L"Method Not Allowed\0"
	HSC_NOT_ACCEPTABLE				L"Not Acceptable\0"
	HSC_PROXY_AUTH_REQUIRED			L"Proxy Authorization Required\0"
	HSC_REQUEST_TIMEOUT				L"Request Timed Out\0"
	HSC_CONFLICT					L"Conflict\0"
	HSC_GONE						L"Resource No Longer Exists -- Remove Any Links\0"
	HSC_LENGTH_REQUIRED				L"Length Required\0"
	HSC_PRECONDITION_FAILED			L"Precondition Failed\0"
	HSC_REQUEST_ENTITY_TOO_LARGE	L"Request Entity Too Large\0"
	HSC_REQUEST_URI_TOO_LARGE		L"Request-URI Too Large\0"
	HSC_UNSUPPORTED_MEDIA_TYPE		L"Unsupported Media Type\0"
	HSC_RANGE_NOT_SATISFIABLE		L"Requested Range Not Satisfiable\0"
	HSC_EXPECTATION_FAILED			L"Expectation Failed\0"

	HSC_UNPROCESSABLE				L"Unprocessable Entity\0"
	HSC_LOCKED						L"Locked\0"
	HSC_METHOD_FAILURE				L"Method Failure\0"
	HSC_INCOMPLETE_DATA				L"Incomplete Data\0"
	HSC_INSUFFICIENT_SPACE			L"Insufficient Space to Store Resource\0"

	HSC_INTERNAL_SERVER_ERROR		L"Internal Server Error\0"
	HSC_NOT_IMPLEMENTED				L"Not Implemented\0"
	HSC_BAD_GATEWAY					L"Bad Gateway\0"
	HSC_SERVICE_UNAVAILABLE			L"Service Unavailable\0"
	HSC_GATEWAY_TIMEOUT				L"Gateway Timeout\0"
	HSC_VERSION_NOT_SUPPORTED		L"HTTP Version Not Supported\0"
	HSC_NO_PARTIAL_UPDATE			L"Partial Update Not Implemented\0"

	HSC_SERVER_TOO_BUSY			L"Server Too Busy\0"

;	non-HTTP errors that need localization ------------------------------------

	IDS_WRITTEN						L"<body><h1>%hs was written successfully</h1></body>\r\n\0"
	IDS_CREATED						L"<body><h1>%hs was created successfully</h1></body>\r\n\0"

	IDS_FAIL_CREATE_DIR				L"Failed to create resource\0"

	IDS_FAIL_PROP_NO_EXIST			L"The requested property does not exist\0"
	IDS_FAIL_PROP_NO_ACCSS			L"The user cannot modify the requested property\0"

	IDS_BR_LOCKTOKEN_NOT_ALLOWED	L"Lock-Token not allowed\0"
	IDS_BR_LOCKTOKEN_SYNTAX			L"Syntax error in Lock-Token header\0"
	IDS_BR_LOCKTOKEN_MISSING		L"Missing Lock-Token header\0"
	IDS_BR_LOCKTOKEN_INVALID		L"Invalid Lock-Token encountered\0"
	IDS_BR_LOCKINFO_SYNTAX			L"Invalid or missing Lock type information\0"
	IDS_BR_TIMEOUT_SYNTAX			L"Syntax error in Time-Out header\0"
	IDS_BR_LOCK_BODY_TYPE			L"Invalid Content-Type on Lock request\0"
	IDS_BR_MULTIPLE_LOCKTOKENS		L"Multiple locktokens invalid on this request\0"
	IDS_BR_NO_COLL_LOCK				L"LOCKing a collection is not allowed\0"
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\traces.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	TRACES.CPP
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include "_davfs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\urlmap.cpp ===
//	========================================================================
//	H T T P E X T \ U R L M A P . C P P
//
//	Copyright Microsoft Corporation 1997-1999.
//
//	This file contains all necessary routines to deal with IIS URLs
//	properly.  This file is part of HTTPEXT, as in HTTPEXT, we need to
//	handle URLs the same way IIS would.
//
//	========================================================================

#include <_davfs.h>
#include <langtocpid.h>

//$	REVIEW: BUG:NT5:196814
//
//	<string.hxx> is an IIS header file that exposes the CanonURL() api.
//	It is exported from IISRTL.DLL and we should be able to call it
//	instead of us stealing their code.
//
//$	HACK:
//
//	<string.hxx> includes <buffer.hxx> which includes <nt.h> and all of
//	its minions.  DAV has already included all of the <winnt.h> and its
//	minions.  The <nt.h> and <winnt.h> are at odds, so we are defining
//	NT_INCLUDED, _NTRTL_, _NTURTL_, DBG_ASSERT(), IntializeListHead(),
//	and RemoveEntryList() to disable those conflicts.
//
#define NT_INCLUDED
#define _NTRTL_
#define _NTURTL_
#define InitializeListHead(_p)
#define RemoveEntryList(_p)
#define DBG_ASSERT Assert
#pragma warning (disable:4390)
#include <string.hxx>
#pragma warning (default:4390)

//
//$	HACK: end
//$	REVIEW: end

//
//  Private constants.
//
enum {

	ACTION_NOTHING			= 0x00000000,
	ACTION_EMIT_CH			= 0x00010000,
	ACTION_EMIT_DOT_CH		= 0x00020000,
	ACTION_EMIT_DOT_DOT_CH	= 0x00030000,
	ACTION_BACKUP			= 0x00040000,
	ACTION_MASK				= 0xFFFF0000

};

//	States and State translations ---------------------------------------------
//
const UINT gc_rguStateTable[16] = {

	//	State 0
	//
	0 ,             // other
	0 ,             // "."
	4 ,             // EOS
	1 ,             // "\"

	//	State 1
	//
	0 ,              // other
	2 ,             // "."
	4 ,             // EOS
	1 ,             // "\"

	//	State 2
	//
	0 ,             // other
	3 ,             // "."
	4 ,             // EOS
	1 ,             // "\"

	//	State 3
	//
	0 ,             // other
	0 ,             // "."
	4 ,             // EOS
	1               // "\"
};

const UINT gc_rguActionTable[16] = {

	// State 0
	//
	ACTION_EMIT_CH,             // other
	ACTION_EMIT_CH,             // "."
	ACTION_EMIT_CH,             // EOS
	ACTION_EMIT_CH,             // "\"

	//	State 1
	//
	ACTION_EMIT_CH,             // other
	ACTION_NOTHING,             // "."
	ACTION_EMIT_CH,             // EOS
	ACTION_NOTHING,             // "\"

	//	State 2
	//
	ACTION_EMIT_DOT_CH,         // other
	ACTION_NOTHING,             // "."
	ACTION_EMIT_CH,             // EOS
	ACTION_NOTHING,             // "\"

	//	State 3
	//
	ACTION_EMIT_DOT_DOT_CH,     // other
	ACTION_EMIT_DOT_DOT_CH,     // "."
	ACTION_BACKUP,              // EOS
	ACTION_BACKUP               // "\"
};

//	The following table provides the index for various ISA Latin1 characters
//  in the incoming URL.
//
//	It assumes that the URL is ISO Latin1 == ASCII
//
const UINT gc_rguIndexForChar[] = {

	2,								// null char
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	// 1 thru 10
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	// 11 thru 20
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   // 21 thru 30
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   // 31 thru 40
	0, 0, 0, 0, 0, 1, 3, 0, 0, 0,   // 41 thru 50  46 = '.' 47 = '/'
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   // 51 thru 60
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   // 61 thru 70
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   // 71 thru 80
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   // 81 thru 90
	0, 3, 0, 0, 0, 0, 0, 0, 0, 0,   // 91 thru 100  92 = '\\'
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   // 101 thru 110
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   // 111 thru 120
	0, 0, 0, 0, 0, 0, 0, 0          // 121 thru 128
};

//	FIsUTF8TrailingByte -------------------------------------------------------
//
//	Function returns TRUE if the given character is UTF-8 trailing byte
//
inline BOOL FIsUTF8TrailingByte (CHAR ch)
{
	return (0x80 == (ch & 0xc0));
}

//	FIsUTF8Url ----------------------------------------------------------------
//
//	Function returns TRUE if the given string can be treated as UTF-8
//
BOOL __fastcall
FIsUTF8Url (/* [in] */ LPCSTR pszUrl)
{
	CHAR ch;

	while (0 != (ch = *pszUrl++))
	{
		//	Sniff for a lead-byte
		//
		if (ch & 0x80)
		{
			CHAR chT1;
			CHAR chT2;

			//	Pick off the trailing bytes
			//
			chT1 = *pszUrl++;
			if (chT1)
				chT2 = *pszUrl;
			else
				chT2 = 0;

			//	Handle the three byte case
			//	1110xxxx 10xxxxxx 10xxxxxx
			//
			if (((ch & 0xF0) == 0xE0) &&
				FIsUTF8TrailingByte (chT1) &&
				FIsUTF8TrailingByte (chT2))
			{
				//	We found a UTF-8 character.  Keep going.
				//
				pszUrl++;
				continue;
			}
			//	Also watch for the two byte case
			//	110xxxxx 10xxxxxx
			//
			else if (((ch & 0xE0) == 0xC0) && FIsUTF8TrailingByte (chT1))
			{
				//	We found a UTF-8 character.  Keep going.
				//
				continue;
			}
			else
			{
				//	If we had a lead-byte but no UTF trailing bytes, then
				//	this cannot be a UTF8 url.
				//
				DebugTrace ("FIsUTF8Url(): url contains UTF8 lead byte with no trailing\n");
				return FALSE;
			}
		}
	}

	//	Hey, we made it through without any non-singlebyte chars, so we can
	//	operate as if this is a UTF8 url.
	//
	DebugTrace ("FIsUTF8Url(): url contains only UTF8 characters\n");
	return TRUE;
}

//	ScCanonicalizeURL ---------------------------------------------------------
//
//	Wide version of the CanonURL() function, which lives in iisrtl.lib
//
//	PURPOSE:    Sanitizes a path by removing bogus path elements.
//
//		As expected, "/./" entries are simply removed, and
//		"/../" entries are removed along with the previous
//		path element.
//
//		To maintain compatibility with URL path semantics
//		additional transformations are required. All backward
//		slashes "\\" are converted to forward slashes. Any
//		repeated forward slashes (such as "///") are mapped to
//		single backslashes.
//
//		A state table (see the p_StateTable global at the
//		beginning of this file) is used to perform most of
//		the transformations.  The table's rows are indexed
//		by current state, and the columns are indexed by
//		the current character's "class" (either slash, dot,
//		NULL, or other).  Each entry in the table consists
//		of the new state tagged with an action to perform.
//		See the ACTION_* constants for the valid action
//		codes.
//
//  PARAMETERS:
//
//		pwszSrc		- url to canonicalize
//		pwszDest	- buffer to fill
//		pcch		- number of characters written into the buffer
//					  (which includes '\0' termination)
//
//	RETURN CODES:
//
//		S_OK.
//
//	NOTE: This function assumes that destination buffer is
//		  equal or biger than the source. 
//
SCODE __fastcall
ScCanonicalizeURL( /* [in]     */ LPCWSTR pwszSrc,
				   /* [in/out] */ LPWSTR pwszDest,
				   /* [out]	   */ UINT * pcch )
{
	LPCWSTR pwszPath;
	UINT  uiCh;
	UINT  uiIndex = 0;	// State = 0

	Assert( pwszSrc );
	Assert( pwszDest );
	Assert( pcch );

	//	Zero out return
	//
	*pcch = 0;

	//	Remember start of the buffer into which we will canonicalize
	//
	pwszPath = pwszDest;

	//  Loop until we enter state 4 (the final, accepting state).
	//
	do {

		//  Grab the next character from the path and compute its
		//  next state.  While we're at it, map any forward
		//  slashes to backward slashes.
		//
		uiIndex = gc_rguStateTable[uiIndex] * 4; // 4 = # states
		uiCh = *pwszSrc++;

		uiIndex += ((uiCh >= 0x80) ? 0 : gc_rguIndexForChar[uiCh]);

		//  Perform the action associated with the state.
		//
		switch( gc_rguActionTable[uiIndex] )
		{
			case ACTION_EMIT_DOT_DOT_CH :

				*pwszDest++ = L'.';

				/* fall through */

			case ACTION_EMIT_DOT_CH :

				*pwszDest++ = L'.';

				/* fall through */

			case ACTION_EMIT_CH :

				*pwszDest++ = static_cast<WCHAR>(uiCh);

				/* fall through */

			case ACTION_NOTHING :

				break;

			case ACTION_BACKUP :
				if ( (pwszDest > (pwszPath + 1) ) && (*pwszPath == L'/'))
				{
					pwszDest--;
					Assert( *pwszDest == L'/' );

					*pwszDest = L'\0';
					pwszDest = wcsrchr( pwszPath, L'/') + 1;
				}

				*pwszDest = L'\0';
				break;

			default :

				TrapSz("Invalid action code in state table!");
				uiIndex = 2;    // move to invalid state
				Assert( 4 == gc_rguStateTable[uiIndex] );
				*pwszDest++ = L'\0';
				break;
		}

	} while( gc_rguStateTable[uiIndex] != 4 );

	//	Point to terminating nul
	//
	if (ACTION_EMIT_CH == gc_rguActionTable[uiIndex])
	{
		pwszDest--;
	}
    
	Assert((L'\0' == *pwszDest) && (pwszDest >= pwszPath));

	//	Return number of characters written
	//
	*pcch = static_cast<UINT>(pwszDest - pwszPath + 1);

	return S_OK;
}

SCODE __fastcall
ScCanonicalizePrefixedURL( /* [in]     */ LPCWSTR pwszSrc,
						   /* [in]	   */ LPWSTR pwszDest,
						   /* [out]	   */ UINT * pcch )
{
	SCODE sc = S_OK;

	LPCWSTR pwszStripped;
	UINT cchStripped;
	UINT cch = 0;

	Assert(pwszSrc);
	Assert(pwszDest);
	Assert(pcch);

	//	Zero out return
	//
	*pcch = 0;

	pwszStripped = PwszUrlStrippedOfPrefix(pwszSrc);
	cchStripped = static_cast<UINT>(pwszStripped - pwszSrc);

	//	Copy the prefix over to the destination. I do not use
	//	memcpy here as source and destination may overlap,
	//	and in such case those functions are not recomended.
	//
	for (UINT ui = 0; ui < cchStripped; ui++)
	{
		pwszDest[ui] = pwszSrc[ui];
	}

	//	Canonicalize the remainder of te URL
	//
	sc = ScCanonicalizeURL(pwszStripped,
						   pwszDest + cchStripped,
						   &cch);
	if (S_OK != sc)
	{
		Assert(S_FALSE != sc);
		DebugTrace("ScCanonicalizePrefixedURL() - ScCanonicalizeUrl() failed 0x%08lX\n", sc);
		goto ret;
	}

	//	Return the number of characters written
	//
	*pcch = cchStripped + cch;

ret:

	return sc;
}

//	ScConvertToWide -----------------------------------------------------------
//
SCODE __fastcall
ScConvertToWide(/* [in]     */	LPCSTR	pszSource,
				/* [in/out] */  UINT *	pcchDest,
				/* [out]    */	LPWSTR	pwszDest,
				/* [in]		*/	LPCSTR	pszAcceptLang,
				/* [in]		*/	BOOL	fUrlConversion)
{
	SCODE sc = S_OK;
	CStackBuffer<CHAR, MAX_PATH> pszToConvert;
	UINT cpid = CP_UTF8;
	UINT cb;
	UINT cch;

	Assert(pszSource);
	Assert(pcchDest);
	Assert(pwszDest);

	if (fUrlConversion)
	{
		//	Allocate the space to escape URL into.
		//
		cb = static_cast<UINT>(strlen(pszSource));
		if (NULL == pszToConvert.resize(cb + 1))
		{
			sc = E_OUTOFMEMORY;
			DebugTrace("ScConvertToWide() -  Error while allocating memory 0x%08lX\n", sc);
			goto ret;
		}

		//	Unescape to the new buffer. Unescaping can only shrink the size,
		//	so we have enough buffer allocated.
		//
		HttpUriUnescape(pszSource, pszToConvert.get());

		//	Perform a quick pass over the url looking for non-UTF8 characters.
		//	Remember if we need to continue to scan for UTF8 characters.
		//
		if (!FIsUTF8Url(pszToConvert.get()))
		{
			//	... cannot do CP_UTF8, assume CP_ACP.
			//
			cpid = CP_ACP;
		}

		//	If the URL cannot be treated as UTF8 then find out the code page for it
		//
		if (CP_UTF8 != cpid)
		{
			if (pszAcceptLang)
			{
				HDRITER hdri(pszAcceptLang);
				LPCSTR psz;

				//	Let us try guessing the cpid from the language string
				//	Try all the languages in the header. We stop at the
				//	first language for which we have a cpid mapping. If
				//	none of the languages specified in the header have cpid
				//	mappings, then we will end up with the default cpid
				//	CP_ACP
				//
				for (psz = hdri.PszNext(); psz; psz = hdri.PszNext())
				{
					if (CLangToCpidCache::FFindCpid(psz, &cpid))
						break;
				}
			}
		}

		//	Swap the pointer and recalculate the size
		//
		pszSource = pszToConvert.get();
	}

	//	Find out the length of the string we will convert
	//
	cb = static_cast<UINT>(strlen(pszSource));

	//	Translate to unicode including '\0' termination
	//
	cch = MultiByteToWideChar(cpid,
							  (CP_UTF8 != cpid) ? MB_ERR_INVALID_CHARS : 0,
							  pszSource,
							  cb + 1,
							  pwszDest,
							  *pcchDest);
	if (0 == cch)
	{
		//	If buffer was not sufficient 
		//
		if (ERROR_INSUFFICIENT_BUFFER == GetLastError())
		{
			//	Find out the size needed
			//
			cch = MultiByteToWideChar(cpid,
									  (CP_UTF8 != cpid) ? MB_ERR_INVALID_CHARS : 0,
									  pszSource,
									  cb + 1,
									  NULL,
									  0);
			if (0 == cch)
			{
				sc = HRESULT_FROM_WIN32(GetLastError());
				DebugTrace("ScConvertToWide() - MultiByteToWideChar() failed to fetch size 0x%08lX - CPID: %d\n", sc, cpid);
				goto ret;
			}

			//	Return the size and warning back
			//	
			*pcchDest = cch;
			sc = S_FALSE;
			goto ret;
		}
		else
		{
			sc = HRESULT_FROM_WIN32(GetLastError());
			DebugTrace("ScConvertToWide() - MultiByteToWideChar() failed 0x%08lX - CPID: %d\n", sc, cpid);
			goto ret;
		}
	}

	*pcchDest = cch;

ret:

	return sc;
}


//	ScNormalizeUrl ------------------------------------------------------------
//
//	PURPOSE:	Normalization of a url.
//
//		Has two components to the operation:
//
//		1) All sequences of %xx are replaced by a single character that
//		   has a value that is equal to the hex representation of the
//		   following two characters.
//
//		2) All path modification sequences are stripped out and the url
//		   is adjusted accordingly.  The set of path modification sequences
//		   that we recognize are as follows:
//
//		"//"	reduces to "/"
//		"/./"	reduces to "/"
//		"/../"	strips off the last path segment
//
//		It is important to note that the unescaping happens first!
//
//		NOTE:  this function does NOT currently normalize the path separators
//		All '\' are NOT replaced with '/' in this function or vice versa.
//		The code is implemented such that slashes replaced due to a double
//		slash such as "//", "\\", "\/", or "/\" are defaulted to forward
//		slashes '/'
//
//		A state table (see the gc_rguStateTable global at the beginning
//		of this file) is used to perform most of the transformations.  The
//		table's rows are indexed by current state, and the columns are indexed
//		by the current character's "class" (either slash, dot, NULL, or other).
//		Each entry in the table consists of the new state tagged with an action
//		to perform.  See the ACTION_* constants for the valid action codes.//
//
//	PARAMETERS:
//
//		pwszSourceUrl		-- the URL to be normalized
//		pcchNormalizedUrl	-- the amount of characters available in buffer
//							   pointed by pwszNormalizedUrl
//		pwszNormalizedUrl	-- the place to put the normalized URL
//
//	RETURN CODES:
//
//		S_OK: Everything went well,	the URL was normalized into pwszNormalizedUrl.
//		S_FALSE: Buffer was not sufficient. Required size is in *pcchNormalizedUrl.
//		E_OUTOFMEMORY: Memory alocation failure
//		...other errors that we could get from the conversion routines
//
SCODE __fastcall
ScNormalizeUrl (
	/* [in]     */	LPCWSTR			pwszSourceUrl,
	/* [in/out] */  UINT *			pcchNormalizedUrl,
	/* [out]    */	LPWSTR			pwszNormalizedUrl,
	/* [in]		*/	LPCSTR			pszAcceptLang)
{
	SCODE sc = S_OK;
	CStackBuffer<CHAR, MAX_PATH> pszSourceUrl;
	UINT cchSourceUrl;
	UINT cbSourceUrl;

	Assert(pwszSourceUrl);
	Assert(pcchNormalizedUrl);
	Assert(pwszNormalizedUrl);

	//	We are given the wide version of the URL, so someone who
	//	converted it already should have done that correctly. So
	//	we will convert it to CP_UTF8
	//
	cchSourceUrl = static_cast<UINT>(wcslen(pwszSourceUrl));
	cbSourceUrl = cchSourceUrl * 3;
	if (NULL == pszSourceUrl.resize(cbSourceUrl + 1))
	{
		sc = E_OUTOFMEMORY;
		DebugTrace("ScNormalizeUrl() - Error while allocating memory 0x%08lX\n", sc);
		goto ret;
	}

	cbSourceUrl = WideCharToMultiByte(CP_UTF8,
									  0,
									  pwszSourceUrl,
									  cchSourceUrl + 1,
									  pszSourceUrl.get(),
									  cbSourceUrl + 1,
									  NULL,
									  NULL);
	if (0 == cbSourceUrl)
	{
		sc = HRESULT_FROM_WIN32(GetLastError());
		DebugTrace("ScNormalizeUrl() - WideCharToMultiByte() failed 0x%08lX\n", sc);
		goto ret;
	}

	sc = ScNormalizeUrl(pszSourceUrl.get(),
						pcchNormalizedUrl,
						pwszNormalizedUrl,
						pszAcceptLang);
	if (FAILED(sc))
	{
		DebugTrace("ScNormalizeUrl() - ScNormalizeUrl() failed 0x%08lX\n", sc);
		goto ret;
	}

ret:

	return sc;
}

SCODE __fastcall
ScNormalizeUrl (
	/* [in]     */	LPCSTR			pszSourceUrl,
	/* [in/out] */	UINT		  *	pcchNormalizedUrl,
	/* [out]    */	LPWSTR			pwszNormalizedUrl,
	/* [in]		*/	LPCSTR			pszAcceptLang)
{
	SCODE sc = S_OK;
	
	Assert(pszSourceUrl);
	Assert(pcchNormalizedUrl);
	Assert(pwszNormalizedUrl);

	//	Convert the URL to UNICODE into the given buffer.
	//	Function may return S_FALSE, so make sure we
	//	check the return code correctly - against S_OK
	//
	sc = ScConvertToWide(pszSourceUrl,
						 pcchNormalizedUrl,
						 pwszNormalizedUrl,
						 pszAcceptLang,
						 TRUE);
	if (S_OK != sc)
	{
		DebugTrace("ScNormalizeUrl() - ScConvertToWide() returned 0x%08lX\n", sc);
		goto ret;
	}

	//	Canonicalize in place, take into account that URL may be fully
	//	qualified.
	//
	sc = ScCanonicalizePrefixedURL(pwszNormalizedUrl,
								   pwszNormalizedUrl,
								   pcchNormalizedUrl);
	if (FAILED(sc))
	{
		DebugTrace("ScNormalizeUrl() - ScCanonicalizePrefixedURL() failed 0x%08lX\n", sc);
		goto ret;
	}

ret:

	return sc;
}

//	ScStoragePathFromUrl ------------------------------------------------------
//
//	PURPOSE:	Url to storage path translation.
//
SCODE __fastcall
ScStoragePathFromUrl (
	/* [in]     */ const IEcb &	ecb,
	/* [in]     */ LPCWSTR		pwszUrl,
	/* [out]    */ LPWSTR		wszStgID,
	/* [in/out] */ UINT		  *	pcch,
	/* [out]    */ CVRoot	 **	ppcvr)
{
	Assert (pwszUrl);
	Assert (wszStgID);
	Assert (pcch);

	SCODE				sc = S_OK;
	HSE_UNICODE_URL_MAPEX_INFO mi;
	LPCWSTR				pwszVRoot;
	UINT				cchVRoot;
	UINT				cch = 0;

#undef	ALLOW_RELATIVE_URL_TRANSLATION
#ifdef	ALLOW_RELATIVE_URL_TRANSLATION

	CStackBuffer<WCHAR,256> pwszNew;

#endif	// ALLOW_RELATIVE_URL_TRANSLATION

	//	Lets make sure this funcion is never called with a
	//	prefixed url.
	//
	sc = ScStripAndCheckHttpPrefix (ecb, &pwszUrl);
	if (FAILED (sc))
		return sc;

	//	Make sure that the url is absolute
	//
	if (L'/' != *pwszUrl)
	{

#ifdef	ALLOW_RELATIVE_URL_TRANSLATION

		//$	REVIEW:
		//
		//	This code is here should we ever decide we need
		//	to support relative url processing.
		//
		//	Construct an absolute url from the relative one
		//
		UINT	cchRequestUrl = wcslen(ecb.LpwszRequestUrl());
		UINT	cchUrl = static_cast<UINT>(wcslen(pwszUrl));

		if (NULL == pwszNew.resize(CbSizeWsz(cchRequestUrl + cchUrl)))
		{
			sc = E_OUTOFMEMORY;
			DebugTrace("ScStoragePathFromUrl() - CStackBuffer::resize() failed 0x%08lX\n", sc);
			return sc;
		}

		memcpy (pwszNew.get(), ecb.LpwszRequestUrl(), cchRequestUrl * sizeof(WCHAR));
		memcpy (pwszNew.get(), pwszUrl, (cchUrl + 1) * sizeof(WCHAR));

		//	Now pszURI points to the generated absolute URI
		//
		pwszUrl = pwszNew.get();
		//
		//$	REVIEW: end
#else

		DebugTrace ("ScStoragePathFromUrl(): cannot translate relative URIs\n");

		return E_DAV_BAD_DESTINATION;

#endif	// ALLOW_RELATIVE_URL_TRANSLATION
	}

	//	OK, here is where virtual root spanning needs to be supported...
	//
	//	When the virtual root of the request url does not match the
	//	the virtual root for the url being translated, extra work
	//	needs to be done.
	//
	//	There are two ways to do this.
	//
	//	1)	Call back to IIS and have it do the translation for us
	//	2)	Use our metabase cache to rip through each virtual root
	//		and find the longest matching virtual root.
	//
	//	At first thought, the second method seems efficient.  However,
	//	the changes being made to the metabase cache do not make this
	//	an easy matter.  The cache no longer will be containing just
	//	virtual roots, so the lookup will not be as cheap.
	//
	//$	REVIEW: In fact, I believe that we must do the virtual lookup
	//	via IIS for all translations.  The sub-virtual root thing keeps
	//	gnawing at me.
	//
	sc = ecb.ScReqMapUrlToPathEx(pwszUrl,
								 &cch,
								 &mi);
	if (FAILED(sc))
	{
		DebugTrace("ScStoragePathFromUrl() - IEcb::SSFReqMapUrlPathEx() failed 0x%08lX\n", sc);
		return sc;
	}

	//	Try and figure out if the url spanned a virtual root at all.
	//
	cchVRoot = ecb.CchGetVirtualRootW(&pwszVRoot);
	if (cchVRoot != mi.cchMatchingURL)
	{
		//	This case is not so cut-n-dry..
		//
		//	Since CchGetVirtualRoot() should always return a url
		//	that does not have a trailing slash, the matching count
		//	could be off by one and the root may actually be the
		//	same!
		//
		//  Assuming "/vroot" is the Virtual Root in question, this if
		//  statement protects against the following:
		//	1.  catches a two completely different sized vroots.
		//		disqualifies matches that are too short or
		//		too long "/vr", but allows "/vroot/" because need to
		//		handle IIS bug (NT:432359).
		//	2.  checks to make sure the URL is slash terminated.  This
		// 		allows "/vroot/" (again because of NT:432359), but
		//		disqualifies vroots such as "/vrootA"
		//  3.  allows "/vroot" to pass if mi.cchMatchingURL is off by
		//		one (again because of NT:432359).
		//
		if ((cchVRoot + 1 != mi.cchMatchingURL) ||	//  1
			((L'/' != pwszUrl[cchVRoot]) &&			//  2
			 (L'\0' != pwszUrl[cchVRoot])))			//  3
		{
			//  If we're here the virtual root of the URL does not match
			//  the current virtual root...
			//
			DebugTrace ("ScStoragePathFromUrl() - urls do not "
						"share common virtual root\n"
						"-- pwszUrl: %ls\n"
						"-- pwszVirtualRoot: %ls\n"
						"-- cchVirtualRoot: %ld\n",
						pwszUrl,
						pwszVRoot,
						cchVRoot);

			//	Tell the caller that the virtual root is spanned.  This allows
			//	the call to succeed, but the caller to fail the call if spanning
			//	is not allowed.
			//
			sc = W_DAV_SPANS_VIRTUAL_ROOTS;
		}
		else
		{
			//  If we're here we know that the current virtual root matches
			//  the virtual root of the URL, and the following character in
			//  the URL is a slash or a NULL termination.  cchMatchingURL is
			//  EXACTLY 1 greater than the number of characters in the virtual
			//  root (cchVRoot) due to the IIS bug (NT:432359).
			//
			//  Theoretically, if cchMatchingURL matches and matches
			//  one more than the number of characters in the
			//  vroot, the characters will match!  Thus we should assert this case.
			//
			Assert (!_wcsnicmp(pwszVRoot, pwszUrl, cchVRoot));

			//	In this case, mi.cchMatchingURL actually _includes_ the
			//	slash.  Below, when we copy in the trailing part of the
			//	URL, we skip mi.cchMatchingURL characters in the URL
			//	before copying in the trailing URL.  This has the
			//	unfortunate side effect in this case of missing the
			//	slash that is at the beginning of the URL after the
			//	virtual root, so you could end up with a path that looks
			//	like:
			//	\\.\BackOfficeStorage\mydom.extest.microsoft.com\MBXuser1/Inbox
			//	rather than:
			//	\\.\BackOfficeStorage\mydom.extest.microsoft.com\MBX/user1/Inbox
			//
			//	So decrement miw.cchMatchingURL here to handle this.
			//
			DebugTrace ("ScStoragePathFromUrl() : mi.cchMatchingURL included a slash!\n");
			mi.cchMatchingURL--;
		}
	}
	//  If we are hitting this conditional if statement, we know that
	//  the mi.cchMatchingURL is the same as the number of characters
	//	in the vroot.
	//	1.  We already checked for difference in the vroot lengts above
	//	    and if length of the vroot was 0 then they actually matched
	//	2.  We know that due to an IIS bug (NT:432359), cchMatchingURL
	//		could be 1 character too long.  This lines checks for that
	//		case.  If that is the case, we know that the VRoot is one
	//		character longer than the virtual root of the URL -- ie
	//		we are spanning virtual roots.
	//	3.  If the strings aren't in fact the same then we know that
	//		cchMatchingURL matched to a different virtual root than
	//		pszVRoot.
	//
	else if ((0 != cchVRoot) &&								//  1
			((L'\0' == pwszUrl[cchVRoot - 1]) ||			//  2
			_wcsnicmp(pwszVRoot, pwszUrl, cchVRoot)))		//  3
	{
		DebugTrace ("ScStoragePathFromUrl(): urls do not "
					"share common virtual root\n"
					"-- pwszUrl: %ls\n"
					"-- pwszVirtualRoot: %ls\n"
					"-- cchVirtualRoot: %ld\n",
					pwszUrl,
					pwszVRoot,
					cchVRoot);

		//	Tell the caller that the virtual root is spanned.  This allows
		//	the call to succeed, but the caller to fail the call if spanning
		//	is not allowed.
		//
		sc = W_DAV_SPANS_VIRTUAL_ROOTS;
	}

	//	If we span, and the caller wants it, look up the vroot
	//	for them.
	//
	if ((W_DAV_SPANS_VIRTUAL_ROOTS == sc) && ppcvr)
	{
		auto_ref_ptr<CVRoot> arp;
		CStackBuffer<WCHAR, MAX_PATH> pwsz;
		CStackBuffer<WCHAR, MAX_PATH> pwszMetaPath;
		if (NULL == pwsz.resize((mi.cchMatchingURL + 1) * sizeof(WCHAR)))
		{
			sc = E_OUTOFMEMORY;
			DebugTrace("ScStoragePathFromUrl() - CStackBuffer::resize() failed 0x%08lX\n", sc);
			return sc;
		}

		memcpy(pwsz.get(), pwszUrl, mi.cchMatchingURL * sizeof(WCHAR));
		pwsz[mi.cchMatchingURL] = L'\0';
		if (NULL == pwszMetaPath.resize(::CbMDPathW(ecb, pwsz.get())))
		{
			sc = E_OUTOFMEMORY;
			DebugTrace("ScStoragePathFromUrl() - CStackBuffer::resize() failed 0x%08lX\n", sc);
			return sc;
		}

		MDPathFromURIW (ecb, pwsz.get(), pwszMetaPath.get());
		_wcslwr (pwszMetaPath.get());

		//	Find the vroot
		//
		if (!CChildVRCache::FFindVroot (ecb, pwszMetaPath.get(), arp))
		{
			DebugTrace ("ScStoragePathFromUrl(): spanned virtual root not available\n");
			return E_DAV_BAD_DESTINATION;
		}

		*ppcvr = arp.relinquish();
	}

	//	If there is not enough space in the buffer provided, a return
	//	of S_FALSE tells the caller to realloc and try again!
	//
	Assert (*pcch);
	if (*pcch < cch)
	{
		DebugTrace ("ScStoragePathFromUrl (IIS URL Version): buffer too "
					"small for url translation\n");
		*pcch = cch;
		return S_FALSE;
	}

	//	Copy the Matching Path to the beginning of rgwchStgID
	//
	memcpy(wszStgID, mi.lpszPath, cch * sizeof(WCHAR));

	//	At this point, cch is the actual number of chars in the destination
	//	-- including the null
	//
	*pcch = cch;
	Assert (L'\0' == wszStgID[cch - 1]);
	Assert (L'\0' != wszStgID[cch - 2]);
	return sc;
}

//	Storage path to url translation -------------------------------------------
//
SCODE __fastcall
ScUrlFromStoragePath (
	/* [in]     */ const IEcbBase &	ecb,
	/* [in]     */ LPCWSTR			pwszPath,
	/* [out]    */ LPWSTR			pwszUrl,
	/* [in/out] */ UINT			  *	pcch,
	/* [in]		*/ LPCWSTR			pwszServer)
{
	WCHAR *	pwch;
	LPCWSTR	pwszPrefix;
	LPCWSTR	pwszVroot;
	LPCWSTR	pwszVrPath;
	UINT	cch;
	UINT	cchPath;
	UINT	cchMatching;
	UINT	cchAdjust;
	UINT	cchPrefix;
	UINT	cchServer;
	UINT	cchVroot;
	UINT	cchTrailing;

	//	Find the number of path characters that match the
	//	virtual root
	//
	cchVroot = ecb.CchGetVirtualRootW (&pwszVroot);

	//	We always return fully qualified Urls -- so we need to know
	//	the server name and the prefix.
	//
	cchPrefix = ecb.CchUrlPrefixW (&pwszPrefix);

	//	If server name is not given yet take default one
	//
	if (!pwszServer)
	{
		cchServer = ecb.CchGetServerNameW (&pwszServer);
	}
	else
	{
		cchServer = static_cast<UINT>(wcslen(pwszServer));
	}

	//	The number of characters to be skiped needs to include the physical
	//	vroot path.
	//
	cchMatching = ecb.CchGetMatchingPathW (&pwszVrPath);

	//	If the matching path is ending with '\\' we need to ajust accordingly
	//	as that symbol in the matching path is "overlapping" with the start
	//	of trailing URL part. To construct the URL correctly we need to make
	//	sure that we do not skip that separator. Also handle it the best way
	//	we can if someone is trying to commit suicide by putting '/' at the
	//	end of the matching path.
	//
	if ((0 != cchMatching) &&
		(L'\\' == pwszVrPath[cchMatching - 1] || L'/' == pwszVrPath[cchMatching - 1]) )
	{
		cchAdjust = 1;
	}
	else
	{
		cchAdjust = 0;
	}

	//	So, at this point, the length of the resulting url is the length
	//	of the servername, virtual root and trailing path all put together.
	//
	cchPath = static_cast<UINT>(wcslen(pwszPath));

	//	We assume that the path we are passed in is always fully qualified
	//	with the vroot. Assert that. Calculate the length of trailing
	//	portion including '\0' termination.
	//
	Assert (cchPath + cchAdjust >= cchMatching);
	cchTrailing = cchPath - cchMatching + cchAdjust + 1;
	cch = cchPrefix + cchServer + cchVroot + cchTrailing;

	//	If there is not enough room, a return value of S_FALSE will
	//	properly instruct the caller to realloc and call again.
	//
	if (*pcch < cch)
	{
		DebugTrace ("ScUrlFromStoragePath(): buffer too small for path translation.\n");
		*pcch = cch;
		return S_FALSE;
	}

	//	Start building the url by copying over the prefix and servername.
	//
	memcpy (pwszUrl, pwszPrefix, cchPrefix * sizeof(WCHAR));
	memcpy (pwszUrl + cchPrefix, pwszServer, cchServer * sizeof(WCHAR));
	cch = cchPrefix + cchServer;

	//	Copy over the virtual root
	//
	memcpy (pwszUrl + cch, pwszVroot, cchVroot * sizeof(WCHAR));
	cch += cchVroot;

	//$	REVIEW: I don't know what happens here when we want to be able to
	//	span virtual roots with MOVE/COPY and what not.  However, it will
	//	be up to the caller to fail this if that is the case.
	//
	if (!FSizedPathConflict (pwszPath,
							 cchPath,
							 pwszVrPath,
							 cchMatching))
	{
		DebugTrace ("ScUrlFromStoragePath (IIS URL Version): translation not "
					"scoped by current virtual root\n");
		return E_DAV_BAD_DESTINATION;
	}
	//
	//$	REVIEW: end

	//	While copying make sure that we are not skiping the '\' separator
	//	at the beginning of the trailing URL. That is what cchAdjust stands for.
	//
	memcpy( pwszUrl + cch, pwszPath + cchMatching - cchAdjust, cchTrailing * sizeof(WCHAR));

	//	Lastly, swap all '\\' to '/'
	//
	for (pwch = pwszUrl + cch;
		 NULL != (pwch = wcschr (pwch, L'\\'));
		 )
	{
		*pwch++ = L'/';
	}

	//	Pass back the length, cchTrailing includes the null-termination at this
	//	point.
	//
	*pcch = cch + cchTrailing;
	Assert (0 == pwszUrl[cch + cchTrailing - 1]);
	Assert (0 != pwszUrl[cch + cchTrailing - 2]);

	DebugTrace ("ScUrlFromStoragePath(): translated path:\n"
				"- path \"%ls\" maps to \"%ls\"\n"
				"- cchMatchingPath = %d\n"
				"- cchVroot = %d\n",
				pwszPath,
				pwszUrl,
				cchMatching,
				cchVroot);

	return S_OK;
}


SCODE __fastcall
ScUrlFromSpannedStoragePath (
	/* [in]     */ LPCWSTR	pwszPath,
	/* [in]     */ CVRoot &	vr,
	/* [in]     */ LPWSTR	pwszUrl,
	/* [in/out] */ UINT	  *	pcch)
{
	WCHAR * pwch;

	LPCWSTR	pwszPort;
	LPCWSTR	pwszServer;
	LPCWSTR	pwszVRoot;
	LPCWSTR	pwszVRPath;
	UINT	cch;
	UINT	cchPort;
	UINT	cchServer;
	UINT	cchTotal;
	UINT	cchTrailing;
	UINT	cchVRoot;

	//	Make sure that the path and the virtual root context share a
	//	common base path!
	//
	cch = vr.CchGetVRPath(&pwszVRPath);
	if (_wcsnicmp (pwszPath, pwszVRPath, cch))
	{
		DebugTrace ("ScUrlFromSpannedStoragePath (IIS URL Version): path "
					"is not from virtual root\n");
		return E_DAV_BAD_DESTINATION;
	}
	pwszPath += cch;

	//	If the next character is not a moniker separator, then this can't
	//	be a match
	//
	if (*pwszPath && (*pwszPath != L'\\'))
	{
		DebugTrace ("ScUrlFromSpannedStoragePath (IIS URL Version): path "
					"is not from virtual root\n");
		return E_DAV_BAD_DESTINATION;
	}

	//	A concatination of the url prefix, server, port, vroot prefix and
	//	the remaining path gives us our URL.
	//
	cchTrailing = static_cast<UINT>(wcslen (pwszPath));
	cchVRoot = vr.CchGetVRoot(&pwszVRoot);
	cchServer = vr.CchGetServerName(&pwszServer);
	cchPort = vr.CchGetPort(&pwszPort);
	cch = cchTrailing +
		  cchVRoot +
		  cchPort +
		  cchServer +
		  CchConstString(gc_wszUrl_Prefix_Secure) + 1;

	if (*pcch < cch)
	{
		DebugTrace ("ScUrlFromSpannedStoragePath (IIS URL Version): spanned "
					"translation buffer too small\n");

		*pcch = cch;
		return S_FALSE;
	}

	//	A small note about codepages....
	//
	//	Start constructing the url by grabbing the appropriate prefix
	//
	if (vr.FSecure())
	{
		cchTotal = gc_cchszUrl_Prefix_Secure;
		memcpy (pwszUrl, gc_wszUrl_Prefix_Secure, cchTotal * sizeof(WCHAR));
	}
	else
	{
		cchTotal = gc_cchszUrl_Prefix;
		memcpy (pwszUrl, gc_wszUrl_Prefix, cchTotal * sizeof(WCHAR));
	}

	//	Tack on the server name
	//
	memcpy (pwszUrl + cchTotal, pwszServer, cchServer * sizeof(WCHAR));
	cchTotal += cchServer;

	//	Tack on the port if it is neither the default or a secure port
	//
	if (!vr.FDefaultPort() && !vr.FSecure())
	{
		memcpy (pwszUrl + cchTotal, pwszPort, cchPort * sizeof(WCHAR));
		cchTotal += cchPort;
	}

	//	Add the vroot
	//
	memcpy (pwszUrl + cchTotal, pwszVRoot, cchVRoot * sizeof(WCHAR));
	cchTotal += cchVRoot;

	//	Add the trailing path.
	//
	//	IMPORTANT: The resulting cch will include the NULL
	//	termination.
	//
	if (cch < cchTotal + cchTrailing + 1)
	{
		DebugTrace ("ScUrlFromSpannedStoragePath (IIS URL Version): spanned "
					"translation buffer too small\n");

		*pcch = cchTotal + cchTrailing + 1;
		return S_FALSE;
	}
	else
	{
		memcpy (pwszUrl + cchTotal, pwszPath, (cchTrailing + 1) * sizeof(WCHAR));
	}

	Assert (L'\0' == pwszUrl[cchTotal + cchTrailing]);
	Assert (L'\0' != pwszUrl[cchTotal + cchTrailing - 1]);

	//	Translate all '\\' to '/'
	//
	for (pwch = pwszUrl + cchTrailing + 1; *pwch; pwch++)
	{
		if (L'\\' == *pwch)
		{
			*pwch = L'/';
		}
	}

	DebugTrace ("ScUrlFromSpannedStoragePath (IIS URL Version): spanned "
				"storage path fixed as '%S'\n", pwszUrl);
	*pcch = cchTotal + cchTrailing + 1;
	return S_OK;
}


//	Wire urls -----------------------------------------------------------------
//
SCODE __fastcall
ScWireUrlFromWideLocalUrl (
	/* [in]     */ UINT					cchLocal,
	/* [in]     */ LPCWSTR				pwszLocalUrl,
	/* [in/out] */ auto_heap_ptr<CHAR>&	pszWireUrl)
{
	UINT ib = 0;

	//	Since the url is already wide, all we need to do is
	//	to reduce the url to a UTF8 entity.
	//
	//	We could call the Win32 WideCharToMultiByte(), but we
	//	already know that production, and it would be best to
	//	skip the system call if possible.
	//
	//	Allocate enough space as if every char had maximum expansion
	//
	CStackBuffer<CHAR,MAX_PATH> psz;
	if (NULL == psz.resize((cchLocal * 3) + 1))
		return E_OUTOFMEMORY;

	if (cchLocal)
	{
		//	Currently we get UTF-8 url-s onto the wire. Do we ever
		//	want to pipe out any other codepage?
		//
		ib = WideCharToUTF8(pwszLocalUrl,
							cchLocal,
							psz.get(),
							(cchLocal * 3));
		Assert(ib);
	}

	//	Termination...
	//
	psz[ib] = 0;

	//	Escape it
	//
	HttpUriEscape (psz.get(), pszWireUrl);
	return S_OK;
}

SCODE __fastcall
ScWireUrlFromStoragePath (
	/* [in]     */ IMethUtilBase	  *	pmu,
	/* [in]     */ LPCWSTR				pwszStoragePath,
	/* [in]     */ BOOL					fCollection,
	/* [in]     */ CVRoot			  *	pcvrTranslate,
	/* [in/out] */ auto_heap_ptr<CHAR>&	pszWireUrl)
{
	Assert (pwszStoragePath);
	Assert (NULL == pszWireUrl.get());

	SCODE	sc = S_OK;

	//	Take a best guess for size and try and convert
	//	NOTE: we allocate space allowing for the trailing
	//	slash on directories - thus for the calls filling
	//	the buffer we indicate that available space is one
	//	character less than actually allocated.
	//
	CStackBuffer<WCHAR,128> pwszUrl;
	UINT cch = pwszUrl.celems();

	if (pcvrTranslate == NULL)
	{
		sc = pmu->ScUrlFromStoragePath (pwszStoragePath, pwszUrl.get(), &cch);
		if (S_FALSE == sc)
		{
			//	Try again, but with a bigger size.
			//
			if (NULL == pwszUrl.resize(CbSizeWsz(cch)))
				return E_OUTOFMEMORY;

			sc = pmu->ScUrlFromStoragePath (pwszStoragePath, pwszUrl.get(), &cch);
		}
		if (S_OK != sc)
		{
			DebugTrace ("ScWireUrlFromStoragePath (IIS URL Version): "
						"failed to translate path to href\n");
			return sc;
		}
	}
	else
	{
		sc = ScUrlFromSpannedStoragePath (pwszStoragePath,
										  *pcvrTranslate,
										  pwszUrl.get(),
										  &cch);
		if (S_FALSE == sc)
		{
			//	Try again, but with a bigger size.
			//
			if (NULL == pwszUrl.resize(CbSizeWsz(cch)))
				return E_OUTOFMEMORY;

			sc = ScUrlFromSpannedStoragePath (pwszStoragePath,
											  *pcvrTranslate,
											  pwszUrl.get(),
											  &cch);
		}
		if (S_OK != sc)
		{
			DebugTrace ("ScWireUrlFromStoragePath (IIS URL Version): "
						"failed to translate path to href\n");
			return sc;
		}
	}

	//	cch includes the termination char
	//
	Assert (cch);
	Assert (L'\0' == pwszUrl[cch - 1]);
	Assert (L'\0' != pwszUrl[cch - 2]);

	//	For directories, check the trailing slash
	//
	if (fCollection && (L'/' != pwszUrl[cch - 2]))
	{
		//	Add the trailing '/'
		//
		//	Remember we've added one extra bytes when allocating pwszUrl
		//
		pwszUrl[cch - 1] = L'/';
		pwszUrl[cch] = L'\0';
		cch += 1;
	}

	return ScWireUrlFromWideLocalUrl (cch - 1, pwszUrl.get(), pszWireUrl);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\traces.h ===
#ifndef _TRACES_H_
#define _TRACES_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	TRACES.H
//
//	.INI file tagged traces
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

DEFINE_TRACE(Put);
DEFINE_TRACE(HttpExtDbgHeaders);
DEFINE_TRACE(MoveCopyDelete);
DEFINE_TRACE(Url);
DEFINE_TRACE(FsLock);

#define PutTrace				DO_TRACE(Put)
#define HttpExtDbgHeadersTrace	DO_TRACE(HttpExtDbgHeaders)
#define MCDTrace				DO_TRACE(MoveCopyDelete)
#define UrlTrace				DO_TRACE(Url)
#define FsLockTrace				DO_TRACE(FsLock)

inline void InitTraces()
{
	INIT_TRACE(Put);
	INIT_TRACE(HttpExtDbgHeaders);
	INIT_TRACE(MoveCopyDelete);
	INIT_TRACE(Url);
	INIT_TRACE(FsLock);
}

#endif // !defined(_TRACES_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\voltype.cpp ===
//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	VOLTYPE.CPP
//
//		Implements volume type checking.  Results are cached on a per volume
//		basis to improve performance -- the call to GetVolumeInformationW()
//		is around 100KCycles and never changes for a given volume without a
//		reboot.
//

#include "_davfs.h"

#define cbDriveSpec	(sizeof(L"c:\\"))
#define cchDriveSpec (CElems(L"c:\\") - 1)

//	========================================================================
//
//	CLASS CVolumeTypeCache
//
//	A cache of volume types per volume.
//
class CVolumeTypeCache : public Singleton<CVolumeTypeCache>
{
	//
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CVolumeTypeCache>;

	//
	//	Hint: the max expected number of volumes.  It is ok for the
	//	number of volumes to be greater than this number -- it's only a hint.
	//	The number should be prime -- it gets used for the hash table
	//	size.
	//
	enum { NUM_VOLUMES_MAX_HINT = 17 };

	//
	//	Cache of mappings from volumes to volume types
	//	and a reader/writer lock to proctet it.
	//
	CCache<CRCWsz, VOLTYPE> m_cache;
	CMRWLock m_mrwCache;

	//
	//	String buffer for cached strings
	//
	ChainedStringBuffer<WCHAR> m_sb;

	//	NOT IMPLEMENTED
	//
	CVolumeTypeCache& operator=( const CVolumeTypeCache& );
	CVolumeTypeCache( const CVolumeTypeCache& );

	//	CREATORS
	//
	//	Allow sufficient space initially for the expected
	//	max number of volumes.
	//
	CVolumeTypeCache() :
		m_cache(NUM_VOLUMES_MAX_HINT),
		m_sb(NUM_VOLUMES_MAX_HINT * sizeof(WCHAR) * cbDriveSpec)
	{
	}

public:
	//	CREATORS
	//
	//	Instance creating/destroying routines provided
	//	by the Singleton template.
	//
	using Singleton<CVolumeTypeCache>::CreateInstance;
	using Singleton<CVolumeTypeCache>::DestroyInstance;
	using Singleton<CVolumeTypeCache>::Instance;
	BOOL FInitialize();

	//	ACCESSORS
	//
	VOLTYPE VolumeType(LPCWSTR pwszPath, HANDLE htokUser);
};

BOOL
CVolumeTypeCache::FInitialize()
{
	//
	//	Init the cache
	//
	if ( !m_cache.FInit() )
		return FALSE;

	//
	//	Init its reader/writer lock
	//
	if ( !m_mrwCache.FInitialize() )
		return FALSE;

	return TRUE;
}

VOLTYPE
CVolumeTypeCache::VolumeType(LPCWSTR pwszPath, HANDLE htokUser)
{
	//	By default assume the volume type is NOT NTFS.  That way if we
	//	cannot determine the volume type, we at least don't end up saying
	//	that we support more functionality than might actually be there.
	//
	VOLTYPE voltype = VOLTYPE_NOT_NTFS;
	CStackBuffer<WCHAR> pwszVol;

	//	If the path now refers to a UNC, then treat it as such...
	//
	if ((*pwszPath == L'\\') && (*(pwszPath + 1) == L'\\'))
	{
		LPCWSTR pwsz;
		UINT cch;

		//	If there is not enough info here, then we don't know
		//	what the volume type is.
		//
		pwsz = wcschr (pwszPath + 2, L'\\');
		if (!pwsz)
			goto ret;

		//	Ok, we have picked off the server portion of the UNC, now
		//	we should check for the share name.  If is terminated with
		//	a slash, then we are set.  Otherwise, we need to be smart
		//	about it...
		//
		pwsz = wcschr (pwsz + 1, L'\\');
		if (!pwsz)
		{
			//	OK, we need to be smart.
			//
			//	The call to GetVolumeInformationW() requires that the
			//	path passed in be terminated with an extra slash in the
			//	case where it refers to a UNC.
			//
			cch = static_cast<UINT>(wcslen(pwszPath));
			if (NULL == pwszVol.resize((cch + 2) * sizeof(WCHAR)))
				goto ret;

			wcsncpy (pwszVol.get(), pwszPath, cch);
			pwszVol[cch] = L'\\';
			pwszVol[cch + 1] = 0;
		}
		else
		{
			cch = static_cast<UINT>(++pwsz - pwszPath);
			if (NULL == pwszVol.resize((cch + 1) * sizeof(WCHAR)))
				goto ret;

			wcsncpy (pwszVol.get(), pwszPath, cch);
			pwszVol[cch] = 0;
		}
	}
	else
	{
		if (NULL == pwszVol.resize(cbDriveSpec))
			goto ret;

		wcsncpy(pwszVol.get(), pwszPath, cchDriveSpec);
		pwszVol[cchDriveSpec] = 0;
	}

	//	Try the cache for volume info.
	//
	{
		CSynchronizedReadBlock sb(m_mrwCache);
		if (m_cache.FFetch(CRCWsz(pwszVol.get()), &voltype))
			goto ret;
	}

	//	Didn't find it in the cache, so do the expensive lookup.
	//
	{
		WCHAR wszLabel[20];
		DWORD dwSerial;
		DWORD cchNameMax;
		DWORD dwFlags;
		WCHAR wszFormat[20];

		//	Temporarily revert to local system before calling GetVolumeInformationW()
		//	so that we have adequate permission to query the volume type, even if the
		//	admin has secured the root of the drive.
		//
		safe_revert sr(htokUser);

		if (GetVolumeInformationW (pwszVol.get(),
								   wszLabel,
								   CElems(wszLabel),
								   &dwSerial,
								   &cchNameMax,
								   &dwFlags,
								   wszFormat,
								   CElems(wszFormat)))
		{
			//	If it is "NTFS", then I guess we have to believe it.
			//
			voltype = ((!_wcsicmp (wszFormat, L"NTFS"))
					    ? VOLTYPE_NTFS
						: VOLTYPE_NOT_NTFS);
		}
		else
		{
			//	If we couldn't get volume information for whatever reason then
			//	return the default volume type (VOLTYPE_NOT_NTFS), but DO NOT
			//	cache it.  If the failure is temporary, we want to force the
			//	call to GetVolumeInformationW() again the next time this volume
			//	is hit.  The call to GetVolumeInformationW() should theoretically
			//	not fail repeatedly given that we are passing in valid parameters,
			//	and that we have sufficient permission to query the device, etc.
			//
			goto ret;
		}
	}

	//	Add the volume to the cache.  Ignore errors -- we already have
	//	a volume type to return to the caller.  Also note that we use
	//	FSet() rather than FAdd().  The reason is that since we never
	//	expire items from this cache, duplicates would stick around forever.
	//	The number of potential dups is only as high as the number of
	//	simultaneous threads that hit a volume for the first time, but
	//	that could still be pretty high (on the order of a couple hundred).
	//
	{
		CSynchronizedWriteBlock sb(m_mrwCache);

		if (!m_cache.Lookup(CRCWsz(pwszVol.get())))
			(VOID) m_cache.FAdd(CRCWsz(m_sb.AppendWithNull(pwszVol.get())), voltype);
	}

ret:
	return voltype;
}

VOLTYPE
VolumeType(LPCWSTR pwszPath, HANDLE htokUser)
{
	return CVolumeTypeCache::Instance().VolumeType(pwszPath, htokUser);
}

BOOL
FInitVolumeTypeCache()
{
	return CVolumeTypeCache::CreateInstance().FInitialize();
}

VOID
DeinitVolumeTypeCache()
{
	CVolumeTypeCache::DestroyInstance();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\_davfs.cpp ===
/*
 *	_ D A V F S . C
 *
 *	Precompiled header sources
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_davfs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\_diriter.h ===
/*
 *	_ D I R I T E R . H
 *
 *	Headers for directory ineration object
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	__DIRITER_H_
#define __DIRITER_H_

#include <buffer.h>

//	Path separators -----------------------------------------------------------
//
DEC_CONST WCHAR gc_wszPathSeparator[] = L"\\";
DEC_CONST WCHAR gc_wszUriSeparator[] = L"/";

//	Helper functions ----------------------------------------------------------
//
inline BOOL
IsHidden(const WIN32_FIND_DATAW& fd)
{
	return !!(fd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN);
}

inline BOOL
IsDirectory(const WIN32_FIND_DATAW& fd)
{
	return !!(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
}

//	CInitedStringBuffer -------------------------------------------------------
//
template<class T>
class CInitedStringBuffer : public StringBuffer<T>
{
	//	non-implemented operators
	//
	CInitedStringBuffer (const CInitedStringBuffer& );
	CInitedStringBuffer& operator= (const CInitedStringBuffer& );

public:

	CInitedStringBuffer (const T* pszInit, const T* pszSep)
	{
		//	Initialize the uri
		//
		if (pszInit)
		{
			Append (pszInit);
			if (*(PContents() + CchSize() - 1) != *pszSep)
				Append (pszSep);
		}
		else
			Append (pszSep);
	}
};

//	CResPath ------------------------------------------------------------------
//
template<class T>
class CResPath
{
	const T*				m_sz;	//	Path separator
	StringBuffer<T>&		m_sb;
	UINT					m_ib;

	//	non-implemented operators
	//
	CResPath (const CResPath& );
	CResPath& operator= (const CResPath& );

public:

	CResPath (StringBuffer<T>& sb, const T* pszSep)
			: m_sz(pszSep),
			  m_sb(sb),
			  m_ib(sb.CbSize())
	{
		Assert (m_ib >= sizeof(T));
		const T* psz = m_sb.PContents() + ((m_ib/sizeof(T)) - 1);
		if (*psz == '\0')
		{
			Assert (!memcmp (m_sz, psz - 1, sizeof(T)));
			m_ib -= sizeof(T);
		}
		else
			Assert (!memcmp (m_sz, psz, sizeof(T)));
	}

	const T* PszPath(void) const { return m_sb.PContents(); }
	void Extend (const T* pszSegment, UINT cch, BOOL fDir)
	{
		//	Append the path segment, and in the case of a
		//	directory append the separator as well.
		//
		if (fDir)
		{
			//	Copy over the name, then append a slash and the
			//	null termination
			//
			m_sb.AppendAt (m_ib, cch * sizeof(T), pszSegment);
			m_sb.Append (2 * sizeof(T), m_sz);
		}
		else
		{
			//	Copy over the name, then append a null.
			T ch = 0;
			m_sb.AppendAt (m_ib, cch * sizeof(T), pszSegment);
			m_sb.Append (sizeof(T), &ch);
		}
	}
};

//	CDirState -----------------------------------------------------------------
//
class CDirState : public CMTRefCounted
{
	HANDLE						m_hFind;
	WIN32_FIND_DATAW&			m_fd;

	CInitedStringBuffer<WCHAR>	m_sbPathDst;
	auto_ref_ptr<CVRoot>		m_pvrDst;

	CResPath<WCHAR>				m_rpUriSrc;
	CResPath<WCHAR>				m_rpPathSrc;
	CResPath<WCHAR>				m_rpUriDst;
	CResPath<WCHAR>				m_rpPathDst;

	void Extend (WIN32_FIND_DATAW& fd)
	{
		BOOL fDirectory = IsDirectory (fd);
		UINT cch = static_cast<UINT>(wcslen (fd.cFileName));

		m_rpPathSrc.Extend (fd.cFileName, cch, fDirectory);
		m_rpPathDst.Extend (fd.cFileName, cch, fDirectory);

		//	We only want to extend the count of chars NOT INCLUDING
		//	the NULL
		//
		m_rpUriSrc.Extend (fd.cFileName, cch, fDirectory);
		m_rpUriDst.Extend (fd.cFileName, cch, fDirectory);
	}

	//	non-implemented operators
	//
	CDirState (const CDirState& );
	CDirState& operator= (const CDirState& );

public:

	CDirState (StringBuffer<WCHAR>& sbUriSrc,
			   StringBuffer<WCHAR>& sbPathSrc,
			   StringBuffer<WCHAR>& sbUriDst,
			   LPCWSTR pwszPathDst,
			   CVRoot* pvr,
			   WIN32_FIND_DATAW& fd)
			: m_hFind(INVALID_HANDLE_VALUE),
			  m_fd(fd),
			  m_sbPathDst(pwszPathDst, gc_wszPathSeparator),
			  m_pvrDst(pvr),
			  m_rpUriSrc(sbUriSrc, gc_wszUriSeparator),
			  m_rpPathSrc(sbPathSrc, gc_wszPathSeparator),
			  m_rpUriDst(sbUriDst, gc_wszUriSeparator),
			  m_rpPathDst(m_sbPathDst, gc_wszPathSeparator)
	{
		//	Clear and/or reset the find data
		//
		memset (&fd, 0, sizeof(WIN32_FIND_DATAW));
	}

	~CDirState()
	{
		if (m_hFind != INVALID_HANDLE_VALUE)
		{
			FindClose (m_hFind);
		}
	}

	SCODE ScFindNext(void);

	LPCWSTR PwszUri(void)				const { return m_rpUriSrc.PszPath(); }
	LPCWSTR PwszSource(void)			const { return m_rpPathSrc.PszPath(); }
	LPCWSTR PwszUriDestination(void)	const { return m_rpUriDst.PszPath(); }
	LPCWSTR PwszDestination(void)		const { return m_rpPathDst.PszPath(); }

	CVRoot* PvrDestination(void)		const { return m_pvrDst.get(); }
};

//	CDirectoryStack -----------------------------------------------------------
//
//	Use pragmas to disable the specific level 4 warnings
//	that appear when we use the STL.  One would hope our version of the
//	STL compiles clean at level 4, but alas it doesn't....
//
#pragma warning(disable:4663)	//	C language, template<> syntax
#pragma warning(disable:4244)	//	return conversion, data loss

// Turn this warning off for good.
//
#pragma warning(disable:4786)	//	symbol truncated in debug info

// Put STL includes here
//
#include <list>

// Turn warnings back on
//
#pragma warning(default:4663)	//	C language, template<> syntax
#pragma warning(default:4244)	//	return conversion, data loss

typedef std::list<const CDirState*, heap_allocator<const CDirState*> > CDirectoryStack;

//	Directory iteration class -------------------------------------------------
//
class CDirIter
{
	CInitedStringBuffer<WCHAR>	m_sbUriSrc;
	CInitedStringBuffer<WCHAR>	m_sbPathSrc;
	CInitedStringBuffer<WCHAR>	m_sbUriDst;

	auto_ref_ptr<CDirState>		m_pds;

	BOOL						m_fSubDirectoryIteration;
	CDirectoryStack				m_stack;

	WIN32_FIND_DATAW			m_fd;

	//	NOT IMPLEMENTED
	//
	CDirIter (const CDirIter&);
	CDirIter& operator= (const CDirIter&);

public:

	CDirIter (LPCWSTR pwszUri,
			  LPCWSTR pwszSource,
			  LPCWSTR pwszUriDestination,
			  LPCWSTR pwszDestination,
			  CVRoot* pvrDestination,
			  BOOL fDoSubDirs = FALSE)
			: m_sbUriSrc(pwszUri, gc_wszUriSeparator),
			  m_sbPathSrc(pwszSource, gc_wszPathSeparator),
			  m_sbUriDst(pwszUriDestination, gc_wszUriSeparator),
			  m_fSubDirectoryIteration(fDoSubDirs)
	{
		//	Create the initial directory state
		//
		m_pds = new CDirState (m_sbUriSrc,
							   m_sbPathSrc,
							   m_sbUriDst,
							   pwszDestination,
							   pvrDestination,
							   m_fd);
	}

	//	API -------------------------------------------------------------------
	//
	SCODE __fastcall ScGetNext (
		/* [in] */ BOOL fDoSubDirs = TRUE,
		/* [in] */ LPCWSTR pwszNewPath = NULL,
		/* [in] */ CVRoot* pvrDestination = NULL);

	LPCWSTR PwszSource() const			{ return m_pds->PwszSource(); }
	LPCWSTR PwszDestination() const		{ return m_pds->PwszDestination(); }
	LPCWSTR PwszUri() const				{ return m_pds->PwszUri(); }
	LPCWSTR PwszUriDestination() const	{ return m_pds->PwszUriDestination(); }
	CVRoot* PvrDestination()			{ return m_pds->PvrDestination(); }

	WIN32_FIND_DATAW& FindData()		{ return m_fd; }

	BOOL FDirectory() const				{ return IsDirectory(m_fd); }
	BOOL FHidden() const				{ return IsHidden(m_fd); }
	BOOL FSpecial() const
	{
		return (!wcscmp (L".", m_fd.cFileName) ||
				!wcscmp (L"..", m_fd.cFileName));
	}
};

#endif	// __DIRITER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\_fsimpl.h ===
/*
 *	_ F S I M P L . H
 *
 *	File System Implementation of DAV
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	__FSIMPL_H_
#define __FSIMPL_H_

extern const WCHAR gc_wszPathPrefix[];
extern const UINT gc_cchwszPathPrefix;

//	Support functions ---------------------------------------------------------
//
#include <ex\rgiter.h>

class auto_ref_handle;
VOID TransmitFileRanges (LPMETHUTIL pmu,
						 const auto_ref_handle& hf,
						 DWORD dwSize,
						 CRangeBase *priRanges,
						 LPCWSTR pwszContent);

//	Tracing -------------------------------------------------------------------
//
#ifdef	DBG
extern BOOL g_fDavTrace;
#define DavTrace				!g_fDavTrace?0:DebugTraceFn
#else
#define DavTrace				NOP_FUNCTION
#endif

//	Instance ------------------------------------------------------------------
//
extern HINSTANCE g_hinst;

extern CHAR gc_szVersion[];

// Gives the count of elements in an array
//
#define CElems(_rg)		(sizeof(_rg)/sizeof(_rg[0]))

//	free the global DBCreateCommand object
//
VOID ReleaseDBCreateCommandObject();

//	Locking support functions -------------------------------------------------
//	(Implemented in fslock.cpp)
//
BOOL FGetLockHandle (LPMETHUTIL pmu, LPCWSTR pwszPath,
					 DWORD dwAccess, LPCWSTR pwszLockTokenHeader,
					 auto_ref_handle * phandle);
SCODE ScDoLockedCopy (LPMETHUTIL pmu, CParseLockTokenHeader * plth,
					  LPCWSTR pwszSrc, LPCWSTR pwszDst);

#endif	// __FSIMPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\_davfs.h ===
/*
 *	_ D A V F S . H
 *
 *	Precompiled header sources
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	__DAVFS_H_
#define __DAVFS_H_

#pragma warning(disable:4001)	/* single line comments */
#pragma warning(disable:4050)	/* different code attributes */
#pragma warning(disable:4100)	/* unreferenced formal parameter */
#pragma warning(disable:4115)	/* named type definition in parentheses */
#pragma warning(disable:4127)	/* conditional expression is constant */
#pragma warning(disable:4201)	/* nameless struct/union */
#pragma warning(disable:4206)	/* translation unit is empty */
#pragma warning(disable:4209)	/* benign typedef redefinition */
#pragma warning(disable:4214)	/* bit field types other than int */
#pragma warning(disable:4514)	/* unreferenced inline function */
#pragma warning(disable:4200)	/* zero-sized array in struct/union */
#pragma warning(disable:4710)	//	(inline) function not expanded

//	Windows headers
//
//$HACK!
//
//	Define _WINSOCKAPI_ to keep windows.h from including winsock.h,
//	whose declarations would be redefined in winsock2.h,
//	which is included by iisextp.h,
//	which we include in davimpl.h!
//
#define _WINSOCKAPI_
#include <windows.h>
#include <winnls.h>

#include <malloc.h>

#include <caldbg.h>
#include <calrc.h>
#include <perfctrs.h>
#include <crc.h>
#include <exo.h>
#include <singlton.h>
#include <thrdpool.h>

#include <align.h>
#include <mem.h>
#include <except.h>

#include <davimpl.h>
#include <security.h>
#include <davmb.h>
#include <eventlog.h>
#include <statcode.h>
#include <sz.h>
#include <etag.h>
#include <dav.rh>

#include <ex\cnvt.h>
#include <util.h>

#include <filter.h>
#include <filterr.h>

#include <smh.h>
#include <shlkcache.h>

#include "_fslock.h"
#include "_fsimpl.h"
#include "_fsri.h"
#include "_fsutil.h"

#include "_diriter.h"

#include "_fsmvcpy.h"
#include "_fsmeta.h"

#include "_voltype.h"

#include "davprsmc.h"
#include "traces.h"

//	DAV Prefixed Win32 API's --------------------------------------------------
//
HANDLE __fastcall DavCreateFile (
	/* [in] */ LPCWSTR lpFileName,
    /* [in] */ DWORD dwDesiredAccess,
    /* [in] */ DWORD dwShareMode,
    /* [in] */ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    /* [in] */ DWORD dwCreationDisposition,
    /* [in] */ DWORD dwFlagsAndAttributes,
    /* [in] */ HANDLE hTemplateFile);

BOOL __fastcall DavDeleteFile (
	/* [in] */ LPCWSTR lpFileName);

BOOL __fastcall DavCopyFile (
	/* [in] */ LPCWSTR lpExistingFileName,
	/* [in] */ LPCWSTR lpNewFileName,
	/* [in] */ BOOL bFailIfExists);

BOOL __fastcall DavMoveFile (
	/* [in] */ LPCWSTR lpExistingFileName,
	/* [in] */ LPCWSTR lpNewFileName,
	/* [in] */ DWORD dwReplace);

BOOL __fastcall DavCreateDirectory (
	/* [in] */ LPCWSTR lpFileName,
	/* [in] */ LPSECURITY_ATTRIBUTES lpSecurityAttributes);

BOOL __fastcall DavRemoveDirectory (
	/* [in] */ LPCWSTR lpFileName);

BOOL __fastcall DavGetFileAttributes (
	/* [in] */ LPCWSTR lpFileName,
	/* [in] */ GET_FILEEX_INFO_LEVELS fInfoLevelId,
	/* [out] */ LPVOID lpFileInformation);

#endif	// __DAVFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\_fslock.h ===
#ifndef __FSLOCK_H_
#define __FSLOCK_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	CLOCKFS.H
//
//		Declares the CLockFS object which inherits from CLock and uses
//      a CInShLockData object to store information about the lock it represents.
//
//	Copyright 2000 Microsoft Corporation, All Rights Reserved
//

//	========================================================================
//
//	CLASS CLockFS
//
//		Implements a lock object for the file system.
//		Contains a file handle that has a particular type of access on the file.
//		Inherits from CLock, which is a ref-countable class.
//      Wraps CInShLockData that exists in shared memory and holds lock information.
//
class CLockFS : public CMTRefCounted
{
	SharedPtr<CInShLockData> m_spSharedLockData;

	//	NOT IMPLEMENTED
	//
	CLockFS (const CLockFS&);
	CLockFS& operator= (const CLockFS&);

    LPCVOID GetOwnerSID()
    { return m_spSharedLockData->GetOwnerSID(); };

public:
    CLockFS() {};
	~CLockFS() {};	// autoptr will clean up the handle.

    // HTTPEXT - SharedMemory functions
    // =================================
    SharedPtr<CInShLockData>& SharedData()
    { return m_spSharedLockData; };

	// =======================================
	//	ACCESSORS
	LPCWSTR GetResourceName() const
	{ return m_spSharedLockData->GetResourceName(); }

	const __int64* GetLockID() const
	{ return m_spSharedLockData->GetLockID(); };

	DWORD GetTimeoutInSecs() const
	{ return m_spSharedLockData->GetTimeoutInSecs(); }

	DWORD GetAccess() const
	{ return m_spSharedLockData->GetAccess(); }

	DWORD GetLockType() const
	{ return m_spSharedLockData->GetLockType(); }

	DWORD GetLockScope() const
	{ return m_spSharedLockData->GetLockScope(); }

	LPCWSTR PwszOwnerComment() const 
	{ return m_spSharedLockData->PwszOwnerComment(); }

    //	Lock token string
	//
	LPCWSTR GetLockTokenString() const
	{
		return m_spSharedLockData->GetLockTokenString();
	}

	//	MANIPULATORS
	//

	//	Set the timeout in seconds
	//
	void SetTimeout (DWORD dwSeconds)
	{  
		m_spSharedLockData->SetTimeoutInSecs(dwSeconds);
	}

	VOID SendLockComment(LPMETHUTIL pmu) const;
	
	DWORD DwCompareLockOwner (LPMETHUTIL pmu);
};

//	------------------------------------------------------------------------
//
//	class CParseLockTokenHeader
//
//		Takes in a Lock-Token header (you need to fetch the header & pre-check
//		that it's not NULL) and provides parsing & iteration routines.
//
//		Can also be instantiated over a If-[None-]State-Match header to
//		do the state-token checking required.
//
//		Implemented in lockutil.cpp
//
class CParseLockTokenHeader
{
	//	The big stuff
	//
	LPMETHUTIL m_pmu;
	HDRITER_W m_hdr;
	LPCSTR m_pszCurrent;

	//	State bits
	BOOL m_fPathsSet : 1;
	BOOL m_fTokensChecked : 1;

	//	Data for paths
	UINT m_cwchPath;
	auto_heap_ptr<WCHAR> m_pwszPath;
	UINT m_cwchDest;
	auto_heap_ptr<WCHAR> m_pwszDest;

	//	Count of locktokens provided
	ULONG m_cTokens;

	//	Quick-access to single-locktoken data
	LPCSTR m_pszToken;

	//	Data for multiple tokens
	struct PATH_TOKEN
	{
		__int64 i64LockId;
		BOOL fFetched;	// TRUE = path & dwords below have been filled in.
		LPCWSTR pwszPath;
		DWORD dwLockType;
		DWORD dwAccess;
	};
	auto_heap_ptr<PATH_TOKEN> m_pargPathTokens;
	//	m_cTokens tells how many valid structures we have.

	//	Fetch info about this lockid from the lock cache.
	HRESULT HrFetchPathInfo (__int64 i64LockId, PATH_TOKEN * pPT);

	//	NOT IMPLEMENTED
	//
	CParseLockTokenHeader( const CParseLockTokenHeader& );
	CParseLockTokenHeader& operator=( const CParseLockTokenHeader& );

public:
	CParseLockTokenHeader (LPMETHUTIL pmu, LPCWSTR pwszHeader) :
			m_pmu(pmu),
			m_hdr(pwszHeader),
			m_pszCurrent(NULL),
			m_fPathsSet(FALSE),
			m_fTokensChecked(FALSE),
			m_cwchPath(0),
			m_cwchDest(0),
			m_cTokens(0),
			m_pszToken(NULL)
	{
		Assert(m_pmu);
		Assert(pwszHeader);
	}
	~CParseLockTokenHeader() {}

	//	Special test -- F if not EXACTLY ONE item in the header.
	BOOL FOneToken();
	//	Feed the relevant paths to this lock token parser.
	HRESULT SetPaths (LPCWSTR pwszPath, LPCWSTR pwszDest);
	//	Get the token string for a path WITH a certain kind of access.
	HRESULT HrGetLockIdForPath (LPCWSTR pwszPath, DWORD dwAccess,
								__int64 * pi64LockId,
								BOOL fPathLookup = FALSE);

};

BOOL FLockViolation (LPMETHUTIL pmu,
					 HRESULT hr,
					 LPCWSTR pwszPath,
					 DWORD dwAccess);

BOOL FDeleteLock (LPMETHUTIL pmu, __int64 i64LockId);

HRESULT HrCheckStateHeaders (LPMETHUTIL pmu,
							 LPCWSTR pwszPath,
							 BOOL fGetMeth);

HRESULT HrLockIdFromString (LPMETHUTIL pmu,
							LPCWSTR pwszToken,
							__int64 * pi64LockId);

SCODE ScLockDiscoveryFromCLock (LPMETHUTIL pmu,
								CXMLEmitter& emitter,
								CEmitterNode& en,
								CLockFS* pLock);

HRESULT HrGetLockProp (LPMETHUTIL pmu,
					   LPCWSTR wszPropName,
					   LPCWSTR wszResource,
					   RESOURCE_TYPE rtResource,
					   CXMLEmitter& emitter,
					   CEmitterNode& enParent);

#endif // __FSLOCK_H_ endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\_fsmeta.h ===
/*
 *	_ F S M E T A . H
 *
 *	File system metadata routines
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef __FSMETA_H_
#define __FSMETA_H_

//	STL helpers ---------------------------------------------------------------
//
//	Use pragmas to disable the specific level 4 warnings
//	that appear when we use the STL.  One would hope our version of the
//	STL compiles clean at level 4, but alas it doesn't....
#pragma warning(disable:4663)	//	C language, template<> syntax
#pragma warning(disable:4244)	//	return conversion, data loss
// Turn this warning off for good.
#pragma warning(disable:4786)	//	symbol truncated in debug info
// Put STL includes here
#include <list>
// Turn warnings back on
#pragma warning(default:4663)	//	C language, template<> syntax
#pragma warning(default:4244)	//	return conversion, data loss

//	OLE and NT5 properties ----------------------------------------------------
//
#define OLEDBVER 0x200
#include <ole2.h>
#include <stgint.h>
#include <pbagex.h>

typedef HRESULT (__stdcall * STGOPENSTORAGEONHANDLE)(
	IN HANDLE hStream,
	IN DWORD grfMode,
	IN void *reserved1,
	IN void *reserved2,
	IN REFIID riid,
	OUT void **ppObjectOpen );

typedef HRESULT (__stdcall * STGCREATESTORAGEONHANDLE)(
	IN HANDLE hStream,
	IN DWORD grfMode,
	IN DWORD stgfmt,
	IN void *reserved1,
	IN void *reserved2,
	IN REFIID riid,
	OUT void **ppObjectOpen );

extern STGOPENSTORAGEONHANDLE	g_pfnStgOpenStorageOnHandle;

//	reserved properties ------------------------------------------------------
//
//	There are two conditions that make a property reserved.
//
//	The first and foremost is that the property is not something that is stored
//	in the resource's property container, but instead is calculated from file
//	system information or DAV specific conditions (lock info, etc.)
//
//	The second is that the property is not something that can be set via
//	PROPPATCH calls.  This distinction is needed when asking if a property is
//	reserved.
//
enum {

	//	The properties in this section are all properties that are calculated
	//	from the filesystem or DAV specific information.
	//
	iana_rp_content_length,
	iana_rp_creation_date,
	iana_rp_displayname,
	iana_rp_etag,
	iana_rp_last_modified,
	iana_rp_resourcetype,
	iana_rp_lockdiscovery,
	iana_rp_supportedlock,
	iana_rp_ishidden,
	iana_rp_iscollection,
	sc_crp_get_reserved,

	//	The properties in this section are actually stored in the property
	//	container (via PUT) but are reserved for the purpose of PUT.
	//
	//	IMPORTANT! "DAV:getcontenttype" must be the first non-get reserved
	//	property!
	//
	iana_rp_content_type = sc_crp_get_reserved,
	iana_rp_content_encoding,
	iana_rp_content_language,

	//	To be consistent with DAVEX, make the following property reserved
	//
	iana_rp_searchrequest,
	sc_crp_set_reserved
};

typedef struct RP { DWORD dwCRC; LPCWSTR pwsz; } RP;
#define IanaItemCrc(_sz,_crc) { _crc, L"DAV:" L#_sz }
DEC_CONST RP sc_rp[sc_crp_set_reserved] = {

	IanaItemCrc(getcontentlength,		0x25412A26),
	IanaItemCrc(creationdate,			0xA8A9F240),
	IanaItemCrc(displayname,			0xA399DB8D),
	IanaItemCrc(getetag,				0x5E54D3B8),
	IanaItemCrc(getlastmodified,		0x45D75CD4),
	IanaItemCrc(resourcetype,			0x8155BECE),
	IanaItemCrc(lockdiscovery,			0xC7ED2F96),
	IanaItemCrc(supportedlock,			0x39B9A692),
	IanaItemCrc(ishidden,				0xE31B1632),
	IanaItemCrc(iscollection,			0xD3E3FF13),
	IanaItemCrc(getcontenttype,			0xC28B9FED),
	IanaItemCrc(getcontentencoding,		0x4B7C7220),
	IanaItemCrc(getcontentlanguage,		0x5E9717C2),
	IanaItemCrc(searchrequest,			0x5AC72D67),
};

//	DAV Metadata --------------------------------------------------------------
//
#include <xmeta.h>

//	The FS impl of DAV uses the NT5 property interfaces and IPropertyBag
//	as its underlying property storage implementation.  This mechanism uses
//	strings and/or PROPVARIANTS to refer to properties and their values.
//
//	Therefore the PROPFIND and PROPPATCH contexts are written with this in
//	mind.
//
//	CFSFind/CFSPatch ----------------------------------------------------------
//
class CFSProp;
class CFSFind : public CFindContext, public IPreloadNamespaces
{
	ChainedStringBuffer<WCHAR>	m_csb;
	ULONG						m_cProps;
	ULONG						m_cMaxProps;
	auto_heap_ptr<LPCWSTR>		m_rgwszProps;

	LONG						m_ip_getcontenttype;

	//	non-implemented operators
	//
	CFSFind( const CFSFind& );
	CFSFind& operator=( const CFSFind& );

public:

	virtual ~CFSFind() {}
	CFSFind()
			: m_cProps(0),
			  m_cMaxProps(0),
			  m_ip_getcontenttype(-1)
	{
	}

	//	When the parser finds an item that the client wants returned,
	//	the item is added to the context via the following set context
	//	methods.  Each add is qualified by the resource on which the
	//	request is made. fExcludeProp is used for full-fidelity special
	//	cases in the Exchange implementation only.
	//
	virtual SCODE ScAddProp(LPCWSTR pwszPath, LPCWSTR pwszProp, BOOL fExcludeProp);

	//	The ScFind() method is used to invoke the context onto a given
	//	resources property object.
	//
	SCODE ScFind (CXMLEmitter& msr, IMethUtil * pmu, CFSProp& fpt);

	//	Add an error to the response that is based on the context.
	//
	SCODE ScErrorAllProps (CXMLEmitter& msr,
						   IMethUtil * pmu,
						   LPCWSTR pwszPath,
						   BOOL	fCollection,
						   CVRoot* pcvrTranslation,
						   SCODE scErr)
	{
		//	Add an item to the msr that says this entire
		//	file was not accessible
		//
		return  ScAddMulti (msr,
							pmu,
							pwszPath,
							NULL,
							HscFromHresult(scErr),
							fCollection,
							pcvrTranslation);
	}

	//	IPreloadNamespaces
	//
	SCODE	ScLoadNamespaces(CXMLEmitter * pmsr);
};

class CFSPatch : public CPatchContext, public IPreloadNamespaces
{
	class CFSPropContext : public CPropContext
	{
		PROPVARIANT*		m_pvar;
		BOOL				m_fHasValue;

		//	non-implemented operators
		//
		CFSPropContext( const CFSPropContext& );
		CFSPropContext& operator=( const CFSPropContext& );

	public:

		CFSPropContext(PROPVARIANT* pvar)
				: m_pvar(pvar),
				  m_fHasValue(FALSE)
		{
			Assert (pvar != NULL);
		}

		virtual ~CFSPropContext() {}
		virtual SCODE ScSetType(LPCWSTR pwszType)
		{
			return ScVariantTypeFromString (pwszType, m_pvar->vt);
		}
		virtual SCODE ScSetValue(LPCWSTR pwszValue, UINT cmvValues)
		{
			//	At this time, HTTPEXT does not support multivalued
			//	properties.
			//
			Assert (0 == cmvValues);

			//	If no type was specified, we default to a string
			//
			m_fHasValue = TRUE;
			if (m_pvar->vt == VT_EMPTY)
				m_pvar->vt = VT_LPWSTR;

			return ScVariantValueFromString (*m_pvar, pwszValue);
		}
		virtual SCODE ScComplete(BOOL fEmpty)
		{
			Assert (m_fHasValue);
			return m_fHasValue ? S_OK : E_DAV_XML_PARSE_ERROR;
		}

		//	At this time, HTTPEXT does not support multivalued
		//	properties.
		//
		virtual BOOL FMultiValued() { return FALSE; }
	};

	//	PATCH_SET items
	//
	ChainedStringBuffer<WCHAR>	m_csb;
	ULONG						m_cSetProps;
	ULONG						m_cMaxSetProps;
	auto_heap_ptr<LPCWSTR>		m_rgwszSetProps;
	auto_heap_ptr<PROPVARIANT>	m_rgvSetProps;

	//	Failed Propserties including reserverd properties
	//
	CStatusCache				m_csn;

	//	PATCH_DELETE items
	//
	ULONG						m_cDeleteProps;
	ULONG						m_cMaxDeleteProps;
	auto_heap_ptr<LPCWSTR>		m_rgwszDeleteProps;

	//	non-implemented operators
	//
	CFSPatch( const CFSPatch& );
	CFSPatch& operator=( const CFSPatch& );

public:

	virtual ~CFSPatch();
	CFSPatch()
			: m_cSetProps(0),
			  m_cMaxSetProps(0),
			  m_cDeleteProps(0),
			  m_cMaxDeleteProps(0)
	{
	}

	SCODE	ScInit() { return m_csn.ScInit(); }

	//	When the parser finds an item that the client wants operated on,
	//	the item is added to the context via the following set context
	//	methods.  Each request is qualified by the resource on which the
	//	request is made.
	//
	virtual SCODE ScDeleteProp(LPCWSTR pwszPath,
							   LPCWSTR pwszProp);
	virtual SCODE ScSetProp(LPCWSTR pwszPath,
							LPCWSTR pwszProp,
							auto_ref_ptr<CPropContext>& pPropCtx);

	//	The ScPatch() method is used to invoke the context onto a given
	//	resources property object.
	//
	SCODE ScPatch (CXMLEmitter& msr, IMethUtil * pmu, CFSProp& fpt);

	//	IPreloadNamespaces
	//
	SCODE	ScLoadNamespaces(CXMLEmitter * pmsr);
};

//	CFSProp -------------------------------------------------------------------
//
#include "_voltype.h"
class CFSProp
{
	IMethUtil*						m_pmu;

	LPCWSTR							m_pwszURI;
	LPCWSTR							m_pwszPath;
	CVRoot*							m_pcvrTranslation;

	CResourceInfo&					m_cri;

	auto_com_ptr<IPropertyBagEx>& 	m_pbag;
	BOOL FInvalidPbag() const		{ return (m_pbag.get() == NULL); }

	//	Volume type of the drive on which m_pwszPath resides
	//
	mutable VOLTYPE m_voltype;

	BOOL FIsVolumeNTFS() const
	{
		//	If we don't already know it, figure out the volume type
		//	for the volume on which our path resides.
		//
		if (VOLTYPE_UNKNOWN == m_voltype)
			m_voltype = VolumeType(m_pwszPath, m_pmu->HitUser());

		//	Return whether that volume is NTFS.
		//
		Assert(m_voltype != VOLTYPE_UNKNOWN);
		return VOLTYPE_NTFS == m_voltype;
	}

	//	non-implemented operators
	//
	CFSProp( const CFSProp& );
	CFSProp& operator=( const CFSProp& );

	enum { PROP_CHUNK_SIZE = 16 };

	SCODE ScGetPropsInternal (ULONG cProps,
							  LPCWSTR* rgwszPropNames,
							  PROPVARIANT* rgvar,
							  LONG ip_getcontenttype);


public:

	CFSProp(IMethUtil* pmu,
			auto_com_ptr<IPropertyBagEx>& pbag,
			LPCWSTR pwszUri,
			LPCWSTR pwszPath,
			CVRoot* pcvr,
			CResourceInfo& cri)
			: m_pmu(pmu),
			  m_pwszURI(pwszUri),
			  m_pwszPath(pwszPath),
			  m_pcvrTranslation(pcvr),
			  m_cri(cri),
			  m_pbag(pbag),
			  m_voltype(VOLTYPE_UNKNOWN)
	{
	}

	LPCWSTR PwszPath() const { return m_pwszPath; }
	CVRoot* PcvrTranslation() const { return m_pcvrTranslation; }
	BOOL FCollection() const
	{
		if (m_cri.FLoaded())
			return m_cri.FCollection();
		else
			return FALSE;
	}

	//	Reserved Properties
	//
	typedef enum { RESERVED_GET, RESERVED_SET } RESERVED_TYPE;
	static BOOL FReservedProperty (LPCWSTR pwszProp, RESERVED_TYPE rt, UINT* prp);
	SCODE ScGetReservedProp (CXMLEmitter& xml,
							 CEmitterNode& en,
							 UINT irp,
							 BOOL fValues = TRUE);

	//	PROPFIND context access
	//
	SCODE ScGetAllProps (CXMLEmitter&, CEmitterNode&, BOOL fValues);
	SCODE ScGetSpecificProps (CXMLEmitter&,
							  CEmitterNode&,
							  ULONG cProps,
							  LPCWSTR* rgwszProps,
							  LONG ip_gcontenttype);

	//	PROPPATCH context access
	//
	SCODE ScSetProps (CStatusCache & csn,
					  ULONG cProps,
					  LPCWSTR* rgwszProps,
					  PROPVARIANT* rgvProps);

	SCODE ScDeleteProps (CStatusCache & csn,
						 ULONG cProps,
						 LPCWSTR* rgwszProps);
	SCODE ScPersist();

	//	Non-context access
	//
	SCODE ScSetStringProp (LPCWSTR pwszProp, LPCWSTR pwszValue)
	{
		PROPVARIANT var = {0};
		SCODE sc = S_OK;

		var.vt = VT_LPWSTR;
		var.pwszVal = const_cast<LPWSTR>(pwszValue);

		Assert (!FInvalidPbag());
		sc = m_pbag->WriteMultiple (1, &pwszProp, &var);
		if (FAILED(sc))
		{
			//	This is the common path for when we are trying to access
			//	something over an SMB, but the host cannot support the
			//	request (it is not an NT5 NTFS machine).
			//
			if ((sc == STG_E_INVALIDNAME) || !FIsVolumeNTFS())
				sc = E_DAV_SMB_PROPERTY_ERROR;
		}
		return sc;
	}
};

//	Support functions ---------------------------------------------------------
//
SCODE ScFindFileProps (IMethUtil* pmu,
		CFSFind& cfc,
		CXMLEmitter& msr,
		LPCWSTR pwszUri,
		LPCWSTR pwszPath,
		CVRoot* pcvrTranslation,
		CResourceInfo& cri,
		BOOL fEmbedErrorsInResponse);

SCODE ScFindFilePropsDeep (IMethUtil* pmu,
		CFSFind& cfc,
		CXMLEmitter& msr,
		LPCWSTR pwszUri,
		LPCWSTR pwszPath,
		CVRoot* pcvrTranslation,
		LONG lDepth);

SCODE ScSetContentProperties (IMethUtil * pmu, LPCWSTR pwszPath,
						HANDLE hFile = INVALID_HANDLE_VALUE);

SCODE ScCopyProps (IMethUtil* pmu,
				   LPCWSTR pwszSrc,
				   LPCWSTR pwszDst,
				   BOOL fCollection,
				   HANDLE hSource = INVALID_HANDLE_VALUE,
				   HANDLE hfDest = INVALID_HANDLE_VALUE);

//	ScGetPropertyBag ----------------------------------------------------------
//
//	Helper function used to get IPropertyBagEx interface
//
SCODE ScGetPropertyBag (LPCWSTR pwszPath,
						DWORD dwAccessDesired,
						IPropertyBagEx** ppbe,
						BOOL fCollection,
						HANDLE hLockFile = INVALID_HANDLE_VALUE);

inline BOOL FGetDepth (IMethUtil * pmu, LONG * plDepth)
{
	LONG lDepth = pmu->LDepth (DEPTH_INFINITY);

	//	"Depth" header, if appears, can only be '0', '1' or 'infinity',
	//	all other values are treated as error
	//
	switch (lDepth)
	{
		case DEPTH_ZERO:
		case DEPTH_ONE:
		case DEPTH_ONE_NOROOT:
		case DEPTH_INFINITY:

			*plDepth = lDepth;
			break;

		default:

			return FALSE;
	}
	return TRUE;
}

// safe_statpropbag -------------------------------------------------------------
//
#pragma pack(8)
class safe_statpropbag
{
	//	IMPORTANT:  Do not add any other members to this class
	//	other than the STATPROP that is to be protected.
	//
	STATPROPBAG sp;

	//	non-implemented
	//
	safe_statpropbag(const safe_statpropbag& b);
	safe_statpropbag& operator=(const safe_statpropbag& b);

public:

	explicit safe_statpropbag()
	{
		memset (&sp, 0, sizeof(safe_statpropbag));
	}
	~safe_statpropbag()
	{
		CoTaskMemFree (sp.lpwstrName);
	}

	//	ACCESSORS
	//
	STATPROPBAG* load() { return &sp; }
	STATPROPBAG get() { return sp; }
};
#pragma pack()

#endif	// __FSMETA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\_fsmvcpy.h ===
/*
 *	_ F S M V C P Y . H
 *
 *	Sources for directory iteration object
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef __FSMVCPY_H_
#define __FSMVCPY_H_

#include <xemit.h>

//	Metabase operations -------------------------------------------------------
//

//	class CAccessMetaOp -------------------------------------------------------
//
class CAccessMetaOp : public CMetaOp
{
	enum { DONT_INHERIT = 0 };

	DWORD		m_dwAcc;
	BOOL		m_fAccessBlocked;

	//	non-implemented
	//
	CAccessMetaOp& operator=( const CAccessMetaOp& );
	CAccessMetaOp( const CAccessMetaOp& );

protected:

	//	Subclass' operation to perform for each node where
	//	a value is explicitly set.
	//
	virtual SCODE __fastcall ScOp(LPCWSTR pwszMbPath, UINT cch);

public:

	virtual ~CAccessMetaOp() {}
	CAccessMetaOp (const LPMETHUTIL pmu, LPCWSTR pwszPath, DWORD dwAcc)
			: CMetaOp (pmu->GetEcb(), pwszPath, MD_ACCESS_PERM, DWORD_METADATA, FALSE),
			  m_dwAcc(dwAcc),
			  m_fAccessBlocked(FALSE)
	{
	}

	//	If FAccessBlocked() returns true, the operation must
	//	check the access directly on all resources that the
	//	operation wishes to process
	//
	BOOL __fastcall FAccessBlocked() const { return m_fAccessBlocked; }
};

//	class CAuthMetaOp -------------------------------------------------------
//
class CAuthMetaOp : public CMetaOp
{
	enum { DONT_INHERIT = 0 };

	DWORD		m_dwAuth;
	BOOL		m_fAccessBlocked;

	//	non-implemented
	//
	CAuthMetaOp& operator=( const CAuthMetaOp& );
	CAuthMetaOp( const CAuthMetaOp& );

protected:

	//	Subclass' operation to perform for each node where
	//	a value is explicitly set.
	//
	virtual SCODE __fastcall ScOp(LPCWSTR pwszMbPath, UINT cch);

public:

	virtual ~CAuthMetaOp() {}
	CAuthMetaOp (const LPMETHUTIL pmu, LPCWSTR pwszPath, DWORD dwAuth)
			: CMetaOp (pmu->GetEcb(), pwszPath, MD_AUTHORIZATION, DWORD_METADATA, FALSE),
			  m_dwAuth(dwAuth),
			  m_fAccessBlocked(FALSE)
	{
	}

	//	If FAccessBlocked() returns true, the operation must
	//	check the access directly on all resources that the
	//	operation wishes to process
	//
	BOOL __fastcall FAccessBlocked() const { return m_fAccessBlocked; }
};

//	class CIPRestrictionMetaOp ------------------------------------------------
//
class CIPRestrictionMetaOp : public CMetaOp
{
	enum { DONT_INHERIT = 0 };

	BOOL					m_fAccessBlocked;

	//	non-implemented
	//
	CIPRestrictionMetaOp& operator=( const CIPRestrictionMetaOp& );
	CIPRestrictionMetaOp( const CIPRestrictionMetaOp& );

protected:

	//	Subclass' operation to perform for each node where
	//	a value is explicitly set.
	//
	virtual SCODE __fastcall ScOp(LPCWSTR pwszMbPath, UINT cch);

public:

	virtual ~CIPRestrictionMetaOp() {}
	CIPRestrictionMetaOp (const LPMETHUTIL pmu, LPCWSTR pwszPath)
			: CMetaOp (pmu->GetEcb(), pwszPath, MD_IP_SEC, BINARY_METADATA, FALSE),
			  m_fAccessBlocked(FALSE)
	{
	}

	//	If FAccessBlocked() returns true, the operation must
	//	check the access directly on all resources that the
	//	operation wishes to process
	//
	BOOL __fastcall FAccessBlocked() const { return m_fAccessBlocked; }
};

//	class CContentTypeMetaOp --------------------------------------------------
//
class CContentTypeMetaOp : public CMetaOp
{
	enum { DONT_INHERIT = 0 };

	LPCWSTR		m_pwszDestPath;
	BOOL		m_fDelete;

	//	non-implemented
	//
	CContentTypeMetaOp& operator=( const CContentTypeMetaOp& );
	CContentTypeMetaOp( const CContentTypeMetaOp& );

protected:

	//	Subclass' operation to perform for each node where
	//	a value is explicitly set.
	//
	virtual SCODE __fastcall ScOp(LPCWSTR pwszMbPath, UINT cch);

public:

	virtual ~CContentTypeMetaOp() {}
	CContentTypeMetaOp (const LPMETHUTIL pmu, LPCWSTR pwszSrcPath, LPCWSTR pwszDestPath, BOOL fDelete)
			: CMetaOp (pmu->GetEcb(), pwszSrcPath, MD_MIME_MAP, MULTISZ_METADATA, fDelete),
			  m_pwszDestPath(pwszDestPath),
			  m_fDelete(fDelete)
	{
	}
};

//	Helper functions
//
//	XML Error construction helpers ------------------------------------------------
//
SCODE ScAddMulti (
	/* [in] */ CXMLEmitter& emitter,
	/* [in] */ IMethUtil * pmu,
	/* [in] */ LPCWSTR pwszPath,
	/* [in] */ LPCWSTR pwszErr,
	/* [in] */ ULONG hsc,
	/* [in] */ BOOL fCollection = FALSE,
	/* [in] */ CVRoot* pcvrTrans = NULL);

//	Access --------------------------------------------------------------------
//
SCODE __fastcall
ScCheckMoveCopyDeleteAccess (
	/* [in] */ IMethUtil* pmu,
	/* [in] */ LPCWSTR pwszUrl,
	/* [in] */ CVRoot* pcvr,
	/* [in] */ BOOL fDirectory,
	/* [in] */ BOOL fCheckScriptmaps,
	/* [in] */ DWORD dwAccess,
	/* [out] */ SCODE* pscItem,
	/* [in] */ CXMLEmitter& msr);

//	Delete --------------------------------------------------------------------
//
SCODE
ScDeleteDirectoryAndChildren (
	/* [in] */ IMethUtil* pmu,
	/* [in] */ LPCWSTR pwszUrl,
	/* [in] */ LPCWSTR pwszPath,
	/* [in] */ BOOL fCheckAccess,
	/* [in] */ DWORD dwAcc,
	/* [in] */ LONG lDepth,
	/* [in] */ CXMLEmitter& msr,
	/* [in] */ CVRoot* pcvrTranslate,
	/* [out] */ BOOL* pfDeleted,
	/* [in] */ CParseLockTokenHeader* plth,	// Usually NULL -- no locktokens to worry about
	/* [in] */ BOOL fDeleteLocks);			// Normally FALSE -- don't drop locks

//	MoveCopy ------------------------------------------------------------------
//
void MoveCopyResource (
	/* [in] */ IMethUtil* pmu,
	/* [in] */ DWORD dwAccRequired,
	/* [in] */ BOOL fDeleteSrc);

#endif	// __FSMVCPY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\_fssrch.h ===
/*
 *	_ F S S R C H . H
 *
 *	File system search routines
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef __FSSRCH_H_
#define __FSSRCH_H_

#include <xsearch.h>

//$REVIEW: 4510 -- Should we work this one out of the code?
#pragma warning(disable:4510)	// default constructor could not be generated
#pragma warning(disable:4610)	// class can never be instantiated - user defined constructor required

typedef std::list<CRCWszi, heap_allocator<CRCWszi> > CWsziList;

#include <oledb.h>

//	CSearchRowsetContext ------------------------------------------------------
//
class CSearchRowsetContext : public CSearchContext
{
	//	non-implemented operators
	//
	CSearchRowsetContext( const CSearchRowsetContext& );
	CSearchRowsetContext& operator=( const CSearchRowsetContext& );

protected:

	auto_com_ptr<IRowset>		m_prs;			//	Rowset

	auto_heap_ptr<DBBINDING>	m_rgBindings;	//	array of column bindings
	auto_com_ptr<IAccessor>		m_pAcc;			//	IAccessor
	auto_heap_ptr<BYTE>			m_pData;		//	data buffer
	DBCOUNTITEM					m_cHRow;		//	length of array of HROWS
	HROW *						m_rgHRow;		//	array of HROWs
	HACCESSOR					m_hAcc;			//	array of accessors
	ULONG						m_ulRowCur;		//	current row
	ULONG						m_cRowsEmitted; //	Number of rows emitted

	//	Rowset specific methods
	//
	VOID CleanUp();

public:

	virtual ~CSearchRowsetContext() {}
	CSearchRowsetContext ()
			: m_cHRow(0),
			  m_rgHRow(NULL),
			  m_hAcc(NULL),
			  m_ulRowCur(0),
			  m_cRowsEmitted(0)
	{
	}

	//	When the parser finds an item that applies to the search, a call is
	//	made such that the context is informed of the desired search.
	//
	virtual SCODE ScSetSQL(CParseNmspcCache * pnsc, LPCWSTR pwszSQL) = 0;

	//	Search processing
	//
	virtual SCODE ScMakeQuery() = 0;
	virtual SCODE ScEmitResults (CXMLEmitter& emitter);

	//	Impl. specific rowset methods
	//
	virtual SCODE ScCreateAccessor () = 0;
	virtual SCODE ScEmitRow (CXMLEmitter& emitter) = 0;

	//	OLE DB Error code translations
	//
	static ULONG HscFromDBStatus (ULONG ulStatus);
};

//	Search XMLDocument --------------------------------------------------------
//
class CFSSearch : public CSearchRowsetContext
{
	IMethUtil *					m_pmu;

	//	Receives the string buffer returned from
	//	GetColumnInfo. it is allocated by OLE DB
	//	provider and should be freed with
	//	CoTaskMemFree
	//
	LPWSTR						m_pwszBuf;
	DBCOLUMNINFO *				m_rgInfo;

	//	Used for SQL
	//
	StringBuffer<WCHAR>			m_sbSQL;
	auto_com_ptr<ICommandText>	m_pCommandText;

	//	Find context
	//
	CFSFind						m_cfc;

	//	Used for child-vroot processing
	//
	ChainedStringBuffer<WCHAR>	m_csb;
	CVRList						m_vrl;

	//	non-implemented operators
	//
	CFSSearch( const CFSSearch& );
	CFSSearch& operator=( const CFSSearch& );

	LPCWSTR PwszSQL() const { return m_sbSQL.PContents(); }

public:

	CFSSearch(IMethUtil * pmu)
		: m_pmu(pmu),
		  m_rgInfo(NULL),
		  m_pwszBuf(NULL)
	{
	}

	~CFSSearch()
	{
		//	free information returned from IColumnInfo
		//
		CoTaskMemFree (m_rgInfo);
		CoTaskMemFree (m_pwszBuf);
	}

	//	Impl. methods
	//
	virtual SCODE ScMakeQuery();
	virtual SCODE ScSetSQL(CParseNmspcCache * pnsc, LPCWSTR pwszSQL);
	virtual SCODE ScEmitRow (CXMLEmitter& emitter);
	virtual SCODE ScCreateAccessor();

	IPreloadNamespaces * PPreloadNamespaces () { return &m_cfc; }
};

#endif // __FSSRCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\_fsutil.h ===
/*
 *	_ F S U T I L . H
 *
 *	File system routines
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef __FSUTIL_H_
#define __FSUTIL_H_

enum { CCH_PATH_PREFIX = 4 };

//	Public function to clear out the cached security-enabled thread token
//	used in ScChildISAPIAccessCheck.
//	Should be called in our ISAPI terminate proc.
//
void CleanupSecurityToken();

#endif	// __FSUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\_fsri.h ===
/*
 *	_ F S R I . H
 *
 *	Resource information helper class
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	__FSRI_H_
#define __FSRI_H_

/*
 *	CResourceInfo -------------------------------------------------------------
 *
 *	The CResourceInfo object is intended to function as an abstraction
 *	to the file information available to the impl.  Namely, it should
 *	be used in such a way that file information calls to the Win32 kernel
 *	are kept to a minimum -- the ideal is once and only once.
 *
 *	The other issue is the efficiency of how this information is obtained.
 *	So if I need to know the attributes of a file, then I do not want to
 *	have to make a call to FindFirstFile()/CloseFind() just to get the
 *	attributes.  This is a tremendously expensive method for doing so.
 *	However, there are times that information beyond the information
 *	returned by GetFileAttributesEx() is desired, and in those instances,
 *	a more expensive mechanism should be employed to get that data.
 *
 *	Regardless of how the data was obtained, the caller wants unified
 *	access to the information.  This helper class provides that.
 *
 *	The object itself knows how the file information held there was
 *	obtained.  So to access the file information, the caller calls the
 *	accessor to obtain the values.  The accessors switch off of the mode
 *	indicator that describes how the information was filled in.
 *
 */
class CResourceInfo
{
	enum { NODATA, BY_ATTRIBUTE, BY_FIND };

	UINT m_lmode;
	union {

		WIN32_FILE_ATTRIBUTE_DATA ad;
		WIN32_FIND_DATAW fd;

	} m_u;

public:

	CResourceInfo()
		: m_lmode(NODATA)
	{
		memset(&m_u, 0, sizeof(m_u));
	}

	//	Resource information initialization
	//
	SCODE ScGetResourceInfo (LPCWSTR pwszFile);

	BOOL FLoaded() { return m_lmode != NODATA; }

	//	Data access
	//
	DWORD DwAttributes() const
	{
		Assert (m_lmode != NODATA);
		return (m_lmode == BY_ATTRIBUTE)
				? m_u.ad.dwFileAttributes
				: m_u.fd.dwFileAttributes;
	}
	BOOL FCollection() const
	{
		return !!(DwAttributes() & FILE_ATTRIBUTE_DIRECTORY);
	}
	BOOL FHidden() const
	{
		return !!(DwAttributes() & FILE_ATTRIBUTE_HIDDEN);
	}
	BOOL FRemote() const
	{
		return !!(DwAttributes() & FILE_ATTRIBUTE_OFFLINE);
	}
	FILETIME * PftCreation()
	{
		Assert (m_lmode != NODATA);
		return (m_lmode == BY_ATTRIBUTE)
				? &m_u.ad.ftCreationTime
				: &m_u.fd.ftCreationTime;
	}
	FILETIME * PftLastModified()
	{
		Assert (m_lmode != NODATA);
		return (m_lmode == BY_ATTRIBUTE)
				? &m_u.ad.ftLastWriteTime
				: &m_u.fd.ftLastWriteTime;
	}
	void FileSize (LARGE_INTEGER& li)
	{
		Assert (m_lmode != NODATA);
		if (m_lmode == BY_ATTRIBUTE)
		{
			li.LowPart = m_u.ad.nFileSizeLow;
			li.HighPart = m_u.ad.nFileSizeHigh;
		}
		else
		{
			li.LowPart = m_u.fd.nFileSizeLow;
			li.HighPart = m_u.fd.nFileSizeHigh;
		}
	}
	WIN32_FIND_DATAW * PfdLoad()
	{
		m_lmode = BY_FIND;
		return &m_u.fd;
	}
	WIN32_FIND_DATAW& Fd()
	{
		Assert (m_lmode == BY_FIND);
		return m_u.fd;
	}
	BOOL FFindData() const { return (m_lmode == BY_FIND); }
	void Reset() { m_lmode = NODATA; }
};

/*	Resource locations --------------------------------------------------------
 *
 *	DAVFS allows for the client to be somewhat lax in its url's when
 *	specifying a resource.  Namely, if the caller specifies a resource
 *	that is a collection, and the url does not end in a trailing slash,
 *	in most cases we will simply go ahead and succeed the call while
 *	making sure that we return the properly qualified url in the location
 *	header.  The FTrailingSlash() and the ScCheckForLocationCorrectness()
 *	methods provide for this lax checking.
 *
 *	FTrailingSlash() simply returns TRUE if (and only if) the url ends in
 *	a trailing slash.
 *
 *	ScCheckForLocationCorrectness() will check the url against the
 *	resource and either add the appropriate location header, or it will
 *	request a redirect if the url and the resource do not agree.  The
 *	caller has the control over whether or not a true redirect is desired.
 *	As an informational return, if a location header has been added S_FALSE
 *	will be returned to the caller.
 */
enum { NO_REDIRECT = FALSE, REDIRECT = TRUE };

inline BOOL FTrailingSlash (LPCWSTR pwsz)
{
	Assert (pwsz);
	UINT cch = static_cast<UINT>(wcslen (pwsz));
	return ((0 != cch) && (L'/' == pwsz[cch - 1]));
}

SCODE ScCheckForLocationCorrectness (IMethUtil*,
									 CResourceInfo&,
									 UINT mode = NO_REDIRECT);

/*
 *	If-xxx header helper functions --------------------------------------------
 *
 *	The current ScCheckIfHeaders() implementation in the common code
 *	takes the last modified time of the resource as the second parameter.
 *	This version helper function takes the actual path to the resource.
 *	It is implemented by getting the resource information for the file
 *	and then calling the common implementation of ScCheckIfHeaders().
 */
SCODE ScCheckIfHeaders (IMethUtil* pmu, LPCWSTR pwszPath, BOOL fGetMethod);

#endif	// __FSRI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\_sof.h ===
/*
 *	_ S O F . H
 *
 *	Stream on file implementation class
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	__SOF_H_
#define __SOF_H_

#include <nonimpl.h>

//	StmOnFile -----------------------------------------------------------------
//
class StmOnFile : public CStreamNonImpl
{
private:

	HANDLE	m_hf;

public:

	StmOnFile(HANDLE hf) : m_hf(hf) {}
	~StmOnFile() {}

	virtual /* [local] */ HRESULT STDMETHODCALLTYPE Read(
		/* [length_is][size_is][out] */ void __RPC_FAR *,
		/* [in] */ ULONG,
		/* [out] */ ULONG __RPC_FAR *);

	virtual /* [local] */ HRESULT STDMETHODCALLTYPE Write(
		/* [size_is][in] */ const void __RPC_FAR * pb,
		/* [in] */ ULONG cb,
		/* [out] */ ULONG __RPC_FAR * pcb);

	virtual HRESULT STDMETHODCALLTYPE Commit(
		/* [in] */ DWORD)
	{
		//	Flush the file to disk
		//
		if (!FlushFileBuffers (m_hf))
			return HRESULT_FROM_WIN32(GetLastError());

		return S_OK;
	}
};

#endif // __SOF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\_shlkmgr.h ===
#ifndef _SHLKMGR_H_
#define _SHLKMGR_H_


//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	SHLKMGR.H
//
//		Declaration of the CSharedLockMgr class which inherits from ILockCache
//      and is used in place of CLockCache for httpext.  It wraps the shared
//      memory lock cache, needed to support recycling and multiple processes
//      handling dav requests.
//
//	Copyright 2000 Microsoft Corporation, All Rights Reserved
//
 
#include <smh.h>
#include <shlkcache.h>
#include <singlton.h>
#include "_fslock.h"

/**********************************
* Class CSharedLockMgr
*
***********************************/
class CSharedLockMgr : private Singleton<CSharedLockMgr>
{
	//	Friend declarations required by Singleton template
	//
	friend class Singleton<CSharedLockMgr>;

    // Since this is a singleton object we do not want anyone
    // being able to create or destruct this object without
    // going through the CreateInstance or DestroyInstance calls.
	//
    CSharedLockMgr();
    ~CSharedLockMgr();
    
    // Shared Ptrs to the cache representing the key cache and the
    // cache representing the name cache for this lock object.
	//
    SharedPtr<CInShLockCache> m_spSharedCache;
    SharedPtr<CInShCacheStatic> m_spSharedStatic;

    // Handle to DAVProc process, used for duplicating handles
    // so that we can use file handles held by DAVProc.
	//
	HANDLE m_hDavProc;

    // Flag lets us know that the shared memory has been initalized
    // if it has not than we will try to initalize it again.
	//
    BOOL m_fSharedMemoryInitalized;

	//	Critical section to serialize the initialization
	//
	CCriticalSection m_cs;

    // Uses the m_fSharedMemoryInitalized flag to determine if 
    // we need to initalize the shared memory and if we do it does 
    // the work to set everything up.
	//
    BOOL SharedMemoryInitalized();

    // Generate a new lock token ID.  This is done here because
    // we need to use the static shared memory data to make sure
    // that the ids are unique across process.
	//
    HRESULT GetNewLockTokenId(__int64* pi64LockID);

    // Used to get the DAVProcessID that is needed for opening the
    // the handle to the dav process that we need for duplicating handles.
	//
    DWORD GetDAVProcessId()
    { return (m_spSharedStatic->GetDAVProcessId()); }


	//  NOT IMPLEMENTED
	//
	CSharedLockMgr& operator=( const CSharedLockMgr& );
	CSharedLockMgr( const CSharedLockMgr& );

public:
	
	enum
	{	// 3 minutes (in seconds) (until I get this debugged!)
		//
		DWSEC_TIMEOUT_DEFAULT = 60 * 3
	};
	
	//	Instance creating/destroying routines provided
	//	by the Singleton template.
	//=================================
	using Singleton<CSharedLockMgr>::CreateInstance;
	using Singleton<CSharedLockMgr>::DestroyInstance;
	using Singleton<CSharedLockMgr>::Instance;

    BOOL FLock (CLockFS& lock, DWORD  dwsecTimeout = DWSEC_TIMEOUT_DEFAULT);
  	HRESULT HrGetLock( LPMETHUTIL pmu, __int64 i64LockId, CLockFS * * pplock );
	BOOL FGetLockNoAuth( __int64 i64LockId, CLockFS * * pplock );  
    VOID DeleteLock(__int64 i64LockId);
    LPCWSTR WszGetGuid();
	BOOL FGetLockOnError( IMethUtil * pmu,
						  LPCWSTR wszResource,
						  DWORD dwLockType,
						  BOOL	fEmitXML = FALSE,
						  CXMLEmitter * pemitter = NULL,
						  CXNode * pxnParent = NULL);

    // CLockCache has an implementation only for Debug mode for this.
    // I am not copying that implemenation for CSharedLockMgr.
	//virtual DWORD GetDefaultTimeoutSeconds();

    // CSharedLockMgr specific classes
    //=================================
    // Used to generate a new shared data lock token with 
    // the appropriate information stored it.  Has to be 
    // generated from here because of the need to get to the
    // new lock token ID, and to access the lock token guid.
    HRESULT GetNewLockData(LPCWSTR wszResource
                        , HANDLE hfile
                        , DWORD dwAccess
                        , DWORD dwLockType
                        , DWORD dwLockScope
                        , DWORD dwTimeout
                        , LPCWSTR wszOwnerComment
                        , HANDLE hit
                        , CLockFS& lock);

    // Used instead of GetHandle because it has the side
    // affect of duplicating the handle and the handle must
    // be closed afterwards.  Functions using this implementation
    // of ILockCache should not call GetHandle, but instead just call
    // this function.
	HRESULT GetDAVProcessHandle(HANDLE* phDavProc);
    
};


#endif  // end _SHLKMGR_H_ define
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\align.h ===
/*
 *	A L I G N . H
 *
 *	Alignment macros
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_ALIGN_H_
#define _ALIGN_H_

//	Alignments ----------------------------------------------------------------
//
#undef	AlignN
#undef	Align2
#undef	Align4
#undef	Align8
#undef	AlignNatural
#undef	FIsAlignedCb
#undef	FIsAligned

enum {

	ALIGN_NONE = 0,
	ALIGN_WORD,
	ALIGN_INTEL,
	ALIGN_RISC,
	ALIGN_16BYTE,
	ALIGN_128BYTE = 7,
	ALIGN_4K = 12,
#if defined (_AMD64_) || defined (_IA64_)
	ALIGN_NATURAL = ALIGN_RISC
#elif defined (WIN32)
	ALIGN_NATURAL = ALIGN_INTEL
#endif
};

#define AlignN(x,n)			(((x)+(1<<(n))-1) & ~((1<<(n))-1))
#define PadN(x,n)			(AlignN(x,n) - (x))

#define Align2(x)			AlignN((x),ALIGN_WORD)
#define Align4(x)			AlignN((x),ALIGN_INTEL)
#define Align8(x)			AlignN((x),ALIGN_RISC)
#define Align16(x)			AlignN((x),ALIGN_16BYTE)
#define Align128(x)			AlignN((x),ALIGN_128BYTE)
#define Align4K(x)			AlignN((x),ALIGN_4K)
#define AlignNatural(x)		AlignN((x),ALIGN_NATURAL)

#define Pad2(x)				PadN((x),ALIGN_WORD)
#define Pad4(x)				PadN((x),ALIGN_INTEL)
#define Pad8(x)				PadN((x),ALIGN_RISC)
#define Pad16(x)			PadN((x),ALIGN_16BYTE)
#define Pad4K(x)			PadN((x),ALIGN_4K)

#define FIsAlignedCb(x)		(AlignNatural((ULONG_PTR)(x)) == (ULONG_PTR)(x))
#define FIsAligned(x)		(FIsAlignedCb((LPVOID)(x)))

#endif	// _ALIGN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\httpext\_voltype.h ===
#ifndef _VOLTYPE_H_
#define _VOLTYPE_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	_VOLTYPE.H
//
//		Volume type checking interface.  Results are cached on a per volume
//		basis to improve performance -- the call to GetVolumeInformationW()
//		is around 100KCycles and never changes for a given volume without a
//		reboot.
//
enum VOLTYPE
{
	VOLTYPE_UNKNOWN,
	VOLTYPE_NTFS,
	VOLTYPE_NOT_NTFS
};

//	Function to return tye volume type (from the enumeration above) of the
//	specified path.
//
VOLTYPE VolumeType(LPCWSTR pwszPath, HANDLE htokUser);

//	Init/Deinit of the volume type cache.  It is ok to call
//	DeinitVolumeTypeCache() if the call to FInitVolumeTypeCache()
//	failed (returned FALSE) or even if it was never called at all.
//
BOOL FInitVolumeTypeCache();
VOID DeinitVolumeTypeCache();

#endif // !defined(_VOLTYPE_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\buffer.h ===
/*
 *	B U F F E R . H
 *
 *	Data buffer processing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_BUFFER_H_
#define _BUFFER_H_

#ifdef _EXDAV_
#error "buffer.h uses throwing allocators"
#endif

//	Include the non-safe/throwing allocators
#include <mem.h>

//	Include safe buffer definition header
//
#include <ex\buffer.h>

//	AppendChainedSz -----------------------------------------------------------
//
inline LPCWSTR AppendChainedSz (ChainedStringBuffer<WCHAR>& sb, LPCWSTR pwsz)
{
	return sb.AppendWithNull (pwsz);
}

#endif // _BUFFER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\calpc.h ===
/*
 *	C A L P C . H
 *
 *	PerfCounter data headers
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef _CALPC_H_
#define _CALPC_H_

#include <winperf.h>

//	Extensible Object definitions ---------------------------------------------
//
//	Update the following sort of define when adding an object type.
//
#define NUM_PERF_OBJECT_TYPES 1
typedef enum {

	PC_TOTALREQUESTS = 0,
	PC_NUMCURRENTREQUESTS,
	PC_NUMWORKERTHREADS,
	PC_NUMACTIVEWORKERTHREADS,
	PC_CURRENTLOCKS,
	PC_REQ_FORWARDS,
	PC_REQ_REDIRECTS,
	PC_EXCEPTIONS,
	CPC_COUNTERS

} PERFCOUNTER;

typedef enum {

	PCI_PERFMON = -1,
	PCI_TOTALS = 0,
	PCI_DAVFS,
	PCI_DAVOWS,
	PCI_DAVEX,
	CPC_INSTANCES

} PERFCOUNTERINSTANCE;

enum { CCH_MAX_INSTANCE_NAME = (sizeof(L"PERFMON") * sizeof(WCHAR)) };

//	Resource object type counter definitions.
//
//	This is the counter structure presently returned by the performance DLL.
//
#pragma pack(4)
typedef struct _PERFDLL_DATA_DEFINITION
{
	PERF_OBJECT_TYPE		potObjectType;
	PERF_COUNTER_DEFINITION	rgpcdCounters[CPC_COUNTERS];

} PERFDLL_DATA_DEFINITION;
#pragma pack()

//	This is the block of data that corresponds to each instance of
//	the object. This structure will immediately follow the instance
//	definition data structure.
//
#pragma pack(4)
typedef struct _PERFDLL_COUNTER_BLOCK
{
	PERF_COUNTER_BLOCK	pcbCounterBlock;
	LONG				rgdwCounters[CPC_COUNTERS];
	LONG				lActive;

} PERFDLL_COUNTER_BLOCK, * PPERFDLL_COUNTER_BLOCK;
#pragma pack()

enum { CB_PERF_COUNTER_MEMORY = (sizeof(PERFDLL_COUNTER_BLOCK) * CPC_INSTANCES) };

#ifdef __cplusplus
extern "C" {
#endif

SCODE __cdecl ScOpenPerfCounters (PERFCOUNTERINSTANCE ipc);
VOID __cdecl ClosePerfCounters (VOID);

extern PERFDLL_DATA_DEFINITION g_PerfDllDataDefinition;
extern PPERFDLL_COUNTER_BLOCK g_pcntrblk;
extern LPVOID g_pvcntrblk;

#ifdef __cplusplus
}
#endif

#define PERFDLL_COUNTER_BLOCK_NAME		L"CALIGULA_PERFORMANCE_DATA"
#define PERFDLL_COUNTER_MUTEX_NAME		L"CALIGULA_PERFORMANCE_DATA_MUTEX"

__inline void IncrementPerfCounter(PERFCOUNTER _x)
{
	InterlockedIncrement(&g_pcntrblk->rgdwCounters[_x]);
}
__inline void DecrementPerfCounter(PERFCOUNTER _x)
{
	InterlockedDecrement(&g_pcntrblk->rgdwCounters[_x]);
}
__inline void ResetPerfCounter(PERFCOUNTER _x)
{
	InterlockedExchange(&g_pcntrblk->rgdwCounters[_x], 0);
}

#endif	//	_CALPC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\caldbg.h ===
/*
 *	C A L D B G . H
 *
 *	Debugging support header
 *	Support functions are implemented in CALDBG.C.
 *
 *	Copyright 1986-1997 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _CALDBG_H_
#define _CALDBG_H_

#include <malloc.h>

/*
 * Debugging Macros -------------------------------------------------------
 *
 *		IFDBG(x)		Results in the expression x if DBG is defined, or
 *						to nothing if DBG is not defined
 *
 *		IFNDBG(x)		Results in the expression x if DBG is not defined,
 *						or to nothing if DBG is defined
 *
 *		Unreferenced(a) Causes a to be referenced so that the compiler
 *						doesn't issue warnings about unused local variables
 *						which exist but are reserved for future use (eg
 *						ulFlags in many cases)
 */
#if defined(DBG)
#define IFDBG(x)			x
#define IFNDBG(x)
#else
#define IFDBG(x)
#define IFNDBG(x)			x
#endif

#ifdef __cplusplus
#define EXTERN_C_BEGIN		extern "C" {
#define EXTERN_C_END		}
#else
#define EXTERN_C_BEGIN
#define EXTERN_C_END
#endif

/*
 *	 Assert Macros ------------------------------------------------------------
 *
 *		Assert(a)		Displays a message indicating the file and line number
 *						of this Assert() if a == 0.	 OK'ing an assert traps
 *						into the debugger.
 *
 *		AssertSz(a,sz)	Works like an Assert(), but displays the string sz
 *						along with the file and line number.
 *
 *		Side asserts	A side assert works like an Assert(), but evaluates
 *						'a' even when asserts are not enabled.
 */
#if defined(DBG) || defined(ASSERTS_ENABLED)
#define IFTRAP(x)			x
#else
#define IFTRAP(x)			0
#endif

#define Trap()						IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,"Trap"))
#define TrapSz(psz)					IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz))

#define Assert(t)					IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,"Assertion Failure: " #t),0))
#define AssertSz(t,psz)				IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz),0))

#define SideAssert(t)				((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,"Assertion Failure: " #t)),0)
#define SideAssertSz(t,psz)			((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz)),0)

#define ForcePopupAsserts()			IFTRAP(EnablePopupAsserts())

/*
 *	 Trace Macros -------------------------------------------------------------
 *
 *		DebugTrace			Use for arbitrary formatted output. It
 *							takes exactly the same arguments as the
 *							Windows wsprintf() function.
 *		DebugTraceNoCRLF	Same as DebugTrace, but doesn't add "\r\n".
 *							Good for writing a trace that is part of a longer line.
 *		TraceError			DebugTrace the function name (_func, any string)
 *							INI file entries allow you to filter based on the
 *							error code's failing/succeeding status.
 */

#if defined(DBG) || defined(TRACES_ENABLED)
#define IFTRACE(x)			x
#define DebugTrace			DebugTraceFn
#define DebugTraceCRLF		DebugTraceCRLFFn
#define DebugTraceNoCRLF	DebugTraceNoCRLFFn
#define TraceErrorEx(_err,_func,_flag)	TraceErrorFn(_err,_func,__FILE__,__LINE__,_flag)
#define TraceError(_err,_func)			TraceErrorEx(_err,_func,FALSE)
#else
#define IFTRACE(x)			0
#define DebugTrace			NOP_FUNCTION
#define DebugTraceCRLF		NOP_FUNCTION
#define DebugTraceNoCRLF	NOP_FUNCTION
#define TraceErrorEx(_err,_func,_flag)	NOP_FUNCTION
#define TraceError(_err,_func)			TraceErrorEx(_err,_func,FALSE)
#endif

/*	------------------------------------------------------------------------
 *
 *	.INI triggered traces
 */

#ifdef DBG
#define DEFINE_TRACE(trace)		__declspec(selectany) int g_fTrace##trace = FALSE
#define DO_TRACE(trace)			!g_fTrace##trace ? 0 : DebugTraceFn
#define INIT_TRACE(trace)		g_fTrace##trace = GetPrivateProfileInt( gc_szDbgTraces, #trace, FALSE, gc_szDbgIni )
//	Convenience macro for DBG code.  Will cause an error on non-debug builds.
#define DEBUG_TRACE_TEST(trace)	g_fTrace##trace
#else
#define DEFINE_TRACE(trace)
#define DO_TRACE(trace)			DebugTrace
#define INIT_TRACE(trace)
//#define DEBUG_TRACETEST(trace)	// Purposefully cause an error on non-debug builds
#endif

/* Debugging Functions ---------------------------------------------------- */

#define EXPORTDBG

EXTERN_C_BEGIN

VOID EXPORTDBG __cdecl EnablePopupAsserts (void);
INT EXPORTDBG __cdecl DebugTrapFn (int fFatal, char *pszFile, int iLine, char *pszFormat, ...);
INT EXPORTDBG __cdecl DebugTraceFn (char *pszFormat, ...);
INT EXPORTDBG __cdecl DebugTraceCRLFFn (char *pszFormat, ...);
INT EXPORTDBG __cdecl DebugTraceNoCRLFFn (char *pszFormat, ...);
VOID EXPORTDBG __cdecl GetCallStack (DWORD *pdwCaller, int cSkip, int cFind);
BOOL EXPORTDBG __cdecl GetSymbolName (DWORD dwAddr, LPSTR szMod, LPSTR szFn, DWORD * pdwDisp);
INT EXPORTDBG __cdecl TraceErrorFn (DWORD error, char *pszFunction,
									char *pszFile, int iLine,
									BOOL fEcTypeError);

EXTERN_C_END





//	Symbolic names ------------------------------------------------------------
//
#include <imagehlp.h>
enum { CB_SYM_MAX = 256 };
enum { CB_MOD_MAX = 64 };
enum { NCALLERS	= 10 };

EXTERN_C_BEGIN

typedef BOOL (__stdcall SYMINITIALIZE) (HANDLE hProc, LPSTR lpszSynPath, BOOL fInvadeProc);
typedef BOOL (__stdcall SYMGETMODULE) (HANDLE hProc, DWORD dwAddr, PIMAGEHLP_MODULE pmod);
typedef BOOL (__stdcall SYMGETSYMBOL) (HANDLE hProc, DWORD dwAddr, PDWORD pdwDisp, PIMAGEHLP_SYMBOL psym);
typedef BOOL (__stdcall SYMUNDECORATE) (PIMAGEHLP_SYMBOL psym, LPSTR lpszUnDecName, DWORD cbBuf);

EXTERN_C_END

/* Debugging Strings ------------------------------------------------------ */

EXTERN_C_BEGIN

//	Inifile name -- must be set by calling code!
extern const CHAR gc_szDbgIni[];

//	Strings set in caldbg.c for use in calling code.
extern const CHAR gc_szDbgAssertLeaks[];
extern const CHAR gc_szDbgAssertCloses[];
extern const CHAR gc_szDbgDebugTrace[];
extern const CHAR gc_szDbgEventLog[];
extern const CHAR gc_szDbgGeneral[];
extern const CHAR gc_szDbgLeakLogging[];
extern const CHAR gc_szDbgLogFile[];
extern const CHAR gc_szDbgRecordResources[];
extern const CHAR gc_szDbgSymbolicDumps[];
extern const CHAR gc_szDbgTraces[];
extern const CHAR gc_szDbgUseVirtual[];
extern const CHAR gc_szDbgUseExchmem[];

EXTERN_C_END

/* Virtual Allocations ---------------------------------------------------- */

EXTERN_C_BEGIN

VOID * EXPORTDBG __cdecl VMAlloc(ULONG);
VOID * EXPORTDBG __cdecl VMAllocEx(ULONG, ULONG);
VOID * EXPORTDBG __cdecl VMRealloc(VOID *, ULONG);
VOID * EXPORTDBG __cdecl VMReallocEx(VOID *, ULONG, ULONG);
ULONG EXPORTDBG __cdecl VMGetSize(VOID *);
ULONG EXPORTDBG __cdecl VMGetSizeEx(VOID *, ULONG);
VOID EXPORTDBG __cdecl VMFree(VOID *);
VOID EXPORTDBG __cdecl VMFreeEx(VOID *, ULONG);

EXTERN_C_END

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\autoptr.h ===
/*
 *	A U T O P T R . H
 *
 *	Implementation of the Standard Template Library (STL) auto_ptr template.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef _AUTOPTR_H_
#define _AUTOPTR_H_

#include <ex\autoptr.h>

//	========================================================================
//
//	TEMPLATE CLASS auto_ptr_obsolete
//
//		auto_ptr for objects in _davprs
//
template<class X>
class auto_ptr_obsolete
{
	mutable X *		owner;
	X *				px;

public:
	explicit auto_ptr_obsolete(X* p=0) : owner(p), px(p) {}
	auto_ptr_obsolete(const auto_ptr_obsolete<X>& r)
			: owner(r.owner), px(r.relinquish()) {}

	auto_ptr_obsolete& operator=(const auto_ptr_obsolete<X>& r)
	{
		if ((void*)&r != (void*)this)
		{
			delete owner;
			owner = r.owner;
			px = r.relinquish();
		}

		return *this;
	}
	//	NOTE: This equals operator is meant to be used to load a
	//	new pointer (not yet held in any auto-ptr anywhere) into this object.
	auto_ptr_obsolete& operator=(X* p)
	{
		Assert(!owner);		//	Scream on overwrite of good data.
		owner = p;
		px = p;
		return *this;
	}

	~auto_ptr_obsolete()  { delete owner; }
	bool operator!()const { return (px == NULL); }
	operator X*()	const { return px; }
	X& operator*()  const { return *px; }
	X* operator->() const { return px; }
	X* get()		const { return px; }
	X* relinquish() const { owner = 0; return px; }

	void clear()
	{
		if (owner)
			delete owner;
		owner = 0;
		px = 0;
	}
};


//	========================================================================
//
//	TEMPLATE CLASS auto_com_ptr
//
//		auto_ptr for COM (IUnknown-derived) objects.
//
//		Yes, this is functionally a subset of CComPtr in the ATL,
//		but we don't want to pull in the whole friggin' ATL for one
//		measly template.
//
template<class X>
class auto_com_ptr
{
	X *		px;

	//	NOT IMPLEMENTED
	//
	void * operator new(size_t cb);

public:
	//	CONSTRUCTORS
	//
	explicit auto_com_ptr(X* p=0) : px(p) {}

	//	Copy constructor -- provided only for returning objects.
	//	Should ALWAYS be optimized OUT.  Scream if we actually execute this code!
	//$REVIEW:  Should we really be returning objects like this?
	//
	auto_com_ptr(const auto_com_ptr<X>& r) : px(r.px)
			{ TrapSz("Copy ctor for auto_com_ptr incorrectly called!"); }
	~auto_com_ptr()
	{
		if (px)
		{
			px->Release();
		}
	}

	//	MANIPULATORS
	//
	auto_com_ptr& operator=(const auto_com_ptr<X>& r)
	{
		if ((void*)&r != (void*)this)
		{
			clear();		// Release any object we're holding now
			px = r.px;		// Grab & hold a ref on the object passed in
			if (px)
				px->AddRef();
		}
		return *this;
	}

	//	NOTE: This equals operator is meant to be used to load a
	//	new pointer (not yet held in any auto-ptr anywhere) into this object.
	//$REVIEW: The other options is an "additional" wrapper on the rvalue:
	//$REVIEW:	current- m_pEventRouter = CreateEventRouter( m_szVRoot );
	//$REVIEW:	other option- m_pEventRouter = auto_com_ptr<>(CreateEventRouter( m_szVRoot ));
	//
	auto_com_ptr& operator=(X* p)
	{
		Assert(!px);		//	Scream on overwrite of good data.
		px = p;
		return *this;
	}

	//	ACCESSORS
	//
	bool operator!()const { return (px == NULL); }
	operator X*()	const { return px; }
	X& operator*()  const { return *px; }
	X* operator->() const { return px; }
	X** operator&() { Assert(NULL==px); return &px; }
	X* get()		const { return px; }

	//	MANIPULATORS
	//
	X* relinquish()	{ X* p = px; px = 0; return p; }
	X** load()		{ Assert(NULL==px); return &px; }
	void clear()
	{
		if (px)			// Release any object we're holding now
		{
			px->Release();
		}
		px = NULL;
	}
};

//	========================================================================
//
//	CLASS CMTRefCounted
//	TEMPLATE CLASS auto_ref_ptr
//
class CMTRefCounted
{
	//	NOT IMPLEMENTED
	//
	CMTRefCounted(const CMTRefCounted& );
	CMTRefCounted& operator=(const CMTRefCounted& );

protected:
	LONG	m_cRef;

public:
	CMTRefCounted() : m_cRef(0) {}
	virtual ~CMTRefCounted() {}

	void AddRef()
	{
		InterlockedIncrement(&m_cRef);
	}

	void Release()
	{
		if (0 == InterlockedDecrement(&m_cRef))
			delete this;
	}
};


//	========================================================================
//
//	TEMPLATE FUNCTION QI_cast
//
//		QI directly into an auto_com_ptr.
//
//		Queries for the given IID on the punk provided.
//		Returns NULL if failure.
//		Usage:
//			auto_com_ptr<INew> punkNew;
//			punkNew = QI_cast<INew, &IID_INew>( punkOld );
//			if (!punkNew)
//			{	// error handling	}
//
//$LATER: Fix this func (and all invocations!) to NOT return an auto_com_ptr!
//
template<class I, const IID * piid>
auto_com_ptr<I>
QI_cast( IUnknown * punk )
{
	I * p;
	punk->QueryInterface( *piid, (LPVOID *) &p );
	return auto_com_ptr<I>( p );
}

#include <safeobj.h>

#endif // _AUTOPTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\calrc.h ===
/*
 *	C A L R C . H
 *
 *	Resource tracking header
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef _CALRC_H_
#define _CALRC_H_

#endif	//	_CALRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\crc.h ===
/*
 *	C R C . H
 *
 *	CRC Implementation
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_CRC_H_
#define _CRC_H_
#ifdef __cplusplus
extern "C" {
#endif

//	Table used for CRC calculation
//
extern const DWORD g_rgdwCRC[256];

//	Basic CRC function
//
DWORD DwComputeCRC (DWORD dwCRC, PVOID pv, UINT cb);

//	Basic CRC iteration -- for use where DwComputeCRC is insufficient
//
#define CRC_COMPUTE(_crc,_ch)	(g_rgdwCRC[((_crc) ^ (_ch)) & 0xff] ^ ((_crc) >> 8))

#ifdef __cplusplus
}

//	CRC'd string classes
//
#include <crcsz.h>

#endif	// __cplusplus
#endif	// _CRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\body.h ===
#ifndef _BODY_H_
#define _BODY_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	BODY.H
//
//		Common implementation classes from which request body and
//		response body are derived.
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <sgstruct.h>
#include <limits.h>		// definition of LONG_MIN
#include <ex\refcnt.h>	// IRefCounted
#include <ex\astream.h>	// Async stream interfaces
#include <ex\refhandle.h> // auto_ref_handle, etc.


//	========================================================================
//
//	CLASS IAsyncPersistObserver
//
//	Async I/O completion callback object interface used by
//	IBody::AsyncPersist().  Callers of AsyncPersist() must pass an object
//	conforming to this interface.  That object will be notified when
//	the async persist operation completes via a call to its
//	PersistComplete() member function.
//
class IAsyncPersistObserver : public IRefCounted
{
	//	NOT IMPLEMENTED
	//
	IAsyncPersistObserver& operator=( const IAsyncPersistObserver& );

public:
	//	CREATORS
	//
	virtual ~IAsyncPersistObserver() = 0;

	//	MANIPULATORS
	//
	virtual VOID PersistComplete( HRESULT hr ) = 0;
};


//	========================================================================
//
//	CLASS IAcceptObserver
//
//	Passed to the IBody::Accept() and IBodyPartAccept() methods when
//	accepting a body part visitor.  The accept observer is called whenever
//	the accept operation completes (which may happen asynchronously).
//	Note that the body part visitor is often the accept observer itself,
//	but it doesn't have to be.  The accept code which notifies the observer
//	is not aware that it is notifying a visitor.
//
class IAcceptObserver
{
	//	NOT IMPLEMENTED
	//
	IAcceptObserver& operator=( const IAcceptObserver& );

public:
	//	CREATORS
	//
	virtual ~IAcceptObserver() = 0;

	//	MANIPULATORS
	//
	virtual VOID AcceptComplete( UINT64 cbAccepted64 ) = 0;
};


//	========================================================================
//
//	CLASS CAsyncDriver
//
//	Implements a mechanism to allow an object to be driven asynchronously
//	from any one thread at a time.
//
template<class X>
class CAsyncDriver
{
	//
	//	Number of calls to Run() that will be made before
	//	the object requires another call to Start() to
	//	get it going again.  Each call to Start() increments
	//	this count by one.  The count is decremented by
	//	one as each Run() completes.
	//
	LONG m_lcRunCount;

	//	NOT IMPLEMENTED
	//
	CAsyncDriver( const CAsyncDriver& );
	CAsyncDriver& operator=( const CAsyncDriver& );

public:
	//	CREATORS
	//
	CAsyncDriver() : m_lcRunCount(0) {}
#ifdef DBG
	~CAsyncDriver() { m_lcRunCount = LONG_MIN; }
#endif

	//	MANIPULATORS
	//
	VOID Start(X& x)
	{
		//
		//	The object's Run() implementation often allows the final ref
		//	on the object to be released.  And this CAsyncDriver is often
		//	a member of that object.  Therefore, we need to AddRef() the
		//	object to keep ourselves alive until we return from this
		//	function.  It's kinda strange, but the alternative is to
		//	require callers to AddRef() the object themselves, but that
		//	approach would be more prone to error.
		//
		auto_ref_ptr<X> px(&x);

		AssertSz( m_lcRunCount >= 0, "CAsyncDriver::Start() called on destroyed/bad CAsyncDriver!" );

		//
		//	Start/Restart/Continue the driver
		//
		if ( InterlockedIncrement( &m_lcRunCount ) == 1 )
		{
			do
			{
				x.Run();
			}
			while ( InterlockedDecrement( &m_lcRunCount ) > 0 );
		}
	}
};


//	========================================================================
//
//	CLASS IBodyPart
//
//	Defines the interface to a body part.  An IBodyPart object is assumed
//	to consist of the body part data and an internal iterator over that
//	data.
//
//	An IBodyPart must implement the following methods:
//
//	CbSize()
//		Returns the size (in bytes) of the body part.  Necessary for
//		computation of a part's contribution to the content length.
//
//	Rewind()
//		Prepares the body part to be traversed again by new visitor.
//
//	Accept()
//		Accepts a body part visitor object to iterate over the body part.
//		The accept operation may be asynchronous either because the
//		body part chooses to implement it that way, or because the accepted
//		visitor requires it.  For this reason, an accept observer is
//		also used.  This observer should be called whenever the
//		accept operation completes.
//
class IBodyPart
{
	//	NOT IMPLEMENTED
	//
	IBodyPart& operator=( const IBodyPart& );

public:
	//	CREATORS
	//
	virtual ~IBodyPart() = 0;

	//	ACCESSORS
	//
	virtual UINT64 CbSize64() const = 0;

	//	MANIPULATORS
	//
	virtual VOID Accept( IBodyPartVisitor& v,
						 UINT64 ibPos64,
						 IAcceptObserver& obsAccept ) = 0;

	virtual VOID Rewind() = 0;
};


//	========================================================================
//
//	CLASS IBodyPartVisitor
//
//	Defines an interface for an object used to access body part data.
//	A body part visitor handles three types of data: in-memory bytes (text),
//	files, and streams (via IAsyncStream).  What the visitor does with that
//	data and how it does it is not specified; the behavior is provided by
//	the visitor itself.  The IBodyPartVisitor interface just standardizes
//	things to provide for asynchronous iteration over the entire body
//	without the need for custom asynchronous iteration code everywhere.
//
//	A body part visitor may implement any of its VisitXXX() methods
//	as asynchronous operations.  Regardless, the visitor must call
//	VisitComplete() on the visitor observer passed to it whenever
//	the visit operation completes.
//
//	When visiting body part data in one of the VisitXXX() methods,
//	a visitor does not have to visit (i.e. buffer) ALL of the data
//	before calling IAcceptObserver::AcceptComplete().  It can just
//	call AcceptComplete() with the number of bytes that can actually
//	be accepted.
//
class IAsyncStream;
class IBodyPartVisitor
{
	//	NOT IMPLEMENTED
	//
	IBodyPartVisitor& operator=( const IBodyPartVisitor& );

public:
	//	CREATORS
	//
	virtual ~IBodyPartVisitor() = 0;

	//	MANIPULATORS
	//
	virtual VOID VisitBytes( const BYTE * pbData,
							 UINT cbToVisit,
							 IAcceptObserver& obsAccept ) = 0;

	virtual VOID VisitFile( const auto_ref_handle& hf,
							UINT64 ibOffset64,
							UINT64 cbToVisit64,
							IAcceptObserver& obsAccept ) = 0;

	virtual VOID VisitStream( IAsyncStream& stm,
							  UINT cbToVisit,
							  IAcceptObserver& obsAccept ) = 0;

	virtual VOID VisitComplete() = 0;
};


//	========================================================================
//
//	CLASS IBody
//
//	Common request/response body interface
//
class IAsyncStream;
class IBody
{
	//	NOT IMPLEMENTED
	//
	IBody& operator=( const IBody& );

public:
	//	========================================================================
	//
	//	CLASS iterator
	//
	class iterator
	{
		//	NOT IMPLEMENTED
		//
		iterator& operator=( const iterator& );

	public:
		//	CREATORS
		//
		virtual ~iterator() = 0;

		//	MANIPULATORS
		//
		virtual VOID Accept( IBodyPartVisitor& v,
							 IAcceptObserver& obs ) = 0;

		virtual VOID Prune() = 0;
	};

	//	CREATORS
	//
	virtual ~IBody() = 0;

	//	ACCESSORS
	//
	virtual BOOL FIsEmpty() const = 0;
	virtual UINT64 CbSize64() const = 0;

	//	MANIPULATORS
	//
	virtual VOID Clear() = 0;
	virtual VOID AddText( LPCSTR lpszText, UINT cbText ) = 0;
	VOID AddText( LPCSTR lpszText ) { AddText(lpszText, static_cast<UINT>(strlen(lpszText))); }
	virtual VOID AddFile( const auto_ref_handle& hf,
						  UINT64 ibFile64,
						  UINT64 cbFile64 ) = 0;
	virtual VOID AddStream( IStream& stm ) = 0;
	virtual VOID AddStream( IStream& stm, UINT ibOffset, UINT cbSize ) = 0;
	virtual VOID AddBodyPart( IBodyPart * pBodyPart ) = 0;

	virtual VOID AsyncPersist( IAsyncStream& stm,
							   IAsyncPersistObserver& obs ) = 0;

	virtual IStream * GetIStream( IAsyncIStreamObserver& obs ) = 0;
	virtual iterator * GetIter() = 0;
};

IBody * NewBody();

//	========================================================================
//
//	CLASS CFileBodyPart
//
//	Represents a file body part.  A file body part is a part whose content
//	can be accessed with the standard Win32 APIs ReadFile() and TransmitFile().
//
//	Note: File body parts using this implementation must be no longer
//	than ULONG_MAX bytes!
//
class CFileBodyPart : public IBodyPart
{
	//	The file handle
	//
	auto_ref_handle m_hf;

	//	Starting offset into the file
	//
	UINT64 m_ibFile64;

	//	Size of the content
	//
	UINT64 m_cbFile64;

	//	NOT IMPLEMENTED
	//
	CFileBodyPart( const CFileBodyPart& );
	CFileBodyPart& operator=( const CFileBodyPart& );

public:
	//	CREATORS
	//
	CFileBodyPart( const auto_ref_handle& hf,
				   UINT64 ibFile64,
				   UINT64 cbFile64 );


	//	ACCESSORS
	//
	UINT64 CbSize64() const { return m_cbFile64; }

	//	MANIPULATORS
	//
	VOID Rewind();

	VOID Accept( IBodyPartVisitor& v,
				 UINT64 ibPos64,
				 IAcceptObserver& obsAccept );
};

//	========================================================================
//
//	CLASS CTextBodyPart
//
class CTextBodyPart : public IBodyPart
{
	//	String buffer to hold the text
	//
	StringBuffer<char>	m_bufText;

	//	NOT IMPLEMENTED
	//
	CTextBodyPart( const CTextBodyPart& );
	CTextBodyPart& operator=( const CTextBodyPart& );

public:

	//	AddTextBytes()
	//
	//	NOTE: this method was added for XML emitting.
	//	In that scenaro, an XML response is composed of
	//	many -- potentially thousands -- of calls to add
	//	response bytes.  If we strictly went and used the
	//	CMethUtil methods to ::AddResponseText(), we would
	//	end up with many -- potentially thousands -- of body
	//	parts.  So, the upshot here is that performance of
	//	such a mechanism would suck.
	//
	//	By adding the method -- and moving the declaration of
	//	this class to a publicly available header, we can now
	//	create a text body part as a component of the emitting
	//	process, and pour our data into body part directly.
	//	Once the content is complete, we can then simply add
	//	the body part.
	//
	VOID AddTextBytes ( UINT cbText, LPCSTR lpszText );

	//	CREATORS
	//
	CTextBodyPart( UINT cbText, LPCSTR lpszText );

	//	ACCESSORS
	//
	UINT64 CbSize64() const { return m_bufText.CbSize(); }

	//	MANIPULATORS
	//
	VOID Rewind();

	VOID Accept( IBodyPartVisitor& v,
				 UINT64 ibPos64,
				 IAcceptObserver& obsAccept );
};


#endif // !defined(_BODY_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\crcsz.h ===
/*
 *	C R C S Z . H
 *
 *	CRC Implementation
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_CRCSZ_H_
#define _CRCSZ_H_

//	Case Sensitive CRC'd string classes ---------------------------------------
//
//	Encapsulation of a CRC'ed string.  Use this class as the key type for
//	your cache class where a string key is called for.  The benefit is
//	increased cache search performance because a full string compare
//	is done only when the CRCs match (which typically happens only
//	for the string you're looking for).
//
class CRCSz
{
public:

	DWORD	m_dwCRC;
	LPCSTR	m_lpsz;

	CRCSz(LPCSTR psz) :
		m_lpsz(psz),
		m_dwCRC(DwComputeCRC(0,
							 const_cast<CHAR *>(psz),
							 static_cast<UINT>(strlen(psz))))
	{
	}

	//	operators for use with the hash cache
	//
	int hash( const int rhs ) const
	{
		return (m_dwCRC % rhs);
	}

	bool isequal( const CRCSz& rhs ) const
	{
		return ((m_dwCRC == rhs.m_dwCRC) &&
				!strcmp( m_lpsz, rhs.m_lpsz ));
	}
};

class CRCWszN
{
public:

	UINT		m_cch;
	DWORD		m_dwCRC;
	LPCWSTR		m_pwsz;

	CRCWszN(LPCWSTR pwsz, UINT cch) :
		m_cch(cch),
		m_pwsz(pwsz),
		m_dwCRC(DwComputeCRC (0,
							  const_cast<WCHAR *>(pwsz),
							  cch * sizeof(WCHAR)))
	{
	}

	//	operators for use with the hash cache
	//
	int hash( const int rhs ) const
	{
		return (m_dwCRC % rhs);
	}
	bool isequal( const CRCWszN& rhs ) const
	{
		return ((m_cch == rhs.m_cch) &&
				(m_dwCRC == rhs.m_dwCRC) &&
				!wcsncmp( m_pwsz, rhs.m_pwsz, m_cch ));
	}
};

class CRCWsz : public CRCWszN
{
	//	Not Implemented
	//
	CRCWsz();

public:

	CRCWsz(LPCWSTR pwsz) :
		CRCWszN(pwsz, static_cast<UINT>(wcslen(pwsz)))
	{
	}

	CRCWsz( const CRCWszN& rhs ) :
		CRCWszN (rhs)
	{
	}
};


//	Case Insensitive CRC'd string classes -------------------------------------
//
//	Encapsulation of a CRC'ed string.  Use this class as the key type for
//	your cache class where a string key is called for.  The benefit is
//	increased cache search performance because a full string compare
//	is done only when the CRCs match (which typically happens only
//	for the string you're looking for).
//
class CRCSzi
{
public:

	DWORD	m_dwCRC;
	LPCSTR	m_lpsz;

	CRCSzi( LPCSTR lpsz ) :
		m_lpsz(lpsz)
	{
		UINT cch = static_cast<UINT>(strlen(lpsz));
		CHAR lpszLower[128];

		//	Note that the CRC only is taken from the first 127 characters.
		//
		cch = (UINT)min(cch, sizeof(lpszLower) - 1);
		CopyMemory(lpszLower, lpsz, cch);
		lpszLower[cch] = 0;
		_strlwr(lpszLower);

		m_dwCRC = DwComputeCRC (0, const_cast<CHAR *>(lpszLower), cch);
	}

	//	operators for use with the hash cache
	//
	int hash( const int rhs ) const
	{
		return (m_dwCRC % rhs);
	}
	bool isequal( const CRCSzi& rhs ) const
	{
		return ((m_dwCRC == rhs.m_dwCRC) &&
				!lstrcmpiA( m_lpsz, rhs.m_lpsz ));
	}
};

class CRCWsziN
{
public:

	UINT		m_cch;
	DWORD		m_dwCRC;
	LPCWSTR		m_pwsz;

	CRCWsziN() :
			m_cch(0),
			m_dwCRC(0),
			m_pwsz(NULL)
	{}
	
	CRCWsziN(LPCWSTR pwsz, UINT cch) :
		m_cch(cch),
		m_pwsz(pwsz)
	{
		//	Note that the CRC only is taken from the first 127 characters.
		//
		WCHAR pwszLower[128];
		UINT cb = sizeof(WCHAR) * min(cch, (sizeof(pwszLower)/sizeof(WCHAR)) - 1);
		
		CopyMemory(pwszLower, pwsz, cb);
        pwszLower[cb / sizeof(WCHAR)] = L'\0';
		_wcslwr(pwszLower);

		m_dwCRC = DwComputeCRC (0, const_cast<WCHAR *>(pwszLower), cb);
	}

	//	operators for use with the hash cache
	//
	int hash( const int rhs ) const
	{
		return (m_dwCRC % rhs);
	}
	bool isequal( const CRCWsziN& rhs ) const
	{
		return ((m_cch == rhs.m_cch) &&
				(m_dwCRC == rhs.m_dwCRC) &&
				!_wcsnicmp( m_pwsz, rhs.m_pwsz, m_cch ));
	}
};

class CRCWszi : public CRCWsziN
{
public:
	CRCWszi()
	{}

	CRCWszi( LPCWSTR pwsz ) :
		CRCWsziN (pwsz, static_cast<UINT>(wcslen(pwsz)))
	{
	}

	//	operators for use with list::sort
	//
	bool operator<( const CRCWszi& rhs ) const
	{
		INT lret = 1;

		if (m_dwCRC < rhs.m_dwCRC)
			return true;

		if (m_dwCRC == rhs.m_dwCRC)
		{
			lret = _wcsnicmp(m_pwsz,
							 rhs.m_pwsz,
							 min(m_cch, rhs.m_cch));
		}
		return (lret ? (lret < 0) : (m_cch < rhs.m_cch));
	}

	//	operators for use with list::unique
	//
	bool operator==( const CRCWszi& rhs ) const
	{
		return isequal(rhs);
	}
};

#endif	// _CRCSZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\cvroot.h ===
/*
 *	C V R O O T . H
 *
 *	Extended virtual root information used in link fixup
 *	and vroot enumeration
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_CVROOT_H_
#define _CVROOT_H_

#include <buffer.h>
#include <autoptr.h>

//	CVroot --------------------------------------------------------------------
//
class IMDData;
class CVRoot : public CMTRefCounted
{
private:

	//	Buffer for all of the string data that we own.  Note that it is
	//	declared before any of the string pointers because it must be
	//	constructed first.
	//
	ChainedStringBuffer<WCHAR> m_sb;

	//	VRoot metadata
	//
	auto_ref_ptr<IMDData>	m_pMDData;

	//	Real metabase path
	//
	LPCWSTR					m_pwszMbPath;

	//	Wide copy of the virtual root's physical path
	//
	auto_heap_ptr<WCHAR>	m_pwszVRPath;
	UINT					m_cchVRPath;

	//	Calculated values from the metadata
	//
	LPCWSTR					m_pwszVRoot;
	UINT					m_cchVRoot;

	LPCWSTR					m_pwszServer;
	UINT					m_cchServer;

	LPCWSTR					m_pwszPort;
	UINT					m_cchPort;
	BOOL					m_fDefaultPort;
	BOOL					m_fSecure;

	//	NOT IMPLEMENTED
	//
	CVRoot& operator=(const CVRoot&);
	CVRoot(const CVRoot&);

public:

	CVRoot( LPCWSTR pwszUrl,
			LPCWSTR pwszVrUrl,
			UINT cchServerDefault,
		    LPCWSTR pwszServerDefault,
		    IMDData* pMDData );

	UINT CchPrefixOfMetabasePath (LPCWSTR* ppwsz) const
	{
		Assert (ppwsz);
		*ppwsz = m_pwszMbPath;
		return static_cast<UINT>(m_pwszVRoot - m_pwszMbPath);
	}

	UINT CchGetServerName (LPCWSTR* ppwsz) const
	{
		Assert (ppwsz);
		*ppwsz = m_pwszServer;
		return m_cchServer;
	}

	UINT CchGetPort (LPCWSTR* ppwsz) const
	{
		Assert (ppwsz);
		*ppwsz = m_pwszPort;
		return m_cchPort;
	}

	UINT CchGetVRoot (LPCWSTR* ppwsz) const
	{
		Assert (ppwsz);
		*ppwsz = m_pwszVRoot;
		return m_cchVRoot;
	}

	UINT CchGetVRPath (LPCWSTR* ppwsz) const
	{
		Assert (ppwsz);
		*ppwsz = m_pwszVRPath;
		return m_cchVRPath;
	}

	BOOL FSecure () const { return m_fSecure; }
	BOOL FDefaultPort () const { return m_fDefaultPort; }

	const IMDData * MetaData() const { return m_pMDData.get(); }
};

//	CVroot List ---------------------------------------------------------------
//
//	Use pragmas to disable the specific level 4 warnings
//	that appear when we use the STL.  One would hope our version of the
//	STL compiles clean at level 4, but alas it doesn't....
//
#pragma warning(disable:4663)	//	C language, template<> syntax
#pragma warning(disable:4244)	//	return conversion, data loss

// Turn this warning off for good.
//
#pragma warning(disable:4786)	//	symbol truncated in debug info

// Put STL includes here
//
#include <list>

// Turn warnings back on
//
#pragma warning(default:4663)	//	C language, template<> syntax
#pragma warning(default:4244)	//	return conversion, data loss

class CSortableStrings
{
public:

	LPCWSTR		m_pwsz;

	CSortableStrings(LPCWSTR pwsz = NULL)
			: m_pwsz(pwsz)
	{
	}

	//	operators for use with list::sort
	//
	BOOL operator<( const CSortableStrings& rhs ) const
	{

		if (_wcsicmp( m_pwsz, rhs.m_pwsz ) < 0)
			return TRUE;

		return FALSE;
	}
};

typedef std::list<CSortableStrings, heap_allocator<CSortableStrings> > CVRList;

#endif	// _CVROOT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\davsc.h ===
/*
 *	D A V S C . H
 *
 *	Extended error codes for DAV
 *
 *	These error codes should be designed/implemented in such a way as to
 *	provide better error code translations for returns to the client.
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#pragma once
#ifndef _DAVSC_H_
#define _DAVSC_H_

#define FACILITY_DAV		21
#define DAV_SCODE(_ids)		MAKE_SCODE(SEVERITY_ERROR,FACILITY_DAV,_ids)
#define DAV_WARNING(_ids)	MAKE_SCODE(SEVERITY_SUCCESS,FACILITY_DAV,_ids)

//	Core and/or common error codes range from 0x100-0x800
//	DAV Exchange reserves 0x001-0x0FF for IIS component errors
//	and 0x800-0xFFFF for server component errors.
//
#define E_DAV_NO_DESTINATION						DAV_SCODE(0x100)
#define E_DAV_BAD_DESTINATION						DAV_SCODE(0x101)
#define E_DAV_MALFORMED_PATH						DAV_SCODE(0x102)
#define E_DAV_CONFLICTING_PATHS						DAV_SCODE(0x103)
#define E_DAV_INVALID_HEADER						DAV_SCODE(0x104)
#define E_DAV_NO_IIS_ACCESS_RIGHTS					DAV_SCODE(0x105)
#define E_DAV_LOCKED								DAV_SCODE(0x106)
#define E_DAV_PROTECTED_ENTITY						DAV_SCODE(0x107)
#define E_DAV_NONEXISTING_PARENT					DAV_SCODE(0x108)
#define E_DAV_MISSING_LENGTH						DAV_SCODE(0x109)
#define E_DAV_ENTITY_NOT_LOCKED						DAV_SCODE(0x10A)
#define E_DAV_ENTITY_TYPE_CONFLICT					DAV_SCODE(0x10B)
#define E_DAV_ENTITY_NOT_MODIFIED					DAV_SCODE(0x10C)
#define E_DAV_IF_HEADER_FAILURE						DAV_SCODE(0x10D)
#define E_DAV_UNKNOWN_CONTENT						DAV_SCODE(0x10E)
#define E_DAV_RANGE_NOT_SATISFIABLE					DAV_SCODE(0x10F)
#define E_DAV_NO_PARTIAL_UPDATE						DAV_SCODE(0x110)
#define E_DAV_LOCK_NOT_FOUND						DAV_SCODE(0x111)
#define E_DAV_VOLUME_NOT_NTFS						DAV_SCODE(0x112)
#define E_DAV_PROPFIND_TYPE_UNEXPECTED				DAV_SCODE(0x113)
#define E_DAV_EMPTY_PATCH_REQUEST					DAV_SCODE(0x114)
#define E_DAV_EMPTY_FIND_REQUEST					DAV_SCODE(0x115)
#define E_DAV_PATCH_TYPE_MISMATCH					DAV_SCODE(0x116)
#define E_DAV_RESPONSE_TYPE_UNACCEPTED				DAV_SCODE(0x117)
#define E_DAV_BASE64_ENCODING_ERROR					DAV_SCODE(0x118)
#define E_DAV_METHOD_FORWARDED						DAV_SCODE(0x119)
#define E_DAV_READ_REQUEST_TIMEOUT					DAV_SCODE(0x11A)
#define E_DAV_INCOMPLETE_SQL_STATEMENT				DAV_SCODE(0x11B)
#define E_DAV_XML_PARSE_ERROR						DAV_SCODE(0x11C)
#define E_DAV_SMB_PROPERTY_ERROR					DAV_SCODE(0x11D)
#define E_DAV_OVERWRITE_REQUIRED					DAV_SCODE(0x11E)
#define E_DAV_NO_QUERY								DAV_SCODE(0x11F)
#define E_DAV_NAMED_PROPERTY_ERROR					DAV_SCODE(0x120)
#define E_DAV_UNEXPECTED_TYPE						DAV_SCODE(0x121)
#define E_DAV_COLLECTION_EXISTS						DAV_SCODE(0x122)
#define E_DAV_XML_DOM_ERROR							DAV_SCODE(0x123)
#define E_DAV_ROW_PACKING_ERROR						DAV_SCODE(0x124)
#define E_DAV_COLUMN_VALUE_NOT_FOUND				DAV_SCODE(0x125)
#define E_DAV_IPC_CONNECT_FAILED					DAV_SCODE(0x126)
#define E_DAV_IPC_ALLOC_FAILED						DAV_SCODE(0x127)
#define E_DAV_IPC_SEND_FAILED						DAV_SCODE(0x128)
#define E_DAV_IPC_REC_FAILED						DAV_SCODE(0x129)
#define E_DAV_IPC_IMPERSONATION_ERR					DAV_SCODE(0x12A)
#define E_DAV_INVALID_URI							DAV_SCODE(0x12B)
#define E_DAV_MISSING_CONTENT_TYPE					DAV_SCODE(0x12C)
#define E_DAV_IPC_CREATE_EVENT_FAIL					DAV_SCODE(0x12D)
#define E_DAV_REDIRECT_FAILED						DAV_SCODE(0x12E)
#define E_DAV_SHORT_FILENAME						DAV_SCODE(0x12F)
#define E_DAV_ALT_FILESTREAM						DAV_SCODE(0x130)
#define E_DAV_RESPONSE_INCOMPLETE					DAV_SCODE(0x131)
#define E_DAV_STAR_SCRIPTMAPING_MISMATCH			DAV_SCODE(0x132)
#define E_DAV_NO_IIS_READ_ACCESS					DAV_SCODE(0x133)
#define E_DAV_NO_IIS_WRITE_ACCESS					DAV_SCODE(0x134)
#define E_DAV_NO_IIS_EXECUTE_ACCESS					DAV_SCODE(0x135)
#define E_DAV_NO_ACL_ACCESS							DAV_SCODE(0x136)
#define E_DAV_METHOD_FAILURE_STAR_URL				DAV_SCODE(0x137)
#define E_DAV_SEARCH_SCOPE_ERROR					DAV_SCODE(0x138)
#define E_DAV_CANT_SATISFY_LOCK_REQUEST				DAV_SCODE(0x139)
#define E_DAV_CANT_PERSIST_SEARCH					DAV_SCODE(0x13A)
#define E_DAV_CANT_QUERY_ROWS						DAV_SCODE(0x13B)
#define E_DAV_CANT_MAKE_DBCOMMANDTREE				DAV_SCODE(0x13C)
#define E_DAV_UNSUPPORTED_SQL						DAV_SCODE(0x13D)
#define E_DAV_CANT_SEEK_ROW							DAV_SCODE(0x13E)
#define E_DAV_CANT_QUERY_POSITION					DAV_SCODE(0x13F)
#define E_DAV_EXPROX_CONNECT_FAILED					DAV_SCODE(0x140)
#define E_DAV_TRANSACTION_CACHE						DAV_SCODE(0x141)
#define E_DAV_NOTALLOWED_WITHIN_TRANSACTION			DAV_SCODE(0x142)
#define E_DAV_VIEW_NOT_FOUND						DAV_SCODE(0x143)
#define E_DAV_RSRC_NOT_FOUND						DAV_SCODE(0x144)
#define E_DAV_RSRC_INSUFFICIENT_BUFFER				DAV_SCODE(0x145)
#define E_DAV_FORBIDDEN								DAV_SCODE(0x146)
#define E_DAV_CONFLICT								DAV_SCODE(0x147)
#define E_DAV_INVALID_PROPERTY_NAME					DAV_SCODE(0x148)
#define E_DAV_HIDDEN_OBJECT							DAV_SCODE(0x149)
#define	E_DAV_FORMS_HANDLER							DAV_SCODE(0x14A)
#define E_DAV_XML_BAD_DATA							DAV_SCODE(0x14B)
//unused											DAV_SCODE(0x14C)
#define E_DAV_NATIVE_CONTENT_NOT_MAPI				DAV_SCODE(0x14D)


//	Special error to mark properties for which we have property streams open,
//	for seafety reasons do not use for anything else
//
#define E_DAV_USE_PROPERTY_STREAM					DAV_SCODE(0x14E)
#define E_DAV_PARTIAL_COLUMN						DAV_SCODE(0x14F)

//  Error code used by exprox exception handler code
//
#define E_DAV_EXPROX_THREW_EXCEPTION                DAV_SCODE(0x150)

#define E_DAV_MAIL_SUBMISSION_FORBIDDEN				DAV_SCODE(0x600)
#define E_DAV_MKCOL_REVISION_ID_FORBIDDEN			DAV_SCODE(0x601)
#define E_DAV_MKCOL_NOT_ALLOWED_ON_NULL_RESOURCE	DAV_SCODE(0x602)
#define	E_DAV_MKCOL_OBJECT_ALREADY_EXISTS			DAV_SCODE(0x603)
#define E_DAV_GET_DB_HELPER_FAILURE					DAV_SCODE(0x604)
#define E_DAV_NOTIF_SUBID_ERROR						DAV_SCODE(0x605)
#define E_DAV_NOTIF_POLL_FAILURE					DAV_SCODE(0x606)

#define W_DAV_RESPONSE_ALREADY_SENT					DAV_WARNING(0x7EF)
#define W_DAV_NOSAVECHANGESREQUIRED					DAV_WARNING(0x7F0)
#define W_DAV_NO_TARGETS							DAV_WARNING(0x7F1)
#define W_DAV_RELATIVE_URI							DAV_WARNING(0x7F2)
#define W_DAV_MOVED_TEMPORARILY						DAV_WARNING(0x7F3)
#define W_DAV_ESCAPED_SQL_TOKEN						DAV_WARNING(0x7F4)
#define W_DAV_NULL_RESOURCE							DAV_WARNING(0x7F5)
#define W_DAV_SEARCH_PENDING						DAV_WARNING(0x7F6)
#define W_DAV_SPANS_VIRTUAL_ROOTS					DAV_WARNING(0x7F7)
#define W_DAV_XML_NODE_NOT_CONSTRUCTED				DAV_WARNING(0x7F8)
#define W_DAV_SCRIPTMAP_MATCH_EXCLUDED				DAV_WARNING(0x7F9)
#define W_DAV_SCRIPTMAP_MATCH_FOUND					DAV_WARNING(0x7FA)
#define W_DAV_PARTIAL_CONTENT						DAV_WARNING(0x7FB)
#define W_DAV_NO_CONTENT							DAV_WARNING(0x7FC)
#define W_DAV_CREATED								DAV_WARNING(0x7FD)
#define W_DAV_PARTIAL_SUCCESS						DAV_WARNING(0x7FE)
#define W_DAV_VIEW_USE_DEFAULT						DAV_WARNING(0x7FF)

#define E_DAV_STORE_BAD_PATH						DAV_SCODE(0x800)
#define E_DAV_STORE_QUERY_SMTP_DOMAIN				DAV_SCODE(0x801)
#define E_DAV_STORE_OUTOFMEMORY						DAV_SCODE(0x802)
#define E_DAV_STORE_SESS_GET_INFO					DAV_SCODE(0x803)

//  E_DAV_STORE_MDB_UNAVAILABLE is only sent when the public store
//  is hit, but it is dismounted.
//
#define E_DAV_STORE_MDB_UNAVAILABLE					DAV_SCODE(0x804)
#define E_DAV_STORE_GET_MAILBOX_GUID				DAV_SCODE(0x805)
#define E_DAV_STORE_LOGON_FAILED					DAV_SCODE(0x806)
#define E_DAV_STORE_ADD_LOGON						DAV_SCODE(0x807)
#define E_DAV_STORE_NOT_FOUND						DAV_SCODE(0x808)
#define E_DAV_STORE_CHECK_FOLDER_NAME				DAV_SCODE(0x809)
#define E_DAV_STORE_OPEN_FOLDER						DAV_SCODE(0x80a)
#define E_DAV_STORE_GET_TABLE						DAV_SCODE(0x80b)
#define E_DAV_STORE_SET_COLUMNS						DAV_SCODE(0x80c)
#define E_DAV_STORE_FIND_ROW						DAV_SCODE(0x80d)
#define E_DAV_STORE_OPEN_IMAIL_OBJ					DAV_SCODE(0x80e)
#define E_DAV_STORE_OPEN_IMAIL_STREAM				DAV_SCODE(0x80f)
#define E_DAV_STORE_STREAM_READ						DAV_SCODE(0x810)
#define E_DAV_STORE_NOTIMPL							DAV_SCODE(0x811)
#define E_DAV_STORE_SAVE_CHANGES_MSG				DAV_SCODE(0x812)
#define E_DAV_STORE_GET_SESS						DAV_SCODE(0x813)
#define E_DAV_STORE_SAVE_CHANGES_ATTACH				DAV_SCODE(0x814)
#define E_DAV_STORE_SESS_CONFIG						DAV_SCODE(0x815)
#define E_DAV_STORE_OUTOFSHAREDMEMORY				DAV_SCODE(0x816)
#define E_DAV_STORE_IPC_SEND						DAV_SCODE(0x817)
#define E_DAV_STORE_CHECK_RIGHTS_FOLD				DAV_SCODE(0x818)
#define E_DAV_STORE_CREATE_ATTACH					DAV_SCODE(0x819)
#define E_DAV_STORE_CREATE_TEMP_STREAM				DAV_SCODE(0x81a)
#define E_DAV_STORE_QUERY_ROWS						DAV_SCODE(0x81b)
#define E_DAV_STORE_STREAM_WRITE					DAV_SCODE(0x81c)
#define E_DAV_STORE_GET_PROPS						DAV_SCODE(0x81d)
#define E_DAV_SEARCH_COULD_NOT_RESTRICT				DAV_SCODE(0x81e)
#define E_DAV_STORE_INTERNAL						DAV_SCODE(0x81f)
#define E_DAV_STORE_OPEN_MSG						DAV_SCODE(0x820)
#define E_DAV_STORE_OPEN_ATTACH						DAV_SCODE(0x821)
#define E_DAV_STORE_OPEN_STREAM						DAV_SCODE(0x822)
#define E_DAV_STORE_MDB_STREAM_READ					DAV_SCODE(0x823)
#define E_DAV_STORE_CREATE_FOLDER					DAV_SCODE(0x824)
#define E_DAV_STORE_ALREADY_EXISTS					DAV_SCODE(0x825)
#define E_DAV_STORE_GET_TOKEN_INFO					DAV_SCODE(0x826)
#define E_DAV_STORE_LOOKUP_ACCOUNT_SID				DAV_SCODE(0x827)
#define E_DAV_STORE_SET_PROPS						DAV_SCODE(0x828)
#define E_DAV_STORE_DELETE							DAV_SCODE(0x829)
#define E_DAV_SEARCH_FOLDER_NOT_CREATED				DAV_SCODE(0x82a)

#define E_DAV_STORE_MOVE_COPY						DAV_SCODE(0x830)
#define E_DAV_STORE_DELETE_PROPS					DAV_SCODE(0x831)
#define E_DAV_STORE_SESSPOOLERROR					DAV_SCODE(0x832)
#define E_DAV_STORE_BEGIN_GOP						DAV_SCODE(0x833)
#define E_DAV_STORE_COMMIT_GOP						DAV_SCODE(0x834)
#define E_DAV_STORE_ROLLBACK_GOP					DAV_SCODE(0x835)
#define E_DAV_STORE_GET_IDS_FROM_NAMES				DAV_SCODE(0x836)
#define E_DAV_STORE_GET_NAMES_FROM_IDS				DAV_SCODE(0x837)
#define E_DAV_STORE_OP_REQUIRES_FOLDER				DAV_SCODE(0x838)
#define E_DAV_STORE_SEARCH_ERROR					DAV_SCODE(0x839)
#define E_DAV_STORE_SEARCH_UNSUPPORTED				DAV_SCODE(0x83d)
#define E_DAV_STORE_TOO_MANY_CONNECTIONS			DAV_SCODE(0x83e)
#define E_DAV_STORE_SEEK_ROWS						DAV_SCODE(0x83f)
#define E_DAV_STORE_BAD_CONTEXT_INFO				DAV_SCODE(0x840)
#define E_DAV_STORE_IFS_FILE_OPEN					DAV_SCODE(0x841)
#define E_DAV_STORE_IFS_FILE_WRITE					DAV_SCODE(0x842)
#define E_DAV_STORE_MAIL_SUBMISSION					DAV_SCODE(0x843)
#define E_DAV_STORE_GET_IFS_ROOT					DAV_SCODE(0x844)
#define E_DAV_STORE_SESSMGRERROR					DAV_SCODE(0x845)
#define E_DAV_STORE_TIMEOUT_WAIT_FOR_TICKET			DAV_SCODE(0x846)
#define E_DAV_STORE_INVALIDTICKET					DAV_SCODE(0x847)
#define E_DAV_STORE_RESTRICT						DAV_SCODE(0x848)
#define E_DAV_STORE_SORTTABLE						DAV_SCODE(0x849)
#define E_DAV_INVALID_TPLT_FORMAT					DAV_SCODE(0x84a)
#define E_DAV_INVALID_CALLBACK						DAV_SCODE(0x84b)
#define E_DAV_STORE_QUERYPOS						DAV_SCODE(0x84c)
#define E_DAV_STORE_APPLY_VIEW						DAV_SCODE(0x84d)
#define E_DAV_STORE_INIT_VIEW						DAV_SCODE(0x84e)
#define E_DAV_STORE_FIND_VIEW						DAV_SCODE(0x84f)
#define E_DAV_STORE_MSHL_COLUMN						DAV_SCODE(0x850)
#define E_DAV_STORE_ADD_COLUMN						DAV_SCODE(0x851)
#define E_DAV_TLHNAME_PARSE_ERROR					DAV_SCODE(0x852)
#define E_DAV_STORE_USE_PROXY						DAV_SCODE(0x853)
#define E_DAV_SEARCH_TABLE_ERROR					DAV_SCODE(0x854)
#define E_DAV_STORE_USER_CACHE_ERROR				DAV_SCODE(0x855)
#define E_DAV_MDB_DOWN								DAV_SCODE(0x856)
#define E_DAV_STORE_COPY_PROPS						DAV_SCODE(0x857)
#define E_DAV_STORE_SAVE_MSG						DAV_SCODE(0x858)
#define E_DAV_STORE_RECIP							DAV_SCODE(0x859)
#define E_DAV_STORE_NOT_VERSIONED					DAV_SCODE(0x85a)
#define E_DAV_STORE_GET_VERSION_HISTORY				DAV_SCODE(0x85b)
#define E_DAV_STORE_REVISION_ID_FAILURE				DAV_SCODE(0x85c)
#define E_DAV_VERSIONING_BAD_VERB					DAV_SCODE(0x85d)
#define E_DAV_VERSIONING_BAD_COMMENT				DAV_SCODE(0x85e)
#define E_DAV_VERSIONING_BAD_LOCK_DEPTH				DAV_SCODE(0x85f)
#define E_DAV_VERSIONING_INVALID_PARAMETER			DAV_SCODE(0x860)
#define E_DAV_STORE_NEED_TRAILING_SLASH				DAV_SCODE(0x861)
#define E_DAV_STORE_SET_FILE_HANDLE_PROP			DAV_SCODE(0x862)
#define E_DAV_LOCK_TIMEOUT							DAV_SCODE(0x863)
#define E_DAV_STORE_DELETE_FOLDER					DAV_SCODE(0x864)
#define E_DAV_STORE_DELETE_MESSAGES					DAV_SCODE(0x865)
#define E_DAV_STORE_MOVECOPY_FOLDER					DAV_SCODE(0x866)
#define E_DAV_STORE_MOVECOPY_MESSAGES				DAV_SCODE(0x867)
#define E_DAV_EPOXY_ERROR_ALREADY_SENT				DAV_SCODE(0x868)
#define E_DAV_UNRESOLVED_RECIP						DAV_SCODE(0x869)
#define E_DAV_NO_OBJECT_SELECTED					DAV_SCODE(0x86a)
#define E_DAV_SELECT_ONE_FOLDER						DAV_SCODE(0x86b)
#define E_DAV_MESSAGE_TOO_LARGE						DAV_SCODE(0x86c)
#define E_DAV_QUOTA_EXCEEDED						DAV_SCODE(0x86d)
#define E_DAV_SID_AMBIGUOUS							DAV_SCODE(0x86e)
#define E_DAV_GUID_AMBIGUOUS						DAV_SCODE(0x86f)
#define E_DAV_NO_RECIPS								DAV_SCODE(0x870)
#define E_DAV_ALIAS_AMBIGUOUS						DAV_SCODE(0x871)


//	Error to be set by the code that attempts to enqueue the packet
//	onto epoxy, but does not manage to do that for some reason
//
#define E_DAV_EPOXY_UNAVAILABLE						DAV_SCODE(0x871)


#endif	// _DAVSC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\davmb.h ===
/*
 *	D A V M B . H
 *
 *	DAV metabase
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	_DAVMB_H_
#define _DAVMB_H_

#include <initguid.h>
#include <exguid.h>
#include <iadmw.h>
#include <iwamreg.h>
#include <iiscnfg.h>
#include <autoptr.h>
#include <exo.h>
#include <malloc.h>
#include <szsrc.h>
#include <ex\refcnt.h>

//	Advising the notification sink --------------------------------------------
//
HRESULT
HrAdviseSink( IMSAdminBase& msAdminBase,
			  IMSAdminBaseSink * pMSAdminBaseSink,
			  DWORD * pdwCookie );

//	Unadvising the notification sink ------------------------------------------
//
VOID
UnadviseSink( IMSAdminBase& msAdminBase,
			  DWORD dwCookie );

//	Constructing metabase change object ---------------------------------
//
inline
SCODE ScBuildChangeObject(LPCWSTR pwszBase,
						  UINT cchBase,
						  LPCWSTR pwszPath,
						  UINT cchPath,
						  DWORD dwMDChangeType,
						  const DWORD * pdwMDDataId,
						  LPWSTR pwszBuf,
						  UINT * pcchBuf,
						  PMD_CHANGE_OBJECT_W pMdChObjW)
{
	SCODE sc = S_OK;
	UINT cchT;
	
	Assert(0 == cchBase || pwszBase);
	Assert(0 == cchPath || pwszPath);
	Assert(pdwMDDataId);
	Assert(pcchBuf);
	Assert(0 == *pcchBuf || pwszBuf);
	Assert(pMdChObjW);

	//	Ambiguous trace. I am comenting it out...
	//
	/*	DebugTrace(	"ScBuildChangeObject() called:\n"
				"   Base path: '%S'\n"
				"   Remaining path: '%S'\n"
				"   Change type: 0x%08lX\n"
				"   Data ID: 0x%08lX\n",
				pwszBase ? pwszBase : L"NONE",
				pwszPath ? pwszPath : L"NONE",
				dwMDChangeType,
				*pdwMDDataId );*/

	//	Construct the path change is occuring on.
	//
	BOOL fNeedSeparator  = FALSE;
	BOOL fNeedTerminator = FALSE;

	//	Make sure that we do not assemble the path with
	//	double '/' in the middle.
	//
	if (cchBase &&
		cchPath &&
		L'/' == pwszBase[cchBase - 1] &&
		L'/' == pwszPath[0])
	{
		//	Get rid of one '/'
		//
		cchBase--;
	}
	else if ((0 == cchBase || L'/' != pwszBase[cchBase - 1]) &&
			 (0 == cchPath || L'/' != pwszPath[0]))
	{
		//	We need a separator
		//
		fNeedSeparator = TRUE;
	}

	//	Check out if we need terminating '/' at the end.
	//
	if (cchPath && L'/' != pwszPath[cchPath - 1])
	{
		fNeedTerminator = TRUE;
	}

	cchT = cchBase + cchPath + 1;
	if (fNeedSeparator)
	{
		cchT++;
	}
	if (fNeedTerminator)
	{
		cchT++;
	}

	if (*pcchBuf < cchT)
	{
		*pcchBuf = cchT;
		sc = S_FALSE;
	}
	else
	{
		cchT = 0;
		if (cchBase)
		{
			memcpy(pwszBuf, pwszBase, cchBase * sizeof(WCHAR));
			cchT += cchBase;
		}
		if (fNeedSeparator)
		{
			pwszBuf[cchT] = L'/';
			cchT++;
		}
		if (cchPath)
		{
			memcpy(pwszBuf + cchT, pwszPath, cchPath * sizeof(WCHAR));
			cchT += cchPath;
		}
		if (fNeedTerminator)
		{
			pwszBuf[cchT] = L'/';
			cchT++;
		}
		pwszBuf[cchT] = L'\0';

		pMdChObjW->pszMDPath = pwszBuf;
		pMdChObjW->dwMDChangeType = dwMDChangeType;
		pMdChObjW->dwMDNumDataIDs = 1;
		pMdChObjW->pdwMDDataIDs = const_cast<DWORD *>(pdwMDDataId);
	}

	return sc;
}

class LFUData
{
	//	Approximate number of hits via Touch()
	//
	DWORD m_dwcHits;

	//	NOT IMPLEMENTED
	//
	LFUData& operator=(const LFUData&);
	LFUData(const LFUData&);

public:
	//	CREATORS
	//
	LFUData() : m_dwcHits(0) {}

	//	MANIPULATORS
	//

	//	--------------------------------------------------------------------
	//
	//	Touch()
	//
	//	Increments the hit count.  Note that this is done without an
	//	interlocked operation.  The expectation is that the actual count
	//	value is just a hint and as such, it is not critical that it be
	//	exactly accurate.
	//
	VOID Touch()
	{
		++m_dwcHits;
	}

	//	--------------------------------------------------------------------
	//
	//	DwGatherAndResetHitCount()
	//
	//	Fetches and resets the hit count.  Again, the actual value is
	//	unimportant, so there is no interlocked operation.
	//
	DWORD DwGatherAndResetHitCount()
	{
		DWORD dwcHits = m_dwcHits;

		m_dwcHits = 0;

		return dwcHits;
	}
};

class IContentTypeMap;
class ICustomErrorMap;
class IScriptMap;
class IMDData : public IRefCounted
{
	//	LFU data
	//
	LFUData m_lfudata;

	//	NOT IMPLEMENTED
	//
	IMDData& operator=(const IMDData&);
	IMDData(const IMDData&);

protected:
	//	CREATORS
	//	Only create this object through it's descendents!
	//
	IMDData() {}

public:
	//	CREATORS
	//
	virtual ~IMDData() {}

	//	MANIPULATORS
	//
	LFUData& LFUData() { return m_lfudata; }

	//	ACCESSORS
	//
	virtual LPCWSTR PwszMDPathDataSet() const = 0;
	virtual IContentTypeMap * GetContentTypeMap() const = 0;
	virtual const ICustomErrorMap * GetCustomErrorMap() const = 0;
	virtual const IScriptMap * GetScriptMap() const = 0;
	virtual LPCWSTR PwszDefaultDocList() const = 0;
	virtual LPCWSTR PwszVRUserName() const = 0;
	virtual LPCWSTR PwszVRPassword() const = 0;
	virtual LPCWSTR PwszExpires() const = 0;
	virtual LPCWSTR PwszBindings() const = 0;
	virtual LPCWSTR PwszVRPath() const = 0;
	virtual DWORD DwDirBrowsing() const = 0;
	virtual DWORD DwAccessPerms() const = 0;
	virtual BOOL FAuthorViaFrontPage() const = 0;
	virtual BOOL FHasIPRestriction() const = 0;
	virtual BOOL FSameIPRestriction(const IMDData* prhs) const = 0;
	virtual BOOL FHasApp() const = 0;
	virtual DWORD DwAuthorization() const = 0;
	virtual BOOL FIsIndexed() const = 0;
	virtual BOOL FSameStarScriptmapping(const IMDData* prhs) const = 0;

	//
	//	Any new metadata accessor should be added here and
	//	an implementation provided in \cal\src\_davprs\davmb.cpp.
	//
};

class IEcb;

//	========================================================================
//
//	CLASS CMDObjectHandle
//
//	Encapsulates access to a metabase object through an open handle,
//	ensuring that the handle is always propery closed.
//
class CMDObjectHandle
{
	enum { METADATA_TIMEOUT = 5000 };

	//
	//	Reference to ECB for security switching
	//
	const IEcb& m_ecb;

	//
	//	COM interface to the metabase
	//
	IMSAdminBase * m_pMSAdminBase;

	//
	//	Raw metabase handle
	//
	METADATA_HANDLE m_hMDObject;

	//
	//	The path for which the handle was opened
	//
	LPCWSTR m_pwszPath;

	//	NOT IMPLEMENTED
	//
	CMDObjectHandle(const CMDObjectHandle&);
	CMDObjectHandle& operator=(CMDObjectHandle&);

public:
	
	//	CREATORS
	//
	CMDObjectHandle(const IEcb& ecb, IMSAdminBase * pMSAdminBase = NULL) :
	    m_ecb(ecb),
		m_pMSAdminBase(pMSAdminBase),
		m_hMDObject(METADATA_MASTER_ROOT_HANDLE),
		m_pwszPath(NULL)
	{
	}

	~CMDObjectHandle();

	//	MANIPULATORS
	//
	HRESULT HrOpen( IMSAdminBase * pMSAdminBase,
					LPCWSTR pwszPath,
					DWORD dwAccess,
					DWORD dwMsecTimeout );

	HRESULT HrOpenLowestNode( IMSAdminBase * pMSAdminBase,
							  LPWSTR pwszPath,
							  DWORD dwAccess,
							  LPWSTR * ppwszPath );

	HRESULT HrEnumKeys( LPCWSTR pwszPath,
						LPWSTR pwszChild,
						DWORD dwIndex ) const;

	HRESULT HrGetDataPaths( LPCWSTR pwszPath,
							DWORD   dwPropID,
							DWORD   dwDataType,
							LPWSTR	 pwszDataPaths,
							DWORD * pcchDataPaths ) const;

	HRESULT HrGetMetaData( LPCWSTR pwszPath,
						   METADATA_RECORD * pmdrec,
						   DWORD * pcbBufRequired ) const;

	HRESULT HrGetAllMetaData( LPCWSTR pwszPath,
							  DWORD dwAttributes,
							  DWORD dwUserType,
							  DWORD dwDataType,
							  DWORD * pdwcRecords,
							  DWORD * pdwDataSet,
							  DWORD cbBuf,
							  LPBYTE pbBuf,
							  DWORD * pcbBufRequired ) const;

	HRESULT HrSetMetaData( LPCWSTR pwszPath,
						   const METADATA_RECORD * pmdrec ) const;

	HRESULT HrDeleteMetaData( LPCWSTR pwszPath,
							  DWORD dwPropID,
							  DWORD dwDataType ) const;

	VOID Close();
};

//	Initialize the metabase
//
BOOL FMDInitialize();

//	Deinit the metabase
//
VOID MDDeinitialize();

//	Fetch the metadata for a specific URI.
//
//	Note: If you need data for the request URI you
//	should use the MetaData() accessor on the IEcb
//	instead of this function.
//
HRESULT HrMDGetData( const IEcb& ecb,
					 LPCWSTR pwszURI,
					 IMDData ** ppMDData );

//	Fetch the metadata for a specific metabase path
//	which may not exist -- e.g. paths to objects
//	whose metadata is entirely inherited.
//
//	When fetching metadata for a path that may not
//	exist pszMDPathOpen must be set to a path that
//	is known to exist and is a proper prefix of
//	the desired access path -- typically the path
//	to the vroot.
//
HRESULT HrMDGetData( const IEcb& ecb,
					 LPCWSTR pwszMDPathAccess,
					 LPCWSTR pwszMDPathOpen,
					 IMDData ** ppMDData );

//	Get metabase change number
//
DWORD DwMDChangeNumber();

//	Open a metadata handle
//
HRESULT HrMDOpenMetaObject( LPCWSTR pwszMDPath,
							DWORD dwAccess,
							DWORD dwMsecTimeout,
							CMDObjectHandle * pmdoh );

HRESULT HrMDOpenLowestNodeMetaObject( LPWSTR pwszMDPath,
									  DWORD dwAccess,
									  LPWSTR * ppwszMDPath,
									  CMDObjectHandle * pmdoh );

HRESULT
HrMDIsAuthorViaFrontPageNeeded(const IEcb& ecb,
							   LPCWSTR pwszURI,
							   BOOL * pfFrontPageWeb);

//	------------------------------------------------------------------------
//
//	FParseMDData()
//
//	Parses a comma-delimited metadata string into fields.  Any whitespace
//	around the delimiters is considered insignificant and removed.
//
//	Returns TRUE if the data parsed into the expected number of fields
//	and FALSE otherwise.
//
//	Pointers to the parsed are returned in rgpszFields.  If a string
//	parses into fewer than the expected number of fields, NULLs are
//	returned for all of the fields beyond the last one parsed.
//
//	If a string parses into the expected number of fields then
//	the last field is always just the remainder of the string beyond
//	the second to last field, regardless whether the string could be
//	parsed into additional fields.  For example "  foo , bar ,  baz  "
//	parses into three fields as "foo", "bar" and "baz", but parses
//	into two fields as "foo" and "bar ,  baz"
//
//	The total number of characters in pszData, including the null
//	terminator, is also returned in *pcchzData.
//
//	Note: this function MODIFIES pszData.
//
BOOL
FParseMDData( LPWSTR pwszData,
			  LPWSTR rgpwszFields[],
			  UINT cFields,
			  UINT * pcchData );

//	------------------------------------------------------------------------
//
//	FCopyStringToBuf()
//
//	Copies a string (pszSource) to a buffer (pszBuf) if the size of the
//	buffer is large enough to hold the string.  The size of the string is
//	returned in *pchBuf.  A return value of TRUE indicates that the buffer
//	was large enough and string was successfully copied.
//
//	This function is primarily intended for use in copying string return
//	values from IMDData accessors into buffers so that they can be used
//	after the IMDData object from which they were obtained is gone.
//
inline BOOL
FCopyStringToBuf( LPCWSTR pwszSrc,
				  LPWSTR pwszBuf,
				  UINT * pcchBuf )
{
	Assert( pwszSrc );
	Assert( pwszBuf );
	Assert( pcchBuf );

	UINT cchSrc = static_cast<UINT>(wcslen(pwszSrc) + 1);

	//
	//	If the supplied buffer isn't big enough to copy the
	//	string type into, then fill in the required size and
	//	return an error.
	//
	if ( *pcchBuf < cchSrc )
	{
		*pcchBuf = cchSrc;
		return FALSE;
	}

	//
	//	The buffer was large enough so copy the string.
	//
	memcpy( pwszBuf, pwszSrc, cchSrc * sizeof(WCHAR) );
	*pcchBuf = cchSrc;
	return TRUE;
}

//	Metabase operations -------------------------------------------------------
//
//	class CMetaOp -------------------------------------------------------------
//
class CMetaOp
{
	//	Enumeration of metabase nodes
	//
	enum { CCH_BUFFER_SIZE = 4096 };
	SCODE __fastcall ScEnumOp (LPWSTR pwszMetaPath, UINT cch);

	//	non-implemented
	//
	CMetaOp& operator=(const CMetaOp&);
	CMetaOp(const CMetaOp&);

protected:

	const IEcb * m_pecb;
	CMDObjectHandle	m_mdoh;
	DWORD		m_dwId;
	DWORD		m_dwType;
	LPCWSTR		m_pwszMetaPath;
	BOOL		m_fWrite;

	//	Subclass' operation to perform for each node where
	//	a value is explicitly set.
	//
	virtual SCODE __fastcall ScOp(LPCWSTR pwszMbPath, UINT cch) = 0;

public:

	virtual ~CMetaOp() {}

	CMetaOp ( const IEcb * pecb, LPCWSTR pwszPath, DWORD dwID, DWORD dwType, BOOL fWrite)
			: m_pecb(pecb),
			  m_mdoh(*pecb),
			  m_dwId(dwID),
			  m_dwType(dwType),
			  m_pwszMetaPath(pwszPath),
			  m_fWrite(fWrite)
	{
	}

	//	Interface use by MOVE/COPY, etc.
	//
	//	NOTE: these operations do not go through the metabase cache
	//	for a very specific reason -- the resource is either being
	//	moved, copied or deleted.  Just because an item was a part
	//	of a large tree operation, does not mean it needs to be added
	//	into the cache.
	//
	SCODE __fastcall ScMetaOp();
};

#endif	// _DAVMB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\davimpl.h ===
#ifndef _DAVIMPL_H_
#define _DAVIMPL_H_

//	++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//
//	DAVIMPL.H
//
//		Header for DAV implementation methods interface
//
//	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
//

#include <objbase.h>	//	For common C/C++ interface macros

#include <httpext.h>
#include <ex\oldhack.h> //  This file is so that we build as there are some definitions in old headers that are not in new. Will go away.

#include <autoptr.h>	//	For CMTRefCounted base class
#include <ecb.h>
#include <request.h>
#include <response.h>
#include <sgstruct.h>
#include <vrenum.h>
#include <davsc.h>
#include <body.h>		//	For async stream interfaces, CRefHandle, etc.
#include <sz.h>
#include <ex\calcom.h>
#include <url.h>
#include <ex\xml.h>

//	Resource types ------------------------------------------------------------
//
typedef enum {

	RT_NULL = 0,
	RT_DOCUMENT,
	RT_STRUCTURED_DOCUMENT,
	RT_COLLECTION

} RESOURCE_TYPE;

enum { MAX_VERSION_LEN = 20*4 };

//	Access control scope ------------------------------------------------------
//
//	The acl scope is used when asking the metabase for the IIS access applied
//	to a specific resource.
//
//	The following enum actually represents bit flags.
//
//		STRICT:		resource access must have all requested access bits
//		LOOSE:		resource access must have at least one requested access bit
//		INHERIT:	resource access may be inherited from parent.
//
enum {

	ACS_STRICT	= 0x00,
	ACS_LOOSE	= 0x01,
	ACS_INHERIT	= 0x10
};

//	Implementation-defined items ----------------------------------------------
//
#include <impldef.h>
#include <implstub.h>

//	Parser-Defined items ------------------------------------------------------
//

//	Content-type --------------------------------------------------------------
//
//	Content-type is stored in the metabase for HTTPEXT.  Each resource, if it
//	has a content-type that is different than the default content-type, is store
//	explicitly on the resource.  If the content-type is the default value, then
//	there is no explicit setting in the metabase.  Instead, the mapping of a
//	resource's extension to the default content-type is stored.
//
BOOL FGetContentTypeFromURI(
	/* [in] */ const IEcb& ecb,
	/* [in] */ LPCWSTR pwszUrl,
	/* [i/o] */ LPWSTR pwszContentType,
	/* [i/o] */ UINT *  pcchContentType,
	/* [i/o] */ BOOL *  pfIsGlobalMapping = NULL );

BOOL FGetContentTypeFromPath( const IEcb& ecb,
							  LPCWSTR pwszPath,
							  LPWSTR  pwszContentType,
							  UINT *  pcchContentType );

SCODE ScSetContentType(
	/* [in] */ const IEcb& ecb,
	/* [in] */ LPCWSTR pwszUrl,
	/* [in] */ LPCWSTR pwszContentType );

//	Method ID's ---------------------------------------------------------------
//
//	Each DAV method has its own ID for use in scriptmap inclusion lists.
//
typedef enum {

	MID_UNKNOWN = -1,
	MID_OPTIONS,
	MID_GET,
	MID_HEAD,
	MID_PUT,
	MID_POST,
	MID_DELETE,
	MID_MOVE,
	MID_COPY,
	MID_MKCOL,
	MID_PROPFIND,
	MID_PROPPATCH,
	MID_SEARCH,
	MID_LOCK,
	MID_UNLOCK,
	MID_SUBSCRIBE,
	MID_UNSUBSCRIBE,
	MID_POLL,
	MID_BATCHDELETE,
	MID_BATCHCOPY,
	MID_BATCHMOVE,
	MID_BATCHPROPFIND,
	MID_BATCHPROPPATCH,
	MID_X_MS_ENUMATTS
} METHOD_ID;

//	Note: The method name handed to us from IIS is skinny, and there is no
//	real reason why it should be widened for this call.  However, when the
//	scriptmap metabase cache goes wide, we may want to do something smarter
//	here.
//
METHOD_ID MidMethod (LPCSTR pszMethod);
METHOD_ID MidMethod (LPCWSTR pwszMethod);

//	Custom error suberrors ----------------------------------------------------
//
typedef enum {

	//	Default
	//
	CSE_NONE = 0,

	//	401
	//
	CSE_401_LOGON_FAILED = 1,	// "Logon Failed"
	CSE_401_SERVER_CONFIG = 2,	// "Logon Failed due to server configuration"
	CSE_401_ACL = 3,			// "Unauthorized access due to ACL on resource"
	CSE_401_FILTER = 4,			// "Authorization failed by filter"
	CSE_401_ISAPI = 5,			// "Authorization failed by ISAPI/CGI app"

	//	403
	//
	CSE_403_EXECUTE = 1,			// "Execute Access Forbidden"
	CSE_403_READ = 2,				// "Read Access Forbidden"
	CSE_403_WRITE = 3,				// "Write Access Forbidden"
	CSE_403_SSL = 4,				// "SSL Required"
	CSE_403_SSL_128 = 5,			// "SSL 128 Required"
	CSE_403_IP = 6,					// "IP Address Rejected"
	CSE_403_CERT_REQUIRED = 7,		// "Client Certificate Required"
	CSE_403_SITE = 8,				// "Site Access Denied"
	CSE_403_TOO_MANY_USERS = 9,		// "Too many users are connected"
	CSE_403_INVALID_CONFIG = 10,	// "Invalid configuration"
	CSE_403_PASSWORD_CHANGE = 11,	// "Password change"
	CSE_403_MAPPER = 12,			// "Mapper access denied"
	CSE_403_CERT_REVOKED = 13,		// "Client certificate revoked"
	CSE_403_FOURTEEN,				// There is no suberror for this one.
	CSE_403_CALS_EXCEEDED = 15,		// "Client Access Licenses exceeded"
	CSE_403_CERT_INVALID = 16,		// "Client certificate untrusted or invalid"
	CSE_403_CERT_EXPIRED = 17,		// "Client certificate expired"

	//	500
	//
	CSE_500_SHUTDOWN = 11,			// "Server shutting down"
	CSE_500_RESTART = 12,			// "Application restarting"
	CSE_500_TOO_BUSY = 13,			// "Server too busy"
	CSE_500_INVALID_APP = 14,		// "Invalid application"
	CSE_500_GLOBAL_ASA = 15,		// "Requests for global.asa not allowed"
	CSE_500_ASP_ERROR = 100,		// "ASP error"
};

//	========================================================================
//
//	CLASS IAsyncIStreamObserver
//
//	Interface to async I/O completion mechanism for IStreams capable of
//	returning E_PENDING from IStream::Read() and IStream::CopyTo().
//	A client would typically associate an IAsyncIStreamObserver with
//	an IStream when creating the latter.  When one of the IStream calls
//	returns E_PENDING, the IAsyncIStreamObserver will be called when
//	the pending operation completes.
//
class IAsyncIStreamObserver
{
	//	NOT IMPLEMENTED
	//
	IAsyncIStreamObserver& operator=( const IAsyncIStreamObserver& );

public:
	//	CREATORS
	//
	virtual ~IAsyncIStreamObserver() = 0;

	//	MANIPULATORS
	//
	virtual VOID AsyncIOComplete() = 0;
};

//	========================================================================
//
//	DAV IMPL UTILITY CLASS
//
//		Utility class for use by the DAV impl.
//		ALL methods here are inlined on retail builds.  DON'T ADD NON-TRIVIAL METHODS!
//
class IBodyPart;

class IMethUtilBase : public CMTRefCounted
{
private:
	// NOT IMPLEMENTED
	IMethUtilBase(const IMethUtilBase&);
	IMethUtilBase& operator=(const IMethUtilBase&);
protected:
	auto_ref_ptr<IEcbBase> m_pecb;
	auto_ref_ptr<IResponseBase> m_presponse;
	IMethUtilBase(IEcbBase& ecb, IResponseBase& response) :
		m_pecb(&ecb),
		m_presponse(&response)
	{
	}
public:
	void AddResponseText( UINT	cbText,
						  LPCSTR pszText )
	{
		m_presponse->AddBodyText(cbText, pszText);
	}

	void AddResponseText( UINT	cchText,
						  LPCWSTR pwszText )
	{
		m_presponse->AddBodyText(cchText, pwszText);
	}

	void AddResponseFile( const auto_ref_handle& hf,
						  UINT64 ib64 = 0,
						  UINT64 cb64 = 0xFFFFFFFFFFFFFFFF )
	{
		m_presponse->AddBodyFile(hf, ib64, cb64);
	}
	ULONG LcidAccepted() const			{ return m_pecb->LcidAccepted(); }
	VOID  SetLcidAccepted(LCID lcid) 	{ m_pecb->SetLcidAccepted(lcid); }
	LPCWSTR LpwszRequestUrl() const		{ return m_pecb->LpwszRequestUrl(); }
	BOOL FSsl() const					{ return m_pecb->FSsl(); }
	BOOL FFrontEndSecured() const		{ return m_pecb->FFrontEndSecured(); }
	UINT CchUrlPrefix( LPCSTR * ppszPrefix ) const
	{
		return m_pecb->CchUrlPrefix( ppszPrefix );
	}
	UINT CchServerName( LPCSTR * ppszServer ) const
	{
		return m_pecb->CchGetServerName( ppszServer );
	}
	UINT CchGetVirtualRootW( LPCWSTR * ppwszVroot ) const
	{
		return m_pecb->CchGetVirtualRootW(ppwszVroot);
	}
	UINT CchGetMatchingPathW( LPCWSTR * ppwszVroot ) const
	{
		return m_pecb->CchGetMatchingPathW(ppwszVroot);
	}
	LPCWSTR LpwszPathTranslated() const	{ return m_pecb->LpwszPathTranslated(); }
	SCODE ScUrlFromStoragePath( LPCWSTR pwszPath,
								LPWSTR pwszUrl,
								UINT* pcch )
	{
		return ::ScUrlFromStoragePath( *m_pecb,
									   pwszPath,
									   pwszUrl,
									   pcch );
	}

	//	Instance data lookup --------------------------------------------------
	//
	CInstData& InstData() const
	{
		return m_pecb->InstData();
	}

	//$NOTE
	//$REVIEW
	// I had to pull HitUser into here as pure virtual because we needed access
	// to it in CWMRenderer class (which has IMethBaseUtil * as a member) in
	// order to do a Revert.  This was the only way to get davex and the forms
	// stuff to build without touching lots core headers this late in the Beta3
	// game.  We should revisit this in RC1 to try and remove this from the vtable.
	// (9/1/99 - russsi)
	//
	virtual	HANDLE	HitUser() const = 0;

	virtual LPCSTR	LpszServerName() const = 0;

	virtual	BOOL 	FAuthenticated() const = 0;

};

class CMethUtil : public IMethUtilBase
{
private:
	auto_ref_ptr<IEcb> m_pecb;
	auto_ref_ptr<IRequest> m_prequest;
	auto_ref_ptr<IResponse> m_presponse;

	//	Method ID
	//
	METHOD_ID m_mid;

	//	Translation
	//
	enum { TRANS_UNKNOWN = -1, TRANS_FALSE, TRANS_TRUE };
	mutable LONG m_lTrans;

	//	Overwrite
	//
	mutable LONG m_lOverwrite;

	//	Depth
	//
	//	The values for this member are defined in EX\CALCOM.H
	//
	mutable LONG m_lDepth;

	//	Destination url
	//
	mutable auto_heap_ptr<WCHAR> m_pwszDestinationUrl;
	mutable auto_heap_ptr<WCHAR> m_pwszDestinationPath;
	mutable UINT m_cchDestinationPath;
	mutable auto_ref_ptr<CVRoot> m_pcvrDestination;

	//	CREATORS
	//
	//	Only create this object through the construction function!
	//
	CMethUtil( IEcb& ecb, IRequest& request, IResponse& response, METHOD_ID mid ) :
			IMethUtilBase(ecb,response),
			m_pecb(&ecb),
			m_prequest(&request),
			m_presponse(&response),
			m_mid(mid),
			m_lTrans(TRANS_UNKNOWN),
			m_lOverwrite(OVERWRITE_UNKNOWN),
			m_lDepth(DEPTH_UNKNOWN),
			m_cchDestinationPath(0)
	{ }

	//	NOT IMPLEMENTED
	//
	CMethUtil( const CMethUtil& );
	CMethUtil& operator=( const CMethUtil& );

public:

	//	CREATORS
	//
	//	NOTE: Virtual destructor already provided by parent CMTRefCounted.
	//
	static CMethUtil * NewMethUtil( IEcb& ecb,
									IRequest& request,
									IResponse& response,
									METHOD_ID mid )
	{
		return new CMethUtil( ecb, request, response, mid );
	}

	//	Get the pointer to ECB so the we could pass it to the  objects that
	//	will need to query it for data. This object holds a ref on ECB, so
	//	make sure it is used only as long as this object is alive.
	//
	const IEcb * GetEcb() { return m_pecb.get(); }

	//	REQUEST ACCESSORS -----------------------------------------------------
	//
	//	Common header evaluation ----------------------------------------------
	//
	//	FTranslate():
	//
	//		Gets the value of the translate header.
	//
	BOOL FTranslated () const
	{
		//	If we don't have a value yet...
		//
		if (TRANS_UNKNOWN == m_lTrans)
		{
			//	Translation is expected when:
			//
			//		The "translate" header is not present or
			//		The "translate" header has a value other than "f" or "F"
			//
			//	NOTE: The draft says the valid values are "t" or "f".	So, we
			//	are draft compliant if we check only the first char.  This way
			//	we are faster and/or more flexible.
			//
			//	BTW: this is also an IIS-approved way to check boolean strings.
			//	-- BeckyAn (BA:js)
			//
			LPCSTR psz = m_prequest->LpszGetHeader (gc_szTranslate);
			if (!psz || (*psz != 'f' && *psz != 'F'))
				m_lTrans = TRANS_TRUE;
			else
				m_lTrans = TRANS_FALSE;
		}
		return (TRANS_TRUE == m_lTrans);
	}

	//	LOverwrite():
	//
	//		Gets the enumerated value of the Overwrite/Allow-Rename headers.
	//
	LONG LOverwrite () const
	{
		//	If we don't have a value yet...
		//
		if (OVERWRITE_UNKNOWN == m_lOverwrite)
		{
			//	Overwrite is expected when:
			//
			//		The "overwrite" header has a value of "t"
			//
			//	NOTE: The draft says the valid values are "t" or "f".	So, we
			//	are draft compliant if we check only the first char.  This way
			//	we are faster and/or more flexible.
			//
			//	BTW: this is also an IIS-approved way to check boolean strings.
			//	-- BeckyAn (BA:js)
			//
			//	NOTE also: the default value if there is no Overwrite: header
			//	is TRUE -- DO overwrite. Allow-rename if "f", when header is
			//	absent.
			//
			LPCSTR pszOverWrite = m_prequest->LpszGetHeader (gc_szOverwrite);
			if ((!pszOverWrite) || (*pszOverWrite == 't' || *pszOverWrite == 'T'))
			{
				m_lOverwrite |= OVERWRITE_YES;
			}
			LPCSTR pszAllowRename = m_prequest->LpszGetHeader (gc_szAllowRename);
			if (pszAllowRename && (*pszAllowRename == 't' || *pszAllowRename == 'T'))
				m_lOverwrite |= OVERWRITE_RENAME;
		}
		return (m_lOverwrite);
	}

	//	LDepth ():
	//
	//		Returns an enumerated value identifying the contents of the
	//		depth header.
	//
	//	The values for the enumeration are defined in EX\CALCOM.H
	//
	LONG __fastcall LDepth (LONG lDefault) const
	{
		//	If we do not have a value yet...
		//
		if (DEPTH_UNKNOWN == m_lDepth)
		{
			//	Depth can have several values:
			//
			//		DEPTH_ZERO				corresponds to "0"
			//		DEPTH_ONE				corresponds to "1"
			//		DEPTH_INFINITY			corresponds to "Infinity"
			//		DEPTH_ONE_NOROOT		corresponds to "1,NoRoot"
			//		DEPTH_INFINITY_NOROOT	corresponds to "Infinty,NoRoot"
			//
			//	In the case there is no depth header specified, there
			//	is a default that applies to each method.  The default
			//	is not the same from method to method, so the caller
			//	must pass in a default value.
			//
			LPCSTR psz = m_prequest->LpszGetHeader (gc_szDepth);

			if (NULL == psz)
			{
				m_lDepth = lDefault;
			}
			else
			{
				switch (*psz)
				{
					case '0':

						if (!_stricmp (psz, gc_sz0))
							m_lDepth = DEPTH_ZERO;
						break;

					case '1':

						if (!_stricmp(psz, gc_sz1))
							m_lDepth = DEPTH_ONE;
						else if (!_stricmp(psz, gc_sz1NoRoot))
							m_lDepth = DEPTH_ONE_NOROOT;
						break;

					case 'i':
					case 'I':

						if (!_stricmp(psz, gc_szInfinity))
							m_lDepth = DEPTH_INFINITY;
						else if (!_stricmp(psz, gc_szInfinityNoRoot))
							m_lDepth = DEPTH_INFINITY_NOROOT;
						break;
				}
			}
		}
		return m_lDepth;
	}

	//	FBrief():
	//
	//		Gets the value of the Brief header.
	//
	BOOL FBrief () const { return m_pecb->FBrief(); }

	//	FIsOffice9Request()
	//		Finds out if the request is comming from Rosebud as shipped
	//		in Office9.
	//
	BOOL FIsOffice9Request () const
	{
		//	Get the User-Agent header
		//
		LPCSTR pszUserAgent = m_prequest->LpszGetHeader(gc_szUser_Agent);

		//	If there is User-Agent header search for the product token of Office9
		//
		if (pszUserAgent)
		{
			LPCSTR pszProductToken = strstr(pszUserAgent, gc_szOffice9UserAgent);

			//	If we have found the Office9 product token, and it is the
			//	last token in the string, then the request is from Office9.
			//
			//	Important Note: Office9's entire User-Agent is "Microsoft Data
			//	Access Internet Publishing Provider DAV".  We want to make sure
			//	and NOT match "Microsoft Data Access Internet Publishing Provider
			//	DAV 1.1 (for instance).  So we require the token on the end of
			//	the string.  NOTE: Exprox currently adds itself BEFORE any
			//	User-Agent string, so we're okay here.
			//
			if (pszProductToken &&
				((pszProductToken == pszUserAgent) || FIsWhiteSpace(pszProductToken - 1)) &&
				('\0' == (pszProductToken[gc_cchOffice9UserAgent])))
			{
				return TRUE;
			}
		}

		return FALSE;
	}

	//	FIsRosebudNT5Request()
	//		Finds out if the request is comming from Rosebud as shipped
	//		in NT5.
	//
	BOOL FIsRosebudNT5Request () const
	{
		//	Get the User-Agent header
		//
		LPCSTR pszUserAgent = m_prequest->LpszGetHeader(gc_szUser_Agent);

		//	If there is User-Agent header search for the product token of Rosebud-NT5.
		//
		if (pszUserAgent)
		{
			LPCSTR pszProductToken = strstr(pszUserAgent, gc_szRosebudNT5UserAgent);

			//	If we have found the Rosebud product token, and it is the
			//	last token in the string, then the request is from Rosebud.
			//
			//	Important Note: Rosebud-NT5's entire User-Agent is "Microsoft Data
			//	Access Internet Publishing Provider DAV 1.1".  We want to make sure
			//	and NOT match "Microsoft Data Access Internet Publishing Provider
			//	DAV 1.1 refresh" (for instance).  So we require the token on the end of
			//	the string.  NOTE: Exprox currently adds itself BEFORE any
			//	User-Agent string, so we're okay here.
			//
			if (pszProductToken &&
				((pszProductToken == pszUserAgent) || FIsWhiteSpace(pszProductToken - 1)) &&
				('\0' == (pszProductToken[gc_cchRosebudNT5UserAgent])))
			{
				return TRUE;
			}
		}

		return FALSE;
	}

	//	Request item access ---------------------------------------------------
	//
	HANDLE HitUser() const				{ return m_pecb->HitUser(); }
	LPCSTR LpszMethod() const			{ return m_pecb->LpszMethod(); }
	LPCWSTR LpwszMethod() const			{ return m_pecb->LpwszMethod(); }
	METHOD_ID MidMethod() const			{ return m_mid; }
	LPCSTR LpszQueryString() const		{ return m_pecb->LpszQueryString(); }
	LPCSTR LpszServerName() const
	{
		LPCSTR pszServer;
		(void) m_pecb->CchGetServerName(&pszServer);
		return pszServer;
	}
	LPCSTR LpszVersion() const			{ return m_pecb->LpszVersion(); }
	BOOL FAuthenticated() const			{ return m_pecb->FAuthenticated(); }

	BOOL FGetServerVariable(LPCSTR	pszName,
							LPSTR	pszValue,
							DWORD *	pcbValue) const
		{ return m_pecb->FGetServerVariable(pszName, pszValue, pcbValue); }

	DWORD CbTotalRequestBytes() const 		{ return m_pecb->CbTotalBytes(); }
	DWORD CbAvailableRequestBytes() const 	{ return m_pecb->CbAvailable(); }

	//	Destination url access ------------------------------------------------
	//
	SCODE __fastcall ScGetDestination( LPCWSTR* ppwszUrl,
									   LPCWSTR* ppwszPath,
									   UINT* pcchPath,
									   CVRoot** ppcvr = NULL) const;

	//	Uncommon header access wide -------------------------------------------
	//
	LPCWSTR LpwszGetRequestHeader( LPCSTR pszName, BOOL fUrlConversion ) const
	{
		//	Assert that this is not one of the common headers handled above
		//
		Assert (_stricmp (gc_szTranslate, pszName));
		Assert (_stricmp (gc_szOverwrite, pszName));
		Assert (_stricmp (gc_szDepth, pszName));
		Assert (_stricmp (gc_szDestination, pszName));

		return m_prequest->LpwszGetHeader(pszName, fUrlConversion);
	}

	//	IIS Access ------------------------------------------------------------
	//
	SCODE ScIISAccess( LPCWSTR pwszURI,
					   DWORD dwAccessRequested,
					   DWORD* pdwAccessOut = NULL,
					   UINT mode = ACS_INHERIT ) const;

	//	Utility function to tell whether the scriptmap has an
	//	applicable entry for a given URI and access.
	//
	BOOL FInScriptMap( LPCWSTR pwszURI,
					   DWORD dwAccess,
					   BOOL * pfCGI = NULL,
					   SCODE * pscMatch = NULL) const;

	//	Child ISAPI invocation ------------------------------------------------
	//
	//	fForward = FALSE means just check if there's a scriptmap entry
	//	fCheckISAPIAccess means do extra ACL checking (workaround the ASP access bug)
	//	fKeepQueryString should only be set to FALSE on default doc processing
	//	pszQueryPrefix allows the query string to be prefixed with new data
	//	fIgnoreTFAccess if set to TRUE will ignore the access bits checking in translate: f case,
	//				  is handy when the acces bits are to be ignored by security checking functions
	//				  and function is used solely to redirect to the child ISAPI.
	//				  Example: we have real urls, constructed both from request URL
	//				  and relative URL parts from XML body (like B* methods). The object specified: t
	//				  by the request URL might need to be redirected to child ISAPI in the translate
	//				  case, while actual (constructed) URL-s might look like:
	//
	//						/exchange/user1/Inbox.asp/message.eml (where message.eml was relative part)
	//
	//				  if we do not disable the security checking on the request URL in translate: f case
	//				  we might be failed out up front in case for example script source access was disabled
	//				  and it turned to be that directory was named INBOX.ASP.
	//				  NOTE: of course later the security is being checked on each constructed URL separately,
	//						that is why we do not open the security hole.
	//
	//	fDoNotForward if set to TRUE instead of forwarding request to child ISAPI it will return bad gateway,
	//				  which is necessary in the case there would be an attempt to execute child ISAPI on the
	//				  URL that is a construct of the request URL and the relative URL that comes in the request
	//				  body (like in B* methods)
	//
	SCODE ScApplyChildISAPI( LPCWSTR pwszURI,
							 DWORD  dwAccess,
							 BOOL	fCheckISAPIAccess = FALSE,
							 LPBYTE pbSD = NULL,
							 BOOL	fKeepQueryString = TRUE,
							 BOOL	fIgnoreTFAccess = FALSE,
							 BOOL	fDoNotForward = FALSE,
						     BOOL	fCheckImpl = TRUE) const;

	//	Apply child ISAPI if necessary, if not, verify if desired access
	//	is granted
	//
	SCODE ScIISCheck ( LPCWSTR pwszURI,
					   DWORD dwDesired = 0,
					   BOOL	fCheckISAPIAccess = FALSE,
					   LPBYTE pbSD = NULL,
					   BOOL	fDoNotForward = FALSE,
					   BOOL fCheckImpl = TRUE,
					   DWORD * pdwAccessOut = NULL) const;

	//	Move/Copy/Delete access
	//
	SCODE ScCheckMoveCopyDeleteAccess (
		/* [in] */ LPCWSTR pwszUrl,
		/* [in] */ CVRoot* pcvr,
		/* [in] */ BOOL fDirectory,
		/* [in] */ BOOL fCheckScriptmaps,
		/* [in] */ DWORD dwAccess);

	//	Url parsing/construction ----------------------------------------------
	//
	BOOL __fastcall FIsVRoot (LPCWSTR pwszURI);

	//	Exchange and FS uses different URL to path mappers.
	//
	SCODE ScStoragePathFromUrl( LPCWSTR pwszUrl,
								LPWSTR pwszPath,
								UINT * pcch ) const
	{
		return ::ScStoragePathFromUrl(
					*m_pecb,
					pwszUrl,
					pwszPath,
					pcch );
	}

	//	Construct the redirect url given the server name
	//
	SCODE ScConstructRedirectUrl( BOOL fNeedSlash,
								  LPSTR * ppszUrl,
								  LPCWSTR pwszServer = NULL ) const
	{
		return ::ScConstructRedirectUrl( *m_pecb,
										 fNeedSlash,
										 ppszUrl,
										 pwszServer );
	}

	SCODE ScStripAndCheckHttpPrefix( LPCWSTR * ppwszUrl ) const
	{
		return ::ScStripAndCheckHttpPrefix( *m_pecb,
											ppwszUrl );
	}


	//	Fetch the metadata for the request URI
	//
	IMDData& MetaData() const
	{
		return m_pecb->MetaData();
	}

	//	Fetch the metadata for an aribtrary URI.
	//	Note: use the MetaData() accessor above
	//	to get the metadata for the request URI.
	//
	HRESULT HrMDGetData( LPCWSTR pwszURI,
						 IMDData ** ppMDData )
	{
		Assert(m_pecb.get());
		return ::HrMDGetData( *m_pecb,
							  pwszURI,
							  ppMDData );
	}

	HRESULT HrMDGetData( LPCWSTR pwszMDPathAccess,
						 LPCWSTR pwszMDPathOpen,
						 IMDData ** ppMDData )
	{
		Assert(m_pecb.get());
		return ::HrMDGetData( *m_pecb,
							  pwszMDPathAccess,
							  pwszMDPathOpen,
							  ppMDData );
	}

	HRESULT HrMDIsAuthorViaFrontPageNeeded( BOOL * pfFrontPageWeb ) const
	{
		Assert( pfFrontPageWeb );

		return ::HrMDIsAuthorViaFrontPageNeeded(*m_pecb,
												m_pecb->PwszMDPathVroot(),
												pfFrontPageWeb);
	}

	BOOL FGetContentType( LPCWSTR  pwszURI,
						  LPWSTR   pwszContentType,
						  UINT *  pcchContentType ) const
	{
		return ::FGetContentTypeFromURI( *m_pecb,
										 pwszURI,
										 pwszContentType,
										 pcchContentType );
	}

	SCODE ScSetContentType( LPCWSTR pwszURI,
							LPCWSTR pwszContentType )
	{
		return ::ScSetContentType( *m_pecb,
								   pwszURI,
								   pwszContentType );
	}

	//	Url and child virtual directories -------------------------------------
	//
	SCODE ScFindChildVRoots( LPCWSTR pwszUri,
							 ChainedStringBuffer<WCHAR>& sb,
							 CVRList& vrl )
	{
		//	Get the wide metapath, and make sure the URL is
		//	stripped before we call into the MDPath processing
		//
		Assert (pwszUri == PwszUrlStrippedOfPrefix (pwszUri));
		UINT cb = ::CbMDPathW(*m_pecb, pwszUri);
		CStackBuffer<WCHAR,MAX_PATH> pwszMetaPath;
		if (NULL == pwszMetaPath.resize(cb))
			return E_OUTOFMEMORY;

		//	Find the vroot
		//
		MDPathFromURIW (*m_pecb, pwszUri, pwszMetaPath.get());
		return CChildVRCache::ScFindChildren( *m_pecb, pwszMetaPath.get(), sb, vrl );
	}

	BOOL FGetChildVRoot( LPCWSTR pwszMetaPath, auto_ref_ptr<CVRoot>& cvr )
	{
		return CChildVRCache::FFindVroot( *m_pecb, pwszMetaPath, cvr );
	}

	BOOL FFindVRootFromUrl( LPCWSTR pwszUri, auto_ref_ptr<CVRoot>& cvr )
	{
		//	Get the wide metapath, and make sure the URL is
		//	stripped before we call into the MDPath processing
		//
		Assert (pwszUri == PwszUrlStrippedOfPrefix (pwszUri));
		UINT cb = ::CbMDPathW(*m_pecb, pwszUri);
		CStackBuffer<WCHAR,MAX_PATH> pwszMetaPath(cb);
		if (NULL == pwszMetaPath.resize(cb))
			return FALSE;

		//	Build the path and go...
		//
		MDPathFromURIW (*m_pecb, pwszUri, pwszMetaPath.get());
		_wcslwr (pwszMetaPath.get());

		//	If the last char of the metabase path is a slash, trim
		//	it.
		//
		cb = static_cast<UINT>(wcslen(pwszMetaPath.get()));
		if (L'/' == pwszMetaPath[cb - 1])
			pwszMetaPath[cb - 1] = L'\0';

		//	Find the vroot
		//
		return CChildVRCache::FFindVroot( *m_pecb, pwszMetaPath.get(), cvr );
	}

	//	Exception handler -----------------------------------------------------
	//
	//	Impls must call this function whenever they catch an exception on
	//	a thread other than the thread on which the request initially
	//	executed.  This call causes a 500 Server Error response to be sent
	//	if no other response is already in the process of being sent (only
	//	a problem for chunked responses).  It also ensures that the
	//	EXTENSION_CONTROL_BLOCK from IIS will be properly cleaned up
	//	regardless whether the pmu or any other object gets leaked as a result
	//	of the exception.  This last function keeps IIS from hanging on
	//	shutdown.
	//
	void HandleException()
	{
		//
		//	Just forward the exception handling to the ECB and hope it works.
		//	If it doesn't then there is nothing we can do about it -- we
		//	may leak the ECB which would cause IIS to hang on shutdown.
		//
		(VOID) m_pecb->HSEHandleException();
	}

	//	Async error response handler ------------------------------------------
	//
	//	Used to handle non-exception asynchronous error responses.  The main
	//	distinction between the exception and non-exception case is that in
	//	the exception case we force a cleanup of the ECB, but here we don't.
	//	Also, the exception case is hardwired to 500 Internal Server Error,
	//	but this function can be used to send any 500 level error (e.g. a
	//	503 Service Unavailable).
	//
	VOID SendAsyncErrorResponse( DWORD dwStatusCode,
								 LPCSTR pszBody = NULL,
								 DWORD cchzBody = 0,
								 LPCSTR pszStatusDescription = NULL,
								 DWORD cchzStatusDescription = 0 )
	{
		m_pecb->SendAsyncErrorResponse( dwStatusCode,
										pszBody,
										cchzBody,
										pszStatusDescription,
										cchzStatusDescription );
	}

	//	Request body access ---------------------------------------------------
	//
	BOOL FExistsRequestBody() const
	{
		return m_prequest->FExistsBody();
	}

	IStream * GetRequestBodyIStream( IAsyncIStreamObserver& obs ) const
	{
		return m_prequest->GetBodyIStream(obs);
	}

	VOID AsyncPersistRequestBody( IAsyncStream& stm,
								  IAsyncPersistObserver& obs ) const
	{
		m_prequest->AsyncImplPersistBody( stm, obs );
	}

	//	Response manipulators -------------------------------------------------
	//
	SCODE ScRedirect( LPCSTR pszURI )
	{
		return m_presponse->ScRedirect(pszURI);
	}

	void RestartResponse()
	{
		m_presponse->ClearHeaders();
		m_presponse->ClearBody();
	}

	void SupressBody()
	{
		//	This should only be called by an IMPL. in response to a HEAD
		//	request...
		//
		Assert (MID_HEAD == MidMethod());
		m_presponse->SupressBody();
	}

	void SetResponseCode( ULONG		ulCode,
						  LPCSTR	lpszBodyDetail,
						  UINT		uiBodyDetail,
						  UINT		uiCustomSubError = CSE_NONE )
	{
		m_presponse->SetStatus( ulCode,
								NULL,
								uiCustomSubError,
								lpszBodyDetail,
								uiBodyDetail );
	}

	void SetResponseHeader( LPCSTR	pszName,
							LPCSTR	pszValue,
							BOOL	fMultiple = FALSE )
	{
		m_presponse->SetHeader(pszName, pszValue, fMultiple);
	}

	void SetResponseHeader( LPCSTR	pszName,
							LPCWSTR	pwszValue,
							BOOL	fMultiple = FALSE )
	{
		m_presponse->SetHeader(pszName, pwszValue, fMultiple);
	}

	void AddResponseStream( LPSTREAM pstm )
	{
		Assert( !IsBadReadPtr(pstm, sizeof(IStream)) );
		m_presponse->AddBodyStream(*pstm);
	}

	void AddResponseStream( LPSTREAM pstm,
							UINT     ibOffset,
							UINT     cbSize )
	{
		Assert( cbSize > 0 );
		Assert( !IsBadReadPtr(pstm, sizeof(IStream)) );
		m_presponse->AddBodyStream(*pstm, ibOffset, cbSize);
	}

	void AddResponseBodyPart( IBodyPart * pBodyPart )
	{
		m_presponse->AddBodyPart( pBodyPart );
	}

	//	Common response emission routines -------------------------------------
	//
	void __fastcall EmitLocation (	LPCSTR pszHeader,
									LPCWSTR pwszURI,
									BOOL fCollection);

	void __fastcall EmitLastModified (FILETIME * pft);
	void __fastcall EmitCacheControlAndExpires (LPCWSTR pwszUrl);

	SCODE __fastcall ScEmitHeader (LPCWSTR pwszContent,
								   LPCWSTR pwszURI = NULL,
								   FILETIME* pftLastModification = NULL);


	//	Etags -----------------------------------------------------------------
	//
	void __fastcall EmitETag (FILETIME * pft);
	void __fastcall EmitETag (LPCWSTR pwszPath);

	//	Deferred Sends --------------------------------------------------------
	//

	//
	//	DeferResponse()
	//
	//	If called in an implementation method, this function prevents the
	//	default automatic sending of the response upon the implementation
	//	method's return.
	//
	//	After calling this function the implementation must call either
	//	SendPartialResponse() or SendCompleteResponse() to send the response.
	//
	void DeferResponse()			{ m_presponse->Defer(); }

	//
	//	SendPartialResponse()
	//
	//	Starts sending accumulated response data.  The impl is expected to
	//	continue adding response data after calling this function.  The impl
	//	must call SendCompleteResponse() to indicate when it is done adding
	//	response data.
	//
	void SendPartialResponse()		{ m_presponse->SendPartial(); }

	//
	//	SendCompleteResponse()
	//
	//	Starts sending accumulated response data.  Indicates that the impl
	//	is done adding response data.  The impl must not add response data
	//	after calling this function.
	//
	void SendCompleteResponse()		{ m_presponse->SendComplete(); }

	//	Expiration/Cache-Control ----------------------------------------------
	//
	SCODE ScGetExpirationTime( IN		LPCWSTR	pwszURI,
							   IN		LPWSTR	pwszExpire,
							   IN OUT	UINT *	pcch);

	//	Allow header ----------------------------------------------------------
	//
	void SetAllowHeader (RESOURCE_TYPE rt);

	//	Metadata helpers ------------------------------------------------------
	//
	UINT CbMDPathW(LPCWSTR pwszUrl) const { return ::CbMDPathW(*m_pecb, pwszUrl); }
	VOID MDPathFromUrlW( LPCWSTR pwszUrl, LPWSTR pwszMDPath )
	{
		::MDPathFromURIW (*m_pecb, pwszUrl, pwszMDPath);
	}
};

typedef CMethUtil * LPMETHUTIL;
typedef CMethUtil IMethUtil;

//	========================================================================
//
//	STRUCT SImplMethods
//
//	Implementation methods
//
typedef void (DAVMETHOD)( LPMETHUTIL );

extern DAVMETHOD DAVOptions;
extern DAVMETHOD DAVGet;
extern DAVMETHOD DAVHead;
extern DAVMETHOD DAVPut;
extern DAVMETHOD DAVPost;
extern DAVMETHOD DAVDelete;
extern DAVMETHOD DAVMove;
extern DAVMETHOD DAVCopy;
extern DAVMETHOD DAVMkCol;
extern DAVMETHOD DAVPropFind;
extern DAVMETHOD DAVPropPatch;
extern DAVMETHOD DAVSearch;
extern DAVMETHOD DAVLock;
extern DAVMETHOD DAVUnlock;
extern DAVMETHOD DAVSubscribe;
extern DAVMETHOD DAVUnsubscribe;
extern DAVMETHOD DAVPoll;
extern DAVMETHOD DAVBatchDelete;
extern DAVMETHOD DAVBatchMove;
extern DAVMETHOD DAVBatchCopy;
extern DAVMETHOD DAVBatchPropFind;
extern DAVMETHOD DAVBatchPropPatch;
extern DAVMETHOD DAVEnumAtts;
extern DAVMETHOD DAVUnsupported;	// Returns 501 Not Supported

//	========================================================================
//
//	IIS ISAPI Extension interface
//
class CDAVExt
{
public:
	static BOOL FInitializeDll( HINSTANCE, DWORD );
	static BOOL FVersion ( HSE_VERSION_INFO * );
	static BOOL FTerminate();
	static VOID LogECBString( LPEXTENSION_CONTROL_BLOCK, LONG, LPCSTR );
	static DWORD DwMain( LPEXTENSION_CONTROL_BLOCK, BOOL fUseRawUrlMappings = FALSE );
};

//  Potential hToken conversion to handle Universal Security Groups -----------
//	in a mixed mode user domain.
//
SCODE
ScFindOrCreateTokenContext( HANDLE hTokenIn,
					  	    VOID ** ppCtx,
					  	    HANDLE *phTokenOut);
VOID
ReleaseTokenCtx(VOID *pCtx);

//	Map last error to HTTP response code --------------------------------------
//
UINT HscFromLastError (DWORD dwErr);
UINT HscFromHresult (HRESULT hr);
UINT CSEFromHresult (HRESULT hr);

//	Virtual root mappings -----------------------------------------------------
//
BOOL FWchFromHex (LPCWSTR pwsz, WCHAR * pwch);

//	Lock header lookup --------------------------------------------------------
//
BOOL FGetLockTimeout (LPMETHUTIL pmu, DWORD * pdwSeconds, DWORD dwMaxOverride = 0);

//	Content type mappings -----------------------------------------------------
//
SCODE ScIsAcceptable (IMethUtil * pmu, LPCWSTR pwszContent);
SCODE ScIsContentType (IMethUtil * pmu, LPCWSTR pwszType, LPCWSTR pwszTypeAnother = NULL);
inline SCODE ScIsContentTypeXML(IMethUtil * pmu)
{
	return ScIsContentType(pmu, gc_wszText_XML, gc_wszApplication_XML);
}

//	Range header processors ---------------------------------------------------
//
class CRangeParser;

SCODE
ScProcessByteRanges(
	/* [in] */ IMethUtil * pmu,
	/* [in] */ LPCWSTR pwszPath,
	/* [in] */ DWORD dwSizeLow,
	/* [in] */ DWORD dwSizeHigh,
	/* [in] */ CRangeParser * pByteRange );

SCODE
ScProcessByteRangesFromEtagAndTime (
	/* [in] */ IMethUtil * pmu,
	/* [in] */ DWORD dwSizeLow,
	/* [in] */ DWORD dwSizeHigh,
	/* [in] */ CRangeParser *pByteRange,
	/* [in] */ LPCWSTR pwszEtag,
	/* [in] */ FILETIME * pft );

//	Non-Async IO on Top of Overlapped Files -----------------------------------
//
BOOL ReadFromOverlapped (HANDLE hf,
	LPVOID pvBuf,
	ULONG cbToRead,
	ULONG * pcbRead,
	OVERLAPPED * povl);
BOOL WriteToOverlapped (HANDLE hf,
	const void * pvBuf,
	ULONG cbToRead,
	ULONG * pcbRead,
	OVERLAPPED * povl);

//	DAVEX LOCK Support routines -----------------------------------------------
//
class CXMLEmitter;
class CEmitterNode;
SCODE   ScBuildLockDiscovery (CXMLEmitter& emitter,
							  CEmitterNode& en,
							  LPCWSTR wszLockToken,
							  LPCWSTR wszLockType,
							  LPCWSTR wszLockScope,
							  BOOL fRollback,
							  BOOL fDepthInfinity,
							  DWORD dwTimeout,
							  LPCWSTR pwszOwnerComment,
							  LPCWSTR pwszSubType);

//	========================================================================
//
//	CLASS CXMLBody
//		This class is wrapper around CTextBodyPart, it collects small XML pieces
//	and save them in a CTextBodyPart, the body part will be added to body part
//	list when it grow large enough. This avoid contructing CTextBodyPart too
//	frequently.
//
class CXMLBody : public IXMLBody
{
private:
	auto_ptr<CTextBodyPart>		m_ptbp;
	auto_ref_ptr<IMethUtil>		m_pmu;
	BOOL						m_fChunked;

	//	non-implemented
	//
	CXMLBody(const CXMLBody& p);
	CXMLBody& operator=(const CXMLBody& p);

	//	Helper
	//
	VOID	SendCurrentChunk()
	{
		XmlTrace ("Dav: Xml: adding %ld bytes to body\n", m_ptbp->CbSize64());
		m_pmu->AddResponseBodyPart (m_ptbp.relinquish());

		//$REVIEW: The auto_ptr clas defined in \inc\autoptr.h is different from
		//$REVIEW: the one defined in \inc\ex\autoptr.h. it does not set px
		//$REVIEW: to zero when it relinquish. I believe this is a bug. I am not
		//$REVIEW: sure if anyone is relying on this behavior, so I did not go ahead
		//$REVIEW: fix the relinquish(), a better/complete fix will be moving
		//$REVIEW: everyoen to \inc\ex\autoptr.h
		//$REVIEW:
		m_ptbp.clear();

		//	Send the data from this chunk back to the client before
		//	we go fetch the next chunk.
		//
		if (m_fChunked)
			m_pmu->SendPartialResponse();
	}

public:
	//	ctor & dtor
	//
	CXMLBody (IMethUtil * pmu, BOOL fChunked = TRUE)
			:	m_pmu(pmu),
				m_fChunked(fChunked)
	{
	}

	~CXMLBody ()
	{
	}

	//	IXMLBody methods
	//
	SCODE ScAddTextBytes ( UINT cbText, LPCSTR lpszText );

	VOID Done()
	{
		if (m_ptbp.get())
			SendCurrentChunk();
	}
};

SCODE ScAddTitledHref (CEmitterNode& enParent,
					   IMethUtil * pmu,
					   LPCWSTR pwszTag,
					   LPCWSTR pwszPath,
					   BOOL fCollection = FALSE,
					   CVRoot* pcvrTranslate = NULL);

inline
SCODE ScAddHref (CEmitterNode& enParent,
				 IMethUtil * pmu,
				 LPCWSTR pwszPath,
				 BOOL fCollection = FALSE,
				 CVRoot* pcvrTranslate = NULL)
{
	return ScAddTitledHref (enParent,
							pmu,
							gc_wszXML__Href,
							pwszPath,
							fCollection,
							pcvrTranslate);
}

//$HACK:ROSEBUD_TIMEOUT_HACK
//  For the bug where rosebud waits until the last second
//  before issueing the refresh. Need to filter out this check with
//  the user agent string. The hack is to increase the timeout
//	by 30 seconds and send back the requested timeout.
//
DEC_CONST gc_dwSecondsHackTimeoutForRosebud = 120;

//$HACK:END:ROSEBUD_TIMEOUT_HACK
//

#endif // !defined(_DAVIMPL_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\webdav\inc\ecbimpl.h ===
/*
	Copyright (c) 1999 Microsoft Corporation, All Rights Reserved

	Description
	===========
	This header defines the template class CEcbBaseImpl<>, which is used to implement
	specific ECB-related functions which are required by the WebClient.

	The reason for implementing the function this way is so that _WEBMAIL can be
	linked into multiple projects, and so that each of those projects can use this
	template to provide the ECB-related functions.  That is to say, we want to share
	the code, and this is the way we ended up doing it.

	Specifically, _WEBMAIL accepts pointers of type IEcbBase.  And _DAVPRS uses
	objects of type IEcb, which is derived from IEcbBase - and all of the functions
	in this template class used to be implemented by _DAVPRS.  And EXWFORM wants to
	use _WEBMAIL, and wants to share the implementation of these functions with
	_DAVPRS, but doesn't want to have to implement all of IEcb.

	So, in _DAVPRS, the class heirarchy looks like...
		class IEcbBase;
		class IEcb : public IEcbBase;
		class CEcb : public CEcbBaseImpl<IEcb>;

	In EXWFORM, the class heirarchy looks like...
		class IEcbBase;
		class CLocalEcb : public CEcbBaseImpl<IEcbBase>;

	History
	=======
	6/27/99	dondu	Created
*/


#ifndef _ECBIMPL_INC
#define _ECBIMPL_INC


template<class _T>
class CEcbBaseImpl : public _T
{
protected:

	//	Buffer for cached constant strings.  Must be WCHAR because it is
	//	used for both CHAR and WCHAR strings. Alignment must be pesimistic.
	//
	mutable ChainedStringBuffer<WCHAR> m_sb;

	//	Skinny vroot information
	//
	mutable UINT m_cchVroot;
	mutable LPSTR m_rgchVroot;

	//	Wide character vroot information
	//
	mutable UINT m_cchVrootW;
	mutable LPWSTR m_rgwchVroot;

	//	Skinny vroot path
	//
	mutable UINT m_cchVrootPath;
	mutable LPSTR m_rgchVrootPath;

	//	Wide character vroot path
	//
	mutable UINT m_cchVrootPathW;
	mutable LPWSTR m_rgwchVrootPath;

	//	Skinny server name
	//
	mutable UINT m_cchServerName;
	mutable LPSTR m_lpszServerName;

	//	Wide character server name
	//
	mutable UINT m_cchServerNameW;
	mutable LPWSTR m_pwszServerName;

	//	Cached path translated from request URI (e.g. L"c:\davfs\foo.txt")
	//
	mutable LPWSTR m_pwszPathTranslated;

	//	Cached request URL in skinny form.
	//
	mutable LPSTR m_pszRequestUrl;

	//	Cached request URL in wide form.
	//
	mutable LPWSTR m_pwszRequestUrl;

	//	Cached raw URL
	//
	mutable LPSTR	m_pszRawURL;
	mutable UINT	m_cbRawURL;

	//	Cached LCID of request/response language
	//
	mutable ULONG	m_lcid;

	//	ECB port secure state
	//
	mutable enum {

		HTTPS_UNKNOWN,
		NORMAL,
		SECURE
	}				m_secure;
	mutable BOOL	m_fFESecured;

	//	Cached Accept-Language: header
	//
	mutable auto_heap_ptr<CHAR> m_pszAcceptLanguage;

	//	Wide method name. Skinny version is on raw ECB
	//
	mutable LPWSTR	m_pwszMethod;

private:

	// NOT IMPLEMENTED
	//
	CEcbBaseImpl(const CEcbBaseImpl&);
	CEcbBaseImpl& operator=(const CEcbBaseImpl&);

	//	Internal private helpers for caching vroot information
	//	
	VOID GetMapExInfo60After() const;
	VOID GetMapExInfo60Before() const;

protected:

	CEcbBaseImpl(EXTENSION_CONTROL_BLOCK& ecb);

	//	Internal helper for caching vroot information
	//
	VOID GetMapExInfo() const;

public:

	//	Server variables
	//
	virtual BOOL FGetServerVariable( LPCSTR pszName, LPSTR pszValue, DWORD * pcbValue ) const;
	virtual BOOL FGetServerVariable( LPCSTR pszName, LPWSTR pwszValue, DWORD * pcchValue ) const;

	//	Virtual root information
	//
	virtual UINT CchGetVirtualRoot( LPCSTR * ppszVroot ) const;
	virtual UINT CchGetVirtualRootW( LPCWSTR * ppwszVroot ) const;

	virtual UINT CchGetMatchingPathW( LPCWSTR * ppwszMatchingPath ) const;

	//	Server name
	//
	virtual UINT CchGetServerName( LPCSTR* ppszServer) const;
	virtual UINT CchGetServerNameW( LPCWSTR* ppwszServer) const;

	//	URL prefix
	//
	virtual LPCSTR LpszUrlPrefix() const;
	virtual LPCWSTR LpwszUrlPrefix() const;
	virtual UINT CchUrlPrefix( LPCSTR * ppszPrefix ) const;
	virtual UINT CchUrlPrefixW( LPCWSTR * ppwszPrefix ) const;

	//	ACCESSORS
	//
	virtual LPCSTR LpszRequestUrl() const;
	virtual LPCWSTR LpwszRequestUrl() const;
	virtual LPCWSTR LpwszMethod() const;
	virtual LPCWSTR LpwszPathTranslated() const;
	virtual UINT CbGetRawURL (LPCSTR * ppszRawURL) const;
	virtual ULONG  LcidAccepted() const;
	virtual VOID SetLcidAccepted(LCID lcid);

	virtual BOOL FSsl() const;
	virtual BOOL FFrontEndSecured() const { return FSsl() && m_fFESecured; }
};


//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::CEcbBaseImpl()
//
template<class _T>
CEcbBaseImpl<_T>::CEcbBaseImpl(EXTENSION_CONTROL_BLOCK& ecb) :
   _T(ecb),
   m_sb(1024), // 1K for constant cached strings
   m_cchVroot(0),
   m_rgchVroot(NULL),
   m_cchVrootW(0),
   m_rgwchVroot(NULL),
   m_cchVrootPath(0),
   m_rgchVrootPath(NULL),
   m_cchVrootPathW(0),
   m_rgwchVrootPath(NULL),
   m_cchServerName(0),
   m_lpszServerName(NULL),
   m_cchServerNameW(0),
   m_pwszServerName(NULL),
   m_pwszPathTranslated(NULL),
   m_pszRequestUrl(NULL),
   m_pwszRequestUrl(NULL),
   m_pszRawURL(NULL),
   m_cbRawURL(0),
   m_lcid(0),
   m_secure(HTTPS_UNKNOWN),
   m_fFESecured(FALSE),
   m_pwszMethod(NULL)
{
#ifdef DBG

	// This is here (in the DBG build only) to help generate
	// compile errors for any inappropriate use of this template
	// class - basically, you're not supposed to use this class
	// with anything other than IEcbBase, or something which
	// derives from IEcbBase.
	//
	IEcbBase* p;
	p = reinterpret_cast<_T *> (NULL);

#endif
	// nothing
}

//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::GetMapExInfo60After()
//
template<class _T>
VOID CEcbBaseImpl<_T>::GetMapExInfo60After() const
{
	if ( !m_rgwchVroot )
	{
		HSE_UNICODE_URL_MAPEX_INFO mi;
		UINT cbPath = MAX_PATH * sizeof(WCHAR);

		//$REMOVE after 156176 is fixed START
		//
		mi.lpszPath[0] = L'\0';
		mi.cchMatchingPath = 0;
		//
		//$REMOVE after 156176 is fixed END

		//	No cached wide vroot data. Get mapings for the request URL.
		//
		//	We can get the virtual root by translating the path and using
		//	the count of matched characters in the URL.
		//
		//	NOTE: ServerSupportFunction(HSE_REQ_MAP_UNICODE_URL_TO_PATH_EX)
		//	has a bug - it requires the count of bytes available for the
		//	path. We know that MAX_PATH is available in HSE_UNICODE_URL_MAPEX_INFO
		//	so pass in the right value to work around the crash.
		//
		if ( !m_pecb->ServerSupportFunction( m_pecb->ConnID,
											 HSE_REQ_MAP_UNICODE_URL_TO_PATH_EX,
											 const_cast<LPWSTR>(LpwszRequestUrl()),
											 reinterpret_cast<DWORD *>(&cbPath),
											 reinterpret_cast<DWORD *>(&mi) ))
		{
			//	There is a fix for Windows Bugs 156176 that we need to do the
			//	following check for. It applies to IIS 6.0 (+) path only. In IIS 5.0
			//	the maping functions were silently succeeding, and truncating the
			//	buffer that contained the mapped path if it exceeded MAX_PATH.
			//	That behaviour suited us, but is not very nice, so IIS 6.0 chose
			//	to still fill in the buffer as before, but fail with special error
			//	(ERROR_INSUFFICIENT_BUFFER). That error still means success to us,
			//	so fail only if we see something different
			//
			if (ERROR_INSUFFICIENT_BUFFER != GetLastError())
			{
				//	Function does not allow to return failures, so the only option
				//	is to throw. We cannot proceed if we did not get the data anyway.
				//	If this function succeeds once, subsequent calls to it are non
				//	failing.
				//
				DebugTrace ("CEcbBaseImpl<_T>::GetMapExInfo60After() - ServerSupportFunction(HSE_REQ_MAP_UNICODE_URL_TO_PATH_EX) failed 0x%08lX\n", GetLastError());
				throw CLastErrorException();
			}
		}

		//$REMOVE after 156176 is fixed START
		//
		if (L'\0' == mi.lpszPath[0])
		{
			DebugTrace ("CEcbBaseImpl<_T>::GetMapExInfo60After() - ServerSupportFunction(HSE_REQ_MAP_UNICODE_URL_TO_PATH_EX) failed 0x%08lX\n", GetLastError());
			throw CLastErrorException();
		}
		//
		//$REMOVE after 156176 is fixed END

		EcbTrace ("Dav: caching request URI maping info (path for IIS 6.0 and later):\n"
					"   URL \"%ls\" maps to \"%ls\"\n"
					"   dwFlags = 0x%08x\n"
					"   cchMatchingPath = %d\n"
					"   cchMatchingURL  = %d\n",
					LpwszRequestUrl(),
					mi.lpszPath,
					mi.dwFlags,
					mi.cchMatchingPath,
					mi.cchMatchingURL);

		//	Adjust the matching URL ...
		//
		if ( mi.cchMatchingURL )
		{
			LPCWSTR pwsz = LpwszRequestUrl() + mi.cchMatchingURL - 1;

			//	... do not include the trailing slash, if any...
			//
			if ( L'/' == *pwsz )
			{
				mi.cchMatchingURL -= 1;
			}

			//	... also we found a case (INDEX on the vroot) where the
			//	cchMatching... points to the '\0' (where a trailing slash
			//	would be IF DAV methods required a trailing slash). So,
			//	also chop off any trailing '\0' here! --BeckyAn 21Aug1997
			//
			else if ( L'\0' == *pwsz )
			{
				mi.cchMatchingURL -= 1;
			}
		}

		//	Cache the vroot data.
		//	Corollary:  m_cchVrootW should always be > 0 when we have data.
		//
		m_cchVrootW = mi.cchMatchingURL + 1;
		m_rgwchVroot = reinterpret_cast<LPWSTR>(m_sb.Alloc(m_cchVrootW * sizeof(WCHAR)));
		memcpy (m_rgwchVroot, LpwszRequestUrl(), m_cchVrootW * sizeof(WCHAR));
		m_rgwchVroot[m_cchVrootW - 1] = L'\0';

		//	Adjust the matching path the same way as we did matching URL
		//
		if ( mi.cchMatchingPath )
		{
			LPCWSTR pwsz = mi.lpszPath + mi.cchMatchingPath - 1;

			if ( L'\\' == *pwsz )
			{
				while ((0 < mi.cchMatchingPath) &&
					   (L'\\' == *pwsz) &&
					   (!FIsDriveTrailingChar(pwsz, mi.cchMatchingPath)))
				{
					mi.cchMatchingPath--;
					pwsz--;
				}
			}
			else if ( L'\0' == *pwsz )
			{
				mi.cchMatchingPath--;
			}
		}

		//	Cache the matching path data.
		//	Corollary:  m_cchVrootPathW should always be > 0 when we have data.
		//
		m_cchVrootPathW = mi.cchMatchingPath + 1;
		m_rgwchVrootPath = reinterpret_cast<LPWSTR>(m_sb.Alloc(m_cchVrootPathW * sizeof(WCHAR)));
		memcpy (m_rgwchVrootPath, mi.lpszPath, mi.cchMatchingPath * sizeof(WCHAR));
		m_rgwchVrootPath[mi.cchMatchingPath] = L'\0';
	}
}

//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::GetMapExInfo60Before()
//
template<class _T>
VOID CEcbBaseImpl<_T>::GetMapExInfo60Before() const
{
	if ( !m_rgchVroot )
	{
		HSE_URL_MAPEX_INFO mi;

		//	No cached wide vroot data. Get mapings for the request URL.
		//
		//	We can get the virtual root by translating the path and using
		//	the count of matched characters in the URL
		//
		//	NOTE: ServerSupportFunction(HSE_REQ_MAP_UNICODE_URL_TO_PATH_EX)
		//	does not require the count of bytes available for the path.
		//	So we just pass in NULL and it will figure out the available size
		//	itself - it knows the form of HSE_URL_MAPEX_INFO too, and that
		//	it gives MAX_PATH butes for the translated path.
		//
		if ( !m_pecb->ServerSupportFunction( m_pecb->ConnID,
											 HSE_REQ_MAP_URL_TO_PATH_EX,
											 const_cast<LPSTR>(LpszRequestUrl()),
											 NULL,
											 reinterpret_cast<DWORD *>(&mi) ))
		{
			//	Function does not allow to return failures, so the only option
			//	is to throw. We cannot proceed if we did not get the data anyway.
			//	If this function succeeds once, subsequent calls to it are non
			//	failing.
			//
			DebugTrace ("CEcbBaseImpl<_T>::GetMapExInfo60Before() - ServerSupportFunction(HSE_REQ_MAP_URL_TO_PATH_EX) failed 0x%08lX\n", GetLastError());
			throw CLastErrorException();
		}

		EcbTrace ("Dav: caching request URI maping info (path for pre IIS 6.0):\n"
					"   URL \"%hs\" maps to \"%hs\"\n"
					"   dwFlags = 0x%08x\n"
					"   cchMatchingPath = %d\n"
					"   cchMatchingURL  = %d\n",
					LpszRequestUrl(),
					mi.lpszPath,
					mi.dwFlags,
					mi.cchMatchingPath,
					mi.cchMatchingURL);

		//	Adjust the matching URL ...
		//
		if ( mi.cchMatchingURL )
		{
			LPCSTR psz = LpszRequestUrl() + mi.cchMatchingURL - 1;

			//	... do not include the trailing slash, if any...
			//
			if ( '/' == *psz )
			{
				//$	RAID: NT:359868
				//
				//	This is the first of many places where we need to be very
				//	careful with our usage of single character checks.  Namely,
				//	in DBCS land, we need to check for lead bytes before treating
				//	the last char as if it is a slash.
				//
				if (!FIsDBCSTrailingByte (psz, mi.cchMatchingURL))
					mi.cchMatchingURL -= 1;
				//
				//$	RAID: end.
			}

			//	... also we found a case (INDEX on the vroot) where the
			//	cchMatching... points to the '\0' (where a trailing slash
			//	would be IF DAV methods required a trailing slash). So,
			//	also chop off any trailing '\0' here! --BeckyAn 21Aug1997
			//
			else if ( '\0' == *psz )
			{
				mi.cchMatchingURL -= 1;
			}
		}

		//	Cache the vroot data.
		//	Corollary:  m_cchVrootW should always be > 0 when we have data.
		//
		m_cchVroot = mi.cchMatchingURL + 1;
		m_rgchVroot = reinterpret_cast<LPSTR>(m_sb.Alloc(m_cchVroot));
		memcpy (m_rgchVroot, LpszRequestUrl(), m_cchVroot);
		m_rgchVroot[m_cchVroot - 1] = '\0';

		//	Adjust the matching path the same way as we did maching URL
		//
		if ( mi.cchMatchingPath )
		{
			LPCSTR psz = mi.lpszPath + mi.cchMatchingPath - 1;

			if ( '\\' == *psz )
			{
				//$	RAID: NT:359868
				//
				//	This is the second of many places where we need to be very
				//	careful with our usage of single character checks.  Namely,
				//	in DBCS land, we need to check for lead bytes before treating
				//	the last char as if it is a backslash.
				//
				while ((0 < mi.cchMatchingPath) &&
					   ('\\' == *psz) &&
					   (!FIsDBCSTrailingByte (psz, mi.cchMatchingPath)) &&
					   (!FIsDriveTrailingChar (psz, mi.cchMatchingPath)))
				{
					mi.cchMatchingPath--;
					psz--;
				}

				//
				//$	RAID: end.
			}
			else if ( '\0' == *psz )
			{
				mi.cchMatchingPath--;
			}
		}

		//	Cache the matching path data.
		//	Corollary:  m_cchVrootPath should always be > 0 when we have data.
		//
		m_cchVrootPath = mi.cchMatchingPath + 1;
		m_rgchVrootPath = reinterpret_cast<LPSTR>(m_sb.Alloc(m_cchVrootPath));
		memcpy (m_rgchVrootPath, mi.lpszPath, mi.cchMatchingPath);
		m_rgchVrootPath[mi.cchMatchingPath] = '\0';
	}
}

//	------------------------------------------------------------------------
//
//	CEcbBaseImpl::GetMapExInfo()
//
template<class _T>
VOID CEcbBaseImpl<_T>::GetMapExInfo() const
{
	if ( m_pecb->dwVersion >= IIS_VERSION_6_0 )
	{
		GetMapExInfo60After();
	}
	else
	{
		GetMapExInfo60Before();
	}
}


//	------------------------------------------------------------------------
//
//	FGetServerVariable()
//
//		Get the value of an ECB variable (e.g. "SERVER_NAME")
//
template<class _T>
BOOL
CEcbBaseImpl<_T>::FGetServerVariable( LPCSTR pszName, LPSTR pszValue,
									  DWORD * pcbValue ) const
{
	BOOL fResult = FALSE;


	Assert( m_pecb );
	Assert( !IsBadWritePtr( pcbValue, sizeof(DWORD) ) );
	Assert( *pcbValue > 0 );
	Assert( !IsBadWritePtr( pszValue, *pcbValue ) );

	if ( m_pecb->GetServerVariable( m_pecb->ConnID,
									const_cast<LPSTR>(pszName),
									pszValue,
									pcbValue ) )
	{
		fResult = TRUE;
	}
	else if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
	{
		AssertSz( GetLastError() == ERROR_INVALID_INDEX, "Unexpected last error from GetServerVariable()\n" );
		*pcbValue = 0;
	}

	return fResult;
}

template<class _T>
BOOL
CEcbBaseImpl<_T>::FGetServerVariable( LPCSTR pszName, LPWSTR pwszValue,
									  DWORD * pcchValue ) const
{
	BOOL fResult = FALSE;
	CStackBuffer<CHAR> pszValue;
	DWORD cbValue;
	UINT cch;

	Assert( m_pecb );
	Assert( !IsBadWritePtr( pcchValue, sizeof(DWORD) ) );
	Assert( *pcchValue > 0 );
	Assert( !IsBadWritePtr( pwszValue, *pcchValue * sizeof(WCHAR) ) );

	//	Assume that 1 wide character can be made of 3 skinny ones,
	//	which may be true in the case codepage is CP_UTF8
	//
	cbValue = *pcchValue * 3;
	if (NULL != pszValue.resize(cbValue))
	{
		if ( m_pecb->GetServerVariable( m_pecb->ConnID,
										const_cast<LPSTR>(pszName),
										pszValue.get(),
										&cbValue ) )
		{
			fResult = TRUE;
		}
		else if ( ERROR_INSUFFICIENT_BUFFER == GetLastError() )
		{
			if (NULL != pszValue.resize(cbValue))
			{
				if ( m_pecb->GetServerVariable( m_pecb->ConnID,
												const_cast<LPSTR>(pszName),
												pszValue.get(),
												&cbValue ) )
				{
					fResult = TRUE;
				}
			}
		}
	}

	//	By now we should be succesfull in geting data as the buffer provided
	//	was big enough
	//
	if (FALSE == fResult)
	{
		EcbTrace( "Dav: CEcbBaseImpl<_T>::FGetServerVariable(). Error 0x%08lX from GetServerVariable()\n", GetLastError() );
		*pcchValue = 0;
		goto ret;
	}

	//	We have the data, need to convert it to wide version, assume we will fail
	//
	fResult = FALSE;
	cch = MultiByteToWideChar(CP_ACP,
							  MB_ERR_INVALID_CHARS,
							  pszValue.get(),
							  cbValue,
							  pwszValue,
							  *pcchValue);
	if (0 == cch)
	{
		//	The function failed...
		//
		if ( ERROR_INSUFFICIENT_BUFFER == GetLastError() )
		{
			//	... figure out the necessary size for the buffer
			//
			cch = MultiByteToWideChar(CP_ACP,
									  MB_ERR_INVALID_CHARS,
									  pszValue.get(),
									  cbValue,
									  NULL,
									  0);
			if (0 == cch)
			{
				//	We still failed
				//
				AssertSz( ERROR_INSUFFICIENT_BUFFER != GetLastError(), "We should not fail with ERROR_INSUFFICIENT BUFFER here.\n" );

				EcbTrace( "Dav: