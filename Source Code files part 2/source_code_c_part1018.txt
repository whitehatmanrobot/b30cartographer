not attaching to a file system device
            //
            if (deviceExtension->TargetDeviceObject->DeviceType == FILE_DEVICE_DISK_FILE_SYSTEM) {
                ClusDiskPrint((3,
                        "[ClusDisk] AttachDevice: We incorrectly attached our partition device %p to file system device %p \n",
                        physicalDevice,
                        deviceExtension->TargetDeviceObject));
                RtlFreeUnicodeString( &targetDeviceName );
                continue;
            }

            ClusDiskPrint((3,
                           "[ClusDisk] AttachDevice: Attach to partition %u/%u\n",
                           diskNumber,
                           partitionInfo->PartitionNumber));

            //
            // Create device object for this partition.
            //

            swprintf(clusdiskDeviceBuffer,
                     CLUSDISK_DEVICE_NAME,
                     diskNumber,
                     partitionInfo->PartitionNumber);
            WCSLEN_ASSERT( clusdiskDeviceBuffer );

            RtlInitUnicodeString( &clusdiskDeviceName, clusdiskDeviceBuffer );

            status = IoCreateDevice(DriverObject,
                                    sizeof(CLUS_DEVICE_EXTENSION),
                                    &clusdiskDeviceName,
                                    FILE_DEVICE_DISK,
                                    0,
                                    FALSE,
                                    &deviceObject);

            if ( !NT_SUCCESS(status) ) {
                ClusDiskPrint((3,
                           "[ClusDisk] AttachDevice: Failed to create device %wZ, %08X\n",
                           &clusdiskDeviceName,
                           status));
                RtlFreeUnicodeString(&targetDeviceName);
                continue;
            }

            deviceObject->Flags |= DO_DIRECT_IO;
            deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

            //
            // Point device extension back at device object and
            // remember the disk number.
            //

            deviceExtension = deviceObject->DeviceExtension;
            deviceExtension->DeviceObject = deviceObject;
            deviceExtension->DiskNumber = diskNumber;
            deviceExtension->DriverObject = DriverObject;
            deviceExtension->BusType = zeroExtension->BusType;
            
            //
            // Always set disk state to offline.  These are volume objects.
            //
            deviceExtension->DiskState = DiskOffline;
            deviceExtension->PerformReserves = FALSE;
            deviceExtension->ReserveFailure = 0;
            deviceExtension->Signature = Signature;
            deviceExtension->AttachValid = TRUE;
            deviceExtension->Detached = TRUE;
            deviceExtension->OfflinePending = FALSE;
            deviceExtension->ScsiAddress = scsiAddress;
            InitializeListHead( &deviceExtension->WaitingIoctls );
            InitializeListHead( &deviceExtension->HoldIO );

            IoInitializeRemoveLock( &deviceExtension->RemoveLock, CLUSDISK_ALLOC_TAG, 0, 0 );

            CDLOG( "ClusDiskAttachDevice: IoCreateDevice D0 %p State %!diskstate! diskNo %d partNo %d",
                   deviceObject,
                   deviceExtension->DiskState,
                   diskNumber,
                   partitionInfo->PartitionNumber );
            //
            // Signal the worker thread running event.
            //
            KeInitializeEvent( &deviceExtension->Event, NotificationEvent, TRUE );

            //
            // Maintain the last partition number created.  Put it in
            // each extension just to initialize the field.
            //

            deviceExtension->LastPartitionNumber = max(deviceExtension->LastPartitionNumber,
                                                       partitionInfo->PartitionNumber);

            zeroExtension->LastPartitionNumber = deviceExtension->LastPartitionNumber;

            KeInitializeEvent( &deviceExtension->PagingPathCountEvent,
                               NotificationEvent, TRUE );
            deviceExtension->PagingPathCount = 0;
            deviceExtension->HibernationPathCount = 0;
            deviceExtension->DumpPathCount = 0;

            ExInitializeResourceLite( &deviceExtension->DriveLayoutLock );

            //
            // Store pointer to physical device.
            //
            ObReferenceObject( physicalDevice );
            deviceExtension->PhysicalDevice = physicalDevice;

            //
            // First dismount any mounted file systems.
            //
            if ( targetDevice->Vpb &&
                 (targetDevice->Vpb->Flags & VPB_MOUNTED) ) {

                status = DismountPartition( targetDevice,
                                            diskNumber,
                                            partitionInfo->PartitionNumber);

                if ( !NT_SUCCESS( status )) {
                    ClusDiskPrint((1,
                                  "[ClusDisk] AttachDevice: Dismount of %u/%u failed %08X\n",
                                  diskNumber, partitionInfo->PartitionNumber, status));
                }
            }

            //
            // Attach to the partition. This call links the newly created
            // device to the target device, returning the target device object.
            //
            ClusDiskPrint((3,
                           "[ClusDisk] AttachDevice: attaching to device %wZ\n",
                           &targetDeviceName ));

            attachedTargetDevice = IoAttachDeviceToDeviceStack(deviceObject,
                                                               targetDevice);
            ASSERT( attachedTargetDevice == targetDevice );

            if ( attachedTargetDevice == NULL ) {
                ClusDiskPrint((1,
                               "[ClusDisk] AttachDevice: Failed to attach to device %wZ\n",
                               &targetDeviceName));

                RtlFreeUnicodeString(&targetDeviceName);
                IoDeleteDevice(deviceObject);
                continue;
            }

            deviceExtension->TargetDeviceObject = attachedTargetDevice;
            deviceExtension->Detached = FALSE;

            RtlFreeUnicodeString(&targetDeviceName);

            //
            // Call ourself back to make sure ft acts appropriately.
            //
            // [GN] No need to do it.
            //
            // CluCallBackDiskState( deviceObject, deviceExtension->DiskState );

            //
            // Propagate driver's alignment requirements and power flags.
            //

            deviceObject->AlignmentRequirement =
                deviceExtension->TargetDeviceObject->AlignmentRequirement;

            deviceObject->SectorSize =
                deviceExtension->TargetDeviceObject->SectorSize;

            //
            // The storage stack explicitly requires DO_POWER_PAGABLE to be
            // set in all filter drivers *unless* DO_POWER_INRUSH is set.
            // this is true even if the attached device doesn't set DO_POWER_PAGABLE.
            //
            if ( deviceExtension->TargetDeviceObject->Flags & DO_POWER_INRUSH) {
                deviceObject->Flags |= DO_POWER_INRUSH;
            } else {
                deviceObject->Flags |= DO_POWER_PAGABLE;
            }

            //
            // Check if this device is already mounted or is a file system
            // device. The file systems should have already been dismounted!
            //
            if ( targetDevice->Vpb ) {
                if ( targetDevice->Vpb->Flags & VPB_MOUNTED ) {

                    ClusDiskPrint((3,
                                   "[ClusDisk] AttachDevice: Dismounting disk %u partition %u (devobj %p)\n",
                                   diskNumber, partitionInfo->PartitionNumber,
                                   targetDevice));
                    status = DismountPartition( targetDevice,
                                                diskNumber,
                                                partitionInfo->PartitionNumber);

                    if ( !NT_SUCCESS( status )) {
                        ClusDiskPrint((1,
                                       "[ClusDisk] AttachDevice: Dismount disk %u partition %u failed %08X\n",
                                       diskNumber, partitionInfo->PartitionNumber, status));
                    }
                }
            }
        }

        ExFreePool( driveLayoutInfo );
        finalStatus = STATUS_SUCCESS;
        break;
    }

    DEREFERENCE_OBJECT( targetDevice );
    
    CDLOG( "ClusDiskAttachDevice: Exit status %!status!", finalStatus );

    return(finalStatus);

} // ClusDiskAttachDevice



NTSTATUS
ClusDiskDetachDevice(
    ULONG          Signature,
    PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    Detach from a disk device with the signature specified.

Arguments:

    Signature - the signature for the device to detach from.

    DriverObject - the driver object for our device.

Return Value:

    NT Status

Notes:

    We have to be careful with the partition0 devices. RAW doesn't support
    dismount, so it is not clear that we can actually delete those device
    objects, since they could be cached by FileSystems like RAW!

--*/

{
    NTSTATUS                status;
    PDEVICE_LIST_ENTRY      deviceEntry;
    PCLUS_DEVICE_EXTENSION  deviceExtension;
    PCLUS_DEVICE_EXTENSION  physicalDeviceExtension;
    PDEVICE_OBJECT          deviceObject = DriverObject->DeviceObject;
    BOOLEAN                 found = FALSE;
    UNICODE_STRING          signatureName;
    UNICODE_STRING          availableName;
    KIRQL                   irql;
    PCLUS_DEVICE_EXTENSION  foundExtension = NULL;
    PLIST_ENTRY             listEntry;
    PIRP                    irp;

    //
    // Find our device entry.
    //

    // 2000/02/05: stevedz - added synchronization.
    
    ACQUIRE_SHARED( &ClusDiskDeviceListLock );
    
    deviceEntry = ClusDiskDeviceList;
    while ( deviceEntry ) {
        if ( deviceEntry->Signature == Signature ) {
            break;
        }
        deviceEntry = deviceEntry->Next;
    }

    if ( (deviceEntry == NULL) ||
         !deviceEntry->Attached ) {
        if ( deviceEntry ) {
            ClusDiskPrint((
                    1,
                    "[ClusDisk] DetachDevice: Failed to detach signature = %lx, attached = %lx\n",
                    Signature, deviceEntry->Attached ));
        } else {
            ClusDiskPrint((
                    1,
                    "[ClusDisk] DetachDevice: Failed to detach signature = %lx\n",
                    Signature ));

        }

        RELEASE_SHARED( &ClusDiskDeviceListLock ); 
        
        goto DeleteDiskSignature;
    }

    //
    // Now find all devices that we are attached to with this signature.
    //
    KeAcquireSpinLock(&ClusDiskSpinLock, &irql);
    while ( deviceObject ) {
        deviceExtension = deviceObject->DeviceExtension;
        //
        // Only disable devices with our signature, but
        // Don't remove the root device...
        //
        if ( (deviceExtension->Signature == Signature) ) {
            //
            // Remember one found extension - it doesn't matter which one.
            //
            foundExtension = deviceExtension;

            //
            // Detach from the target device. This only requires marking
            // the device object as detached!
            //
            deviceExtension->Detached = TRUE;

            //
            // We want to make sure reserves are stopped because the disk is
            // not going to be controlled by the cluster any longer.
            //
            ASSERT_RESERVES_STOPPED( deviceExtension );

            //
            // Make this device available again.
            //
            // deviceExtension->DiskState = DiskOnline;
            ONLINE_DISK( deviceExtension );

            ClusDiskPrint(( 3,
                            "[ClusDisk] DetachDevice: Marking signature = %lx online \n",
                            Signature ));

            found = TRUE;
        }
        deviceObject = deviceObject->NextDevice;
    }
    KeReleaseSpinLock(&ClusDiskSpinLock, irql);
    RELEASE_SHARED( &ClusDiskDeviceListLock ); 

    //
    // Delete all drive letters for this disk signature, and assign letters
    // to the correct device name.
    //
    if ( foundExtension ) {

        physicalDeviceExtension = foundExtension->PhysicalDevice->DeviceExtension;

        //
        // Signal all waiting Irp's on the physical device extension.
        //
        IoAcquireCancelSpinLock( &irql );
        KeAcquireSpinLockAtDpcLevel(&ClusDiskSpinLock);
        while ( !IsListEmpty(&physicalDeviceExtension->WaitingIoctls) ) {
            listEntry = RemoveHeadList(&physicalDeviceExtension->WaitingIoctls);
            irp = CONTAINING_RECORD( listEntry,
                                     IRP,
                                     Tail.Overlay.ListEntry );
            ClusDiskCompletePendingRequest(irp, STATUS_SUCCESS, physicalDeviceExtension);
        }
        while ( !IsListEmpty(&foundExtension->HoldIO) ) {
            listEntry = RemoveHeadList(&foundExtension->HoldIO);
            irp = CONTAINING_RECORD( listEntry,
                                     IRP,
                                     Tail.Overlay.ListEntry );
            ClusDiskCompletePendingRequest(irp, STATUS_REQUEST_ABORTED, foundExtension);
        }
        KeReleaseSpinLockFromDpcLevel(&ClusDiskSpinLock);
        IoReleaseCancelSpinLock( irql );
    }
    
DeleteDiskSignature:

    //
    // Allocate buffer for signatures registry key.
    //
    status = ClusDiskInitRegistryString(
                                        &signatureName,
                                        CLUSDISK_SIGNATURE_KEYNAME,
                                        sizeof(CLUSDISK_SIGNATURE_KEYNAME)
                                       );
    if ( !NT_SUCCESS(status) ) {
        return(status);
    }

    //
    // Allocate buffer for our list of available signatures,
    // and form the subkey string name.
    //
    status = ClusDiskInitRegistryString(
                                        &availableName,
                                        CLUSDISK_AVAILABLE_DISKS_KEYNAME,
                                        sizeof(CLUSDISK_AVAILABLE_DISKS_KEYNAME)
                                       );
    if ( !NT_SUCCESS(status) ) {
        ExFreePool( signatureName.Buffer );
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Always - remove signature from signature list.
    //
    status = ClusDiskDeleteSignature(
                                     &signatureName,
                                     Signature
                                    );

    //
    // Conditionally add signature to available list.
    //
    // always add signature to available list. This will handle the case
    // where the disk signature was not found by this system in a previous
    // scan of the disks.
    //
    found = TRUE;
    if ( found ) {

        ClusDiskPrint((3,
                       "[ClusDisk] DetachDevice: adding disk %08X to available disks list\n",
                       Signature));

        status = ClusDiskAddSignature(
                                      &availableName,
                                      Signature,
                                      TRUE
                                     );
    } else {
        ClusDiskPrint((
                3,
                "[ClusDisk] DetachDevice: No devices were detached!\n" ));
    }

    ExFreePool( signatureName.Buffer );
    ExFreePool( availableName.Buffer );

    return(STATUS_SUCCESS);

} // ClusDiskDetachDevice



NTSTATUS
ClusDiskRead(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the driver entry point for read and write requests
    to disks to which the clusdisk driver has attached.
    This driver collects statistics and then sets a completion
    routine so that it can collect additional information when
    the request completes. Then it calls the next driver below
    it.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PCLUS_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PCLUS_DEVICE_EXTENSION  physicalDisk =
                               deviceExtension->PhysicalDevice->DeviceExtension;
    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_OBJECT     targetDeviceObject = deviceExtension->TargetDeviceObject;
    KIRQL              irql;

    NTSTATUS            status;
    
    status = AcquireRemoveLock(&deviceExtension->RemoveLock, Irp);
    if (!NT_SUCCESS(status)) {
        ClusDiskPrint((
                1,
                "[ClusDisk] ClusDiskRead: AcquireRemoveLock for %p failed %08X \n", 
                deviceExtension,
                status));
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    status = AcquireRemoveLock(&physicalDisk->RemoveLock, Irp);
    if (!NT_SUCCESS(status)) {
        ClusDiskPrint((
                1,
                "[ClusDisk] ClusDiskRead: AcquireRemoveLock for %p (PD) failed %08X \n", 
                physicalDisk,
                status));
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }
    
    //
    // Return error if device is our root device.
    //
    if ( deviceExtension->BusType == RootBus ) {
        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    //
    // Return error if disk is not Online (or Stalled).
    // ReclaimInProgress means we are trying to create the volume objects
    // and reads should pass through (but not writes).
    //

    if ( (physicalDisk->DiskState != DiskOnline) &&
         (physicalDisk->DiskState != DiskStalled) ) 
    {
        CDLOG( "ClusDiskRead(%p): Irp %p Reject len %d offset %I64x", 
               DeviceObject,
               Irp,
               currentIrpStack->Parameters.Read.Length,
               currentIrpStack->Parameters.Read.ByteOffset.QuadPart 
               );

        ClusDiskPrint((
                3,
                "[ClusDisk] ClusDiskRead: ReadReject IRP %p for signature %p (%p) (PD) \n", 
                Irp,
                physicalDisk->Signature,
                physicalDisk));
        
        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = STATUS_DEVICE_OFF_LINE;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(STATUS_DEVICE_OFF_LINE);
    }

    CDLOGF(READ,"ClusDiskRead(%p): Irp %p Read len %d offset %I64x",  
              DeviceObject,
              Irp,
              currentIrpStack->Parameters.Read.Length,
              currentIrpStack->Parameters.Read.ByteOffset.QuadPart );
           
//
// Until we start doing something in the completion routine, just
// skip this driver. In the future, we might want to report errors
// back to the cluster software... but that could get tricky, since some
// requests should fail, but that is expected.
//
#if 0
    //
    // Copy current stack to next stack.
    //

    IoCopyCurrentIrpStackLocationToNext( Irp );

    //
    // Set completion routine callback.
    //

    IoSetCompletionRoutine(Irp,
                           ClusDiskIoCompletion,
                           NULL,    // Completion context
                           TRUE,    // Invoke on success
                           TRUE,    // Invoke on error
                           TRUE);   // Invoke on cancel
#else
    //
    // Set current stack back one.
    //

    IoSkipCurrentIrpStackLocation( Irp );

    ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
    ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

#endif

    //
    // Return the results of the call to the disk driver.
    //

    return IoCallDriver(targetDeviceObject,
                        Irp);

} // ClusDiskRead



NTSTATUS
ClusDiskWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the driver entry point for read and write requests
    to disks to which the clusdisk driver has attached.
    This driver collects statistics and then sets a completion
    routine so that it can collect additional information when
    the request completes. Then it calls the next driver below
    it.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PCLUS_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PCLUS_DEVICE_EXTENSION  physicalDisk =
                               deviceExtension->PhysicalDevice->DeviceExtension;
    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_OBJECT     targetDeviceObject = deviceExtension->TargetDeviceObject;
    KIRQL              irql;

    NTSTATUS            status;

    status = AcquireRemoveLock(&deviceExtension->RemoveLock, Irp);
    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] ClusDiskWrite: AcquireRemoveLock for %p failed %08X \n", 
                deviceExtension,
                status));
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    status = AcquireRemoveLock(&physicalDisk->RemoveLock, Irp);
    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] ClusDiskWrite: AcquireRemoveLock for %p (PD) failed %08X \n", 
                physicalDisk,
                status));
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    //
    // Return error if device is our root device.
    //
    if ( deviceExtension->BusType == RootBus ) {
        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    //
    // Hold the I/O request if we are stalled.
    // First check for hint - i.e. with no lock held.
    //
    if ( deviceExtension->DiskState == DiskStalled ) {
        KeAcquireSpinLock(&ClusDiskSpinLock, &irql);
        //
        // Check again, with lock held - this one is valid!
        //
        if ( deviceExtension->DiskState == DiskStalled ) {
            CDLOG( "ClusDiskWrite(%p): HoldIo irp %p", DeviceObject, Irp );
            ClusDiskPrint((1,"[ClusDisk] HoldIO - pending IRP %p, target %p, Q: %p \n",
                           Irp, targetDeviceObject, &deviceExtension->HoldIO ));
            IoMarkIrpPending( Irp );
            InsertTailList( &deviceExtension->HoldIO,
                            &Irp->Tail.Overlay.ListEntry );
            KeReleaseSpinLock(&ClusDiskSpinLock, irql);

            ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);

            IoAcquireCancelSpinLock( &irql );
            if (Irp->Cancel) {
                IoReleaseCancelSpinLock( irql );

                KeAcquireSpinLock(&ClusDiskSpinLock, &irql);
                RemoveEntryList(&Irp->Tail.Overlay.ListEntry); 
                KeReleaseSpinLock(&ClusDiskSpinLock, irql);

                ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
                Irp->IoStatus.Status = STATUS_CANCELLED;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                return STATUS_CANCELLED;
            } else {
                IoSetCancelRoutine(Irp, ClusDiskIrpCancel);
            }
            IoReleaseCancelSpinLock( irql );

            //
            // We don't release the RemoveLock here as it will be 
            // done when the IRP is removed from the queue.
            //

            return(STATUS_PENDING);
        }
        KeReleaseSpinLock(&ClusDiskSpinLock, irql);
    }

    //
    // Return error if disk is not Online.
    //

    if ( physicalDisk->DiskState != DiskOnline ) {
        CDLOG( "ClusDiskWrite(%p) Reject irp %p", DeviceObject, Irp );
        ClusDiskPrint((
                3,
                "[ClusDisk] ClusDiskWrite: WriteReject IRP %p for signature %p (%p) (PD) \n", 
                Irp,
                physicalDisk->Signature,
                physicalDisk));
        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = STATUS_DEVICE_OFF_LINE;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(STATUS_DEVICE_OFF_LINE);
    }

    //
    // Trace writes to the first few sectors
    //
    CDLOGF(WRITE, "ClusDiskWrite(%p) Irp %p Write len %d offset %I64x", 
              DeviceObject,
              Irp,
              currentIrpStack->Parameters.Write.Length,
              currentIrpStack->Parameters.Write.ByteOffset.QuadPart );

    KeQuerySystemTime( &physicalDisk->LastWriteTime );

//
// Until we start doing something in the completion routine, just
// skip this driver. In the future, we might want to report errors
// back to the cluster software... but that could get tricky, since some
// requests should fail, but that is expected.
//
#if 0
    //
    // Copy current stack to next stack.
    //

    IoCopyCurrentIrpStackLocationToNext( Irp );

    //
    // Set completion routine callback.
    //

    IoSetCompletionRoutine(Irp,
                           ClusDiskIoCompletion,
                           NULL,    // Completion context
                           TRUE,    // Invoke on success
                           TRUE,    // Invoke on error
                           TRUE);   // Invoke on cancel
#else
    //
    // Set current stack back one.
    //

    IoSkipCurrentIrpStackLocation( Irp );

    ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
    ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

#endif

    //
    // Return the results of the call to the disk driver.
    //

    return IoCallDriver(targetDeviceObject,
                        Irp);

} // ClusDiskWrite



NTSTATUS
ClusDiskIoCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )

/*++

Routine Description:

    This routine will get control from the system at the completion of an IRP.
    It will calculate the difference between the time the IRP was started
    and the current time, and decrement the queue depth.

Arguments:

    DeviceObject - for the IRP.
    Irp          - The I/O request that just completed.
    Context      - Not used.

Return Value:

    The IRP status.

--*/

{
    PCLUS_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PCLUS_DEVICE_EXTENSION physicalDisk = deviceExtension->PhysicalDevice->DeviceExtension;
    
    UNREFERENCED_PARAMETER(Context);

    CDLOGF(WRITE, "ClusDiskIoCompletion: CompletedIrp DevObj %p Irp %p", 
              DeviceObject,
              Irp );

    if ( physicalDisk->DiskState != DiskOnline ) {
        CDLOGF(WRITE,"ClusDiskIoCompletion: CompletedIrpNotOnline DevObj %p Irp %p %!diskstate!", 
                  DeviceObject,
                  Irp,
                  physicalDisk->DiskState );
        CDLOG( "ClusDiskIoCompletion: CompletedIrpNotOnline2 DevObj %p Irp %p %!diskstate!",
                DeviceObject,
                Irp,
                physicalDisk->DiskState );
    }

    ReleaseRemoveLock( &deviceExtension->RemoveLock, Irp );
    ReleaseRemoveLock( &physicalDisk->RemoveLock, Irp );
    
    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }
    return STATUS_SUCCESS;


} // ClusDiskIoCompletion



NTSTATUS
ClusDiskUpdateDriveLayout(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called after an IOCTL to set drive layout completes.
    It attempts to attach to each partition in the system. If it fails
    then it is assumed that clusdisk has already attached.  After
    the attach the new device extension is set up to point to the
    device extension representing the physical disk.  There are no
    data items or other pointers that need to be cleaned up on a
    per partition basis.

Arguments:

    PhysicalDeviceObject - Pointer to device object for the disk just changed.
    Irp          - IRP involved.

Return Value:

    NT Status

--*/

{
    PCLUS_DEVICE_EXTENSION physicalExtension = PhysicalDeviceObject->DeviceExtension;
    ULONG             partitionNumber = physicalExtension->LastPartitionNumber;
    PDEVICE_OBJECT    targetObject;
    PDEVICE_OBJECT    deviceObject;
    PCLUS_DEVICE_EXTENSION deviceExtension;
    WCHAR             ntDeviceName[MAX_PARTITION_NAME_LENGTH];
    STRING            ntString;
    UNICODE_STRING    ntUnicodeString;
    PFILE_OBJECT      fileObject;
    NTSTATUS          status;
    KIRQL             irql;

    //
    // Attach to any new partitions created by the set layout call.
    //

    do {

        //
        // Get first/next partition.  Already attached to the disk,
        // otherwise control would not have been passed to this driver
        // on the device I/O control.
        //

        partitionNumber++;

        //
        // Create unicode NT device name.
        //

        swprintf(ntDeviceName,
                 DEVICE_PARTITION_NAME,
                 physicalExtension->DiskNumber,
                 partitionNumber);
        WCSLEN_ASSERT( ntDeviceName );

        RtlInitUnicodeString(&ntUnicodeString, ntDeviceName);

        //
        // Get target device object.
        //

        status = IoGetDeviceObjectPointer(&ntUnicodeString,
                                          FILE_READ_ATTRIBUTES,
                                          &fileObject,
                                          &targetObject);

        //
        // If this fails then it is because there is no such device
        // which signals completion.
        //

        if ( !NT_SUCCESS(status) ) {
            break;
        }

        //
        // Dereference file object as these are the rules.
        //

        ObDereferenceObject(fileObject);

        //
        // Check if this device is already mounted.
        //

        if ( (targetObject->Vpb &&
             (targetObject->Vpb->Flags & VPB_MOUNTED)) ) {

            //
            // Assume this device has already been attached.
            //

            continue;
        }

        //
        // Create device object for this partition.
        //

        status = IoCreateDevice(physicalExtension->DriverObject,
                                sizeof(CLUS_DEVICE_EXTENSION),
                                NULL, // XXXX
                                FILE_DEVICE_DISK,
                                0,
                                FALSE,
                                &deviceObject);

        if ( !NT_SUCCESS(status) ) {
            continue;
        }

        deviceObject->Flags |= DO_DIRECT_IO;
        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

        //
        // Point device extension back at device object.
        //

        deviceExtension = deviceObject->DeviceExtension;
        deviceExtension->DeviceObject = deviceObject;

        //
        // Store pointer to physical device and disk/driver information.
        //
        ObReferenceObject( PhysicalDeviceObject );
        deviceExtension->PhysicalDevice = PhysicalDeviceObject;
        deviceExtension->DiskNumber = physicalExtension->DiskNumber;
        deviceExtension->DriverObject = physicalExtension->DriverObject;
        deviceExtension->BusType = physicalExtension->BusType;
        deviceExtension->ReserveTimer = 0;
        deviceExtension->PerformReserves = FALSE;
        deviceExtension->ReserveFailure = 0;
        deviceExtension->Signature = physicalExtension->Signature;
        deviceExtension->Detached = TRUE;
        deviceExtension->OfflinePending = FALSE;
        InitializeListHead( &deviceExtension->WaitingIoctls );
        InitializeListHead( &deviceExtension->HoldIO );
    
        IoInitializeRemoveLock( &deviceExtension->RemoveLock, CLUSDISK_ALLOC_TAG, 0, 0 );

        //
        // Signal the worker thread running event.
        //
        KeInitializeEvent( &deviceExtension->Event, NotificationEvent, TRUE );

        KeInitializeEvent( &deviceExtension->PagingPathCountEvent,
                           NotificationEvent, TRUE );
        deviceExtension->PagingPathCount = 0;
        deviceExtension->HibernationPathCount = 0;
        deviceExtension->DumpPathCount = 0;

        ExInitializeResourceLite( &deviceExtension->DriveLayoutLock );
        
        //
        // Update the highest partition number in partition zero
        // and store the same value in this new extension just to initialize
        // the field.
        //

        physicalExtension->LastPartitionNumber =
            deviceExtension->LastPartitionNumber = partitionNumber;

        //
        // Attach to the partition. This call links the newly created
        // device to the target device, returning the target device object.
        //
        status = IoAttachDevice(deviceObject,
                                &ntUnicodeString,
                                &deviceExtension->TargetDeviceObject);

        if ( (!NT_SUCCESS(status)) || (status == STATUS_OBJECT_NAME_EXISTS) ) {

            //
            // Assume this device is already attached.
            //
            IoDeleteDevice(deviceObject);
        } else {

            //
            // Propagate driver's alignment requirements and power flags.
            //
            deviceExtension->Detached = FALSE;

            deviceObject->AlignmentRequirement =
                deviceExtension->TargetDeviceObject->AlignmentRequirement;

            deviceObject->SectorSize =
                deviceExtension->TargetDeviceObject->SectorSize;

            //
            // The storage stack explicitly requires DO_POWER_PAGABLE to be
            // set in all filter drivers *unless* DO_POWER_INRUSH is set.
            // this is true even if the attached device doesn't set DO_POWER_PAGABLE.
            //
            if ( deviceExtension->TargetDeviceObject->Flags & DO_POWER_INRUSH) {
                deviceObject->Flags |= DO_POWER_INRUSH;
            } else {
                deviceObject->Flags |= DO_POWER_PAGABLE;
            }

        }
    } while (TRUE);

    return Irp->IoStatus.Status;

} // ClusDiskUpdateDriveLayout



NTSTATUS
ClusDiskGetRunningDevices(
    IN PVOID Buffer,
    IN ULONG BufferSize
    )

/*++

Routine Description:

    Find out the list of signatures for devices with active reservations.

Arguments:

Return Value:

--*/

{
    ULONG           bufferSize = BufferSize;
    PULONG          itemCount = (PULONG)Buffer;
    PULONG          nextSignature;
    PDEVICE_OBJECT  deviceObject;
    PCLUS_DEVICE_EXTENSION deviceExtension;
    KIRQL           irql;

    if ( bufferSize < sizeof(ULONG) ) {
        return(STATUS_BUFFER_TOO_SMALL);
    }

    bufferSize -= sizeof(ULONG);

    *itemCount = 0;
    nextSignature = itemCount+1;

    KeAcquireSpinLock(&ClusDiskSpinLock, &irql);
    deviceObject = RootDeviceObject->DriverObject->DeviceObject;

    //
    // For each ClusDisk device, if we have a persistent reservation, then
    // add it.
    //
    while ( deviceObject ) {
        deviceExtension = deviceObject->DeviceExtension;
        if ( (deviceExtension->BusType != RootBus) &&
             deviceExtension->ReserveTimer &&
             (deviceExtension->PhysicalDevice == deviceObject) ) {
            if ( bufferSize < sizeof(ULONG) ) {
                break;
            }
            bufferSize -= sizeof(ULONG);
            *itemCount = *itemCount + 1;
            *nextSignature++ = deviceExtension->Signature;
        }
        deviceObject = deviceObject->NextDevice;
    }
    KeReleaseSpinLock(&ClusDiskSpinLock, irql);

    return(STATUS_SUCCESS);

} // ClusDiskGetRunningDevices



NTSTATUS
GetScsiPortNumber(
    IN ULONG DiskSignature,
    IN PUCHAR DiskPortNumber
    )

/*--

Routine Description:

    Find the Scsi Port Number for the given device signature.

Arguments:

    DiskSignature - supplies the disk signature for the requested device.

    DiskPortNumber - returns the corresponding Scsi Port Number if found.

Return Value:

    NTSTATUS

--*/

{
    ULONG                       driveLayoutSize;
    PDRIVE_LAYOUT_INFORMATION   driveLayout = NULL;
    ULONG                       diskCount;
    ULONG                       diskNumber;
    WCHAR                       deviceNameBuffer[MAX_PARTITION_NAME_LENGTH];
    UNICODE_STRING              unicodeString;
    NTSTATUS                    status = STATUS_UNSUCCESSFUL;
    OBJECT_ATTRIBUTES           objectAttributes;
    IO_STATUS_BLOCK             ioStatus;
    HANDLE                      ntFileHandle = NULL;
    SCSI_ADDRESS                scsiAddress;
    HANDLE                      eventHandle;
    PCONFIGURATION_INFORMATION  configurationInformation;


    //
    // Get the system configuration information to get number of disks.
    //
    configurationInformation = IoGetConfigurationInformation();

    // Allocate a drive layout buffer.
    driveLayoutSize = sizeof(DRIVE_LAYOUT_INFORMATION) +
        (MAX_PARTITIONS * sizeof(PARTITION_INFORMATION));
    driveLayout = ExAllocatePool( NonPagedPoolCacheAligned,
                                  driveLayoutSize );
    if ( driveLayout == NULL ) {
        ClusDiskPrint((
                  1,
                  "[ClusDisk] GetScsiPortNumber: Failed to allocate root drive layout structure.\n"
                  ));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    *DiskPortNumber = 0xff;

    // Find the disk with the right signature
    for ( diskNumber = 0;
          diskNumber < configurationInformation->DiskCount;
          diskNumber++ ) {

         if ( ntFileHandle ) {
            ZwClose( ntFileHandle );
            ntFileHandle = NULL;
         }
         swprintf(deviceNameBuffer, DEVICE_PARTITION_NAME, diskNumber, 0);
         WCSLEN_ASSERT( deviceNameBuffer );

         // Create device name for the physical disk.
         RtlInitUnicodeString(&unicodeString, deviceNameBuffer);

         // Setup object attributes for the file to open.
         InitializeObjectAttributes(&objectAttributes,
                                    &unicodeString,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL);

         // Open the device.
         status = ZwCreateFile( &ntFileHandle,
                           FILE_READ_DATA,
                           &objectAttributes,
                           &ioStatus,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN,
                           FILE_SYNCHRONOUS_IO_NONALERT,
                           NULL,
                           0 );

         if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((
                    1,
                    "[ClusDisk] GetScsiPortNumber: Failed to open device [%ws]. Error %lx.\n",
                    deviceNameBuffer,
                    status ));

            ExFreePool( driveLayout );
            return(status);
         }

         // Create event for notification.
        status = ZwCreateEvent( &eventHandle,
                                EVENT_ALL_ACCESS,
                                NULL,
                                SynchronizationEvent,
                                FALSE );

         if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((
                        1,
                        "[ClusDisk] GetScsiPortNumber: Failed to create event. %08X\n",
                        status));

            ExFreePool( driveLayout );
            ZwClose( ntFileHandle );
            return(status);
         }

         status = ZwDeviceIoControlFile( ntFileHandle,
                                        eventHandle,
                                        NULL,
                                        NULL,
                                        &ioStatus,
                                        IOCTL_DISK_GET_DRIVE_LAYOUT,
                                        NULL,
                                        0,
                                        driveLayout,
                                        driveLayoutSize );
         ZwClose( eventHandle );

         if ( NT_SUCCESS(status) ) {
            if ( DiskSignature == driveLayout->Signature ) {
               // Create event for notification.
               status = ZwCreateEvent( &eventHandle,
                                EVENT_ALL_ACCESS,
                                NULL,
                                SynchronizationEvent,
                                FALSE );

               if ( !NT_SUCCESS(status) ) {
                  ClusDiskPrint((
                                1,
                                "[ClusDisk] GetScsiPortNumber: Failed to create event. %08X\n",
                                status));

                  ExFreePool( driveLayout );
                  ZwClose( ntFileHandle );
                  return(status);
               }

               // Get the port number for the SystemRoot disk device.
               status = ZwDeviceIoControlFile( ntFileHandle,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &ioStatus,
                                    IOCTL_SCSI_GET_ADDRESS,
                                    NULL,
                                    0,
                                    &scsiAddress,
                                    sizeof(SCSI_ADDRESS) );

               if ( NT_SUCCESS(status) ) {
                  *DiskPortNumber = scsiAddress.PortNumber;
                  break;
               } else {
                  ClusDiskPrint((
                                1,
                                "[ClusDisk] GetScsiAddress FAILED. Error %lx\n",
                                 status));
               }

            } else {
               continue;
            }
         } else {
            ClusDiskPrint((
                          1,
                          "[ClusDisk] GetScsiAddress, GetDriveLayout FAILED. Error %lx.\n",
                          status));
         }
    }

    if ( ntFileHandle ) {
        ZwClose( ntFileHandle );
    }

    ExFreePool( driveLayout );

    return(status);

} // GetScsiPortNumber



NTSTATUS
IsDiskClusterCapable(
    IN UCHAR PortNumber,
    OUT PBOOLEAN IsCapable
    )

/*++

Routine Description:

    Check if a given SCSI port device supports cluster manageable SCSI devices.

Arguments:

    PortNumber - the port number for the SCSI device.

    IsCapable - returns whether the SCSI device is cluster capable. That is,
            supports, RESERVE/RELEASE/BUS RESET, etc.

Return Value:

--*/

{
    WCHAR               deviceNameBuffer[64];
    UNICODE_STRING      deviceNameString;
    NTSTATUS            status;
    OBJECT_ATTRIBUTES   objectAttributes;
    IO_STATUS_BLOCK     ioStatus;
    HANDLE              ntFileHandle;
    HANDLE              eventHandle;
    SRB_IO_CONTROL      srbControl;


   *IsCapable = TRUE;       // Err on the side of being usable.

   swprintf(deviceNameBuffer, L"\\Device\\Scsiport%d", PortNumber);
   WCSLEN_ASSERT( deviceNameBuffer );

   // Create device name for the scsiport driver
   RtlInitUnicodeString(&deviceNameString, deviceNameBuffer);

   // Setup object attributes for the file to open.
   InitializeObjectAttributes(&objectAttributes,
                              &deviceNameString,
                              OBJ_CASE_INSENSITIVE,
                              NULL,
                              NULL);

   // Open the device.
   status = ZwCreateFile( &ntFileHandle,
                           FILE_READ_DATA,
                           &objectAttributes,
                           &ioStatus,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN,
                           FILE_SYNCHRONOUS_IO_NONALERT,
                           NULL,
                           0 );

   if ( !NT_SUCCESS(status) ) {
      ClusDiskPrint((1,
                     "[ClusDisk] IsDiskClusterCapable: Failed to open device [%ws]. Error %08X.\n",
                     deviceNameString, status ));
      return(status);
   }

   // Create event for notification.
   status = ZwCreateEvent( &eventHandle,
                           EVENT_ALL_ACCESS,
                           NULL,
                           SynchronizationEvent,
                           FALSE );

   if ( !NT_SUCCESS(status) ) {
      ClusDiskPrint((1, "[ClusDisk] IsDiskClusterCapable: Failed to create event. %08X\n",
                     status));

      ZwClose( ntFileHandle );
      return(status);
   }

   srbControl.HeaderLength = sizeof(SRB_IO_CONTROL);
   RtlMoveMemory( srbControl.Signature, "CLUSDISK", 8 );
   srbControl.Timeout = 3;
   srbControl.Length = 0;
   srbControl.ControlCode = IOCTL_SCSI_MINIPORT_NOT_QUORUM_CAPABLE;

   status = ZwDeviceIoControlFile(ntFileHandle,
                                  eventHandle,
                                  NULL,
                                  NULL,
                                  &ioStatus,
                                  IOCTL_SCSI_MINIPORT,
                                  &srbControl,
                                  sizeof(SRB_IO_CONTROL),
                                  NULL,
                                  0 );

   if ( NT_SUCCESS(status) ) {
      *IsCapable = TRUE;
   } else {
      ClusDiskPrint((3,
                     "[ClusDisk] IsDiskClusterCapable: NOT_QUORUM_CAPABLE IOCTL FAILED. Error %08X.\n",
                     status));
   }

   ZwClose( eventHandle );
   ZwClose( ntFileHandle );

   return(status);

}  // IsDiskClusterCapable


VOID
ClusDiskResumeIO(
    PDEVICE_OBJECT DeviceObject
    )

/*++

--*/

{
    PLIST_ENTRY             listEntry;
    PIRP                    irp;
    KIRQL                   irql;
    PDEVICE_OBJECT          clusterDeviceObject;
    PCLUS_DEVICE_EXTENSION  deviceExtension;
    PCLUS_DEVICE_EXTENSION  physicalDisk;
    PDEVICE_OBJECT          targetDeviceObject;
    REPLACE_CONTEXT         context;

    CDLOG( "ClusDiskResumeIO(%p): Entry", DeviceObject );

    IoAcquireCancelSpinLock( &irql );
    KeAcquireSpinLockAtDpcLevel(&ClusDiskSpinLock);    

    clusterDeviceObject = DeviceObject->DriverObject->DeviceObject;
    while ( clusterDeviceObject ) {
        deviceExtension = clusterDeviceObject->DeviceExtension;
        //physicalDisk = deviceExtension->PhysicalDevice->DeviceExtension;
        if ( deviceExtension->DiskState == DiskStalled ) {
            targetDeviceObject = deviceExtension->TargetDeviceObject;

            while ( !IsListEmpty(&deviceExtension->HoldIO ) ) {
                listEntry = RemoveHeadList(&deviceExtension->HoldIO);
                irp = CONTAINING_RECORD( listEntry,
                                         IRP,
                                         Tail.Overlay.ListEntry );
                IoSetCancelRoutine(irp, NULL);

                KeReleaseSpinLockFromDpcLevel(&ClusDiskSpinLock);
                IoReleaseCancelSpinLock( irql );

                ReleaseRemoveLock(&deviceExtension->RemoveLock, irp);
                               
                if (irp->Cancel) {

                    CDLOG( "ResumeIo: CompleteCanceled irp %p", irp );
                    irp->IoStatus.Status = STATUS_CANCELLED;
                    IoCompleteRequest(irp, IO_NO_INCREMENT);
                    
                } else {
                    ClusDiskPrint((1, "[ClusDisk] ResumeIO: Resume IRP %p, target %p Q: %p \n",
                            irp, targetDeviceObject, &deviceExtension->HoldIO ));
                    //
                    // We must bump the stack location here, in case we cancel
                    // the I/O.
                    //
                    
                    IoSkipCurrentIrpStackLocation( irp );
                    
                    IoCallDriver(targetDeviceObject,
                                 irp);
                }
                IoAcquireCancelSpinLock( &irql );
                KeAcquireSpinLockAtDpcLevel(&ClusDiskSpinLock);    
//              KeAcquireSpinLock(&ClusDiskSpinLock, &irql);
            }

            ASSERT_RESERVES_STARTED( deviceExtension );
            // deviceExtension->DiskState = DiskOnline;
            ONLINE_DISK( deviceExtension );
            ClusDiskPrint(( 3, 
                            "[ClusDisk] ResumeIO: Marking signature %08X online \n",
                            deviceExtension->Signature ));
        
        }

        // Advance to next device

        clusterDeviceObject = clusterDeviceObject->NextDevice;
    }

//  KeReleaseSpinLock(&ClusDiskSpinLock, irql);
    KeReleaseSpinLockFromDpcLevel(&ClusDiskSpinLock);
    IoReleaseCancelSpinLock( irql );

    //
    // Before we did HoldIo, we opened a handles to all volumes
    // to be able to dismount if we decide to offline the disks while HoldIo
    // is in progress. Clean them up now.
    //

    clusterDeviceObject = DeviceObject->DriverObject->DeviceObject;
    while ( clusterDeviceObject ) {
        deviceExtension = clusterDeviceObject->DeviceExtension;
        
        if (deviceExtension->PhysicalDevice == clusterDeviceObject) {
            
            context.DeviceExtension = deviceExtension;
            context.NewValue        = NULL;     // clean up
            context.Flags           = 0;        // don't dismount
            
            ProcessDelayedWorkSynchronous( clusterDeviceObject, ClusDiskpReplaceHandleArray, &context );
        }
        
        clusterDeviceObject = clusterDeviceObject->NextDevice;
    }
    

    CDLOG( "ClusDiskResumeIO(%p): Exit", DeviceObject );

    return;

} // ClusDiskResumeIO

NTSTATUS
ClusDiskCreateHandle(
    OUT PHANDLE     pHandle,
    IN  ULONG       DiskNumber,
    IN  ULONG       PartitionNumber,
    IN  ACCESS_MASK DesiredAccess
    )
/*++

Routine Description:

    Open a file handle to self

Arguments:

    DeviceObject - 
    DesiredAccess - acces mask to be passed to create file

Return Value:

    Status is returned.

--*/
{
    WCHAR                   deviceNameBuffer[ MAX_PARTITION_NAME_LENGTH ];
    UNICODE_STRING          deviceName;
    IO_STATUS_BLOCK         ioStatus;
    OBJECT_ATTRIBUTES       objectAttributes;
    NTSTATUS                status;

    swprintf( deviceNameBuffer, DEVICE_PARTITION_NAME, 
              DiskNumber, 
              PartitionNumber );
              
    RtlInitUnicodeString( &deviceName, deviceNameBuffer );

    CDLOG( "CreateHandle(%wZ): Entry", &deviceName );

    InitializeObjectAttributes( &objectAttributes,
                                &deviceName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    *pHandle = 0;
    
    status = ZwCreateFile( pHandle,
                           DesiredAccess,
                           &objectAttributes,
                           &ioStatus,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN,
                           FILE_SYNCHRONOUS_IO_NONALERT,
                           NULL,
                           0 );

    CDLOG( "CreateHandle: Exit status %!status! handle %p", status, *pHandle );
    return status;
}


VOID
ClusDiskpReplaceHandleArray(
    PDEVICE_OBJECT DeviceObject,
    PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    Replaces handle array stored in the device extension with a new one.
    Use NULL as a NewValue to clean up the field.

    It will close all the handles stored in the array and free up the memory block.

    If DO_DISMOUNT is specified, it will call FSCTL_DISMOUNT for every handle
    
Arguments:

    DeviceObject - Partition0 Device Object
    
    WorkContext - General context info and routine specific context info.

Return Value:

    Status is returned.

--*/
{
    PREPLACE_CONTEXT    Context = WorkContext->Context;
    PCLUS_DEVICE_EXTENSION  deviceExtension = Context->DeviceExtension;
    HANDLE* OldArray;

    CDLOG( "ClusDiskpReplaceHandleArray: Entry NewValue %p Flags %x",
           Context->NewValue,
           Context->Flags );

    OldArray =
        InterlockedExchangePointer(
            (VOID*)&deviceExtension->VolumeHandles, Context->NewValue);

    //
    // We can release the remove lock now (in some instances).  This prevents a deadlock
    // between the DismountDevice routine and the Remove PnP IRP.  During dismount, we
    // have saved a copy of the handle array, and we no longer refer to the device object
    // or extension.
    //
    
    if ( Context->Flags & RELEASE_REMOVE_LOCK ) {
        ReleaseRemoveLock(&deviceExtension->RemoveLock, deviceExtension);
    }
        
    if (OldArray) {
        ULONG i;
        ULONG Count = PtrToUlong( OldArray[0] );

        //
        // We should already be running in the system process.  If not, then there
        // is an error and we need to exit.
        //
        
        if ( ClusDiskSystemProcess != (PKPROCESS) IoGetCurrentProcess() ) {
            CDLOG( "ClusDiskpReplaceHandleArray: Not running in system process" );
            ExFreePool( OldArray );
            goto FnExit;                   
        }

        for(i = 1; i <= Count; ++i) {
            if (OldArray[i]) {
                
                ClusDiskPrint(( 3,
                                "[ClusDisk] ClusDiskpReplaceHandleArray: Handle %x \n", 
                                OldArray[i] ));
                
                if (Context->Flags & DO_DISMOUNT) {
                    DismountDevice(OldArray[i]);
                }
                ZwClose(OldArray[i]);
            }
        }

        CDLOG("ClusDiskpReplaceHandleArray: Freed oldArray %p", OldArray );
        ExFreePool( OldArray );
    }            

FnExit:

    CDLOG( "ClusDiskpReplaceHandleArray: Exit" );

    ClusDiskPrint(( 3,
                    "[ClusDisk] ClusDiskpReplaceHandleArray: Returns \n" ));

    KeSetEvent( &WorkContext->CompletionEvent, IO_NO_INCREMENT, FALSE );

}   // ClusDiskpReplaceHandleArray


NTSTATUS
ProcessDelayedWorkSynchronous(
    PDEVICE_OBJECT DeviceObject,
    PVOID WorkerRoutine,
    PVOID Context
    )
/*++

Routine Description:

    Call the WorkerRoutine directly if we are running in the system process.  If
    we are not running in the system process, check the IRQL.  If the IRQL is
    PASSIVE_LEVEL, queue the WorkerRoutine as a work item and wait for it to complete.
    When the work item completes, it will set an event.  
    
    If the IRQL is not PASSIVE_LEVEL, then this routine will return an error.
    
Arguments:

    DeviceObject 
    
    WorkerRoutine - Routine to run.
                    
    Context - Context information for the WorkerRoutine.                    

Return Value:

    Status is returned.

--*/
{
    PIO_WORKITEM            workItem = NULL;
    PWORK_CONTEXT           workContext = NULL;
    
    NTSTATUS                status = STATUS_UNSUCCESSFUL;
                             
    __try {                             

        ClusDiskPrint(( 3,
                        "[ClusDisk] DelayedWorkSync: Entry \n" ));

        //
        // Prepare a context structure.
        //
        
        workContext = ExAllocatePool( NonPagedPool, sizeof(WORK_CONTEXT) );
        
        if ( !workContext ) {
            ClusDiskPrint(( 1,
                            "[ClusDisk] DelayedWorkSync: Failed to allocate WorkContext \n" ));
            __leave;
        }

        KeInitializeEvent( &workContext->CompletionEvent, SynchronizationEvent, FALSE );

        workContext->DeviceObject = DeviceObject;
        workContext->FinalStatus = STATUS_SUCCESS;
        workContext->Context = Context;

        //
        // If we are in the system process, we can call the worker routine directly.
        //
        
        if ( (PKPROCESS)IoGetCurrentProcess() == ClusDiskSystemProcess ) {

            ClusDiskPrint(( 3,
                            "[ClusDisk] DelayedWorkSync: Calling WorkerRoutine directly \n" ));
            
            ((PIO_WORKITEM_ROUTINE)WorkerRoutine)( DeviceObject, workContext );
            __leave;
        }
        
        //
        // If we are not running at passive level, we cannot continue.
        //
        
        if ( PASSIVE_LEVEL != KeGetCurrentIrql() ) {
            ClusDiskPrint(( 1,
                            "[ClusDisk] DelayedWorkSync: IRQL not PASSIVE_LEVEL \n" ));
            __leave;
        }
        
        workItem = IoAllocateWorkItem( DeviceObject );
    
        if ( NULL == workItem ) {
            ClusDiskPrint(( 1,
                            "[ClusDisk] DelayedWorkSync: Failed to allocate WorkItem \n" ));
            __leave;
        }    

        //
        // Queue the workitem.  IoQueueWorkItem will insure that the device object is
        // referenced while the work-item progresses.
        //
                                
        ClusDiskPrint(( 3,
                        "[ClusDisk] DelayedWorkSync: Queuing work item \n" ));
        
        IoQueueWorkItem( workItem,
                         WorkerRoutine,
                         DelayedWorkQueue,
                         workContext );
                         
        KeWaitForSingleObject( &workContext->CompletionEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        ClusDiskPrint(( 3,
                        "[ClusDisk] DelayedWorkSync: Work item completed \n" ));
                                                        
    
    } __finally {

        if ( workItem) {
            IoFreeWorkItem( workItem );
        }
    
        if ( workContext ) {
            status = workContext->FinalStatus;
            
            ExFreePool( workContext );
        }
        
    }
    
    ClusDiskPrint(( 3,
                    "[ClusDisk] DelayedWorkSync: Returning status %08X \n", status ));
                    
    return status;                    

}   // ProcessDelayedWorkSynchronous


VOID
ClusDiskpOpenFileHandles( 
    PDEVICE_OBJECT Part0DeviceObject,
    PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    Creates file handles for all partitions on the disk.

Arguments:

    DeviceObject - Partition0 Device Object

    WorkContext - General context info and routine specific context info.

Return Value:

    Status is returned.

--*/

{
    NTSTATUS                  status;
    NTSTATUS                  returnStatus = STATUS_SUCCESS;
    PCLUS_DEVICE_EXTENSION    deviceExtension = 
                                Part0DeviceObject->DeviceExtension;
    PDEVICE_OBJECT            deviceObject;
    PDRIVE_LAYOUT_INFORMATION pDriveLayout;
    ULONG                     partitionCount;
    ULONG                     i;
    HANDLE*                   HandleArray = NULL;
    ULONG                     ArraySize;
    REPLACE_CONTEXT           context;
    
    CDLOG( "OpenFileHandles(%p): Entry", Part0DeviceObject );

    ASSERT( (deviceExtension->PhysicalDevice == Part0DeviceObject)
         && (Part0DeviceObject != RootDeviceObject) );

    pDriveLayout = ClusDiskGetPartitionInfo( deviceExtension );
    if (NULL == pDriveLayout) {
        returnStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto exit_gracefully;
    }
    partitionCount = pDriveLayout->PartitionCount;
    ExFreePool(pDriveLayout);

    ArraySize = (partitionCount + 1) * sizeof(HANDLE);

    //
    // If we are not running in the system process, we can't continue.
    //
    
    if ( ClusDiskSystemProcess != (PKPROCESS) IoGetCurrentProcess() ) {
        CDLOG("OpenFileHandles: Not running in system process" );
        returnStatus = STATUS_UNSUCCESSFUL;
        goto exit_gracefully;
    }

    HandleArray = 
        ExAllocatePool(PagedPool, ArraySize );

    if (!HandleArray) {
        CDLOG("OpenFileHandles: AllocFailed ArraySize %d", ArraySize );
        returnStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto exit_gracefully;
    }

    //
    // Store the size of the array in the first element
    //

    HandleArray[0] = (HANDLE)( UlongToPtr(partitionCount) );

    for(i = 1; i <= partitionCount; ++i) {
        HANDLE FileHandle;

        status = ClusDiskCreateHandle( 
                    &FileHandle,
                    deviceExtension->DiskNumber, 
                    i,
                    FILE_WRITE_ATTRIBUTES);     // Use FILE_WRITE_ATTRIBUTES for dismount

        if (NT_SUCCESS(status)) {
            HandleArray[i] = FileHandle;
        } else {
            HandleArray[i] = 0;
            returnStatus = status;
        }
    }

    context.DeviceExtension = deviceExtension;
    context.NewValue        = HandleArray;
    context.Flags           = 0;        // don't dismount
    
    ProcessDelayedWorkSynchronous( Part0DeviceObject, ClusDiskpReplaceHandleArray, &context );

exit_gracefully:    
    CDLOG( "OpenFileHandles: Exit => %!status!", returnStatus );

    ClusDiskPrint(( 3,
                    "[ClusDisk] ClusDiskpOpenFileHandles: Returning status %08X \n", returnStatus ));

    WorkContext->FinalStatus = returnStatus;
    
    KeSetEvent( &WorkContext->CompletionEvent, IO_NO_INCREMENT, FALSE );

}   // ClusDiskpOpenFileHandles


NTSTATUS
ClusDiskDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This device control dispatcher handles only the cluster disk
    device control. All others are passed down to the disk drivers.

Arguments:

    DeviceObject - Context for the activity.
    Irp          - The device control argument block.

Return Value:

    Status is returned.

--*/

{
    PCLUS_DEVICE_EXTENSION      deviceExtension = DeviceObject->DeviceExtension;
    PCLUS_DEVICE_EXTENSION      physicalDisk =
                                    deviceExtension->PhysicalDevice->DeviceExtension;
    PDEVICE_OBJECT              targetDeviceObject;
    PIO_STACK_LOCATION          currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PIO_STACK_LOCATION          nextIrpStack = IoGetNextIrpStackLocation(Irp);
    PUCHAR                      ioDiskState = Irp->AssociatedIrp.SystemBuffer;
    UCHAR                       newDiskState;
    UCHAR                       oldDiskState;
    ULONG                       returnLength = 0;
    ULONG                       access;
    NTSTATUS                    status = STATUS_SUCCESS;
    PSTORAGE_BUS_RESET_REQUEST  storageReset;
    BOOLEAN                     settingNewState = FALSE;
    KIRQL                       irql;
    PULONG                      reserveSignature;
    ULONG                       signature;
    PSRB_IO_CONTROL             srbControl;
    BOOLEAN                     isCapable;
    LARGE_INTEGER               waitTime;

    //
    // Note that we are going to acquire two RemoveLocks here: one for the original DO and one
    // for the physical device (pointed to this DO's device extension).  Whenever an IRP is 
    // queued, we release one RemoveLock in this routine - release the RemoveLock in the device
    // extension NOT containing the queued IRP.  The routine that processes the queued IRP will
    // release the RemoveLock as it has the proper device extension.
    //
    // This should work correctly even if the DO and the physical device point to the same DO, since
    // the RemoveLock is really just a counter, we will increment the counter for the DO twice and
    // decrement it once here, and once when the IRP is completed.
    
    status = AcquireRemoveLock(&deviceExtension->RemoveLock, Irp);
    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] ClusDiskDeviceControl: AcquireRemoveLock for %p failed %08X \n", 
                deviceExtension,
                status));
         Irp->IoStatus.Status = status;
         IoCompleteRequest(Irp, IO_NO_INCREMENT);
         return status;
    }

    status = AcquireRemoveLock(&physicalDisk->RemoveLock, Irp);
    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] ClusDiskDeviceControl: AcquireRemoveLock for %p (PD) failed %08X \n", 
                physicalDisk,
                status));
         ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
         Irp->IoStatus.Status = status;
         IoCompleteRequest(Irp, IO_NO_INCREMENT);
         return status;
    }
    
    //
    // Find out if this is directed at the root device. If so, we only
    // support ATTACH and DETACH.
    //
    if ( deviceExtension->BusType == RootBus ) {
        return(ClusDiskRootDeviceControl( DeviceObject, Irp ));
    }
    
    switch (currentIrpStack->Parameters.DeviceIoControl.IoControlCode) {


#if 0
    // Since we cannot get to the device object from the user mode when we
    // are holding IOs, we will use only ClusDisk0 to perform arbitration 
    // escape operations.
    // Remove, when Hold IO stuff is fully tested.
    

    // Arbitration support routine. Currently provides ability to read/write
    // physical sectors on the disk while the device is offline

    case IOCTL_DISK_CLUSTER_ARBITRATION_ESCAPE:
       if ( ARGUMENT_PRESENT( Irp->AssociatedIrp.SystemBuffer ) &&
           currentIrpStack->Parameters.DeviceIoControl.InputBufferLength >=
               sizeof(ULONG) ) {

           CDLOG("IoctlClusterArbitrationEscape: DO %p", DeviceObject );    

           status = ProcessArbitrationEscape( physicalDisk,
                                              Irp->AssociatedIrp.SystemBuffer,
                                              currentIrpStack->Parameters.DeviceIoControl.InputBufferLength,
                                              0);
       } else {
           status = STATUS_INVALID_PARAMETER;
       }

       ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
       ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
       Irp->IoStatus.Status = status;
       IoCompleteRequest(Irp, IO_NO_INCREMENT);
       return(status);
#endif       

    // Optionally set new state, and optionally get old state.

    case IOCTL_DISK_CLUSTER_SET_STATE:

        //
        // Save the old disk state.
        //

        oldDiskState = (UCHAR)physicalDisk->DiskState;

        ClusDiskPrint((3, "[ClusDisk] DeviceControl: PD DiskState %s,  devObj DiskState %s \n",
                       DiskStateToString( physicalDisk->DiskState ),
                       DiskStateToString( deviceExtension->DiskState ) ));
        // stevedz - remove this assert for now.  Why is part0 state different from partX state?
        // ASSERT( physicalDisk->DiskState == deviceExtension->DiskState );

        //
        // Check if input buffer supplied. If present, then this is the
        // new disk state.
        //

        if ( ARGUMENT_PRESENT( ioDiskState) &&
            currentIrpStack->Parameters.DeviceIoControl.InputBufferLength >=
                 sizeof(UCHAR) ) {
            newDiskState = ioDiskState[0];

            ClusDiskPrint((3, "[ClusDisk] DeviceControl: Setting state on disk %u (%p), state %s \n",
                        physicalDisk->DiskNumber,
                        DeviceObject,
                        DiskStateToString( newDiskState ) ));

            if ( newDiskState > DiskStateMaximum ) {
                status = STATUS_INVALID_PARAMETER;
            
            } else if ( DiskOfflinePending == newDiskState ) {

                //
                // We are not changing the current disk state, but the disk resource DLL is
                // telling us that we are in offline/terminate processing.  When NTFS is done
                // flushing the drive, it sends an IOCTL to unlock the media.  When we see
                // the unlock IOCTL and the offline pending flag is set, we know we can
                // immediately mark the disk as offline.
                //

                ClusDiskPrint(( 1,
                                "[ClusDisk] Set offline pending flag, Signature = %08lX \n",
                                physicalDisk->Signature ));
                                
                physicalDisk->OfflinePending = TRUE;
                
                settingNewState = FALSE;
                status = STATUS_SUCCESS;

            } else {

                if ( DiskOnline == newDiskState ) {
                    ASSERT_RESERVES_STARTED( physicalDisk );
                    physicalDisk->OfflinePending = FALSE;

                    //
                    // If current state is offline, then before bringing the disk
                    // online, we want to dismount the file systems if they are mounted.
                    //
                    
                    if ( DiskOffline == physicalDisk->DiskState ) {
                        ClusDiskDismountDevice( physicalDisk->DiskNumber, TRUE );
                    }
                    ONLINE_DISK( physicalDisk );
                } else if ( DiskOffline == newDiskState ) {
                    OFFLINE_DISK( physicalDisk );
                } else {
                    physicalDisk->DiskState = newDiskState;
                }

                CDLOG( "IoctlClusterSetState(%p): old %!diskstate! => new %!diskstate!", 
                       DeviceObject,
                       oldDiskState,
                       newDiskState );

                settingNewState = TRUE;
#if 0
                if ( oldDiskState != newDiskState ) {
                    // going from Online to Offline or Offline to Online
                    physicalDisk->ReserveTimer = RESERVE_TIMER;
                }
#endif
            }
        } else {
            ClusDiskPrint((3, "[ClusDisk] DeviceControl: Getting state from disk %u (%p), state %s \n",
                        physicalDisk->DiskNumber,
                        DeviceObject,
                        DiskStateToString( oldDiskState ) ));
        }


        if ( NT_SUCCESS(status) &&
             ARGUMENT_PRESENT( ioDiskState ) &&
             currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength >=
                 sizeof(UCHAR) ) {
            ioDiskState[0] = oldDiskState;
            returnLength = 1;
        }

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = returnLength;

        if ((status == STATUS_SUCCESS) &&
            settingNewState) {

            //
            // Call down to what's below.  If it's FT it will know what to do.
            // Any other driver will reject the ioctl.  However none of this
            // matters since we absolutely want to return to our caller the
            // results we just set up.  SO, we will use our current stack location
            // to save off the status, information, and pointer to the system buffer.
            // We will use the fourth stack location to hold the state we wish
            // to set the member to.
            //
#if 0 // We can't ignore the status from IoCallDriver!

            currentIrpStack->Parameters.Others.Argument1 = ioDiskState;
            (ULONG_PTR)currentIrpStack->Parameters.Others.Argument2 = Irp->IoStatus.Information;
            (BOOLEAN)currentIrpStack->Parameters.Others.Argument3 = newDiskState == DiskOnline;
            Irp->AssociatedIrp.SystemBuffer = &currentIrpStack->Parameters.Others.Argument3;

            nextIrpStack->Flags = currentIrpStack->Flags;
            nextIrpStack->MajorFunction = currentIrpStack->MajorFunction;
            nextIrpStack->MinorFunction = currentIrpStack->MinorFunction;
            nextIrpStack->Parameters.DeviceIoControl.OutputBufferLength = 0;
            nextIrpStack->Parameters.DeviceIoControl.InputBufferLength = sizeof(BOOLEAN);
            nextIrpStack->Parameters.DeviceIoControl.IoControlCode = FT_CLUSTER_SET_MEMBER_STATE;
            nextIrpStack->Parameters.DeviceIoControl.Type3InputBuffer = NULL;

            IoSetCompletionRoutine(
                Irp,
                CluSetFtMemberComplete,
                NULL,
                TRUE,
                TRUE,
                TRUE
                );

            return (IoCallDriver(deviceExtension->TargetDeviceObject, Irp));
#endif
            ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            IoCompleteRequest(Irp,IO_NO_INCREMENT);
            return(STATUS_SUCCESS);

        } else {

            ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            IoCompleteRequest(Irp,IO_NO_INCREMENT);
            return(status);

        }

    // Check the reservation timer

    case IOCTL_DISK_CLUSTER_ALIVE_CHECK:

        if ( RootDeviceObject == NULL ) {
            ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            return(STATUS_INVALID_DEVICE_REQUEST);
        }

        IoAcquireCancelSpinLock( &irql );
        KeAcquireSpinLockAtDpcLevel(&ClusDiskSpinLock);

        if ( (physicalDisk->DiskState == DiskOnline) &&
             (physicalDisk->ReserveTimer == 0) &&
             (!NT_SUCCESS(physicalDisk->ReserveFailure)) ) {
            status = physicalDisk->ReserveFailure;
        } else {
            if ( (physicalDisk->DiskState != DiskOnline) ||
                 (physicalDisk->ReserveTimer == 0) ) {
#if 0
            ClusDiskPrint((
                    1,
                    "[ClusDisk] DeviceControl, AliveCheck failed, signature %lx.\n",
                    physicalDisk->Signature ));
#endif
                status = STATUS_CANCELLED;
            } else {
                status = STATUS_SUCCESS;
            }
        }

        if ( status == STATUS_SUCCESS ) {
            NTSTATUS    newStatus;

            newStatus = ClusDiskMarkIrpPending( Irp, ClusDiskIrpCancel );
            if ( NT_SUCCESS( newStatus ) ) {
                InsertTailList( &physicalDisk->WaitingIoctls,
                                &Irp->Tail.Overlay.ListEntry );
                status = STATUS_PENDING;

                // Release only this DO RemoveLock.  The physical device RemoveLock
                // will be released when the IRP is removed from the queue.
                
                ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

            } else {
                status = newStatus;

                ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
                ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
                Irp->IoStatus.Status = status;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }

            KeReleaseSpinLockFromDpcLevel(&ClusDiskSpinLock);
            IoReleaseCancelSpinLock( irql );
        } else {
            KeReleaseSpinLockFromDpcLevel(&ClusDiskSpinLock);
            IoReleaseCancelSpinLock( irql );
            ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }

        return(status);

    // Perform a bus reset

    case IOCTL_DISK_CLUSTER_RESET_BUS:

        CDLOG( "IoctlBusReset(%p): Sig %08x PathId %d", 
               DeviceObject,
               deviceExtension->Signature,
               deviceExtension->ScsiAddress.PathId );
        
        if ( currentIrpStack->Parameters.DeviceIoControl.InputBufferLength <
             sizeof(STORAGE_BUS_RESET_REQUEST) ) {
            ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        *nextIrpStack = *currentIrpStack;
        storageReset = Irp->AssociatedIrp.SystemBuffer;
        storageReset->PathId = deviceExtension->ScsiAddress.PathId;

        nextIrpStack->Parameters.DeviceIoControl.OutputBufferLength = 0;
        nextIrpStack->Parameters.DeviceIoControl.InputBufferLength =
                                            sizeof(STORAGE_BUS_RESET_REQUEST);
        nextIrpStack->Parameters.DeviceIoControl.IoControlCode =
                                            IOCTL_STORAGE_BREAK_RESERVATION;

        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

        return(IoCallDriver(deviceExtension->TargetDeviceObject, Irp));

    case IOCTL_SCSI_GET_ADDRESS:

        IoSkipCurrentIrpStackLocation( Irp );

        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

        //
        // Pass this device control down to next driver layer.
        //

        return IoCallDriver(deviceExtension->TargetDeviceObject, Irp);


    // Perform unrestricted reserve

    case IOCTL_DISK_CLUSTER_RESERVE:

        CDLOG( "IoctlClusterReserve(%p): sig %08x", DeviceObject, deviceExtension->Signature );
        
        *nextIrpStack = *currentIrpStack;
        nextIrpStack->Parameters.DeviceIoControl.IoControlCode =
                                                           IOCTL_DISK_RESERVE;
        
        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        
        return IoCallDriver(deviceExtension->TargetDeviceObject, Irp);

    // Perform unrestricted get drive layout

    case IOCTL_DISK_CLUSTER_GET_DRIVE_LAYOUT:

        // This IOCTL can result in a read of the disk - so honor HoldIO
        //
        // Hold the I/O request if we are stalled.
        // First check for hint - i.e. with no lock held.
        //
        if ( deviceExtension->DiskState == DiskStalled ) {
            KeAcquireSpinLock(&ClusDiskSpinLock, &irql);
            //
            // Check again, with lock held - this one is valid!
            //
            if ( deviceExtension->DiskState == DiskStalled ) {
                ClusDiskPrint((1,"[ClusDisk] HoldCTL - pending IRP %p, target %p \n",
                               Irp, DeviceObject ));

                CDLOG("IoctlGetDriveLayout: Stall DO %p", DeviceObject );
                               
                InsertTailList( &deviceExtension->HoldIO,
                                &Irp->Tail.Overlay.ListEntry );
                
                // Release the physical device RemoveLock.  The original DO RemoveLock will
                // be released when the IRP is removed from the queue.
                
                ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
                
                KeReleaseSpinLock(&ClusDiskSpinLock, irql);
                return(STATUS_PENDING);
            }
            KeReleaseSpinLock(&ClusDiskSpinLock, irql);
        }
        *nextIrpStack = *currentIrpStack;
        nextIrpStack->Parameters.DeviceIoControl.IoControlCode =
                                                   IOCTL_DISK_GET_DRIVE_LAYOUT;
        
        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        
        return IoCallDriver(deviceExtension->TargetDeviceObject, Irp);

    // Perform unrestricted release

    case IOCTL_DISK_CLUSTER_RELEASE:

        CDLOG( "IoctlClusterRelease(%p): sig %08x", DeviceObject, deviceExtension->Signature );
        
        ClusDiskPrint((3,
                       "[ClusDisk] Release on signature %lx.\n",
                       deviceExtension->Signature ));

        physicalDisk->ReserveTimer = 0;
        *nextIrpStack = *currentIrpStack;
        nextIrpStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_DISK_RELEASE;
        Irp->IoStatus.Status = STATUS_SUCCESS;
        
        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        
        status = IoCallDriver(deviceExtension->TargetDeviceObject, Irp);
        ASSERT( status != STATUS_PENDING );
        return(STATUS_SUCCESS);

    // Check if this is the root device

    case IOCTL_DISK_CLUSTER_ROOT:

        if ( deviceExtension->BusType == RootBus ) {
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_INVALID_DEVICE_REQUEST;
        }

        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(status);

    // Check if low-level miniport driver support cluster devices.

    case IOCTL_DISK_CLUSTER_NOT_CLUSTER_CAPABLE:
        //
        // Make sure there is no input/output data buffer.
        //
        if ( Irp->AssociatedIrp.SystemBuffer != NULL ) {
            ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(STATUS_INVALID_PARAMETER);
        }

        //
        // Verifier found a problem with the original code.  The status returned
        // wasn't the same as Irp->IoStatus.Status.  The IRP status was always
        // success, but the dispatch routine sometimes returned an error.  This
        // seems to work but verifier says this is invalid.  When I changed the code
        // to update the IRP status with the same returned status, new drives 
        // couldn't be seen.  This is because the user mode component uses this
        // IOCTL to indicate the disk is NOT cluster capable, so the user mode
        // code looked for a failure to incidate a cluster disk.
        //
        
        // 
        // IsDiskClusterCapable always returns TRUE ???  
        //
        
        status = IsDiskClusterCapable ( deviceExtension->ScsiAddress.PortNumber,
                                        &isCapable);

        //
        // Fix for IBM.  The Win2000 2195 code returned from this IOCTL the status 
        // of the SCSI miniport IOCTL.  This was returned to DeviceIoControl rather
        // than the status in the IRP.  Changed to make the behavior the same as
        // Win20000 2195.
        //
        
        //
        // If the SCSI miniport IOCTL succeeds, we return success -- meaning we should
        // *not* use this disk.  If any of the routines failed while trying to issue 
        // the SCSI miniport IOCTL (including issuing the SCSI miniport IOCTL itself), 
        // then we return failure -- meaning we *should* use this disk.
        //

        Irp->IoStatus.Status = status;
        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        return(status);

    // Test if the Cluster Disk Filter driver is part of driver stack.

    case IOCTL_DISK_CLUSTER_NT4_CAPABLE:

        //
        // 2000/02/05: stevedz - start failing this IOCTL.
        //
        
        status = STATUS_INVALID_DEVICE_REQUEST;

        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(status);

    case IOCTL_DISK_CLUSTER_WAIT_FOR_CLEANUP:
    {
        ULONG waitTimeInSeconds;
        
        if ( currentIrpStack->Parameters.DeviceIoControl.InputBufferLength <
             sizeof(ULONG) || Irp->AssociatedIrp.SystemBuffer == NULL) {
            ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(STATUS_INVALID_PARAMETER);
        }

        waitTimeInSeconds = *(PULONG)Irp->AssociatedIrp.SystemBuffer;
        
        CDLOG( "IoctlWaitForCleanup(%p): Entry waitTime %d second(s)", 
                  DeviceObject,
                  waitTimeInSeconds );
    
        waitTime.QuadPart = (LONGLONG)waitTimeInSeconds * -(10000*1000);
        status = KeWaitForSingleObject(
                              &physicalDisk->Event,
                              Suspended,
                              KernelMode,
                              FALSE,
                              &waitTime);
        //
        // Reset the event in case of timeout.
        // [HACKHACK] should we do this?
        // No. If Offline worker is stuck somewhere, we better
        // go and debug the problem, rather then return success
        // and wait for the offline worker to do nasty things
        // behind our backs
        //
        //  KeSetEvent( &physicalExtension->Event, 0, FALSE );

        if (status == STATUS_TIMEOUT) {
            //
            // NT_SUCCESS considers STATUS_TIMEOUT as a success code
            // we need something stronger
            //
            status = STATUS_IO_TIMEOUT;
        }
                              
        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        CDLOG( "IoctlWaitForCleanup(%p): Exit => %!status!", 
                    DeviceObject,
                    status );
               
        return(status);
    }
        
    case IOCTL_DISK_CLUSTER_TEST:

        CDLOG( "IoctlDiskClusterTest(%p)", DeviceObject );

        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(STATUS_SUCCESS);

    case IOCTL_VOLUME_IS_CLUSTERED:

        //
        // Look at the reserve timer.  If reserved, this is a clustered disk.
        //
        
        if ( physicalDisk->ReserveTimer != 0 ) {
            status = STATUS_SUCCESS;
        } else {
            status = STATUS_UNSUCCESSFUL;
        }
        
        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(status);
    
    case IOCTL_DISK_CLUSTER_VOLUME_TEST:

        if ( deviceExtension->PhysicalDevice == DeviceObject ) {
            status = STATUS_ILLEGAL_FUNCTION;
        } else {
            status = STATUS_SUCCESS;
        }
        CDLOG( "IoctlDiskClusterVolumeTest(%p) => %!status!", DeviceObject, status );

        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(status);
    
    case IOCTL_DISK_MEDIA_REMOVAL: {

        PPREVENT_MEDIA_REMOVAL      mediaRemoval = Irp->AssociatedIrp.SystemBuffer;
        
        if ( currentIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(PREVENT_MEDIA_REMOVAL) ||
             NULL == mediaRemoval ) {

            ClusDiskPrint(( 1,
                            "[ClusDisk] IOCTL_DISK_MEDIA_REMOVAL invalid parameter, Signature = %08lX \n",
                            physicalDisk->Signature ));
            
            ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(STATUS_INVALID_PARAMETER);
        }

        ClusDiskPrint(( 3,
                        "[ClusDisk] IOCTL_DISK_MEDIA_REMOVAL: received, Signature = %08lX  OfflinePending = %d  PreventMedia = %d  \n",
                        physicalDisk->Signature,
                        physicalDisk->OfflinePending,
                        mediaRemoval->PreventMediaRemoval ));

#if 0   // Remove for now.  If we eject we cannot provent pagefile creation.

        if ( physicalDisk->OfflinePending && !mediaRemoval->PreventMediaRemoval ) {

            //
            // When the disk resource gets an offline or terminate request, we set
            // the OfflinePending flag.  When the disk resource asks NTFS to dismount
            // the volume (via FSCTL_DISMOUNT_VOLUME), the last thing NTFS does before
            // returning from the dismount request is to send IOCTL_DISK_MEDIA_REMOVAL
            // to unlock the media.  When we get this IOCTL, mark the disk offline
            // instead of waiting for the stop reserve request.  This should close
            // the window between the time the NTFS dismount occurs and the time
            // we previously marked the disk offline in stop reserve handler.
            //

            // physicalDisk->DiskState = DiskOffline;
            OFFLINE_DISK( physicalDisk );

            ClusDiskPrint(( 1,
                            "[ClusDisk] IOCTL_DISK_MEDIA_REMOVAL: Disk state set to offline, Signature = %08lX  \n",
                            physicalDisk->Signature ));

            physicalDisk->OfflinePending = FALSE;
        } 
#endif
        
        // FALL THROUGH

        IoSkipCurrentIrpStackLocation( Irp );

        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        
        return IoCallDriver(deviceExtension->TargetDeviceObject, Irp);
    }
    
    // **************************
    // The following IOCTL's should not be blocked by stalled disks
    // **************************

    // Reset an individual disk on a shared bus. Not implemented.
    //case IOCTL_DISK_CLUSTER_DISK_RESET:

    case IOCTL_STORAGE_GET_HOTPLUG_INFO:
    case IOCTL_STORAGE_RESET_BUS:
    case IOCTL_STORAGE_BREAK_RESERVATION:
    case IOCTL_STORAGE_QUERY_PROPERTY:
    case IOCTL_STORAGE_GET_MEDIA_TYPES:
    case IOCTL_STORAGE_GET_MEDIA_TYPES_EX:
    case IOCTL_STORAGE_FIND_NEW_DEVICES:
    case IOCTL_STORAGE_GET_DEVICE_NUMBER:
    case IOCTL_STORAGE_MEDIA_REMOVAL:
    case IOCTL_STORAGE_CHECK_VERIFY:
    case IOCTL_MOUNTDEV_QUERY_UNIQUE_ID:
    case IOCTL_MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY:
    case IOCTL_MOUNTDEV_QUERY_DEVICE_NAME:
    case IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME:
    case IOCTL_MOUNTDEV_LINK_CREATED:
    case IOCTL_MOUNTDEV_LINK_DELETED:
    case IOCTL_DISK_GET_DRIVE_LAYOUT:
    case IOCTL_DISK_GET_DRIVE_LAYOUT_EX:
    case IOCTL_DISK_CHECK_VERIFY:
    case IOCTL_DISK_GET_DRIVE_GEOMETRY:
    case IOCTL_DISK_GET_DRIVE_GEOMETRY_EX:
    case IOCTL_DISK_GET_PARTITION_INFO:
    case IOCTL_DISK_GET_PARTITION_INFO_EX:
    case IOCTL_DISK_IS_WRITABLE:
    case IOCTL_VOLUME_ONLINE:
    case IOCTL_VOLUME_OFFLINE:
    case IOCTL_VOLUME_IS_OFFLINE:
    case IOCTL_DISK_GET_LENGTH_INFO:
    case IOCTL_MOUNTDEV_QUERY_STABLE_GUID:
    case IOCTL_PARTMGR_QUERY_DISK_SIGNATURE:
    
        if ( physicalDisk->DiskState == DiskStalled ) {
            ClusDiskPrint((
                1,
                "[ClusDisk] Passthru (when stalled) IOCTL = %08lX, Signature = %08lX .\n",
                currentIrpStack->Parameters.DeviceIoControl.IoControlCode,
                deviceExtension->Signature));
            //
            // Set current stack back one.
            //
            IoSkipCurrentIrpStackLocation( Irp );

            ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

            //
            // Pass unrecognized device control requests
            // down to next driver layer.
            //

            return IoCallDriver(deviceExtension->TargetDeviceObject, Irp);
        } // othwerwise fall through

        // FALL THROUGH

    //
    // N.B. The following IOCTLs are used a lot in booting and by WINDISK.
    // We treat them special in that they will passed through to the
    // next level driver. I.E. We don't check if we should verify the attach!
    //
    //
    // None yet found...
    //case IOCTL_xxx

        //
        // Hold the I/O request if we are stalled.
        // First check for hint - i.e. with no lock held.
        //
        if ( deviceExtension->DiskState == DiskStalled ) {
            KeAcquireSpinLock(&ClusDiskSpinLock, &irql);
            //
            // Check again, with lock held - this one is valid!
            //
            if ( deviceExtension->DiskState == DiskStalled ) {
                ClusDiskPrint((1,"[ClusDisk] HoldCTL - pending IRP %p, target %p \n",
                               Irp, DeviceObject ));
                InsertTailList( &deviceExtension->HoldIO,
                                &Irp->Tail.Overlay.ListEntry );
                KeReleaseSpinLock(&ClusDiskSpinLock, irql);

                // Release only the physical device RemoveLock.  The original DO
                // will be released when the IRP is removed from the queue.
                
                ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
                
                return(STATUS_PENDING);
            }
            KeReleaseSpinLock(&ClusDiskSpinLock, irql);
        }

        IoSkipCurrentIrpStackLocation( Irp );

        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        
        return IoCallDriver(deviceExtension->TargetDeviceObject, Irp);

    default:

        //
        // For all other requests, we must be online to process the request.
        //
        //
        // Before returning failure, first verify device attachment. This
        // means that if the device is attached check if it should be detached.
        // If the device does get detached, then allow IO to go through.
        //
        if ( !deviceExtension->AttachValid ) {
            targetDeviceObject = deviceExtension->TargetDeviceObject;
            ClusDiskPrint((
                1,
                "[ClusDisk] Attach is not valid. IOCTL = %lx, check if we need to detach.\n",
                currentIrpStack->Parameters.DeviceIoControl.IoControlCode));
            if ( !ClusDiskVerifyAttach( DeviceObject ) ) {
                ClusDiskPrint((
                    1,
                    "[ClusDisk] We detached.\n"));
                IoSkipCurrentIrpStackLocation( Irp );

                ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
                ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
                
                return IoCallDriver(targetDeviceObject,
                                    Irp);
            }
            if ( deviceExtension->AttachValid ) {
                ClusDiskPrint((
                    1,
                    "[ClusDisk] Attach is now valid, Signature = %08lX .\n",
                    deviceExtension->Signature));
            }
        }

        if ( physicalDisk->DiskState != DiskOnline ) {

#if 0
            // This seems like a good idea, but needs more testing.  We might miss
            // setting up irp completion routine.

            //
            // Try cracking the control code and letting any IOCTLs through that
            // do not have write access set.
            //

            access = ACCESS_FROM_CTL_CODE(currentIrpStack->Parameters.DeviceIoControl.IoControlCode);

            if ( !(access & FILE_WRITE_ACCESS) ) {

                ClusDiskPrint((
                    3,
                    "[ClusDisk] Sending IOCTL = %08lX based on access %02X, Signature = %08lX \n",
                    currentIrpStack->Parameters.DeviceIoControl.IoControlCode,
                    access,
                    deviceExtension->Signature));

                IoSkipCurrentIrpStackLocation( Irp );

                ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
                ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

                return IoCallDriver(deviceExtension->TargetDeviceObject, Irp);

            }
#endif
            
            // All other IOCTL's fall through and are failed because disk is offline.

            ClusDiskPrint((
                1,
                "[ClusDisk] Disk not online: Rejected IOCTL = %08lX, Signature = %08lX \n",
                currentIrpStack->Parameters.DeviceIoControl.IoControlCode,
                deviceExtension->Signature));
            ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
            Irp->IoStatus.Status = STATUS_DEVICE_OFF_LINE;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return(STATUS_DEVICE_OFF_LINE);
        }

        switch (currentIrpStack->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_DISK_FIND_NEW_DEVICES:

            //
            // Copy current stack to next stack.
            //

            IoCopyCurrentIrpStackLocationToNext( Irp );

            //
            // Ask to be called back during request completion.
            // Pass current disk count as context.  
            // 
            //
                
            IoSetCompletionRoutine(Irp,
                                   ClusDiskNewDiskCompletion,
                                   (PVOID)( UlongToPtr( IoGetConfigurationInformation()->DiskCount ) ),
                                   TRUE,    // Invoke on success
                                   TRUE,    // Invoke on error
                                   TRUE);   // Invoke on cancel

            //
            // Call target driver.
            //

            // The completion routine will release the RemoveLocks.
            
            return IoCallDriver(deviceExtension->TargetDeviceObject, Irp);

        case IOCTL_DISK_SET_DRIVE_LAYOUT:
        case IOCTL_DISK_SET_DRIVE_LAYOUT_EX:

            CDLOG( "IoctlDiskSetDriveLayout(%p)", DeviceObject );

            //
            // Copy current stack to next stack.
            //

            IoCopyCurrentIrpStackLocationToNext( Irp );

            //
            // Ask to be called back during request completion.
            //
                
            IoSetCompletionRoutine(Irp,
                                   ClusDiskSetLayoutCompletion,
                                   DeviceObject,
                                   TRUE,    // Invoke on success
                                   TRUE,    // Invoke on error
                                   TRUE);   // Invoke on cancel

            //
            // Call target driver.
            //

            // The completion routine will release the RemoveLocks.
            
            return IoCallDriver(deviceExtension->TargetDeviceObject, Irp);

        default:

            //
            // Set current stack back one.
            //
            IoSkipCurrentIrpStackLocation( Irp );

            ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

            //
            // Pass unrecognized device control requests
            // down to next driver layer.
            //

            return IoCallDriver(deviceExtension->TargetDeviceObject, Irp);
        }

    }

} // ClusDiskDeviceControl



NTSTATUS
ClusDiskRootDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This device control dispatcher handles only the cluster disk IOCTLs
    for the root device. This is ATTACH and DETACH.

    Important:  Two RemoveLocks will be held on entry to this function.
    One RemoveLock for the original DO and one for the associated physical
    device.
    
Arguments:

    DeviceObject - Context for the activity.
    Irp          - The device control argument block.

Return Value:

    Status is returned.

--*/

{
    PCLUS_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PCLUS_DEVICE_EXTENSION  physicalDisk =
                               deviceExtension->PhysicalDevice->DeviceExtension;
    
    // Save pointers to the original RemoveLocks as the device extensions
    // may change in this routine.
    PCLUS_DEVICE_EXTENSION lockedDeviceExtension = deviceExtension;
    PCLUS_DEVICE_EXTENSION lockedPhysicalDisk = physicalDisk;
    
    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_OBJECT targetDeviceObject;
    NTSTATUS    status = STATUS_SUCCESS;
    ULONG       signature;
    PULONG      inputData = Irp->AssociatedIrp.SystemBuffer;
    ULONG       inputSize = currentIrpStack->Parameters.DeviceIoControl.InputBufferLength;
    ULONG       outputSize = currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength; 
    KIRQL       irql;
    BOOLEAN     isCapable;
    BOOLEAN     newPhysLockAcquired;
    UCHAR       portNumber;
    PLIST_ENTRY listEntry;
    PIRP        irp;

    switch (currentIrpStack->Parameters.DeviceIoControl.IoControlCode) {

    // Stall I/O's until further notice
    case IOCTL_DISK_CLUSTER_HOLD_IO:

        CDLOG( "RootCluserHoldIo(%p)", DeviceObject );

        // First - let's flush the file buffers!
        // - one of these device objects should be the physical device object
#if 0
        // Flushing the file buffers can take a while... we'll skip it for
        // now. Until we can come up with a good way of doing it.
        targetDeviceObject = DeviceObject->DriverObject->DeviceObject;
        while ( targetDeviceObject ) {
            deviceExtension = targetDeviceObject->DeviceExtension;
            if ( deviceExtension->DiskState == DiskOnline ) {
                LockVolumes( deviceExtension );
            }
            targetDeviceObject = targetDeviceObject->NextDevice;
        }
#endif

        ACQUIRE_SHARED( &ClusDiskDeviceListLock );

        // First - let's capture the file handles to
        // volume objects. We will not be able to do it
        // if the device is stalled or offline, so we will not be able
        // to dismount

        targetDeviceObject = DeviceObject->DriverObject->DeviceObject;
        while ( targetDeviceObject ) {
            deviceExtension = targetDeviceObject->DeviceExtension;
            if ( (deviceExtension->PhysicalDevice == targetDeviceObject) &&
                 (!deviceExtension->Detached) &&
                 (deviceExtension->DiskState == DiskOnline) ) 
            {
                //
                // Disk has to be online,
                // If it is offline, OpenFile will fail - not if FILE_WRITE_ATTRIBUTES used...
                // It it is stalled OpenFile may stall
                //
                ProcessDelayedWorkSynchronous( targetDeviceObject, ClusDiskpOpenFileHandles, NULL );
            }
            targetDeviceObject = targetDeviceObject->NextDevice;
        }
        
        //
        // Now set their states to Stalled!
        // - some of these device objects should be the physical device object
        // - skip those...
        KeAcquireSpinLock(&ClusDiskSpinLock, &irql);
        targetDeviceObject = DeviceObject->DriverObject->DeviceObject;
        while ( targetDeviceObject ) {
            deviceExtension = targetDeviceObject->DeviceExtension;
            physicalDisk = deviceExtension->PhysicalDevice->DeviceExtension;
            if ( (deviceExtension != physicalDisk) &&
                 (!deviceExtension->Detached) &&
                 (physicalDisk->DiskState == DiskOnline) ) {
                deviceExtension->DiskState = DiskStalled;
            }
            targetDeviceObject = targetDeviceObject->NextDevice;
        }
        //
        // Now set the state for the physical device objects!
        targetDeviceObject = DeviceObject->DriverObject->DeviceObject;
        while ( targetDeviceObject ) {
            deviceExtension = targetDeviceObject->DeviceExtension;
            physicalDisk = deviceExtension->PhysicalDevice->DeviceExtension;
            if ( (deviceExtension == physicalDisk) &&
                 (!deviceExtension->Detached) &&
                 (physicalDisk->DiskState == DiskOnline) ) {
                physicalDisk->DiskState = DiskStalled;
            }
            targetDeviceObject = targetDeviceObject->NextDevice;
        }
        KeReleaseSpinLock(&ClusDiskSpinLock, irql);

        RELEASE_SHARED( &ClusDiskDeviceListLock );

        ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
        
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return(STATUS_SUCCESS);

    // Resume stalled I/O's
    case IOCTL_DISK_CLUSTER_RESUME_IO:
        
        CDLOG( "RootCluserResumeIo(%p)", DeviceObject );
        ClusDiskResumeIO( DeviceObject );
        ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = STATUS_SUCCESS;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return(STATUS_SUCCESS);

    case IOCTL_DISK_CLUSTER_ARBITRATION_ESCAPE:

        if ( ARGUMENT_PRESENT( inputData ) &&
             inputSize >= sizeof(ARBITRATION_READ_WRITE_PARAMS) )
        {
            BOOLEAN success;
            PDEVICE_OBJECT physicalDevice;
            PARBITRATION_READ_WRITE_PARAMS params = 
                (PARBITRATION_READ_WRITE_PARAMS)inputData;

            // Can't hold the spinlock and then try to acquire the resource lock or the system 
            // might deadlock.
            // KeAcquireSpinLock(&ClusDiskSpinLock, &irql);
            success = AttachedDevice( params->Signature, &physicalDevice );
            // KeReleaseSpinLock(&ClusDiskSpinLock, irql);

            if( success ) {

                PCLUS_DEVICE_EXTENSION tempDeviceExtension = physicalDevice->DeviceExtension;

                // We have a new device here, acquire the RemoveLock if possible.
                
                status = AcquireRemoveLock(&tempDeviceExtension->RemoveLock, Irp);
                if ( !NT_SUCCESS(status) ) {
                    ClusDiskPrint((
                            1,
                            "[ClusDisk] ClusDiskRootDeviceControl: AcquireRemoveLock for %p failed %08X \n", 
                            tempDeviceExtension,
                            status));
                } else {

                    status = ProcessArbitrationEscape(
                                physicalDevice->DeviceExtension,
                                inputData,
                                inputSize,
                                &outputSize);
                    if ( NT_SUCCESS(status) ) {
                        Irp->IoStatus.Information = outputSize;
                    }    

                    ReleaseRemoveLock(&tempDeviceExtension->RemoveLock, Irp);
                }
            } else {
                status = STATUS_NOT_FOUND;
            }
        } else {
            status = STATUS_INVALID_PARAMETER;
        }

        ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(status);
        
    // Perform an attach to a device object, for a given signature
    case IOCTL_DISK_CLUSTER_ATTACH:

        if ( ARGUMENT_PRESENT( inputData ) &&
            currentIrpStack->Parameters.DeviceIoControl.InputBufferLength >=
                sizeof(ULONG) ) {
            signature = inputData[0];

            ClusDiskPrint((3,
                           "[ClusDisk] RootDeviceControl: attaching signature %08X\n",
                           signature));

            CDLOG( "RootCluserAttach: sig %08x", signature );
            
            status = ClusDiskTryAttachDevice( signature,
                                              0,
                                              DeviceObject->DriverObject );
        } else {
            status = STATUS_INVALID_PARAMETER;
        }

        ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(status);

    // Perform a detach from a device object, for a given signature

    case IOCTL_DISK_CLUSTER_DETACH:
        if ( ARGUMENT_PRESENT( inputData ) &&
            currentIrpStack->Parameters.DeviceIoControl.InputBufferLength >=
                sizeof(ULONG) ) {
            signature = inputData[0];

            CDLOG( "RootCluserDetach: sig %08x", signature );
            
            ClusDiskPrint((3,
                           "[ClusDisk] RootDeviceControl: detaching signature %08X\n",
                           signature));

            status = ClusDiskDetachDevice( signature,
                                           DeviceObject->DriverObject );
        } else {
            status = STATUS_INVALID_PARAMETER;
        }

        ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(status);

    case IOCTL_DISK_CLUSTER_ATTACH_LIST: {
        
        //
        // Attaches a signature list to the system.  NO resets will occur.  If we
        // really need to make sure the device attaches, then use the normal 
        // attach IOCTL.  This IOCTL is mainly used by cluster setup.
        //

        status = AttachSignatureList( DeviceObject,
                                      inputData,
                                      currentIrpStack->Parameters.DeviceIoControl.InputBufferLength
                                      );        
        
        ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(status);

    }

    // Detach from all the signatures in the list.
    
    case IOCTL_DISK_CLUSTER_DETACH_LIST:  {

        
        status = DetachSignatureList( DeviceObject,
                                      inputData,
                                      currentIrpStack->Parameters.DeviceIoControl.InputBufferLength
                                      );

        ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(status);
    
    }
    
    // Start the reservation timer

    case IOCTL_DISK_CLUSTER_START_RESERVE:

        CDLOG( "RootStartReserve(%p)", DeviceObject );
        
        if ( RootDeviceObject == NULL ) {
            ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
            Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            return(STATUS_INVALID_DEVICE_REQUEST);
        }

        if ( currentIrpStack->FileObject->FsContext ) {
            status = STATUS_DUPLICATE_OBJECTID;
        } else if ( ARGUMENT_PRESENT(inputData) &&
            currentIrpStack->Parameters.DeviceIoControl.InputBufferLength >=
                 sizeof(ULONG) ) {

            status = VerifyArbitrationArgumentsIfAny(
                        inputData,
                        currentIrpStack->Parameters.DeviceIoControl.InputBufferLength);
            if (!NT_SUCCESS(status) ) {
               ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
               ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
               Irp->IoStatus.Status = status;
               IoCompleteRequest(Irp, IO_NO_INCREMENT);
               return(status);
            }

            signature = inputData[0];


            // Acquire the device list lock first, then the spinlock.  This will prevent deadlock.            
            ACQUIRE_SHARED( &ClusDiskDeviceListLock );    
            KeAcquireSpinLock(&ClusDiskSpinLock, &irql);
            if ( MatchDevice(signature, &targetDeviceObject) &&
                 targetDeviceObject ) {
                status = EnableHaltProcessing( &irql );
                if ( NT_SUCCESS(status) ) {
            
                    physicalDisk = targetDeviceObject->DeviceExtension;
                    
                    status = AcquireRemoveLock(&physicalDisk->RemoveLock, Irp);
                    if ( !NT_SUCCESS(status) ) {

                        ClusDiskPrint((
                                1,
                                "[ClusDisk] ClusDiskRootDeviceControl: AcquireRemoveLock for %p failed %08X \n", 
                                physicalDisk,
                                status));
                        
                        status = STATUS_NO_SUCH_FILE;
                        
                    } else {
                    
                        ProcessArbitrationArgumentsIfAny(
                             physicalDisk,
                             inputData,
                             currentIrpStack->Parameters.DeviceIoControl.InputBufferLength);
    
                        ClusDiskPrint((3,
                                       "[ClusDisk] Start reservations on signature %lx.\n",
                                       physicalDisk->Signature ));
    
                        currentIrpStack->FileObject->FsContext = targetDeviceObject;
                        CDLOG("RootCtl: IncRef(%p)", targetDeviceObject );
                        ObReferenceObject( targetDeviceObject );
                        physicalDisk->ReserveTimer = RESERVE_TIMER;
                        physicalDisk->ReserveFailure = 0;
                        physicalDisk->PerformReserves = TRUE;
                        status = STATUS_SUCCESS;
    
                        ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
                    }
                }
            } else {
                status = STATUS_NO_SUCH_FILE;
            }
            KeReleaseSpinLock(&ClusDiskSpinLock, irql);
            RELEASE_SHARED( &ClusDiskDeviceListLock );    
        } else {
            status = STATUS_INVALID_PARAMETER;
        }

        ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(status);

    // Stop the reservation timer

    case IOCTL_DISK_CLUSTER_STOP_RESERVE:

        CDLOG( "RootStopReserve(%p)", DeviceObject );
        
        if ( (RootDeviceObject == NULL) ||
             (deviceExtension->BusType != RootBus) ) {
            ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
            Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            return(STATUS_INVALID_DEVICE_REQUEST);
        }

        newPhysLockAcquired = FALSE;

        if ( currentIrpStack->FileObject->FsContext ) {

            //
            // GorN Oct/13/1999. PnP can come and rip out the device object
            // we stored in the FsContext. It doesn't delete it, since we have a reference
            // to it, but we will not be able to use it, since the objects underneath this one
            // are destroyed.
            //
            // Our PnpRemoveDevice handler will zero out targetDevice field of the device 
            // extension, this will not eliminate the race completely, but will reduces the
            // chance of this happening, since, usually, device removal comes first,
            // we notify resmon and then it calls stop reserve.
            //
            // Chances that PnpRemoveDevice will come at exact moment resmon called ClusterStopReserve
            // are smaller
            //

            targetDeviceObject = (PDEVICE_OBJECT)currentIrpStack->FileObject->FsContext;
            physicalDisk = targetDeviceObject->DeviceExtension;

            CDLOG( "RootStopReserve: FsContext targetDO %p RemoveLock.IoCount %d", 
                    targetDeviceObject,
                    physicalDisk->RemoveLock.Common.IoCount );

            // We have a new device here, acquire the RemoveLock if possible.
            
            status = AcquireRemoveLock(&physicalDisk->RemoveLock, Irp);
            if ( !NT_SUCCESS(status) ) {
                ClusDiskPrint((
                        1,
                        "[ClusDisk] ClusDiskRootDeviceControl: AcquireRemoveLock for %p failed %08X \n", 
                        physicalDisk,
                        status));
                        
                status = STATUS_INVALID_HANDLE;
                        
            } else {

                ClusDiskPrint((3,
                               "[ClusDisk] IOCTL, stop reservations on signature %lx, disk state %s \n",
                               physicalDisk->Signature,
                               DiskStateToString( physicalDisk->DiskState ) ));

                newPhysLockAcquired = TRUE;
                
                IoAcquireCancelSpinLock( &irql );
                KeAcquireSpinLockAtDpcLevel(&ClusDiskSpinLock);
                physicalDisk->ReserveTimer = 0;
    
                //
                // Signal all waiting Irp's on the physical device extension.
                //
                while ( !IsListEmpty(&physicalDisk->WaitingIoctls) ) {
                    listEntry = RemoveHeadList(&physicalDisk->WaitingIoctls);
                    irp = CONTAINING_RECORD( listEntry,
                                             IRP,
                                             Tail.Overlay.ListEntry );
                    ClusDiskCompletePendingRequest(irp, STATUS_SUCCESS, physicalDisk);
                }
    
                KeReleaseSpinLockFromDpcLevel(&ClusDiskSpinLock);
                IoReleaseCancelSpinLock( irql );
    
                //
                // This should not be done here.
                // Cleaning FsContext here, will prevent ClusDiskCleanup
                // from doing its work
                //
                // ObDereferenceObject(targetDeviceObject);
                // CDLOG("RootCtl_DecRef(%p)", targetDeviceObject );
                // currentIrpStack->FileObject->FsContext = NULL;
                
                //
                // Release the scsi device.
                //
                // [GorN] 10/04/1999. Why this release was commented out?
                // [GorN] 10/13/1999. It was commented out, because it was causing an AV,
                //                    if the device was removed by PnP
    
                // 
                // 2000/02/05: stevedz - RemoveLocks should resolve this problem.
                //
                // The following "if" only reduces the chances of AV to occur, not
                // eliminates it completely. TargetDeviceObject is zeroed out by our PnP
                // handler when the device is removed
                //
                if (physicalDisk->TargetDeviceObject) {
                    ReleaseScsiDevice( physicalDisk );
                }                
    
                ClusDiskPrint((3,
                               "[ClusDisk] IOCTL, stop reservations on signature %lx.\n",
                               physicalDisk->Signature ));
    
                status = STATUS_SUCCESS;
            }
            
        } else {
            status = STATUS_INVALID_HANDLE;
        }

        if (newPhysLockAcquired) {
            ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
        }
        
        ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(status);

    // Aliveness check
    case IOCTL_DISK_CLUSTER_ALIVE_CHECK:

        CDLOG( "RootAliveCheck(%p)", DeviceObject );

        if ( (RootDeviceObject == NULL) ||
             (deviceExtension->BusType != RootBus) ) {
            ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
            Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            return(STATUS_INVALID_DEVICE_REQUEST);
        }

        IoAcquireCancelSpinLock( &irql );
        KeAcquireSpinLockAtDpcLevel( &ClusDiskSpinLock );

        // Indicate that we didn't acquire a third RemoveLock for the new physical device.
        
        newPhysLockAcquired = FALSE;

        if ( currentIrpStack->FileObject->FsContext ) {
            targetDeviceObject = (PDEVICE_OBJECT)currentIrpStack->FileObject->FsContext;
            physicalDisk = targetDeviceObject->DeviceExtension;

            // We have a new device here, acquire the RemoveLock if possible.
            
            status = AcquireRemoveLock(&physicalDisk->RemoveLock, Irp);
            if ( !NT_SUCCESS(status) ) {
                ClusDiskPrint((
                        1,
                        "[ClusDisk] ClusDiskRootDeviceControl: AcquireRemoveLock for %p failed %08X \n", 
                        physicalDisk,
                        status));
                
                status = STATUS_FILE_DELETED;                        
            
            } else {
                
                newPhysLockAcquired = TRUE;
                
                if ( physicalDisk->TargetDeviceObject == NULL ) {
                    status = STATUS_FILE_DELETED;
                } else
                if ( physicalDisk->ReserveFailure &&
                     (!NT_SUCCESS(physicalDisk->ReserveFailure)) ) {
                    status = physicalDisk->ReserveFailure;
                } else {
                    //
                    // The device does not have to be 'online' to have been
                    // successfully arbitrated and being defended. However,
                    // the quorum device really should be 'online'...
                    //
                    if ( physicalDisk->ReserveTimer == 0 ) {
#if 0
                        ClusDiskPrint((
                                1,
                                "[ClusDisk] RootDeviceControl, AliveCheck failed, signature %lx, state = %s, ReserveTimer = %lx.\n",
                                physicalDisk->Signature,
                                DiskStateToString( physicalDisk->DiskState ),
                                physicalDisk->ReserveTimer ));
#endif
                        status = STATUS_CANCELLED;
                    } else {
                        status = STATUS_SUCCESS;
                    }
                }
            }
                                        
        } else {
            status = STATUS_INVALID_HANDLE;
        }
        
        if ( status == STATUS_SUCCESS ) {
            NTSTATUS    newStatus;

            newStatus = ClusDiskMarkIrpPending( Irp, ClusDiskIrpCancel );
            if ( NT_SUCCESS( newStatus ) ) {
                InsertTailList( &physicalDisk->WaitingIoctls,
                                &Irp->Tail.Overlay.ListEntry );
                status = STATUS_PENDING;
                
                // Release all RemoveLocks except the one where we queued the I/O.  When the IRP
                // is processed, the RemoveLock will be processed.
                
                ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
                ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);

            } else {
                status = newStatus;

                if (newPhysLockAcquired) {
                    ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
                }
                ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
                ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
            
                Irp->IoStatus.Status = status;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            }

            KeReleaseSpinLockFromDpcLevel( &ClusDiskSpinLock );
            IoReleaseCancelSpinLock( irql );
        } else {
            KeReleaseSpinLockFromDpcLevel( &ClusDiskSpinLock );
            IoReleaseCancelSpinLock( irql );
            
            if (newPhysLockAcquired) {
                ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
            }
            ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
            
            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }

        return(status);

    // Check out what's happening
    case IOCTL_DISK_CLUSTER_ACTIVE:
        if ( (RootDeviceObject == NULL) ||
             (deviceExtension->BusType != RootBus) ) {
            ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
            ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
            Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            return(STATUS_INVALID_DEVICE_REQUEST);
        }

        status = ClusDiskGetRunningDevices(
                  inputData,
                  currentIrpStack->Parameters.DeviceIoControl.OutputBufferLength
                  );

        Irp->IoStatus.Status = status;
        if ( NT_SUCCESS(status) ) {
            Irp->IoStatus.Information = (inputData[0] + 1) * sizeof(ULONG);
        }
        ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return(status);

    // Check if device is Cluster Capable (performs normal SCSI operations)
    // NB:  Non-SCSI device must return success on this call!
    case IOCTL_DISK_CLUSTER_NOT_CLUSTER_CAPABLE:
        //
        // Get the passed in device signature.
        //
        isCapable = TRUE;       // Err on the side of being usable.
        if ( ARGUMENT_PRESENT( inputData ) &&
            currentIrpStack->Parameters.DeviceIoControl.InputBufferLength >=
                sizeof(ULONG) ) {
            signature = inputData[0];
            status = GetScsiPortNumber( signature, &portNumber );
            if ( NT_SUCCESS(status) &&
                 (portNumber != 0xff) ) {
                status = IsDiskClusterCapable( portNumber,
                                               &isCapable);
            }
        } else {
            //
            // Default is to fail this IOCTL, which allows us to use the device.
            //
            status = STATUS_UNSUCCESSFUL;
        }
        //
        // Verifier found a problem with the original code.  The status returned
        // wasn't the same as Irp->IoStatus.Status.  The IRP status was always
        // success, but the dispatch routine sometimes returned an error.  This
        // seems to work but verifier says this is invalid.  When I changed the code
        // to update the IRP status with the same returned status, new drives 
        // couldn't be seen.  This is because the user mode component uses this
        // IOCTL to indicate the disk is NOT cluster capable, so the user mode
        // code looked for a failure to incidate a cluster disk.
        //
        
        //
        // Fix for IBM.  The Win2000 2195 code returned from this IOCTL the status 
        // of the SCSI miniport IOCTL.  This was returned to DeviceIoControl rather
        // than the status in the IRP.  Changed to make the behavior the same as
        // Win20000 2195.
        //
        
        //
        // If the SCSI miniport IOCTL succeeds, we return success.  If any of the
        // routines failed while trying to issue the SCSI miniport IOCTL (including
        // issuing the SCSI miniport IOCTL itself), then we return failure.
        //

        Irp->IoStatus.Status = status;
        ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        return(status);

    default:
        ReleaseRemoveLock(&lockedPhysicalDisk->RemoveLock, Irp);
        ReleaseRemoveLock(&lockedDeviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = STATUS_ILLEGAL_FUNCTION;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(STATUS_ILLEGAL_FUNCTION);

    }
    
} // ClusDiskRootDeviceControl



NTSTATUS
ClusDiskShutdownFlush(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called for a shutdown and flush IRPs.  These are sent by the
    system before it actually shuts down or when the file system does a flush.

Arguments:

    DriverObject - Pointer to device object to being shutdown by system.
    Irp          - IRP involved.

Return Value:

    NT Status

--*/

{
    PCLUS_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PCLUS_DEVICE_EXTENSION  physicalDisk =
                               deviceExtension->PhysicalDevice->DeviceExtension;
    NTSTATUS    status;                            

    status = AcquireRemoveLock( &deviceExtension->RemoveLock, Irp);
    
    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] ClusDiskShutdownFlush: AcquireRemoveLock for %p failed %08X \n", 
                deviceExtension,
                status));
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }
    
    //
    // Return error if device is our root device.
    //
    if ( deviceExtension->BusType == RootBus ) {
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    if ( physicalDisk->DiskState != DiskOnline ) {
        ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
        Irp->IoStatus.Status = STATUS_DEVICE_OFF_LINE;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return(STATUS_DEVICE_OFF_LINE);
    }

    //
    // Set current stack back one.
    //

    IoSkipCurrentIrpStackLocation( Irp );

    ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

    return IoCallDriver(deviceExtension->TargetDeviceObject, Irp);

} // ClusDiskShutdownFlush()



NTSTATUS
ClusDiskNewDiskCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )

/*++

Routine Description:

    This is the completion routine for IOCTL_DISK_FIND_NEW_DEVICES.

Arguments:

    DeviceObject - Pointer to device object to being shutdown by system.
    Irp          - IRP involved.
    Context      - Previous disk count.

Return Value:

    NTSTATUS

--*/

{
    PCLUS_DEVICE_EXTENSION  deviceExtension =
        (PCLUS_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    PCLUS_DEVICE_EXTENSION      physicalDisk =
                                    deviceExtension->PhysicalDevice->DeviceExtension;

    //
    // Find new disk devices and attach to disk and all of its partitions.
    //

    ClusDiskNextDisk = Context;
    ClusDiskScsiInitialize(DeviceObject->DriverObject, Context, 1);
    
    // There are two RemoveLocks held.  Release them both.
    
    ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
    ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }
    return Irp->IoStatus.Status;

} // ClusDiskNewDiskCompletion



NTSTATUS
ClusDiskSetLayoutCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )

/*++

Routine Description:

    This is the completion routine for IOCTL_SET_DRIVE_LAYOUT_EX and
    IOCTL_DISK_SET_DRIVE_LAYOUT_EX.  This will routine will make sure
    the cached drive layout info structure is updated.

Arguments:

    DeviceObject - Pointer to device object
    Irp          - IRP involved.
    Context      - Not used

Return Value:

    NTSTATUS

--*/

{
    PCLUS_DEVICE_EXTENSION  deviceExtension =
        (PCLUS_DEVICE_EXTENSION)DeviceObject->DeviceExtension;
    PCLUS_DEVICE_EXTENSION      physicalDisk =
                                    deviceExtension->PhysicalDevice->DeviceExtension;
    PDRIVE_LAYOUT_INFORMATION   driveLayoutInfo = NULL;

    //
    // Update the cached drive layout.
    //
    
    GetDriveLayout( physicalDisk->DeviceObject, &driveLayoutInfo, TRUE );
    
    if ( driveLayoutInfo ) {
        ExFreePool( driveLayoutInfo );
    }
    
    // There are two RemoveLocks held.  Release them both.
    
    ReleaseRemoveLock(&physicalDisk->RemoveLock, Irp);
    ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }
    return Irp->IoStatus.Status;

} // ClusDiskSetLayoutCompletion


BOOLEAN
ClusDiskAttached(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG        DiskNumber
    )

/*++

Routine Description:

    This routine checks if clusdisk in in the path.

Arguments:

    DeviceObject - pointer the device object to check if ClusDisk is present.

    DiskNumber - the disk number for this device object.

Return Value:

    TRUE - if ClusDisk is attached.

    FALSE - if ClusDisk is not attached.

--*/

{
    PIRP                    irp;
    PKEVENT                 event;
    IO_STATUS_BLOCK         ioStatusBlock;
    NTSTATUS                status;
    WCHAR                   deviceNameBuffer[MAX_PARTITION_NAME_LENGTH];
    UNICODE_STRING          deviceNameString;
    OBJECT_ATTRIBUTES       objectAttributes;
    HANDLE                  fileHandle;
    HANDLE                  eventHandle;

    if ( DeviceObject->DeviceType  == FILE_DEVICE_DISK_FILE_SYSTEM ) {
        //
        // Create event for notification.
        //
        status = ZwCreateEvent( &eventHandle,
                                EVENT_ALL_ACCESS,
                                NULL,
                                SynchronizationEvent,
                                FALSE );

        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((
                    1,
                    "[ClusDisk] Failed to create event, status %lx\n",
                    status ));
            return(TRUE);
        }
        //
        // Open a file handle and perform the request
        //
        swprintf(deviceNameBuffer, DEVICE_PARTITION_NAME, DiskNumber, 0);
        WCSLEN_ASSERT( deviceNameBuffer );

        RtlInitUnicodeString(&deviceNameString,
                             deviceNameBuffer);

        //
        // Setup object attributes for the file to open.
        //
        InitializeObjectAttributes(
                    &objectAttributes,
                    &deviceNameString,
                    OBJ_CASE_INSENSITIVE,
                    NULL,
                    NULL
                    );

        status = ZwCreateFile( &fileHandle,
                               FILE_READ_DATA,
                               &objectAttributes,
                               &ioStatusBlock,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               FILE_OPEN,
                               FILE_SYNCHRONOUS_IO_NONALERT,
                               NULL,
                               0 );
        ASSERT( status != STATUS_PENDING );

        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((
                1,
                "[ClusDisk] DiskAttached, failed to open file %ws. Error %lx.\n",
                deviceNameBuffer,
                status ));
            ZwClose(eventHandle);
            return(TRUE);
        }

        status = ZwDeviceIoControlFile( fileHandle,
                                        eventHandle,
                                        NULL,
                                        NULL,
                                        &ioStatusBlock,
                                        IOCTL_DISK_CLUSTER_TEST,
                                        NULL,
                                        0,
                                        NULL,
                                        0 );
        ZwClose( fileHandle );
        ZwClose( eventHandle );
        return(status == STATUS_SUCCESS);
    }

    event = ExAllocatePool( NonPagedPool,
                            sizeof(KEVENT) );
    if ( event == NULL ) {
        return(FALSE);
    }

    //
    // Find out if ClusDisk is already in device stack.
    //

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_CLUSTER_TEST,
                                        DeviceObject,
                                        NULL,
                                        0,
                                        NULL,
                                        0,
                                        FALSE,
                                        event,
                                        &ioStatusBlock);

    if (!irp) {
        ExFreePool( event );
        ClusDiskPrint((
                    1,
                    "[ClusDisk] Failed to build IRP to test for ClusDisk.\n"
                    ));
        return(FALSE);
    }

    //
    // Set the event object to the unsignaled state.
    // It will be used to signal request completion.
    //

    KeInitializeEvent(event,
                      NotificationEvent,
                      FALSE);

    status = IoCallDriver(DeviceObject,
                          irp);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(event,
                              Suspended,
                              KernelMode,
                              FALSE,
                              NULL);

        status = ioStatusBlock.Status;
    }
    ExFreePool( event );

    if ( NT_SUCCESS(status) ) {
        return(TRUE);
    }

    return(FALSE);

} // ClusDiskAttached



BOOLEAN
ClusDiskVerifyAttach(
    PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine verifies if ClusDisk is attached, and whether it should be
    detached.

Arguments:

    DeviceObject - pointer to a ClusDisk device object to verify if it is
            and should remain attached.

Return Value:

    TRUE - if device is still attached.

    FALSE - if device was detached.

--*/

{
    NTSTATUS                    status;
    PDEVICE_OBJECT              deviceObject;
    PCLUS_DEVICE_EXTENSION      deviceExtension;
    PDRIVE_LAYOUT_INFORMATION   driveLayoutInfo;
    UNICODE_STRING              signatureName;

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // The following call really can't fail!
    //
    if ( !ClusDiskAttached( DeviceObject, deviceExtension->DiskNumber ) ) {
        return(FALSE);
    }

    //
    // Check if this device is a valid attachment.
    //
    if ( deviceExtension->AttachValid ) {
        return(TRUE);
    }

    //
    // Get device object for the physical (partition0) device.
    //
    deviceObject = deviceExtension->PhysicalDevice;

    //
    // Otherwise, we're not sure... verify it.
    //

    //
    // Read the partition info to get the signature. If this device is
    // a valid attachment then update the ClusDisk DeviceObject. Otherwise,
    // detach or leave attached but in the UNKNOWN state.
    //

    driveLayoutInfo = ClusDiskGetPartitionInfo( deviceExtension );
    if ( driveLayoutInfo != NULL ) {
        deviceExtension->Signature = driveLayoutInfo->Signature;
        if ( MatchDevice( driveLayoutInfo->Signature, NULL ) ) {
            //
            // We assume that the device object we have is for the partition0
            // device object.
            //
#if 0
            ClusDiskPrint((
                1,
                "[ClusDisk] We are going to attach signature %08lx to DevObj %p \n",
                driveLayoutInfo->Signature,
                DeviceObject ));
#endif
            AddAttachedDevice( driveLayoutInfo->Signature,
                               deviceObject );

            //
            // Need to write disk info into the signatures list.
            //
            status = ClusDiskInitRegistryString(
                                              &signatureName,
                                              CLUSDISK_SIGNATURE_KEYNAME,
                                              sizeof(CLUSDISK_SIGNATURE_KEYNAME)
                                             );
            if ( NT_SUCCESS(status) ) {
                ClusDiskWriteDiskInfo( driveLayoutInfo->Signature,
                                       deviceExtension->DiskNumber,
                                       CLUSDISK_SIGNATURE_KEYNAME
                                     );
                ExFreePool( signatureName.Buffer );
            }
        } else {
            ClusDiskDetachDevice( driveLayoutInfo->Signature,
                                  DeviceObject->DriverObject
                                 );
        }
        ExFreePool( driveLayoutInfo );
    }

    return(TRUE);

} // ClusDiskVerifyAttach



VOID
ClusDiskWriteDiskInfo(
    IN ULONG Signature,
    IN ULONG DiskNumber,
    IN LPWSTR SubKeyName
    )

/*++

Routine Description:

    Write the disk name for the given signature.

Arguments:

    Signature - the signature key to store the disk name under.

    DiskNumber - the disk number to assign to the given signature. It is
            assumed that this is always describing partition0 on the disk.

    SubKeyName - the clusdisk parameters subkey name in which to write
            this information.

Return Value:

    None.

--*/

{
    UNICODE_STRING          keyName;
    WCHAR                   keyNameBuffer[MAXIMUM_FILENAME_LENGTH];
    WCHAR                   signatureBuffer[64];
    HANDLE                  signatureHandle;
    OBJECT_ATTRIBUTES       objectAttributes;
    UNICODE_STRING          name;
    NTSTATUS                status;

    keyName.Length = 0;
    keyName.MaximumLength = sizeof( keyNameBuffer );
    keyName.Buffer = keyNameBuffer;

    RtlAppendUnicodeToString( &keyName, ClusDiskRegistryPath.Buffer );

    RtlAppendUnicodeToString( &keyName, SubKeyName );

    swprintf( signatureBuffer, L"\\%08lX", Signature );
    WCSLEN_ASSERT( signatureBuffer );

    RtlAppendUnicodeToString( &keyName, signatureBuffer );

    //
    // Setup the object attributes for the Parameters\SubKeyName\xyz key.
    //

    InitializeObjectAttributes(
            &objectAttributes,
            &keyName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

    //
    // Open Parameters\SubKeyName\xyz Key.
    //

    status = ZwOpenKey(
                    &signatureHandle,
                    KEY_READ | KEY_WRITE,
                    &objectAttributes
                    );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                    1,
                    "[ClusDisk] WriteDiskInfo: Failed to open %wZ registry key. Status: %lx\n",
                    &keyName,
                    status
                    ));
        return;
    }

    //
    // Write the disk name.
    //
    status = ClusDiskAddDiskName( signatureHandle, DiskNumber );

    ZwClose( signatureHandle );

    return;

} // ClusDiskWriteDiskInfo



NTSTATUS
GetDriveLayout(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PDRIVE_LAYOUT_INFORMATION *DriveLayout,
    BOOLEAN UpdateCachedLayout
    )

/*++

Routine Description:

    Return the DRIVE_LAYOUT_INFORMATION for a given device object.

Arguments:

    DeviceObject - The specific device object to return info about

    BytesPerSector - The number of bytes per sector on this disk

    DriveLayout - Pointer to a DRIVE_LAYOUT_INFORMATION structure to return the info
    
    UpdateCachedLayout - Update the drive layout stored in the device extension (if any)
                         with a fresh copy.

Return Value:

    NTSTATUS

--*/

{
    PCLUS_DEVICE_EXTENSION      deviceExtension = DeviceObject->DeviceExtension;
    PCLUS_DEVICE_EXTENSION      physicalDisk = deviceExtension->PhysicalDevice->DeviceExtension;
    PDRIVE_LAYOUT_INFORMATION   driveLayoutInfo = NULL;
    PDRIVE_LAYOUT_INFORMATION   cachedDriveLayoutInfo = NULL;
    
    NTSTATUS                    status = STATUS_SUCCESS;
    ULONG                       driveLayoutSize;
    
    BOOLEAN                     cachedCopy = FALSE;
    BOOLEAN                     freeLayouts = FALSE;
    
    //
    // Allocate a drive layout buffer.
    //
    
    driveLayoutSize = sizeof(DRIVE_LAYOUT_INFORMATION) +
        (MAX_PARTITIONS * sizeof(PARTITION_INFORMATION));
    
    driveLayoutInfo = ExAllocatePool(NonPagedPoolCacheAligned,
                                     driveLayoutSize
                                     );
    
    if ( !driveLayoutInfo ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] GetDriveLayout: Failed to allocate drive layout structure. \n"
                        ));
                    
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto FnExit;
    }

    if ( UpdateCachedLayout ) {

        //
        // If cached buffer needs to be updated, free the existing buffer.
        // 
        
        ACQUIRE_EXCLUSIVE( &physicalDisk->DriveLayoutLock );
        
        if ( physicalDisk->DriveLayout ) {
            ExFreePool( physicalDisk->DriveLayout );
            physicalDisk->DriveLayout = NULL;
        }
        physicalDisk->DriveLayoutSize = 0;
        
        RELEASE_EXCLUSIVE( &physicalDisk->DriveLayoutLock );
    
    } else {

        //
        // If cached copy exists, use that instead of getting a new version.
        //
                
        ACQUIRE_SHARED( &physicalDisk->DriveLayoutLock );
        
        if ( physicalDisk->DriveLayout ) {
    
            ClusDiskPrint(( 3,
                            "[ClusDisk] GetDriveLayout: using cached drive layout information for DE %p \n",
                            physicalDisk
                            ));
             
            RtlCopyMemory( driveLayoutInfo, 
                           physicalDisk->DriveLayout,
                           physicalDisk->DriveLayoutSize );
        
            *DriveLayout = driveLayoutInfo;
            cachedCopy = TRUE;
        }
        
        RELEASE_SHARED( &physicalDisk->DriveLayoutLock );
        
        if ( cachedCopy ) {
            goto FnExit;
        }
    }

    freeLayouts = TRUE;
    
    //
    // Allocate a drive layout buffer for saving in device extension.
    //
    
    cachedDriveLayoutInfo = ExAllocatePool(NonPagedPoolCacheAligned,
                                           driveLayoutSize
                                           );
    
    if ( !cachedDriveLayoutInfo ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] GetDriveLayout: Failed to allocate cached drive layout structure. \n"
                        ));
                    
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto FnExit;
    }
    
    //
    // Now get the drive layout information
    //

    status = SimpleDeviceIoControl(DeviceObject,
                                   IOCTL_DISK_GET_DRIVE_LAYOUT,
                                   NULL,
                                   0,
                                   cachedDriveLayoutInfo,
                                   driveLayoutSize
                                   );

    if ( !NT_SUCCESS(status) ) {
        
        //
        // Couldn't get the drive layout.  Free the temporary buffer, set the caller's
        // drive layout pointer to NULL, and return the error status to the caller.
        //
        
        ClusDiskPrint(( 1,
                        "[ClusDisk] GetDriveLayout: Failed to issue IoctlDiskGetDriveLayout. %08X\n",
                        status
                        ));

        CDLOG( "GetDriveLayout(%p): failed %!status!",
               DeviceObject,
               status );
        
        *DriveLayout = NULL;
        freeLayouts = TRUE;
        
        goto FnExit;
                    
    } 

    //
    // Successfully retrieved drive layout.  Save the new layout in the device
    // extension.  Copy the layout into the user's buffer.
    //

    ClusDiskPrint(( 3,
                    "[ClusDisk] GetDriveLayout: updating drive layout for DE %p \n",
                    physicalDisk
                    ));

    CDLOG( "GetDriveLayout(%p): updating drive layout for DE %p ",
           DeviceObject,
           physicalDisk );
    
    freeLayouts = FALSE;
    
    ACQUIRE_EXCLUSIVE( &physicalDisk->DriveLayoutLock );
    
    if ( physicalDisk->DriveLayout ) {
        ExFreePool( physicalDisk->DriveLayout );
        physicalDisk->DriveLayout = NULL;
    }
    physicalDisk->DriveLayout = cachedDriveLayoutInfo;
    physicalDisk->DriveLayoutSize = driveLayoutSize;
    
    RELEASE_EXCLUSIVE( &physicalDisk->DriveLayoutLock );
    
    RtlCopyMemory( driveLayoutInfo, 
                   cachedDriveLayoutInfo,
                   driveLayoutSize );

    //
    // Point the user to the drive layout buffer and return success.  Caller is
    // responsible for freeing the buffer when they are done with it.
    //
    
    *DriveLayout = driveLayoutInfo;

FnExit:

    if ( freeLayouts ) {
        
        if ( driveLayoutInfo ) {
            ExFreePool( driveLayoutInfo );
        }
        
        if ( cachedDriveLayoutInfo ) {
            ExFreePool( cachedDriveLayoutInfo );
        }
    }

    return status;

} // GetDriveLayout



MEDIA_TYPE
GetMediaType(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    Return the SCSI_ADDRESS for a given device object.

Arguments:

    DeviceObject - The specific device object to return info about

    ScsiAddress - Pointer to a SCSI_ADDRESS structure to return the info

Return Value:

    Media Type or Unknown if not known.

--*/

{
    PIRP                irp;
    PKEVENT             event;
    IO_STATUS_BLOCK     ioStatusBlock;
    NTSTATUS            status;
    DISK_GEOMETRY       diskGeometry;

    event = ExAllocatePool( NonPagedPool,
                            sizeof(KEVENT) );
    if ( event == NULL ) {
        return( Unknown );
    }

    //
    // Find out if this is on a SCSI bus. Note, that if this device
    // is not a SCSI device, it is expected that the following
    // IOCTL will fail!
    //

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                        DeviceObject,
                                        NULL,
                                        0,
                                        &diskGeometry,
                                        sizeof(DISK_GEOMETRY),
                                        FALSE,
                                        event,
                                        &ioStatusBlock);

    if (!irp) {
        ExFreePool( event );
        ClusDiskPrint((
                    1,
                    "[ClusDisk] Failed to build IRP to read MediaType.\n"
                    ));
        return(Unknown);
    }

    //
    // Set the event object to the unsignaled state.
    // It will be used to signal request completion.
    //

    KeInitializeEvent(event,
                      NotificationEvent,
                      FALSE);

    status = IoCallDriver(DeviceObject,
                          irp);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(event,
                              Suspended,
                              KernelMode,
                              FALSE,
                              NULL);

        status = ioStatusBlock.Status;
    }
    ExFreePool( event );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                    1,
                    "[ClusDisk] Failed to read SCSI_ADDRESS. %08X\n",
                    status
                    ));
        return(Unknown);
    }

    return(diskGeometry.MediaType);

} // GetMediaType



NTSTATUS
GetScsiAddress(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_ADDRESS ScsiAddress
    )

/*++

Routine Description:

    Return the SCSI_ADDRESS for a given device object.

Arguments:

    DeviceObject - The specific device object to return info about

    ScsiAddress - Pointer to a SCSI_ADDRESS structure to return the info

Return Value:

    NTSTATUS

--*/

{
    PIRP                irp;
    PKEVENT             event;
    IO_STATUS_BLOCK     ioStatusBlock;
    NTSTATUS            status;

    event = ExAllocatePool( NonPagedPool,
                            sizeof(KEVENT) );
    if ( event == NULL ) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    //
    // Find out if this is on a SCSI bus. Note, that if this device
    // is not a SCSI device, it is expected that the following
    // IOCTL will fail!
    //

    irp = IoBuildDeviceIoControlRequest(IOCTL_SCSI_GET_ADDRESS,
                                        DeviceObject,
                                        NULL,
                                        0,
                                        ScsiAddress,
                                        sizeof(SCSI_ADDRESS),
                                        FALSE,
                                        event,
                                        &ioStatusBlock);

    if (!irp) {
        ExFreePool( event );
        ClusDiskPrint((
                    1,
                    "[ClusDisk] Failed to build IRP to read SCSI ADDRESS.\n"
                    ));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Set the event object to the unsignaled state.
    // It will be used to signal request completion.
    //

    KeInitializeEvent(event,
                      NotificationEvent,
                      FALSE);

    status = IoCallDriver(DeviceObject,
                          irp);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(event,
                              Suspended,
                              KernelMode,
                              FALSE,
                              NULL);

        status = ioStatusBlock.Status;
    }
    ExFreePool( event );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                    1,
                    "[ClusDisk] Failed to read SCSI_ADDRESS. %08X\n",
                    status
                    ));

        CDLOG( "GetScsiAddress(%p): failed %!status!", 
               DeviceObject,
               status );
    }

    return(status);

} // GetScsiAddress



PDRIVE_LAYOUT_INFORMATION
ClusDiskGetPartitionInfo(
    PCLUS_DEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

    Return the Partition Layout Information for particular device extension.

Arguments:

    DeviceExtension - The specific device extension to return information.

Return Value:

    Pointer to an allocated partition layout information structure.
    NULL on failure.

Notes:

    The caller is responsible for freeing the allocated buffer.

--*/

{
    PIRP                        irp;
    PKEVENT                     event;
    IO_STATUS_BLOCK             ioStatusBlock;
    NTSTATUS                    status = STATUS_IO_TIMEOUT;
    ULONG                       driveLayoutInfoSize;
    PDRIVE_LAYOUT_INFORMATION   driveLayoutInfo;
    ULONG                       retryCount = MAX_RETRIES;

    driveLayoutInfoSize = sizeof(DRIVE_LAYOUT_INFORMATION) +
        (MAX_PARTITIONS * sizeof(PARTITION_INFORMATION));

    driveLayoutInfo = ExAllocatePool(NonPagedPoolCacheAligned,
                                   driveLayoutInfoSize);

    if ( !driveLayoutInfo ) {
        ClusDiskPrint((
                    1,
                    "[ClusDisk] Failed to allocate PartitionInfo structure to read drive layout.\n"
                    ));
        return(NULL);
    }

    event = ExAllocatePool( NonPagedPool,
                            sizeof(KEVENT) );
    if ( !event ) {
        ExFreePool(driveLayoutInfo);
        return(NULL);
    }

    while ( retryCount-- ) {

        if ( (retryCount != (MAX_RETRIES-1)) &&
             (status != STATUS_DEVICE_BUSY) ) {

            ResetScsiDevice( DeviceExtension->TargetDeviceObject,
                             &DeviceExtension->ScsiAddress );
        }

        //
        // Create IRP for the get drive layout device control.
        //

        irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_DRIVE_LAYOUT,
                                            DeviceExtension->TargetDeviceObject,
                                            NULL,
                                            0,
                                            driveLayoutInfo,
                                            driveLayoutInfoSize,
                                            FALSE,
                                            event,
                                            &ioStatusBlock);

        if (!irp) {
            ClusDiskPrint((
                        1,
                        "[ClusDisk] Failed to Init IRP to read PartitionInfo. Skipping partitions!\n"
                        ));
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        //
        // Set the event object to the unsignaled state.
        // It will be used to signal request completion.
        //

        KeInitializeEvent(event,
                          NotificationEvent,
                          FALSE);

        status = IoCallDriver(DeviceExtension->TargetDeviceObject,
                              irp);

        if (status == STATUS_PENDING) {

            KeWaitForSingleObject(event,
                                  Suspended,
                                  KernelMode,
                                  FALSE,
                                  NULL);

            status = ioStatusBlock.Status;
        }

        if ( !NT_SUCCESS(status) ) {
            if ( (status != STATUS_DEVICE_OFF_LINE) &&
                 (status != STATUS_DATA_OVERRUN) ) {
                ClusDiskPrint((
                    1,
                    "[ClusDisk] Failed to read PartitionInfo. Status %lx\n",
                    status
                        ));
            }
            ClusDiskGetDiskGeometry( DeviceExtension->TargetDeviceObject );
            continue;
        } else {
            DeviceExtension->Signature = driveLayoutInfo->Signature;
            break;
        }
    }

    ExFreePool( event );

    if ( NT_SUCCESS(status) ) {
        return(driveLayoutInfo);
    } else {
        ExFreePool(driveLayoutInfo);
        return(NULL);
    }

} // ClusDiskGetPartitionInfo



BOOLEAN
AddAttachedDevice(
    IN ULONG Signature,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    Indicate that this device is now attached.

Arguments:

    Signature - The signature for the device we just attached.

    DeviceObject - The device object for the partition0 device object.

Return Value:

    TRUE - Signature is already on the device list or has been added.
           successfully.

    FALSE - Signature was not on the device list and we failed to add it.

--*/

{
    PDEVICE_LIST_ENTRY          deviceEntry;
    PCLUS_DEVICE_EXTENSION      deviceExtension;

    // 2000/02/05: stevedz - added synchronization.
    
    ACQUIRE_EXCLUSIVE( &ClusDiskDeviceListLock );
    
    deviceEntry = ClusDiskDeviceList;

    while ( deviceEntry != NULL ) {
        if ( Signature == deviceEntry->Signature ) {
            if ( deviceEntry->Attached ) {
                ClusDiskPrint((
                        1,
                        "[ClusDisk] Attaching to %lx more than once!\n",
                        Signature ));
            }
            if ( DeviceObject ) {
                deviceExtension = DeviceObject->DeviceExtension;
                ASSERT(deviceExtension->PhysicalDevice == DeviceObject);
                deviceEntry->Attached = TRUE;
                deviceEntry->DeviceObject = DeviceObject;
                deviceExtension->AttachValid = TRUE;
                deviceExtension->Signature = Signature;
            }
            RELEASE_EXCLUSIVE( &ClusDiskDeviceListLock );
            return(TRUE);
        }
        deviceEntry = deviceEntry->Next;
    }

    deviceEntry = ExAllocatePool(
                                NonPagedPool,
                                sizeof(DEVICE_LIST_ENTRY) );
    if ( deviceEntry == NULL ) {
        ClusDiskPrint((1,
                    "[ClusDisk] Failed to allocate device entry structure for signature %08lX\n",
                    Signature));
        RELEASE_EXCLUSIVE( &ClusDiskDeviceListLock );
        return(FALSE);
    }

    RtlZeroMemory( deviceEntry, sizeof(DEVICE_LIST_ENTRY) );

    deviceEntry->Signature = Signature;
    deviceEntry->LettersAssigned = FALSE;
    deviceEntry->DeviceObject = DeviceObject;

    if ( DeviceObject == NULL ) {
        deviceEntry->Attached = FALSE;
    } else {
        deviceEntry->Attached = TRUE;
    }

    //
    // Link new entry into list.
    //
    deviceEntry->Next = ClusDiskDeviceList;
    ClusDiskDeviceList = deviceEntry;

    RELEASE_EXCLUSIVE( &ClusDiskDeviceListLock );
    return(TRUE);

} // AddAttachedDevice


BOOLEAN
MatchDevice(
    IN ULONG Signature,
    OUT PDEVICE_OBJECT *DeviceObject
    )

/*++

Routine Description:

    Check to see if the Signature of the specified device is one
    that we should control.

Arguments:

    Signature - The signature for the device we are checking.

    DeviceObject - Pointer to a return value for the device object.

Return Value:

    TRUE - if this Signature is for a device we should control.

    FALSE - if this Signature is NOT for a device we should control.

--*/

{
    PDEVICE_LIST_ENTRY deviceEntry;

    if ( SystemDiskSignature == Signature ) {
        if ( ARGUMENT_PRESENT(DeviceObject) ) {
            *DeviceObject = NULL;
        }
        return(FALSE);
    }

    // 2000/02/05: stevedz - added synchronization.
    
    ACQUIRE_SHARED( &ClusDiskDeviceListLock );
    
    deviceEntry = ClusDiskDeviceList;

    while ( deviceEntry != NULL ) {
        if ( Signature == deviceEntry->Signature ) {
            if ( ARGUMENT_PRESENT(DeviceObject) ) {
                *DeviceObject = deviceEntry->DeviceObject;
            }
            RELEASE_SHARED( &ClusDiskDeviceListLock );
            return(TRUE);
        }
        deviceEntry = deviceEntry->Next;
    }

    if ( ARGUMENT_PRESENT(DeviceObject) ) {
        *DeviceObject = NULL;
    }
    RELEASE_SHARED( &ClusDiskDeviceListLock );
    return(FALSE);

} // MatchDevice



BOOLEAN
MatchScsiBus(
    PSCSI_ADDRESS ScsiAddress
    )

/*++

Routine Description:

    Check to see if the ScsiAddress of the specified device is one
    that we could possibly control. That means that it resides on a
    shared SCSI bus.

Arguments:

    ScsiAddress - pointer to the SCSI_ADRESS for this device.

Return Value:

    TRUE - if this SCSI_ADDRESS matchs.

    FALSE - if this SCSI_ADDRESS does NOT match.

--*/

{
    PSCSI_BUS_ENTRY busEntry;

    busEntry = ClusDiskScsiBusList;
    while ( busEntry ) {
        if ( (busEntry->Port == ScsiAddress->PortNumber) &&
             (busEntry->Path == ScsiAddress->PathId) ) {
            return(TRUE);
        }
        busEntry = busEntry->Next;
    }

    return(FALSE);

} // MatchScsiBus



NTSTATUS
ClusDiskGetDiskGeometry(
    PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    Retry getting disk geometry.

Arguments:

    DeviceObject - the target device object.

Return Value:

    NTSTATUS

--*/

{
    NTSTATUS    status;
    NTSTATUS    tmpStatus;
    ULONG       retryCount = 2;
    SCSI_ADDRESS scsiAddress;

    if ( DeviceObject->DeviceType  == FILE_DEVICE_DISK_FILE_SYSTEM ) {
        return(STATUS_INVALID_DEVICE_REQUEST);
    }

    do {
        status = GetDiskGeometry( DeviceObject );
        if ( status == STATUS_DATA_OVERRUN ) {
            tmpStatus = GetScsiAddress( DeviceObject, &scsiAddress );
            if ( NT_SUCCESS(tmpStatus) &&
                 (status != STATUS_DEVICE_BUSY) &&
                 (retryCount > 1) ) {
                ResetScsiDevice( DeviceObject, &scsiAddress );
            }
        }
    } while ( --retryCount &&
              (status == STATUS_DATA_OVERRUN) );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] Failed to read disk geometry, error %lx.\n",
                        status ));
    }

    return(status);

} // ClusDiskGetDiskGeometry



NTSTATUS
GetDiskGeometry(
    PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    Get the disk geometry for a target device.

Arguments:

    DeviceObject - the target device object.

Return Value:

    NTSTATUS

--*/

{
    PDISK_GEOMETRY      diskGeometryBuffer;
    NTSTATUS            status;
    PKEVENT             event;
    PIRP                irp;
    IO_STATUS_BLOCK     ioStatusBlock;

    //
    // Allocate DISK_GEOMETRY buffer from nonpaged pool.
    //

    diskGeometryBuffer = ExAllocatePool(NonPagedPoolCacheAligned,
                                        sizeof(DISK_GEOMETRY));

    if (!diskGeometryBuffer) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    event = ExAllocatePool( NonPagedPool,
                            sizeof(KEVENT) );
    if ( !event ) {
        ExFreePool(diskGeometryBuffer);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Perform the get drive geometry synchronously.
    //

    KeInitializeEvent(event,
                      NotificationEvent,
                      FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                        DeviceObject,
                                        NULL,
                                        0,
                                        diskGeometryBuffer,
                                        sizeof(DISK_GEOMETRY),
                                        FALSE,
                                        event,
                                        &ioStatusBlock);

    status = IoCallDriver(DeviceObject, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(event,
                              Suspended,
                              KernelMode,
                              FALSE,
                              NULL);
        status = ioStatusBlock.Status;
    }

    ExFreePool(event);

    //
    // Deallocate read capacity buffer.
    //
    ExFreePool(diskGeometryBuffer);

    return(status);

} // GetDiskGeometry



NTSTATUS
ReserveScsiDevice(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

    Reserve a SCSI device.

Arguments:

    DeviceExtension - The device extension for the device to reserve.

Return Value:

    NTSTATUS

--*/

{
    PIRP                        irp;
    NTSTATUS                    status;
    PIO_STACK_LOCATION          irpStack;
    PKEVENT                     event;
    KIRQL                       irql;
    PCLUS_DEVICE_EXTENSION      rootDeviceExtension;
    IO_STATUS_BLOCK             ioStatusBlock;
    PLIST_ENTRY                 listEntry;
    ULONG                       retryCount = 1;
    
    CDLOGF(RESERVE,"ReserveScsiDevice(%p): Entry DiskNo %d Sig %08x",
            DeviceExtension->DeviceObject,
            DeviceExtension->DiskNumber,
            DeviceExtension->Signature );

    event = ExAllocatePool( NonPagedPool,
                            sizeof(KEVENT) );
    if ( !event ) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }


retry:
    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_RESERVE,
                                        DeviceExtension->TargetDeviceObject,
                                        NULL,
                                        0,
                                        NULL,
                                        0,
                                        FALSE,
                                        event,
                                        &ioStatusBlock);

    if ( irp == NULL ) {
        ExFreePool(event);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    KeInitializeEvent(event,
                      NotificationEvent,
                      FALSE);

    status = IoCallDriver(DeviceExtension->TargetDeviceObject,
                          irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(event,
                              Suspended,
                              KernelMode,
                              FALSE,
                              NULL);
        status = ioStatusBlock.Status;
    }

    rootDeviceExtension = RootDeviceObject->DeviceExtension;

    if ( !NT_SUCCESS(status) ) {
        if ( retryCount-- &&
             (status == STATUS_IO_DEVICE_ERROR) ) {
            goto retry;
        }
        ClusDiskPrint((
                    1,
                    "[ClusDisk] Lost reservation for Signature %08lx, status %lx.\n",
                    DeviceExtension->Signature,
                    status
                    ));

        IoAcquireCancelSpinLock( &irql );
        KeAcquireSpinLockAtDpcLevel(&ClusDiskSpinLock);
        DeviceExtension->ReserveTimer = 0;
        DeviceExtension->ReserveFailure = status;
        //
        // Signal all waiting Irp's
        //
        while ( !IsListEmpty(&DeviceExtension->WaitingIoctls) ) {
            listEntry = RemoveHeadList(&DeviceExtension->WaitingIoctls);
            irp = CONTAINING_RECORD( listEntry,
                                     IRP,
                                     Tail.Overlay.ListEntry );
            // ReleaseRemoveLock(&DeviceExtension->RemoveLock, Irp);
            //irp->IoStatus.Status = status;
            //IoCompleteRequest(irp, IO_NO_INCREMENT);
            ClusDiskCompletePendingRequest(irp, status, DeviceExtension);
        }
        KeReleaseSpinLockFromDpcLevel(&ClusDiskSpinLock);
        IoReleaseCancelSpinLock( irql );
    }

    ExFreePool(event);

    DeviceExtension->TimerBusy = FALSE;
    
    CDLOGF(RESERVE,"ReserveScsiDevice(%p): Exit => %!status!",
            DeviceExtension->DeviceObject,
            status );

    return(status);

} // ReserveScsiDevice



VOID
ReleaseScsiDevice(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

    Release a SCSI device (release from reservation).

Arguments:

    DeviceExtension - the device extension of the device to release.
                      This must be the physical device (partition0).

Return Value:

    None.

--*/

{
    PIRP                        irp;
    SCSI_PASS_THROUGH           spt;
    SCSI_REQUEST_BLOCK          srb;
    PKEVENT                     event;
    IO_STATUS_BLOCK             ioStatusBlock;
    NTSTATUS                    status = STATUS_INSUFFICIENT_RESOURCES;
    PIO_STACK_LOCATION          irpStack;

    CDLOG( "ReleaseScsiDevice(%p): Entry DiskNo %d Sig %08x",
           DeviceExtension->DeviceObject,
           DeviceExtension->DiskNumber,
           DeviceExtension->Signature );

    ClusDiskPrint((3,
                   "[ClusDisk] Release disk number %u (sig: %08X), disk state %s \n",
                   DeviceExtension->DiskNumber,
                   DeviceExtension->Signature,
                   DiskStateToString( DeviceExtension->DiskState ) ));

    event = ExAllocatePool( NonPagedPool,
                            sizeof(KEVENT) );
    if ( !event ) {
        return;
    }

    irp = IoBuildDeviceIoControlRequest(IOCTL_DISK_RELEASE,
                                        DeviceExtension->TargetDeviceObject,
                                        &spt,
                                        sizeof(SCSI_PASS_THROUGH),
                                        &spt,
                                        sizeof(SCSI_PASS_THROUGH),
                                        FALSE,
                                        event,
                                        &ioStatusBlock);

    if (!irp) {
        ExFreePool(event);
        ClusDiskPrint((
                    1,
                    "[ClusDisk] Failed to Init IRP to perform a release.\n"
                    ));
        return;
    }

    //
    // Before release, mark disk as offline.
    //

    ASSERT( DeviceExtension == DeviceExtension->PhysicalDevice->DeviceExtension );

    // stevedz - disable this assertion for now.
    // ASSERT( DiskOffline == DeviceExtension->DiskState );    

    // DeviceExtension->DiskState = DiskOffline;
    OFFLINE_DISK( DeviceExtension );
    
    ClusDiskPrint(( 3,
                    "[ClusDisk] Release %p, marking disk offline \n",
                    DeviceExtension->PhysicalDevice
                    ));

    //
    // Set the event object to the unsignaled state.
    // It will be used to signal request completion.
    //

    KeInitializeEvent(event,
                      NotificationEvent,
                      FALSE);

    status = IoCallDriver(DeviceExtension->TargetDeviceObject,
                          irp);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(event,
                              Suspended,
                              KernelMode,
                              FALSE,
                              NULL);

        status = ioStatusBlock.Status;
    }

    ExFreePool(event);

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                    1,
                    "[ClusDisk] Failed to perform release. Status %lx\n",
                    status
                    ));
    }

    CDLOG( "ReleaseScsiDevice(%p): Exit => %!status!",
           DeviceExtension->DeviceObject,
           status );
} // ReleaseScsiDevice



VOID
ResetScsiDevice(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_ADDRESS ScsiAddress
    )

/*++

Routine Description:

    Reset a SCSI device.

Arguments:

    DeviceObject - The device object to perform the bus reset.

    ScsiAddress - The SCSI_ADDRESS for specific device. Needs PathId.

Return Value:

    None.

--*/

{
    PIRP                        irp;
    STORAGE_BUS_RESET_REQUEST   storageReset;
    PKEVENT                     event;
    IO_STATUS_BLOCK             ioStatusBlock;
    NTSTATUS                    status;
    PIO_STACK_LOCATION          irpStack;

    CDLOG( "ResetScsiDevice(%p): Entry PathId %d", 
           DeviceObject, 
           ScsiAddress->PathId );

    ClusDiskPrint(( 3,
                    "[ClusDisk] Bus Reset DevObj %p  PathId %u  \n",
                    DeviceObject,
                    ScsiAddress->PathId
                    ));
    
    event = ExAllocatePool( NonPagedPool,
                            sizeof(KEVENT) );
    if ( !event ) {
        return;
    }

    storageReset.PathId = ScsiAddress->PathId;

    irp = IoBuildDeviceIoControlRequest(IOCTL_STORAGE_BREAK_RESERVATION,
                                        DeviceObject,
                                        &storageReset,
                                        sizeof(STORAGE_BUS_RESET_REQUEST),
                                        NULL,
                                        0,
                                        FALSE,
                                        event,
                                        &ioStatusBlock);

    if (!irp) {
        ExFreePool( event );
        ClusDiskPrint((
                    1,
                    "[ClusDisk] Failed to Init IRP to perform a reset.\n"
                    ));
        return;
    }

    //
    // Set the event object to the unsignaled state.
    // It will be used to signal request completion.
    //

    KeInitializeEvent(event,
                      NotificationEvent,
                      FALSE);

    status = IoCallDriver(DeviceObject,
                          irp);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(event,
                              Suspended,
                              KernelMode,
                              TRUE,
                              NULL);

        status = ioStatusBlock.Status;
    }

    ExFreePool( event );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                    1,
                    "[ClusDisk] Failed to perform reset on %wZ. Status %lx\n",
                    &DeviceObject->DriverObject->DriverName,
                    status
                    ));
    }

    CDLOG( "ResetScsiDevice(%p): Exit => %!status!", DeviceObject, status );

} // ResetScsiDevice



NTSTATUS
ClusDiskOfflineFtSet(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

    Tell FTDISK to offline the FT Set associated with this device.

Arguments:

    DeviceExtension - pointer to the ClusDisk device extension for the device.

Return Value:

    NTSTATUS for this request.

--*/

{
    return STATUS_SUCCESS;

} // ClusDiskOfflineFtSet



VOID
ClusDiskAddScsiBusList(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

    This routine adds a potentially new bus to our bus list.

Arguments:

    DeviceExtension - The device extension that we just found.

Return Value:

    None.

--*/

{
    PSCSI_BUS_ENTRY busEntry;

    busEntry = ClusDiskScsiBusList;
    while ( busEntry ) {
        if ( (busEntry->Port == DeviceExtension->ScsiAddress.PortNumber) &&
             (busEntry->Path == DeviceExtension->ScsiAddress.PathId) ) {
            break;
        }
        busEntry = busEntry->Next;
    }

    if ( !busEntry ) {
        busEntry = ExAllocatePool(NonPagedPool,
                                  sizeof(SCSI_BUS_ENTRY) );
        if (busEntry != NULL ) {
            busEntry->Port = DeviceExtension->ScsiAddress.PortNumber;
            busEntry->Path = DeviceExtension->ScsiAddress.PathId;
            busEntry->Next = ClusDiskScsiBusList;
            ClusDiskScsiBusList = busEntry;
        }
    }

    return;

} // ClusDiskAddScsiBusList


#if 0

NTSTATUS
LockVolumes(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

    Lock all volumes for this Disk.

Arguments:

    DiskNumber - the disk number for the disk to lock volumes.

Return Value:

    NT Status for request.

--*/

{
    NTSTATUS                status;
    OBJECT_ATTRIBUTES       objectAttributes;
    UNICODE_STRING          ntUnicodeString;
    HANDLE                  fileHandle;
    WCHAR                   deviceNameBuffer[MAX_PARTITION_NAME_LENGTH];
    IO_STATUS_BLOCK         ioStatusBlock;
    PDRIVE_LAYOUT_INFORMATION driveLayoutInfo;
    PPARTITION_INFORMATION  partitionInfo;
    ULONG                   partIndex;
    HANDLE                  eventHandle;
    PFILE_OBJECT            fileObject;
    PDEVICE_OBJECT          deviceObject;
    PKEVENT                 event;
    PIRP                    irp;

    //
    // Allocate an event structure
    //
    event = ExAllocatePool(
                NonPagedPool,
                sizeof(KEVENT)
                );

    status = STATUS_INSUFFICIENT_RESOURCES;
    if (!event) {
        return(status);
    }

    driveLayoutInfo = ClusDiskGetPartitionInfo( DeviceExtension );

    if ( driveLayoutInfo != NULL ) {
        //
        // Create event for notification.
        //
        status = ZwCreateEvent( &eventHandle,
                                EVENT_ALL_ACCESS,
                                NULL,
                                SynchronizationEvent,
                                FALSE );

        if ( !NT_SUCCESS(status) ) {
            ExFreePool( driveLayoutInfo );
            ExFreePool( event );
            return(status);
        }

        for ( partIndex = 0;
              partIndex < driveLayoutInfo->PartitionCount;
              partIndex++ )
            {

            partitionInfo = &driveLayoutInfo->PartitionEntry[partIndex];

            //
            // First make sure this is a valid partition.
            //
            if ( !partitionInfo->RecognizedPartition ||
                  partitionInfo->PartitionNumber == 0 ) {
                continue;
            }

            //
            // Create the device name for the device.
            //
            swprintf(deviceNameBuffer,
                     DEVICE_PARTITION_NAME,
                     DeviceExtension->DiskNumber,
                     partitionInfo->PartitionNumber);
            WCSLEN_ASSERT( deviceNameBuffer );

            //
            // Get Unicode name
            //
            RtlInitUnicodeString( &ntUnicodeString, deviceNameBuffer );

            //
            // Try to open this device to perform a dismount
            //
            InitializeObjectAttributes( &objectAttributes,
                                        &ntUnicodeString,
                                        OBJ_CASE_INSENSITIVE,
                                        NULL,
                                        NULL );

            ClusDiskPrint((
                    3,
                    "[ClusDisk] Locking Partition %ws.\n",
                    deviceNameBuffer ));

            status = ZwCreateFile( &fileHandle,
                                   SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                                   &objectAttributes,
                                   &ioStatusBlock,
                                   NULL,
                                   FILE_ATTRIBUTE_NORMAL,
                                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                                   FILE_OPEN,
                                   FILE_SYNCHRONOUS_IO_NONALERT,
                                   NULL,
                                   0 );

            if ( !NT_SUCCESS(status) ) {
                ClusDiskPrint((
                        1,
                        "[ClusDisk] LockVolumes failed to open file %wZ. Error %lx.\n",
                        &ntUnicodeString,
                        status ));
                continue;
            }

            status = ZwClearEvent( eventHandle );

#if 0
            status = ObReferenceObjectByHandle(
                                fileHandle,
                                FILE_WRITE_DATA,
                                *IoFileObjectType,
                                KernelMode,
                                &fileObject,
                                NULL );
            if ( !NT_SUCCESS(status) ) {
                ClusDiskPrint((
                        1,
                        "[ClusDisk] LockVolumes: failed to reference object %ws, status %lx\n",
                        deviceNameBuffer,
                        status ));
                continue;
            }
            deviceObject = IoGetRelatedDeviceObject( fileObject );
            ObDereferenceObject( fileObject );
            ClusDiskPrint((
                        1,
                        "[ClusDisk] LockVolumes - found file/device object %p \n",
                        deviceObject ));
            if ( !deviceObject ) {
                continue;
            }

            KeInitializeEvent(event,
                              NotificationEvent,
                              FALSE);


            irp = IoBuildSynchronousFsdRequest(
                            IRP_MJ_FLUSH_BUFFERS,
                            deviceObject,
                            NULL,
                            0,
                            NULL,
                            event,
                            &ioStatusBlock );
            if (!irp) {
                continue;
            }

            if (IoCallDriver( deviceObject,
                              irp ) == STATUS_PENDING) {

                KeWaitForSingleObject(
                    event,
                    Suspended,
                    KernelMode,
                    FALSE,
                    NULL
                    );
            }

#else
            status = ZwFsControlFile(
                                fileHandle,
                                eventHandle,        // Event Handle
                                NULL,               // APC Routine
                                NULL,               // APC Context
                                &ioStatusBlock,
                                FSCTL_LOCK_VOLUME,
                                NULL,               // InputBuffer
                                0,                  // InputBufferLength
                                NULL,               // OutputBuffer
                                0                   // OutputBufferLength
                                );
            if ( status == STATUS_PENDING ) {
                status = ZwWaitForSingleObject(eventHandle,
                                               FALSE,
                                               NULL);
                ASSERT( NT_SUCCESS(status) );
                status = ioStatusBlock.Status;
            }
#endif
            if ( !NT_SUCCESS(status) ) {
                ClusDiskPrint((
                        1,
                        "[ClusDisk] Failed to flush buffers for %wZ. Error %lx.\n",
                        &ntUnicodeString,
                        status ));
            } else {
                ClusDiskPrint((
                        3,
                        "[ClusDisk] Flushed buffers for %wZ.\n",
                        &ntUnicodeString ));
            }

            ZwClose( fileHandle );

        } // for

        ExFreePool( driveLayoutInfo );
        ZwClose( eventHandle );

    } // if

    ExFreePool( event );

    return(status);

} // LockVolumes
#endif


NTSTATUS
IsVolumeMounted(
    IN ULONG DiskNumber,
    IN ULONG PartNumber,
    OUT BOOLEAN *IsMounted
    )
{
    HANDLE      fileHandle = NULL;
    NTSTATUS    status;
    FILE_FS_DEVICE_INFORMATION deviceInfo;
    IO_STATUS_BLOCK ioStatusBlock;

    if ( PASSIVE_LEVEL != KeGetCurrentIrql() ) {
        status = STATUS_UNSUCCESSFUL;
        goto FnExit;
    }
    
    //
    // Open the device so we can query if a volume is mounted without
    // causing it to be mounted.  Note that we can only specify 
    // FILE_READ_ATTRIBUTES | SYNCHRONIZE or a mount will occur.
    //
        
    status = ClusDiskCreateHandle( &fileHandle,
                                   DiskNumber,
                                   PartNumber,
                                   FILE_READ_ATTRIBUTES | SYNCHRONIZE );

    if ( !NT_SUCCESS(status) ) {
        goto FnExit;
    }
    
    //
    // Make the device info query.
    //

    status = ZwQueryVolumeInformationFile( fileHandle,
                                           &ioStatusBlock,
                                           &deviceInfo,
                                           sizeof(deviceInfo),
                                           FileFsDeviceInformation );

    if ( !NT_SUCCESS(status) ) {
        goto FnExit;
    }
    
    *IsMounted = (deviceInfo.Characteristics & FILE_DEVICE_IS_MOUNTED) ?  TRUE : FALSE;
     
FnExit: 

    if ( fileHandle ) {
        ZwClose( fileHandle );
    }

    return status;
    
}   // IsVolumeMounted



NTSTATUS
DismountPartition(
    IN PDEVICE_OBJECT TargetDevice,
    IN ULONG DiskNumber,
    IN ULONG PartNumber
    )

/*++

Routine Description:

    Dismount the device, given the disk and partition numbers

Arguments:

    TargetDevice - the target device to send volume IOCTLs to.
    
    DiskNumber - the disk number for the disk to dismount

    PartNumber - the parition number for the disk to dismount

Return Value:

    NT Status for request.

--*/

{
    NTSTATUS                status;
    NTSTATUS                status2;
    HANDLE                  fileHandle = NULL;
    IO_STATUS_BLOCK         ioStatusBlock;
    KIRQL                   irql;
    BOOLEAN                 isMounted;
    
    CDLOG( "DismountPartition: Entry DiskNo %d PartNo %d", DiskNumber, PartNumber );

    ClusDiskPrint(( 3,
                    "[ClusDisk] DismountPartition: Dismounting disk %d  partition %d \n",
                    DiskNumber,
                    PartNumber ));

    status = IsVolumeMounted( DiskNumber, PartNumber, &isMounted );
    if ( NT_SUCCESS(status) ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] DismountPartition: Volume is mounted returns: %s \n",
                        isMounted ? "TRUE" : "FALSE" ));

        if ( FALSE == isMounted) {
            
            // Volume not mounted, we are done.  Return success.
            
            status = STATUS_SUCCESS;
            goto FnExit;                        
        }
    }
    
    irql = KeGetCurrentIrql();
    if ( PASSIVE_LEVEL != irql ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] DismountPartition: Invalid IRQL %d \n", irql ));
        CDLOG( "DismountPartition: Invalid IRQL %d ", irql ); 
        ASSERT( FALSE );
        status = STATUS_UNSUCCESSFUL;
        goto FnExit;
    }

#if DBG
    //
    // Find out if FTDISK thinks this disk is currently online or offline.
    // If offline, success is returned.  
    // If online, c0000001 STATUS_UNSUCCESSFUL is returned.
    //
    
    status = SendFtdiskIoctlSync( TargetDevice,
                                  DiskNumber, 
                                  PartNumber, 
                                  IOCTL_VOLUME_IS_OFFLINE );
                                  
    
    if ( NT_SUCCESS(status) ) {
        ClusDiskPrint(( 3,
                        "[ClusDisk] DismountPartition: IOCTL_VOLUME_IS_OFFLINE indicates volume is offline. \n" ));
        CDLOG( "DismountPartition: IOCTL_VOLUME_OFFLINE indicates volume is offline" ); 
        
    } else {
        ClusDiskPrint(( 3,
                        "[ClusDisk] DismountPartition: IOCTL_VOLUME_IS_OFFLINE returns %08X \n", 
                        status ));
        CDLOG( "DismountPartition: IOCTL_VOLUME_OFFLINE returns %08X", status ); 
    }
#endif
    
    // If the disk is offline: 
    //      if access is: FILE_READ_ATTRIBUTES | SYNCHRONIZE
    //
    //          - DismountDevice fails with: c0000010 STATUS_INVALID_DEVICE_REQUEST
    //
    //      if access is: FILE_READ_DATA | SYNCHRONIZE
    //
    //          - ClusDiskCreateHandle fails with:  C000000E STATUS_NO_SUCH_DEVICE
    //
    //      if access is: FILE_WRITE_ATTRIBUTES | SYNCHRONIZE
    //
    //          - DismountDevice works!
    
    status = ClusDiskCreateHandle( &fileHandle,
                                   DiskNumber,
                                   PartNumber,
                                   FILE_WRITE_ATTRIBUTES | SYNCHRONIZE );

    //
    // Check status of getting the device handle.
    //
    
    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] DismountPartition: Unable to get device handle \n" ));
        CDLOG( "DismountPartition: Unable to get device handle" ); 
        goto FnExit;
    }

    status = DismountDevice( fileHandle );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] Failed to dismount disk %d partition %d. Error %08X.\n",
                        DiskNumber,
                        PartNumber,
                        status ));
    } else {
        ClusDiskPrint(( 3,
                        "[ClusDisk] Dismounted disk %d partition %d \n",
                        DiskNumber,
                        PartNumber ));
    }

FnExit:

    if ( fileHandle ) {
        ZwClose( fileHandle );
    }
    
    CDLOG( "DismountPartition: Exit DiskNo %d PartNo %d => %!status!", 
           DiskNumber, 
           PartNumber, 
           status );

    ClusDiskPrint(( 3,
                    "[ClusDisk] DismountPartition: Dismounting disk %d  partition %d  status %08X \n",
                    DiskNumber,
                    PartNumber,
                    status ));

    return(status);

} // DismountPartition



NTSTATUS
DismountDevice(
    IN HANDLE FileHandle
    )

/*++

Routine Description:

    Dismounts a device.

Arguments:

    FileHandle - file handle to use for performing dismount.

Return Value:

    NT Status for request.

--*/

{
    IO_STATUS_BLOCK             ioStatusBlock;
    NTSTATUS                    status;
    HANDLE                      eventHandle;

    CDLOG( "DismountDevice: Entry handle %p", FileHandle );

    ClusDiskPrint(( 3,
                    "[ClusDisk] DismountDevice: Entry handle %p \n",
                    FileHandle ));

    //
    // Create event for notification.
    //
    status = ZwCreateEvent( &eventHandle,
                            EVENT_ALL_ACCESS,
                            NULL,
                            SynchronizationEvent,
                            FALSE );

    if ( !NT_SUCCESS(status) ) {
        CDLOG( "DismountDevice: Failed to create event" );
        goto FnExit;
    }

    // 
    // Lock first.
    //
    // If raw FS mounted, dismount will fail if lock was not done first.
    // By doing the lock, we insure we don't see dismount failures on 
    // disks with raw mounted.
    //

    CDLOG( "DismountDevice: FSCTL_LOCK_VOLUME called" );
        
    status = ZwFsControlFile(
                        FileHandle,
                        eventHandle,        // Event Handle
                        NULL,               // APC Routine
                        NULL,               // APC Context
                        &ioStatusBlock,
                        FSCTL_LOCK_VOLUME,
                        NULL,               // InputBuffer
                        0,                  // InputBufferLength
                        NULL,               // OutputBuffer
                        0                   // OutputBufferLength
                        );
    if ( status == STATUS_PENDING ) {
        status = ZwWaitForSingleObject(eventHandle,
                                       FALSE,
                                       NULL);
        ASSERT( NT_SUCCESS(status) );
        status = ioStatusBlock.Status;
    }

    //
    // Now dismount.  We don't care if the lock failed.
    //
    
    CDLOG( "DismountDevice: FSCTL_DISMOUNT_VOLUME called" );

    status = ZwFsControlFile(
                        FileHandle,
                        eventHandle,        // Event Handle
                        NULL,               // APC Routine
                        NULL,               // APC Context
                        &ioStatusBlock,
                        FSCTL_DISMOUNT_VOLUME,
                        NULL,               // InputBuffer
                        0,                  // InputBufferLength
                        NULL,               // OutputBuffer
                        0                   // OutputBufferLength
                        );
    if ( status == STATUS_PENDING ) {
        status = ZwWaitForSingleObject(eventHandle,
                                       FALSE,
                                       NULL);
        ASSERT( NT_SUCCESS(status) );
        status = ioStatusBlock.Status;
    }

    ZwClose( eventHandle );
    if ( !NT_SUCCESS(status) && status != STATUS_VOLUME_DISMOUNTED) {
        ClusDiskPrint((
                    1,
                    "[ClusDisk] DismountDevice: Failed to dismount the volume. Status %08X.\n",
                    status
                    ));
    }

FnExit: 

    CDLOG( "DismountDevice: Handle %p Exit => %!status!", FileHandle, status );

    ClusDiskPrint(( 3,
                    "[ClusDisk] DismountDevice: Exit handle %p, status %08X \n",
                    FileHandle,
                    status ));

    return(status);

} // DismountDevice



BOOLEAN
AttachedDevice(
    IN ULONG Signature,
    OUT PDEVICE_OBJECT *DeviceObject
    )

/*++

Routine Description:

    Find out whether we're supposed to attach to a given disk signature.

Arguments:

    Signature - The signature to decide whether to attach or not.

    DeviceObject - The DeviceObject for Partition0 if it is attached.

Return Value:

    TRUE - if we're supposed to attach to this signature.
    FALSE - if not.

--*/

{
    PDEVICE_LIST_ENTRY  deviceEntry;

    // 2000/02/05: stevedz - added synchronization.
    
    ACQUIRE_SHARED( &ClusDiskDeviceListLock );
    
    deviceEntry = ClusDiskDeviceList;
    while ( deviceEntry ) {
        if ( deviceEntry->Signature == Signature ) {
            if ( deviceEntry->Attached ) {
                *DeviceObject = deviceEntry->DeviceObject;
                RELEASE_SHARED( &ClusDiskDeviceListLock );
                return(TRUE);
            } else {
                RELEASE_SHARED( &ClusDiskDeviceListLock );
                return(FALSE);
            }
        }
        deviceEntry = deviceEntry->Next;
    }

    RELEASE_SHARED( &ClusDiskDeviceListLock );
    return(FALSE);

} // AttachedDevice



NTSTATUS
EnableHaltProcessing(
    IN KIRQL *Irql
    )

/*++

Routine Description:

    Enable halt processing. This routine is called every time we create
    an open reference to the ClusDisk control channel. The reference count
    is bumped and if it transitions from zero to non-zero, we register
    for a halt notification callback with the ClusterNetwork driver.

    If we do open a handle to ClusterNetwork, we must leave it open until
    we're all done.

Arguments:

    None.

Return Value:

    NTSTATUS for the request.

Notes:

    This routine must be called with the ClusDiskSpinLock held.

--*/

{
    NTSTATUS                    status;
    PCLUS_DEVICE_EXTENSION      deviceExtension;
    KIRQL                       irql;
    ULONG                       haltEnabled;
    HALTPROC_CONTEXT            context;
    
    CDLOG( "EnableHaltProcessing: Entry Irql %!irql!", *Irql );
    
    haltEnabled = ClusNetRefCount;
    ClusNetRefCount++;

    //
    // If halt processing is already enabled, then leave now if ClusNetHandle
    // is set.  Otherwise, fall through, open clusnet driver, and try to save
    // the handle.  If multiple threads are saving the handle at the same time,
    // only one will succeed - the other threads will release their handles.
    // Note: the ClusNetHandle might still be null even if the reference
    // count is non-zero. We might be in the process of performing the
    // open on another thread.  In this case, we no longer return an error.
    // Instead, we fall through, and try to save the ClusNetHandle later.
    //
    if ( haltEnabled ) {
        if ( ClusNetHandle != NULL ) {
            CDLOG( "EnableHaltProcessing: ClusNetHandle already saved" );
            return(STATUS_SUCCESS);
        } 
    }

    deviceExtension = RootDeviceObject->DeviceExtension;
    KeReleaseSpinLock(&ClusDiskSpinLock, *Irql);

    context.FileHandle = NULL;
    context.DeviceExtension = deviceExtension;
    
    status = ProcessDelayedWorkSynchronous( RootDeviceObject, EnableHaltProcessingWorker, &context );

    KeAcquireSpinLock(&ClusDiskSpinLock, Irql);

    if ( NT_SUCCESS(status) ) {
        
        //
        // If another thread is running concurrently and managed to save the handle, we need to close
        // the one we just opened.
        //
        
        if ( ClusNetHandle != NULL ) {

            //
            // Don't close the handle directly - use the work queue.  Release the spinlock before
            // closing the handle.  The context filehandle is already set.
            //
                
            KeReleaseSpinLock(&ClusDiskSpinLock, *Irql);
            ProcessDelayedWorkSynchronous( RootDeviceObject, DisableHaltProcessingWorker, &context );
            KeAcquireSpinLock(&ClusDiskSpinLock, Irql);
            
        } else {

            ClusNetHandle = context.FileHandle;
        
        }
        
    } else {
        // Backout refcount
        --ClusNetRefCount;
    }
    CDLOG( "EnableHaltProcessing: Exit Irql %!irql! => %!status!", *Irql, status );

    return(status);

} // EnableHaltProcessing


VOID
EnableHaltProcessingWorker(
    PDEVICE_OBJECT DeviceObject,
    PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    This routine runs in the system process and registers a callback with the
    clusnet driver.

Arguments:

    DeviceObject - Unused.

    WorkContext - General context info and routine specific context info.

Return Value:

    Status returned in WorkContext structure.

--*/
{

    PHALTPROC_CONTEXT           context = WorkContext->Context;
    NTSTATUS                    status;
    HANDLE                      fileHandle;
    IO_STATUS_BLOCK             ioStatusBlock;
    UNICODE_STRING              ntUnicodeString;
    OBJECT_ATTRIBUTES           objectAttributes;
    PCLUS_DEVICE_EXTENSION      deviceExtension;
    KIRQL                       irql;
    HANDLE                      eventHandle;
    CLUSNET_SET_EVENT_MASK_REQUEST eventCallback;
    ULONG                       haltEnabled;

    //
    // Create event for notification.
    //
    status = ZwCreateEvent( &eventHandle,
                            EVENT_ALL_ACCESS,
                            NULL,
                            SynchronizationEvent,
                            FALSE );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] Failed to create event, status %lx\n",
                status ));
        goto FnExit;
    }

    //
    // Setup event mask structure.
    //
    eventCallback.EventMask = ClusnetEventHalt |
                              ClusnetEventPoisonPacketReceived;
    eventCallback.KmodeEventCallback = ClusDiskEventCallback;

    //
    // Create device name for the ClusterNetwork device.
    //

    RtlInitUnicodeString(&ntUnicodeString,
                         DD_CLUSNET_DEVICE_NAME);

    //
    // Try to open ClusterNetwork device.
    //
    InitializeObjectAttributes( &objectAttributes,
                                &ntUnicodeString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    status = ZwCreateFile( &fileHandle,
                           SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                           &objectAttributes,
                           &ioStatusBlock,
                           0,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN_IF,
                           0,
                           NULL,
                           0 );

    ASSERT( status != STATUS_PENDING );

    if ( NT_SUCCESS(status) ) {
        status = ZwDeviceIoControlFile( fileHandle,
                                        eventHandle,
                                        NULL,
                                        NULL,
                                        &ioStatusBlock,
                                        IOCTL_CLUSNET_SET_EVENT_MASK,
                                        &eventCallback,
                                        sizeof(eventCallback),
                                        NULL,
                                        0 );
    } else {
        fileHandle = NULL;
    }

    if ( status == STATUS_PENDING ) {
        status = ZwWaitForSingleObject(eventHandle,
                                       FALSE,
                                       NULL);
        ASSERT( NT_SUCCESS(status) );
        status = ioStatusBlock.Status;
    }

    ZwClose( eventHandle );

    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
            1,
            "[ClusDisk] Failed to register for halt processing. Error %lx.\n",
            status ));
        if ( fileHandle ) {
            ZwClose( fileHandle );
        }
    } else {
    
        context->FileHandle = fileHandle;
    }

FnExit:

    ClusDiskPrint(( 3,
                    "[ClusDisk] EnableHaltProcessingWorker: Returning status %08X \n", status ));

    WorkContext->FinalStatus = status;
    
    KeSetEvent( &WorkContext->CompletionEvent, IO_NO_INCREMENT, FALSE );

}   // EnableHaltProcessingWorker



NTSTATUS
DisableHaltProcessing(
    IN KIRQL *Irql
    )

/*++

Routine Description:

    This routine disables halt processing as needed.

Arguments:

    Irql - pointer to the irql that we were previously running.

Return Value:

    NTSTATUS of request.

Note:

    The ClusDiskSpinLock must be held on entry.

--*/

{
    HANDLE                  clusNetHandle;
    PCLUS_DEVICE_EXTENSION  deviceExtension;
    HALTPROC_CONTEXT        context;

    CDLOG( "DisableHaltProcessing: Entry Irql %!irql!", *Irql );


    if ( ClusNetRefCount == 0 ) {
        return(STATUS_INVALID_DEVICE_STATE);
    }

    ASSERT( ClusNetHandle != NULL );

    if ( --ClusNetRefCount == 0 ) {
        clusNetHandle = ClusNetHandle;
        ClusNetHandle = NULL;
        deviceExtension = RootDeviceObject->DeviceExtension;

        //
        // We must close the ClusterNetwork handle. But first leave
        // the handle null, so we can release the spinlock and
        // perform the decrement syncrhonized. This is just like
        // the enable case when we release the spinlock.
        //
        
        KeReleaseSpinLock(&ClusDiskSpinLock, *Irql);
        context.FileHandle = clusNetHandle;
        ProcessDelayedWorkSynchronous( RootDeviceObject, DisableHaltProcessingWorker, &context );
        KeAcquireSpinLock(&ClusDiskSpinLock, Irql);

        // [GorN 12/09/99] We can get here if EnableHaltProcessing 
        // occurs while we are doing ZwClose( clusNetHandle );
        // Don't need this assert:
        //
        // ASSERT( ClusNetRefCount == 0 );
    }

    CDLOG( "DisableHaltProcessing: Exit Irql %!irql!", *Irql );
    
    return(STATUS_SUCCESS);

} // DisableHaltProcessing

VOID
DisableHaltProcessingWorker(
    PDEVICE_OBJECT DeviceObject,
    PWORK_CONTEXT WorkContext
    )
/*++

Routine Description:

    This routine runs in the system process and simply closes the clusnet 
    file handle.

Arguments:

    DeviceObject - Unused.

    WorkContext - General context info and routine specific context info.

Return Value:

    None.

--*/
{
    PHALTPROC_CONTEXT   context = WorkContext->Context;
    
    ZwClose( context->FileHandle );

    ClusDiskPrint(( 3,
                    "[ClusDisk] DisableHaltProcessingWorker: Returns \n" ));
    
    KeSetEvent( &WorkContext->CompletionEvent, IO_NO_INCREMENT, FALSE );
    
}   // DisableHaltProcessingWorker


VOID
ClusDiskEventCallback(
    IN CLUSNET_EVENT_TYPE   EventType,
    IN CL_NODE_ID           NodeId,
    IN CL_NETWORK_ID        NetworkId
    )

/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/

{
    NTSTATUS        status;
    PDEVICE_OBJECT  deviceObject;
    PCLUS_DEVICE_EXTENSION deviceExtension;
    KIRQL           irql;

    CDLOG( "ClusDiskEventCallback: Entry EventType %d NodeId %d NetworkId %d" , 
           EventType,
           NodeId,
           NetworkId );

    ClusDiskPrint((
            3,
            "[ClusDisk] Halt Processing routine was called with event %lx.\n",
            EventType ));

    if ( RootDeviceObject == NULL ) {
        return;
    }

    deviceObject = RootDeviceObject->DriverObject->DeviceObject;

    // stevedz - Why stop the reservation before offline completes?

#if 0
   
    // We later call ClusDiskCompletePendedIrps (inside ClusDiskHaltProcessingWorker), 
    // to mark disk offline and complete IRPs.  ClusDiskCompletePendedIrps will
    // clear the reserve flags.

    //
    // For each ClusDisk device, if we have a persistent reservation, then
    // stop it.
    //
    while ( deviceObject ) {
        deviceExtension = deviceObject->DeviceExtension;
        if ( deviceExtension->BusType != RootBus ) {
            deviceExtension->ReserveTimer = 0;
            // Don't offline the device so that dismount can possibly work!
        }
        deviceObject = deviceObject->NextDevice;
    }
#endif

    //
    // Now schedule a worker queue item to fully take the devices offline.
    //
    //
    // Globally Synchronize
    //
    KeAcquireSpinLock(&ClusDiskSpinLock, &irql);

    if ( !HaltBusy ) {
        HaltBusy = TRUE;
        ExQueueWorkItem(&HaltWorkItem,
                        CriticalWorkQueue );
    }
    KeReleaseSpinLock(&ClusDiskSpinLock, irql);

    CDLOG( "ClusDiskEventCallback: Exit EventType %d NodeId %d NetworkId %d" , 
           EventType,
           NodeId,
           NetworkId );
    
    return;

} // ClusDiskEventCallback



VOID
ClusDiskLogError(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject OPTIONAL,
    IN ULONG SequenceNumber,
    IN UCHAR MajorFunctionCode,
    IN UCHAR RetryCount,
    IN ULONG UniqueErrorValue,
    IN NTSTATUS FinalStatus,
    IN NTSTATUS SpecificIOStatus,
    IN ULONG LengthOfText,
    IN PWCHAR Text
    )

/*++

Routine Description:

    This routine allocates an error log entry, copies the supplied data
    to it, and requests that it be written to the error log file.

Arguments:

    DriverObject - A pointer to the driver object for the device.

    DeviceObject - A pointer to the device object associated with the
    device that had the error, early in initialization, one may not
    yet exist.

    SequenceNumber - A ulong value that is unique to an IRP over the
    life of the irp in this driver - 0 generally means an error not
    associated with an irp.

    MajorFunctionCode - If there is an error associated with the irp,
    this is the major function code of that irp.

    RetryCount - The number of times a particular operation has been
    retried.

    UniqueErrorValue - A unique long word that identifies the particular
    call to this function.

    FinalStatus - The final status given to the irp that was associated
    with this error.  If this log entry is being made during one of
    the retries this value will be STATUS_SUCCESS.

    SpecificIOStatus - The IO status for a particular error.

    LengthOfText - The length in bytes (including the terminating NULL)
                   of the text insertion string.

    Text - the text to dump.

Return Value:

    None.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    PVOID objectToUse;
    PUCHAR ptrToText;
    ULONG  maxTextLength = 104;


    if (ARGUMENT_PRESENT(DeviceObject)) {

        objectToUse = DeviceObject;

    } else {

        objectToUse = DriverObject;

    }

    if ( LengthOfText < maxTextLength ) {
        maxTextLength = LengthOfText;
    }

    errorLogEntry = IoAllocateErrorLogEntry(
                        objectToUse,
                        (UCHAR)(sizeof(IO_ERROR_LOG_PACKET) + maxTextLength)
                        );

    if ( errorLogEntry != NULL ) {

        errorLogEntry->ErrorCode = SpecificIOStatus;
        errorLogEntry->SequenceNumber = SequenceNumber;
        errorLogEntry->MajorFunctionCode = MajorFunctionCode;
        errorLogEntry->RetryCount = RetryCount;
        errorLogEntry->UniqueErrorValue = UniqueErrorValue;
        errorLogEntry->FinalStatus = FinalStatus;
        errorLogEntry->DumpDataSize = 0;
        ptrToText = (PUCHAR)&errorLogEntry->DumpData[0];

        if (maxTextLength) {

            errorLogEntry->NumberOfStrings = 1;
            errorLogEntry->StringOffset = (USHORT)(ptrToText-
                                                   (PUCHAR)errorLogEntry);
            RtlCopyMemory(
                ptrToText,
                Text,
                maxTextLength
                );

        }

        IoWriteErrorLogEntry(errorLogEntry);

    } else {
        ClusDiskPrint((1,
                "[ClusDisk] Failed to allocate system buffer of size %u.\n",
                sizeof(IO_ERROR_LOG_PACKET) + maxTextLength ));
    }

} // ClusDiskLogError



NTSTATUS
CluSetFtMemberComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine puts the irp back the way it was before we call a lower
    level driver.  We don't care if the lower one succeeded or not.

Arguments:

    DeviceObject - Pointer to the device object for the disk.

    Irp - Pointer to the IRP for the current request.

    Context - not used.

Return Value:

    Always return status_success.

Notes:

    This routine can only be called if ClusDisk succeed in changing
    the state of the device.

--*/

{

    PIO_STACK_LOCATION currentIrpStack = IoGetCurrentIrpStackLocation(Irp);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = (ULONG_PTR)currentIrpStack->Parameters.Others.Argument2;
    Irp->AssociatedIrp.SystemBuffer = currentIrpStack->Parameters.Others.Argument1;

    return(STATUS_SUCCESS);

}



NTSTATUS
ClusDiskMarkIrpPending(
    PIRP                Irp,
    PDRIVER_CANCEL      CancelRoutine
    )
/*++

Notes:

    Called with IoCancelSpinLock held.

--*/
{
    KIRQL               irql;

    //
    // Set up for cancellation
    //
    ASSERT(Irp->CancelRoutine == NULL);

    if (!Irp->Cancel) {

        IoMarkIrpPending(Irp);
        IoSetCancelRoutine(Irp, CancelRoutine);
#if 0
        ClusDiskPrint((
                1,
                "[ClusDisk] Pending Irp %p \n",
                Irp
                ));
#endif
        return(STATUS_SUCCESS);
    }

    //
    // The IRP has already been cancelled.
    //

    ClusDiskPrint((
        1,
        "[ClusDisk] Irp %lx already cancelled.\n", Irp));

    return(STATUS_CANCELLED);

}  // ClusDiskMarkIrpPending



VOID
ClusDiskCompletePendingRequest(
    IN PIRP                 Irp,
    IN NTSTATUS             Status,
    PCLUS_DEVICE_EXTENSION  DeviceExtension
    )
/*++

Routine Description:

    Completes a pending request.

Arguments:

    Irp           - A pointer to the IRP for this request.
    Status        - The final status of the request.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION  irpSp;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

#if DBG

    if (Irp->Cancel) {
        ASSERT(Irp->CancelRoutine == NULL);
    }

#endif  // DBG

    IoSetCancelRoutine(Irp, NULL);

#if 1
    ClusDiskPrint((
            1,
            "[ClusDisk] Completed waiting Irp %p \n",
            Irp
            ));
#endif

    if (Irp->Cancel) {
#if 0
        ClusDiskPrint((
            1,
            "[ClusDisk] Completed irp %p was cancelled\n", Irp));
#endif

        Status = STATUS_CANCELLED;
    }

    ReleaseRemoveLock(&DeviceExtension->RemoveLock, Irp);
    Irp->IoStatus.Status = (NTSTATUS) Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return;

}  // ClusDiskCompletePendingRequest



VOID
ClusDiskIrpCancel(
    PDEVICE_OBJECT  DeviceObject,
    PIRP            Irp
    )

/*++

Routine Description:

    Cancellation handler pending Irps.

Return Value:

    None.

Notes:

    Called with cancel spinlock held.
    Returns with cancel spinlock released.

--*/

{
    PCLUS_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION      irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS                status;

    CDLOG( "IrpCancel: Entry DO %p irp %p", DeviceObject, Irp );

    ClusDiskPrint((
            1,
            "[ClusDisk] Cancel Irp %p, DevObj %p \n",
            Irp,
            DeviceObject ));

    status = AcquireRemoveLock(&deviceExtension->RemoveLock, Irp);
    if ( !NT_SUCCESS(status) ) {
        ClusDiskPrint((
                1,
                "[ClusDisk] ClusDiskIrpCancel: AcquireRemoveLock for %p failed %08X \n",
                deviceExtension,
                status ));
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return;
    }


    //
    // If this Irp is associated with the control device object, then make
    // sure the Irp is removed from the WaitingIoctls list first.
    //

    KeAcquireSpinLockAtDpcLevel(&ClusDiskSpinLock);
    RemoveEntryList( &Irp->Tail.Overlay.ListEntry );
    KeReleaseSpinLockFromDpcLevel(&ClusDiskSpinLock);

    IoSetCancelRoutine(Irp, NULL);

    //
    // Release the cancel spinlock here, so that we are not holding the
    // spinlock when we complete the Irp.
    //
    IoReleaseCancelSpinLock(Irp->CancelIrql);

    ReleaseRemoveLock(&deviceExtension->RemoveLock, Irp);
    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    
    CDLOG( "IrpCancel: Exit DO %p irp %p", DeviceObject, Irp );

    return;

} // ClusDiskIrpCancel



NTSTATUS
ClusDiskForwardIrpSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine sends the Irp to the next driver in line
    when the Irp needs to be processed by the lower drivers
    prior to being processed by this one.

Arguments:

    DeviceObject
    Irp

Return Value:

    NTSTATUS

--*/

{
    PCLUS_DEVICE_EXTENSION   deviceExtension;
    KEVENT event;
    NTSTATUS status;

    KeInitializeEvent( &event, NotificationEvent, FALSE );
    deviceExtension = (PCLUS_DEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // copy the irpstack for the next device
    //
    
    IoCopyCurrentIrpStackLocationToNext( Irp );

    //
    // set a completion routine
    //

    IoSetCompletionRoutine( Irp, ClusDiskIrpCompletion,
                            &event, TRUE, TRUE, TRUE );

    //
    // call the next lower device
    //

    status = IoCallDriver( deviceExtension->TargetDeviceObject, Irp );

    //
    // wait for the actual completion
    //

    if ( status == STATUS_PENDING ) {
        KeWaitForSingleObject( &event, Executive, KernelMode, FALSE, NULL );
        status = Irp->IoStatus.Status;
    }

    return status;

}   // ClusDiskForwardIrpSynchronous()


#if 0

NTSTATUS
EjectVolumes(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine tells the partmgr to eject all volumes.  For the volume manager
    to re-attach to the volumes, IOCTL_PARTMGR_CHECK_UNCLAIMED_PARTITIONS is used.
    The cluster service calls IOCTL_PARTMGR_CHECK_UNCLAIMED_PARTITIONS when bringing
    the disk online, so it is not necessary to make this call in the driver.
    
    Note that this routine should only be called for physical devices (partition0)
    and that no one should be using the volumes.

Arguments:


Return Value:

    NTSTATUS

--*/
{
    PIRP                    irp;
    PKEVENT                 event = NULL;
    PCLUS_DEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    IO_STATUS_BLOCK         ioStatusBlock;
    NTSTATUS                status = STATUS_SUCCESS;

    // Looks like the IO request will bypass clusdisk at the physical disk level 
    // because clusdisk attached after FTDISK went looking for the top of the disk 
    // stack and cached the pointer.
    // 
    // PnP race condition: occasionally, the device stack was incorrect and clustered
    // disks weren't being protected properly.  Since we are using PnP notification 
    // instead of an AddDevice routine, there was a small window where we would
    // attach to the device stack correctly, but another driver was also attaching
    // at the same time.  So I/O bound for the device would go like this:
    //      NTFS -> Volsnap -> Ftdisk -> Disk
    //
    // even though the device stack looked like this:
    //      82171a50  \Driver\ClusDisk   82171b08  ClusDisk1Part0
    //      822be720  \Driver\PartMgr    822be7d8
    //      822bd030  \Driver\Disk       822bd0e8  DR1
    //      822c0990  \Driver\aic78xx    822c0a48  aic78xx1Port2Path0Target0Lun0
    //
    // So we have to tell partmgr to eject all the volume managers and then 
    // let the volume managers attach again.  This has the effect of removing the
    // cached pointer 
    //
    // To tell the volume managers to stop using this disk:
    //      IOCTL_PARTMGR_EJECT_VOLUME_MANAGERS
    //
    // To tell the volume managers they can start using the disk:
    //      IOCTL_PARTMGR_CHECK_UNCLAIMED_PARTITIONS


    CDLOG( "EjectVolumes: Entry DO %p", DeviceObject );

    if ( !deviceExtension->TargetDeviceObject ) {
        status = STATUS_INVALID_PARAMETER;
        goto FnExit;
    }

    event = ExAllocatePool( NonPagedPool,
                            sizeof(KEVENT) );
    if ( NULL == event ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto FnExit;
    }

    //
    // Eject the volume managers.
    //

    irp = IoBuildDeviceIoControlRequest( IOCTL_PARTMGR_EJECT_VOLUME_MANAGERS,
                                         deviceExtension->TargetDeviceObject,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         FALSE,
                                         event,
                                         &ioStatusBlock );

    if ( !irp ) {
        ClusDiskPrint((
                    1,
                    "[ClusDisk] EjectVolumes: Failed to build IRP to eject volume managers. \n"
                    ));
        
        status = STATUS_UNSUCCESSFUL;
        goto FnExit;
    }

    //
    // Set the event object to the unsignaled state.
    // It will be used to signal request completion.
    //

    KeInitializeEvent( event,
                       NotificationEvent,
                       FALSE );

    status = IoCallDriver( deviceExtension->TargetDeviceObject,
                           irp );

    if ( STATUS_PENDING == status ) {

        KeWaitForSingleObject( event,
                               Suspended,
                               KernelMode,
                               FALSE,
                               NULL );

        status = ioStatusBlock.Status;
    }

    ClusDiskPrint((3,
                   "[ClusDisk] EjectVolumes: Eject IOCTL returns %08X \n",
                   status
                   ));

FnExit:

    if ( event ) {
        ExFreePool( event );
    }


    ClusDiskPrint((1,
                   "[ClusDisk] EjectVolumes: Target devobj %p   Final status %08X \n",
                   DeviceObject,
                   status
                   ));

    CDLOG( "EjectVolumes: Exit DO %p, status %08X", DeviceObject, status );

    return status;

}   // EjectVolumes

#endif

#if 0   // Removed 2/27/2001            


NTSTATUS
ReclaimVolumes(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine tells the partmgr to reclaim all volumes.  
    
    Note that this routine should only be called for physical devices (partition0)
    and that no one should be using the volumes.

Arguments:


Return Value:

    NTSTATUS

--*/
{
    PCLUS_DEVICE_EXTENSION  deviceExtension =  DeviceObject->DeviceExtension;
    PIRP                    irp = NULL;
    PKEVENT                 event = NULL;
    IO_STATUS_BLOCK         ioStatusBlock;
    NTSTATUS                status = STATUS_SUCCESS;

    CDLOG( "ReclaimVolumes: Entry DO %p", DeviceObject );

    InterlockedIncrement( &deviceExtension->ReclaimInProgress );
           
    if ( !deviceExtension->TargetDeviceObject ) {
        status = STATUS_INVALID_PARAMETER;
        goto FnExit;
    }
    
    event = ExAllocatePool( NonPagedPool,
                            sizeof(KEVENT) );
    if ( NULL == event ) {
        
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto FnExit;
    }

    //
    // Allow the volume managers to reclaim partitions.
    //

    irp = IoBuildDeviceIoControlRequest( IOCTL_PARTMGR_CHECK_UNCLAIMED_PARTITIONS,
                                         deviceExtension->TargetDeviceObject,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         FALSE,
                                         event,
                                         &ioStatusBlock );

    if ( !irp ) {
        ClusDiskPrint((
                    1,
                    "[ClusDisk] Failed to build IRP to check unclaimed partitions. \n"
                    ));
        
        status = STATUS_UNSUCCESSFUL;
        goto FnExit;
    }

    //
    // Set the event object to the unsignaled state.
    // It will be used to signal request completion.
    //

    KeInitializeEvent( event,
                       NotificationEvent,
                       FALSE );


    status = IoCallDriver( deviceExtension->TargetDeviceObject,
                           irp );

    if ( status == STATUS_PENDING ) {

        KeWaitForSingleObject( event,
                               Suspended,
                               KernelMode,
                               FALSE,
                               NULL );

        status = ioStatusBlock.Status;
    }

FnExit:

    if ( event ) {
        ExFreePool( event );
    }
    
    ClusDiskPrint((1,
                   "[ClusDisk] ReclaimVolumes: Target devobj %p   Final status %08X \n",
                   DeviceObject,
                   status
                   ));

    CDLOG( "ReclaimVolumes: Exit DO %p, status %08X", DeviceObject, status );
    
    InterlockedDecrement( &deviceExtension->ReclaimInProgress );
    
    return status;
    
}   // ReclaimVolumes
#endif


BOOLEAN
IsDiskMbr(
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    Indicate whether the specified disk is MBR or not.

    If the disk is reserved by another node, then the disk must be MBR.  In this case,
    IOCTL_DISK_GET_DRIVE_LAYOUT_EX will fail and we return TRUE indicating that this
    could be an MBR disk.
    
    If the disk is not reserved by another node, then the disk could be GPT or MBR.
    If IOCTL_DISK_GET_DRIVE_LAYOUT_EX succeeds, we check the drive layout info and
    determine the partition style.  If it is not MBR, we return FALSE.  If the drive
    layout partition style indicates we are MBR, then we return TRUE.

Arguments:

    DeviceObject - The specific device object to return info about

Return Value:

    TRUE - if the disk is MBR or we couldn't get the drive layout info.

--*/

{
    
    
    PDRIVE_LAYOUT_INFORMATION_EX    driveLayoutInfo = NULL;
    NTSTATUS                        status;
    ULONG                           driveLayoutSize;

    BOOLEAN                         retVal = TRUE;

    if ( !DeviceObject ) {
        goto FnExit;
    }
    
    //
    // Allocate a drive layout buffer.
    //
    
    driveLayoutSize = sizeof(DRIVE_LAYOUT_INFORMATION_EX) +
        (MAX_PARTITIONS * sizeof(PARTITION_INFORMATION_EX));
    
    driveLayoutInfo = ExAllocatePool( NonPagedPoolCacheAligned,
                                      driveLayoutSize
                                      );
    
    if ( !driveLayoutInfo ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] Failed to allocate drive layout (ex) structure. \n"
                        ));
                    
        goto FnExit;
    }
    
    //
    // Now get the drive layout information
    //

    status = SimpleDeviceIoControl( DeviceObject,
                                    IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                                    NULL,
                                    0,
                                    driveLayoutInfo,
                                    driveLayoutSize
                                    );

    if ( !NT_SUCCESS(status) ) {
        
        //
        // Couldn't get the drive layout.  Free the temporary buffer and return
        // to the caller.
        //
        
        ClusDiskPrint(( 1,
                        "[ClusDisk] Failed to issue IoctlDiskGetDriveLayoutEx. %08X\n",
                        status
                        ));

        CDLOG( "IsDiskMbr(%p): failed %!status!",
               DeviceObject,
               status );
        
        goto FnExit;
                    
    } 

    //
    // At this point, we have the drive layout.  Check if we are working with a
    // MBR disk.  If not MBR, set return to FALSE.
    //
    
    if ( PARTITION_STYLE_MBR != driveLayoutInfo->PartitionStyle ) {
        retVal = FALSE;
    }

FnExit:

    if ( driveLayoutInfo) {
        ExFreePool( driveLayoutInfo );
    }
    
    return retVal;

} // IsDiskMbr


NTSTATUS
SetVolumeState(
    PCLUS_DEVICE_EXTENSION PhysicalDisk,
    ULONG NewDiskState
    )
{
    PVOL_STATE_INFO volStateInfo = NULL;
    
    NTSTATUS        status = STATUS_SUCCESS;

    //
    // If this isn't the physical disk (i.e. partition 0), then exit.
    //
    
    if ( PhysicalDisk != PhysicalDisk->PhysicalDevice->DeviceExtension ) {
        status = STATUS_INVALID_PARAMETER;
        goto FnExit;
    }

#if 0
    // Don't use this...
    // Optimization?  If new state is equal to old state, we are done.
    // Should work as long as this device extension is set AFTER the
    // call to SetVolumeState.  Currently the macros set the device extension
    // state BEFORE calling this routine.  Also, some routines set DE state
    // well before calling this routine.
    // More testing...
    
    if ( NewDiskState == DeviceExtension->DiskState ) {
        goto FnExit;
    }
#endif

    volStateInfo = ExAllocatePool( NonPagedPool, sizeof( VOL_STATE_INFO ) );
    
    if ( !volStateInfo ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto FnExit;
    }

    volStateInfo->NewDiskState = NewDiskState;
    volStateInfo->WorkItem = NULL;
    
    //
    // If IRQL is PASSIVE_LEVEL, call the routine directly.
    // We know the call is direct because the WorkItem portion will
    // be NULL.
    //
    
    if ( PASSIVE_LEVEL == KeGetCurrentIrql() ) {
        SetVolumeStateWorker( PhysicalDisk->DeviceObject, 
                              volStateInfo );
        goto FnExit;
    }
    
    volStateInfo->WorkItem = IoAllocateWorkItem( PhysicalDisk->DeviceObject );
    
    if ( !volStateInfo->WorkItem ) {
        ExFreePool( volStateInfo );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto FnExit;
    }

    IoQueueWorkItem( volStateInfo->WorkItem,
                     SetVolumeStateWorker,
                     CriticalWorkQueue,
                     volStateInfo );
    
FnExit:

    return status;    

}   // SetVolumeState


VOID
SetVolumeStateWorker(
    PDEVICE_OBJECT DeviceObject,
    PVOID Context
    )
/*++

Routine Description:

    Call volume manager to mark all volumes for this disk offline or online.
    
    If the IRQL is not PASSIVE_LEVEL, then this routine will return an error.
    
Arguments:

    DeviceObject - Clustered disk to set state.

    Context - Contains information whether this routine has been called directly
              or via a work item.  Also indicates whether this is an online or 
              offline request.
                                      
Return Value:

    None.

--*/
{
    PDRIVE_LAYOUT_INFORMATION   driveLayoutInfo = NULL;
    PPARTITION_INFORMATION      partitionInfo;
    PIO_WORKITEM                workItem =  ((PVOL_STATE_INFO)Context)->WorkItem;
    PCLUS_DEVICE_EXTENSION      PhysicalDisk = DeviceObject->DeviceExtension;
    
    NTSTATUS                    status;
        
    ULONG                       ioctl;
    ULONG                       partIndex;
    ULONG                       newDiskState = ((PVOL_STATE_INFO)Context)->NewDiskState;

    KIRQL                       irql;
    
    CDLOG( "SetVolumeState: Entry DevObj %p  newstate: %s  workItem: %p ", 
           PhysicalDisk->DeviceObject,
           ( DiskOnline == newDiskState ? "DiskOnline" : "DiskOffline" ),
           workItem );

    ClusDiskPrint(( 3,
                    "[ClusDisk] SetVolumeState: DevObj %p  newstate: %s   workItem: %p \n",
                    PhysicalDisk->DeviceObject,
                    DiskStateToString( newDiskState ),
                    workItem ));

    irql = KeGetCurrentIrql();
    if ( PASSIVE_LEVEL != irql ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] SetVolumeState: Current IRQL %d not PASSIVE_LEVEL  - skipping state change \n",
                        irql ));
        ASSERT( FALSE );
        goto FnExit;
    }

    //
    // This should never happen as it was checked earlier.
    //
    
    if ( PhysicalDisk != PhysicalDisk->PhysicalDevice->DeviceExtension ) {
        ASSERT( FALSE );
        PhysicalDisk = PhysicalDisk->PhysicalDevice->DeviceExtension;
        ClusDiskPrint(( 1,
                        "[ClusDisk] SetVolumeState: Resetting physical disk pointer: DevObj %p  \n",
                        PhysicalDisk->DeviceObject ));
    }
    
    if ( DiskOnline == newDiskState ) {
        ioctl = IOCTL_VOLUME_ONLINE;
    } else {
        ioctl = IOCTL_VOLUME_OFFLINE;
    }

    //
    // Get the drive layout for the disk.
    //

    status = GetDriveLayout( PhysicalDisk->DeviceObject,
                             &driveLayoutInfo,
                             FALSE );

    if ( !NT_SUCCESS(status) || !driveLayoutInfo ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] SetVolumeState: Failed to read partition info, status %08X \n",
                        status ));
        goto FnExit;
    }

    for ( partIndex = 0;
          partIndex < driveLayoutInfo->PartitionCount;
          partIndex++ ) {

        partitionInfo = &driveLayoutInfo->PartitionEntry[partIndex];

        if ( 0 ==  partitionInfo->PartitionNumber ) {
            continue;
        }
        
        // Online/Offline the volume.

        status = SendFtdiskIoctlSync( NULL,
                                      PhysicalDisk->DiskNumber,
                                      partitionInfo->PartitionNumber,
                                      ioctl );
                
        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint(( 1,
                            "[ClusDisk] SetVolumeState: Failed to set state disk%d part%d , status %08X \n",
                            PhysicalDisk->DiskNumber,
                            partitionInfo->PartitionNumber,
                            status
                            ));
        }

    }

FnExit:

    CDLOG( "SetVolumeState: Exit DevObj %p DiskNumber %d  newstate: %s  status %x ", 
           PhysicalDisk->DeviceObject,
           PhysicalDisk->DiskNumber,
           ( DiskOnline == newDiskState ? "DiskOnline" : "DiskOffline" ),
           status );

    ClusDiskPrint(( 3,
                    "[ClusDisk] SetVolumeState: DiskNumber %d  newstate: %s  final status %08X \n",
                    PhysicalDisk->DiskNumber,
                    ( DiskOnline == newDiskState ? "DiskOnline" : "DiskOffline" ),
                    status
                    ));

    if ( driveLayoutInfo ) {
        ExFreePool( driveLayoutInfo );
    }

    if ( workItem ) {
        IoFreeWorkItem( workItem );
    }
    
    if ( Context ) {
        ExFreePool( Context );
    }

    return;

}   // SetVolumeStateWorker


NTSTATUS
SendFtdiskIoctlSync(
    PDEVICE_OBJECT TargetObject,
    ULONG DiskNumber,
    ULONG PartNumber,
    ULONG Ioctl
    )
{
    PIRP                irp;
    PDEVICE_OBJECT      targetDevice = NULL;
    KEVENT              event;
    NTSTATUS            status;
    IO_STATUS_BLOCK     ioStatusBlock;

    WCHAR               partitionNameBuffer[MAX_PARTITION_NAME_LENGTH];
    UNICODE_STRING      targetDeviceName;

    if ( TargetObject ) {
    
        targetDevice = TargetObject;
        
    } else {        
        
        //
        // Create device name for the physical disk.
        //
    
        swprintf( partitionNameBuffer,
                  DEVICE_PARTITION_NAME,
                  DiskNumber,
                  PartNumber );
        WCSLEN_ASSERT( partitionNameBuffer );
    
        ClusDiskPrint(( 3,
                        "[ClusDisk] SendFtdiskIoctlSync: Device %ws \n",
                        partitionNameBuffer
                        ));
    
        status = ClusDiskGetTargetDevice( DiskNumber,
                                          PartNumber,
                                          &targetDevice,
                                          &targetDeviceName,
                                          NULL,
                                          NULL,
                                          FALSE );
        if ( targetDeviceName.Buffer ) {
            RtlFreeUnicodeString(&targetDeviceName);
        }
    }

    if ( !targetDevice ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] SendFtdiskIoctlSync: Failed to get devobj for disk %d partition %d \n",
                        DiskNumber,
                        PartNumber
                        ));
        status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto FnExit;
    }

    //
    // Set the event object to the unsignaled state.
    // It will be used to signal request completion.
    //
    KeInitializeEvent( &event,
                       NotificationEvent,
                       FALSE );

    irp = IoBuildDeviceIoControlRequest( Ioctl,
                                         targetDevice,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         FALSE,
                                         &event,
                                         &ioStatusBlock );
    if ( !irp ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] SendFtdiskIoctlSync: Failed to build IRP for IOCTL %X  \n", Ioctl ));
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto FnExit;
    } 
            
    status = IoCallDriver( targetDevice,
                           irp );

    if ( STATUS_PENDING == status ) {

        KeWaitForSingleObject( &event,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        status = ioStatusBlock.Status;
    }

FnExit:

    if ( !TargetObject ) {
        DEREFERENCE_OBJECT( targetDevice );
    }
    
    CDLOG( "SendFtDiskIoctlSync: Exit disk %d part %d  IOCTL %X  status %X", 
           DiskNumber, PartNumber, Ioctl, status );

    ClusDiskPrint(( 3,
                    "[ClusDisk] SendFtDiskIoctlSync: disk %d part %d  IOCTL %X   status %08X \n",
                    DiskNumber, 
                    PartNumber, 
                    Ioctl,
                    status
                    ));
    
    return status;
    
}    // SendFtdiskIoctlSync


NTSTATUS
AttachSignatureList(
    PDEVICE_OBJECT DeviceObject,
    PULONG InBuffer,
    ULONG InBufferLen
    )
{

    ULONG   idx;
    ULONG   signature;

    NTSTATUS    status = STATUS_INVALID_PARAMETER;
    NTSTATUS    retVal;
    
    BOOLEAN     stopProcessing = FALSE;
    
    UNICODE_STRING signatureName;
    UNICODE_STRING availableName;

    signatureName.Buffer = NULL;
    availableName.Buffer = NULL;
    
    ClusDiskPrint(( 3,
                    "[ClusDisk] AttachSignatureList: list at %p, length %d \n",
                    InBuffer,
                    InBufferLen ));

    CDLOG( "AttachSignatureList: siglist %p, length %d ", InBuffer, InBufferLen );

    if ( !InBufferLen ) {
        status = STATUS_SUCCESS;
        goto FnExit;
    }
    
    if ( InBuffer && 
         InBufferLen && 
         InBufferLen >= sizeof(ULONG) && 
         ( InBufferLen % sizeof(ULONG) == 0 ) ) {

        //
        // Allocate buffer for Signatures registry key. So we can add
        // the signature.
        //
        status = ClusDiskInitRegistryString( &signatureName,
                                             CLUSDISK_SIGNATURE_KEYNAME,
                                             sizeof(CLUSDISK_SIGNATURE_KEYNAME)
                                             );

        if ( !NT_SUCCESS(status) ) {
            goto FnExit;
        }

        //
        // Allocate buffer for AvailableDisks registry key.
        //
        
        status = ClusDiskInitRegistryString( &availableName,
                                             CLUSDISK_AVAILABLE_DISKS_KEYNAME,
                                             sizeof(CLUSDISK_AVAILABLE_DISKS_KEYNAME) );

        if ( !NT_SUCCESS(status) ) {
            goto FnExit;
        }

        for ( idx = 0; idx < InBufferLen / sizeof(ULONG); idx++ ) {
            
            signature = InBuffer[idx];

            ClusDiskPrint((1,
                           "[ClusDisk] AttachSignatureList: attaching signature %08X\n",
                           signature));

            CDLOG( "AttachSignatureList: sig %08x", signature );

            //
            // No signature or system disk signature, don't add it.
            //

            if ( ( 0 == signature ) || SystemDiskSignature == signature ) {
                ClusDiskPrint((2,
                               "[ClusDisk] AttachSignatureList: skipping signature %08X\n",
                               signature));
                CDLOG( "AttachSignatureList: skipping sig %08x", signature );
                continue;
            }
            
            // We have to force the signature under \Parameters\Signatures because
            // the disk might not be accessible (i.e. reserved by another node) and
            // ClusDiskAttachDevice will only put the signature there if the
            // disk can really be attached.
            
            //
            // Create the signature key under \Parameters\Signatures.
            //
            
            retVal = ClusDiskAddSignature( &signatureName,
                                           signature,
                                           FALSE
                                           );

            //
            // Error adding this signature, save the error for return and continue
            // with the signature list.
            //

            if ( !NT_SUCCESS(retVal) ) {
                
                status = retVal;
                continue;
            }
                        
            //
            // Delete the signature key under Parameters\AvailableDisks.
            //
            
            ClusDiskDeleteSignature( &availableName,
                                     signature );
        
            //
            // Just try to attach to the device with no bus resets.
            //
            
            ClusDiskAttachDevice( signature,
                                  0,
                                  DeviceObject->DriverObject,
                                  FALSE,
                                  &stopProcessing );

        }

    }

FnExit:

    if ( signatureName.Buffer ) {
        ExFreePool( signatureName.Buffer );
    }

    if ( availableName.Buffer ) {
        ExFreePool( availableName.Buffer );
    }

    ClusDiskPrint(( 3,
                    "[ClusDisk] AttachSignatureList: returning final status %08X \n",
                    status ));

    CDLOG( "AttachSignatureList: returning final status %x ", status );

    return status;
    
}   // AttachSignatureList


NTSTATUS
DetachSignatureList(
    PDEVICE_OBJECT DeviceObject,
    PULONG InBuffer,
    ULONG InBufferLen
    )
{

    ULONG   idx;
    ULONG   signature;

    NTSTATUS    status = STATUS_SUCCESS;
    NTSTATUS    retVal;
    
    ClusDiskPrint(( 3,
                    "[ClusDisk] DetachSignatureList: list at %p, length %d \n",
                    InBuffer,
                    InBufferLen ));

    CDLOG( "DetachSignatureList: list %p, length %d ", InBuffer, InBufferLen );

    if ( !InBufferLen ) {
        status = STATUS_SUCCESS;
        goto FnExit;
    }
    
    if ( InBuffer && 
         InBufferLen && 
         InBufferLen >= sizeof(ULONG) && 
         ( InBufferLen % sizeof(ULONG) == 0 ) ) {


        for ( idx = 0; idx < InBufferLen / sizeof(ULONG); idx++ ) {
            
            signature = InBuffer[idx];

            ClusDiskPrint((1,
                           "[ClusDisk] DetachSignatureList: detaching signature %08X\n",
                           signature));

            CDLOG( "DetachSignatureList: sig %08x", signature );

            // Skip zero signature.
            if ( !signature ) {
                ClusDiskPrint((2,
                               "[ClusDisk] DetachSignatureList: skipping signature %08X\n",
                               signature));
    
                CDLOG( "DetachSignatureList: skipping sig %08x", signature );
                continue;
            }
            
            retVal = ClusDiskDetachDevice( signature, DeviceObject->DriverObject );

            //
            // If any detach fails, return an error.  If multiple detachs fail, there 
            // is no way to pass back information on which specific signature failed, 
            // so simply indicate one of the failures back to the caller.
            // On failure, we still want to continue detaching, so don't break out
            // of the loop.
            //
                        
            if ( !NT_SUCCESS(retVal) ) {
                status = retVal;
            }
            
        }
    } 

FnExit:

    ClusDiskPrint(( 3,
                    "[ClusDisk] DetachSignatureList: returning final status %08X \n",
                    status ));

    CDLOG( "DetachSignatureList: returning final status %x ", status );

    // Always return success.  
    // Cluster setup will send a NULL buffer with zero length when rejoining a node.
    
    return status;
    
}   // DetachSignatureList


NTSTATUS
CleanupDeviceList(
    PDEVICE_OBJECT DeviceObject
    )
{
/*++

Routine Description:

    Queue a work item to remove entries from the ClusDiskDeviceList.

Arguments:

    DeviceObject - Device that is being removed by the system.

Return Value:

    NTSTATUS

--*/

    PIO_WORKITEM  workItem = NULL;

    CDLOG( "CleanupDeviceList: Entry DO %p", DeviceObject );

    workItem = IoAllocateWorkItem( DeviceObject );

    if ( NULL == workItem ) {
        ClusDiskPrint(( 1,
                        "[ClusDisk] CleanupDeviceList: Failed to allocate WorkItem \n" ));
        goto FnExit;
    }

    //
    // Queue the workitem.  IoQueueWorkItem will insure that the device object is
    // referenced while the work-item progresses.
    //

    ClusDiskPrint(( 3,
                    "[ClusDisk] CleanupDeviceList: Queuing work item \n" ));

    IoQueueWorkItem( workItem,
                     CleanupDeviceListWorker,
                     DelayedWorkQueue,
                     workItem );

FnExit:

    CDLOG( "CleanupDeviceList: Exit, DO %p", DeviceObject );

    return STATUS_SUCCESS;

}   //  CleanupDeviceList


VOID
CleanupDeviceListWorker(
    PDEVICE_OBJECT DeviceObject,
    PVOID Context
    )
/*++

Routine Description:

    Work item that will walk ClusDiskDeviceList and remove any entries
    that are marked as free.

Arguments:

Return Value:

    None.

--*/
{
    PDEVICE_LIST_ENTRY  deviceEntry;
    PDEVICE_LIST_ENTRY  lastEntry;
    PDEVICE_LIST_ENTRY  nextEntry;

    ACQUIRE_EXCLUSIVE( &ClusDiskDeviceListLock );

    deviceEntry = ClusDiskDeviceList;
    lastEntry = NULL;
    while ( deviceEntry ) {

        if ( deviceEntry->FreePool ) {
            if ( lastEntry == NULL ) {
                ClusDiskDeviceList = deviceEntry->Next;
            } else {
                lastEntry->Next = deviceEntry->Next;
            }
            nextEntry = deviceEntry->Next;
            ExFreePool( deviceEntry );
            deviceEntry = nextEntry;
            continue;
        }
        lastEntry = deviceEntry;
        deviceEntry = deviceEntry->Next;
    }

    RELEASE_EXCLUSIVE( &ClusDiskDeviceListLock );

    IoFreeWorkItem( (PIO_WORKITEM)Context );

}   // CleanupDeviceListWorker



#if DBG
VOID
ClusDiskDebugPrint(
    ULONG PrintLevel,
    PCHAR   DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print routine.

Arguments:

    PrintLevel - The Debug Print Level.

    DebugMessage - The Debug Message Format String, plus additional args.

Return:

    None.

--*/

{
    va_list args;

    va_start( args, DebugMessage);

#if !defined(WMI_TRACING) 
    if ( PrintLevel <= ClusDiskPrintLevel ) {
        CHAR buffer[256];
        (VOID) vsprintf( buffer, DebugMessage, args );
        DbgPrint( buffer );
    }
#else
    if ( PrintLevel <= ClusDiskPrintLevel || WPP_LEVEL_ENABLED(LEGACY) ) {
        CHAR buffer[256];

        (VOID) vsprintf( buffer, DebugMessage, args );

        if (PrintLevel <= ClusDiskPrintLevel) {
            DbgPrint( buffer );
        }
        CDLOGF(LEGACY,"LegacyLogging %!ARSTR!", buffer );
    }
#endif

    va_end( args );
}
#endif // DBG


#if DBG

NTSTATUS
AcquireRemoveLock(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN OPTIONAL PVOID Tag 
    )
{
    NTSTATUS status;

    // Don't expect the displayed RemoveLock values to be correct on a heavily utilized system.

    status = IoAcquireRemoveLock(RemoveLock, Tag);

    if ( TrackRemoveLocks || (TrackRemoveLockSpecific == RemoveLock) ) {
        
        ClusDiskPrint(( 1,
                        "ACQ: RemoveLock %p  Tag %p  Status %08X \n", 
                        RemoveLock, 
                        Tag, 
                        status ));

        ClusDiskPrint(( 1,
                        "ACQ: Removed %02X  IoCount %08X \n", 
                        RemoveLock->Common.Removed, 
                        RemoveLock->Common.IoCount ));
    }

    return status;

}   // AcquireRemoveLock

VOID
ReleaseRemoveLock(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID Tag 
    )
{
    // Don't expect the displayed RemoveLock values to be correct on a heavily utilized system.
    
    IoReleaseRemoveLock(RemoveLock, Tag);
    
    if ( TrackRemoveLocks || (TrackRemoveLockSpecific == RemoveLock) ) {
        ClusDiskPrint(( 1,
                        "REL: RemoveLock %p  Tag %p \n ", 
                        RemoveLock, 
                        Tag ));
        
        ClusDiskPrint(( 1,
                        "REL: Removed %02X  IoCount %08X \n", 
                        RemoveLock->Common.Removed, 
                        RemoveLock->Common.IoCount ));
    }

    if (TrackRemoveLocksEnableChecks) {

        //
        // The IoCount should never be less than 1 (especially never a negative value).
        // Is it possible that a race condition could occur because we are printing the
        // value from the RemoveLock and the remove could have just occurred.  RemoveLock
        // IoCount should never be less than zero.
        //
            
        ASSERTMSG("REL: RemoveLock IoCount possibly corrupt (less than 1) ",  (RemoveLock->Common.IoCount >= 1 ));           

        //
        // IoCount == 1 is OK, it just means there is no I/O outstanding on the device.  
        //
                                                                                               
        // ASSERTMSG("REL: IoCount == 1 - check stack ", (RemoveLock->Common.IoCount != 1 ));    
    }

}   // ReleaseRemoveLock

VOID
ReleaseRemoveLockAndWait(
    IN PIO_REMOVE_LOCK RemoveLock,
    IN PVOID Tag 
    )
{
    // Don't expect the displayed RemoveLock values to be correct on a heavily utilized system.

    ClusDiskPrint(( 1,
                    "RELWAIT: RemoveLock %p  Tag %p \n ", 
                    RemoveLock, 
                    Tag ));

    ClusDiskPrint(( 1,
                    "RELWAIT: Removed %02X  IoCount %08X \n", 
                    RemoveLock->Common.Removed, 
                    RemoveLock->Common.IoCount ));

    IoReleaseRemoveLockAndWait(RemoveLock, Tag);

    ClusDiskPrint(( 1, "RELWAIT: Wait complete \n " ));

    ClusDiskPrint(( 1, 
                    "RELWAIT: Removed %02X  IoCount %08X \n", 
                    RemoveLock->Common.Removed, 
                    RemoveLock->Common.IoCount ));

}   // ReleaseRemoveLockAndWait


PCHAR
PnPMinorFunctionString(
    UCHAR MinorFunction
    )
{
    switch (MinorFunction)
    {
        case IRP_MN_START_DEVICE:
            return "IRP_MN_START_DEVICE";
        case IRP_MN_QUERY_REMOVE_DEVICE:
            return "IRP_MN_QUERY_REMOVE_DEVICE";
        case IRP_MN_REMOVE_DEVICE:
            return "IRP_MN_REMOVE_DEVICE";
        case IRP_MN_CANCEL_REMOVE_DEVICE:
            return "IRP_MN_CANCEL_REMOVE_DEVICE";
        case IRP_MN_STOP_DEVICE:
            return "IRP_MN_STOP_DEVICE";
        case IRP_MN_QUERY_STOP_DEVICE:
            return "IRP_MN_QUERY_STOP_DEVICE";
        case IRP_MN_CANCEL_STOP_DEVICE:
            return "IRP_MN_CANCEL_STOP_DEVICE";
        case IRP_MN_QUERY_DEVICE_RELATIONS:
            return "IRP_MN_QUERY_DEVICE_RELATIONS";
        case IRP_MN_QUERY_INTERFACE:
            return "IRP_MN_QUERY_INTERFACE";
        case IRP_MN_QUERY_CAPABILITIES:
            return "IRP_MN_QUERY_CAPABILITIES";
        case IRP_MN_QUERY_RESOURCES:
            return "IRP_MN_QUERY_RESOURCES";
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            return "IRP_MN_QUERY_RESOURCE_REQUIREMENTS";
        case IRP_MN_QUERY_DEVICE_TEXT:
            return "IRP_MN_QUERY_DEVICE_TEXT";
        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            return "IRP_MN_FILTER_RESOURCE_REQUIREMENTS";
        case IRP_MN_READ_CONFIG:
            return "IRP_MN_READ_CONFIG";
        case IRP_MN_WRITE_CONFIG:
            return "IRP_MN_WRITE_CONFIG";
        case IRP_MN_EJECT:
            return "IRP_MN_EJECT";
        case IRP_MN_SET_LOCK:
            return "IRP_MN_SET_LOCK";
        case IRP_MN_QUERY_ID:
            return "IRP_MN_QUERY_ID";
        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            return "IRP_MN_QUERY_PNP_DEVICE_STATE";
        case IRP_MN_QUERY_BUS_INFORMATION:
            return "IRP_MN_QUERY_BUS_INFORMATION";
        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            return "IRP_MN_DEVICE_USAGE_NOTIFICATION";
        case IRP_MN_SURPRISE_REMOVAL:
            return "IRP_MN_SURPRISE_REMOVAL";
        case IRP_MN_QUERY_LEGACY_BUS_INFORMATION:
            return "IRP_MN_QUERY_LEGACY_BUS_INFORMATION";
        default:
            return "Unknown PNP IRP";
    }

}   // PnPMinorFunctionString


PCHAR
BoolToString(
    BOOLEAN Value
    )
{
    if ( Value ) {
        return "TRUE";
    }
    return "FALSE";
    
}   // BoolToString


PCHAR
DiskStateToString(
    ULONG DiskState
    )
{
    switch ( DiskState ) {
        
    case DiskOffline:
        return "DiskOffline (0)";
    
    case DiskOnline:
        return "DiskOnline  (1)";

    case DiskFailed:
        return "DiskFailed  (2)";
        
    case DiskStalled:
        return "DiskStalled (3)";

    case DiskOfflinePending:
        return "DiskOfflinePending (4)";
    
    default:
        return "Unknown DiskState";
    }

}   // DiskStateToString

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusdisk\config.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    config.c

Abstract:

    This module provides the configuration information to the
    cluster disk device driver.

Author:

    Rod Gamache (rodga) 7-Dec-1996
        Steal as much code as possible from FTDISK's config.c
    Charlie Wickham (charlwi) 20-Oct-1997
        NT5: stolen from ntos\fstub\drivesup.c

Environment:

    kernel mode only

Revision History:

--*/

#include "clusdskp.h"
#include "mountmgr.h"


//
// Size of default work area allocated when getting information from
// the registry.
//

#define WORK_AREA  4096

typedef struct _DRIVE_LETTER_ENTRY {
    struct  _DRIVE_LETTER_ENTRY *Next;
    UCHAR   DriveLetter;
    UCHAR   Fill3[3];
} DRIVE_LETTER_ENTRY, *PDRIVE_LETTER_ENTRY;


//
// Global data
//

PDRIVE_LETTER_ENTRY ClusDiskDriveLetters = NULL;

//
// Forwards
//

NTSTATUS
GetDriveLetterFromMountMgr(
    IN  LPWSTR  PartitionString,
    OUT PUCHAR  DriveLetter
    );

#pragma alloc_text(PAGE, GetDriveLetterFromMountMgr)


NTSTATUS
GetDriveLetterFromMountMgr(
    IN  LPWSTR  PartitionString,
    OUT PUCHAR  DriveLetter
    )

/*++

Routine Description:

    This routine queries the mount mgr for the drive letter
    of the specified device.

Arguments:

    DeviceName  - Supplies the device name.

    DriveLetter - Returns the drive letter or 0 for none.

Return Value:

    NTSTATUS

--*/

{
    ULONG                   partitionStringLength;
    ULONG                   mountPointSize;
    PMOUNTMGR_MOUNT_POINT   mountPoint;
    UNICODE_STRING          name;
    NTSTATUS                status;
    PFILE_OBJECT            fileObject;
    PDEVICE_OBJECT          deviceObject;
    KEVENT                  event;
    PIRP                    irp;
    MOUNTMGR_MOUNT_POINTS   points;
    IO_STATUS_BLOCK         ioStatus;
    ULONG                   mountPointsSize;
    PMOUNTMGR_MOUNT_POINTS  mountPoints;
    BOOLEAN                 freeMountPoints;
    UNICODE_STRING          dosDevices;
    UCHAR                   driveLetter;
    ULONG                   i;
    UNICODE_STRING          subString;
    WCHAR                   c;

    PAGED_CODE();

    partitionStringLength = wcslen( PartitionString ) * sizeof(WCHAR);

    //
    // allocate a MOUNT_POINT structure plus enough space for the
    // device name to follow
    //

    mountPointSize = sizeof( MOUNTMGR_MOUNT_POINT ) + partitionStringLength;

    mountPoint = (PMOUNTMGR_MOUNT_POINT)ExAllocatePool( PagedPool, mountPointSize );
    if (!mountPoint) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( mountPoint, sizeof( MOUNTMGR_MOUNT_POINT ));
    mountPoint->DeviceNameOffset = (USHORT) sizeof(MOUNTMGR_MOUNT_POINT);
    mountPoint->DeviceNameLength = (USHORT) partitionStringLength;
    RtlCopyMemory( mountPoint + 1, PartitionString, partitionStringLength );

    //
    // get a pointer to the mount mgr device object and issue the first
    // query to get the size of the data
    //

    RtlInitUnicodeString( &name, MOUNTMGR_DEVICE_NAME );
    status = IoGetDeviceObjectPointer(&name,
                                      FILE_READ_ATTRIBUTES,
                                      &fileObject,
                                      &deviceObject);

    if (!NT_SUCCESS(status)) {
        ExFreePool(mountPoint);
        return status;
    }

    KeInitializeEvent(&event, NotificationEvent, FALSE);
    irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTMGR_QUERY_POINTS,
                                        deviceObject,
                                        mountPoint,
                                        mountPointSize,
                                        &points,
                                        sizeof(points),
                                        FALSE,
                                        &event,
                                        &ioStatus);

    if (!irp) {
        ObDereferenceObject(fileObject);
        ExFreePool(mountPoint);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    status = IoCallDriver(deviceObject, irp);
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatus.Status;
    }

    //
    // allocate enough space to get all the mount point info
    //

    if (status == STATUS_BUFFER_OVERFLOW) {

        mountPointsSize = points.Size;
        mountPoints = (PMOUNTMGR_MOUNT_POINTS)
                      ExAllocatePool(PagedPool, mountPointsSize);
        if (!mountPoints) {
            ObDereferenceObject(fileObject);
            ExFreePool(mountPoint);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        KeInitializeEvent(&event, NotificationEvent, FALSE);
        irp = IoBuildDeviceIoControlRequest(IOCTL_MOUNTMGR_QUERY_POINTS,
                                            deviceObject,
                                            mountPoint,
                                            mountPointSize,
                                            mountPoints,
                                            mountPointsSize,
                                            FALSE,
                                            &event,
                                            &ioStatus);
        if (!irp) {
            ExFreePool(mountPoints);
            ObDereferenceObject(fileObject);
            ExFreePool(mountPoint);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        status = IoCallDriver(deviceObject, irp);
        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
            status = ioStatus.Status;
        } else if ( !NT_SUCCESS( status )) {
            ClusDiskPrint((1,"[ClusDisk] GetDLFromMM: 2nd IRP failed %08X\n",
                           status));
        }

        freeMountPoints = TRUE;

    } else {
        mountPoints = &points;
        freeMountPoints = FALSE;

        if ( !NT_SUCCESS( status )) {
            ClusDiskPrint((1,"[ClusDisk] GetDLFromMM: 1st IRP failed %08X\n",
                           status));
        }
    }

    ExFreePool(mountPoint);
    ObDereferenceObject(fileObject);

    if (!NT_SUCCESS(status)) {
        if (freeMountPoints) {
            ExFreePool(mountPoints);
        }
        return status;
    }

    //
    // run through the list of mount points, matching the
    // supplied devicename against the mount point symname.
    //

    RtlInitUnicodeString(&dosDevices, L"\\DosDevices\\");

    driveLetter = 0;
    for (i = 0; i < mountPoints->NumberOfMountPoints; i++) {

        if (mountPoints->MountPoints[i].SymbolicLinkNameLength !=
            dosDevices.Length + 2*sizeof(WCHAR)) {

            continue;
        }

        subString.Length = subString.MaximumLength = dosDevices.Length;
        subString.Buffer = (PWSTR) ((PCHAR) mountPoints +
                mountPoints->MountPoints[i].SymbolicLinkNameOffset);

        if (RtlCompareUnicodeString(&dosDevices, &subString, TRUE)) {
            continue;
        }

        c = subString.Buffer[subString.Length/sizeof(WCHAR) + 1];

        if (c != ':') {
            continue;
        }

        c = subString.Buffer[subString.Length/sizeof(WCHAR)];

        if (c < 'C' || c > 'Z') {
            continue;
        }

        driveLetter = (UCHAR) c;
        break;
    }

    if (freeMountPoints) {
        ExFreePool(mountPoints);
    }

    if ( driveLetter != 0 ) {
        *DriveLetter = driveLetter;
        status = STATUS_SUCCESS;
    } else {
        status = STATUS_NOT_FOUND;
    }

    return status;
} // ClusDiskQueryMountLetter


VOID
ClusDiskAssignLetter(
    IN UCHAR DriveLetter,
    IN LPWSTR AssignDevice
    )

/*++

Routine Description:

    For all of the disks signatures that are supposed to be attached, we
    assign their drive letters to the specified device.

Arguments:

    DriveLetter - the driver letter to assign to ClusDisk0.

    AssignDevice - NULL if we are not to assign any device letters,
                   NON-NULL if we are.

Return Value:

    None.

--*/

{
} // ClusDiskAssignLetter


VOID
ClusDiskReleaseDriveLetters(
    VOID
    )

/*++

Routine Description:

    This routine is called only when the driver is being unloaded. This
    routine releases all of the drive letters that were assigned to ClusDisk0.

Arguments:

    None.

Return Value:

    None.

Notes:

    This routine is only called when UnLoading ClusDisk.

    2000/02/05: stevedz - This routine appears to be unnecessary.
    
    This routine should check if the drive letter is already assigned
    to ClusDisk0 before removing the assignment. Furthermore, it should
    probably reassign the letters back to the original drive, but since
    unload is not really supported, we won't worry about it now.

--*/

{
} // ClusDiskReleaseDriveLetters



NTSTATUS
ClusDiskDismount(
    IN ULONG  Signature
    )

/*++

Routine Description:

    Dismount all partitions on a spindle, using the registry to grovel
    for the drive letters.

Arguments:

    Signature - the signature of the device to grovel for.

Return Value:

    STATUS_SUCCESS if successful.

    An NTSTATUS error code on failure.

--*/

{
    NTSTATUS                    status;
    ULONG                       diskNumber;
    ULONG                       partIndex;
    UNICODE_STRING              DeviceName;
    WCHAR                       NameBuffer[sizeof(L"\\Device\\Harddisk999\\Partition999")/sizeof(WCHAR)];
    UCHAR                       driveLetter;
    PCONFIGURATION_INFORMATION  configurationInformation;
    PDRIVE_LAYOUT_INFORMATION   DriveLayoutData;
    PPARTITION_INFORMATION      partitionInfo;

    //
    // Get the system configuration information and take a
    // peek at each disk
    //

    configurationInformation = IoGetConfigurationInformation();
    for (diskNumber = 0;
         diskNumber < configurationInformation->DiskCount;
         diskNumber++)
    {

        //
        // get the device name for the physical disk and its
        // partition information
        //
        status = ClusDiskGetTargetDevice(diskNumber,
                                         0,
                                         NULL,
                                         &DeviceName,
                                         &DriveLayoutData,
                                         NULL,
                                         FALSE);

        if ( !NT_SUCCESS(status) ) {
            ClusDiskPrint((1, "[Clusdisk] Dismount: Can't get target device info - %08X\n",
                           status));
            continue;
        }

        if ( DriveLayoutData == NULL ) {
            ClusDiskPrint((1, "[Clusdisk] Dismount: Can't get partition info for disk %u\n",
                           diskNumber));

            RtlFreeUnicodeString(&DeviceName);
            continue;
        }

        //
        // Skip till we find our device!
        //
        if ( DriveLayoutData->Signature == Signature ) {

            for ( partIndex = 0;
                  partIndex < DriveLayoutData->PartitionCount;
                  partIndex++ )
            {

                partitionInfo = &DriveLayoutData->PartitionEntry[partIndex];

                //
                // Make sure this is a valid partition, i.e., it's recognized by
                // a FS and it has a non-zero starting offset and length
                //
                if (!partitionInfo->RecognizedPartition &&
                    !partitionInfo->StartingOffset.QuadPart &&
                    !partitionInfo->PartitionLength.QuadPart)
                {
                    continue;
                }

                swprintf(NameBuffer,
                         L"\\Device\\Harddisk%u\\Partition%u",
                         diskNumber,
                         partitionInfo->PartitionNumber);

                RtlInitUnicodeString(&DeviceName, NameBuffer);

                status = GetDriveLetterFromMountMgr( NameBuffer, &driveLetter );

                if (NT_SUCCESS(status) && IsAlpha(driveLetter) ) {
                    status = DismountPartitionDevice( driveLetter );
                } else {
                    ClusDiskPrint((1,
                                   "[ClusDisk] Dismount: couldn't dismount drive. "
                                   "status %08X driveLetter %c (%02X)\n",
                                   status, driveLetter, driveLetter));
                }
            }
            break;
        }

        ExFreePool( DriveLayoutData );
        RtlFreeUnicodeString( &DeviceName );
    }

    return(STATUS_SUCCESS);
} // ClusDiskDismount
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusdisk\makefile.inc ===
RunWpp:
	wpp01 trace.wpp clusdisk.c ezwrite.c

cldskwmi.c: cdwpp.h

clusdisk.rc: cdwpp.mof

clean:
	del cdwpp.mof cdwpp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusdisk\ezwrite.c ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    ezwrite.c

Abstract:

    Arbitration Support routines for clusdisk.c 

Authors:

    Gor Nishanov     11-June-1998

Revision History:

--*/

#include "clusdskp.h"
#include "diskarbp.h"

#if !defined(WMI_TRACING)

#define CDLOG0(Dummy)
#define CDLOG(Dummy1,Dummy2)
#define CDLOGFLG(Dummy0,Dummy1,Dummy2)
#define LOGENABLED(Dummy) FALSE

#else

#include "ezwrite.tmh"

#endif // !defined(WMI_TRACING)

#define ARBITRATION_BUFFER_SIZE PAGE_SIZE

PARBITRATION_ID  gArbitrationBuffer = 0;

NTSTATUS
ArbitrationInitialize(
    VOID
    )
{
    gArbitrationBuffer = ExAllocatePool(NonPagedPool, ARBITRATION_BUFFER_SIZE);
    if( gArbitrationBuffer == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(gArbitrationBuffer, ARBITRATION_BUFFER_SIZE);
    KeQuerySystemTime( &gArbitrationBuffer->SystemTime );
    gArbitrationBuffer->SeqNo.QuadPart = 2; // UserMode arbitration uses 0 and 1 //

    return STATUS_SUCCESS;
}

VOID
ArbitrationDone(
    VOID
    )
{
    if(gArbitrationBuffer != 0) {
        ExFreePool(gArbitrationBuffer);
        gArbitrationBuffer = 0;
    }
}

VOID
ArbitrationTick(
    VOID
    )
{
//   InterlockedIncrement(&gArbitrationBuffer->SeqNo.LowPart);
    ++gArbitrationBuffer->SeqNo.QuadPart;
}

BOOLEAN
ValidSectorSize(
    IN ULONG SectorSize)
{
    // too big //
    if (SectorSize > ARBITRATION_BUFFER_SIZE) {
        return FALSE;
    }

    // too small //
    if (SectorSize < sizeof(ARBITRATION_ID)) {
        return FALSE;
    }

    // not a power of two //
    if (SectorSize & (SectorSize - 1) ) {
        return FALSE;
    }

    return TRUE;
}

NTSTATUS
VerifyArbitrationArgumentsIfAny(
    IN PULONG                 InputData,
    IN LONG                   InputSize
    )
/*++

Routine Description:

    Process Parameters Passed to IOCTL_DISK_CLUSTER_START_RESERVE.

Arguments:

    DeviceExtension - The target device extension
    InputData       - InputData array from Irp
    InputSize       - its size

Return Value:

    NTSTATUS
    
Notes:    
    
--*/
{
    PSTART_RESERVE_DATA params = (PSTART_RESERVE_DATA)InputData;

    // Old style StartReserve //
    if( InputSize == sizeof(ULONG) ) {
       return STATUS_SUCCESS;
    }

    // We have less arguments than we need //
    if( InputSize < sizeof(START_RESERVE_DATA) ) {
       return STATUS_INVALID_PARAMETER;
    }
    // Wrong Version //
    if(params->Version != START_RESERVE_DATA_V1_SIG) {
       return STATUS_INVALID_PARAMETER;
    }
    // Signature size is invalid //
    if (params->NodeSignatureSize > sizeof(params->NodeSignature)) {
       return STATUS_INVALID_PARAMETER;
    }
    
    if( !ValidSectorSize(params->SectorSize) ) {
       return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;
}
    
VOID
ProcessArbitrationArgumentsIfAny(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension,
    IN PULONG                 InputData,
    IN LONG                   InputSize
    )
/*++

Routine Description:

    Process Parameters Passed to IOCTL_DISK_CLUSTER_START_RESERVE.

Arguments:

    DeviceExtension - The target device extension
    InputData       - InputData array from Irp
    InputSize       - its size

Return Value:

    NTSTATUS
    
Notes:    

    Assumes that parameters are valid.
    Use VerifyArbitrationArgumentsIfAny to verify parameters
    
--*/
{
    PSTART_RESERVE_DATA params = (PSTART_RESERVE_DATA)InputData;

    DeviceExtension->SectorSize = 0; // Invalidate Sector Size //

    // old style StartReserve //
    if( InputSize == sizeof(ULONG) ) {
       return;
    }

    RtlCopyMemory(gArbitrationBuffer->NodeSignature, 
                  params->NodeSignature, params->NodeSignatureSize);

    DeviceExtension->ArbitrationSector = params->ArbitrationSector;
    DeviceExtension->SectorSize        = params->SectorSize;
}

NTSTATUS
DoUncheckedReadWrite(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension,
    IN PARBITRATION_READ_WRITE_PARAMS params
) 
/*++

Routine Description:

    Prepares read/write IRP and execute its synchronously

Arguments:

    DeviceExtension - The target device extension
    params          - Describes offset, operation, buffer, etc
                      This structure is defined in cluster\inc\diskarbp.h

Return Value:

    NTSTATUS
    
--*/
{
   PIRP                        irp;
   NTSTATUS                    status;
   PKEVENT                     event;
   KIRQL                       irql;
   PCLUS_DEVICE_EXTENSION      rootDeviceExtension;
   IO_STATUS_BLOCK             ioStatusBlock;
   ULONG                       sectorSize = DeviceExtension->SectorSize;
   LARGE_INTEGER               offset;
   ULONG                       function = (params->Operation == AE_READ)?IRP_MJ_READ:IRP_MJ_WRITE;
   ULONG                       retryCount = 1;

     event = ExAllocatePool( NonPagedPool,
                             sizeof(KEVENT) );
     if ( !event ) {
         return(STATUS_INSUFFICIENT_RESOURCES);
     }

retry:

   KeInitializeEvent(event,
                     NotificationEvent,
                     FALSE);

   offset.QuadPart = (ULONGLONG) (params->SectorSize * params->SectorNo);
   
   irp = IoBuildSynchronousFsdRequest(function,
                                      DeviceExtension->TargetDeviceObject,
                                      params->Buffer,
                                      params->SectorSize,
                                      &offset,
                                      event,
                                      &ioStatusBlock);

   if ( irp == NULL ) {
       ExFreePool( event );
       return(STATUS_INSUFFICIENT_RESOURCES);
   }

   status = IoCallDriver(DeviceExtension->TargetDeviceObject,
                         irp);

   if (status == STATUS_PENDING) {
       KeWaitForSingleObject(event,
                             Suspended,
                             KernelMode,
                             FALSE,
                             NULL);
       status = ioStatusBlock.Status;
   }

   if ( !NT_SUCCESS(status) ) {
       if ( retryCount-- &&
            (status == STATUS_IO_DEVICE_ERROR) ) {
           goto retry;
       }
       ClusDiskPrint((
                   1,
                   "[ClusDisk] Failed read/write for Signature %08X, status %lx.\n",
                   DeviceExtension->Signature,
                   status
                   ));
   }

   ExFreePool(event);

   return(status);

} // DoUncheckedReadWrite //

NTSTATUS
WriteToArbitrationSector(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension
    )

/*++

Routine Description:

    Writes to an Arbitration Sector.

Arguments:

    DeviceExtension - The device extension for the device to reserve.

Return Value:

    NTSTATUS

--*/

{
    ARBITRATION_READ_WRITE_PARAMS params;
    ULONG sectorSize = DeviceExtension->SectorSize;

    if (0 == gArbitrationBuffer || 0 == DeviceExtension->SectorSize) {
       return STATUS_SUCCESS;
    }
    params.Operation         = AE_WRITE;
    params.SectorSize        = DeviceExtension->SectorSize;
    params.Buffer            = gArbitrationBuffer;
    params.SectorNo          = DeviceExtension->ArbitrationSector;

    return( DoUncheckedReadWrite(DeviceExtension, &params) );

} // WriteToArbitrationSector //


VOID
ArbitrationReserve(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension
    )
{
   NTSTATUS status;
   status = WriteToArbitrationSector( DeviceExtension );
   if ( !NT_SUCCESS(status) ) {
      
      CDLOGF(RESERVE,"ArbitrationReserve(%p) => %!status!", 
              DeviceExtension->DeviceObject, 
              status );
                
      ClusDiskPrint((
                  1,
                  "[ClusDisk] Failed to write to arbitration sector on Signature %08X\n",
                  DeviceExtension->Signature));
   }
}

NTSTATUS
SimpleDeviceIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG          Ioctl,
    IN PVOID          InBuffer,
    IN ULONG          InBufferSize,
    IN PVOID          OutBuffer,
    IN ULONG          OutBufferSize)
{
    NTSTATUS                status;
    IO_STATUS_BLOCK         ioStatusBlock;

    PKEVENT                 event = 0;
    PIRP                    irp   = 0;

    CDLOG( "SimpleDeviceIoControl(%p): Entry Ioctl %x", DeviceObject, Ioctl );

    event = ExAllocatePool( NonPagedPool, sizeof(KEVENT) );
    if ( event == NULL ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        ClusDiskPrint((
                1,
                "[ClusDisk] SimpleDeviceIoControl: Failed to allocate event\n" ));
        goto exit_gracefully;
    }

    irp = IoBuildDeviceIoControlRequest(
              Ioctl,
              DeviceObject,
              InBuffer, InBufferSize,
              OutBuffer, OutBufferSize,
              FALSE,
              event,
              &ioStatusBlock);
    if ( !irp ) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        ClusDiskPrint((
            1,
            "[ClusDisk] SimpleDeviceIoControl. Failed to build IRP %x.\n",
            Ioctl
            ));
        goto exit_gracefully;
    }

    //
    // Set the event object to the unsignaled state.
    // It will be used to signal request completion.
    //

    KeInitializeEvent(event, NotificationEvent, FALSE);
    
    status = IoCallDriver(DeviceObject, irp);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(event,
                              Suspended,
                              KernelMode,
                              FALSE,
                              NULL);

        status = ioStatusBlock.Status;
    }

exit_gracefully:

    if ( event ) {
        ExFreePool( event );
    }    
    
    CDLOG( "SimpleDeviceIoControl(%p): Exit Ioctl %x => %!status!", 
           DeviceObject, Ioctl, status );

    return status;

} // SimpleDeviceIoControl



/*++

Routine Description:

    Arbitration support routine. Currently provides ability to read/write
    physical sectors on the disk while the device is offline

Arguments:

    SectorSize:  requred sector size
                    (Assumes that the SectorSize is a power of two)

Return Value:

    STATUS_INVALID_PARAMETER
    STATUS_SUCCESS

Notes:

--*/
NTSTATUS 
ProcessArbitrationEscape(
    IN PCLUS_DEVICE_EXTENSION DeviceExtension,
    IN PULONG                 InputData,
    IN LONG                   InputSize,
    IN PULONG                 OutputSize
    )
{
    NTSTATUS status = STATUS_INVALID_PARAMETER;
    PARBITRATION_READ_WRITE_PARAMS params;

    if( InputData[0] != AE_SECTORSIZE ) {
        *OutputSize = 0;
    }

    switch(InputData[0]) {
   
    // Users can query whether ARBITRATION_ESCAPE is present by calling //
    // AE_TEST subfunction                                              //

    case AE_TEST: 
        status = STATUS_SUCCESS;
        break;

    case AE_WRITE:
    case AE_READ:
        if(InputSize < ARBITRATION_READ_WRITE_PARAMS_SIZE) {
            break;
        }
        params = (PARBITRATION_READ_WRITE_PARAMS)InputData;
        if ( !ValidSectorSize(params->SectorSize) ) {
            break;
        }
        try {
            ProbeForWrite( params->Buffer, params->SectorSize, sizeof( UCHAR ) );
            ProbeForRead ( params->Buffer, params->SectorSize, sizeof( UCHAR ) );
            status = DoUncheckedReadWrite(DeviceExtension, params);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return GetExceptionCode();
        }
        break;
        
    case AE_POKE:
        {
            PARTITION_INFORMATION partInfo;
            
            status = SimpleDeviceIoControl( 
                        DeviceExtension->TargetDeviceObject,
                        IOCTL_DISK_GET_PARTITION_INFO,
                        NULL, 0,
                        &partInfo, sizeof(PARTITION_INFORMATION) );
            break;
        }
    case AE_RESET:
        {
            STORAGE_BUS_RESET_REQUEST storageReset;
            storageReset.PathId = DeviceExtension->ScsiAddress.PathId;
            
            status = SimpleDeviceIoControl( 
                        DeviceExtension->TargetDeviceObject,
                        IOCTL_STORAGE_BREAK_RESERVATION,
                        &storageReset, sizeof(storageReset),
                        NULL, 0 );
            break;
        }
    case AE_RESERVE:
        {
            status = SimpleDeviceIoControl( 
                        DeviceExtension->TargetDeviceObject,
                        IOCTL_STORAGE_RESERVE,
                        NULL, 0, NULL, 0 );
            break;
        }            
    case AE_RELEASE:
        {
            status = SimpleDeviceIoControl( 
                        DeviceExtension->TargetDeviceObject,
                        IOCTL_STORAGE_RELEASE,
                        NULL, 0, NULL, 0 );
            break;
        }            
    case AE_SECTORSIZE:
        {
            DISK_GEOMETRY diskGeometry;
            if (*OutputSize < sizeof(ULONG)) {
                status =  STATUS_BUFFER_TOO_SMALL;
                *OutputSize = 0;
                break;
            }
            status = SimpleDeviceIoControl( 
                        DeviceExtension->TargetDeviceObject,
                        IOCTL_DISK_GET_DRIVE_GEOMETRY,
                        NULL, 0,
                        &diskGeometry, sizeof(diskGeometry) );
                        
            if ( NT_SUCCESS(status) ) {
                *InputData = diskGeometry.BytesPerSector;
                *OutputSize = sizeof(ULONG);
            } else {
                *OutputSize = 0;
            }
            break;
        }
    }
    return(status);
} // ProcessArbitrationEscape //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusdisk\object.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    object.c

Abstract:

    Resource DLL for disks.

Author:

    Rod Gamache (rodga) 18-Dec-1995

Revision History:

--*/

#include "ntos.h"
#include "zwapi.h"
#include "windef.h"
#include "stdio.h"
#include "stdlib.h"
#include "clusdskp.h"

extern POBJECT_TYPE IoDeviceObjectType;

#if 0
#define ATTR_DIR        0x00000001
#define ATTR_DEVICE     0x00000002
#define ATTR_FILE       0x00000004
#define ATTR_SYMLINK    0x00000008

#define DIRECTORYTYPE   L"Directory"
#define DEVICETYPE      L"Device"
#define FILETYPE        L"File"
#define SYMLINKTYPE     L"SymbolicLink"
#endif


#ifdef ALLOC_PRAGMA

//#pragma alloc_text(INIT, GetSymbolicLink)

#endif // ALLOC_PRAGMA


/* Converts the type-name into an attribute value */

#if 0
LONG
CalcAttributes(
    PUNICODE_STRING Type
    )
{
    UNICODE_STRING  TypeName;

    RtlInitUnicodeString(&TypeName, DIRECTORYTYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_DIR;
    }
    RtlInitUnicodeString(&TypeName, DEVICETYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_DEVICE;
    }
    RtlInitUnicodeString(&TypeName, FILETYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_FILE;
    }
    RtlInitUnicodeString(&TypeName, SYMLINKTYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_SYMLINK;
    }
    return(0);

} // CalcAttributes
#endif


VOID
GetSymbolicLink(
    IN PWCHAR RootName,
    IN OUT PWCHAR ObjectName   // Assume this points at a MAX_PATH len buffer
    )
{
    NTSTATUS    Status;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    HANDLE      LinkHandle;
    WCHAR       UnicodeBuffer[MAX_PATH];
    WCHAR       Buffer[MAX_PATH];
    UNICODE_STRING UnicodeString;
    ULONG       rootLen;
    ULONG       objLen;

    rootLen = wcslen(RootName);
    objLen = wcslen(ObjectName);
    
    if ( (rootLen + objLen + 1) > ( sizeof(UnicodeBuffer)/sizeof(WCHAR) ) ) {
        *ObjectName = '\0';
        return;
    }
    
    RtlZeroMemory( Buffer, sizeof(Buffer) );
    wcsncpy( Buffer, RootName, rootLen );
    wcsncat( Buffer, ObjectName, objLen );

    //
    // Make the output buffer empty in case we fail.
    //
    *ObjectName = '\0';


    RtlInitUnicodeString(&UnicodeString, Buffer);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );

    // Open the given symbolic link object
    Status = ZwOpenSymbolicLinkObject(&LinkHandle,
                                      GENERIC_READ,
                                      &ObjectAttributes);
    if (!NT_SUCCESS(Status)) {
        ClusDiskPrint((1,
                       "[ClusDisk] GetSymbolicLink: ZwOpenSymbolicLink "
                       "failed, status = %08X., Name = [%ws]\n",
                       Status, UnicodeString.Buffer));
        return;
    }

    // Go get the target of the symbolic link

    UnicodeString.Length = 0;
    UnicodeString.Buffer = ObjectName;
    UnicodeString.MaximumLength = (USHORT)(MAX_PATH);

    Status = ZwQuerySymbolicLinkObject(LinkHandle, &UnicodeString, NULL);

    ZwClose(LinkHandle);

    if (!NT_SUCCESS(Status)) {
        ClusDiskPrint((1,
                       "[ClusDisk] GetSymbolicLink: ZwQuerySymbolicLink failed, status = %08X.\n",
                       Status));
        return;
    }

    // Add NULL terminator
    UnicodeString.Buffer[UnicodeString.Length/sizeof(WCHAR)] = '\0';

    return;

} // GetSymbolicLink


static WCHAR wszDosDevices[] = L"\\DosDevices\\A:";


NTSTATUS
GetDriveLetterFromObjectDir(
    IN LPWSTR InputDeviceName,
    OUT PUCHAR Letter
    )
{
    UNICODE_STRING LinkName;
    UNICODE_STRING DeviceName;
    UNICODE_STRING UniDeviceName;
    OBJECT_ATTRIBUTES Obja;
    HANDLE LinkHandle;
    NTSTATUS Status;
    ULONG i;
    PWCHAR p;
    WCHAR DeviceNameBuffer[MAXIMUM_FILENAME_LENGTH];

    RtlInitUnicodeString( &UniDeviceName, InputDeviceName );
    RtlInitUnicodeString(&LinkName,wszDosDevices);

    p = (PWCHAR)LinkName.Buffer;
    p = p+12;
    for ( i=0; i<26; i++ ) {
        *p = (WCHAR)'A' + (WCHAR)i;

        InitializeObjectAttributes(
            &Obja,
            &LinkName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );
        Status = ZwOpenSymbolicLinkObject(
                    &LinkHandle,
                    SYMBOLIC_LINK_QUERY,
                    &Obja
                    );
        if (NT_SUCCESS( Status )) {

            //
            // Open succeeded, Now get the link value
            //

            DeviceName.Length = 0;
            DeviceName.MaximumLength = sizeof(DeviceNameBuffer);
            DeviceName.Buffer = DeviceNameBuffer;

            Status = ZwQuerySymbolicLinkObject(
                        LinkHandle,
                        &DeviceName,
                        NULL
                        );
            ZwClose(LinkHandle);
            if ( NT_SUCCESS(Status) ) {
                if ( RtlEqualUnicodeString(&UniDeviceName,&DeviceName,TRUE) ) {
                    *Letter = (UCHAR)('A' + i);
                    return(STATUS_SUCCESS);
                }
            }
        }
    }

    return(STATUS_NO_SUCH_FILE);

} // GetDriveLetterFromObjectDir


#if 0

PDEVICE_OBJECT
GetDeviceObject(
    IN LPWSTR   lpwstrDirectory,
    IN LPWSTR   lpwstrObject,
    IN LPWSTR   lpwstrType
    )
/*++

Routine Description:

    Find the device object given the directory, name and type.

Arguments:

    Directory - the directory name for the object.

    Object - the object name.

    Type - the object type.

Return Value:

    non-zero pointer to the device object

    NULL on failure


--*/

{
#define BUFFER_SIZE 2048

    NTSTATUS    Status;
    HANDLE      DirectoryHandle;
    HANDLE      ObjectHandle = NULL;
    ULONG       Context = 0;
    ULONG       ReturnedLength;
    CHAR        Buffer[BUFFER_SIZE];
    UNICODE_STRING ObjectName;
    UNICODE_STRING ObjectType;
    UNICODE_STRING DirectoryName;
    OBJECT_ATTRIBUTES Attributes;
    IO_STATUS_BLOCK IoStatusBlock;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    BOOL        NotFound;

    UNICODE_STRING TypeName;

    //
    // Initialize strings
    //
    RtlInitUnicodeString( &ObjectType, lpwstrType );

    RtlInitUnicodeString( &ObjectName, lpwstrObject );

    RtlInitUnicodeString( &DirectoryName, lpwstrDirectory );

    InitializeObjectAttributes( &Attributes,
                                &DirectoryName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    if (!NT_SUCCESS( Status = ZwOpenDirectoryObject( &DirectoryHandle,
                                                      STANDARD_RIGHTS_READ |
                                                      DIRECTORY_QUERY |
                                                      DIRECTORY_TRAVERSE,
                                                     &Attributes ) )) {

        if (Status == STATUS_OBJECT_TYPE_MISMATCH) {
            ClusDiskPrint((
                    1,
                    "ClusDisk: OpenObject, <%wZ> is not a valid Object Directory Object name\n",
                    &DirectoryName ));
        } else {
            ClusDiskPrint((
                    1,
                    "ClusDisk: OpenObject, failed to open directory, status = 0x%lx\n\r", Status ));
        }
        return NULL;
    }

    //
    //  Query the entire directory in one sweep
    //
    NotFound = TRUE;

    for (Status = ZwQueryDirectoryObject( DirectoryHandle,
                                          Buffer,
                                          sizeof(Buffer),
                                          // LATER FALSE,
                                          TRUE, // one entry at a time for now
                                          TRUE,
                                          &Context,
                                          &ReturnedLength );

        NotFound;
        Status = ZwQueryDirectoryObject( DirectoryHandle,
                                         Buffer,
                                         sizeof(Buffer),
                                         // LATER FALSE,
                                         TRUE, // one entry at a time for now
                                         FALSE,
                                         &Context,
                                         &ReturnedLength ) ) {
        //
        //  Check the status of the operation.
        //
        if ( !NT_SUCCESS(Status) ) {
            break;
        }

        //
        // For every record in the buffer get the symbolic link and
        // compare the name of the symbolic link with the one we're
        // looking for.
        //

        //
        //  Point to the first record in the buffer, we are guaranteed to have
        //  one otherwise Status would have been No More Files
        //

        DirInfo = (POBJECT_DIRECTORY_INFORMATION)Buffer;

        while ( DirInfo->Name.Length != 0 ) {

            ClusDiskPrint((
                    1,
                    "ClusDisk: Found object <%wZ>, Type <%wZ>\n",
                    &(DirInfo->Name),
                    &(DirInfo->TypeName) ));

            if (RtlEqualUnicodeString(&ObjectName, &DirInfo->Name, TRUE) &&
                RtlEqualUnicodeString(&ObjectType, &DirInfo->TypeName, TRUE)) {
                NotFound = FALSE;
                break;
            }
            
            DirInfo++;
        } // while
    } // for

    ZwClose(DirectoryHandle);
    if ( NotFound ) {
        return(NULL);
    }

    InitializeObjectAttributes( &Attributes,
                                &ObjectName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    Status = ZwOpenSymbolicLinkObject( &ObjectHandle,
                                       SYMBOLIC_LINK_ALL_ACCESS,
                                       &Attributes );

    return(NULL);

#if 0
    // We now have the type of the object in ObjectType
    // We still have the full object name in lpstrObject
    // Use the appropriate open routine to get a handle

    sprintf( Buffer, "\\\\.\\%s", AnsiString.Buffer );

    RtlInitAnsiString( &AnsiString, Buffer );

    Status = RtlAnsiStringToUnicodeString(&ObjectName, &AnsiString, FALSE);
    ASSERT(NT_SUCCESS(Status));

    InitializeObjectAttributes( &Attributes,
                                &ObjectName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    Status = ZwOpenSymbolicLinkObject( &ObjectHandle,
                                       SYMBOLIC_LINK_ALL_ACCESS,
                                       &Attributes );
#if 0
    Status = ZwOpenFile( &ObjectHandle,
                         FILE_READ_ATTRIBUTES,
                         &Attributes,
                         &IoStatusBlock,
                         0,
                         FILE_NON_DIRECTORY_FILE );                     
#endif
    if ( !NT_SUCCESS(Status) ) {
        ClusDiskPrint((
                1,
                "ClusDisk: OpenObject, open file failed, status %lx.\n",
                Status ));
        return(NULL);
    }
#endif

    return(ObjectHandle);

} // GetDeviceObject
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusdisk\kdcd\precomp.h ===
#if DBG
#define DEBUG 1
#endif

#define NT 1
#define _PNP_POWER  1
#define SECFLTR 1

#include <ntverp.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
// Prevent hal.h, included in ntos.h from overriding _BUS_DATA_TYPE
// enum found in ntioapi.h, included from nt.h.
//
#define _HAL_
#include <ntos.h>

#include <windows.h>
#include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h>

//#define _NTIFS_
#undef Ioctl
#include "clusdskp.h"
#include "clusdisk.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusdisk\test\disksp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    disksp.h

Abstract:

    Disks Resource DLL private definitions.

Author:

    Rod Gamache (rodga) 29-Mar-1996

Revision History:

--*/


#define MAX_PARTITIONS  128

//
// The following structure in inserted into a table (based on disk number).
// The letters are indexed by order of their partitions in the registry.
//

typedef struct _DISK_INFO {
    DWORD   PhysicalDrive;
    HANDLE  FileHandle;
    UCHAR   Letters[MAX_PARTITIONS];
} DISK_INFO, *PDISK_INFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusdisk\kdcd\kdcd.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kdcd.c

Abstract:

    Cluster Disk driver KD extension - based on Vert's skeleton

Author:

    John Vert (jvert) 6-Aug-1992

Revision History:

--*/

#include "precomp.h"

PCHAR DiskStateTitles[] = {
    "Offline",
    "Online",
    " *** Failed *** ",
    " *** Stalled *** "
};

PCHAR BusTypeTitles[] = {
    "Root",
    "SCSI",
    "Unknown"
};

#define IRP_LIST_MAX    20

//
// globals
//

EXT_API_VERSION        ApiVersion = { 5, 0, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;

#define TrueOrFalse( _x )  ( _x ? "True" : "False" )

/* forwards */

BOOL
ReadTargetMemory(
    PVOID TargetAddress,
    PVOID LocalBuffer,
    ULONG BytesToRead
    );

__inline PCHAR
ListInUse(
    PLIST_ENTRY,
    PLIST_ENTRY
    );

__inline PCHAR
TrueFalse(
    BOOLEAN Value
    );

/* end forwards */

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

DECLARE_API( cdversion )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf("%s Extension dll for Build %d debugging %s kernel for Build %d\n",
            DebuggerType,
            VER_PRODUCTBUILD,
            SavedMajorVersion == 0x0c ? "Checked" : "Free",
            SavedMinorVersion
            );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}


VOID
Dump_DrvObj(
    IN PDRIVER_OBJECT DriverObject
    )
/*
 *   dump all the devobjs and devexts
 */
{
    PCLUS_DEVICE_EXTENSION DevExtension;
    PDEVICE_OBJECT DeviceObject;
    PDEVICE_OBJECT TargetDevObject;
    DRIVER_OBJECT LocalDriverObject;
    DEVICE_OBJECT LocalDeviceObject;
    CLUS_DEVICE_EXTENSION LocalDevExtension;

    //
    // read memory from target machine
    //

    if ( !ReadTargetMemory((PVOID)DriverObject,
                           (PVOID)&LocalDriverObject,
                           sizeof(DRIVER_OBJECT))) {
        return;
    }

    dprintf( "DriverObject @ %08X\n", DriverObject );

    DeviceObject = LocalDriverObject.DeviceObject;

    while ( DeviceObject ) {
        if ( !ReadTargetMemory((PVOID)DeviceObject,
                               (PVOID)&LocalDeviceObject,
                               sizeof(DEVICE_OBJECT))) {
            return;
        }

        TargetDevObject = NULL;
        DevExtension = LocalDeviceObject.DeviceExtension;

        if ( DevExtension ) {
            if ( !ReadTargetMemory((PVOID)DevExtension,
                                   (PVOID)&LocalDevExtension,
                                   sizeof(CLUS_DEVICE_EXTENSION))) {
                return;
            }
            TargetDevObject = LocalDevExtension.TargetDeviceObject;
        }

        dprintf( "    DevObj/DevExt/TargetDev: %08X, %08X, %08X\n",
                 DeviceObject,
                 DevExtension,
                 TargetDevObject );
        DeviceObject = LocalDeviceObject.NextDevice;
                 
    } // while

    return;

} // Dump_DrvObj


DECLARE_API( cddrvobj )
/*
 *   dump all the devobjs and devexts
 */
{
    PDRIVER_OBJECT DriverObject;
    PCLUS_DEVICE_EXTENSION DevExtension;
    PDEVICE_OBJECT DeviceObject;
    PDEVICE_OBJECT TargetDevObject;
    DRIVER_OBJECT LocalDriverObject;
    DEVICE_OBJECT LocalDeviceObject;
    CLUS_DEVICE_EXTENSION LocalDevExtension;

    DriverObject = (PDRIVER_OBJECT)GetExpression( args );

    if ( !DriverObject ) {

        dprintf("bad string conversion (%s) \n", args );
        dprintf("try !object \\device\\clusdisk0 \n");
        return;
    }

    Dump_DrvObj( DriverObject );

    return;

} // drvobj


VOID
Dump_DevExt(
    IN  PCLUS_DEVICE_EXTENSION TargetExt
    )
/*
 *   dump the clusdisk extension structure
 */
{
    CLUS_DEVICE_EXTENSION LocalExt;
    BOOL success;
    LONG BytesRead;
    WCHAR LocalDeviceName[512];

    //
    // read memory from target machine
    //

    if ( !ReadTargetMemory((PVOID)TargetExt,
                           (PVOID)&LocalExt,
                           sizeof(CLUS_DEVICE_EXTENSION))) {
        return;
    }

    dprintf( "    Extension                @ %08X\n", TargetExt );
    dprintf( "    This extension's DevObj  = %08X\n", LocalExt.DeviceObject );
    dprintf( "    Target DevObj            = %08X\n", LocalExt.TargetDeviceObject );
    dprintf( "    Physical (Part0) DevObj  = %08X", LocalExt.PhysicalDevice );
    
    if ( LocalExt.DeviceObject == LocalExt.PhysicalDevice ) {
        dprintf( " [ This device is the physical device ] \n" );
    } else {
        dprintf( " \n" );
    }
    
    dprintf( "    Scsi Address             = Port %u Path %u Target %u Lun %u\n",
             LocalExt.ScsiAddress.PortNumber,
             LocalExt.ScsiAddress.PathId,
             LocalExt.ScsiAddress.TargetId,
             LocalExt.ScsiAddress.Lun);

    dprintf( "    Signature                = %08X\n", LocalExt.Signature );
    dprintf( "    Disk number              = %08X (%u)\n", LocalExt.DiskNumber, LocalExt.DiskNumber );

    dprintf( "    Disk State               = %s  **** \n", ( LocalExt.DiskState <= DiskStateMaximum ?
                                        DiskStateTitles[LocalExt.DiskState] :
                                        "Out of Range"));

    dprintf( "    Reservation Timer        = %08X\n", LocalExt.ReserveTimer );
    dprintf( "    Last reserve time        = %I64X\n", LocalExt.LastReserve );
    dprintf( "    Event                    @ %08X\n", &TargetExt->Event );
    dprintf( "    Cluster Bus Type         = %s\n", (LocalExt.BusType <= UnknownBus ?
                                        BusTypeTitles[LocalExt.BusType] :
                                        "Out of Range"));

    dprintf( "    Last Reserve Status      = %08X\n", LocalExt.ReserveFailure );
    dprintf( "    HoldIO                   @ %08X \n", &TargetExt->HoldIO );
    dprintf( "        %s\n", 
             ListInUse( &LocalExt.HoldIO, (PLIST_ENTRY)&TargetExt->HoldIO ));
    dprintf( "    WaitingIoctls            @ %08X\n", &TargetExt->WaitingIoctls );
    dprintf( "        %s\n", 
             ListInUse( &LocalExt.WaitingIoctls, (PLIST_ENTRY)&TargetExt->WaitingIoctls ));

    dprintf( "    WorkItem                 @ %08X\n", &TargetExt->WorkItem );

    dprintf( "    Perform Reserves         = %s\n", TrueOrFalse( LocalExt.PerformReserves ));
    dprintf( "    Timer Busy               = %s\n", TrueOrFalse( LocalExt.TimerBusy ));

    dprintf( "    AttachValid              = %s\n", TrueOrFalse( LocalExt.AttachValid ));
    dprintf( "    Detached                 = %s\n", TrueOrFalse( LocalExt.Detached ));

    dprintf( "    Driver Object            = %08X\n", LocalExt.DriverObject );

    dprintf( "    Last Partition Number    = %u\n", LocalExt.LastPartitionNumber );
    dprintf( "    Disk Notification Entry  = %08X\n", LocalExt.DiskNotificationEntry );
    dprintf( "    Vol  Notification Entry  = %08X\n", LocalExt.VolumeNotificationEntry );

    dprintf( "    Sector Size              = %u\n", LocalExt.SectorSize );
    dprintf( "    Arbitration Sector       = %u\n", LocalExt.ArbitrationSector );

    dprintf( "    Last Write Time (approx) = %I64X \n", LocalExt.LastWriteTime );
    dprintf( "    VolumeHandles            @ %08X \n", &TargetExt->VolumeHandles );
    
    dprintf( "    RemoveLock               @ %08X  [use !remlock] \n",  &TargetExt->RemoveLock );
    
#if 0
    if ( ReadTargetMemory((PVOID)LocalExt.DeviceName,
                          (PVOID)&LocalDeviceName,
                          sizeof(LocalDeviceName))) {

        dprintf( "    DeviceName = %ws\n", LocalDeviceName );
    } else {
        dprintf( "    DeviceName @ %08X\n", LocalExt.DeviceName );
    }
#endif

    dprintf( "    Paging event             @ %08X \n", &TargetExt->PagingPathCountEvent );
    dprintf( "    Paging path count        = %08X \n", LocalExt.PagingPathCount );
    dprintf( "    Hibernation path count   = %08X \n", LocalExt.HibernationPathCount );
    dprintf( "    Dump path count          = %08X \n", LocalExt.DumpPathCount );

    dprintf( "    ReclaimInProgress        = %08X \n", LocalExt.ReclaimInProgress );

    dprintf(" \n");

    return;
}

VOID
Dump_All(
    IN PDRIVER_OBJECT DriverObject
    )
/*
 *   dump all the devobjs and devexts fully
 */
{
    PCLUS_DEVICE_EXTENSION DevExtension;
    PDEVICE_OBJECT DeviceObject;
    PDEVICE_OBJECT TargetDevObject;
    DRIVER_OBJECT LocalDriverObject;
    DEVICE_OBJECT LocalDeviceObject;
    CLUS_DEVICE_EXTENSION LocalDevExtension;

    //
    // read memory from target machine
    //

    if ( !ReadTargetMemory((PVOID)DriverObject,
                           (PVOID)&LocalDriverObject,
                           sizeof(DRIVER_OBJECT))) {
        return;
    }

    dprintf( "DriverObject                 @ %08X\n\n", DriverObject );

    DeviceObject = LocalDriverObject.DeviceObject;

    while ( DeviceObject ) {
        if ( !ReadTargetMemory((PVOID)DeviceObject,
                               (PVOID)&LocalDeviceObject,
                               sizeof(DEVICE_OBJECT))) {
            return;
        }

        TargetDevObject = NULL;
        DevExtension = LocalDeviceObject.DeviceExtension;

        if ( DevExtension ) {
            if ( !ReadTargetMemory((PVOID)DevExtension,
                                   (PVOID)&LocalDevExtension,
                                   sizeof(CLUS_DEVICE_EXTENSION))) {
                return;
            }
            TargetDevObject = LocalDevExtension.TargetDeviceObject;
        }

        dprintf( "--- \n");
        dprintf( "    DevObj/DevExt/TargetDev  @ %08X, %08X, %08X\n",
                 DeviceObject,
                 DevExtension,
                 TargetDevObject );
        if ( DevExtension ) {
            Dump_DevExt( DevExtension );
        }
        DeviceObject = LocalDeviceObject.NextDevice;
                 
    } // while

    return;

} // Dump_All


DECLARE_API( cddevext )
/*
 *   dump the clusdisk extension structure
 */
{
    PCLUS_DEVICE_EXTENSION TargetExt;
    CLUS_DEVICE_EXTENSION LocalExt;
    BOOL success;
    LONG BytesRead;
    WCHAR LocalDeviceName[512];
    //
    // get address of RGP symbol
    //

    TargetExt = (PCLUS_DEVICE_EXTENSION)GetExpression( args );

    if ( !TargetExt ) {

        dprintf("bad string conversion (%s) \n", args );
        return;
    }

    Dump_DevExt( TargetExt );

    return;
}


DECLARE_API( cddevobj )
/*
 *   dump the clusdisk extension structure for the specfied device object
 */
{
    PDEVICE_OBJECT  deviceAddr;
    DEVICE_OBJECT   deviceObject;
    ULONG           result;
   
    //
    // get address of RGP symbol
    //

    deviceAddr = (PDEVICE_OBJECT)GetExpression( args );
    
    if ( !deviceAddr ) {
        
        dprintf("bad string conversion (%s) \n", args );
        return;
        
    }
    
    if ((!ReadMemory( (ULONG_PTR)deviceAddr,
                     &deviceObject,
                     sizeof(deviceObject),
                     &result)) || result < sizeof(deviceObject)) {
        return;
    }

    dprintf( "Device Object @ %08X \n", deviceAddr );
    dprintf( "  Driver Object @ %08X\n", deviceObject.DriverObject );
    
    Dump_DevExt( deviceObject.DeviceExtension );

    return;    
}


DECLARE_API( cddumpall )
/*
 *   dump all the devobjs and devexts
 */
{
    PDEVICE_OBJECT      deviceAddr;
    
    PDEVICE_OBJECT      deviceObject;
    DEVICE_OBJECT       localDeviceObject;

    ULONG               result;

    //
    // Get clusdisk0 device object.
    //
    
    deviceAddr = (PDEVICE_OBJECT)GetExpression( "clusdisk!RootDeviceObject" );
    
    if ( !deviceAddr ) {
        
        dprintf( "Can't get \\device\\clusdisk0 expression \n" );
        return;
    }

    //
    // Get a copy of clusdisk0 device object.
    //

    if ((!ReadMemory( (ULONG_PTR) deviceAddr,
                     &deviceObject,
                     sizeof(deviceObject),
                     &result)) || result < sizeof(deviceObject)) {
    
        dprintf( "Unable to read \\device\\clusdisk0 device object \n" );
        return;
    }

    dprintf( "ClusDisk0 DevObj @ %08X \n", deviceObject );
    
    if ((!ReadMemory( (ULONG_PTR) deviceObject,
                     &localDeviceObject,
                     sizeof(localDeviceObject),
                     &result)) || result < sizeof(localDeviceObject)) {
    
        dprintf( "Unable to read \\device\\clusdisk0 device object \n" );
        return;
    }

//    dprintf( "  Driver Object @ %08X \n", localDeviceObject.DriverObject );

    Dump_All( localDeviceObject.DriverObject );

    return;

} // dumpall


DECLARE_API( cddevlist )
/*
 *   run down the device list dumping out the contents
 */
{
    PDEVICE_LIST_ENTRY  targetDevList;

    PDEVICE_OBJECT      deviceAddr;
    
    DEVICE_LIST_ENTRY   localDevList;
    
    PDEVICE_OBJECT      deviceObject;
    DEVICE_OBJECT       localDeviceObject;
    
    ULONG               result;
    
    targetDevList = (PDEVICE_LIST_ENTRY)GetExpression( "clusdisk!ClusDiskDeviceList" );

    if ( !targetDevList ) {

        dprintf("Can't convert clusdisk!ClusDiskDeviceList symbol\n");
        return;
    }

    //
    // Get clusdisk0 device object.
    
    deviceAddr = (PDEVICE_OBJECT)GetExpression( "clusdisk!RootDeviceObject" );
    
    if ( !deviceAddr ) {
        
        dprintf( "Can't get \\device\\clusdisk0 expression \n" );
        return;
    }

    //
    // Get a copy of clusdisk0 device object.
    //

    if ((!ReadMemory( (ULONG_PTR) deviceAddr,
                     &deviceObject,
                     sizeof(deviceObject),
                     &result)) || result < sizeof(deviceObject)) {
    
        dprintf( "Unable to read \\device\\clusdisk0 device object \n" );
        return;
    }

    dprintf( "ClusDisk0 Device Object @ %08X \n", deviceObject );
    
    if ((!ReadMemory( (ULONG_PTR) deviceObject,
                     &localDeviceObject,
                     sizeof(localDeviceObject),
                     &result)) || result < sizeof(localDeviceObject)) {
    
        dprintf( "Unable to read \\device\\clusdisk0 device object \n" );
        return;
    }

    dprintf( "  Driver Object @ %08X \n", localDeviceObject.DriverObject );

    //
    // read head of device list's contents from other machine
    //

    if ( !ReadTargetMemory( targetDevList, &targetDevList, sizeof( PDEVICE_LIST_ENTRY ))) {

        dprintf("Can't get ClusDiskDeviceList data\n");
        return;
    }

    while ( targetDevList != NULL ) {

        if (CheckControlC()) {
            return;
        }

        //
        // read device list entry out of target's memory
        //

        if ( !ReadTargetMemory( targetDevList, &localDevList, sizeof( DEVICE_LIST_ENTRY ))) {

            dprintf("Problem reading device list at %x\n", targetDevList );
            return;

        }

        dprintf( "\nDeviceList @ %08X\n", targetDevList );

#if 0   // Not needed...
        dprintf( "    Next DeviceList @ %08X\n", localDevList.Next );
#endif

        dprintf( "    Signature       = %08X\n", localDevList.Signature );
        dprintf( "    DeviceObject    = %08X\n", localDevList.DeviceObject );

        dprintf( "    Attached        = %s\n", TrueOrFalse( localDevList.Attached ));
        dprintf( "    LettersAssigned = %s\n", TrueOrFalse( localDevList.LettersAssigned ));
        
        targetDevList = (PDEVICE_LIST_ENTRY)localDevList.Next;
    }

    dprintf("\n");
    
} // devlist

BOOL
ReadTargetMemory(
    PVOID TargetAddress,
    PVOID LocalBuffer,
    ULONG BytesToRead
    )
{
    BOOL success;
    ULONG BytesRead;

    success = ReadMemory((ULONG_PTR)TargetAddress, LocalBuffer, BytesToRead, &BytesRead);

    if (success) {

        if (BytesRead != BytesToRead) {

            dprintf("wrong byte count. expected=%d, read =%d\n", BytesToRead, BytesRead);
        }

    } else {
        dprintf("Problem reading memory at %08X for %u bytes\n",
                TargetAddress, BytesToRead);

        success = FALSE;
    }

    return success;
}

PCHAR
ListInUse(
    PLIST_ENTRY ListToCheck,
    PLIST_ENTRY RealListAddress
    )
/*
 *  The Lists only hold IRPs!
 */
{
    PIRP Irp;
    IRP  LocalIrp;
    PLIST_ENTRY Next;
    USHORT irpCount = 0;

    if ( ListToCheck->Flink == RealListAddress ) {
        return( "(empty)" );
    } else {
        dprintf( "\n" );
        Next = ListToCheck->Flink;
        while ( Next != RealListAddress ) {
            Irp = CONTAINING_RECORD( Next,
                                     IRP,
                                     Tail.Overlay.ListEntry );
            if ( !ReadTargetMemory((PVOID)Irp,
                               (PVOID)&LocalIrp,
                               sizeof(IRP))) {
                dprintf( "Failed to read irp @ %08X \n", Irp );
                return("");
            }
            dprintf( "     ++ IRP: %08X\n", Irp );
            Next = LocalIrp.Tail.Overlay.ListEntry.Flink;
            
            if ( irpCount++ > IRP_LIST_MAX ) {
                dprintf( "     ++ Exceeded IRP max (possibly corrupt list) - stopping \n" );
                break;
            }
        }
        return ("");
    }
}

DECLARE_API( help )
{
    dprintf("Clusdisk kd extensions\n\n");
    dprintf("  cddevlist -           dump the clusdisk device list\n");
    dprintf("  cddevext <address> -  dump a devobj's extension structure\n");
    dprintf("  cddrvobj <address> -  dump the driver object\n");
    dprintf("  cddevobj <address> -  dump the devobj's extension\n");
    dprintf("  cddumpall          -  dump all devobj extensions, given a drvobj address\n\n");

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusdisk\test\diskreg.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    diskreg.c

Abstract:

    This is a tool to interface between applications and the configuration
    registry.

    The format of the registry information is described in the two
    include files ntdskreg.h and ntddft.h.  The registry information
    is stored in a single value within the key \registry\machine\system\disk.
    The value name is "information".  The format of this single value is
    a collection of "compressed" structures.  Compressed structures are
    multi element structures where the following structure starts at the
    end of the preceeding structure.  The picture below attempts to display
    this:

        +---------------------------------------+
        |                                       |
        |   DISK_CONFIG_HEADER                  |
        |     contains the offset to the        |
        |     DISK_REGISTRY header and the      |
        |     FT_REGISTRY header.               |
        +---------------------------------------+
        |                                       |
        |   DISK_REGISTRY                       |
        |     contains a count of disks         |
        +---------------------------------------+
        |                                       |
        |   DISK_DESCRIPTION                    |
        |     contains a count of partitions    |
        +---------------------------------------+
        |                                       |
        |   PARTITION_DESCRIPTION               |
        |     entry for each partition          |
        +---------------------------------------+
        |                                       |
        =   More DISK_DESCRIPTION plus          =
        =     PARTITION_DESCRIPTIONS for        =
        =     the number of disks in the        =
        =     system.  Note, the second disk    =
        =     description starts in the "n"th   =
        =     partition location of the memory  =
        =     area.  This is the meaning of     =
        =     "compressed" format.              =
        |                                       |
        +---------------------------------------+
        |                                       |
        |   FT_REGISTRY                         |
        |     contains a count of FT components |
        |     this is located by an offset in   |
        |     the DISK_CONFIG_HEADER            |
        +---------------------------------------+
        |                                       |
        |   FT_DESCRIPTION                      |
        |     contains a count of FT members    |
        +---------------------------------------+
        |                                       |
        |   FT_MEMBER                           |
        |     entry for each member             |
        +---------------------------------------+
        |                                       |
        =   More FT_DESCRIPTION plus            =
        =     FT_MEMBER entries for the number  =
        =     of FT compenents in the system    =
        |                                       |
        +---------------------------------------+

    This packing of structures is done for two reasons:

    1. to conserve space in the registry.  If there are only two partitions
       on a disk then there are only two PARTITION_DESCRIPTIONs in the
       registry for that disk.
    2. to not impose a maximum on the number of items that can be described
       in the registry.  For example if the number of members in a stripe
       set were to change from 32 to 64 there would be no effect on the
       registry format, only on the UI that presents it to the user.

Author:

    Bob Rinne (bobri)  2-Apr-1992

Environment:

    User process.  Library written for DiskMan use.

Notes:

Revision History:

    8-Dec-93 (bobri) Added double space and cdrom registry manipulation routines.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <ctype.h>
#include <string.h>
//#include <io.h>
#include <ntdskreg.h>
#include <ntddft.h>
#include <ntdddisk.h>
#include <windef.h>
#include <winbase.h>


//
// Size of memory area to allocate for configuration registry use.
//

#define DISKS_PRINT printf


//
// Constant strings.
//

PUCHAR DiskRegistryKey = DISK_REGISTRY_KEY;
PUCHAR DiskRegistryValue = DISK_REGISTRY_VALUE;



NTSTATUS
FtCreateKey(
    PHANDLE HandlePtr,
    PUCHAR KeyName,
    PUCHAR KeyClass
    )

/*++

Routine Description:

    Given an asciiz name, this routine will create a key in the configuration
    registry.

Arguments:

    HandlePtr - pointer to handle if create is successful.
    KeyName - asciiz string, the name of the key to create.
    KeyClass - registry class for the new key.
    DiskInfo - disk information for the associated partition.

Return Value:

    NTSTATUS - from the config registry calls.

--*/

{
    NTSTATUS          status;
    STRING            keyString;
    UNICODE_STRING    unicodeKeyName;
    STRING            classString;
    UNICODE_STRING    unicodeClassName;
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG             disposition;
    HANDLE            tempHandle;

#if DBG
    if ((KeyName == NULL) ||
        (KeyClass == NULL)) {
        DISKS_PRINT("FtCreateKey: Invalid parameter 0x%1!x!, 0x%2!x!\n",
            KeyName,
            KeyClass);
        ASSERT(0);
    }
#endif

    //
    // Initialize the object for the key.
    //

    RtlInitString(&keyString,
                  KeyName);

    (VOID)RtlAnsiStringToUnicodeString(&unicodeKeyName,
                                       &keyString,
                                       TRUE);

    memset(&objectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));
    InitializeObjectAttributes(&objectAttributes,
                               &unicodeKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    //
    // Setup the unicode class value.
    //

    RtlInitString(&classString,
                  KeyClass);
    (VOID)RtlAnsiStringToUnicodeString(&unicodeClassName,
                                       &classString,
                                       TRUE);

    //
    // Create the key.
    //

    status = NtCreateKey(&tempHandle,
                         KEY_READ | KEY_WRITE,
                         &objectAttributes,
                         0,
                         &unicodeClassName,
                         REG_OPTION_NON_VOLATILE,
                         &disposition);

    if (NT_SUCCESS(status)) {
        switch (disposition)
        {
        case REG_CREATED_NEW_KEY:
            break;

        case REG_OPENED_EXISTING_KEY:
            DISKS_PRINT("Warning: Creation was for an existing key!\n");
            break;

        default:
            DISKS_PRINT("New disposition returned == 0x%x\n", disposition);
            break;
        }
    }

    //
    // Free all allocated space.
    //

    RtlFreeUnicodeString(&unicodeKeyName);
    RtlFreeUnicodeString(&unicodeClassName);

    if (HandlePtr != NULL) {
        *HandlePtr = tempHandle;
    } else {
        NtClose(tempHandle);
    }
    return status;
}


NTSTATUS
FtOpenKey(
    PHANDLE HandlePtr,
    PUCHAR  KeyName,
    PUCHAR  CreateKeyClass
    )

/*++

Routine Description:

    Given an asciiz string, this routine will open a key in the configuration
    registry and return the HANDLE to the caller.

Arguments:

    HandlePtr - location for HANDLE on success.
    KeyName   - asciiz string for the key to be opened.
    CreateKeyClass - if NULL do not create key name.
                     If !NULL call create if open fails.

Return Value:

    NTSTATUS - from the config registry calls.

--*/

{
    NTSTATUS          status;
    STRING            keyString;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING    unicodeKeyName;

    RtlInitString(&keyString,
                  KeyName);

    (VOID)RtlAnsiStringToUnicodeString(&unicodeKeyName,
                                       &keyString,
                                       TRUE);

    memset(&objectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));
    InitializeObjectAttributes(&objectAttributes,
                               &unicodeKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtOpenKey(HandlePtr,
                       MAXIMUM_ALLOWED,
                       &objectAttributes);

    RtlFreeUnicodeString(&unicodeKeyName);


    if ((!NT_SUCCESS(status)) && (CreateKeyClass)) {
        status = FtCreateKey(HandlePtr,
                             KeyName,
                             CreateKeyClass);
    }
    return status;
}


NTSTATUS
FtRegistryQuery(
    IN PUCHAR  ValueName,
    OUT PVOID *FreeToken,
    OUT PVOID *Buffer,
    OUT ULONG *LengthReturned,
    OUT PHANDLE HandlePtr
    )

/*++

Routine Description:

    This routine opens the Disk Registry key and gets the contents of the
    disk information value.  It returns this contents to the caller.

Arguments:

    ValueName - asciiz string for the value name to query.
    FreeToken - A pointer to a buffer to be freed by the caller.  This is the
                buffer pointer allocated to obtain the registry information
                via the registry APIs.  To the caller it is an opaque value.
    Buffer    - pointer to a pointer for a buffer containing the desired
                registry value contents.  This is allocated by this routine and
                is part of the "FreeToken" buffer allocated once the actual
                size of the registry information is known.
    LengthReturned - pointer to location for the size of the contents returned.
    HandlePtr - pointer to a handle pointer if the caller wishes to keep it
                open for later use.

Return Value:

    NTSTATUS - from the configuration registry.

--*/

{
    NTSTATUS        status;
    HANDLE          handle;
    ULONG           resultLength;
    STRING          valueString;
    UNICODE_STRING  unicodeValueName;
    PDISK_CONFIG_HEADER         regHeader;
    PKEY_VALUE_FULL_INFORMATION keyValueInformation;

    *LengthReturned = 0;
    status = FtOpenKey(&handle,
                       DiskRegistryKey,
                       NULL);
    if (NT_SUCCESS(status)) {

        RtlInitString(&valueString,
                      ValueName);
        RtlAnsiStringToUnicodeString(&unicodeValueName,
                                     &valueString,
                                     TRUE);
        resultLength = 0;

        while (1) {
            if ( resultLength != 0 ) {
                keyValueInformation = (PKEY_VALUE_FULL_INFORMATION)
                                          LocalAlloc(LMEM_FIXED, resultLength);
            }
            
            //
            // PREFIX bug: 47610
            // If the memory can't be allocated, stop processing.  This code will 
            // correctly fall through and return NULL to FreeToken (because
            // keyValueInformation is NULL).
            //
            
            if ( !keyValueInformation ) {
                status = STATUS_NO_MEMORY;
                break;
            }
            
            status = NtQueryValueKey(handle,
                                     &unicodeValueName,
                                     KeyValueFullInformation,
                                     keyValueInformation,
                                     resultLength,
                                     &resultLength);

            if ( status != STATUS_BUFFER_TOO_SMALL ) {

                //
                // Either a real error or the information fit.
                //

                break;
            }
        }
        RtlFreeUnicodeString(&unicodeValueName);

        if (HandlePtr != NULL) {
            *HandlePtr = handle;
        } else {
            NtClose(handle);
        }

        if (NT_SUCCESS(status)) {
            if (keyValueInformation->DataLength == 0) {

                //
                // Treat this as if there was not disk information.
                //

                LocalFree(keyValueInformation);
                *FreeToken = (PVOID) NULL;
                return STATUS_OBJECT_NAME_NOT_FOUND;
            } else {

                //
                // Set up the pointers for the caller.
                //

                regHeader = (PDISK_CONFIG_HEADER)
                  ((PUCHAR) keyValueInformation + keyValueInformation->DataOffset);
                *LengthReturned = regHeader->FtInformationOffset +
                                  regHeader->FtInformationSize;
                *Buffer = (PVOID) regHeader;
            }
        }
        *FreeToken = (PVOID) keyValueInformation;
    } else {
        *FreeToken = (PVOID) NULL;
    }

    return status;
}



BOOLEAN
GetAssignedDriveLetter(
    ULONG         Signature,
    LARGE_INTEGER StartingOffset,
    LARGE_INTEGER Length,
    PUCHAR        DriveLetter,
    PULONG        Partition
    )

/*++

Routine Description:

    This routine will get the information from the disk registry
    and return the drive letter assigned for the partition in
    the registry information.

Arguments:

    Signature      - disk signature for disk containing partition for letter.
    StartingOffset - Starting offset of partition for the letter.
    Length         - length of specified partition.
    DriveLetter    - Place to return drive letter for partition.
    Partition      - Found partition number.

Return Value:

    TRUE if all works.

--*/

{
    PVOID                  freeToken = NULL;
    ULONG                  lengthReturned,
                           i,
                           j;
    NTSTATUS               status;
    PDISK_CONFIG_HEADER    regHeader;
    PDISK_REGISTRY         diskRegistry;
    PDISK_DESCRIPTION      diskDescription;
    PDISK_PARTITION        diskPartition;
    HANDLE                 handle;

    *DriveLetter = ' ';

    //
    // Get the registry information.
    //

    status = FtRegistryQuery(DiskRegistryValue,
                             &freeToken,
                             (PVOID *) &regHeader,
                             &lengthReturned,
                             &handle);
    if (!NT_SUCCESS(status)) {

        //
        // Could be permission problem, or there is no registry information.
        //

        lengthReturned = 0;

        //
        // Try to open the key for later use when setting the new value.
        //

        status = FtOpenKey(&handle,
                           DiskRegistryKey,
                           NULL);
    }

    if (!NT_SUCCESS(status)) {

        //
        // There is no registry key for the disk information.
        // Return FALSE and force caller to create registry information.
        //

        return FALSE;
    }

    if (lengthReturned == 0) {

        //
        // There is currently no registry information.
        //

        NtClose(handle);
        LocalFree(freeToken);
        return FALSE;
    }

    //
    // Search all disks.
    //

    diskRegistry = (PDISK_REGISTRY)
                         ((PUCHAR)regHeader + regHeader->DiskInformationOffset);
    diskDescription = &diskRegistry->Disks[0];

    for (i = 0; i < diskRegistry->NumberOfDisks; i++) {

        if ( diskDescription->Signature != Signature ) {
            goto next_disk;
        }

        //
        // Now locate the partition.
        //

        for (j = 0; j < diskDescription->NumberOfPartitions; j++) {

            diskPartition = &diskDescription->Partitions[j];

            if ( (diskPartition->StartingOffset.QuadPart == StartingOffset.QuadPart) &&
                 (diskPartition->Length.QuadPart == Length.QuadPart) ) {

                *DriveLetter = diskPartition->DriveLetter;
                *Partition = j;
                NtClose(handle);
                LocalFree( freeToken );
                return TRUE;
            }

        }

next_disk:
        //
        // Look at the next disk
        //

        diskDescription = (PDISK_DESCRIPTION)
              &diskDescription->Partitions[diskDescription->NumberOfPartitions];
    }

    NtClose(handle);
    LocalFree(freeToken);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusdisk\test\mountie.h ===
DWORD
DevfileOpen(
    OUT HANDLE *Handle,
    IN  wchar_t *Pathname
    );

VOID
DevfileClose(
    IN HANDLE Handle
    );

DWORD
DevfileIoctl(
    HANDLE Handle,
    DWORD Ioctl,
    PVOID Inbuf,
    ULONG Inbufsize,
    PVOID OutBuf,
    DWORD OutBufSize,
    LPDWORD ReturnedBufsize
    );


DWORD
DisksAssignDosDevice(
    PCHAR   MountName,
    PWCHAR  VolumeDevName
    );

DWORD
DisksRemoveDosDevice(
    PCHAR   MountName
    );

DWORD
FindFirstVolumeForSignature(
    IN  HANDLE MountMgrHandle,
    IN  DWORD Signature,
    OUT LPSTR VolumeName,
    IN  DWORD BufferLength,
    OUT LPHANDLE Handle,
    OUT PVOID UniqueId OPTIONAL,
    IN OUT LPDWORD IdLength,
    OUT PUCHAR DriveLetter OPTIONAL
    );

DWORD
FindNextVolumeForSignature(
    IN  HANDLE MountMgrHandle,
    IN  DWORD Signature,
    IN  HANDLE Handle,
    OUT LPSTR VolumeName,
    IN  DWORD BufferLength,
    OUT PVOID UniqueId OPTIONAL,
    IN OUT LPDWORD IdLength,
    OUT PUCHAR DriveLetter OPTIONAL
    );

DWORD
DisksSetDiskInfo(
    IN HKEY RegistryKey,
    IN DWORD Signature
    );

DWORD
DisksSetMountMgr(
    IN HKEY RegistryKey,
    IN DWORD Signature
    );

BOOL
DisksDoesDiskInfoMatch(
    IN HKEY RegistryKey,
    IN DWORD Signature
    );

BOOL
DisksIsDiskInfoValid(
    IN HKEY RegistryKey,
    IN DWORD Signature
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusdisk\test\mountie.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    mountie.c

Abstract:

    Abstract

Author:

    Rod Gamache (rodga) 4-Mar-1998

Environment:

    User Mode

Revision History:


--*/

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <devioctl.h>
//#include <ntdddisk.h>
//#include <ntddscsi.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <cfgmgr32.h>
#include <mountmgr.h>

#include "disksp.h"
#include "mountie.h"

#define OUTPUT_BUFFER_LEN 1024


/*
 * DevfileOpen - open a device file given a pathname
 *
 * Return a non-zero code for error.
 */
DWORD
DevfileOpen(
    OUT HANDLE *Handle,
    IN wchar_t *pathname
    )
{
    HANDLE      fh;
    OBJECT_ATTRIBUTES objattrs;
    UNICODE_STRING  cwspath;
    NTSTATUS        status;
    IO_STATUS_BLOCK iostatus;

    RtlInitUnicodeString(&cwspath, pathname);
    InitializeObjectAttributes(&objattrs, &cwspath, OBJ_CASE_INSENSITIVE,
                               NULL, NULL);
    fh = NULL;
    status = NtOpenFile(&fh,
                        SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                        &objattrs, &iostatus,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT);
    if (status != STATUS_SUCCESS) {
        return status;
    }

    if (iostatus.Status != STATUS_SUCCESS) {
        if (fh) {
            NtClose(fh);
        }
        return iostatus.Status;
    }

    *Handle = fh;
    return STATUS_SUCCESS;

} // DevfileOpen


/*
 * DevfileClose - close a file
 */
VOID
DevfileClose(
    IN HANDLE Handle
    )
{

    NtClose(Handle);

} // DevFileClose


/*
 * DevfileIoctl - issue an ioctl to a device
 */
DWORD
DevfileIoctl(
    IN HANDLE Handle,
    IN DWORD Ioctl,
    IN PVOID InBuf,
    IN ULONG InBufSize,
    IN OUT PVOID OutBuf,
    IN DWORD OutBufSize,
    OUT LPDWORD returnLength
    )
{
    NTSTATUS        status;
    IO_STATUS_BLOCK ioStatus;

    status = NtDeviceIoControlFile(Handle,
                                   (HANDLE) NULL,
                                   (PIO_APC_ROUTINE) NULL,
                                   NULL,
                                   &ioStatus,
                                   Ioctl,
                                   InBuf, InBufSize,
                                   OutBuf, OutBufSize);
    if ( status == STATUS_PENDING ) {
        status = NtWaitForSingleObject( Handle, FALSE, NULL );
    }

    if ( NT_SUCCESS(status) ) {
        status = ioStatus.Status;
    }

    if ( ARGUMENT_PRESENT(returnLength) ) {
        *returnLength = (DWORD)ioStatus.Information;
    }

    return status;

} // DevfileIoctl



DWORD
DisksAssignDosDevice(
    PCHAR   MountName,
    PWCHAR  VolumeDevName
    )

/*++

Routine Description:

Inputs:
    MountName -
    VolumeDevName - 

Return value:

    A Win32 error code.

--*/

{
    WCHAR mount_device[MAX_PATH];
    USHORT mount_point_len;
    USHORT dev_name_len;
    HANDLE   handle;
    DWORD   status;
    USHORT inputlength;
    PMOUNTMGR_CREATE_POINT_INPUT input;

    status = DevfileOpen(&handle, MOUNTMGR_DEVICE_NAME);
    if (status) {
        return status;
    }

    swprintf(mount_device, L"\\DosDevices\\%S", MountName);
    mount_point_len = wcslen(mount_device) * sizeof(WCHAR);
    dev_name_len = wcslen(VolumeDevName) * sizeof(WCHAR);
    inputlength = sizeof(MOUNTMGR_CREATE_POINT_INPUT) +
                  mount_point_len + dev_name_len;

    input = (PMOUNTMGR_CREATE_POINT_INPUT)malloc(inputlength);
    if (!input) {
        DevfileClose(handle);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    input->SymbolicLinkNameOffset = sizeof(MOUNTMGR_CREATE_POINT_INPUT);
    input->SymbolicLinkNameLength = mount_point_len;
    input->DeviceNameOffset = input->SymbolicLinkNameOffset +
                              input->SymbolicLinkNameLength;
    input->DeviceNameLength = dev_name_len;
    RtlCopyMemory((PCHAR)input + input->SymbolicLinkNameOffset,
                  mount_device, mount_point_len);
    RtlCopyMemory((PCHAR)input + input->DeviceNameOffset,
                  VolumeDevName, dev_name_len);
    status = DevfileIoctl(handle, IOCTL_MOUNTMGR_CREATE_POINT,
                          input, inputlength, NULL, 0, NULL);
    free(input);
    DevfileClose(handle);
    return status;

} // DisksAssignDosDevice



DWORD
DisksRemoveDosDevice(
    PCHAR   MountName
    )

/*++

Routine Description:

Inputs:
    MountName -

Return value:


--*/

{
    WCHAR mount_device[MAX_PATH];
    USHORT mount_point_len;
    USHORT dev_name_len;
    HANDLE handle;
    DWORD  status;
    USHORT inputlength;
    PMOUNTMGR_MOUNT_POINT input;

    UCHAR bogusBuffer[128];

    status = DevfileOpen(&handle, MOUNTMGR_DEVICE_NAME);
    if (status) {
        return status;
    }

    swprintf(mount_device, L"\\DosDevices\\%S", MountName);
    mount_point_len = wcslen(mount_device) * sizeof(WCHAR);
    inputlength = sizeof(MOUNTMGR_MOUNT_POINT) + mount_point_len;

    input = (PMOUNTMGR_MOUNT_POINT)malloc(inputlength);
    if (!input) {
        DevfileClose(handle);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    input->UniqueIdOffset = 0;
    input->UniqueIdLength = 0;
    input->DeviceNameOffset = 0;
    input->DeviceNameLength = 0;
    input->SymbolicLinkNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
    input->SymbolicLinkNameLength = mount_point_len;
    RtlCopyMemory((PCHAR)input + input->SymbolicLinkNameOffset,
                  mount_device, mount_point_len);
    status = DevfileIoctl(handle, IOCTL_MOUNTMGR_DELETE_POINTS,
                          input, inputlength, bogusBuffer, 128, NULL);
    free(input);
    DevfileClose(handle);
    return status;

} // DisksRemoveDosDevice




DWORD
FindFirstVolumeForSignature(
    IN  HANDLE MountMgrHandle,
    IN  DWORD Signature,
    OUT LPSTR VolumeName,
    IN  DWORD BufferLength,
    OUT LPHANDLE Handle,
    OUT PVOID UniqueId OPTIONAL,
    IN OUT LPDWORD IdLength,
    OUT PUCHAR DriveLetter OPTIONAL
    )

/*++

Inputs:

    MountMgrHandle - a handle to the mount manager.

    Signature - the signature we are looking for.

    VolumeName - must be a valid buffer of at least MAX_PATH characters.

    BufferLength - the length of VolumeName.

    Handle - pointer to receive the FindFirstVolume/FindNextVolume enum handle.

    UniqueId - optional pointer to buffer to receive the UniqueId.

    IdLength - pointer to length of the UniqueId buffer. Must be valid if
               UniqueId is present.

    DriveLetter - returns the drive letter if present.

Return Value:

    Win32 error code

--*/

{
    HANDLE  handle;
    BOOL    success;
    DWORD   status;
    LPDWORD idSignature;
    DWORD   bufLength;
    LPWSTR  wVolumeName;
    DWORD   inputlength;
    DWORD   outputlength;
    DWORD   returnlength;
    UCHAR   outputBuffer[OUTPUT_BUFFER_LEN];
    PMOUNTMGR_MOUNT_POINT input;
    PMOUNTMGR_MOUNT_POINTS output;
    PUCHAR byteBuffer;
    DWORD mountPoints;

    if ( !ARGUMENT_PRESENT( VolumeName ) ) {
        return ERROR_INVALID_PARAMETER;
    }

    handle = FindFirstVolume( VolumeName, BufferLength );

    if ( handle == INVALID_HANDLE_VALUE ) {
        return(ERROR_FILE_NOT_FOUND);
    }

    do {
        bufLength = strlen( VolumeName );
        VolumeName[bufLength-1] = '\0';
        if ( VolumeName[1] != '\\' ) {
            status = ERROR_INVALID_NAME;
            break;
        } else {
            VolumeName[1] = '?';
            wVolumeName = malloc( bufLength * sizeof(WCHAR) );
            if (!wVolumeName) {
                status = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            mbstowcs( wVolumeName, VolumeName, bufLength );
            bufLength--;
            printf( "\nFound volume %ws\n", wVolumeName );
            inputlength = sizeof(MOUNTMGR_MOUNT_POINT) +
                          (bufLength*sizeof(WCHAR)) + (2*sizeof(WCHAR));

            input = (PMOUNTMGR_MOUNT_POINT)malloc(inputlength);
            if (!input) {
                free( wVolumeName );
                status = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            input->SymbolicLinkNameOffset = 0;
            input->SymbolicLinkNameLength = 0;
            input->UniqueIdOffset = 0;
            input->UniqueIdLength = 0;
            input->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
            input->DeviceNameLength = (USHORT)(bufLength * sizeof(WCHAR));
            RtlCopyMemory((PCHAR)input + input->DeviceNameOffset,
                          wVolumeName, bufLength * sizeof(WCHAR) );
            outputlength = OUTPUT_BUFFER_LEN;

            status = DevfileIoctl(MountMgrHandle, IOCTL_MOUNTMGR_QUERY_POINTS,
                         input, inputlength, outputBuffer, outputlength, &returnlength);

            if ( status != ERROR_SUCCESS ) {
                printf( "Query points for %ws failed, error %u\n",
                    input->DeviceNameOffset, status );
                free( wVolumeName );
                free(input);
                wVolumeName = NULL;
                input = NULL;
                break;
            } else {
                output = (PMOUNTMGR_MOUNT_POINTS)outputBuffer;
                mountPoints = output->NumberOfMountPoints;
                if ( !mountPoints ) {
                    return ERROR_INVALID_DATA;
                }
                byteBuffer = outputBuffer + output->MountPoints[0].UniqueIdOffset;
                idSignature = (LPDWORD)byteBuffer;
                if ( !Signature ||
                     (Signature == *idSignature) ) {
                    NTSTATUS   ntStatus;
                    UNICODE_STRING unicodeString;
                    OEM_STRING  oemString;
                    DWORD  count;
                    UCHAR  driveLetter;
                    UCHAR  devName[ MAX_PATH ];
                    PWCHAR wideBuffer;
                    LPDWORD dwordBuffer;

                    free( wVolumeName );
                    free(input);
                    input = NULL;
                    wVolumeName = NULL;
                    *Handle = handle;
                    if ( ARGUMENT_PRESENT(UniqueId) ) {
                        if ( *IdLength > output->MountPoints[0].UniqueIdLength ) {
                            *IdLength = output->MountPoints[0].UniqueIdLength;
                        }
                        RtlCopyMemory( UniqueId, byteBuffer, *IdLength );
                    }

                    //
                    // Print the ID
                    //
                    count =  output->MountPoints[0].UniqueIdLength;
                    count = (count + 3) / 4;
                    dwordBuffer = (LPDWORD)(outputBuffer + output->MountPoints[0].UniqueIdOffset);
                    printf( "Id = " );
                    while ( count-- ) {
                        printf( "%08lx ", *(dwordBuffer++) );
                    }
                    printf( "\n" );

                    if ( ARGUMENT_PRESENT(DriveLetter) ) {
                        *DriveLetter = 0;
                        while ( mountPoints-- ) {
                            byteBuffer = outputBuffer + 
                                output->MountPoints[mountPoints].SymbolicLinkNameOffset;
                            //
                            // Covert UNICODE name to OEM string upper case
                            //
                            unicodeString.Buffer = (PWCHAR)byteBuffer;
                            unicodeString.MaximumLength = output->MountPoints[mountPoints].SymbolicLinkNameLength + sizeof(WCHAR);
                            unicodeString.Length = output->MountPoints[mountPoints].SymbolicLinkNameLength;
                            oemString.Buffer = devName;
                            oemString.MaximumLength = sizeof(devName);
                            ntStatus = RtlUpcaseUnicodeStringToOemString(
                                            &oemString,
                                            &unicodeString,
                                            FALSE );
                            if ( ntStatus != STATUS_SUCCESS ) {
                                status = RtlNtStatusToDosError( ntStatus );
                                return status;
                            }
                            devName[oemString.Length] = '\0';
                            count = sscanf( devName, "\\DOSDEVICES\\%c:", &driveLetter ); 
                            wideBuffer = (PWCHAR)byteBuffer;
                            wideBuffer[(output->MountPoints[mountPoints].SymbolicLinkNameLength)/2] = L'\0';
                            if ( count ) {
                                *DriveLetter = driveLetter;
                                printf( "Symbolic name = %ws, letter = %c:\\\n",
                                         byteBuffer,
                                         driveLetter );
                                if ( Signature ) {
                                    break;
                                }
                            } else {
                                printf( "Symbolic name = %ws\n",
                                         byteBuffer );
                            }
                        }
                    }
                    if ( Signature ) {
                        return ERROR_SUCCESS;
                    }
                }
            }

            free(wVolumeName);
            free(input);
        }

        success = FindNextVolume( handle,
                                  VolumeName,
                                  BufferLength );
        if ( !success ) {
            status = GetLastError();
        }

    } while ( status == ERROR_SUCCESS );

    FindVolumeClose( handle );
    return status;

} // FindFirstVolumeForSignature



DWORD
FindNextVolumeForSignature(
    IN  HANDLE MountMgrHandle,
    IN  DWORD Signature,
    IN  HANDLE Handle,
    OUT LPSTR VolumeName,
    IN  DWORD BufferLength,
    OUT PVOID UniqueId OPTIONAL,
    IN OUT LPDWORD IdLength,
    OUT PUCHAR DriveLetter OPTIONAL
    )

/*++

Inputs:

    MountMgrHandle - a handle to the mount manager.

    Signature - the signature we are looking for.

    Handle - the FindFirstVolume/FindNextVolume enum handle.

    VolumeName - must be a valid buffer of at least MAX_PATH characters.

    BufferLength - the length of VolumeName.

    UniqueId - optional pointer to buffer to receive the UniqueId.

    IdLength - point to the length of the UniqueId buffer.

    DriveLetter - returns the drive letter if present.

Return Value:

    Win32 error code

--*/

{
    BOOL    success;
    DWORD   status;
    LPDWORD idSignature;
    DWORD bufLength;
    LPWSTR wVolumeName;
    DWORD inputlength;
    DWORD outputlength;
    DWORD returnlength;
    UCHAR outputBuffer[OUTPUT_BUFFER_LEN];
    PMOUNTMGR_MOUNT_POINT input;
    PMOUNTMGR_MOUNT_POINTS output;
    PUCHAR byteBuffer;
    DWORD mountPoints;


    if ( !ARGUMENT_PRESENT( VolumeName ) ) {
        return ERROR_INVALID_PARAMETER;
    }

    do {
        success = FindNextVolume( Handle, VolumeName, BufferLength );

        if ( !success ) {
            status = GetLastError();
            break;
        }

        bufLength = strlen( VolumeName );

        VolumeName[bufLength-1] = '\0';
        if ( VolumeName[1] != '\\' ) {
            status = ERROR_INVALID_NAME;
            break;
        } else {
            VolumeName[1] = '?';
            bufLength--;
            wVolumeName = malloc( bufLength * sizeof(WCHAR) );
            if (!wVolumeName) {
                status = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            mbstowcs( wVolumeName, VolumeName, bufLength );
            inputlength = sizeof(MOUNTMGR_MOUNT_POINT) +
                          (bufLength*sizeof(WCHAR)) + (2*sizeof(WCHAR));

            input = (PMOUNTMGR_MOUNT_POINT)malloc(inputlength);
            if (!input) {
                free( wVolumeName );
                status = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            input->SymbolicLinkNameOffset = 0;
            input->SymbolicLinkNameLength = 0;
            input->UniqueIdOffset = 0;
            input->UniqueIdLength = 0;
            input->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
            input->DeviceNameLength = (USHORT)(bufLength * sizeof(WCHAR));
            RtlCopyMemory((PCHAR)input + input->DeviceNameOffset,
                          wVolumeName, bufLength * sizeof(WCHAR) );
            outputlength = OUTPUT_BUFFER_LEN;

            status = DevfileIoctl(MountMgrHandle, IOCTL_MOUNTMGR_QUERY_POINTS,
                         input, inputlength, outputBuffer, outputlength, &returnlength);

            if ( status != ERROR_SUCCESS ) {
                free( wVolumeName );
                free(input);
                break;
            } else {
                output = (PMOUNTMGR_MOUNT_POINTS)outputBuffer;
                mountPoints = output->NumberOfMountPoints;
                if ( !mountPoints ) {
                    return ERROR_INVALID_DATA;
                }
                byteBuffer = outputBuffer + output->MountPoints[0].UniqueIdOffset;
                idSignature = (LPDWORD)byteBuffer;
                if ( Signature ==  *idSignature ) {
                    NTSTATUS   ntStatus;
                    UNICODE_STRING unicodeString;
                    OEM_STRING  oemString;
                    DWORD  count;
                    UCHAR  driveLetter;
                    UCHAR  devName[ MAX_PATH ];

                    free( wVolumeName );
                    free(input);
                    if ( ARGUMENT_PRESENT(UniqueId) ) {
                        if ( *IdLength > output->MountPoints[0].UniqueIdLength ) {
                            *IdLength = output->MountPoints[0].UniqueIdLength;
                        }
                        RtlCopyMemory( UniqueId, byteBuffer, *IdLength );
                    }

                    if ( ARGUMENT_PRESENT(DriveLetter) ) {
                        *DriveLetter = 0;
                        while ( mountPoints-- ) {
                            byteBuffer = outputBuffer + 
                                output->MountPoints[mountPoints].SymbolicLinkNameOffset;
                            //
                            // Covert UNICODE name to OEM string upper case
                            //
                            unicodeString.Buffer = (PWCHAR)byteBuffer;
                            unicodeString.MaximumLength = output->MountPoints[mountPoints].SymbolicLinkNameLength + sizeof(WCHAR);
                            unicodeString.Length = output->MountPoints[mountPoints].SymbolicLinkNameLength;
                            oemString.Buffer = devName;
                            oemString.MaximumLength = sizeof(devName);
                            ntStatus = RtlUpcaseUnicodeStringToOemString(
                                            &oemString,
                                            &unicodeString,
                                            FALSE );
                            if ( ntStatus != STATUS_SUCCESS ) {
                                status = RtlNtStatusToDosError( ntStatus );
                                return status;
                            }
                            devName[oemString.Length] = '\0';
                            count = sscanf( devName, "\\DOSDEVICES\\%c:", &driveLetter ); 
                            if ( count ) {
                                *DriveLetter = driveLetter;
                                break;
                            }
                        }
                    }
                    return ERROR_SUCCESS;
                }
            }

            free(wVolumeName);
            free(input);
        }

        success = FindNextVolume( Handle,
                                  VolumeName,
                                  BufferLength );
        if ( !success ) {
            status = GetLastError();
        }

    } while ( status == ERROR_SUCCESS );

    return status;

} // FindNextVolumeForSignature


#if 0

DWORD
DisksSetDiskInfo(
    IN HKEY RegistryKey,
    IN DWORD Signature
    )

/*++

Inputs:

Return Value:

    A Win32 error code.

--*/

{
    DWORD   status;
    UCHAR   driveLetter;
    UCHAR   volumeName[MAX_PATH];
    HANDLE  handle;
    HANDLE  mHandle;
    UCHAR   uniqueId[MAX_PATH];
    UCHAR   smashedId[MAX_PATH+1];
    DWORD   idLength;
    DWORD   i;
    WCHAR   indexName[16];
    HKEY    registryKey;
    DWORD   disposition;
    
    status = DevfileOpen( &mHandle, MOUNTMGR_DEVICE_NAME );
    if ( status != ERROR_SUCCESS ) {
        printf( "SetDiskInfo: DevfileOpen failed, status = %u\n", status);
        return status;
    }

    status = ClusterRegDeleteKey( RegistryKey, L"MountMgr" );
    if ( (status != ERROR_SUCCESS) && (status != ERROR_FILE_NOT_FOUND) ) {
        DevfileClose( mHandle );
        printf( "DiskInfo: ClusterRegDeleteKey failed, status = %1!u!\n", status);
        return status;
    }

    status = ClusterRegCreateKey( RegistryKey,
                                  L"MountMgr",
                                  0,
                                  KEY_READ | KEY_WRITE,
                                  NULL,
                                  &registryKey,
                                  &disposition );
    if ( status != ERROR_SUCCESS ) {
        DevfileClose( mHandle );
        (DiskpLogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"SetDiskInfo: ClusterRegCreateKey failed, status = %1!u!\n", status);
        return status;
    }

    idLength = MAX_PATH;
    status = FindFirstVolumeForSignature( ResourceHandle,
                                          mHandle,
                                          Signature,
                                          volumeName,
                                          MAX_PATH,
                                          &handle,
                                          uniqueId,
                                          &idLength,
                                          &driveLetter );
    if ( status != ERROR_SUCCESS ) {
        DevfileClose( mHandle );
        ClusterRegCloseKey( registryKey );
        (DiskpLogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"SetDiskInfo: FindFirstVolume failed, status = %1!u!\n", status);
        return status;
    }

    i = 0;
    while ( status == ERROR_SUCCESS ) {
        wsprintfW( indexName, L"%0.5u", i++ );

        smashedId[0] = driveLetter;
        RtlCopyMemory( &smashedId[1], uniqueId, idLength );
        status = ClusterRegSetValue( registryKey,
                                     indexName,
                                     REG_BINARY,
                                     (CONST BYTE *)smashedId,
                                     idLength + 1);
        if ( status != ERROR_SUCCESS ) {
            //printf("DiskSetDiskInfo, error setting value %s\n", indexName );
        }

        idLength = MAX_PATH;
        status = FindNextVolumeForSignature( mHandle,
                                             Signature,
                                             handle,
                                             volumeName,
                                             MAX_PATH,
                                             uniqueId,
                                             &idLength,
                                             &driveLetter );
    }

    FindVolumeClose( handle );
    DevfileClose( mHandle );
    ClusterRegCloseKey( registryKey );

    return ERROR_SUCCESS;

} // DisksSetDiskInfo



DWORD
DisksSetMountMgr(
    IN HKEY RegistryKey,
    IN DWORD Signature
    )

/*++

Inputs:

Return Value:

    A Win32 error code.

--*/

{
    DWORD   status;
    UCHAR   volumeName[MAX_PATH];
    LPWSTR  wVolumeName;
    HANDLE  mHandle;
    HANDLE  handle = NULL;
    UCHAR   storedId[MAX_PATH+1];
    DWORD   storedIdSize;
    DWORD   i;
    WCHAR   indexName[16];
    HKEY    registryKey;
    DWORD   type; 
    DWORD   bufLength;
    UCHAR   driveLetter[4];
    NTSTATUS ntStatus;

    status = DevfileOpen( &mHandle, MOUNTMGR_DEVICE_NAME );
    if ( status != ERROR_SUCCESS ) {
        (DiskpLogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"SetMountMgr: DevfileOpen failed, status = %1!u!\n", status);
        return status;
    }

    status = ClusterRegOpenKey( RegistryKey,
                                L"MountMgr",
                                KEY_READ | KEY_WRITE,
                                &registryKey );
    if ( status != ERROR_SUCCESS ) {
        DevfileClose( mHandle );
        return status;
        (DiskpLogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"SetMountMgr: ClusterRegOpenKey failed, status = %1!u!\n", status);
    }

    i = 0;
    do {
        wsprintfW( indexName, L"%0.5u", i++ );
        storedIdSize = MAX_PATH;
        status = ClusterRegQueryValue( registryKey,
                                       indexName,
                                       &type,
                                       (PUCHAR)storedId,
                                       &storedIdSize);

        (DiskpLogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"SetMountMgr: ClusterRegQueryValue returned status = %1!u!\n", status);
        if ( status != ERROR_SUCCESS ) {
            break;
        }

        storedId[1] = ':';
        storedId[2] = '\0';
        ntStatus = DisksRemoveDosDevice( storedId );
        status = RtlNtStatusToDosError( ntStatus );
        (DiskpLogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"SetMountMgr: RemoveDosDevice for %1!x! returned status = %2!u!\n", *storedId, status);
        if ( status == ERROR_FILE_NOT_FOUND ) {
            status = ERROR_SUCCESS;
        }

    } while ( status == ERROR_SUCCESS );

    status = FindFirstVolumeForSignature( ResourceHandle,
                                          mHandle,
                                          Signature,
                                          volumeName,
                                          MAX_PATH,
                                          &handle,
                                          NULL,
                                          NULL,
                                          &driveLetter[0] );

    if ( status != ERROR_SUCCESS ) {
        (DiskpLogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"SetMountMgr: FindFirstVolume failed for Signature %1!08lx!, status = %2!u!\n", Signature, status);
    }

    i = 0;
    while ( status == ERROR_SUCCESS ) {
        wsprintfW( indexName, L"%0.5u", i++ );
        storedIdSize = MAX_PATH;
        status = ClusterRegQueryValue( registryKey,
                                       indexName,
                                       &type,
                                       (PUCHAR)storedId,
                                       &storedIdSize );
        if ( status != ERROR_SUCCESS ) {
            break;
        }

        //
        // Remove current drive letter
        //
        driveLetter[1] = ':';
        driveLetter[2] = '\0';
        ntStatus = DisksRemoveDosDevice( driveLetter );
        status = RtlNtStatusToDosError( ntStatus );
        (DiskpLogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"SetMountMgr: RemoveDosDevice for %1!x! returned status = %2!u!\n", driveLetter[0], status);

        bufLength = strlen( volumeName );
        wVolumeName = malloc( (bufLength + 1) * sizeof(WCHAR) );
        if (!wVolumeName) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        mbstowcs( wVolumeName, volumeName, bufLength + 1 );

        storedId[1] = ':';
        storedId[2] = '\0';
        status = DisksAssignDosDevice( storedId, wVolumeName );
        (DiskpLogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"SetMountMgr: AssignDosDevice for %1!x! (%2!ws!) returned status = %3!u!\n", *storedId, wVolumeName, status);
        free( wVolumeName );
        if ( status != ERROR_SUCCESS ) {
            break;
        }

        status = FindNextVolumeForSignature( mHandle,
                                             Signature,
                                             handle,
                                             volumeName,
                                             MAX_PATH,
                                             NULL,
                                             NULL,
                                             &driveLetter[0] );

        if ( status != ERROR_SUCCESS ) {
            (DiskpLogEvent)(
                    ResourceHandle,
                    LOG_ERROR,
                    L"SetMountMgr: FindNextVolume failed, status = %1!u!\n", status);
        }
        if ( status == ERROR_NO_MORE_FILES ) {
            status = ERROR_SUCCESS;
            break;
        }

    }

    DevfileClose( mHandle );
    ClusterRegCloseKey( registryKey );
    if ( handle ) {
        FindVolumeClose( handle );
    }

    return status;

} // DisksSetMountMgr



BOOL
DisksDoesDiskInfoMatch(
    IN HKEY RegistryKey,
    IN DWORD Signature
    )

/*++

Inputs:

Return Value:

    A Win32 error code.

--*/

{
    DWORD   status;
    UCHAR   driveLetter;
    UCHAR   volumeName[MAX_PATH];
    HANDLE  handle;
    HANDLE  mHandle;
    UCHAR   uniqueId[MAX_PATH];
    UCHAR   smashedId[MAX_PATH+1];
    UCHAR   storedId[MAX_PATH+1];
    DWORD   idLength;
    DWORD   storedIdSize;
    DWORD   i;
    WCHAR   indexName[16];
    HKEY    registryKey;
    DWORD   type;
    

    status = DevfileOpen( &mHandle, MOUNTMGR_DEVICE_NAME );
    if ( status != ERROR_SUCCESS ) {
        return FALSE;
    }

    status = ClusterRegOpenKey( RegistryKey,
                                L"MountMgr",
                                KEY_READ | KEY_WRITE,
                                &registryKey );
    if ( status != ERROR_SUCCESS ) {
        DevfileClose( mHandle );
        return FALSE;
    }

    idLength = MAX_PATH;
    status = FindFirstVolumeForSignature( ResourceHandle,
                                          mHandle,
                                          Signature,
                                          volumeName,
                                          MAX_PATH,
                                          &handle,
                                          uniqueId,
                                          &idLength,
                                          &driveLetter );
    if ( status != ERROR_SUCCESS ) {
        DevfileClose( mHandle );
        ClusterRegCloseKey( registryKey );
        return FALSE;
    }

    i = 0;
    while ( status == ERROR_SUCCESS ) {
        wsprintfW( indexName, L"%0.5u", i++ );

        smashedId[0] = driveLetter;
        RtlCopyMemory( &smashedId[1], uniqueId, idLength );
        storedIdSize = MAX_PATH;
        status = ClusterRegQueryValue( registryKey,
                                       indexName,
                                       &type,
                                       (PUCHAR)storedId,
                                       &storedIdSize);

        if ( (status != ERROR_SUCCESS) ||
             (type != REG_BINARY) ||
             (storedIdSize != (idLength+1)) ||
             (RtlCompareMemory( smashedId, storedId, idLength ) != idLength) ) {
            FindVolumeClose( handle );
            DevfileClose( mHandle );
            ClusterRegCloseKey( registryKey );
            return FALSE;
        }

        idLength = MAX_PATH;
        status = FindNextVolumeForSignature( mHandle,
                                             Signature,
                                             handle,
                                             volumeName,
                                             MAX_PATH,
                                             uniqueId,
                                             &idLength,
                                             &driveLetter );
    }

    FindVolumeClose( handle );
    DevfileClose( mHandle );
    ClusterRegCloseKey( registryKey );

    if ( status != ERROR_NO_MORE_FILES ) {
        return FALSE;
    }

    return TRUE;

} // DisksDoesDiskInfoMatch



BOOL
DisksIsDiskInfoValid(
    IN HKEY RegistryKey,
    IN DWORD Signature
    )

/*++

Inputs:

Return Value:

    A Win32 error code.

--*/

{
    DWORD   status;
    UCHAR   volumeName[MAX_PATH];
    UCHAR   storedId[MAX_PATH+1];
    DWORD   storedIdSize;
    WCHAR   indexName[16];
    HKEY    registryKey;
    DWORD   i;
    DWORD   type;
    HANDLE  handle;
    HANDLE  mHandle;
    

    status = DevfileOpen( &mHandle, MOUNTMGR_DEVICE_NAME );
    if ( status != ERROR_SUCCESS ) {
        return FALSE;
    }

    status = ClusterRegOpenKey( RegistryKey,
                                L"MountMgr",
                                KEY_READ | KEY_WRITE,
                                &registryKey );
    if ( status != ERROR_SUCCESS ) {
        DevfileClose( mHandle );
        return FALSE;
    }

    status = FindFirstVolumeForSignature( ResourceHandle,
                                          mHandle,
                                          Signature,
                                          volumeName,
                                          MAX_PATH,
                                          &handle,
                                          NULL,
                                          NULL,
                                          NULL );
    if ( status != ERROR_SUCCESS ) {
        DevfileClose( mHandle );
        ClusterRegCloseKey( registryKey );
        return TRUE;
    }

    i = 0;
    while ( status == ERROR_SUCCESS ) {
        wsprintfW( indexName, L"%0.5u", i++ );

        storedIdSize = MAX_PATH;
        status = ClusterRegQueryValue( registryKey,
                                       indexName,
                                       &type,
                                       (PUCHAR)storedId,
                                       &storedIdSize);
        if ( (status != ERROR_SUCCESS) ||
             (type != REG_BINARY) ) {
            FindVolumeClose( handle );
            DevfileClose( mHandle );
            ClusterRegCloseKey( registryKey );
            if ( status == ERROR_FILE_NOT_FOUND ) {
                return TRUE;
            } else {
                return FALSE;
            }
        }

        status = FindNextVolumeForSignature( mHandle,
                                             Signature,
                                             handle,
                                             volumeName,
                                             MAX_PATH,
                                             NULL,
                                             NULL,
                                             NULL );
    }

    FindVolumeClose( handle );
    DevfileClose( mHandle );
    ClusterRegCloseKey( registryKey );

    return TRUE;

} // DisksIsDiskInfoValid

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusdisk\test\disktest.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    disktest.c

Abstract:

    Abstract

Author:

    Rod Gamache (rodga) 4-Mar-1996

Environment:

    User Mode

Revision History:


--*/

#define INITGUID 1
//#include <windows.h>
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <clusapi.h>
#include <ntddvol.h>

#include <mountie.h>
#include <mountmgr.h>
#include <partmgrp.h>
#include <devioctl.h>
#include <ntdddisk.h>
#include <ntddscsi.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>

//#include <initguid.h>
#include <devguid.h>

#include <setupapi.h>
#include <cfgmgr32.h>

#include "clusdisk.h"
#include "disksp.h"
#include "diskarbp.h"

#ifndef ClusterHashGuid
#define ClusterHashGuid(Guid) (((PULONG) &Guid)[0] ^ ((PULONG) &Guid)[1] ^ ((PULONG) &Guid)[2] ^ ((PULONG) &Guid)[3])
#endif

NTSTATUS
GetAssignedLetter ( 
    PWCHAR deviceName, 
    PCHAR driveLetter 
    );

PVOID
DoIoctlAndAllocate(
    IN HANDLE FileHandle,
    IN DWORD  IoControlCode,
    IN PVOID  InBuf,
    IN ULONG  InBufSize,
    OUT PDWORD BytesReturned
    );

VOID
GetSymbolicLink(
    IN PCHAR RootName,
    IN OUT PCHAR ObjectName,
    IN PDISK_INFO DiskInfo
    );

HANDLE
OpenObject(
    LPSTR lpstrDirectory,
    LPSTR lpstrObject,
    PDISK_INFO DiskInfo
    );

PSTR PartitionName = "\\Device\\Harddisk%d\\Partition%d";


int __cdecl
main(
     int argc,
     char *argv[]
     );

static DWORD
Reset(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

static DWORD
Reserve(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

static DWORD
Release(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

static DWORD
Online(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

static DWORD
Offline(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

DWORD
Claim(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

DWORD
EjectVolumes(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

DWORD
PokeMountMgr ( 
    VOID
    );

DWORD
EnumMounts(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

DWORD
EnumExtents(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

DWORD
EnumNodes(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

DWORD
EnumDisks(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

DWORD
DisableNode(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

DWORD
EnableNode(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

DWORD
DisableDisk(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

DWORD
EnableDisk(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

DWORD
GetDiskGeometry(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

DWORD
GetScsiAddress(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

DWORD
GetDriveLayout(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         );

DWORD
GetDriveLayoutEx(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         );

LPTSTR
BooleanToString(
    BOOLEAN Value
    );

void
FormatGuid(
    GUID*   Guid,
    char*   Str
    );

DWORD
GetVolumeInfo(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         );

DWORD
SetDriveLayout(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         );

DWORD
Attach(
        HANDLE fileHandle,
        int argc,
        char *argv[]
        );

DWORD
Detach(
        HANDLE fileHandle,
        int argc,
        char *argv[]
        );

DWORD
HoldIO(
        HANDLE fileHandle,
        int argc,
        char *argv[]
        );

DWORD
ResumeIO(
        HANDLE fileHandle,
        int argc,
        char *argv[]
        );

static DWORD
GetPartitionInfo(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         );

BOOLEAN
AssignDriveLetters(
        PDISK_INFO DiskInfo
        );

DWORD
AssignLetters(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         );

BOOLEAN
RemoveDriveLetters(
        PDISK_INFO DiskInfo
        );

DWORD
RemoveLetters(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         );

DWORD
ReadSector(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

DWORD
ReadSectorViaIoctl(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    );

DWORD
FixDisk(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         );

static DWORD
FixDriveLayout(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         );

static DWORD
StartReserve(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         );

static DWORD
StopReserve(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         );

static DWORD
Active(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         );

static DWORD
NotClusterCapable(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         );

static DWORD
Test(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         );

static DWORD
Nt4Capable(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         );

static DWORD
GetDriveLetter( 
         PUCHAR deviceNameString
         );

NTSTATUS
GetVolumeInformationFromHandle(
   HANDLE Handle
   );


VOID
PrintError(
    IN DWORD ErrorCode
    );

DWORD
GetSerialNumber(
    HANDLE FileHandle
    );


static void
usage(
      char *programName
      );

int
ExecuteCommand(
    IN PSTR    Command,
    IN int     argc,
    IN char *argv[]
    );

//
// Global data
//

PSTR    DeviceName;
PSTR    ProgramName;


int __cdecl
main(
     int argc,
     char *argv[]
     )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
#define MAX_DEVICES 99

    DWORD   logicalDrives;
    DWORD   letter;
    DWORD   index;
    PSTR    command;
    UCHAR   buffer[128];
    wchar_t * pBuffer;
    DWORD   status;
    HANDLE  handle;

    if (argc < 3)
    {
        usage( argv[0] );
        return -1;
    }
    argc--;
    ProgramName = *argv++;  // skip program name
    argc--;
    DeviceName = *argv++;
    argc--;
    command = *argv++;

    if ( ( lstrcmpi( DeviceName, "*" ) == 0 ) ||
         ( lstrcmpi( DeviceName, "l*" ) == 0 ) ) {
        // this is a wildcard request for logical drives.
        logicalDrives = GetLogicalDrives();

        for ( index = 0; index < 27; index++ ) {
            letter = 'A' + index;
            if ( (logicalDrives & 1) ) {
                sprintf( buffer, "%c:", letter );
                printf( "\n ** For device ** %s\n", buffer );
                DeviceName =  buffer;
                status = ExecuteCommand(
                    command,
                    argc,
                    argv );
                
                // Don't stop on error.
            }
            logicalDrives = logicalDrives >> 1;
        } // for
    } else if ( lstrcmpi( DeviceName, "p*" ) == 0 ) {
        pBuffer = (wchar_t *)buffer;

        for ( index = 0; index < MAX_DEVICES; index++ ) {
            DWORD accessMode = GENERIC_READ;
            DWORD shareMode = FILE_SHARE_READ;

            wsprintfW( pBuffer, L"\\\\.\\PhysicalDrive%u", index );
            handle = CreateFileW(
                    pBuffer,
                    shareMode,
                    shareMode,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL );
            status = ERROR_INVALID_HANDLE;
            if ( handle != INVALID_HANDLE_VALUE ) {
                CloseHandle( handle );
                status = ERROR_SUCCESS;
                printf( "\n ** For device ** %ws\n", pBuffer );
                sprintf( buffer, "%ws", pBuffer );
                DeviceName =  buffer;
                status = ExecuteCommand(
                    command,
                    argc,
                    argv );
                if ( status != 0 ) {
                    return( status );
                }
            }
        }
    } else {
        status = ExecuteCommand(
            command,
            argc,
            argv );
    }

    return(status);
}

int
ExecuteCommand(
    IN PSTR Command,
    IN int     argc,
    IN char *argv[]
    )

{
    PSTR device;
    HANDLE fileHandle;
    DWORD accessMode, shareMode;
    DWORD errorCode;
    BOOL  failed = FALSE;
    UCHAR deviceNameString[128];
    DWORD logicalDrives;
    DWORD letter;
    DWORD index;

    NTSTATUS       ntStatus;
    ANSI_STRING    objName;
    UNICODE_STRING unicodeName;
    OBJECT_ATTRIBUTES objAttributes;
    IO_STATUS_BLOCK ioStatusBlock;

    //
    // Note it is important to access the device with 0 access mode so that
    // the file open code won't do extra I/O to the device
    //
    shareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
    accessMode = GENERIC_READ | GENERIC_WRITE;

    strcpy(deviceNameString, "\\\\.\\");
    strcat(deviceNameString, DeviceName);

    fileHandle = CreateFile(deviceNameString,
       accessMode,
       shareMode,
       NULL,
       OPEN_EXISTING,
       0,
       NULL);

    if ( fileHandle == INVALID_HANDLE_VALUE ) {
        errorCode = GetLastError();
        if ( (errorCode == ERROR_PATH_NOT_FOUND) ||
             (errorCode == ERROR_FILE_NOT_FOUND) ) {
            strcpy(deviceNameString, "\\Device\\");
            strcat(deviceNameString, DeviceName);
            RtlInitString(&objName, deviceNameString);
            ntStatus = RtlAnsiStringToUnicodeString( &unicodeName,
                                                     &objName,
                                                     TRUE );
            if ( !NT_SUCCESS(ntStatus) ) {
                printf("Error converting device name %s to unicode. Error: %lx\n",
                      deviceNameString, ntStatus);
                return -1;
            }
            InitializeObjectAttributes( &objAttributes,
                                        &unicodeName,
                                        OBJ_CASE_INSENSITIVE,
                                        NULL,
                                        NULL );
            ntStatus = NtCreateFile( &fileHandle,
                                     SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                                     &objAttributes,
                                     &ioStatusBlock,
                                     NULL,
                                     FILE_ATTRIBUTE_NORMAL,
                                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                                     FILE_OPEN,
                                     0,
                                     NULL,
                                     0 );
            if ( !NT_SUCCESS(ntStatus) ) {
                failed = TRUE;
            }
            RtlFreeUnicodeString( &unicodeName );
        } else {
           printf("Error opening %s. Error: %d\n",
              deviceNameString, errorCode = GetLastError());
           PrintError(errorCode);
           return -1;
        }
    }

    if ( failed ) {
        strcpy(deviceNameString, "\\Device\\");
        strcat(deviceNameString, DeviceName);
        //strcat(deviceNameString, "\\Partition0");
        RtlInitString(&objName, deviceNameString);
        ntStatus = RtlAnsiStringToUnicodeString( &unicodeName,
                                                 &objName,
                                                 TRUE );
        if ( !NT_SUCCESS(ntStatus) ) {
            printf("Error converting device name %s to unicode. Error: %lx\n",
                  deviceNameString, ntStatus);
            return -1;
        }
        InitializeObjectAttributes( &objAttributes,
                                    &unicodeName,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL );
        ntStatus = NtCreateFile( &fileHandle,
                                 SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                                 &objAttributes,
                                 &ioStatusBlock,
                                 NULL,
                                 FILE_ATTRIBUTE_NORMAL,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 FILE_OPEN,
                                 0,
                                 NULL,
                                 0 );
        if ( !NT_SUCCESS(ntStatus) ) {
            printf("Error opening device %ws. Error: %lx.\n",
                   unicodeName.Buffer, ntStatus );
            return -1;
        }
        RtlFreeUnicodeString( &unicodeName );
    }
    //printf("Accessing %s ... \n", deviceNameString);

    if (!_stricmp( Command, "Reset" ))
        errorCode = Reset( fileHandle, argc, argv );
    else if (!_stricmp( Command, "Reserve" ))
        errorCode = Reserve( fileHandle, argc, argv );
    else if (!_stricmp( Command, "Release" ))
        errorCode = Release( fileHandle, argc, argv );
    else if (!_stricmp( Command, "Online" ))
        errorCode = Online( fileHandle, argc, argv );
    else if (!_stricmp( Command, "Offline" ))
        errorCode = Offline( fileHandle, argc, argv );
    else if (!_stricmp( Command, "HoldIO" ))
        errorCode = HoldIO( fileHandle, argc, argv );
    else if (!_stricmp( Command, "ResumeIO" ))
        errorCode = ResumeIO( fileHandle, argc, argv );
    else if (!_stricmp( Command, "Claim" ))
        errorCode = Claim( fileHandle, argc, argv );
    else if (!_stricmp( Command, "EjectVolumes" ))
        errorCode = EjectVolumes( fileHandle, argc, argv );
    else if (!_stricmp( Command, "PokeMountMgr" ))
        errorCode = PokeMountMgr();
    else if (!_stricmp( Command, "EnumMounts" ))
        errorCode = EnumMounts( fileHandle, argc, argv );
    else if (!_stricmp( Command, "EnumExtents" ))
        errorCode = EnumExtents( fileHandle, argc, argv );
    else if (!_stricmp( Command, "EnumNodes" ))
        errorCode = EnumNodes( fileHandle, argc, argv );
    else if (!_stricmp( Command, "EnumDisks" ))
        errorCode = EnumDisks( fileHandle, argc, argv );
    else if (!_stricmp( Command, "DisableNode" ))
        errorCode = DisableNode( fileHandle, argc, argv );
    else if (!_stricmp( Command, "EnableNode" ))
        errorCode = EnableNode( fileHandle, argc, argv );
    else if (!_stricmp( Command, "DisableDisk" ))
        errorCode = DisableDisk( fileHandle, argc, argv );
    else if (!_stricmp( Command, "EnableDisk" ))
        errorCode = EnableDisk( fileHandle, argc, argv );
    else if (!_stricmp( Command, "GetDiskGeometry" ))
        errorCode = GetDiskGeometry( fileHandle, argc, argv );
    else if (!_stricmp( Command, "GetScsiAddress" ))
        errorCode = GetScsiAddress( fileHandle, argc, argv );
    else if (!_stricmp( Command, "GetVolumeInfo" ))
        errorCode = GetVolumeInfo( fileHandle, argc, argv );
    else if (!_stricmp( Command, "GetDriveLayout" ))
        errorCode = GetDriveLayout( fileHandle, argc, argv );
    else if (!_stricmp( Command, "GetDriveLayoutEx" ))
        errorCode = GetDriveLayoutEx( fileHandle, argc, argv );
    else if (!_stricmp( Command, "SetDriveLayout" ))
        errorCode = SetDriveLayout( fileHandle, argc, argv );
    else if (!_stricmp( Command, "GetPartitionInfo" ))
        errorCode = GetPartitionInfo( fileHandle, argc, argv );
    else if (!_stricmp( Command, "AssignLetters" ))
        errorCode = AssignLetters( fileHandle, argc, argv );
    else if (!_stricmp( Command, "RemoveLetters" ))
        errorCode = RemoveLetters( fileHandle, argc, argv );
    else if (!_stricmp( Command, "ReadSector" ))
        errorCode = ReadSector( fileHandle, argc, argv );
    else if (!_stricmp( Command, "rs" ))
        errorCode = ReadSectorViaIoctl( fileHandle, argc, argv );
    else if (!_stricmp( Command, "Attach" ))
        errorCode = Attach( fileHandle, argc, argv );
    else if (!_stricmp( Command, "Detach" ))
        errorCode = Detach( fileHandle, argc, argv );
    else if (!_stricmp( Command, "FixDisk" ))
        errorCode = FixDisk( fileHandle, argc, argv );
    else if (!_stricmp( Command, "FixDriveLayout" ))
        errorCode = FixDriveLayout( fileHandle, argc, argv );
    else if (!_stricmp( Command, "StartReserve" ))
        errorCode = StartReserve( fileHandle, argc, argv );
    else if (!_stricmp( Command, "StopReserve" ))
        errorCode = StopReserve( fileHandle, argc, argv );
    else if (!_stricmp( Command, "Test" ))
        errorCode = Test( fileHandle, argc, argv );
    else if (!_stricmp( Command, "NT4Capable" ))
        errorCode = Nt4Capable( fileHandle, argc, argv );
    else if (!_stricmp( Command, "Active"))
        errorCode = Active( fileHandle, argc, argv );
    else if (!_stricmp( Command, "Capable"))
        errorCode = NotClusterCapable( fileHandle, argc, argv );
    else if (!_stricmp( Command, "GetDriveLetter")) 
        errorCode = GetDriveLetter( deviceNameString );
    else if (!_stricmp( Command, "GetSerialNumber")) 
        errorCode = GetSerialNumber( fileHandle );        
    else
    {
        printf( "Invalid command.\n" );
        CloseHandle( fileHandle );
        usage( ProgramName );
        return(-1);
    }
    
    CloseHandle( fileHandle );

    if (errorCode != ERROR_SUCCESS) {
        printf( "Error performing %s:, error %u.\n", Command, errorCode );
        PrintError(errorCode);
        printf( "%s: failed.\n", ProgramName );
        return(-1);
    } else
        return(0);
}


static DWORD
Reset(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode, bytesReturned;
    SCSI_PASS_THROUGH scsiBlock;
    SCSI_ADDRESS scsiAddress;
    STORAGE_BUS_RESET_REQUEST storageReset;
    
    if (argc != 0)
    {
        printf( "usage: <device> Reset\n" );
        return ERROR_INVALID_NAME;
    }

    success = DeviceIoControl(fileHandle,
                              IOCTL_SCSI_GET_ADDRESS,
                              NULL,
                              0,
                              &scsiAddress,
                              sizeof(SCSI_ADDRESS),
                              &bytesReturned,
                              FALSE );
    if ( !success ||
          bytesReturned < sizeof(DWORD) ) {
        printf( "Error reading SCSI address, error = %d\n",
             errorCode = GetLastError());
        PrintError(errorCode);
        return errorCode;
    }

    scsiBlock.PathId = scsiAddress.PathId;
    scsiBlock.TargetId = scsiAddress.TargetId;
    scsiBlock.Lun = 0;
    scsiBlock.Length = sizeof(SCSI_PASS_THROUGH);

    success = DeviceIoControl(fileHandle,
                              IOCTL_DISK_CLUSTER_RESET_BUS,
                              &scsiBlock,
                              sizeof(SCSI_PASS_THROUGH), 
                              NULL,
                              0,
                              &bytesReturned,
                              FALSE);

    if (!success) {
       storageReset.PathId = scsiAddress.PathId;
       success = DeviceIoControl(fileHandle,
                                 IOCTL_STORAGE_RESET_BUS,
                                 &storageReset,
                                 sizeof(STORAGE_BUS_RESET_REQUEST),
                                 NULL,
                                 0,
                                 &bytesReturned,
                                 FALSE);
   
       if (!success) {
          printf( "Error performing bus reset; error was %d\n",
             errorCode = GetLastError());
          PrintError(errorCode);
          return errorCode;
       }
    }

    return ERROR_SUCCESS;
}


static DWORD
Test(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode, bytesReturned;
    
    if (argc != 0)
    {
        printf( "usage: <device> Test\n" );
        return ERROR_INVALID_NAME;
    }
    
    success = DeviceIoControl(fileHandle,
                             IOCTL_DISK_CLUSTER_TEST,
                             NULL,
                             0,
                             NULL,
                             0,
                             &bytesReturned,
                             FALSE);

    if (!success)
    {
       printf( "Error performing test; error was %d\n",
          errorCode = GetLastError());
       PrintError(errorCode);
       return errorCode;
    }

    return ERROR_SUCCESS;
}


static DWORD
Nt4Capable(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode, bytesReturned;
    
    if (argc != 0)
    {
        printf( "usage: <device> NT4Capable\n" );
        return ERROR_INVALID_NAME;
    }
    
    success = DeviceIoControl(fileHandle,
                             IOCTL_DISK_CLUSTER_NT4_CAPABLE,
                             NULL,
                             0,
                             NULL,
                             0,
                             &bytesReturned,
                             FALSE);

    if (!success)
    {
       printf( "Error performing NT4Capable; error was %d\n",
          errorCode = GetLastError());
       PrintError(errorCode);
       return errorCode;
    }

    return ERROR_SUCCESS;
}


static DWORD
NotClusterCapable(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode, bytesReturned;
    
    if (argc != 0)
    {
        printf( "usage: <device> Capable\n" );
        return ERROR_INVALID_NAME;
    }
    
    success = DeviceIoControl(fileHandle,
                             IOCTL_DISK_CLUSTER_NOT_CLUSTER_CAPABLE,
                             NULL,
                             0,
                             NULL,
                             0,
                             &bytesReturned,
                             FALSE);

    if (!success)
    {
       printf( "Error performing Capable; error was %d\n",
          errorCode = GetLastError());
       PrintError(errorCode);
       return errorCode;
    }

    return ERROR_SUCCESS;
}



static DWORD
StartReserve(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode, bytesReturned;
    DWORD signature;
    STRING ansiString;
    UNICODE_STRING numberString;

    if (argc != 1)
    {
        printf( "usage: <device> StartReserve <device signature>\n" );
        return ERROR_INVALID_NAME;
    }

    RtlInitAnsiString( &ansiString, *argv );

    printf(" Ansi string for signature is %s\n",
             ansiString.Buffer );

    RtlAnsiStringToUnicodeString(
                            &numberString,
                            &ansiString,
                            TRUE );

    errorCode = RtlUnicodeStringToInteger(
                            &numberString,
                            16,
                            &signature );

    RtlFreeUnicodeString( &numberString );

    if ( !NT_SUCCESS(errorCode) ) {
        printf( "Error converting signature to hex number, NT status %u.\n",
                errorCode );
        return(errorCode);
    }

    success = DeviceIoControl(fileHandle,
                             IOCTL_DISK_CLUSTER_START_RESERVE,
                             &signature,
                             sizeof(DWORD),
                             NULL,
                             0,
                             &bytesReturned,
                             FALSE);

    if (!success)
    {
       printf( "Error performing StartReserve; error was %d\n",
          errorCode = GetLastError());
       PrintError(errorCode);
       return errorCode;
    }

    return ERROR_SUCCESS;
}


static DWORD
StopReserve(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode, bytesReturned;
    
    if (argc != 0)
    {
        printf( "usage: <device> StopReserve\n" );
        return ERROR_INVALID_NAME;
    }
    
    success = DeviceIoControl(fileHandle,
                             IOCTL_DISK_CLUSTER_STOP_RESERVE,
                             NULL,
                             0,
                             NULL,
                             0,
                             &bytesReturned,
                             FALSE);

    if (!success)
    {
       printf( "Error performing StopReserve; error was %d\n",
          errorCode = GetLastError());
       PrintError(errorCode);
       return errorCode;
    }

    return ERROR_SUCCESS;
}


static DWORD
Active(
    HANDLE fileHandle,
    int argc,
    char *argv[]
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD   errorCode, bytesReturned;
    DWORD   signatures[100];
    DWORD   number;
    DWORD   i;

    if (argc != 0)
    {
        printf( "usage: <device> Active\n" );
        return ERROR_INVALID_NAME;
    }
    
    success = DeviceIoControl(fileHandle,
                             IOCTL_DISK_CLUSTER_ACTIVE,
                             NULL,
                             0,
                             signatures,
                             sizeof(signatures),
                             &bytesReturned,
                             FALSE);

    if (!success)
    {
       printf( "Error performing active; error was %d\n",
          errorCode = GetLastError());
       PrintError(errorCode);
       return errorCode;
    }

    printf("   List of signatures:\n\n");

    number = signatures[0];
    for ( i = 1; i <= number; i++ ) {
        printf("\t%08lX\n", signatures[i]);
    }
    printf("\n");

    return ERROR_SUCCESS;
}


static DWORD
Reserve(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode, bytesReturned;
    SCSI_PASS_THROUGH scsiBlock;
   
    if (argc != 0)
    {
        printf( "usage: <device> Reserve\n" );
        return ERROR_INVALID_NAME;
    }
    
    scsiBlock.PathId = 1;
    scsiBlock.TargetId = 3;
    scsiBlock.Lun = 0;
    scsiBlock.Length = sizeof(SCSI_PASS_THROUGH);

    success = DeviceIoControl(fileHandle,
                             IOCTL_DISK_RESERVE,
                             &scsiBlock,
                             sizeof(SCSI_PASS_THROUGH),
                             &scsiBlock,
                             sizeof(SCSI_PASS_THROUGH),
                             &bytesReturned,
                             FALSE);

    errorCode = GetLastError();
    if ( errorCode == ERROR_NOT_READY ) {
        success = DeviceIoControl(fileHandle,
                                  IOCTL_DISK_CLUSTER_RESERVE,
                                  &scsiBlock,
                                  sizeof(SCSI_PASS_THROUGH),
                                  &scsiBlock,
                                  sizeof(SCSI_PASS_THROUGH),
                                  &bytesReturned,
                                  FALSE);
    }
    if (!success) {
       errorCode = GetLastError();
       printf( "Error performing reserve; error was %d\n",
          errorCode);
       PrintError(errorCode);
       return errorCode;
    }

    return ERROR_SUCCESS;

} // Reserve


static DWORD
Release(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode, bytesReturned;
    SCSI_PASS_THROUGH scsiBlock;
   
    if (argc != 0)
    {
        printf( "usage: <device> Release\n" );
        return ERROR_INVALID_NAME;
    }
    
    scsiBlock.PathId = 1;
    scsiBlock.TargetId = 3;
    scsiBlock.Lun = 0;
    scsiBlock.Length = sizeof(SCSI_PASS_THROUGH);

    success = DeviceIoControl(fileHandle,
                             IOCTL_DISK_RELEASE,
                             &scsiBlock,
                             sizeof(SCSI_PASS_THROUGH),
                             &scsiBlock,
                             sizeof(SCSI_PASS_THROUGH),
                             &bytesReturned,
                             FALSE);

    if (!success)
    {
       printf( "Error performing release; error was %d\n",
          errorCode = GetLastError());
       PrintError(errorCode);
       return errorCode;
    }

    return ERROR_SUCCESS;

} // Release


static DWORD
Online(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode, bytesReturned;
    UCHAR newState;
    UCHAR oldState;
   
    if (argc != 0)
    {
        printf( "usage: <device> Online\n" );
        return ERROR_INVALID_NAME;
    }
    
    newState = DiskOnline;

    success = DeviceIoControl(fileHandle,
                             IOCTL_DISK_CLUSTER_SET_STATE,
                             &newState,
                             sizeof(newState),
                             &oldState,
                             sizeof(oldState),
                             &bytesReturned,
                             FALSE);

    if (!success)
    {
       printf( "Error performing Online; error was %d\n",
          errorCode = GetLastError());
       PrintError(errorCode);
       return errorCode;
    }

    return ERROR_SUCCESS;

} // Online


static DWORD
Offline(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL  success;
    DWORD errorCode;
    DWORD newState;
    DWORD oldState;
    DWORD bytesReturned;
   
    if (argc != 0)
    {
        printf( "usage: <device> Offline\n" );
        return ERROR_INVALID_NAME;
    }
    
    newState = DiskOffline;

    success = DeviceIoControl(fileHandle,
                             IOCTL_DISK_CLUSTER_SET_STATE,
                             &newState,
                             sizeof(newState),
                             &oldState,
                             sizeof(oldState),
                             &bytesReturned,
                             FALSE);

    if (!success)
    {
       printf( "Error performing Offline; error was %d\n",
          errorCode = GetLastError());
       PrintError(errorCode);
       return errorCode;
    }

    return ERROR_SUCCESS;

} // Offline



DWORD
Claim(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL  success;
    DWORD errorCode;
    DWORD bytesReturned;
   
    if (argc != 0)
    {
        printf( "usage: <device> Claim \n" );
        return ERROR_INVALID_NAME;
    }
    
    success = DeviceIoControl(fileHandle,
                             IOCTL_PARTMGR_CHECK_UNCLAIMED_PARTITIONS,
                             NULL,
                             0,
                             NULL,
                             0,
                             &bytesReturned,
                             FALSE);

    if (!success)
    {
       printf( "Error performing Claim; error was %d\n",
          errorCode = GetLastError());
       PrintError(errorCode);
       return errorCode;
    }

    return ERROR_SUCCESS;

} // Claim


DWORD
EjectVolumes(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL  success;
    DWORD errorCode;
    DWORD bytesReturned;
   
    if (argc != 0)
    {
        printf( "usage: <PhysicalDriveX> EjectVolumes \n" );
        return ERROR_INVALID_NAME;
    }
    
    success = DeviceIoControl(fileHandle,
                             IOCTL_PARTMGR_EJECT_VOLUME_MANAGERS,
                             NULL,
                             0,
                             NULL,
                             0,
                             &bytesReturned,
                             FALSE);

    if (!success)
    {
       printf( "Error performing EjectVolumes; error was %d\n",
          errorCode = GetLastError());
       PrintError(errorCode);
       return errorCode;
    }

    return ERROR_SUCCESS;

} // EjectVolumes


DWORD
EnumMounts(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL  success;
    DWORD status;
    DWORD bytesReturned;
    HANDLE handle;
    HANDLE mHandle;
    DWORD i;
    DWORD signature;
    UCHAR uniqueId[MAX_PATH];
    DWORD idLength;
    STRING ansiString;
    UNICODE_STRING numberString;
    UCHAR volumeName[MAX_PATH];
    UCHAR driveLetter;

    if (argc > 1)
    {
        printf( "usage: <any_device> EnumMounts [signature]\n" );
        return ERROR_INVALID_NAME;
    }

    if ( argc == 1 ) {
        RtlInitAnsiString( &ansiString, *argv );

        printf(" Ansi string for signature is %s\n",
                 ansiString.Buffer );

        RtlAnsiStringToUnicodeString(
                            &numberString,
                            &ansiString,
                            TRUE );

        status = RtlUnicodeStringToInteger(
                        &numberString,
                        16,
                        &signature );

        RtlFreeUnicodeString( &numberString );

        if ( !NT_SUCCESS(status) ) {
            printf( "Error converting signature to hex number, NT status %u.\n",
                    status );
            return(status);
        }
    } else {
        signature = 0;
    }

    status = DevfileOpen( &mHandle, MOUNTMGR_DEVICE_NAME );
    if ( status != ERROR_SUCCESS ) {
        printf( "DevfileOpen failed for %s, status = %u\n",
            MOUNTMGR_DEVICE_NAME, status );
        return status;
    }

    idLength = MAX_PATH;
    status = FindFirstVolumeForSignature( mHandle,
                                          signature,
                                          volumeName,
                                          MAX_PATH,
                                          &handle,
                                          uniqueId,
                                          &idLength,
                                          &driveLetter );
    if ( status != ERROR_SUCCESS ) {
        DevfileClose( mHandle );
        if ( status == ERROR_NO_MORE_FILES ) {
            status = ERROR_SUCCESS;
        } else {
            printf( "FindFirstVolume failed, status = %u\n", status );
        }
        return status;
    }

    i = 1;
    while ( status == ERROR_SUCCESS ) {

        printf( "Found match for volume %s\n", volumeName );

        i++;
        idLength = MAX_PATH;
        status = FindNextVolumeForSignature( mHandle,
                                             signature,
                                             handle,
                                             volumeName,
                                             MAX_PATH,
                                             uniqueId,
                                             &idLength,
                                             &driveLetter );
    }

    FindVolumeClose( handle );
    DevfileClose( mHandle );

    return ERROR_SUCCESS;

} // EnumMounts


DWORD
EnumExtents(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL    success;
    DWORD   status;
    DWORD   bytesReturned;
    DWORD   diskExtentSize;
    PVOLUME_DISK_EXTENTS diskExtents;
    DWORD   i;

    if (argc != 0)
    {
        printf( "usage: <device> EnumExtents\n" );
        return ERROR_INVALID_NAME;
    }

    diskExtentSize = sizeof(VOLUME_DISK_EXTENTS);
    diskExtents = LocalAlloc( LMEM_FIXED, diskExtentSize);
    if ( !diskExtents ) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Get volume information for disk extents.
    //
    success = DeviceIoControl( fileHandle,
                               IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                               NULL,
                               0,
                               diskExtents,
                               diskExtentSize,
                               &bytesReturned,
                               FALSE );
    status = GetLastError();

    if ( !success ) {
        if ( status == ERROR_MORE_DATA ) {
            diskExtentSize = sizeof(VOLUME_DISK_EXTENTS) +
                             (sizeof(DISK_EXTENT) * diskExtents->NumberOfDiskExtents);
            LocalFree( diskExtents );
            diskExtents = LocalAlloc( LMEM_FIXED, diskExtentSize);
            if ( !diskExtents ) {
                return(ERROR_NOT_ENOUGH_MEMORY);
            }

            status = ERROR_SUCCESS;
            success = DeviceIoControl( fileHandle,
                                   IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                                   NULL,
                                   0,
                                   diskExtents,
                                   diskExtentSize,
                                   &bytesReturned,
                                   FALSE );
            if ( !success ) {
                status = GetLastError();
            }
        }
    }

    printf( "\n  Starting offset                Length             DiskNumber\n");
    printf( "  ---------------                ------             ----------\n");
    for ( i = 0; i < diskExtents->NumberOfDiskExtents; i++ ) {
        printf( " %08lx %08lx\t\t%08lx\t\t%u\n",
                 diskExtents->Extents[i].StartingOffset.HighPart,
                 diskExtents->Extents[i].StartingOffset.LowPart,
                 diskExtents->Extents[i].ExtentLength.LowPart,
                 diskExtents->Extents[i].DiskNumber );
    }

    return status;

} // EnumExtents



DWORD
EnumNodes(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL        success;
    DWORD       status;
    HDEVINFO    hDevInfo;
    SP_DEVINFO_DATA devInfoData;
    DWORD       index;
    DWORD       size;
    LPDWORD     dwGuid;
    UCHAR       devDesc[MAX_PATH];
    UCHAR       devID[MAX_PATH];


    hDevInfo = SetupDiGetClassDevs( NULL,
                                    NULL,
                                    NULL,
                                    DIGCF_ALLCLASSES | DIGCF_PRESENT );

    if ( hDevInfo == INVALID_HANDLE_VALUE ) {
        status = GetLastError();
        printf( "SetupDiGetClassDevs failed with error %u\n", status );
        return status;
    }

    memset( &devInfoData, 0, sizeof(SP_DEVINFO_DATA));
    devInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    //
    // First see if anything works...
    //
    success = SetupDiEnumDeviceInfo( hDevInfo, 0, &devInfoData );
    if ( !success ) {
        status = GetLastError();
        printf( "SetupDiEnumDeviceInfo failed, status = %u\n", status );
        return status;
    }

    index = 0;
    while ( SetupDiEnumDeviceInfo( hDevInfo, index, &devInfoData ) ) {
        devDesc[0] = '\0';
        size = sizeof(devDesc);
        printf( "Index = %u\n", index );
        if ( CM_Get_DevNode_Registry_Property( devInfoData.DevInst,
                                               CM_DRP_DEVICEDESC,
                                               NULL,
                                               devDesc,
                                               &size,
                                               0 ) == 0 ) {
            printf( "Device description = %s\n", devDesc );
            dwGuid = (LPDWORD)&devInfoData.ClassGuid;
            printf( "   GUID = %lx, %lx, %lx, %lx\n", dwGuid[0], dwGuid[1], dwGuid[2], dwGuid[3] );
            devID[0] = '\0';
            CM_Get_Device_ID( devInfoData.DevInst,
                              devID,
                              sizeof(devID),
                              0 );
            if ( devID[0] ) {
                printf( "   Device Id = %s\n", devID );
            }
        }

        index++;
    }

    return ERROR_SUCCESS;

} // EnumNodes



DWORD
EnumDisks(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD status;
    BOOL  success;
    HDEVINFO DeviceInfoSet;
    SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;
    DWORD i;
    PSP_DEVICE_INTERFACE_DETAIL_DATA_W DeviceInterfaceDetailData = NULL;
    DWORD DeviceInterfaceDetailDataSize = 0;
    DWORD RequiredSize;
    SP_DEVINFO_DATA DeviceInfoData;
    SP_PROPCHANGE_PARAMS PropChangeParams;
    BOOL disable = FALSE;
    BOOL parent = FALSE;
    //GUID mountDevGuid;
    GUID diskDevGuid;
    HANDLE devHandle;
    UCHAR driveLayoutBuf[sizeof(DRIVE_LAYOUT_INFORMATION) +
                        (sizeof(PARTITION_INFORMATION) * 64 )];
    PDRIVE_LAYOUT_INFORMATION driveLayout = (PDRIVE_LAYOUT_INFORMATION)driveLayoutBuf;

    if (argc > 1)
    {
        printf( "usage: <any_device> EnumDisks [DISABLE | PARENT]\n" );
        return ERROR_INVALID_NAME;
    }

    if ( argc == 1 ) {
        if (!_stricmp( *argv, "Disable" ))
            disable = TRUE;
        else if (!_stricmp( *argv, "Parent" ))
            parent = TRUE;
        else {
            printf( "usage: <any_device> EnumDisks [DISABLE | PARENT]\n" );
            return ERROR_INVALID_NAME;
        }
    }

    memcpy( &diskDevGuid, &DiskClassGuid, sizeof(GUID) );
    //memcpy( &mountDevGuid, &MOUNTDEV_MOUNTED_DEVICE_GUID, sizeof(GUID) );

    DeviceInfoSet = SetupDiGetClassDevs(&diskDevGuid,
                                        NULL,
                                        NULL,
                                        DIGCF_DEVICEINTERFACE | DIGCF_PRESENT
                                       );

    DeviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

    for(i = 0;
        SetupDiEnumDeviceInterfaces(DeviceInfoSet,
                                    NULL,
                                    &diskDevGuid,
                                    i,
                                    &DeviceInterfaceData);
        i++) {

        //
        // To retrieve the device interface name (e.g., that you can call
        // CreateFile() on...
        //
        while(!SetupDiGetDeviceInterfaceDetailW(DeviceInfoSet,
                                               &DeviceInterfaceData,
                                               DeviceInterfaceDetailData,
                                               DeviceInterfaceDetailDataSize,
                                               &RequiredSize,
                                               &DeviceInfoData) ) {
            //
            // We failed to get the device interface detail data--was it because
            // our buffer was too small? (Hopefully so!)
            //
            status = GetLastError();
            //printf("Call to SetupDiGetDeviceInterfaceData failed status = %u, required size = %u\n",
            //    status, RequiredSize);

            // Free our current buffer since we failed anyway.
            free(DeviceInterfaceDetailData);
            DeviceInterfaceDetailData = NULL;

            if(status != ERROR_INSUFFICIENT_BUFFER) {
                //
                // Failure!
                //
                break;
            }

            DeviceInterfaceDetailData = malloc(RequiredSize);
            if(DeviceInterfaceDetailData) {
                DeviceInterfaceDetailDataSize = RequiredSize;
                DeviceInterfaceDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_W);
            } else {
                //
                // Failure!
                //
                DeviceInterfaceDetailDataSize = 0;
                break;
            }
        }

        if(!DeviceInterfaceDetailData) {
            //
            // We encountered a failure above--abort.
            //
            break;
        }

        //
        // Now we may use the device interface name contained in the
        // DeviceInterfaceDetailData->DevicePath field (e.g., in a call to
        // CreateFile).
        //
    
        printf("DevicePath = %ws\n", DeviceInterfaceDetailData->DevicePath );
        devHandle = CreateFileW( DeviceInterfaceDetailData->DevicePath,
                                 GENERIC_READ,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                                 NULL,
                                 OPEN_EXISTING,
                                 0,
                                 NULL );

        if ( devHandle != INVALID_HANDLE_VALUE ) {
            // Get signature
            success = DeviceIoControl( devHandle,
                            IOCTL_DISK_GET_DRIVE_LAYOUT,
                            NULL,
                            0,
                            driveLayout,
                            sizeof(driveLayoutBuf),
                            &RequiredSize,
                            FALSE );
            if ( success ) {
                printf( " Signature for device = %08lx\n", driveLayout->Signature );
            }
            CloseHandle( devHandle );
        }

        //
        // To open up the persistent storage registry key associated with this
        // device interface (e.g., to retrieve it's FriendlyName value entry),
        // use SetupDiCreateDeviceInterfaceRegKey or
        // SetupDiOpenDeviceInterfaceRegKey.
        //

        //
        // Notice that we retrieved the associated device information element
        // in the above call to SetupDiGetDeviceInterfaceDetail.  We can thus
        // use this element in setupapi calls to effect changes to the devnode
        // (including invoking the class installer and any co-installers that
        // may be involved).
        //
        // For example, here's how we'd disable the device...
        //

        if ( disable ) {
            // Perform following only if we are supposed to disable

#ifdef PERSISTENT
        PropChangeParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
        PropChangeParams.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
        PropChangeParams.StateChange = DICS_DISABLE;
        PropChangeParams.Scope = DICS_FLAG_GLOBAL;
        //
        // No need to set PropChangeParams.HwProfile since we're doing global
        // property change.
        //
        if( !SetupDiSetClassInstallParamsW(DeviceInfoSet,
                                     &DeviceInfoData,
                                     (PSP_CLASSINSTALL_HEADER)&PropChangeParams,
                                     sizeof(PropChangeParams)
                                    ) ) {
            status = GetLastError();
            printf( "SetupDiSetClassInstallParams failed with %u\n", status );
            continue;
        }

        if ( !SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,
                                  DeviceInfoSet,
                                  &DeviceInfoData
                                 ) ) {
            status = GetLastError();
            printf( "SetupDiCallClassInstaller failed with %u\n", status );
            continue;
        }

        printf("Disabled!\n");
        getchar();

        //
        // ...and here's how we'd re-enable it...
        //
        PropChangeParams.StateChange = DICS_ENABLE;
        if ( !SetupDiSetClassInstallParamsW(DeviceInfoSet,
                                     &DeviceInfoData,
                                     (PSP_CLASSINSTALL_HEADER)&PropChangeParams,
                                     sizeof(PropChangeParams)
                                    ) ) {
            status = GetLastError();
            printf( "SetupDiSetClassInstallParams failed with %u\n", status );
            continue;
        }

        if ( !SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,
                                  DeviceInfoSet,
                                  &DeviceInfoData
                                 ) ) {
            status = GetLastError();
            printf( "SetupDiCallClassInstaller failed with %u\n", status );
       }
#else
#if 0 // we don't support multiple switches together - this would need disable
      // and parent set together!
        //
        // Try to find parent
        //
        if ( parent ) {
            status = CM_Get_Parent( parentDev,
                                    DeviceInfoData.DevInst,
                                    0 );
            if ( status != ERROR_SUCCESS ) {
                printf( "CM_Get_Parent failed with %u\n", status );
                continue;
            }
        }
#endif
        //
        // NOTE:  The code above does a persistent disable/enable.  If you only
        // wanted this to be temporary (i.e., in effect till reboot), then you
        // could retrieve the devnode handle from the DeviceInfoData.DevInst
        // field and call CM_Disable_DevNode and CM_Enable_DevNode directly.
        //
        status = CM_Disable_DevNode( DeviceInfoData.DevInst, 0 );
        if ( status != ERROR_SUCCESS ) {
            printf( "CM_Disable_DevNode failed with %u\n", status );
            continue;
        }

        printf("Disabled!\n");
        getchar();

        status = CM_Enable_DevNode( DeviceInfoData.DevInst, 0 );
        if ( status != ERROR_SUCCESS ) {
            printf( "CM_Enable_DevNode failed with %u\n", status );
        }
#endif //PERSISTENT

        } else { // If we are supposed to disable the disk
          //
          // Try to find parent
          //
          if ( parent ) {
            DEVINST parentDev;
            DEVINST pParentDev = 0;
            WCHAR   outBuffer[MAX_PATH];
            HDEVINFO devInfoSet;
            SP_DEVINFO_DATA devInfoData;
            SP_DEVICE_INTERFACE_DATA devInterfaceData;

          do {
            status = CM_Get_Parent( &parentDev,
                                    DeviceInfoData.DevInst,
                                    0 );
            if ( status != ERROR_SUCCESS ) {
                printf( "CM_Get_Parent failed with %u\n", status );
                break;
            }

            if ( pParentDev == parentDev ) {
                break;
            }

            pParentDev = parentDev;
            status = CM_Get_Device_IDW( parentDev,
                                        outBuffer,
                                        sizeof(outBuffer)/sizeof(WCHAR),
                                        0 );

            if ( status != ERROR_SUCCESS ) {
                printf( "CM_Get_Parent failed with %u\n", status );
                //status = ERROR_SUCCESS;
            } else {
                printf( "    ParentDev = %ws\n", outBuffer );
            }
          } while ( status == ERROR_SUCCESS );
          }

        }
    }

    SetupDiDestroyDeviceInfoList(DeviceInfoSet);

    return ERROR_SUCCESS;

} // EnumDisks



DWORD
DisableNode(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL        success;
    DWORD       status;
    HDEVINFO    hDevInfo;
    GUID        devClassDisk;
    SP_DEVINFO_DATA devInfoData;
    DWORD       index;
    DWORD       size;
    LPDWORD     dwGuid;
    UCHAR       devDesc[MAX_PATH];
    UCHAR       devID[MAX_PATH];


    printf( "Not supported yet\n");
    return ERROR_SUCCESS;

} // DisableNode


DWORD
EnableNode(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL        success;
    DWORD       status;
    HDEVINFO    hDevInfo;
    GUID        devClassDisk;
    SP_DEVINFO_DATA devInfoData;
    DWORD       index;
    DWORD       size;
    LPDWORD     dwGuid;
    UCHAR       devDesc[MAX_PATH];
    UCHAR       devID[MAX_PATH];


    printf( "Not supported yet\n");
    return ERROR_SUCCESS;

} // EnableNode


DWORD
DisableDisk(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL        success;
    DWORD       status;
    HDEVINFO    hDevInfo;
    GUID        devClassDisk;
    SP_DEVINFO_DATA devInfoData;
    DWORD       index;
    DWORD       size;
    LPDWORD     dwGuid;
    UCHAR       devDesc[MAX_PATH];
    UCHAR       devID[MAX_PATH];


    printf( "Not supported yet\n");
    return ERROR_SUCCESS;

} // DisableDisk


DWORD
EnableDisk(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL        success;
    DWORD       status;
    HDEVINFO    hDevInfo;
    GUID        devClassDisk;
    SP_DEVINFO_DATA devInfoData;
    DWORD       index;
    DWORD       size;
    LPDWORD     dwGuid;
    UCHAR       devDesc[MAX_PATH];
    UCHAR       devID[MAX_PATH];


    printf( "Not supported yet\n");
    return ERROR_SUCCESS;

} // EnableDisk



DWORD
HoldIO(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode;
    DWORD bytesReturned;

    if (argc != 0)
    {
        printf( "usage: <device> HoldIO\n" );
        return ERROR_INVALID_NAME;
    }

    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_CLUSTER_HOLD_IO,
                               NULL,
                               0,
                               NULL,
                               0,
                               &bytesReturned,
                               FALSE );

    if (!success) {
        printf( "Error performing Hold IO, error %d\n",
          errorCode = GetLastError());
        PrintError(errorCode);
        return errorCode;
    }

    return ERROR_SUCCESS;

} // HoldIO


DWORD
ResumeIO(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode;
    DWORD bytesReturned;

    if (argc != 0)
    {
        printf( "usage: <device> ResumeIO\n" );
        return ERROR_INVALID_NAME;
    }

    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_CLUSTER_RESUME_IO,
                               NULL,
                               0,
                               NULL,
                               0,
                               &bytesReturned,
                               FALSE );

    if (!success) {
        printf( "Error performing Resume IO, error %d\n",
          errorCode = GetLastError());
        PrintError(errorCode);
        return errorCode;
    }

    return ERROR_SUCCESS;

} // ResumeIO


DWORD
GetDiskGeometry(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode;
    DWORD bytesReturned;
    DISK_GEOMETRY diskGeometry;

    if (argc != 0)
    {
        printf( "usage: <device> GetDiskGeometry\n" );
        return ERROR_INVALID_NAME;
    }

    ZeroMemory( &diskGeometry, sizeof(DISK_GEOMETRY) );

    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_GET_DRIVE_GEOMETRY,
                               NULL,
                               0,
                               &diskGeometry,
                               sizeof(DISK_GEOMETRY),
                               &bytesReturned,
                               FALSE );

    if (!success) {
        printf( "Error performing GetDiskGeometry, error %d\n",
          errorCode = GetLastError());
        PrintError(errorCode);
        return errorCode;
    }

    if ( bytesReturned < sizeof(DISK_GEOMETRY) ) {
        printf("Error reading DiskGeometry information. Expected %u bytes, got %u bytes.\n",
            sizeof(DISK_GEOMETRY), 
            bytesReturned);
        return(ERROR_INSUFFICIENT_BUFFER);
    }

    printf("GetDiskGeometry was successful, we got %d bytes returned.\n",
            bytesReturned);

    printf("Cylinders = %lx%lx, TracksPerCylinder = %lx, SectorsPerTrack = %lx, BytesPerSector = %lx\n",

        diskGeometry.Cylinders.HighPart, diskGeometry.Cylinders.LowPart,
        diskGeometry.TracksPerCylinder, diskGeometry.SectorsPerTrack,
        diskGeometry.BytesPerSector);

    return ERROR_SUCCESS;

} // GetDiskGeometry


DWORD
GetScsiAddress(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode;
    DWORD bytesReturned;
    SCSI_ADDRESS scsiAddress;

    if (argc != 0)
    {
        printf( "usage: <device> GetScsiAddress\n" );
        return ERROR_INVALID_NAME;
    }

    ZeroMemory( &scsiAddress, sizeof(scsiAddress) );

    success = DeviceIoControl( fileHandle,
                               IOCTL_SCSI_GET_ADDRESS,
                               NULL,
                               0,
                               &scsiAddress,
                               sizeof(DISK_GEOMETRY),
                               &bytesReturned,
                               FALSE );

    if (!success) {
        printf( "Error performing GetScsiAddress, error %d\n",
          errorCode = GetLastError());
        PrintError(errorCode);
        return errorCode;
    }

    if ( bytesReturned < sizeof(scsiAddress) ) {
        printf("Error reading ScsiAddress information. Expected %u bytes, got %u bytes.\n",
            sizeof(scsiAddress), 
            bytesReturned);
        return(ERROR_INSUFFICIENT_BUFFER);
    }

    printf("GetScsiAddress was successful, we got %d bytes returned.\n",
            bytesReturned);

    printf("PortNumber = %x, PathId = %x, TargetId = %x, Lun = %x\n",

        scsiAddress.PortNumber, scsiAddress.PathId, 
        scsiAddress.TargetId, scsiAddress.Lun);

    return ERROR_SUCCESS;

} // GetScsiAddress


DWORD
GetDriveLayout(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode;
    DWORD bytesReturned;
    DWORD harddiskNo;
    DWORD i;
    PDRIVE_LAYOUT_INFORMATION driveLayout;
    PPARTITION_INFORMATION partInfo;

    if (argc != 0)
    {
        printf( "usage: <device> GetDriveLayout\n" );
        return ERROR_INVALID_NAME;
    }

    driveLayout = DoIoctlAndAllocate(fileHandle,
                                     IOCTL_DISK_GET_DRIVE_LAYOUT,
                                     NULL, 0, &bytesReturned);
    if (!driveLayout) {
        return GetLastError();
    }
    
    printf("GetDriveLayout was successful, %d bytes returned.\n",
            bytesReturned);

    printf("Partition Count = %u \n", driveLayout->PartitionCount);
    printf("Signature = %lx\n", driveLayout->Signature);

    printf("\n");
    printf("Part# Type Recog BootInd    PartOff      PartLeng    HidSect  Rewrite \n");
    printf("===== ==== ===== ======= ============  ============  =======  ======= \n");

    for (i = 0; i < driveLayout->PartitionCount; i++ ) {
        partInfo = &driveLayout->PartitionEntry[i];
        
        printf("  %2u   %2X    %1u      %1u    %12I64X  %12I64X  %7u   %s \n",
            partInfo->PartitionNumber,
            partInfo->PartitionType,
            partInfo->RecognizedPartition,
            partInfo->BootIndicator,
            partInfo->StartingOffset.QuadPart,
            partInfo->PartitionLength.QuadPart,
            partInfo->HiddenSectors,
            BooleanToString( partInfo->RewritePartition )
            );
    }

    free( driveLayout );

    return ERROR_SUCCESS;

} // GetDriveLayout


DWORD
GetDriveLayoutEx(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    PDRIVE_LAYOUT_INFORMATION_EX    driveLayout = NULL;
    PPARTITION_INFORMATION_EX       partInfo;
    DWORD                           errorCode = NO_ERROR;
    DWORD                           bytesReturned;
    DWORD                           harddiskNo;
    DWORD                           idx;
    DWORD                           nameIdx;
    BOOL                            success;

    TCHAR                           strGuid[MAX_PATH];
    TCHAR                           strType[MAX_PATH];

    if ( argc != 0 ) {
        printf( "usage: <device> GetDriveLayoutEx \n" );
        errorCode = ERROR_INVALID_NAME;
        goto FnExit;
    }

    driveLayout = DoIoctlAndAllocate( fileHandle,
                                      IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                                      NULL, 0, &bytesReturned );
    if ( !driveLayout ) {
        errorCode = GetLastError();
        printf("IOCTL_DISK_GET_DRIVE_LAYOUT_EX failed: %u \n", errorCode);
        PrintError( errorCode );
        goto FnExit;
    }
    
    printf("GetDriveLayoutEx was successful: %d bytes returned.\n",
            bytesReturned);

    printf("Partition style = ");

    if ( PARTITION_STYLE_MBR == driveLayout->PartitionStyle ) {
        printf("MBR \n");
    } else if ( PARTITION_STYLE_GPT == driveLayout->PartitionStyle ) {
        printf("GPT \n");
    } else if ( PARTITION_STYLE_RAW == driveLayout->PartitionStyle ) {
        printf("RAW \n");
        goto FnExit;
    } else {
        printf("Unknown \n");
        goto FnExit;
    }

    printf("Partition Count = %u \n", driveLayout->PartitionCount);

    if ( PARTITION_STYLE_MBR == driveLayout->PartitionStyle ) {
    
        printf("Signature = %lx \n", driveLayout->Mbr.Signature);

        printf("\n");
        printf("Part# Type Recog BootInd    PartOff      PartLeng    HidSect  Rewrite \n");
        printf("===== ==== ===== ======= ============  ============  =======  ======= \n");

        for ( idx = 0; idx < driveLayout->PartitionCount; idx++ ) {
            partInfo = &driveLayout->PartitionEntry[idx];

            if ( PARTITION_STYLE_MBR != partInfo->PartitionStyle ) {
                printf("Skipping partition: style is not MBR (%u) \n", partInfo->PartitionStyle);
                continue;
            }
            
            printf("  %2u   %2X    %1u      %1u    %12I64X  %12I64X  %7u   %s \n",
                   partInfo->PartitionNumber,
                   partInfo->Mbr.PartitionType,
                   partInfo->Mbr.RecognizedPartition,
                   partInfo->Mbr.BootIndicator,
                   partInfo->StartingOffset.QuadPart,
                   partInfo->PartitionLength.QuadPart,
                   partInfo->Mbr.HiddenSectors,
                   BooleanToString( partInfo->RewritePartition )
                   );
        }

    } else {

        FormatGuid( &(driveLayout->Gpt.DiskId), strGuid );
        printf("Signature (GUID)   = %s \n", strGuid );
        printf("Signature (hashed) = %08x \n", ClusterHashGuid( driveLayout->Gpt.DiskId ) ); 

        printf("\n");
        printf("Part#       PartOff          PartLeng       Rewrite \n");
        printf("=====  ================  ================   ======= \n");

        for ( idx = 0; idx < driveLayout->PartitionCount; idx++ ) {
            partInfo = &driveLayout->PartitionEntry[idx];
            
            if ( idx ) {
                printf("\n");
            }
            
            if ( PARTITION_STYLE_GPT != partInfo->PartitionStyle ) {
                printf("Skipping partition: style is not GPT (%u) \n", partInfo->PartitionStyle);
                continue;
            }
                        
            printf("  %2u   %16I64X  %16I64X   %s \n",
                   partInfo->PartitionNumber,
                   partInfo->StartingOffset.QuadPart,
                   partInfo->PartitionLength.QuadPart,
                   BooleanToString( partInfo->RewritePartition )
                   );

            FormatGuid( &(partInfo->Gpt.PartitionType), strGuid);
            if ( !memcmp( &(partInfo->Gpt.PartitionType), &PARTITION_SYSTEM_GUID, sizeof(GUID) ) ) {
                sprintf(strType, "System");
            } else if ( !memcmp( &(partInfo->Gpt.PartitionType), &PARTITION_MSFT_RESERVED_GUID, sizeof(GUID) ) ) {
                sprintf(strType, "Microsoft Reserved");
            } else if ( !memcmp( &(partInfo->Gpt.PartitionType), &PARTITION_BASIC_DATA_GUID, sizeof(GUID) ) ) {
                sprintf(strType, "Basic Data");
            } else if ( !memcmp( &(partInfo->Gpt.PartitionType), &PARTITION_LDM_METADATA_GUID, sizeof(GUID) ) ) {
                sprintf(strType, "LDM Metadata");
            } else if ( !memcmp( &(partInfo->Gpt.PartitionType), &PARTITION_LDM_DATA_GUID, sizeof(GUID) ) ) {
                sprintf(strType, "LDM Data");
#if PARTITION_CLUSTER_GUID
            } else if ( !memcmp( &(partInfo->Gpt.PartitionType), &PARTITION_CLUSTER_GUID, sizeof(GUID) ) ) {
                sprintf(strType, "Cluster Data");
#endif
            } else {
                sprintf(strType, "Unknown partition type");
            }

            printf("\n");
            printf("     PartitionType = %s \n", strGuid);
            printf("                     %s \n", strType);

            FormatGuid(&(partInfo->Gpt.PartitionId), strGuid);
            printf("     PartitionId   = %s \n", strGuid);

            printf("     Attributes    = %I64X \n", partInfo->Gpt.Attributes);
            
            printf("     Name: ");                    
            for ( nameIdx = 0; nameIdx < 36; nameIdx++ ) {

                printf("%c", partInfo->Gpt.Name[nameIdx]);
            }
            printf("\n");                
            
        }

    }


FnExit:

    free( driveLayout );

    return ERROR_SUCCESS;

}   // GetDriveLayoutEx


LPTSTR
BooleanToString(
    BOOLEAN Value
    )
{
    if ( Value ) {
        return "TRUE ";
    }

    return "FALSE";

}   // BooleanToString



void
FormatGuid(
    GUID*   Guid,
    char*   Str
    )
{
    //
    //  Code from guidgen
    //

    sprintf(Str, "{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            // first copy...
            Guid->Data1, Guid->Data2, Guid->Data3,
            Guid->Data4[0], Guid->Data4[1], Guid->Data4[2], Guid->Data4[3],
            Guid->Data4[4], Guid->Data4[5], Guid->Data4[6], Guid->Data4[7]);
}


DWORD
GetVolumeInfo(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode;
    PCLUSPROP_PARTITION_INFO partInfo;
    ANSI_STRING ansiName;
    UNICODE_STRING unicodeName;
    NTSTATUS ntStatus;

    if (argc != 0) {
        printf( "usage: <device> GetVolumeInfo\n" );
        return ERROR_INVALID_NAME;
    }

    ntStatus = GetVolumeInformationFromHandle(fileHandle);
    if ( !NT_SUCCESS(ntStatus) ) {
       errorCode = RtlNtStatusToDosError( ntStatus );
       printf( "GetVolumeInformationFromHandle failed with status %X, %u\n", 
               ntStatus, errorCode );
    }

    partInfo = LocalAlloc( LMEM_FIXED, sizeof(CLUSPROP_PARTITION_INFO) );

    if ( !partInfo ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ZeroMemory( partInfo, sizeof(CLUSPROP_PARTITION_INFO) );

    RtlInitString(&ansiName, DeviceName);
    errorCode = RtlAnsiStringToUnicodeString( &unicodeName,
                                              &ansiName,
                                              TRUE );
    if ( !NT_SUCCESS(errorCode) ) {
        return(errorCode);
    }

    // The following assumes a drive letter is used.
    // wsprintfW( partInfo->szDeviceName, L"%c:\\", unicodeName.Buffer[0] );

    wcsncpy( partInfo->szDeviceName, unicodeName.Buffer, unicodeName.Length );
    
    RtlFreeUnicodeString( &unicodeName );

    if ( !GetVolumeInformationW( partInfo->szDeviceName,
                                partInfo->szVolumeLabel,
                                sizeof(partInfo->szVolumeLabel),
                                &partInfo->dwSerialNumber,
                                &partInfo->rgdwMaximumComponentLength,
                                &partInfo->dwFileSystemFlags,
                                partInfo->szFileSystem,
                                sizeof(partInfo->szFileSystem) ) ) {
        partInfo->szVolumeLabel[0] = L'\0';
        errorCode = GetLastError();
        printf("Error reading volume information for %ws. Error %u.\n",
                partInfo->szDeviceName,
                errorCode);
        LocalFree( partInfo );
        return( errorCode );
    }

    printf("DeviceName = %ws\n", partInfo->szDeviceName);
    printf("VolumeLabel = %ws\n", partInfo->szVolumeLabel);
    printf("FileSystemFlags = %lx, FileSystem = %ws\n",
            partInfo->dwFileSystemFlags, partInfo->szFileSystem);

    LocalFree( partInfo );

    return ERROR_SUCCESS;

} // GetVolumeInfo


DWORD
SetDriveLayout(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode;
    DWORD bytesReturned;
    DWORD driveLayoutSize;
    PDRIVE_LAYOUT_INFORMATION driveLayout;
    PPARTITION_INFORMATION partInfo;
    DWORD index;
    DWORD partShift = 0;

    if (argc != 0)
    {
        printf( "usage: <device> SetDriveLayout\n" );
        return ERROR_INVALID_NAME;
    }

    driveLayoutSize = sizeof(DRIVE_LAYOUT_INFORMATION) +
                      (sizeof(PARTITION_INFORMATION) * MAX_PARTITIONS);

    driveLayout = LocalAlloc( LMEM_FIXED, driveLayoutSize );

    if ( !driveLayout ) {
        return(ERROR_OUTOFMEMORY);
    }

    ZeroMemory( driveLayout, driveLayoutSize );

    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_GET_DRIVE_LAYOUT,
                               NULL,
                               0,
                               driveLayout,
                               driveLayoutSize,
                               &bytesReturned,
                               FALSE );

    if (!success) {
        printf( "Error performing GetDriveLayout; error was %d\n",
          errorCode = GetLastError());
        PrintError(errorCode);
        LocalFree( driveLayout );
        return errorCode;
    }

    driveLayoutSize = sizeof(DRIVE_LAYOUT_INFORMATION) +
                      (sizeof(PARTITION_INFORMATION) *
                      (driveLayout->PartitionCount - 1));

    if ( bytesReturned < driveLayoutSize ) {
        printf("Error reading DriveLayout information. Expected %u bytes, got %u bytes.\n",
            sizeof(DRIVE_LAYOUT_INFORMATION) + (sizeof(PARTITION_INFORMATION) *
            (driveLayout->PartitionCount - 1)), bytesReturned);
        LocalFree( driveLayout );
        return(ERROR_INSUFFICIENT_BUFFER);
    }

    if ( driveLayout->PartitionCount > MAX_PARTITIONS ) {
        printf("SetDriveLayout, exiting - too many partitions!\n");
        LocalFree( driveLayout );
        return(ERROR_TOO_MANY_LINKS);
    }

    for ( index = 0;
          (index < driveLayout->PartitionCount) &&
          (index < MAX_PARTITIONS );
          index++ ) {
        partInfo = &driveLayout->PartitionEntry[index];
        if ( (partInfo->PartitionType == PARTITION_ENTRY_UNUSED) ||
             !partInfo->RecognizedPartition ) {
            continue;
        }

        if ( (index == 0) &&
             (partInfo->PartitionNumber == 0) ) {
            partShift = 1;
        }
        printf("Partition %u was %s\n", partInfo->PartitionNumber, (partShift? "incremented" : "left alone"));
        partInfo->PartitionNumber += partShift;
    }

    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_SET_DRIVE_LAYOUT,
                               driveLayout,
                               driveLayoutSize,
                               NULL,
                               0,
                               &bytesReturned,
                               FALSE );

    if ( !success ) {
        printf("Error performing SetDriveLayout, error %u.\n",
            errorCode = GetLastError());
        PrintError(errorCode);
        LocalFree( driveLayout );
        return(errorCode);
    }

    LocalFree( driveLayout );

    printf("SetDriveLayout was successful. Set %d bytes.\n", driveLayoutSize);

    return ERROR_SUCCESS;

} // SetDriveLayout



static DWORD
Attach(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode;
    DWORD bytesReturned;
    DWORD signature;
    STRING ansiString;
    UNICODE_STRING numberString;

    if (argc != 1)
    {
        printf( "usage: <device> Attach <device signature>\n" );
        return ERROR_INVALID_NAME;
    }

    RtlInitAnsiString( &ansiString, *argv );

    printf(" Ansi string for signature is %s\n",
             ansiString.Buffer );

    RtlAnsiStringToUnicodeString(
                            &numberString,
                            &ansiString,
                            TRUE );

    errorCode = RtlUnicodeStringToInteger(
                            &numberString,
                            16,
                            &signature );

    RtlFreeUnicodeString( &numberString );

    if ( !NT_SUCCESS(errorCode) ) {
        printf( "Error converting signature to hex number, NT status %u.\n",
                errorCode );
        return(errorCode);
    }

    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_CLUSTER_ATTACH,
                               &signature,
                               sizeof(DWORD),
                               NULL,
                               0,
                               &bytesReturned,
                               FALSE );

    if (!success) {
        printf( "Error performing ATTACH, error was %d\n",
          errorCode = GetLastError());
        PrintError(errorCode);
        return errorCode;
    }

    return ERROR_SUCCESS;

} // Attach



static DWORD
Detach(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode;
    DWORD bytesReturned;
    DWORD signature;
    STRING ansiString;
    UNICODE_STRING numberString;

    if (argc != 1)
    {
        printf( "usage: <device> Detach <device signature>\n" );
        return ERROR_INVALID_NAME;
    }

    RtlInitAnsiString( &ansiString, *argv );

    printf(" Ansi string for signature is %s\n",
             ansiString.Buffer );

    RtlAnsiStringToUnicodeString(
                            &numberString,
                            &ansiString,
                            TRUE );

    errorCode = RtlUnicodeStringToInteger(
                            &numberString,
                            16,
                            &signature );

    RtlFreeUnicodeString( &numberString );

    if ( !NT_SUCCESS(errorCode) ) {
        printf( "Error converting signature to hex number, NT status %u.\n",
                errorCode );
        return(errorCode);
    }

    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_CLUSTER_DETACH,
                               &signature,
                               sizeof(DWORD),
                               NULL,
                               0,
                               &bytesReturned,
                               FALSE );

    if (!success) {
        printf( "Error performing DETACH, error was %d\n",
          errorCode = GetLastError());
        PrintError(errorCode);
        return errorCode;
    }

    return ERROR_SUCCESS;

} // Detach



static DWORD
GetPartitionInfo(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode;
    DWORD bytesReturned;
    PARTITION_INFORMATION partInfo;

    if (argc != 0)
    {
        printf( "usage: <device> GetPartitionInfo\n" );
        return ERROR_INVALID_NAME;
    }

    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_GET_PARTITION_INFO,
                               NULL,
                               0,
                               &partInfo,
                               sizeof(PARTITION_INFORMATION),
                               &bytesReturned,
                               FALSE );

    if (!success) {
        printf( "Error performing GetPartitionInfo; error was %d\n",
          errorCode = GetLastError());
        PrintError(errorCode);
        return errorCode;
    }

    printf("GetPartitionInfo was successful, we got %d bytes returned.\n\n",
            bytesReturned);

    printf("Part# Type Recog BootInd      PartOff      PartLeng   HidSect\n");

#if 0
Part# Type Recog BootInd      PartOff      PartLeng   HidSect
  xx   xx    x      x    xxxxxxxxxxxx  xxxxxxxxxxxx   xxxxxxx
#endif
    printf("  %2u   %2X    %1u      %1u    %12I64X  %12I64X   %7u\n",
        partInfo.PartitionNumber,
        partInfo.PartitionType,
        partInfo.RecognizedPartition,
        partInfo.BootIndicator,
        partInfo.StartingOffset.QuadPart,
        partInfo.PartitionLength.QuadPart,
        partInfo.HiddenSectors);

    return ERROR_SUCCESS;

} // GetPartitionInfo



DWORD
AssignLetters(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD errorCode;
    LPSTR device;
    DISK_INFO diskInfo;
    DWORD count;

    if (argc != 0)
    {
        printf( "usage: <device> AssignLetters\n" );
        return ERROR_INVALID_NAME;
    }

    diskInfo.FileHandle = fileHandle;

    --argv;
    device = *--argv;
    count = sscanf( device, "physicaldrive%d", &diskInfo.PhysicalDrive ); 
    if ( count != 1 ) {
        printf("AssignLetters, failed to get device drive number for '%s', count %u.\n",
            device, count);
        return(ERROR_INVALID_PARAMETER);
    }

    errorCode = AssignDriveLetters( &diskInfo );

    return(errorCode);

} // AssignLetters



DWORD
RemoveLetters(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD errorCode = ERROR_SUCCESS;
    LPSTR device;
    DISK_INFO diskInfo;
    DWORD count;
    UCHAR fileName[MAX_PATH];
    UCHAR objectLink[MAX_PATH];
    DWORD length;
    DWORD partitionNumber;
    DWORD deviceNumber;
    DWORD maxPartitions = 8;
    DWORD bytesReturned;
    HANDLE FileHandle;

    if (argc != 0) {
        printf( "usage: <device> RemoveLetters\n" );
        return ERROR_INVALID_NAME;
    }

    diskInfo.FileHandle = fileHandle;

    --argv;
    device = *--argv;
    count = sscanf( device, "physicaldrive%d", &diskInfo.PhysicalDrive ); 
    if ( count != 1 ) {
        printf("RemoveLetters, failed to get device drive number for '%s', count %u.\n",
            device, count);
        return(ERROR_INVALID_PARAMETER);
    }

    //errorCode = RemoveDriveLetters( &diskInfo );

    sprintf( objectLink, "PhysicalDrive%d", diskInfo.PhysicalDrive );
    GetSymbolicLink( "\\DosDevices\\", objectLink, &diskInfo );

    length = sscanf( objectLink, PartitionName, &deviceNumber, &partitionNumber );
    if ( length != 2 || partitionNumber != 0 ) {
        printf("Cannot find partition info for %s.\n",
               objectLink);
        maxPartitions = 0;
    }

    length = strlen( objectLink );
    objectLink[length-1] = '\0';

    for ( partitionNumber = 1;
          partitionNumber <= maxPartitions;
          partitionNumber++ ) {
        sprintf( fileName, "%s%d\0", objectLink, partitionNumber );
        FileHandle = OpenObject( "\\DosDevices", fileName, &diskInfo );
        if ( FileHandle == INVALID_HANDLE_VALUE ||
             FileHandle == NULL ) {
#if 0
            printf("Error opening partitions on device %s%s, error %u.\n",
                    "\\DosDevices",
                    fileName,
                    GetLastError() );
#endif
            break;
        }
        if ( !DeviceIoControl( FileHandle,
                               FSCTL_DISMOUNT_VOLUME,
                               NULL,
                               0,
                               NULL,
                               0,
                               &bytesReturned,
                               NULL ) ) {
            printf("Error dismounting volume, %u.\n",
                   GetLastError() );
        }
        CloseHandle( FileHandle );
    }
#if 0
    errorCode = RemoveDriveLetters( &diskInfo );
#endif
    return(errorCode);

} // RemoveLetters



DWORD
ReadSector(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode;
    DWORD status;
    DWORD bytesReturned;
    DWORD bytesRead;
    DWORD x,y;

    DISK_GEOMETRY diskGeometry;
    LPBYTE buf = 0;
    INT   sectorNo;

    if (argc != 1)
    {
        printf( "usage: <device> ReadSector No\n" );
        return ERROR_INVALID_NAME;
    }
    
    status = sscanf(argv[0], "%d", &sectorNo);
    
    if ( 0 == status ) {
        printf("Unable to get sector number from input \n");
        return ERROR_INVALID_PARAMETER;
    }

    ZeroMemory( &diskGeometry, sizeof(DISK_GEOMETRY) );

    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_GET_DRIVE_GEOMETRY,
                               NULL,
                               0,
                               &diskGeometry,
                               sizeof(DISK_GEOMETRY),
                               &bytesReturned,
                               FALSE );

    if (!success) {
        printf( "Error performing GetDiskGeometry, error %d\n",
          errorCode = GetLastError());
        PrintError(errorCode);
        return errorCode;
    }

    if ( bytesReturned < sizeof(DISK_GEOMETRY) ) {
        printf("Error reading DiskGeometry information. Expected %u bytes, got %u bytes.\n",
            sizeof(DISK_GEOMETRY), 
            bytesReturned);
        return(ERROR_INSUFFICIENT_BUFFER);
    }

    printf("GetDiskGeometry was successful, we got %d bytes returned.\n",
            bytesReturned);

    printf("Cylinders = %lx%lx, TracksPerCylinder = %lx, SectorsPerTrack = %lx, BytesPerSector = %lx\n",

        diskGeometry.Cylinders.HighPart, diskGeometry.Cylinders.LowPart,
        diskGeometry.TracksPerCylinder, diskGeometry.SectorsPerTrack,
        diskGeometry.BytesPerSector);

    errorCode = ERROR_SUCCESS;
    
    __try {
       
       buf = VirtualAlloc(0, diskGeometry.BytesPerSector, MEM_COMMIT, PAGE_READWRITE);
       if(buf == 0) {
          printf("Virtual Alloc failed\n");
          errorCode = GetLastError();
          __leave;
       }
       printf("Sector %d\n", sectorNo);
       status = SetFilePointer(fileHandle,
                               diskGeometry.BytesPerSector * sectorNo,
                               NULL,
                               FILE_BEGIN);
    
       if( 0xFFFFFFFF == status ) {
          printf("Error setting file pointer to %lx \n", diskGeometry.BytesPerSector * sectorNo);
          errorCode = GetLastError();
          __leave;
       }
          
       status = ReadFile(fileHandle,
                         buf,
                         diskGeometry.BytesPerSector,
                         &bytesRead,
                         NULL);
       if( status == 0 ) {
          printf("Error reading sector %lx \n.", sectorNo);
          errorCode = GetLastError();
          __leave;
       }
       
       if ( bytesRead != diskGeometry.BytesPerSector ) {
           printf("Error reading sector. Expected %ul bytes, got %ul bytes.\n",
               diskGeometry.BytesPerSector, 
               bytesRead);
           errorCode = ERROR_INSUFFICIENT_BUFFER;
           __leave;
       }

       for(x = 0; x < diskGeometry.BytesPerSector; x += 16) {
          for(y = 0; y < 16; ++y) {
             BYTE ch = buf[x+y];
             if (ch >= ' ' && ch <= '~') {
                printf("  %c", ch);
             } else {
                printf(" %02x", ch);
             }
          }
          printf("\n");
       }
       errorCode = ERROR_SUCCESS;
    }
    __finally {
       if(buf) {
          VirtualFree(buf, 0, MEM_RELEASE);
       }
    }


    return errorCode;

} // ReadSector


DWORD
ReadSectorViaIoctl(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL success;
    DWORD errorCode;
    DWORD bytesReturned;
    DISK_GEOMETRY diskGeometry;
    DWORD bytesRead;
    DWORD status;
    DWORD x,y;
    ARBITRATION_READ_WRITE_PARAMS params;
    
    LPBYTE buf = 0;
    INT   sectorNo;

    if (argc != 1)
    {
        printf( "usage: <device> rs No\n" );
        return ERROR_INVALID_NAME;
    }
    status = sscanf(argv[0], "%d", &sectorNo);
    
    if ( 0 == status ) {
        printf("Unable to get sector number from input \n");
        return ERROR_INVALID_PARAMETER;
    }

    ZeroMemory( &diskGeometry, sizeof(DISK_GEOMETRY) );

    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_GET_DRIVE_GEOMETRY,
                               NULL,
                               0,
                               &diskGeometry,
                               sizeof(DISK_GEOMETRY),
                               &bytesReturned,
                               FALSE );

    if (!success) {
        printf( "Error performing GetDiskGeometry, error %d\n",
          errorCode = GetLastError());
        PrintError(errorCode);
        return errorCode;
    }

    if ( bytesReturned < sizeof(DISK_GEOMETRY) ) {
        printf("Error reading DiskGeometry information. Expected %u bytes, got %u bytes.\n",
            sizeof(DISK_GEOMETRY), 
            bytesReturned);
        return(ERROR_INSUFFICIENT_BUFFER);
    }

    printf("GetDiskGeometry was successful, we got %d bytes returned.\n",
            bytesReturned);

    printf("Cylinders = %lx%lx, TracksPerCylinder = %lx, SectorsPerTrack = %lx, BytesPerSector = %lx\n",

        diskGeometry.Cylinders.HighPart, diskGeometry.Cylinders.LowPart,
        diskGeometry.TracksPerCylinder, diskGeometry.SectorsPerTrack,
        diskGeometry.BytesPerSector);

    errorCode = ERROR_SUCCESS;
    __try {

       buf = VirtualAlloc(0, diskGeometry.BytesPerSector, MEM_COMMIT, PAGE_READWRITE);
       if(buf == 0) {
          printf("Virtual Alloc failed\n");
          errorCode = GetLastError();
          __leave;
       }
       printf("Sector %d\n", sectorNo);
       
       params.Operation = AE_READ;
       params.SectorSize = diskGeometry.BytesPerSector;
       params.SectorNo = sectorNo;
       params.Buffer = buf;

       success = DeviceIoControl( fileHandle,
                                  IOCTL_DISK_CLUSTER_ARBITRATION_ESCAPE,
                                  &params,
                                  sizeof(params),
                                  NULL,
                                  0,
                                  &bytesReturned,
                                  FALSE );
       if(!success) {
          printf("Error reading sector %lx\n.", sectorNo);
          errorCode = GetLastError();
          __leave;
       }
       
       for(x = 0; x < diskGeometry.BytesPerSector; x += 16) {
          for(y = 0; y < 16; ++y) {
             BYTE ch = buf[x+y];
             if (ch >= ' ' && ch <= '~') {
                printf("  %c", ch);
             } else {
                printf(" %02x", ch);
             }
          }
          printf("\n");
       }
       errorCode = ERROR_SUCCESS;
    }
    __finally {
       if(buf) {
          VirtualFree(buf, 0, MEM_RELEASE);
       }
    }


    return errorCode;

} // ReadSectorViaIoctl



DWORD
FixDisk(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Fix the drive layout for the disk.

Arguments:

    

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD                       status;
    DWORD                       index;
    DWORD                       driveLayoutSize;
    DWORD                       bytesPerTrack;
    DWORD                       bytesPerCylinder;
    PDRIVE_LAYOUT_INFORMATION   driveLayout;
    PPARTITION_INFORMATION      partInfo;
    BOOL                     success;
    BOOL                     reset = FALSE;
    DWORD                       returnLength;
    DISK_GEOMETRY               diskGeometry;
    LARGE_INTEGER               partOffset;
    LARGE_INTEGER               partLength;
    LARGE_INTEGER               partSize;
    LARGE_INTEGER               modulo;

    if (argc > 1)
    {
        printf( "usage: <device> FixDisk [RESET]\n" );
        return ERROR_INVALID_NAME;
    }

    if ( argc != 0 ) {
        if ( !_stricmp( *argv, "reset" ) ) {
            reset = TRUE;
        }
    }

    driveLayoutSize = sizeof(DRIVE_LAYOUT_INFORMATION) +
                      (sizeof(PARTITION_INFORMATION) * (1 + MAX_PARTITIONS));

    driveLayout = LocalAlloc( LMEM_FIXED, driveLayoutSize );

    if ( !driveLayout ) {
        printf("FixDisk, failed to allocate drive layout info.\n");
        return(ERROR_OUTOFMEMORY);
    }

    //
    // Read the drive capacity to get bytesPerSector and bytesPerCylinder.
    //
    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_GET_DRIVE_GEOMETRY,
                               NULL,
                               0,
                               &diskGeometry,
                               sizeof(DISK_GEOMETRY),
                               &returnLength,
                               FALSE );
    if ( !success ) {
        printf("FixDriveLayout, error reading drive capacity. Error: %u.\n",
            status = GetLastError());
        LocalFree( driveLayout );
        return(status);
    }
    printf("FixDriveLayout, bps = %u, spt = %u, tpc = %u.\n",
        diskGeometry.BytesPerSector, diskGeometry.SectorsPerTrack,
        diskGeometry.TracksPerCylinder);

    //
    // If read of the partition table originally failed, then we rebuild
    // it!
    //
    if ( reset ) {
        driveLayout->PartitionCount = MAX_PARTITIONS;
        driveLayoutSize = sizeof(DRIVE_LAYOUT_INFORMATION) +
                          (MAX_PARTITIONS * sizeof(PARTITION_INFORMATION));
        driveLayout->Signature = 2196277081;

        bytesPerTrack = diskGeometry.SectorsPerTrack *
                        diskGeometry.BytesPerSector;

        bytesPerCylinder = diskGeometry.TracksPerCylinder *
                           bytesPerTrack;


        partInfo = &driveLayout->PartitionEntry[0];
        partLength.QuadPart = bytesPerCylinder * diskGeometry.Cylinders.QuadPart;

        //
        // The partition offset is 1 track (in bytes).
        // Size is media_size - offset, rounded down to cylinder boundary.
        //
        partOffset.QuadPart = bytesPerTrack;
        partSize.QuadPart = partLength.QuadPart - partOffset.QuadPart;

        modulo.QuadPart = (partOffset.QuadPart + partSize.QuadPart) %
                          bytesPerCylinder;
        partSize.QuadPart -= modulo.QuadPart;

        partInfo = driveLayout->PartitionEntry;

        //
        // Initialize first partition entry.
        //
        partInfo->RewritePartition = TRUE;
        partInfo->PartitionType = PARTITION_IFS;
        partInfo->BootIndicator = FALSE;
        partInfo->StartingOffset.QuadPart = partOffset.QuadPart;
        partInfo->PartitionLength.QuadPart = partSize.QuadPart;
        partInfo->HiddenSectors = 0;
        partInfo->PartitionNumber = 1;

        //
        // For now the remaining partition entries are unused.
        //
        for ( index = 1; index < driveLayout->PartitionCount; index++ ) {
            partInfo = &driveLayout->PartitionEntry[index];
            partInfo->PartitionType = PARTITION_ENTRY_UNUSED;
            partInfo->RewritePartition = TRUE;
            partInfo->BootIndicator = FALSE;
            partInfo->StartingOffset.QuadPart = 0;
            partInfo->PartitionLength.QuadPart = 0;
            partInfo->HiddenSectors = 0;
            partInfo->PartitionNumber = 0;
        }

    } else {
        //
        // For now, the remaining partition entries are unused.
        //
        for ( index = 0; index < driveLayout->PartitionCount; index++ ) {
            partInfo = &driveLayout->PartitionEntry[index];
            partInfo->RewritePartition = TRUE;
            partInfo->PartitionNumber = index+1;
        }
#if 0
        //
        // Recalculate the starting offset for the extended partitions.
        //
        for ( index = 0; index < driveLayout->PartitionCount; index++ ) {
            LARGE_INTEGER   extendedOffset;
            LARGE_INTEGER   bytesPerSector;

            bytesPerSector.QuadPart = diskGeometry.BytesPerSector;
            extendedOffset.QuadPart = 0;

            partInfo = &driveLayout->PartitionEntry[index];
            partInfo->RewritePartition = TRUE;
            if ( IsContainerPartition(partInfo->PartitionType) ) {
                //
                // If this is the first extended partition, then remember
                // the offset to added to the next partition.
                //
                if ( extendedOffset.QuadPart == 0 ) {
                    extendedOffset.QuadPart = bytesPerSector.QuadPart *
                                              (LONGLONG)partInfo->HiddenSectors;
                } else {
                    //
                    // We need to recalculate this extended partition's starting
                    // offset based on the current 'HiddenSectors' field and
                    // the first extended partition's offset.
                    //
                    partInfo->StartingOffset.QuadPart = extendedOffset.QuadPart
                                 + (bytesPerSector.QuadPart *
                                    (LONGLONG)partInfo->HiddenSectors);
                    partInfo->HiddenSectors = 0;
                }
            }
        }
#endif
    }

    //
    // Now set the new partition information.
    //
    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_SET_DRIVE_LAYOUT,
                               driveLayout,
                               driveLayoutSize,
                               NULL,
                               0,
                               &returnLength,
                               FALSE );

    if ( !success ) {
        printf("FixDisk, error setting partition information. Error: %u.\n",
            status = GetLastError() );
        LocalFree( driveLayout );
        return(status);
    }

    LocalFree( driveLayout );
    return(ERROR_SUCCESS);

} // FixDisk


static DWORD
FixDriveLayout(
         HANDLE fileHandle,
         int argc,
         char *argv[]
         )

/*++

Routine Description:

    Fix the (broken) disk.

Arguments:

    

Return Value:

    ERROR_SUCCESS if successful.

    A Win32 error code on failure.

--*/

{
    DWORD                       status;
    DWORD                       index;
    DWORD                       driveLayoutSize;
    DWORD                       bytesPerTrack;
    DWORD                       bytesPerCylinder;
    PDRIVE_LAYOUT_INFORMATION   driveLayout;
    PPARTITION_INFORMATION      partInfo;
    BOOL                     success;
    DWORD                       returnLength;
    DISK_GEOMETRY               diskGeometry;
    LARGE_INTEGER               partOffset;
    LARGE_INTEGER               partLength;
    LARGE_INTEGER               partSize;
    LARGE_INTEGER               modulo;

    driveLayoutSize = sizeof(DRIVE_LAYOUT_INFORMATION) +
                      (sizeof(PARTITION_INFORMATION) * 2 * MAX_PARTITIONS);

    driveLayout = LocalAlloc( LMEM_FIXED, driveLayoutSize );

    if ( !driveLayout ) {
        printf("FixDriveLayout, failed to allocate drive layout info.\n");
        return(ERROR_OUTOFMEMORY);
    }

    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_GET_DRIVE_LAYOUT,
                               NULL,
                               0,
                               driveLayout,
                               driveLayoutSize,
                               &returnLength,
                               FALSE );

    if ( !success ) {
        printf("FixDriveLayout, error getting partition information. Error: %u.\n",
            status = GetLastError() );
        LocalFree( driveLayout );
        return(status);
    }

    printf("FixDriveLayout, disk signature is %u, partition count is %u.\n",
        driveLayout->Signature, driveLayout->PartitionCount);

    //
    // Read the drive capacity to get bytesPerSector and bytesPerCylinder.
    //
    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_GET_DRIVE_GEOMETRY,
                               NULL,
                               0,
                               &diskGeometry,
                               sizeof(DISK_GEOMETRY),
                               &returnLength,
                               FALSE );
    if ( !success ) {
        printf("FixDriveLayout, error reading drive capacity. Error: %u.\n",
            status = GetLastError());
        LocalFree( driveLayout );
        return(status);
    }
    printf("FixDriveLayout, bps = %u, spt = %u, tpc = %u.\n",
        diskGeometry.BytesPerSector, diskGeometry.SectorsPerTrack,
        diskGeometry.TracksPerCylinder);
        
    //
    // If read of the partition table originally failed, then we rebuild
    // it!
    //
    if ( !driveLayout->PartitionCount ) {
        driveLayout->PartitionCount = MAX_PARTITIONS;

        bytesPerTrack = diskGeometry.SectorsPerTrack *
                        diskGeometry.BytesPerSector;

        bytesPerCylinder = diskGeometry.TracksPerCylinder *
                           bytesPerTrack;


        partInfo = &driveLayout->PartitionEntry[0];
        partLength.QuadPart = partInfo->PartitionLength.QuadPart;

        //
        // The partition offset is 1 track (in bytes).
        // Size is media_size - offset, rounded down to cylinder boundary.
        //
        partOffset.QuadPart = bytesPerTrack;
        partSize.QuadPart = partLength.QuadPart - partOffset.QuadPart;

        modulo.QuadPart = (partOffset.QuadPart + partSize.QuadPart) %
                          bytesPerCylinder;
        partSize.QuadPart -= modulo.QuadPart;

        partInfo = driveLayout->PartitionEntry;

        //
        // Initialize first partition entry.
        //
        partInfo->RewritePartition = TRUE;
        partInfo->PartitionType = PARTITION_HUGE;
        partInfo->BootIndicator = FALSE;
        partInfo->StartingOffset.QuadPart = partOffset.QuadPart;
        partInfo->PartitionLength.QuadPart = partSize.QuadPart;
        partInfo->HiddenSectors = 0;
        partInfo->PartitionNumber = 0;

        //
        // For now, the remaining partition entries are unused.
        //
        for ( index = 1; index < MAX_PARTITIONS; index++ ) {
            partInfo->RewritePartition = TRUE;
            partInfo->PartitionType = PARTITION_ENTRY_UNUSED;
            partInfo->BootIndicator = FALSE;
            partInfo->StartingOffset.QuadPart = 0;
            partInfo->PartitionLength.QuadPart = 0;
            partInfo->HiddenSectors = 0;
            partInfo->PartitionNumber = 0;
        }

    } else {
        //
        // Recalculate the starting offset for the extended partitions.
        //
        for ( index = 0; index < driveLayout->PartitionCount; index++ ) {
            LARGE_INTEGER   extendedOffset;
            LARGE_INTEGER   bytesPerSector;

            bytesPerSector.QuadPart = diskGeometry.BytesPerSector;
            extendedOffset.QuadPart = 0;

            partInfo = &driveLayout->PartitionEntry[index];
            partInfo->RewritePartition = TRUE;
            if ( IsContainerPartition(partInfo->PartitionType) ) {
                //
                // If this is the first extended partition, then remember
                // the offset to added to the next partition.
                //
                if ( extendedOffset.QuadPart == 0 ) {
                    extendedOffset.QuadPart = bytesPerSector.QuadPart *
                                              (LONGLONG)partInfo->HiddenSectors;
                } else {
                    //
                    // We need to recalculate this extended partition's starting
                    // offset based on the current 'HiddenSectors' field and
                    // the first extended partition's offset.
                    //
                    partInfo->StartingOffset.QuadPart = extendedOffset.QuadPart
                                 + (bytesPerSector.QuadPart *
                                    (LONGLONG)partInfo->HiddenSectors);
                    partInfo->HiddenSectors = 0;
                }
            }
        }
    }
    //
    // Now set the new partition information.
    //
    success = DeviceIoControl( fileHandle,
                               IOCTL_DISK_SET_DRIVE_LAYOUT,
                               driveLayout,
                               driveLayoutSize,
                               NULL,
                               0,
                               &returnLength,
                               FALSE );

    if ( !success ) {
        printf("FixDriveLayout, error setting partition information. Error: %u.\n",
            status = GetLastError() );
        LocalFree( driveLayout );
        return(status);
    }

    LocalFree( driveLayout );
    return(ERROR_SUCCESS);

} // FixDriveLayout


static DWORD
GetDriveLetter( 
         PUCHAR deviceNameString
         )
{
   UCHAR driveLetter;
   WCHAR deviceName[MAX_PATH];
   NTSTATUS status;
   mbstowcs( deviceName, deviceNameString, strlen(deviceNameString) );
   status = GetAssignedLetter(deviceName, &driveLetter);
   if ( NT_SUCCESS(status) ) {
      if (driveLetter) {
         wprintf(L"%ws ----> %c:\n", deviceName, driveLetter);
      } else {
         wprintf(L"%ws has no drive letter\n", deviceName);
      }
   }
   return RtlNtStatusToDosError( status );
}



static void
usage(
      char *programName
      )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    printf( "usage: %s target_device command\n", programName );
    printf( "commands:\n" );
    printf( "\tReset\n" );
    printf( "\tReserve\n" );
    printf( "\tRelease\n" );
    printf( "\tOnline\n" );
    printf( "\tOffline\n" );
    printf( "\tClaim\n" );
    printf( "\tEjectVolumes\n");
    printf( "\tHoldIO\n" );
    printf( "\tResumeIO\n" );
    printf( "\tPokeMountMgr\n" );
    printf( "\tEnumMounts\n" );
    printf( "\tEnumExtents\n" );
    printf( "\tEnumNodes\n" );
    printf( "\tEnumDisks\n" );
    printf( "\tGetDiskGeometry\n" );
    printf( "\tGetScsiAddress\n" );
    printf( "\tGetDriveLayout\n" );
    printf( "\tGetDriveLayoutEx\n");
    printf( "\tSetDriveLayout\n" );
    printf( "\tGetPartitionInfo\n" );
    printf( "\tGetVolumeInfo\n" );
    printf( "\tGetDriveLetter\n" );
    printf( "\tGetSerialNumber\n");
    printf( "\tAssignLetters\n" );
    printf( "\tRemoveLetters\n" );
    printf( "\tReadSector\n" );
    printf( "\tTest\n" );
    printf( "\tNt4Capable\n" );
    printf( "\tAttach       [ClusDisk0 device] \n" );
    printf( "\tDetach       [ClusDisk0 device] \n" );
    printf( "\tStartReserve [ClusDisk0 device] \n" );
    printf( "\tStopReserve  [ClusDisk0 device] \n" );
    printf( "\tActive       [ClusDisk0 device] \n" );
    printf( "target_device wildcards: \n" );
    printf( "\tAll physical devices: use p* \n" );
    printf( "\tAll logical devices:  use l* or * \n" );
}


NTSTATUS
GetVolumeInformationFromHandle(
   HANDLE Handle
   )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    UCHAR VolumeInfoBuffer[ sizeof(FILE_FS_VOLUME_INFORMATION) + sizeof(WCHAR) * MAX_PATH ];
    UCHAR AttrInfoBuffer[ sizeof(FILE_FS_ATTRIBUTE_INFORMATION) + sizeof(WCHAR) * MAX_PATH ];

    ULONG VolumeInfoLength = sizeof(VolumeInfoBuffer);
    ULONG AttributeInfoLength = sizeof(AttrInfoBuffer);
    PFILE_FS_VOLUME_INFORMATION VolumeInfo = (PFILE_FS_VOLUME_INFORMATION)VolumeInfoBuffer;
    PFILE_FS_ATTRIBUTE_INFORMATION AttributeInfo = (PFILE_FS_ATTRIBUTE_INFORMATION)AttrInfoBuffer;

    ZeroMemory(VolumeInfoBuffer, (sizeof(FILE_FS_VOLUME_INFORMATION) + sizeof(WCHAR) * MAX_PATH)); 
    ZeroMemory(AttrInfoBuffer, (sizeof(FILE_FS_ATTRIBUTE_INFORMATION) + sizeof(WCHAR) * MAX_PATH));
    
    Status = NtQueryVolumeInformationFile(
                Handle,
                &IoStatusBlock,
                VolumeInfo,
                VolumeInfoLength,
                FileFsVolumeInformation
                );
    if ( !NT_SUCCESS(Status) ) {
       return Status;
    }

    Status = NtQueryVolumeInformationFile(
                Handle,
                &IoStatusBlock,
                AttributeInfo,
                AttributeInfoLength,
                FileFsAttributeInformation
                );
    if ( !NT_SUCCESS(Status) ) {
       return Status;
    }

    AttributeInfo->FileSystemName[AttributeInfo->FileSystemNameLength] = 0;
    VolumeInfo->VolumeLabel[VolumeInfo->VolumeLabelLength] = 0;

    printf("\nGetVolumeInformationFromHandle data: \n");

    printf("Volume information: \n");
    printf("  VolumeCreationTime           0x%lx : %lx \n", 
           VolumeInfo->VolumeCreationTime.HighPart,
           VolumeInfo->VolumeCreationTime.LowPart);
    printf("  VolumeSerialNumber           0x%lx \n", VolumeInfo->VolumeSerialNumber);
    printf("  VolumeLabelLength            0x%lx \n", VolumeInfo->VolumeLabelLength);
    printf("  SupportsObjects (BOOL)       0x%lx \n", VolumeInfo->SupportsObjects);
    printf("  VolumeLabel                  %ws   \n", VolumeInfo->VolumeLabel);           
    
    printf("Attribute Information: \n");
    printf("  FileSystemAttributes (Flags) 0x%lx \n", AttributeInfo->FileSystemAttributes);
    printf("  MaximumComponentNameLength   0x%lx \n", AttributeInfo->MaximumComponentNameLength);
    printf("  FileSystemNameLength         0x%lx \n", AttributeInfo->FileSystemNameLength);
    printf("  FileSystemName               %ws \n\n", AttributeInfo->FileSystemName);
    
    return STATUS_SUCCESS;
}

#define FIRST_SHOT_SIZE 512
PVOID
DoIoctlAndAllocate(
    IN HANDLE FileHandle,
    IN DWORD  IoControlCode,
    IN PVOID  InBuf,
    IN ULONG  InBufSize,

    OUT PDWORD BytesReturned
    )
{
   UCHAR firstShot[ FIRST_SHOT_SIZE ];

   DWORD status = ERROR_SUCCESS;
   BOOL success;

   DWORD outBufSize;
   PVOID outBuf = 0;
   DWORD bytesReturned;

   success = DeviceIoControl( FileHandle,
                      IoControlCode,
                      InBuf,
                      InBufSize,
                      &firstShot,
                      sizeof(firstShot),
                      &bytesReturned,
                      (LPOVERLAPPED) NULL );

   if ( success ) {
      outBufSize = bytesReturned;
      outBuf     = malloc( outBufSize );
      if (!outBuf) {
         status = ERROR_OUTOFMEMORY;
      } else {
         RtlCopyMemory(outBuf, &firstShot, outBufSize);
         status = ERROR_SUCCESS;
      }
   } else {
      outBufSize = sizeof(firstShot);
      for(;;) {
         status = GetLastError();
         //
         // If it is not a buffer size related error, then we cannot do much
         //
         if ( status != ERROR_INSUFFICIENT_BUFFER && status != ERROR_MORE_DATA) {
            break;
         }
         //
         // Otherwise, try an outbut buffer twice the previous size
         //
         outBufSize *= 2;
         outBuf = malloc( outBufSize );
         if ( !outBuf ) {
            status = ERROR_OUTOFMEMORY;
            break;
         }

         success = DeviceIoControl( FileHandle,
                                    IoControlCode,
                                    InBuf,
                                    InBufSize,
                                    outBuf,
                                    outBufSize,
                                    &bytesReturned,
                                    (LPOVERLAPPED) NULL );
         if (success) {
            status = ERROR_SUCCESS;
            break;
         }
         free( outBuf );
      } 
   }
   
   if (status != ERROR_SUCCESS) {
      free( outBuf ); // free( 0 ) is legal //
      outBuf = 0;
      bytesReturned = 0;
   }

   SetLastError( status );
   *BytesReturned = bytesReturned;
   return outBuf;
}

#define OUTPUT_BUFFER_LEN (1024)
#define INPUT_BUFFER_LEN  (sizeof(MOUNTMGR_MOUNT_POINT) + 2 * MAX_PATH * sizeof(WCHAR))

static
NTSTATUS
GetAssignedLetterM ( 
    IN HANDLE MountMgrHandle,
    IN PWCHAR deviceName, 
    OUT PCHAR driveLetter ) 
/*++

Routine Description:

    Get an assigned drive letter from MountMgr, if any

Inputs:
    MountMgrHandle - 
    deviceName - 
    driveLetter - receives drive letter

Return value:

    STATUS_SUCCESS - on success
    NTSTATUS code  - on failure

--*/

{
   DWORD status = STATUS_SUCCESS;
   
   PMOUNTMGR_MOUNT_POINT  input  = NULL;
   PMOUNTMGR_MOUNT_POINTS output = NULL;
   PMOUNTMGR_MOUNT_POINT out;
   
   DWORD len = wcslen( deviceName ) * sizeof(WCHAR);
   DWORD bytesReturned;
   DWORD idx;
   
   DWORD outputLen;
   DWORD inputLen;

   WCHAR wc;

   
   inputLen = INPUT_BUFFER_LEN;
   input = LocalAlloc( LPTR, inputLen );
   
   if ( !input ) {
       goto FnExit;
   }

   input->SymbolicLinkNameOffset = 0;
   input->SymbolicLinkNameLength = 0;
   input->UniqueIdOffset = 0;
   input->UniqueIdLength = 0;
   input->DeviceNameOffset = sizeof(MOUNTMGR_MOUNT_POINT);
   input->DeviceNameLength = (USHORT) len;
   RtlCopyMemory((PCHAR)input + input->DeviceNameOffset,
                 deviceName, len );
   if (len > sizeof(WCHAR) && deviceName[1] == L'\\') {
       // convert Dos name to NT name
       ((PWCHAR)(input + input->DeviceNameOffset))[1] = L'?';
   }

   outputLen = OUTPUT_BUFFER_LEN;
   output = LocalAlloc( LPTR, outputLen );
   
   if ( !output ) {
       goto FnExit;
   }
   
   status = DevfileIoctl(MountMgrHandle, IOCTL_MOUNTMGR_QUERY_POINTS,
                input, inputLen, output, outputLen, &bytesReturned);
   
   if ( STATUS_BUFFER_OVERFLOW == status ) {
       
       outputLen = output->Size;
       LocalFree( output );
       
       output = LocalAlloc( LPTR, outputLen );
       
       if ( !output ) {
           goto FnExit;
       }
   
       status = DevfileIoctl(MountMgrHandle, IOCTL_MOUNTMGR_QUERY_POINTS,
                    input, inputLen, output, outputLen, &bytesReturned);
   }

   if ( !NT_SUCCESS(status) ) {
       goto FnExit;
   }

   if (driveLetter) {
       *driveLetter = 0;
   }
   for ( idx = 0; idx < output->NumberOfMountPoints; ++idx ) {
       out = &output->MountPoints[idx];
       if (out->SymbolicLinkNameLength/sizeof(WCHAR) == 14 &&
           (_wcsnicmp((PWCHAR)((PCHAR)output + out->SymbolicLinkNameOffset), L"\\DosDevices\\", 12) == 0) &&
           L':' == *((PCHAR)output + out->SymbolicLinkNameOffset + 13*sizeof(WCHAR)) ) 
       {
           wc = *((PCHAR)output + out->SymbolicLinkNameOffset + 12*sizeof(WCHAR));
           if (driveLetter && out->UniqueIdLength) {
              *driveLetter = (CHAR)toupper((UCHAR)wc);
              break;
           }
       }
   }

FnExit:   
   
   if ( output ) {
       LocalFree( output );
   }
   
   if ( input ) {
       LocalFree( input );
   }
   
   return status;
}


NTSTATUS
GetAssignedLetter ( 
    PWCHAR deviceName, 
    PCHAR driveLetter ) 
{
   HANDLE MountMgrHandle;
   DWORD status = DevfileOpen( &MountMgrHandle, MOUNTMGR_DEVICE_NAME );

   if (driveLetter) {
      *driveLetter = 0;
   }

   if ( NT_SUCCESS(status) ) {
      status = GetAssignedLetterM(MountMgrHandle, deviceName, driveLetter);
      DevfileClose(MountMgrHandle);
   }

   return status;
}

DWORD
PokeMountMgr ( 
    VOID
    ) 
{
   HANDLE MountMgrHandle;
   NTSTATUS ntStatus = DevfileOpen( &MountMgrHandle, MOUNTMGR_DEVICE_NAME );
   DWORD status = ERROR_SUCCESS;

   if ( NT_SUCCESS(ntStatus) ) {
      BOOL success;
      DWORD bytesReturned;
      printf("About to call MOUNTMGR_CHECK_UNPROCESSED_VOLUMES...");
      success = DeviceIoControl( MountMgrHandle,
                                 IOCTL_MOUNTMGR_CHECK_UNPROCESSED_VOLUMES,
                                 NULL,
                                 0,
                                 NULL,
                                 0,
                                 &bytesReturned,
                                 FALSE );
      printf("complete.\n");
      if (!success) {
          status = GetLastError();
      }
      DevfileClose(MountMgrHandle);
   } else {
      status = RtlNtStatusToDosError(ntStatus);
   }

   return status;
}


VOID
PrintError(
    IN DWORD ErrorCode
    )
{
    LPVOID lpMsgBuf;
    ULONG count;

    count = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                            FORMAT_MESSAGE_FROM_SYSTEM |
                            FORMAT_MESSAGE_IGNORE_INSERTS,
                          NULL,
                          ErrorCode,
                          0,
                          (LPTSTR) &lpMsgBuf,
                          0,
                          NULL
                          );

    if (count != 0) {
        printf("  (%d) %s\n", ErrorCode, (LPCTSTR) lpMsgBuf);
        LocalFree( lpMsgBuf );
    } else {
        printf("Format message failed.  Error: %d\n", GetLastError());
    }

}   // PrintError
      

DWORD
GetSerialNumber(
    HANDLE FileHandle
    )
{
    PSTORAGE_DEVICE_DESCRIPTOR descriptor = NULL;

    PCHAR   sigString;

    DWORD   dwError = NO_ERROR;
    DWORD   descriptorSize;
    DWORD   bytesReturned;

    STORAGE_PROPERTY_QUERY propQuery;

    descriptorSize = sizeof( STORAGE_DEVICE_DESCRIPTOR) + 2048;

    descriptor = LocalAlloc( LPTR, descriptorSize );

    if ( !descriptor ) {
        dwError = GetLastError();
        printf("Unable to allocate output buffer: %d \n", dwError);
        PrintError( dwError );
        goto FnExit;
    }

    ZeroMemory( &propQuery, sizeof( propQuery ) );

    propQuery.PropertyId = StorageDeviceProperty;
    propQuery.QueryType  = PropertyStandardQuery;

    if ( !DeviceIoControl( FileHandle,
                           IOCTL_STORAGE_QUERY_PROPERTY,
                           &propQuery,
                           sizeof(propQuery),
                           descriptor,
                           descriptorSize,
                           &bytesReturned,
                           NULL ) ) {

        dwError = GetLastError();
        printf("IOCTL_STORAGE_QUERY_PROPERTY failed: %d \n", dwError);
        PrintError( dwError );
        goto FnExit;
    }

    if ( !bytesReturned || bytesReturned < sizeof( STORAGE_DEVICE_DESCRIPTOR ) ) {
        printf("Invalid byte length returned: %d \n", bytesReturned);
        goto FnExit;
    }
        
    //
    // IA64 sometimes returns -1 for SerialNumberOffset.
    //
    
    if ( 0 == descriptor->SerialNumberOffset || 
         descriptor->SerialNumberOffset > descriptor->Size ) {
        printf("No serial number information available \n");
        goto FnExit;
    }
    
    //
    // Serial number string is a zero terminated ASCII string.  
    
    //
    // The header ntddstor.h says the for devices with no serial number,
    // the offset will be zero.  This doesn't seem to be true.
    //
    // For devices with no serial number, it looks like a string with a single
    // null character '\0' is returned.
    //
    
    sigString = (PCHAR)descriptor + (DWORD)descriptor->SerialNumberOffset;
    
    if ( strlen(sigString) == 0) {
        printf("Serial number: NULL string returned \n");        
    } else {
        printf("Serial number: %s \n", sigString);
    }
    

FnExit:

    if ( descriptor ) {
        LocalFree( descriptor );
    }

    return dwError;

}   // GetSerialNumber
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusdisk\test\object.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    object.c

Abstract:

    Resource DLL for disks.

Author:

    Rod Gamache (rodga) 18-Dec-1995

Revision History:

--*/

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "windef.h"
#include "stdio.h"
#include "stdlib.h"
#include "disksp.h"

#define ATTR_DIR        0x00000001
#define ATTR_DEVICE     0x00000002
#define ATTR_FILE       0x00000004
#define ATTR_SYMLINK    0x00000008

#define DIRECTORYTYPE   L"Directory"
#define DEVICETYPE      L"Device"
#define FILETYPE        L"File"
#define SYMLINKTYPE     L"SymbolicLink"




/* Converts the type-name into an attribute value */

LONG CalcAttributes(
    PUNICODE_STRING Type
    )
{
    UNICODE_STRING  TypeName;

    RtlInitUnicodeString(&TypeName, DIRECTORYTYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_DIR;
    }
    RtlInitUnicodeString(&TypeName, DEVICETYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_DEVICE;
    }
    RtlInitUnicodeString(&TypeName, FILETYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_FILE;
    }
    RtlInitUnicodeString(&TypeName, SYMLINKTYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_SYMLINK;
    }
    return(0);

} // CalcAttributes




/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  StripObjectSpec() -                                                       */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Remove the filespec portion from a path (including the backslash). */

VOID StripObjectSpec(LPSTR lpszPath)
{
  LPSTR     p;

#ifdef  DBCS
  p = lpszPath + lstrlen(lpszPath);
  while ((*p != '\\') && (p != lpszPath))
      p = AnsiPrev(lpszPath, p);
#else
  p = lpszPath + lstrlen(lpszPath);
  while ((*p != '\\') && (p != lpszPath))
      p--;
#endif

  /* Don't strip backslash from root directory entry. */
  if ((p == lpszPath) && (*p == '\\')) {
        p++;
  }

  *p = '\000';

} // StripObjectSpec



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  StripObjectPath() -                                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Extract only the filespec portion from a path. */

VOID  StripObjectPath(LPSTR lpszPath)
{
  LPSTR     p;

  p = lpszPath + lstrlen(lpszPath);
#ifdef  DBCS
  while ((*p != '\\') && (p != lpszPath))
      p = AnsiPrev(lpszPath, p);
#else
  while ((*p != '\\') && (p != lpszPath))
      p--;
#endif

  if (*p == '\\')
      p++;

  if (p != lpszPath)
      lstrcpy(lpszPath, p);

} // StripObjectPath



VOID
GetSymbolicLink(
    IN PCHAR RootName,
    IN OUT PCHAR ObjectName,   // Assume this points at a MAX_PATH len buffer
    IN PDISK_INFO DiskInfo
    )
{
    NTSTATUS    Status;
    OBJECT_ATTRIBUTES   Object_Attributes;
    HANDLE      LinkHandle;
    STRING      String;
    WCHAR       UnicodeBuffer[MAX_PATH];
    CHAR        Buffer[2*MAX_PATH];
    UNICODE_STRING UnicodeString;

    strcpy( Buffer, RootName );
    strcat( Buffer, ObjectName );

    RtlInitString(&String, Buffer);
    Status = RtlAnsiStringToUnicodeString( &UnicodeString,
                                           &String,
                                           TRUE );
    ASSERT( NT_SUCCESS( Status ) );

    InitializeObjectAttributes(&Object_Attributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );

    // Open the given symbolic link object
    Status = NtOpenSymbolicLinkObject(&LinkHandle,
                                      GENERIC_ALL,
                                      &Object_Attributes);
    RtlFreeUnicodeString(&UnicodeString);

    if (!NT_SUCCESS(Status)) {
        printf( "Open symbolic link failed, status = %u.\n",
            Status);
        return;
    }

    // Set up our String variable to point at the object name buffer

    String.Length = 0;
    String.MaximumLength = (USHORT)(MAX_PATH);
    String.Buffer = ObjectName;

    // Go get the target of the symbolic link

    UnicodeString.Buffer = UnicodeBuffer;
    UnicodeString.MaximumLength = sizeof(UnicodeBuffer);

    Status = NtQuerySymbolicLinkObject(LinkHandle, &UnicodeString, NULL);

    NtClose(LinkHandle);

    if (!NT_SUCCESS(Status)) {
        printf("Query symbolic link failed, status = %u.\n",
            Status);
        return;
    }

    // Copy the symbolic target into return buffer

    Status = RtlUnicodeStringToAnsiString(&String, &UnicodeString, FALSE);
    ASSERT(NT_SUCCESS(Status));

    // Add NULL terminator
    String.Buffer[String.Length] = 0;
    return;
}



/* Open the object given only its name.
 * First find the object type by enumerating the directory entries.
 * Then call the type-specific open routine to get a handle
 */

HANDLE
OpenObject(
    LPSTR   lpstrDirectory,
    LPSTR   lpstrObject,
    PDISK_INFO DiskInfo
    )
{
#define BUFFER_SIZE 1024

    NTSTATUS    Status;
    HANDLE      DirectoryHandle;
    ULONG       Context = 0;
    ULONG       ReturnedLength;
    CHAR        Buffer[BUFFER_SIZE];
    CHAR        StringBuffer[BUFFER_SIZE];
    CHAR        CompareBuffer[MAX_PATH];
    CHAR        ReturnBuffer[MAX_PATH];
    ANSI_STRING AnsiString;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    WCHAR       ObjectNameBuf[MAX_PATH];
    UNICODE_STRING ObjectName;
    WCHAR       ObjectTypeBuf[MAX_PATH];
    UNICODE_STRING ObjectType;
    HANDLE      ObjectHandle;
    OBJECT_ATTRIBUTES Attributes;
    UNICODE_STRING DirectoryName;
    IO_STATUS_BLOCK IOStatusBlock;
    BOOL        NotFound;

    //DbgPrint("Open object: raw full name = <%s>\n", lpstrObject);
#if 0
    // Remove drive letter
    while ((*lpstrObject != 0) && (*lpstrObject != '\\')) {
        lpstrObject++;
    }
#endif

    //DbgPrint("Open object: full name = <%s%s>\n", lpstrDirectory, lpstrObject);

    // Initialize the object type buffer
    ObjectType.Buffer = ObjectTypeBuf;
    ObjectType.MaximumLength = sizeof(ObjectTypeBuf);

    // Initialize the object name string
    //strcpy(Buffer, lpstrObject);
    //StripObjectPath(Buffer);
    RtlInitAnsiString(&AnsiString, lpstrObject);

    ObjectName.Buffer = ObjectNameBuf;
    ObjectName.MaximumLength = sizeof(ObjectNameBuf);

    Status = RtlAnsiStringToUnicodeString(&ObjectName, &AnsiString, FALSE);
    ASSERT(NT_SUCCESS(Status));

    //DbgPrint("Open object: name only = <%wZ>\n", &ObjectName);

    // Form buffer to compare Object entries against.
    strcpy(CompareBuffer, lpstrObject );
    //StripObjectSpec( CompareBuffer );

    //
    //  Open the directory for list directory access
    //

    strcpy(StringBuffer, lpstrDirectory);
    //StripObjectSpec(Buffer);

    RtlInitAnsiString(&AnsiString, StringBuffer);

    Status = RtlAnsiStringToUnicodeString( &DirectoryName, &AnsiString, TRUE);
    ASSERT(NT_SUCCESS(Status));

    InitializeObjectAttributes( &Attributes,
                                &DirectoryName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    //DbgPrint("Open object: dir only = <%wZ>\n", &DirectoryName);

    if (!NT_SUCCESS( Status = NtOpenDirectoryObject( &DirectoryHandle,
                                                  STANDARD_RIGHTS_READ |
                                                      DIRECTORY_QUERY |
                                                      DIRECTORY_TRAVERSE,
                                                  &Attributes ) )) {

        if (Status == STATUS_OBJECT_TYPE_MISMATCH) {
            DbgPrint( "%wZ is not a valid Object Directory Object name\n",
                    &DirectoryName );
        } else {
            DbgPrint("OpenObject: failed to open directory, status = 0x%lx\n\r", Status);
        }

        RtlFreeUnicodeString(&DirectoryName);

        printf("Unable to open object.\n");
        return NULL;
    }

    RtlFreeUnicodeString(&DirectoryName);


    //
    //  Query the entire directory in one sweep
    //
    NotFound = TRUE;

    for (Status = NtQueryDirectoryObject( DirectoryHandle,
                                          Buffer,
                                          sizeof(Buffer),
                                          // LATER FALSE,
                                          TRUE, // one entry at a time for now
                                          TRUE,
                                          &Context,
                                          &ReturnedLength );
         NotFound;
         Status = NtQueryDirectoryObject( DirectoryHandle,
                                          Buffer,
                                          sizeof(Buffer),
                                          // LATER FALSE,
                                          TRUE, // one entry at a time for now
                                          FALSE,
                                          &Context,
                                          &ReturnedLength ) ) {
        //
        //  Check the status of the operation.
        //

        if (!NT_SUCCESS( Status )) {
            if (Status != STATUS_NO_MORE_ENTRIES) {
                printf("Failed to query directory object, status = %%1!u!.",
                       Status);
            }
            break;
        }

        //
        // For every record in the buffer get the symbolic link and
        // compare the name of the symbolic link with the one we're
        // looking for.
        //

        //
        //  Point to the first record in the buffer, we are guaranteed to have
        //  one otherwise Status would have been No More Files
        //

        DirInfo = (POBJECT_DIRECTORY_INFORMATION)Buffer;

        RtlCopyString( (PSTRING)&ObjectType, (PSTRING)&DirInfo->TypeName);

        AnsiString.MaximumLength = BUFFER_SIZE;

        while ( DirInfo->Name.Length != 0 ) {

            //DbgPrint("Found object <%wZ>\n", &(DirInfo->Name));

            RtlCopyString( (PSTRING)&ObjectType, (PSTRING)&DirInfo->TypeName);

            if ( CalcAttributes(&ObjectType) == ATTR_SYMLINK ) {
                RtlUnicodeStringToAnsiString( &AnsiString,
                                              &(DirInfo->Name),
                                              FALSE );

                strcpy( ReturnBuffer, AnsiString.Buffer );
                GetSymbolicLink( "\\DosDevices\\", ReturnBuffer, DiskInfo);

                if ( strncmp( ReturnBuffer, CompareBuffer, strlen(CompareBuffer) ) == 0 &&
                     AnsiString.Buffer[strlen(AnsiString.Buffer)-1] == ':' ) {

                    NotFound = FALSE;
                    break;
                }
            }

            DirInfo++;
        }
    } // for

    NtClose(DirectoryHandle);
    if ( NotFound ) {
        SetLastError(ERROR_FILE_NOT_FOUND);
        return(NULL);
    }

    // We now have the type of the object in ObjectType
    // We still have the full object name in lpstrObject
    // Use the appropriate open routine to get a handle

    sprintf( Buffer, "\\\\.\\%s", AnsiString.Buffer );

    ObjectHandle = CreateFile( Buffer,
                               GENERIC_READ | GENERIC_WRITE,
                               FILE_SHARE_WRITE | FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               NULL );

    return(ObjectHandle);

} // OpenObject
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusexts\clusexts\clusextp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ntsdextp.h

Abstract:

    Common header file for NTSDEXTS component source files.

Author:

    Steve Wood (stevewo) 21-Feb-1995

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntsdexts.h>
#include <stdio.h>
#include <stdlib.h>
#include "dbgextp.h"

//prototypes for help functions
void ClusObjHelp(void);
void ResObjHelp(void);
void VersionHelp(void);
void LeaksHelp(void);
void LinkHelp(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusexts\clusexts\clusexts.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    clusexts.c

Abstract:

    This function contains the default cluster debugger extensions

Author:

    Sunita Shrivastava (sunitas) 19-May-1997

Revision History:

--*/

#include "clusextp.h"
#include "omextp.h"
//#include "resextp.h"

NTSD_EXTENSION_APIS ExtensionApis;
HANDLE ExtensionCurrentProcess;



DECLARE_API( version )
{
    OSVERSIONINFOA VersionInformation;
    HKEY hkey;
    DWORD cb, dwType;
    CHAR szCurrentType[128];
    CHAR szCSDString[3+128];

    INIT_API();

    VersionInformation.dwOSVersionInfoSize = sizeof(VersionInformation);
    if (!GetVersionEx( &VersionInformation )) {
        dprintf("GetVersionEx failed - %u\n", GetLastError());
        return;
        }

    szCurrentType[0] = '\0';
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     "Software\\Microsoft\\Windows NT\\CurrentVersion",
                     0,
                     KEY_READ,
                     &hkey
                    ) == NO_ERROR
       )
    {
        cb = sizeof(szCurrentType);
        if (RegQueryValueEx(hkey, "CurrentType", NULL, &dwType, szCurrentType, &cb ) != 0) {
            szCurrentType[0] = '\0';
            }
        RegCloseKey(hkey);
    }

    if (VersionInformation.szCSDVersion[0]) {
        sprintf(szCSDString, ": %s", VersionInformation.szCSDVersion);
        }
    else {
        szCSDString[0] = '\0';
        }

    dprintf("Version %d.%d (Build %d%s) %s\n",
          VersionInformation.dwMajorVersion,
          VersionInformation.dwMinorVersion,
          VersionInformation.dwBuildNumber,
          szCSDString,
          szCurrentType
         );
    return;
}

void VersionHelp()
{
    dprintf("!ver : Dump cluster version\n");
}

DECLARE_API( help )
{
    INIT_API();

    while (*lpArgumentString == ' ')
        lpArgumentString++;

    if (*lpArgumentString == '\0') {
        dprintf("clusexts help:\n\n");
        dprintf("!help [!cmd]          - Show the supported commands\n");
        dprintf("!clusobj              - Dump the cluster service objects\n");
        dprintf("!resobj               - Dump the resource monitor objects\n");
        dprintf("!version              - Dump cluster version and build number\n");
        dprintf("!leaks                - Dump leaks.dll info\n");
        dprintf("!dblink               - Dump a list via its Blinks\n");
        dprintf("!dflink               - Dump a list via its Flinks\n");
        dprintf("!dumpsid              - Dump the domain account associated with a SID\n");

    } else {
        if (*lpArgumentString == '!')
            lpArgumentString++;
        if (strcmp(lpArgumentString, "clusobj") == 0) {
            ClusObjHelp();
        } else if (strcmp(lpArgumentString, "resobj") == 0) {
            ResObjHelp();
        } else if (strcmp( lpArgumentString, "version") == 0) {
            VersionHelp();
        } else if (strcmp( lpArgumentString, "leaks") == 0) {
            LeaksHelp();
        } else {
            dprintf("Invalid command.  No help available\n");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusdisk\test\partiton.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    partiton.c

Abstract:

    Partition scanning routines and assigning Dos Device Letters.

Author:

    Rod Gamache (rodga) 20-Feb-1996

Revision History:

--*/

#include "windows.h"
#include "winioctl.h"
#include "ntddscsi.h"
#include "string.h"
#include "stdio.h"
#include "stdlib.h"

#include "disksp.h"
#include "clusdisk.h"
#include "lm.h"
#include "lmerr.h"


#define UNICODE 1
#define ENTRIES_PER_BOOTSECTOR  8


BOOLEAN
GetAssignedDriveLetter(
    ULONG         Signature,
    LARGE_INTEGER StartingOffset,
    LARGE_INTEGER Length,
    PUCHAR        DriveLetter,
    PULONG        Partition
    );


DWORD
AssignDriveLetters(
    PDISK_INFO DiskInfo
    )

/*++

Routine Description:

    This routine scans the partitions on a specified volume and assigns device
    letters.  If the DosDeviceLetter has already been assigned, then everything
    is fine. Otherwise, the 'sticky' device letter from the registry is used.
    An error is returned if there is a partition that does not have any
    registry information or no 'sticky' device letter.

Arguments:

    DiskInfo - The disk information for this partition.

Return Value:

    Win32 Error Status - ERROR_SUCCESS if success.

--*/

{
    DWORD   status;
    DWORD   returnLength;
    DWORD   diskSignature;
    DWORD   driveLayoutSize;
    DWORD   partNumber;
    DWORD   index;
    PDRIVE_LAYOUT_INFORMATION driveLayout;
    PPARTITION_INFORMATION partInfo;
    WCHAR   targetPath[100];
    WCHAR   newName[8];
    UCHAR   driveLetter;
    BOOL    success;
    DWORD   partition;

    driveLayoutSize = sizeof(DRIVE_LAYOUT_INFORMATION) +
                      (sizeof(PARTITION_INFORMATION) * MAX_PARTITIONS);

    driveLayout = LocalAlloc( LMEM_FIXED, driveLayoutSize );

    ZeroMemory( driveLayout, driveLayoutSize );

    if ( !driveLayout ) {
        printf( "AssignDriveLetters, failed to allocate drive layout info.\n");
        return(ERROR_OUTOFMEMORY);
    }

    success = DeviceIoControl( DiskInfo->FileHandle,
                               IOCTL_DISK_GET_DRIVE_LAYOUT,
                               NULL,
                               0,
                               driveLayout,
                               driveLayoutSize,
                               &returnLength,
                               FALSE );

    if ( !success ) {
        printf( "AssignDriveLetters, error getting drive layout, %u.\n",
            status = GetLastError() );
        LocalFree( driveLayout );
        return(status);
    }

    if ( returnLength < (sizeof(DRIVE_LAYOUT_INFORMATION) +
                        (sizeof(PARTITION_INFORMATION) *
                        (driveLayout->PartitionCount-1))) ) {
        printf("Found %d partitons, need %u, return size %u.\n",
            driveLayout->PartitionCount, sizeof(DRIVE_LAYOUT_INFORMATION) +
            (sizeof(PARTITION_INFORMATION) * (driveLayout->PartitionCount - 1)), returnLength);
        printf("AssignDriveLetters, error getting drive layout. Zero length returned.\n");
        LocalFree( driveLayout );
        return(ERROR_INSUFFICIENT_BUFFER);
    }

    //
    // Process all partitions, assigning drive letters.
    //

    ZeroMemory(DiskInfo->Letters, sizeof(DiskInfo->Letters));

    for ( index = 0;
          (index < driveLayout->PartitionCount) &&
          (index < ENTRIES_PER_BOOTSECTOR);
          index++ ) {

        partInfo = &driveLayout->PartitionEntry[index];
        if ( (partInfo->PartitionType == PARTITION_ENTRY_UNUSED) ||
             !partInfo->RecognizedPartition ) {
            printf("AssignDriveLetters, unused partition found, index %u.\n", index);
            continue;
        }

	    partNumber = partInfo->PartitionNumber;

        if ( partNumber > MAX_PARTITIONS ) {
            printf("AssignDriveLetters, bad partition number %u, index %u.\n",
                partNumber, index);
            break;
        }

        GetAssignedDriveLetter( driveLayout->Signature,
                                partInfo->StartingOffset,
                                partInfo->PartitionLength,
                                &driveLetter,
                                &partition );

        printf("AssignDriveLetters found letter %c, partition %u, offset %u, length %u.\n",
            driveLetter, partNumber, partInfo->StartingOffset, partInfo->PartitionLength);
        if ( driveLetter != ' ' ) {

            DiskInfo->Letters[partNumber] = driveLetter;
            swprintf( targetPath,
                      L"\\Device\\Harddisk%d\\Partition%d",
                      DiskInfo->PhysicalDrive,
                      partNumber );

            newName[0] = (TCHAR)driveLetter;
            newName[1] = (TCHAR)':';
            newName[2] = 0;

            DefineDosDeviceW( DDD_RAW_TARGET_PATH | DDD_NO_BROADCAST_SYSTEM,
                             newName,
                             targetPath );
        }
    }

    LocalFree( driveLayout );

    return(ERROR_SUCCESS);

} // AssignDriveLetters



DWORD
RemoveDriveLetters(
    PDISK_INFO DiskInfo
    )
/*++

Routine Description:

    This routine scans the partitions on a specified volume and removes device
    letters.  If the DosDeviceLetter has already been assigned, then everything
    is fine. Otherwise, the 'sticky' device letter from the registry is used.
    An error is returned if there is a partition that does not have any
    registry information or no 'sticky' device letter.

Arguments:

    DiskInfo - The disk information for this partition.

Return Value:

    Win32 Error Status - ERROR_SUCCESS if success.

--*/

{
    DWORD   status;
    DWORD   returnLength;
    DWORD   diskSignature;
    DWORD   driveLayoutSize;
    DWORD   index;
    PDRIVE_LAYOUT_INFORMATION driveLayout;
    PPARTITION_INFORMATION partInfo;
    TCHAR   newName[8];
    WCHAR   shareName[8];
    UCHAR   driveLetter;
    BOOL    success;
    DWORD   partition;

    driveLayoutSize = sizeof(DRIVE_LAYOUT_INFORMATION) +
                      (sizeof(PARTITION_INFORMATION) * MAX_PARTITIONS);

    driveLayout = LocalAlloc( LMEM_FIXED, driveLayoutSize );

    if ( !driveLayout ) {
        printf("RemoveDriveLetters, failed to allocate drive layout info.\n");
        return(ERROR_OUTOFMEMORY);
    }

    success = DeviceIoControl( DiskInfo->FileHandle,
                               IOCTL_DISK_GET_DRIVE_LAYOUT,
                               NULL,
                               0,
                               driveLayout,
                               driveLayoutSize,
                               &returnLength,
                               FALSE );

    if ( !success ) {
       printf("RemoveDriveLetters, error getting partition information, %u.\n",
            status = GetLastError() );
        LocalFree( driveLayout );
        return(status);
    }

    if ( returnLength < (sizeof(DRIVE_LAYOUT_INFORMATION) +
                          sizeof(PARTITION_INFORMATION)) ) {
        printf("RemoveDriveLetters, error getting partition information. Zero length returned.\n");
        LocalFree( driveLayout );
        return(ERROR_INSUFFICIENT_BUFFER);
    }

    //
    // Process all partitions, assigning drive letters.
    //

    for ( index = 0;
          (index < driveLayout->PartitionCount) &&
          (index < ENTRIES_PER_BOOTSECTOR);
          index++ ) {

        partInfo = &driveLayout->PartitionEntry[index];

        if ( (partInfo->PartitionType == PARTITION_ENTRY_UNUSED) ||
             !partInfo->RecognizedPartition ) {
            continue;
        }

        GetAssignedDriveLetter( driveLayout->Signature,
                                partInfo->StartingOffset,
                                partInfo->PartitionLength,
                                &driveLetter,
                                &partition );

        printf("Found letter %c, offset %u, length %u\n",
            driveLetter, partInfo->StartingOffset, partInfo->PartitionLength);
        if ( driveLetter != ' ' ) {

            newName[0] = (TCHAR)driveLetter;
            newName[1] = (TCHAR)':';
            newName[2] = (TCHAR)0;

            shareName[0] = (WCHAR)driveLetter;
            shareName[1] = (WCHAR)'$';
            shareName[2] = (WCHAR)0;
#if 0
            NetShareDel( NULL,
                         shareName,
                         0 );
#endif
            success = DefineDosDevice( DDD_REMOVE_DEFINITION | DDD_NO_BROADCAST_SYSTEM,
                                       newName,
                                       (LPCTSTR) NULL );
            if ( !success ) {
                printf("RemoveDriveLetters, error removing definition for device %c:.\n",
                    driveLetter);
            }
        }
    }

    LocalFree( driveLayout );

    return(ERROR_SUCCESS);

} // RemoveDriveLetters
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusexts\clusexts\omextp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    omextp.h

Abstract:

    Private header for cluster object manager debugger extensions.

Author:

    Steve Wood (stevewo) 21-Feb-1995

Revision History:

--*/

#include <clusapi.h>
#include <service.h>
#include "..\service\nm\nmp.h"

#define OBJECT_TYPE_RESOURCE    "Resource"
#define OBJECT_TYPE_RESOURCE_TYPE "ResourceType"
#define OBJECT_TYPE_GROUP       "Group"
#define OBJECT_TYPE_NODE        "Node"
#define OBJECT_TYPE_NETWORK     "Network"
#define OBJECT_TYPE_NETINTERFACE "NetInterface"
#define OBJECT_TYPE_CLUSTER     "Cluster"
#define OBJECT_TYPE_UNKNOWN     "UNKNOWN"

#define RESOURCE_STATE_ONLINE   "Online"
#define RESOURCE_STATE_OFFLINE  "Offline"
#define RESOURCE_STATE_FAILED   "Failed"
#define RESOURCE_STATE_ONLINE_PENDING   "OnlinePending"
#define RESOURCE_STATE_OFFLINE_PENDING  "OfflinePending"

#define GROUP_STATE_PARTIAL_ONLINE "PartialOnline"

#define NODE_STATE_UNKNOWN   "Unknown"
#define NODE_STATE_UP        "Up"
#define NODE_STATE_DOWN      "Down"
#define NODE_STATE_PAUSED    "Paused"    
#define NODE_STATE_JOINING   "Joining"


void DumpClusObjList(
    IN PVOID AddrObjTypeTable,
    IN OBJECT_TYPE ObjType, 
    IN BOOL Verbose
    );


void
DumpClusObjAtAddr(
    IN PVOID Body
    );

PLIST_ENTRY
DumpClusObj(
    IN POM_HEADER pOmHeader,
    IN PVOID   Body,
    IN OBJECT_TYPE ObjectType,
    IN BOOL    Verbose
    );


VOID
DumpObject(
    IN OBJECT_TYPE    ObjectType,
    IN PVOID          Body
    );

VOID
DumpResourceObject(
    IN PVOID Body
    );

VOID
DumpResourceTypeObject(
    IN PVOID Body
    );

VOID
DumpGroupObject(
    IN PVOID Body
    );

VOID
DumpNodeObject(
    IN PVOID Body
    );

#if OM_TRACE_REF
void
DumpDeadObjList(
    PVOID AddrDeadList
    );

PLIST_ENTRY
DumpDeadListObj(
    IN POM_HEADER pOmHeader
    );
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusexts\clusexts\leaksext.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    leaksext.c

Abstract:

    dbg extension for use with leaks.dll

Author:

    Charlie Wickham (charlwi) 28-Sep-1998

Revision History:

--*/

#include "clusextp.h"
#include "leaksext.h"

#define FIND_WHITE_SPACE( _ptr_ )                   \
        while ( *_ptr_ != ' ' && *_ptr_ != '\0' )   \
            _ptr_++;

#define SKIP_WHITE_SPACE( _ptr_ )   \
        while ( *_ptr_ == ' ' )     \
            _ptr_++;

#define IS_DWORD_ADDR( _num_ )    !(( (ULONG_PTR)( _num_ )) & 3 )

PCHAR LeaksHandleTypes[] = {
    "Unknown",
    "Event",
    "Registry",
    "Token"
};

DWORD       NumberOfFilters;
ULONG_PTR   FilterAddrs[ 512 ];

BOOL
FilteredAddress(
    ULONG_PTR   Address
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD       numberOfFilters = NumberOfFilters;
    ULONG_PTR * filteredAddr = FilterAddrs;

    while ( numberOfFilters-- ) {
        if ( *filteredAddr == Address ) {
            return TRUE;
        }
        ++filteredAddr;
    }

    return FALSE;
}

VOID
GetSymbolInfo(
    ULONG_PTR   Address,
    LPSTR       Buffer,
    ULONG_PTR * Offset
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    GetSymbol( Address, Buffer, Offset );
    if ( strlen( Buffer ) == 0 ) {
        sprintf(Buffer, "0x%p", Address );
        *Offset = 0;
    }
}

VOID
DumpMemoryInfo(
    BOOL Verbose,
    LPSTR ArgString
    )
{
    DWORD * startingAddr;
    DWORD * endingAddr;
    int     scanResult;
    LPSTR   p;
    DWORD   memBuffer[ 1024 ];  // some pages are not mapped in the middle of the heap
    SIZE_T  bytesRead;
    DWORD   dwordsToRead;
    ULONG   success;
    SIZE_T  bytesToScan;
    DWORD * pDword;
    DWORD * targetAddr;
    PMEM_HDR    memHdr;
    DWORD * filterAddrs[ 512 ];
    DWORD   numberOfFilters = 0;

    //
    // parse args for range
    //
    if ( *ArgString == '\0' ) {
        dprintf("missing args\n");
        return;
    }

    p = ArgString;
    SKIP_WHITE_SPACE( p );

    scanResult = sscanf( p, "%x %x", &startingAddr, &endingAddr );

    if ( scanResult == EOF ) {
        dprintf("missing args\n");
        return;
    }

    if ( scanResult < 2 ) {
        dprintf("can't convert %s to starting address (is it hex?)\n", p);
        return;
    }

    if ( startingAddr >= endingAddr ) {
        dprintf("starting address must be less than ending addr!\n");
        return;
    }

    if ( !IS_DWORD_ADDR( startingAddr ) || !IS_DWORD_ADDR( endingAddr )) {
        dprintf("Use DWORDS for addresses\n");
        return;
    }

    FIND_WHITE_SPACE( p );      // skip over starting addr
    SKIP_WHITE_SPACE( p );
    FIND_WHITE_SPACE( p );      // skip over ending addr
    SKIP_WHITE_SPACE( p );

    //
    // see if any filter args are present
    //
    while ( *p != '\0' ) {
        sscanf( p, "%x", &FilterAddrs[ NumberOfFilters++ ]);
        FIND_WHITE_SPACE( p );
        SKIP_WHITE_SPACE( p );
    }

    //
    // read in hunks of memory looking for our leaks allocator tags
    //
    dwordsToRead = (DWORD)__min(( endingAddr - startingAddr ), ( sizeof( memBuffer ) / sizeof( DWORD )));

    while ( startingAddr < endingAddr ) {
        success = ReadMemory(startingAddr,
                             memBuffer,
                             dwordsToRead * sizeof(DWORD),
                             &bytesRead);

        if ( success ) {

            pDword = memBuffer;
            bytesToScan = bytesRead;
            targetAddr = startingAddr;

            while( bytesToScan > 0 ) {
                CHAR        routineName[ 512 ];
                ULONG_PTR   offset;

                if (*pDword == (DWORD)HEAP_SIGNATURE_ALLOC ) {
                    memHdr = (PMEM_HDR)( pDword - 1 );
                    if ( !FilteredAddress( (ULONG_PTR)memHdr->CallersAddress ) &&
                         !FilteredAddress( (ULONG_PTR)memHdr->CallersCaller )) {

                        dprintf("ALOC @ %p\n", targetAddr - 3 ); // get to beginning of heap data
                        GetSymbolInfo((ULONG_PTR)memHdr->CallersAddress,
                                      routineName,
                                      &offset);

                        dprintf("    Caller:          %s+0x%X (%p)\n",
                                routineName,
                                offset,
                                (ULONG_PTR)memHdr->CallersAddress);

                        if ( memHdr->CallersCaller != NULL ) {
                            GetSymbolInfo((ULONG_PTR) memHdr->CallersCaller, routineName, &offset );
                            dprintf("    Caller's Caller: %s+0x%X (%p)\n",
                                    routineName,
                                    offset,
                                    (ULONG_PTR) memHdr->CallersCaller);
                        }
                    }
                }

                if (Verbose && *pDword == (DWORD)HEAP_SIGNATURE_FREE ) {
                    memHdr = (PMEM_HDR)( targetAddr - 1 );
                    if ( !FilteredAddress( (ULONG_PTR)memHdr->CallersAddress ) &&
                         !FilteredAddress( (ULONG_PTR)memHdr->CallersCaller )) {

                        dprintf("FREE @ %p\n", targetAddr - 3 ); // get to beginning of heap data
                        GetSymbolInfo((ULONG_PTR)memHdr->CallersAddress,
                                      routineName,
                                      &offset);

                        dprintf("    Caller:          %s+0x%X\n", routineName, offset );

                        if ( memHdr->CallersCaller != NULL ) {
                            GetSymbolInfo((ULONG_PTR) memHdr->CallersCaller, routineName, &offset );
                            dprintf("    Caller's Caller: %s+0x%X\n", routineName, offset );
                        }
                    }
                }

                bytesToScan -= sizeof( DWORD );
                ++pDword;
                ++targetAddr;
            }
        } else {
            dprintf("\n\nProblem reading memory @ %08X for %u DWORDS\n\n",
                    startingAddr,
                    dwordsToRead);
        }

        startingAddr = __min( startingAddr + ( sizeof( memBuffer ) / sizeof( DWORD )), endingAddr );
        dwordsToRead = (DWORD)__min(( endingAddr - startingAddr ), ( sizeof( memBuffer ) / sizeof( DWORD )));
    }
}


VOID
DumpHandleInfo(
    BOOL Verbose,
    LPSTR ArgString
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    PHANDLE_TABLE       targetHandleTable, hTable;
    HANDLE_TABLE        localHandleTable[ MAX_HANDLE / HANDLE_DELTA ];
    DWORD               i;
    LEAKS_HANDLE_TYPE   handleType;
    CHAR                routineName[ 512 ];

    //
    // determine handle type
    //
    if ( *ArgString == '\0' ) {
        handleType = 0;
    } else if ( _strnicmp( ArgString, "ev", 2 ) == 0 ) {
        handleType = LeaksEvent;
    } else if ( _strnicmp( ArgString, "reg", 3 ) == 0 ) {
        handleType = LeaksRegistry;
    } else if ( _strnicmp( ArgString, "tok", 3 ) == 0 ) {
        handleType = LeaksToken;
    } else {
        dprintf("Unrecognized handle type: event, registry, or token is needed\n");
        return;
    }

    targetHandleTable = (PHANDLE_TABLE)GetExpression( "leaks!HandleTable" );

    if ( !targetHandleTable ) {
        dprintf("Can't convert leaks!HandleTable symbol\n");
        return;
    }

    if ( !ReadMemory(targetHandleTable,
                     localHandleTable,
                     sizeof(localHandleTable),
                     NULL))
    {
        dprintf("Can't read HandleTable data from debug process memory\n");
        return;
    }

    i = MAX_HANDLE / HANDLE_DELTA;
    hTable = localHandleTable;

    for ( i = 0; i < MAX_HANDLE / HANDLE_DELTA; ++ i ) {
        ULONG_PTR offset;

        //
        // if caller is non-null, then our stuff is tracking this handle
        // AND
        //     we're in verbose AND
        //         the handle type is not specified OR
        //         the handle type is one we're interested in
        //     OR
        //     we're not in verbose and the handle is in use AND
        //         the handle type is not specified OR
        //         the handle type is one we're interested in
        // then we print it out.
        //
        if (hTable[i].Caller != NULL
            &&
            (
             ( Verbose
               &&
               ( handleType == 0
                 ||
                 hTable[i].HandleType == handleType
               )
             )
             ||
             ( hTable[i].InUse
               &&
               ( handleType == 0
                 ||
                 hTable[i].HandleType == handleType
               )
             )
            )
           )
        {
            GetSymbolInfo((ULONG_PTR)hTable[i].Caller,
                          routineName,
                          &offset);

            dprintf("Handle %3X: %s %s\n",
                    i * HANDLE_DELTA,
                    hTable[i].InUse ? "IN USE" : "FREE",
                    LeaksHandleTypes[ hTable[i].HandleType ]);

            dprintf("    Caller:          %s+0x%X\n", routineName, offset );

            if ( hTable[i].CallersCaller != NULL ) {
                GetSymbolInfo((ULONG_PTR) hTable[i].CallersCaller, routineName, &offset );
                dprintf("    Caller's Caller: %s+0x%X\n", routineName, offset );
            }
        }

        if (CheckControlC()) {
            break;
        }
    }
}

DECLARE_API( leaks )

/*++

Routine Description:

    dump the appropriate info collected by leaks.dll

Arguments:

    usual

Return Value:

    None

--*/

{
    LPSTR               p = NULL;
    VOID                (* function)( BOOL, LPSTR ) = NULL;
    BOOL                verbose = FALSE;

    INIT_API();

    //
    // get args
    //
    p = lpArgumentString;
    while ( *p ) {

        if ( *p == '-' ) {
            p++;

            switch ( *p ) {
            case 'h':
            case 'H':
                function = DumpHandleInfo;
                break;

            case 'm':
            case 'M':
                function = DumpMemoryInfo;
                break;

            case 'v':
            case 'V':
                verbose = TRUE;
                break;

            default:
                dprintf( "clusexts: !leaks invalid option flag '-%c'\n", *p );
                break;
            }
        } else {
            break;
        }

        //
        // skip to end of arg then to end of white space
        //
        FIND_WHITE_SPACE( p );
        SKIP_WHITE_SPACE( p );
    }

    if ( function == NULL ) {
        dprintf("clusexts: -h [-v] [event, reg, token]\n");
        return;
    }

    (*function)( verbose, p );
}


VOID
LeaksHelp(
    VOID
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    dprintf("!leaks -h [-v] [event, reg, token] : dump handle info out of leaks.dll\n");
    dprintf("!leaks -m [-v] startaddr endaddr   : dump memory allocation info out of leaks.dll\n");
}

/* end leaksext.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusexts\clusexts\leaksext.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    leaksext.h

Abstract:

    header for leaks.dll extension

Author:

    Charlie Wickham (charlwi) 28-Sep-1998

Revision History:

--*/

#include <leaks.h>

/* end leaksext.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusexts\clusexts\omext.c ===
#include "clusextp.h"
#include "omextp.h"


DECLARE_API( clusobj )

/*++

Routine Description:

    This function is called as an NTSD extension to display all
    critical sections in the target process.

Arguments:


Return Value:

    None.

--*/

{
    OBJECT_TYPE ObjType = ObjectTypeMax;
    OBJECT_TYPE i;
    BOOL        Verbose;
    BOOL        DumpAll=TRUE;
    LPSTR       p = NULL;
    PVOID       ObjToDump = NULL;
    PVOID       AddrObjTypeTable;
    PVOID       AddrDeadList;
    BOOL        DumpDeadList = FALSE;
    
    INIT_API();

    //get the arguments
    Verbose = FALSE;
    p = lpArgumentString;
    while ( p != NULL && *p ) {
        if ( *p == '-' ) {
            p++;
            switch ( *p ) {
                case 't':
                case 'T':
                    ObjType = ObjectTypeResType;
                    p++;
                    DumpAll = FALSE;
                    break;

                case 'r':
                case 'R':
                    ObjType = ObjectTypeResource;
                    p++;
                    DumpAll = FALSE;
                    break;

                case 'g':
                case 'G':
                    ObjType = ObjectTypeGroup;
                    p++;
                    DumpAll = FALSE;
                    break;

                case 'n':
                case 'N':
                    ObjType = ObjectTypeNode;
                    p++;
                    DumpAll = FALSE;
                    break;

                case 'x':
                case 'X':
                    ObjType = ObjectTypeNetwork;
                    p++;
                    DumpAll = FALSE;
                    break;

                case 'i':
                case 'I':
                    ObjType = ObjectTypeNetInterface;
                    p++;
                    DumpAll = FALSE;
                    break;
#if OM_TRACE_REF
                case 'd':
                case 'D':
                    p++;
                    DumpDeadList = TRUE;
                    break;
#endif

                case 'v':
                case 'V':
                    Verbose = TRUE;
                    break;

                case 'h':
                case 'H':
                    ClusObjHelp();
                    return;

                case 'o':
                case 'O':
                    ObjType = ObjectTypeMax;
                    p++;
                    break;
                    
                case ' ':
                    goto gotBlank;

                default:
                    dprintf( "clusexts: !clusobj invalid option flag '-%c'\n", *p );
                    break;

                }
            }
        else if (*p != ' ') {
            sscanf(p,"%lx",&ObjToDump);
            p = strpbrk( p, " " );
            }
        else {
gotBlank:
            p++;
            }
        }

#if OM_TRACE_REF
    if (DumpDeadList)
    {
        AddrDeadList = (PVOID)GetExpression("&clussvc!gDeadListHead");
        if ( !AddrDeadList ) 
        {
            dprintf( "clusexts: !clusobj failed to addres of gDeadListHead\n");
            return;
        }

        DumpDeadObjList(AddrDeadList);
    }
    else 
#endif    
    {
        //if the object type is zero, then an address must be specified
        if (ObjType == ObjectTypeMax)
        {
            if (!ObjToDump)
                dprintf( "clusexts: need to specify an address with the -o option\n");
            else
                DumpClusObjAtAddr(ObjToDump);
            return;                
        }
        //
        // Locate the address of the list head.
        //

        AddrObjTypeTable = (PVOID)GetExpression("&clussvc!OmpObjectTypeTable");
        if ( !AddrObjTypeTable ) 
        {
            dprintf( "clusexts: !clusobj failed to get OmpObjectTypeTable\n");
            return;
        }

        if (DumpAll)
        {
            for (i=ObjectTypeResource; i<ObjectTypeMax; i++)
                DumpClusObjList(AddrObjTypeTable, i, Verbose);
        }
        else
        {
            DumpClusObjList(AddrObjTypeTable, ObjType, Verbose);
        }    
    }
    dprintf( "\n" );

    return;
}

void
DumpClusObjList(
    PVOID AddrObjTypeTable,
    OBJECT_TYPE ObjType, 
    BOOL Verbose)
{
    BOOL            b;
    OM_OBJECT_TYPE  OmObjType;
    POM_OBJECT_TYPE pOmObjType;
    OM_HEADER       OmHeader;
    LIST_ENTRY      ListHead;
    PLIST_ENTRY     Next;
    PUCHAR          ObjectType;

    //
    // Read the object_type header
    //

    b = ReadMemory(
            (LPVOID)((LPBYTE)AddrObjTypeTable + (sizeof(POM_OBJECT_TYPE) * ObjType)),
            &pOmObjType,
            sizeof(POM_OBJECT_TYPE),
            NULL
            );
    if ( !b ) 
    {
        dprintf( "clusexts: !clusobj failed to readmemory for pom_object_type\n");
        return;
    }


    b = ReadMemory(
            (LPVOID)(pOmObjType),
            &OmObjType,
            sizeof(OM_OBJECT_TYPE),
            NULL
            );
    if ( !b ) 
    {
        dprintf( "clusexts: !clusobj failed to readmemory for om_object_type\n");
        return;
    }

    Next = OmObjType.ListHead.Flink;

    switch ( OmObjType.Type ) {
    case ObjectTypeResource:
        ObjectType = OBJECT_TYPE_RESOURCE;
        break;

    case ObjectTypeResType:
        ObjectType = OBJECT_TYPE_RESOURCE_TYPE;
        break;

    case ObjectTypeGroup:
        ObjectType = OBJECT_TYPE_GROUP;
        break;

    case ObjectTypeNode:
        ObjectType = OBJECT_TYPE_NODE;
        break;

    case ObjectTypeNetwork:
        ObjectType = OBJECT_TYPE_NETWORK;
        break;

    case ObjectTypeNetInterface:
        ObjectType = OBJECT_TYPE_NETINTERFACE;
        break;

    case ObjectTypeCluster:
        ObjectType = OBJECT_TYPE_CLUSTER;
        break;

    default:
        ObjectType = OBJECT_TYPE_UNKNOWN;
        break;
    }

    dprintf( "\n***** Dumping %s Objects *****\n", ObjectType);

    if ( OmObjType.Type == ObjectTypeResource ) {
        PVOID       blockingQuorum;
        DWORD       blockingQuorumCount;
        PVOID       quoLockAddr;
        RTL_RESOURCE quoLock;
    
        blockingQuorum = (PVOID)GetExpression("&clussvc!gdwQuoBlockingResources");
        b = ReadMemory(
            (LPVOID)(blockingQuorum),
            &blockingQuorumCount,
            sizeof(DWORD),
            NULL
        );
        if (!b) {
            dprintf("Failed to read gdwQuoBlockingResources\n");
            goto SkipPrint;
        }

        quoLockAddr = (PVOID)GetExpression("&clussvc!gQuoLock");
        b = ReadMemory(
            (LPVOID)(quoLockAddr),
            &quoLock,
            sizeof(RTL_RESOURCE),
            NULL
            );
        if (!b) {
            goto SkipPrint;
        }
        dprintf("\nResources Blocking Quorum = %d\n",
                blockingQuorumCount );
        if ( quoLock.CriticalSection.OwningThread != NULL ) {
            dprintf("Global Quorum Lock critical section owned by %lx\n",
                    quoLock.CriticalSection.OwningThread );
        }
        dprintf("Quorum Lock shared semaphore = %lx, exclusive semaphore = %lx\n",
                quoLock.SharedSemaphore, quoLock.ExclusiveSemaphore );
        if ( quoLock.NumberOfWaitingShared ||
             quoLock.NumberOfWaitingExclusive ) {
            dprintf("Quorum Lock shared waiters = %d, exclusive waiters = %d\n",
                quoLock.NumberOfWaitingShared, quoLock.NumberOfWaitingExclusive );
        }
        if ( quoLock.NumberOfActive == 0 ) {
            dprintf("Quorum Lock is unowned\n");
        } else if ( quoLock.NumberOfActive < 0 ) {
            dprintf("Quorum Lock is owned exclusive by %lx, count = %d\n",
                quoLock.ExclusiveOwnerThread, 0-quoLock.NumberOfActive);
        } else {
            dprintf("Quorum Lock is owned shared, count = %d\n",
                quoLock.NumberOfActive);
        }
        dprintf("\n");
    }
SkipPrint:

    if ( Verbose ) {
        dprintf( "\nRefCnt Address  ObjId                            Name\n\n");
    } else {
        dprintf( "\nRefCnt ObjId                            Name\n\n");
    }

    //
    // Walk the list of cluster objects
    // this assumes that the list head is the first field in
    // OM_OBJECT_TYPE structure
    //
    while ( Next != (PLIST_ENTRY)pOmObjType ) 
    {

        b = ReadMemory( (LPVOID)CONTAINING_RECORD( Next,
                                                   OM_HEADER,
                                                   ListEntry
                                                 ),
                        &OmHeader,
                        sizeof(OM_HEADER),
                        NULL
                      );
        if ( !b ) 
        {
            dprintf( "clusexts: !clusobj read obj header failed, error=%u\n",
                GetLastError());
            return;
        }

        Next = DumpClusObj(&OmHeader,
                           &(((POM_HEADER)Next)->Body),
                           OmObjType.Type,
                           Verbose);
        if (Next == NULL) 
            break;

        if ((CheckControlC)()) 
            break;

     }
}

#if OM_TRACE_REF
void
DumpDeadObjList(
    PVOID AddrDeadList
    )
/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    the objects on dead list for the cluster object manager.

Arguments:
    AddrDeadList - pointer to the gDeadListHead.

Return Value:

--*/
{
    BOOL            b;
    LIST_ENTRY      ListHead;
    OM_HEADER       OmHeader;
    PLIST_ENTRY     Next;

    //
    // Read the object_type header
    //

    b = ReadMemory(
            (LPVOID)((LPBYTE)AddrDeadList),
            &ListHead,
            sizeof(LIST_ENTRY),
            NULL
            );
    if ( !b ) 
    {
        dprintf( "clusexts: !clusobj failed to readmemory for deadlist\n");
        return;
    }


    Next = ListHead.Flink;

    //
    // Walk the list of cluster objects
    // this assumes that the list head is the first field in
    // OM_OBJECT_TYPE structure
    //
    while ( Next != (PLIST_ENTRY)AddrDeadList ) 
    {

        b = ReadMemory( (LPVOID)CONTAINING_RECORD( Next,
                                                   OM_HEADER,
                                                   DeadListEntry
                                                 ),
                        &OmHeader,
                        sizeof(OM_HEADER),
                        NULL
                      );
        if ( !b ) 
        {
            dprintf( "clusexts: !clusobj read obj header failed\n");
            return;
        }

        Next = DumpDeadListObj(&OmHeader);
        
        if (Next == NULL) 
            break;

        if ((CheckControlC)()) 
            break;

     }
}



PLIST_ENTRY
DumpDeadListObj(
    IN POM_HEADER pOmHeader
    )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    the contents of an object on the dead list for the cluster object 
    manager.

Arguments:


Return Value:

    Pointer to the next object in the deadlist of om objects.

--*/

{
    WCHAR       Name[32];
    WCHAR       Id[128];
    BOOLEAN     b;
    
    b = ReadMemory(
        (LPVOID)(pOmHeader->Name),
        Name,
        sizeof(Name),
        NULL
        );
    if (!b)
    {
        goto FnExit;
    }
    b = ReadMemory(
        (LPVOID)(pOmHeader->Id),
        Id,
        sizeof(Id),
        NULL
        );
    if (!b)
    {
        goto FnExit;
    }

    dprintf(
        "%3.3ld    %-8.8lx %-32.32ws %-32.32ws\n",
        pOmHeader->RefCount,
        &(pOmHeader->Body),
        Id,
        Name
        );

FnExit:
    return (pOmHeader->DeadListEntry.Flink);
}

#endif
    
void ClusObjHelp()
{
    dprintf("!clusobj -[r|g|n|x] -v : Dump the cluster objects\n");
    dprintf("!clusobj : Dumps all objects\n");
    dprintf("  -r : Dump the resource objects\n");
    dprintf("  -g : Dump the group objects\n");
    dprintf("  -n : Dump the node objects\n");
    dprintf("  -x : Dump the network objects\n");
    dprintf("  -i : Dump the network interface objects\n");
    dprintf("  -v : Dump the object in verbose mode\n");
    dprintf("  -o addr : Dump the objects at address\n");
    dprintf("  -d : Dump the objects on the deadlist(objs whose refcount is not zero!)\n");
    

}

void
DumpClusObjAtAddr(PVOID Body)
{
    POM_HEADER      pOmHeader = NULL;
    BOOL            b;
    OM_HEADER       OmHeader;
    
    dprintf("clusexts : Dumping object at address %lx\n",
        Body);
    
    pOmHeader = OmpObjectToHeader(Body);

    b = ReadMemory( pOmHeader,
                    &OmHeader,
                    sizeof(OM_HEADER),
                    NULL
                  );
    if ( !b ) 
    {
        dprintf("DumpClusObjAtAddr: !clusobj read obj header failed, error=%u\n",
            GetLastError());
        return;
    }

    DumpClusObj(&OmHeader, Body, ObjectTypeMax, TRUE);

}

PLIST_ENTRY
DumpClusObj(
    IN POM_HEADER pOmHeader,
    IN PVOID      Body,
    IN OBJECT_TYPE ObjectType,
    IN BOOL       Verbose
    )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    the contents of the specified cluster object.

Arguments:


Return Value:

    Pointer to the next critical section in the list for the process or
    NULL if no more critical sections.

--*/

{
    WCHAR       Name[64];
    WCHAR       Id[37]; //guids are 16(32 characters) byte values + 4 dashes + 1 null
    BOOL        b;
    PLIST_ENTRY pNextEntry = NULL;
    DWORD       dwLength=sizeof(Name);
    DWORD       dwRetryCount;

    dwRetryCount = 6;        
    dwLength=sizeof(Id);
ReadId:
    b = ReadMemory(
        (LPVOID)(pOmHeader->Id),
        Id,
        dwLength,
        NULL
        );
    if (!b)
    {
        //since we dont know the length of the id, we may not be able to
        //read the given size
        //retry with a smaller length
        if (GetLastError() == ERROR_NOACCESS)
        {
            if (dwRetryCount)
            {
                dwLength = dwLength/2;
                dwRetryCount--;
                goto ReadId;
            }                
        }
        //if there is another error, exit now
        dwRetryCount = 0;
    }

    if (!dwRetryCount)
    {
        //unsuccessful in reading id
        dprintf(
            "DumpClusObj: Readmemory failed to read  pOmHeader->Id %u\n",
            GetLastError()
            );
        goto FnExit;
    }
    else
    {
        //the id may be partially read
        //null terminate it
        Id[((dwLength)/sizeof(WCHAR))-1]=L'\0';
    }

    dwRetryCount = 6;
    dwLength=sizeof(Name);
ReadName:
    b = ReadMemory(
        (LPVOID)(pOmHeader->Name),
        Name,
        dwLength,
        NULL
        );
    if (!b)
    {
        //since we dont know the length of the name, we may not be able to
        //read the given size
        //retry with a smaller length
        if (GetLastError() == ERROR_NOACCESS)
        {
            if (dwRetryCount)
            {
                dwLength = dwLength/2;
                dwRetryCount--;
                goto ReadName;
            }                
        }
        //if there is another error, exit now
        dwRetryCount = 0;
        
    }

    if (!dwRetryCount)
    {
        //unsuccessful in reading name
        dprintf(
            "DumpClusObj: Readmemory failed to read  pOmHeader->Name %u\n",
            GetLastError()
            );
        goto FnExit;
    }
    else
    {
        //the name may be partially read
        //null terminate it
        Name[((dwLength)/sizeof(WCHAR))-1]=L'\0';
    }
    
    if ( Verbose ) {
        dprintf(
            "%3.3ld    %-8.8lx %-32.32ws %-32.32ws\n",
            pOmHeader->RefCount,
            Body,
            Id,
            Name
            );
        if (ObjectType == ObjectTypeMax)
        {
            OM_OBJECT_TYPE OmObjectType;
            
            //use the type specified in the header
            b = ReadMemory(
                (LPVOID)(pOmHeader->ObjectType),
                &OmObjectType,
                sizeof(OM_OBJECT_TYPE),
                NULL
                );
            if (!b)
            {
                dprintf(
                    "DumpClusObj: Readmemory failed to read  pOmHeader->ObjectType,err=%u\n",
                    GetLastError()
                    );
                goto FnExit;
            }
            ObjectType = OmObjectType.Type;            
        }
        DumpObject( ObjectType, Body );
    } else {
        dprintf(
            "%3.3ld    %-32.32ws %-32.32ws\n",
            pOmHeader->RefCount,
            Id,
            Name
            );
    }

    pNextEntry = pOmHeader->ListEntry.Flink;
FnExit:
    return (pNextEntry);
}




VOID
DumpObject(
    IN OBJECT_TYPE    ObjectType,
    IN PVOID          Body
    )

/*++

Routine Description:

    Dump information specific to the given object.

Arguments:

    ObjectType - the type of object to dump.

    Body - the adress for the body of the object.

Return Value:

    None.

--*/

{

    switch ( ObjectType ) {

    case ObjectTypeResource:
        DumpResourceObject( Body );
        break;

    case ObjectTypeGroup:
        DumpGroupObject( Body );
        break;

    case ObjectTypeResType:
        DumpResourceTypeObject( Body );
        break;

    case ObjectTypeNode:
        DumpNodeObject( Body );
        break;
        
    default:
        break;

    }

    return;

} // DumpObject



VOID
DumpResourceObject(
    IN PVOID Body
    )

/*++

Routine Description:

    Dump information about a resource.

Arguments:

    Body - pointer to the resource object to dump.

Return Value:

    None.

--*/

{
    FM_RESOURCE Resource;
    PFM_RESOURCE pResource = Body;
    BOOL        b;
    PUCHAR      State;
    PUCHAR      PersistentState;
    DWORD       PossibleOwners = 0;
    LIST_ENTRY  ListEntry;

    b = ReadMemory(
            Body,
            &Resource,
            sizeof(FM_RESOURCE),
            NULL
            );
    if ( !b ) 
    {
        dprintf( "clusexts: !clusobj failed to readmemory for resource object\n");
        return;
    }

    //
    // Get the resource's current state.
    //
    switch ( Resource.State ) {
    case ClusterResourceOnline: 
        State = RESOURCE_STATE_ONLINE;
        break;

    case ClusterResourceOffline: 
        State = RESOURCE_STATE_OFFLINE;
        break;

    case ClusterResourceFailed:
        State = RESOURCE_STATE_FAILED;
        break;

    case ClusterResourceOnlinePending: 
        State = RESOURCE_STATE_ONLINE_PENDING;
        break;

    case ClusterResourceOfflinePending: 
        State = RESOURCE_STATE_OFFLINE_PENDING;
        break;

    default:
        State = OBJECT_TYPE_UNKNOWN;
        break;
    }

    //
    // Get the resource's persistent state.
    //
    switch ( Resource.PersistentState ) {
    case ClusterResourceOnline: 
        PersistentState = RESOURCE_STATE_ONLINE;
        break;

    case ClusterResourceOffline: 
        PersistentState = RESOURCE_STATE_OFFLINE;
        break;

    case ClusterResourceFailed:
        PersistentState = RESOURCE_STATE_FAILED;
        break;

    case ClusterResourceOnlinePending: 
        PersistentState = RESOURCE_STATE_ONLINE_PENDING;
        break;

    case ClusterResourceOfflinePending: 
        PersistentState = RESOURCE_STATE_OFFLINE_PENDING;
        break;

    default:
        PersistentState = OBJECT_TYPE_UNKNOWN;
        break;
    }

    b = ReadMemory(
            (LPVOID)&(pResource->PossibleOwners),
            &ListEntry,
            sizeof(LIST_ENTRY),
            NULL
            );
    if ( !b )  {
        dprintf( "clusexts: !clusobj failed to readmemory for resource list entry\n");
        return;
    }

    while ( (PVOID)&(pResource->PossibleOwners) != (PVOID)(ListEntry.Flink) ) {
        PossibleOwners++;
        b = ReadMemory(
                (LPVOID)(ListEntry.Flink),
                &ListEntry,
                sizeof(LIST_ENTRY),
                NULL
                );
        if ( !b )  {
            dprintf( "clusexts: !clusobj failed to readmemory for resource list entry\n");
            return;
        }
    }

    dprintf(
        "%s State, %sQuroum Resource, Group %lx, %s PersistentState\n",
        State,
        Resource.QuorumResource ? "" : "NOT ",
        Resource.Group,
        PersistentState );
    dprintf(
        "DependOn %lx, ProvideFor %lx, (%u)PossibleOwners %lx, Contains %lx\n",
        &(pResource->DependsOn),
        &(pResource->ProvidesFor),
        PossibleOwners,
        &(pResource->PossibleOwners),
        &(pResource->ContainsLinkage) );
    dprintf( "%s\n",
        Resource.BlockingQuorum ? "Blocking Quorum " : "");

    dprintf( "\n" );

    return;

} // DumpResourceObject



VOID
DumpResourceTypeObject(
    IN PVOID Body
    )

/*++

Routine Description:

    Dump information about a resource type.

Arguments:

    Body - pointer to the resource object to dump.

Return Value:

    None.

--*/

{
    FM_RESTYPE ResType;
    BOOL       b;
    WCHAR      DllName[64];

    b = ReadMemory(
            Body,
            &ResType,
            sizeof(FM_RESTYPE),
            NULL
            );
    if ( !b ) 
    {
        dprintf( "clusexts: !clusobj failed to readmemory for resource type object\n");
        return;
    }

    b = ReadMemory(
            ResType.DllName,
            DllName,
            sizeof(DllName),
            NULL );

    if ( b ) {
        dprintf(
            "DllName = %ws\n\n",
            DllName );
    }

    return;

} // DumpResourceObject


VOID
DumpGroupObject(
    IN PVOID Body
    )

/*++

Routine Description:

    Dump information about a group.

Arguments:

    Body - pointer to the group object to dump.

Return Value:

    None.

--*/

{
    FM_GROUP    Group;
    PFM_GROUP   pGroup = Body;
    BOOL        b;
    PUCHAR      State;
    PUCHAR      PersistentState;
    DWORD       i;
    DWORD       lockIndex;
    LOCK_INFO   lockInfo;
    DWORD       unlockIndex;
    LOCK_INFO   unlockInfo;

    b = ReadMemory(
            Body,
            &Group,
            sizeof(FM_GROUP),
            NULL
            );
    if ( !b ) 
    {
        dprintf( "clusexts: !clusobj failed to readmemory for group object\n");
        return;
    }

    //
    // Get the group's current state.
    //
    switch ( Group.State ) {
    case ClusterGroupOnline: 
        State = RESOURCE_STATE_ONLINE;
        break;

    case ClusterGroupOffline: 
        State = RESOURCE_STATE_OFFLINE;
        break;

    case ClusterGroupFailed:
        State = RESOURCE_STATE_FAILED;
        break;

    case ClusterGroupPartialOnline: 
        State = GROUP_STATE_PARTIAL_ONLINE;
        break;

    default:
        State = OBJECT_TYPE_UNKNOWN;
        break;
    }

    //
    // Get the group's persistent state.
    //
    switch ( Group.PersistentState ) {
    case ClusterGroupOnline: 
        PersistentState = RESOURCE_STATE_ONLINE;
        break;

    case ClusterGroupOffline: 
        PersistentState = RESOURCE_STATE_OFFLINE;
        break;

    case ClusterGroupFailed:
        PersistentState = RESOURCE_STATE_FAILED;
        break;

    case ClusterGroupPartialOnline: 
        PersistentState = GROUP_STATE_PARTIAL_ONLINE;
        break;

    default:
        PersistentState = OBJECT_TYPE_UNKNOWN;
        break;
    }

    dprintf(
        "%s State, %s PermState, OrderOwners %u, OwnNode %lx, %s Moving\n",
        State,
        PersistentState,
        Group.OrderedOwners,
        Group.OwnerNode,
        Group.MovingList ? "" : "NOT" );
    dprintf(
        "Contains %lx, PreferredOwners %lx, FailbackType %u, Failures %u\n",
        &(pGroup->Contains),
        &(pGroup->PreferredOwners),
        Group.FailbackType,
        Group.NumberOfFailures );

    dprintf(
        "Lock Address = %lx, Owning thread = %lx, MovingList = %lx\n",
        &(pGroup->Lock),
        Group.Lock.OwningThread,
        Group.MovingList );
    dprintf(
        "Lock History:    Acquires                Releases\n" );
    dprintf(
        "           -------------------       -------------------\n" );
    lockIndex = Group.LockIndex;
    unlockIndex = Group.UnlockIndex;
    for ( i = 0; i < FM_MAX_LOCK_ENTRIES; i++ ) {
      lockInfo = Group.LockTable[lockIndex++];
      unlockInfo = Group.UnlockTable[unlockIndex++];

      lockIndex &= (FM_MAX_LOCK_ENTRIES - 1);
      unlockIndex &= (FM_MAX_LOCK_ENTRIES - 1);
      dprintf(
        "          %3.2u    %3.2lx    %6.5u      %3.2u    %3.2lx    %6.5u\n",
        lockInfo.Module,
        lockInfo.ThreadId,
        lockInfo.LineNumber,
        unlockInfo.Module,
        unlockInfo.ThreadId,
        unlockInfo.LineNumber );
    }

    dprintf( "\n" );

    return;

} // DumpResourceObject


VOID
DumpNodeObject(
    IN PVOID Body
    )
/*++

Routine Description:

    Dump information about a node.

Arguments:

    Body - pointer to the node object to dump.

Return Value:

    None.

--*/

{
    NM_NODE     Node;
    PNM_NODE    pNode=Body;
    BOOL        b;
    PUCHAR      State;

    b = ReadMemory(
            Body,
            &Node,
            sizeof(NM_NODE),
            NULL
            );
    if ( !b ) 
    {
        dprintf( "clusexts: !clusobj failed to readmemory for group object\n");
        return;
    }

    if (Node.State == (UCHAR)ClusterNodeStateUnknown)
    {
        dprintf(
            "State NODE_STATE_UNKNOWN\n");
    }
    else if (Node.State == ClusterNodeUp)
    {
        dprintf(
            "State NODE_STATE_UP\n");
    }
    else if (Node.State == ClusterNodeDown)
    {
        dprintf(
            "State NODE_STATE_DOWN\n");
    }
    else if (Node.State == ClusterNodePaused)
    {
        dprintf(
            "State NODE_STATE_PAUSED\n");
    }
    else if (Node.State == ClusterNodeJoining)
    {
        dprintf(
            "State NODE_STATE_JOINING\n");
    }
    else
    {
        dprintf( 
            "State %u\n",
            Node.State);                
    }

    dprintf(
        "Flags 0x%08lx\n",
        Node.Flags);

    dprintf(
        "InterfaceCount %u  InterfaceList %lx\n",
        Node.InterfaceCount, &(pNode->InterfaceList));

    dprintf(
        "NodeHighestVersion 0x%08lx  NodeLowestVersion 0x%08lx\n",
        Node.HighestVersion, Node.LowestVersion);

    dprintf( "\n" );
    dprintf( "\n" );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusexts\clusexts\dbgextp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ntsdextp.h

Abstract:

    Common header file for NTSDEXTS component source files.

Author:

    Steve Wood (stevewo) 21-Feb-1995

Revision History:

--*/

#define move(dst, src)\
try {\
    ReadMemory((LPVOID) (src), &(dst), sizeof(dst), NULL);\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    return;\
}
#define moveBlock(dst, src, size)\
try {\
    ReadMemory((LPVOID) (src), &(dst), (size), NULL);\
} except (EXCEPTION_EXECUTE_HANDLER) {\
    return;\
}

CHAR igrepLastPattern[256];
DWORD igrepSearchStartAddress;
DWORD igrepLastPc;

#ifdef __cplusplus
#define CPPMOD extern "C"
#else
#define CPPMOD
#endif

#define DECLARE_API(s)                          \
    CPPMOD VOID                                 \
    s(                                          \
        HANDLE hCurrentProcess,                 \
        HANDLE hCurrentThread,                  \
        DWORD dwCurrentPc,                      \
        PNTSD_EXTENSION_APIS lpExtensionApis,   \
        LPSTR lpArgumentString                  \
     )

#define INIT_API() {                            \
    ExtensionApis = *lpExtensionApis;           \
    ExtensionCurrentProcess = hCurrentProcess;  \
    }

#define dprintf                 (ExtensionApis.lpOutputRoutine)
#define GetExpression           (ExtensionApis.lpGetExpressionRoutine)
#define GetSymbol               (ExtensionApis.lpGetSymbolRoutine)
#define Disassm                 (ExtensionApis.lpDisasmRoutine)
#define CheckControlC           (ExtensionApis.lpCheckControlCRoutine)
#define ReadMemory(a,b,c,d)     ReadProcessMemory( ExtensionCurrentProcess, (LPCVOID)(a), (b), (c), (d) )
#define WriteMemory(a,b,c,d)    WriteProcessMemory( ExtensionCurrentProcess, (LPVOID)(a), (LPVOID)(b), (c), (d) )

#ifndef malloc
#define malloc( n ) HeapAlloc( GetProcessHeap(), 0, (n) )
#endif
#ifndef free
#define free( p ) HeapFree( GetProcessHeap(), 0, (p) )
#endif

extern NTSD_EXTENSION_APIS ExtensionApis;
extern HANDLE ExtensionCurrentProcess;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusexts\clusexts\resext.c ===
#include "clusextp.h"
#include "resextp.h"

LPSTR ObjectName[] = {
    OBJECT_TYPE_BUCKET,
    OBJECT_TYPE_RESOURCE
};


DECLARE_API( resobj )

/*++

Routine Description:

    This function is called as an NTSD extension to display all
    resource object in the target resrcmon process.

Arguments:


Return Value:

    None.

--*/

{
    RES_OBJ_TYPE ObjType,i;
    BOOL        Verbose;
    BOOL        DumpAll=TRUE;
    LPSTR       p;
    PVOID       ObjToDump;
    PVOID       RmpEventListHead;

    INIT_API();

    //get the arguments
    Verbose = FALSE;
    p = lpArgumentString;
    while ( p != NULL && *p ) {
        if ( *p == '-' ) {
            p++;
            switch ( *p ) {
                case 'b':
                case 'B':
                    ObjType = ResObjectTypeBucket;
                    p++;
                    DumpAll = FALSE;
                    break;

                case 'r':
                case 'R':
                    ObjType = ResObjectTypeResource;
                    p++;
                    DumpAll = FALSE;
                    break;

                case 'v':
                case 'V':
                    Verbose = TRUE;
                    break;

                case 'h':
                case 'H':
                    ResObjHelp();
                    return;

                case ' ':
                    goto gotBlank;

                default:
                    dprintf( "clusexts: !resobj invalid option flag '-%c'\n", *p );
                    break;

                }
            }
        else if (*p != ' ') {
            sscanf(p,"%lx",&ObjToDump);
            p = strpbrk( p, " " );
            }
        else {
gotBlank:
            p++;
            }
        }

    //
    // Locate the address of the list head.
    //

    RmpEventListHead = (PVOID)GetExpression("&resrcmon!RmpEventListHead");
    if ( !RmpEventListHead ) 
    {
        dprintf( "clusexts: !resobj failed to get RmpEventListHead\n");
        return;
    }

    dprintf( "\n" );

    if (DumpAll)
    {
        for (i=0; i<ResObjectTypeMax; i++)
            ResDumpResObjList(RmpEventListHead, i, Verbose);
    }
    else
    {
        ResDumpResObjList(RmpEventListHead, ObjType, Verbose);
    }    

    dprintf( "\n" );

    return;
}

void
ResDumpResObjList(
    PVOID RmpEventListHead,
    RES_OBJ_TYPE ObjType, 
    BOOL Verbose
    )
{
    BOOL            b;
    LIST_ENTRY      ListHead;
    PLIST_ENTRY     Next;
    POLL_EVENT_LIST PollList;
    PUCHAR          ObjectType;
    DWORD           Count = 0;
    PPOLL_EVENT_LIST pPollList;

    //
    // Read the list head
    //

    b = ReadMemory(
            RmpEventListHead,
            &ListHead,
            sizeof(LIST_ENTRY),
            NULL
            );
    if ( !b ) 
    {
        dprintf( "clusexts: !resobj failed to readmemory for ListHead\n");
        return;
    }

    Next = ListHead.Flink;

    ObjectType = ObjectName[ObjType];

    //
    // Walk the list of poll event lists
    //
    while ( Next != RmpEventListHead ) 
    {
        pPollList = CONTAINING_RECORD( Next,
                                       POLL_EVENT_LIST,
                                       Next );
        b = ReadMemory( pPollList,
                        &PollList,
                        sizeof(POLL_EVENT_LIST),
                        NULL
                      );
        if ( !b ) 
        {
            dprintf( "clusexts: !resobj read poll list entry failed\n");
            return;
        }

        dprintf( "\nDumping %s Objects for list entry %d (%lx)\n\n",
                 ObjectType, ++Count, Next );

        Next = ResDumpResObj(&PollList,
                             pPollList,
                             ObjType,
                             Verbose);
        if (Next == NULL) 
            break;

        if ((CheckControlC)()) 
            break;

     }
}



void
ResObjHelp()
{
    dprintf("!resobj -[r|g|n|x] -v : Dump the resource monitor objects\n");
    dprintf("!resobj : Dumps all objects\n");
    dprintf("  -r : Dump the resource objects\n");
    dprintf("  -l : Dump the event list objects\n");
    dprintf("  -v : Dump the object in verbose mode\n");

}


PLIST_ENTRY
ResDumpResObj(
    IN PVOID        Object,
    IN PVOID        ObjectAddress,
    IN RES_OBJ_TYPE ObjectType,
    IN BOOL         Verbose
    )

/*++

Routine Description:

    This function is called as an NTSD extension to format and dump
    the contents of the specified cluster object.

Arguments:


Return Value:

    Pointer to the next critical section in the list for the process or
    NULL if no more critical sections.

--*/

{
    MONITOR_BUCKET Bucket;
    LIST_ENTRY  ListEntry;
    PLIST_ENTRY Next;
    PPOLL_EVENT_LIST pObject = ObjectAddress;
    PPOLL_EVENT_LIST object = Object;
    LPDWORD     lpDword = (LPDWORD)Object;
    BOOL        b;
    DWORD       i;
    PMONITOR_BUCKET pBucket;

    b = ReadMemory(
            (LPVOID)&(pObject->BucketListHead),
            &ListEntry,
            sizeof(LIST_ENTRY),
            NULL
            );
    if (!b) {
        goto FnExit;
    }

    dprintf(
        "Lock Address = %lx, Owning thread = %lx\n",
        &(pObject->ListLock),
        object->ListLock.OwningThread );

    dprintf(
        "Lock History:    Acquires                Releases\n"
        "           -------------------       -------------------\n" );
    dprintf(
        "          %3.2u    %3.2lx    %6.5u      %3.2u    %3.2lx    %6.5u\n",
        object->PPrevPrevListLock.Module,
        object->PPrevPrevListLock.ThreadId,
        object->PPrevPrevListLock.LineNumber,
        object->LastListUnlock.Module,
        object->LastListUnlock.ThreadId,
        object->LastListUnlock.LineNumber );

    dprintf(
        "          %3.2u    %3.2lx    %6.5u      %3.2u    %3.2lx    %6.5u\n",
        object->PrevPrevListLock.Module,
        object->PrevPrevListLock.ThreadId,
        object->PrevPrevListLock.LineNumber,
        object->PrevListUnlock.Module,
        object->PrevListUnlock.ThreadId,
        object->PrevListUnlock.LineNumber );

    dprintf(
        "          %3.2u    %3.2lx    %6.5u      %3.2u    %3.2lx    %6.5u\n",
        object->PrevListLock.Module,
        object->PrevListLock.ThreadId,
        object->PrevListLock.LineNumber,
        object->PrevPrevListUnlock.Module,
        object->PrevPrevListUnlock.ThreadId,
        object->PrevPrevListUnlock.LineNumber );

    dprintf(
        "          %3.2u    %3.2lx    %6.5u      %3.2u    %3.2lx    %6.5u\n",
        object->LastListLock.Module,
        object->LastListLock.ThreadId,
        object->LastListLock.LineNumber,
        object->PPrevPrevListUnlock.Module,
        object->PPrevPrevListUnlock.ThreadId,
        object->PPrevPrevListUnlock.LineNumber );

    dprintf( "\n" );

    switch ( ObjectType ) {

    case ResObjectTypeBucket:
        dprintf( "    BucketListHead = %lx\n", &(pObject->BucketListHead) );
        dprintf( "    NumberOfBuckets = %u\n", object->NumberOfBuckets );
        break;

    case ResObjectTypeResource:

        dprintf( "ResourceCount = %u, EventCount = %u\n",
            object->NumberOfResources,
            object->EventCount );

        if ( Verbose ) {
            for ( i = 1; i <= object->EventCount; i++ ) {
                dprintf("EventHandle[%u] = %lx\n", i, object->Handle[i-1] );
            }
            dprintf("\n");
            for ( i = 1; i <= object->EventCount; i++ ) {
                if ( object->Resource[i] != 0 ) {
                    dprintf( "    Resource %u address = %lx\n", i, object->Resource[i-1] );
                }
            }
        }
        break;

    default:
        break;

    }

    Next = ListEntry.Flink;
    i = 0;

    //
    // Now follow the list of buckets.
    //
    while ( Next != &(pObject->BucketListHead) ) {
        pBucket = CONTAINING_RECORD( Next,
                                     MONITOR_BUCKET,
                                     BucketList );
        b = ReadMemory( (LPVOID)pBucket,
                        &Bucket,
                        sizeof(MONITOR_BUCKET),
                        NULL );
        if ( !b ) 
        {
            dprintf( "clusexts: !resobj read bucket failed\n");
            goto FnExit;
        }

        if ( Verbose ||
             (ObjectType == ResObjectTypeBucket) ) {
            ResDumpObject( ObjectType,
                           &Bucket,
                           pBucket );
        }

        Next = Bucket.BucketList.Flink;
    }

FnExit:
    return (object->Next.Flink);

    return NULL;
}



VOID
ResDumpObject(
    IN RES_OBJ_TYPE    ObjectType,
    IN PMONITOR_BUCKET Bucket,
    IN PVOID           ObjectAddress
    )

/*++

Routine Description:

    Dump information specific to the given object.

Arguments:

    ObjectType - the type of object to dump.

    Object - the adress for the body of the object.

Return Value:

    None.

--*/

{

    switch ( ObjectType ) {

    case ResObjectTypeResource:
        ResDumpResourceObjects( Bucket, ObjectAddress );
        break;

    case ResObjectTypeBucket:
        ResDumpBucketObject( Bucket, ObjectAddress );
        break;

    default:
        break;

    }

    return;

} // ResDumpObject



VOID
ResDumpResourceObjects(
    IN PMONITOR_BUCKET Bucket,
    IN PVOID           ObjectAddress
    )

/*++

Routine Description:

    Dump information about a list of resources in a bucket.

Arguments:

    Object - pointer to the resource object to dump.

Return Value:

    None.

--*/

{
    RESOURCE    Resource;
    PMONITOR_BUCKET bucket = ObjectAddress;
    BOOL        b;
    LIST_ENTRY  ListEntry;
    PLIST_ENTRY Next;
    PRESOURCE   pResource;

    b = ReadMemory(
            (LPVOID)&(bucket->ResourceList),
            &ListEntry,
            sizeof(LIST_ENTRY),
            NULL
            );
    if (!b) {
        dprintf( "clusexts: !resobj failed to bucket resource list\n");
        return;
    }

    Next = ListEntry.Flink;

    while ( Next != &(bucket->ResourceList) ) {
        pResource = CONTAINING_RECORD( Next,
                                       RESOURCE,
                                       ListEntry );

        b = ReadMemory( pResource,
                        &Resource,
                        sizeof(RESOURCE),
                        NULL
                      );
        if ( !b ) 
        {
            dprintf( "clusexts: !resobj read resource failed\n");
            return;
        }

        dprintf( "    Resource Address = %lx\n", pResource );
        ResDumpResourceInfo( &Resource,
                             pResource );

        Next = Resource.ListEntry.Flink;
    }

    return;

} // ResDumpResourceObject


VOID
ResDumpResourceInfo(
    IN PRESOURCE    Resource,
    IN PVOID        ObjectAddress
    )

/*++

Routine Description:

    Dump information about a resource.

Arguments:

    Object - pointer to the resource object to dump.

Return Value:

    None.

--*/

{
    PUCHAR      State;
    PRESOURCE   pResource = ObjectAddress;
    WCHAR       DllName[MAX_PATH];
    WCHAR       ResourceName[MAX_PATH];
    WCHAR       ResourceType[MAX_PATH];
    BOOL        b;

    //
    // Get the resource's current state.
    //
    switch ( Resource->State ) {
    case ClusterResourceOnline: 
        State = RESOURCE_STATE_ONLINE;
        break;

    case ClusterResourceOffline: 
        State = RESOURCE_STATE_OFFLINE;
        break;

    case ClusterResourceFailed:
        State = RESOURCE_STATE_FAILED;
        break;

    case ClusterResourceOnlinePending: 
        State = RESOURCE_STATE_ONLINE_PENDING;
        break;

    case ClusterResourceOfflinePending: 
        State = RESOURCE_STATE_OFFLINE_PENDING;
        break;

    default:
        State = OBJECT_TYPE_UNKNOWN;
        break;
    }


    b = ReadMemory(
            Resource->ResourceName,
            ResourceName,
            sizeof(ResourceName),
            NULL
            );
    if ( !b )  {
        dprintf( "clusexts: !resobj failed to readmemory for resource name\n");
        return;
    }

    b = ReadMemory(
            Resource->ResourceType,
            ResourceType,
            sizeof(ResourceType),
            NULL
            );
    if ( !b )  {
        dprintf( "clusexts: !resobj failed to readmemory for resource type\n");
        return;
    }

    b = ReadMemory(
            Resource->DllName,
            DllName,
            sizeof(DllName),
            NULL
            );
    if ( !b )  {
        dprintf( "clusexts: !resobj failed to readmemory for dll name\n");
        return;
    }

    dprintf( "    ResourceName = %ws\n", ResourceName );
    dprintf( "    ResourceType = %ws\n", ResourceType );
    dprintf( "    DllName = %ws\n", DllName );
    dprintf( "    Id = %lx, State = %s, EventHandle = %lx, OnlineHandle = %lx\n",
            Resource->Id, State, Resource->EventHandle, Resource->OnlineEvent );
    dprintf( "    TimerEvent = %lx, PendingTimeout = %u, %sArbitrated\n",
            Resource->TimerEvent, Resource->PendingTimeout,
            (Resource->IsArbitrated ? "" : "NOT ") );

    dprintf( "\n" );

    return;

} // ResDumpResourceObject



VOID
ResDumpBucketObject(
    IN PMONITOR_BUCKET Bucket,
    IN PVOID           ObjectAddress
    )

/*++

Routine Description:

    Dump information about a resource type.

Arguments:

    Body - pointer to the resource object to dump.

Return Value:

    None.

--*/

{
    LARGE_INTEGER DueTime;
    RESOURCE    Resource;
    PMONITOR_BUCKET bucket = ObjectAddress;
    BOOL        b;
    LIST_ENTRY  ListEntry;
    PLIST_ENTRY Next;
    DWORD       i = 0;
    PRESOURCE   pResource;

    DueTime.QuadPart = Bucket->DueTime;

    b = ReadMemory(
            (LPVOID)&(bucket->ResourceList),
            &ListEntry,
            sizeof(LIST_ENTRY),
            NULL
            );
    if (!b) {
        dprintf( "clusexts: !resobj failed to bucket resource list\n");
        return;
    }

    Next = ListEntry.Flink;

    while ( Next != &(bucket->ResourceList) ) {
        pResource = CONTAINING_RECORD( Next,
                                       RESOURCE,
                                       ListEntry );

        b = ReadMemory( pResource,
                        &Resource,
                        sizeof(RESOURCE),
                        NULL
                      );
        if ( !b ) 
        {
            dprintf( "clusexts: !resobj read resource failed\n");
            return;
        }

        ++i;
        Next = Resource.ListEntry.Flink;
    }

    dprintf( "    Address = %lx, DueTime = %lx%lx, %u resources\n", bucket, DueTime.HighPart, DueTime.LowPart, i );

    return;

} // ResDumpBucketObject
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusexts\clusexts\security.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    security.c

Abstract:

    security related debugger extensions

Author:

    Charlie Wickham (charlwi) 17-Mar-2000

Revision History:

--*/

#include "clusextp.h"
#include <sddl.h>

#define FIND_WHITE_SPACE( _ptr_ )                                   \
    while ( *_ptr_ != '\0' && *_ptr_ != ' ' && *_ptr_ != '\t' ) {   \
        ++_ptr_;                                                    \
    }                                                               \

#define SKIP_WHITE_SPACE( _ptr_ )                                       \
    while ( *_ptr_ != '\0' && ( *_ptr_ == ' ' || *_ptr_ == '\t' )) {    \
        ++_ptr_;                                                        \
    }                                                                   \


LPWSTR SidTypeNames[] = {
    L"SidTypeUser",
    L"SidTypeGroup",
    L"SidTypeDomain",
    L"SidTypeAlias",
    L"SidTypeWellKnownGroup",
    L"SidTypeDeletedAccount",
    L"SidTypeInvalid",
    L"SidTypeUnknown",
    L"SidTypeComputer"
};

DECLARE_API( dumpsid )

/*++

Routine Description:

    Look up the account associated with the passed in SID

--*/

{
    PCHAR   p;
	BOOL    success;
    LPSTR   nodeName = NULL;
    LPSTR   stringSid;
    DWORD   status;
    PSID    Sid;
    CHAR    nameBuf[ 512 ];
    CHAR    domainName[ 512 ];
    DWORD   nameSize = sizeof( nameBuf );
    DWORD   domainNameSize = sizeof( domainName );
    SID_NAME_USE    sidType;

	if ( lpArgumentString == NULL || *lpArgumentString == '\0' ) {
        dprintf("siddump [nodename] SID\n");
        return;
    }

    //
    // run down the arg string, finding the args
    //
    p = lpArgumentString;
    dprintf("args: ->%s<-\n", p );

    SKIP_WHITE_SPACE( p );              // skip over leading white space
    if ( *p == '\0' ) {
        dprintf("siddump [nodename] SID\n");
        return;
    }

    stringSid = p;

    FIND_WHITE_SPACE( p );              // find end of 1st arg
    if ( *p != '\0' ) {
        *p++ = 0;                       // terminate the first arg string

        SKIP_WHITE_SPACE( p );          // see if there is another arg
        if ( *p != '\0' ) {
            nodeName = stringSid;
            stringSid = p;
            FIND_WHITE_SPACE( p );      // find the end of the 2nd string
            if ( *p != '\0' ) {
                *p = 0;
            }

            dprintf("node: >%s< sid: >%s<,\n", nodeName, stringSid);
        } else {
            dprintf("sid = >%s<\n", stringSid);
        }
    }

    success = ConvertStringSidToSid( stringSid, &Sid );
    if ( !success ) {
        dprintf("Can't convert SID: error %u\n", status = GetLastError());
        return;
    }

    success = LookupAccountSid(nodeName,
                               Sid,
                               nameBuf,
                               &nameSize,
                               domainName,
                               &domainNameSize,
                               &sidType);

    if ( success ) {
        dprintf("\n%s\\%s\n", domainName, nameBuf );
        dprintf("Sid Type: %ws\n", SidTypeNames[ sidType - 1 ]);
    } else {
        dprintf("Can't lookup SID: error %u\n", status = GetLastError());
        return;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusexts\clusexts\resextp.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    resextp.h

Abstract:

    Private header for resmon object debugger extensions.

Author:

    Steve Wood (stevewo) 21-Feb-1995

Revision History:

--*/

#include <clusapi.h>
#include <resmonp.h>

#define OBJECT_TYPE_BUCKET      "Poll Bucket"
#define OBJECT_TYPE_RESOURCE    "Resource"
#define OBJECT_TYPE_UNKNOWN     "UNKNOWN"

#define RESOURCE_STATE_ONLINE   "Online"
#define RESOURCE_STATE_OFFLINE  "Offline"
#define RESOURCE_STATE_FAILED   "Failed"
#define RESOURCE_STATE_ONLINE_PENDING   "OnlinePending"
#define RESOURCE_STATE_OFFLINE_PENDING  "OfflinePending"


typedef enum _ResObjectType {
    ResObjectTypeBucket = 0,
    ResObjectTypeResource = 1,
    ResObjectTypeMax = 2
} RES_OBJ_TYPE;


void
ResDumpResObjList(
    IN PVOID RmpEventListHead,
    IN RES_OBJ_TYPE ObjType, 
    IN BOOL Verbose
    );


PLIST_ENTRY
ResDumpResObj(
    IN PVOID        Object,
    IN PVOID        ObjectAddress,
    IN RES_OBJ_TYPE ObjectType,
    IN BOOL         Verbose
    );

VOID
ResDumpObject(
    IN RES_OBJ_TYPE    ObjectType,
    IN PMONITOR_BUCKET Bucket,
    IN PVOID           ObjectAddress
    );

VOID
ResDumpBucketObject(
    IN PMONITOR_BUCKET Bucket,
    IN PVOID           ObjectAddress
    );

VOID
ResDumpResourceObjects(
    IN PMONITOR_BUCKET Bucket,
    IN PVOID           ObjectAddress
    );

VOID
ResDumpResourceInfo(
    IN PRESOURCE    Resource,
    IN PVOID        ObjectAddress
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\driver\clusnet.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    clusnet.c

Abstract:

    Intialization and dispatch routines for the Cluster Network Driver.

Author:

    Mike Massa (mikemas)           July 29, 1996

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     07-29-96    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "clusnet.tmh"

#include <sspi.h>

//
// Global Data
//
PDRIVER_OBJECT   CnDriverObject = NULL;
PDEVICE_OBJECT   CnDeviceObject = NULL;
KSPIN_LOCK       CnDeviceObjectStackSizeLock = 0;
PDEVICE_OBJECT   CdpDeviceObject = NULL;
PKPROCESS        CnSystemProcess = NULL;
CN_STATE         CnState = CnStateShutdown;
PERESOURCE       CnResource = NULL;
CL_NODE_ID       CnMinValidNodeId = ClusterInvalidNodeId;
CL_NODE_ID       CnMaxValidNodeId = ClusterInvalidNodeId;
CL_NODE_ID       CnLocalNodeId = ClusterInvalidNodeId;
KSPIN_LOCK       CnShutdownLock = 0;
BOOLEAN          CnShutdownScheduled = FALSE;
PKEVENT          CnShutdownEvent = NULL;
WORK_QUEUE_ITEM  CnShutdownWorkItem = {{NULL, NULL}, NULL, NULL};
HANDLE           ClussvcProcessHandle = NULL;


//
// vars for managing Events. The lookaside list generates Event data structs
// that are used to carry the data back to user mode. EventLock is the only
// lock and synchronizes all access to any event structure (both here and in
// CN_FSCONTEXT). EventFileHandles is a list of CN_FSCONTEXT structs that
// are interested in receiving event notifications. To avoid synchronization
// problems between clusnet and mm in clussvc, events have an epoch associated
// with them. MM increments the epoch at the beginning of regroup event and
// updates clusnet at the end of regroup. Any events still pending in the
// event queue with a stale epoch are ignored by MM.
//
// EventDeliveryInProgress is a count of threads that are currently 
// iterating through the EventFileHandles list and delivering events. 
// The EventFileHandles list cannot be modified while EventDeliveryInProgress
// is greater than zero. EventDeliveryComplete is a notification event
// that is signalled when the EventDeliveryInProgress count reaches zero.
// EventRevisitRequired indicates whether a new event IRP arrived during
// event delivery. To avoid delivering events out of order, the IRP cannot
// be completed immediately.
//

PNPAGED_LOOKASIDE_LIST  EventLookasideList = NULL;
LIST_ENTRY              EventFileHandles = {0,0};
#if DBG
CN_LOCK                 EventLock = {0,0};
#else
CN_LOCK                 EventLock = 0;
#endif
ULONG                   EventEpoch;
LONG                    EventDeliveryInProgress = 0;
KEVENT                  EventDeliveryComplete;
BOOLEAN                 EventRevisitRequired = FALSE;

#if DBG
ULONG            CnDebug = 0;
#endif // DBG

//
// Private Types
//

//
// Private Data
//

SECURITY_STATUS
SEC_ENTRY
SecSetPagingMode(
	BOOLEAN Pageable
	);

BOOLEAN SecurityPagingModeSet = FALSE;

//
// Local Prototypes
//
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    );

VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
CnCreateDeviceObjects(
    IN PDRIVER_OBJECT   DriverObject
    );

VOID
CnDeleteDeviceObjects(
    VOID
    );

VOID
CnAdjustDeviceObjectStackSize(
    PDEVICE_OBJECT ClusnetDeviceObject,
    PDEVICE_OBJECT TargetDeviceObject
    );

//
// Mark init code as discardable.
//
#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, CnCreateDeviceObjects)

#pragma alloc_text(PAGE, DriverUnload)
#pragma alloc_text(PAGE, CnDeleteDeviceObjects)

#endif // ALLOC_PRAGMA

//
// Function definitions
//
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    )
/*++

Routine Description:

    Initialization routine for the driver.

Arguments:

    DriverObject   - Pointer to the driver object created by the system.
    RegistryPath   - The driver's registry key.

Return Value:

    An NT status code.

--*/
{
    NTSTATUS        status;
    USHORT          i;

#if DBG
    volatile BOOLEAN DontLoad = FALSE;

    if ( DontLoad )
        return STATUS_UNSUCCESSFUL;
#endif


    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[ClusNet] Loading...\n"));
    }

    WPP_INIT_TRACING(DriverObject, RegistryPath);

    //
    // Save a pointer to the system process so that we can open
    // handles in the context of this process later.
    //
    CnSystemProcess = (PKPROCESS) IoGetCurrentProcess();

    //
    // Allocate a synchronization resource.
    //
    CnResource = CnAllocatePool(sizeof(ERESOURCE));

    if (CnResource == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    status = ExInitializeResourceLite(CnResource);

    if (!NT_SUCCESS(status)) {
        goto error_exit;
    }

    //
    // initialize the mechanisms used to deliver event callbacks
    // to user mode
    //
    EventLookasideList = CnAllocatePool(sizeof(NPAGED_LOOKASIDE_LIST));

    if (EventLookasideList == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    ExInitializeNPagedLookasideList(EventLookasideList,
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof( CLUSNET_EVENT_ENTRY ),
                                    CN_EVENT_SIGNATURE,
                                    0);

    CnInitializeLock( &EventLock, CNP_EVENT_LOCK );
    InitializeListHead( &EventFileHandles );
    KeInitializeEvent( &EventDeliveryComplete, NotificationEvent, TRUE );

    //
    // Initialize miscellaneous other items.
    //
    KeInitializeSpinLock(&CnShutdownLock);
    KeInitializeSpinLock(&CnDeviceObjectStackSizeLock);

    //
    // Initialize the driver object
    //
    CnDriverObject = DriverObject;

    DriverObject->DriverUnload = DriverUnload;
    DriverObject->FastIoDispatch = NULL;

    for (i=0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = CnDispatch;
    }

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] =
        CnDispatchDeviceControl;

    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] =
        CnDispatchInternalDeviceControl;

    //
    // Create all the devices exported by this driver.
    //
    status = CnCreateDeviceObjects(DriverObject);

    if (!NT_SUCCESS(status)) {
        goto error_exit;
    }

#ifdef MEMLOGGING
    //
    // initialize the in-memory log
    //

    CnInitializeMemoryLog();
#endif // MEMLOGGING

    //
    // Load the IP Address and NetBT support.
    // This must be done before the transport registers for PnP events.
    //
    status = IpaLoad();

    if (!NT_SUCCESS(status)) {
        goto error_exit;
    }

    status = NbtIfLoad();
    
    if (!NT_SUCCESS(status)) {
        goto error_exit;
    }

    //
    // Load the transport component
    //
    status = CxLoad(RegistryPath);

    if (!NT_SUCCESS(status)) {
        goto error_exit;
    }

#ifdef MM_IN_CLUSNET

    //
    // Load the membership component
    //
    status = CmmLoad(RegistryPath);

    if (!NT_SUCCESS(status)) {
        goto error_exit;
    }

#endif // MM_IN_CLUSNET

    //
    // make ksecdd non-pagable so we can sign and verify
    // signatures at raised IRQL
    //

    SecSetPagingMode( FALSE );
    SecurityPagingModeSet = TRUE;

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[ClusNet] Loaded.\n"));
    }

    return(STATUS_SUCCESS);


error_exit:

    DriverUnload(CnDriverObject);

    return(status);
}


VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Unloads the driver.

Arguments:

    DriverObject - Pointer to the driver object created by the system.

Return Value:

    None

--*/
{
    PAGED_CODE();

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[ClusNet] Unloading...\n"));
    }

    CnTrace(HBEAT_ERROR,0, "[ClusNet] Unloading...\n");

    //
    // First, force a shutdown.
    //
    CnShutdown();

    //
    // Now unload the components.
    //
#ifdef MM_IN_CLUSNET

    CmmUnload();

#endif // MM_IN_CLUSNET

    CxUnload();

#ifdef MEMLOGGING
    //
    // initialize the in-memory log
    //

    CnFreeMemoryLog();
#endif // MEMLOGGING

    CnDeleteDeviceObjects();

    if (CnResource != NULL) {
        ExDeleteResourceLite(CnResource);
        CnFreePool(CnResource); CnResource = NULL;
    }

    CnDriverObject = NULL;

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[ClusNet] Unloaded.\n"));
    }

    if (EventLookasideList != NULL) {
        ExDeleteNPagedLookasideList( EventLookasideList );
        CnFreePool( EventLookasideList ); EventLookasideList = NULL;
    }

    //
    // finally, allow the security driver to return to nonpaged mode
    //

    if ( SecurityPagingModeSet ) {
        SecSetPagingMode( TRUE );
    }

    WPP_CLEANUP(DriverObject);

    return;

} // DriverUnload


NTSTATUS
CnCreateDeviceObjects(
    IN PDRIVER_OBJECT   DriverObject
    )
/*++

Routine Description:

    Creates the device objects exported by the driver.

Arguments:

    DriverObject   - Pointer to the driver object created by the system.

Return Value:

    An NT status code.

--*/
{
    NTSTATUS        status;
    UNICODE_STRING  deviceName;


    //
    // Create the driver control device
    //
    RtlInitUnicodeString(&deviceName, DD_CLUSNET_DEVICE_NAME);

    status = IoCreateDevice(
                 DriverObject,
                 0,
                 &deviceName,
                 FILE_DEVICE_NETWORK,
                 0,
                 FALSE,
                 &CnDeviceObject
                 );

    if (!NT_SUCCESS(status)) {
        CNPRINT((
            "[ClusNet] Failed to create %ws device object, status %lx\n",
            deviceName.Buffer,
            status
            ));
        return(status);
    }

    CnDeviceObject->Flags |= DO_DIRECT_IO;
    CnDeviceObject->StackSize = CN_DEFAULT_IRP_STACK_SIZE;

    status = IoRegisterShutdownNotification(CnDeviceObject);

    if (!NT_SUCCESS(status)) {
        CNPRINT((
            "[ClusNet] Failed to register for shutdown notification, status %lx\n",
            status
            ));
    }

#if defined(WMI_TRACING)
    status = IoWMIRegistrationControl (CnDeviceObject, WMIREG_ACTION_REGISTER);
    if (!NT_SUCCESS(status)) {
        CNPRINT(("[ClusNet] Failed to register for WMI Support, %lx\n", status) );
    }
#endif

    //
    // Create the datagram transport device
    //
    RtlInitUnicodeString(&deviceName, DD_CDP_DEVICE_NAME);

    status = IoCreateDevice(
                 DriverObject,
                 0,
                 &deviceName,
                 FILE_DEVICE_NETWORK,
                 0,
                 FALSE,
                 &CdpDeviceObject
                 );

    if (!NT_SUCCESS(status)) {
        CNPRINT((
            "[ClusNet] Failed to create %ws device object, status %lx\n",
            deviceName.Buffer,
            status
            ));
        return(status);
    }

    CdpDeviceObject->Flags |= DO_DIRECT_IO;
    CdpDeviceObject->StackSize = CDP_DEFAULT_IRP_STACK_SIZE;

    return(STATUS_SUCCESS);
}


VOID
CnDeleteDeviceObjects(
    VOID
    )
/*++

Routine Description:

    Deletes the device objects exported by the driver.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    if (CnDeviceObject != NULL) {
#if defined(WMI_TRACING)
        IoWMIRegistrationControl(CnDeviceObject, WMIREG_ACTION_DEREGISTER);
#endif
        IoDeleteDevice(CnDeviceObject);
        CnDeviceObject = NULL;
    }

    if (CdpDeviceObject != NULL) {
        IoDeleteDevice(CdpDeviceObject);
        CdpDeviceObject = NULL;
    }

    return;
}

NTSTATUS
CnInitialize(
    IN CL_NODE_ID  LocalNodeId,
    IN ULONG       MaxNodes
    )
/*++

Routine Description:

    Initialization routine for the Cluster Network Driver.
    Called when an initialize request is received.

Arguments:

    LocalNodeId - The ID of the local node.

    MaxNodes - The maximum number of valid cluster nodes.

Return Value:

    An NT status code.

--*/
{
    NTSTATUS   status;
    KIRQL      irql;

    if ( (MaxNodes == 0) ||
         (LocalNodeId < ClusterMinNodeId) ||
         (LocalNodeId > (ClusterMinNodeId + MaxNodes - 1))
       )
    {
        return(STATUS_INVALID_PARAMETER);
    }

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[Clusnet] Initializing...\n"));
    }

    CnState = CnStateInitializePending;

    //
    // Reset global values
    //
    CnAssert(CnLocalNodeId == ClusterInvalidNodeId);
    CnAssert(CnMinValidNodeId == ClusterInvalidNodeId);
    CnAssert(CnMaxValidNodeId == ClusterInvalidNodeId);

    CnMinValidNodeId = ClusterMinNodeId;
    CnMaxValidNodeId = ClusterMinNodeId + MaxNodes - 1;
    CnLocalNodeId = LocalNodeId;

    //
    // Reenable the halt processing mechanism.
    //
    KeAcquireSpinLock(&CnShutdownLock, &irql);
    CnShutdownScheduled = FALSE;
    CnShutdownEvent = NULL;
    KeReleaseSpinLock(&CnShutdownLock, irql);

    //
    // Initialize the IP Address support
    //
    status = IpaInitialize();

    if (status != STATUS_SUCCESS) {
        goto error_exit;
    }

#ifdef MM_IN_CLUSNET

    //
    // Call the Membership Manager's init routine. This will in turn call
    // the Transport's init routine.
    //
    status = CmmInitialize();

#else  // MM_IN_CLUSNET

    status = CxInitialize();

#endif  // MM_IN_CLUSNET

    if (status == STATUS_SUCCESS) {
        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[Clusnet] Initialized.\n"));
        }

        CnState = CnStateInitialized;
    }
    else {
        goto error_exit;
    }

    return(STATUS_SUCCESS);

error_exit:

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[Clusnet] Initialization failed, Shutting down. Status = %08X\n",
                 status));
    }

    CnShutdown();

    return(status);

} // CnInitialize

NTSTATUS
CnShutdown(
    VOID
    )
/*++

Routine Description:

    Terminates operation of the Cluster Membership Manager.
    Called when the Cluster Service is shutting down.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS   status;


    if ( (CnState == CnStateInitialized) ||
         (CnState == CnStateInitializePending)
       )
    {
        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[Clusnet] Shutting down...\n"));
        }

        CnState = CnStateShutdownPending;

        //
        // Shutdown the NetBT and IP Address support.
        //
        NbtIfShutdown();
        IpaShutdown();

#ifdef MM_IN_CLUSNET

        //
        // Shutdown the Membership Manager. This will shutdown the
        // Transport as a side-effect.
        //
        CmmShutdown();

#else  // MM_IN_CLUSNET

        CxShutdown();

#endif  // MM_IN_CLUSNET

        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[Clusnet] Shutdown complete.\n"));
        }

        CnAssert(CnLocalNodeId != ClusterInvalidNodeId);

        CnMinValidNodeId = ClusterInvalidNodeId;
        CnMaxValidNodeId = ClusterInvalidNodeId;
        CnLocalNodeId = ClusterInvalidNodeId;

        CnState = CnStateShutdown;

        status = STATUS_SUCCESS;
    }
    else {
        status = STATUS_DEVICE_NOT_READY;
    }

    //
    // always test if we have a handle to this process
    // and remove it
    //

    if ( ClussvcProcessHandle ) {

        CnCloseProcessHandle( ClussvcProcessHandle );
        ClussvcProcessHandle = NULL;
    }

    return(status);

} // CnShutdown


VOID
CnShutdownWorkRoutine(
    IN PVOID WorkItem
    )
{
    BOOLEAN acquired;
    NTSTATUS Status;

    acquired = CnAcquireResourceExclusive(CnResource, TRUE);

    if (!acquired) {
        KIRQL  irql;

        CNPRINT(("[Clusnet] Failed to acquire CnResource\n"));

        KeAcquireSpinLock(&CnShutdownLock, &irql);
        CnShutdownScheduled = FALSE;
        if (CnShutdownEvent != NULL) {
            KeSetEvent(CnShutdownEvent, IO_NO_INCREMENT, FALSE);
        }
        KeReleaseSpinLock(&CnShutdownLock, irql);

        return;
    }

    (VOID) CnShutdown();

    if (CnShutdownEvent != NULL) {
        KeSetEvent(CnShutdownEvent, IO_NO_INCREMENT, FALSE);
    }

    if (acquired) {
        CnReleaseResourceForThread(
            CnResource,
            (ERESOURCE_THREAD) PsGetCurrentThread()
            );
    }

    //
    // Leave CnShutdownScheduled = TRUE until we are reinitialized to
    // prevent scheduling unnecessary work items.
    //

    return;

} // CnShutdownWorkRoutine


BOOLEAN
CnHaltOperation(
    IN PKEVENT     ShutdownEvent    OPTIONAL
    )
/*++

Routine Description:

    Schedules a critical worker thread to perform clusnet shutdown,
    if a thread is not already scheduled.
    
Arguments:

    ShutdownEvent - if provided, event to be signalled after 
                    shutdown is complete
                    
Return value:

    TRUE if shutdown was scheduled. FALSE if shutdown was already
    scheduled (in which case ShutdownEvent will not be signalled).
    
--*/
{
    KIRQL             irql;


    KeAcquireSpinLock(&CnShutdownLock, &irql);

    if (CnShutdownScheduled) {
        KeReleaseSpinLock(&CnShutdownLock, irql);

        return(FALSE);
    }

    CnShutdownScheduled = TRUE;
    CnShutdownEvent = ShutdownEvent;

    KeReleaseSpinLock(&CnShutdownLock, irql);

    //
    // Schedule a critical worker thread to do the shutdown work.
    //
    ExInitializeWorkItem(
        &CnShutdownWorkItem,
        CnShutdownWorkRoutine,
        &CnShutdownWorkItem
        );

    ExQueueWorkItem(&CnShutdownWorkItem, CriticalWorkQueue);

    return(TRUE);

} // CnHaltOperation


//
// ExResource wrappers that disable APCs.
//
BOOLEAN
CnAcquireResourceExclusive(
    IN PERESOURCE  Resource,
    IN BOOLEAN     Wait
    )
{
    BOOLEAN  acquired;


    KeEnterCriticalRegion();

    acquired = ExAcquireResourceExclusiveLite(Resource, Wait);

    if (!acquired) {
        KeLeaveCriticalRegion();
    }

    return(acquired);

} // CnAcquireResourceExclusive


BOOLEAN
CnAcquireResourceShared(
    IN PERESOURCE  Resource,
    IN BOOLEAN     Wait
    )
{
    BOOLEAN  acquired;


    KeEnterCriticalRegion();

    acquired = ExAcquireResourceSharedLite(Resource, Wait);

    if (!acquired) {
        KeLeaveCriticalRegion();
    }

    return(acquired);

} // CnAcquireResourceShared


VOID
CnReleaseResourceForThread(
    IN PERESOURCE         Resource,
    IN ERESOURCE_THREAD   ResourceThreadId
    )
{
    ExReleaseResourceForThreadLite(Resource, ResourceThreadId);

    KeLeaveCriticalRegion();

    return;

} // CnReleaseResourceForThread



NTSTATUS
CnCloseProcessHandle(
    HANDLE Handle
    )

/*++

Routine Description:

    Close the cluster service process handle

Arguments:

    None

Return Value:

    None

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    CnAssert( Handle != NULL );

    KeAttachProcess( CnSystemProcess );
    Status = ZwClose( Handle );
    KeDetachProcess();

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[Clusnet] Process handle released. status = %08X\n", Status));
    }

    return Status;
}


VOID
CnAdjustDeviceObjectStackSize(
    PDEVICE_OBJECT ClusnetDeviceObject,
    PDEVICE_OBJECT TargetDeviceObject
    )
/*++

Routine Description

    Adjust the StackSize of ClusnetDeviceObject so that we
    can pass client IRPs down to TargetDeviceObject.
    
    The StackSize of clusnet device objects is initialized to
    a default that allows for some leeway for attached drivers.
    
Arguments
    
    ClusnetDeviceObject - clusnet device object whose StackSize
        should be adjusted
        
    TargetDeviceObject - device object clusnet IRPs, originally
        issued to clusnet, will be forwarded to
        
Return value

    None
    
--*/
{
    CCHAR defaultStackSize, newStackSize = 0;
    KIRQL irql;

    if (ClusnetDeviceObject == CnDeviceObject) {
        defaultStackSize = CN_DEFAULT_IRP_STACK_SIZE;
    }
    else if (ClusnetDeviceObject == CdpDeviceObject) {
        defaultStackSize = CDP_DEFAULT_IRP_STACK_SIZE;
    }
    else {
        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[Clusnet] CnAdjustDeviceObjectStackSize: "
                     "unknown clusnet device object %p.\n",
                     ClusnetDeviceObject
                     ));
        }
        return;
    }

    KeAcquireSpinLock(&CnDeviceObjectStackSizeLock, &irql);

    if (ClusnetDeviceObject->StackSize < 
        TargetDeviceObject->StackSize + defaultStackSize) {

        ClusnetDeviceObject->StackSize = 
            TargetDeviceObject->StackSize + defaultStackSize;
        
        IF_CNDBG(CN_DEBUG_INIT) {
            newStackSize = ClusnetDeviceObject->StackSize;
        }
    }

    KeReleaseSpinLock(&CnDeviceObjectStackSizeLock, irql);

    IF_CNDBG(CN_DEBUG_INIT) {
        if (newStackSize != 0) {
            CNPRINT(("[Clusnet] Set StackSize of clusnet device "
                     "object %p to %d "
                     "based on target device object %p.\n",
                     ClusnetDeviceObject,
                     newStackSize,
                     TargetDeviceObject
                     ));
        }
    }

    return;

} // CnAdjustDeviceObjectStackSize

#if DBG

//
// Debug code.
//

ULONG         CnCpuLockMask[MAXIMUM_PROCESSORS];

VOID
CnAssertBreak(
    PCHAR FailedStatement,
    PCHAR FileName,
    ULONG LineNumber
    )
{
    DbgPrint(
        "[Clusnet] Assertion \"%s\" failed in %s line %u\n",
        FailedStatement,
        FileName,
        LineNumber
        );
    DbgBreakPoint();

    return;

}  // CnAssertBreak


ULONG
CnGetCpuLockMask(
    VOID
    )
{
    ULONG   mask;

    if (KeGetCurrentIrql() != DISPATCH_LEVEL) {
        CnAssert(CnCpuLockMask[KeGetCurrentProcessorNumber()] == 0);
        mask = 0;
    }
    else {
        mask = CnCpuLockMask[KeGetCurrentProcessorNumber()];
    }

    return(mask);
}


VOID
CnVerifyCpuLockMask(
    IN ULONG RequiredLockMask,
    IN ULONG ForbiddenLockMask,
    IN ULONG MaximumLockMask
    )
{
    ULONG   mask;


    if (KeGetCurrentIrql() < DISPATCH_LEVEL) {
        mask = 0;
    }
    else {
        mask = CnCpuLockMask[KeGetCurrentProcessorNumber()];
    }

    if ((mask & RequiredLockMask) != RequiredLockMask) {
        CNPRINT((
            "[Clusnet] Locking bug: Req'd lock mask %lx, actual mask %lx\n",
            RequiredLockMask,
            mask
            ));
        DbgBreakPoint();
    }

    if (mask & ForbiddenLockMask) {
        CNPRINT((
            "[Clusnet] Locking bug: Forbidden mask %lx, actual mask %lx\n",
            ForbiddenLockMask,
            mask
            ));
        DbgBreakPoint();
    }

    if (mask > MaximumLockMask) {
        CNPRINT((
            "[Clusnet] Locking bug: Max lock mask %lx, actual mask %lx\n",
            MaximumLockMask,
            mask
            ));
        DbgBreakPoint();
    }

    return;
}

VOID
CnInitializeLock(
    PCN_LOCK  Lock,
    ULONG     Rank
    )
{
    KeInitializeSpinLock(&(Lock->SpinLock));
    Lock->Rank = Rank;

    return;
}


VOID
CnAcquireLock(
    IN  PCN_LOCK   Lock,
    OUT PCN_IRQL   Irql
    )
{
    KIRQL   irql;
    ULONG   currentCpu;



    if (KeGetCurrentIrql() != DISPATCH_LEVEL) {
        KeRaiseIrql(DISPATCH_LEVEL, &irql);
    }
    else {
        irql = DISPATCH_LEVEL;
    }

    currentCpu = KeGetCurrentProcessorNumber();

    if (CnCpuLockMask[currentCpu] >= Lock->Rank) {
        CNPRINT((
            "[Clusnet] CPU %u trying to acquire lock %lx out of order, mask %lx\n",
            currentCpu,
            Lock->Rank,
            CnCpuLockMask[currentCpu]
            ));

        DbgBreakPoint();
    }

    KeAcquireSpinLockAtDpcLevel(&(Lock->SpinLock));
    *Irql = irql;

    CnCpuLockMask[currentCpu] |= Lock->Rank;

    return;
}


VOID
CnAcquireLockAtDpc(
    IN  PCN_LOCK   Lock
    )
{
    ULONG   currentCpu = KeGetCurrentProcessorNumber();


    if (KeGetCurrentIrql() !=  DISPATCH_LEVEL) {
        CNPRINT((
            "[Clusnet] CPU %u trying to acquire DPC lock at passive level.\n",
            currentCpu
            ));

        DbgBreakPoint();
    }

    if (CnCpuLockMask[currentCpu] >= Lock->Rank) {
        CNPRINT((
            "[Clusnet] CPU %u trying to acquire lock %lx out of order, mask %lx\n",
            currentCpu,
            Lock->Rank,
            CnCpuLockMask[currentCpu]
            ));

        DbgBreakPoint();
    }

    KeAcquireSpinLockAtDpcLevel(&(Lock->SpinLock));

    CnCpuLockMask[currentCpu] |= Lock->Rank;

    return;
}


VOID
CnReleaseLock(
    IN  PCN_LOCK   Lock,
    IN  CN_IRQL    Irql
    )
{
    ULONG currentCpu = KeGetCurrentProcessorNumber();

    if (KeGetCurrentIrql() !=  DISPATCH_LEVEL) {
        CNPRINT((
            "[Clusnet] CPU %u trying to release lock from passive level.\n",
            currentCpu
            ));

        DbgBreakPoint();
    }

    if ( !(CnCpuLockMask[currentCpu] & Lock->Rank) ) {
        CNPRINT((
            "[Clusnet] CPU %u trying to release lock %lx, which it doesn't hold, mask %lx\n",
            currentCpu,
            Lock->Rank,
            CnCpuLockMask[currentCpu]
            ));

        DbgBreakPoint();
    }

    CnCpuLockMask[currentCpu] &= ~(Lock->Rank);

    KeReleaseSpinLock(&(Lock->SpinLock), Irql);

    return;
}


VOID
CnReleaseLockFromDpc(
    IN  PCN_LOCK   Lock
    )
{
    ULONG currentCpu = KeGetCurrentProcessorNumber();


    if (KeGetCurrentIrql() !=  DISPATCH_LEVEL) {
        CNPRINT((
            "[Clusnet] CPU %u trying to release lock from passive level.\n",
            currentCpu
            ));

        DbgBreakPoint();
    }

    if ( !(CnCpuLockMask[currentCpu] & Lock->Rank) ) {
        CNPRINT((
            "[Clusnet] CPU %u trying to release lock %lx, which it doesn't hold, mask %lx\n",
            currentCpu,
            Lock->Rank,
            CnCpuLockMask[currentCpu]
            ));

        DbgBreakPoint();
    }

    CnCpuLockMask[currentCpu] &= ~(Lock->Rank);

    KeReleaseSpinLockFromDpcLevel(&(Lock->SpinLock));

    return;
}


VOID
CnMarkIoCancelLockAcquired(
    VOID
    )
{
    ULONG currentCpu = KeGetCurrentProcessorNumber();

    CnAssert(KeGetCurrentIrql() == DISPATCH_LEVEL);

    CnAssert(!(CnCpuLockMask[currentCpu] & CN_IOCANCEL_LOCK));
    CnAssert(CnCpuLockMask[currentCpu] < CN_IOCANCEL_LOCK_MAX);

    CnCpuLockMask[currentCpu] |= CN_IOCANCEL_LOCK;

    return;
}


VOID
CnAcquireCancelSpinLock(
    OUT PCN_IRQL   Irql
    )
{

    KIRQL   irql;
    KIRQL   tempIrql;
    ULONG   currentCpu;


    if (KeGetCurrentIrql() != DISPATCH_LEVEL) {
        KeRaiseIrql(DISPATCH_LEVEL, &irql);
    }
    else {
        irql = DISPATCH_LEVEL;
    }

    currentCpu = KeGetCurrentProcessorNumber();

    if (CnCpuLockMask[currentCpu] >= CN_IOCANCEL_LOCK) {
        CNPRINT((
            "[Clusnet] CPU %u trying to acquire IoCancel lock out of order, mask %lx\n",
            currentCpu,
            CnCpuLockMask[currentCpu]
            ));

        DbgBreakPoint();
    }

    IoAcquireCancelSpinLock(&tempIrql);

    CnAssert(tempIrql == DISPATCH_LEVEL);

    *Irql = irql;

    CnCpuLockMask[currentCpu] |= CN_IOCANCEL_LOCK;

    return;
}


VOID
CnReleaseCancelSpinLock(
    IN CN_IRQL     Irql
    )
{
    ULONG currentCpu = KeGetCurrentProcessorNumber();


    if (KeGetCurrentIrql() !=  DISPATCH_LEVEL) {
        CNPRINT((
            "[Clusnet] CPU %u trying to release lock from passive level.\n",
            currentCpu
            ));

        DbgBreakPoint();
    }

    if ( !(CnCpuLockMask[currentCpu] & CN_IOCANCEL_LOCK) ) {
        CNPRINT((
            "[Clusnet] CPU %u trying to release IoCancel lock, which it doesn't hold, mask %lx\n",
            currentCpu,
            CnCpuLockMask[currentCpu]
            ));

        DbgBreakPoint();
    }

    CnCpuLockMask[currentCpu] &= ~(CN_IOCANCEL_LOCK);

    IoReleaseCancelSpinLock(Irql);

    return;

}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusexts\leaks\leaks.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    leaks.c

Abstract:

    A filter DLL for trying to detect memory, event, registry, and
    token handle leaks.

Author:

    Charlie Wickham/Rod Gamache

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#define _ADVAPI32_
#define _KERNEL32_
#include <windows.h>
#include <stdio.h>

#include "clusrtl.h"
#include "leaks.h"

HINSTANCE Kernel32Handle;
HINSTANCE Advapi32Handle;

FARPROC SystemLocalAlloc;
FARPROC SystemLocalFree;

FARPROC SystemCreateEventA;
FARPROC SystemCreateEventW;

FARPROC SystemRegOpenKeyA;
FARPROC SystemRegOpenKeyW;
FARPROC SystemRegOpenKeyExA;
FARPROC SystemRegOpenKeyExW;
FARPROC SystemRegCreateKeyA;
FARPROC SystemRegCreateKeyW;
FARPROC SystemRegCreateKeyExA;
FARPROC SystemRegCreateKeyExW;
FARPROC SystemRegCloseKey;

FARPROC SystemOpenProcessToken;
FARPROC SystemOpenThreadToken;
FARPROC SystemDuplicateToken;
FARPROC SystemDuplicateTokenEx;

FARPROC SystemCloseHandle;

#define SetSystemPointer( _h, _n ) \
    System##_n = GetProcAddress( _h, #_n );

BOOL LeaksVerbose = FALSE;

HANDLE_TABLE HandleTable[ MAX_HANDLE / HANDLE_DELTA ];


BOOLEAN
WINAPI
LeaksDllEntry(
    IN HINSTANCE    DllHandle,
    IN DWORD        Reason,
    IN LPVOID       Reserved
    )
/*++

Routine Description:

    Main DLL entrypoint

Arguments:

    DllHandle - Supplies the DLL handle.

    Reason - Supplies the call reason

Return Value:

    TRUE if successful

    FALSE if unsuccessful

--*/

{
    if (Reason == DLL_PROCESS_ATTACH) {
        DisableThreadLibraryCalls(DllHandle);
        ClRtlInitialize( TRUE, NULL );

        //
        // get pointers to the real functions
        //

        Kernel32Handle = LoadLibrary( "kernel32.dll" );
        Advapi32Handle = LoadLibrary( "advapi32.dll" );

        SetSystemPointer( Kernel32Handle, LocalAlloc );
        SetSystemPointer( Kernel32Handle, LocalFree );

        SetSystemPointer( Kernel32Handle, CreateEventA );
        SetSystemPointer( Kernel32Handle, CreateEventW );

        SetSystemPointer( Advapi32Handle, RegOpenKeyA );
        SetSystemPointer( Advapi32Handle, RegOpenKeyW );
        SetSystemPointer( Advapi32Handle, RegOpenKeyExA );
        SetSystemPointer( Advapi32Handle, RegOpenKeyExW );
        SetSystemPointer( Advapi32Handle, RegCreateKeyA );
        SetSystemPointer( Advapi32Handle, RegCreateKeyW );
        SetSystemPointer( Advapi32Handle, RegCreateKeyExA );
        SetSystemPointer( Advapi32Handle, RegCreateKeyExW );
        SetSystemPointer( Advapi32Handle, RegCloseKey );

        SetSystemPointer( Advapi32Handle, OpenProcessToken );
        SetSystemPointer( Advapi32Handle, OpenThreadToken );
        SetSystemPointer( Advapi32Handle, DuplicateToken );
        SetSystemPointer( Advapi32Handle, DuplicateTokenEx );

        SetSystemPointer( Kernel32Handle, CloseHandle );
    }

    return(TRUE);
}

HLOCAL
WINAPI
LEAKS_LocalAlloc(
    UINT    uFlags,
    SIZE_T  uBytes
    )
{
    HLOCAL  memory;
    PMEM_HDR memHdr;
    PVOID   callersAddress;
    PVOID   callersCaller;

    RtlGetCallersAddress(
            &callersAddress,
            &callersCaller );


    memHdr = (PVOID)(*SystemLocalAlloc)( uFlags, uBytes + sizeof(MEM_HDR) );
    if ( !memHdr ) {
        return NULL;
    }

    memHdr->Signature = HEAP_SIGNATURE_ALLOC;
    memHdr->CallersAddress = callersAddress;
    memHdr->CallersCaller = callersCaller;

    return(memHdr+1);
}

HLOCAL
WINAPI
LEAKS_LocalFree(
    HLOCAL  hMem
    )
{
    PMEM_HDR memHdr = hMem;
    PVOID   callersAddress;
    PVOID   callersCaller;
    CHAR    buf[128];

    if ( memHdr ) {
        --memHdr;
        if ( memHdr->Signature == HEAP_SIGNATURE_FREE ) {

            sprintf( buf, "Freeing %p a 2nd time!\n", memHdr );
            OutputDebugString( buf );
            DebugBreak();
        } else if ( memHdr->Signature == HEAP_SIGNATURE_ALLOC ) {

            RtlGetCallersAddress(&callersAddress,
                                 &callersCaller );

            memHdr->Signature = HEAP_SIGNATURE_FREE;
            memHdr->CallersAddress = callersAddress;
            memHdr->CallersCaller = callersCaller;
        } else {
            memHdr++;
        }
    } else {
#if 0
        sprintf( buf, "Passing NULL to LocalFree, tsk, tsk, tsk!!\n" );
        OutputDebugString( buf );
        DebugBreak();
#endif
    }

    return( (HLOCAL)(*SystemLocalFree)(memHdr) );
}

HANDLE
WINAPI
LEAKS_CreateEventA(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCSTR lpName
    )
{
    HANDLE  handle;
    PVOID   callersAddress;
    PVOID   callersCaller;

    handle = (HANDLE)(*SystemCreateEventA)(
                         lpEventAttributes,
                         bManualReset,
                         bInitialState,
                         lpName
                         );

    if ( handle != NULL ) {
        SetHandleTable( handle, TRUE, LeaksEvent );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint(LOG_NOISE, "[LEAKS] CreateEventA returns handle %1!X!, called from %2!X! and %3!X!\n",
                      handle,
                      callersAddress,
                      callersCaller );
    }

    return(handle);

} // CreateEventA


HANDLE
WINAPI
LEAKS_CreateEventW(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    )
{
    HANDLE  handle;
    PVOID   callersAddress;
    PVOID   callersCaller;

    handle = (HANDLE)(*SystemCreateEventW)(
                         lpEventAttributes,
                         bManualReset,
                         bInitialState,
                         lpName
                         );

    if ( handle != NULL ) {
        SetHandleTable( handle, TRUE, LeaksEvent );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint(LOG_NOISE,"[LEAKS] CreateEventW returns handle %1!X!, called from %2!X! and %3!X!\n",
                      handle,
                      callersAddress,
                      callersCaller );
    }

    return(handle);

} // CreateEventW

LONG
APIENTRY
LEAKS_RegOpenKeyA(
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (LONG)(*SystemRegOpenKeyA)(
                    hKey,
                    lpSubKey,
                    phkResult
                    );

    if ( status == ERROR_SUCCESS ) {
        SetHandleTable( *phkResult, TRUE, LeaksRegistry );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint(LOG_NOISE,"[LEAKS] RegOpenKeyA returns key %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *phkResult,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);

} // RegOpenKeyA

LONG
APIENTRY
LEAKS_RegOpenKeyW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (LONG)(*SystemRegOpenKeyW)(
                    hKey,
                    lpSubKey,
                    phkResult
                    );

    if ( status == ERROR_SUCCESS ) {
        SetHandleTable( *phkResult, TRUE, LeaksRegistry );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint(LOG_NOISE, "[LEAKS] RegOpenKeyW returns key %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *phkResult,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);

} // RegOpenKeyW

LONG
APIENTRY
LEAKS_RegOpenKeyExA(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD  ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (LONG)(*SystemRegOpenKeyExA)(
                    hKey,
                    lpSubKey,
                    ulOptions,
                    samDesired,
                    phkResult
                    );

    if ( status == ERROR_SUCCESS ) {
        SetHandleTable( *phkResult, TRUE, LeaksRegistry );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint(LOG_NOISE, "[LEAKS] RegOpenKeyExA returns key %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *phkResult,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);

} // RegOpenKeyExA

LONG
APIENTRY
LEAKS_RegOpenKeyExW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD  ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (LONG)(*SystemRegOpenKeyExW)(
                    hKey,
                    lpSubKey,
                    ulOptions,
                    samDesired,
                    phkResult
                    );

    if ( status == ERROR_SUCCESS ) {
        SetHandleTable( *phkResult, TRUE, LeaksRegistry );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint(LOG_NOISE, "[LEAKS] RegOpenKeyExW returns key %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *phkResult,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);

} // RegOpenKeyExW


LONG
APIENTRY
LEAKS_RegCreateKeyA(
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (LONG)(*SystemRegCreateKeyA)(
                    hKey,
                    lpSubKey,
                    phkResult
                    );

    if ( status == ERROR_SUCCESS ) {
        SetHandleTable( *phkResult, TRUE, LeaksRegistry );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint(LOG_NOISE, "[LEAKS] RegCreateKeyA returns key %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *phkResult,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);

} // RegCreateKeyA


LONG
APIENTRY
LEAKS_RegCreateKeyW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (LONG)(*SystemRegCreateKeyW)(
                    hKey,
                    lpSubKey,
                    phkResult
                    );

    if ( status == ERROR_SUCCESS ) {
        SetHandleTable( *phkResult, TRUE, LeaksRegistry );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint(LOG_NOISE, "[LEAKS] RegCreateKeyW returns key %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *phkResult,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);

} // RegCreateKeyW


LONG
APIENTRY
LEAKS_RegCreateKeyExA(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD  Reserved,
    LPSTR  lpClass,
    DWORD  dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (LONG)(*SystemRegCreateKeyExA)(hKey,
                                      lpSubKey,
                                      Reserved,
                                      lpClass,
                                      dwOptions,
                                      samDesired,
                                      lpSecurityAttributes,
                                      phkResult,
                                      lpdwDisposition
                                      );

    if ( status == ERROR_SUCCESS ) {
        SetHandleTable( *phkResult, TRUE, LeaksRegistry );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint(LOG_NOISE, "[LEAKS] RegCreateKeyExA returns key %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *phkResult,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);

} // RegCreateKeyExA

LONG
APIENTRY
LEAKS_RegCreateKeyExW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD  Reserved,
    LPWSTR lpClass,
    DWORD  dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (LONG)(*SystemRegCreateKeyExW)(
                    hKey,
                    lpSubKey,
                    Reserved,
                    lpClass,
                    dwOptions,
                    samDesired,
                    lpSecurityAttributes,
                    phkResult,
                    lpdwDisposition
                    );

    if ( status == ERROR_SUCCESS ) {
        SetHandleTable( *phkResult, TRUE, LeaksRegistry );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint(LOG_NOISE, "[LEAKS] RegCreateKeyExW returns key %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *phkResult,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);

} // RegCreateKeyExW


LONG
APIENTRY
LEAKS_RegCloseKey(
    HKEY hKey
    )
{
    LONG    status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (LONG)(*SystemRegCloseKey)( hKey );

    if ( status == ERROR_SUCCESS ) {
        SetHandleTable( hKey, FALSE, LeaksRegistry );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint(LOG_NOISE, "[LEAKS] RegCloseKey for key %1!X! returns status %2!u!, called from %3!X! and %4!X!\n",
                      hKey,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);

} // RegCloseKey

BOOL
WINAPI
LEAKS_CloseHandle(
    IN OUT HANDLE hObject
    )
{
    PVOID   callersAddress;
    PVOID   callersCaller;

    if ( HandleTable[ HINDEX( hObject )].InUse ) {

        RtlGetCallersAddress(&callersAddress,
                             &callersCaller );

        HandleTable[ HINDEX( hObject )].InUse = FALSE;
        HandleTable[ HINDEX( hObject )].Caller = callersAddress;
        HandleTable[ HINDEX( hObject )].CallersCaller = callersCaller;

        if ( LeaksVerbose ) {
            ClRtlLogPrint(LOG_NOISE, "[LEAKS] CloseHandle for handle %1!X!, called from %2!X! and %3!X!\n",
                          hObject,
                          callersAddress,
                          callersCaller );
        }
    }

    return (BOOL)(*SystemCloseHandle)( hObject );
}

BOOL
WINAPI
LEAKS_OpenProcessToken (
    IN HANDLE ProcessHandle,
    IN DWORD DesiredAccess,
    OUT PHANDLE TokenHandle
    )
{
    BOOL status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (BOOL)(*SystemOpenProcessToken)(ProcessHandle,
                                       DesiredAccess,
                                       TokenHandle);

    if ( status ) {
        SetHandleTable( *TokenHandle, TRUE, LeaksToken );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint(LOG_NOISE, "[LEAKS] OpenProcessToken returns handle %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *TokenHandle,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);
}


BOOL
WINAPI
LEAKS_OpenThreadToken (
    IN HANDLE ThreadHandle,
    IN DWORD DesiredAccess,
    IN BOOL OpenAsSelf,
    OUT PHANDLE TokenHandle
    )
{
    BOOL status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (BOOL)(*SystemOpenThreadToken)(ThreadHandle,
                                      DesiredAccess,
                                      OpenAsSelf,
                                      TokenHandle);

    if ( status ) {
        SetHandleTable( *TokenHandle, TRUE, LeaksToken );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint(LOG_NOISE, "[LEAKS] OpenThreadToken returns handle %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *TokenHandle,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);
}

BOOL
WINAPI
LEAKS_DuplicateToken(
    IN HANDLE ExistingTokenHandle,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    OUT PHANDLE DuplicateTokenHandle
    )
{
    BOOL status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (BOOL)(*SystemDuplicateToken)(ExistingTokenHandle,
                                     ImpersonationLevel,
                                     DuplicateTokenHandle);

    if ( status ) {
        SetHandleTable( *DuplicateTokenHandle, TRUE, LeaksToken );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint(LOG_NOISE, "[LEAKS] DuplicateToken returns handle %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *DuplicateTokenHandle,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);
}

BOOL
WINAPI
LEAKS_DuplicateTokenEx(
    IN HANDLE hExistingToken,
    IN DWORD dwDesiredAccess,
    IN LPSECURITY_ATTRIBUTES lpTokenAttributes,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    IN TOKEN_TYPE TokenType,
    OUT PHANDLE phNewToken)
{
    BOOL status;
    PVOID   callersAddress;
    PVOID   callersCaller;

    status = (BOOL)(*SystemDuplicateTokenEx)(hExistingToken,
                                       dwDesiredAccess,
                                       lpTokenAttributes,
                                       ImpersonationLevel,
                                       TokenType,
                                       phNewToken);

    if ( status ) {
        SetHandleTable( *phNewToken, TRUE, LeaksToken );
    }

    if ( LeaksVerbose ) {
        ClRtlLogPrint(LOG_NOISE, "[LEAKS] DuplicateTokenEx returns handle %1!X!, status %2!u!, called from %3!X! and %4!X!\n",
                      *phNewToken,
                      status,
                      callersAddress,
                      callersCaller );
    }

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\api\cnetapi.c ===
/*++

Copyright (c) 1996-2000  Microsoft Corporation

Module Name:

    cnapi.c

Abstract:

    Cluster Network configuration APIs

Author:

    Mike Massa (mikemas)  18-Mar-1996

Environment:

    User Mode - Win32

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <clusapi.h>
#include <clusdef.h>
#include <ntddcnet.h>
#include <cnettest.h>
#include <cnetapi.h>
#include <clusrtl.h>
#include <winsock2.h>
#include <tdi.h>
#include <align.h>


//
// Private Support Routines.
//
static NTSTATUS
OpenDevice(
    HANDLE *Handle,
    LPWSTR DeviceName,
    ULONG ShareAccess
    )
/*++

Routine Description:

    This function opens a specified IO device.

Arguments:

    Handle - pointer to location where the opened device Handle is
        returned.

    DriverName - name of the device to be opened.

Return Value:

    Windows Error Code.

--*/
{
    OBJECT_ATTRIBUTES   objectAttributes;
    IO_STATUS_BLOCK     ioStatusBlock;
    UNICODE_STRING      nameString;
    NTSTATUS            status;

    *Handle = NULL;

    //
    // Open a Handle to the device.
    //

    RtlInitUnicodeString(&nameString, DeviceName);

    InitializeObjectAttributes(
        &objectAttributes,
        &nameString,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );


    status = NtCreateFile(
                 Handle,
                 SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                 &objectAttributes,
                 &ioStatusBlock,
                 NULL,
                 FILE_ATTRIBUTE_NORMAL,
                 ShareAccess,
                 FILE_OPEN_IF,
                 0,
                 NULL,
                 0
                 );

    return(status);

}  // OpenDevice


NTSTATUS
DoIoctl(
    IN     HANDLE        Handle,
    IN     DWORD         IoctlCode,
    IN     PVOID         Request,
    IN     DWORD         RequestSize,
    IN     PVOID         Response,
    IN OUT PDWORD        ResponseSize,
    IN     LPOVERLAPPED  Overlapped
    )
/*++

Routine Description:

    Packages and issues an ioctl.

Arguments:

    Handle - An open file Handle on which to issue the request.

    IoctlCode - The IOCTL opcode.

    Request - A pointer to the input buffer.

    RequestSize - Size of the input buffer.

    Response - A pointer to the output buffer.

    ResponseSize - On input, the size in bytes of the output buffer.
                   On output, the number of bytes returned in the output buffer.

Return Value:

    NT Status Code.

--*/
{
    NTSTATUS           status;


    if (ARGUMENT_PRESENT(Overlapped)) {
        Overlapped->Internal = (ULONG_PTR) STATUS_PENDING;

        status = NtDeviceIoControlFile(
                     Handle,
                     Overlapped->hEvent,
                     NULL,
                     (((DWORD_PTR) Overlapped->hEvent) & 1) ? NULL : Overlapped,
                     (PIO_STATUS_BLOCK) &(Overlapped->Internal),
                     IoctlCode,
                     Request,
                     RequestSize,
                     Response,
                     *ResponseSize
                     );

    }
    else {
        IO_STATUS_BLOCK    ioStatusBlock = {0, 0};
        HANDLE             event = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (event != NULL) {

            //
            // Prevent operation from completing to a completion port.
            //
            event = (HANDLE) (((ULONG_PTR) event) | 1);

            status = NtDeviceIoControlFile(
                         Handle,
                         event,
                         NULL,
                         NULL,
                         &ioStatusBlock,
                         IoctlCode,
                         Request,
                         RequestSize,
                         Response,
                         *ResponseSize
                         );

            if (status == STATUS_PENDING) {
                status = NtWaitForSingleObject(
                             event,
                             TRUE,
                             NULL
                             );
            }

            if (status == STATUS_SUCCESS) {
                status = ioStatusBlock.Status;

                // NOTENOTE: on 64 bit this truncates might want to add > code

                *ResponseSize = (ULONG)ioStatusBlock.Information;
            }
            else {
                *ResponseSize = 0;
            }

            CloseHandle(event);
        }
        else {
            status = GetLastError();
        }
    }

    return(status);

}  // DoIoctl


#define FACILITY_CODE_MASK  0x0FFF0000
#define FACILITY_CODE_SHIFT 16
#define SHIFTED_FACILITY_CLUSTER  (FACILITY_CLUSTER_ERROR_CODE << FACILITY_CODE_SHIFT)


DWORD
NtStatusToClusnetError(
    NTSTATUS  Status
    )
{
    DWORD dosStatus;

    if ( !((Status & FACILITY_CODE_MASK) == SHIFTED_FACILITY_CLUSTER) ) {
        dosStatus = RtlNtStatusToDosError(Status);
    }
    else {
        //dosStatus = (DWORD) Status;
        switch ( Status ) {

        case STATUS_CLUSTER_INVALID_NODE:
            dosStatus = ERROR_CLUSTER_INVALID_NODE;
            break;

        case STATUS_CLUSTER_NODE_EXISTS:
            dosStatus = ERROR_CLUSTER_NODE_EXISTS;
            break;

        case STATUS_CLUSTER_JOIN_IN_PROGRESS:
            dosStatus = ERROR_CLUSTER_JOIN_IN_PROGRESS;
            break;

        case STATUS_CLUSTER_NODE_NOT_FOUND:
            dosStatus = ERROR_CLUSTER_NODE_NOT_FOUND;
            break;

        case STATUS_CLUSTER_LOCAL_NODE_NOT_FOUND:
            dosStatus = ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND;
            break;

        case STATUS_CLUSTER_NETWORK_EXISTS:
            dosStatus = ERROR_CLUSTER_NETWORK_EXISTS;
            break;

        case STATUS_CLUSTER_NETWORK_NOT_FOUND:
            dosStatus = ERROR_CLUSTER_NETWORK_NOT_FOUND;
            break;

        case STATUS_CLUSTER_NETINTERFACE_EXISTS:
            dosStatus = ERROR_CLUSTER_NETINTERFACE_EXISTS;
            break;

        case STATUS_CLUSTER_NETINTERFACE_NOT_FOUND:
            dosStatus =ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
            break;

        case STATUS_CLUSTER_INVALID_REQUEST:
            dosStatus = ERROR_CLUSTER_INVALID_REQUEST;
            break;

        case STATUS_CLUSTER_INVALID_NETWORK_PROVIDER:
            dosStatus = ERROR_CLUSTER_INVALID_NETWORK_PROVIDER;
            break;

        case STATUS_CLUSTER_NODE_DOWN:
            dosStatus = ERROR_CLUSTER_NODE_DOWN;
            break;

        case STATUS_CLUSTER_NODE_UNREACHABLE:
            dosStatus = ERROR_CLUSTER_NODE_UNREACHABLE;
            break;

        case STATUS_CLUSTER_NODE_NOT_MEMBER:
            dosStatus = ERROR_CLUSTER_NODE_NOT_MEMBER;
            break;

        case STATUS_CLUSTER_JOIN_NOT_IN_PROGRESS:
            dosStatus = ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS;
            break;

        case STATUS_CLUSTER_INVALID_NETWORK:
            dosStatus = ERROR_CLUSTER_INVALID_NETWORK;
            break;

        case STATUS_CLUSTER_NODE_UP:
            dosStatus = ERROR_CLUSTER_NODE_UP;
            break;

        case STATUS_CLUSTER_NODE_NOT_PAUSED:
            dosStatus = ERROR_CLUSTER_NODE_NOT_PAUSED;
            break;

        case STATUS_CLUSTER_NO_SECURITY_CONTEXT:
            dosStatus = ERROR_CLUSTER_NO_SECURITY_CONTEXT;
            break;

        case STATUS_CLUSTER_NETWORK_NOT_INTERNAL:
            dosStatus = ERROR_CLUSTER_NETWORK_NOT_INTERNAL;
            break;

        case STATUS_CLUSTER_NODE_ALREADY_UP:
            dosStatus = ERROR_CLUSTER_NODE_ALREADY_UP;
            break;

        case STATUS_CLUSTER_NODE_ALREADY_DOWN:
            dosStatus = ERROR_CLUSTER_NODE_ALREADY_DOWN;
            break;

        case STATUS_CLUSTER_NETWORK_ALREADY_ONLINE:
            dosStatus = ERROR_CLUSTER_NETWORK_ALREADY_ONLINE;
            break;

        case STATUS_CLUSTER_NETWORK_ALREADY_OFFLINE:
            dosStatus = ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE;
            break;

        case STATUS_CLUSTER_NODE_ALREADY_MEMBER:
            dosStatus = ERROR_CLUSTER_NODE_ALREADY_MEMBER;
            break;

        default:
            dosStatus = (DWORD)Status;
            break;
        }
    }

    return(dosStatus);
}


//
// Public Routines
//
HANDLE
ClusnetOpenControlChannel(
    IN ULONG ShareAccess
    )
{
    HANDLE    handle = NULL;
    DWORD     status;

    status = OpenDevice(&handle, L"\\Device\\ClusterNetwork", ShareAccess);

    if (status != ERROR_SUCCESS) {
        SetLastError(NtStatusToClusnetError(status));
    }

    return(handle);

}  // ClusnetOpenControlChannel


DWORD
ClusnetEnableShutdownOnClose(
    IN HANDLE  ControlChannel
    )
{
    NTSTATUS  status;
    ULONG  responseSize = 0;
    CLUSNET_SHUTDOWN_ON_CLOSE_REQUEST  request;
    DWORD  requestSize = sizeof(request);

    request.ProcessId = GetCurrentProcessId();

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CLUSNET_ENABLE_SHUTDOWN_ON_CLOSE,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

} // ClusnetEnableShutdownOnClose


DWORD
ClusnetDisableShutdownOnClose(
    IN HANDLE  ControlChannel
    )
{
    NTSTATUS  status;
    ULONG     responseSize = 0;


    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CLUSNET_DISABLE_SHUTDOWN_ON_CLOSE,
                 NULL,
                 0,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

} // ClusnetEnableShutdownOnClose


DWORD
ClusnetInitialize(
    IN HANDLE                             ControlChannel,
    IN CL_NODE_ID                         LocalNodeId,
    IN ULONG                              MaxNodes,
    IN CLUSNET_NODE_UP_ROUTINE            NodeUpRoutine,
    IN CLUSNET_NODE_DOWN_ROUTINE          NodeDownRoutine,
    IN CLUSNET_CHECK_QUORUM_ROUTINE       CheckQuorumRoutine,
    IN CLUSNET_HOLD_IO_ROUTINE            HoldIoRoutine,
    IN CLUSNET_RESUME_IO_ROUTINE          ResumeIoRoutine,
    IN CLUSNET_HALT_ROUTINE               HaltRoutine
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    CLUSNET_INITIALIZE_REQUEST   request;
    DWORD                        requestSize = sizeof(request);
    DWORD                        responseSize = 0;


    request.LocalNodeId = LocalNodeId;
    request.MaxNodes = MaxNodes;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CLUSNET_INITIALIZE,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetInitialize


DWORD
ClusnetShutdown(
    IN HANDLE       ControlChannel
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    DWORD                        requestSize = 0;
    DWORD                        responseSize = 0;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CLUSNET_SHUTDOWN,
                 NULL,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetShutdown


DWORD
ClusnetRegisterNode(
    IN HANDLE       ControlChannel,
    IN CL_NODE_ID   NodeId
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS              status;
    CX_NODE_REG_REQUEST   request;
    DWORD                 requestSize = sizeof(request);
    DWORD                 responseSize = 0;


    request.Id = NodeId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_REGISTER_NODE,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetRegisterNode


DWORD
ClusnetDeregisterNode(
    IN HANDLE       ControlChannel,
    IN CL_NODE_ID   NodeId
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                status;
    CX_NODE_DEREG_REQUEST   request;
    DWORD                   requestSize = sizeof(request);
    DWORD                   responseSize = 0;


    request.Id = NodeId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_DEREGISTER_NODE,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetDeregisterNode


DWORD
ClusnetRegisterNetwork(
    IN HANDLE               ControlChannel,
    IN CL_NETWORK_ID        NetworkId,
    IN ULONG                Priority,
    IN BOOLEAN              Restricted
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                   status;
    CX_NETWORK_REG_REQUEST     request;
    DWORD                      requestSize = sizeof(request);
    DWORD                      responseSize = 0;


    request.Id = NetworkId;
    request.Priority = Priority;
    request.Restricted = Restricted;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_REGISTER_NETWORK,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetRegisterNetwork


DWORD
ClusnetDeregisterNetwork(
    IN HANDLE         ControlChannel,
    IN CL_NETWORK_ID  NetworkId
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                   status;
    CX_NETWORK_DEREG_REQUEST   request;
    DWORD                      requestSize = sizeof(request);
    DWORD                      responseSize = 0;


    request.Id = NetworkId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_DEREGISTER_NETWORK,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetDeregisterNetwork


DWORD
ClusnetRegisterInterface(
    IN  HANDLE              ControlChannel,
    IN  CL_NODE_ID          NodeId,
    IN  CL_NETWORK_ID       NetworkId,
    IN  ULONG               Priority,
    IN  PWSTR               AdapterId,
    IN  ULONG               AdapterIdLength,
    IN  PVOID               TdiAddress,
    IN  ULONG               TdiAddressLength,
    OUT PULONG              MediaStatus
    )
/*++

Routine Description:

    Registers a node's interface on a network.

Arguments:

    ControlChannel - An open handle to the Cluster Network control device.

    NodeId - The ID of the node for which to register the interface.

    NetworkId - The ID of the network for which to register the interface.

    Priority - The priority value assigned to the interface. If a value of
               zero is specified, the interface will inherit its priority
               from the network.

    AdapterId - ID of adapter associated with interface
    
    AdapterIdLength - Length of buffer holding adapter ID, not including
                        terminating UNICODE_NULL character

    TdiAddress - A pointer to a TDI TRANSPORT_ADDRESS structure containing
                 the transport address of the interface.

    TdiAddressLength - The length, in bytes, of the TdiAddress buffer.
    
    MediaStatus - returned current status of media (e.g. cable disconnected)
    
Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                   status;
    PCX_INTERFACE_REG_REQUEST  request;
    DWORD                      requestSize;
    CX_INTERFACE_REG_RESPONSE  response;
    DWORD                      responseSize 
                               = sizeof(CX_INTERFACE_REG_RESPONSE);
    DWORD                      adapterIdOffset;


    // calculate the size of the request structure without the adapter
    // id string.
    requestSize = FIELD_OFFSET(CX_INTERFACE_REG_REQUEST, TdiAddress) +
                  TdiAddressLength;

    // round request to type alignment for adapter id string
    requestSize = ROUND_UP_COUNT(requestSize, TYPE_ALIGNMENT(PWSTR));

    // add buffer for interface name. null-terminate to be safe.
    if (AdapterId == NULL) {
        AdapterIdLength = 0;
    }
    adapterIdOffset = requestSize;
    requestSize += AdapterIdLength + sizeof(UNICODE_NULL);

    if (requestSize < sizeof(CX_INTERFACE_REG_REQUEST)) {
        requestSize = sizeof(CX_INTERFACE_REG_REQUEST);
    }

    request = LocalAlloc(LMEM_FIXED, requestSize);

    if (request == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ZeroMemory(request, requestSize);

    request->NodeId = NodeId;
    request->NetworkId = NetworkId;
    request->Priority = Priority;
    request->TdiAddressLength = TdiAddressLength;

    MoveMemory(
        &(request->TdiAddress[0]),
        TdiAddress,
        TdiAddressLength
        );

    request->AdapterIdLength = AdapterIdLength;
    request->AdapterIdOffset = adapterIdOffset;

    if (AdapterId != NULL) {
        CopyMemory(
            (PUWSTR)((PUCHAR)request + adapterIdOffset),
            AdapterId,
            AdapterIdLength
            );
    }

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_REGISTER_INTERFACE,
                 request,
                 requestSize,
                 &response,
                 &responseSize,
                 NULL
                 );

    LocalFree(request);

    if (MediaStatus != NULL) {
        *MediaStatus = response.MediaStatus;
    }

    return(NtStatusToClusnetError(status));

}  // ClusnetRegisterInterface


DWORD
ClusnetDeregisterInterface(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId,
    IN CL_NETWORK_ID   NetworkId
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    CX_INTERFACE_DEREG_REQUEST   request;
    DWORD                        requestSize = sizeof(request);
    DWORD                        responseSize = 0;


    request.NodeId = NodeId;
    request.NetworkId = NetworkId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_DEREGISTER_INTERFACE,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetDeregisterInterface


DWORD
ClusnetOnlineNodeComm(
    IN HANDLE      ControlChannel,
    IN CL_NODE_ID  NodeId
    )
/*++

Routine Description:

    Enables communication to the specified node.

Arguments:

    ControlChannel -  An open control channel handle to the Cluster Network
                      driver.

    NodeId - The ID of the node to which to enable communication.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                    status;
    CX_ONLINE_NODE_COMM_REQUEST      request;
    DWORD                       requestSize = sizeof(request);
    DWORD                       responseSize = 0;


    request.Id = NodeId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_ONLINE_NODE_COMM,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetOnlineNodeCommunication


DWORD
ClusnetOfflineNodeComm(
    IN HANDLE      ControlChannel,
    IN CL_NODE_ID  NodeId
    )
/*++

Routine Description:

    Disable communication to the specified node.

Arguments:

    ControlChannel -  An open control channel handle to the Cluster Network
                      driver.

    NodeId - The ID of the node to which to disable communication.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    CX_OFFLINE_NODE_COMM_REQUEST      request;
    DWORD                        requestSize = sizeof(request);
    DWORD                        responseSize = 0;


    request.Id = NodeId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_OFFLINE_NODE_COMM,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetOfflineNodeCommunication


DWORD
ClusnetOnlineNetwork(
    IN  HANDLE          ControlChannel,
    IN  CL_NETWORK_ID   NetworkId,
    IN  PWCHAR          TdiProviderName,
    IN  PVOID           TdiBindAddress,
    IN  ULONG           TdiBindAddressLength,
    IN  LPWSTR          AdapterName,
    OUT PVOID           TdiBindAddressInfo,
    IN  PULONG          TdiBindAddressInfoLength
    )
/*++

Routine Description:

    Brings a cluster network online using the specified TDI transport
    provider and local TDI transport address.

Arguments:

    ControlChannel - An open handle to the Cluster Network control device.

    NetworkId - The ID of the network to bring online.

    TdiProviderName - The name of the transport provider device that
                      this network should open (e.g. \Device\Udp).

    TdiAddress - A pointer to a TDI TRANSPORT_ADDRESS structure containing
                 the transport address of the local interface to which
                 the network should be bound.

    TdiAddressLength - The length, in bytes, of the TdiAddress buffer.

    AdapterName - name of the adapter on which this network is associated

    TdiBindAddressInfo - A pointer to a TDI_ADDRESS_INFO structure. On output,
                         this structure contains the actual address that
                         the provider opened.

    TdiBindAddressInfoLength - On input, a pointer to the size, in bytes,
                               of the TdiBindAddressInfo parameter. On
                               output, the variable is updated to the
                               amount of date returned in the
                               TdiBindAddressInfo structure.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                    status;
    PCX_ONLINE_NETWORK_REQUEST  request;
    DWORD                       requestSize;
    PVOID                       response;
    ULONG                       tdiProviderNameLength;
    ULONG                       adapterNameLength;


    tdiProviderNameLength = (wcslen(TdiProviderName) + 1) * sizeof(WCHAR);
    adapterNameLength = (wcslen(AdapterName) + 1) * sizeof(WCHAR);

    //
    // The request size is based on the size and required alignment
    // of each field of data following the structure.
    //
    requestSize = sizeof(CX_ONLINE_NETWORK_REQUEST);

    // Provider Name
    requestSize = ROUND_UP_COUNT(requestSize, TYPE_ALIGNMENT(PWSTR))
                  + tdiProviderNameLength;

    // Bind Address
    requestSize = ROUND_UP_COUNT(requestSize, TYPE_ALIGNMENT(PWSTR))
                  + TdiBindAddressLength;

    // Adapter Name
    requestSize = ROUND_UP_COUNT(requestSize, TYPE_ALIGNMENT(PWSTR))
                  + adapterNameLength;

    request = LocalAlloc(LMEM_FIXED, requestSize);

    if (request == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    request->Id = NetworkId;
    request->TdiProviderNameLength = tdiProviderNameLength;
    request->TdiProviderNameOffset = 
        ROUND_UP_COUNT(sizeof(CX_ONLINE_NETWORK_REQUEST),
                       TYPE_ALIGNMENT(PWSTR));

    MoveMemory(
        (((PUCHAR) request) + request->TdiProviderNameOffset),
        TdiProviderName,
        tdiProviderNameLength
        );

    request->TdiBindAddressLength = TdiBindAddressLength;
    request->TdiBindAddressOffset = 
        ROUND_UP_COUNT((request->TdiProviderNameOffset +
                        tdiProviderNameLength),
                       TYPE_ALIGNMENT(TRANSPORT_ADDRESS));
                         

    MoveMemory(
        (((PUCHAR) request) + request->TdiBindAddressOffset),
        TdiBindAddress,
        TdiBindAddressLength
        );

    request->AdapterNameLength = adapterNameLength;
    request->AdapterNameOffset = 
        ROUND_UP_COUNT((request->TdiBindAddressOffset +
                        TdiBindAddressLength),
                       TYPE_ALIGNMENT(PWSTR));

    MoveMemory(
        (((PUCHAR) request) + request->AdapterNameOffset),
        AdapterName,
        adapterNameLength
        );

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_ONLINE_NETWORK,
                 request,
                 requestSize,
                 TdiBindAddressInfo,
                 TdiBindAddressInfoLength,
                 NULL
                 );

    LocalFree(request);

    return(NtStatusToClusnetError(status));

}  // ClusnetOnlineNetwork


DWORD
ClusnetOfflineNetwork(
    IN HANDLE         ControlChannel,
    IN CL_NETWORK_ID  NetworkId
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    CX_OFFLINE_NETWORK_REQUEST   request;
    DWORD                        requestSize = sizeof(request);
    DWORD                        responseSize = 0;


    request.Id = NetworkId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_OFFLINE_NETWORK,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetOfflineNetwork


DWORD
ClusnetSetNetworkRestriction(
    IN HANDLE               ControlChannel,
    IN CL_NETWORK_ID        NetworkId,
    IN BOOLEAN              Restricted,
    IN ULONG                NewPriority
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                             status;
    CX_SET_NETWORK_RESTRICTION_REQUEST   request;
    DWORD                                responseSize = 0;


    request.Id = NetworkId;
    request.Restricted = Restricted;
    request.NewPriority = NewPriority;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_SET_NETWORK_RESTRICTION,
                 &request,
                 sizeof(CX_SET_NETWORK_RESTRICTION_REQUEST),
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

} // ClusnetSetNetworkRestriction


DWORD
ClusnetGetNetworkPriority(
    IN HANDLE               ControlChannel,
    IN  CL_NETWORK_ID       NetworkId,
    OUT PULONG              Priority
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                          status;
    PCX_GET_NETWORK_PRIORITY_REQUEST  request;
    PCX_GET_NETWORK_PRIORITY_RESPONSE response;
    DWORD                             requestSize;
    DWORD                             responseSize;


    requestSize = sizeof(CX_GET_NETWORK_PRIORITY_REQUEST);
    responseSize = sizeof(CX_GET_NETWORK_PRIORITY_RESPONSE);

    if (requestSize > responseSize) {
        request = LocalAlloc(LMEM_FIXED, requestSize);
        response = (PCX_GET_NETWORK_PRIORITY_RESPONSE) request;
    }
    else {
        response = LocalAlloc(LMEM_FIXED, responseSize);
        request = (PCX_GET_NETWORK_PRIORITY_REQUEST) response;
    }

    if (request == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    request->Id = NetworkId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_GET_NETWORK_PRIORITY,
                 request,
                 requestSize,
                 response,
                 &responseSize,
                 NULL
                 );

    if (status == STATUS_SUCCESS) {
        if (responseSize != sizeof(CX_GET_NETWORK_PRIORITY_RESPONSE)) {
            status = STATUS_UNSUCCESSFUL;
        }
        else {
            *Priority = response->Priority;
        }
    }

    LocalFree(request);

    return(NtStatusToClusnetError(status));

}  // ClusnetGetNetworkPriority


DWORD
ClusnetSetNetworkPriority(
    IN HANDLE               ControlChannel,
    IN  CL_NETWORK_ID       NetworkId,
    IN  ULONG               Priority
    )
/*++

Routine Description:

    ControlChannel - An open handle to the Cluster Network control device.


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                          status;
    CX_SET_NETWORK_PRIORITY_REQUEST   request;
    DWORD                             responseSize = 0;


    request.Id = NetworkId;
    request.Priority = Priority;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_SET_NETWORK_PRIORITY,
                 &request,
                 sizeof(CX_SET_NETWORK_PRIORITY_REQUEST),
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}   // ClusnetSetNetworkPriority


DWORD
ClusnetGetInterfacePriority(
    IN HANDLE               ControlChannel,
    IN  CL_NODE_ID          NodeId,
    IN  CL_NETWORK_ID       NetworkId,
    OUT PULONG              InterfacePriority,
    OUT PULONG              NetworkPriority

    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                            status;
    PCX_GET_INTERFACE_PRIORITY_REQUEST  request;
    PCX_GET_INTERFACE_PRIORITY_RESPONSE response;
    DWORD                               requestSize;
    DWORD                               responseSize;


    requestSize = sizeof(CX_GET_INTERFACE_PRIORITY_REQUEST);
    responseSize = sizeof(CX_GET_INTERFACE_PRIORITY_RESPONSE);

    if (requestSize > responseSize) {
        request = LocalAlloc(LMEM_FIXED, requestSize);
        response = (PCX_GET_INTERFACE_PRIORITY_RESPONSE) request;
    }
    else {
        response = LocalAlloc(LMEM_FIXED, responseSize);
        request = (PCX_GET_INTERFACE_PRIORITY_REQUEST) response;
    }

    if (request == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    request->NodeId = NodeId;
    request->NetworkId = NetworkId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_GET_INTERFACE_PRIORITY,
                 request,
                 requestSize,
                 response,
                 &responseSize,
                 NULL
                 );

    if (status == STATUS_SUCCESS) {
        if (responseSize != sizeof(CX_GET_INTERFACE_PRIORITY_RESPONSE)) {
            status = STATUS_UNSUCCESSFUL;
        }
        else {
            *InterfacePriority = response->InterfacePriority;
            *NetworkPriority = response->NetworkPriority;
        }
    }

    LocalFree(request);

    return(NtStatusToClusnetError(status));

}   // ClusnetGetInterfacePriority


DWORD
ClusnetSetInterfacePriority(
    IN HANDLE               ControlChannel,
    IN  CL_NODE_ID          NodeId,
    IN  CL_NETWORK_ID       NetworkId,
    IN  ULONG               Priority
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                            status;
    CX_SET_INTERFACE_PRIORITY_REQUEST   request;
    DWORD                               responseSize = 0;


    request.NodeId = NodeId;
    request.NetworkId = NetworkId;
    request.Priority = Priority;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_SET_INTERFACE_PRIORITY,
                 &request,
                 sizeof(CX_SET_INTERFACE_PRIORITY_REQUEST),
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetGetInterfacePriority


DWORD
ClusnetGetNodeCommState(
    IN  HANDLE                     ControlChannel,
    IN  CL_NODE_ID                 NodeId,
    OUT PCLUSNET_NODE_COMM_STATE   State
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                            status;
    PCX_GET_NODE_STATE_REQUEST          request;
    PCX_GET_NODE_STATE_RESPONSE         response;
    DWORD                               requestSize;
    DWORD                               responseSize;


    requestSize = sizeof(CX_GET_NODE_STATE_REQUEST);
    responseSize = sizeof(CX_GET_NODE_STATE_RESPONSE);

    if (requestSize > responseSize) {
        request = LocalAlloc(LMEM_FIXED, requestSize);
        response = (PCX_GET_NODE_STATE_RESPONSE) request;
    }
    else {
        response = LocalAlloc(LMEM_FIXED, responseSize);
        request = (PCX_GET_NODE_STATE_REQUEST) response;
    }

    if (request == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    request->Id = NodeId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_GET_NODE_STATE,
                 request,
                 requestSize,
                 response,
                 &responseSize,
                 NULL
                 );

    if (status == STATUS_SUCCESS) {
        if (responseSize != sizeof(CX_GET_NODE_STATE_RESPONSE)) {
            status = STATUS_UNSUCCESSFUL;
        }
        else {
            *State = response->State;
        }
    }

    LocalFree(request);

    return(NtStatusToClusnetError(status));

}  // ClusnetGetNodeState


DWORD
ClusnetGetNetworkState(
    IN  HANDLE                    ControlChannel,
    IN  CL_NETWORK_ID             NetworkId,
    OUT PCLUSNET_NETWORK_STATE    State
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                            status;
    PCX_GET_NETWORK_STATE_REQUEST       request;
    PCX_GET_NETWORK_STATE_RESPONSE      response;
    DWORD                               requestSize;
    DWORD                               responseSize;


    requestSize = sizeof(CX_GET_NETWORK_STATE_REQUEST);
    responseSize = sizeof(CX_GET_NETWORK_STATE_RESPONSE);

    if (requestSize > responseSize) {
        request = LocalAlloc(LMEM_FIXED, requestSize);
        response = (PCX_GET_NETWORK_STATE_RESPONSE) request;
    }
    else {
        response = LocalAlloc(LMEM_FIXED, responseSize);
        request = (PCX_GET_NETWORK_STATE_REQUEST) response;
    }

    if (request == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    request->Id = NetworkId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_GET_NETWORK_STATE,
                 request,
                 requestSize,
                 response,
                 &responseSize,
                 NULL
                 );

    if (status == STATUS_SUCCESS) {
        if (responseSize != sizeof(CX_GET_NETWORK_STATE_RESPONSE)) {
            status = STATUS_UNSUCCESSFUL;
        }
        else {
            *State = response->State;
        }
    }

    LocalFree(request);

    return(NtStatusToClusnetError(status));

}  // ClusnetGetNetworkState


DWORD
ClusnetGetInterfaceState(
    IN  HANDLE                    ControlChannel,
    IN  CL_NODE_ID                NodeId,
    IN  CL_NETWORK_ID             NetworkId,
    OUT PCLUSNET_INTERFACE_STATE  State
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                            status;
    PCX_GET_INTERFACE_STATE_REQUEST     request;
    PCX_GET_INTERFACE_STATE_RESPONSE    response;
    DWORD                               requestSize;
    DWORD                               responseSize;


    requestSize = sizeof(CX_GET_INTERFACE_STATE_REQUEST);
    responseSize = sizeof(CX_GET_INTERFACE_STATE_RESPONSE);

    if (requestSize > responseSize) {
        request = LocalAlloc(LMEM_FIXED, requestSize);
        response = (PCX_GET_INTERFACE_STATE_RESPONSE) request;
    }
    else {
        response = LocalAlloc(LMEM_FIXED, responseSize);
        request = (PCX_GET_INTERFACE_STATE_REQUEST) response;
    }

    if (request == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    request->NodeId = NodeId;
    request->NetworkId = NetworkId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_GET_INTERFACE_STATE,
                 request,
                 requestSize,
                 response,
                 &responseSize,
                 NULL
                 );

    if (status == STATUS_SUCCESS) {
        if (responseSize != sizeof(CX_GET_INTERFACE_STATE_RESPONSE)) {
            status = STATUS_UNSUCCESSFUL;
        }
        else {
            *State = response->State;
        }
    }

    LocalFree(request);

    return(NtStatusToClusnetError(status));

}  // ClusnetGetInterfaceState


#ifdef MM_IN_CLUSNSET

DWORD
ClusnetFormCluster(
    IN HANDLE       ControlChannel,
    IN ULONG        ClockPeriod,
    IN ULONG        SendHBRate,
    IN ULONG        RecvHBRate
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    CMM_FORM_CLUSTER_REQUEST     request;
    DWORD                        requestSize = sizeof(request);
    DWORD                        responseSize = 0;


    request.ClockPeriod = ClockPeriod;
    request.SendHBRate = SendHBRate;
    request.RecvHBRate = RecvHBRate;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CMM_FORM_CLUSTER,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetFormCluster


DWORD
ClusnetJoinCluster(
    IN     HANDLE              ControlChannel,
    IN     CL_NODE_ID          JoiningNodeId,
    IN     CLUSNET_JOIN_PHASE  Phase,
    IN     ULONG               JoinTimeout,
    IN OUT PVOID *             MessageToSend,
    OUT    PULONG              MessageLength,
    OUT    PULONG              DestNodeMask
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                     status;
    CMM_JOIN_CLUSTER_REQUEST     request;
    DWORD                        requestSize = sizeof(request);
    PCMM_JOIN_CLUSTER_RESPONSE   response;
    ULONG                        IoctlCode;
    DWORD                        responseSize;


    //
    // Parse the input parameters
    //
    if ( Phase == ClusnetJoinPhase1 )
        IoctlCode = IOCTL_CMM_JOIN_CLUSTER_PHASE1;
    else if ( Phase == ClusnetJoinPhase2 )
        IoctlCode = IOCTL_CMM_JOIN_CLUSTER_PHASE2;
    else if ( Phase == ClusnetJoinPhase3 )
        IoctlCode = IOCTL_CMM_JOIN_CLUSTER_PHASE3;
    else if ( Phase == ClusnetJoinPhase4 )
        IoctlCode = IOCTL_CMM_JOIN_CLUSTER_PHASE4;
    else if ( Phase == ClusnetJoinPhaseAbort )
        IoctlCode = IOCTL_CMM_JOIN_CLUSTER_ABORT;
    else
        return(ERROR_INVALID_PARAMETER);


    request.JoiningNode = JoiningNodeId;
    request.JoinTimeout = JoinTimeout;

    //
    // allocate space for the response buffer and a message space at the back
    // of the struct. Current RGP message requirements are 80 bytes
    // (sizeof(rgp_msgbuf)).
    //

    responseSize = sizeof(*response) + 200;

    if (*MessageToSend != NULL) {
        //
        // recycle old message buffer
        //
        response = CONTAINING_RECORD(
                       *MessageToSend,
                       CMM_JOIN_CLUSTER_RESPONSE,
                       SendData
                       );
    }
    else {
        response = LocalAlloc(LMEM_FIXED, responseSize);
    }

    if ( response == NULL ) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    status = DoIoctl(
                 ControlChannel,
                 IoctlCode,
                 &request,
                 requestSize,
                 response,
                 &responseSize,
                 NULL
                 );

    if (NT_SUCCESS(status)) {
        *MessageToSend = &(response->SendData[0]);
        *MessageLength = response->SizeOfSendData;
        *DestNodeMask = response->SendNodeMask;

        return(ERROR_SUCCESS);
    }

    LocalFree( response );
    *MessageToSend = NULL;

    return(NtStatusToClusnetError(status));

}  // ClusnetJoinCluster


VOID
ClusnetEndJoinCluster(
    IN HANDLE  ControlChannel,
    IN PVOID   LastSentMessage
    )
{
    ULONG                        responseSize = 0;
    PCMM_JOIN_CLUSTER_RESPONSE   response;


    if (LastSentMessage != NULL) {
        response = CONTAINING_RECORD(
                       LastSentMessage,
                       CMM_JOIN_CLUSTER_RESPONSE,
                       SendData
                       );

        LocalFree(response);
    }

    (VOID) DoIoctl(
               ControlChannel,
               IOCTL_CMM_JOIN_CLUSTER_END,
               NULL,
               0,
               NULL,
               &responseSize,
               NULL
               );

    return;

}  // ClusnetEndJoinCluster


DWORD
ClusnetDeliverJoinMessage(
    IN HANDLE  ControlChannel,
    IN PVOID   Message,
    IN ULONG   MessageLength
    )
{
    NTSTATUS   status;
    DWORD      responseSize = 0;


    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CMM_DELIVER_JOIN_MESSAGE,
                 Message,
                 MessageLength,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

} // ClusnetDeliverJoinMessage

DWORD
ClusnetLeaveCluster(
    IN HANDLE       ControlChannel
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS    status;
    DWORD       responseSize = 0;


    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CMM_LEAVE_CLUSTER,
                 NULL,
                 0,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetLeaveCluster


DWORD
ClusnetEvictNode(
    IN HANDLE       ControlChannel,
    IN ULONG        NodeId
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                    status;
    CMM_EJECT_CLUSTER_REQUEST   request;
    DWORD                       requestSize = sizeof(request);
    DWORD                       responseSize = 0;

    request.Node = NodeId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CMM_EJECT_CLUSTER,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetEvictNode


#endif // MM_IN_CLUSNSET

DWORD
ClusnetGetNodeMembershipState(
    IN  HANDLE                      ControlChannel,
    IN  ULONG                       NodeId,
    OUT CLUSNET_NODE_STATE * State
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                    status;
    CX_GET_NODE_MMSTATE_REQUEST   request;
    DWORD                       requestSize = sizeof(request);
    CX_GET_NODE_MMSTATE_RESPONSE  response;
    DWORD                       responseSize = sizeof(response);

    request.Id = NodeId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_GET_NODE_MMSTATE,
                 &request,
                 requestSize,
                 &response,
                 &responseSize,
                 NULL
                 );

    if (status == STATUS_SUCCESS) {

        *State = response.State;
    }

    return(NtStatusToClusnetError(status));

}  // ClusnetGetNodeMembershipState

DWORD
ClusnetSetNodeMembershipState(
    IN  HANDLE                      ControlChannel,
    IN  ULONG                       NodeId,
    IN  CLUSNET_NODE_STATE   State
    )
/*++

Routine Description:

    Set the internal node membership state to the indicated value

Arguments:

    ControlChannel - An open handle to the Cluster Network control device.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS status;
    CX_SET_NODE_MMSTATE_REQUEST request;
    DWORD requestSize = sizeof(request);
    DWORD responseSize;

    request.NodeId = NodeId;
    request.State = State;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_SET_NODE_MMSTATE,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetSetNodeMembershipState

DWORD
ClusnetSetEventMask(
    IN  HANDLE              ControlChannel,
    IN  CLUSNET_EVENT_TYPE  EventMask
    )

/*++

Routine Description:

    Based on the supplied callback pointers, set the mask of events
    generated in kernel mode in which this file handle is interested

Arguments:

    ControlChannel - An open handle to the Cluster Network control device.
    EventMask - bit mask of interested events

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                        status;
    CLUSNET_SET_EVENT_MASK_REQUEST  request;
    DWORD                           requestSize = sizeof(request);
    DWORD                           responseSize = 0;

    request.EventMask = EventMask;
    request.KmodeEventCallback = NULL;

    status = DoIoctl(
        ControlChannel,
        IOCTL_CLUSNET_SET_EVENT_MASK,
        &request,
        requestSize,
        NULL,
        &responseSize,
        NULL
        );

    return(NtStatusToClusnetError(status));

}  // ClusnetSetEventMask


DWORD
ClusnetGetNextEvent(
    IN  HANDLE          ControlChannel,
    OUT PCLUSNET_EVENT  Event,
    IN  LPOVERLAPPED    Overlapped  OPTIONAL
    )

/*++

Routine Description:

    Wait for the next event to be completed.

Arguments:

    ControlChannel - An open handle to the Cluster Network control device.
    Event - handle to event that is set when IO is complete
    Response - pointer to structure that is filled in when IRP completes

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS status;
    ULONG ResponseSize = sizeof( CLUSNET_EVENT );

    //
    // if no event passed in, then assume the caller wants to block.
    // we still need an event to block on while waiting...
    //

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CLUSNET_GET_NEXT_EVENT,
                 NULL,
                 0,
                 Event,
                 &ResponseSize,
                 Overlapped
                 );

    return(NtStatusToClusnetError(status));

}  // ClusnetGetNextEvent

DWORD
ClusnetHalt(
    IN  HANDLE  ControlChannel
    )

/*++

Routine Description:

    Tell clusnet that we need to halt immediately

Arguments:

    ControlChannel - An open handle to the Cluster Network control device.

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS status;
    DWORD responseSize;

    status = DoIoctl(
        ControlChannel,
        IOCTL_CLUSNET_HALT,
        NULL,
        0,
        NULL,
        &responseSize,
        NULL
        );

    return(NtStatusToClusnetError(status));

}  // ClusnetHalt

DWORD
ClusnetSetMemLogging(
    IN  HANDLE  ControlChannel,
    IN  ULONG   NumberOfEntries
    )

/*++

Routine Description:

    Turn in-memory logging in clusnet on or off.

Arguments:

    ControlChannel - An open handle to the Cluster Network control device.
    NumberOfEntires - # of entries to allocate for the log. Zero turns off logging

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS status;
    CLUSNET_SET_MEM_LOGGING_REQUEST request;
    DWORD requestSize = sizeof( request );
    DWORD responseSize;

    request.NumberOfEntries = NumberOfEntries;

    status = DoIoctl(
        ControlChannel,
        IOCTL_CLUSNET_SET_MEMORY_LOGGING,
        &request,
        requestSize,
        NULL,
        &responseSize,
        NULL
        );

    return(NtStatusToClusnetError(status));

}  // ClusnetSetMemLogging

DWORD
ClusnetSendPoisonPacket(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId
    )

/*++

Routine Description:

    Send a poison packet to the indicated node

Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                              status;
    CX_SEND_POISON_PKT_REQUEST            request;
    DWORD                                 requestSize = sizeof(request);
    DWORD                                 responseSize = 0;

    request.Id = NodeId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_SEND_POISON_PACKET,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));
}

DWORD
ClusnetSetOuterscreen(
    IN HANDLE          ControlChannel,
    IN ULONG           Outerscreen
    )

/*++

Routine Description:

    set the cluster member outerscreen

Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                              status;
    CX_SET_OUTERSCREEN_REQUEST            request;
    DWORD                                 requestSize = sizeof(request);
    DWORD                                 responseSize = 0;

    request.Outerscreen = Outerscreen;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_SET_OUTERSCREEN,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));
}

DWORD
ClusnetRegroupFinished(
    IN HANDLE          ControlChannel,
    IN ULONG           NewEpoch
    )

/*++

Routine Description:

    inform clusnet that regroup has finished

Arguments:

    ControlChannel - An open handle to the Cluster Network control device.
    NewEpoch - new event epoch used to detect stale events

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                              status;
    CX_REGROUP_FINISHED_REQUEST           request;
    DWORD                                 requestSize = sizeof(request);
    DWORD                                 responseSize = 0;

    request.NewEpoch = NewEpoch;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_REGROUP_FINISHED,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));
}

DWORD
ClusnetImportSecurityContexts(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      JoiningNodeId,
    IN PWCHAR          PackageName,
    IN ULONG           SignatureSize,
    IN PVOID           ServerContext,
    IN PVOID           ClientContext
    )

/*++

Routine Description:

    inform clusnet that regroup has finished

Arguments:

    ControlChannel - An open handle to the Cluster Network control device.
    NewEpoch - new event epoch used to detect stale events

Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/

{
    NTSTATUS                              status;
    CX_IMPORT_SECURITY_CONTEXT_REQUEST    request;
    DWORD                                 requestSize = sizeof(request);
    DWORD                                 responseSize = 0;

    request.JoiningNodeId = JoiningNodeId;
    request.PackageName = PackageName;
    request.PackageNameSize = sizeof(WCHAR) * ( wcslen( PackageName ) + 1 );
    request.SignatureSize = SignatureSize;
    request.ServerContext = ServerContext;
    request.ClientContext = ClientContext;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_IMPORT_SECURITY_CONTEXTS,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));
}

DWORD
ClusnetReserveEndpoint(
    IN HANDLE   ControlChannel,
    IN PWSTR    EndpointString
    )
/*++

Routine Description:

    Tell clusnet to tell TCP/IP to reserve the port number in 
    EndpointString.
    
Arguments:

    ControlChannel - An open handle to the Cluster Network control device.

    
    EndpointString - string containing port number assigned to clusnet
    
Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    USHORT port;
    DWORD err;
    DWORD responseSize = 0;
    NTSTATUS status;

    err = ClRtlTcpipStringToEndpoint(EndpointString, &port);

    if (err == ERROR_SUCCESS) {

        // TCP/IP needs the port in host byte-order format.
        // ClRtlTcpipStringToEndpoint returns it in network
        // byte-order format.
        port = ntohs(port);

        status = DoIoctl(
                     ControlChannel,
                     IOCTL_CX_RESERVE_ENDPOINT,
                     &port,
                     sizeof(port),
                     NULL,
                     &responseSize,
                     NULL
                     );
    
        err = NtStatusToClusnetError(status);
    }

    return err;
}

DWORD
ClusnetConfigureMulticast(
    IN HANDLE               ControlChannel,
    IN CL_NETWORK_ID        NetworkId,
    IN ULONG                MulticastNetworkBrand,
    IN PVOID                MulticastAddress,
    IN ULONG                MulticastAddressLength,
    IN PVOID                Key,
    IN ULONG                KeyLength,
    IN PVOID                Salt,
    IN ULONG                SaltLength
    )
/*++

Routine Description:

    Configures multicast parameters for the specified network.
    
--*/
{
    NTSTATUS                          status;
    PCX_CONFIGURE_MULTICAST_REQUEST   request;
    DWORD                             requestSize;
    DWORD                             responseSize;

    //
    // The request size is based on the size and required alignment
    // of each field of data following the structure. If there is no
    // data following the structure, only the structure is required.
    //
    requestSize = sizeof(CX_CONFIGURE_MULTICAST_REQUEST);

    if (MulticastAddressLength != 0) {
        requestSize = ROUND_UP_COUNT(requestSize,
                                     TYPE_ALIGNMENT(TRANSPORT_ADDRESS)
                                     ) +
                      MulticastAddressLength;
    }

    if (KeyLength != 0) {
        requestSize = ROUND_UP_COUNT(requestSize,
                                     TYPE_ALIGNMENT(PVOID)
                                     ) +
                      KeyLength;
    }

    if (SaltLength != 0) {
        requestSize = ROUND_UP_COUNT(requestSize,
                                     TYPE_ALIGNMENT(PVOID)
                                     ) +
                      SaltLength;
    }


    //
    // Allocate the request buffer.
    //
    request = LocalAlloc(LMEM_FIXED, requestSize);

    if (request == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    request->NetworkId = NetworkId;
    request->MulticastNetworkBrand = MulticastNetworkBrand;

    if (MulticastAddress != NULL) {
        request->MulticastAddress =
            ROUND_UP_COUNT(sizeof(CX_CONFIGURE_MULTICAST_REQUEST),
                           TYPE_ALIGNMENT(TRANSPORT_ADDRESS));
        MoveMemory(
            (((PUCHAR) request) + request->MulticastAddress),
            MulticastAddress,
            MulticastAddressLength
            );
        request->MulticastAddressLength = MulticastAddressLength;
    } else {
        request->MulticastAddress = 0;
        request->MulticastAddressLength = 0;
    }

    if (Key != NULL) {
        request->Key = 
            ROUND_UP_COUNT((request->MulticastAddress
                            + request->MulticastAddressLength),
                           TYPE_ALIGNMENT(PVOID));
        MoveMemory(
            (((PUCHAR) request) + request->Key),
            Key,
            KeyLength
            );
        request->KeyLength = KeyLength;
    } else {
        request->Key = 0;
        request->KeyLength = 0;
    }

    if (Salt != NULL) {
        request->Salt =
            ROUND_UP_COUNT((request->Key + request->KeyLength),
                           TYPE_ALIGNMENT(PVOID));
        MoveMemory(
            (((PUCHAR) request) + request->Salt),
            Salt,
            SaltLength
            );
        request->SaltLength = SaltLength;
    } else {
        request->Salt = 0;
        request->SaltLength = 0;
    }

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_CONFIGURE_MULTICAST,
                 request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    LocalFree(request);

    return(NtStatusToClusnetError(status));

} // ClusnetConfigureMulticast


DWORD
ClusnetGetMulticastReachableSet(
    IN  HANDLE               ControlChannel,
    IN  CL_NETWORK_ID        NetworkId,
    OUT ULONG              * NodeScreen
    )
/*++

Routine Description:

    Queries the current set of nodes considered reachable by
    a multicast on the specified network.
    
Arguments:

    ControlChannel - open clusnet control channel
    
    NetworkId - multicast network
    
    NodeScreen - mask of nodes
    
Return value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                                   status;
    CX_GET_MULTICAST_REACHABLE_SET_REQUEST     request;
    CX_GET_MULTICAST_REACHABLE_SET_RESPONSE    response;
    DWORD                                      responseSize = sizeof(response);

    request.Id = NetworkId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_GET_MULTICAST_REACHABLE_SET,
                 &request,
                 sizeof(request),
                 &response,
                 &responseSize,
                 NULL
                 );

    if (status == STATUS_SUCCESS) {

        *NodeScreen = response.NodeScreen;
    }

    return(NtStatusToClusnetError(status));

} // ClusnetGetMulticastReachableSet


#if DBG

DWORD
ClusnetSetDebugMask(
    IN HANDLE   ControlChannel,
    IN ULONG    Mask
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                        status;
    CLUSNET_SET_DEBUG_MASK_REQUEST  request;
    DWORD                           responseSize = 0;


    request.DebugMask = Mask;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CLUSNET_SET_DEBUG_MASK,
                 &request,
                 sizeof(CLUSNET_SET_DEBUG_MASK_REQUEST),
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));
}


DWORD
ClusnetOnlinePendingInterface(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId,
    IN CL_NETWORK_ID   NetworkId
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                              status;
    CX_ONLINE_PENDING_INTERFACE_REQUEST   request;
    DWORD                                 requestSize = sizeof(request);
    DWORD                                 responseSize = 0;


    request.NodeId = NodeId;
    request.NetworkId = NetworkId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_ONLINE_PENDING_INTERFACE,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));
}


DWORD
ClusnetOnlineInterface(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId,
    IN CL_NETWORK_ID   NetworkId
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                              status;
    CX_ONLINE_INTERFACE_REQUEST           request;
    DWORD                                 requestSize = sizeof(request);
    DWORD                                 responseSize = 0;


    request.NodeId = NodeId;
    request.NetworkId = NetworkId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_ONLINE_INTERFACE,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));
}


DWORD
ClusnetOfflineInterface(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId,
    IN CL_NETWORK_ID   NetworkId
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                              status;
    CX_OFFLINE_INTERFACE_REQUEST          request;
    DWORD                                 requestSize = sizeof(request);
    DWORD                                 responseSize = 0;


    request.NodeId = NodeId;
    request.NetworkId = NetworkId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_OFFLINE_INTERFACE,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));
}


DWORD
ClusnetFailInterface(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId,
    IN CL_NETWORK_ID   NetworkId
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                              status;
    CX_FAIL_INTERFACE_REQUEST             request;
    DWORD                                 requestSize = sizeof(request);
    DWORD                                 responseSize = 0;


    request.NodeId = NodeId;
    request.NetworkId = NetworkId;

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_FAIL_INTERFACE,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));
}


DWORD
ClusnetSendMmMsg(
    IN HANDLE          ControlChannel,
    IN CL_NODE_ID      NodeId,
    IN ULONG           Pattern
    )
/*++

Routine Description:


Arguments:

    ControlChannel - An open handle to the Cluster Network control device.


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    NTSTATUS                              status;
    CX_SEND_MM_MSG_REQUEST                request;
    DWORD                                 requestSize = sizeof(request);
    DWORD                                 responseSize = 0;
    DWORD                                 i;


    request.DestNodeId = NodeId;

    for (i=0; i < CX_MM_MSG_DATA_LEN; i++) {
        request.MessageData[i] = Pattern;
    }

    status = DoIoctl(
                 ControlChannel,
                 IOCTL_CX_SEND_MM_MSG,
                 &request,
                 requestSize,
                 NULL,
                 &responseSize,
                 NULL
                 );

    return(NtStatusToClusnetError(status));
}


#endif // DBG



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusexts\leaks\leaks.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    leaks.h

Abstract:

    header for leak filter dll

Author:

    Charlie Wickham (charlwi) 28-Sep-1998

Environment:

    User Mode

Revision History:

--*/

//
// keep a table of caller and caller's caller for open handles. indexed by
// handle value divided by 4.  !leaks in clusexts will display this info.
//

typedef enum _LEAKS_HANDLE_TYPE {
    LeaksEvent = 1,
    LeaksRegistry,
    LeaksToken
} LEAKS_HANDLE_TYPE;


typedef struct _HANDLE_TABLE {
    PVOID Caller;
    PVOID CallersCaller;
    LEAKS_HANDLE_TYPE HandleType;
    BOOL InUse;
} HANDLE_TABLE, *PHANDLE_TABLE;

#define MAX_HANDLE      4096
#define HANDLE_DELTA    4
#define HINDEX( _h )    (((DWORD_PTR) _h ) / HANDLE_DELTA )

#define SetHandleTable( _h, _inuse, _htype )                        \
    {                                                               \
        RtlGetCallersAddress(&callersAddress,                       \
                             &callersCaller );                      \
        HandleTable[ HINDEX( _h )].InUse = _inuse;                  \
        HandleTable[ HINDEX( _h )].HandleType = _htype;             \
        HandleTable[ HINDEX( _h )].Caller = callersAddress;         \
        HandleTable[ HINDEX( _h )].CallersCaller = callersCaller;   \
    }

//
// leaks memory header. This structure is at the front of the allocated area
// and the area behind it is returned to the caller. PlaceHolder holds the
// heap free list pointer. Signature holds ALOC or FREE.
//

#define HEAP_SIGNATURE_ALLOC 'COLA'
#define HEAP_SIGNATURE_FREE 'EERF'

typedef struct _MEM_HDR {
    PVOID   PlaceHolder;
    DWORD   Signature;
    PVOID   CallersAddress;
    PVOID   CallersCaller;
} MEM_HDR, *PMEM_HDR;

/* end leaks.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\driver\precomp.h ===
#include "clusnet.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\driver\event.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    event.c

Abstract:

    general kernel to user event facility. Maintains a list of events that have
    occurred and delivers them to Umode via the completion of an IOCTL IRP.

    How this works:

    The consumer opens a handle to clusnet and issues an
    IOCTL_CLUSNET_SET_EVENT_MASK IRP indicating a mask of the events in which it
    is interested. A kernel consumer must also supply a callback routine through
    which it is notified about the event, i.e, they don't need to drop an
    IOCTL_CLUSNET_GET_NEXT_EVENT IRP to receive notifications. The consumer is
    linked onto the EventFileHandles list through the Linkage field in the
    CN_FSCONTEXT structure. All synchronization is provided through one lock
    called EventLock.

    Umode consumers issue an IOCTL_CLUSNET_GET_NEXT_EVENT IRP to reap the next
    interesting event. If no events are queued, the IRP is marked pending and a
    pointer to it is stored in the FS context. CnEventIrpCancel is set as the
    cancel routine. Note that only one IRP can be pending at a time; if an IRP
    is already queued, this one is completed with STATUS_UNSUCCESSFUL.

    If an event is waiting, it is removed from the FS context's list, the data
    copied to the IRP's buffer and completed with success.

    Posters call CnIssueEvent to post the event of interest. This obtains the
    event lock, walks the file object list, and for consumers that are
    interested in this event, allocates an Event context block (maintained as a
    nonpaged lookaside list) and queues it to that file object's list of
    events. It then posts a work queue item to run CnpDeliverEvents. We can't do
    IRP processing directly since that would violate lock ordering within
    clusnet.

    CnDeliverEvents obtains the IO cancel and event locks, then runs the file
    context list to see if there are events queued for any pending IRPs. If so,
    the event data is copied to the systembuffer and the IRP is completed.

Author:

    Charlie Wickham (charlwi) 17-Feb-1997

Environment:

    Kernel Mode

Revision History:

    Charlie Wickham (charlwi) 25-Oct-1999

        Split CnIssueEvent into two routines: CnIssueEvent which strictly looks
        up the apporpriate consumers of the event and CnpDeliverEvents which
        runs at IRQL 0 to complete any IRPs that are waiting for new
        events. This was done to prevent out of order event delivery; since the
        event lock was near the top of locks to acquire first, the net IF down
        events had to be queued to a worker thread which was bad. Now the event
        lock is lowest which doesn't require a worker thread to post. The worker
        thread still runs when it detects that there is an IRP waiting for an
        event.
        
    David Dion (daviddio) 29-Nov-2000
    
        Disallow modification of the EventFileHandles list while event
        deliveries are in process. Because CnpDeliverEvents and CnIssueEvent
        drop their locks to deliver (via IRP completion and kmode callback,
        respectively), a race condition can occur where an FS context event
        mask is cleared and the FS context linkage fields are reset.
        Modification of the EventFileHandles list is prevented using a count
        of currently delivering threads that is protected by the EventLock.

 --*/

#include "precomp.h"
#pragma hdrstop
#include "event.tmh"

/* Forward */

NTSTATUS
CnSetEventMask(
    IN  PCN_FSCONTEXT                   FsContext,
    IN  PCLUSNET_SET_EVENT_MASK_REQUEST EventRequest
    );

NTSTATUS
CnGetNextEvent(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CnIssueEvent(
    CLUSNET_EVENT_TYPE Event,
    CL_NODE_ID NodeId OPTIONAL,
    CL_NETWORK_ID NetworkId OPTIONAL
    );

VOID
CnEventIrpCancel(
    PDEVICE_OBJECT   DeviceObject,
    PIRP             Irp
    );

/* End Forward */


VOID
CnStartEventDelivery(
    VOID
    )
/*++

Routine Description:

    Synchronizes iteration through EventFileHandles list with respect
    to the EventDeliveryInProgress counter and the EventDeliveryComplete
    KEVENT.
    
Arguments:

    None.
    
Return value:

    None.
    
Notes:

    Called with and returns with EventLock held.
    
--*/
{
    CnVerifyCpuLockMask(
        CNP_EVENT_LOCK,                    // Required
        0,                                 // Forbidden
        CNP_EVENT_LOCK_MAX                 // Maximum
        );

    CnAssert(EventDeliveryInProgress >= 0);
 
    if (++EventDeliveryInProgress == 1) {
#if DBG
        if (KeResetEvent(&EventDeliveryComplete) == 0) {
            CnAssert(FALSE);
        }
#else // DBG
        KeClearEvent(&EventDeliveryComplete);
#endif // DBG
    }
    
    EventRevisitRequired = FALSE;

    CnVerifyCpuLockMask(
        CNP_EVENT_LOCK,                    // Required
        0,                                 // Forbidden
        CNP_EVENT_LOCK_MAX                 // Maximum
        );

} // CnStartEventDelivery


BOOLEAN
CnStopEventDelivery(
    VOID
    )
/**    
Routine Description:

    Synchronizes iteration through EventFileHandles list with respect
    to the EventDeliveryInProgress counter and the EventDeliveryComplete
    KEVENT. Checks the EventRevisitRequired flag to determine if an
    event IRP arrived during the preceding delivery.
    
    When signalling EventDeliveryComplete, IO_NETWORK_INCREMENT is used
    to try to avoid starvation of waiters versus other event-delivering
    threads.
    
Arguments:

    None.
    
Return value:

    TRUE if a new event or event IRP may have been added to the 
    EventFileHandles list, and it is necessary to rescan.    
    
Notes:

    Called with and returns with EventLock held.
    
--*/
{
    BOOLEAN eventRevisitRequired = EventRevisitRequired;

    CnVerifyCpuLockMask(
        CNP_EVENT_LOCK,                    // Required
        0,                                 // Forbidden
        CNP_EVENT_LOCK_MAX                 // Maximum
        );

    EventRevisitRequired = FALSE;

    CnAssert(EventDeliveryInProgress >= 1);
    if (--EventDeliveryInProgress == 0) {
        if (KeSetEvent(
                &EventDeliveryComplete,
                IO_NETWORK_INCREMENT,
                FALSE
                ) != 0) {
            CnAssert(FALSE);
        }
    }

    if (eventRevisitRequired) {
        CnTrace(
            EVENT_DETAIL, StopDeliveryRevisitRequired,
            "[CN] CnStopEventDelivery: revisit required."
            );
    }

    CnVerifyCpuLockMask(
        CNP_EVENT_LOCK,                    // Required
        0,                                 // Forbidden
        CNP_EVENT_LOCK_MAX                 // Maximum
        );

    return(eventRevisitRequired);

} // CnStopEventDelivery


BOOLEAN
CnIsEventDeliveryInProgress(
    VOID
    )
/*++
    
Routine Description:

    Checks the EventDeliveryInProgress counter to determine if
    an event delivery is in progress. If so, sets the 
    EventRevisitRequired flag.
    
Arguments:

    None.
    
Return value:

    TRUE if event delivery in progress.
    
Notes:

    Called with and returns with EventLock held.
    
--*/
{
    CnVerifyCpuLockMask(
        CNP_EVENT_LOCK,                    // Required
        0,                                 // Forbidden
        CNP_EVENT_LOCK_MAX                 // Maximum
        );

    if (EventDeliveryInProgress > 0) {
        return(EventRevisitRequired = TRUE);
    } else {
        return(FALSE);
    }

    CnVerifyCpuLockMask(
        CNP_EVENT_LOCK,                    // Required
        0,                                 // Forbidden
        CNP_EVENT_LOCK_MAX                 // Maximum
        );

} // CnIsEventDeliveryInProgress


BOOLEAN
CnWaitForEventDelivery(
    IN PKIRQL EventLockIrql
    )    
/*++

Routine Description:

    Waits for EventDeliveryComplete event to be signalled as long
    as EventDeliveryInProgress counter is greater than zero.
    
    Maintains a starvation counter to avoid looping forever.
    Starvation threshold of 100 was chosen arbitrarily.
    
Arguments:

    EventLockIrql - irql at which EventLock was acquired
    
Return value:

    TRUE if returning with no deliveries in progress
    FALSE if starvation threshold is exceeded and returning with 
        deliveries in progress

Notes:

    Called with and returns with EventLock held; however, EventLock
    may be dropped and reacquired during execution.
    
    This call blocks, so no other spinlocks may be held at 
    invocation.
    
--*/
{
    NTSTATUS status;
    ULONG    starvationCounter;

    CnVerifyCpuLockMask(
        CNP_EVENT_LOCK,                    // Required
        (ULONG) ~(CNP_EVENT_LOCK),         // Forbidden
        CNP_EVENT_LOCK_MAX                 // Maximum
        );

    starvationCounter = 100;

    while (starvationCounter-- > 0) {

        if (EventDeliveryInProgress == 0) {
            return(TRUE);
        }

        CnReleaseLock(&EventLock, *EventLockIrql);

        status = KeWaitForSingleObject(
                     &EventDeliveryComplete,
                     Executive,
                     KernelMode,
                     FALSE,
                     NULL
                     );
        CnAssert(status == STATUS_SUCCESS);

        CnAcquireLock(&EventLock, EventLockIrql);
    }

    CnTrace(
        EVENT_DETAIL, EventWaitStarvation,
        "[CN] CnWaitForEventDelivery: starvation threshold %u "
        "exceeded.",
        starvationCounter
        );

    IF_CNDBG( CN_DEBUG_EVENT ) {
        CNPRINT(("[CN] CnWaitForEventDelivery: starvation threshold "
                 "expired.\n"));
    }    

    CnVerifyCpuLockMask(
        CNP_EVENT_LOCK,                    // Required
        (ULONG) ~(CNP_EVENT_LOCK),         // Forbidden
        CNP_EVENT_LOCK                     // Maximum
        );

    return(FALSE);

} // CnWaitForEventDelivery


NTSTATUS
CnSetEventMask(
    IN  PCN_FSCONTEXT                   FsContext,
    IN  PCLUSNET_SET_EVENT_MASK_REQUEST EventRequest
    )

/*++

Routine Description:

    For a given file handle context, set the event mask associated
    with it

Arguments:

    FsContext - pointer to the clusnet file handle context block
    EventMask - mask of interested events

Return Value:

    STATUS_TIMEOUT if unable to modify EventFileHandles list.
    STATUS_INVALID_PARAMETER_MIX if providing NULL event mask on
        first call
    STATUS_SUCCESS on success.
    
Notes:

    This call may block.

--*/

{
    CN_IRQL     OldIrql;
    NTSTATUS    Status = STATUS_SUCCESS;
    PLIST_ENTRY NextEntry;

    CnVerifyCpuLockMask(
        0,                                 // Required
        0xFFFFFFFF,                        // Forbidden
        0                                  // Maximum
        );

    CnAcquireLock( &EventLock, &OldIrql );

#if 0
    PCN_FSCONTEXT ListFsContext;

    NextEntry = EventFileHandles.Flink;
    while ( NextEntry != &EventFileHandles ) {

        ListFsContext = CONTAINING_RECORD( NextEntry, CN_FSCONTEXT, Linkage );
        if ( ListFsContext == FsContext ) {

            break;
        }

        NextEntry = ListFsContext->Linkage.Flink;
    }
#endif

    if ( EventRequest->EventMask != 0 ) {

        //
        // adding or updating a handle. If not in the list then add them.
        // Remember the events and, if appropriate, the callback func to use
        // when an event occurs.
        //
        if ( IsListEmpty( &FsContext->Linkage )) {

            //
            // Do not modify the EventFileHandles list if an event
            // delivery is in progress.
            //
            if (CnWaitForEventDelivery(&OldIrql)) {
                InsertHeadList( &EventFileHandles, &FsContext->Linkage );
            } else {
                Status = STATUS_TIMEOUT;
            }
        }

        if (NT_SUCCESS(Status)) {
            FsContext->EventMask = EventRequest->EventMask;
            FsContext->KmodeEventCallback = EventRequest->KmodeEventCallback;
        }

    } else if ( !IsListEmpty( &FsContext->Linkage )) {

        //
        // Null event mask and the fileobj on the event file obj list means
        // remove this guy from the list. Zap any events that may been queued
        // waiting for an IRP. Re-init the linkage to empty so we'll add them
        // back on if they re-init the mask.
        //
        FsContext->EventMask = 0;

        //
        // Do not modify the EventFileHandles list if an event 
        // delivery is in progress. It is okay to modify this
        // FsContext structure since the EventLock is held.
        //
        if (CnWaitForEventDelivery(&OldIrql)) {
            RemoveEntryList( &FsContext->Linkage );
            InitializeListHead( &FsContext->Linkage );
        } else {
            Status = STATUS_TIMEOUT;
        }

        while ( !IsListEmpty( &FsContext->EventList )) {

            NextEntry = RemoveHeadList( &FsContext->EventList );
            ExFreeToNPagedLookasideList( EventLookasideList, NextEntry );
        }
    } else {

        //
        // can't provide NULL event mask first time in
        //
        Status = STATUS_INVALID_PARAMETER_MIX;
    }

    CnReleaseLock( &EventLock, OldIrql );

    if (Status != STATUS_SUCCESS) {
        CnTrace(
            EVENT_DETAIL, SetEventMaskFailed,
            "[CN] CnSetEventMask failed, status %!status!.",
            Status
            );
    }

    CnVerifyCpuLockMask(
        0,                                 // Required
        0xFFFFFFFF,                        // Forbidden
        0                                  // Maximum
        );

    return Status;
} // CnSetEventMask

VOID
CnpDeliverEvents(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Parameter
    )

/*++

Routine Description:

    Deliver any queued events to those who are waiting. If an IRP is already
    queued, complete it with the info supplied.

Arguments:

    DeviceObject - clusnet device object, not used
    Parameter - PIO_WORKITEM that must be freed

Return Value:

    None

--*/

{
    CN_IRQL                 OldIrql;
    PCLUSNET_EVENT_ENTRY    Event;
    PCLUSNET_EVENT_RESPONSE UserEventData;
    PCN_FSCONTEXT           FsContext;
    PLIST_ENTRY             NextFsHandleEntry;
    PIRP                    EventIrp;
    PLIST_ENTRY             Entry;
    ULONG                   eventsDelivered = 0;
    BOOLEAN                 revisitRequired;

    CnVerifyCpuLockMask(
        0,                                 // Required
        0xFFFFFFFF,                        // Forbidden
        0                                  // Maximum
        );

    //
    // free the workitem
    //
    IoFreeWorkItem( (PIO_WORKITEM) Parameter );

    //
    // grab the cancel and event locks and loop through the file handles,
    // looking to see which file objs have events queued and IRPs pending.
    //
    CnAcquireCancelSpinLock ( &OldIrql );
    CnAcquireLockAtDpc( &EventLock );

    do {

        //
        // Indicate that a thread is iterating through the EventFileHandles
        // list to deliver events.
        //
        CnTrace(
            EVENT_DETAIL, DeliverEventsStartIteration,
            "[CN] CnpDeliverEvents: starting file handles list iteration."
            );

        CnStartEventDelivery();

        NextFsHandleEntry = EventFileHandles.Flink;
        while ( NextFsHandleEntry != &EventFileHandles ) {

            FsContext = CONTAINING_RECORD( NextFsHandleEntry, CN_FSCONTEXT, Linkage );

            EventIrp = FsContext->EventIrp;
            if ( !IsListEmpty( &FsContext->EventList ) && EventIrp != NULL ) {

                //
                // clear the pointer to the pended IRP and remove the entry from the
                // event list while synchronized.
                //
                FsContext->EventIrp = NULL;
                Entry = RemoveHeadList( &FsContext->EventList );

                CnReleaseLockFromDpc( &EventLock );

                Event = CONTAINING_RECORD( Entry, CLUSNET_EVENT_ENTRY, Linkage );

                IF_CNDBG( CN_DEBUG_EVENT ) {
                    CNPRINT(("[CN] CnDeliverEvents: completing IRP %p with event %d\n",
                             EventIrp, Event->EventData.EventType));
                }

                EventIrp->CancelIrql = OldIrql;

                UserEventData = (PCLUSNET_EVENT_RESPONSE)EventIrp->AssociatedIrp.SystemBuffer;

                UserEventData->Epoch = Event->EventData.Epoch;
                UserEventData->EventType = Event->EventData.EventType;
                UserEventData->NodeId = Event->EventData.NodeId;
                UserEventData->NetworkId = Event->EventData.NetworkId;

                ExFreeToNPagedLookasideList( EventLookasideList, Entry );

                CnTrace(
                    EVENT_DETAIL, DeliverEventsCompletingIrp,
                    "[CN] Completing IRP to deliver event: "
                    "Epoch %u, Type %u, NodeId %u, NetworkId %u.",
                    UserEventData->Epoch,
                    UserEventData->EventType,
                    UserEventData->NodeId,
                    UserEventData->NetworkId
                    );

                //
                // IO Cancel lock is released in this routine
                //
                CnCompletePendingRequest(EventIrp,
                                         STATUS_SUCCESS,
                                         sizeof( CLUSNET_EVENT_RESPONSE ));

                CnAcquireCancelSpinLock ( &OldIrql );
                CnAcquireLockAtDpc( &EventLock );

                ++eventsDelivered;
            }

            NextFsHandleEntry = FsContext->Linkage.Flink;
        }

        CnTrace(
            EVENT_DETAIL, DeliverEventsStopIteration,
            "[CN] CnpDeliverEvents: file handle list iteration complete."
            );

    } while ( CnStopEventDelivery() );

    CnReleaseLockFromDpc( &EventLock );
    CnReleaseCancelSpinLock( OldIrql );

    CnTrace(
        EVENT_DETAIL, DeliverEventsSummary,
        "[CN] CnpDeliverEvents: delivered %u events.",
        eventsDelivered
        );

    IF_CNDBG( CN_DEBUG_EVENT ) {
        CNPRINT(("[CN] CnDeliverEvents: events delivered %d\n", eventsDelivered ));
    }

    CnVerifyCpuLockMask(
        0,                                 // Required
        0xFFFFFFFF,                        // Forbidden
        0                                  // Maximum
        );

} // CnDeliverEvents

NTSTATUS
CnIssueEvent(
    CLUSNET_EVENT_TYPE EventType,
    CL_NODE_ID NodeId OPTIONAL,
    CL_NETWORK_ID NetworkId OPTIONAL
    )

/*++

Routine Description:

    Post an event to each file object's event queue that is interested in this
    type of event. Schedule a work queue item to run down the file objs to
    deliver the events. We can't complete the IRPs directly since we might
    violate the locking order inside clusnet.

Arguments:

    EventType - type of event

    NodeId - optional node Id associated with event

    NetworkId - optional network Id associated with event

Return Value:

    STATUS_SUCCESS
    STATUS_INSUFFICIENT_RESOUCES

--*/

{
    CN_IRQL                 OldIrql;
    PCLUSNET_EVENT_ENTRY    Event;
    PCLUSNET_EVENT_RESPONSE UserData;
    PCN_FSCONTEXT           FsContext;
    PLIST_ENTRY             NextFsHandleEntry;
    PIRP                    EventIrp;
    PIO_WORKITEM            EventWorkItem;
    BOOLEAN                 startupWorkerThread = FALSE;
    BOOLEAN                 eventHandled = FALSE;

    CnVerifyCpuLockMask(
        0,                                 // Required
        CNP_EVENT_LOCK,                    // Forbidden
        CNP_EVENT_LOCK_PRECEEDING          // Maximum
        );

    CnTrace(
        EVENT_DETAIL, CnIssueEvent,
        "[CN] CnIssueEvent: Event Type %u, NodeId %u, NetworkId %u.",
        EventType, NodeId, NetworkId
        );

    IF_CNDBG( CN_DEBUG_EVENT ) {
        CNPRINT(( "[CN] CnIssueEvent: Event type 0x%lx Node: %d Network: %d\n",
                  EventType, NodeId, NetworkId ));
    }

    //
    // grab the event lock and loop through the file handles, looking to see
    // which ones are interested in this event
    //
    CnAcquireLock( &EventLock, &OldIrql );

    //
    // Indicate that a thread is iterating through the EventFileHandles
    // list to deliver events (kernel-mode callback counts as a delivery).
    //
    CnTrace(
        EVENT_DETAIL, IssueEventStartIteration,
        "[CN] CnIssueEvent: starting file handles list iteration."
        );

    CnStartEventDelivery();

    NextFsHandleEntry = EventFileHandles.Flink;

    if ( NextFsHandleEntry == &EventFileHandles ) {
        IF_CNDBG( CN_DEBUG_EVENT ) {
            CNPRINT(( "[CN] CnIssueEvent: No file objs on event file handle list\n"));
        }
    }

    while ( NextFsHandleEntry != &EventFileHandles ) {

        FsContext = CONTAINING_RECORD( NextFsHandleEntry, CN_FSCONTEXT, Linkage );

        if ( FsContext->EventMask & EventType ) {

            //
            // if kernel mode, then issue the callback
            //
            if ( FsContext->KmodeEventCallback ) {

                //
                // up the ref count so have a valid Flink when we return any
                // potential call out
                //
                CnReferenceFsContext( FsContext );

                CnReleaseLock( &EventLock, OldIrql );

                CnTrace(
                    EVENT_DETAIL, IssueEventKmodeCallback,
                    "[CN] CnIssueEvent: invoking kernel-mode callback %p "
                    "for Event Type %u NodeId %u NetworkId %u.",
                    FsContext->KmodeEventCallback,
                    EventType,
                    NodeId,
                    NetworkId
                    );

                (*FsContext->KmodeEventCallback)( EventType, NodeId, NetworkId );

                CnAcquireLock( &EventLock, &OldIrql );
                CnDereferenceFsContext( FsContext );

            } else {

                //
                // post a copy of this event on the handle's list.
                //
                Event = ExAllocateFromNPagedLookasideList( EventLookasideList );

                if ( Event == NULL ) {

                    IF_CNDBG( CN_DEBUG_EVENT ) {
                        CNPRINT(( "[CN] CnIssueEvent: No more Event buffers!\n"));
                    }

                    CnReleaseLock( &EventLock, OldIrql );
                    return STATUS_INSUFFICIENT_RESOURCES;
                }

                Event->EventData.Epoch = InterlockedExchange( &EventEpoch, EventEpoch );
                Event->EventData.EventType = EventType;
                Event->EventData.NodeId = NodeId;
                Event->EventData.NetworkId = NetworkId;

                InsertTailList( &FsContext->EventList, &Event->Linkage );

                //
                // run the worker thread only if there is an IRP already queued
                //
                if ( FsContext->EventIrp ) {
                    startupWorkerThread = TRUE;
                }
            }

            eventHandled = TRUE;
        }

        NextFsHandleEntry = FsContext->Linkage.Flink;
    }

    //
    // Indicate that iteration through the EventFileHandles list
    // is complete.
    //
    CnTrace(
        EVENT_DETAIL, IssueEventStartIteration,
        "[CN] CnIssueEvent: file handles list iteration complete."
        );

    startupWorkerThread |= CnStopEventDelivery();

    CnReleaseLock( &EventLock, OldIrql );

    if ( startupWorkerThread ) {
        //
        // schedule deliver event routine to run
        //
        
        CnTrace(
            EVENT_DETAIL, IssueEventScheduleWorker,
            "[CN] CnIssueEvent: scheduling worker thread."
            );

        EventWorkItem = IoAllocateWorkItem( CnDeviceObject );
        if ( EventWorkItem != NULL ) {

            IoQueueWorkItem(
                EventWorkItem, 
                CnpDeliverEvents, 
                DelayedWorkQueue,
                EventWorkItem
                );
        }
    }

    if ( !eventHandled ) {
        CnTrace(
            EVENT_DETAIL, IssueEventNoConsumers,
            "[CN] CnIssueEvent: No consumers for Event Type %u Node %u Network %u.",
            EventType, NodeId, NetworkId
            );

        IF_CNDBG( CN_DEBUG_EVENT ) {
            CNPRINT(( "[CN] CnIssueEvent: No consumers for Event type 0x%lx Node: %d Network: %d\n",
                      EventType, NodeId, NetworkId ));
        }
    }

    CnVerifyCpuLockMask(
        0,                                 // Required
        CNP_EVENT_LOCK,                    // Forbidden
        CNP_EVENT_LOCK_PRECEEDING          // Maximum
        );

    return STATUS_SUCCESS;

} // CnIssueEvent

VOID
CnEventIrpCancel(
    PDEVICE_OBJECT   DeviceObject,
    PIRP             Irp
    )

/*++

Routine Description:

    Cancellation handler for CnGetNextEvent requests.

Return Value:

    None

Notes:

    Called with cancel spinlock held.
    Returns with cancel spinlock released.

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
    PFILE_OBJECT fileObject;
    CN_IRQL cancelIrql = Irp->CancelIrql;
    PCN_FSCONTEXT FsContext = (PCN_FSCONTEXT) IrpSp->FileObject->FsContext;

    CnMarkIoCancelLockAcquired();

    fileObject = CnBeginCancelRoutine(Irp);

    CnAcquireLockAtDpc( &EventLock );

    CnReleaseCancelSpinLock(DISPATCH_LEVEL);

    CnTrace(
        EVENT_DETAIL, EventIrpCancel,
        "[CN] Cancelling event IRP %p.",
        Irp
        );

    IF_CNDBG( CN_DEBUG_EVENT ) {
        CNPRINT(("[CN] CnEventIrpCancel: canceling %p\n", Irp ));
    }

    CnAssert(DeviceObject == CnDeviceObject);

    //
    // We can only complete the irp if it really belongs to the Event code. The
    // IRP could have been completed before we acquired the Event lock.
    //
    if ( FsContext->EventIrp == Irp ) {

        FsContext->EventIrp = NULL;

        CnReleaseLock( &EventLock, cancelIrql );

        CnAcquireCancelSpinLock(&(Irp->CancelIrql));

        CnEndCancelRoutine(fileObject);

        CnCompletePendingRequest(Irp, STATUS_CANCELLED, 0);

        return;
    }

    CnReleaseLock( &EventLock, cancelIrql );

    CnAcquireCancelSpinLock( &cancelIrql );

    CnEndCancelRoutine(fileObject);

    CnReleaseCancelSpinLock(cancelIrql);

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return;

}  // CnEventIrpCancel

NTSTATUS
CnGetNextEvent(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine obtains the next event from the event list for
    this file handle. If an event is queued, it completes this IRP
    with the event data. Otherwise, the IRP is pended, waiting for
    an event to be posted.

Return Value:

   STATUS_PENDING         if IRP successfully captured
   STATUS_UNSUCCESSFUL    if no more room in the list or IRP couldn't be

Notes:

    Returns with cancel spinlock released.

--*/

{
    NTSTATUS                Status;
    KIRQL                   OldIrql;
    PLIST_ENTRY             Entry;
    PCLUSNET_EVENT_ENTRY    Event;
    PCN_FSCONTEXT           FsContext = IrpSp->FileObject->FsContext;
    PCLUSNET_EVENT_RESPONSE UserEventData = (PCLUSNET_EVENT_RESPONSE)
                                                Irp->AssociatedIrp.SystemBuffer;
    BOOLEAN                 DeliveryInProgress = FALSE;

    CnVerifyCpuLockMask(
        0,                                 // Required
        0xFFFFFFFF,                        // Forbidden
        0                                  // Maximum
        );

    //
    // acquire the IO cancel lock, then our event lock so we're synch'ed
    // with regards to the state of the IRP and the event list
    //
    CnAcquireCancelSpinLock( &OldIrql );
    CnAcquireLockAtDpc( &EventLock );

    //
    // check first if we have an event queued. if we have an event queued 
    // and there is no delivery in progress we can complete the IRP now.
    // otherwise, we need to pend the IRP to avoid out-of-order delivery.
    //
    if ( !IsListEmpty( &FsContext->EventList )
         && !(DeliveryInProgress = CnIsEventDeliveryInProgress())
         ) {

        //
        // complete the IRP now
        //
        CnReleaseCancelSpinLock(DISPATCH_LEVEL);

        Entry = RemoveHeadList( &FsContext->EventList );

        CnReleaseLock( &EventLock, OldIrql );

        Event = CONTAINING_RECORD( Entry, CLUSNET_EVENT_ENTRY, Linkage );
        *UserEventData = Event->EventData;

        CnTrace(
            EVENT_DETAIL, GetNextEventCompletingIrp,
            "[CN] Completing IRP to deliver event: "
            "Epoch %u, Type %u, NodeId %u, NetworkId %u.",
            UserEventData->Epoch,
            UserEventData->EventType,
            UserEventData->NodeId,
            UserEventData->NetworkId
            );

        IF_CNDBG( CN_DEBUG_EVENT ) {
            CNPRINT(("[CN] CnGetNextEvent: completing IRP %p with event %d\n",
                     Irp, Event->EventData.EventType));
        }

        ExFreeToNPagedLookasideList( EventLookasideList, Entry );

        Irp->IoStatus.Information = sizeof(CLUSNET_EVENT_RESPONSE);

        Status = STATUS_SUCCESS;

    } else {

        //
        // make sure we have room for the new IRP
        //
        if ( FsContext->EventIrp ) {

            CnReleaseCancelSpinLock( DISPATCH_LEVEL );

            CnTrace(
                EVENT_DETAIL, GetNextIrpAlreadyPending,
                "[CN] CnGetNextEvent: IRP %p is already pending.",
                FsContext->EventIrp
                );

            IF_CNDBG( CN_DEBUG_EVENT ) {
                CNPRINT(("[CN] CnGetNextEvent: IRP %p is already pending\n",
                         FsContext->EventIrp));
            }

            Status = STATUS_UNSUCCESSFUL;
        } else {

            Status = CnMarkRequestPending( Irp, IrpSp, CnEventIrpCancel );
            CnAssert( NT_SUCCESS( Status ));

            CnReleaseCancelSpinLock( DISPATCH_LEVEL );

            if ( NT_SUCCESS( Status )) {

                //
                // remember this IRP in our open file context block
                //
                FsContext->EventIrp = Irp;

                CnTrace(
                    EVENT_DETAIL, GetNextEventDeliveryInProgress,
                    "[CN] CnGetNextEvent: pending IRP %p, "
                    "delivery in progress: %!bool!",
                    Irp, DeliveryInProgress
                    );
                
                IF_CNDBG( CN_DEBUG_EVENT ) {
                    CNPRINT(("[CN] CnGetNextEvent: pending IRP %p\n", Irp));
                }

                Status = STATUS_PENDING;
            }
        }

        CnReleaseLock(&EventLock, OldIrql);
    }

    CnVerifyCpuLockMask(
        0,                                 // Required
        0xFFFFFFFF,                        // Forbidden
        0                                  // Maximum
        );

    return Status;

} // CnGetNextEvent

/* end event.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\driver\dispatch.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

    Dispatch routines for the Cluster Network Driver.

Author:

    Mike Massa (mikemas)           January 3, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-03-97    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Data
//
PCN_FSCONTEXT    CnExclusiveChannel = NULL;

//
// Un-exported Prototypes
//
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenProcess (
    OUT PHANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN PCLIENT_ID ClientId OPTIONAL
    );

//
// Local Prototypes
//
FILE_FULL_EA_INFORMATION UNALIGNED *
CnFindEA(
    PFILE_FULL_EA_INFORMATION  StartEA,
    CHAR                      *TargetName,
    USHORT                     TargetNameLength
    );

NTSTATUS
CnCreate(
    IN PDEVICE_OBJECT     DeviceObject,
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CnCleanup(
    IN PDEVICE_OBJECT     DeviceObject,
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CnClose(
    IN PDEVICE_OBJECT     DeviceObject,
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CnEnableShutdownOnClose(
    PIRP   Irp
    );

//
// Mark pageable code.
//
#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, CnDispatchDeviceControl)
#pragma alloc_text(PAGE, CnFindEA)
#pragma alloc_text(PAGE, CnCreate)
#pragma alloc_text(PAGE, CnEnableShutdownOnClose)

#endif // ALLOC_PRAGMA



//
// Function definitions
//
VOID
CnDereferenceFsContext(
    PCN_FSCONTEXT   FsContext
    )
{
    LONG  newValue = InterlockedDecrement(&(FsContext->ReferenceCount));


    CnAssert(newValue >= 0);

    if (newValue != 0) {
        return;
    }

    //
    // Set the cleanup event.
    //
    KeSetEvent(&(FsContext->CleanupEvent), 0, FALSE);

    return;

}  // CnDereferenceFsContext


NTSTATUS
CnMarkRequestPending(
    PIRP                Irp,
    PIO_STACK_LOCATION  IrpSp,
    PDRIVER_CANCEL      CancelRoutine
    )
/*++

Notes:

    Called with IoCancelSpinLock held.

--*/
{
    PCN_FSCONTEXT   fsContext = (PCN_FSCONTEXT) IrpSp->FileObject->FsContext;
    CN_IRQL         oldIrql;

    //
    // Set up for cancellation
    //
    CnAssert(Irp->CancelRoutine == NULL);

    if (!Irp->Cancel) {

        IoMarkIrpPending(Irp);
        IoSetCancelRoutine(Irp, CancelRoutine);

        CnReferenceFsContext(fsContext);

        IF_CNDBG(CN_DEBUG_IRP) {
            CNPRINT((
                "[Clusnet] Pending irp %p fileobj %p.\n",
                Irp,
                IrpSp->FileObject
                ));
        }

        return(STATUS_SUCCESS);
    }

    //
    // The IRP has already been cancelled.
    //

    IF_CNDBG(CN_DEBUG_IRP) {
        CNPRINT(("[Clusnet] irp %p already cancelled.\n", Irp));
    }

    return(STATUS_CANCELLED);

}  // CnPrepareIrpForCancel



VOID
CnCompletePendingRequest(
    IN PIRP      Irp,
    IN NTSTATUS  Status,
    IN ULONG     BytesReturned
    )
/*++

Routine Description:

    Completes a pending request.

Arguments:

    Irp           - A pointer to the IRP for this request.
    Status        - The final status of the request.
    BytesReturned - Bytes sent/received information.

Return Value:

    None.

Notes:

    Called with IoCancelSpinLock held. Lock Irql is stored in Irp->CancelIrql.
    Releases IoCancelSpinLock before returning.

--*/

{
    PIO_STACK_LOCATION  irpSp;
    PCN_FSCONTEXT       fsContext;


    irpSp = IoGetCurrentIrpStackLocation(Irp);
    fsContext = (PCN_FSCONTEXT) irpSp->FileObject->FsContext;

    
    IoSetCancelRoutine(Irp, NULL);

    CnDereferenceFsContext(fsContext);

    IF_CNDBG(CN_DEBUG_IRP) {
        CNPRINT((
            "[Clusnet] Completing irp %p fileobj %p, status %lx\n",
            Irp,
            irpSp->FileObject,
            Status
            ));
    }

    if (Irp->Cancel || fsContext->CancelIrps) {

        IF_CNDBG(CN_DEBUG_IRP) {
            CNPRINT(("[Clusnet] Completed irp %p was cancelled\n", Irp));
        }

        Status = (NTSTATUS) STATUS_CANCELLED;
        BytesReturned = 0;
    }

    CnReleaseCancelSpinLock(Irp->CancelIrql);

    Irp->IoStatus.Status = (NTSTATUS) Status;
    Irp->IoStatus.Information = BytesReturned;

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    return;

}  // CnCompletePendingRequest



PFILE_OBJECT
CnBeginCancelRoutine(
    IN  PIRP     Irp
    )

/*++

Routine Description:

    Performs common bookkeeping for irp cancellation.

Arguments:

    Irp          - Pointer to I/O request packet

Return Value:

    A pointer to the file object on which the irp was submitted.
    This value must be passed to CnEndCancelRequest().

Notes:

    Called with cancel spinlock held.

--*/

{
    PIO_STACK_LOCATION  irpSp;
    PCN_FSCONTEXT       fsContext;
    NTSTATUS            status = STATUS_SUCCESS;
    PFILE_OBJECT        fileObject;


    CnAssert(Irp->Cancel);

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    fileObject = irpSp->FileObject;
    fsContext = (PCN_FSCONTEXT) fileObject->FsContext;

    IoSetCancelRoutine(Irp, NULL);

    //
    // Add a reference so the object can't be closed while the cancel routine
    // is executing.
    //
    CnReferenceFsContext(fsContext);

    IF_CNDBG(CN_DEBUG_IRP) {
        CNPRINT((
            "[Clusnet] Cancelling irp %p fileobj %p\n",
            Irp,
            fileObject
            ));
    }

    return(fileObject);

}  // CnBeginCancelRoutine



VOID
CnEndCancelRoutine(
    PFILE_OBJECT    FileObject
    )
/*++

Routine Description:

    Performs common bookkeeping for irp cancellation.

Arguments:


Return Value:


Notes:

    Called with cancel spinlock held.

--*/
{

    PCN_FSCONTEXT   fsContext = (PCN_FSCONTEXT) FileObject->FsContext;


    //
    // Remove the reference placed on the endpoint by the cancel routine.
    //
    CnDereferenceFsContext(fsContext);

    IF_CNDBG(CN_DEBUG_IRP) {
        CNPRINT((
            "[Clusnet] Finished cancelling, fileobj %p\n",
            FileObject
            ));
    }

    return;

} // CnEndCancelRoutine



NTSTATUS
CnDispatchInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )

/*++

Routine Description:

    This is the dispatch routine for Internal Device Control IRPs.
    This is the hot path for kernel-mode TDI clients.

Arguments:

    DeviceObject - Pointer to device object for target device
    Irp          - Pointer to I/O request packet

Return Value:

    An NT status code.

--*/

{
    PIO_STACK_LOCATION   irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS            status = STATUS_SUCCESS;
    ULONG          fileType = (ULONG)((ULONG_PTR)irpSp->FileObject->FsContext2);
#if DBG
    KIRQL            entryIrql = KeGetCurrentIrql();
#endif // DBG


    Irp->IoStatus.Information = 0;

    if (DeviceObject == CdpDeviceObject) {
        if (fileType == TDI_TRANSPORT_ADDRESS_FILE) {
            if (irpSp->MinorFunction == TDI_SEND_DATAGRAM) {
                status = CxSendDatagram(Irp, irpSp);

#if DBG
                CnAssert(entryIrql == KeGetCurrentIrql());
#endif // DBG
                return(status);
            }
            else if (irpSp->MinorFunction == TDI_RECEIVE_DATAGRAM) {
                status = CxReceiveDatagram(Irp, irpSp);
#if DBG
                CnAssert(entryIrql == KeGetCurrentIrql());
#endif // DBG
                return(status);
            }
            else if (irpSp->MinorFunction ==  TDI_SET_EVENT_HANDLER) {
                status = CxSetEventHandler(Irp, irpSp);

#if DBG
                CnAssert(entryIrql == KeGetCurrentIrql());
#endif // DBG

                return(status);
            }

            //
            // Fall through to common code.
            //
        }

        //
        // These functions are common to all endpoint types.
        //
        switch(irpSp->MinorFunction) {

        case TDI_QUERY_INFORMATION:
            status = CxQueryInformation(Irp, irpSp);
            break;

        case TDI_SET_INFORMATION:
        case TDI_ACTION:
            CNPRINT((
                "[Clusnet] Call to unimplemented TDI function 0x%x\n",
                irpSp->MinorFunction
                ));
            status = STATUS_NOT_IMPLEMENTED;
            break;

        default:
            CNPRINT((
                "[Clusnet] Call to invalid TDI function 0x%x\n",
                irpSp->MinorFunction
                ));
            status = STATUS_INVALID_DEVICE_REQUEST;
        }
    }
    else {
        CNPRINT((
            "[Clusnet] Invalid internal device control function 0x%x on device %ws\n",
            irpSp->MinorFunction,
            DD_CLUSNET_DEVICE_NAME
            ));

        status = STATUS_INVALID_DEVICE_REQUEST;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    #if DBG
        CnAssert(entryIrql == KeGetCurrentIrql());
    #endif // DBG

    return(status);

} // CnDispatchInternalDeviceControl



NTSTATUS
CnDispatchDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )

/*++

Routine Description:

    This is the top-level dispatch routine for Device Control IRPs.

Arguments:

    DeviceObject - Pointer to device object for target device
    Irp          - Pointer to I/O request packet

Return Value:

    An NT status code.

Notes:

    This routine completes any IRPs for which the return code is not
    STATUS_PENDING.

--*/

{
    NTSTATUS              status;
    CCHAR                 ioIncrement = IO_NO_INCREMENT;
    BOOLEAN               resourceAcquired = FALSE;
    PIO_STACK_LOCATION    irpSp = IoGetCurrentIrpStackLocation(Irp);
    ULONG                 ioControlCode =
                              irpSp->Parameters.DeviceIoControl.IoControlCode;
    ULONG                 fileType = 
                          (ULONG) ((ULONG_PTR) irpSp->FileObject->FsContext2);


    PAGED_CODE();

    //
    // Set this in advance. Any subsequent dispatch routine that cares
    // about it will modify it itself.
    //
    Irp->IoStatus.Information = 0;

    //
    // The following commands are valid on only TDI address objects.
    //
    if (fileType == TDI_TRANSPORT_ADDRESS_FILE) {
        if (ioControlCode == IOCTL_CX_IGNORE_NODE_STATE) {
            status = CxDispatchDeviceControl(Irp, irpSp);
        }
        else {
            //
            // Not handled. Return an error.
            //
            status = STATUS_INVALID_DEVICE_REQUEST;
        }

        goto complete_request;
    }
    
    //
    // The remaining commands are valid for control channels.
    //
    CnAssert(fileType == TDI_CONTROL_CHANNEL_FILE);
    
    //
    // The following set of commands affect only this file object and
    // can be issued at any time. We do not need to hold the CnResource
    // in order to process them. Nor do we need to be in the initialized.
    // state.
    //
    switch(ioControlCode) {
    
    case IOCTL_CLUSNET_SET_EVENT_MASK:
        {
            PCN_FSCONTEXT fsContext = irpSp->FileObject->FsContext;
            PCLUSNET_SET_EVENT_MASK_REQUEST request;
            ULONG                           requestSize;
    
    
            request = (PCLUSNET_SET_EVENT_MASK_REQUEST)
                      Irp->AssociatedIrp.SystemBuffer;
    
            requestSize =
                irpSp->Parameters.DeviceIoControl.InputBufferLength;
    
            if (requestSize >= sizeof(CLUSNET_SET_EVENT_MASK_REQUEST))
            {
                //
                // Kernel mode callers must supply a callback.
                // User mode callers must not.
                //
                if ( !( (Irp->RequestorMode == KernelMode) &&
                        (request->KmodeEventCallback == NULL)
                      )
                     &&
                     !( (Irp->RequestorMode == UserMode) &&
                        (request->KmodeEventCallback != NULL)
                      )
                   )
                {
                    status = CnSetEventMask( fsContext, request );
                }
                else {
                    status = STATUS_INVALID_PARAMETER;
                }
            }
            else {
                status = STATUS_INVALID_PARAMETER;
            }
        }
        goto complete_request;
    
    case IOCTL_CLUSNET_GET_NEXT_EVENT:
        {
            PCLUSNET_EVENT_RESPONSE response;
            ULONG                   responseSize;
    
    
            responseSize =
                irpSp->Parameters.DeviceIoControl.OutputBufferLength;
    
            if ( (responseSize < sizeof(CLUSNET_EVENT_RESPONSE))) {
    
                status = STATUS_INVALID_PARAMETER;
            }
            else {
                status = CnGetNextEvent( Irp, irpSp );
                ioIncrement = IO_NETWORK_INCREMENT;
            }
        }
        goto complete_request;
    
    } // end of switch

    //
    // Not handled yet. Fall through.
    //

    if (ClusnetIsGeneralIoctl(ioControlCode)) {

        if (!ClusnetIsNTEIoctl(ioControlCode)) {

            //
            // The following commands require exclusive access to CnResource.
            //
            resourceAcquired = CnAcquireResourceExclusive(
                                   CnResource,
                                   TRUE
                                   );

            if (!resourceAcquired) {
                CnAssert(resourceAcquired == TRUE);
                status = STATUS_UNSUCCESSFUL;
                goto complete_request;
            }

            switch(ioControlCode) {

            case IOCTL_CLUSNET_INITIALIZE:

                if (CnState == CnStateShutdown) {
                    PCLUSNET_INITIALIZE_REQUEST   request;
                    ULONG                         requestSize;

                    request = (PCLUSNET_INITIALIZE_REQUEST)
                              Irp->AssociatedIrp.SystemBuffer;

                    requestSize = 
                        irpSp->Parameters.DeviceIoControl.InputBufferLength;

                    if (requestSize < sizeof(CLUSNET_INITIALIZE_REQUEST)) {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else {
                        status = CnInitialize(
                                     request->LocalNodeId,
                                     request->MaxNodes
                                     );
                    }
                }
                else {
                    status = STATUS_INVALID_DEVICE_REQUEST;
                }

                goto complete_request;

            case IOCTL_CLUSNET_ENABLE_SHUTDOWN_ON_CLOSE:
                status = CnEnableShutdownOnClose(Irp);
                goto complete_request;

            case IOCTL_CLUSNET_DISABLE_SHUTDOWN_ON_CLOSE:
                {
                    PCN_FSCONTEXT  fsContext = irpSp->FileObject->FsContext;

                    fsContext->ShutdownOnClose = FALSE;

                    if ( ClussvcProcessHandle ) {

                        CnCloseProcessHandle( &ClussvcProcessHandle );
                        ClussvcProcessHandle = NULL;
                    }

                    status = STATUS_SUCCESS;
                }
                goto complete_request;

            case IOCTL_CLUSNET_HALT:
                status = CnShutdown();

                CnReleaseResourceForThread(
                    CnResource,
                    (ERESOURCE_THREAD) PsGetCurrentThread()
                    );

                resourceAcquired = FALSE;

                //
                // Issue a Halt event. If clusdisk still has a handle
                // to clusnet, then it will release its reservations.
                //
                CnIssueEvent( ClusnetEventHalt, 0, 0 );

                goto complete_request;

            case IOCTL_CLUSNET_SHUTDOWN:
                status = CnShutdown();
                goto complete_request;

            case IOCTL_CLUSNET_SET_MEMORY_LOGGING:
                {
                    PCLUSNET_SET_MEM_LOGGING_REQUEST request;
                    ULONG                           requestSize;

                    request = (PCLUSNET_SET_MEM_LOGGING_REQUEST)
                              Irp->AssociatedIrp.SystemBuffer;

                    requestSize =
                        irpSp->Parameters.DeviceIoControl.InputBufferLength;

                    if ( (requestSize < sizeof(CLUSNET_SET_MEM_LOGGING_REQUEST))) {

                        status = STATUS_INVALID_PARAMETER;
                    }
                    else {

                        status = CnSetMemLogging( request );
                    }
                }
                goto complete_request;
    #if DBG
            case IOCTL_CLUSNET_SET_DEBUG_MASK:
                {
                    PCLUSNET_SET_DEBUG_MASK_REQUEST   request;
                    ULONG                             requestSize;

                    request = (PCLUSNET_SET_DEBUG_MASK_REQUEST)
                              Irp->AssociatedIrp.SystemBuffer;

                    requestSize =
                        irpSp->Parameters.DeviceIoControl.InputBufferLength;

                    if (requestSize < sizeof(CLUSNET_SET_DEBUG_MASK_REQUEST)) {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else {
                        CnDebug = request->DebugMask;
                        status = STATUS_SUCCESS;
                    }
                }
                goto complete_request;
    #endif // DBG
            
            } // end switch

        } else {

            //
            // The following commands are only valid if we are
            // in the initialized state. The resource is 
            // acquired to start the operation in the proper
            // state; however, the dispatched routines are 
            // reentrant, so the resource can be released before
            // the IRPs complete.
            //
        
            resourceAcquired = CnAcquireResourceShared(
                                   CnResource,
                                   TRUE
                                   );

            if (!resourceAcquired) {
                CnAssert(resourceAcquired == TRUE);
                status = STATUS_UNSUCCESSFUL;
                goto complete_request;
            }

            if (CnState != CnStateInitialized) {
                status = STATUS_DEVICE_NOT_READY;
                goto complete_request;
            }

            switch(ioControlCode) {

            case IOCTL_CLUSNET_ADD_NTE:
                
                status = IpaAddNTE(Irp, irpSp);

                goto complete_request;

            case IOCTL_CLUSNET_DELETE_NTE:
                
                status = IpaDeleteNTE(Irp, irpSp);

                goto complete_request;

            case IOCTL_CLUSNET_SET_NTE_ADDRESS:
                
                status = IpaSetNTEAddress(Irp, irpSp);

                goto complete_request;

            case IOCTL_CLUSNET_ADD_NBT_INTERFACE:
                {
                    PNETBT_ADD_DEL_IF  request;
                    ULONG              requestSize;
                    PNETBT_ADD_DEL_IF  response;
                    ULONG              responseSize;


                    request = (PNETBT_ADD_DEL_IF)
                              Irp->AssociatedIrp.SystemBuffer;

                    requestSize =
                        irpSp->Parameters.DeviceIoControl.InputBufferLength;

                    responseSize =
                        irpSp->Parameters.DeviceIoControl.OutputBufferLength;

                    response = (PNETBT_ADD_DEL_IF) request;

                    if ( (requestSize < sizeof(NETBT_ADD_DEL_IF)) ||
                         (responseSize < sizeof(NETBT_ADD_DEL_IF))
                       )
                    {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else {
                        status = NbtAddIf(
                                     request,
                                     requestSize,
                                     response,
                                     &responseSize
                                     );

                        CnAssert(status != STATUS_PENDING);

                        if (NT_SUCCESS(status)) {
                            Irp->IoStatus.Information = responseSize;
                        }
                    }
                }
                goto complete_request;

            case IOCTL_CLUSNET_DEL_NBT_INTERFACE:
                {
                    PNETBT_ADD_DEL_IF   request;
                    ULONG               requestSize;


                    request = (PNETBT_ADD_DEL_IF)
                              Irp->AssociatedIrp.SystemBuffer;

                    requestSize =
                        irpSp->Parameters.DeviceIoControl.InputBufferLength;

                    if (requestSize < sizeof(NETBT_ADD_DEL_IF)) {
                        status = STATUS_INVALID_PARAMETER;
                    }
                    else {
                        status = NbtDeleteIf(request, requestSize);

                        CnAssert(status != STATUS_PENDING);
                    }
                }
                goto complete_request;

            } // end switch
        }
        
        //
        // Not handled. Return an error.
        //
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto complete_request;
    }
    else {
        //
        // The following commands require shared access to CnResource.
        // They are only valid in the initialized state.
        //
        resourceAcquired = CnAcquireResourceShared(CnResource, TRUE);
       
        if (!resourceAcquired) {
            CnAssert(resourceAcquired == TRUE);
            status = STATUS_UNSUCCESSFUL;
            goto complete_request;
        }
       
        if (CnState == CnStateInitialized) {
            if (ClusnetIsTransportIoctl(ioControlCode)) {
                status = CxDispatchDeviceControl(Irp, irpSp);
            }
            else {
                //
                // Not handled. Return an error.
                //
                status = STATUS_INVALID_DEVICE_REQUEST;
            }
        }
        else {
            //
            // We haven't been initialized yet. Return an error.
            //
            status = STATUS_DEVICE_NOT_READY;
        }
    }
    
complete_request:

    if (resourceAcquired) {
        CnReleaseResourceForThread(
            CnResource,
            (ERESOURCE_THREAD) PsGetCurrentThread()
            );
    }

    if (status != STATUS_PENDING) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, ioIncrement);
    }

    return(status);

} // CnDispatchDeviceControl



NTSTATUS
CnDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )

/*++

Routine Description:

    This is the generic dispatch routine for the driver.

Arguments:

    DeviceObject - Pointer to device object for target device
    Irp          - Pointer to I/O request packet

Return Value:

    An NT status code.

--*/

{
    PIO_STACK_LOCATION    irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS              status = STATUS_SUCCESS;
#if DBG
    KIRQL                 entryIrql = KeGetCurrentIrql();
#endif // DBG


    PAGED_CODE();

    CnAssert(irpSp->MajorFunction != IRP_MJ_INTERNAL_DEVICE_CONTROL);

    switch (irpSp->MajorFunction) {

    case IRP_MJ_CREATE:
        status = CnCreate(DeviceObject, Irp, irpSp);
        break;

    case IRP_MJ_CLEANUP:
        status = CnCleanup(DeviceObject, Irp, irpSp);
        break;

    case IRP_MJ_CLOSE:
        status = CnClose(DeviceObject, Irp, irpSp);
        break;

    case IRP_MJ_SHUTDOWN:
        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[ClusNet] Processing shutdown notification...\n"));
        }

        {
            BOOLEAN acquired = CnAcquireResourceExclusive(
                                   CnResource,
                                   TRUE
                                   );

            CnAssert(acquired == TRUE);

            (VOID) CnShutdown();

            if (acquired) {
                CnReleaseResourceForThread(
                    CnResource,
                    (ERESOURCE_THREAD) PsGetCurrentThread()
                    );
            }

            //
            // Issue a Halt event. If clusdisk still has a handle
            // to clusnet, then it will release its reservations
            //
            CnIssueEvent( ClusnetEventHalt, 0, 0 );

            status = STATUS_SUCCESS;
        }

        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[ClusNet] Shutdown processing complete.\n"));
        }

        break;

    default:
        IF_CNDBG(CN_DEBUG_IRP) {
            CNPRINT((
                "[ClusNet] Received IRP with unsupported "
                "major function 0x%lx\n",
                irpSp->MajorFunction
                ));
        }
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    CnAssert(status != STATUS_PENDING);

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

#if DBG
    CnAssert(entryIrql == KeGetCurrentIrql());
#endif // DBG

    return(status);

} // CnDispatch



NTSTATUS
CnCreate(
    IN PDEVICE_OBJECT     DeviceObject,
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Handler for create IRPs.

Arguments:

    DeviceObject - Pointer to the device object for this request.
    Irp          - Pointer to I/O request packet

Return Value:

    An NT status code.

Notes:

    This routine never returns STATUS_PENDING.
    The calling routine must complete the IRP.

--*/

{
    PCN_FSCONTEXT                        fsContext;
    FILE_FULL_EA_INFORMATION            *ea;
    FILE_FULL_EA_INFORMATION UNALIGNED  *targetEA;
    NTSTATUS                             status;

    PAGED_CODE();

    //
    // Reject unathorized opens
    //
    if ( (IrpSp->FileObject->RelatedFileObject != NULL) ||
         (IrpSp->FileObject->FileName.Length != 0)
       )
    {
        return(STATUS_ACCESS_DENIED);
    }

    ea = (PFILE_FULL_EA_INFORMATION) Irp->AssociatedIrp.SystemBuffer;

    if ((DeviceObject == CdpDeviceObject) && (ea != NULL)) {

        IF_CNDBG(CN_DEBUG_OPEN) {
            CNPRINT((
                "[ClusNet] Opening address object, file object %p\n",
                IrpSp->FileObject
                ));
        }

        //
        // This is the CDP device. This should be an address object open.
        //
        targetEA = CnFindEA(
                       ea,
                       TdiTransportAddress,
                       TDI_TRANSPORT_ADDRESS_LENGTH
                       );

        if (targetEA != NULL) {
            IrpSp->FileObject->FsContext2 = (PVOID)
                                            TDI_TRANSPORT_ADDRESS_FILE;

            //
            // Open an address object. This will also allocate the common
            // file object context structure.
            //
            status = CxOpenAddress(
                         &fsContext,
                         (TRANSPORT_ADDRESS UNALIGNED *)
                             &(targetEA->EaName[targetEA->EaNameLength + 1]),
                         targetEA->EaValueLength
                         );
        }
        else {
            IF_CNDBG(CN_DEBUG_OPEN) {
                CNPRINT((
                    "[ClusNet] No transport address in EA!\n"
                    ));
            }
            status = STATUS_INVALID_PARAMETER;
        }
    }
    else {
        //
        // This is a control channel open.
        //
        IF_CNDBG(CN_DEBUG_OPEN) {
            IF_CNDBG(CN_DEBUG_OPEN) {
                CNPRINT((
                    "[ClusNet] Opening control channel, file object %p\n",
                    IrpSp->FileObject
                    ));
            }
        }

        //
        // Allocate our common file object context structure.
        //
        fsContext = CnAllocatePool(sizeof(CN_FSCONTEXT));

        if (fsContext != NULL) {
            IrpSp->FileObject->FsContext2 = (PVOID) TDI_CONTROL_CHANNEL_FILE;
            CN_INIT_SIGNATURE(fsContext, CN_CONTROL_CHANNEL_SIG);

            //
            // Check the sharing flags. If this is an exclusive open, check
            // to make sure there isn't already an exclusive open outstanding.
            //
            if (IrpSp->Parameters.Create.ShareAccess == 0) {
                BOOLEAN acquired = CnAcquireResourceExclusive(
                                       CnResource,
                                       TRUE
                                       );

                CnAssert(acquired == TRUE);

                if (CnExclusiveChannel == NULL) {
                    CnExclusiveChannel = fsContext;
                    status = STATUS_SUCCESS;
                }
                else {
                    CnFreePool(fsContext);
                    status = STATUS_SHARING_VIOLATION;
                }

                if (acquired) {
                    CnReleaseResourceForThread(
                        CnResource,
                        (ERESOURCE_THREAD) PsGetCurrentThread()
                        );
                }
            }
            else {
                status = STATUS_SUCCESS;
            }
        }
        else {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (status == STATUS_SUCCESS) {
        IrpSp->FileObject->FsContext = fsContext;

        fsContext->FileObject = IrpSp->FileObject;
        fsContext->ReferenceCount = 1;
        fsContext->CancelIrps = FALSE;
        fsContext->ShutdownOnClose = FALSE;

        KeInitializeEvent(
            &(fsContext->CleanupEvent),
            SynchronizationEvent,
            FALSE
            );

        //
        // init the Event list stuff. We use the empty list test on the
        // Linkage field to see if this context block is already been linked
        // to the event file object list
        //
        fsContext->EventMask = 0;
        InitializeListHead( &fsContext->EventList );
        InitializeListHead( &fsContext->Linkage );
        fsContext->EventIrp = NULL;
    }

    return(status);

} // CnCreate



NTSTATUS
CnCleanup(
    IN PDEVICE_OBJECT     DeviceObject,
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Cancels all outstanding Irps on a device object and waits for them to be
    completed before returning.

Arguments:

    DeviceObject - Pointer to the device object on which the Irp was received.
    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    An NT status code.

Notes:

    This routine may block.
    This routine never returns STATUS_PENDING.
    The calling routine must complete the IRP.

--*/

{
    CN_IRQL        oldIrql;
    NTSTATUS       status;
    ULONG          fileType = 
                       (ULONG)((ULONG_PTR)IrpSp->FileObject->FsContext2);
    PCN_FSCONTEXT  fsContext = (PCN_FSCONTEXT) IrpSp->FileObject->FsContext;
    PLIST_ENTRY    EventEntry;
    PIRP           eventIrp;


    if (fileType == TDI_TRANSPORT_ADDRESS_FILE) {
        //
        // This is an address object.
        //
        CnAssert(DeviceObject == CdpDeviceObject);

        status = CxCloseAddress(fsContext);
    }
    else {
        //
        // This is a control channel.
        //
        CnAssert(fileType == TDI_CONTROL_CHANNEL_FILE);

        //
        // If this channel has a shutdown trigger enabled,
        // shutdown the driver.
        //
        if (fsContext->ShutdownOnClose) {

            BOOLEAN  shutdownScheduled;

            //
            // Bug 303422: CnShutdown closes handles that were opened
            // in the context of the system process. However, attaching
            // to the system process during shutdown can cause a
            // bugcheck under certain conditions. The only alternative
            // is to defer executing of CnShutdown to a system worker
            // thread.
            //
            // Rather than creating a new event object, leverage the 
            // cleanup event in the fscontext. It is reset before use
            // below.
            //
            KeClearEvent(&(fsContext->CleanupEvent));

            shutdownScheduled = CnHaltOperation(&(fsContext->CleanupEvent));

            if (shutdownScheduled) {
                status = KeWaitForSingleObject(
                             &(fsContext->CleanupEvent),
                             (Irp->RequestorMode == KernelMode 
                              ? Executive : UserRequest),
                             KernelMode,
                             FALSE,
                             NULL
                             );

                CnAssert(NT_SUCCESS(status));

                status = STATUS_SUCCESS;
            }

            //
            // issue a Halt event. If clusdisk still has a handle
            // to clusnet, then it will release its reservations
            //
            CnIssueEvent( ClusnetEventHalt, 0, 0 );
        }

        //
        // if this guy forgot to clear the event mask before
        // closing the handle, do the appropriate cleanup
        // now.
        //

        if ( fsContext->EventMask ) {
            CLUSNET_SET_EVENT_MASK_REQUEST EventRequest;

            EventRequest.EventMask = 0;

            //
            // cannot proceed if CnSetEventMask returns a timeout
            // error. this indicates that the fsContext has not
            // been removed from the EventFileHandles list because
            // of lock starvation.
            do {
                status = CnSetEventMask( fsContext, &EventRequest );
            } while ( status == STATUS_TIMEOUT );
            CnAssert( status == STATUS_SUCCESS );
        }

        CnAcquireCancelSpinLock( &oldIrql );
        CnAcquireLockAtDpc( &EventLock );

        if ( fsContext->EventIrp != NULL ) {

            eventIrp = fsContext->EventIrp;
            fsContext->EventIrp = NULL;

            CnReleaseLockFromDpc( &EventLock );
            eventIrp->CancelIrql = oldIrql;
            CnCompletePendingRequest(eventIrp, STATUS_CANCELLED, 0);
        } else {
            CnReleaseLockFromDpc( &EventLock );
            CnReleaseCancelSpinLock( oldIrql );
        }
    }

    //
    // Remove the initial reference and wait for all pending work
    // to complete.
    //
    fsContext->CancelIrps = TRUE;
    KeResetEvent(&(fsContext->CleanupEvent));

    CnDereferenceFsContext(fsContext);

    IF_CNDBG(CN_DEBUG_CLEANUP) {
        CNPRINT((
            "[ClusNet] Waiting for completion of Irps on file object %p\n",
            IrpSp->FileObject
            ));
    }

    status = KeWaitForSingleObject(
                 &(fsContext->CleanupEvent),
                 (Irp->RequestorMode == KernelMode ? Executive : UserRequest),
                 KernelMode,
                 FALSE,
                 NULL
                 );

    CnAssert(NT_SUCCESS(status));

    status = STATUS_SUCCESS;

    IF_CNDBG(CN_DEBUG_CLEANUP) {
        CNPRINT((
            "[Clusnet] Wait on file object %p finished\n",
            IrpSp->FileObject
            ));
    }

    return(status);

} // CnCleanup



NTSTATUS
CnClose(
    IN PDEVICE_OBJECT     DeviceObject,
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Dispatch routine for MJ_CLOSE IRPs. Performs final cleanup of the
    open file object.

Arguments:

    DeviceObject - Pointer to the device object on which the Irp was received.
    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    An NT status code.

Notes:

    This routine never returns STATUS_PENDING.
    The calling routine must complete the IRP.

--*/

{
    BOOLEAN        acquired;
    PCN_FSCONTEXT  fsContext = (PCN_FSCONTEXT) IrpSp->FileObject->FsContext;
    ULONG          fileType = 
                       (ULONG)((ULONG_PTR)IrpSp->FileObject->FsContext2);


    CnAssert(fsContext->ReferenceCount == 0);
    CnAssert(IsListEmpty(&(fsContext->EventList)));

    if (fileType == TDI_CONTROL_CHANNEL_FILE) {
        acquired = CnAcquireResourceExclusive(
                       CnResource,
                       TRUE
                       );

        CnAssert(acquired == TRUE);

        if (CnExclusiveChannel == fsContext) {
            CnExclusiveChannel = NULL;
        }

        if (acquired) {
            CnReleaseResourceForThread(
                CnResource,
                (ERESOURCE_THREAD) PsGetCurrentThread()
                );
        }
    }

    IF_CNDBG(CN_DEBUG_CLOSE) {
        CNPRINT((
            "[ClusNet] Close on file object %p\n",
            IrpSp->FileObject
            ));
    }

    CnFreePool(fsContext);

    return(STATUS_SUCCESS);

} // CnClose



FILE_FULL_EA_INFORMATION UNALIGNED *
CnFindEA(
    PFILE_FULL_EA_INFORMATION  StartEA,
    CHAR                      *TargetName,
    USHORT                     TargetNameLength
    )
/*++

Routine Description:

    Parses and extended attribute list for a given target attribute.

Arguments:

    StartEA           - the first extended attribute in the list.
        TargetName        - the name of the target attribute.
        TargetNameLength  - the length of the name of the target attribute.

Return Value:

    A pointer to the requested attribute or NULL if the target wasn't found.

--*/
{
    USHORT                                i;
    BOOLEAN                               found;
    FILE_FULL_EA_INFORMATION UNALIGNED *  CurrentEA;
    FILE_FULL_EA_INFORMATION UNALIGNED *  NextEA;


    PAGED_CODE();

    NextEA = (FILE_FULL_EA_INFORMATION UNALIGNED *) StartEA;

    do {
        found = TRUE;

        CurrentEA = NextEA;
        NextEA = (FILE_FULL_EA_INFORMATION UNALIGNED *)
                  ( ((PUCHAR) StartEA) + CurrentEA->NextEntryOffset);

        if (CurrentEA->EaNameLength != TargetNameLength) {
            continue;
        }

        for (i=0; i < CurrentEA->EaNameLength; i++) {
            if (CurrentEA->EaName[i] == TargetName[i]) {
                continue;
            }
            found = FALSE;
            break;
        }

        if (found) {
            return(CurrentEA);
        }

    } while(CurrentEA->NextEntryOffset != 0);

    return(NULL);

}  // CnFindEA


NTSTATUS
CnEnableShutdownOnClose(
    PIRP   Irp
    )
{
    NTSTATUS            status;
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    PCN_FSCONTEXT       fsContext = irpSp->FileObject->FsContext;
    ULONG               requestSize;
    CLIENT_ID           ClientId;
    OBJECT_ATTRIBUTES   ObjAttributes;
    PCLUSNET_SHUTDOWN_ON_CLOSE_REQUEST request;


    PAGED_CODE();
    
    request = (PCLUSNET_SHUTDOWN_ON_CLOSE_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;

    requestSize = irpSp->Parameters.DeviceIoControl.InputBufferLength;

    if ( requestSize >= sizeof(CLUSNET_SHUTDOWN_ON_CLOSE_REQUEST)
       )
    {
        //
        // illegal for kernel mode
        //
        if ( Irp->RequestorMode != KernelMode ) {
            //
            // Get a handle to the cluster service process.
            // This is used to kill the service if a poison
            // pkt is received. Since a kernel worker thread
            // is used to kill the cluster service, we need
            // to acquire the handle in the system process.
            //
            IF_CNDBG(CN_DEBUG_INIT) {
                CNPRINT(("[Clusnet] Acquiring process handle\n"));
            }

            if (ClussvcProcessHandle == NULL) {
                KeAttachProcess( CnSystemProcess );

                ClientId.UniqueThread = (HANDLE)NULL;
                ClientId.UniqueProcess = UlongToHandle(request->ProcessId);

                InitializeObjectAttributes(
                    &ObjAttributes,
                    NULL,
                    0,
                    (HANDLE) NULL,
                    (PSECURITY_DESCRIPTOR) NULL
                    );

                status = ZwOpenProcess(
                             &ClussvcProcessHandle,
                             0,
                             &ObjAttributes,
                             &ClientId
                             );

                KeDetachProcess();

                if ( NT_SUCCESS( status )) {
                    fsContext->ShutdownOnClose = TRUE;
                } else {
                    IF_CNDBG(CN_DEBUG_INIT) {
                        CNPRINT((
                            "[Clusnet] ZwOpenProcess failed. status = %08X\n",
                            status
                            ));
                    }
                }
            }
            else {
                status = STATUS_INVALID_DEVICE_REQUEST;
            }
        }
        else {
            status = STATUS_INVALID_PARAMETER_MIX;
        }
    }
    else {
        status = STATUS_INVALID_PARAMETER;
    }

    return(status);

} // CnEnableShutdownOnClose
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\driver\memlog.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    memlog.c

Abstract:

    general purpose in-memory logging facility

Author:

    Charlie Wickham (charlwi) 31-May-1997

Environment:

    Kernel Mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

/* External */

/* Static */

/* Forward */
/* End Forward */

#ifdef MEMLOGGING

//
// in-memory event logging facility. This is used to determine
// subtle timing problems that can't be observed via printfs.
//

#define MAX_MEMLOG_ENTRIES 2000
ULONG MemLogEntries = MAX_MEMLOG_ENTRIES;
ULONG MemLogNextLogEntry = 0;

PMEMLOG_ENTRY MemLog;
KSPIN_LOCK MemLogLock;

VOID
CnInitializeMemoryLog(
    VOID
    )
{
    KeInitializeSpinLock( &MemLogLock );

    if ( MemLogEntries > 0 ) {
        MemLog = CnAllocatePool( MemLogEntries * sizeof( MEMLOG_ENTRY ));

        if ( MemLog == NULL ) {
            MemLogEntries = 0;
        }

        MEMLOG( MemLogInitLog, 0, 0 );
    }
}

NTSTATUS
CnSetMemLogging(
    PCLUSNET_SET_MEM_LOGGING_REQUEST request
    )
{
    KIRQL OldIrql;
    NTSTATUS Status = STATUS_SUCCESS;

    if ( request->NumberOfEntries != MemLogEntries ) {

        KeAcquireSpinLock( &MemLogLock, &OldIrql );

        if ( MemLog != NULL ) {

            CnFreePool( MemLog );
            MemLogEntries = 0;
            MemLog = NULL;
        }

        if ( request->NumberOfEntries != 0 ) {

            MemLogEntries = request->NumberOfEntries;

            MemLog = CnAllocatePool( MemLogEntries * sizeof( MEMLOG_ENTRY ));

            if ( MemLog == NULL ) {

                MemLogEntries = 0;
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {

                MemLogNextLogEntry = 0;
            }
        }
        KeReleaseSpinLock( &MemLogLock, OldIrql );
    }

    return Status;
}

VOID
CnFreeMemoryLog(
    VOID
    )
{
    if ( MemLog )
        CnFreePool( MemLog );
}

#else // MEMLOGGING

NTSTATUS
CnSetMemLogging(
    PCLUSNET_SET_MEM_LOGGING_REQUEST request
    )
{
    return STATUS_INVALID_DEVICE_REQUEST;
}

#endif // MEMLOGGING

/* end memlog.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\driver\errorlog.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    errorlog.c

Abstract:

    This module implements the error logging in the server.

    !!! This module must be nonpageable.

Author:

    Manny Weiser (mannyw)    11-Feb-92

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <windef.h>
#include <align.h>

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, CnWriteErrorLogEntry)
#endif

ULONG CnSequenceNumber = 0;

//#pragma optimize("",off)

VOID
_cdecl
CnWriteErrorLogEntry(
    IN ULONG UniqueErrorCode,
    IN NTSTATUS NtStatusCode,
    IN PVOID ExtraInformationBuffer,
    IN USHORT ExtraInformationLength,
    IN USHORT NumberOfInsertionStrings,
    ...
    )

#define LAST_NAMED_ARGUMENT NumberOfInsertionStrings

/*++

Routine Description:

    This function allocates an I/O error log record, fills it in and writes it
    to the I/O error log.

Arguments:



Return Value:

    None.


--*/
{

    PIO_ERROR_LOG_PACKET ErrorLogEntry;
    int TotalErrorLogEntryLength;
    ULONG SizeOfStringData = 0;
    va_list ParmPtr;                    // Pointer to stack parms.
    ULONG Length;

    PAGED_CODE();

    if (NumberOfInsertionStrings != 0) {
        ULONG i;

        va_start(ParmPtr, LAST_NAMED_ARGUMENT);

        for (i = 0; i < NumberOfInsertionStrings; i += 1) {

            PWSTR String = va_arg(ParmPtr, PWSTR);

            Length = wcslen(String);
            while ( (Length > 0) && (String[Length-1] == L' ') ) {
                Length--;
            }

            SizeOfStringData += (Length + 1) * sizeof(WCHAR);
        }
    }

    //
    //  Ideally we want the packet to hold the servername and ExtraInformation.
    //  Usually the ExtraInformation gets truncated.
    //

    TotalErrorLogEntryLength =
         min( ExtraInformationLength + sizeof(IO_ERROR_LOG_PACKET) + 1 + SizeOfStringData,
              ERROR_LOG_MAXIMUM_SIZE );

    ErrorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
        (PDEVICE_OBJECT)CnDeviceObject,
        (UCHAR)TotalErrorLogEntryLength
        );

    if (ErrorLogEntry != NULL) {
        PCHAR DumpData;
        ULONG RemainingSpace = TotalErrorLogEntryLength -
            FIELD_OFFSET( IO_ERROR_LOG_PACKET, DumpData );
        ULONG i;
        ULONG SizeOfRawData;

        if (RemainingSpace > SizeOfStringData) {
            SizeOfRawData = RemainingSpace - SizeOfStringData;
        } else {
            SizeOfStringData = RemainingSpace;

            SizeOfRawData = 0;
        }

        //
        // Fill in the error log entry
        //

        ErrorLogEntry->ErrorCode = UniqueErrorCode;
        ErrorLogEntry->MajorFunctionCode = 0;
        ErrorLogEntry->RetryCount = 0;
        ErrorLogEntry->UniqueErrorValue = 0;
        ErrorLogEntry->FinalStatus = NtStatusCode;
        ErrorLogEntry->IoControlCode = 0;
        ErrorLogEntry->DeviceOffset.LowPart = 0;
        ErrorLogEntry->DeviceOffset.HighPart = 0;
        ErrorLogEntry->SequenceNumber = (ULONG)CnSequenceNumber ++;
        ErrorLogEntry->StringOffset = (USHORT)(ROUND_UP_COUNT(
                    FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData) + SizeOfRawData,
                    ALIGN_WORD));

        DumpData = (PCHAR)ErrorLogEntry->DumpData;

        //
        // Append the extra information.  This information is typically
        // an SMB header.
        //

        if (( ARGUMENT_PRESENT( ExtraInformationBuffer )) &&
            ( SizeOfRawData != 0 )) {
            ULONG Length;

            Length = min(ExtraInformationLength, (USHORT)SizeOfRawData);
            RtlCopyMemory(
                DumpData,
                ExtraInformationBuffer,
                Length);
            ErrorLogEntry->DumpDataSize = (USHORT)Length;
        } else {
            ErrorLogEntry->DumpDataSize = 0;
        }

        ErrorLogEntry->NumberOfStrings = 0;

        if (NumberOfInsertionStrings != 0) {
            PWSTR StringOffset = (PWSTR)((PCHAR)ErrorLogEntry + ErrorLogEntry->StringOffset);
            PWSTR InsertionString;

            //
            // Set up ParmPtr to point to first of the caller's parameters.
            //

            va_start(ParmPtr, LAST_NAMED_ARGUMENT);

            for (i = 0 ; i < NumberOfInsertionStrings ; i+= 1) {
                InsertionString = va_arg(ParmPtr, PWSTR);
                Length = wcslen(InsertionString);
                while ( (Length > 0) && (InsertionString[Length-1] == L' ') ) {
                    Length--;
                }

                if ( ((Length + 1) * sizeof(WCHAR)) > SizeOfStringData ) {
                    Length = ( SizeOfStringData / sizeof( WCHAR )) - 1;
                }

                if ( Length > 0 ) {
                    RtlCopyMemory(StringOffset, InsertionString, Length*sizeof(WCHAR));
                    StringOffset += Length;
                    *StringOffset++ = L'\0';

                    SizeOfStringData -= (Length + 1) * sizeof(WCHAR);

                    ErrorLogEntry->NumberOfStrings += 1;
                }
            }

        }

        IoWriteErrorLogEntry(ErrorLogEntry);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\inc\clusmem.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    clusmem.h

Abstract:

    Cluster Membership Manager definitions exposed within the
    Cluster Network Driver.

Author:

    Mike Massa (mikemas)           February 10, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     02-10-97    created

Notes:

--*/

#ifndef _CLUSMEM_INCLUDED
#define _CLUSMEM_INCLUDED


//
//
// Function Prototypes
//
//

//
// Init/Shutdown
//
NTSTATUS
CmmLoad(
    IN PUNICODE_STRING RegistryPath
    );

VOID
CmmUnload(
    VOID
    );

NTSTATUS
CmmInitialize(
    IN CL_NODE_ID LocalNodeId
    );

VOID
CmmShutdown(
    VOID
    );


//
// Irp Dispatch
//
NTSTATUS
CmmDispatchDeviceControl(
    IN PIRP                Irp,
    IN PIO_STACK_LOCATION  IrpSp
    );


//
// Messaging Interface
//
VOID
CmmReceiveMessageHandler(
    IN  CL_NODE_ID   SourceNodeId,
    IN  PVOID        MessageData,
    IN  ULONG        MessageLength
    );


#endif // ndef _CLUSMEM_INCLUDED


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\inc\cluxport.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cluxport.h

Abstract:

    Cluster Transport definitions exposed within the Cluster Network Driver.

Author:

    Mike Massa (mikemas)           January 3, 1996

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-03-97    created

Notes:

--*/

#ifndef _CLUXPORT_INCLUDED
#define _CLUXPORT_INCLUDED

#include <tdi.h>
#include <tdikrnl.h>
#include <clustdi.h>

//
//
// Function Prototypes
//
//

//
// Initialization/Shutdown
//
NTSTATUS
CxLoad(
    IN PUNICODE_STRING RegistryPath
    );

VOID
CxUnload(
    VOID
    );

NTSTATUS
CxInitialize(
    VOID
    );

VOID
CxShutdown(
    VOID
    );

//
// Irp Dispatch
//
NTSTATUS
CxDispatchDeviceControl(
    IN PIRP                Irp,
    IN PIO_STACK_LOCATION  IrpSp
    );


//
// Nodes
//
NTSTATUS
CxRegisterNode(
    CL_NODE_ID    NodeId
    );

NTSTATUS
CxDeregisterNode(
    CL_NODE_ID           NodeId,
    PIRP                 Irp,
    PIO_STACK_LOCATION   IrpSp
    );

NTSTATUS
CxOnlineNodeComm(
    CL_NODE_ID     NodeId
    );

NTSTATUS
CxOfflineNodeComm(
    IN CL_NODE_ID          NodeId,
    IN PIRP                Irp,
    IN PIO_STACK_LOCATION  IrpSp
    );

NTSTATUS
CxGetNodeCommState(
    IN  CL_NODE_ID                NodeId,
    OUT PCLUSNET_NODE_COMM_STATE  State
    );


//
// Networks
//
NTSTATUS
CxRegisterNetwork(
    CL_NETWORK_ID       NetworkId,
    ULONG               Priority,
    BOOLEAN             Restricted
    );

NTSTATUS
CxDeregisterNetwork(
    CL_NETWORK_ID       NetworkId,
    PIRP                Irp,
    PIO_STACK_LOCATION  IrpSp
    );

NTSTATUS
CxOnlineNetwork(
    IN  CL_NETWORK_ID       NetworkId,
    IN  PWCHAR              TdiProviderName,
    IN  ULONG               TdiProviderNameLength,
    IN  PTRANSPORT_ADDRESS  TdiBindAddress,
    IN  ULONG               TdiBindAddressLength,
    IN  PWCHAR              AdapterName,
    IN  ULONG               AdapterNameLength,
    OUT PTDI_ADDRESS_INFO   TdiBindAddressInfo,
    IN  ULONG               TdiBindAddressInfoLength,
    IN  PIRP                Irp                       OPTIONAL
    );

NTSTATUS
CxOfflineNetwork(
    CL_NETWORK_ID       NetworkId,
    PIRP                Irp,
    PIO_STACK_LOCATION  IrpSp
    );

NTSTATUS
CxGetNetworkState(
    IN  CL_NETWORK_ID           NetworkId,
    OUT PCLUSNET_NETWORK_STATE  State
    );

NTSTATUS
CxSetNetworkRestriction(
    IN CL_NETWORK_ID  NetworkId,
    IN BOOLEAN        Restricted,
    IN ULONG          NewPriority
    );

NTSTATUS
CxSetNetworkPriority(
    IN CL_NETWORK_ID  NetworkId,
    IN ULONG          Priority
    );

NTSTATUS
CxGetNetworkPriority(
    IN  CL_NETWORK_ID   NetworkId,
    OUT PULONG          Priority
    );


//
// Interfaces
//
NTSTATUS
CxRegisterInterface(
    CL_NODE_ID          NodeId,
    CL_NETWORK_ID       NetworkId,
    ULONG               Priority,
    PUWSTR              AdapterId,
    ULONG               AdapterIdLength,
    ULONG               TdiAddressLength,
    PTRANSPORT_ADDRESS  TdiAddress,
    PULONG              MediaStatus
    );

NTSTATUS
CxDeregisterInterface(
    CL_NODE_ID          NodeId,
    CL_NETWORK_ID       NetworkId
    );

NTSTATUS
CxSetInterfacePriority(
    IN CL_NODE_ID          NodeId,
    IN CL_NETWORK_ID       NetworkId,
    IN ULONG               Priority
    );

NTSTATUS
CxGetInterfacePriority(
    IN  CL_NODE_ID          NodeId,
    IN  CL_NETWORK_ID       NetworkId,
    OUT PULONG              InterfacePriority,
    OUT PULONG              NetworkPriority
    );

NTSTATUS
CxGetInterfaceState(
    IN  CL_NODE_ID                NodeId,
    IN  CL_NETWORK_ID             NetworkId,
    OUT PCLUSNET_INTERFACE_STATE  State
    );

//
// Misc. stuff
//
NTSTATUS
CxGetNodeMembershipState(
    IN  CL_NODE_ID NodeId,
    OUT PCLUSNET_NODE_STATE State
    );

NTSTATUS
CxSetNodeMembershipState(
    IN  CL_NODE_ID NodeId,
    IN  CLUSNET_NODE_STATE State
    );

NTSTATUS
CxSetOuterscreen(
    IN  ULONG Outerscreen
    );

VOID
CxRegroupFinished(
    IN  ULONG NewEpoch
    );

NTSTATUS
CxImportSecurityContext(
    IN  CL_NODE_ID NodeId,
    IN  PWCHAR PackageName,
    IN  ULONG PackageNameSize,
    IN  ULONG SignatureSize,
    IN  PVOID InboundContext,
    IN  PVOID OutboundContext
    );

VOID
CxDeleteSecurityContext(
    IN  CL_NODE_ID NodeId
    );

//
// Membership Message Interface
//
typedef
VOID
(*PCX_SEND_COMPLETE_ROUTINE) (
    IN NTSTATUS  Status,
    IN ULONG     BytesSent,
    IN PVOID     Context,
    IN PVOID     Buffer
    );

NTSTATUS
CxSendMembershipMessage(
    IN CL_NODE_ID                  DestinationNodeId,
    IN PVOID                       MessageData,
    IN USHORT                      MessageDataLength,
    IN PCX_SEND_COMPLETE_ROUTINE   CompletionRoutine,
    IN PVOID                       CompletionContext   OPTIONAL
    );

VOID
CxSendPoisonPacket(
    IN CL_NODE_ID                  DestinationNodeId,
    IN PCX_SEND_COMPLETE_ROUTINE   CompletionRoutine   OPTIONAL,
    IN PVOID                       CompletionContext   OPTIONAL,
    IN PIRP                        Irp                 OPTIONAL
    );

NTSTATUS
CxSendHeartBeatMessage(
    IN CL_NODE_ID                  DestinationNodeId,
    IN ULONG                       SeqNumber,
    IN ULONG                       AckNumber,
    IN CL_NETWORK_ID               NetworkId
    );


//
// Top-edge TDI Routines
//
NTSTATUS
CxOpenAddress(
    OUT PCN_FSCONTEXT *                CnFsContext,
    IN  TRANSPORT_ADDRESS UNALIGNED *  TransportAddress,
    IN  ULONG                          TransportAddressLength
    );

NTSTATUS
CxCloseAddress(
    IN PCN_FSCONTEXT CnFsContext
    );

NTSTATUS
CxSetEventHandler(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp
    );

NTSTATUS
CxQueryInformation(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp
    );

NTSTATUS
CxSendDatagram(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp
    );

NTSTATUS
CxReceiveDatagram(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp
    );

//
// Test APIs
//
#if DBG

NTSTATUS
CxOnlinePendingInterface(
    IN  CL_NODE_ID          NodeId,
    IN  CL_NETWORK_ID       NetworkId
    );

NTSTATUS
CxOnlineInterface(
    IN  CL_NODE_ID          NodeId,
    IN  CL_NETWORK_ID       NetworkId
    );

NTSTATUS
CxOfflineInterface(
    IN  CL_NODE_ID          NodeId,
    IN  CL_NETWORK_ID       NetworkId
    );

NTSTATUS
CxFailInterface(
    IN  CL_NODE_ID          NodeId,
    IN  CL_NETWORK_ID       NetworkId
    );

#endif // DBG


#endif // ndef _CLUXPORT_INCLUDED



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\inc\clusnet.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    clusnet.h

Abstract:

    Top-level, common header file for the Cluster Network Driver.
    Defines common driver structures.

Author:

    Mike Massa (mikemas)           January 3, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-03-97    created

Notes:

--*/

#ifndef _CLUSNET_INCLUDED_
#define _CLUSNET_INCLUDED_

#define _NTDDK_ // [HACKHACK] to make ProbeForRead work. Better to include ntddk instead of ntos //

#define WMI_TRACING 1

#include <ntos.h>
#include <zwapi.h>
#include <clusdef.h>
#include <ntddcnet.h>
#include <cnettest.h>
#include <ntemgmt.h>
#include <nbtmgmt.h>
#include <memlog.h>

#if defined(WMI_TRACING) 
# include "cnwmi.h"
#endif

//
// Constants
//
#define CN_POOL_TAG         'tnSC'

#define CDP_DEFAULT_IRP_STACK_SIZE  4
#define CN_DEFAULT_IRP_STACK_SIZE   4

//
// Pool Macros
//
#define CnAllocatePool(_bufsize)  \
            ExAllocatePoolWithTag(NonPagedPool, (_bufsize), CN_POOL_TAG);

#define CnAllocatePoolWithQuota(_bufsize)  \
            ExAllocatePoolWithQuotaTag(NonPagedPool, (_bufsize), CN_POOL_TAG);

#define CnFreePool(_ptr)  \
            ExFreePool((_ptr))

#define ROUND32(_value)  ( ((_value) + 3) & ~(0x3) )

//
// Init/Cleanup synchronization
//
typedef enum {
    CnStateShutdown = 0,
    CnStateShutdownPending = 1,
    CnStateInitializePending = 2,
    CnStateInitialized = 3
} CN_STATE;


//
// Node ID validation macro
//
#define CnIsValidNodeId(_id)  ( ((_id) >= CnMinValidNodeId) && \
                                ((_id) <= CnMaxValidNodeId) )


//
// Lock acquisition ranking. Locks must be acquired in this order to
// prevent deadlocks. Components really should avoid calling outside
// of themselves while holding locks.
//
#define CN_IOCANCEL_LOCK             0x00000001
#define CN_IOCANCEL_LOCK_MAX         0x00000001

// MM locks
#define MM_RGP_LOCK                  0x00000010
#define MM_CALLBACK_LOCK             0x00000020

// CX Locks
#define CX_PRECEEDING_LOCK_RANGE     0x0000FFFF
#define CX_LOCK_RANGE                0xFFFF0000
#define CX_ADDROBJ_TABLE_LOCK        0x00010000
#define CX_ADDROBJ_TABLE_LOCK_MAX    0x0001FFFF
#define CX_ADDROBJ_LOCK              0x00020000
#define CX_ADDROBJ_LOCK_MAX          0x0003FFFF

#define CNP_PRECEEDING_LOCK_RANGE    0x00FFFFFF
#define CNP_LOCK_RANGE               0xFF000000
#define CNP_NODE_TABLE_LOCK          0x01000000
#define CNP_NODE_TABLE_LOCK_MAX      0x01FFFFFF
#define CNP_NODE_OBJECT_LOCK         0x02000000
#define CNP_NODE_OBJECT_LOCK_MAX     0x03FFFFFF
#define CNP_NETWORK_LIST_LOCK        0x04000000
#define CNP_NETWORK_LIST_LOCK_MAX    0x07FFFFFF
#define CNP_NETWORK_OBJECT_LOCK      0x08000000
#define CNP_NETWORK_OBJECT_LOCK_MAX  0x0FFFFFFF
#define CNP_HBEAT_LOCK               0x10000000
#define CNP_EVENT_LOCK_PRECEEDING    0x1FFFFFFF
#define CNP_EVENT_LOCK               0x20000000
#define CNP_EVENT_LOCK_MAX           0x3FFFFFFF
#define CNP_SEC_CTXT_LOCK            0x20000000


//
// Debugging Definitions
//
#if DBG

#define CNPRINT(many_args) DbgPrint many_args

extern ULONG CnDebug;

#define CN_DEBUG_INIT           0x00000001
#define CN_DEBUG_OPEN           0x00000002
#define CN_DEBUG_CLEANUP        0x00000004
#define CN_DEBUG_CLOSE          0x00000008

#define CN_DEBUG_IRP            0x00000010
#define CN_DEBUG_NODEOBJ        0x00000020
#define CN_DEBUG_NETOBJ         0x00000040
#define CN_DEBUG_IFOBJ          0x00000080

#define CN_DEBUG_CONFIG         0x00000100
#define CN_DEBUG_CNPSEND        0x00000200
#define CN_DEBUG_CNPRECV        0x00000400
#define CN_DEBUG_CNPREF         0x00000800

#define CN_DEBUG_EVENT          0x00001000
#define CN_DEBUG_MMSTATE        0x00002000
#define CN_DEBUG_HBEATS         0x00004000
#define CN_DEBUG_POISON         0x00008000

#define CN_DEBUG_CDPSEND        0x00010000
#define CN_DEBUG_CDPRECV        0x00020000
#define CN_DEBUG_CCMPSEND       0x00040000
#define CN_DEBUG_CCMPRECV       0x00080000

#define CN_DEBUG_ADDROBJ        0x00100000
#define CN_DEBUG_INFO           0x00200000
#define CN_DEBUG_NTE            0x00400000
#define CN_DEBUG_NDIS           0x00800000

#define CN_DEBUG_RGP            0x10000000
#define CN_DEBUG_CMM            0x20000000
#define CN_DEBUG_CMMMSG         0x40000000
#define CN_DEBUG_CMMTIMERQ      0x80000000

#define IF_CNDBG(flag)  if (CnDebug & flag)

VOID
CnAssertBreak(
    PCHAR FailedStatement,
    PCHAR FileName,
    ULONG LineNumber
    );

#define CnAssert(_statement)  \
            if (!(_statement)) CnAssertBreak(#_statement, __FILE__, __LINE__)

#define CN_SIGNATURE_FIELD                  ULONG   Signature;
#define CN_INIT_SIGNATURE(pstruct, sig)     ((pstruct)->Signature = (sig))
#define CN_ASSERT_SIGNATURE(pstruct, sig)   CnAssert( (pstruct)->Signature == \
                                                    (sig) )

#define CN_DBGCHECK  DbgBreakPoint()

typedef struct {
    KSPIN_LOCK   SpinLock;
    ULONG        Rank;
}  CN_LOCK, *PCN_LOCK;

typedef KIRQL       CN_IRQL, *PCN_IRQL;

ULONG
CnGetCpuLockMask(
    VOID
    );

VOID
CnVerifyCpuLockMask(
    IN ULONG RequiredLockMask,
    IN ULONG ForbiddenLockMask,
    IN ULONG MaximumLockMask
    );

VOID
CnInitializeLock(
    PCN_LOCK  Lock,
    ULONG     Rank
    );

VOID
CnAcquireLock(
    IN  PCN_LOCK   Lock,
    OUT PCN_IRQL   Irql
    );

VOID
CnReleaseLock(
    IN  PCN_LOCK   Lock,
    IN  CN_IRQL    Irql
    );

VOID
CnAcquireLockAtDpc(
    IN  PCN_LOCK   Lock
    );

VOID
CnReleaseLockFromDpc(
    IN  PCN_LOCK   Lock
    );

VOID
CnMarkIoCancelLockAcquired(
    VOID
    );

VOID
CnAcquireCancelSpinLock(
    OUT PCN_IRQL   Irql
    );

VOID
CnReleaseCancelSpinLock(
    IN CN_IRQL     Irql
    );


#else // DBG


#define CNPRINT(many_args)
#define IF_CNDBG(flag)   if (0)

#define CnAssert(_statement)

#define CN_SIGNATURE_FIELD
#define CN_INIT_SIGNATURE(pstruct, sig)
#define CN_ASSERT_SIGNATURE(pstruct, sig)

#define CN_DBGCHECK

typedef KSPIN_LOCK  CN_LOCK, *PCN_LOCK;
typedef KIRQL       CN_IRQL, *PCN_IRQL;

#define CnVerifyCpuLockMask(p1, p2, p3)

#define CnInitializeLock(_plock, _rank)   KeInitializeSpinLock((_plock))
#define CnAcquireLock(_plock, _pirql)     KeAcquireSpinLock((_plock), (_pirql))
#define CnReleaseLock(_plock, _irql)      KeReleaseSpinLock((_plock), (_irql))

#define CnAcquireLockAtDpc(_plock)      KeAcquireSpinLockAtDpcLevel((_plock))
#define CnReleaseLockFromDpc(_plock)    KeReleaseSpinLockFromDpcLevel((_plock))

#define CnMarkIoCancelLockAcquired()

#define CnAcquireCancelSpinLock(_pirql)  IoAcquireCancelSpinLock((_pirql))
#define CnReleaseCancelSpinLock(_irql)   IoReleaseCancelSpinLock((_irql))

#endif // DBG


//
// File Object Context Structure
//
// A pointer to this structure is stored in FileObject->FsContext.
// It maintains context information about open file objects.
//
typedef struct {

    //
    // used by event mechanism to find interested consumers when a new event
    // is posted.
    //
    LIST_ENTRY     Linkage;

    CN_SIGNATURE_FIELD
    PFILE_OBJECT   FileObject;
    LONG           ReferenceCount;
    UCHAR          CancelIrps;
    UCHAR          ShutdownOnClose;
    UCHAR          Pad[2];
    KEVENT         CleanupEvent;

    //
    // list of event context blocks representing events to be delivered to
    // consumer
    //
    LIST_ENTRY     EventList;

    //
    // pending IRP that is completed when a new event is issued
    //
    PIRP           EventIrp; 

    //
    // event types in which this consumer is interested
    //
    ULONG          EventMask;

    //
    // routine used to notify kernel consumers of new events
    //
    CLUSNET_EVENT_CALLBACK_ROUTINE KmodeEventCallback;
} CN_FSCONTEXT, *PCN_FSCONTEXT;

#define CN_CONTROL_CHANNEL_SIG   'lrtc'


//
// Generic Resource Management Package
//

//
// Forward Declarations
//
typedef struct _CN_RESOURCE *PCN_RESOURCE;
typedef struct _CN_RESOURCE_POOL *PCN_RESOURCE_POOL;

/*++

PCN_RESOURCE
CnCreateResourceRoutine(
    IN PVOID  Context
    );

Routine Description:

    Creates a new instance of a resource to be managed by a resource pool.

Arguments:

    Context - The context value specified when the pool was initialized.

Return Value:

    A pointer to the newly created resource if successful.
    NULL if unsuccessful.

--*/
typedef
PCN_RESOURCE
(*PCN_CREATE_RESOURCE_ROUTINE)(
    IN PVOID  PoolContext
    );


/*++

PCN_RESOURCE
CnDeleteResourceRoutine(
    IN PCN_RESOURCE  Resource
    );

Routine Description:

    Destroys an instance of a resource allocated by
    CnCreateResourceRoutine().

Arguments:

    Resource - A pointer to the resource to destroy.

Return Value:

    None.

--*/
typedef
VOID
(*PCN_DELETE_RESOURCE_ROUTINE) (
    IN PCN_RESOURCE   Resource
    );

//
// Resource Pool Structure
//
typedef struct _CN_RESOURCE_POOL {
    CN_SIGNATURE_FIELD
    SLIST_HEADER                  ResourceList;
    KSPIN_LOCK                    ResourceListLock;
    USHORT                        Depth;
    USHORT                        Pad;
    PCN_CREATE_RESOURCE_ROUTINE   CreateRoutine;
    PVOID                         CreateContext;
    PCN_DELETE_RESOURCE_ROUTINE   DeleteRoutine;
} CN_RESOURCE_POOL;

#define CN_RESOURCE_POOL_SIG    'lpnc'


//
// Resource Structure
//
typedef struct _CN_RESOURCE {
    SINGLE_LIST_ENTRY            Linkage;
    CN_SIGNATURE_FIELD
    PCN_RESOURCE_POOL            Pool;
    PVOID                        Context;
} CN_RESOURCE;

#define CN_RESOURCE_SIG    'ernc'


//
// Routines for operating on Resource Pools
//

/*++

VOID
CnInitializeResourcePool(
    IN PCN_RESOURCE_POOL            Pool,
    IN USHORT                       Depth,
    IN PCN_CREATE_RESOURCE_ROUTINE  CreateRoutine,
    IN PVOID                        CreateContext,
    IN PCN_DELETE_RESOURCE_ROUTINE  DeleteRoutine,
    );

Routine Description:

    Initializes a resource pool structure.

Arguments:

    Pool - A pointer to the pool structure to initialize.

    Depth - The maximum number of items to cache in the pool.

    CreateRoutine - A pointer to the routine to call to create a new
                    instance of a resource.

    CreateContext - A context value to pass as an argument to
                    the CreateRoutine.

    DeleteRoutine - A pointer to the routine to call to destroy an instance
                    of a resource created by CreateRoutine.

Return Value

    None.

--*/
#define CnInitializeResourcePool(_pool, _depth, _creatertn, _createctx, _deletertn) \
            { \
                CN_INIT_SIGNATURE(_pool, CN_RESOURCE_POOL_SIG);       \
                ExInitializeSListHead(&((_pool)->ResourceList));      \
                KeInitializeSpinLock(&((_pool)->ResourceListLock));   \
                (_pool)->Depth = _depth;                              \
                (_pool)->CreateRoutine = _creatertn;                  \
                (_pool)->CreateContext = _createctx;                  \
                (_pool)->DeleteRoutine = _deletertn;                  \
            }

VOID
CnDrainResourcePool(
    IN PCN_RESOURCE_POOL   Pool
    );

PCN_RESOURCE
CnAllocateResource(
    IN PCN_RESOURCE_POOL   Pool
    );

VOID
CnFreeResource(
    PCN_RESOURCE   Resource
    );

/*++

VOID
CnSetResourceContext(
    IN PCN_RESOURCE  Resource,
    IN PVOID         ContextValue
    );

Routine Description:

    Sets the context value for a Resource.

Arguments:

    Resource - A pointer to the resource on which to operate.

Return Value:

    A pointer to the context value associated with the resource.

--*/
#define CnSetResourceContext(_res, _value)  ((_res)->Context = (_value))


/*++

PVOID
CnGetResourceContext(
    IN PCN_RESOURCE  Resource
    );

Routine Description:

    Retrieves the context value from a Resource.

Arguments:

    Resource - A pointer to the resource on which to operate.

Return Value:

    A pointer to the context value associated with the resource.

--*/
#define CnGetResourceContext(_res)          ((_res)->Context)





//
// Init/Cleanup Function Prototypes
//
NTSTATUS
CnInitialize(
    IN CL_NODE_ID  LocalNodeId,
    IN ULONG       MaxNodes
    );

NTSTATUS
CnShutdown(
    VOID
    );

BOOLEAN
CnHaltOperation(
    IN PKEVENT     ShutdownEvent    OPTIONAL
    );

NTSTATUS
CnCloseProcessHandle(
    HANDLE Handle
    );

//
// Irp Handling Routines
//
NTSTATUS
CnDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
CnDispatchInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
CnDispatchDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

#if DBG
#define CnReferenceFsContext(_fsc) \
          {  \
            LONG newValue = InterlockedIncrement(&((_fsc)->ReferenceCount)); \
            CnAssert(newValue > 1); \
          }
#else // DBG

#define CnReferenceFsContext(_fsc) \
          (VOID) InterlockedIncrement( &((_fsc)->ReferenceCount) )

#endif // DBG

VOID
CnDereferenceFsContext(
    PCN_FSCONTEXT   FsContext
    );

NTSTATUS
CnMarkRequestPending(
    PIRP                Irp,
    PIO_STACK_LOCATION  IrpSp,
    PDRIVER_CANCEL      CancelRoutine
    );

VOID
CnCompletePendingRequest(
    IN PIRP      Irp,
    IN NTSTATUS  Status,
    IN ULONG     BytesReturned
    );

PFILE_OBJECT
CnBeginCancelRoutine(
    IN  PIRP     Irp
    );

VOID
CnEndCancelRoutine(
    PFILE_OBJECT    FileObject
    );

VOID
CnAdjustDeviceObjectStackSize(
    PDEVICE_OBJECT ClusnetDeviceObject,
    PDEVICE_OBJECT TargetDeviceObject
    );

//
// ExResource wrappers
//
BOOLEAN
CnAcquireResourceExclusive(
    IN PERESOURCE  Resource,
    IN BOOLEAN     Wait
    );

BOOLEAN
CnAcquireResourceShared(
    IN PERESOURCE  Resource,
    IN BOOLEAN     Wait
    );

VOID
CnReleaseResourceForThread(
    IN PERESOURCE         Resource,
    IN ERESOURCE_THREAD   ResourceThreadId
    );


//
// routines for in-memory logging facility
//

#ifdef MEMLOGGING
VOID
CnInitializeMemoryLog(
    VOID
    );

VOID
CnFreeMemoryLog(
    VOID
    );
#endif // MEMLOGGING

NTSTATUS
CnSetMemLogging(
    PCLUSNET_SET_MEM_LOGGING_REQUEST request
    );

#if 0
//
// NDIS related stuff
//

NDIS_STATUS
CnRegisterNDISProtocolHandlers(
    VOID
    );

NDIS_STATUS
CnDeregisterNDISProtocolHandlers(
    VOID
    );

VOID
CnOpenAdapterComplete(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS Status,
    IN  NDIS_STATUS OpenErrorStatus
    );

VOID
CnCloseAdapterComplete(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS Status
    );

VOID
CnStatusIndication(
    IN  NDIS_HANDLE ProtocolBindingContext,
    IN  NDIS_STATUS GeneralStatus,
    IN  PVOID       StatusBuffer,
    IN  UINT        StatusBufferSize
    );

VOID
CnStatusIndicationComplete(
    IN  NDIS_HANDLE ProtocolBindingContext
    );

#endif

//
// error logging support
//

VOID _cdecl
CnWriteErrorLogEntry(
    IN ULONG UniqueErrorCode,
    IN NTSTATUS NtStatusCode,
    IN PVOID ExtraInformationBuffer,
    IN USHORT ExtraInformationLength,
    IN USHORT NumberOfInsertionStrings,
    ...
    );

//
// Global Data
//
extern PDRIVER_OBJECT   CnDriverObject;
extern PDEVICE_OBJECT   CnDeviceObject;;
extern PDEVICE_OBJECT   CdpDeviceObject;
extern PKPROCESS        CnSystemProcess;
extern CN_STATE         CnState;
extern PERESOURCE       CnResource;
extern CL_NODE_ID       CnMinValidNodeId;
extern CL_NODE_ID       CnMaxValidNodeId;
extern CL_NODE_ID       CnLocalNodeId;
extern HANDLE           ClussvcProcessHandle;

//
// vars for managing Events. The lookaside list generates Event data structs
// that are used to carry the event data back to user mode. EventLock is
// acquired when ANY Event operation takes place. Events are not generated
// at a high rate, hence the gross level of locking. EventFileHandles is a list
// of CN_FSCONTEXT blocks. These contain the acutal list of Events to be delivered
// to that file handle when clussvc makes an IRP available.
//

extern PNPAGED_LOOKASIDE_LIST   EventLookasideList;
extern CN_LOCK                  EventLock;
extern LIST_ENTRY               EventFileHandles;
extern ULONG                    EventEpoch;
extern LONG                     EventDeliveryInProgress;
extern KEVENT                   EventDeliveryComplete;
extern BOOLEAN                  EventRevisitRequired;

#include <cluxport.h>
#include <event.h>

#ifdef MM_IN_CLUSNET

#include <clusmem.h>

#endif // MM_IN_CLUSNET


#endif // ifndef _CLUSNET_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\driver\resource.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    resource.c

Abstract:

    Generic resource management routines for the Cluster Network driver.

Author:

    Mike Massa (mikemas)           February 12, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     02-12-97    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop


PCN_RESOURCE
CnAllocateResource(
    IN PCN_RESOURCE_POOL   Pool
    )
/*++

Routine Description:

    Allocates a resource from a resource pool.

Arguments:

    Pool - A pointer to the pool from which to allocate a resource.

Return Value:

    A pointer to the allocated resource if successful.
    NULL if unsuccessful.

--*/
{
    PCN_RESOURCE        resource;
    PSINGLE_LIST_ENTRY  entry = ExInterlockedPopEntrySList(
                                    &(Pool->ResourceList),
                                    &(Pool->ResourceListLock)
                                    );

    if (entry != NULL) {
        resource = CONTAINING_RECORD(entry, CN_RESOURCE, Linkage);
    }
    else {
        resource = (*(Pool->CreateRoutine))(Pool->CreateContext);

        if (resource != NULL) {
            CN_INIT_SIGNATURE(resource, CN_RESOURCE_SIG);
            resource->Pool = Pool;
        }
    }

    return(resource);

}  // CnAllocateResource


VOID
CnFreeResource(
    PCN_RESOURCE   Resource
    )
/*++

Routine Description:

    Frees a resource back to a resource pool.

Arguments:

    Resource - A pointer to the resource to free.

Return Value:

    None.

--*/
{
    PCN_RESOURCE_POOL  pool = Resource->Pool;


    if (ExQueryDepthSList(&(pool->ResourceList)) < pool->Depth) {
        ExInterlockedPushEntrySList(
            &(pool->ResourceList),
            &(Resource->Linkage),
            &(pool->ResourceListLock)
            );
    }
    else {
        (*(pool->DeleteRoutine))(Resource);
    }

    return;

} // CnpFreeResource


VOID
CnDrainResourcePool(
    PCN_RESOURCE_POOL   Pool
    )
/*++

Routine Description:

    Frees all cached resources in a resource pool in preparation for the
    pool to be destroyed. This routine does not free the memory containing
    the pool.

Arguments:

    Pool - A pointer to the pool to drain.

Return Value:

    None.

--*/
{
    PSINGLE_LIST_ENTRY  entry;
    PCN_RESOURCE        resource;


    while ( (entry = ExInterlockedPopEntrySList(
                         &(Pool->ResourceList),
                         &(Pool->ResourceListLock)
                         )
            ) != NULL
          )
    {
        resource = CONTAINING_RECORD(entry, CN_RESOURCE, Linkage);

        (*(Pool->DeleteRoutine))(resource);
    }

    return;

}  // CnDrainResourcePool
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\inc\cnettest.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cnettest.h

Abstract:

    Test IOCTL definitions for Cluster Network Driver.

Author:

    Mike Massa (mikemas)           February 3, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     02-03-97    created

Notes:

--*/

#ifndef _CNETTEST_INCLUDED_
#define _CNETTEST_INCLUDED_


#if DBG

//
// General test ioctls. Codes 25-49.
//
#define IOCTL_CLUSNET_SET_DEBUG_MASK  \
            _NTDDCNET_CTL_CODE(25, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// General test ioctl structures.
//
typedef struct {
    ULONG  DebugMask;
} CLUSNET_SET_DEBUG_MASK_REQUEST, *PCLUSNET_SET_DEBUG_MASK_REQUEST;


//
// Transport test ioctls. Codes 150-199.
//

#define IOCTL_CX_ONLINE_PENDING_INTERFACE  \
            _NTDDCNET_CTL_CODE(150, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_ONLINE_INTERFACE  \
            _NTDDCNET_CTL_CODE(151, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_OFFLINE_INTERFACE  \
            _NTDDCNET_CTL_CODE(152, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_FAIL_INTERFACE  \
            _NTDDCNET_CTL_CODE(153, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_SEND_MM_MSG  \
            _NTDDCNET_CTL_CODE(154, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// IOCTL structure definitions
//
typedef CX_INTERFACE_COMMON_REQUEST CX_ONLINE_PENDING_INTERFACE_REQUEST;
typedef PCX_INTERFACE_COMMON_REQUEST PCX_ONLINE_PENDING_INTERFACE_REQUEST;

typedef CX_INTERFACE_COMMON_REQUEST CX_ONLINE_INTERFACE_REQUEST;
typedef PCX_INTERFACE_COMMON_REQUEST PCX_ONLINE_INTERFACE_REQUEST;

typedef CX_INTERFACE_COMMON_REQUEST CX_OFFLINE_INTERFACE_REQUEST;
typedef PCX_INTERFACE_COMMON_REQUEST PCX_OFFLINE_INTERFACE_REQUEST;

typedef CX_INTERFACE_COMMON_REQUEST CX_FAIL_INTERFACE_REQUEST;
typedef PCX_INTERFACE_COMMON_REQUEST PCX_FAIL_INTERFACE_REQUEST;

#define CX_MM_MSG_DATA_LEN   64

typedef struct {
    CL_NODE_ID  DestNodeId;
    ULONG       MessageData[CX_MM_MSG_DATA_LEN];
} CX_SEND_MM_MSG_REQUEST, *PCX_SEND_MM_MSG_REQUEST;

//
// IOCTL status codes
//
// Codes 0x1000 - 1999 are reserved for test values.
//


#endif // DBG


#endif  // _CNETTEST_INCLUDED_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\inc\nbtmgmt.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    nbtmgmt.h

Abstract:

    Declarations for NBT interface management routines.

Author:

    David Dion (daviddio)           December 14, 1999

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    daviddio    12-14-99    created

Notes:

--*/

#ifndef _NBTMGMT_INCLUDED
#define _NBTMGMT_INCLUDED

#include <nbtioctl.h>

//
// Function Prototypes
//

NTSTATUS
NbtIfLoad(
    VOID
    );

VOID
NbtIfShutdown(
    VOID
    );

NTSTATUS
NbtAddIf(
    IN     PNETBT_ADD_DEL_IF    Request,
    IN     ULONG                RequestSize,
    OUT    PNETBT_ADD_DEL_IF    Response,
    IN OUT PULONG               ResponseSize
    );

NTSTATUS
NbtDeleteIf(
    IN PNETBT_ADD_DEL_IF    Request,
    IN ULONG                RequestSize
    );

#endif // ndef _NBTMGMT_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\inc\memlog.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    memlog.h

Abstract:

    in memory logging facility

Author:

    Charlie Wickham (charlwi) 17-Mar-1997

Revision History:

--*/

#ifndef _MEMLOG_
#define _MEMLOG_

/* Prototypes */
/* End Prototypes */

#ifdef MEMLOGGING

typedef struct _MEMLOG_ENTRY {
    LARGE_INTEGER SysTime;
    USHORT Type;
    USHORT LineNo;
    ULONG_PTR Arg1;
    ULONG_PTR Arg2;
} MEMLOG_ENTRY, *PMEMLOG_ENTRY;

// 
//  Do not change the order of
//
//    MemLogReceivedPacket,
//    MemLogReceivedPacket1,
//
//    MemLogMissedIfHB,
//    MemLogMissedIfHB1,
//   
//    MemLogFailingIf,
//    MemLogFailingIf1,
//
//  MEMLOG4 relies on MemLogFailingIf1 = MemLogFailingIf + 1, etc
// 

typedef enum _MEMLOG_TYPES {
    MemLogInitLog = 1,
    MemLogInitHB,
    MemLogHBStarted,
    MemLogHBStopped,
    MemLogHBDpcRunning,
    MemLogWaitForDpcFinish,
    MemLogMissedIfHB,
    MemLogMissedIfHB1,
    MemLogFailingIf,
    MemLogFailingIf1,
    MemLogSendHBWalkNode,
    MemLogCheckHBWalkNode,
    MemLogCheckHBNodeReachable,
    MemLogCheckHBMissedHB,
    MemLogSendingHB,
    MemLogNodeDown,
    MemLogSetDpcEvent,
    MemLogNoNetID,
    MemLogOnlineIf,
    MemLogSeqAckMismatch,
    MemLogNodeUp,
    MemLogReceivedPacket,
    MemLogReceivedPacket1,
    MemLogDpcTimeSkew,
    MemLogHBPacketSend,
    MemLogHBPacketSendComplete,
    MemLogPoisonPktReceived,
    MemLogOuterscreen,
    MemLogNodeDownIssued,
    MemLogRegroupFinished,
    MemLogInconsistentStates,
    MemLogOutOfSequence,
    MemLogInvalidSignature,
    MemLogSignatureSize,
    MemLogNoSecurityContext,
    MemLogPacketSendFailed
} MEMLOG_TYPES;

extern ULONG MemLogEntries;
extern ULONG MemLogNextLogEntry;

extern PMEMLOG_ENTRY MemLog;
extern KSPIN_LOCK MemLogLock;

#define _MEMLOG( _type, _arg1, _arg2 )                                      \
    {                                                                       \
        KIRQL MemLogIrql;                                                   \
        if ( MemLogEntries ) {                                              \
            KeAcquireSpinLock( &MemLogLock, &MemLogIrql );                  \
            KeQuerySystemTime( &MemLog[ MemLogNextLogEntry ].SysTime );     \
            MemLog[ MemLogNextLogEntry ].Type = _type;                      \
            MemLog[ MemLogNextLogEntry ].LineNo = __LINE__;                 \
            MemLog[ MemLogNextLogEntry ].Arg1 = _arg1;                      \
            MemLog[ MemLogNextLogEntry ].Arg2 = _arg2;                      \
            if ( ++MemLogNextLogEntry == MemLogEntries )                    \
                MemLogNextLogEntry = 0;                                     \
            MemLog[ MemLogNextLogEntry ].Type = 0;                          \
            KeReleaseSpinLock( &MemLogLock, MemLogIrql );                   \
        }                                                                   \
    }

#else // MEMLOGGING

#define _MEMLOG( _type, _arg1, _arg2 )

#endif // MEMLOGGING

#define MEMLOG( _type, _arg1, _arg2 )       \
    {                                       \
        _MEMLOG( _type, _arg1, _arg2 );     \
    }

#define MEMLOG4( _type, _arg3, _arg4 , _arg1, _arg2 )  \
    {                                                  \
        _MEMLOG( _type + 1, _arg3, _arg4 );            \
        _MEMLOG( _type, _arg1, _arg2 );                \
    }

#endif /* _MEMLOG_ */

/* end memlog.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\inc\event.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    event.h

Abstract:

    Event definitions

Author:

    Charlie Wickham (charlwi) 17-Feb-1997

Revision History:

--*/

#ifndef _EVENT_H_
#define _EVENT_H_

/* Prototypes */

NTSTATUS
CnSetEventMask(
    IN  PCN_FSCONTEXT                   FsContext,
    IN  PCLUSNET_SET_EVENT_MASK_REQUEST EventRequest
    );

NTSTATUS
CnGetNextEvent(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CnIssueEvent(
    CLUSNET_EVENT_TYPE Event,
    CL_NODE_ID NodeId OPTIONAL,
    CL_NETWORK_ID NetworkId OPTIONAL
    );

/* End Prototypes */

#endif /* _EVENT_H_ */

/* end event.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\inc\ntemgmt.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ntemgmt.h

Abstract:

    Declartions for IP Network Table Entry management routines.

Author:

    Mike Massa (mikemas)           April 16, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     04-16-97    created

Notes:

--*/

#ifndef _NTEMGMT_INCLUDED
#define _NTEMGMT_INCLUDED

#include <ntddip.h>

//
// Function Prototypes
//


NTSTATUS
IpaLoad(
    VOID
    );

NTSTATUS
IpaInitialize(
    VOID
    );

VOID
IpaShutdown(
    VOID
    );

NTSTATUS
IpaAddNTE(
    IN PIRP                     Irp,
    IN PIO_STACK_LOCATION       IrpSp
    );

NTSTATUS
IpaDeleteNTE(
    IN PIRP                     Irp,
    IN PIO_STACK_LOCATION       IrpSp
    );

NTSTATUS
IpaSetNTEAddress(
    IN PIRP                     Irp,
    IN PIO_STACK_LOCATION       IrpSp
    );

BOOLEAN
IpaIsAddressRegistered(
    ULONG  Address
    );

#endif // ndef _NTEMGMT_INCLUDED



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\inc\ntddcnet.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ntddcnet.h

Abstract:

    Public header file for the Cluster Network Driver. Defines all
    control IOCTLs.

Author:

    Mike Massa (mikemas)           January 3, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-03-97    created

Notes:

--*/

#ifndef _NTDDCNET_INCLUDED_
#define _NTDDCNET_INCLUDED_


//
// Device Names.
//
// ClusterNetwork is the control device. All control IOCTLs are issued
// on this device. ClusterDatagramProtocol is the datagram transport device.
// This device supports TDI IOCTLs.
//
#define DD_CLUSNET_DEVICE_NAME   L"\\Device\\ClusterNetwork"
#define DD_CDP_DEVICE_NAME       L"\\Device\\ClusterDatagramProtocol"


//
// General Types
//

//
// Control IOCTL definitions.
//

#define FSCTL_NTDDCNET_BASE     FILE_DEVICE_NETWORK

#define _NTDDCNET_CTL_CODE(function, method, access) \
            CTL_CODE(FSCTL_NTDDCNET_BASE, function, method, access)

#define ClusnetIoctlCode(_ioctl)    (((_ioctl) >> 2) & 0x00000FFF)


//
// General driver management IOCTLs. Codes 0-49
//
#define CLUSNET_MINIMUM_GENERAL_IOCTL   0
#define CLUSNET_MAXIMUM_GENERAL_IOCTL  49

/* #define ClusnetIsGeneralIoctl(_ioctl) \
            ( (ClusnetIoctlCode(_ioctl) >= CLUSNET_MINIMUM_GENERAL_IOCTL) && \
              (ClusnetIoctlCode(_ioctl) <= CLUSNET_MAXIMUM_GENERAL_IOCTL) ) */
// Check for CLUSNET_MINIMUM_GENERAL_IOCTL removed since ioctl is a ULONG
// and always greater than zero. Reinstate if CLUSNET_MINIMUM_GENERAL_IOCTL
// is made nonzero.
#define ClusnetIsGeneralIoctl(_ioctl) \
            (ClusnetIoctlCode(_ioctl) <= CLUSNET_MAXIMUM_GENERAL_IOCTL)

#define IOCTL_CLUSNET_INITIALIZE  \
            _NTDDCNET_CTL_CODE(0, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CLUSNET_SHUTDOWN  \
            _NTDDCNET_CTL_CODE(1, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CLUSNET_ENABLE_SHUTDOWN_ON_CLOSE  \
            _NTDDCNET_CTL_CODE(2, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CLUSNET_DISABLE_SHUTDOWN_ON_CLOSE  \
            _NTDDCNET_CTL_CODE(3, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CLUSNET_SET_EVENT_MASK  \
            _NTDDCNET_CTL_CODE(4, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CLUSNET_GET_NEXT_EVENT  \
            _NTDDCNET_CTL_CODE(5, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CLUSNET_HALT  \
            _NTDDCNET_CTL_CODE(6, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CLUSNET_SET_MEMORY_LOGGING  \
            _NTDDCNET_CTL_CODE(7, METHOD_BUFFERED, FILE_WRITE_ACCESS)
            
//
// NTE IOCTLs are a special class of general driver management IOCTLs.
// Codes are 8-12.
//
#define CLUSNET_MINIMUM_NTE_IOCTL  8
#define CLUSNET_MAXIMUM_NTE_IOCTL 12

#define ClusnetIsNTEIoctl(_ioctl) \
            ( (ClusnetIoctlCode(_ioctl) >= CLUSNET_MINIMUM_NTE_IOCTL) && \
              (ClusnetIoctlCode(_ioctl) <= CLUSNET_MAXIMUM_NTE_IOCTL) )

#define IOCTL_CLUSNET_ADD_NTE  \
            _NTDDCNET_CTL_CODE(8, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CLUSNET_DELETE_NTE  \
            _NTDDCNET_CTL_CODE(9, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CLUSNET_SET_NTE_ADDRESS  \
            _NTDDCNET_CTL_CODE(10, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CLUSNET_ADD_NBT_INTERFACE  \
            _NTDDCNET_CTL_CODE(11, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CLUSNET_DEL_NBT_INTERFACE  \
            _NTDDCNET_CTL_CODE(12, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// Codes 25-49 are reserved for general test ioctls
//

//
// General driver IOCTL structure definitions
//

//
// Initialize request. This must be issued before any other request.
//
typedef struct {
    CL_NODE_ID   LocalNodeId;
    ULONG        MaxNodes;
} CLUSNET_INITIALIZE_REQUEST, *PCLUSNET_INITIALIZE_REQUEST;

//
// Shutdown request. Deletes all registered nodes and interfaces.
//
typedef struct {
    CL_NODE_ID   LocalNodeId;
} CLUSNET_SHUTDOWN_REQUEST, *PCLUSNET_SHUTDOWN_REQUEST;

//
// shutdown on close request
//
typedef struct {
    ULONG        ProcessId;
} CLUSNET_SHUTDOWN_ON_CLOSE_REQUEST, *PCLUSNET_SHUTDOWN_ON_CLOSE_REQUEST;

//
// Set event mask request. Hands a bit mask and a function (kernel mode
// only) to the driver indicating which events the thread wishes to
// be notified about. The IRP is pended for user mode. Kernel mode
// events are delivered via the callback.
//

typedef VOID (*CLUSNET_EVENT_CALLBACK_ROUTINE)(CLUSNET_EVENT_TYPE,
                                               CL_NODE_ID,
                                               CL_NETWORK_ID);

typedef struct {
    ULONG EventMask;
    CLUSNET_EVENT_CALLBACK_ROUTINE KmodeEventCallback;
} CLUSNET_SET_EVENT_MASK_REQUEST, *PCLUSNET_SET_EVENT_MASK_REQUEST;

typedef CLUSNET_EVENT CLUSNET_EVENT_RESPONSE;
typedef PCLUSNET_EVENT PCLUSNET_EVENT_RESPONSE;

typedef struct _CLUSNET_EVENT_ENTRY {
    LIST_ENTRY Linkage;
    CLUSNET_EVENT EventData;
} CLUSNET_EVENT_ENTRY, *PCLUSNET_EVENT_ENTRY;

#define CN_EVENT_SIGNATURE      'tvec'

//
// in-memory logging. conveys the number of entries to allocate
// (zero if turning off) for logging events
//

typedef struct _CLUSNET_SET_MEM_LOGGING_REQUEST {
    ULONG NumberOfEntries;
} CLUSNET_SET_MEM_LOGGING_REQUEST, *PCLUSNET_SET_MEM_LOGGING_REQUEST;

#ifdef MM_IN_CLUSNET
//
// Membership management IOCTLs. Codes 50-99
//

#define CLUSNET_MINIMUM_CMM_IOCTL  50
#define CLUSNET_MAXIMUM_CMM_IOCTL  99

#define ClusnetIsMembershipIoctl(_ioctl) \
            ( (ClusnetIoctlCode(_ioctl) >= CLUSNET_MINIMUM_CMM_IOCTL) && \
              (ClusnetIoctlCode(_ioctl) <= CLUSNET_MAXIMUM_CMM_IOCTL) )


//
// NOTE: currently (3/3/97) CMM Ioctl codes 50 through 62 are not used.
// These were defined during an initial attempt to get the membership
// manager into kernel mode (which didn't succeed).
//

//
// first guy in cluster forms one...
//

#define IOCTL_CMM_FORM_CLUSTER \
            _NTDDCNET_CTL_CODE(50, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// MMJoin phases. Basically correspond to the 4 messages that are sent as part
// of the Join process. End must be submitted to terminate the process.
//

#define IOCTL_CMM_JOIN_CLUSTER_PHASE1  \
            _NTDDCNET_CTL_CODE(51, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CMM_JOIN_CLUSTER_PHASE2  \
            _NTDDCNET_CTL_CODE(52, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CMM_JOIN_CLUSTER_PHASE3  \
            _NTDDCNET_CTL_CODE(53, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CMM_JOIN_CLUSTER_PHASE4  \
            _NTDDCNET_CTL_CODE(54, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CMM_JOIN_CLUSTER_ABORT  \
            _NTDDCNET_CTL_CODE(55, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CMM_JOIN_CLUSTER_END  \
            _NTDDCNET_CTL_CODE(56, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// This ioctl is used to deliver a join message on an active node.
//
#define IOCTL_CMM_DELIVER_JOIN_MESSAGE  \
            _NTDDCNET_CTL_CODE(57, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CMM_SHUTDOWN_CLUSTER  \
            _NTDDCNET_CTL_CODE(58, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CMM_LEAVE_CLUSTER  \
            _NTDDCNET_CTL_CODE(59, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CMM_EJECT_CLUSTER  \
            _NTDDCNET_CTL_CODE(60, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CMM_GET_NODE_STATE  \
            _NTDDCNET_CTL_CODE(61, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//
// callbacks are done by completing an (usually) outstanding IRP. The type
// of callback as well as required parameters are passed back to clussvc
// by completing this IRP.
//

#define IOCTL_CMM_REGISTER_CALLBACK  \
            _NTDDCNET_CTL_CODE(62, METHOD_BUFFERED, FILE_WRITE_ACCESS)



//
// Membership IOCTL structure definitions
//

//
// Common request structure
//
// This structure shared among a number of requests. The Node field may not be
// used; see the appropriate MM* routine to determine what is used.
//
typedef struct _CMM_COMMON_CLUSTER_REQUEST {
    ULONG  Node;
} CMM_COMMON_CLUSTER_REQUEST, *PCMM_COMMON_CLUSTER_REQUEST;

//
// Form cluster request
//
typedef struct _CMM_FORM_CLUSTER_REQUEST {
    ULONG  ClockPeriod;
    ULONG  SendHBRate;
    ULONG  RecvHBRate;
} CMM_FORM_CLUSTER_REQUEST, *PCMM_FORM_CLUSTER_REQUEST;

//
// Join cluster request
//
// Used for all four join phases. This structure is variable in length. Clussvc
// must allocate enough space in which the MM writes a packet to be sent by
// Clussvc. MM sets SizeOfSendData on output to indicate how much data is in
// SendData after a join phase has been called. SendNodeMask indicates which
// nodes should receive the packet.
//

typedef struct _CMM_JOIN_CLUSTER_REQUEST {
    ULONG  JoiningNode;
    ULONG  JoinTimeout;
} CMM_JOIN_CLUSTER_REQUEST, *PCMM_JOIN_CLUSTER_REQUEST;

//
// Join cluster response
//
typedef struct _CMM_JOIN_CLUSTER_RESPONSE {
    ULONG     SizeOfSendData;
    ULONG     SendNodeMask;
    UCHAR     SendData[0];
} CMM_JOIN_CLUSTER_RESPONSE, *PCMM_JOIN_CLUSTER_RESPONSE;

//
// Deliver join message request
//
typedef struct _CMM_DELIVER_JOIN_CLUSTER_REQUEST {
    UCHAR     MessageData[0];
} CMM_DELIVER_JION_MESSAGE_REQUEST, *PCMM_DELIVER_JION_MESSAGE_REQUEST;

//
// Eject node request
//
typedef CMM_COMMON_CLUSTER_REQUEST CMM_EJECT_CLUSTER_REQUEST;
typedef PCMM_COMMON_CLUSTER_REQUEST PCMM_EJECT_CLUSTER_REQUEST;

//
// Get node membership state request
//
typedef CMM_COMMON_CLUSTER_REQUEST CMM_GET_NODE_STATE_REQUEST;
typedef PCMM_COMMON_CLUSTER_REQUEST PCMM_GET_NODE_STATE_REQUEST;

//
// Get node membership state response
//
typedef struct _CMM_GET_NODE_STATE_RESPONSE {
    CLUSNET_NODE_STATE  State;
} CMM_GET_NODE_STATE_RESPONSE, *PCMM_GET_NODE_STATE_RESPONSE;

//
// struct used to notfiy clussvc of callback events. All callbacks have a DWORD as their
// first param. MMNodeChange is the only callback with a 2nd param. CallbackType is one
// of RGP_CALLBACK_*. These structs are linked off of the main RGP struct
//

typedef struct _CMM_CALLBACK_DATA {
    ULONG CallbackType;
    ULONG Arg1;
    ULONG Arg2;
} CMM_CALLBACK_DATA, *PCMM_CALLBACK_DATA;

typedef struct _CMM_CALLBACK_EVENT {
    LIST_ENTRY Linkage;
    CMM_CALLBACK_DATA EventData;
} CMM_CALLBACK_EVENT, *PCMM_CALLBACK_EVENT;

#endif // MM_IN_CLUSNET

//
// Transport management IOCTLs. Codes 100-199
//
#define CLUSNET_MINIMUM_CX_IOCTL  100
#define CLUSNET_MAXIMUM_CX_IOCTL  199

#define ClusnetIsTransportIoctl(_ioctl) \
            ( (ClusnetIoctlCode(_ioctl) >= CLUSNET_MINIMUM_CX_IOCTL) && \
              (ClusnetIoctlCode(_ioctl) <= CLUSNET_MAXIMUM_CX_IOCTL) )

#define IOCTL_CX_MINIMUM_IOCTL  \
            _NTDDCNET_CTL_CODE(100, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_REGISTER_NODE  \
            _NTDDCNET_CTL_CODE(100, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_DEREGISTER_NODE  \
            _NTDDCNET_CTL_CODE(101, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_REGISTER_NETWORK  \
            _NTDDCNET_CTL_CODE(102, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_DEREGISTER_NETWORK  \
            _NTDDCNET_CTL_CODE(103, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_REGISTER_INTERFACE  \
            _NTDDCNET_CTL_CODE(104, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_DEREGISTER_INTERFACE  \
            _NTDDCNET_CTL_CODE(105, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_ONLINE_NODE_COMM  \
            _NTDDCNET_CTL_CODE(106, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_OFFLINE_NODE_COMM  \
            _NTDDCNET_CTL_CODE(107, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_ONLINE_NETWORK  \
            _NTDDCNET_CTL_CODE(108, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_OFFLINE_NETWORK  \
            _NTDDCNET_CTL_CODE(109, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_GET_NETWORK_PRIORITY  \
            _NTDDCNET_CTL_CODE(110, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_SET_NETWORK_PRIORITY  \
            _NTDDCNET_CTL_CODE(111, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_GET_INTERFACE_PRIORITY  \
            _NTDDCNET_CTL_CODE(112, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_SET_INTERFACE_PRIORITY  \
            _NTDDCNET_CTL_CODE(113, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_GET_NODE_STATE  \
            _NTDDCNET_CTL_CODE(114, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_GET_NETWORK_STATE  \
            _NTDDCNET_CTL_CODE(115, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_GET_INTERFACE_STATE  \
            _NTDDCNET_CTL_CODE(116, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_IGNORE_NODE_STATE  \
            _NTDDCNET_CTL_CODE(117, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_CX_SET_NODE_MMSTATE  \
            _NTDDCNET_CTL_CODE(118, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_GET_NODE_MMSTATE  \
            _NTDDCNET_CTL_CODE(119, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_SEND_POISON_PACKET  \
            _NTDDCNET_CTL_CODE(120, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_SET_OUTERSCREEN  \
            _NTDDCNET_CTL_CODE(121, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_REGROUP_FINISHED  \
            _NTDDCNET_CTL_CODE(122, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_IMPORT_SECURITY_CONTEXTS  \
            _NTDDCNET_CTL_CODE(123, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_SET_NETWORK_RESTRICTION  \
            _NTDDCNET_CTL_CODE(124, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_RESERVE_ENDPOINT \
            _NTDDCNET_CTL_CODE(125, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_CONFIGURE_MULTICAST \
            _NTDDCNET_CTL_CODE(126, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_CX_GET_MULTICAST_REACHABLE_SET \
            _NTDDCNET_CTL_CODE(127, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// Codes 150-199 are reserved for test ioctls and are defined in cnettest.h
//

#define IOCTL_CX_MAXIMUM_IOCTL  \
            _NTDDCNET_CTL_CODE(199, METHOD_BUFFERED, FILE_WRITE_ACCESS)


//
// Transport IOCTL structure definitions
//

//
// Common request definitions
//
typedef struct {
    CL_NODE_ID     Id;
} CX_NODE_COMMON_REQUEST, *PCX_NODE_COMMON_REQUEST;

typedef struct {
    CL_NETWORK_ID  Id;
} CX_NETWORK_COMMON_REQUEST, *PCX_NETWORK_COMMON_REQUEST;

typedef struct {
    CL_NODE_ID     NodeId;
    CL_NETWORK_ID  NetworkId;
} CX_INTERFACE_COMMON_REQUEST, *PCX_INTERFACE_COMMON_REQUEST;

//
// Node registration request.
//
typedef CX_NODE_COMMON_REQUEST CX_NODE_REG_REQUEST;
typedef PCX_NODE_COMMON_REQUEST PCX_NODE_REG_REQUEST;

//
// Node deregistration request.
//
typedef CX_NODE_COMMON_REQUEST CX_NODE_DEREG_REQUEST;
typedef PCX_NODE_COMMON_REQUEST PCX_NODE_DEREG_REQUEST;

//
// Network registration request
//
// The Priority indicates the order in which networks will be chosen to
// carry packets. Valid values are 0x1-0xFFFFFFFF. Numerically lower values
// are higher priority.
//
// The TdiProviderName and TdiBindAddress structures follow the registration
// strucuture in the IRP. The TdiProviderName is the device name
// (e.g \Device\Udp) which must be opened to access the underlying
// transport provider. The TdiBindAddress is the provider's local address to
// which the network should bind.
//
typedef struct {
    CL_NETWORK_ID     Id;
    ULONG             Priority;
    BOOLEAN           Restricted;
} CX_NETWORK_REG_REQUEST, *PCX_NETWORK_REG_REQUEST;

//
// Network deregistration request.
//
typedef CX_NETWORK_COMMON_REQUEST CX_NETWORK_DEREG_REQUEST;
typedef PCX_NETWORK_COMMON_REQUEST PCX_NETWORK_DEREG_REQUEST;

//
// Interface registration request.
//
// The Priority indicates the order in which interfaces will be chosen to
// carry packets. Valid values are 0x1-0xFFFFFFFF. Numerically lower values
// are higher priority. A value of zero indicates that the interface
// should inherit its priority from the associated network.
//
// AdapterIdOffset is the offset in bytes from the beginning of the
// CX_INTERFACE_REG_REQUEST structure to a buffer containing the adapter
// id as a string of UNICODE characters. AdapterIdLength is the length,
// in bytes, of the UNICODE string, not including terminating UNICODE_NULL.
// AdapterIdOffset is 64-bit aligned.
//
// The TdiAddress field is a placeholder for a TDI TRANSPORT_ADDRESS
// structure which is embedded in the registration structure. This
// structure contains the transport address at which the cluster transport
// on the specified node is listening on the specified network. For the
// local node, this is the address used in the network registration (unless
// a wildcard address was used).
//
typedef struct {
    CL_NODE_ID         NodeId;
    CL_NETWORK_ID      NetworkId;
    ULONG              Priority;
    ULONG              AdapterIdOffset;
    ULONG              AdapterIdLength;
    ULONG              TdiAddressLength;
    ULONG              TdiAddress[1];                                         // TDI TRANSPORT_ADDRESS struct
} CX_INTERFACE_REG_REQUEST, *PCX_INTERFACE_REG_REQUEST;

typedef struct {
    ULONG              MediaStatus; // NDIS_MEDIA_STATUS
} CX_INTERFACE_REG_RESPONSE, *PCX_INTERFACE_REG_RESPONSE;

//
// Interface deregistration request.
//
typedef CX_INTERFACE_COMMON_REQUEST CX_INTERFACE_DEREG_REQUEST;
typedef PCX_INTERFACE_COMMON_REQUEST PCX_INTERFACE_DEREG_REQUEST;

//
//
// Online node request
//
typedef CX_NODE_COMMON_REQUEST CX_ONLINE_NODE_COMM_REQUEST;
typedef PCX_NODE_COMMON_REQUEST PCX_ONLINE_NODE_COMM_REQUEST;

//
// Offline node request
//
typedef CX_NODE_COMMON_REQUEST CX_OFFLINE_NODE_COMM_REQUEST;
typedef PCX_NODE_COMMON_REQUEST PCX_OFFLINE_NODE_COMM_REQUEST;

// Online network request
//
// The TdiProviderName and TdiBindAddress structures follow the registration
// strucuture in the IRP. The TdiProviderName is the device name
// (e.g \Device\Udp) which must be opened to access the underlying
// transport provider. The TdiBindAddress is the provider's local address to
// which the network should bind.
//
// The output buffer for this request contains a TDI_ADDRESS_INFO structure,
// which contains the local address that the provider actually opened.
//
typedef struct {
    CL_NETWORK_ID     Id;
    ULONG             TdiProviderNameOffset;   // offset from start of struct
    ULONG             TdiProviderNameLength;   // in bytes, including NUL
    ULONG             TdiBindAddressOffset;    // offset from start of struct
    ULONG             TdiBindAddressLength;
    ULONG             AdapterNameOffset;    // offset from start of struct
    ULONG             AdapterNameLength;
} CX_ONLINE_NETWORK_REQUEST, *PCX_ONLINE_NETWORK_REQUEST;

//
// Offline network request
//
typedef CX_NETWORK_COMMON_REQUEST CX_OFFLINE_NETWORK_REQUEST;
typedef PCX_NETWORK_COMMON_REQUEST PCX_OFFLINE_NETWORK_REQUEST;

//
// Set network restriction request
//
typedef struct {
    CL_NETWORK_ID      Id;
    BOOLEAN            Restricted;
    ULONG              NewPriority;
} CX_SET_NETWORK_RESTRICTION_REQUEST, *PCX_SET_NETWORK_RESTRICTION_REQUEST;

//
// Get network priority request
//
typedef CX_NETWORK_COMMON_REQUEST CX_GET_NETWORK_PRIORITY_REQUEST;
typedef PCX_NETWORK_COMMON_REQUEST PCX_GET_NETWORK_PRIORITY_REQUEST;

//
// Get network priority response
//
typedef struct {
    ULONG              Priority;
} CX_GET_NETWORK_PRIORITY_RESPONSE, *PCX_GET_NETWORK_PRIORITY_RESPONSE;

//
// Set network priority request
//
typedef struct {
    CL_NETWORK_ID      Id;
    ULONG              Priority;
} CX_SET_NETWORK_PRIORITY_REQUEST, *PCX_SET_NETWORK_PRIORITY_REQUEST;

//
// Get interface priority request
//
typedef CX_INTERFACE_COMMON_REQUEST CX_GET_INTERFACE_PRIORITY_REQUEST;
typedef PCX_INTERFACE_COMMON_REQUEST PCX_GET_INTERFACE_PRIORITY_REQUEST;

//
// Get interface priority response
//
typedef struct {
    ULONG              InterfacePriority;
    ULONG              NetworkPriority;
} CX_GET_INTERFACE_PRIORITY_RESPONSE, *PCX_GET_INTERFACE_PRIORITY_RESPONSE;

//
// Set interface priority request
//
typedef struct {
    CL_NODE_ID         NodeId;
    CL_NETWORK_ID      NetworkId;
    ULONG              Priority;
} CX_SET_INTERFACE_PRIORITY_REQUEST, *PCX_SET_INTERFACE_PRIORITY_REQUEST;

//
// Get node state request
//
typedef CX_NODE_COMMON_REQUEST CX_GET_NODE_STATE_REQUEST;
typedef PCX_NODE_COMMON_REQUEST PCX_GET_NODE_STATE_REQUEST;

//
// Get node state response
//
typedef struct {
    CLUSNET_NODE_COMM_STATE   State;
} CX_GET_NODE_STATE_RESPONSE, *PCX_GET_NODE_STATE_RESPONSE;

//
// Get network state request
//
typedef CX_NETWORK_COMMON_REQUEST CX_GET_NETWORK_STATE_REQUEST;
typedef PCX_NETWORK_COMMON_REQUEST PCX_GET_NETWORK_STATE_REQUEST;

//
// Get network state response
//
typedef struct {
    CLUSNET_NETWORK_STATE   State;
} CX_GET_NETWORK_STATE_RESPONSE, *PCX_GET_NETWORK_STATE_RESPONSE;

//
// Get interface state request
//
typedef CX_INTERFACE_COMMON_REQUEST CX_GET_INTERFACE_STATE_REQUEST;
typedef PCX_INTERFACE_COMMON_REQUEST PCX_GET_INTERFACE_STATE_REQUEST;

//
// Get interface state response
//
typedef struct {
    CLUSNET_INTERFACE_STATE   State;
} CX_GET_INTERFACE_STATE_RESPONSE, *PCX_GET_INTERFACE_STATE_RESPONSE;

//
// Get node membership state request
//
typedef CX_NODE_COMMON_REQUEST CX_GET_NODE_MMSTATE_REQUEST;
typedef PCX_NODE_COMMON_REQUEST PCX_GET_NODE_MMSTATE_REQUEST;

//
// Get node membership state response
//
typedef struct {
    CLUSNET_NODE_STATE State;
} CX_GET_NODE_MMSTATE_RESPONSE, *PCX_GET_NODE_MMSTATE_RESPONSE;

//
// Set node membership state request
//
typedef struct _CX_SET_NODE_MMSTATE_REQUEST {
    CL_NODE_ID NodeId;
    CLUSNET_NODE_STATE State;
} CX_SET_NODE_MMSTATE_REQUEST, *PCX_SET_NODE_MMSTATE_REQUEST;

//
// Send Poison Packet request
//
typedef CX_NODE_COMMON_REQUEST CX_SEND_POISON_PKT_REQUEST;
typedef PCX_NODE_COMMON_REQUEST PCX_SEND_POISON_PKT_REQUEST;

//
// Set Outerscreen request. sets clusnet's notion of which nodes
// are in the cluster. used to filter poison packets from non-cluster
// members.
//
typedef struct _CX_SET_OUTERSCREEN_REQUEST {
    ULONG Outerscreen;
} CX_SET_OUTERSCREEN_REQUEST, *PCX_SET_OUTERSCREEN_REQUEST;

//
// Regroup Finished request. tell clusnet the new event epoch
//
typedef struct _CX_REGROUP_FINISHED_REQUEST {
    ULONG NewEpoch;
} CX_REGROUP_FINISHED_REQUEST, *PCX_REGROUP_FINISHED_REQUEST;

//
// Import Security Context. used to ship pointers to security blobs
// from user to kernel mode so clusnet can sign its poison and
// heartbeat pkts.
//
typedef struct _CX_IMPORT_SECURITY_CONTEXT_REQUEST {
    CL_NODE_ID  JoiningNodeId;
    PVOID       PackageName;
    ULONG       PackageNameSize;
    ULONG       SignatureSize;
    PVOID       ServerContext;
    PVOID       ClientContext;
} CX_IMPORT_SECURITY_CONTEXT_REQUEST, *PCX_IMPORT_SECURITY_CONTEXT_REQUEST;

//
// Configure Multicast plumbs a network's multicast parameters into
// clusnet.
//
typedef struct _CX_CONFIGURE_MULTICAST_REQUEST {
    CL_NETWORK_ID    NetworkId;
    ULONG            MulticastNetworkBrand;
    ULONG            MulticastAddress;   // offset from start of struct
    ULONG            MulticastAddressLength;
    ULONG            Key;                // offset from start of struct
    ULONG            KeyLength;
    ULONG            Salt;               // offset from start of struct
    ULONG            SaltLength;
} CX_CONFIGURE_MULTICAST_REQUEST, *PCX_CONFIGURE_MULTICAST_REQUEST;

//
// Request and response to query a network's multicast reachable set.
//
typedef CX_NETWORK_COMMON_REQUEST CX_GET_MULTICAST_REACHABLE_SET_REQUEST;
typedef PCX_NETWORK_COMMON_REQUEST PCX_GET_MULTICAST_REACHABLE_SET_REQUEST;

typedef struct _CX_GET_MULTICAST_REACHABLE_SET_RESPONSE {
    ULONG            NodeScreen;
} CX_GET_MULTICAST_REACHABLE_SET_RESPONSE, 
*PCX_GET_MULTICAST_REACHABLE_SET_RESPONSE;

#endif   //ifndef _NTDDCNET_INCLUDED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\inc\cnwmi.h ===
/*++

Copyright (c) 1996-1998  Microsoft Corporation

Module Name:

    cnwmi.h

Abstract:

    clusnet specific wmi tracing declarations

Authors:

    GorN     10-Aug-1999

Environment:

    kernel mode only

Notes:

Revision History:


--*/

#define WPP_CONTROL_GUIDS \
    WPP_DEFINE_CONTROL_GUID(Clusnet,(8e707979,0c45,4f9b,bb17,a1124d54bbfe), \
      WPP_DEFINE_BIT(HBEAT_EVENT)     \
      WPP_DEFINE_BIT(HBEAT_ERROR)     \
      WPP_DEFINE_BIT(HBEAT_DETAIL)    \
                                      \
      WPP_DEFINE_BIT(CNP_SEND_ERROR)  \
      WPP_DEFINE_BIT(CNP_RECV_ERROR)  \
      WPP_DEFINE_BIT(CNP_SEND_DETAIL) \
      WPP_DEFINE_BIT(CNP_RECV_DETAIL) \
                                      \
      WPP_DEFINE_BIT(CCMP_SEND_ERROR) \
      WPP_DEFINE_BIT(CCMP_RECV_ERROR) \
      WPP_DEFINE_BIT(CCMP_SEND_DETAIL)\
      WPP_DEFINE_BIT(CCMP_RECV_DETAIL)\
                                      \
      WPP_DEFINE_BIT(CDP_SEND_ERROR)  \
      WPP_DEFINE_BIT(CDP_RECV_ERROR)  \
      WPP_DEFINE_BIT(CDP_SEND_DETAIL) \
      WPP_DEFINE_BIT(CDP_RECV_DETAIL) \
                                      \
      WPP_DEFINE_BIT(CXPNP)           \
      WPP_DEFINE_BIT(CNP_NET_DETAIL)  \
      WPP_DEFINE_BIT(NTEMGMT_DETAIL)  \
      WPP_DEFINE_BIT(CNP_NODE_DETAIL) \
                                      \
      WPP_DEFINE_BIT(CDP_ADDR_DETAIL) \
      WPP_DEFINE_BIT(EVENT_DETAIL)    \
      WPP_DEFINE_BIT(CNP_IF_DETAIL)   \
   )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\inc\hblog.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    hblog.h

Abstract:

    in memory logging for heart beat debugging

Author:

    Charlie Wickham (charlwi) 17-Mar-1997

Revision History:

--*/

#ifndef _HBLOG_
#define _HBLOG_

/* Prototypes */
/* End Prototypes */

#ifdef HBLOGGING

typedef struct _HBLOG_ENTRY {
    LARGE_INTEGER SysTime;
    USHORT Type;
    USHORT LineNo;
    ULONG Arg1;
    ULONG Arg2;
} HBLOG_ENTRY, *PHBLOG_ENTRY;

typedef enum _HBLOG_TYPES {
    HBLogInitHB = 1,
    HBLogHBStarted,
    HBLogHBStopped,
    HBLogHBDpcRunning,
    HBLogWaitForDpcFinish,
    HBLogMissedIfHB,
    HBLogMissedIfHB1,
    HBLogFailingIf,
    HBLogFailingIf1,
    HBLogSendHBWalkNode,
    HBLogCheckHBWalkNode,
    HBLogCheckHBNodeReachable,
    HBLogCheckHBMissedHB,
    HBLogSendingHB,
    HBLogNodeDown,
    HBLogSetDpcEvent,
    HBLogNoNetID,
    HBLogOnlineIf,
    HBLogSeqAckMismatch,
    HBLogNodeUp,
    HBLogReceivedPacket,
    HBLogReceivedPacket1,
    HBLogDpcTimeSkew,
    HBLogHBPacketSend,
    HBLogHBPacketSendComplete,
    HBLogPoisonPktReceived,
    HBLogOuterscreen,
    HBLogNodeDownIssued,
    HBLogRegroupFinished,
    HBLogInconsistentStates
} HBLOG_TYPES;

#endif // HBLOGGING

#endif /* _HBLOG_ */

/* end hblog.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\kdcn\precomp.h ===
#if DBG
#define DEBUG 1
#endif

#define NT 1
#define _PNP_POWER  1
#define SECFLTR 1

#include <ntverp.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
// Prevent hal.h, included in ntos.h from overriding _BUS_DATA_TYPE
// enum found in ntioapi.h, included from nt.h.
//
#define _HAL_
#include <ntos.h>

#include <windows.h>
#include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h>

#define _NTIFS_
#include <clusnet.h>
#include "cxp.h"
#include "cnpdef.h"
#include "memlog.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\kdcn\kdcn.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kdcn.c

Abstract:

    Clustner Xport KD extension - based on Vert's skeleton

Author:

    John Vert (jvert) 6-Aug-1992

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// globals
//

EXT_API_VERSION        ApiVersion = { 5, 0, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;

CHAR igrepLastPattern[256];
DWORD igrepSearchStartAddress;
DWORD igrepLastPc;

PCHAR EventTypes[] = {
    "",                 // used if the number is out of range
    "Node Up",
    "Node Down",
    "Poison Packet Received",
    "Halt",
    "Net IF Up",
    "Net IF Unreachable",
    "Net IF Failed",
    "(not used)",
    "Add Address",
    "Delete Address"
};

PCHAR NetObjState[] = {
    "Offline",
    "OfflinePending",
    "Partitioned",
    "OnlinePending",
    "Online"
};

PCHAR NodeObjCommState[] = {
    "Offline",
    "OfflinePending",
    "Unreachable",
    "OnlinePending",
    "Online"
};

PCHAR NodeObjMemberState[] = {
    "Alive",
    "Joining",
    "Dead",
    "Not Configured"
};

PCHAR InterfaceState[] = {
    "Offline",
    "OfflinePending",
    "Unreachable",
    "OnlinePending",
    "Online"
};

PCHAR CcmpMessageTypes[] = {
    "Invalid",
    "Heartbeat",
    "Poison",
    "Membership"
};

#define TrueOrFalse( _x )  ( _x ? "True" : "False" )

/* forwards */

VOID
DumpEventData(
    PCLUSNET_EVENT_ENTRY EventAddress,
    PCLUSNET_EVENT_ENTRY EventEntry
    );

VOID
DumpInterfaceObj(
    PCNP_INTERFACE TargetIfObj,
    PCNP_INTERFACE LocalIfObj
    );

BOOL
ReadNodeTable(
    PCNP_NODE **LocalNodeTable,
    CL_NODE_ID *MaxNodeId,
    CL_NODE_ID *MinNodeId
    );

VOID
DumpNodeObjFlags(
    ULONG Flags
    );

VOID
DumpNetObjFlags(
    ULONG Flag
    );

BOOL
ReadTargetMemory(
    PVOID TargetAddress,
    PVOID LocalBuffer,
    ULONG BytesToRead
    );

__inline PCHAR
ListInUse(
    PLIST_ENTRY ListHead,
    PLIST_ENTRY ListToCheck
    );

__inline PCHAR
TrueFalse(
    BOOLEAN Value
    );

VOID
DprintUnicodeString(
    PUNICODE_STRING String,
    DWORD_PTR       AddrString,
    PCHAR           Symbol       OPTIONAL,
    DWORD_PTR       Displacement OPTIONAL
    );

#if 0
VOID
DumpRGPCounters(
    rgp_counter_t *counters
    );

VOID
DumpClusterMask(
    PCHAR Title,
    cluster_t *
    );

VOID
DumpRGPOSSpecific(
    OS_specific_rgp_control_t *Target_rgpos,
    OS_specific_rgp_control_t *Local_rgpos
    );
#endif

/* end forwards */

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf("%s Extension dll for Build %d debugging %s clusnet for Build %d\n",
            DebuggerType,
            VER_PRODUCTBUILD,
            SavedMajorVersion == 0x0c ? "Checked" : "Free",
            SavedMinorVersion
            );
}

VOID
CheckVersion(
    VOID
    )
{
    PVOID   cnDebugAddr;

    cnDebugAddr = (PVOID)GetExpression( "clusnet!cndebug" );

#if DBG
    if ( cnDebugAddr == NULL ) {
        dprintf("\r\nYou MUST use the checked built KDCN with the checked built driver!!!\n\n");
    }

    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ( cnDebugAddr != NULL ) {
        dprintf("\r\nYou MUST use the free built KDCN with the free built driver!!!\n\n");
    }
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

DECLARE_API( ustr )

/*++

Routine Description:

    This function is called as a KD extension to format and dump
    counted unicode string.

Arguments:

    see wdbgexts.h

Return Value:

    None.

--*/

{
    UNICODE_STRING UnicodeString;
    DWORD_PTR dwAddrString;
    CHAR Symbol[64];
    DWORD_PTR Displacement;
    BOOL b;

    //
    // Evaluate the argument string to get the address of
    // the string to dump.
    //

    dwAddrString = GetExpression(args);
    if ( !dwAddrString ) {
        return;
    }

    //
    // Get the symbolic name of the string
    //

    GetSymbol((LPVOID)dwAddrString,Symbol,&Displacement);

    //
    // Read the string from the debuggees address space into our
    // own.

    b = ReadMemory(dwAddrString, &UnicodeString, sizeof(UnicodeString), NULL);

    if ( !b ) {
        return;
    }

    DprintUnicodeString(&UnicodeString, dwAddrString, Symbol, Displacement);

} // ustr

DECLARE_API( netobj )
/*
 *   dump the specified clusnet network object structure or all if no
 *   arg is specified
 */
{
    PCNP_NETWORK TargetNetObj;
    CNP_NETWORK LocalNetObj;
    PCNP_NETWORK LastNetObj;
    LIST_ENTRY LocalListHead;
    PLIST_ENTRY TargetListHead;
    BOOLEAN DumpAllNetObjs = FALSE;

    if ( *args == '\0' ) {

        //
        // run down the network object list, dumping the contents of each one
        //
        TargetListHead = (PLIST_ENTRY)GetExpression( "clusnet!cnpnetworklist" );
        if ( !TargetListHead ) {
            dprintf("Can't convert clusnet!cnpnetworklist symbol\n");
            return;
        }

        //
        // read network object listhead out of target's memory
        //
        if ( !ReadTargetMemory( TargetListHead, &LocalListHead, sizeof(LIST_ENTRY))) {

            dprintf("Can't get CnpNetworkList data\n");
            return;
        }

        TargetNetObj = (PCNP_NETWORK)LocalListHead.Flink;
        LastNetObj = (PCNP_NETWORK)TargetListHead;
        DumpAllNetObjs = TRUE;

    } else {

        TargetNetObj =  (PCNP_NETWORK)GetExpression( args );
        if ( !TargetNetObj ) {
            dprintf("bad string conversion (%s) \n", args );
            return;
        }

        LastNetObj = 0;
    }

    while ( TargetNetObj != LastNetObj ) {

        if (CheckControlC()) {
            return;
        }

        //
        // read network object struct out of target's memory
        //
        TargetNetObj = CONTAINING_RECORD( TargetNetObj, CNP_NETWORK, Linkage );
        if ( !ReadTargetMemory( TargetNetObj, &LocalNetObj, sizeof( CNP_NETWORK ))) {
            dprintf("Problem reading net obj at %p\n", TargetNetObj );
            return;
        }

#if DBG
        if ( LocalNetObj.Signature != CNP_NETWORK_SIG ) {
            dprintf( "CNP_NETWORK @ %p has the wrong signature\n", TargetNetObj );
        }
#endif

        dprintf( "\nNetObj @ %p\n\n", TargetNetObj );
        dprintf( "    Next NetObj @ %p\n", LocalNetObj.Linkage.Flink );

        dprintf( "    ID = %d\n", LocalNetObj.Id );
        dprintf( "    Lock @ %p\n", &TargetNetObj->Lock );
        dprintf( "    Irql = %d\n", LocalNetObj.Irql );
        dprintf( "    RefCount = %d\n", LocalNetObj.RefCount );
        dprintf( "    Active RefCount = %d\n", LocalNetObj.ActiveRefCount );
        dprintf( "    State = %s\n", NetObjState [ LocalNetObj.State ]);
        DumpNetObjFlags( LocalNetObj.Flags );
        dprintf( "    Priority = %d\n", LocalNetObj.Priority );
        dprintf( "    DatagramHandle @ %p\n", LocalNetObj.DatagramHandle );
        dprintf( "    Datagram File Obj @ %p\n", LocalNetObj.DatagramFileObject );
        dprintf( "    Datagram Device Obj @ %p\n", LocalNetObj.DatagramDeviceObject );
        dprintf( "    TDI provider info @ %p\n", &TargetNetObj->ProviderInfo );
        dprintf( "    Current mcast group @ %p\n", LocalNetObj.CurrentMcastGroup );
        dprintf( "    Previous mcast group @ %p\n", LocalNetObj.PreviousMcastGroup );
        dprintf( "    Multicast reachable node set = %lx\n", LocalNetObj.McastReachableNodes);
        dprintf( "    Multicast reachable node count = %d\n", LocalNetObj.McastReachableCount);
        dprintf( "    Pending Delete IRP @ %p\n", LocalNetObj.PendingDeleteIrp );
        dprintf( "    Pending Offline IRP @ %p\n", LocalNetObj.PendingOfflineIrp );
        dprintf( "    Work Q Item @ %p\n", &TargetNetObj->ExWorkItem );

        if ( !DumpAllNetObjs ) {
            break;
        } else {
            TargetNetObj = (PCNP_NETWORK)LocalNetObj.Linkage.Flink;
        }
    }
} // netobj

VOID
DumpNetObjFlags(
    ULONG Flags
    )
{
    dprintf("    Flags = %08X (", Flags );
    if ( Flags & CNP_NET_FLAG_DELETING )
        dprintf(" Deleting" );
    if ( Flags & CNP_NET_FLAG_PARTITIONED )
        dprintf(" Partitioned" );
    if ( Flags & CNP_NET_FLAG_RESTRICTED )
        dprintf(" Restricted" );
    if ( Flags & CNP_NET_FLAG_LOCALDISCONN ) {
        dprintf(" Local-Disconnect" );
    }
    if ( Flags & CNP_NET_FLAG_MULTICAST ) {
        dprintf(" Multicast-Enabled" );
    }
    dprintf(")\n");
}

DECLARE_API( nodeobj )
/*
 *   if no arg, run down the node table, dumping each clusnet node object
 *   structure. otherwise, dump the indicated node obj
 */
{
    PCNP_NODE TargetNodeObj;
    CNP_NODE LocalNodeObj;
    PCNP_NODE *LocalNodeTable = NULL;
    CL_NODE_ID MaxNodeId, MinNodeId;
    ULONG StartNode, EndNode, Node;

    //
    // read in the node table
    //
    if ( !ReadNodeTable( &LocalNodeTable, &MaxNodeId, &MinNodeId )) {
        if ( LocalNodeTable )
            free( LocalNodeTable );
        return;
    }
    
    if ( *args == '\0' ) {

        StartNode = MinNodeId;
        EndNode = MaxNodeId;
    } else {

        StartNode = EndNode = (ULONG)GetExpression( args );

        if ( StartNode > MaxNodeId ) {
            dprintf("Node ID out of Range: 0 to %d\n", MaxNodeId );

            if ( LocalNodeTable )
                free( LocalNodeTable );
            return;
        }
    }

    dprintf("Min, Max Node ID = ( %u, %d )\n", MinNodeId, MaxNodeId );

    for ( Node = StartNode; Node <= EndNode; ++Node ) {

        if (CheckControlC()) {
            break;
        }

        //
        // read node object struct out of target's memory
        //
        TargetNodeObj = *(LocalNodeTable + Node);
        if ( TargetNodeObj == NULL ) {

            continue;
        } else if ( !ReadTargetMemory( TargetNodeObj, &LocalNodeObj, sizeof( CNP_NODE ))) {

            dprintf("Problem reading node obj at %p (Node %d)\n", TargetNodeObj, Node );
            break;
        }

#if DBG
        if ( LocalNodeObj.Signature != CNP_NODE_SIG ) {
            dprintf( "CNP_NODE @ %p has the wrong signature\n", TargetNodeObj );
        }
#endif

        dprintf( "\nNodeObj @ %p\n\n", TargetNodeObj );
        dprintf( "    Linkage.Flink @ %p\n", LocalNodeObj.Linkage.Flink );

        dprintf( "    ID = %d\n", LocalNodeObj.Id );
        dprintf( "    Lock @ %p\n", &TargetNodeObj->Lock );
        dprintf( "    Irql = %d\n", LocalNodeObj.Irql );
        dprintf( "    RefCount = %d\n", LocalNodeObj.RefCount );
        dprintf( "    Comm State = %s\n", NodeObjCommState [ LocalNodeObj.CommState ]);
        dprintf( "    MMState = %s\n", NodeObjMemberState [ LocalNodeObj.MMState ]);
        DumpNodeObjFlags( LocalNodeObj.Flags );
        dprintf( "    Interface List @ %p", &TargetNodeObj->InterfaceList );
        if ( &TargetNodeObj->InterfaceList == LocalNodeObj.InterfaceList.Flink ) {
            dprintf( " (empty)" );
        }
        dprintf( "\n" );

        dprintf( "    Current Interface @ %p\n", LocalNodeObj.CurrentInterface );
        dprintf( "    Pending Delete IRP @ %p\n", LocalNodeObj.PendingDeleteIrp );

        dprintf( "    HBWasMissed = %s\n", TrueOrFalse( LocalNodeObj.HBWasMissed ));
        dprintf( "    Node Down Issued = %s\n", TrueOrFalse( LocalNodeObj.NodeDownIssued ));
        dprintf( "    MissedHBs = %u\n", LocalNodeObj.MissedHBs );
    }

    if ( LocalNodeTable ) {
        free( LocalNodeTable );
    }
} // nodeobj

VOID
DumpNodeObjFlags(
    ULONG Flags
    )
{
    dprintf("    Flags = %08X (", Flags );
    if ( Flags & CNP_NODE_FLAG_DELETING )
        dprintf(" Deleting" );
    if ( Flags & CNP_NODE_FLAG_UNREACHABLE )
        dprintf(" Unreachable" );
    if ( Flags & CNP_NODE_FLAG_LOCAL )
        dprintf(" Local" );
    dprintf(")\n");
}

DECLARE_API( nodeifs )
/*
 *   dump the interface list for the indicated node obj
 */
{
    PCNP_NODE TargetNodeObj;
    CNP_NODE LocalNodeObj;
    PCNP_NODE *LocalNodeTable = NULL;
    PCNP_INTERFACE NextTargetIfObj;
    CNP_INTERFACE LocalIfObj;
    CL_NODE_ID MaxNodeId, MinNodeId;
    ULONG Node;

    if ( *args == '\0' ) {
        dprintf("Node ID must be specified\n");
        return;
    }

    if ( !ReadNodeTable( &LocalNodeTable, &MaxNodeId, &MinNodeId )) {

        if ( LocalNodeTable )
            free( LocalNodeTable );
        return;
    }

    Node = (ULONG)GetExpression( args );

    if ( Node > MaxNodeId || Node < MinNodeId ) {
        dprintf("Node ID is out of range: %u to %u\n", MinNodeId, MaxNodeId );

        if ( LocalNodeTable )
            free( LocalNodeTable );
        return;
    }

    //
    // read node object struct out of target's memory
    //

    TargetNodeObj = *(LocalNodeTable + Node);
    if ( !ReadTargetMemory( TargetNodeObj, &LocalNodeObj, sizeof( CNP_NODE ))) {
        dprintf("Problem reading node obj at %p (Node %d)\n", TargetNodeObj, Node );

        if ( LocalNodeTable )
            free( LocalNodeTable );
        return;

    }

#if DBG
    if ( LocalNodeObj.Signature != CNP_NODE_SIG ) {
        dprintf( "CNP_NODE @ %p has the wrong signature\n", TargetNodeObj );
    }
#endif

    dprintf( "\nNodeObj @ %p Interface List @ %p", TargetNodeObj, &TargetNodeObj->InterfaceList );
    if ( &TargetNodeObj->InterfaceList == LocalNodeObj.InterfaceList.Flink ) {
        dprintf( " (empty)" );
    }
    dprintf( "\n\n" );

    NextTargetIfObj = (PCNP_INTERFACE)LocalNodeObj.InterfaceList.Flink;

    while ( &TargetNodeObj->InterfaceList != (PLIST_ENTRY)NextTargetIfObj ) {

        if (CheckControlC()) {
            break;
        }

        NextTargetIfObj = CONTAINING_RECORD( NextTargetIfObj, CNP_INTERFACE, NodeLinkage );
        if ( !ReadTargetMemory( 
                  NextTargetIfObj, 
                  &LocalIfObj, 
                  FIELD_OFFSET( CNP_INTERFACE, TdiAddress ) + sizeof(TA_IP_ADDRESS)
                  )
             ) {
            break;
        }

        DumpInterfaceObj( NextTargetIfObj, &LocalIfObj );

        NextTargetIfObj = (PCNP_INTERFACE)LocalIfObj.NodeLinkage.Flink;
    }

    if ( LocalNodeTable ) {
        free( LocalNodeTable );
    }
} // nodeifs

DECLARE_API( currif )
/*
 *   for the specified node, dump the current interface obj
 */
{
    PCNP_NODE TargetNodeObj;
    CNP_NODE LocalNodeObj;
    PCNP_NODE *LocalNodeTable = NULL;
    CL_NODE_ID MaxNodeId, MinNodeId;
    CNP_INTERFACE LocalIfObj;
    ULONG Node;
    
    if ( *args == '\0' ) {
        dprintf("Node ID must be specified\n");
        return;
    }

    //
    // read in the node table
    //
    if ( !ReadNodeTable( &LocalNodeTable, &MaxNodeId, &MinNodeId )) {

        if ( LocalNodeTable )
            free( LocalNodeTable );
        return;
    }

    Node = (ULONG)GetExpression( args );

    if ( Node > MaxNodeId || Node < MinNodeId ) {
        dprintf("Node ID is out of range: %u to %u\n", MinNodeId, MaxNodeId );

        if ( LocalNodeTable )
            free( LocalNodeTable );
        return;
    }

    //
    // read node object struct out of target's memory
    //
    TargetNodeObj = *(LocalNodeTable + Node);

    if ( !ReadTargetMemory( TargetNodeObj, &LocalNodeObj, sizeof( CNP_NODE ))) {

        dprintf("Problem reading node obj at %p (Node %d)\n", TargetNodeObj, Node );
        if ( LocalNodeTable )
            free( LocalNodeTable );
        return;
    }

#if DBG
    if ( LocalNodeObj.Signature != CNP_NODE_SIG ) {
        dprintf( "CNP_NODE @ %p has the wrong signature\n", TargetNodeObj );
    }
#endif

    dprintf( "\nNodeObj @ %p Current Interface @ %p\n\n", TargetNodeObj, LocalNodeObj.CurrentInterface );

    if ( LocalNodeObj.CurrentInterface ) {

        if ( ReadTargetMemory( LocalNodeObj.CurrentInterface, &LocalIfObj, sizeof( CNP_INTERFACE ))) {
            DumpInterfaceObj( LocalNodeObj.CurrentInterface, &LocalIfObj );
        }
    }
                          
    if ( LocalNodeTable ) {
        free( LocalNodeTable );
    }
} // currif

VOID
DumpInterfaceObj(
    PCNP_INTERFACE TargetIfObj,
    PCNP_INTERFACE IfObj
    )
{
    LONG i, j;
    TA_ADDRESS *TA;
    TDI_ADDRESS_IP UNALIGNED *TAIp;

#if DBG
    if ( IfObj->Signature != CNP_INTERFACE_SIG ) {
        dprintf( "CNP_INTERFACE @ %p has the wrong signature\n", TargetIfObj );
    }
#endif

    dprintf("Interface Obj @ %p\n", TargetIfObj );
    dprintf("    Node Obj @ %p\n", IfObj->Node );
    dprintf("    Net Obj @ %p\n", IfObj->Network );
    dprintf("    State = %s\n", InterfaceState[ IfObj->State ]);
    dprintf("    Priority = %d\n", IfObj->Priority );
    dprintf("    Flags = %08X\n", IfObj->Flags );
    dprintf("    MissedHBs = %u\n", IfObj->MissedHBs );
    dprintf("    Seq to send = %u\n", IfObj->SequenceToSend );
    dprintf("    Last Seq Recv'd = %u\n", IfObj->LastSequenceReceived );
    dprintf("    Multicast discovery count = %u\n", IfObj->McastDiscoverCount );
    dprintf("    AdapterWMIProviderId = %08X\n", IfObj->AdapterWMIProviderId );
    
    dprintf("    TDI Addr Len = %d\n", IfObj->TdiAddressLength );
    dprintf("    TDI Addr Count = %d\n", IfObj->TdiAddress.TAAddressCount );

    TA = IfObj->TdiAddress.Address;
    for (i=0; i < IfObj->TdiAddress.TAAddressCount; ++i ) {
        dprintf("    [%d] Addr Length = %d\n", i, TA->AddressLength );
        dprintf("    [%d] Addr Type = %d", i, TA->AddressType );

        switch ( TA->AddressType ) {
        case TDI_ADDRESS_TYPE_IP:
            TAIp = (TDI_ADDRESS_IP UNALIGNED *)TA->Address;
//            dprintf("%08X %08X\n", TAIp->in_addr,ntohl(TAIp->in_addr));
            dprintf(" (IP)\n    [%d] Port: %d Addr: %d.%d.%d.%d\n",
                    i, ntohs(TAIp->sin_port), (ntohl(TAIp->in_addr) >> 24 ) & 0xFF,
                    (ntohl(TAIp->in_addr) >> 16 ) & 0xFF,
                    (ntohl(TAIp->in_addr) >> 8 ) & 0xFF,
                    ntohl(TAIp->in_addr) & 0xFF);
            break;

        default:
            dprintf("\n    [%d] Addr:", i );
            for( j = 0; j < TA->AddressLength; ++j )
                dprintf(" %02X", TA->Address[j]);
            dprintf("\n");
        }
        TA = (TA_ADDRESS *)((CHAR UNALIGNED *)TA + TA->AddressLength);
    }
}

DECLARE_API( memlog )
/*
 *   dump the heart beat log. can optionally specify starting entry number
 */
{
    PMEMLOG_ENTRY TargetMemLog;
    PMEMLOG_ENTRY TargetLogEntry;
    MEMLOG_ENTRY LogEntry;
    PULONG TargetLogEntries;
    ULONG LogEntries;
    PULONG TargetNextLogEntry;
    ULONG NextLogEntry;
    LONG NumEntries;
    ULONG Pass;
    ULONG LineCount = 0;
    ULONG StartingEntry;
    LARGE_INTEGER LastSysTime;
    DOUBLE LastTimeDelta;
    DOUBLE FirstTimeDelta;
    BOOLEAN PrintTime = TRUE;
    LARGE_INTEGER FirstEntryTime;

    //
    // get address of MemLog and read its contents to get the real start
    // of the log
    //

    TargetMemLog = (PMEMLOG_ENTRY)GetExpression( "clusnet!memlog" );
    if ( !TargetMemLog ) {

        dprintf( "Can't find symbol clusnet!memlog\n" );
        return;
    }

    if ( !ReadTargetMemory( TargetMemLog, &TargetMemLog, sizeof( PMEMLOG_ENTRY ))) {

        return;
    }

    //
    // repeat this process, getting the size of the log and the next entry index
    //

    TargetLogEntries = (PULONG)GetExpression( "clusnet!memlogentries" );
    if ( !TargetLogEntries ) {

        dprintf( "Can't find symbol clusnet!memlogentries\n" );
        return;
    }

    if ( !ReadTargetMemory( TargetLogEntries, &LogEntries, sizeof( ULONG ))) {

        return;
    }

    TargetNextLogEntry = (PULONG)GetExpression( "clusnet!memlognextlogentry" );
    if ( !TargetNextLogEntry ) {

        dprintf( "Can't find symbol clusnet!memlognextlogentry\n" );
        return;
    }

    if ( !ReadTargetMemory( TargetNextLogEntry, &NextLogEntry, sizeof( ULONG ))) {

        return;
    }

    //
    // get optional starting entry number
    //

    if ( *args != '\0' ) {

        StartingEntry = (ULONG)GetExpression( args );
        if ( StartingEntry >= LogEntries ) {

            dprintf("Starting entry out of range (0 to %d)\n", LogEntries - 1);
            return;
        }

        if ( StartingEntry <= NextLogEntry ) {

            //
            // adjust starting number if on significant boundry
            //

            if ( StartingEntry == NextLogEntry ) {
                if ( NextLogEntry == 0 )
                    StartingEntry = LogEntries - 1;
                else
                    StartingEntry = NextLogEntry - 1;
            }

            Pass = 0;
            NumEntries = StartingEntry + 1;
        } else {

            Pass = 1;
            NumEntries = StartingEntry - NextLogEntry;
        }

        TargetLogEntry = TargetMemLog + StartingEntry;
    } else {

        Pass = 0;

        if ( NextLogEntry == 0 )
            NumEntries = LogEntries - 1;
        else
            NumEntries = NextLogEntry - 1;

        TargetLogEntry = TargetMemLog + NumEntries;
    }

    //
    // read in the most current entry to get its time. We calc the first time
    // delta from this value
    //

    if ( !ReadTargetMemory(TargetMemLog + NextLogEntry - 1, &LogEntry, sizeof( MEMLOG_ENTRY ))) {

        dprintf("can't read current log entry (%p) from memory\n\n", TargetLogEntry);
        return;
    }

    LastSysTime.QuadPart = LogEntry.SysTime.QuadPart;
    FirstEntryTime.QuadPart = LogEntry.SysTime.QuadPart;

    dprintf("MemLog @ %p, Log Entries = %d, Next Entry = %d (%p)\n\n",
            TargetMemLog, LogEntries, NextLogEntry, TargetMemLog + NextLogEntry);

    //
    // depending on our starting entry, look through the log twice.
    // next entry might have wrapped so first time we
    // dump all the entries down to the base. Next time we start at the end and 
    // dump out the remaining entries

    dprintf("First     Last\n");
    dprintf("Entry     Entry   Line  Log\n");
    dprintf("Delta     Delta   No    Type  Desc\n");

    while ( Pass < 2 ) {

        while ( NumEntries-- ) {

            if (CheckControlC()) {
                return;
            }

            if ( !ReadTargetMemory(TargetLogEntry, &LogEntry, sizeof( MEMLOG_ENTRY ))) {

                dprintf("can't read log entry (%p) from memory\n\n", TargetLogEntry);
                return;
            }

            if ( LogEntry.Type == 0 )
                break;

            LastTimeDelta = ( LastSysTime.QuadPart - LogEntry.SysTime.QuadPart ) / 10000000.0;
            FirstTimeDelta = ( FirstEntryTime.QuadPart - LogEntry.SysTime.QuadPart ) / 10000000.0;

            if ( PrintTime ) {
                dprintf("%8.3f %6.3f: (%4hu, 0x%02X) ", FirstTimeDelta, LastTimeDelta,
                        LogEntry.LineNo, LogEntry.Type );
            }

            PrintTime = TRUE;

            switch ( LogEntry.Type ) {
            case MemLogInitLog:
                dprintf("Memory Log Init'ed\n");
                break;

            case MemLogInitHB:
                dprintf("Heartbeats Init'ed\n");
                break;

            case MemLogHBStarted:
                dprintf("START: Period = %u ms\n", LogEntry.Arg1);
                break;

            case MemLogHBStopped:
                dprintf("STOPPED\n");
                break;

            case MemLogHBDpcRunning:
                dprintf("DPC not removed. HeartBeatDpcRunning = %s\n",
                        TrueOrFalse( LogEntry.Arg1 ));
                break;

            case MemLogWaitForDpcFinish:
                dprintf("DPC: Waiting to finish running\n");
                break;

            case MemLogMissedIfHB:
                dprintf("HB MISSED on interface. Node = %u net = %u",
                        LogEntry.Arg1, LogEntry.Arg2);
                PrintTime = FALSE;
                break;

            case MemLogMissedIfHB1:
                dprintf(" (IF @ %p) MissedHBCount = %d\n", LogEntry.Arg1, LogEntry.Arg2);
                break;

            case MemLogFailingIf:
                dprintf("IF FAILED. Node = %d, net = %d",
                        LogEntry.Arg1, LogEntry.Arg2);
                PrintTime = FALSE;
                break;

            case MemLogFailingIf1:
                dprintf(" (IF @ %p) IF State = %s\n", LogEntry.Arg1, InterfaceState[LogEntry.Arg2]);
                break;

            case MemLogSendHBWalkNode:
                dprintf("Walking node %d to send HB. MMState = %s\n",
                        LogEntry.Arg1, NodeObjMemberState[LogEntry.Arg2]);
                break;

            case MemLogCheckHBWalkNode:
                dprintf("Walking node %d to check for HB. MMState = %s.\n",
                        LogEntry.Arg1, NodeObjMemberState[LogEntry.Arg2]);
                break;

            case MemLogCheckHBNodeReachable:
                dprintf("Node %d is currently %sreachable\n", LogEntry.Arg1,
                        (LogEntry.Arg2 ? "" : "NOT "));
                break;

            case MemLogCheckHBMissedHB:
                dprintf("NODE MISSED HB on all IFs. MissedHBCount = %u MMState = %s\n",
                        LogEntry.Arg1, NodeObjMemberState[LogEntry.Arg2]);
                break;

            case MemLogSendingHB:
                dprintf("Sending HB to Node %d on net %d\n", LogEntry.Arg1, LogEntry.Arg2);
                break;

            case MemLogNodeDown:
                dprintf("NODE DOWN EVENT for node %d\n", LogEntry.Arg1);
                break;

            case MemLogSetDpcEvent:
                dprintf("DPC: setting finished event\n");
                break;

            case MemLogNoNetID:
                dprintf("BAD NET POINTER: Recv'd packet from node %d (%p)\n",
                        LogEntry.Arg1, LogEntry.Arg2);
                break;

            case MemLogOnlineIf:
                dprintf("NODE %d ONLINE. IF State = %s\n", LogEntry.Arg1,
                        InterfaceState[LogEntry.Arg2]);
                break;

            case MemLogSeqAckMismatch:
                dprintf("Recv'ed ack off with seq on IF %p. IF State = %s\n",
                        LogEntry.Arg1, InterfaceState[LogEntry.Arg2]);
                break;

            case MemLogNodeUp:
                dprintf("NODE UP EVENT for node %d\n", LogEntry.Arg1);
                break;

            case MemLogReceivedPacket:
                dprintf("Recv'ed HB from Node %d, net %d", LogEntry.Arg1, LogEntry.Arg2);
                PrintTime = FALSE;
                break;

            case MemLogReceivedPacket1:
                dprintf(" (S: %u A: %u)\n", LogEntry.Arg1, LogEntry.Arg2);
                break;

            case MemLogDpcTimeSkew:
                dprintf("HB DPC fired %8.3f ms late\n", (double)(LogEntry.Arg1/10000.0));
                break;

            case MemLogHBPacketSend:
                dprintf("%s Packet handed to CNP", CcmpMessageTypes[ LogEntry.Arg1 ]);
                if ( LogEntry.Arg1 == CcmpHeartbeatMsgType )
                    dprintf(" (S:%u)", LogEntry.Arg2);
                else if ( LogEntry.Arg1 == CcmpPoisonMsgType )
                    dprintf(" by %s", LogEntry.Arg2 == 1 ? "Heartbeat DPC" : "clussvc" );
                dprintf("\n");
                break;

            case MemLogHBPacketSendComplete:
                dprintf("%s Packet Send completed", CcmpMessageTypes[ LogEntry.Arg1 ]);
                if ( LogEntry.Arg1 == CcmpHeartbeatMsgType )
                    dprintf(" (S:%u)", LogEntry.Arg2);
                else if ( LogEntry.Arg1 == CcmpPoisonMsgType )
                    dprintf(" by %s", LogEntry.Arg2 == 1 ? "Heartbeat DPC" : "clussvc" );
                dprintf("\n");
                break;

            case MemLogPoisonPktReceived:
                dprintf("Poison Packet received from node %u\n", LogEntry.Arg1);
                break;

            case MemLogOuterscreen:
                dprintf("Outerscreen changed to %04X\n",
                        ((LogEntry.Arg1 & 0xFF ) << 8) | ((LogEntry.Arg1 >> 8 ) & 0xFF ));
                break;

            case MemLogNodeDownIssued:
                dprintf("Node %u NodeDownIssued set to %s\n",
                        LogEntry.Arg1, TrueOrFalse( LogEntry.Arg2 ));
                break;

            case MemLogRegroupFinished:
                dprintf("REGROUP FINISHED. New Epoch = %u\n", LogEntry.Arg1 );
                break;

            case MemLogInconsistentStates:
                dprintf("INCONSISTENT STATES. STARTING NEW REGROUP. Node = %u, MMState = %s\n",
                        LogEntry.Arg1, NodeObjMemberState[ LogEntry.Arg2 ]);
                break;

            case MemLogOutOfSequence:
                dprintf("Out Of Sequence Packet from Node = %u, SeqNo = %u\n",
                        LogEntry.Arg1, LogEntry.Arg2 );
                break;

            case MemLogInvalidSignature:
                dprintf("Packet with bad Signature from Node = %u, type = %s\n",
                        LogEntry.Arg1, CcmpMessageTypes[ LogEntry.Arg2 ]);
                break;

            case MemLogSignatureSize:
                dprintf("Invalid Signature buffer size from Node = %u, size = %u\n",
                        LogEntry.Arg1, LogEntry.Arg2 );
                break;

            case MemLogNoSecurityContext:
                dprintf("No context to verify signature for Node = %u\n",
                        LogEntry.Arg1 );
                break;

            case MemLogPacketSendFailed:
                dprintf("Packet not sent to Node %d, status = %08X\n",
                        LogEntry.Arg1, LogEntry.Arg2 );
                break;

            default:
                dprintf(" unknown event, Arg1 = %p Arg2 = %p\n",
                        LogEntry.Arg1, LogEntry.Arg2);
            }

            LastSysTime.QuadPart = LogEntry.SysTime.QuadPart;

            --TargetLogEntry;
        }

        if ( ++Pass < 2 ) {

            NumEntries = LogEntries - NextLogEntry - 1;
            TargetLogEntry = TargetMemLog + LogEntries - 1;
        }
    }
} // memlog

DECLARE_API( mlfind )
/*
 *   list the entry nums of the specified events in the memory log
 */
{
    PMEMLOG_ENTRY TargetMemLog;
    PMEMLOG_ENTRY TargetLogEntry;
    MEMLOG_ENTRY LogEntry;
    PULONG TargetLogEntries;
    ULONG LogEntries;
    PULONG TargetNextLogEntry;
    ULONG NextLogEntry;
    LONG NumEntries;
    ULONG i;
    DOUBLE FirstTimeDelta;
    LARGE_INTEGER FirstEntryTime;
    MEMLOG_TYPES LogType;
    ULONG EntryDelta;

    if ( *args == '\0' ) {

        dprintf("Event type must be specified\n");
        return;
    }

    LogType = (MEMLOG_TYPES)GetExpression( args );

    //
    // get address of MemLog and read its contents to get the real start
    // of the log
    //

    TargetMemLog = (PMEMLOG_ENTRY)GetExpression( "clusnet!memlog" );
    if ( !TargetMemLog ) {

        dprintf( "Can't find symbol clusnet!memlog\n" );
        return;
    }

    if ( !ReadTargetMemory( TargetMemLog, &TargetMemLog, sizeof( PMEMLOG_ENTRY ))) {

        return;
    }

    //
    // repeat this process, getting the size of the log and the next entry index
    //

    TargetLogEntries = (PULONG)GetExpression( "clusnet!memlogentries" );
    if ( !TargetLogEntries ) {

        dprintf( "Can't find symbol clusnet!memlogentries\n" );
        return;
    }

    if ( !ReadTargetMemory( TargetLogEntries, &LogEntries, sizeof( ULONG ))) {

        return;
    }

    TargetNextLogEntry = (PULONG)GetExpression( "clusnet!memlognextlogentry" );
    if ( !TargetNextLogEntry ) {

        dprintf( "Can't find symbol clusnet!memlognextlogentry\n" );
        return;
    }

    if ( !ReadTargetMemory( TargetNextLogEntry, &NextLogEntry, sizeof( ULONG ))) {

        return;
    }

    dprintf("MemLog @ %p, Log Entries = %d, Next Entry = %d (%p)\n",
            TargetMemLog, LogEntries, NextLogEntry, TargetMemLog + NextLogEntry);

    FirstEntryTime.QuadPart = 0;

    //
    // look through the log twice. next entry might have wrapped so first time we
    // dump all the entries down to the base. Next time we start at the end and 
    // dump out the remaining entries

    for ( i = 0; i < 2; ++i ) {

        if ( i == 0 ) {

            NumEntries =  NextLogEntry;
            TargetLogEntry = TargetMemLog + NumEntries;
        } else {

            NumEntries = LogEntries - NextLogEntry - 1;
            TargetLogEntry = TargetMemLog + LogEntries;
        }

        while ( --TargetLogEntry, NumEntries-- ) {

            if (CheckControlC()) {
                return;
            }

            if ( !ReadTargetMemory(TargetLogEntry, &LogEntry, sizeof( MEMLOG_ENTRY ))) {

                dprintf("can't read log entry (%p) from memory\n\n", TargetLogEntry);
                return;
            }

            if ( LogEntry.Type == 0 )
                break;

            if ( FirstEntryTime.QuadPart == 0 ) {
                FirstEntryTime.QuadPart = LogEntry.SysTime.QuadPart;
            }

            if ( LogEntry.Type != LogType )
                continue;

            FirstTimeDelta = ( FirstEntryTime.QuadPart - LogEntry.SysTime.QuadPart ) / 10000000.0;

            EntryDelta = (DWORD)(TargetLogEntry - TargetMemLog);
            dprintf("%8.3f: (%5hu) Entry at %d (0x%X)\n", FirstTimeDelta, LogEntry.LineNo,
                    EntryDelta, EntryDelta);
        }
    }
} // mlfind

DECLARE_API( events )

//
// run down the event file handle list, dumping interesting info for each one
//

{
    PCN_FSCONTEXT           targetFSContext;
    PCN_FSCONTEXT           lastFSContext;
    CN_FSCONTEXT            localFSContext;
    LIST_ENTRY              localListHead;
    PLIST_ENTRY             targetListHead;
    PCLUSNET_EVENT_ENTRY    nextEvent;
    CLUSNET_EVENT_ENTRY     localEvent;

    //
    // get the event file handle list head 
    //
    targetListHead = (PLIST_ENTRY)GetExpression( "clusnet!eventfilehandles" );
    if ( !targetListHead ) {

        dprintf("Can't convert clusnet!eventfilehandles symbol\n");
        return;
    }

    //
    // read CN FS context object listhead out of target's memory
    //
    if ( !ReadTargetMemory( targetListHead, &localListHead, sizeof(LIST_ENTRY))) {
        dprintf("Can't get EventFileHandles data\n");
        return;
    }

    targetFSContext = (PCN_FSCONTEXT)localListHead.Flink;
    lastFSContext = (PCN_FSCONTEXT)targetListHead;

    if ( targetFSContext == lastFSContext ) {
        dprintf("No file objects in EventFileHandles\n");
        return;
    }

    while ( targetFSContext != lastFSContext ) {

        if (CheckControlC()) {
            return;
        }

        //
        // read FS context struct out of target's memory
        //
        targetFSContext = CONTAINING_RECORD( targetFSContext, CN_FSCONTEXT, Linkage );
        if ( !ReadTargetMemory( targetFSContext, &localFSContext, sizeof( CN_FSCONTEXT ))) {
            dprintf("Problem reading FS context at %p\n", targetFSContext );
            return;
        }

#if DBG
        if ( localFSContext.Signature != CN_CONTROL_CHANNEL_SIG ) {
            dprintf( "CN_FSCONTEXT @ %p has the wrong signature\n", targetFSContext );
        }
#endif

        dprintf( "\nFSContext @ %p\n\n", targetFSContext );
        dprintf( "    Next FSContext @ %p\n", localFSContext.Linkage.Flink );

        dprintf( "    Event Mask %08X\n", localFSContext.EventMask );
        dprintf( "    Event IRP @ %p\n", localFSContext.EventIrp );
        dprintf( "    Event list @ %p %s\n", &targetFSContext->EventList,
                 ListInUse( &targetFSContext->EventList, &localFSContext.EventList ));

        nextEvent = (PCLUSNET_EVENT_ENTRY)localFSContext.EventList.Flink;
        while ( &targetFSContext->EventList != (PLIST_ENTRY)nextEvent ) {

            if (CheckControlC()) {
                break;
            }

            nextEvent = CONTAINING_RECORD( nextEvent, CLUSNET_EVENT_ENTRY, Linkage );
            if ( !ReadTargetMemory( nextEvent, &localEvent, sizeof( CLUSNET_EVENT_ENTRY ))) {
                break;
            }

            DumpEventData( nextEvent, &localEvent );

            nextEvent = (PCLUSNET_EVENT_ENTRY)localEvent.Linkage.Flink;
        }

        targetFSContext = (PCN_FSCONTEXT)localFSContext.Linkage.Flink;
    }
} // events

DWORD
GetEventTypeIndex(
    CLUSNET_EVENT_TYPE EventType
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD index;

    for ( index = 0; index < 10; ++index ) {
        if ( ( 1 << index ) & EventType ) {
            return index + 1;
        }
    }

    return 0;
}

VOID
DumpEventData(
    PCLUSNET_EVENT_ENTRY EventAddress,
    PCLUSNET_EVENT_ENTRY EventEntry
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    dprintf("    Event @ %p\n", EventAddress );
    dprintf("        Epoch  %u\n", EventEntry->EventData.Epoch );
    dprintf("        Type   0x%03X (%s)\n",
            EventEntry->EventData.EventType,
            EventTypes[ GetEventTypeIndex( EventEntry->EventData.EventType )]);
    dprintf("        NodeId %u\n", EventEntry->EventData.NodeId );
    dprintf("        NetId  %u (%08X)\n", EventEntry->EventData.NetworkId,
            EventEntry->EventData.NetworkId);
}

DECLARE_API( fsctxt )
/*
 *   dump the specified clusnet file object context struct
 */
{
    PCN_FSCONTEXT targetFSContext;
    CN_FSCONTEXT localFSContext;

    if ( *args == '\0' ) {
        dprintf("Address must be specified\n");
        return;
    }

    targetFSContext =  (PCN_FSCONTEXT)GetExpression( args );
    if ( !targetFSContext ) {
        dprintf("bad string conversion (%s) \n", args );
        return;
    }

    //
    // read network object struct out of target's memory
    //
    if ( !ReadTargetMemory( targetFSContext, &localFSContext, sizeof( CN_FSCONTEXT ))) {
        dprintf("Problem reading FS Context obj at %p\n", targetFSContext );
        return;
    }

#if DBG
    if ( localFSContext.Signature != CN_CONTROL_CHANNEL_SIG ) {
        dprintf( "CN_FSCONTEXT @ %p has the wrong signature\n", targetFSContext );
    }
#endif

    dprintf( "\nFS Context @ %p\n\n", targetFSContext );
    dprintf( "    Next FS Ctxt on EventFileHandles @ %p\n", localFSContext.Linkage.Flink );

    dprintf( "    File Obj @ %p\n", localFSContext.FileObject );
    dprintf( "    RefCount = %d\n", localFSContext.ReferenceCount );
    dprintf( "    CancelIrps = %s\n", TrueOrFalse( localFSContext.CancelIrps ));
    dprintf( "    ShutdownOnClose = %s\n", TrueOrFalse( localFSContext.ShutdownOnClose ));
    dprintf( "    CleanupEvent @ %p\n", &targetFSContext->CleanupEvent );
    dprintf( "    Event List @ %p %s\n",
             &targetFSContext->EventList,
             ListInUse( &targetFSContext->EventList, &localFSContext.EventList ));
    dprintf( "    EventIrp @ %p\n", localFSContext.EventIrp );
    dprintf( "    EventMask = %08X\n", localFSContext.EventMask );
    dprintf( "    Krn Event Callback @ %p\n", localFSContext.KmodeEventCallback );
} // fsctxt

DECLARE_API( sendreq )
/*
 *   dump the specified CNP send request struct
 */
{
    PCNP_SEND_REQUEST targetCnpSendReq;
    CNP_SEND_REQUEST localCnpSendReq;

    if ( *args == '\0' ) {
        dprintf("Address must be specified\n");
        return;
    }

    targetCnpSendReq =  (PCNP_SEND_REQUEST)GetExpression( args );
    if ( !targetCnpSendReq ) {
        dprintf("bad string conversion (%s) \n", args );
        return;
    }

    //
    // read send request struct out of target's memory
    //
    if ( !ReadTargetMemory( targetCnpSendReq, &localCnpSendReq, sizeof( CNP_SEND_REQUEST ))) {
        dprintf("Problem reading CNP send request at %p\n", targetCnpSendReq );
        return;
    }

    dprintf( "\nCNP Send Request @ %p\n\n", targetCnpSendReq );
    dprintf( "    CnResource @ %p\n", &targetCnpSendReq->CnResource );
    dprintf( "    HeaderMdl @ %p\n", localCnpSendReq.HeaderMdl );
    dprintf( "    CnpHeader @ %p\n", localCnpSendReq.CnpHeader );
    dprintf( "    UpperProtocolIrp @ %p\n", localCnpSendReq.UpperProtocolIrp );
    dprintf( "    UpperProtocolHeader @ %p\n", localCnpSendReq.UpperProtocolHeader );
    dprintf( "    UpperProtocolHeaderLength %d\n", localCnpSendReq.UpperProtocolHeaderLength );
    dprintf( "    UpperProtocolIrpMode %d\n", localCnpSendReq.UpperProtocolIrpMode );
    dprintf( "    UpperProtocolMdl @ %p\n", localCnpSendReq.UpperProtocolMdl );
    dprintf( "    UpperProtocolContext @ %p\n", localCnpSendReq.UpperProtocolContext );
    dprintf( "    CompletionRoutine @ %p\n", localCnpSendReq.CompletionRoutine );
    dprintf( "    Network @ %p\n", localCnpSendReq.Network );
    dprintf( "    DestAddress @ %p\n", localCnpSendReq.TdiSendDatagramInfo.RemoteAddress );
    dprintf( "    Multicast Group @ %p\n", localCnpSendReq.McastGroup );

} // fsctxt

#if 0
// from when regroup was in the kernel
DECLARE_API( rgpdump )
/*
 *   dump the regroup struct
 */
{
    rgp_control_t **TargetRGPAddress;
    rgp_control_t *TargetRGP;
    rgp_control_t LocalRGP;
    OS_specific_rgp_control_t *Local_rgpos;     // points to local memory
    OS_specific_rgp_control_t *Target_rgpos;    // points to target memory
    BOOL success;
    LONG BytesRead;

    //
    // get address of RGP symbol
    //

    TargetRGPAddress = (rgp_control_t **)GetExpression( "Clusnet!rgp" );

    if ( !TargetRGPAddress ) {

        dprintf("Can't convert Clusnet!rgp symbol\n");
        return;
    }

    //
    // read address of RGP block
    //

    if ( !ReadTargetMemory((PVOID)TargetRGPAddress,
                           (PVOID)&TargetRGP,
                           sizeof(rgp_control_t *))) {
        return;
    }

    //
    // read actual RGP block into our local buffer
    //

    if ( !ReadTargetMemory((PVOID)TargetRGP,
                           (PVOID)&LocalRGP,
                           sizeof( rgp_control_t ))) {
        return;
    }

    Target_rgpos = &TargetRGP->OS_specific_control;
    Local_rgpos = &LocalRGP.OS_specific_control;

    dprintf( "RGP @ %p\n\n", TargetRGP );

    dprintf( "info:\n" );
    dprintf( "    Version = %u\n", LocalRGP.rgpinfo.version );
    dprintf( "    Seq number = %u\n", LocalRGP.rgpinfo.seqnum );
    dprintf( "    Clock Period = %hu ms\n", LocalRGP.rgpinfo.a_tick );
    dprintf( "    I Am Alive ticks = %hu\n", LocalRGP.rgpinfo.iamalive_ticks );
    dprintf( "    Check ticks = %hu\n", LocalRGP.rgpinfo.check_ticks );
    dprintf( "    Min stage1 ticks = %hu\n", LocalRGP.rgpinfo.Min_Stage1_ticks );
    DumpClusterMask( "    Cluster mask = ", &LocalRGP.rgpinfo.cluster );

    dprintf( "    My node = %hu\n", LocalRGP.mynode );
    dprintf( "    Tiebreaker node = %hu\n", LocalRGP.tiebreaker );
    dprintf( "    Number of nodes in cluster = %u\n", LocalRGP.num_nodes );
    dprintf( "    Clock tick counter = %hu\n", LocalRGP.clock_ticks );
    dprintf( "    RGP counter = %hu\n", LocalRGP.rgpcounter );
    dprintf( "    Restart counter = %hu\n", LocalRGP.restartcount );
    dprintf( "    Pruning ticks = %hu\n", LocalRGP.pruning_ticks );
    dprintf( "    PFail State = %hu\n", LocalRGP.pfail_state );

    dprintf( "    Cautious Mode = %u\n", LocalRGP.cautiousmode );
    dprintf( "    Send Stage = %u\n", LocalRGP.sendstage );
    dprintf( "    Tie Breaker Selected = %u\n", LocalRGP.tiebreaker_selected );
    dprintf( "    Has Unreachable Nodes = %u\n", LocalRGP.has_unreachable_nodes );

    DumpClusterMask( "    Outer Screen      = ", &LocalRGP.outerscreen );
    DumpClusterMask( "    Inner Screen      = ", &LocalRGP.innerscreen );
    DumpClusterMask( "    Status Targets    = ", &LocalRGP.status_targets );
    DumpClusterMask( "    Poison Targets    = ", &LocalRGP.poison_targets );
    DumpClusterMask( "    Init Nodes        = ", &LocalRGP.initnodes );
    DumpClusterMask( "    End Nodes         = ", &LocalRGP.endnodes );
    DumpClusterMask( "    Unreachable Nodes = ", &LocalRGP.unreachable_nodes );

    DumpRGPOSSpecific( &TargetRGP->OS_specific_control, &LocalRGP.OS_specific_control );
}

DECLARE_API( rgposdump )
/*
 *   dump just the OS specific portion of the regroup struct
 */
{
    rgp_control_t **TargetRGPAddress;
    rgp_control_t *TargetRGP;
    rgp_control_t LocalRGP;
    OS_specific_rgp_control_t *Local_rgpos;     // points to local memory
    OS_specific_rgp_control_t *Target_rgpos;    // points to target memory
    BOOL success;
    LONG BytesRead;

    //
    // get address of RGP symbol
    //

    TargetRGPAddress = (rgp_control_t **)GetExpression( "Clusnet!rgp" );

    if ( !TargetRGPAddress ) {

        dprintf("Can't convert Clusnet!rgp symbol\n");
        return;
    }

    //
    // read address of RGP block
    //

    if ( !ReadTargetMemory((PVOID)TargetRGPAddress,
                           (PVOID)&TargetRGP,
                           sizeof(rgp_control_t *))) {
        return;
    }

    //
    // read actual RGP block into our local buffer
    //

    if ( !ReadTargetMemory((PVOID)TargetRGP,
                           (PVOID)&LocalRGP,
                           sizeof( rgp_control_t ))) {
        return;
    }

    Target_rgpos = &TargetRGP->OS_specific_control;
    Local_rgpos = &LocalRGP.OS_specific_control;

    dprintf( "RGP @ %p\n\n", TargetRGP );

    DumpRGPOSSpecific( &TargetRGP->OS_specific_control, &LocalRGP.OS_specific_control );
}

VOID
DumpRGPOSSpecific(
    OS_specific_rgp_control_t *Target_rgpos,
    OS_specific_rgp_control_t *Local_rgpos
    )
{
    dprintf( "OS specific\n" );

    dprintf( "RGP Counters:\n" );
    DumpRGPCounters( &Local_rgpos->counter );

    DumpClusterMask( "    CPUUPMASK = ", &Local_rgpos->CPUUPMASK );

    dprintf( "    RgpLock @ %p\n", &Target_rgpos->RgpLock );
    dprintf( "    RGPTimer @ %p\n", &Target_rgpos->RGPTimer );
    dprintf( "    PeriodicCheckDPC @ %p\n", &Target_rgpos->PeriodicCheckDPC );
    dprintf( "    TimerDPCFinished @ %p\n", &Target_rgpos->TimerDPCFinished );
    dprintf( "    CallbackLock @ %p\n", &Target_rgpos->CallbackLock );
    dprintf( "    CallbackIRP @ %p\n", &Target_rgpos->CallbackIrp );

    dprintf( "    CallbackEvents @ %p %s\n", &Target_rgpos->CallbackEvents,
                                               ListInUse( &Local_rgpos->CallbackEvents ));

    dprintf( "    SendMsgQLock @ %p\n", &Target_rgpos->SendMsgQLock );
    dprintf( "    SendMsgQDPC @ %p\n", &Target_rgpos->SendMsgQDPC );
    dprintf( "    SendMsgQ @ %p %s\n", &Target_rgpos->SendMsgQ,
                                         ListInUse( &Local_rgpos->SendMsgQ ));
    dprintf( "    MsgShutdown: %s\n", TrueFalse( Local_rgpos->MsgShutdown ));
    dprintf( "    MsgDPCQueued: %s\n", TrueFalse( Local_rgpos->MsgDPCQueued ));
    dprintf( "    MsgDPCFinished @ %p\n", &Target_rgpos->MsgDPCFinished );

    DumpClusterMask( "    NeedsNodeDownCallback = ", &Local_rgpos->NeedsNodeDownCallback );

} // rgpdump

VOID
DumpRGPCounters(
    rgp_counter_t *counters
    )
{
    dprintf( "    QueuedIAmAlive = %u\n", counters->QueuedIAmAlive );
    dprintf( "    RcvdLocalIAmAlive = %u\n", counters->RcvdLocalIAmAlive );
    dprintf( "    RcvdRemoteIAmAlive = %u\n", counters->RcvdRemoteIAmAlive );
    dprintf( "    RcvdRegroup = %u\n", counters->RcvdRegroup );
}

VOID
DumpClusterMask(
    PCHAR Title,
    cluster_t *nodemask
    )
{
    UINT i;

    dprintf( Title );

    for ( i = 0; i < BYTES_IN_CLUSTER; ++i ) {

        dprintf("%02X", (ULONG)(*nodemask[i]) );
    }
    dprintf("\n");
}
#endif

BOOL
ReadNodeTable(
    PCNP_NODE **LocalNodeTable,
    CL_NODE_ID *MaxNodeId,
    CL_NODE_ID *MinNodeId
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    PCNP_NODE TargetNodeTable;
    CL_NODE_ID *TargetMaxNodeId;
    CL_NODE_ID *TargetMinNodeId;
    ULONG NumberOfValidNodes;

    //
    // get the address of the node table symbol on the target machine
    //

    TargetNodeTable = (PCNP_NODE)GetExpression( "clusnet!cnpnodetable" );

    if ( !TargetNodeTable ) {

        dprintf("Can't convert clusnet!cnpnnodetable symbol\n");
        return FALSE;
    }

    if ( !ReadTargetMemory( TargetNodeTable, &TargetNodeTable, sizeof(PCNP_NODE))) {

        dprintf("Can't get pointer to target node table\n");
        return FALSE;
    }

    if ( TargetNodeTable == NULL ) {

        dprintf("Node Table hasn't been allocated.\n");
        return FALSE;
    }

    //
    // get lowest and highest valid node in the cluster
    //

    TargetMaxNodeId = (CL_NODE_ID *)GetExpression( "clusnet!cnmaxvalidnodeid" );

    if ( !TargetMaxNodeId ) {

        dprintf("Can't convert clusnet!cnmaxvalidnodeid symbol\n");
        return FALSE;
    }

    if ( !ReadTargetMemory( TargetMaxNodeId, MaxNodeId, sizeof(CL_NODE_ID))) {

        dprintf("Can't get Max Node ID data\n");
        return FALSE;
    }

    TargetMinNodeId = (CL_NODE_ID *)GetExpression( "clusnet!cnminvalidnodeid" );

    if ( !TargetMinNodeId ) {

        dprintf("Can't convert clusnet!cnMinvalidnodeid symbol\n");
        return FALSE;
    }

    if ( !ReadTargetMemory( TargetMinNodeId, MinNodeId, sizeof(CL_NODE_ID))) {

        dprintf("Can't get Min Node ID data\n");
        return FALSE;
    }

    //
    // allocate space for local copy of node table. The max and min are added
    // together since Node Ids may not be zero based while the node table is
    // zero based.
    //

    NumberOfValidNodes = *MaxNodeId + *MinNodeId;
    *LocalNodeTable = malloc( NumberOfValidNodes * sizeof( PCNP_NODE ));

    if ( !*LocalNodeTable ) {

        dprintf("Can't get local mem for node table\n");
        return FALSE;
    }

    //
    // read node table from target memory
    //

    if ( !ReadTargetMemory(TargetNodeTable,
                           *LocalNodeTable,
                           ClusterDefaultMaxNodes * sizeof(PCNP_NODE))) {

        dprintf("Can't get local copy of node table data\n");
        return FALSE;
    }

    return TRUE;
}

BOOL
ReadTargetMemory(
    PVOID TargetAddress,
    PVOID LocalBuffer,
    ULONG BytesToRead
    )
{
    BOOL success;
    ULONG BytesRead;

    success = ReadMemory((ULONG_PTR)TargetAddress, LocalBuffer, BytesToRead, &BytesRead);

    if (success) {

        if (BytesRead != BytesToRead) {

            dprintf("wrong byte count. expected=%d, read =%d\n", BytesToRead, BytesRead);
        }

    } else {
        dprintf("Problem reading memory at %p for %u bytes\n",
                TargetAddress, BytesToRead);

        success = FALSE;
    }

    return success;
}

__inline PCHAR
ListInUse(
    PLIST_ENTRY ListHead,
    PLIST_ENTRY ListToCheck
    )
{
    return ListToCheck->Flink == ListHead ? "(empty)" : "";
}

__inline PCHAR
TrueFalse(
    BOOLEAN Value
    )
{
    return Value ? "TRUE" : "FALSE";
}

VOID
DprintUnicodeString(
    PUNICODE_STRING UnicodeString,
    DWORD_PTR       AddrString,
    PCHAR           Symbol       OPTIONAL,
    DWORD_PTR       Displacement OPTIONAL
    )
{
    ANSI_STRING AnsiString;
    LPSTR StringData;
    BOOL b;
    
    StringData = malloc(UnicodeString->Length+sizeof(UNICODE_NULL));
    if ( StringData == NULL ) {
        dprintf("Unable to allocate memory for string buffer\n");
        return;
    }

    b = ReadMemory((ULONG_PTR)UnicodeString->Buffer,
                   StringData,
                   UnicodeString->Length,
                   NULL);
    if ( !b ) {
        free(StringData);
        return;
    }

    UnicodeString->Buffer = (PWSTR)StringData;
    UnicodeString->MaximumLength = UnicodeString->Length+(USHORT)sizeof(UNICODE_NULL);

    RtlUnicodeStringToAnsiString(&AnsiString,UnicodeString,TRUE);
    free(StringData);

    if (Symbol == NULL || Displacement == (DWORD_PTR) NULL) {
        dprintf("String(%d,%d) at %p: %s\n",
                UnicodeString->Length,
                UnicodeString->MaximumLength,
                AddrString,
                AnsiString.Buffer
                );
    }
    else {
        dprintf("String(%d,%d) %s+%p at %p: %s\n",
                UnicodeString->Length,
                UnicodeString->MaximumLength,
                Symbol,
                Displacement,
                AddrString,
                AnsiString.Buffer
                );
    }

    RtlFreeAnsiString(&AnsiString);

} // DprintUnicodeString

DECLARE_API( help )
{
    dprintf("Clusnet kd extensions\n\n");
    dprintf("netobj [address]               - dump a network object\n");
    dprintf("nodeobj [node ID]              - dump a node object\n");
    dprintf("nodeifs <node ID>              - dump the interface objects of a node object\n");
    dprintf("currif <node ID>               - dump the current interface object of a node object\n");
    dprintf("memlog [starting entry number] - dump the in-memory log\n");
    dprintf("mlfind <entry type>            - find all specified entry types in the memory log\n");
    dprintf("events                         - dump the FS context structs on the EventFileHandles list\n");
    dprintf("fsctxt <address>               - dump a CN_FSCONTEXT struct\n");
    dprintf("sendreq <address>              - dump a CNP send request struct\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\test\cdpsrv.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cdpsrv.c

Abstract:


Author:

    Mike Massa (mikemas)           Feb 24, 1992

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     02-24-92    created

Notes:

--*/


#include <windows.h>
#include <winsock2.h>
#include <wsclus.h>
#include <stdio.h>
#include <stdlib.h>

#define MAX_PACKET_SIZE 65535-20-68

static char szTestPattern [] = "data" ;
#define TESTPATTERN_LEN 4

int count = 0;

WSADATA        WsaData;

// void _CRTAPI1
int _cdecl
main(int argc, char **argv, char **envp)
{
    SOCKET serve_me;
    u_short Port;
    struct sockaddr addr, recvaddr;
    int addrlen, recv_addrlen;
    SOCKADDR_CLUSTER *clus_addr = (PSOCKADDR_CLUSTER)&addr;
    char *buf;
    int   err;
    int i, j;
    WORD  versionRequested = MAKEWORD(2, 0);
    DWORD  bytesReturned = 0;


    if(argc<2){
            printf("usage: cdpsrv port\n");
            exit(4);
    }

    Port = (u_short) atoi(argv[1]);

    err = WSAStartup( versionRequested, &WsaData );

    if ( err != ERROR_SUCCESS ) {
        printf("cdpsrv: WSAStartup %d:", err);
        exit(1);
    }

    if ((buf = malloc(MAX_PACKET_SIZE)) == NULL) {
        printf("out of memory\n");
        exit(1);
    }

    memset(&addr,0,sizeof(addr));
    clus_addr->sac_family = AF_CLUSTER;
    clus_addr->sac_port = Port;
    clus_addr->sac_node = 0;

    serve_me=socket(AF_CLUSTER, SOCK_DGRAM, CLUSPROTO_CDP);

    if (serve_me == INVALID_SOCKET){
        printf("\nsocket failed (%d)\n", WSAGetLastError());
        exit(1);
    }

    err = WSAIoctl(
              serve_me,
              SIO_CLUS_IGNORE_NODE_STATE,
              NULL,
              0,
              NULL,
              0,
              &bytesReturned,
              NULL,
              NULL
              );

    if (err == SOCKET_ERROR) {
        printf("Died on WSHIoctl(), status %u\n", WSAGetLastError());
        closesocket(serve_me);
        exit(9);
    }

    if (bind(serve_me, &addr, sizeof(addr))==SOCKET_ERROR){
        printf("\nbind failed (%d) on port %d\n",
        WSAGetLastError(), Port);
        closesocket(serve_me);
        exit(1);
    }

    while(1) {
        recv_addrlen = sizeof(SOCKADDR_CLUSTER);

        err = recvfrom(
                  serve_me,
                  buf,
                  MAX_PACKET_SIZE,
                  0,
                  &recvaddr,
                  &recv_addrlen
                  );

        if (err == SOCKET_ERROR) {
            printf("\nrecvfrom failed (%d)\n", WSAGetLastError());
            break;
        }

        i = 0 ;
        while (i < err)
        {
            for (j=0; j < TESTPATTERN_LEN && i < err; i++, j++)
                if (buf [i] != szTestPattern [j])
                {
                    printf ("Received Length is %d\n", err) ;
                    while (i < err)
                    {
                        printf ("Char at %d is %d %c\n", i, buf[i], buf[i]) ;
                        i++ ;
                    }
                    exit (1) ;
                }
        }


        if ((++count % 50) == 0) {
            printf("#");
        }
    }

    closesocket(serve_me);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\ntemgmt\nbtmgmt.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    nbtmgmt.c

Abstract:

    Routines for managing NBT interfaces.

Author:

    David Dion (daviddio)           December 9, 1999

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    daviddio    12-09-99    created

Notes:

--*/

#include "clusnet.h"
#include "nbtmgmt.tmh"

//
// Types
//
typedef struct _NBT_IF {
    LIST_ENTRY   Linkage;
    ULONG        InstanceNumber;
    PFILE_OBJECT FileObject;
    WCHAR        IfName[1];
} NBT_IF, *PNBT_IF;


//
// Data
//
LIST_ENTRY       NbtIfList = {NULL,NULL};
KSPIN_LOCK       NbtIfListLock = 0;


//
// Local function prototypes
//
NTSTATUS
NbtIfOpenDevice(
    IN      LPWSTR          DeviceName,
    OUT     PFILE_OBJECT    *FileObject
    );

NTSTATUS
NbtIfIssueDeviceControl(
    IN PFILE_OBJECT     FileObject,
    IN ULONG            IoControlCode,
    IN PVOID            InputBuffer,
    IN ULONG            InputBufferLength,
    IN PVOID            OutputBuffer,
    IN ULONG            OutputBufferLength
    );

PNBT_IF
NbtFindIf(
    IN LPWSTR  DeviceName,
    IN ULONG   Length
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, NbtIfLoad)
#pragma alloc_text(PAGE, NbtIfOpenDevice)
#pragma alloc_text(PAGE, NbtIfIssueDeviceControl)

#endif // ALLOC_PRAGMA



NTSTATUS
NbtIfIssueDeviceControl(
    IN PFILE_OBJECT FileObject,
    IN ULONG        IoControlCode,
    IN PVOID        InputBuffer,
    IN ULONG        InputBufferLength,
    IN PVOID        OutputBuffer,
    IN ULONG        OutputBufferLength
    )

/*++

Routine Description:


Arguments:


Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    NTSTATUS             status = STATUS_SUCCESS;
    IO_STATUS_BLOCK      iosb;
    KEVENT               event;
    PIRP                 irp;


    PAGED_CODE();

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
              IoControlCode,
              IoGetRelatedDeviceObject(FileObject),
              InputBuffer,
              InputBufferLength,
              OutputBuffer,
              OutputBufferLength,
              FALSE,
              &event,
              &iosb
              );

    if (irp != NULL) {

        status = IoCallDriver(
                     IoGetRelatedDeviceObject(FileObject),
                     irp
                     );

        if (status == STATUS_PENDING) {

            status = KeWaitForSingleObject(
                         &event,
                         Executive,
                         KernelMode,
                         FALSE,
                         NULL
                         );
            CnAssert(status == STATUS_SUCCESS);

            status = iosb.Status;
        }
    
    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] Failed to build NBT request irp, status %lx\n",
                status
                ));
        }
        CnTrace(NTEMGMT_DETAIL, NbtIfIrpAllocFailed,
            "[Clusnet] Failed to build NBT request irp, status %!status!.",
            status // LOGSTATUS
            );                
    }

    return(status);

} // NbtIfIssueDeviceControl


NTSTATUS
NbtIfOpenDevice(
    IN      LPWSTR          DeviceName,
    OUT     PFILE_OBJECT    *FileObject
    )

{
    UNICODE_STRING nameString;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK iosb;
    HANDLE handle;
    NTSTATUS status;

    *FileObject = (PFILE_OBJECT) NULL;

    //
    // Open the NBT device.
    //
    RtlInitUnicodeString(&nameString, DeviceName);

    InitializeObjectAttributes(
        &objectAttributes,
        &nameString,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    status = ZwCreateFile(
                 &handle,
                 SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                 &objectAttributes,
                 &iosb,
                 NULL,
                 FILE_ATTRIBUTE_NORMAL,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_OPEN_IF,
                 0,
                 NULL,
                 0
                 );

    if (NT_SUCCESS(status)) {

        // Get a pointer to the corresponding file object. The file
        // object pointer is used to issue ioctls to the device.
        status = ObReferenceObjectByHandle(
                     handle,
                     0,
                     NULL,
                     KernelMode,
                     FileObject,
                     NULL
                     );

        if (!NT_SUCCESS(status)) {
            *FileObject = (PFILE_OBJECT) NULL;
            CnTrace(NTEMGMT_DETAIL, NbtIfObDerefFailed,
                "[Clusnet] Failed to deref NBT device handle %p "
                "for device %ls, status %!status!.",
                handle,
                DeviceName, // LOGWSTR
                status // LOGSTATUS
                );                
            IF_CNDBG(CN_DEBUG_INIT) {
                CNPRINT(("[Clusnet] Failed to deref NBT device handle %p "
                         "for device %S, status %lx\n", 
                         handle, DeviceName, status));
            }
        }

        ZwClose(handle);

    } else {
        CnTrace(NTEMGMT_DETAIL, NbtIfOpenDeviceFailed,
            "[Clusnet] Failed to open NBT device %ls, status %!status!.",
            DeviceName, // LOGWSTR
            status // LOGSTATUS
            );                
        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[Clusnet] Failed to open NBT device %S, status %lx\n", 
                     DeviceName, status));
        }
    }

    return(status);

}   // NbtIfOpenDevice


PNBT_IF
NbtFindIf(
    LPWSTR DeviceName,
    ULONG Length
    )
{
    PNBT_IF     nbtif;
    PLIST_ENTRY entry;


    for ( entry = NbtIfList.Flink;
          entry != &NbtIfList;
          entry = entry->Flink
        )
    {
        nbtif = CONTAINING_RECORD(entry, NBT_IF, Linkage);

        if (RtlCompareMemory( 
                &nbtif->IfName[0], 
                DeviceName,
                Length - sizeof(UNICODE_NULL)
                ) == Length - sizeof(UNICODE_NULL)) {
            return(nbtif);
        }
    }

    return(NULL);

} // NbtFindIf


//
// Public Routines
//
NTSTATUS
NbtIfLoad(
    VOID
    )
{
    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[Clusnet] NBT support loading.\n"));
    }

    KeInitializeSpinLock(&NbtIfListLock);
    InitializeListHead(&NbtIfList);

    return(STATUS_SUCCESS);

}  // NbtIfLoad


VOID
NbtIfShutdown(
    VOID
    )
{
    NTSTATUS                status;
    KIRQL                   irql;
    PLIST_ENTRY             entry;
    PNBT_IF                 nbtif;
    LIST_ENTRY              deletelist;


    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[Clusnet] Destroying all cluster NBT interfaces...\n"));
    }

    KeAcquireSpinLock( &NbtIfListLock, &irql );

    //
    // Move the contents of NbtIfList to the delete list
    //
    if (!IsListEmpty( &NbtIfList )) {
        RtlCopyMemory( &deletelist, &NbtIfList, sizeof(NbtIfList) );
        deletelist.Flink->Blink = &deletelist;
        deletelist.Blink->Flink = &deletelist;
        InitializeListHead( &NbtIfList );
    } else {
        InitializeListHead( &deletelist );
    }

    KeReleaseSpinLock( &NbtIfListLock, irql );

    while (!IsListEmpty( &deletelist )) {

        entry = RemoveHeadList( &deletelist );

        nbtif = CONTAINING_RECORD( entry, NBT_IF, Linkage );

        status = NbtIfIssueDeviceControl(
                     nbtif->FileObject,
                     IOCTL_NETBT_DELETE_INTERFACE,
                     NULL, // request
                     0,    // request size
                     NULL, // response
                     0     // response size
                     );

        if (status != STATUS_SUCCESS) {
            
            LPWSTR deviceName = (LPWSTR) &nbtif->IfName[0];

            CnTrace(NTEMGMT_DETAIL, NbtIfDeleteFailed,
                "[Clusnet] Failed to delete NBT interface %ls "
                "file object %p, status %!status!.",
                deviceName, // LOGWSTR
                nbtif->FileObject,
                status // LOGSTATUS
                );                

            IF_CNDBG(CN_DEBUG_NTE) {
                CNPRINT(("[Clusnet] Failed to delete NBT interface %S "
                         "file object %p, status %lx\n",
                         deviceName,
                         nbtif->FileObject,
                         status
                         ));
            }
        
        } else {

            LPWSTR deviceName = (LPWSTR) &nbtif->IfName[0];

            CnTrace(NTEMGMT_DETAIL, NbtIfDeleted,
                "[Clusnet] Delete NBT interface %ls.",
                deviceName // LOGWSTR
                );                

            IF_CNDBG(CN_DEBUG_NTE) {
                CNPRINT(("[Clusnet] Deleted NBT interface %S.\n",
                         deviceName
                         ));
            }
        }

        // Release the reference that was taken when the NBT device
        // was created.
        ObDereferenceObject(nbtif->FileObject);

        CnFreePool(nbtif);
    }

    CnTrace(NTEMGMT_DETAIL, NbtIfShutdownIfsDeleted,
        "[Clusnet] All cluster NBT interfaces destroyed."
        );                

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[Clusnet] All cluster NBT interfaces destroyed.\n"));
    }

    return;

} // NbtIfShutdown


NTSTATUS
NbtAddIf(
    IN     PNETBT_ADD_DEL_IF    Request,
    IN     ULONG                RequestSize,
    OUT    PNETBT_ADD_DEL_IF    Response,
    IN OUT PULONG               ResponseSize
    )
{
    NTSTATUS        status;
    PFILE_OBJECT    requestFileObject;
    PFILE_OBJECT    responseFileObject;
    PNBT_IF         nbtif;
    KIRQL           irql;


    CnTrace(NTEMGMT_DETAIL, NbtIfAdding,
        "[Clusnet] Creating new NBT interface for NBT device %ls.",
        Request->IfName // LOGWSTR
        );                

    IF_CNDBG(CN_DEBUG_NTE) {
        CNPRINT((
            "[Clusnet] Creating new NBT interface for NBT device %S...\n",
            Request->IfName
            ));
    }

    //
    // Open the NBT device specified in the request. This corresponds
    // to a particular TCP/IP interface.
    //
    status = NbtIfOpenDevice( Request->IfName, &requestFileObject );

    if (NT_SUCCESS(status)) {

        //
        // Allocate a record for the NBT interface
        //
        nbtif = CnAllocatePool(
                    FIELD_OFFSET( NBT_IF, IfName[0] )
                    + Response->Length
                    );
    
        if (nbtif != NULL) {

            //
            // Issue an ioctl to create a new NBT interface.
            // The response contains the name of the new NBT
            // interface device object.
            //
            status = NbtIfIssueDeviceControl(
                         requestFileObject,
                         IOCTL_NETBT_ADD_INTERFACE,
                         NULL,
                         0,
                         Response,
                         *ResponseSize
                         );
        
            if (NT_SUCCESS(status)
                && NT_SUCCESS(Response->Status)) {

                //
                // Open the new NBT interface device object.
                //
                status = NbtIfOpenDevice(
                             (LPWSTR) Response->IfName,
                             &responseFileObject
                             );

                if (NT_SUCCESS(status)) {

                    LPWSTR deviceName = (LPWSTR) &Response->IfName[0];
                    
                    //
                    // Store the interface name, instance, and
                    // file object corresponding to the new NBT
                    // interface device object.
                    //
                    RtlZeroMemory( 
                        nbtif,
                        FIELD_OFFSET( NBT_IF, IfName[0] ) + Response->Length
                        );

                    RtlCopyMemory(
                        &nbtif->IfName[0],
                        deviceName,
                        Response->Length
                        );

                    nbtif->InstanceNumber = Response->InstanceNumber;
                    nbtif->FileObject = responseFileObject;

                    KeAcquireSpinLock(&NbtIfListLock, &irql);

                    InsertTailList(&NbtIfList, &(nbtif->Linkage));

                    KeReleaseSpinLock(&NbtIfListLock, irql);
                
                    CnTrace(NTEMGMT_DETAIL, NbtIfAdded,
                        "[Clusnet] Created new NBT interface device %ls.",
                        deviceName // LOGWSTR
                        );                

                    IF_CNDBG(CN_DEBUG_NTE) {
                        CNPRINT((
                            "[Clusnet] Created new NBT interface "
                            "device %S.\n",
                            deviceName
                            ));
                    }

                } else {

                    CnTrace(NTEMGMT_DETAIL, NbtIfAddOpenNewFailed,
                        "[Clusnet] Failed to open NBT device for new "
                        "interface %ls, status %!status!.",
                        Request->IfName, // LOGWSTR
                        status // LOGSTATUS
                        );                

                    IF_CNDBG(CN_DEBUG_NTE) {
                        CNPRINT((
                            "[Clusnet] Failed to open NBT device for "
                            "new interface %S: %x\n",
                            Request->IfName,
                            status
                            ));
                    }

                    CnFreePool(nbtif);
                }
            } else {
                
                CnTrace(NTEMGMT_DETAIL, NbtIfAddFailed,
                    "[Clusnet] Failed to add NBT interface for "
                    "NBT device %ls, status %!status!, %!status!.",
                    Request->IfName, // LOGWSTR
                    status, // LOGSTATUS
                    Response->Status // LOGSTATUS
                    );                

                IF_CNDBG(CN_DEBUG_NTE) {
                    CNPRINT((
                        "[Clusnet] Failed to add NBT interface "
                        "for NBT device %S: %x, %x\n",
                        Request->IfName,
                        status,
                        Response->Status
                        ));
                }

                CnFreePool(nbtif);
            }
        } else {
            
            status = STATUS_INSUFFICIENT_RESOURCES;
            CnTrace(NTEMGMT_DETAIL, NbtIfAddAllocFailed,
                "[Clusnet] Failed to allocate record for NBT "
                "interface %ls, status %!status!.",
                Request->IfName, // LOGWSTR
                status // LOGSTATUS
                );                
        }

        //
        // Release reference on NBT device object corresponding
        // to TCP/IP interface.
        //
        ObDereferenceObject(requestFileObject);

    } else {
        
        CnTrace(NTEMGMT_DETAIL, NbtIfAddOpenFailed,
            "[Clusnet] Failed to open NBT device %ls for add, "
            "status %!status!.",
            Request->IfName, // LOGWSTR
            status // LOGSTATUS
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] Failed to open NBT device %S: %x\n",
                Request->IfName,
                status
                ));
        }
    }

    return(status);

} // NbtAddIf


NTSTATUS
NbtDeleteIf(
    IN PNETBT_ADD_DEL_IF    Request,
    IN ULONG                RequestSize
    )
{
    NTSTATUS    status;
    PNBT_IF     nbtif;
    KIRQL       irql;
    ULONG       responseSize = 0;


    CnTrace(NTEMGMT_DETAIL, NbtIfDeleting,
        "[Clusnet] Deleting NBT interface %ls.",
        Request->IfName // LOGWSTR
        );                

    IF_CNDBG(CN_DEBUG_NTE) {
        CNPRINT((
            "[Clusnet] Attempting to delete NBT interface %S...\n",
            (LPWSTR) &Request->IfName[0]
            ));
    }

    KeAcquireSpinLock(&NbtIfListLock, &irql);

    nbtif = NbtFindIf( (LPWSTR) &Request->IfName[0], Request->Length );

    if (nbtif != NULL) {
        
        RemoveEntryList(&(nbtif->Linkage));

        KeReleaseSpinLock(&NbtIfListLock, irql);

        status = NbtIfIssueDeviceControl(
                     nbtif->FileObject,
                     IOCTL_NETBT_DELETE_INTERFACE,
                     NULL, // request
                     0,    // request size
                     NULL, // response
                     0     // response size
                     );

        if (status != STATUS_SUCCESS) {
            
            LPWSTR deviceName = (LPWSTR) &nbtif->IfName[0];

            CnTrace(NTEMGMT_DETAIL, NbtIfDeleteFailed,
                "[Clusnet] Failed to delete NBT interface %ls "
                "file object %p, status %!status!.",
                deviceName, // LOGWSTR
                nbtif->FileObject,
                status // LOGSTATUS
                );                

            IF_CNDBG(CN_DEBUG_NTE) {
                CNPRINT(("[Clusnet] Failed to delete NBT interface %S "
                         "file object %p, status %lx\n",
                         deviceName,
                         nbtif->FileObject,
                         status
                         ));
            }
        
        } else {

            LPWSTR deviceName = (LPWSTR) &nbtif->IfName[0];

            CnTrace(NTEMGMT_DETAIL, NbtIfDeleted,
                "[Clusnet] Delete NBT interface %ls.",
                deviceName // LOGWSTR
                );                

            IF_CNDBG(CN_DEBUG_NTE) {
                CNPRINT(("[Clusnet] Deleted NBT interface %S.\n",
                         deviceName
                         ));
            }
        }

        // Release the reference that was taken when the NBT device
        // was created.
        ObDereferenceObject(nbtif->FileObject);

        CnFreePool(nbtif);

    } else {
        KeReleaseSpinLock(&NbtIfListLock, irql);
    
        CnTrace(NTEMGMT_DETAIL, NbtIfDeleteNotFound,
            "[Clusnet] NBT interface %ls does not exist.",
            Request->IfName // LOGWSTR
            );                

        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT(("[Clusnet] NBT interface %S does not exist.\n", 
                     (LPWSTR) &Request->IfName[0]));
        }
    
        status = STATUS_UNSUCCESSFUL;
    }

    return (status);

} // NbtDeleteIf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\ntemgmt\ntemgmt.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ntemgmt.c

Abstract:

    Routines for managing IP Network Table Entries.

Author:

    Mike Massa (mikemas)           April 16, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     04-16-97    created

Notes:

--*/

#include "clusnet.h"
#include "ntemgmt.tmh"


//
// Types
//
typedef struct {
    LIST_ENTRY   Linkage;
    ULONG        Address;
    USHORT       Context;
    ULONG        Instance;
} IPA_NTE, *PIPA_NTE;


//
// Data
//
LIST_ENTRY       IpaNteList = {NULL,NULL};
KSPIN_LOCK       IpaNteListLock = 0;
HANDLE           IpaIpHandle = NULL;
PDEVICE_OBJECT   IpaIpDeviceObject = NULL;
PFILE_OBJECT     IpaIpFileObject = NULL;


//
// Local function prototypes
//
NTSTATUS
IpaIssueDeviceControl (
    IN ULONG            IoControlCode,
    IN PVOID            InputBuffer,
    IN ULONG            InputBufferLength,
    IN PVOID            OutputBuffer,
    IN PULONG           OutputBufferLength
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, IpaLoad)
#pragma alloc_text(PAGE, IpaIssueDeviceControl)
#pragma alloc_text(PAGE, IpaInitialize)


#endif // ALLOC_PRAGMA



NTSTATUS
IpaIssueDeviceControl(
    IN ULONG    IoControlCode,
    IN PVOID    InputBuffer,
    IN ULONG    InputBufferLength,
    IN PVOID    OutputBuffer,
    IN PULONG   OutputBufferLength
    )

/*++

Routine Description:


Arguments:


Return Value:

    NTSTATUS -- Indicates the status of the request.

Notes:

    Called in the context of the system process.

--*/

{
    NTSTATUS             status = STATUS_SUCCESS;
    IO_STATUS_BLOCK      ioStatusBlock;
    PIRP                 irp;
    PKEVENT              event;


    PAGED_CODE();

    CnAssert(IpaIpHandle != NULL);
    CnAssert(IpaIpFileObject != NULL);
    CnAssert(IpaIpDeviceObject != NULL);
    CnAssert(CnSystemProcess == (PKPROCESS) IoGetCurrentProcess());

    //
    // Reference the file object. This reference will be removed by the I/O
    // completion code.
    //
    status = ObReferenceObjectByPointer(
                 IpaIpFileObject,
                 0,
                 NULL,
                 KernelMode
                 );

    if (!NT_SUCCESS(status)) {
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] Failed to reference IP device file handle, status %lx\n",
                status
                ));
        }
        CnTrace(NTEMGMT_DETAIL, IpaNteObRefFailed,
            "[Clusnet] Failed to reference IP device file handle, status %!status!.",
            status // LOGSTATUS
            );                
        return(status);
    }

    event = ExAllocatePool(NonPagedPool, sizeof(KEVENT));

    if (event != NULL) {
        KeInitializeEvent(event, NotificationEvent, FALSE);

        irp = IoBuildDeviceIoControlRequest(
                  IoControlCode,
                  IpaIpDeviceObject,
                  InputBuffer,
                  InputBufferLength,
                  OutputBuffer,
                  *OutputBufferLength,
                  FALSE,
                  event,
                  &ioStatusBlock
                  );

        if (irp != NULL) {
            status = IoCallDriver(IpaIpDeviceObject, irp);

            //
            // If necessary, wait for the I/O to complete.
            //
            if (status == STATUS_PENDING) {
                KeWaitForSingleObject(
                    event,
                    UserRequest,
                    KernelMode,
                    FALSE,
                    NULL
                    );
            }

            if (NT_SUCCESS(status)) {
                status = ioStatusBlock.Status;

                // NOTENOTE: on 64 bit this is a truncation might
                // want > check code

                *OutputBufferLength = (ULONG)ioStatusBlock.Information;
            }
            else {
                IF_CNDBG(CN_DEBUG_NTE) {
                    CNPRINT((
                        "[Clusnet] NTE request failed, status %lx\n",
                        status
                        ));
                }
                CnTrace(NTEMGMT_DETAIL, IpaNteRequestFailed,
                    "[Clusnet] NTE request failed, status %!status!.",
                    status // LOGSTATUS
                    );                
                *OutputBufferLength = 0;
            }

            ExFreePool(event);

            return(status);
        }
        else {
            status = STATUS_INSUFFICIENT_RESOURCES;
            IF_CNDBG(CN_DEBUG_NTE) {
                CNPRINT((
                    "[Clusnet] Failed to build NTE request irp, status %lx\n",
                    status
                    ));
            }
            CnTrace(NTEMGMT_DETAIL, IpaNteIrpAllocFailed,
                "[Clusnet] Failed to build NTE request irp, status %!status!.",
                status // LOGSTATUS
                );                
        }

        ExFreePool(event);
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] Failed to allocate memory for event object.\n"
                ));
        }
        CnTrace(NTEMGMT_DETAIL, IpaNteEventAllocFailed,
            "[Clusnet] Failed to allocate event object, status %!status!.",
            status // LOGSTATUS
            );                
    }

    ObDereferenceObject(IpaIpFileObject);

    return(status);

} // IpaDeviceControl


PIPA_NTE
IpaFindNTE(
    USHORT  Context
    )
{
    PIPA_NTE      nte;
    PLIST_ENTRY   entry;


    for ( entry = IpaNteList.Flink;
          entry != &IpaNteList;
          entry = entry->Flink
        )
    {
        nte = CONTAINING_RECORD(entry, IPA_NTE, Linkage);

        if (Context == nte->Context) {
            return(nte);
        }
    }

    return(NULL);

} // IpaFindNTE


NTSTATUS
IpaAddNTECompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
/*++

Routine Description:

    IpaAddNTECompletion is the completion routine for an
    IOCTL_IP_ADD_NTE IRP. It completes the processing for
    an IOCTL_CLUSNET_ADD_NTE request and releases CnResource.
    
Arguments:

    DeviceObject - not used
    Irp - completed IRP
    Context - local NTE data structure
        
Return value

    Must not be STATUS_MORE_PROCESSING_REQUIRED
    
--*/
{
    PIP_ADD_NTE_RESPONSE     response;
    PIPA_NTE                 nte;
    NTSTATUS                 status;
    KIRQL                    irql;

    nte = (PIPA_NTE) Context;

    status = Irp->IoStatus.Status;

    if (status == STATUS_SUCCESS) {

        response = 
            (PIP_ADD_NTE_RESPONSE) Irp->AssociatedIrp.SystemBuffer;

        nte->Context = response->Context;
        nte->Instance = response->Instance;

        CnTrace(NTEMGMT_DETAIL, IpaNteCreatedNte,
            "[Clusnet] Created new NTE, context %u, instance %u.",
            nte->Context, // LOGUSHORT
            nte->Instance // LOGULONG
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] Created new NTE %lu, instance %u\n",
                nte->Context,
                nte->Instance
                ));
        }

        KeAcquireSpinLock(&IpaNteListLock, &irql);

        InsertTailList(&IpaNteList, &(nte->Linkage));

        KeReleaseSpinLock(&IpaNteListLock, irql);
    }
    else {

        CnTrace(NTEMGMT_DETAIL, IpaNteCreateNteFailed,
            "[Clusnet] Failed to create new NTE, status %!status!.",
            status // LOGSTATUS
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] Failed to create new NTE, status %lx\n",
                status
                ));
        }

        CnFreePool(nte);
    }

    //
    // Irp was already marked pending in our dispatch routine, but leave
    // this code in case the dispatch routine is ever changed.
    //
    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    return(status);

} // IpaAddNTECompletion


NTSTATUS
IpaDeleteNTECompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
/*++

Routine Description:

    IpaDeleteNTECompletion is the completion routine for an
    IOCTL_IP_DELETE_NTE IRP. It completes the processing for
    an IOCTL_CLUSNET_ADD_NTE request and releases CnResource.
    
Arguments:

    DeviceObject - not used
    Irp - completed IRP
    Context - local NTE data structure
        
Return value

    Must not be STATUS_MORE_PROCESSING_REQUIRED
    
--*/
{
    PIPA_NTE                 nte;
    NTSTATUS                 status;

    nte = (PIPA_NTE) Context;

    status = Irp->IoStatus.Status;

    if (status != STATUS_SUCCESS) {
        CnTrace(NTEMGMT_DETAIL, IpaNteDeleteNteFailed,
            "[Clusnet] Failed to delete NTE context %u, status %!status!.",
            nte->Context, // LOGUSHORT
            status // LOGSTATUS
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT(("[Clusnet] Failed to delete NTE %u, status %lx\n",
                     nte->Context,
                     status
                     ));
        }
        CnAssert(status == STATUS_SUCCESS);
    }
    else {
        CnTrace(NTEMGMT_DETAIL, IpaNteNteDeleted,
            "[Clusnet] Deleted NTE %u.",
            nte->Context // LOGUSHORT
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT(("[Clusnet] Deleted NTE %u\n", nte->Context));
        }
    }

    CnFreePool(nte);

    //
    // Irp was already marked pending in our dispatch routine, but leave
    // this code in case the dispatch routine is ever changed.
    //
    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    return(status);

} // IpaDeleteNTECompletion


NTSTATUS
IpaSetNTEAddressCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
/*++

Routine Description

    IpaSetNTEAddressCompletion is the completion routine for an
    IOCTL_IP_SET_ADDRESS IRP. It completes the processing for
    an IOCTL_CLUSNET_SET_NTE_ADDRESS request and releases
    CnResource.
    
Arguments

    DeviceObject - not used
    Irp - completed IRP
    Context - former IP address of NTE, must be restored in
        IpaNteList if IOCTL failed
        
Return value

    Must not be STATUS_MORE_PROCESSING_REQUIRED
    
--*/
{
    PIP_SET_ADDRESS_REQUEST request;
    NTSTATUS                status; 
    KIRQL                   irql;
    PIPA_NTE                nte;

    request = (PIP_SET_ADDRESS_REQUEST) Irp->AssociatedIrp.SystemBuffer;
    
    status = Irp->IoStatus.Status;

    if (status != STATUS_SUCCESS) {
        CnTrace(NTEMGMT_DETAIL, IpaNteSetNteFailed,
            "[Clusnet] Failed to set address for NTE %u, status %!status!.",
            request->Context, // LOGUSHORT
            status // LOGSTATUS
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] Failed to set NTE %u, status %lx\n",
                request->Context,
                status
                ));
        }

        KeAcquireSpinLock(&IpaNteListLock, &irql);

        nte = IpaFindNTE(request->Context);

        if ((nte != NULL) && (nte->Address == request->Address)) {
            nte->Address = PtrToUlong(Context);
        }

        KeReleaseSpinLock(&IpaNteListLock, irql);
    }
    else {
        CnTrace(NTEMGMT_DETAIL, IpaNteSetNteAddress,
            "[Clusnet] Set NTE %u to address %x.",
            request->Context, // LOGUSHORT
            request->Address // LOGXLONG
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] Set NTE %u to address %lx\n",
                request->Context,
                request->Address
                ));
        }
    }

    //
    // Irp was already marked pending in our dispatch routine, but leave
    // this code in case the dispatch routine is ever changed.
    //
    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    return(status);

} // IpaSetNTEAddressCompletion

//
// Public Routines
//
NTSTATUS
IpaLoad(
    VOID
    )
{
    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[Clusnet] NTE support loading.\n"));
    }

    KeInitializeSpinLock(&IpaNteListLock);
    InitializeListHead(&IpaNteList);

    return(STATUS_SUCCESS);

}  // IpaLoad


NTSTATUS
IpaInitialize(
    VOID
    )
{
    NTSTATUS             status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES    objectAttributes;
    UNICODE_STRING       nameString;
    IO_STATUS_BLOCK      ioStatusBlock;


    PAGED_CODE( );

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[Clusnet] NTE support initializing.\n"));
    }

    CnAssert(IsListEmpty(&IpaNteList));
    CnAssert(IpaIpHandle == NULL);
    CnAssert(CnSystemProcess != NULL);

    //
    // Open handles in the context of the system process
    //
    KeAttachProcess(CnSystemProcess);

    //
    // Open the IP device.
    //
    RtlInitUnicodeString(&nameString, DD_IP_DEVICE_NAME);

    InitializeObjectAttributes(
        &objectAttributes,
        &nameString,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    status = ZwCreateFile(
                 &IpaIpHandle,
                 SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                 &objectAttributes,
                 &ioStatusBlock,
                 NULL,
                 FILE_ATTRIBUTE_NORMAL,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_OPEN_IF,
                 0,
                 NULL,
                 0
                 );

    if (!NT_SUCCESS(status)) {
        CnTrace(NTEMGMT_DETAIL, IpaNteOpenIpFailed,
            "[Clusnet] Failed to open IP device, status %!status!.",
            status // LOGSTATUS
            );                
        
        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[Clusnet] Failed to open IP device, status %lx\n", status));
        }
        goto error_exit;
    }

    status = ObReferenceObjectByHandle(
                 IpaIpHandle,
                 0,
                 NULL,
                 KernelMode,
                 &IpaIpFileObject,
                 NULL
                 );

    if (!NT_SUCCESS(status)) {
        CnTrace(NTEMGMT_DETAIL, IpaNteRefIpFailed,
            "[Clusnet] Failed to reference IP device, status %!status!.",
            status // LOGSTATUS
            );                
        
        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[Clusnet] Failed to reference IP device file handle, status %lx\n", status));
        }
        ZwClose(IpaIpHandle); IpaIpHandle = NULL;
        goto error_exit;
    }

    IpaIpDeviceObject = IoGetRelatedDeviceObject(IpaIpFileObject);

    CnAdjustDeviceObjectStackSize(CnDeviceObject, IpaIpDeviceObject);

    status = STATUS_SUCCESS;

error_exit:

    KeDetachProcess();

    return(status);

}  // IpaInitialize


VOID
IpaShutdown(
    VOID
    )
{
    NTSTATUS                status;
    KIRQL                   irql;
    PLIST_ENTRY             entry;
    PIPA_NTE                nte;
    IP_DELETE_NTE_REQUEST   request;
    ULONG                   responseSize = 0;


    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[Clusnet] Destroying all cluster NTEs...\n"));
    }

    if (IpaIpHandle != NULL) {
        //
        // Handles was opened in the context of the system process.
        //
        CnAssert(CnSystemProcess != NULL);
        KeAttachProcess(CnSystemProcess);

        KeAcquireSpinLock(&IpaNteListLock, &irql);

        while (!IsListEmpty(&IpaNteList)) {
            entry = RemoveHeadList(&IpaNteList);

            KeReleaseSpinLock(&IpaNteListLock, irql);

            nte = CONTAINING_RECORD(entry, IPA_NTE, Linkage);

            request.Context = nte->Context;

            status = IpaIssueDeviceControl(
                         IOCTL_IP_DELETE_NTE,
                         &request,
                         sizeof(request),
                         NULL,
                         &responseSize
                         );

            if (status != STATUS_SUCCESS) {
                CnTrace(NTEMGMT_DETAIL, IpaNteShutdownDeleteNteFailed,
                    "[Clusnet] Shutdown: failed to delete NTE %u, status %!status!.",
                    nte->Context, // LOGUSHORT
                    status // LOGSTATUS
                    );                

                IF_CNDBG(CN_DEBUG_INIT) {
                    CNPRINT(("[Clusnet] Failed to delete NTE %u, status %lx\n",
                             nte->Context,
                             status
                             ));
                }
            }
            else {
                CnTrace(NTEMGMT_DETAIL, IpaNteShutdownDeletedNte,
                    "[Clusnet] Shutdown: deleted NTE context %u, instance %u.",
                    nte->Context, // LOGUSHORT
                    nte->Instance // LOGULONG
                    );                

                IF_CNDBG(CN_DEBUG_INIT) {
                    CNPRINT(("[Clusnet] Deleted NTE %u\n", request.Context));
                }
            }

            CnFreePool(nte);

            KeAcquireSpinLock(&IpaNteListLock, &irql);
        }

        KeReleaseSpinLock(&IpaNteListLock, irql);

        CnTrace(NTEMGMT_DETAIL, IpaNteShutdownNtesDeleted,
            "[Clusnet] All cluster NTEs destroyed."
            );                
        
        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[Clusnet] All cluster NTEs destroyed.\n"));
        }

        ObDereferenceObject(IpaIpFileObject);
        ZwClose(IpaIpHandle);
        IpaIpHandle = NULL;
        IpaIpFileObject = NULL;
        IpaIpDeviceObject = NULL;

        KeDetachProcess();
    }

    return;

} // IpaShutdown


NTSTATUS
IpaAddNTE(
    IN PIRP                     Irp,
    IN PIO_STACK_LOCATION       IrpSp
    )
/*++

Routine Description

    IpaAddNTE issues an IOCTL_IP_ADD_NTE to IP to add an NTE. 
    Irp is reused. It must be allocated with sufficient stack
    locations, as determined when IpaIpDeviceObject was opened
    in IpaInitialize.
    
Arguments

    Irp - IRP from I/O manager to clusnet
    IrpSp - current IRP stack location
    
Return Value

    STATUS_PENDING, or error status if request is not submitted
    to IP.
    
--*/
{
    NTSTATUS                 status;
    PIP_ADD_NTE_REQUEST      request;
    ULONG                    requestSize;
    ULONG                    responseSize;
    PIPA_NTE                 nte;
    PIO_STACK_LOCATION       nextIrpSp;


    //
    // Verify input parameters
    //
    requestSize =
        IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    responseSize =
        IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if (requestSize < sizeof(IP_ADD_NTE_REQUEST)) {
        ULONG correctSize = sizeof(IP_ADD_NTE_REQUEST);
        CnTrace(NTEMGMT_DETAIL, IpaNteAddInvalidReqSize,
            "[Clusnet] Add NTE request size %u invalid, "
            "should be %u.",
            requestSize, // LOGULONG
            correctSize // LOGULONG
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] Add NTE request size %d invalid, should be %d.\n",
                requestSize,
                sizeof(IP_ADD_NTE_REQUEST)
                ));
        }
        return(STATUS_INVALID_PARAMETER);
    } else if (responseSize < sizeof(IP_ADD_NTE_RESPONSE)) {
        ULONG correctSize = sizeof(IP_ADD_NTE_RESPONSE);
        CnTrace(NTEMGMT_DETAIL, IpaNteAddInvalidResponseSize,
            "[Clusnet] Add NTE response size %u invalid, "
            "should be %u.",
            responseSize, // LOGULONG
            correctSize // LOGULONG
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] Add NTE response size %d invalid, should be %d.\n",
                responseSize,
                sizeof(IP_ADD_NTE_RESPONSE)
                ));
        }
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Verify that Irp has sufficient stack locations
    //
    if (Irp->CurrentLocation - IpaIpDeviceObject->StackSize < 1) {
        UCHAR correctSize = IpaIpDeviceObject->StackSize+1;
        CnTrace(NTEMGMT_DETAIL, IpaNteAddNoIrpStack,
            "[Clusnet] Add NTE IRP has %u remaining stack locations, "
            "need %u.",
            Irp->CurrentLocation, // LOGUCHAR
            correctSize // LOGUCHAR
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] Add NTE IRP has %d stack locations, need %d.\n",
                Irp->CurrentLocation,
                IpaIpDeviceObject->StackSize
                ));
        }
        return(STATUS_INVALID_PARAMETER);
    }

    request = (PIP_ADD_NTE_REQUEST) Irp->AssociatedIrp.SystemBuffer;

    CnTrace(NTEMGMT_DETAIL, IpaNteCreatingNte,
        "[Clusnet] Creating new NTE for address %x.",
        request->Address // LOGXLONG
        );                

    IF_CNDBG(CN_DEBUG_NTE) {
        CNPRINT((
            "[Clusnet] Creating new NTE for address %lx...\n",
            request->Address
            ));
    }

    //
    // Allocate a local NTE data structure.
    //
    nte = CnAllocatePool(sizeof(IPA_NTE));

    if (nte == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    nte->Address = request->Address;

    //
    // Set up the next IRP stack location for IP.
    // IOCTL_CLUSNET_ADD_NTE uses the same request
    // and response buffer, so there is no need to
    // alter the IRP system buffer.
    //
    IoCopyCurrentIrpStackLocationToNext(Irp);

    nextIrpSp = IoGetNextIrpStackLocation(Irp);
    nextIrpSp->Parameters.DeviceIoControl.IoControlCode 
        = IOCTL_IP_ADD_NTE;
    nextIrpSp->FileObject = IpaIpFileObject;

    IoSetCompletionRoutine(
        Irp,
        IpaAddNTECompletion,
        (PVOID) nte,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Mark the IRP pending, since we return STATUS_PENDING
    // regardless of the result of IoCallDriver.
    //
    IoMarkIrpPending(Irp);

    //
    // Issue the request
    //
    IoCallDriver(IpaIpDeviceObject, Irp);

    //
    // At this point we must return STATUS_PENDING so that
    // the clusnet dispatch routine will not try to complete
    // the IRP. The lower-level driver is required to complete
    // the IRP, and errors will be handled in the completion
    // routine.
    //
    return (STATUS_PENDING);

} // IpaAddNTE


NTSTATUS
IpaDeleteNTE(
    IN PIRP                     Irp,
    IN PIO_STACK_LOCATION       IrpSp
    )
/*++

Routine Description

    IpaDeleteNTE issues an IOCTL_IP_DELETE_NTE to IP to delete
    an NTE. Irp is reused. It must be allocated with sufficient
    stack locations, as determined when IpaIpDeviceObject was
    opened in IpaInitialize.
    
Arguments

    Irp - IRP from I/O manager to clusnet
    IrpSp - current IRP stack location
    
Return Value

    STATUS_PENDING, or error status if request is not submitted
    to IP.
    
--*/
{
    NTSTATUS                 status;
    PIP_DELETE_NTE_REQUEST   request;
    ULONG                    requestSize;
    PIPA_NTE                 nte;
    KIRQL                    irql;
    PIO_STACK_LOCATION       nextIrpSp;


    //
    // Verify input parameters
    //
    requestSize =
        IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(IP_DELETE_NTE_REQUEST)) {
        ULONG correctSize = sizeof(IP_DELETE_NTE_REQUEST);
        CnTrace(NTEMGMT_DETAIL, IpaNteDelInvalidReqSize,
            "[Clusnet] Delete NTE request size %u invalid, "
            "should be %u.",
            requestSize, // LOGULONG
            correctSize // LOGULONG
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] Delete NTE request size %d invalid, "
                "should be %d.\n",
                requestSize,
                sizeof(IP_DELETE_NTE_REQUEST)
                ));
        }
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Verify that Irp has sufficient stack locations
    //
    if (Irp->CurrentLocation - IpaIpDeviceObject->StackSize < 1) {
        UCHAR correctSize = IpaIpDeviceObject->StackSize+1;
        CnTrace(NTEMGMT_DETAIL, IpaNteDeleteNoIrpStack,
            "[Clusnet] Delete NTE IRP has %u remaining stack locations, "
            "need %u.",
            Irp->CurrentLocation, // LOGUCHAR
            correctSize // LOGUCHAR
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] Delete NTE IRP has %d stack locations, "
                "need %d.\n",
                Irp->CurrentLocation,
                IpaIpDeviceObject->StackSize
                ));
        }
        return(STATUS_INVALID_PARAMETER);
    }

    request = (PIP_DELETE_NTE_REQUEST) Irp->AssociatedIrp.SystemBuffer;

    //
    // Find the NTE in local NTE list and remove.
    //
    KeAcquireSpinLock(&IpaNteListLock, &irql);

    nte = IpaFindNTE(request->Context);

    if (nte == NULL) {
        KeReleaseSpinLock(&IpaNteListLock, irql);

        CnTrace(NTEMGMT_DETAIL, IpaNteDeleteNteUnknown,
            "[Clusnet] NTE %u does not exist.",
            request->Context // LOGUSHORT
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] NTE %u does not exist.\n", 
                request->Context
                ));
        }

        return(STATUS_UNSUCCESSFUL);
    }

    RemoveEntryList(&(nte->Linkage));

    KeReleaseSpinLock(&IpaNteListLock, irql);

    //
    // Set up the next IRP stack location for IP.
    // IOCTL_CLUSNET_ADD_NTE uses the same request
    // and response buffer, so there is no need to
    // alter the IRP system buffer.
    //
    IoCopyCurrentIrpStackLocationToNext(Irp);

    nextIrpSp = IoGetNextIrpStackLocation(Irp);
    nextIrpSp->Parameters.DeviceIoControl.IoControlCode 
        = IOCTL_IP_DELETE_NTE;
    nextIrpSp->FileObject = IpaIpFileObject;

    IoSetCompletionRoutine(
        Irp,
        IpaDeleteNTECompletion,
        (PVOID) nte,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Mark the IRP pending, since we return STATUS_PENDING
    // regardless of the result of IoCallDriver.
    //
    IoMarkIrpPending(Irp);

    //
    // Issue the request
    //
    IoCallDriver(IpaIpDeviceObject, Irp);

    //
    // At this point we must return STATUS_PENDING so that
    // the clusnet dispatch routine will not try to complete
    // the IRP. The lower-level driver is required to complete
    // the IRP, and errors will be handled in the completion
    // routine.
    //
    return (STATUS_PENDING);

} // IpaDeleteNTE


NTSTATUS
IpaSetNTEAddress(
    IN PIRP                     Irp,
    IN PIO_STACK_LOCATION       IrpSp
    )
/*++

Routine Description

    IpaSetNTEAddress issues an IOCTL_IP_SET_ADDRESS to IP in order
    to set the IP address for an NTE. Irp is reused. It must be
    allocated with sufficient stack locations, as determined when
    IpaIpDeviceObject was opened in IpaInitialize.
    
Arguments

    Irp - IRP from I/O manager to clusnet
    IrpSp - current IRP stack location
    
Return Value

    STATUS_PENDING, or error status if request is not submitted
    to IP.
    
--*/
{
    NTSTATUS                 status;
    PIP_SET_ADDRESS_REQUEST  request;
    ULONG                    requestSize;
    PIPA_NTE                 nte;
    KIRQL                    irql;
    PIO_STACK_LOCATION       nextIrpSp;
    ULONG                    oldAddress;


    //
    // Verify input parameters
    //
    requestSize =
        IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(IP_SET_ADDRESS_REQUEST)) {
        ULONG correctSize = sizeof(IP_SET_ADDRESS_REQUEST);
        CnTrace(NTEMGMT_DETAIL, IpaNteSetInvalidReqSize,
            "[Clusnet] Set NTE request size %u invalid, "
            "should be %u.",
            requestSize, // LOGULONG
            correctSize // LOGULONG
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] Set NTE request size %d invalid, should be %d.\n",
                requestSize,
                sizeof(IP_SET_ADDRESS_REQUEST)
                ));
        }
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Verify that Irp has sufficient stack locations
    //
    if (Irp->CurrentLocation - IpaIpDeviceObject->StackSize < 1) {
        UCHAR correctSize = IpaIpDeviceObject->StackSize+1;
        CnTrace(NTEMGMT_DETAIL, IpaNteSetNoIrpStack,
            "[Clusnet] Set NTE IRP has %u remaining stack locations, "
            "need %u.",
            Irp->CurrentLocation, // LOGUCHAR
            correctSize // LOGUCHAR
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT((
                "[Clusnet] Set NTE IRP has %d stack locations, need %d.\n",
                Irp->CurrentLocation,
                IpaIpDeviceObject->StackSize
                ));
        }
        return(STATUS_INVALID_PARAMETER);
    }

    request = (PIP_SET_ADDRESS_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;

    IF_CNDBG(CN_DEBUG_NTE) {
        CNPRINT((
            "[Clusnet] Attempting to set NTE %u to address %lx...\n",
            request->Context,
            request->Address
            ));
    }

    KeAcquireSpinLock(&IpaNteListLock, &irql);

    nte = IpaFindNTE(request->Context);

    if (nte != NULL) {
        oldAddress = nte->Address;
        nte->Address = request->Address;

        KeReleaseSpinLock(&IpaNteListLock, irql);

        //
        // Set up the next IRP stack location for IP.
        // IOCTL_CLUSNET_SET_NTE_ADDRESS uses the same request
        // and response buffer, so there is no need to alter the
        // IRP system buffer.
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);
        
        nextIrpSp = IoGetNextIrpStackLocation(Irp);
        nextIrpSp->Parameters.DeviceIoControl.IoControlCode 
            = IOCTL_IP_SET_ADDRESS;
        nextIrpSp->FileObject = IpaIpFileObject;

        IoSetCompletionRoutine(
            Irp,
            IpaSetNTEAddressCompletion,
            UlongToPtr(oldAddress),
            TRUE,
            TRUE,
            TRUE
            );

        //
        // Mark the IRP pending, since we return STATUS_PENDING
        // regardless of the result of IoCallDriver.
        //
        IoMarkIrpPending(Irp);

        //
        // Issue the request
        //
        IoCallDriver(IpaIpDeviceObject, Irp);

        //
        // At this point we must return STATUS_PENDING so that
        // the clusnet dispatch routine will not try to complete
        // the IRP. The lower-level driver is required to complete
        // the IRP, and errors will be handled in the completion
        // routine.
        //
        status = STATUS_PENDING;

    } else {
        
        KeReleaseSpinLock(&IpaNteListLock, irql);

        CnTrace(NTEMGMT_DETAIL, IpaNteSetNteUnknown,
            "[Clusnet] NTE %u does not exist.",
            request->Context // LOGUSHORT
            );                
        
        IF_CNDBG(CN_DEBUG_NTE) {
            CNPRINT(("[Clusnet] NTE %u does not exist.\n", 
                     request->Context
                     ));
        }

        status = STATUS_UNSUCCESSFUL;
    }

    return(status);

} // IpaSetNTEAddress


BOOLEAN
IpaIsAddressRegistered(
    ULONG  Address
    )
{
    PIPA_NTE      nte;
    KIRQL         irql;
    PLIST_ENTRY   entry;
    BOOLEAN       isAddressRegistered = FALSE;


    KeAcquireSpinLock(&IpaNteListLock, &irql);

    for ( entry = IpaNteList.Flink;
          entry != &IpaNteList;
          entry = entry->Flink
        )
    {
        nte = CONTAINING_RECORD(entry, IPA_NTE, Linkage);

        if (nte->Address == Address) {
            isAddressRegistered = TRUE;
            break;
        }
    }

    KeReleaseSpinLock(&IpaNteListLock, irql);

    return(isAddressRegistered);

} // IpaIsAddressRegistered
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\rpcep\rpcep.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    rpcep.cpp

Abstract:

    dump all registered interfaces on the local RPC endpoint mapper

Author:

    Charlie Wickham (charlwi) 10-Feb-2000

Revision History:

--*/

#include <stdio.h>
#include <errno.h>
#include <rpc.h>

CHAR blanks[] = "                                            ";

int __cdecl
main( int argc, char *argv[])
{
    RPC_STATUS status;
    RPC_EP_INQ_HANDLE inquiryContext;
    DWORD numBlanks;

    status = RpcMgmtEpEltInqBegin(NULL,
                                  RPC_C_EP_ALL_ELTS,
                                  (RPC_IF_ID *)NULL,
                                  0,
                                  NULL,
                                  &inquiryContext);

    if (status != RPC_S_OK) {
        printf( "RpcMgmtEpEltInqBegin() failed with %d\n", status);
        return status;
    }

    do {
        RPC_IF_ID ifId;
        RPC_BINDING_HANDLE bindingHandle;
        unsigned char * annotation;
        unsigned char * localBinding;

        status = RpcMgmtEpEltInqNext(inquiryContext,
                                     &ifId,
                                     &bindingHandle,
                                     NULL,
                                     &annotation);

        if ( status == RPC_X_NO_MORE_ENTRIES ) {
            break;
        } else if (status != RPC_S_OK) {
            printf( "RpcMgmtEpEltInqNext() failed with %d\n", status);
            break;
        }

        status = RpcBindingToStringBinding( bindingHandle, &localBinding );
        printf("%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X",
               ifId.Uuid.Data1, ifId.Uuid.Data2, ifId.Uuid.Data3,
               ifId.Uuid.Data4[0], ifId.Uuid.Data4[1], ifId.Uuid.Data4[2], ifId.Uuid.Data4[3],
               ifId.Uuid.Data4[4], ifId.Uuid.Data4[5], ifId.Uuid.Data4[6], ifId.Uuid.Data4[7]
               );

        numBlanks = sizeof(blanks) - ( strlen( (const char *)localBinding ) + 2 );
        printf("  [%s]%*.s\"%s\"\n", localBinding, numBlanks, blanks, annotation );

        RpcBindingFree( &bindingHandle );
        RpcStringFree( &localBinding );

    } while ( TRUE );

    status = RpcMgmtEpEltInqDone( &inquiryContext );
    if (status != RPC_S_OK) {
        printf( "RpcMgmtEpEltInqDone() failed with %d\n", status);
    }

    return 0;
}

/* end rpcep.cpp */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\test\cdpcli.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    utestcly.c

Abstract:

    UDP stress test client. Fires datagrams at a specific UDP port
    on a machine.

Author:

    Mike Massa (mikemas)           Feb 24, 1992

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     02-24-92    created

Notes:

--*/

#include <windows.h>
#include <winsock2.h>
#include <wsclus.h>
#include <stdio.h>
#include <stdlib.h>

static char szTestPattern [] = "data" ;
#define TESTPATTERN_LEN 4

#define MAX_PACKET_SIZE   (65535-20-68)

WSADATA        WsaData;

// void _CRTAPI1
int _cdecl
main(int argc, char **argv, char **envp)
{
        SOCKET serve_me;
        u_long dstNode;
        u_short dstPort;
        struct sockaddr addr;
        int remotelen;
        SOCKADDR_CLUSTER  remoteaddr;
        PSOCKADDR_CLUSTER clus_addr = (PSOCKADDR_CLUSTER) &addr;
        int   count;
        int   pktsize;
        char *buf;
        int   i, j;
        int   err;
        WORD  versionRequested = MAKEWORD(2, 0);
        DWORD bytesReturned = 0;


        if(argc<5){
                printf("usage: cdpcli node port pktsize pktcnt\n");
                printf("    Pktcnt of -1 will loop forever\n");
                exit(4);
        }

        dstNode = (u_long) atoi(argv[1]);
        dstPort = (u_short) atoi(argv[2]);
        pktsize = atoi(argv[3]);
        count = atoi(argv[4]);

        if (pktsize > MAX_PACKET_SIZE) {
            printf("max packet size is 1460\n");
            exit(1);
        }

        err = WSAStartup( versionRequested, &WsaData );

        if ( err != ERROR_SUCCESS ) {
            printf("udpcli: WSAStartup %d:", err);
            exit(1);
        }

        if ((buf = malloc(pktsize)) == NULL) {
            printf("out of memory\n");
            exit(1);
        }

        i = 0 ;
        while (i < pktsize)
        {
            for (j=0; j < TESTPATTERN_LEN && i < pktsize; i++, j++)
                buf [i] = szTestPattern [j] ;
        }

        serve_me = socket(AF_CLUSTER, SOCK_DGRAM, CLUSPROTO_CDP);

        if(serve_me == INVALID_SOCKET){
                printf(
                    "Died on socket(), status %u\n",
                    WSAGetLastError()
                    );
                exit(4);
        }

        memset(&addr,0,sizeof(addr));
        clus_addr->sac_family = AF_CLUSTER;
        clus_addr->sac_port = 0;
        clus_addr->sac_node = 0;
        clus_addr->sac_zero = 0;


        if(bind(serve_me, &addr, sizeof(addr))==SOCKET_ERROR){
                printf("Died on bind(), status %u\n", WSAGetLastError());
                closesocket(serve_me);
                exit(9);
        }

        err = WSAIoctl(
                  serve_me,
                  SIO_CLUS_IGNORE_NODE_STATE,
                  NULL,
                  0,
                  NULL,
                  0,
                  &bytesReturned,
                  NULL,
                  NULL
                  );

        if (err == SOCKET_ERROR) {
            printf("Died on WSHIoctl(), status %u\n", WSAGetLastError());
            closesocket(serve_me);
            exit(9);
        }

        memset(&addr,0,sizeof(addr));
        clus_addr->sac_family = AF_CLUSTER;
        clus_addr->sac_port = dstPort;
        clus_addr->sac_node = dstNode;

        for(i=0; i < count || count == -1; i++) {
            if( sendto(
                    serve_me,
                    buf,
                    pktsize,
                    0,
                    &addr,
                    sizeof(addr)
                    )
                 ==SOCKET_ERROR
              ){
                printf("sendto failed %d\n",WSAGetLastError());
                exit(9);
            }
        }

        closesocket(serve_me);
}


int init_net()
{
        WORD wVersionRequired;
        WSADATA versionInfo;

        wVersionRequired = 1<<8 | 0;
        if(WSAStartup(wVersionRequired, &versionInfo)){
                printf("died in WSAStartup() %d\n",WSAGetLastError());
                exit(9);
        }
        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\xport\cdp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cdp.h

Abstract:

    Main private header file for the Cluster Network Protocol.

Author:

    Mike Massa (mikemas)           July 29, 1996

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     07-29-96    created

Notes:

--*/

#ifndef _CDP_INCLUDED_
#define _CDP_INCLUDED_


NTSTATUS
CdpInitializeSend(
    VOID
    );

VOID
CdpCleanupSend(
    VOID
    );

NTSTATUS
CdpInitializeReceive(
    VOID
    );

VOID
CdpCleanupReceive(
    VOID
    );

#endif // ifndef _CDP_INCLUDED_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\test\cntest.c ===
/*++

Copyright (c) 1996  Microsoft Corporation. All Rights Reserved.

Module Name:

    cntest.c

Abstract:

    Test program for managing the cluster transport.

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <winsock2.h>
#include <tdi.h>
#include <clusapi.h>
#include <clusdef.h>
#include <ntddcnet.h>
#include <cnetapi.h>


//
// Local prototypes
//

PWCHAR
ConvertStringToUnicode(
    PUCHAR String
    );

PTRANSPORT_ADDRESS
BuildTdiAddressForIp(
    IN  ULONG     Address,
    IN  USHORT    Port,
    OUT PULONG    TdiAddressLength
    );

DWORD
Initialize(
    IN char **  argv,
    IN int      argc
    );

DWORD
RegisterNode(
    IN char **  argv,
    IN int      argc
    );

DWORD
DeregisterNode(
    IN char **  argv,
    IN int      argc
    );

DWORD
RegisterNetwork(
    IN char **  argv,
    IN int      argc
    );

DWORD
DeregisterNetwork(
    IN char **  argv,
    IN int      argc
    );

DWORD
RegisterInterface(
    IN char **  argv,
    IN int      argc
    );

DWORD
DeregisterInterface(
    IN char **  argv,
    IN int      argc
    );

DWORD
GetNetworkPriority(
    IN char **  argv,
    IN int      argc
    );

DWORD
OnlineNodeComm(
    IN char **  argv,
    IN int      argc
    );

DWORD
OfflineNodeComm(
    IN char **  argv,
    IN int      argc
    );

DWORD
OnlineNetwork(
    IN char **  argv,
    IN int      argc
    );

DWORD
OfflineNetwork(
    IN char **  argv,
    IN int      argc
    );

DWORD
SetNetworkPriority(
    IN char **  argv,
    IN int      argc
    );

DWORD
GetInterfacePriority(
    IN char **  argv,
    IN int      argc
    );

DWORD
SetInterfacePriority(
    IN char **  argv,
    IN int      argc
    );

DWORD
GetNodeCommState(
    IN char **  argv,
    IN int      argc
    );

DWORD
GetNetworkState(
    IN char **  argv,
    IN int      argc
    );

DWORD
GetInterfaceState(
    IN char **  argv,
    IN int      argc
    );

DWORD
TestEvents(
    IN char **  argv,
    IN int      argc
    );

DWORD
SetMemLogging(
    IN char **  argv,
    IN int      argc
    );

DWORD
SendPoisonPacket(
    IN char **  argv,
    IN int      argc
    );

DWORD
GetMulticastReachableSet(
    IN char **  argv,
    IN int      argc
    );

#if  DBG

DWORD
SetDebugMask(
    IN char **  argv,
    IN int      argc
    );

DWORD
OnlinePendingInterface(
    IN char **  argv,
    IN int      argc
    );

DWORD
OnlineInterface(
    IN char **  argv,
    IN int      argc
    );

DWORD
OfflineInterface(
    IN char **  argv,
    IN int      argc
    );

DWORD
FailInterface(
    IN char **  argv,
    IN int      argc
    );

DWORD
SendMmMsg(
    IN char **  argv,
    IN int      argc
    );

DWORD
MMgrForm(
    IN char **  argv,
    IN int      argc
    );

DWORD
MMgrJoin(
    IN char **  argv,
    IN int      argc
    );

DWORD
MMgrLeave(
    IN char **  argv,
    IN int      argc
    );

DWORD
MMgrGetMembershipState(
    IN char **  argv,
    IN int      argc
    );

DWORD
MMgrEject(
    IN char **  argv,
    IN int      argc
    );

#endif // DBG


//
// Local Types
//
typedef enum {
    OpcodeInvalid = 0,
    OpcodeInit,
    OpcodeShutdown,
    OpcodeSetDebugMask,
    OpcodeAdd,
    OpcodeDelete,
    OpcodeOnlinePending,
    OpcodeOnline,
    OpcodeOffline,
    OpcodeFail,
    OpcodeGetPriority,
    OpcodeSetPriority,
    OpcodeGetState,
    OpcodeSendMmMsg,
#ifdef MM_IN_CLUSNET
    OpcodeMMgrForm,
    OpcodeMMgrJoin,
    OpcodeMMgrLeave,
    OpcodeMMgrGetMembershipState,
    OpcodeMMgrEject,
#endif
    OpcodeTestEvents,
    OpcodeSetMemLogging,
    OpcodeSendPoisonPacket,
    OpcodeGetMulticastReachableSet
} CN_OPCODE;

typedef enum {
    ObjTypeInvalid = 0,
    ObjTypeNode,
    ObjTypeNetwork,
    ObjTypeInterface
} CN_OBJTYPE;

HANDLE     Handle = NULL;

//
// Local Prototypes
//
void
Usage(
    void
    );


//
// Main Function
//
int _cdecl
main(int argc, char **argv)
{

    DWORD         status = ERROR_INVALID_PARAMETER;
    CN_OPCODE        opcode = OpcodeInvalid;
    CN_OBJTYPE       objtype = ObjTypeInvalid;
    BOOLEAN          objTypeRequired = TRUE;


    if (argc < 2) {
        Usage();
        return(status);
    }

    //
    // Crack the operation.
    //
    if (strcmp(argv[1], "init") == 0) {
        opcode = OpcodeInit;
        objTypeRequired = FALSE;
    }
    else if (strcmp(argv[1], "shutdown") == 0) {
        opcode = OpcodeShutdown;
        objTypeRequired = FALSE;
    }
    else if (strcmp(argv[1], "setdebug") == 0) {
        opcode = OpcodeSetDebugMask;
        objTypeRequired = FALSE;
    }
    else if (strcmp(argv[1], "add") == 0) {
        opcode = OpcodeAdd;
    }
    else if (strcmp(argv[1], "del") == 0) {
        opcode = OpcodeDelete;
    }
    else if (strcmp(argv[1], "onpend") == 0) {
        opcode = OpcodeOnlinePending;
    }
    else if (strcmp(argv[1], "online") == 0) {
        opcode = OpcodeOnline;
    }
    else if (strcmp(argv[1], "offline") == 0) {
        opcode = OpcodeOffline;
    }
    else if (strcmp(argv[1], "fail") == 0) {
        opcode = OpcodeFail;
    }
    else if (strcmp(argv[1], "getpri") == 0) {
        opcode = OpcodeGetPriority;
    }
    else if (strcmp(argv[1], "setpri") == 0) {
        opcode = OpcodeSetPriority;
    }
    else if (strcmp(argv[1], "getstate") == 0) {
        opcode = OpcodeGetState;
    }
    else if (strcmp(argv[1], "send") == 0) {
        opcode = OpcodeSendMmMsg;
        objTypeRequired = FALSE;
    }
#ifdef MM_IN_CLUSNET
    else if (strcmp(argv[1], "mmform") == 0) {
        opcode = OpcodeMMgrForm;
        objTypeRequired = FALSE;
    }
    else if (strcmp(argv[1], "mmjoin") == 0) {
        opcode = OpcodeMMgrJoin;
        objTypeRequired = FALSE;
    }
    else if (strcmp(argv[1], "mmleave") == 0) {
        opcode = OpcodeMMgrLeave;
        objTypeRequired = FALSE;
    }
    else if (strcmp(argv[1], "mmgetstate") == 0) {
        opcode = OpcodeMMgrGetMembershipState;
        objTypeRequired = FALSE;
    }
    else if (strcmp(argv[1], "mmeject") == 0) {
        opcode = OpcodeMMgrEject;
        objTypeRequired = FALSE;
    }
#endif
    else if (strcmp(argv[1], "events") == 0) {
        opcode = OpcodeTestEvents;
        objTypeRequired = FALSE;
    }
    else if (strcmp(argv[1], "memlog") == 0) {
        opcode = OpcodeSetMemLogging;
        objTypeRequired = FALSE;
    }
    else if (strcmp(argv[1], "poison") == 0) {
        opcode = OpcodeSendPoisonPacket;
        objTypeRequired = FALSE;
    }
    else if (strcmp(argv[1], "getmcast") == 0) {
        opcode = OpcodeGetMulticastReachableSet;
        objTypeRequired = FALSE;
    }
    else {
        printf("invalid command %s\n", argv[1]);
        Usage();
        return(status);
    }

    //
    // Crack the object type
    //
    if (objTypeRequired) {
        if (strcmp(argv[2], "node") == 0) {
            objtype = ObjTypeNode;
        }
        else if (strcmp(argv[2], "network") == 0) {
            objtype = ObjTypeNetwork;
        }
        else if (strcmp(argv[2], "interface") == 0) {
            objtype = ObjTypeInterface;
        }
        else {
            printf("invalid object type %s\n", argv[2]);
            Usage();
            return(status);
        }
    }

    //
    // Open the driver
    //
    Handle = ClusnetOpenControlChannel(FILE_SHARE_READ);

    if (Handle == NULL) {
        printf("Unable to open driver, status %08X\n", GetLastError());
        return(GetLastError());
    }

    //
    // Gather remaining params and dispatch
    //
    switch (opcode) {
        case OpcodeInit:
            status = Initialize(argv + 2, argc - 2);
            break;

        case OpcodeShutdown:
            status = ClusnetShutdown(Handle);
            break;

#if DBG
        case OpcodeSetDebugMask:
            status = SetDebugMask(argv + 2, argc - 2);
            break;

#endif // DBG

        case OpcodeAdd:
            switch(objtype) {
                case ObjTypeNode:

                    status = RegisterNode(argv + 3, argc - 3);
                    break;

                case ObjTypeNetwork:
                    status = RegisterNetwork(argv + 3, argc - 3);
                    break;

                case ObjTypeInterface:
                    status = RegisterInterface(argv + 3, argc - 3);
                    break;

                default:
                    break;

            }
            break;

        case OpcodeDelete:
            switch(objtype) {
                case ObjTypeNode:
                    status = DeregisterNode(argv + 3, argc - 3);
                    break;

                case ObjTypeNetwork:
                    status = DeregisterNetwork(argv + 3, argc - 3);
                    break;

                case ObjTypeInterface:
                    status = DeregisterInterface(argv + 3, argc - 3);
                    break;

                    default:
                    break;

            }
            break;

#if DBG
            case OpcodeOnlinePending:
                switch(objtype) {
                    case ObjTypeInterface:
                        status = OnlinePendingInterface(argv + 3, argc - 3);
                        break;

                    default:
                        break;

            }
            break;
#endif // DBG

        case OpcodeOnline:
            switch(objtype) {
                case ObjTypeNode:
                    status = OnlineNodeComm(argv + 3, argc - 3);
                    break;

                case ObjTypeNetwork:
                    status = OnlineNetwork(argv + 3, argc - 3);
                    break;
#if DBG
                case ObjTypeInterface:
                    status = OnlineInterface(argv + 3, argc - 3);
                    break;
#endif // DBG

                default:
                    break;

            }
            break;

        case OpcodeOffline:
            switch(objtype) {
                case ObjTypeNode:
                    status = OfflineNodeComm(argv + 3, argc - 3);
                    break;

                case ObjTypeNetwork:
                    status = OfflineNetwork(argv + 3, argc - 3);
                    break;

#if DBG
                case ObjTypeInterface:
                    status = OfflineInterface(argv + 3, argc - 3);
                    break;
#endif // DBG

                default:
                    break;

            }
            break;

#if DBG
        case OpcodeFail:
            switch(objtype) {
                case ObjTypeInterface:
                    status = FailInterface(argv + 3, argc - 3);
                    break;

                default:
                    break;

        }
        break;
#endif // DBG


        case OpcodeGetPriority:
            switch(objtype) {
                case ObjTypeNetwork:
                    status = GetNetworkPriority(argv + 3, argc - 3);
                    break;

                case ObjTypeInterface:
                    status = GetInterfacePriority(argv + 3, argc - 3);
                    break;

                default:
                    break;

            }
            break;

        case OpcodeSetPriority:
            switch(objtype) {
                case ObjTypeNetwork:
                    status = SetNetworkPriority(argv + 3, argc - 3);
                    break;

                case ObjTypeInterface:
                    status = SetInterfacePriority(argv + 3, argc - 3);
                    break;

                default:
                    break;

            }
            break;

        case OpcodeGetState:
            switch(objtype) {
                case ObjTypeNode:
                    status = GetNodeCommState(argv + 3, argc - 3);
                    break;
                case ObjTypeNetwork:
                    status = GetNetworkState(argv + 3, argc - 3);
                    break;

                case ObjTypeInterface:
                    status = GetInterfaceState(argv + 3, argc - 3);
                    break;

                default:
                    break;

            }
            break;

#if DBG
        case OpcodeSendMmMsg:
            status = SendMmMsg(argv + 2, argc - 2);
            break;

#ifdef MM_IN_CLUSNET
        case OpcodeMMgrForm:
            status = MMgrForm(argv + 2, argc - 2);
            break;

        case OpcodeMMgrJoin:
            status = MMgrJoin(argv + 2, argc - 2);
            break;

        case OpcodeMMgrLeave:
            status = MMgrLeave(argv + 2, argc - 2);
            break;

        case OpcodeMMgrGetMembershipState:
            status = MMgrGetMembershipState(argv + 2, argc - 2);
            break;

        case OpcodeMMgrEject:
            status = MMgrEject(argv + 2, argc - 2);
            break;

#endif // MM_IN_CLUSNET
#endif // DBG


        case OpcodeTestEvents:
            status = TestEvents(argv + 2, argc - 2);
            break;

        case OpcodeSetMemLogging:
            status = SetMemLogging(argv + 2, argc - 2);
            break;

        case OpcodeSendPoisonPacket:
            status = SendPoisonPacket(argv + 2, argc - 2);
            break;

        case OpcodeGetMulticastReachableSet:
            status = GetMulticastReachableSet(argv + 2, argc - 2);
            break;

        default:
            break;
    }

    ClusnetCloseControlChannel(Handle);

    if (status != ERROR_SUCCESS) {
        if (status == ERROR_INVALID_PARAMETER) {
            Usage();
        }
        else {
            printf("Operation failed, status 0x%08X\n", status);
        }
    }

    return(status);
}


//
// Support functions
//
void
Usage(
    void
    )
{
    printf("\n");
    printf("Usage: cntest <operation> <parameters>\n");
    printf("\n");
    printf("Operations:\n");
    printf("    init <local node id> <max nodes>\n");
    printf("    shutdown\n");
    printf("    add node <node id>\n");
    printf("    del node <node id>\n");
    printf("    add network <network id> <priority>\n");
    printf("    del network <network id>\n");
    printf("    add interface <node id> <network id> <priority> <IP address> <UDP port> [<adapter guid>]\n");
    printf("    del interface <node id> <network id>\n");
    printf("    online node <node id>\n");
    printf("    offline node <node id>\n");
    printf("    online network <network id> <xport device> <IP address> <UDP port> <adapter name>\n");
    printf("    offline network <network id>\n");
    printf("    getpri network <network id>\n");
    printf("    setpri network <network id> <priority>\n");
    printf("    getpri interface <node id> <network id>\n");
    printf("    setpri interface <node id> <network id> <priority>\n");
    printf("    getstate node <node id>\n");
    printf("    getstate network <network id>\n");
    printf("    getstate interface <node id> <network id>\n");
    printf("    memlog <# of entries - zero turns off logging>\n");

#if DBG

    printf("    setdebug <hex mask>\n");
    printf("    onpend interface <node id> <network id>\n");
    printf("    online interface <node id> <network id>\n");
    printf("    offline interface <node id> <network id>\n");
    printf("    fail interface <node id> <network id>\n");
    printf("    send <node id> <4 byte hex pattern>\n");
    printf("    events <mask>\n");

#ifdef MM_IN_CLUSNET
    printf("    mmform <node id> <clock period> <send HB rate> <recv HB rate>\n");
    printf("    mmjoin <node id> <phase #: 1-4> <join timeout>\n");
    printf("    mmleave\n");
    printf("    mmgetstate <node id>\n");
    printf("    mmeject <node id>\n");

#endif
#endif // DBG

    printf("    poison <node id> [number of poison packets]\n");
    printf("    getmcast <network id>\n");
}


DWORD
Initialize(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                   status;
    CL_NODE_ID              localNodeId;
    ULONG                   maxNodes;


    if (argc < 2) {
        return(ERROR_INVALID_PARAMETER);
    }

    localNodeId = strtoul(argv[0], NULL, 10);
    maxNodes = strtoul(argv[1], NULL, 10);

    status = ClusnetInitialize(
                 Handle,
                 localNodeId,
                 maxNodes,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL
                 );

    return(status);
}


DWORD
RegisterNode(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD              status;
    CL_NODE_ID            nodeId;
    BOOLEAN               isLocal;


    if (argc < 1) {
        return(ERROR_INVALID_PARAMETER);
    }

    nodeId = strtoul(argv[0], NULL, 10);

    status = ClusnetRegisterNode(Handle, nodeId);

    return(status);
}


DWORD
DeregisterNode(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                status;
    CL_NODE_ID              nodeId;


    if (argc < 1) {
        return(ERROR_INVALID_PARAMETER);
    }

    nodeId = strtoul(argv[0], NULL, 10);

    status = ClusnetDeregisterNode(Handle, nodeId);

    return(status);
}


DWORD
RegisterNetwork(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                   status;
    CL_NETWORK_ID              networkId;
    ULONG                      priority;


    if (argc < 2) {
        return(ERROR_INVALID_PARAMETER);
    }

    networkId = strtoul(argv[0], NULL, 10);
    priority = strtoul(argv[1], NULL, 10);

    status = ClusnetRegisterNetwork(Handle, networkId, priority, FALSE);

    return(status);
}


DWORD
DeregisterNetwork(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                   status;
    CL_NETWORK_ID              networkId;


    if (argc < 1) {
        return(ERROR_INVALID_PARAMETER);
    }

    networkId = strtoul(argv[0], NULL, 10);

    status = ClusnetDeregisterNetwork(Handle, networkId);

    return(status);
}


DWORD
RegisterInterface(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                   status;
    HANDLE                     handle;
    CL_NODE_ID                 nodeId;
    CL_NETWORK_ID              networkId;
    ULONG                      ipAddress;
    USHORT                     udpPort;
    ULONG                      tempPort;
    ULONG                      priority;
    WCHAR                      adapterId[256];
    PTRANSPORT_ADDRESS         tdiAddress = NULL;
    ULONG                      tdiAddressLength;
    ULONG                      mediaStatus;


    if (argc < 5) {
        return(ERROR_INVALID_PARAMETER);
    }

    nodeId = strtoul(argv[0], NULL, 10);
    networkId = strtoul(argv[1], NULL, 10);
    priority = strtoul(argv[2], NULL, 10);

    ipAddress = inet_addr(argv[3]);

    if (ipAddress == INADDR_NONE) {
        return(ERROR_INVALID_PARAMETER);
    }

    tempPort = strtoul(argv[4], NULL, 10);

    if (tempPort > 0xFFFF) {
        return(ERROR_INVALID_PARAMETER);
    }

    udpPort = htons((USHORT) tempPort);

    tdiAddress = BuildTdiAddressForIp(
                     ipAddress,
                     udpPort,
                     &tdiAddressLength
                     );

    if (tdiAddress == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    if (argc < 6 || strlen(argv[5]) > 255) {
        swprintf(adapterId, L"{11111111-1111-1111-1111-111111111111}");
    } else {
        swprintf(adapterId, L"%S", argv[5]);
    }

    status = ClusnetRegisterInterface(
                 Handle,
                 nodeId,
                 networkId,
                 priority,
                 adapterId,
                 wcslen(adapterId) * sizeof(WCHAR),
                 tdiAddress,
                 tdiAddressLength,
                 &mediaStatus
                 );

error_exit:

    if (tdiAddress != NULL) {
        LocalFree(tdiAddress);
    }

    return(status);
}


DWORD
DeregisterInterface(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                   status;
    CL_NODE_ID                 nodeId;
    CL_NETWORK_ID              networkId;


    if (argc < 2) {
        return(ERROR_INVALID_PARAMETER);
    }

    nodeId = strtoul(argv[0], NULL, 10);
    networkId = strtoul(argv[1], NULL, 10);

    status = ClusnetDeregisterInterface(Handle, nodeId, networkId);

    return(status);
}


DWORD
OnlineNodeComm(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                status;
    CL_NODE_ID              nodeId;


    if (argc < 1) {
        return(ERROR_INVALID_PARAMETER);
    }

    nodeId = strtoul(argv[0], NULL, 10);

    status = ClusnetOnlineNodeComm(Handle, nodeId);

    return(status);
}


DWORD
OfflineNodeComm(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                status;
    CL_NODE_ID              nodeId;


    if (argc < 1) {
        return(ERROR_INVALID_PARAMETER);
    }

    nodeId = strtoul(argv[0], NULL, 10);

    status = ClusnetOfflineNodeComm(Handle, nodeId);

    return(status);
}


DWORD
OnlineNetwork(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                 status;
    CL_NETWORK_ID            networkId;
    PWCHAR                   tdiProviderName = NULL;
    ULONG                    ipAddress;
    USHORT                   udpPort;
    ULONG                    tempPort;
    PTRANSPORT_ADDRESS       tdiBindAddress = NULL;
    ULONG                    tdiBindAddressLength;
    PWCHAR                   adapterName = NULL;
    PUCHAR                   TdiAddressInfo[1024];
    ULONG                    TdiAddressInfoSize = sizeof( TdiAddressInfo );

    if (argc < 5) {
        return(ERROR_INVALID_PARAMETER);
    }

    networkId = strtoul(argv[0], NULL, 10);

    tdiProviderName = ConvertStringToUnicode(argv[1]);

    if (tdiProviderName == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    ipAddress = inet_addr(argv[2]);

    if (ipAddress == INADDR_NONE) {
        return(ERROR_INVALID_PARAMETER);
    }

    tempPort = strtoul(argv[3], NULL, 10);

    if (tempPort > 0xFFFF) {
        return(ERROR_INVALID_PARAMETER);
    }

    udpPort = htons((USHORT) tempPort);

    adapterName = ConvertStringToUnicode(argv[4]);

    if (adapterName == NULL) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    tdiBindAddress = BuildTdiAddressForIp(
                         ipAddress,
                         udpPort,
                         &tdiBindAddressLength
                         );

    if (tdiBindAddress == NULL) {
        status = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    status = ClusnetOnlineNetwork(
                 Handle,
                 networkId,
                 tdiProviderName,
                 tdiBindAddress,
                 tdiBindAddressLength,
                 adapterName,
                 TdiAddressInfo,
                 &TdiAddressInfoSize
                 );

error_exit:

    if (tdiProviderName != NULL) {
        LocalFree(tdiProviderName);
    }

    if (tdiBindAddress != NULL) {
        LocalFree(tdiBindAddress);
    }

    return(status);
}


DWORD
OfflineNetwork(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                   status;
    CL_NETWORK_ID              networkId;


    if (argc < 1) {
        return(ERROR_INVALID_PARAMETER);
    }

    networkId = strtoul(argv[0], NULL, 10);

    status = ClusnetOfflineNetwork(Handle, networkId);

    return(status);
}


DWORD
GetNetworkPriority(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                   status;
    CL_NETWORK_ID              networkId;
    ULONG                      priority;


    if (argc < 1) {
        return(ERROR_INVALID_PARAMETER);
    }

    networkId = strtoul(argv[0], NULL, 10);

    status = ClusnetGetNetworkPriority(Handle, networkId, &priority);

    if (status == ERROR_SUCCESS) {
        printf("Network priority = %u\n", priority);
    }

    return(status);
}


DWORD
SetNetworkPriority(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                   status;
    CL_NETWORK_ID              networkId;
    ULONG                      priority;


    if (argc < 2) {
        return(ERROR_INVALID_PARAMETER);
    }

    networkId = strtoul(argv[0], NULL, 10);
    priority = strtoul(argv[1], NULL, 10);

    status = ClusnetSetNetworkPriority(Handle, networkId, priority);

    return(status);
}


DWORD
GetInterfacePriority(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                 status;
    CL_NODE_ID               nodeId;
    CL_NETWORK_ID            networkId;
    ULONG                    networkPriority;
    ULONG                    interfacePriority;


    if (argc < 2) {
        return(ERROR_INVALID_PARAMETER);
    }

    nodeId = strtoul(argv[0], NULL, 10);
    networkId = strtoul(argv[1], NULL, 10);

    status = ClusnetGetInterfacePriority(
                 Handle,
                 nodeId,
                 networkId,
                 &interfacePriority,
                 &networkPriority
                 );

    if (status == ERROR_SUCCESS) {
        printf("Interface priority = %u\n", interfacePriority);
        printf("Network priority = %u\n", networkPriority);
    }

    return(status);
}


DWORD
SetInterfacePriority(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                 status;
    CL_NODE_ID               nodeId;
    CL_NETWORK_ID            networkId;
    ULONG                    priority;


    if (argc < 3) {
        return(ERROR_INVALID_PARAMETER);
    }

    nodeId = strtoul(argv[0], NULL, 10);
    networkId = strtoul(argv[1], NULL, 10);
    priority = strtoul(argv[2], NULL, 10);

    status = ClusnetSetInterfacePriority(Handle, nodeId, networkId, priority);

    return(status);
}


DWORD
GetNodeCommState(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                 status;
    CL_NODE_ID               nodeId;
    CLUSNET_NODE_COMM_STATE  state;


    if (argc < 1) {
        return(ERROR_INVALID_PARAMETER);
    }

    nodeId = strtoul(argv[0], NULL, 10);

    status = ClusnetGetNodeCommState(
                 Handle,
                 nodeId,
                 &state
                 );

    if (status == ERROR_SUCCESS) {
        printf("State = ");

        switch(state) {
            case ClusnetNodeCommStateOffline:
                printf("Offline\n");
                break;

            case ClusnetNodeCommStateOfflinePending:
                printf("Offline Pending\n");
                break;

            case ClusnetNodeCommStateOnlinePending:
                printf("Online Pending\n");
                break;

            case ClusnetNodeCommStateOnline:
                printf("Online\n");
                break;

            case ClusnetNodeCommStateUnreachable:
                printf("Unreachable\n");
                break;

            default:
                printf("Unknown %u)\n", state);
                break;
        }
    }

    return(status);
}


DWORD
GetNetworkState(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD               status;
    CL_NETWORK_ID          networkId;
    CLUSNET_NETWORK_STATE  state;


    if (argc < 1) {
        return(ERROR_INVALID_PARAMETER);
    }

    networkId = strtoul(argv[0], NULL, 10);

    status = ClusnetGetNetworkState(
                 Handle,
                 networkId,
                 &state
                 );

    if (status == ERROR_SUCCESS) {
        printf("State = ");

        switch(state) {
            case ClusnetNetworkStateOffline:
                printf("Offline\n");
                break;

            case ClusnetNetworkStateOfflinePending:
                printf("Offline pending\n");
                break;

            case ClusnetNetworkStateOnlinePending:
                printf("Online pending\n");
                break;

            case ClusnetNetworkStateOnline:
                printf("Online\n");
                break;

            default:
                printf("Unknown %u)\n", state);
                break;
        }
    }

    return(status);
}


DWORD
GetInterfaceState(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                   status;
    CL_NODE_ID                 nodeId;
    CL_NETWORK_ID              networkId;
    CLUSNET_INTERFACE_STATE    state;


    if (argc < 2) {
        return(ERROR_INVALID_PARAMETER);
    }

    nodeId = strtoul(argv[0], NULL, 10);
    networkId = strtoul(argv[1], NULL, 10);

    status = ClusnetGetInterfaceState(
                 Handle,
                 nodeId,
                 networkId,
                 &state
                 );

    if (status == ERROR_SUCCESS) {
        printf("State = ");

        switch(state) {
            case ClusnetInterfaceStateOffline:
                printf("Offline\n");
                break;

            case ClusnetInterfaceStateOfflinePending:
                printf("Offline pending\n");
                break;

            case ClusnetInterfaceStateOnlinePending:
                printf("Online pending\n");
                break;

            case ClusnetInterfaceStateOnline:
                printf("Online\n");
                break;

            case ClusnetInterfaceStateUnreachable:
                printf("Unreachable\n");
                break;

            default:
                printf("Unknown %u)\n", state);
                break;
        }
    }

    return(status);
}

DWORD
TestEvents(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                   status;
    DWORD                   Mask;
    CLUSNET_EVENT           Event;

    if (argc < 1) {
        return(ERROR_INVALID_PARAMETER);
    }

    Mask = strtoul(argv[0], NULL, 16);

    status = ClusnetSetEventMask( Handle, Mask );

    if ( status == ERROR_SUCCESS ) {

        while ( 1 ) {

            status = ClusnetGetNextEvent( Handle, &Event, NULL );

            printf(
                "Status = %d, Event Type = %d, Node Id = %d, Network Id = %d\n",
                status, Event.EventType, Event.NodeId, Event.NetworkId );
        }
    }

    return(status);
}

DWORD
SetMemLogging(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                   status;
    DWORD                   NumEntries;

    if (argc < 1) {
        return(ERROR_INVALID_PARAMETER);
    }

    NumEntries = strtoul(argv[0], NULL, 10);

    status = ClusnetSetMemLogging( Handle, NumEntries );

    return(status);
}

#if DBG

DWORD
SetDebugMask(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD      status;
    ULONG         mask;


    if (argc < 1) {
        return(ERROR_INVALID_PARAMETER);
    }

    mask = strtoul(argv[0], NULL, 16);

    status = ClusnetSetDebugMask(Handle, mask);

    return(status);
}


DWORD
OnlinePendingInterface(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                   status;
    CL_NODE_ID                 nodeId;
    CL_NETWORK_ID              networkId;


    if (argc < 2) {
        return(ERROR_INVALID_PARAMETER);
    }

    nodeId = strtoul(argv[0], NULL, 10);
    networkId = strtoul(argv[1], NULL, 10);

    status = ClusnetOnlinePendingInterface(Handle, nodeId, networkId);

    return(status);
}


DWORD
OnlineInterface(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                   status;
    CL_NODE_ID                 nodeId;
    CL_NETWORK_ID              networkId;


    if (argc < 2) {
        return(ERROR_INVALID_PARAMETER);
    }

    nodeId = strtoul(argv[0], NULL, 10);
    networkId = strtoul(argv[1], NULL, 10);

    status = ClusnetOnlineInterface(Handle, nodeId, networkId);

    return(status);
}


DWORD
OfflineInterface(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                   status;
    CL_NODE_ID                 nodeId;
    CL_NETWORK_ID              networkId;


    if (argc < 2) {
        return(ERROR_INVALID_PARAMETER);
    }

    nodeId = strtoul(argv[0], NULL, 10);
    networkId = strtoul(argv[1], NULL, 10);

    status = ClusnetOfflineInterface(Handle, nodeId, networkId);

    return(status);
}


DWORD
FailInterface(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                   status;
    CL_NODE_ID                 nodeId;
    CL_NETWORK_ID              networkId;


    if (argc < 2) {
        return(ERROR_INVALID_PARAMETER);
    }

    nodeId = strtoul(argv[0], NULL, 10);
    networkId = strtoul(argv[1], NULL, 10);

    status = ClusnetFailInterface(Handle, nodeId, networkId);

    return(status);
}


DWORD
SendMmMsg(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                   status;
    CL_NODE_ID                 nodeId;
    ULONG                      pattern;


    if (argc < 2) {
        return(ERROR_INVALID_PARAMETER);
    }

    nodeId = strtoul(argv[0], NULL, 10);
    pattern = strtoul(argv[1], NULL, 16);

    status = ClusnetSendMmMsg(Handle, nodeId, pattern);

    return(status);
}

#ifdef MM_IN_CLUSNET
DWORD
MMgrForm(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                   status;
    CL_NODE_ID                 nodeId;
    ULONG                      ClockPeriod;
    ULONG                      SendHBRate;
    ULONG                      RecvHBRate;

    if (argc < 4) {
        return(ERROR_INVALID_PARAMETER);
    }

    nodeId = strtoul(argv[0], NULL, 10);
    ClockPeriod = strtoul(argv[1], NULL, 10);
    SendHBRate = strtoul(argv[2], NULL, 10);
    RecvHBRate = strtoul(argv[3], NULL, 10);

    status = ClusnetFormCluster(Handle, ClockPeriod, SendHBRate, RecvHBRate );

    return(status);
}

DWORD
MMgrJoin(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                   status;
    CL_NODE_ID                 nodeId;
    ULONG                      Phase;
    ULONG                      JoinTimeout;

    if (argc < 3) {
        return(ERROR_INVALID_PARAMETER);
    }

    nodeId = strtoul(argv[0], NULL, 10);
    Phase = strtoul(argv[1], NULL, 10);
    JoinTimeout = strtoul(argv[2], NULL, 10);

#if 0
    status = ClusnetJoinCluster(
                 Handle,
                 nodeId,
                 Phase,
                 JoinTimeout
                 );
#else
    status = ERROR_CALL_NOT_IMPLEMENTED;
#endif

    return(status);
}

DWORD
MMgrLeave(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                   status;

    status = ClusnetLeaveCluster( Handle );

    return(status);
}

DWORD
MMgrGetMembershipState(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                   status;
    CL_NODE_ID              nodeId;
    CLUSTER_NODE_STATE      State;

    if (argc < 1) {
        return(ERROR_INVALID_PARAMETER);
    }

    nodeId = strtoul(argv[0], NULL, 10);

    status = ClusnetGetNodeMembershipState( Handle, nodeId, &State );

    printf("Node state = ");
    switch ( State ) {
    case ClusterNodeUnavailable:
        printf( "Unavailable" );
        break;

    case ClusterNodeUp:
        printf( "Up" );
        break;

    case ClusterNodeDown:
        printf( "Down" );
        break;

    case ClusterNodePaused:
        printf( "Paused" );
        break;

    case ClusterNodeJoining:
        printf( "Joining" );
        break;

    default:
        printf( "Unknown" );
    }

    printf( "\n" );

    return(status);
}

DWORD
MMgrEject(
    IN char **  argv,
    IN int      argc
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                   status;
    CL_NODE_ID                 nodeId;

    if (argc < 1) {
        return(ERROR_INVALID_PARAMETER);
    }

    nodeId = strtoul(argv[0], NULL, 10);

    status = ClusnetEvictNode( Handle, nodeId );

    return(status);
}

#endif // MM_IN_CLUSNET
#endif // DBG


DWORD
SendPoisonPacket(
    IN char **  argv,
    IN int      argc
    )
{
    DWORD status;
    CL_NODE_ID nodeId;
    DWORD packets = 1, i;

    if (argc < 1) {
        return(ERROR_INVALID_PARAMETER);
    }

    nodeId = strtoul(argv[0], NULL, 10);

    if (argc > 1) {
        packets = strtoul(argv[1], NULL, 10);
        packets = (packets > 100) ? 100 : packets;
    }

    for (i = 0; i < packets; i++) {
        status = ClusnetSendPoisonPacket(Handle, nodeId);
        // ignore status
    }

    return(status);
}

DWORD
GetMulticastReachableSet(
    IN char **  argv,
    IN int      argc
    )
{
    DWORD status;
    CL_NETWORK_ID networkId;
    DWORD nodeScreen;

    if (argc < 1) {
        return(ERROR_INVALID_PARAMETER);
    }

    networkId = strtoul(argv[0], NULL, 10);

    status = ClusnetGetMulticastReachableSet(Handle, networkId, &nodeScreen);

    if (status == ERROR_SUCCESS) {
        printf("Multicast reachable screen for network %u: %4x.\n",
               networkId, nodeScreen
               );
    }

    return(status);
}

PWCHAR
ConvertStringToUnicode(
    PUCHAR String
    )
{
    ANSI_STRING           ansiString;
    UNICODE_STRING        unicodeString;
    DWORD              status;


    RtlInitAnsiString(&ansiString, String);
    RtlInitUnicodeString(&unicodeString, NULL);

    status = RtlAnsiStringToUnicodeString(&unicodeString, &ansiString, TRUE);

    if (!NT_SUCCESS(status)) {
        return(NULL);
    }

    return(unicodeString.Buffer);
}


PTRANSPORT_ADDRESS
BuildTdiAddressForIp(
    IN  ULONG     Address,
    IN  USHORT    Port,
    OUT PULONG    TdiAddressLength
    )
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if the operation was successful.
    A Windows error code otherwise.

--*/
{
    DWORD                   status;
    PTA_IP_ADDRESS             taIpAddress;


    taIpAddress = LocalAlloc(LMEM_FIXED, sizeof(TA_IP_ADDRESS));

    if (taIpAddress == NULL) {
        return(NULL);
    }

    ZeroMemory(taIpAddress, sizeof(TA_IP_ADDRESS));

    taIpAddress->TAAddressCount = 1;
    taIpAddress->Address[0].AddressLength = sizeof(TDI_ADDRESS_IP);
    taIpAddress->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
    taIpAddress->Address[0].Address[0].in_addr = Address;
    taIpAddress->Address[0].Address[0].sin_port = Port;

    *TdiAddressLength = sizeof(TA_IP_ADDRESS);

    return((PTRANSPORT_ADDRESS) taIpAddress);
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\wshclus\wshclus.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    wshclus.c

Abstract:

    This module contains necessary routines for the Cluster Transport
    Windows Sockets Helper DLL.  This DLL provides the transport-specific
    support necessary for the Windows Sockets DLL to use the Cluster
    Transport.

    This file is largely a clone of the TCP/IP helper code.

Author:

    Mike Massa (mikemas)    21-Feb-1997

Revision History:

--*/

#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <ctype.h>
#include <wchar.h>
#include <tdi.h>
#include <winsock2.h>
#include <wsahelp.h>
#include <ws2spi.h>
#include <basetyps.h>
#include <nspapi.h>
#include <nspapip.h>
#include <wsclus.h>
#include <clustdi.h>
#include <clusdef.h>
#include <ntddcnet.h>


#define CDP_NAME L"CDP"

#define IS_DGRAM_SOCK(type)  ((type) == SOCK_DGRAM)

//
// Define valid flags for WSHOpenSocket2().
//

#define VALID_CDP_FLAGS         (WSA_FLAG_OVERLAPPED)

//
// Structure and variables to define the triples supported by the
// Cluster Transport. The first entry of each array is considered
// the canonical triple for that socket type; the other entries are
// synonyms for the first.
//

typedef struct _MAPPING_TRIPLE {
    INT AddressFamily;
    INT SocketType;
    INT Protocol;
} MAPPING_TRIPLE, *PMAPPING_TRIPLE;

MAPPING_TRIPLE CdpMappingTriples[] =
                   { AF_CLUSTER,   SOCK_DGRAM,  CLUSPROTO_CDP,
                     AF_CLUSTER,   SOCK_DGRAM,  0,
                     AF_CLUSTER,   0,           CLUSPROTO_CDP,
                     AF_UNSPEC,    0,           CLUSPROTO_CDP,
                     AF_UNSPEC,    SOCK_DGRAM,  CLUSPROTO_CDP
                   };

//
// Winsock 2 WSAPROTOCOL_INFO structures for all supported protocols.
//

#define WINSOCK_SPI_VERSION 2
#define CDP_MESSAGE_SIZE    (65535-20-68)

WSAPROTOCOL_INFOW Winsock2Protocols[] =
    {
        //
        // CDP
        //

        {
            XP1_CONNECTIONLESS                      // dwServiceFlags1
                | XP1_MESSAGE_ORIENTED
                | XP1_IFS_HANDLES,
            0,                                      // dwServiceFlags2
            0,                                      // dwServiceFlags3
            0,                                      // dwServiceFlags4
            PFL_MATCHES_PROTOCOL_ZERO               // dwProviderFlags
                | PFL_HIDDEN,
            {                                       // gProviderId
                0, 0, 0,
                { 0, 0, 0, 0, 0, 0, 0, 0 }
            },
            0,                                      // dwCatalogEntryId
            {                                       // ProtocolChain
                BASE_PROTOCOL,                          // ChainLen
                { 0, 0, 0, 0, 0, 0, 0 }                 // ChainEntries
            },
            WINSOCK_SPI_VERSION,                    // iVersion
            AF_CLUSTER,                             // iAddressFamily
            sizeof(SOCKADDR_CLUSTER),               // iMaxSockAddr
            sizeof(SOCKADDR_CLUSTER),               // iMinSockAddr
            SOCK_DGRAM,                             // iSocketType
            CLUSPROTO_CDP,                          // iProtocol
            0,                                      // iProtocolMaxOffset
            LITTLEENDIAN,                              // iNetworkByteOrder
            SECURITY_PROTOCOL_NONE,                 // iSecurityScheme
            CDP_MESSAGE_SIZE,                       // dwMessageSize
            0,                                      // dwProviderReserved
            L"MSAFD Cluster Datagram Protocol"      // szProtocol
        }

    };

#define NUM_WINSOCK2_PROTOCOLS  \
            ( sizeof(Winsock2Protocols) / sizeof(Winsock2Protocols[0]) )

//
// The GUID identifying this provider.
//

GUID ClusnetProviderGuid = { /* 03614682-8c42-11d0-a8fc-00a0c9062993 */
    0x03614682,
    0x8c42,
    0x11d0,
    {0x00, 0xa0, 0xc9, 0x06, 0x29, 0x93, 0x8c}
    };

LPWSTR ClusnetProviderName = L"ClusNet";

//
// Forward declarations of internal routines.
//

BOOLEAN
IsTripleInList (
    IN PMAPPING_TRIPLE List,
    IN ULONG ListLength,
    IN INT AddressFamily,
    IN INT SocketType,
    IN INT Protocol
    );

NTSTATUS
DoNtIoctl(
    HANDLE     Handle,
    DWORD      IoctlCode,
    PVOID      Request,
    DWORD      RequestSize,
    PVOID      Response,
    PDWORD     ResponseSize
    );


//
// The socket context structure for this DLL.  Each open ClusNet socket
// will have one of these context structures, which is used to maintain
// information about the socket.
//

typedef struct _WSHSOCKET_CONTEXT {
    INT     AddressFamily;
    INT     SocketType;
    INT     Protocol;
    INT     ReceiveBufferSize;
    DWORD   Flags;
    BOOLEAN IgnoreNodeState;
} WSHSOCKET_CONTEXT, *PWSHSOCKET_CONTEXT;

#define DEFAULT_RECEIVE_BUFFER_SIZE 8192



BOOLEAN
DllInitialize (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PVOID Context OPTIONAL
    )
{

    switch ( Reason ) {

    case DLL_PROCESS_ATTACH:

        //
        // We don't need to receive thread attach and detach
        // notifications, so disable them to help application
        // performance.
        //

        DisableThreadLibraryCalls( DllHandle );

        return TRUE;

    case DLL_THREAD_ATTACH:

        break;

    case DLL_PROCESS_DETACH:

        break;

    case DLL_THREAD_DETACH:

        break;
    }

    return TRUE;

} // DllInitialize



INT
WSHGetSockaddrType (
    IN PSOCKADDR Sockaddr,
    IN DWORD SockaddrLength,
    OUT PSOCKADDR_INFO SockaddrInfo
    )

/*++

Routine Description:

    This routine parses a sockaddr to determine the type of the
    machine address and endpoint address portions of the sockaddr.
    This is called by the winsock DLL whenever it needs to interpret
    a sockaddr.

Arguments:

    Sockaddr - a pointer to the sockaddr structure to evaluate.

    SockaddrLength - the number of bytes in the sockaddr structure.

    SockaddrInfo - a pointer to a structure that will receive information
        about the specified sockaddr.


Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    UNALIGNED SOCKADDR_CLUSTER *sockaddr = (PSOCKADDR_CLUSTER)Sockaddr;
    ULONG i;


    //
    // Make sure that the address family is correct.
    //

    if ( sockaddr->sac_family != AF_CLUSTER ) {
        return WSAEAFNOSUPPORT;
    }

    //
    // Make sure that the length is correct.
    //

    if ( SockaddrLength < sizeof(SOCKADDR_CLUSTER) ) {
        return WSAEFAULT;
    }

    //
    // The address passed the tests, looks like a good address.
    // Determine the type of the address portion of the sockaddr.
    //

    if ( sockaddr->sac_node == CLUSADDR_ANY ) {
        SockaddrInfo->AddressInfo = SockaddrAddressInfoWildcard;
    } else {
        SockaddrInfo->AddressInfo = SockaddrAddressInfoNormal;
    }

    //
    // Determine the type of the port (endpoint) in the sockaddr.
    //

    if ( sockaddr->sac_port == 0 ) {
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoWildcard;
    } else {
        SockaddrInfo->EndpointInfo = SockaddrEndpointInfoNormal;
    }

    //
    // Zero out the sin_reserved_mbz part of the address.  We silently allow
    // nonzero values in this field.
    //

    sockaddr->sac_zero = 0;

    return NO_ERROR;

} // WSHGetSockaddrType


INT
WSHGetSocketInformation (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN INT Level,
    IN INT OptionName,
    OUT PCHAR OptionValue,
    OUT PINT OptionLength
    )

/*++

Routine Description:

    This routine retrieves information about a socket for those socket
    options supported in this helper DLL.  This routine is
    called by the winsock DLL when a level/option name combination is
    passed to getsockopt() that the winsock DLL does not understand.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're getting
        information.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    Level - the level parameter passed to getsockopt().

    OptionName - the optname parameter passed to getsockopt().

    OptionValue - the optval parameter passed to getsockopt().

    OptionLength - the optlen parameter passed to getsockopt().

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHSOCKET_CONTEXT context = HelperDllSocketContext;

    UNREFERENCED_PARAMETER( SocketHandle );
    UNREFERENCED_PARAMETER( TdiAddressObjectHandle );
    UNREFERENCED_PARAMETER( TdiConnectionObjectHandle );


    return WSAENOPROTOOPT;

} // WSHGetSocketInformation


INT
WSHGetWildcardSockaddr (
    IN PVOID HelperDllSocketContext,
    OUT PSOCKADDR Sockaddr,
    OUT PINT SockaddrLength
    )

/*++

Routine Description:

    This routine returns a wildcard socket address.  A wildcard address
    is one which will bind the socket to an endpoint of the transport's
    choosing.  For the Cluster Network, a wildcard address has
    node ID == 0 and port = 0.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket() for the socket for which we need a wildcard
        address.

    Sockaddr - points to a buffer which will receive the wildcard socket
        address.

    SockaddrLength - receives the length of the wioldcard sockaddr.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PSOCKADDR_CLUSTER   ClusAddr = (PSOCKADDR_CLUSTER) Sockaddr;


    if ( *SockaddrLength < sizeof(SOCKADDR_CLUSTER) ) {
        return WSAEFAULT;
    }

    *SockaddrLength = sizeof(SOCKADDR_CLUSTER);

    ClusAddr->sac_family = AF_CLUSTER;
    ClusAddr->sac_port = 0;
    ClusAddr->sac_node = CLUSADDR_ANY;
    ClusAddr->sac_zero = 0;

    return NO_ERROR;

} // WSAGetWildcardSockaddr


DWORD
WSHGetWinsockMapping (
    OUT PWINSOCK_MAPPING Mapping,
    IN DWORD MappingLength
    )

/*++

Routine Description:

    Returns the list of address family/socket type/protocol triples
    supported by this helper DLL.

Arguments:

    Mapping - receives a pointer to a WINSOCK_MAPPING structure that
        describes the triples supported here.

    MappingLength - the length, in bytes, of the passed-in Mapping buffer.

Return Value:

    DWORD - the length, in bytes, of a WINSOCK_MAPPING structure for this
        helper DLL.  If the passed-in buffer is too small, the return
        value will indicate the size of a buffer needed to contain
        the WINSOCK_MAPPING structure.

--*/

{
    DWORD mappingLength;


    mappingLength = FIELD_OFFSET(WINSOCK_MAPPING, Mapping[0])
                        + sizeof(CdpMappingTriples);

    //
    // If the passed-in buffer is too small, return the length needed
    // now without writing to the buffer.  The caller should allocate
    // enough memory and call this routine again.
    //

    if ( mappingLength > MappingLength ) {
        return mappingLength;
    }

    //
    // Fill in the output mapping buffer with the list of triples
    // supported in this helper DLL.
    //

    Mapping->Rows = sizeof(CdpMappingTriples) / sizeof(CdpMappingTriples[0]);
    Mapping->Columns = sizeof(MAPPING_TRIPLE) / sizeof(DWORD);

    RtlMoveMemory(
        Mapping->Mapping,
        CdpMappingTriples,
        sizeof(CdpMappingTriples)
        );

    //
    // Return the number of bytes we wrote.
    //

    return mappingLength;

} // WSHGetWinsockMapping


INT
WSHOpenSocket (
    IN OUT PINT AddressFamily,
    IN OUT PINT SocketType,
    IN OUT PINT Protocol,
    OUT PUNICODE_STRING TransportDeviceName,
    OUT PVOID *HelperDllSocketContext,
    OUT PDWORD NotificationEvents
    )
{

    return WSHOpenSocket2(
               AddressFamily,
               SocketType,
               Protocol,
               0,           // Group
               0,           // Flags
               TransportDeviceName,
               HelperDllSocketContext,
               NotificationEvents
               );

} // WSHOpenSocket


INT
WSHOpenSocket2 (
    IN OUT PINT AddressFamily,
    IN OUT PINT SocketType,
    IN OUT PINT Protocol,
    IN GROUP Group,
    IN DWORD Flags,
    OUT PUNICODE_STRING TransportDeviceName,
    OUT PVOID *HelperDllSocketContext,
    OUT PDWORD NotificationEvents
    )

/*++

Routine Description:

    Does the necessary work for this helper DLL to open a socket and is
    called by the winsock DLL in the socket() routine.  This routine
    verifies that the specified triple is valid, determines the NT
    device name of the TDI provider that will support that triple,
    allocates space to hold the socket's context block, and
    canonicalizes the triple.

Arguments:

    AddressFamily - on input, the address family specified in the
        socket() call.  On output, the canonicalized value for the
        address family.

    SocketType - on input, the socket type specified in the socket()
        call.  On output, the canonicalized value for the socket type.

    Protocol - on input, the protocol specified in the socket() call.
        On output, the canonicalized value for the protocol.

    Group - Identifies the group for the new socket.

    Flags - Zero or more WSA_FLAG_* flags as passed into WSASocket().

    TransportDeviceName - receives the name of the TDI provider that
        will support the specified triple.

    HelperDllSocketContext - receives a context pointer that the winsock
        DLL will return to this helper DLL on future calls involving
        this socket.

    NotificationEvents - receives a bitmask of those state transitions
        this helper DLL should be notified on.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHSOCKET_CONTEXT context;


    if ( IsTripleInList(
             CdpMappingTriples,
             sizeof(CdpMappingTriples) / sizeof(CdpMappingTriples[0]),
             *AddressFamily,
             *SocketType,
             *Protocol ) ) {

        //
        // It's a CDP socket. Check the flags.
        //

        if( (Flags & ~VALID_CDP_FLAGS ) != 0) {

            return WSAEINVAL;

        }

        //
        // Return the canonical form of a CDP socket triple.
        //

        *AddressFamily = CdpMappingTriples[0].AddressFamily;
        *SocketType = CdpMappingTriples[0].SocketType;
        *Protocol = CdpMappingTriples[0].Protocol;

        //
        // Indicate the name of the TDI device that will service
        // SOCK_DGRAM sockets in the cluster address family.
        //

        RtlInitUnicodeString( TransportDeviceName, DD_CDP_DEVICE_NAME );

    } else {

        //
        // This should never happen if the registry information about this
        // helper DLL is correct.  If somehow this did happen, just return
        // an error.
        //

        return WSAEINVAL;
    }

    //
    // Allocate context for this socket.  The Windows Sockets DLL will
    // return this value to us when it asks us to get/set socket options.
    //

    context = RtlAllocateHeap( RtlProcessHeap( ), 0, sizeof(*context) );

    if ( context == NULL ) {
        return WSAENOBUFS;
    }

    //
    // Initialize the context for the socket.
    //

    context->AddressFamily = *AddressFamily;
    context->SocketType = *SocketType;
    context->Protocol = *Protocol;
    context->ReceiveBufferSize = DEFAULT_RECEIVE_BUFFER_SIZE;
    context->Flags = Flags;
    context->IgnoreNodeState = FALSE;

    //
    // Tell the Windows Sockets DLL which state transitions we're
    // interested in being notified of.

    if (*SocketType == SOCK_DGRAM) {

        *NotificationEvents = WSH_NOTIFY_CLOSE | WSH_NOTIFY_BIND;
    }

    //
    // Everything worked, return success.
    //

    *HelperDllSocketContext = context;
    return NO_ERROR;

} // WSHOpenSocket2


INT
WSHNotify (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN DWORD NotifyEvent
    )

/*++

Routine Description:

    This routine is called by the winsock DLL after a state transition
    of the socket.  Only state transitions returned in the
    NotificationEvents parameter of WSHOpenSocket() are notified here.
    This routine allows a winsock helper DLL to track the state of
    socket and perform necessary actions corresponding to state
    transitions.

Arguments:

    HelperDllSocketContext - the context pointer given to the winsock
        DLL by WSHOpenSocket().

    SocketHandle - the handle for the socket.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    NotifyEvent - indicates the state transition for which we're being
        called.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHSOCKET_CONTEXT context = HelperDllSocketContext;
    INT err;


    if ( NotifyEvent == WSH_NOTIFY_CLOSE ) {

        //
        // Free the socket context.
        //
        RtlFreeHeap( RtlProcessHeap( ), 0, context );

    } else if ( NotifyEvent == WSH_NOTIFY_BIND ) {
        ULONG true = TRUE;

        if ( context->IgnoreNodeState ) {
            ULONG     responseSize = 0;
            NTSTATUS  status;


            status = DoNtIoctl(
                         TdiAddressObjectHandle,
                         IOCTL_CX_IGNORE_NODE_STATE,
                         NULL,
                         0,
                         NULL,
                         &responseSize
                         );

            if( !NT_SUCCESS(status)) {
                return(WSAENOPROTOOPT);   // SWAG
            }
        }
    }
    else {
        return WSAEINVAL;
    }

    return NO_ERROR;

} // WSHNotify


INT
WSHSetSocketInformation (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN INT Level,
    IN INT OptionName,
    IN PCHAR OptionValue,
    IN INT OptionLength
    )

/*++

Routine Description:

    This routine sets information about a socket for those socket
    options supported in this helper DLL.  This routine is
    called by the winsock DLL when a level/option name combination is
    passed to setsockopt() that the winsock DLL does not understand.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're getting
        information.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    Level - the level parameter passed to setsockopt().

    OptionName - the optname parameter passed to setsockopt().

    OptionValue - the optval parameter passed to setsockopt().

    OptionLength - the optlen parameter passed to setsockopt().

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{
    PWSHSOCKET_CONTEXT context = HelperDllSocketContext;
    INT error;
    INT optionValue;


    UNREFERENCED_PARAMETER( SocketHandle );
    UNREFERENCED_PARAMETER( TdiAddressObjectHandle );
    UNREFERENCED_PARAMETER( TdiConnectionObjectHandle );

    //
    // Check if this is an internal request for context information.
    //

    if ( Level == SOL_INTERNAL && OptionName == SO_CONTEXT ) {

        //
        // The Windows Sockets DLL is requesting that we set context
        // information for a new socket.  If the new socket was
        // accept()'ed, then we have already been notified of the socket
        // and HelperDllSocketContext will be valid.  If the new socket
        // was inherited or duped into this process, then this is our
        // first notification of the socket and HelperDllSocketContext
        // will be equal to NULL.
        //
        // Insure that the context information being passed to us is
        // sufficiently large.
        //

        if ( OptionLength < sizeof(*context) ) {
            return WSAEINVAL;
        }

        if ( HelperDllSocketContext == NULL ) {

            //
            // This is our notification that a socket handle was
            // inherited or duped into this process.  Allocate a context
            // structure for the new socket.
            //

            context = RtlAllocateHeap(
                          RtlProcessHeap( ),
                          0,
                          sizeof(*context)
                          );

            if ( context == NULL ) {
                return WSAENOBUFS;
            }

            //
            // Copy over information into the context block.
            //

            RtlCopyMemory( context, OptionValue, sizeof(*context) );

            //
            // Tell the Windows Sockets DLL where our context information is
            // stored so that it can return the context pointer in future
            // calls.
            //

            *(PWSHSOCKET_CONTEXT *)OptionValue = context;

            return NO_ERROR;

        }
    }

    return WSAENOPROTOOPT;

} // WSHSetSocketInformation


INT
WSHEnumProtocols (
    IN LPINT lpiProtocols,
    IN LPWSTR lpTransportKeyName,
    IN OUT LPVOID lpProtocolBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Enumerates the protocols supported by this helper.

Arguments:

    lpiProtocols - Pointer to a NULL-terminated array of protocol
        identifiers. Only protocols specified in this array will
        be returned by this function. If this pointer is NULL,
        all protocols are returned.

    lpTransportKeyName -

    lpProtocolBuffer - Pointer to a buffer to fill with PROTOCOL_INFO
        structures.

    lpdwBufferLength - Pointer to a variable that, on input, contains
        the size of lpProtocolBuffer. On output, this value will be
        updated with the size of the data actually written to the buffer.

Return Value:

    INT - The number of protocols returned if successful, -1 if not.

--*/

{
    DWORD bytesRequired;
    PPROTOCOL_INFO CdpProtocolInfo;
    BOOL useCdp = FALSE;
    DWORD i;


    UNREFERENCED_PARAMETER(lpTransportKeyName);


    //
    // Make sure that the caller cares about CDP.
    //

    if ( ARGUMENT_PRESENT( lpiProtocols ) ) {

        for ( i = 0; lpiProtocols[i] != 0; i++ ) {
            if ( lpiProtocols[i] == CLUSPROTO_CDP ) {
                useCdp = TRUE;
            }
        }

    } else {

        useCdp = TRUE;
    }

    if ( !useCdp ) {
        *lpdwBufferLength = 0;
        return 0;
    }

    //
    // Make sure that the caller has specified a sufficiently large
    // buffer.
    //

    bytesRequired = (DWORD)((sizeof(PROTOCOL_INFO) * 1) +
                        ( (wcslen( CDP_NAME ) + 1) * sizeof(WCHAR)));

    if ( bytesRequired > *lpdwBufferLength ) {
        *lpdwBufferLength = bytesRequired;
        return -1;
    }

    //
    // Fill in CDP info, if requested.
    //

    if ( useCdp ) {

        CdpProtocolInfo = lpProtocolBuffer;
        CdpProtocolInfo->lpProtocol = (LPWSTR)
            ( (PBYTE)lpProtocolBuffer + *lpdwBufferLength -
                ( (wcslen( CDP_NAME ) + 1) * sizeof(WCHAR) ) );
        CdpProtocolInfo->dwServiceFlags = XP_CONNECTIONLESS |
                                              XP_MESSAGE_ORIENTED;
        CdpProtocolInfo->iAddressFamily = AF_CLUSTER;
        CdpProtocolInfo->iMaxSockAddr = sizeof(SOCKADDR_CLUSTER);
        CdpProtocolInfo->iMinSockAddr = sizeof(SOCKADDR_CLUSTER);
        CdpProtocolInfo->iSocketType = SOCK_DGRAM;
        CdpProtocolInfo->iProtocol = CLUSPROTO_CDP;
        CdpProtocolInfo->dwMessageSize = CDP_MESSAGE_SIZE;
        wcscpy( CdpProtocolInfo->lpProtocol, CDP_NAME );
    }

    *lpdwBufferLength = bytesRequired;

    return 1;

} // WSHEnumProtocols



BOOLEAN
IsTripleInList (
    IN PMAPPING_TRIPLE List,
    IN ULONG ListLength,
    IN INT AddressFamily,
    IN INT SocketType,
    IN INT Protocol
    )

/*++

Routine Description:

    Determines whether the specified triple has an exact match in the
    list of triples.

Arguments:

    List - a list of triples (address family/socket type/protocol) to
        search.

    ListLength - the number of triples in the list.

    AddressFamily - the address family to look for in the list.

    SocketType - the socket type to look for in the list.

    Protocol - the protocol to look for in the list.

Return Value:

    BOOLEAN - TRUE if the triple was found in the list, false if not.

--*/

{
    ULONG i;


    //
    // Walk through the list searching for an exact match.
    //

    for ( i = 0; i < ListLength; i++ ) {

        //
        // If all three elements of the triple match, return indicating
        // that the triple did exist in the list.
        //

        if ( AddressFamily == List[i].AddressFamily &&
             SocketType == List[i].SocketType &&
             Protocol == List[i].Protocol
           ) {
            return TRUE;
        }
    }

    //
    // The triple was not found in the list.
    //

    return FALSE;

} // IsTripleInList


#if 0



INT
WINAPI
WSHGetBroadcastSockaddr (
    IN PVOID HelperDllSocketContext,
    OUT PSOCKADDR Sockaddr,
    OUT PINT SockaddrLength
    )

/*++

Routine Description:

    This routine returns a broadcast socket address.  A broadcast address
    may be used as a destination for the sendto() API to send a datagram
    to all interested clients.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket() for the socket for which we need a broadcast
        address.

    Sockaddr - points to a buffer which will receive the broadcast socket
        address.

    SockaddrLength - receives the length of the broadcast sockaddr.

Return Value:

    INT - a winsock error code indicating the status of the operation, or
        NO_ERROR if the operation succeeded.

--*/

{

    LPSOCKADDR_CLUSTER addr;

    if( *SockaddrLength < sizeof(SOCKADDR_CLUSTER) ) {

        return WSAEFAULT;

    }

    *SockaddrLength = sizeof(SOCKADDR_CLUSTER);

    //
    // Build the broadcast address.
    //

    addr = (LPSOCKADDR_CLUSTER)Sockaddr;

    RtlZeroMemory( addr, sizeof(*addr));

    addr->sac_family = AF_CLUSTER;
    addr->sac_node = CLUSADDR_BROADCAST;

    return NO_ERROR;

} // WSAGetBroadcastSockaddr

#endif // 0


INT
WINAPI
WSHGetWSAProtocolInfo (
    IN LPWSTR ProviderName,
    OUT LPWSAPROTOCOL_INFOW * ProtocolInfo,
    OUT LPDWORD ProtocolInfoEntries
    )

/*++

Routine Description:

    Retrieves a pointer to the WSAPROTOCOL_INFOW structure(s) describing
    the protocol(s) supported by this helper.

Arguments:

    ProviderName - Contains the name of the provider, such as "TcpIp".

    ProtocolInfo - Receives a pointer to the WSAPROTOCOL_INFOW array.

    ProtocolInfoEntries - Receives the number of entries in the array.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    if( ProviderName == NULL ||
        ProtocolInfo == NULL ||
        ProtocolInfoEntries == NULL ) {

        return WSAEFAULT;

    }

    if( _wcsicmp( ProviderName, ClusnetProviderName ) == 0 ) {

        *ProtocolInfo = Winsock2Protocols;
        *ProtocolInfoEntries = NUM_WINSOCK2_PROTOCOLS;

        return NO_ERROR;

    }

    return WSAEINVAL;

} // WSHGetWSAProtocolInfo


INT
WINAPI
WSHAddressToString (
    IN LPSOCKADDR Address,
    IN INT AddressLength,
    IN LPWSAPROTOCOL_INFOW ProtocolInfo,
    OUT LPWSTR AddressString,
    IN OUT LPDWORD AddressStringLength
    )

/*++

Routine Description:

    Converts a SOCKADDR to a human-readable form.

Arguments:

    Address - The SOCKADDR to convert.

    AddressLength - The length of Address.

    ProtocolInfo - The WSAPROTOCOL_INFOW for a particular provider.

    AddressString - Receives the formatted address string.

    AddressStringLength - On input, contains the length of AddressString.
        On output, contains the number of characters actually written
        to AddressString.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    WCHAR string[32];
    INT length;
    LPSOCKADDR_CLUSTER addr;

    //
    // Quick sanity checks.
    //

    if( Address == NULL ||
        AddressLength < sizeof(SOCKADDR_CLUSTER) ||
        AddressString == NULL ||
        AddressStringLength == NULL ) {

        return WSAEFAULT;

    }

    addr = (LPSOCKADDR_CLUSTER)Address;

    if( addr->sac_family != AF_CLUSTER ) {

        return WSAEINVAL;

    }

    //
    // Do the converstion.
    //

    length = wsprintfW(string, L"%u", addr->sac_node);
    length += wsprintfW(string + length, L":%u", addr->sac_port);

    length++;   // account for terminator

    if( *AddressStringLength < (DWORD)length ) {

        return WSAEFAULT;

    }

    *AddressStringLength = (DWORD)length;

    RtlCopyMemory(
        AddressString,
        string,
        length * sizeof(WCHAR)
        );

    return NO_ERROR;

} // WSHAddressToString


INT
WINAPI
WSHStringToAddress (
    IN LPWSTR AddressString,
    IN DWORD AddressFamily,
    IN LPWSAPROTOCOL_INFOW ProtocolInfo,
    OUT LPSOCKADDR Address,
    IN OUT LPINT AddressLength
    )

/*++

Routine Description:

    Fills in a SOCKADDR structure by parsing a human-readable string.

Arguments:

    AddressString - Points to the zero-terminated human-readable string.

    AddressFamily - The address family to which the string belongs.

    ProtocolInfo - The WSAPROTOCOL_INFOW for a particular provider.

    Address - Receives the SOCKADDR structure.

    AddressLength - On input, contains the length of Address. On output,
        contains the number of bytes actually written to Address.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{
    LPWSTR terminator;
    WCHAR ch;
    USHORT base;
    USHORT port;
    ULONG node;
    LPSOCKADDR_CLUSTER addr;

    //
    // Quick sanity checks.
    //

    if( AddressString == NULL ||
        *AddressString == UNICODE_NULL ||
        Address == NULL ||
        AddressLength == NULL ||
        *AddressLength < sizeof(SOCKADDR_CLUSTER) ) {

        return WSAEFAULT;

    }

    if( AddressFamily != AF_CLUSTER ) {

        return WSAEINVAL;

    }

    //
    // Convert it. The format is node:port
    //

    node = 0;
    base = 10;
    terminator = AddressString;

    if( *terminator == L'0' ) {
        base = 8;
        terminator++;

        if( *terminator == UNICODE_NULL ) {
            return(WSAEINVAL);
        }

        if ( *terminator == L'x' ) {
            base = 16;
            terminator++;
        }
    }

    while( (ch = *terminator++) != L':' ) {
        if( iswdigit(ch) ) {
            node = ( node * base ) + ( ch - L'0' );
        } else if( base == 16 && iswxdigit(ch) ) {
            node = ( node << 4 );
            node += ch + 10 - ( iswlower(ch) ? L'a' : L'A' );
        } else {
            return WSAEINVAL;
        }
    }

    port = 0;
    base = 10;

    if( *terminator == L'0' ) {
        base = 8;
        terminator++;

        if( *terminator == UNICODE_NULL ) {
            return(WSAEINVAL);
        }

        if( *terminator == L'x' ) {
            base = 16;
            terminator++;
        }
    }

    while( (ch = *terminator++) != UNICODE_NULL ) {
        if( iswdigit(ch) ) {
            port = ( port * base ) + ( ch - L'0' );
        } else if( base == 16 && iswxdigit(ch) ) {
            port = ( port << 4 );
            port += ch + 10 - ( iswlower(ch) ? L'a' : L'A' );
        } else {
            return WSAEINVAL;
        }
    }

    //
    // Build the address.
    //

    RtlZeroMemory(
        Address,
        sizeof(SOCKADDR_CLUSTER)
        );

    addr = (LPSOCKADDR_CLUSTER)Address;
    *AddressLength = sizeof(SOCKADDR_CLUSTER);

    addr->sac_family = AF_CLUSTER;
    addr->sac_port = port;
    addr->sac_node = node;

    return NO_ERROR;

} // WSHStringToAddress


INT
WINAPI
WSHGetProviderGuid (
    IN LPWSTR ProviderName,
    OUT LPGUID ProviderGuid
    )

/*++

Routine Description:

    Returns the GUID identifying the protocols supported by this helper.

Arguments:

    ProviderName - Contains the name of the provider, such as "TcpIp".

    ProviderGuid - Points to a buffer that receives the provider's GUID.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    if( ProviderName == NULL ||
        ProviderGuid == NULL ) {

        return WSAEFAULT;

    }

    if( _wcsicmp( ProviderName, ClusnetProviderName ) == 0 ) {

        RtlCopyMemory(
            ProviderGuid,
            &ClusnetProviderGuid,
            sizeof(GUID)
            );

        return NO_ERROR;

    }

    return WSAEINVAL;

} // WSHGetProviderGuid

INT
WINAPI
WSHIoctl (
    IN PVOID HelperDllSocketContext,
    IN SOCKET SocketHandle,
    IN HANDLE TdiAddressObjectHandle,
    IN HANDLE TdiConnectionObjectHandle,
    IN DWORD IoControlCode,
    IN LPVOID InputBuffer,
    IN DWORD InputBufferLength,
    IN LPVOID OutputBuffer,
    IN DWORD OutputBufferLength,
    OUT LPDWORD NumberOfBytesReturned,
    IN LPWSAOVERLAPPED Overlapped,
    IN LPWSAOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine,
    OUT LPBOOL NeedsCompletion
    )

/*++

Routine Description:

    Performs queries & controls on the socket. This is basically an
    "escape hatch" for IOCTLs not supported by MSAFD.DLL. Any unknown
    IOCTLs are routed to the socket's helper DLL for protocol-specific
    processing.

Arguments:

    HelperDllSocketContext - the context pointer returned from
        WSHOpenSocket().

    SocketHandle - the handle of the socket for which we're controlling.

    TdiAddressObjectHandle - the TDI address object of the socket, if
        any.  If the socket is not yet bound to an address, then
        it does not have a TDI address object and this parameter
        will be NULL.

    TdiConnectionObjectHandle - the TDI connection object of the socket,
        if any.  If the socket is not yet connected, then it does not
        have a TDI connection object and this parameter will be NULL.

    IoControlCode - Control code of the operation to perform.

    InputBuffer - Address of the input buffer.

    InputBufferLength - The length of InputBuffer.

    OutputBuffer - Address of the output buffer.

    OutputBufferLength - The length of OutputBuffer.

    NumberOfBytesReturned - Receives the number of bytes actually written
        to the output buffer.

    Overlapped - Pointer to a WSAOVERLAPPED structure for overlapped
        operations.

    CompletionRoutine - Pointer to a completion routine to call when
        the operation is completed.

    NeedsCompletion - WSAIoctl() can be overlapped, with all the gory
        details that involves, such as setting events, queuing completion
        routines, and posting to IO completion ports. Since the majority
        of the IOCTL codes can be completed quickly "in-line", MSAFD.DLL
        can optionally perform the overlapped completion of the operation.

        Setting *NeedsCompletion to TRUE (the default) causes MSAFD.DLL
        to handle all of the IO completion details iff this is an
        overlapped operation on an overlapped socket.

        Setting *NeedsCompletion to FALSE tells MSAFD.DLL to take no
        further action because the helper DLL will perform any necessary
        IO completion.

        Note that if a helper performs its own IO completion, the helper
        is responsible for maintaining the "overlapped" mode of the socket
        at socket creation time and NOT performing overlapped IO completion
        on non-overlapped sockets.

Return Value:

    INT - 0 if successful, WinSock error code if not.

--*/

{

    PWSHSOCKET_CONTEXT context = HelperDllSocketContext;
    INT err;
    NTSTATUS status;


    //
    // Quick sanity checks.
    //

    if( HelperDllSocketContext == NULL ||
        SocketHandle == INVALID_SOCKET ||
        NeedsCompletion == NULL ) {

        return WSAEINVAL;

    }

    *NeedsCompletion = TRUE;

    switch( IoControlCode ) {

    case SIO_CLUS_IGNORE_NODE_STATE :
        //
        // This option is only valid for datagram sockets.
        //
        if ( !IS_DGRAM_SOCK(context->SocketType) ) {
            return WSAENOPROTOOPT;
        }

        if( TdiAddressObjectHandle != NULL ) {
            ULONG     responseSize = 0;
            NTSTATUS  status;


            status = DoNtIoctl(
                         TdiAddressObjectHandle,
                         IOCTL_CX_IGNORE_NODE_STATE,
                         NULL,
                         0,
                         NULL,
                         &responseSize
                         );

            if( NT_SUCCESS(status) ) {
                err = NO_ERROR;
            } else {
                err = WSAENOPROTOOPT;   // SWAG
            }
        }
        else {
            err = NO_ERROR;
        }

        context->IgnoreNodeState = TRUE;

        break;

    default :
        err = WSAEINVAL;
        break;
    }

    return err;

}   // WSHIoctl



NTSTATUS
DoNtIoctl(
    HANDLE     Handle,
    DWORD      IoctlCode,
    PVOID      Request,
    DWORD      RequestSize,
    PVOID      Response,
    PDWORD     ResponseSize
    )
/*++

Routine Description:

    Packages and issues an ioctl.

Arguments:

    Handle - An open file Handle on which to issue the request.

    IoctlCode - The IOCTL opcode.

    Request - A pointer to the input buffer.

    RequestSize - Size of the input buffer.

    Response - A pointer to the output buffer.

    ResponseSize - On input, the size in bytes of the output buffer.
                   On output, the number of bytes returned in the output buffer.

Return Value:

    NT Status Code.

--*/
{
    IO_STATUS_BLOCK    ioStatusBlock;
    NTSTATUS           status = 0xaabbccdd;
    HANDLE             event;


    event = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (event == NULL) {
        return(GetLastError());
    }

    ioStatusBlock.Information = 0;

    status = NtDeviceIoControlFile(
                 Handle,                          // Driver Handle
                 event,                           // Event
                 NULL,                            // APC Routine
                 NULL,                            // APC context
                 &ioStatusBlock,                  // Status block
                 IoctlCode,                       // Control code
                 Request,                         // Input buffer
                 RequestSize,                     // Input buffer size
                 Response,                        // Output buffer
                 *ResponseSize                    // Output buffer size
                 );

    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(
                     event,
                     TRUE,
                     NULL
                     );
    }

    if (status == STATUS_SUCCESS) {
        status = ioStatusBlock.Status;
        
        // NOTENOTE: on 64 bit this truncates, might want to add > check code

        *ResponseSize = (ULONG)ioStatusBlock.Information;
    }
    else {
        *ResponseSize = 0;
    }

    CloseHandle(event);

    return(status);

}  // DoIoctl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\xport\ccmp.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ccmp.c

Abstract:

    Cluster Control Message Protocol code.

Author:

    Mike Massa (mikemas)           January 24, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-24-97    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ccmp.tmh"

#include <sspi.h>

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, CcmpLoad)
#pragma alloc_text(PAGE, CcmpUnload)

#endif // ALLOC_PRAGMA

//
// Local Data
//
PCN_RESOURCE_POOL  CcmpSendRequestPool = NULL;
PCN_RESOURCE_POOL  CcmpMcastHBSendRequestPool = NULL;
PCN_RESOURCE_POOL  CcmpReceiveRequestPool = NULL;


#define CCMP_SEND_REQUEST_POOL_DEPTH      5
#define CCMP_RECEIVE_REQUEST_POOL_DEPTH   2

typedef enum {
    CcmpInvalidMsgCode = 0
} CCMP_MSG_CODE;

//
// Packet header structures must be packed.
//
#include <packon.h>

typedef struct {
    ULONG     SeqNumber;
    ULONG     AckNumber;
} CCMP_HEARTBEAT_MSG, *PCCMP_HEARTBEAT_MSG;

typedef struct {
    ULONG     SeqNumber;
} CCMP_POISON_MSG, *PCCMP_POISON_MSG;

typedef struct {
    ULONG             NodeCount;
    CX_CLUSTERSCREEN  McastTargetNodes;
} CCMP_MCAST_HEARTBEAT_HEADER, *PCCMP_MCAST_HEARTBEAT_MSG;

typedef struct {
    UCHAR     Type;
    UCHAR     Code;
    USHORT    Checksum;

    union {
        CCMP_HEARTBEAT_MSG          Heartbeat;
        CCMP_POISON_MSG             Poison;
        CCMP_MCAST_HEARTBEAT_HEADER McastHeartbeat;
    } Message;

} CCMP_HEADER, *PCCMP_HEADER;

#include <packoff.h>


typedef struct {
    PCX_SEND_COMPLETE_ROUTINE     CompletionRoutine;
    PVOID                         CompletionContext;
    PVOID                         MessageData;
} CCMP_SEND_CONTEXT, *PCCMP_SEND_CONTEXT;

typedef struct {
    PCNP_NETWORK  Network;
    CL_NODE_ID    SourceNodeId;
    ULONG         TsduSize;
    ULONG         CnpReceiveFlags;
} CCMP_RECEIVE_CONTEXT, *PCCMP_RECEIVE_CONTEXT;

//
// Size of pre-allocated buffers for CCMP multicast heartbeats.
//
#define CCMP_MCAST_HEARTBEAT_PAYLOAD_PREALLOC(_NodeCount) \
    ((_NodeCount) * sizeof(CX_HB_NODE_INFO))
     
#define CCMP_MCAST_HEARTBEAT_PREALLOC(_NodeCount)         \
    (sizeof(CCMP_HEADER)                                  \
     + CCMP_MCAST_HEARTBEAT_PAYLOAD_PREALLOC(_NodeCount)  \
     )


//
// Security contexts.
//
// The heartbeat and poison packets are signed to detect tampering or
// spoofing.  The context is first established in user mode, then passed to
// clusnet and imported into the kernel security package.
//
// A node maintains an inbound and outbound based context with each node in
// the cluster. Hence, an array, indexed by Node Id, holds the data used to
// represent a context between this node and the specified node.
//
// The use of multiple, simultaneous security packages is supported on NT5. As
// of right now, the signature size can't be determined until the context has
// been generated. It's possible for the signature buffer size for the initial
// context to be smaller than the buffer size for subsequent
// contexts. RichardW is going to provide the ability to determine the
// signature size for a given package without having to generate a context.
//
// There are two scenarios where changing signature buffer size has an effect:
// 1) a mixed mode (SP4/NT5), 2 node cluster is using NTLM with a signature
// buffer size of 16 bytes. The SP4 node is upgraded to NT5. When the two
// nodes join, they will use kerberos which has a larger signature buffer size
// than NTLM but the 1st node has already allocated 16 b. signature
// buffers. This could be fixed by noting the change in buffer size and
// reallocating the lookaside list for the new size. This doesn't solve the
// problem with more than 2 nodes: 2) with > 2 node, mixed mode clusters, it's
// possible to have some nodes using NTLM and others using kerberos. If the
// max signature buffer can be determined before any contexts are generated
// then we'll allocated the largest buffer needed. If not, either multiple
// sets of signature buffers have to be maintained or the old, smaller buffer
// list is deallocated while a new, larger list is generated (in a
// synchronized fashion of course).
//

typedef struct _CLUSNET_SECURITY_DATA {
    CtxtHandle  Inbound;
    CtxtHandle  Outbound;
    ULONG       SignatureBufferSize;
} CLUSNET_SECURITY_DATA, * PCLUSNET_SECURITY_DATA;

//
// this array of structs holds the in/outbound contexts and the signature
// buffer size needed for communicating with the node indexed at this
// location. The index is based on internal (zero based) numbering.
//
CLUSNET_SECURITY_DATA SecurityContexts[ ClusterMinNodeId + ClusterDefaultMaxNodes ];

//
// the size of the signature buffers in the sig buffer lookaside list
//
ULONG AllocatedSignatureBufferSize = 0;

//
// the largest size of the signature buffers imported
//
ULONG MaxSignatureSize = 0;

CN_LOCK SecCtxtLock;

#define VALID_SSPI_HANDLE( _x )     ((_x).dwUpper != (ULONG_PTR)-1 && \
                                     (_x).dwLower != (ULONG_PTR)-1 )

#define INVALIDATE_SSPI_HANDLE( _x ) { \
        (_x).dwUpper = (ULONG_PTR)-1; \
        (_x).dwLower = (ULONG_PTR)-1; \
    }

//
// Lookaside list of signature data and its MDL
//

typedef struct _SIGNATURE_DATA {
    SINGLE_LIST_ENTRY Next;
    CN_SIGNATURE_FIELD
    PMDL SigMDL;
    UCHAR PacketSignature[0];
} SIGNATURE_DATA, *PSIGNATURE_DATA;

PNPAGED_LOOKASIDE_LIST SignatureLL;
#define CN_SIGNATURE_TAG    CN_POOL_TAG

//
// Routines exported within the Cluster Transport.
//
NTSTATUS
CcmpLoad(
    VOID
    )
{
    NTSTATUS   status;
    ULONG      i;

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CCMP] Loading...\n"));
    }

    CcmpSendRequestPool = CnpCreateSendRequestPool(
                              CNP_VERSION_UNICAST,
                              PROTOCOL_CCMP,
                              sizeof(CCMP_HEADER),
                              sizeof(CCMP_SEND_CONTEXT),
                              CCMP_SEND_REQUEST_POOL_DEPTH
                              );

    if (CcmpSendRequestPool == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    CcmpReceiveRequestPool = CnpCreateReceiveRequestPool(
                                 sizeof(CCMP_RECEIVE_CONTEXT),
                                 CCMP_RECEIVE_REQUEST_POOL_DEPTH
                                 );

    if (CcmpSendRequestPool == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    CcmpMcastHBSendRequestPool = 
        CnpCreateSendRequestPool(
            CNP_VERSION_MULTICAST,
            PROTOCOL_CCMP,
            (USHORT)CCMP_MCAST_HEARTBEAT_PREALLOC(ClusterDefaultMaxNodes),
            (USHORT)sizeof(CCMP_SEND_CONTEXT),
            CCMP_SEND_REQUEST_POOL_DEPTH
            );
    if (CcmpMcastHBSendRequestPool == NULL) {
        IF_CNDBG( CN_DEBUG_INIT )
            CNPRINT(("[CCMP]: no memory for mcast heartbeat "
                     "send request pool\n"));
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // initialize the individual client and server side security contexts
    //

    for ( i = ClusterMinNodeId; i <= ClusterDefaultMaxNodes; ++i ) {
        INVALIDATE_SSPI_HANDLE( SecurityContexts[ i ].Outbound );
        INVALIDATE_SSPI_HANDLE( SecurityContexts[ i ].Inbound );
        SecurityContexts[ i ].SignatureBufferSize = 0;
    }

    CnInitializeLock( &SecCtxtLock, CNP_SEC_CTXT_LOCK );

    SignatureLL = NULL;

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CCMP] Loaded.\n"));
    }

    return(STATUS_SUCCESS);

} // CcmpLoad


VOID
CcmpUnload(
    VOID
    )
{
    ULONG i;

    PAGED_CODE();


    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CCMP] Unloading...\n"));
    }

    if (CcmpSendRequestPool != NULL) {
        CnpDeleteSendRequestPool(CcmpSendRequestPool);
        CcmpSendRequestPool = NULL;
    }

    if (CcmpMcastHBSendRequestPool != NULL) {
        CnpDeleteSendRequestPool(CcmpMcastHBSendRequestPool);
        CcmpMcastHBSendRequestPool = NULL;
    }

    if (CcmpReceiveRequestPool != NULL) {
        CnpDeleteReceiveRequestPool(CcmpReceiveRequestPool);
        CcmpReceiveRequestPool = NULL;
    }

    //
    // free Signature buffers and delete security contexts
    //

    if ( SignatureLL != NULL ) {

        ExDeleteNPagedLookasideList( SignatureLL );
        CnFreePool( SignatureLL );
        SignatureLL = NULL;
        AllocatedSignatureBufferSize = 0;
    }

    for ( i = ClusterMinNodeId; i <= ClusterDefaultMaxNodes; ++i ) {

        CxDeleteSecurityContext( i );
    }

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CCMP] Unload complete.\n"));
    }

    return;

}  // CcmpUnload

#ifdef MM_IN_CLUSNET
VOID
CcmpCompleteSendMembershipMsg(
    IN NTSTATUS           Status,
    IN ULONG              BytesSent,
    IN PCNP_SEND_REQUEST  SendRequest,
    IN PMDL               DataMdl,
    IN PIRP               Irp
    )
{
    PCCMP_SEND_CONTEXT  sendContext = SendRequest->UpperProtocolContext;

    CnAssert(DataMdl != NULL);

    if (NT_SUCCESS(Status)) {
        if (BytesSent >= sizeof(CCMP_HEADER)) {
            BytesSent -= sizeof(CCMP_HEADER);
        }
        else {
            BytesSent = 0;
            CnAssert(FALSE);
        }
        
        //
        // Update the Information field of the completed IRP to
        // reflect the actual bytes sent (adjusted for the CCMP
        // header).
        //
        Irp->IoStatus.Information = BytesSent;
    }
    else {
        CnAssert(BytesSent == 0);
    }

    //
    // Call the completion routine.
    //
    (*(sendContext->CompletionRoutine))(
        Status,
        BytesSent,
        sendContext->CompletionContext,
        sendContext->MessageData
        );

    //
    // Free the stuff we allocated.
    //
    IoFreeMdl(DataMdl);

    CnFreeResource((PCN_RESOURCE) SendRequest);

    return;

}  // CcmpCompleteSendMembershipMsg


NTSTATUS
CxSendMembershipMessage(
    IN CL_NODE_ID                  DestinationNodeId,
    IN PVOID                       MessageData,
    IN USHORT                      MessageDataLength,
    IN PCX_SEND_COMPLETE_ROUTINE   CompletionRoutine,
    IN PVOID                       CompletionContext   OPTIONAL
    )
{
    NTSTATUS            status;
    PCNP_SEND_REQUEST   sendRequest;
    PCCMP_HEADER        ccmpHeader;
    PMDL                dataMdl;
    PCCMP_SEND_CONTEXT  sendContext;


    CnAssert(MessageData != NULL);
    CnAssert(MessageDataLength > 0);

    dataMdl = IoAllocateMdl(
                  MessageData,
                  MessageDataLength,
                  FALSE,
                  FALSE,
                  NULL
                  );

    if (dataMdl != NULL) {
        MmBuildMdlForNonPagedPool(dataMdl);

        sendRequest = (PCNP_SEND_REQUEST) CnAllocateResource(
                                              CcmpSendRequestPool
                                              );

        if (sendRequest != NULL) {

            //
            // Fill in the CCMP header.
            //
            ccmpHeader = sendRequest->UpperProtocolHeader;
            RtlZeroMemory(ccmpHeader, sizeof(CCMP_HEADER));
            ccmpHeader->Type = CcmpMembershipMsgType;

            //
            // Fill in the caller portion of the CNP send request.
            //
            sendRequest->UpperProtocolIrp = NULL;
            sendRequest->CompletionRoutine = CcmpCompleteSendMembershipMsg;

            //
            // Fill in our own send context.
            //
            sendContext = sendRequest->UpperProtocolContext;
            sendContext->CompletionRoutine = CompletionRoutine;
            sendContext->CompletionContext = CompletionContext;
            sendContext->MessageData = MessageData;

            //
            // Send the message.
            //
            status = CnpSendPacket(
                         sendRequest,
                         DestinationNodeId,
                         dataMdl,
                         MessageDataLength,
                         FALSE,
                         ClusterAnyNetworkId
                         );

            return(status);
        }

        IoFreeMdl(dataMdl);
    }

    status = STATUS_INSUFFICIENT_RESOURCES;

    return(status);

}  // CxSendMembershipMessage
#endif // MM_IN_CLUSNET
 
VOID
CcmpCompleteSendHeartbeatMsg(
    IN     NTSTATUS           Status,
    IN OUT PULONG             BytesSent,
    IN     PCNP_SEND_REQUEST  SendRequest,
    IN     PMDL               DataMdl
    )
{
    PCCMP_HEADER        ccmpHeader = SendRequest->UpperProtocolHeader;
    PCNP_HEADER         cnpHeader = SendRequest->CnpHeader;
    PSIGNATURE_DATA     SigData;

    
    if (NT_SUCCESS(Status)) {
        MEMLOG(MemLogHBPacketSendComplete,
               CcmpHeartbeatMsgType,
               ccmpHeader->Message.Heartbeat.SeqNumber);
        
        CnTrace(CCMP_SEND_DETAIL, CcmpTraceSendHBComplete,
            "[CCMP] Send of heartbeat to node %u completed, seqno %u.",
            cnpHeader->DestinationAddress, // LOGULONG
            ccmpHeader->Message.Heartbeat.SeqNumber // LOGULONG
            );
    
        //
        // Strip the CCMP header off of the byte count
        //
        if (*BytesSent >= sizeof(CCMP_HEADER)) {
            *BytesSent -= sizeof(CCMP_HEADER);
        }
        else {
            *BytesSent = 0;
            CnAssert(FALSE);
        }
    }
    else {
        MEMLOG(MemLogPacketSendFailed,
               cnpHeader->DestinationAddress,
               Status);
        
        CnTrace(CCMP_SEND_ERROR, CcmpTraceSendHBFailedBelow,
            "[CCMP] Transport failed to send heartbeat to node %u, "
            "seqno %u, status %!status!.",
            cnpHeader->DestinationAddress, // LOGULONG
            ccmpHeader->Message.Heartbeat.SeqNumber, // LOGULONG
            Status // LOGSTATUS
            );

        CnAssert(*BytesSent == 0);
    }

    //
    // Strip the sig data off of the byte count and free it
    //
    CnAssert(DataMdl != NULL);

    SigData = CONTAINING_RECORD(
                  DataMdl->MappedSystemVa,
                  SIGNATURE_DATA,
                  PacketSignature
                  );

    if (NT_SUCCESS(Status)) {
        if (*BytesSent >= SigData->SigMDL->ByteCount) {
            *BytesSent -= SigData->SigMDL->ByteCount;
        } else {
            *BytesSent = 0;
            CnAssert(FALSE);
        }
    }

    // XXX: restore the original buffer size
    SigData->SigMDL->ByteCount = AllocatedSignatureBufferSize;

    ExFreeToNPagedLookasideList( SignatureLL, SigData );

    //
    // At this point BytesSent should be zero.
    //
    CnAssert(*BytesSent == 0);

    //
    // Free the send request.
    //
    CnFreeResource((PCN_RESOURCE) SendRequest);

    return;

}  // CcmpCompleteSendHeartbeatMsg


NTSTATUS
CxSendHeartBeatMessage(
    IN CL_NODE_ID                  DestinationNodeId,
    IN ULONG                       SeqNumber,
    IN ULONG                       AckNumber,
    IN CL_NETWORK_ID               NetworkId
    )
{
    NTSTATUS            status;
    PCNP_SEND_REQUEST   sendRequest;
    PCCMP_HEADER        ccmpHeader;
    SecBufferDesc       SignatureDescriptor;
    SecBuffer           SignatureSecBuffer[2];
    PSIGNATURE_DATA     SigData;
    CN_IRQL             SecContextIrql;
    PCLUSNET_SECURITY_DATA contextData = &SecurityContexts[ DestinationNodeId ];

    
    sendRequest = (PCNP_SEND_REQUEST) CnAllocateResource( CcmpSendRequestPool );

    if (sendRequest != NULL) {

        //
        // Fill in the CCMP header.
        //
        ccmpHeader = sendRequest->UpperProtocolHeader;
        RtlZeroMemory(ccmpHeader, sizeof(CCMP_HEADER));
        ccmpHeader->Type = CcmpHeartbeatMsgType;
        ccmpHeader->Message.Heartbeat.SeqNumber = SeqNumber;
        ccmpHeader->Message.Heartbeat.AckNumber = AckNumber;

        //
        // allocate a buffer and generate a signature. SignatureLL
        // will be NULL if security contexts have not yet been
        // imported.
        //

        if (SignatureLL != NULL) {
        
            SigData = ExAllocateFromNPagedLookasideList( SignatureLL );

            if (SigData != NULL) {

                //
                // acquire the lock on the security contexts and see if
                // we have a valid one with which to send this packet
                //

                CnAcquireLock( &SecCtxtLock, &SecContextIrql );

                if ( VALID_SSPI_HANDLE( contextData->Outbound )) {

                    //
                    // build a descriptor for the message and signature
                    //

                    SignatureDescriptor.cBuffers = 2;
                    SignatureDescriptor.pBuffers = SignatureSecBuffer;
                    SignatureDescriptor.ulVersion = SECBUFFER_VERSION;

                    SignatureSecBuffer[0].BufferType = SECBUFFER_DATA;
                    SignatureSecBuffer[0].cbBuffer = sizeof(CCMP_HEADER);
                    SignatureSecBuffer[0].pvBuffer = (PVOID)ccmpHeader;

                    SignatureSecBuffer[1].BufferType = SECBUFFER_TOKEN;
                    SignatureSecBuffer[1].cbBuffer = 
                        contextData->SignatureBufferSize;
                    SignatureSecBuffer[1].pvBuffer = 
                        SigData->PacketSignature;

                    status = MakeSignature(&contextData->Outbound,
                                           0,
                                           &SignatureDescriptor,
                                           0);
                    CnAssert( status == STATUS_SUCCESS );

                    CnReleaseLock( &SecCtxtLock, SecContextIrql );

                    if ( status == STATUS_SUCCESS ) {

                        //
                        // Fill in the caller portion of the CNP send request.
                        //
                        sendRequest->UpperProtocolIrp = NULL;
                        sendRequest->CompletionRoutine = 
                            CcmpCompleteSendHeartbeatMsg;

                        //
                        // Send the message.
                        //

                        MEMLOG( 
                            MemLogHBPacketSend, 
                            CcmpHeartbeatMsgType, 
                            SeqNumber
                            );

                        CnTrace(CCMP_SEND_DETAIL, CcmpTraceSendHB,
                            "[CCMP] Sending heartbeat to node %u "
                            "on network %u, seqno %u, ackno %u.",
                            DestinationNodeId, // LOGULONG
                            NetworkId, // LOGULONG
                            SeqNumber, // LOGULONG
                            AckNumber // LOGULONG
                            );

                        //
                        // XXX: adjust the MDL to reflect the true
                        // number of bytes in the signature buffer. This
                        // will go away when the max sig buffer size can
                        // be determined in user mode
                        //
                        SigData->SigMDL->ByteCount = 
                            contextData->SignatureBufferSize;

                        status = CnpSendPacket(
                                     sendRequest,
                                     DestinationNodeId,
                                     SigData->SigMDL,
                                     (USHORT)contextData->SignatureBufferSize,
                                     FALSE,
                                     NetworkId);

                        //
                        // CnpSendPacket is responsible for ensuring 
                        // that CcmpCompleteSendHeartbeatMsg is called (it 
                        // is stored in the send request data structure).
                        //
                    }
                } else {

                    CnReleaseLock( &SecCtxtLock, SecContextIrql );
                    ExFreeToNPagedLookasideList( SignatureLL, SigData );
                    CnFreeResource((PCN_RESOURCE) sendRequest);

                    status = STATUS_CLUSTER_NO_SECURITY_CONTEXT;
                }
            } else {

                CnFreeResource((PCN_RESOURCE) sendRequest);
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        
        } else {

            CnFreeResource((PCN_RESOURCE) sendRequest);
            status = STATUS_CLUSTER_NO_SECURITY_CONTEXT;
        }

    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!NT_SUCCESS(status)) {
        CnTrace(CCMP_SEND_ERROR, CcmpTraceSendHBFailedInternal,
            "[CCMP] Failed to send heartbeat to node %u on net %u, "
            "seqno %u, status %!status!.",
            DestinationNodeId, // LOGULONG
            NetworkId, // LOGULONG
            SeqNumber, // LOGULONG
            status // LOGSTATUS
            );
    }

    return(status);

}  // CxSendHeartbeatMessage


VOID
CcmpCompleteSendMcastHeartbeatMsg(
    IN     NTSTATUS           Status,
    IN OUT PULONG             BytesSent,
    IN     PCNP_SEND_REQUEST  SendRequest,
    IN     PMDL               DataMdl
    )
{
    PCCMP_HEADER        ccmpHeader = SendRequest->UpperProtocolHeader;
    PCNP_HEADER         cnpHeader = SendRequest->CnpHeader;
    PCCMP_SEND_CONTEXT  sendContext = SendRequest->UpperProtocolContext;

    
    if (NT_SUCCESS(Status)) {

        MEMLOG(MemLogHBPacketSendComplete,
               CcmpMcastHeartbeatMsgType,
               0xFFFFFFFF);
        
        CnTrace(
            CCMP_SEND_DETAIL, CcmpTraceSendMcastHBComplete,
            "[CCMP] Send of multicast heartbeat "
            "on network id %u completed.",
            SendRequest->Network->Id // LOGULONG
            );
    
        //
        // Strip the CCMP header and multicast heartbeat payload 
        // off of the byte count. The size of the message sent was
        // saved in the send request data structure.
        //
        if (*BytesSent >= SendRequest->UpperProtocolHeaderLength) {
            *BytesSent -= SendRequest->UpperProtocolHeaderLength;
        }
        else {
            *BytesSent = 0;
            CnAssert(FALSE);
        }
    }
    else {
        MEMLOG(MemLogPacketSendFailed,
               cnpHeader->DestinationAddress,
               Status);
        
        CnTrace(
            CCMP_SEND_ERROR, CcmpTraceSendHBFailedBelow,
            "[CCMP] Transport failed to send multicast "
            "heartbeat on network id %u, status %!status!.",
            SendRequest->Network->Id, // LOGULONG
            Status // LOGSTATUS
            );

        CnAssert(*BytesSent == 0);
    }

    //
    // At this point BytesSent should be zero.
    //
    CnAssert(*BytesSent == 0);

    //
    // Call the completion routine if one was specified
    //
    if (sendContext->CompletionRoutine) {
        (*(sendContext->CompletionRoutine))(
            Status,
            *BytesSent,
            sendContext->CompletionContext,
            NULL
            );
    }

    //
    // Free the send request.
    //
    CnFreeResource((PCN_RESOURCE) SendRequest);

    return;

}  // CcmpCompleteSendHeartbeatMsg


NTSTATUS
CxSendMcastHeartBeatMessage(
    IN     CL_NETWORK_ID               NetworkId,
    IN     PVOID                       McastGroup,
    IN     CX_CLUSTERSCREEN            McastTargetNodes,
    IN     CX_HB_NODE_INFO             NodeInfo[],
    IN     PCX_SEND_COMPLETE_ROUTINE   CompletionRoutine,  OPTIONAL
    IN     PVOID                       CompletionContext   OPTIONAL
    )
/*++

Routine Description:

    Send a multicast heartbeat message. The mcast heartbeat is
    structured as follows:
    
        CCMP_HEADER
        
        CNP_MCAST_SIGNATURE (including signature buffer)
        
        CCMP_MCAST_HEARTBEAT_MESSAGE
        
Arguments:

    NetworkId - network to send mcast heartbeat

    McastGroup - contains data for the multicast group to
        which the message is to be sent
    
    McastTargetNodes - screen that indicates whether the 
        (internal) node id is a target of this multicast heartbeat.
    
    NodeInfo - vector, of size ClusterDefaultMaxNodes+ClusterMinNodeId, 
        of node info data structures indexed by dest node id
    
    CompletionRoutine - called in this routine if the request is
        not passed down to a lower level (in which case it will be
        called by this routine's completion routine)
        
    CompletionContext - context for CompletionRoutine
    
Return value:

    NTSTATUS
    
--*/
{
    NTSTATUS                        status = STATUS_HOST_UNREACHABLE;
    PCNP_SEND_REQUEST               sendRequest;
    PCCMP_HEADER                    ccmpHeader;
    PCCMP_SEND_CONTEXT              sendContext;
    CX_HB_NODE_INFO UNALIGNED     * payload;
    PVOID                           signHeaders[2];
    ULONG                           signHeaderLengths[2];
    ULONG                           sigLen;
    PCNP_MULTICAST_GROUP            mcastGroup;
    BOOLEAN                         pushedPacket = FALSE;


    mcastGroup = (PCNP_MULTICAST_GROUP) McastGroup;
    CnAssert(mcastGroup != NULL);

    sendRequest = (PCNP_SEND_REQUEST) CnAllocateResource( 
                                          CcmpMcastHBSendRequestPool
                                          );

    if (sendRequest != NULL) {

        //
        // Fill in the caller portion of the CNP send request.
        //
        sendRequest->UpperProtocolIrp = NULL;
        sendRequest->CompletionRoutine = CcmpCompleteSendMcastHeartbeatMsg;
        sendRequest->McastGroup = mcastGroup;

        //
        // Fill in our own send context.
        //
        sendContext = sendRequest->UpperProtocolContext;
        sendContext->CompletionRoutine = CompletionRoutine;
        sendContext->CompletionContext = CompletionContext;

        //
        // Fill in the CCMP header. 
        //
        ccmpHeader = sendRequest->UpperProtocolHeader;
        RtlZeroMemory(ccmpHeader, sizeof(CCMP_HEADER));
        ccmpHeader->Type = CcmpMcastHeartbeatMsgType;
        ccmpHeader->Message.McastHeartbeat.NodeCount = ClusterDefaultMaxNodes;
        ccmpHeader->Message.McastHeartbeat.McastTargetNodes = McastTargetNodes;

        //
        // Fill in the heartbeat data.
        //
        payload = (CX_HB_NODE_INFO UNALIGNED *)(ccmpHeader + 1);
        RtlCopyMemory(
            payload,
            &(NodeInfo[ClusterMinNodeId]),
            sizeof(*NodeInfo) * ClusterDefaultMaxNodes
            );

        //
        // Send the message.
        //

        MEMLOG( 
            MemLogHBPacketSend, 
            CcmpMcastHeartbeatMsgType, 
            0xFFFFFFFF
            );

        CnTrace(
            CCMP_SEND_DETAIL, CcmpTraceSendMcastHB,
            "[CCMP] Sending multicast heartbeat on network %u, "
            "node count %u, target mask %04X",
            NetworkId, // LOGULONG
            ClusterDefaultMaxNodes,  // LOGUSHORT
            McastTargetNodes.UlongScreen
            );

        status = CnpSendPacket(
                     sendRequest,
                     ClusterAnyNodeId,
                     NULL,
                     0,
                     FALSE,
                     NetworkId
                     );

        //
        // CnpSendPacket is responsible for ensuring 
        // that CcmpCompleteSendMcastHeartbeatMsg is called
        // (it is stored in the send request data structure).
        //

        pushedPacket = TRUE;


    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!NT_SUCCESS(status)) {
        CnTrace(CCMP_SEND_ERROR, CcmpTraceSendMcastHBFailedInternal,
            "[CCMP] Failed to send multicast heartbeat on net %u, "
            "status %!status!, pushedPacket = %!bool!.",
            NetworkId, // LOGULONG
            status, // LOGSTATUS
            pushedPacket
            );
    }

    //
    // If the request wasn't submitted to the next lower layer and
    // a completion routine was provided, call the completion
    // routine.
    //
    if (!pushedPacket && CompletionRoutine) {
        (*CompletionRoutine)(
            status,
            0,
            CompletionContext,
            NULL
            );
    }

    return(status);

} // CxSendMcastHeartBeatMessage


VOID
CcmpCompleteSendPoisonPkt(
    IN     NTSTATUS           Status,
    IN OUT PULONG             BytesSent,
    IN     PCNP_SEND_REQUEST  SendRequest,
    IN     PMDL               DataMdl
    )
{
    PCCMP_SEND_CONTEXT  sendContext = SendRequest->UpperProtocolContext;
    PSIGNATURE_DATA     SigData;
    PCNP_HEADER         cnpHeader = (PCNP_HEADER) SendRequest->CnpHeader;


    MEMLOG(MemLogHBPacketSendComplete,
           CcmpPoisonMsgType,
           ( sendContext->CompletionRoutine == NULL ));

    IF_CNDBG( CN_DEBUG_POISON | CN_DEBUG_CCMPSEND )
        CNPRINT(("[CCMP] Send of poison packet to node %u completed "
                 "with status %08x\n",
                 cnpHeader->DestinationAddress, Status));

    if (NT_SUCCESS(Status)) {
        
        CnTrace(CCMP_SEND_DETAIL, CcmpTraceSendPoisonComplete, 
            "[CCMP] Send of poison packet to node %u completed.",
            cnpHeader->DestinationAddress // LOGULONG
            );
    
        //
        // Strip the CCMP header off of the byte count
        //
        if (*BytesSent >= sizeof(CCMP_HEADER)) {
            *BytesSent -= sizeof(CCMP_HEADER);
        }
        else {
            *BytesSent = 0;
            CnAssert(FALSE);
        }

    } else {
        CnTrace(CCMP_SEND_ERROR, CcmpTraceSendPoisonFailedBelow, 
            "[CCMP] Transport failed to send poison packet to node %u, "
            "status %!status!.",
            cnpHeader->DestinationAddress, // LOGULONG
            Status // LOGSTATUS
            );
        
        CnAssert(*BytesSent == 0);
    }

    //
    // Strip the sig data off of the byte count and free it
    //
    CnAssert(DataMdl != NULL);

    SigData = CONTAINING_RECORD(
                  DataMdl->MappedSystemVa,
                  SIGNATURE_DATA,
                  PacketSignature
                  );

    if (NT_SUCCESS(Status)) {
        if (*BytesSent >= SigData->SigMDL->ByteCount) {
            *BytesSent -= SigData->SigMDL->ByteCount;
        } else {
            *BytesSent = 0;
            CnAssert(FALSE);
        }
    }

    // XXX: restore the original buffer size
    SigData->SigMDL->ByteCount = AllocatedSignatureBufferSize;

    ExFreeToNPagedLookasideList( SignatureLL, SigData );

    //
    // At this point BytesSent should be zero.
    //
    CnAssert(*BytesSent == 0);

    //
    // Call the completion routine if one was specified
    //
    if (sendContext->CompletionRoutine) {
        (*(sendContext->CompletionRoutine))(
            Status,
            *BytesSent,
            sendContext->CompletionContext,
            sendContext->MessageData
            );
    }

    //
    // Free the send request.
    //
    CnFreeResource((PCN_RESOURCE) SendRequest);

    return;

}  // CcmpCompleteSendPoisonPkt


VOID
CxSendPoisonPacket(
    IN CL_NODE_ID                  DestinationNodeId,
    IN PCX_SEND_COMPLETE_ROUTINE   CompletionRoutine,  OPTIONAL
    IN PVOID                       CompletionContext,  OPTIONAL
    IN PIRP                        Irp                 OPTIONAL
    )
{
    NTSTATUS     status;
    PCNP_NODE    node;


    node = CnpFindNode(DestinationNodeId);

    if (node == NULL) {
        if (CompletionRoutine) {
            (*CompletionRoutine)(
                STATUS_CLUSTER_NODE_NOT_FOUND,
                0,
                CompletionContext,
                NULL
                );
        }

        if (Irp) {
            Irp->IoStatus.Status = STATUS_CLUSTER_NODE_NOT_FOUND;
            Irp->IoStatus.Information = 0;
            
            IF_CNDBG( CN_DEBUG_POISON | CN_DEBUG_CCMPSEND )
                CNPRINT(("[CCMP] CxSendPoisonPacket completing IRP "
                         "%p with status %08x\n",
                         Irp, Irp->IoStatus.Status));

            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }
    }
    else {
        CcmpSendPoisonPacket(
            node,
            CompletionRoutine,
            CompletionContext,
            NULL,
            Irp
            );
    }

    return;

} // CxSendPoisonPacket


VOID
CcmpSendPoisonPacket(
    IN PCNP_NODE                   Node,
    IN PCX_SEND_COMPLETE_ROUTINE   CompletionRoutine,  OPTIONAL
    IN PVOID                       CompletionContext,  OPTIONAL
    IN PCNP_NETWORK                Network,            OPTIONAL
    IN PIRP                        Irp                 OPTIONAL
    )
/*++

Notes:

  Called with the node lock held. Returns with the node lock released.
  
  If this send request is not submitted to the next lower layer, 
  CompletionRoutine must be called (if it is not NULL).

--*/
{
    NTSTATUS                status;
    PCNP_SEND_REQUEST       sendRequest;
    PCCMP_HEADER            ccmpHeader;
    PCCMP_SEND_CONTEXT      sendContext;
    SecBufferDesc           SignatureDescriptor;
    SecBuffer               SignatureSecBuffer[2];
    PSIGNATURE_DATA         SigData;
    CN_IRQL                 SecContextIrql;
    SECURITY_STATUS         secStatus;
    PCNP_INTERFACE          interface;
    PCLUSNET_SECURITY_DATA  contextData = &SecurityContexts[Node->Id];
    CL_NETWORK_ID           networkId;
    CL_NODE_ID              nodeId = Node->Id;


    sendRequest = (PCNP_SEND_REQUEST) CnAllocateResource(CcmpSendRequestPool);

    if (sendRequest != NULL) {
        //
        // make sure we have an interface to send this on. We
        // could be shutting down and have dropped info out of
        // the database
        //
        if ( Network != NULL ) {
            PLIST_ENTRY  entry;

            //
            // we really want to send this packet over the indicated
            // network. walk the node's interface list matching the
            // supplied network id to the interface's network ID and
            // send the packet on that interface
            //

            for (entry = Node->InterfaceList.Flink;
                 entry != &(Node->InterfaceList);
                 entry = entry->Flink
                 )
                {
                    interface = CONTAINING_RECORD(entry,
                                                  CNP_INTERFACE,
                                                  NodeLinkage);

                    if ( interface->Network == Network ) {
                        break;
                    }
                }

            if ( entry == &Node->InterfaceList ) {
                interface = Node->CurrentInterface;
            }
        }
        else {
            interface = Node->CurrentInterface;
        }

        if ( interface != NULL ) {
            networkId = interface->Network->Id;

            //
            // Fill in the CCMP header.
            //
            ccmpHeader = sendRequest->UpperProtocolHeader;
            RtlZeroMemory(ccmpHeader, sizeof(CCMP_HEADER));
            ccmpHeader->Type = CcmpPoisonMsgType;
            ccmpHeader->Message.Poison.SeqNumber =
                ++(interface->SequenceToSend);

            CnReleaseLock( &Node->Lock, Node->Irql );

            //
            // Fill in the caller portion of the CNP send request.
            //
            sendRequest->UpperProtocolIrp = Irp;
            sendRequest->CompletionRoutine = CcmpCompleteSendPoisonPkt;

            //
            // Fill in our own send context.
            //
            sendContext = sendRequest->UpperProtocolContext;
            sendContext->CompletionRoutine = CompletionRoutine;
            sendContext->CompletionContext = CompletionContext;

            //
            // allocate a signature buffer and generate one. SignatureLL
            // will be NULL if security contexts have not yet been
            // imported.
            //

            if (SignatureLL != NULL) {

                SigData = ExAllocateFromNPagedLookasideList( SignatureLL );
                
                if (SigData != NULL) {

                    //
                    // acquire the lock on the security contexts and see if
                    // we have a valid one with which to send this packet
                    //

                    CnAcquireLock( &SecCtxtLock, &SecContextIrql );

                    if ( VALID_SSPI_HANDLE( contextData->Outbound )) {

                        //
                        // build a descriptor for the message and signature
                        //

                        SignatureDescriptor.cBuffers = 2;
                        SignatureDescriptor.pBuffers = SignatureSecBuffer;
                        SignatureDescriptor.ulVersion = SECBUFFER_VERSION;

                        SignatureSecBuffer[0].BufferType = SECBUFFER_DATA;
                        SignatureSecBuffer[0].cbBuffer = sizeof(CCMP_HEADER);
                        SignatureSecBuffer[0].pvBuffer = (PVOID)ccmpHeader;

                        SignatureSecBuffer[1].BufferType = SECBUFFER_TOKEN;
                        SignatureSecBuffer[1].cbBuffer =
                            contextData->SignatureBufferSize;
                        SignatureSecBuffer[1].pvBuffer = 
                            SigData->PacketSignature;

                        secStatus = MakeSignature(
                                        &contextData->Outbound,
                                        0,
                                        &SignatureDescriptor,
                                        0);
                        CnAssert( secStatus == STATUS_SUCCESS );

                        CnReleaseLock( &SecCtxtLock, SecContextIrql );

                        //
                        // no completion routine means this routine was called
                        // from the heartbeat dpc. We'll use that to 
                        // distinguish between that and clussvc calling for a 
                        // poison packet to be sent.
                        //

                        //
                        // WMI tracing prints the thread id,
                        // can figure out DPC or not on our own
                        //
                        CnTrace(CCMP_SEND_DETAIL, CcmpTraceSendPoison,
                            "[CCMP] Sending poison packet to node %u "
                            "on net %u.",
                            nodeId, // LOGULONG
                            networkId // LOGULONG
                            );

                        MEMLOG(MemLogHBPacketSend,
                               CcmpPoisonMsgType,
                               ( CompletionRoutine == NULL ));

                        //
                        // Send the message.
                        //
                        //
                        // XXX: adjust the MDL to reflect the true number of
                        // bytes in the signature buffer. This will go away 
                        // when the max sig buffer size can be determined in
                        // user mode
                        //
                        SigData->SigMDL->ByteCount =
                            contextData->SignatureBufferSize;

                        CnpSendPacket(
                            sendRequest,
                            nodeId,
                            SigData->SigMDL,
                            (USHORT)contextData->SignatureBufferSize,
                            FALSE,
                            networkId
                            );

                        //
                        // CnpSendPacket is responsible for ensuring 
                        // that CcmpCompleteSendPoisonPkt is called.
                        // CcmpCompleteSendPoisonPkt calls CompletionRoutine,
                        // which was a parameter to this routine.
                        //
                        return;

                    } else {

                        CnReleaseLock( &SecCtxtLock, SecContextIrql );
                        ExFreeToNPagedLookasideList( SignatureLL, SigData );
                        CnFreeResource((PCN_RESOURCE) sendRequest);

                        status = STATUS_CLUSTER_NO_SECURITY_CONTEXT;
                    }
                
                } else {

                    CnFreeResource((PCN_RESOURCE) sendRequest);
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }
            } else {

                CnFreeResource((PCN_RESOURCE) sendRequest);
                status = STATUS_CLUSTER_NO_SECURITY_CONTEXT;
            }
        } else {
            CnReleaseLock( &Node->Lock, Node->Irql );
            CnFreeResource((PCN_RESOURCE) sendRequest);
            status = STATUS_CLUSTER_NETINTERFACE_NOT_FOUND;
        }
    } else {
        CnReleaseLock( &Node->Lock, Node->Irql );
        IF_CNDBG( CN_DEBUG_POISON )
            CNPRINT(("[CCMP] No send resources for SendPoisonPacket\n"));

        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    CnTrace(CCMP_SEND_ERROR, CcmpTraceSendPoisonFailedInternal,
        "[CCMP] Failed to send poison packet to node %u, status %!status!.",
        nodeId, // LOGULONG
        status // LOGSTATUS
        );

    //
    // The request to send a poison packet did not make it to the
    // next lower layer. If a completion routine was provided, 
    // call it now.
    //
    if (CompletionRoutine) {

        (*CompletionRoutine)(
            status,
            0,
            CompletionContext,
            NULL
            );
    }

    //
    // If an upper protocol IRP was provided, complete it now.
    //
    if (Irp) {

        IF_CNDBG( CN_DEBUG_POISON | CN_DEBUG_CCMPSEND )
            CNPRINT(("[CCMP] CcmpSendPoisonPacket completing IRP "
                     "%p with status %08x\n",
                     Irp, status));
        
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return;

}  // CcmpSendPoisonPacket


VOID
CcmpProcessReceivePacket(
    IN  PCNP_NETWORK   Network,
    IN  CL_NODE_ID     SourceNodeId,
    IN  ULONG          CnpReceiveFlags,
    IN  ULONG          TsduSize,
    IN  PVOID          Tsdu
    )
{
    CCMP_HEADER UNALIGNED     * header = Tsdu;
    SECURITY_STATUS             SecStatus;
    CX_HB_NODE_INFO UNALIGNED * nodeInfo;


    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    CnAssert(TsduSize >= sizeof(CCMP_HEADER));

    //
    // adjust to point past CCMP header to message payload.
    //
    // For unicasts, the message payload is the Signature data.
    //
    // For multicasts, the signature was verified at the CNP level.
    //

    if (header->Type == CcmpMcastHeartbeatMsgType) {

        IF_CNDBG(CN_DEBUG_CCMPRECV) {
            CNPRINT(("[CCMP] Recv'd mcast packet from node %u "
                     "on network %u, node count %u, target "
                     "mask %04x, CNP flags %x.\n",
                     SourceNodeId, 
                     Network->Id,
                     header->Message.McastHeartbeat.NodeCount,
                     header->Message.McastHeartbeat.McastTargetNodes.UlongScreen,
                     CnpReceiveFlags
                     ));
        }

        //
        // Verify that the message was identified as a CNP multicast
        // and that the signature was verified.
        //
        if ((CnpReceiveFlags & 
             (CNP_RECV_FLAG_MULTICAST | CNP_RECV_FLAG_SIGNATURE_VERIFIED)
            ) != 
            (CNP_RECV_FLAG_MULTICAST | CNP_RECV_FLAG_SIGNATURE_VERIFIED)
           ) {
        
            IF_CNDBG(CN_DEBUG_CCMPRECV) {
                CNPRINT(("[CCMP] Dropping mcast packet from node %u "
                         "that was not identified as CNP multicast, "
                         "CNP flags %x.\n",
                         SourceNodeId, CnpReceiveFlags
                         ));
            }

            CnTrace(CCMP_RECV_ERROR, CcmpTraceReceiveNotVerified,
                "[CCMP] Dropping mcast packet from node %u "
                "that was not identified as CNP multicast, "
                "CNP flags %x.",
                SourceNodeId, CnpReceiveFlags
                );

            //
            // Drop it.
            //
            goto error_exit;            
        }

        //
        // Verify that the node count reported in the header is reasonable.
        // It must be compatible with our assumption that the entire 
        // cluster screen fits in one ULONG.
        //
        if (header->Message.McastHeartbeat.NodeCount >
            (sizeof(header->Message.McastHeartbeat.McastTargetNodes) * BYTEL)
            ) {
        
            IF_CNDBG(CN_DEBUG_CCMPRECV) {
                CNPRINT(("[CCMP] Recv'd mcast packet from node %u "
                         "with invalid node count %u, CNP flags %x.\n",
                         SourceNodeId,
                         header->Message.McastHeartbeat.NodeCount,
                         CnpReceiveFlags
                         ));
            }

            CnTrace(CCMP_RECV_ERROR, CcmpTraceReceiveNotTarget,
                "[CCMP] Recv'd mcast packet from node %u "
                "with invalid node count %u, CNP flags %x.",
                SourceNodeId,
                header->Message.McastHeartbeat.NodeCount,
                CnpReceiveFlags
                );

            //
            // Drop it.
            //
            goto error_exit;            
        }
        
        //
        // Verify that the packet contains data for this node.
        //
        if (!CnpClusterScreenMember(
                 header->Message.McastHeartbeat.McastTargetNodes.ClusterScreen,
                 INT_NODE(CnLocalNodeId)
                 )) {
            
            IF_CNDBG(CN_DEBUG_CCMPRECV) {
                CNPRINT(("[CCMP] Recv'd mcast packet from node %u "
                         "but node %u is not a target, CNP flags %x.\n",
                         SourceNodeId, CnLocalNodeId, CnpReceiveFlags
                         ));
            }

            CnTrace(CCMP_RECV_ERROR, CcmpTraceReceiveNotTarget,
                "[CCMP] Recv'd mcast packet from node %u "
                "but node %u is not a target, CNP flags %x.",
                SourceNodeId, CnLocalNodeId, CnpReceiveFlags
                );

            //
            // Drop it.
            //
            goto error_exit;            
        }

        nodeInfo = (CX_HB_NODE_INFO UNALIGNED *)((PUCHAR)Tsdu +
                                                 sizeof(CCMP_HEADER));

        SecStatus = SEC_E_OK;

    } else {

        SecBufferDesc            PacketDataDescriptor;
        SecBuffer                PacketData[3];
        ULONG                    fQOP;
        CN_IRQL                  SecContextIrql;
        PCLUSNET_SECURITY_DATA   contextData = &SecurityContexts[SourceNodeId];

        CnAssert(!(CnpReceiveFlags & CNP_RECV_FLAG_MULTICAST));
        CnAssert(!(CnpReceiveFlags & CNP_RECV_FLAG_SIGNATURE_VERIFIED));
        
        Tsdu = header + 1;
        TsduSize -= sizeof(CCMP_HEADER);

        //
        // Acquire the security context lock.
        //
        CnAcquireLock( &SecCtxtLock, &SecContextIrql );

        //
        // Verify that we have a valid context data.
        //
        if ( !VALID_SSPI_HANDLE( contextData->Inbound )) {

            CnReleaseLock( &SecCtxtLock, SecContextIrql );

            IF_CNDBG(CN_DEBUG_CCMPRECV) {
                CNPRINT(("[CCMP] Dropping packet - no security context "
                         "available for src node %u.\n",
                         SourceNodeId // LOGULONG
                         ));
            }

            CnTrace(CCMP_RECV_ERROR, CcmpTraceReceiveNoSecurityContext, 
                "[CCMP] Dropping packet - no security context available for "
                "src node %u.",
                SourceNodeId // LOGULONG
                );

            MEMLOG( MemLogNoSecurityContext, SourceNodeId, 0 );

            //
            // Drop it.
            //
            goto error_exit;
        } 
            
        //
        // Validate that the received signature size is expected.
        //
        if ( TsduSize < contextData->SignatureBufferSize ) {

            IF_CNDBG(CN_DEBUG_CCMPRECV) {
                CNPRINT(("[CCMP] Recv'd packet from node %u with "
                         "invalid signature buffer size %u.\n",
                         SourceNodeId,
                         TsduSize
                         ));
            }

            CnTrace(CCMP_RECV_ERROR, CcmpTraceReceiveBadSignatureSize,
                "[CCMP] Recv'd packet from node %u with invalid signature "
                "buffer size %u.",
                SourceNodeId, // LOGULONG
                TsduSize // LOGULONG
                );

            MEMLOG( MemLogSignatureSize, SourceNodeId, TsduSize );

            CnReleaseLock( &SecCtxtLock, SecContextIrql );

            //
            // Drop it.
            //
            goto error_exit;
        }

        //
        // Build the descriptors for the message and the
        // signature buffer
        //
        PacketDataDescriptor.cBuffers = 2;
        PacketDataDescriptor.pBuffers = PacketData;
        PacketDataDescriptor.ulVersion = SECBUFFER_VERSION;

        PacketData[0].BufferType = SECBUFFER_DATA;
        PacketData[0].cbBuffer = sizeof(CCMP_HEADER);
        PacketData[0].pvBuffer = (PVOID)header;

        PacketData[1].BufferType = SECBUFFER_TOKEN;
        PacketData[1].cbBuffer = contextData->SignatureBufferSize;
        PacketData[1].pvBuffer = (PVOID)Tsdu;

        //
        // Verify the signature of the packet.
        //
        SecStatus = VerifySignature(&contextData->Inbound,
                                    &PacketDataDescriptor,
                                    0,          // no sequence number
                                    &fQOP);     // Quality of protection

        //
        // Release the security context lock.
        //
        CnReleaseLock( &SecCtxtLock, SecContextIrql );
    }
    
    //
    // If the signature was verified, deliver the message.
    //
    if ( SecStatus == SEC_E_OK ) {

        if (header->Type == CcmpHeartbeatMsgType) {
            CnpReceiveHeartBeatMessage(Network,
                                       SourceNodeId,
                                       header->Message.Heartbeat.SeqNumber,
                                       header->Message.Heartbeat.AckNumber,
                                       FALSE);
        }
        else if (header->Type == CcmpMcastHeartbeatMsgType) {
            CnpReceiveHeartBeatMessage(
                Network,
                SourceNodeId,
                nodeInfo[INT_NODE(CnLocalNodeId)].SeqNumber,
                nodeInfo[INT_NODE(CnLocalNodeId)].AckNumber,
                (BOOLEAN)(CnpReceiveFlags & CNP_RECV_FLAG_CURRENT_MULTICAST_GROUP)
                );
        }
        else if (header->Type == CcmpPoisonMsgType) {
            CnpReceivePoisonPacket(Network,
                                   SourceNodeId,
                                   header->Message.Heartbeat.SeqNumber);
        }
#ifdef MM_IN_CLUSNET
        else if (header->Type == CcmpMembershipMsgType) {
            if (TsduSize > 0) {
                PVOID  messageBuffer = Tsdu;

                //
                // Copy the data if it is unaligned.
                //
                if ( (((ULONG) Tsdu) & 0x3) != 0 ) {
                    IF_CNDBG(CN_DEBUG_CCMPRECV) {
                        CNPRINT(("[CCMP] Copying misaligned membership packet\n"));
                    }

                    messageBuffer = CnAllocatePool(TsduSize);

                    if (messageBuffer != NULL) {
                        RtlMoveMemory(messageBuffer, Tsdu, TsduSize);
                    }
                }

                if (messageBuffer != NULL) {

                    CmmReceiveMessageHandler(SourceNodeId,
                                             messageBuffer,
                                             TsduSize);
                }

                if (messageBuffer != Tsdu) {
                    CnFreePool(messageBuffer);
                }
            }
        }
#endif // MM_IN_CLUSNET
        else {
            IF_CNDBG(CN_DEBUG_CCMPRECV) {
                CNPRINT(("[CCMP] Received packet with unknown "
                         "type %u from node %u, CNP flags %x.\n",
                         header->Type, 
                         SourceNodeId,
                         CnpReceiveFlags
                         ));
            }

            CnTrace(CCMP_RECV_ERROR, CcmpTraceReceiveInvalidType,
                "[CCMP] Received packet with unknown type %u from "
                "node %u, CNP flags %x.",
                header->Type, // LOGUCHAR
                SourceNodeId, // LOGULONG
                CnpReceiveFlags // LOGXLONG
                );
            CnAssert(FALSE);
        }
    } else {
        IF_CNDBG(CN_DEBUG_CCMPRECV) {
            CNPRINT(("[CCMP] Recv'd packet type %u with bad "
                     "signature from node %d, security status %08x, "
                     "CNP flags %x.\n",
                     header->Type, 
                     SourceNodeId, 
                     SecStatus,
                     CnpReceiveFlags
                     ));
        }

        CnTrace(CCMP_RECV_ERROR, CcmpTraceReceiveInvalidSignature,
            "[CCMP] Recv'd %!msgtype! packet with bad signature from node %d, "
            "security status %08x, CNP flags %x.",
            header->Type, // LOGMsgType
            SourceNodeId, // LOGULONG
            SecStatus, // LOGXLONG
            CnpReceiveFlags // LOGXLONG
            );

        MEMLOG( MemLogInvalidSignature, SourceNodeId, header->Type );
    }

error_exit:

    CnVerifyCpuLockMask(
                        0,                // Required
                        0xFFFFFFFF,       // Forbidden
                        0                 // Maximum
                        );

    return;

} // CcmpProcessReceivePacket


NTSTATUS
CcmpCompleteReceivePacket(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    )
{
    PCNP_RECEIVE_REQUEST   request = Context;
    PCCMP_RECEIVE_CONTEXT  context = request->UpperProtocolContext;


    if (Irp->IoStatus.Status == STATUS_SUCCESS) {
        CnAssert(Irp->IoStatus.Information == context->TsduSize);

        CcmpProcessReceivePacket(
            context->Network,
            context->SourceNodeId,
            context->CnpReceiveFlags,
            (ULONG)Irp->IoStatus.Information,
            request->DataBuffer
            );
    }
    else {
        CnTrace(CCMP_RECV_ERROR, CcmpTraceCompleteReceiveFailed,
            "[CDP] Failed to fetch packet data, src node %u, "
            "CNP flags %x, status %!status!.",
            context->SourceNodeId, // LOGULONG
            context->CnpReceiveFlags, // LOGXLONG
            Irp->IoStatus.Status // LOGSTATUS
            );        
    }

    CnpFreeReceiveRequest(request);

    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    return(STATUS_MORE_PROCESSING_REQUIRED);

} // CcmpCompleteReceivePacket


NTSTATUS
CcmpReceivePacketHandler(
    IN  PCNP_NETWORK   Network,
    IN  CL_NODE_ID     SourceNodeId,
    IN  ULONG          CnpReceiveFlags,
    IN  ULONG          TdiReceiveDatagramFlags,
    IN  ULONG          BytesIndicated,
    IN  ULONG          BytesAvailable,
    OUT PULONG         BytesTaken,
    IN  PVOID          Tsdu,
    OUT PIRP *         Irp
    )
{
    NTSTATUS                 status;
    CCMP_HEADER UNALIGNED *  header = Tsdu;
    PCNP_RECEIVE_REQUEST     request;


    CnAssert(KeGetCurrentIrql() == DISPATCH_LEVEL);

    if (BytesIndicated >= sizeof(CCMP_HEADER)) {
        if (BytesIndicated == BytesAvailable) {

            CcmpProcessReceivePacket(
                Network,
                SourceNodeId,
                CnpReceiveFlags,
                BytesAvailable,
                Tsdu
                );

            *BytesTaken += BytesAvailable;
            *Irp = NULL;

            CnVerifyCpuLockMask(
                0,                // Required
                0xFFFFFFFF,       // Forbidden
                0                 // Maximum
                );

            return(STATUS_SUCCESS);
        }

        //
        // We need to fetch the rest of the packet before we
        // can process it.
        //
        // This message cannot be a CNP multicast, because 
        // the CNP layer could not have verified an incomplete 
        // message.
        //
        CnAssert(!(CnpReceiveFlags & CNP_RECV_FLAG_MULTICAST));
        CnAssert(!(CnpReceiveFlags & CNP_RECV_FLAG_SIGNATURE_VERIFIED));
        CnAssert(header->Type != CcmpMcastHeartbeatMsgType);

        request = CnpAllocateReceiveRequest(
                      CcmpReceiveRequestPool,
                      Network,
                      BytesAvailable,
                      CcmpCompleteReceivePacket
                      );

        if (request != NULL) {
            PCCMP_RECEIVE_CONTEXT  context = request->UpperProtocolContext;

            context->Network = Network;
            context->SourceNodeId = SourceNodeId;
            context->TsduSize = BytesAvailable;
            context->CnpReceiveFlags = CnpReceiveFlags;

            *Irp = request->Irp;

            IF_CNDBG(CN_DEBUG_CCMPRECV) {
                CNPRINT(("[CCMP] Fetching packet data, src node %u, "
                         "BI %u, BA %u, CNP flags %x.\n",
                         SourceNodeId, BytesIndicated, 
                         BytesAvailable, CnpReceiveFlags));

            }
            
            CnTrace(CCMP_RECV_DETAIL, CcmpTraceCompleteReceive,
                "[CCMP] Fetching packet data, src node %u, "
                "BI %u, BA %u, CNP flags %x.",
                SourceNodeId, // LOGULONG
                BytesIndicated, // LOGULONG
                BytesAvailable, // LOGULONG
                CnpReceiveFlags // LOGXLONG
                );        
            
            CnVerifyCpuLockMask(
                0,                // Required
                0xFFFFFFFF,       // Forbidden
                0                 // Maximum
                );

            return(STATUS_MORE_PROCESSING_REQUIRED);
        }
        else {
            IF_CNDBG(CN_DEBUG_CCMPRECV) {
                CNPRINT(("[CCMP] Dropped incoming packet - "
                         "out of resources, src node %u.\n",
                         SourceNodeId));

            }
            CnTrace(CCMP_RECV_ERROR, CcmpTraceDropReceiveOOR,
                "[CCMP] Dropped incoming packet - out of resources, "
                "src node %u.",
                SourceNodeId // LOGULONG
                );        
        }
    }
    else {
        IF_CNDBG(CN_DEBUG_CCMPRECV) {
            CNPRINT(("[CCMP] Dropped incoming runt packet, "
                     "src node %u, BI %u, BA %u, CNP flags %x.\n",
                     SourceNodeId, BytesIndicated, BytesAvailable,
                     CnpReceiveFlags));

        }
        CnTrace(CCMP_RECV_ERROR, CcmpTraceDropReceiveRunt,
            "[CCMP] Dropped incoming runt packet, src node %u, "
            "BI %u, BA %u, CNP flags %x.",
            SourceNodeId, // LOGULONG
            BytesIndicated, // LOGULONG
            BytesAvailable, // LOGULONG
            CnpReceiveFlags // LOGXLONG
            );        
    }

    //
    // Something went wrong. Drop the packet.
    //
    *BytesTaken += BytesAvailable;

    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    return(STATUS_SUCCESS);

}  // CcmpReceivePacketHandler

PVOID
SignatureAllocate(
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )
{
    PSIGNATURE_DATA SignatureData;

    CnAssert( NumberOfBytes == ( sizeof(SIGNATURE_DATA) + AllocatedSignatureBufferSize ));

    //
    // allocate the space and then construct an MDL describing it
    //

    SignatureData = ExAllocatePoolWithTag( PoolType, NumberOfBytes, Tag );

    if ( SignatureData != NULL ) {

        SignatureData->SigMDL = IoAllocateMdl(SignatureData->PacketSignature,
                                              AllocatedSignatureBufferSize,
                                              FALSE,
                                              FALSE,
                                              NULL);

        if ( SignatureData->SigMDL != NULL ) {

            MmBuildMdlForNonPagedPool(SignatureData->SigMDL);
            CN_INIT_SIGNATURE( SignatureData, CN_SIGNATURE_TAG );
        } else {

            ExFreePool( SignatureData );
            SignatureData = NULL;
        }
    }

    return SignatureData;
}

VOID
SignatureFree(
    IN PVOID Buffer
    )
{
    PSIGNATURE_DATA SignatureData = (PSIGNATURE_DATA)Buffer;

    CN_ASSERT_SIGNATURE( SignatureData, CN_SIGNATURE_TAG );
    IoFreeMdl( SignatureData->SigMDL );

    ExFreePool( SignatureData );
}

VOID
CxDeleteSecurityContext(
    IN  CL_NODE_ID NodeId
    )

/*++

Routine Description:

    Delete the security context associated with the specified node

Arguments:

    NodeId - Id of the node blah blah blah

Return Value:

    None

--*/

{
    PCLUSNET_SECURITY_DATA contextData = &SecurityContexts[ NodeId ];

    if ( VALID_SSPI_HANDLE( contextData->Inbound )) {

        DeleteSecurityContext( &contextData->Inbound );
        INVALIDATE_SSPI_HANDLE( contextData->Inbound );
    }

    if ( VALID_SSPI_HANDLE( contextData->Outbound )) {

        DeleteSecurityContext( &contextData->Outbound );
        INVALIDATE_SSPI_HANDLE( contextData->Outbound );
    }
}


NTSTATUS
CxImportSecurityContext(
    IN  CL_NODE_ID NodeId,
    IN  PWCHAR PackageName,
    IN  ULONG PackageNameSize,
    IN  ULONG SignatureSize,
    IN  PVOID ServerContext,
    IN  PVOID ClientContext
    )

/*++

Routine Description:

    import a security context that was established in user mode into
    the kernel SSP. We are passed pointers to the structures in user
    mode, so they have be probed and used within try/except blocks.

Arguments:

    NodeId - # of node with which a security context was established

    PackageName - user process pointer to security package name

    PackageNameSize - length, in bytes, of PackageName

    SignatureSize - size, in bytes, needed for a Signature Buffer

    ServerContext - user process pointer to area that contains the
        SecBuffer for an inbound security context

    ClientContext - same as ServerContext, but for outbound security
        context

Return Value:

    STATUS_SUCCESS if everything worked ok, otherwise some error in issperr.h

--*/

{
    PSecBuffer      InboundSecBuffer = (PSecBuffer)ServerContext;
    PSecBuffer      OutboundSecBuffer = (PSecBuffer)ClientContext;

    PVOID           CapturedInboundSecData;
    ULONG           CapturedInboundSecDataSize;
    PVOID           CapturedOutboundSecData;
    ULONG           CapturedOutboundSecDataSize;

    CtxtHandle      InboundContext;
    CtxtHandle      OutboundContext;
    NTSTATUS        Status;

    PWCHAR          KPackageName = NULL;
    PSecBuffer      KInboundSecBuffer = NULL;
    PSecBuffer      KOutboundSecBuffer = NULL;
    PVOID           KInboundData = NULL;
    PVOID           KOutboundData = NULL;
    CN_IRQL         SecContextIrql;
    SECURITY_STRING PackageNameDesc;

    //
    // even though this routine is not marked pagable, make sure that we're
    // not running at raised IRQL since DeleteSecurityContext will puke.
    //
    PAGED_CODE();

    IF_CNDBG( CN_DEBUG_INIT )
        CNPRINT(("[CCMP]: Importing security contexts from %ws\n",
                 PackageName));

    if ( AllocatedSignatureBufferSize == 0 ) {
        //
        // first time in this routine, so create a lookaside list pool for
        // signature buffers and their MDLs
        //

        CnAssert( SignatureLL == NULL );
        SignatureLL = CnAllocatePool( sizeof( NPAGED_LOOKASIDE_LIST ));

        if ( SignatureLL != NULL ) {
            //
            // with the support of multiple packages, the only way to
            // determine the sig buffer size was after a context had been
            // generated. Knowing the max size of all sig buffers used by the
            // service before this routine is called will prevent having to
            // add a bunch of synchronization code that would allocate new
            // buffers and phase out the old buffer pool. on NT5, NTLM uses 16
            // bytes while kerberos uses 37b. We've asked security for a call
            // that will give us the max sig size for a set of packages but
            // that hasn't materialized, hence we force the sig buffer size to
            // something that will work for both NTLM and kerberos. But this
            // discussion is kinda moot since we don't use kerberos anyway on
            // NT5.
            //

//            AllocatedSignatureBufferSize = SignatureSize;
            AllocatedSignatureBufferSize = 64;

#if 0
            ExInitializeNPagedLookasideList(SignatureLL,
                                            SignatureAllocate,
                                            SignatureFree,
                                            0,
                                            sizeof( SIGNATURE_DATA ) + SignatureSize,
                                            CN_POOL_TAG,
                                            4);
#endif
            ExInitializeNPagedLookasideList(SignatureLL,
                                            SignatureAllocate,
                                            SignatureFree,
                                            0,
                                            sizeof( SIGNATURE_DATA ) + AllocatedSignatureBufferSize,
                                            CN_POOL_TAG,
                                            4);
        } else {
            IF_CNDBG( CN_DEBUG_INIT )
                CNPRINT(("[CCMP]: no memory for signature LL\n"));

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto error_exit;
        }

    } else if ( SignatureSize > AllocatedSignatureBufferSize ) {

        //
        // the signature buffer is growing. the problem is that the lookaside
        // list is already in use by other nodes.
        //
        Status = STATUS_INVALID_PARAMETER;
        goto error_exit;
    }

    //
    // validate the pointers passed in as the SecBuffers
    //

    try {
        ProbeForRead( PackageName,
                      PackageNameSize,
                      sizeof( UCHAR ) );

        ProbeForRead( InboundSecBuffer,
                      sizeof( SecBuffer ),
                      sizeof( UCHAR ) );

        ProbeForRead( OutboundSecBuffer,
                      sizeof( SecBuffer ),
                      sizeof( UCHAR ) );

        //
        // made it this far; now capture the internal pointers and their
        // lengths. Probe the embedded pointers in the SecBuffers using the
        // captured data
        //
        CapturedInboundSecData = InboundSecBuffer->pvBuffer;
        CapturedInboundSecDataSize = InboundSecBuffer->cbBuffer;

        CapturedOutboundSecData = OutboundSecBuffer->pvBuffer;
        CapturedOutboundSecDataSize = OutboundSecBuffer->cbBuffer;

        ProbeForRead( CapturedInboundSecData,
                      CapturedInboundSecDataSize,
                      sizeof( UCHAR ) );

        ProbeForRead( CapturedOutboundSecData,
                      CapturedOutboundSecDataSize,
                      sizeof( UCHAR ) );

        //
        // make local copies of everything since security doesn't
        // handle accvios very well
        //

        KPackageName = CnAllocatePoolWithQuota( PackageNameSize );
        if ( KPackageName == NULL ) {
            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }

        RtlCopyMemory( KPackageName, PackageName, PackageNameSize );

        KInboundSecBuffer = CnAllocatePoolWithQuota( sizeof( SecBuffer ));
        if ( KInboundSecBuffer == NULL ) {
            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }
        *KInboundSecBuffer = *InboundSecBuffer;
        KInboundSecBuffer->cbBuffer = CapturedInboundSecDataSize;

        KOutboundSecBuffer = CnAllocatePoolWithQuota( sizeof( SecBuffer ));
        if ( KOutboundSecBuffer == NULL ) {
            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }
        *KOutboundSecBuffer = *OutboundSecBuffer;
        KOutboundSecBuffer->cbBuffer = CapturedOutboundSecDataSize;

        KInboundData = CnAllocatePoolWithQuota( KInboundSecBuffer->cbBuffer );
        if ( KInboundData == NULL ) {
            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }
        RtlCopyMemory( KInboundData, CapturedInboundSecData, CapturedInboundSecDataSize );
        KInboundSecBuffer->pvBuffer = KInboundData;

        KOutboundData = CnAllocatePoolWithQuota( KOutboundSecBuffer->cbBuffer );
        if ( KOutboundData == NULL ) {
            ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
        }
        RtlCopyMemory( KOutboundData, CapturedOutboundSecData, CapturedOutboundSecDataSize );
        KOutboundSecBuffer->pvBuffer = KOutboundData;

    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception was incurred while attempting to probe or copy
        // from one of the caller's parameters. Simply return an
        // appropriate error status code.
        //

        Status = GetExceptionCode();
        IF_CNDBG( CN_DEBUG_INIT )
            CNPRINT(("[CCMP]: Buffer probe failed %08X", Status ));

        goto error_exit;
    }

    //
    // import the data we were handed
    //

    RtlInitUnicodeString( &PackageNameDesc, KPackageName );

    Status = ImportSecurityContext(&PackageNameDesc,
                                   KInboundSecBuffer,
                                   NULL,
                                   &InboundContext);

    if ( NT_SUCCESS( Status )) {

        Status = ImportSecurityContext(&PackageNameDesc,
                                       KOutboundSecBuffer,
                                       NULL,
                                       &OutboundContext);

        if ( NT_SUCCESS( Status )) {
            CtxtHandle oldInbound;
            CtxtHandle oldOutbound;
            PCLUSNET_SECURITY_DATA contextData = &SecurityContexts[ NodeId ];

            INVALIDATE_SSPI_HANDLE( oldInbound );
            INVALIDATE_SSPI_HANDLE( oldOutbound );

            //
            // DeleteSecurityContext can't be called at raised IRQL so make
            // copies of the contexts to be deleted under the lock. After
            // releasing the lock, we can delete the old contexts.
            //

            CnAcquireLock( &SecCtxtLock, &SecContextIrql );

            if ( VALID_SSPI_HANDLE( contextData->Inbound )) {
                oldInbound = contextData->Inbound;
            }

            if ( VALID_SSPI_HANDLE( contextData->Outbound )) {
                oldOutbound = contextData->Outbound;
            }

            contextData->Inbound = InboundContext;
            contextData->Outbound = OutboundContext;
            contextData->SignatureBufferSize = SignatureSize;

            //
            // Update MaxSignatureSize -- the largest signature imported
            // so far.
            //
            if (SignatureSize > MaxSignatureSize) {
                MaxSignatureSize = SignatureSize;
            }

            CnReleaseLock( &SecCtxtLock, SecContextIrql );

            if ( VALID_SSPI_HANDLE( oldInbound )) {
                DeleteSecurityContext( &oldInbound );
            }

            if ( VALID_SSPI_HANDLE( oldOutbound )) {
                DeleteSecurityContext( &oldOutbound );
            }
        } else {
            IF_CNDBG( CN_DEBUG_INIT )
                CNPRINT(("[CCMP]: import of outbound security context failed  %08X\n", Status ));

            DeleteSecurityContext( &InboundContext );

            goto error_exit;
        }
    } else {
        IF_CNDBG( CN_DEBUG_INIT )
            CNPRINT(("[CCMP]: import of inbound security context failed %08X\n", Status ));
        goto error_exit;
    }

error_exit:

    //
    // Clean up allocations.
    //

    if ( KPackageName ) {
        CnFreePool( KPackageName );
    }

    if ( KInboundSecBuffer ) {
        CnFreePool( KInboundSecBuffer );
    }

    if ( KOutboundSecBuffer ) {
        CnFreePool( KOutboundSecBuffer );
    }

    if ( KInboundData ) {
        CnFreePool( KInboundData );
    }

    if ( KOutboundData ) {
        CnFreePool( KOutboundData );
    }

    if (NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // The following is only executed in an error situation.
    //

    IF_CNDBG( CN_DEBUG_INIT ) {
        CNPRINT(("[CCMP]: CxImportSecurityContext returning %08X%\n", Status));
    }
    
    if (CcmpMcastHBSendRequestPool != NULL) {
        CnpDeleteSendRequestPool(CcmpMcastHBSendRequestPool);
        CcmpMcastHBSendRequestPool = NULL;
    }
    if (SignatureLL != NULL) {
        ExDeleteNPagedLookasideList(SignatureLL);
        CnFreePool(SignatureLL);
        SignatureLL = NULL;
    }

    return Status;

} // CxImportSecurityContext
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\xport\chbeat.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    chbeat.c

Abstract:

    membership state heart beat code. Tracks node availability through
    exchanging heart beat messages with nodes that are marked as alive.

Author:

    Charlie Wickham (charlwi) 05-Mar-1997

Environment:

    Kernel Mode

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "chbeat.tmh"

#include "clusvmsg.h"
#include "stdio.h"

/* External */

/* Static */

//
// heart beat structures - heart beats are driven by a timer and DPC
// routine. In order to synchronize the shutdown of the DPC, we also need two
// flags, an event and a spin lock.
//

KTIMER HeartBeatTimer;
KDPC HeartBeatDpc;
KEVENT HeartBeatDpcFinished;
BOOLEAN HeartBeatEnabled = FALSE;
BOOLEAN HeartBeatDpcRunning = FALSE;
CN_LOCK HeartBeatLock;

//
// heart beat period in millisecs
//

#define HEART_BEAT_PERIOD 600

#if 0

Heart Beating Explained

ClockTicks are incremented every HEART_BEAT_PERIOD millisecs. SendTicks are the
number of ticks that go by before sending HBs.

The check for received HB msgs is done in the tick just before HB msgs are
sent. Interface Lost HB ticks are in terms of heart beat check periods and
therefore are incremented only during the check period. An interface is failed
when the number of Interface Lost HB ticks have passed and no HB message has
been received on that interface.

Likewise, Node Lost HB Ticks are in terms of heart beat check periods and are
incremented during the check period. After all interfaces have failed on a
node, Node Lost HB ticks must pass without an interface going back online
before a node down event is issued.  Note that a node's comm state is set to
offline when all interfaces have failed.

#endif

#define CLUSNET_HEART_BEAT_SEND_TICKS           2       // every 1.2 secs
#define CLUSNET_INTERFACE_LOST_HEART_BEAT_TICKS 3       // after 3 secs
#define CLUSNET_NODE_LOST_HEART_BEAT_TICKS      6       // after 6.6 secs

ULONG HeartBeatClockTicks;
ULONG HeartBeatSendTicks = CLUSNET_HEART_BEAT_SEND_TICKS;
ULONG HBInterfaceLostHBTicks = CLUSNET_INTERFACE_LOST_HEART_BEAT_TICKS;
ULONG HBNodeLostHBTicks = CLUSNET_NODE_LOST_HEART_BEAT_TICKS;

//
// Unicast Heartbeat Data
//
// Even with multicast heartbeats, unicast heartbeats must be supported
// for backwards compatibility.
//

//
// This array records all the nodes that need to have a HB sent to another
// node. This array is not protected by a lock since it is only used with the
// heartbeat DPC routine.
//

typedef struct _INTERFACE_HEARTBEAT_INFO {
    CL_NODE_ID NodeId;
    CL_NETWORK_ID NetworkId;
    ULONG SeqNumber;
    ULONG AckNumber;
} INTERFACE_HEARTBEAT_INFO, *PINTERFACE_HEARTBEAT_INFO;

#define InterfaceHBInfoInitialLength            16
#define InterfaceHBInfoLengthIncrement          4

PINTERFACE_HEARTBEAT_INFO InterfaceHeartBeatInfo = NULL;
ULONG InterfaceHBInfoCount;         // running count while sending HBs
ULONG InterfaceHBInfoCurrentLength; // current length of HB info array

LARGE_INTEGER HBTime;       // HB time in relative sys time
#define MAX_DPC_SKEW    ( -HBTime.QuadPart / 2 )

//
// Outerscreen mask. This is set by clussvc's membership manager in user
// mode. As it changes, MM drops down the set outerscreen Ioctl to update
// clusnet's notion of this mask. Clusnet uses this mask to determine the
// validity of a received heart beat. If the sending node is not part
// of the mask, then it is sent a poison packet and the received event
// is not passed on to other consumers. If it is a legetimate PP, then
// we generate the proper event.
//
// Note: MM type definitions and macros have been moved to cnpdef.h for
//       general usage.
//
typedef CX_CLUSTERSCREEN CX_OUTERSCREEN;

CX_OUTERSCREEN MMOuterscreen;


// Multicast Heartbeat Data
//
typedef struct _NETWORK_MCAST_HEARTBEAT_INFO {
    CL_NETWORK_ID        NetworkId;
    PCNP_MULTICAST_GROUP McastGroup;
    CX_HB_NODE_INFO      NodeInfo[ClusterDefaultMaxNodes+ClusterMinNodeId];
    CX_CLUSTERSCREEN     McastTarget;
} NETWORK_MCAST_HEARTBEAT_INFO, *PNETWORK_MCAST_HEARTBEAT_INFO;

#define NetworkHBInfoInitialLength            4
#define NetworkHBInfoLengthIncrement          4

PNETWORK_MCAST_HEARTBEAT_INFO NetworkHeartBeatInfo = NULL;
ULONG NetworkHBInfoCount;         // running count while sending HBs
ULONG NetworkHBInfoCurrentLength; // current length of HB info array

CL_NETWORK_ID     MulticastBestNetwork = ClusterAnyNetworkId;

/* Forward */

NTSTATUS
CxInitializeHeartBeat(
    void
    );

VOID
CxUnloadHeartBeat(
    VOID
    );

VOID
CnpHeartBeatDpc(
    PKDPC DpcObject,
    PVOID DeferredContext,
    PVOID Arg1,
    PVOID Arg2
    );

BOOLEAN
CnpWalkNodesToSendHeartBeats(
    IN  PCNP_NODE   UpdateNode,
    IN  PVOID       UpdateContext,
    IN  CN_IRQL     NodeTableIrql
    );

BOOLEAN
CnpWalkNodesToCheckForHeartBeats(
    IN  PCNP_NODE   UpdateNode,
    IN  PVOID       UpdateContext,
    IN  CN_IRQL     NodeTableIrql
    );

VOID
CnpSendHBs(
    IN  PCNP_INTERFACE   UpdateInterface
    );

NTSTATUS
CxSetOuterscreen(
    IN  ULONG Outerscreen
    );

VOID
CnpReceivePoisonPacket(
    IN  PCNP_NETWORK   Network,
    IN  CL_NODE_ID SourceNodeId,
    IN  ULONG SeqNumber
    );

/* End Forward */


#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, CxInitializeHeartBeat)
#pragma alloc_text(PAGE, CxUnloadHeartBeat)

#endif // ALLOC_PRAGMA



NTSTATUS
CxInitializeHeartBeat(
    void
    )

/*++

Routine Description:

    Init the mechanisms used to send and monitor heart beats

Arguments:

    None

Return Value:

    STATUS_INSUFFICIENT_RESOURCES if allocation fails.
    STATUS_SUCCESS otherwise.

--*/

{
    // allocate the interface info array
    InterfaceHBInfoCount = 0;
    InterfaceHBInfoCurrentLength = InterfaceHBInfoInitialLength;
    
    if (InterfaceHBInfoCurrentLength > 0) {
        InterfaceHeartBeatInfo = CnAllocatePool(
                                     InterfaceHBInfoCurrentLength 
                                     * sizeof(INTERFACE_HEARTBEAT_INFO)
                                     );
        if (InterfaceHeartBeatInfo == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    }

    // allocate the network info array
    NetworkHBInfoCount = 0;
    NetworkHBInfoCurrentLength = NetworkHBInfoInitialLength;

    if (NetworkHBInfoCurrentLength > 0) {
        NetworkHeartBeatInfo = CnAllocatePool(
                                   NetworkHBInfoCurrentLength
                                   * sizeof(NETWORK_MCAST_HEARTBEAT_INFO)
                                   );
        if (NetworkHeartBeatInfo == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
        RtlZeroMemory(
            NetworkHeartBeatInfo, 
            NetworkHBInfoCurrentLength * sizeof(NETWORK_MCAST_HEARTBEAT_INFO)
            );
    }

    KeInitializeTimer( &HeartBeatTimer );
    KeInitializeDpc( &HeartBeatDpc, CnpHeartBeatDpc, NULL );
    KeInitializeEvent( &HeartBeatDpcFinished, SynchronizationEvent, FALSE );
    CnInitializeLock( &HeartBeatLock, CNP_HBEAT_LOCK );

    MEMLOG( MemLogInitHB, 0, 0 );

    return(STATUS_SUCCESS);

} // CxInitializeHeartBeat


VOID
CxUnloadHeartBeat(
    VOID
    )
/*++

Routine Description:

    Called during clusnet driver unload. Free any data structures
    allocated to send and monitor heartbeats.

Arguments:

    None

Return Value:

    None

--*/
{
    PAGED_CODE();

    if (InterfaceHeartBeatInfo != NULL) {
        CnFreePool(InterfaceHeartBeatInfo);
        InterfaceHeartBeatInfo = NULL;
    }

    if (NetworkHeartBeatInfo != NULL) {
        CnFreePool(NetworkHeartBeatInfo);
        NetworkHeartBeatInfo = NULL;
    }

    return;

} // CxUnloadHeartBeat


VOID
CnpStartHeartBeats(
    VOID
    )

/*++

Routine Description:

    Start heart beating with the nodes that are marked alive and have
    an interface marked either OnlinePending or Online.

Arguments:

    None

Return Value:

    None

--*/

{
    BOOLEAN TimerInserted;
    CN_IRQL OldIrql;
    ULONG period = HEART_BEAT_PERIOD;


    CnAcquireLock( &HeartBeatLock, &OldIrql );

    HBTime.QuadPart = Int32x32To64( HEART_BEAT_PERIOD, -10000 );

    TimerInserted = KeSetTimerEx(&HeartBeatTimer,
                                 HBTime,
                                 HEART_BEAT_PERIOD,
                                 &HeartBeatDpc);

    HeartBeatEnabled = TRUE;

    CnTrace(HBEAT_EVENT, HbTraceTimerStarted,
        "[HB] Heartbeat timer started. Period = %u ms.",
        period // LOGULONG
        );            
    
    MEMLOG( MemLogHBStarted, HEART_BEAT_PERIOD, 0 );

    CnReleaseLock( &HeartBeatLock, OldIrql );

} // CnpStartHeartBeats

VOID
CnpStopHeartBeats(
    VOID
    )

/*++

Routine Description:

    Stop heart beating with other nodes in the cluster.

Arguments:

    None

Return Value:

    None

--*/

{
    BOOLEAN TimerCanceled;
    CN_IRQL OldIrql;

    CnAcquireLock( &HeartBeatLock, &OldIrql );

    if (HeartBeatEnabled) {
        HeartBeatEnabled = FALSE;

        //
        // Cancel the periodic timer. Contrary to what the DDK implies,
        // this does not cancel the DPC if it is still queued from the
        // last timer expiration. It only stops the timer from firing
        // again. This is true as of 8/99. See KiTimerListExpire() in
        // ntos\ke\dpcsup.c.
        //
        TimerCanceled = KeCancelTimer( &HeartBeatTimer );

        CnTrace(HBEAT_DETAIL, HbTraceTimerCancelled,
            "[HB] Heartbeat timer cancelled: %!bool!",
            TimerCanceled // LOGBOOLEAN
            );

        MEMLOG( MemLogHBStopped, 0, 0 );

        //
        // Remove the DPC associated with the timer from the system DPC
        // queue, if it is there. This actually does nothing, because a
        // timer DPC is only inserted into the system DPC  queue if it is
        // bound to a specific processor. Unbound DPCs are executed inline
        // on the current processor in the kernel's timer expiration code.
        // Note that the object for a periodic timer is reinserted into the
        // timer queue before the DPC is excuted. So, it is possible for the
        // timer and the associated DPC to be queued simultaneously. This is
        // true as of 8/99. See KiTimerListExpire() in ntos\ke\dpcsup.c.
        //
        // The bottom line is that there is no safe way to synchronize with
        // the execution of a timer DPC during driver unload. All we can
        // do is ensure that the DPC handler code recognizes that it should
        // abort execution immediately and hope that it does so before the
        // driver code is unloaded. We do this by setting the HeartBeatEnabled
        // flag to False above. If our DPC code happens to be executing at
        // this point in time on another processor, as denoted by
        // HeartBeatDpcRunning, we wait for it to finish.
        //
        if ( !KeRemoveQueueDpc( &HeartBeatDpc )) {

            CnTrace(HBEAT_DETAIL, HbTraceDpcRunning,
                "[HB] DPC not removed. HeartBeatDpcRunning = %!bool!",
                HeartBeatDpcRunning // LOGBOOLEAN
                );
        
            MEMLOG( MemLogHBDpcRunning, HeartBeatDpcRunning, 0 );

            if ( HeartBeatDpcRunning ) {

                CnReleaseLock( &HeartBeatLock, OldIrql );

                CnTrace(HBEAT_DETAIL, HbWaitForDpcToFinish,
                    "can't remove DPC; waiting on DPCFinished event"
                    );

                MEMLOG( MemLogWaitForDpcFinish, 0, 0 );

                KeWaitForSingleObject(&HeartBeatDpcFinished,
                                      Executive,
                                      KernelMode,
                                      FALSE,              // not alertable
                                      NULL);              // no timeout

                KeClearEvent( &HeartBeatDpcFinished );

                return;
            }
        }

        CnTrace(HBEAT_EVENT, HbTraceTimerStopped,
            "[HB] Heartbeat timer stopped."
            );

    }

    CnReleaseLock( &HeartBeatLock, OldIrql );

    return;

} // CnpStopHeartBeats

VOID
CnpSendMcastHBCompletion(
    IN NTSTATUS  Status,
    IN ULONG     BytesSent,
    IN PVOID     Context,
    IN PVOID     Buffer
)
/*++

Routine Description:
    
    Called when a mcast heartbeat send request completes 
    successfully or unsuccessfully. Dereferences the
    McastGroup data structure.
    
Arguments:

    Status - status of request
    
    BytesSent - not used
    
    Context - points to multicast group data structure
    
    Buffer - not used
    
Return value:

    None.
    
--*/
{
    PCNP_MULTICAST_GROUP mcastGroup = (PCNP_MULTICAST_GROUP) Context;

    CnAssert(mcastGroup != NULL);

    CnpDereferenceMulticastGroup(mcastGroup);

    return;

} // CnpSendMcastHBCompletion

NTSTATUS
CnpSendMcastHB(
    IN  PCNP_INTERFACE   Interface
    )
/*++

Routine Description:

    Writes multicast heartbeat data into the NetworkHeartBeatInfo
    array for target Interface.
    
Notes:

    Called from DPC with Network and Node locks held.
    Returns with Network and Node locks held.

--*/
{
    ULONG      i;
    BOOLEAN    networkConnected;

    // find the network info structure for this network
    for (i = 0; i < NetworkHBInfoCount; i++) {
        if (NetworkHeartBeatInfo[i].NetworkId 
            == Interface->Network->Id) {
            break;
        }
    }

    // start a new network info structure, if necessary
    if (i == NetworkHBInfoCount) {

        // before claiming an entry in the network info array,
        // make sure the array is large enough
        if (NetworkHBInfoCount >= NetworkHBInfoCurrentLength) {

            // need to allocate a new network info array

            PNETWORK_MCAST_HEARTBEAT_INFO tempInfo = NULL;
            PNETWORK_MCAST_HEARTBEAT_INFO freeInfo = NULL;
            ULONG                         tempLength;

            tempLength = NetworkHBInfoCurrentLength
                + NetworkHBInfoLengthIncrement;
            tempInfo = CnAllocatePool(
                           tempLength 
                           * sizeof(NETWORK_MCAST_HEARTBEAT_INFO)
                           );
            if (tempInfo == NULL) {

                CnTrace(
                    HBEAT_DETAIL, HbNetInfoArrayAllocFailed,
                    "[HB] Failed to allocate network heartbeat info "
                    "array of length %u. Cannot schedule heartbeat "
                    "for node %u on network %u.",
                    tempLength, 
                    Interface->Node->Id,
                    Interface->Network->Id
                    );

                // cannot continue. the failure to send this
                // heartbeat will not be fatal if we recover
                // quickly. if we do not recover, this node
                // will be poisoned, which is probably best
                // since it is dangerously low on nonpaged pool.

                return(STATUS_INSUFFICIENT_RESOURCES);

            } else {

                // the allocation was successful. establish
                // the new array as the heartbeat info
                // array.

                RtlZeroMemory(
                    tempInfo,
                    tempLength * sizeof(NETWORK_MCAST_HEARTBEAT_INFO)
                    );

                freeInfo = NetworkHeartBeatInfo;
                NetworkHeartBeatInfo = tempInfo;
                NetworkHBInfoCurrentLength = tempLength;

                if (freeInfo != NULL) {

                    if (NetworkHBInfoCount > 0) {
                        RtlCopyMemory(
                            NetworkHeartBeatInfo,
                            freeInfo,
                            NetworkHBInfoCount 
                            * sizeof(NETWORK_MCAST_HEARTBEAT_INFO)
                            );
                    }

                    CnFreePool(freeInfo);
                }

                CnTrace(
                    HBEAT_DETAIL, HbNetInfoArrayLengthIncreased,
                    "[HB] Increased network heartbeat info array "
                    "to size %u.",
                    NetworkHBInfoCurrentLength
                    );
            }
        }

        // increment the current counter
        NetworkHBInfoCount++;

        // initialize the information for this structure
        RtlZeroMemory(
            &NetworkHeartBeatInfo[i].McastTarget,
            sizeof(NetworkHeartBeatInfo[i].McastTarget)
            );
        NetworkHeartBeatInfo[i].NetworkId = Interface->Network->Id;
        NetworkHeartBeatInfo[i].McastGroup = 
            Interface->Network->CurrentMcastGroup;
        CnpReferenceMulticastGroup(NetworkHeartBeatInfo[i].McastGroup);
    }

    networkConnected = (BOOLEAN)(!CnpIsNetworkLocalDisconn(Interface->Network));

    CnTrace(HBEAT_DETAIL, HbTraceScheduleMcastHBForInterface,
        "[HB] Scheduling multicast HB for node %u on network %u "
        "(I/F state = %!ifstate!) "
        "(interface media connected = %!bool!).",
        Interface->Node->Id, // LOGULONG
        Interface->Network->Id, // LOGULONG
        Interface->State, // LOGIfState
        networkConnected
        );

    // fill in the network info for this node/interface
    NetworkHeartBeatInfo[i].NodeInfo[Interface->Node->Id].SeqNumber = 
        Interface->SequenceToSend;
    NetworkHeartBeatInfo[i].NodeInfo[Interface->Node->Id].AckNumber =
        Interface->LastSequenceReceived;
    CnpClusterScreenInsert(
        NetworkHeartBeatInfo[i].McastTarget.ClusterScreen,
        INT_NODE(Interface->Node->Id)
        );

    return(STATUS_SUCCESS);

} // CnpSendMcastHB

NTSTATUS
CnpSendUcastHB(
    IN  PCNP_INTERFACE   Interface
    )
/*++

Routine Description:

    Writes unicast heartbeat data into the InterfaceHeartBeatInfo
    array for target Interface.
    
Notes:

    Called from DPC with Network and Node locks held.
    Returns with Network and Node locks held.

--*/
{
    BOOLEAN    networkConnected;
    
    // before filling an entry in the heartbeat info array,
    // make sure the array is large enough.
    if (InterfaceHBInfoCount >= InterfaceHBInfoCurrentLength) {

        // need to allocate a new heartbeat info array

        PINTERFACE_HEARTBEAT_INFO tempInfo = NULL;
        PINTERFACE_HEARTBEAT_INFO freeInfo = NULL;
        ULONG                     tempLength;

        tempLength = InterfaceHBInfoCurrentLength 
            + InterfaceHBInfoLengthIncrement;
        tempInfo = CnAllocatePool(
                       tempLength * sizeof(INTERFACE_HEARTBEAT_INFO)
                       );
        if (tempInfo == NULL) {

            CnTrace(
                HBEAT_DETAIL, HbInfoArrayAllocFailed,
                "[HB] Failed to allocate heartbeat info "
                "array of length %u. Cannot schedule heartbeat "
                "for node %u on network %u.",
                tempLength, 
                Interface->Node->Id,
                Interface->Network->Id
                );

            // cannot continue. the failure to send this
            // heartbeat will not be fatal if we recover
            // quickly. if we do not recover, this node
            // will be poisoned, which is probably best
            // since it is dangerously low on nonpaged pool.

            return(STATUS_INSUFFICIENT_RESOURCES);

        } else {

            // the allocation was successful. establish
            // the new array as the heartbeat info
            // array.

            freeInfo = InterfaceHeartBeatInfo;
            InterfaceHeartBeatInfo = tempInfo;
            InterfaceHBInfoCurrentLength = tempLength;

            if (freeInfo != NULL) {

                if (InterfaceHBInfoCount > 0) {
                    RtlCopyMemory(
                        InterfaceHeartBeatInfo,
                        freeInfo,
                        InterfaceHBInfoCount * sizeof(INTERFACE_HEARTBEAT_INFO)
                        );
                }

                CnFreePool(freeInfo);
            }

            CnTrace(
                HBEAT_DETAIL, HbInfoArrayLengthIncreased,
                "[HB] Increased heartbeat info array to size %u.",
                InterfaceHBInfoCurrentLength
                );
        }
    }

    networkConnected = (BOOLEAN)(!CnpIsNetworkLocalDisconn(Interface->Network));

    CnTrace(HBEAT_DETAIL, HbTraceScheduleHBForInterface,
        "[HB] Scheduling HB for node %u on network %u (I/F state = %!ifstate!) "
        "(interface media connected = %!bool!).",
        Interface->Node->Id, // LOGULONG
        Interface->Network->Id, // LOGULONG
        Interface->State, // LOGIfState
        networkConnected
        );

    InterfaceHeartBeatInfo[ InterfaceHBInfoCount ].NodeId = Interface->Node->Id;
    InterfaceHeartBeatInfo[ InterfaceHBInfoCount ].SeqNumber =
        Interface->SequenceToSend;
    InterfaceHeartBeatInfo[ InterfaceHBInfoCount ].AckNumber =
        Interface->LastSequenceReceived;
    InterfaceHeartBeatInfo[ InterfaceHBInfoCount ].NetworkId = Interface->Network->Id;

    ++InterfaceHBInfoCount;

    return(STATUS_SUCCESS);

} // CnpSendUcastHB


VOID
CnpSendHBs(
    IN  PCNP_INTERFACE   Interface
    )

/*++

Routine Description:

    If Interface is in the correct state then stuff an entry in
    the heartbeat info array. Expand the heartbeat info
    array if necessary.

Arguments:

    Interface - target interface for heartbeat message

Return Value:

    None

--*/

{
    BOOLEAN mcastOnly = FALSE;

    if ( Interface->State >= ClusnetInterfaceStateUnreachable ) {

        // increment the sequence number
        (Interface->SequenceToSend)++;

        // check if we should include this interface in a 
        // multicast heartbeat. first we verify that the
        // network is multicast capable. then, we include it
        // if either of the following conditions are true:
        // - we have received a multicast heartbeat from the
        //   target interface
        // - the discovery count (the number of discovery mcasts
        //   left to send to the target interface) is greater 
        //   than zero
        if (CnpIsNetworkMulticastCapable(Interface->Network)) {
            
            if (CnpInterfaceQueryReceivedMulticast(Interface)) {

                // write the mcast heartbeat data. if not
                // successful, attempt a unicast heartbeat.
                if (CnpSendMcastHB(Interface) == STATUS_SUCCESS) {
                    mcastOnly = TRUE;
                }

            } else if (Interface->McastDiscoverCount > 0) {

                // write the mcast heartbeat data for a
                // discovery. if successful, decrement the
                // discovery count.
                if (CnpSendMcastHB(Interface) == STATUS_SUCCESS) {
                    --Interface->McastDiscoverCount;

                    // if the discovery count has reached zero,
                    // set the rediscovery countdown. this is
                    // the number of heartbeat periods until we
                    // try discovery again.
                    if (Interface->McastDiscoverCount == 0) {
                        Interface->McastRediscoveryCountdown = 
                            CNP_INTERFACE_MCAST_REDISCOVERY;
                    }
                }
            } else if (Interface->McastRediscoveryCountdown > 0) {

                // decrement the rediscovery countdown. if we
                // reach zero, we will start multicast discovery
                // on the next heartbeat to this interface.
                if (--Interface->McastRediscoveryCountdown == 0) {
                    Interface->McastDiscoverCount = 
                        CNP_INTERFACE_MCAST_DISCOVERY;
                }
            }
        }

        // write unicast heartbeat data
        if (!mcastOnly) {
            CnpSendUcastHB(Interface);
        }
    }

    CnReleaseLock(&Interface->Network->Lock, Interface->Network->Irql);

    return;

} // CnpSendHBs

VOID
CnpCheckForHBs(
    IN  PCNP_INTERFACE   Interface
    )

/*++

Routine Description:

    Check if heart beats have been received for this interface

Arguments:

    None

Return Value:

    None

--*/

{
    ULONG   MissedHBCount;
    BOOLEAN NetworkLockReleased = FALSE;

    if ( Interface->State >= ClusnetInterfaceStateUnreachable
         && !CnpIsNetworkLocalDisconn(Interface->Network) ) {

        MissedHBCount = InterlockedIncrement( &Interface->MissedHBs );

        if ( MissedHBCount == 1 ) {

            //
            // a HB was received in time for this node. Clear the status
            // info associated with this interface, but also mark the node
            // as having an interface that is ok. Note that we do not
            // use HBs on restricted nets to determine node health.
            //

            if (!CnpIsNetworkRestricted(Interface->Network)) {
                Interface->Node->HBWasMissed = FALSE;
            }
            
            CnTrace(HBEAT_DETAIL, HbTraceHBReceivedForInterface,
                "[HB] A HB was received from node %u on net %u in this "
                "period.",
                Interface->Node->Id, // LOGULONG
                Interface->Network->Id // LOGULONG
                );

        } else {
            CnTrace(HBEAT_EVENT, HbTraceMissedIfHB,
                "[HB] HB MISSED for node %u on net %u, missed count %u.",
                Interface->Node->Id, // LOGULONG
                Interface->Network->Id, // LOGULONG
                MissedHBCount // LOGULONG
                );

            MEMLOG4(
                MemLogMissedIfHB,
                (ULONG_PTR)Interface, MissedHBCount,
                Interface->Node->Id,
                Interface->Network->Id
                );

            if ( MissedHBCount >= HBInterfaceLostHBTicks &&
                 Interface->State >= ClusnetInterfaceStateOnlinePending ) {

                //
                // interface is either online pending or online, so move it
                // to unreachable. CnpFailInterface will also mark the node
                // unreachable if all of the node's interfaces are unreachable.
                // CnpFailInterface releases the network object lock as part
                // of its duties.
                //

                CnTrace(HBEAT_DETAIL, HbTraceFailInterface,
                    "[HB] Moving I/F for node %u on net %u to failed state, "
                    "previous I/F state = %!ifstate!.",
                    Interface->Node->Id, // LOGULONG
                    Interface->Network->Id, // LOGULONG
                    Interface->State // LOGIfState
                    );
                
                //
                // continuation log entries go before the main entry since
                // we scan the log backwards, i.e., we'll hit FailingIf
                // before we hit FailingIf1.
                //
                MEMLOG4(
                    MemLogFailingIf,
                    (ULONG_PTR)Interface,
                    Interface->State,
                    Interface->Node->Id,
                    Interface->Network->Id
                    );

                CnpFailInterface( Interface );
                NetworkLockReleased = TRUE;

                //
                // issue a net interface unreachable event to let consumers
                // know what is happening
                //
                CnTrace(HBEAT_EVENT, HbTraceInterfaceUnreachableEvent,
                    "[HB] Issuing InterfaceUnreachable event for node %u "
                    "on net %u, previous I/F state = %!ifstate!.",
                    Interface->Node->Id, // LOGULONG
                    Interface->Network->Id, // LOGULONG
                    Interface->State // LOGIfState
                    );
                
                CnIssueEvent(ClusnetEventNetInterfaceUnreachable,
                             Interface->Node->Id,
                             Interface->Network->Id);
            }
        }
    }

    if ( !NetworkLockReleased ) {

        CnReleaseLock(&Interface->Network->Lock,
                      Interface->Network->Irql);
    }

    return;

} // CnpCheckForHBs

BOOLEAN
CnpWalkNodesToSendHeartBeats(
    IN  PCNP_NODE   Node,
    IN  PVOID       UpdateContext,
    IN  CN_IRQL     NodeTableIrql
    )

/*++

Routine Description:

    Support routine called for each node in the node table. If node is
    alive, then we walk its interfaces, performing the appropriate
    action.

Arguments:

    None

Return Value:

    None

--*/

{
    //
    // If this node is alive and not the local node, then walk its
    // interfaces, supplying the appropriate routine to use at this time
    //

    if ( Node->MMState == ClusnetNodeStateAlive &&
         Node != CnpLocalNode ) {

        CnTrace(HBEAT_DETAIL, HbTraceScheduleHBForNode,
            "[HB] Scheduling HBs for node %u (state = %!mmstate!).",
            Node->Id, // LOGULONG
            Node->MMState // LOGMmState
            );
                
        MEMLOG( MemLogSendHBWalkNode, Node->Id, Node->MMState );
        CnpWalkInterfacesOnNode( Node, (PVOID)CnpSendHBs );
    }

    CnReleaseLock( &Node->Lock, Node->Irql );

    return TRUE;       // the node table lock is still held

} // CnpWalkNodesToSendHeartBeats

BOOLEAN
CnpWalkNodesToCheckForHeartBeats(
    IN  PCNP_NODE   Node,
    IN  PVOID       UpdateContext,
    IN  CN_IRQL     NodeTableIrql
    )

/*++

Routine Description:

    heart beat checking routine called for each node  in the node table
    (except for the local node). If node is alive, then we walk its
    interfaces, performing the appropriate action.

Arguments:

    None

Return Value:

    None

--*/

{
    BOOLEAN NodeWasReachable;
    ULONG MissedHBCount;

    if ( Node->MMState == ClusnetNodeStateAlive &&
         Node != CnpLocalNode ) {

        //
        // this node is alive, so walk its interfaces. Assume the
        // worst by setting the HB Missed flag to true and
        // have the interfaces prove that this is wrong. Also make
        // note of the current unreachable flag setting. If it changes
        // this time
        //

        NodeWasReachable = !CnpIsNodeUnreachable( Node );
        Node->HBWasMissed = TRUE;

        CnTrace(HBEAT_DETAIL, HbTraceCheckNodeForHeartbeats,
            "[HB] Checking for HBs from node %u. WasReachable = %!bool!, "
            "state = %!mmstate!.",
            Node->Id, // LOGULONG
            NodeWasReachable, // LOGBOOLEAN
            Node->MMState // LOGMmState
            );

        MEMLOG( MemLogCheckHBNodeReachable, Node->Id, NodeWasReachable );
        MEMLOG( MemLogCheckHBWalkNode, Node->Id, Node->MMState );

        CnpWalkInterfacesOnNode( Node, (PVOID)CnpCheckForHBs );

        if ( Node->HBWasMissed ) {

            //
            // no HBs received on any of this node's IFs. if membership
            // still thinks this node is alive and the node has been
            // unreachable, then note that this node is toast in HB
            // info array. This will cause a node down event to be
            // generated for this node.
            //

            MissedHBCount = InterlockedIncrement( &Node->MissedHBs );

            CnTrace(HBEAT_EVENT, HbTraceNodeMissedHB,
                "[HB] Node %u has missed %u HBs on all interfaces, "
                "current state = %!mmstate!.",
                Node->Id, // LOGULONG
                MissedHBCount, // LOGULONG
                Node->MMState // LOGMmState
                );

            MEMLOG( MemLogCheckHBMissedHB, MissedHBCount, Node->MMState );

            //
            // if the this node is a either a member or in the process of
            // joining AND it's missed too many HBs AND we haven't issued a
            // node down, then issue a node down.
            //
            if ( ( Node->MMState == ClusnetNodeStateAlive
                   ||
                   Node->MMState == ClusnetNodeStateJoining
                 )
                 && MissedHBCount >= HBNodeLostHBTicks
                 && !Node->NodeDownIssued
               )
            {
                Node->NodeDownIssued = TRUE;
                CnIssueEvent( ClusnetEventNodeDown, Node->Id, 0 );

                CnTrace(HBEAT_EVENT, HbTraceNodeDownEvent,
                    "[HB] Issuing NodeDown event for node %u.",
                    Node->Id // LOGULONG
                    );
                        
                MEMLOG( MemLogNodeDownIssued, Node->Id, TRUE );
            }
        }
    } else {
        MEMLOG( MemLogCheckHBWalkNode, Node->Id, Node->MMState );
    }

    CnReleaseLock( &Node->Lock, Node->Irql );

    return TRUE;       // the node table lock is still held

} // CnpWalkNodesToCheckForHeartBeats

VOID
CnpHeartBeatDpc(
    PKDPC DpcObject,
    PVOID DeferredContext,
    PVOID Arg1,
    PVOID Arg2
    )

/*++

Routine Description:

    Start heart beating with the nodes that are marked alive and have
    an interface marked either OnlinePending or Online.

Arguments:

    None

Return Value:

    None

--*/

{
    PINTERFACE_HEARTBEAT_INFO     pNodeHBInfo;
    PNETWORK_MCAST_HEARTBEAT_INFO pMcastHBInfo;
    CN_IRQL                       OldIrql;

#ifdef MEMLOGGING
    static LARGE_INTEGER LastSysTime;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER TimeDelta;

    //
    // try to determine the skew between when we asked to be run and
    // the time we actually did run
    //

    KeQuerySystemTime( &CurrentTime );

    if ( LastSysTime.QuadPart != 0 ) {

        //
        // add in HBTime which is negative due to relative sys time
        //

        TimeDelta.QuadPart = ( CurrentTime.QuadPart - LastSysTime.QuadPart ) +
            HBTime.QuadPart;

        if ( TimeDelta.QuadPart > MAX_DPC_SKEW ||
             TimeDelta.QuadPart < -MAX_DPC_SKEW 
           ) 
        {
            LONG skew = (LONG)(TimeDelta.QuadPart/10000);  // convert to ms

            MEMLOG( MemLogDpcTimeSkew, TimeDelta.LowPart, 0 );
            

            CnTrace(HBEAT_EVENT, HbTraceLateDpc,
                "[HB] Timer fired %d ms late.", 
                skew // LOGSLONG
                );

        }
    }

    LastSysTime.QuadPart = CurrentTime.QuadPart;

#endif // MEMLOGGING

    CnAcquireLock( &HeartBeatLock, &OldIrql );

    if ( !HeartBeatEnabled ) {
        CnTrace(HBEAT_DETAIL, HbTraceSetDpcEvent,
            "DPC: setting HeartBeatDpcFinished event"
            );
        
        MEMLOG( MemLogSetDpcEvent, 0, 0 );

        KeSetEvent( &HeartBeatDpcFinished, 0, FALSE );
        
        CnReleaseLock( &HeartBeatLock, OldIrql );
        
        return;
    }

    HeartBeatDpcRunning = TRUE;

    CnReleaseLock( &HeartBeatLock, OldIrql );

    if ( HeartBeatClockTicks == 0 ||
         HeartBeatClockTicks == HeartBeatSendTicks) {

        //
        // time to send HBs. Clear the count of target interfaces 
        // and walk the node table finding the nodes that are
        // marked alive.
        //

        NetworkHBInfoCount = 0;
        InterfaceHBInfoCount = 0;
        CnpWalkNodeTable( CnpWalkNodesToSendHeartBeats, NULL );

        //
        // run down the list of networks and send out any multicast
        // heartbeats.
        //

        pMcastHBInfo = NetworkHeartBeatInfo;
        while ( NetworkHBInfoCount-- ) {

            CnTrace(
                HBEAT_EVENT, HbTraceSendMcastHB,
                "[HB] Sending multicast HB on net %u.\n",
                pMcastHBInfo->NetworkId
                );

            CxSendMcastHeartBeatMessage(
                pMcastHBInfo->NetworkId,
                pMcastHBInfo->McastGroup,
                pMcastHBInfo->McastTarget,
                pMcastHBInfo->NodeInfo,
                CnpSendMcastHBCompletion,
                pMcastHBInfo->McastGroup
                );

            ++pMcastHBInfo;
        }

        //
        // now run down the list of interfaces that we compiled and
        // send any unicast packets
        //

        pNodeHBInfo = InterfaceHeartBeatInfo;
        while ( InterfaceHBInfoCount-- ) {

            CnTrace(HBEAT_EVENT, HbTraceSendHB,
                "[HB] Sending HB to node %u on net %u, seqno %u, ackno %u.",
                pNodeHBInfo->NodeId, // LOGULONG
                pNodeHBInfo->NetworkId, // LOGULONG
                pNodeHBInfo->SeqNumber, // LOGULONG
                pNodeHBInfo->AckNumber // LOGULONG
            );

            CxSendHeartBeatMessage(pNodeHBInfo->NodeId,
                                   pNodeHBInfo->SeqNumber,
                                   pNodeHBInfo->AckNumber,
                                   pNodeHBInfo->NetworkId);

            MEMLOG(
                MemLogSendingHB, 
                pNodeHBInfo->NodeId, 
                pNodeHBInfo->NetworkId
                );

            ++pNodeHBInfo;
        }

        //
        // finally, up the tick count, progressing to the next potential
        // work item
        //

        HeartBeatClockTicks++;

    } else if ( HeartBeatClockTicks >= ( HeartBeatSendTicks - 1 )) {

        //
        // walk the node table looking for lack of heart beats on
        // a node's set of interfaces.
        //
        CnpWalkNodeTable( CnpWalkNodesToCheckForHeartBeats, NULL );
        HeartBeatClockTicks = 0;

    } else {

        HeartBeatClockTicks++;
    }

    //
    // indicate that we're no longer running and if we're shutting down
    // then set the event that the shutdown thread is waiting on
    //

    CnAcquireLock( &HeartBeatLock, &OldIrql );
    HeartBeatDpcRunning = FALSE;

    if ( !HeartBeatEnabled ) {
        KeSetEvent( &HeartBeatDpcFinished, 0, FALSE );

        CnTrace(HBEAT_DETAIL, HbTraceSetDpcEvent2,
            "DPC: setting HeartBeatDpcFinished event (2)"
            );
                 
        MEMLOG( MemLogSetDpcEvent, 0, 0 );
    }

    CnReleaseLock( &HeartBeatLock, OldIrql );

} // CnpHeartBeatDpc

PCNP_INTERFACE
CnpFindInterfaceLocked(
    IN  PCNP_NODE Node,
    IN  PCNP_NETWORK Network
    )

/*++

Routine Description:

    Given node and network structure pointers, find the interface
    structure. Similar to CnpFindInterface except that we're passing
    in pointers instead of IDs.

Arguments:

    Node - pointer to node struct that sent the packet
    Network - pointer to Network struct on which packet was received

Return Value:

    Pointer to Interface on which packet was recv'd, otherwise NULL

--*/

{
    PLIST_ENTRY IfEntry;
    PCNP_INTERFACE Interface;

    CnVerifyCpuLockMask(CNP_NODE_OBJECT_LOCK,         // Required
                        0,                            // Forbidden
                        CNP_NETWORK_OBJECT_LOCK_MAX   // Maximum
                        );

    for (IfEntry = Node->InterfaceList.Flink;
         IfEntry != &(Node->InterfaceList);
         IfEntry = IfEntry->Flink
         )
        {
            Interface = CONTAINING_RECORD(IfEntry,
                                          CNP_INTERFACE,
                                          NodeLinkage);

            if ( Interface->Network == Network ) {
                break;
            }
        }


    if ( IfEntry == &Node->InterfaceList ) {

        return NULL;
    } else {

        return Interface;
    }
} // CnpFindInterfaceLocked

VOID
CnpReceiveHeartBeatMessage(
    IN  PCNP_NETWORK Network,
    IN  CL_NODE_ID SourceNodeId,
    IN  ULONG SeqNumber,
    IN  ULONG AckNumber,
    IN  BOOLEAN Multicast
    )

/*++

Routine Description:

    We received a heartbeat from a node on a network. Reset
    the missed HB count on that network's interface.


Arguments:

    Network - pointer to network block on which the packet was received

    SourceNodeId - node number that issued the packet

    SeqNumber - sending nodes' sequence num

    AckNumber - last seq number sent by us that was seen at the sending node
    
    Multicast - indicates whether this heartbeat was received in a multicast

Return Value:

    None

--*/

{
    PCNP_NODE Node;
    PCNP_INTERFACE Interface;
    CX_OUTERSCREEN CurrentOuterscreen;
    BOOLEAN IssueNetInterfaceUpEvent = FALSE;

    //
    // we ignore all packets until we're part of the cluster
    //

    CurrentOuterscreen.UlongScreen = InterlockedExchange(
                                         &MMOuterscreen.UlongScreen,
                                         MMOuterscreen.UlongScreen);

    if ( !CnpClusterScreenMember(
              CurrentOuterscreen.ClusterScreen,
              INT_NODE( CnLocalNodeId )
              )
       )
    {
        return;
    }

    //
    // convert the Node ID into a pointer and find the interface
    // on which the packet was received.
    //

    Node = CnpFindNode( SourceNodeId );
    CnAssert( Node != NULL );

    Interface = CnpFindInterfaceLocked( Node, Network );

    if ( Interface == NULL ) {

        //
        // somehow this network object went away while we were
        // receiving some data on it. Just ignore this msg
        //

        CnTrace(HBEAT_ERROR, HbTraceHBFromUnknownNetwork,
            "[HB] Discarding HB from node %u on an unknown network.",
            Node->Id // LOGULONG
            );

        MEMLOG( MemLogNoNetID, Node->Id, (ULONG_PTR)Network );
        goto error_exit;
    }

    //
    // determine if this is guy is legit. If not in the outerscreen,
    // then send a poison packet and we're done
    //

    if ( !CnpClusterScreenMember(
              CurrentOuterscreen.ClusterScreen,
              INT_NODE( SourceNodeId )
              )
       )
    {
        //
        // Don't bother sending poison packets on restricted networks. They
        // will be ignored.
        //
        if (CnpIsNetworkRestricted(Interface->Network)) {
            goto error_exit;
        }

        CnTrace(HBEAT_ERROR, HbTraceHBFromBanishedNode,
            "[HB] Discarding HB from banished node %u on net %u "
            "due to outerscreen %04X. Sending poison packet back.",
            Node->Id, // LOGULONG
            Interface->Network->Id, // LOGULONG
            CurrentOuterscreen.UlongScreen // LOGULONG
            );

        CcmpSendPoisonPacket( Node, NULL, 0, Network, NULL);
        //
        // The node lock was released.
        //
        return;
    }

    //
    // Indicate that a multicast has been received from this interface.
    // This allows us to include this interface in our multicasts.
    //
    if (Multicast) {
        IF_CNDBG(CN_DEBUG_HBEATS) {
            CNPRINT(("[HB] Received multicast heartbeat on "
                     "network %d from source node %d, seq %d, "
                     "ack %d.\n",
                     Network->Id, SourceNodeId,
                     SeqNumber, AckNumber
                     ));
        }

        if (!CnpInterfaceQueryReceivedMulticast(Interface)) {
            
            CnpInterfaceSetReceivedMulticast(Interface);
            
            CnpMulticastChangeNodeReachability(
                Network,
                Node,
                TRUE,    // reachable
                TRUE,    // raise event
                NULL     // OUT new mask
                );
        }

        // There is no point in sending discovery packets to this
        // interface.
        Interface->McastDiscoverCount = 0;
        Interface->McastRediscoveryCountdown = 0;
    }

    //
    // Check that the incoming seq num is something we expect to
    // guard against replay attacks.
    //
    if ( SeqNumber <= Interface->LastSequenceReceived) {

        CnTrace( 
            HBEAT_ERROR, HbTraceHBOutOfSequence,
            "[HB] Discarding HB from node %u on net %u with stale seqno %u. "
            "Last seqno %u. Multicast: %!bool!.",
            Node->Id, // LOGULONG
            Interface->Network->Id, // LOGULONG
            SeqNumber, // LOGULONG
            Interface->LastSequenceReceived, // LOGULONG
            Multicast
            );

        MEMLOG( MemLogOutOfSequence, SourceNodeId, SeqNumber );

        goto error_exit;
    }

    // Update the interface's last received seq number
    // which will be sent back as the ack number.
    Interface->LastSequenceReceived = SeqNumber;

    //
    // Compare our seq number to the ack number in the packet.
    // If more than two off then the source node is not recv'ing
    // our heartbeats, but we're receiving theirs. This network is
    // not usable. We ignore this msg to guarantee that we will
    // declare the network down if the condition persists.
    //
    // In addition, if we are sending multicast heartbeats to this
    // interface, revert to unicasts in case there is a multicast
    // problem.
    //
    if (( Interface->SequenceToSend - AckNumber ) > 2 ) {

        CnTrace(HBEAT_ERROR, HbTraceHBWithStaleAck,
            "[HB] Discarding HB from node %u with stale ackno %u. "
            "My seqno %u. Multicast: %!bool!.",
            Node->Id, // LOGULONG
            AckNumber, // LOGULONG
            Interface->SequenceToSend, // LOGULONG
            Multicast
            );

        MEMLOG( MemLogSeqAckMismatch, (ULONG_PTR)Interface, Interface->State );

        if (CnpInterfaceQueryReceivedMulticast(Interface)) {
            CnpInterfaceClearReceivedMulticast(Interface);
            Interface->McastDiscoverCount = CNP_INTERFACE_MCAST_DISCOVERY;
            CnpMulticastChangeNodeReachability(
                Network,
                Node,
                FALSE,   // not reachable
                TRUE,    // raise event
                NULL     // OUT new mask
                );
        }

        goto error_exit;
    }

    MEMLOG4( MemLogReceivedPacket,
             SeqNumber, AckNumber,
             SourceNodeId, Interface->Network->Id );

    CnTrace(HBEAT_EVENT, HbTraceReceivedHBpacket,
        "[HB] Received HB from node %u on net %u, seqno %u, ackno %u, "
        "multicast: %!bool!.",
        SourceNodeId, // LOGULONG
        Interface->Network->Id, // LOGULONG
        SeqNumber, // LOGULONG
        AckNumber, // LOGULONG
        Multicast
        );

    // Reset the interface's and node's Missed HB count
    // to indicate that things are somewhat normal.
    //
    InterlockedExchange( &Interface->MissedHBs, 0 );

    //
    // Don't reset node miss count on restricted nets.
    //
    if (!CnpIsNetworkRestricted(Interface->Network)) {
        InterlockedExchange( &Node->MissedHBs, 0 );
    }

    //
    // if local interface was previously disconnected (e.g. received
    // a WMI NDIS status media disconnect event), reconnect it now.
    //
    if (CnpIsNetworkLocalDisconn(Interface->Network)) {
        CxReconnectLocalInterface(Interface->Network->Id);
    }

    //
    // move interface to online if necessary
    //
    if ( Interface->State == ClusnetInterfaceStateOnlinePending ||
         Interface->State == ClusnetInterfaceStateUnreachable ) {

        CnAcquireLockAtDpc( &Interface->Network->Lock );
        Interface->Network->Irql = DISPATCH_LEVEL;

        CnTrace(HBEAT_DETAIL, HbTraceInterfaceOnline,
            "[HB] Moving interface for node %u on network %u to online "
            "state.",
            Node->Id, // LOGULONG
            Interface->Network->Id // LOGULONG
            );                

        MEMLOG( MemLogOnlineIf, Node->Id, Interface->State );

        //
        // Events acquire the IO cancel spin lock so we do this after
        // node and network locks have been released and only if we're
        // moving from unreachable.
        //

        IssueNetInterfaceUpEvent = TRUE;

        CnpOnlineInterface( Interface );
    }

    CnReleaseLock( &Node->Lock, Node->Irql );

    if ( IssueNetInterfaceUpEvent ) {

        CnTrace(HBEAT_EVENT, HbTraceInterfaceUpEvent,
            "[HB] Issuing InterfaceUp event for node %u on network %u.",
            Node->Id, // LOGULONG
            Interface->Network->Id // LOGULONG
            );                

        CnIssueEvent(ClusnetEventNetInterfaceUp,
                     Node->Id,
                     Interface->Network->Id);
    }

    //
    // when the first HB is recv'ed, a node may be in either the
    // join or alive state (the sponser, for instance, moves from
    // dead to alive). We need to clear the Node down issued flag
    // for either case. If the MM State is joining, then a node up
    // event must be issued as well. Note that we ignore HBs for
    // node health purposes on restricted nets.
    //

    if ( ( (Node->MMState == ClusnetNodeStateJoining)
           ||
           (Node->MMState == ClusnetNodeStateAlive)
         )
         &&
         Node->NodeDownIssued
         &&
         !CnpIsNetworkRestricted(Interface->Network)
       )
    {

        Node->NodeDownIssued = FALSE;
        MEMLOG( MemLogNodeDownIssued, Node->Id, FALSE );

        if ( Node->MMState == ClusnetNodeStateJoining ) {

            CnTrace(HBEAT_EVENT, HbTraceNodeUpEvent,
                "[HB] Issuing NodeUp event for node %u.",
                Node->Id // LOGULONG
                );   
            
            MEMLOG( MemLogNodeUp, Node->Id, 0 );

            CnIssueEvent( ClusnetEventNodeUp, Node->Id, 0 );
        }
    }

    return;

error_exit:

    CnReleaseLock( &Node->Lock, Node->Irql );
    return;

} // CnpReceiveHeartBeatMessage

NTSTATUS
CxSetOuterscreen(
    IN  ULONG Outerscreen
    )
{
    //
    // based on the number of valid nodes, make sure any extranious
    // bits are not set
    //

    CnAssert( ClusterDefaultMaxNodes <= 32 );
    CnAssert(
        ( Outerscreen & ( 0xFFFFFFFE << ( 32 - ClusterDefaultMaxNodes - 1 )))
        == 0);

    IF_CNDBG( CN_DEBUG_HBEATS )
        CNPRINT(("[CCMP] Setting outerscreen to %04X\n",
                 ((Outerscreen & 0xFF)<< 8) | ((Outerscreen >> 8) & 0xFF)));

    InterlockedExchange( &MMOuterscreen.UlongScreen, Outerscreen );

    CnTrace(HBEAT_EVENT, HbTraceSetOuterscreen,
        "[HB] Setting outerscreen to %04X",
        Outerscreen // LOGULONG
        );

    MEMLOG( MemLogOuterscreen, Outerscreen, 0 );

    return STATUS_SUCCESS;
} // CxSetOuterscreen

VOID
CnpTerminateClusterService(
    IN PVOID Parameter
    )
{
    PWORK_QUEUE_ITEM workQueueItem = Parameter;
    ULONG sourceNodeId = *((PULONG)(workQueueItem + 1));
    WCHAR sourceNodeStringId[ 16 ];

    swprintf(sourceNodeStringId, L"%u", sourceNodeId );

    //
    // only way we can get here right now is if a poison packet was received.
    //
    CnWriteErrorLogEntry(CLNET_NODE_POISONED,
                         STATUS_SUCCESS,
                         NULL,
                         0,
                         1,
                         sourceNodeStringId );

    if ( ClussvcProcessHandle ) {

        //
        // there is still a race condition between the cluster service shutting
        // down and closing this handle and it being used here. This really
        // isn't a problem since the user mode portion is going away anyway.
        // Besides, there isn't alot we can do if this call doesn't work anyway.
        //

        ZwTerminateProcess( ClussvcProcessHandle, STATUS_CLUSTER_POISONED );
    }

    CnFreePool( Parameter );
} // CnpTerminateClusterService

VOID
CnpReceivePoisonPacket(
    IN  PCNP_NETWORK   Network,
    IN  CL_NODE_ID SourceNodeId,
    IN  ULONG SeqNumber
    )
{
    PCNP_NODE Node;
    PCNP_INTERFACE Interface;
    PWORK_QUEUE_ITEM WorkItem;

    
    //
    // give the node and the network pointers, find the interface on which
    // this packet was received
    //

    Node = CnpFindNode( SourceNodeId );
    
    if ( Node == NULL ) {
        CnTrace(HBEAT_ERROR, HbTraceNoPoisonFromUnknownNode,
        "[HB] Discarding poison packet from unknown node %u.",
        Node->Id // LOGULONG
        );
        return;
    }

    Interface = CnpFindInterfaceLocked( Node, Network );

    if ( Interface == NULL ) {

        //
        // somehow this network object went away while we were
        // receiving some data on it. Just ignore this msg
        //
        CnTrace(HBEAT_ERROR, HbTracePoisonFromUnknownNetwork,
            "[HB] Discarding poison packet from node %u on unknown network.",
            Node->Id // LOGULONG
            );

        MEMLOG( MemLogNoNetID, Node->Id, (ULONG_PTR)Network );

        CnReleaseLock( &Node->Lock, Node->Irql );
        return;
    }

    //
    // Check that the incoming seq num is something we expect to
    // guard against replay attacks.
    //

    if ( SeqNumber <= Interface->LastSequenceReceived) {

        CnTrace(HBEAT_ERROR , HbTracePoisonOutOfSeq,
            "[HB] Discarding poison packet from node %u with stale seqno %u. "
            "Current seqno %u.",
            SourceNodeId, // LOGULONG
            SeqNumber, // LOGULONG
            Interface->LastSequenceReceived // LOGULONG
            );

        MEMLOG( MemLogOutOfSequence, SourceNodeId, SeqNumber );

        CnReleaseLock( &Node->Lock, Node->Irql );
        return;
    }

    //
    // Ignore poison packets from restricted networks
    //
    if (CnpIsNetworkRestricted(Network)) {

        CnTrace(HBEAT_ERROR , HbTracePoisonFromRestrictedNet,
            "[HB] Discarding poison packet from node %u on restricted "
            "network %u.",
            SourceNodeId, // LOGULONG
            Network->Id // LOGULONG
            );

        CnReleaseLock( &Node->Lock, Node->Irql );
        return;
    }

    //
    // We always honor a recv'ed poison packet.
    //

    CnReleaseLock( &Node->Lock, Node->Irql );

    CnTrace(HBEAT_EVENT, HbTracePoisonPktReceived,
        "[HB] Received poison packet from node %u. Halting this node.",
        SourceNodeId // LOGULONG
        );            

    MEMLOG( MemLogPoisonPktReceived, SourceNodeId, 0 );

    CnIssueEvent( ClusnetEventPoisonPacketReceived, SourceNodeId, 0 );

    //
    // Shutdown all cluster network processing.
    //
    CnHaltOperation(NULL);

    //
    // allocate a work queue item so we can whack the cluster service
    // process. allocate extra space at the end and stuff the source node ID
    // out there. Yes, I know it is groady...
    //

    WorkItem = CnAllocatePool( sizeof( WORK_QUEUE_ITEM ) + sizeof( CL_NODE_ID ));
    if ( WorkItem != NULL ) {

        *((PULONG)(WorkItem + 1)) = SourceNodeId;
        ExInitializeWorkItem( WorkItem, CnpTerminateClusterService, WorkItem );
        ExQueueWorkItem( WorkItem, CriticalWorkQueue );
    }
    
    return;

} // CnpReceivePoisonPacket

VOID
CnpWalkInterfacesAfterRegroup(
    IN  PCNP_INTERFACE   Interface
    )

/*++

Routine Description:

    Reset counters for each interface after a regroup

Arguments:

    None

Return Value:

    None

--*/

{
    InterlockedExchange( &Interface->MissedHBs, 0 );
    CnReleaseLock(&Interface->Network->Lock, Interface->Network->Irql);

} // CnpWalkInterfacesAfterRegroup

BOOLEAN
CnpWalkNodesAfterRegroup(
    IN  PCNP_NODE   Node,
    IN  PVOID       UpdateContext,
    IN  CN_IRQL     NodeTableIrql
    )

/*++

Routine Description:

    Called for each node in the node table. Regroup has finished
    so we clear the node's missed Heart beat count and its node down
    issued flag. No node should be unreachable at this point. If we
    find one, kick off another regroup.

Arguments:

    standard...

Return Value:

    None

--*/

{
    //
    // check for inconsistent settings of Comm and MM state
    //
    if ( ( Node->MMState == ClusnetNodeStateAlive
           ||
           Node->MMState == ClusnetNodeStateJoining
         )
         &&
         Node->CommState == ClusnetNodeCommStateUnreachable
       )
    {

        CnTrace(HBEAT_EVENT, HbTraceNodeDownEvent2,
            "[HB] Issuing NodeDown event for node %u.",
            Node->Id // LOGULONG
            );
    
        MEMLOG( MemLogInconsistentStates, Node->Id, Node->MMState );
        CnIssueEvent( ClusnetEventNodeDown, Node->Id, 0 );
    }

    CnpWalkInterfacesOnNode( Node, (PVOID)CnpWalkInterfacesAfterRegroup );

    InterlockedExchange( &Node->MissedHBs, 0 );

    //
    // clear this only for nodes in the alive state. Once a node is marked
    // dead, the flag is re-init'ed to true (this is used during a join to
    // issue only one node up event).
    //

    if ( Node->MMState == ClusnetNodeStateAlive ) {

        Node->NodeDownIssued = FALSE;
        MEMLOG( MemLogNodeDownIssued, Node->Id, FALSE );
    }

    CnReleaseLock( &Node->Lock, Node->Irql );

    return TRUE;       // the node table lock is still held

} // CnpWalkNodesAfterRegroup


VOID
CxRegroupFinished(
    ULONG NewEpoch
    )

/*++

Routine Description:

    called when regroup has finished. Walk the node list and
    perform the cleanup in the walk routine.

Arguments:

    None

Return Value:

    None

--*/

{
    MEMLOG( MemLogRegroupFinished, NewEpoch, 0 );

    CnTrace(HBEAT_EVENT, HbTraceRegroupFinished,
        "[HB] Regroup finished, new epoch = %u.",
        NewEpoch // LOGULONG
        );

    CnAssert( NewEpoch > EventEpoch );
    InterlockedExchange( &EventEpoch, NewEpoch );

    CnpWalkNodeTable( CnpWalkNodesAfterRegroup, NULL );
} // CxRegroupFinished

/* end chbeat.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\xport\cdpinit.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cdpinit.c

Abstract:

    Initialization and Cleanup code for the Cluster Datagram Protocol.

Author:

    Mike Massa (mikemas)           July 29, 1996

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     07-29-96    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "cdpinit.tmh"

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, CdpLoad)
#pragma alloc_text(PAGE, CdpUnload)

#endif // ALLOC_PRAGMA


BOOLEAN  CdpInitialized = FALSE;


//
// Initialization/cleanup routines
//
NTSTATUS
CdpLoad(
    VOID
    )
{
    NTSTATUS  status;
    ULONG     i;


    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CDP] Loading...\n"));
    }

    for (i=0; i<CX_ADDROBJ_TABLE_SIZE; i++) {
        InitializeListHead(&(CxAddrObjTable[i]));
    }

    CnInitializeLock(&CxAddrObjTableLock, CX_ADDROBJ_TABLE_LOCK);

    CdpInitialized = TRUE;

    status = CdpInitializeSend();

    if (status != STATUS_SUCCESS) {
        return(status);
    }

    status = CdpInitializeReceive();

    if (status != STATUS_SUCCESS) {
        return(status);
    }

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CDP] Loaded.\n"));
    }

    return(STATUS_SUCCESS);

}  // CdpLoad


VOID
CdpUnload(
    VOID
    )
{
    PAGED_CODE();

    if (CdpInitialized) {
        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[CDP] Unloading...\n"));
        }

        CdpCleanupReceive();

        CdpCleanupSend();

        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[CDP] Unloaded.\n"));
        }

        CdpInitialized = FALSE;
    }

    return;

}  // CdpUnload
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\xport\cdprecv.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cdpsend.c

Abstract:

    TDI Receive datagram routines.

Author:

    Mike Massa (mikemas)           February 20, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     02-20-97    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "cdprecv.tmh"

#include <sspi.h>

#ifdef ALLOC_PRAGMA


#endif // ALLOC_PRAGMA

//
// Local types
//
typedef struct {
    CL_NODE_ID   SourceNodeId;
    USHORT       SourcePort;
    ULONG        TdiReceiveDatagramFlags;
    ULONG        TsduSize;
    PCX_ADDROBJ  AddrObj;
    PCNP_NETWORK Network;
} CDP_RECEIVE_CONTEXT, *PCDP_RECEIVE_CONTEXT;


//
// Local Data
//
PCN_RESOURCE_POOL  CdpReceiveRequestPool = NULL;

#define CDP_RECEIVE_REQUEST_POOL_DEPTH 2

//
// Local utility routines
//
VOID
CdpIndicateReceivePacket(
    IN  PCX_ADDROBJ  AddrObj,
    IN  CL_NODE_ID   SourceNodeId,
    IN  USHORT       SourcePort,
    IN  ULONG        TdiReceiveDatagramFlags,
    IN  ULONG        TsduSize,
    IN  PVOID        Tsdu,
    IN  BOOLEAN      DataVerified
    )
/*++

Notes:

    Called with address object lock held.
    Returns with address object lock released.

--*/
{
    NTSTATUS                   status;
    PTDI_IND_RECEIVE_DATAGRAM  handler = AddrObj->ReceiveDatagramHandler;
    PVOID                      context = AddrObj->ReceiveDatagramContext;
    TA_CLUSTER_ADDRESS         sourceTransportAddress;
    PIRP                       irp = NULL;
    ULONG                      bytesTaken = 0;


    CnVerifyCpuLockMask(
        CX_ADDROBJ_LOCK,      // Required
        0,                    // Forbidden
        CX_ADDROBJ_LOCK_MAX   // Maximum
        );

    CnAssert(handler != NULL);

    CnReleaseLock(&(AddrObj->Lock), AddrObj->Irql);

    //
    // Build the source address buffer
    //
    CxBuildTdiAddress(
        &sourceTransportAddress,
        SourceNodeId,
        SourcePort,
        DataVerified
        );

    CnTrace(CDP_RECV_DETAIL, CdpTraceIndicateReceive,
        "[CDP] Indicating dgram, src: node %u port %u, dst: port %u, "
        "data len %u",
        SourceNodeId, // LOGULONG
        SourcePort, // LOGUSHORT
        AddrObj->LocalPort, // LOGUSHORT
        TsduSize // LOGULONG
        );        

    //
    // Call the upper layer indication handler.
    //
    status = (*handler)(
                 context,
                 sizeof(TA_CLUSTER_ADDRESS),
                 &sourceTransportAddress,
                 0, // no options
                 NULL,
                 TdiReceiveDatagramFlags,
                 TsduSize,
                 TsduSize,
                 &bytesTaken,
                 Tsdu,
                 &irp
                 );

    CnAssert(status != STATUS_MORE_PROCESSING_REQUIRED);
    CnAssert(bytesTaken == TsduSize);
    CnAssert(irp == NULL);

    if (irp != NULL) {
        irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        irp->IoStatus.Information = 0;
        IoCompleteRequest(irp, IO_NETWORK_INCREMENT);
    }

    //
    // Dereference the address object
    //
    CnDereferenceFsContext(&(AddrObj->FsContext));

    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    return;

}  // CdpIndicateReceivePacket


NTSTATUS
CdpCompleteReceivePacket(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    )
{
    NTSTATUS              status;
    PCNP_RECEIVE_REQUEST  request = Context;
    PCDP_RECEIVE_CONTEXT  context = request->UpperProtocolContext;
    PCX_ADDROBJ           addrObj = context->AddrObj;
    ULONG                 consumed;
    PVOID                 data;
    ULONG                 dataLength;
    BOOLEAN               fscontextDereferenced = FALSE;


    if (Irp->IoStatus.Status == STATUS_SUCCESS) {
        CnAssert(Irp->IoStatus.Information == context->TsduSize);

        data = request->DataBuffer;
        dataLength = (ULONG)Irp->IoStatus.Information;

        CnAcquireLock(&(addrObj->Lock), &(addrObj->Irql));

        if (addrObj->ReceiveDatagramHandler != NULL) {
            CdpIndicateReceivePacket(
                addrObj,
                context->SourceNodeId,
                context->SourcePort,
                context->TdiReceiveDatagramFlags,
                dataLength,
                data,
                FALSE   // not verified
                );
            fscontextDereferenced = TRUE;
        }
        else {
            CnReleaseLock(&(addrObj->Lock), addrObj->Irql);
        }
    }
    else {
        CnTrace(CDP_RECV_ERROR, CdpTraceCompleteReceiveFailed,
            "[CDP] Failed to fetch dgram data, src: node %u port %u, "
            "dst: port %u, status %!status!",
            context->SourceNodeId, // LOGULONG
            context->SourcePort, // LOGUSHORT
            addrObj->LocalPort, // LOGUSHORT
            Irp->IoStatus.Status // LOGSTATUS
            );        
    }

    //
    // Drop the active reference on the network.
    //
    if (context->Network != NULL) {
        CnAcquireLock(&(context->Network->Lock), &(context->Network->Irql));
        CnpActiveDereferenceNetwork(context->Network);
        context->Network = NULL;
    }

    //
    // Dereference the addr object fscontext (only necessary
    // after error condition).
    //
    if (!fscontextDereferenced) {
        CnDereferenceFsContext(&(addrObj->FsContext));
    }

    CnpFreeReceiveRequest(request);

    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    return(STATUS_MORE_PROCESSING_REQUIRED);

} // CdpCompleteReceivePacket


//
// Routines exported within the Cluster Transport
//
NTSTATUS
CdpInitializeReceive(
    VOID
    )
{
    IF_CNDBG(CN_DEBUG_INIT){
        CNPRINT(("[CDP] Initializing receive...\n"));
    }

    CdpReceiveRequestPool = CnpCreateReceiveRequestPool(
                                sizeof(CDP_RECEIVE_CONTEXT),
                                CDP_RECEIVE_REQUEST_POOL_DEPTH
                                );

    if (CdpReceiveRequestPool == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    IF_CNDBG(CN_DEBUG_INIT){
        CNPRINT(("[CDP] Receive initialized.\n"));
    }

    return(STATUS_SUCCESS);

}  // CdpInitializeReceive


VOID
CdpCleanupReceive(
    VOID
    )
{
    IF_CNDBG(CN_DEBUG_INIT){
        CNPRINT(("[CDP] Cleaning up receive...\n"));
    }

    if (CdpReceiveRequestPool != NULL) {
        CnpDeleteReceiveRequestPool(CdpReceiveRequestPool);
        CdpReceiveRequestPool = NULL;
    }

    IF_CNDBG(CN_DEBUG_INIT){
        CNPRINT(("[CDP] Receive cleanup complete.\n"));
    }

    return;

}  // CdpCleanupReceive


NTSTATUS
CdpReceivePacketHandler(
    IN  PVOID          Network,
    IN  CL_NODE_ID     SourceNodeId,
    IN  ULONG          CnpReceiveFlags,
    IN  ULONG          TdiReceiveDatagramFlags,
    IN  ULONG          BytesIndicated,
    IN  ULONG          BytesAvailable,
    OUT PULONG         BytesTaken,
    IN  PVOID          Tsdu,
    OUT PIRP *         Irp
    )
{
    NTSTATUS                   status;
    CDP_HEADER UNALIGNED *     header = Tsdu;
    PCX_ADDROBJ                addrObj;
    ULONG                      bytesTaken = 0;
    PCNP_RECEIVE_REQUEST       request;
    USHORT                     srcPort = 0;
    USHORT                     destPort = 0;
    ULONG                      consumed = 0;


    CnAssert(KeGetCurrentIrql() == DISPATCH_LEVEL);

    if (BytesIndicated >= sizeof(CDP_HEADER))
    {
        destPort = header->DestinationPort;
        srcPort =  header->SourcePort;

        //
        // Consume the CDP header
        //
        consumed = sizeof(CDP_HEADER);

        //
        // Verify that the remaining packet is consistent.
        //
        if (header->PayloadLength != (BytesAvailable - consumed)) {
            goto error_exit;
        }

        BytesIndicated -= consumed;
        BytesAvailable -= consumed;
        *BytesTaken += consumed;
        Tsdu = (PUCHAR)Tsdu + consumed;

        CnAcquireLockAtDpc(&CxAddrObjTableLock);

        addrObj = CxFindAddressObject(destPort);

        if (addrObj != NULL) {

            CnReleaseLockFromDpc(&CxAddrObjTableLock);

            if ( ( !(addrObj->Flags & CX_AO_FLAG_CHECKSTATE)
                   ||
                   (CnpReceiveFlags & CNP_RECV_FLAG_NODE_STATE_CHECK_PASSED)
                 )
                 &&
                 (addrObj->ReceiveDatagramHandler != NULL)
               )
            {
                //
                // Reference the address object so it can't go away during
                // the indication.
                //
                CnReferenceFsContext(&(addrObj->FsContext));

                if (BytesAvailable == BytesIndicated) {

                    CdpIndicateReceivePacket(
                        addrObj,
                        SourceNodeId,
                        srcPort,
                        TdiReceiveDatagramFlags,
                        BytesAvailable,
                        ((BytesAvailable > 0) ? Tsdu : NULL),
                        (BOOLEAN)(
                            CnpReceiveFlags & CNP_RECV_FLAG_SIGNATURE_VERIFIED
                        )
                        );

                    //
                    // The addrObj lock was released.
                    //

                    *BytesTaken += BytesAvailable;
                    *Irp = NULL;

                    CnVerifyCpuLockMask(
                        0,                // Required
                        0xFFFFFFFF,       // Forbidden
                        0                 // Maximum
                        );

                    return(STATUS_SUCCESS);
                }

                CnReleaseLockFromDpc(&(addrObj->Lock));

                //
                // This message cannot be a CNP multicast, and it
                // cannot have been verified, because the CNP layer 
                // could not have verified an incomplete message.
                //
                CnAssert(!(CnpReceiveFlags & CNP_RECV_FLAG_MULTICAST));
                CnAssert(!(CnpReceiveFlags & CNP_RECV_FLAG_SIGNATURE_VERIFIED));

                //
                // We need to fetch the rest of the packet before we
                // can indicate it to the upper layer.
                //
                request = CnpAllocateReceiveRequest(
                              CdpReceiveRequestPool,
                              Network,
                              BytesAvailable,
                              CdpCompleteReceivePacket
                              );

                if (request != NULL) {

                    PCDP_RECEIVE_CONTEXT  context;
                    PCNP_NETWORK          network = (PCNP_NETWORK)Network;

                    context = request->UpperProtocolContext;

                    context->SourceNodeId = SourceNodeId;
                    context->SourcePort = header->SourcePort;
                    context->TdiReceiveDatagramFlags = TdiReceiveDatagramFlags;
                    context->TsduSize = BytesAvailable;
                    context->AddrObj = addrObj;
                    context->Network = Network;

                    //
                    // Take a reference on the network so that it 
                    // doesn't disappear before the IRP completes.
                    //
                    CnAcquireLock(&(network->Lock), &(network->Irql));
                    CnpActiveReferenceNetwork(Network);
                    CnReleaseLock(&(network->Lock), network->Irql);

                    *Irp = request->Irp;

                    CnTrace(CDP_RECV_DETAIL, CdpTraceCompleteReceive,
                        "[CDP] Fetching dgram data, src: node %u port %u, "
                        "dst: port %u, BI %u, BA %u, CNP Flags %x.",
                        SourceNodeId, // LOGULONG
                        srcPort, // LOGUSHORT
                        destPort, // LOGUSHORT
                        BytesIndicated, // LOGULONG
                        BytesAvailable, // LOGULONG
                        CnpReceiveFlags // LOGXLONG
                        );        

                    CnVerifyCpuLockMask(
                        0,                // Required
                        0xFFFFFFFF,       // Forbidden
                        0                 // Maximum
                        );

                    return(STATUS_MORE_PROCESSING_REQUIRED);

                }

                CnTrace(
                    CDP_RECV_ERROR, CdpTraceDropReceiveNoIrp,
                    "[CDP] Dropping dgram: failed to allocate "
                    "receive request."
                    );

                //
                // Out of resources. Drop the packet.
                //
            }
            else {
                //
                // No receive handler or node state check failed.
                //
                CnReleaseLockFromDpc(&(addrObj->Lock));

                CnTrace(
                    CDP_RECV_ERROR, CdpTraceDropReceiveState,
                    "[CDP] Dropping dgram: addr obj flags %x, "
                    "CNP flags %x, dgram recv handler %p.",
                    addrObj->Flags,
                    CnpReceiveFlags,
                    addrObj->ReceiveDatagramHandler
                    );
            }
        }
        else {
            CnReleaseLockFromDpc(&CxAddrObjTableLock);

            CnTrace(
                CDP_RECV_ERROR, CdpTraceDropReceiveNoAO,
                "[CDP] Dropping dgram: no clusnet addr obj found "
                "for dest port %u.",
                destPort
                );
        }
    }

error_exit:

    //
    // Something went wrong. Drop the packet by
    // indicating that we consumed it.
    //
    *BytesTaken += BytesAvailable;
    *Irp = NULL;

    CnTrace(CDP_RECV_ERROR, CdpTraceDropReceive,
        "[CDP] Dropped dgram, src: node %u port %u, dst: port %u, "
        "BI %u, BA %u, CNP flags %x.",
        SourceNodeId, // LOGULONG
        srcPort, // LOGUSHORT
        destPort, // LOGUSHORT
        BytesIndicated, // LOGULONG
        BytesAvailable, // LOGULONG
        CnpReceiveFlags // LOGXLONG
        );        

    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    return(STATUS_SUCCESS);

}  // CdpReceivePacketHandler


//
// Routines exported within the Cluster Network driver
//
NTSTATUS
CxReceiveDatagram(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp
    )
{
    NTSTATUS status = STATUS_NOT_IMPLEMENTED;


    CNPRINT(("[Clusnet] CxReceiveDatagram called!\n"));

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    return(status);

}  // CxReceiveDatagram
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\xport\cdpsend.c ===
/*++                            

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cdpsend.c

Abstract:

    TDI Send datagram routines.

Author:

    Mike Massa (mikemas)           February 20, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     02-20-97    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "cdpsend.tmh"

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, CdpInitializeSend)

#endif // ALLOC_PRAGMA


//
// Local Types
//

// CDP_SEND_CONTEXT is currently empty
// typedef struct {
// } CDP_SEND_CONTEXT, *PCDP_SEND_CONTEXT;
typedef PVOID PCDP_SEND_CONTEXT;

#define CDP_SEND_REQUEST_POOL_DEPTH   5

//
// Local Data
//
PCN_RESOURCE_POOL  CdpSendRequestPool = NULL;
PCN_RESOURCE_POOL  CdpMcastSendRequestPool = NULL;


//
// Routines
//
NTSTATUS
CdpInitializeSend(
    VOID
    )
{
    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CDP] Initializing send...\n"));
    }

    CdpSendRequestPool = CnpCreateSendRequestPool(
                             CNP_VERSION_UNICAST,
                             PROTOCOL_CDP,
                             sizeof(CDP_HEADER),
                             0, // sizeof(CDP_SEND_CONTEXT),
                             CDP_SEND_REQUEST_POOL_DEPTH
                             );

    if (CdpSendRequestPool == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    CdpMcastSendRequestPool = CnpCreateSendRequestPool(
                                  CNP_VERSION_MULTICAST,
                                  PROTOCOL_CDP,
                                  sizeof(CDP_HEADER),
                                  0, // sizeof(CDP_SEND_CONTEXT)
                                  CDP_SEND_REQUEST_POOL_DEPTH
                                  );

    if (CdpMcastSendRequestPool == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CDP] Send initialized.\n"));
    }

    return(STATUS_SUCCESS);

}  // CdpInitializeSend


VOID
CdpCleanupSend(
    VOID
    )
{
    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CDP] Cleaning up send...\n"));
    }

    if (CdpSendRequestPool != NULL) {
        CnpDeleteSendRequestPool(CdpSendRequestPool);
    }

    if (CdpMcastSendRequestPool != NULL) {
        CnpDeleteSendRequestPool(CdpMcastSendRequestPool);
    }

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CDP] Send cleanup complete.\n"));
    }

    return;

}  // CdpCleanupSend


VOID
CdpCompleteSendDatagram(
    IN     NTSTATUS           Status,
    IN OUT PULONG             BytesSent,
    IN     PCNP_SEND_REQUEST  SendRequest,
    IN     PMDL               DataMdl
    )
{
    PCDP_SEND_CONTEXT  sendContext = SendRequest->UpperProtocolContext;
    PCNP_HEADER        cnpHeader = SendRequest->CnpHeader;
    PCDP_HEADER        cdpHeader = SendRequest->UpperProtocolHeader;


    if (NT_SUCCESS(Status)) {
        if (*BytesSent >= sizeof(CDP_HEADER)) {
            *BytesSent -= sizeof(CDP_HEADER);
        }
        else {
            *BytesSent = 0;
            CnAssert(FALSE);
        }

        CnTrace(CDP_SEND_DETAIL, CdpTraceSendComplete,
            "[CDP] Send of dgram to node %u port %u complete, bytes sent %u.",
            cnpHeader->DestinationAddress, // LOGULONG
            cdpHeader->DestinationPort, // LOGUSHORT
            *BytesSent // LOGULONG
            );        
    }
    else {
        CnTrace(CDP_SEND_ERROR, CdpTraceSendFailedBelow,
            "[CDP] Transport failed to send dgram to node %u port %u, "
            "data len %u, status %!status!",
            cnpHeader->DestinationAddress, // LOGULONG
            cdpHeader->DestinationPort, // LOGUSHORT
            cdpHeader->PayloadLength, // LOGUSHORT
            Status // LOGSTATUS
            );

        CnAssert(*BytesSent == 0);
    }

    CnAssert(sendContext == NULL);

    if (cnpHeader->DestinationAddress == ClusterAnyNodeId) {
        //
        // Dereference the network multicast group data structure.
        //
        if (SendRequest->McastGroup != NULL) {
            CnpDereferenceMulticastGroup(SendRequest->McastGroup);
            SendRequest->McastGroup = NULL;
        }
    }

    CnFreeResource((PCN_RESOURCE) SendRequest);

    return;

}  // CdpCompleteSendDatagram


NTSTATUS
CxSendDatagram(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp
    )
{
    NTSTATUS                    status = STATUS_NOT_IMPLEMENTED;
    PCX_ADDROBJ                 addrObj;
    PTDI_REQUEST_KERNEL_SENDDG  request;
    ULONG                       bytesSent = 0;
    CN_IRQL                     cancelIrql;
    USHORT                      destPort = 0;
    CL_NODE_ID                  destNode = ClusterInvalidNodeId;


    addrObj = (PCX_ADDROBJ) IrpSp->FileObject->FsContext;
    request = (PTDI_REQUEST_KERNEL_SENDDG) &(IrpSp->Parameters);

    if (request->SendLength <= CDP_MAX_SEND_SIZE(CX_SIGNATURE_LENGTH)) {
        if ( request->SendDatagramInformation->RemoteAddressLength >=
             sizeof(TA_CLUSTER_ADDRESS)
           )
        {
            status = CxParseTransportAddress(
                         request->SendDatagramInformation->RemoteAddress,
                         request->SendDatagramInformation->RemoteAddressLength,
                         &destNode,
                         &destPort
                         );

            if (status == STATUS_SUCCESS) {
                if (destPort != 0) {
                    PCNP_SEND_REQUEST   sendRequest;

                    if (destNode == ClusterAnyNodeId) {

                        //
                        // This is a CNP multicast.
                        //
                        sendRequest = 
                            (PCNP_SEND_REQUEST) CnAllocateResource(
                                                    CdpMcastSendRequestPool
                                                    );
                    } else {

                        //
                        // This is a normal unicast.
                        //
                        sendRequest = 
                            (PCNP_SEND_REQUEST) CnAllocateResource(
                                                    CdpSendRequestPool
                                                    );
                    }

                    if (sendRequest != NULL) {
                        PCDP_HEADER             cdpHeader;
                        PCDP_SEND_CONTEXT       sendContext;
                        BOOLEAN                 checkState;
                        CL_NETWORK_ID           destNet = ClusterAnyNetworkId;

                        checkState = (addrObj->Flags &
                                      CX_AO_FLAG_CHECKSTATE) ?
                                      TRUE : FALSE;
                        
                        //
                        // Fill in the CDP header.
                        //
                        cdpHeader = sendRequest->UpperProtocolHeader;
                        RtlZeroMemory(cdpHeader, sizeof(CDP_HEADER));
                        cdpHeader->SourcePort = addrObj->LocalPort;
                        cdpHeader->DestinationPort = destPort;
                        cdpHeader->PayloadLength = (USHORT)request->SendLength;

                        //
                        // Fill in the caller portion of the CNP
                        // send request.
                        //
                        sendRequest->UpperProtocolIrp = Irp;
                        sendRequest->CompletionRoutine =
                            CdpCompleteSendDatagram;

                        //
                        // Fill in our own send context
                        // (currently nothing).
                        //
                        sendContext = sendRequest->UpperProtocolContext;
                        CnAssert(sendContext == NULL);

                        CnVerifyCpuLockMask(
                            0,                           // Required
                            CNP_LOCK_RANGE,              // Forbidden
                            CNP_PRECEEDING_LOCK_RANGE    // Maximum
                            );

                        //
                        // Send the message.
                        //

                        CnTrace(CDP_SEND_DETAIL, CdpTraceSend,
                            "[CDP] Sending dgram to node %u port %u, "
                            "data len %u.",
                            destNode, // LOGULONG
                            destPort, // LOGUSHORT
                            request->SendLength // LOGULONG
                            );

                        status = CnpSendPacket(
                                     sendRequest,
                                     destNode,
                                     Irp->MdlAddress,
                                     (USHORT) request->SendLength,
                                     checkState,
                                     destNet
                                     );

                        CnVerifyCpuLockMask(
                            0,                           // Required
                            CNP_LOCK_RANGE,              // Forbidden
                            CNP_PRECEEDING_LOCK_RANGE    // Maximum
                            );

                        return(status);
                    }
                    else {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
                else {
                    status = STATUS_INVALID_ADDRESS_COMPONENT;
                }
            }
        }
        else {
            status = STATUS_INVALID_ADDRESS_COMPONENT;
        }
    }
    else {
        status = STATUS_INVALID_BUFFER_SIZE;
    }
    
    CnTrace(CDP_SEND_ERROR, CdpTraceSendFailedInternal,
        "[CDP] Failed to send dgram to node %u port %u, data len %u, "
        "status %!status!",
        destNode, // LOGULONG
        destPort, // LOGUSHORT
        request->SendLength, // LOGULONG
        status // LOGSTATUS
        );
    
    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    CnVerifyCpuLockMask(
        0,                           // Required
        CNP_LOCK_RANGE,              // Forbidden
        CNP_PRECEEDING_LOCK_RANGE    // Maximum
        );

    return(status);

}  // CxSendDatagram
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\xport\cnpdef.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cnpdef.h

Abstract:

    Main private header file for the Cluster Network Protocol.

Author:

    Mike Massa (mikemas)           July 29, 1996

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     07-29-96    created

Notes:

--*/

#ifndef _CNPDEF_INCLUDED_
#define _CNPDEF_INCLUDED_

#include <fipsapi.h>
#include <sspi.h>

//
// Forward declarations
//
typedef struct _CNP_INTERFACE *PCNP_INTERFACE;

//
// Priority definitions
//
#define CnpIsHigherPriority(_p1, _p2)      ((_p1) < (_p2))
#define CnpIsLowerPriority(_p1, _p2)       ((_p1) > (_p2))
#define CnpIsEqualPriority(_p1, _p2)       ((_p1) == (_p2))


//
// Multicast Group Object
//
// This structure contains the data needed to implement a multicast
// endpoint on a network.
//
typedef struct _CNP_MULTICAST_GROUP {
    ULONG                   McastNetworkBrand;
    PTRANSPORT_ADDRESS      McastTdiAddress;
    ULONG                   McastTdiAddressLength;
    PVOID                   Key;
    ULONG                   KeyLength;
    DESTable                DesTable;
    PVOID                   Salt;
    ULONG                   SaltLength;
    ULONG                   SignatureLength;
    ULONG                   RefCount;
} CNP_MULTICAST_GROUP, *PCNP_MULTICAST_GROUP;

//
// Network Object
//
// This structure represents a communication link between the nodes of a
// cluster. It references a particular transport protocol and interface
// configured on the local system. It also links together all of the
// interface objects for the nodes attached to the network.
//
// Networks are identified by a small integer assigned by the Cluster
// Service. Network objects are stored in a global array indexed by
// the network ID.
//
typedef struct {
    LIST_ENTRY              Linkage;
    CN_SIGNATURE_FIELD
    CL_NETWORK_ID           Id;
    CN_LOCK                 Lock;
    CN_IRQL                 Irql;
    ULONG                   RefCount;
    ULONG                   ActiveRefCount;
    CLUSNET_NETWORK_STATE   State;
    ULONG                   Flags;
    ULONG                   Priority;
    HANDLE                  DatagramHandle;
    PFILE_OBJECT            DatagramFileObject;
    PDEVICE_OBJECT          DatagramDeviceObject;
    TDI_PROVIDER_INFO       ProviderInfo;
    PIRP                    PendingDeleteIrp;
    PIRP                    PendingOfflineIrp;
    WORK_QUEUE_ITEM         ExWorkItem;
    PCNP_MULTICAST_GROUP    CurrentMcastGroup;
    PCNP_MULTICAST_GROUP    PreviousMcastGroup;
    CX_CLUSTERSCREEN        McastReachableNodes;
    ULONG                   McastReachableCount;
} CNP_NETWORK, *PCNP_NETWORK;

#define CNP_NETWORK_SIG    'kwtn'

extern LIST_ENTRY      CnpNetworkList;
extern CN_LOCK         CnpNetworkListLock;

#define CNP_NET_FLAG_DELETING       0x00000001
#define CNP_NET_FLAG_PARTITIONED    0x00000002
#define CNP_NET_FLAG_RESTRICTED     0x00000004
#define CNP_NET_FLAG_LOCALDISCONN   0x00000008
#define CNP_NET_FLAG_MULTICAST      0x00000010
#define CNP_NET_FLAG_MCASTSORTED    0x00000020

#define CnpIsNetworkDeleting(_network) \
            (((_network)->Flags & CNP_NET_FLAG_DELETING) != 0)

#define CnpIsValidNetworkId(_id)   ( ((_id) != ClusterAnyNetworkId ) && \
                                     ((_id) != ClusterInvalidNetworkId))

#define CnpIsNetworkRestricted(_network) \
            (((_network)->Flags & CNP_NET_FLAG_RESTRICTED) != 0)

#define CnpIsNetworkLocalDisconn(_network) \
            (((_network)->Flags & CNP_NET_FLAG_LOCALDISCONN) != 0)
            
#define CnpIsNetworkMulticastCapable(_network) \
            (((_network)->Flags & CNP_NET_FLAG_MULTICAST) != 0)
            
#define CnpIsNetworkMulticastSorted(_network) \
            (((_network)->Flags & CNP_NET_FLAG_MCASTSORTED) != 0)
            
#define CnpNetworkResetMcastReachableNodes(_network)     \
            (RtlZeroMemory(                              \
                 &((_network)->McastReachableNodes),     \
                 sizeof((_network)->McastReachableNodes) \
                 ))
/*            
            (BYTE((_network)->McastReachableNodes, INT_NODE(CnLocalNodeId)) \
            = (1 << (BYTEL-1-BIT(INT_NODE(CnLocalNodeId)))))
            */

//
// Node Object
//
// This structure represents a cluster node. One exists for each
// defined member of a cluster.
//
// Nodes are identified by a small integer assigned by the Cluster Service.
// Node objects are stored in a global array indexed by node ID.
//
// Note that the order of the CLUSTER_NODE_COMM_STATE enumeration *is* important.
//
typedef struct {
    LIST_ENTRY              Linkage;
    CN_SIGNATURE_FIELD
    CL_NODE_ID              Id;
    CN_LOCK                 Lock;
    CN_IRQL                 Irql;
    ULONG                   RefCount;
    CLUSNET_NODE_COMM_STATE CommState;
    CLUSNET_NODE_STATE      MMState;
    ULONG                   Flags;
    LIST_ENTRY              InterfaceList;
    PCNP_INTERFACE          CurrentInterface;
    PIRP                    PendingDeleteIrp;
    BOOLEAN                 HBWasMissed;
    BOOLEAN                 NodeDownIssued;
    ULONG                   MissedHBs;
} CNP_NODE, *PCNP_NODE;

#define CNP_NODE_SIG  'edon'

extern PCNP_NODE *        CnpNodeTable;
extern CN_LOCK            CnpNodeTableLock;
extern PCNP_NODE          CnpLocalNode;

#define CNP_NODE_FLAG_DELETING       0x00000001
#define CNP_NODE_FLAG_UNREACHABLE    0x00000002
#define CNP_NODE_FLAG_LOCAL          0x00000010

#define CnpIsNodeDeleting(_node) \
            ((_node)->Flags & CNP_NODE_FLAG_DELETING)

#define CnpIsNodeLocal(_node) \
            ((_node)->Flags & CNP_NODE_FLAG_LOCAL)

#define CnpIsNodeUnreachable(_node) \
            ((_node)->Flags & CNP_NODE_FLAG_UNREACHABLE)

//++
//
// Routine Description:
//
//     Callback routine for CnpWalkNodeTable. Performs an operation on
//     the specified node.
//
// Arguments:
//
//     UpdateNode    - A pointer to the node on which to operate.
//
//     UpdateContext - Operation-specific context
//
//     NodeTableIrql - The IRQL at which the CnpNodeTableLock was acquired.
//
// Return Value:
//
//     Returns TRUE if the CnpNodeTable lock is still held.
//     Returns FALSE if the CnpNodeTable lock is released.
//
// Notes:
//
//     Called with both the CnpNodeTable and node object locks held.
//     The node object lock is released upon return.
//
//--
typedef
BOOLEAN
(*PCNP_NODE_UPDATE_ROUTINE)(
    IN  PCNP_NODE   UpdateNode,
    IN  PVOID       UpdateContext,
    IN  CN_IRQL     NodeTableIrql
    );

//
// Interface Object
//
// This structure represents a node's transport interface to a network.
// It contains a transport address which may be used to communicate
// with the specified node using the specified network.
//
// Interface objects are linked onto lists in the associated node objects.
// They are identified by a {node, network} tuple.
//
// The interfaces on a node are ranked based on their state and priority.
// Numerically higher state values are ranked ahead of lower values.
// For interfaces with the same state, Numerically lower priority values
// are ranked ahead of lower values. Priority values fall in the range
// 0x1-0xFFFFFFFF. State values are defined by CLUSNET_INTERFACE_STATE
// enumeration. By default, interfaces inherit their priority from the
// associated network. In this case, the Priority field will contain the
// network's priority value, and the CNP_IF_FLAG_USE_NETWORK_PRIORITY flag
// will be set in the Flags field.
//
// Note that the order of the CLUSNET_INTERFACE_STATE enumeration
// *is* important.
//

typedef struct _CNP_INTERFACE {
    LIST_ENTRY                     NodeLinkage;
    CN_SIGNATURE_FIELD
    PCNP_NODE                      Node;
    PCNP_NETWORK                   Network;
    CLUSNET_INTERFACE_STATE        State;
    ULONG                          Priority;
    ULONG                          Flags;
    ULONG                          MissedHBs;
    ULONG                          SequenceToSend;
    ULONG                          LastSequenceReceived;
    ULONG                          McastDiscoverCount;
    ULONG                          McastRediscoveryCountdown;
    ULONG                          AdapterWMIProviderId;
    ULONG                          TdiAddressLength;
    TRANSPORT_ADDRESS              TdiAddress;
} CNP_INTERFACE;

#define CNP_INTERFACE_SIG    '  fi'

#define CNP_INTERFACE_MCAST_DISCOVERY        0x5
#define CNP_INTERFACE_MCAST_REDISCOVERY      3000 // 1 hr at 1.2 hbs/sec

#define CNP_IF_FLAG_USE_NETWORK_PRIORITY     0x00000001
#define CNP_IF_FLAG_RECVD_MULTICAST          0x00000002

#define CnpIsInterfaceUsingNetworkPriority(_if) \
            ( (_if)->Flags & CNP_IF_FLAG_USE_NETWORK_PRIORITY )
            
#define CnpInterfaceQueryReceivedMulticast(_if) \
            ( (_if)->Flags & CNP_IF_FLAG_RECVD_MULTICAST )
            
#define CnpInterfaceSetReceivedMulticast(_if) \
            ( (_if)->Flags |= CNP_IF_FLAG_RECVD_MULTICAST )
            
#define CnpInterfaceClearReceivedMulticast(_if) \
            ( (_if)->Flags &= ~CNP_IF_FLAG_RECVD_MULTICAST )
            

//++
//
// Routine Description:
//
//     Callback routine for CnpWalkInterfacesOnNetwork and
//     CnpWalkInterfacesOnNode routines. Performs a specified
//     operation on all interfaces.
//
// Arguments:
//
//     UpdateInterface - A pointer to the interface on which to operate.
//
// Return Value:
//
//     None.
//
// Notes:
//
//     Called with the associated node and network object locks held.
//     Mut return with the network object lock released.
//     May not release node object lock at any time.
//
//--
typedef
VOID
(*PCNP_INTERFACE_UPDATE_ROUTINE)(
    IN  PCNP_INTERFACE   UpdateInterface
    );


//
// Send Request Pool
//
typedef struct {
    USHORT                 UpperProtocolHeaderLength;
    ULONG                  UpperProtocolContextSize;
    UCHAR                  UpperProtocolNumber;
    UCHAR                  CnpVersionNumber;
    UCHAR                  Pad[2];
} CNP_SEND_REQUEST_POOL_CONTEXT, *PCNP_SEND_REQUEST_POOL_CONTEXT;

//
// Forward Declaration
//
typedef struct _CNP_SEND_REQUEST *PCNP_SEND_REQUEST;

typedef
VOID
(*PCNP_SEND_COMPLETE_ROUTINE)(
    IN     NTSTATUS            Status,
    IN OUT PULONG              BytesSent,
    IN     PCNP_SEND_REQUEST   SendRequest,
    IN     PMDL                DataMdl
    );

//
// Send Request Structure
//
typedef struct _CNP_SEND_REQUEST {
    CN_RESOURCE                  CnResource;
    PMDL                         HeaderMdl;
    PVOID                        CnpHeader;
    PIRP                         UpperProtocolIrp;
    PVOID                        UpperProtocolHeader;
    USHORT                       UpperProtocolHeaderLength;
    KPROCESSOR_MODE              UpperProtocolIrpMode;
    UCHAR                        Pad;
    PMDL                         UpperProtocolMdl;
    PVOID                        UpperProtocolContext;
    PCNP_SEND_COMPLETE_ROUTINE   CompletionRoutine;
    PCNP_NETWORK                 Network;
    PCNP_MULTICAST_GROUP         McastGroup;
    TDI_CONNECTION_INFORMATION   TdiSendDatagramInfo;
} CNP_SEND_REQUEST;


//
// Internal Init/Cleanup routines
//

//
// Internal Node Routines
//
VOID
CnpWalkNodeTable(
    PCNP_NODE_UPDATE_ROUTINE  UpdateRoutine,
    PVOID                     UpdateContext
    );

NTSTATUS
CnpValidateAndFindNode(
    IN  CL_NODE_ID    NodeId,
    OUT PCNP_NODE *   Node
    );

PCNP_NODE
CnpLockedFindNode(
    IN  CL_NODE_ID    NodeId,
    IN  CN_IRQL       NodeTableIrql
    );

PCNP_NODE
CnpFindNode(
    IN  CL_NODE_ID    NodeId
    );

VOID
CnpOfflineNode(
    PCNP_NODE    Node
    );

VOID
CnpDeclareNodeUnreachable(
    PCNP_NODE  Node
    );

VOID
CnpDeclareNodeReachable(
    PCNP_NODE  Node
    );

VOID
CnpReferenceNode(
    PCNP_NODE  Node
    );

VOID
CnpDereferenceNode(
    PCNP_NODE  Node
    );


//
// Internal Network Routines
//
VOID
CnpReferenceNetwork(
    PCNP_NETWORK  Network
    );

VOID
CnpDereferenceNetwork(
    PCNP_NETWORK  Network
    );

VOID
CnpActiveReferenceNetwork(
    PCNP_NETWORK  Network
    );

VOID
CnpActiveDereferenceNetwork(
    PCNP_NETWORK   Network
    );

PCNP_NETWORK
CnpFindNetwork(
    IN CL_NETWORK_ID  NetworkId
    );

VOID
CnpDeleteNetwork(
    PCNP_NETWORK  Network,
    CN_IRQL       NetworkListIrql
    );

VOID
CnpFreeMulticastGroup(
    IN PCNP_MULTICAST_GROUP Group
    );

#define CnpReferenceMulticastGroup(_group) \
    (InterlockedIncrement(&((_group)->RefCount)))

#define CnpDereferenceMulticastGroup(_group)                 \
    if (InterlockedDecrement(&((_group)->RefCount)) == 0) {  \
        CnpFreeMulticastGroup(_group);                       \
    }

BOOLEAN
CnpSortMulticastNetwork(
    IN  PCNP_NETWORK        Network,
    IN  BOOLEAN             RaiseEvent,
    OUT CX_CLUSTERSCREEN  * McastReachableNodes      OPTIONAL
    );

BOOLEAN
CnpMulticastChangeNodeReachability(
    IN  PCNP_NETWORK       Network,
    IN  PCNP_NODE          Node,
    IN  BOOLEAN            Reachable,
    IN  BOOLEAN            RaiseEvent,
    OUT CX_CLUSTERSCREEN * NewMcastReachableNodes    OPTIONAL
    );

PCNP_NETWORK
CnpGetBestMulticastNetwork(
    VOID
    );

//
// Internal Interface Routines
//

VOID
CnpWalkInterfacesOnNode(
    PCNP_NODE                      Node,
    PCNP_INTERFACE_UPDATE_ROUTINE  UpdateRoutine
    );

VOID
CnpWalkInterfacesOnNetwork(
    PCNP_NETWORK                   Network,
    PCNP_INTERFACE_UPDATE_ROUTINE  UpdateRoutine
    );

NTSTATUS
CnpOnlinePendingInterface(
    PCNP_INTERFACE   Interface
    );

VOID
CnpOnlinePendingInterfaceWrapper(
    PCNP_INTERFACE   Interface
    );

NTSTATUS
CnpOfflineInterface(
    PCNP_INTERFACE   Interface
    );

VOID
CnpOfflineInterfaceWrapper(
    PCNP_INTERFACE   Interface
    );

NTSTATUS
CnpOnlineInterface(
    PCNP_INTERFACE   Interface
    );

NTSTATUS
CnpFailInterface(
    PCNP_INTERFACE   Interface
    );

VOID
CnpDeleteInterface(
    IN PCNP_INTERFACE Interface
    );

VOID
CnpReevaluateInterfaceRole(
    IN PCNP_INTERFACE  Interface
    );

VOID
CnpRecalculateInterfacePriority(
    IN PCNP_INTERFACE  Interface
    );

VOID
CnpUpdateNodeCurrentInterface(
    PCNP_NODE  Node
    );

VOID
CnpResetAndOnlinePendingInterface(
    IN PCNP_INTERFACE  Interface
    );

NTSTATUS
CnpFindInterface(
    IN  CL_NODE_ID         NodeId,
    IN  CL_NETWORK_ID      NetworkId,
    OUT PCNP_INTERFACE *   Interface
    );


//
// Send Routines.
//
PCN_RESOURCE_POOL
CnpCreateSendRequestPool(
    IN UCHAR  CnpVersionNumber,
    IN UCHAR  UpperProtocolNumber,
    IN USHORT UpperProtocolHeaderSize,
    IN USHORT UpperProtocolContextSize,
    IN USHORT PoolDepth
    );

#define CnpDeleteSendRequestPool(_pool) \
        { \
            CnDrainResourcePool(_pool);  \
            CnFreePool(_pool);           \
        }

NTSTATUS
CnpSendPacket(
    IN PCNP_SEND_REQUEST    SendRequest,
    IN CL_NODE_ID           DestNodeId,
    IN PMDL                 DataMdl,
    IN USHORT               DataLength,
    IN BOOLEAN              CheckDestState,
    IN CL_NETWORK_ID        NetworkId OPTIONAL
    );

VOID
CcmpSendPoisonPacket(
    IN PCNP_NODE                   Node,
    IN PCX_SEND_COMPLETE_ROUTINE   CompletionRoutine,  OPTIONAL
    IN PVOID                       CompletionContext,  OPTIONAL
    IN PCNP_NETWORK                Network,            OPTIONAL
    IN PIRP                        Irp                 OPTIONAL
    );

//
// Receive Routines
//
NTSTATUS
CcmpReceivePacketHandler(
    IN  PCNP_NETWORK   Network,
    IN  CL_NODE_ID     SourceNodeId,
    IN  ULONG          CnpReceiveFlags,
    IN  ULONG          TdiReceiveDatagramFlags,
    IN  ULONG          BytesIndicated,
    IN  ULONG          BytesAvailable,
    OUT PULONG         BytesTaken,
    IN  PVOID          Tsdu,
    OUT PIRP *         Irp
    );

VOID
CnpReceiveHeartBeatMessage(
    IN  PCNP_NETWORK Network,
    IN  CL_NODE_ID SourceNodeId,
    IN  ULONG SeqNumber,
    IN  ULONG AckNumber,
    IN  BOOLEAN Multicast
    );

VOID
CnpReceivePoisonPacket(
    IN  PCNP_NETWORK   Network,
    IN  CL_NODE_ID SourceNodeId,
    IN  ULONG SeqNumber
    );

//
// TDI routines
//
NTSTATUS
CnpTdiReceiveDatagramHandler(
    IN  PVOID    TdiEventContext,
    IN  LONG     SourceAddressLength,
    IN  PVOID    SourceAddress,
    IN  LONG     OptionsLength,
    IN  PVOID    Options,
    IN  ULONG    ReceiveDatagramFlags,
    IN  ULONG    BytesIndicated,
    IN  ULONG    BytesAvailable,
    OUT PULONG   BytesTaken,
    IN  PVOID    Tsdu,
    OUT PIRP *   IoRequestPacket
    );

NTSTATUS
CnpTdiErrorHandler(
    IN PVOID     TdiEventContext,
    IN NTSTATUS  Status
    );

NTSTATUS
CnpTdiSetEventHandler(
    IN PFILE_OBJECT    FileObject,
    IN PDEVICE_OBJECT  DeviceObject,
    IN ULONG           EventType,
    IN PVOID           EventHandler,
    IN PVOID           EventContext,
    IN PIRP            ClientIrp     OPTIONAL
    );

NTSTATUS
CnpIssueDeviceControl (
    IN PFILE_OBJECT     FileObject,
    IN PDEVICE_OBJECT   DeviceObject,
    IN PVOID            IrpParameters,
    IN ULONG            IrpParametersLength,
    IN PVOID            MdlBuffer,
    IN ULONG            MdlBufferLength,
    IN UCHAR            MinorFunction,
    IN PIRP             ClientIrp            OPTIONAL
    );

VOID
CnpAttachSystemProcess(
    VOID
    );

VOID
CnpDetachSystemProcess(
    VOID
    );

NTSTATUS
CnpOpenDevice(
    IN  LPWSTR          DeviceName,
    OUT HANDLE          *Handle
    );

NTSTATUS
CnpZwDeviceControl(
    IN HANDLE   Handle,
    IN ULONG    IoControlCode,
    IN PVOID    InputBuffer,
    IN ULONG    InputBufferLength,
    IN PVOID    OutputBuffer,
    IN ULONG    OutputBufferLength
    );

NTSTATUS
CnpSetTcpInfoEx(
    IN HANDLE   Handle,
    IN ULONG    Entity,
    IN ULONG    Class,
    IN ULONG    Type,
    IN ULONG    Id,
    IN PVOID    Value,
    IN ULONG    ValueLength
    );

#define CnpIsIrpStackSufficient(_irp, _targetdevice) \
            ((_irp)->CurrentLocation - (_targetdevice)->StackSize >= 1)
            
#define CnpIsIPv4McastTransportAddress(_ta)                             \
            (  (((PTA_IP_ADDRESS)(_ta))->Address[0].AddressType         \
               == TDI_ADDRESS_TYPE_IP                                   \
               )                                                        \
            && ((((PTA_IP_ADDRESS)(_ta))->Address[0].Address[0].in_addr \
                 & 0xf0)                                                \
               == 0xe0                                                  \
               )                                                        \
            )
            
#define CnpIsIPv4McastSameGroup(_ta1, _ta2)                              \
            ( ((PTA_IP_ADDRESS)(_ta1))->Address[0].Address[0].in_addr == \
              ((PTA_IP_ADDRESS)(_ta2))->Address[0].Address[0].in_addr    \
            )           

//
// Signature mechanisms.
//

extern FIPS_FUNCTION_TABLE CxFipsFunctionTable;

// Pad the signature length to be an even multiple of DES_BLOCKLEN.
#define CX_SIGNATURE_LENGTH                                               \
    (((A_SHA_DIGEST_LEN % DES_BLOCKLEN) == 0) ?                           \
     A_SHA_DIGEST_LEN :                                                   \
     A_SHA_DIGEST_LEN + DES_BLOCKLEN - (A_SHA_DIGEST_LEN % DES_BLOCKLEN)) 

NTSTATUS
CnpSignMulticastMessage(
    IN     PCNP_SEND_REQUEST               SendRequest,
    IN     PMDL                            DataMdl,
    IN OUT CL_NETWORK_ID                 * NetworkId,
    OUT    ULONG                         * SigLen           OPTIONAL
    );

NTSTATUS
CnpVerifyMulticastMessage(
    IN     PCNP_NETWORK                    Network,
    IN     PVOID                           Tsdu,
    IN     ULONG                           TsduLength,
    IN     ULONG                           ExpectedPayload,
       OUT ULONG                         * BytesTaken,
       OUT BOOLEAN                       * CurrentGroup
    );

#endif // ifndef _CNPDEF_INCLUDED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\xport\cnpmisc.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cnpmisc.c

Abstract:

    Miscellaneous routines for the Cluster Network Protocol.

Author:

    Mike Massa (mikemas)           January 24, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-24-97    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "cnpmisc.tmh"

#include <tdiinfo.h>
#include <tcpinfo.h>
#include <fipsapi.h>
#include <sspi.h>


//
// Local function prototypes
//
NTSTATUS
CnpRestartDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );


#ifdef ALLOC_PRAGMA

//
// All of this code is pageable.
//
#pragma alloc_text(PAGE, CnpTdiSetEventHandler)
#pragma alloc_text(PAGE, CnpIssueDeviceControl)


#endif // ALLOC_PRAGMA



NTSTATUS
CnpRestartDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
{
    PBOOLEAN reuseIrp = (PBOOLEAN) Context;

    //
    // If there was an MDL in the IRP, free it and reset the pointer to
    // NULL.  The IO system can't handle a nonpaged pool MDL being freed
    // in an IRP, which is why we do it here.
    //

    if ( Irp->MdlAddress != NULL ) {
        IoFreeMdl( Irp->MdlAddress );
        Irp->MdlAddress = NULL;
    }

    //
    // Mark the IRP pending, if necessary.
    //
    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    //
    // If we are reusing a client IRP, tell the I/O manager not to 
    // halt I/O completion processing immediately.
    //
    if (*reuseIrp) {
        if (Irp->UserIosb != NULL) {
            *(Irp->UserIosb) = Irp->IoStatus;
        }
        if (Irp->UserEvent != NULL) {
            KeSetEvent(Irp->UserEvent, IO_NO_INCREMENT, FALSE);
        }
        return STATUS_MORE_PROCESSING_REQUIRED;
    } else {
        return STATUS_SUCCESS;
    }

} // CnpRestartDeviceControl




NTSTATUS
CnpIssueDeviceControl (
    IN PFILE_OBJECT     FileObject,
    IN PDEVICE_OBJECT   DeviceObject,
    IN PVOID            IrpParameters,
    IN ULONG            IrpParametersLength,
    IN PVOID            MdlBuffer,
    IN ULONG            MdlBufferLength,
    IN UCHAR            MinorFunction,
    IN PIRP             ClientIrp            OPTIONAL
    )

/*++

Routine Description:

    Issues a device control request to a TDI provider and waits for the
    request to complete.

Arguments:

    FileObject - a pointer to the file object corresponding to a TDI
        handle

    DeviceObject - a pointer to the device object corresponding to the
        FileObject.

    IrpParameters - information to write to the parameters section of the
        stack location of the IRP.

    IrpParametersLength - length of the parameter information.  Cannot be
        greater than 16.

    MdlBuffer - if non-NULL, a buffer of nonpaged pool to be mapped
        into an MDL and placed in the MdlAddress field of the IRP.

    MdlBufferLength - the size of the buffer pointed to by MdlBuffer.

    MinorFunction - the minor function code for the request.
    
    ClientIrp - client IRP that may be reusable for this ioctl

Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    NTSTATUS             status = STATUS_SUCCESS;
    PIRP                 irp;
    PIO_STACK_LOCATION   irpSp;
    KEVENT               event;
    IO_STATUS_BLOCK      ioStatusBlock;
    PDEVICE_OBJECT       deviceObject;
    PMDL                 mdl;
    KPROCESSOR_MODE      clientRequestorMode;
    PKEVENT              clientUserEvent;
    PIO_STATUS_BLOCK     clientIosb;
    PMDL                 clientMdl;
    BOOLEAN              reuseIrp = FALSE;


    PAGED_CODE( );

    //
    // Initialize the kernel event that will signal I/O completion.
    //
    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // If there is a ClientIrp available, check if it has sufficient
    // stack locations.
    //
    if (ClientIrp != NULL 
        && CnpIsIrpStackSufficient(ClientIrp, DeviceObject)) {

        //
        // Reuse the client IRP rather than allocating a new one.
        //
        reuseIrp = TRUE;
        irp = ClientIrp;

        //
        // Save state from client IRP
        //
        clientRequestorMode = irp->RequestorMode;
        clientUserEvent = irp->UserEvent;
        clientIosb = irp->UserIosb;
        clientMdl = irp->MdlAddress;

    } else {

        //
        // Reference the passed in file object. This is necessary because
        // the IO completion routine dereferences it.
        //
        ObReferenceObject( FileObject );

        //
        // Set the file object event to a non-signaled state.
        //
        (VOID) KeResetEvent( &FileObject->Event );

        //
        // Attempt to allocate and initialize the I/O Request Packet (IRP)
        // for this operation.
        //
        irp = IoAllocateIrp( (DeviceObject)->StackSize, TRUE );

        if ( irp == NULL ) {
            ObDereferenceObject( FileObject );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        // Fill in the service independent parameters in the IRP.
        //

        irp->Flags = (LONG)IRP_SYNCHRONOUS_API;
        irp->PendingReturned = FALSE;

        irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;

        irp->AssociatedIrp.SystemBuffer = NULL;
        irp->UserBuffer = NULL;

        irp->Tail.Overlay.Thread = PsGetCurrentThread();
        irp->Tail.Overlay.OriginalFileObject = FileObject;
        irp->Tail.Overlay.AuxiliaryBuffer = NULL;

        //
        // Queue the IRP to the thread.
        //
        IoEnqueueIrp( irp );
    }

    //
    // If an MDL buffer was specified, get an MDL, map the buffer,
    // and place the MDL pointer in the IRP.
    //

    if ( MdlBuffer != NULL ) {

        mdl = IoAllocateMdl(
                  MdlBuffer,
                  MdlBufferLength,
                  FALSE,
                  FALSE,
                  irp
                  );
        if ( mdl == NULL ) {
            if (!reuseIrp) {
                IoFreeIrp( irp );
                ObDereferenceObject( FileObject );
            } else {
                irp->MdlAddress = clientMdl;
            }
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        MmBuildMdlForNonPagedPool( mdl );

    } else {

        irp->MdlAddress = NULL;
    }

    irp->RequestorMode = KernelMode;
    irp->UserIosb = &ioStatusBlock;
    irp->UserEvent = &event;

    //
    // Put the file object pointer in the stack location.
    //
    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->FileObject = FileObject;
    irpSp->DeviceObject = DeviceObject;

    //
    // Fill in the service-dependent parameters for the request.
    //
    CnAssert( IrpParametersLength <= sizeof(irpSp->Parameters) );
    RtlCopyMemory( &irpSp->Parameters, IrpParameters, IrpParametersLength );

    irpSp->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    irpSp->MinorFunction = MinorFunction;

    //
    // Set up a completion routine which we'll use to free the MDL
    // allocated previously.
    //
    IoSetCompletionRoutine(
        irp,
        CnpRestartDeviceControl,
        (PVOID) &reuseIrp,
        TRUE,
        TRUE,
        TRUE
        );

    status = IoCallDriver( DeviceObject, irp );

    //
    // If necessary, wait for the I/O to complete.
    //

    if ( status == STATUS_PENDING ) {
        KeWaitForSingleObject(
            (PVOID)&event,
            UserRequest,
            KernelMode,
            FALSE,
            NULL
            );
    }

    //
    // If the request was successfully queued, get the final I/O status.
    //

    if ( NT_SUCCESS(status) ) {
        status = ioStatusBlock.Status;
    }

    //
    // Before returning, restore the client IRP
    //
    if (reuseIrp) {
        irp->RequestorMode = clientRequestorMode;
        irp->UserIosb = clientIosb;
        irp->UserEvent = clientUserEvent;
        irp->MdlAddress = clientMdl;
    }

    return status;

} // CnpIssueDeviceControl



NTSTATUS
CnpTdiSetEventHandler(
    IN PFILE_OBJECT    FileObject,
    IN PDEVICE_OBJECT  DeviceObject,
    IN ULONG           EventType,
    IN PVOID           EventHandler,
    IN PVOID           EventContext,
    IN PIRP            ClientIrp     OPTIONAL
    )
/*++

Routine Description:

    Sets up a TDI indication handler on a connection or address object
    (depending on the file handle).  This is done synchronously, which
    shouldn't usually be an issue since TDI providers can usually complete
    indication handler setups immediately.

Arguments:

    FileObject - a pointer to the file object for an open connection or
        address object.

    DeviceObject - a pointer to the device object associated with the
        file object.

    EventType - the event for which the indication handler should be
        called.

    EventHandler - the routine to call when tghe specified event occurs.

    EventContext - context which is passed to the indication routine.
    
    ClientIrp - client IRP that may be passed to CnpIssueDeviceControl
        for reuse    

Return Value:

    NTSTATUS -- Indicates the status of the request.

--*/

{
    TDI_REQUEST_KERNEL_SET_EVENT  parameters;
    NTSTATUS                      status;


    PAGED_CODE( );

    parameters.EventType = EventType;
    parameters.EventHandler = EventHandler;
    parameters.EventContext = EventContext;

    status = CnpIssueDeviceControl(
                 FileObject,
                 DeviceObject,
                 &parameters,
                 sizeof(parameters),
                 NULL,
                 0,
                 TDI_SET_EVENT_HANDLER,
                 ClientIrp
                 );

    return(status);

}  // CnpTdiSetEventHandler



NTSTATUS
CnpTdiErrorHandler(
    IN PVOID     TdiEventContext,
    IN NTSTATUS  Status
    )
{

    return(STATUS_SUCCESS);

}  // CnpTdiErrorHandler



VOID
CnpAttachSystemProcess(
    VOID
    )
/*++

Routine Description:

    Attach to the system process, as determined during DriverEntry
    and stored in CnSystemProcess.
    
Arguments:

    None.
    
Return value:

    None.
    
Notes:

    Must be followed by a call to CnpDetachSystemProcess.
    
    Implemented in this module due to header conflicts with
    ntddk.h.
    
--*/
{
    KeAttachProcess(CnSystemProcess);

    return;

}  // CnpAttachSystemProcess



VOID
CnpDetachSystemProcess(
    VOID
    )
/*++

Routine Description:

    Detach from the system process.
    
Arguments:

    None.
    
Return value:

    None.
    
Notes:

    Must be preceded by a call to CnpDetachSystemProcess.
    
    Implemented in this module due to header conflicts with
    ntddk.h.
    
--*/
{
    KeDetachProcess();

    return;

}  // CnpDetachSystemProcess


NTSTATUS
CnpOpenDevice(
    IN      LPWSTR          DeviceName,
    OUT     HANDLE          *Handle
    )
/*++

Routine Description:

    Opens a handle to DeviceName. Since no EaBuffer is specified,
    CnpOpenDevice opens a control channel for TDI transports.
    
Arguments:

    DeviceName - device to open
    
    Handle - resulting handle, NULL on failure

Return Value:

    Status of ZwCreateFile
    
Notes:

    Specifies OBJ_KERNEL_HANDLE, meaning that the resulting 
        handle is only valid in kernel-mode. This routine
        cannot be called to obtain a handle that will be 
        exported to user-mode.

--*/
{
    UNICODE_STRING nameString;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK iosb;
    NTSTATUS status;

    *Handle = (HANDLE) NULL;

    RtlInitUnicodeString(&nameString, DeviceName);

    InitializeObjectAttributes(
        &objectAttributes,
        &nameString,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    status = ZwCreateFile(
                 Handle,
                 SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                 &objectAttributes,
                 &iosb,
                 NULL,
                 FILE_ATTRIBUTE_NORMAL,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_OPEN_IF,
                 0,
                 NULL,
                 0
                 );

    if (!NT_SUCCESS(status)) {
        IF_CNDBG(CN_DEBUG_OPEN) {
            CNPRINT(("[Clusnet] Failed to open device %S, status %lx\n", 
                     DeviceName, status));
        }
        *Handle = NULL;
    }

    return(status);

}   // CnpOpenDevice


NTSTATUS
CnpZwDeviceControl(
    IN HANDLE   Handle,
    IN ULONG    IoControlCode,
    IN PVOID    InputBuffer,
    IN ULONG    InputBufferLength,
    IN PVOID    OutputBuffer,
    IN ULONG    OutputBufferLength
    )
{
    NTSTATUS             status = STATUS_SUCCESS;
    IO_STATUS_BLOCK      iosb;
    HANDLE               event;

    PAGED_CODE();

    status = ZwCreateEvent( &event,
                            EVENT_ALL_ACCESS,
                            NULL,
                            SynchronizationEvent,
                            FALSE );

    if (NT_SUCCESS(status)) {

        status = ZwDeviceIoControlFile(
                     Handle,
                     event,
                     NULL,
                     NULL,
                     &iosb,
                     IoControlCode,
                     InputBuffer,
                     InputBufferLength,
                     OutputBuffer,
                     OutputBufferLength
                     );

        if (status == STATUS_PENDING) {
            status = ZwWaitForSingleObject( event, FALSE, NULL );
            CnAssert( status == STATUS_SUCCESS );
            status = iosb.Status;
        }

        ZwClose( event );
    }

    return(status);

} // CnpZwDeviceControl


#define TCP_SET_INFO_EX_BUFFER_PREALLOCSIZE 16
#define TCP_SET_INFO_EX_PREALLOCSIZE                      \
    (FIELD_OFFSET(TCP_REQUEST_SET_INFORMATION_EX, Buffer) \
     + TCP_SET_INFO_EX_BUFFER_PREALLOCSIZE                \
     )

NTSTATUS
CnpSetTcpInfoEx(
    IN HANDLE   Handle,
    IN ULONG    Entity,
    IN ULONG    Class,
    IN ULONG    Type,
    IN ULONG    Id,
    IN PVOID    Value,
    IN ULONG    ValueLength
    )
{
    NTSTATUS                        status;
    PTCP_REQUEST_SET_INFORMATION_EX setInfoEx;
    UCHAR                           infoBuf[TCP_SET_INFO_EX_PREALLOCSIZE]={0};

    //
    // Check if we need to dynamically allocate.
    //
    if (ValueLength > TCP_SET_INFO_EX_BUFFER_PREALLOCSIZE) {

        setInfoEx = CnAllocatePool(
                        FIELD_OFFSET(TCP_REQUEST_SET_INFORMATION_EX, Buffer)
                        + ValueLength
                        );
        if (setInfoEx == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        RtlZeroMemory(
            setInfoEx,
            FIELD_OFFSET(TCP_REQUEST_SET_INFORMATION_EX, Buffer) + ValueLength
            );

    } else {

        setInfoEx = (PTCP_REQUEST_SET_INFORMATION_EX)&infoBuf[0];
    }

    setInfoEx->ID.toi_entity.tei_entity = Entity;
    setInfoEx->ID.toi_entity.tei_instance = 0;
    setInfoEx->ID.toi_class = Class;
    setInfoEx->ID.toi_type = Type;
    setInfoEx->ID.toi_id = Id;
    setInfoEx->BufferSize = ValueLength;
    RtlCopyMemory(setInfoEx->Buffer, Value, ValueLength);
    
    status = CnpZwDeviceControl(
                 Handle,
                 IOCTL_TCP_SET_INFORMATION_EX,
                 setInfoEx,
                 FIELD_OFFSET(TCP_REQUEST_SET_INFORMATION_EX, Buffer)
                 + ValueLength,
                 NULL,
                 0
                 );

    //
    // Free the buffer, if dynamically allocated
    //
    if (setInfoEx != (PTCP_REQUEST_SET_INFORMATION_EX)&infoBuf[0]) {
        CnFreePool(setInfoEx);
    }

    return(status);

}   // CnpSetTcpInfoEx


NTSTATUS
CnpMakeSignature(
    IN     PSecBufferDesc         Data,
    IN     DESTable             * DesTable,
    IN     PVOID                  SigBuffer,         OPTIONAL
    IN     ULONG                  SigBufferLength,   OPTIONAL
    OUT    PSecBuffer           * SigSecBuffer,      OPTIONAL
    OUT    ULONG                * SigLen             OPTIONAL
    )
/*++

Routine Description:

    Builds a signature for Data.
    
Arguments:

    Data - data to be signed, packaged in a SecBufferDesc. All
           SecBuffers in Data should be of type SECBUFFER_DATA
           except exactly one which has type SECBUFFER_TOKEN.
           Other buffers will be ignored.
           
    DESTable - DES table containing encryption/decryption keys
    
    SigBuffer - Buffer in which to place completed signature. If NULL,
                signature is written into signature secbuffer (has
                type SECBUFFER_TOKEN in Data).
                
    SigBufferLength - length of buffer at SigBuffer, if provided
    
    SigSecBuffer - If non-NULL, returns pointer to signature secbuffer
                   from Data.
    
    SigLen - on success, contains length of signature written
             on SEC_E_BUFFER_TOO_SMALL, contains required signature length
             undefined otherwise
    
Return value:

    SEC_E_OK if successful.
    SEC_E_SECPKG_NOT_FOUND if the security buffer version is wrong.
    SEC_E_BUFFER_TOO_SMALL if SigBufferLength is too small.
    SEC_E_INVALID_TOKEN if Data is a misformed SecBuffer.
    
--*/
{
    A_SHA_CTX            shaCtxt;
    UCHAR                hashBuffer[CX_SIGNATURE_LENGTH] = { 0 };
    ULONG                hashSize;
    ULONG                bufIndex;
    PSecBuffer           sigSecBuffer = NULL;
    PSecBuffer           curBuffer;
    PUCHAR               curBlock;
    PUCHAR               encryptedHashBuffer;
    ULONG                status;

    //
    // Verify the version.
    //
    if (Data->ulVersion != SECBUFFER_VERSION) {
        status = SEC_E_SECPKG_NOT_FOUND;
        goto error_exit;
    }

    //
    // Verify that the provided sig buffer is big enough.
    //
    if (SigBuffer != NULL && SigBufferLength < CX_SIGNATURE_LENGTH) {
        status = SEC_E_BUFFER_TOO_SMALL;
        goto error_exit;
    }

    //
    // Initialize the SHA context.
    //
    CxFipsFunctionTable.FipsSHAInit(&shaCtxt);

    //
    // Hash the data.
    //
    for (bufIndex = 0, curBuffer = &(Data->pBuffers[bufIndex]); 
         bufIndex < Data->cBuffers; 
         bufIndex++, curBuffer++) {

        //
        // Process this buffer according to its type.
        //
        if (curBuffer->BufferType == SECBUFFER_DATA) {

            //
            // Hash this buffer.
            //
            CxFipsFunctionTable.FipsSHAUpdate(
                                    &shaCtxt, 
                                    (PUCHAR) curBuffer->pvBuffer, 
                                    curBuffer->cbBuffer
                                    );

        } else if (curBuffer->BufferType == SECBUFFER_TOKEN) {

            if (sigSecBuffer != NULL) {
                status = SEC_E_INVALID_TOKEN;
                goto error_exit;
            } else {
                sigSecBuffer = curBuffer;
                
                //
                // Verify that the signature buffer is big enough.
                //
                if (sigSecBuffer->cbBuffer < A_SHA_DIGEST_LEN) {
                    *SigLen = CX_SIGNATURE_LENGTH;
                    status = SEC_E_BUFFER_TOO_SMALL;
                    goto error_exit;
                }

                //
                // Set the output buffer.
                //
                if (SigBuffer == NULL) {
                    encryptedHashBuffer = sigSecBuffer->pvBuffer;
                } else {
                    encryptedHashBuffer = SigBuffer;
                }
            }
        }
    }

    //
    // Verify that we found a buffer for the signature.
    //
    if (sigSecBuffer == NULL) {
        status = SEC_E_INVALID_TOKEN;
        goto error_exit;
    }

    //
    // Complete the hash.
    //
    CxFipsFunctionTable.FipsSHAFinal(&shaCtxt, hashBuffer);

    //
    // Encrypt the hash one DES block at a time.
    //
    for (bufIndex = 0;
         bufIndex < CX_SIGNATURE_LENGTH; 
         bufIndex += DES_BLOCKLEN) {
    
        CxFipsFunctionTable.FipsDes(
                                &(encryptedHashBuffer[bufIndex]),
                                &(hashBuffer[bufIndex]), 
                                DesTable,
                                ENCRYPT
                                );
    }

    if (SigSecBuffer != NULL) {
        *SigSecBuffer = sigSecBuffer;
    }
    if (SigLen != NULL) {
        *SigLen = CX_SIGNATURE_LENGTH;
    }

    status = SEC_E_OK;

error_exit:

    return(status);

} // CnpMakeSignature

NTSTATUS
CnpVerifySignature(
    IN     PSecBufferDesc         Data,
    IN     DESTable             * DesTable
    )
/*++

Routine Description:

    Verifies a signature for data.

Arguments:

    Data - data to be verified, packaged in a SecBufferDesc. All
           SecBuffers in Data should be of type SECBUFFER_DATA
           except exactly one which has type SECBUFFER_TOKEN.
           Other buffers will be ignored.
           
    DESTable - DES table containing encryption/decryption keys
    
Return value:

    SEC_E_OK if the signature is correct.
    SEC_E_SECPKG_NOT_FOUND if the security buffer version is wrong.
    SEC_E_INVALID_TOKEN if Data is a misformed SecBuffer.
    SEC_E_MESSAGE_ALTERED if signature is incorrect (including if it
        is the wrong length).
        
--*/
{
    UCHAR                encryptedHashBuffer[CX_SIGNATURE_LENGTH];
    PSecBuffer           sigBuffer = NULL;
    ULONG                status;

    status = CnpMakeSignature(
                 Data,
                 DesTable,
                 encryptedHashBuffer,
                 sizeof(encryptedHashBuffer),
                 &sigBuffer,
                 NULL
                 );
    if (status == STATUS_SUCCESS) {
    
        //
        // Compare the generated signature to the provided signature.
        //
        if (RtlCompareMemory(
                encryptedHashBuffer,
                sigBuffer->pvBuffer, 
                sigBuffer->cbBuffer
                ) != sigBuffer->cbBuffer) {
            status = SEC_E_MESSAGE_ALTERED;
        } else {
            status = SEC_E_OK;
        }
    }

    return(status);

} // CnpVerifySignature

NTSTATUS
CnpSignMulticastMessage(
    IN     PCNP_SEND_REQUEST               SendRequest,
    IN     PMDL                            DataMdl,
    IN OUT CL_NETWORK_ID                 * NetworkId,
    OUT    ULONG                         * SigDataLen        OPTIONAL
    )
/*++

Routine Description:

    Sign a message.
    
    If NetworkId is not ClusterAnyNetworkId, the mcast group
    field must be set (and already referenced) in the SendRequest.
    This is the group that will be used to send the packet.
    
Arguments:

    SendRequest - send request, used to locate the upper protocol
                  header to sign, as well as the signature buffer.
    
    DataMdl - data to sign
    
    NetworkId - IN: network on which to send the message, or 
                    ClusterAnyNetworkId if it should be chosen
                OUT: network id chosen to send packet
    
    SigDataLen - OUT (OPTIONAL): number of bytes occupied in
                 message by signature data and signature
    
--*/
{
    NTSTATUS                        status;
    PCNP_NETWORK                    network;
    PCNP_MULTICAST_GROUP            mcastGroup;
    BOOLEAN                         mcastGroupReferenced = FALSE;
    CNP_HEADER UNALIGNED          * cnpHeader;
    CNP_SIGNATURE UNALIGNED       * cnpSig;
    SecBufferDesc                   sigDescriptor;
    SecBuffer                       sigSecBufferPrealloc[4];
    PSecBuffer                      sigSecBuffer = NULL;
    ULONG                           secBufferCount;
    ULONG                           sigLen;
    PMDL                            mdl;
    PSecBuffer                      curBuffer;

    CnAssert(SendRequest != NULL);
    CnAssert(((CNP_HEADER UNALIGNED *)SendRequest->CnpHeader)->Version ==
             CNP_VERSION_MULTICAST);

    //
    // Determine which network to use.
    //
    if (*NetworkId != ClusterAnyNetworkId) {
        
        mcastGroup = SendRequest->McastGroup;
        CnAssert(mcastGroup != NULL);
    
    } else {
        
        network = CnpGetBestMulticastNetwork();

        if (network == NULL) {
            CnTrace(CNP_SEND_ERROR, CnpMcastGetBestNetwork,
                "[CNP] Failed to find best multicast network."
                );
            status = STATUS_NETWORK_UNREACHABLE;
            goto error_exit;
        } 
        
        //
        // Get the network id and mcast group before releasing
        // the network lock.
        //
        *NetworkId = network->Id;

        mcastGroup = network->CurrentMcastGroup;
        if (mcastGroup == NULL) {
            CnTrace(CNP_SEND_ERROR, CnpMcastGroupNull,
                "[CNP] Best multicast network %u has null "
                "multicast group.",
                network->Id
                );
            CnReleaseLock(&(network->Lock), network->Irql);
            status = STATUS_NETWORK_UNREACHABLE;
            goto error_exit;
        }
        CnpReferenceMulticastGroup(mcastGroup);
        mcastGroupReferenced = TRUE;

        CnReleaseLock(&(network->Lock), network->Irql);
    }

    CnAssert(mcastGroup->SignatureLength <= CX_SIGNATURE_LENGTH);

    //
    // Determine how many sig sec buffers we will need.
    // The common case is four: one for a header, 
    // one for the data, one for the salt, and one for 
    // the signature. We prealloc sig buffers on the 
    // stack for the common case, but we dynamically 
    // allocate if needed (e.g. if the data is a chain
    // of MDLs).
    //
    secBufferCount = 3;
    for (mdl = DataMdl; mdl != NULL; mdl = mdl->Next) {
        secBufferCount++;
    }

    //
    // Allocate the sig sec buffers.
    //
    if (secBufferCount <= 4) {
        sigSecBuffer = &sigSecBufferPrealloc[0];
    } else {

        sigSecBuffer = CnAllocatePool(
                           secBufferCount * sizeof(SecBuffer)
                           );
        if (sigSecBuffer == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto error_exit;
        }
    }

    //
    // Prepare the descriptor for the message and signature.
    //
    sigDescriptor.cBuffers = secBufferCount;
    sigDescriptor.pBuffers = sigSecBuffer;
    sigDescriptor.ulVersion = SECBUFFER_VERSION;
    curBuffer = sigSecBuffer;

    //
    // Header.
    //
    if (SendRequest->UpperProtocolHeader != NULL) {
        CnAssert(SendRequest->UpperProtocolHeaderLength > 0);
        curBuffer->BufferType = SECBUFFER_DATA;
        curBuffer->cbBuffer = SendRequest->UpperProtocolHeaderLength;
        curBuffer->pvBuffer = SendRequest->UpperProtocolHeader;
        curBuffer++;
    }

    //
    // The payload provided by our client.
    //
    for (mdl = DataMdl; mdl != NULL; mdl = mdl->Next) {

        curBuffer->BufferType = SECBUFFER_DATA;
        curBuffer->cbBuffer = MmGetMdlByteCount(mdl);
        curBuffer->pvBuffer = MmGetMdlVirtualAddress(mdl);
        curBuffer++;
    }

    //
    // The salt.
    //
    curBuffer->BufferType = SECBUFFER_DATA;
    curBuffer->cbBuffer = mcastGroup->SaltLength;
    curBuffer->pvBuffer = mcastGroup->Salt;
    curBuffer++;

    //
    // The Signature.
    //
    cnpHeader = (CNP_HEADER UNALIGNED *)(SendRequest->CnpHeader);
    cnpSig = (CNP_SIGNATURE UNALIGNED *)(cnpHeader + 1);
    curBuffer->BufferType = SECBUFFER_TOKEN;
    curBuffer->pvBuffer = cnpSig->SigBuffer;
    curBuffer->cbBuffer = CX_SIGNATURE_LENGTH;

    status = CnpMakeSignature(
                 &sigDescriptor,
                 &(mcastGroup->DesTable),
                 NULL,
                 0,
                 NULL,
                 &sigLen
                 );

    if (status == STATUS_SUCCESS && sigLen <= CX_SIGNATURE_LENGTH) {

        //
        // Fill in the CNP signature data.
        //
        cnpSig->PayloadOffset = (USHORT) CNP_SIG_LENGTH(CX_SIGNATURE_LENGTH);
        cnpSig->Version = CNP_SIG_VERSION_1;
        cnpSig->NetworkId = *NetworkId;
        cnpSig->ClusterNetworkBrand = mcastGroup->McastNetworkBrand;
        cnpSig->SigBufferLen = (USHORT) sigLen;

    } else {

        IF_CNDBG(CN_DEBUG_CNPSEND) {
            CNPRINT(("[CNP] MakeSignature failed or returned "
                     "an unexpected length, status %x, "
                     "expected length %d, returned length %d.\n",
                     status, CX_SIGNATURE_LENGTH, sigLen));
        }

        CnTrace(CNP_SEND_ERROR, CnpMcastMakeSigFailed,
            "[CNP] MakeSignature failed or returned "
            "an unexpected length, status %!status!, "
            "expected length %d, returned length %d.",
            status, CX_SIGNATURE_LENGTH, sigLen
            );

        status = STATUS_CLUSTER_NO_SECURITY_CONTEXT;
    }

    if (SigDataLen != NULL) {
        *SigDataLen = cnpSig->PayloadOffset;
    }

    SendRequest->McastGroup = mcastGroup;

error_exit:

    if (sigSecBuffer != NULL && 
        sigSecBuffer != &sigSecBufferPrealloc[0]) {

        CnFreePool(sigSecBuffer);
        sigSecBuffer = NULL;
    }

    if (status != STATUS_SUCCESS && mcastGroupReferenced) {
        CnAssert(mcastGroup != NULL);
        CnpDereferenceMulticastGroup(mcastGroup);
        mcastGroupReferenced = FALSE;
    }

    return(status);

} // CnpSignMulticastMessage


NTSTATUS
CnpVerifyMulticastMessage(
    IN     PCNP_NETWORK                    Network,
    IN     PVOID                           Tsdu,
    IN     ULONG                           TsduLength,
    IN     ULONG                           ExpectedPayload,
       OUT ULONG                         * BytesTaken,
       OUT BOOLEAN                       * CurrentGroup
    )
/*++

Routine Description:

    Verify a message.
    
Arguments:

    Network - network on which message arrived
    
    Tsdu - points to protocol header
           
    TsduLength - length of TSDU, including signature data
    
    ExpectedPayload - expected payload after signature data
                     
    BytesTaken - OUT: quantity of data consumed by signature
                     
    CurrentGroup - OUT: whether signature matched current
                        multicast group. 

Return value:

    SEC_E_OK or error status.
    
--*/
{
    NTSTATUS                        status;
    CNP_SIGNATURE UNALIGNED       * cnpSig = Tsdu;
    ULONG                           sigBufBytes = 0;
    ULONG                           sigPayOffBytes = 0;
    PVOID                           payload;
    ULONG                           payloadLength;
    PCNP_MULTICAST_GROUP            currMcastGroup = NULL;
    PCNP_MULTICAST_GROUP            prevMcastGroup = NULL;

    SecBufferDesc                   sigDescriptor;
    SecBuffer                       sigSecBufferPrealloc[3];
    PSecBuffer                      sigSecBuffer = NULL;
    PSecBuffer                      curBuffer;


    //
    // Verify that the signature is present. Do not 
    // dereference any signature data until we know 
    // it's there.
    //
    if (
        
        // Verify that signature header data is present.
        (TsduLength < (ULONG)CNP_SIGHDR_LENGTH) ||

        // Verify that signature buffer is present
        (TsduLength < (sigBufBytes = CNP_SIG_LENGTH(cnpSig->SigBufferLen))) ||

        // Verify that the payload offset is reasonable
        (TsduLength <= (sigPayOffBytes = cnpSig->PayloadOffset)) ||

        // Verify that the expected payload is present
        (TsduLength - sigPayOffBytes != ExpectedPayload)
        
        ) {

        IF_CNDBG(CN_DEBUG_CNPRECV) {
            CNPRINT(("[CNP] Cannot verify mcast packet with "
                     "mis-sized payload: TsduLength %u, required "
                     "sig hdr %u, sig buffer %u, "
                     "payload offset %u, expected payload %u.\n",
                     TsduLength,
                     CNP_SIGHDR_LENGTH,
                     sigBufBytes,
                     sigPayOffBytes,
                     ExpectedPayload
                     ));
        }

        CnTrace(CNP_RECV_ERROR, CnpTraceReceiveTooSmall,
            "[CNP] Cannot verify mcast packet with "
            "undersized payload: TsduLength %u, required "
            "sig hdr %u, sig buffer %u, "
            "payload offset %u, expected payload %u.\n",
            TsduLength,
            CNP_SIGHDR_LENGTH,
            sigBufBytes,
            sigPayOffBytes,
            ExpectedPayload
            );

        //
        // Drop it.
        //
        status = SEC_E_INCOMPLETE_MESSAGE;
        goto error_exit;            
    }

    //
    // Verify that the signature protocol is understood.
    //
    if (cnpSig->Version != CNP_SIG_VERSION_1) {
        IF_CNDBG(CN_DEBUG_CNPRECV) {
            CNPRINT(("[CNP] Cannot verify mcast packet with "
                     "unknown signature version: %u.\n",
                     cnpSig->Version
                     ));
        }

        CnTrace(
            CNP_RECV_ERROR, CnpTraceRecvUnknownSigVersion,
            "[CNP] Cannot verify mcast packet with "
            "unknown signature version: %u.",
            cnpSig->Version
            );

        //
        // Drop it.
        //
        status = SEC_E_BAD_PKGID;
        goto error_exit;
    }

    //
    // Locate the payload following the signature data.
    //
    payload = (PVOID)((PUCHAR)(cnpSig) + sigPayOffBytes);
    payloadLength = TsduLength - sigPayOffBytes;

    //
    // Lock the network object and reference the 
    // multicast groups.
    //
    CnAcquireLock(&(Network->Lock), &(Network->Irql));

    currMcastGroup = Network->CurrentMcastGroup;
    if (currMcastGroup != NULL) {
        CnpReferenceMulticastGroup(currMcastGroup);
    }
    prevMcastGroup = Network->CurrentMcastGroup;
    if (prevMcastGroup != NULL) {
        CnpReferenceMulticastGroup(prevMcastGroup);
    }

    CnReleaseLock(&(Network->Lock), Network->Irql);

    //
    // Verify that the packet network id matches the 
    // local network object.
    //
    if (cnpSig->NetworkId != Network->Id) {
        IF_CNDBG(CN_DEBUG_CNPRECV) {
            CNPRINT(("[CNP] Mcast packet has bad network "
                     "id: found %d, expected %d.\n",
                     cnpSig->NetworkId,
                     Network->Id
                     ));
        }

        CnTrace(
            CNP_RECV_ERROR, CnpTraceReceiveBadNetworkId,
            "[CNP] Mcast packet has bad network id: "
            "found %d, expected %d.",
            cnpSig->NetworkId,
            Network->Id
            );

        //
        // Drop it.
        //
        status = SEC_E_TARGET_UNKNOWN;
        goto error_exit;
    }

    //
    // Verify that the brand matches either the current or
    // previous multicast group.
    //
    if (currMcastGroup != NULL &&
        cnpSig->ClusterNetworkBrand != currMcastGroup->McastNetworkBrand) {

        // can't use currMcastGroup
        CnpDereferenceMulticastGroup(currMcastGroup);
        currMcastGroup = NULL;
    }

    if (prevMcastGroup != NULL &&
        cnpSig->ClusterNetworkBrand != prevMcastGroup->McastNetworkBrand) {

        // can't use prevMcastGroup
        CnpDereferenceMulticastGroup(prevMcastGroup);
        prevMcastGroup = NULL;
    }

    if (currMcastGroup == NULL && prevMcastGroup == NULL) {

        IF_CNDBG(CN_DEBUG_CNPRECV) {
            CNPRINT(("[CNP] Recv'd mcast packet with brand %x, "
                     "but no matching multicast groups.\n",
                     cnpSig->ClusterNetworkBrand
                     ));
        }

        CnTrace(
            CNP_RECV_ERROR, CnpTraceReceiveBadBrand,
            "[CNP] Recv'd mcast packet with brand %x, "
            "but no matching multicast groups.",
            cnpSig->ClusterNetworkBrand
            );

        //
        // Drop it.
        //
        status = SEC_E_TARGET_UNKNOWN;
        goto error_exit;
    }

    //
    // Build the signature descriptor for verification. The bytes
    // that were signed (and hence need to be verified) include
    // the payload data, starting after the signature, and the salt.
    //
    sigSecBuffer = &sigSecBufferPrealloc[0];
    curBuffer = sigSecBuffer;

    sigDescriptor.cBuffers = 2;
    sigDescriptor.pBuffers = sigSecBuffer;
    sigDescriptor.ulVersion = SECBUFFER_VERSION;

    //
    // Data.
    //
    if (payloadLength > 0) {
        sigDescriptor.cBuffers = 3;
        curBuffer->BufferType = SECBUFFER_DATA;
        curBuffer->cbBuffer = payloadLength;
        curBuffer->pvBuffer = payload;
        curBuffer++;
    } 

    //
    // Signature.
    //
    curBuffer->BufferType = SECBUFFER_TOKEN;
    curBuffer->cbBuffer = cnpSig->SigBufferLen;
    curBuffer->pvBuffer = (PVOID)&(cnpSig->SigBuffer[0]);
    curBuffer++;

    /*CNPRINT(("[CNP] Verifying message of length %d with "
             "sig of length %d.\n",
             HeaderLength + payloadLength,
             cnpSig->SigBufferLen));*/

    //
    // Try the current multicast group, and if necessary,
    // the previous multicast group.
    //
    status = SEC_E_INVALID_TOKEN;

    if (currMcastGroup != NULL) {

        //
        // Salt.
        //
        curBuffer->BufferType = SECBUFFER_DATA;
        curBuffer->cbBuffer = currMcastGroup->SaltLength;
        curBuffer->pvBuffer = currMcastGroup->Salt;

        status = CnpVerifySignature(
                     &sigDescriptor,
                     &(currMcastGroup->DesTable)
                     );

        if (status == SEC_E_OK && CurrentGroup != NULL) {
            *CurrentGroup = TRUE;
        }
    }

    if (status != SEC_E_OK && prevMcastGroup != NULL) {

        curBuffer->cbBuffer = prevMcastGroup->SaltLength;
        curBuffer->pvBuffer = prevMcastGroup->Salt;

        status = CnpVerifySignature(
                     &sigDescriptor,
                     &(prevMcastGroup->DesTable)
                     );
        if (status == SEC_E_OK && CurrentGroup != NULL) {
            *CurrentGroup = FALSE;
        }
    }

    if (status == SEC_E_OK) {
        *BytesTaken = sigPayOffBytes;
    }

error_exit:

    if (currMcastGroup != NULL) {
        CnpDereferenceMulticastGroup(currMcastGroup);
    }

    if (prevMcastGroup != NULL) {
        CnpDereferenceMulticastGroup(prevMcastGroup);
    }

    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    return(status);

} // CnpVerifyMulticastMessage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\xport\cnpif.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cnpif.c

Abstract:

    Interface management routines for the Cluster Network Protocol.

Author:

    Mike Massa (mikemas)           January 6, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-06-97    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "cnpif.tmh"

#include <ntddndis.h>


//
// Routines exported within CNP
//
BOOLEAN
CnpIsBetterInterface(
    PCNP_INTERFACE            Interface1,
    PCNP_INTERFACE            Interface2
    )
{
    if ( (Interface2 == NULL)
         ||
         (Interface1->State > Interface2->State)
         ||
         ( (Interface1->State == Interface2->State)
           &&
           CnpIsHigherPriority(Interface1->Priority, Interface2->Priority)
         )
       )
    {
        return(TRUE);
    }

    return(FALSE);
}

VOID
CnpWalkInterfacesOnNode(
    PCNP_NODE                      Node,
    PCNP_INTERFACE_UPDATE_ROUTINE  UpdateRoutine
    )
/*++

Routine Description:

    Walks the interface list of a node and performs a specified
    operation on each interface.

Arguments:

    Node    - The node on which to operate.

    UpdateRoutine - The operation to perform on each interface.

Return Value:

    None.

Notes:

    Called with node object lock held.

    Valid Update Routines:

        CnpOnlinePendingInterfaceWrapper
        CnpOfflineInterfaceWrapper

--*/
{
    PLIST_ENTRY      entry, nextEntry;
    PCNP_INTERFACE   interface;



    CnVerifyCpuLockMask(
        CNP_NODE_OBJECT_LOCK,      // Required
        0,                         // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX   // Maximum
        );

    entry = Node->InterfaceList.Flink;

    while (entry != &(Node->InterfaceList)) {
        //
        // Save a pointer to the next entry now in case we delete the
        // current entry.
        //
        nextEntry = entry->Flink;

        interface = CONTAINING_RECORD(
                        entry,
                        CNP_INTERFACE,
                        NodeLinkage
                        );

        CnAcquireLockAtDpc(&(interface->Network->Lock));
        interface->Network->Irql = DISPATCH_LEVEL;

        (*UpdateRoutine)(interface);

        //
        // The network object lock was released.
        //

        entry = nextEntry;
    }

    CnVerifyCpuLockMask(
        CNP_NODE_OBJECT_LOCK,      // Required
        0,                         // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX   // Maximum
        );

    return;

} // CnpWalkInterfacesOnNode



VOID
CnpWalkInterfacesOnNetwork(
    PCNP_NETWORK                   Network,
    PCNP_INTERFACE_UPDATE_ROUTINE  UpdateRoutine
    )
/*++

Routine Description:

    Walks the node table and the interface list of each node looking
    for interfaces on a specified network. Performs a specified operation
    on each matching interface.

Arguments:

    Network    - The target network.

    UpdateRoutine - The operation to perform on each matching interface.

Return Value:

    None.

Notes:

    Called with no locks held.

    Valid Update Routines:

        CnpOnlinePendingInterfaceWrapper
        CnpOfflineInterfaceWrapper
        CnpDeleteInterface
        CnpRecalculateInterfacePriority

--*/
{
    ULONG            i;
    CN_IRQL          tableIrql;
    PCNP_NODE        node;
    PLIST_ENTRY      entry;
    PCNP_INTERFACE   interface;


    CnVerifyCpuLockMask(
        0,                         // Required
        CNP_LOCK_RANGE,            // Forbidden
        CNP_PRECEEDING_LOCK_RANGE  // Maximum
        );

    CnAcquireLock(&CnpNodeTableLock, &tableIrql);

    CnAssert(CnMinValidNodeId != ClusterInvalidNodeId);
    CnAssert(CnMaxValidNodeId != ClusterInvalidNodeId);

    for (i=CnMinValidNodeId; i <= CnMaxValidNodeId; i++) {
        node = CnpNodeTable[i];

        if (node != NULL) {

            CnAcquireLockAtDpc(&(node->Lock));
            CnReleaseLockFromDpc(&CnpNodeTableLock);
            node->Irql = tableIrql;

            for (entry = node->InterfaceList.Flink;
                 entry != &(node->InterfaceList);
                 entry = entry->Flink
                )
            {
                interface = CONTAINING_RECORD(
                                entry,
                                CNP_INTERFACE,
                                NodeLinkage
                                );

                if (interface->Network == Network) {

                    CnAcquireLockAtDpc(&(Network->Lock));
                    Network->Irql = DISPATCH_LEVEL;

                    (*UpdateRoutine)(interface);

                    //
                    // The network object lock was released.
                    // The node object lock is still held.
                    //

                    break;
                }
            }

            CnReleaseLock(&(node->Lock), node->Irql);
            CnAcquireLock(&CnpNodeTableLock, &tableIrql);
        }
    }

    CnReleaseLock(&CnpNodeTableLock, tableIrql);

    CnVerifyCpuLockMask(
        0,                         // Required
        CNP_LOCK_RANGE,            // Forbidden
        CNP_PRECEEDING_LOCK_RANGE  // Maximum
        );

    return;

} // CnpWalkInterfacesOnNetwork



NTSTATUS
CnpOnlinePendingInterface(
    PCNP_INTERFACE   Interface
    )
/*++

Routine Description:

    Changes an Offline interface to the OnlinePending state.
    This will enable heartbeats over this interface. When a heartbeat
    is established, the interface will move to the Online state.

Arguments:

    Interface - A pointer to the interface to change.

Return Value:

    An NT status value.

Notes:

    Called with associated node and network locks held.
    Returns with network lock released.

    Conforms to calling convention for PCNP_INTERFACE_UPDATE_ROUTINE.

--*/
{
    NTSTATUS                 status = STATUS_SUCCESS;
    PCNP_NODE                node = Interface->Node;
    PCNP_NETWORK             network = Interface->Network;


    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK | CNP_NETWORK_OBJECT_LOCK),   // Required
        0,                                                  // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX                         // Maximum
        );

    if ( (Interface->State == ClusnetInterfaceStateOffline) &&
         (network->State == ClusnetNetworkStateOnline)
       )
    {
        IF_CNDBG( CN_DEBUG_IFOBJ )
            CNPRINT((
                "[CNP] Moving interface (%u, %u) to OnlinePending state.\n",
                node->Id,
                network->Id
                ));

        Interface->State = ClusnetInterfaceStateOnlinePending;
        Interface->MissedHBs = 0;

        //
        // Send multicast discovery packets.
        //
        if (Interface->Node != CnpLocalNode
            && CnpIsNetworkMulticastCapable(network)) {
            Interface->McastDiscoverCount = CNP_INTERFACE_MCAST_DISCOVERY;
        }

        //
        // Place an active reference on the associated network.
        //
        CnpActiveReferenceNetwork(network);

        //
        // Update the node's CurrentInterface if appropriate.
        //
        if ( !CnpIsNetworkRestricted(network) &&
             CnpIsBetterInterface(Interface, node->CurrentInterface)
           )
        {
            node->CurrentInterface = Interface;

            IF_CNDBG( CN_DEBUG_IFOBJ )
                CNPRINT((
                    "[CNP] Network %u is now the best route to node %u\n",
                    network->Id,
                    node->Id
                    ));
        }
    }
    else {
        status = STATUS_CLUSTER_INVALID_REQUEST;
    }

    CnReleaseLockFromDpc(&(network->Lock));

    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK),   // Required
        0,                        // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX  // Maximum
        );

    return(status);

}  // CnpOnlinePendingInterface



VOID
CnpOnlinePendingInterfaceWrapper(
    PCNP_INTERFACE   Interface
    )
/*++

Routine Description:

    Wrapper for CnpOnlinePendingInterface that conforms to the calling
    convention for PCNP_INTERFACE_UPDATE_ROUTINE.

Arguments:

    Interface - A pointer to the interface to change.

Return Value:

    None.

Notes:

    Called with associated node and network locks held.
    Returns with network lock released.

--*/
{
    (VOID) CnpOnlinePendingInterface(Interface);

    return;

} // CnpOnlinePendingInterfaceWrapper


NTSTATUS
CnpOfflineInterface(
    PCNP_INTERFACE   Interface
    )
/*++

Routine Description:

    Called to change an interface to the Offline state
    when the associated network goes offline or the interface
    is being deleted.

Arguments:

    Interface - A pointer to the interface to change.

Return Value:

    An NT status value.

Notes:

    Called with associated node and network locks held.
    Returns with network lock released.

    Conforms to calling convention for PCNP_INTERFACE_UPDATE_ROUTINE.

--*/
{
    NTSTATUS             status = STATUS_SUCCESS;
    PCNP_NODE            node = Interface->Node;
    PCNP_NETWORK         network = Interface->Network;


    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK | CNP_NETWORK_OBJECT_LOCK),   // Required
        0,                                                  // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX                         // Maximum
        );

    if (Interface->State != ClusnetInterfaceStateOffline) {

        IF_CNDBG( CN_DEBUG_IFOBJ )
            CNPRINT((
                "[CNP] Moving interface (%u, %u) to Offline state.\n",
                node->Id,
                network->Id
                ));

        Interface->State = ClusnetInterfaceStateOffline;

        //
        // Release the network lock.
        //
        CnReleaseLock(&(network->Lock), network->Irql);

        //
        // Update the node's CurrentInterface value if appropriate.
        //
        if (node->CurrentInterface == Interface) {
            CnpUpdateNodeCurrentInterface(node);

            if ( !CnpIsNodeUnreachable(node)
                 &&
                 ( (node->CurrentInterface == NULL) ||
                   ( node->CurrentInterface->State <
                     ClusnetInterfaceStateOnlinePending
                   )
                 )
               )
            {
                //
                // This node is now unreachable.
                //
                CnpDeclareNodeUnreachable(node);
            }
        }
        
        //
        // Change the node's reachability status via this network. 
        //
        CnpMulticastChangeNodeReachability(
            network, 
            node, 
            FALSE,    // not reachable
            TRUE,     // raise event
            NULL      // OUT new mask
            );
        
        //
        // Remove the active reference on the associated network.
        // This releases the network lock.
        //
        CnAcquireLock(&(network->Lock), &(network->Irql));
        CnpActiveDereferenceNetwork(network);
    }
    else {
        CnAssert(network->Irql == DISPATCH_LEVEL);
        CnReleaseLockFromDpc(&(network->Lock));
        status = STATUS_CLUSTER_INVALID_REQUEST;
    }

    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK),   // Required
        0,                        // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX  // Maximum
        );

    return(status);

}  // CnpOfflineInterface



VOID
CnpOfflineInterfaceWrapper(
    PCNP_INTERFACE   Interface
    )
/*++

Routine Description:

    Wrapper for CnpOfflineInterface that conforms to the calling
    convention for PCNP_INTERFACE_UPDATE_ROUTINE.

Arguments:

    Interface - A pointer to the interface to change.

Return Value:

    None.

Notes:

    Called with associated node and network locks held.
    Returns with network lock released.

--*/
{
    (VOID) CnpOfflineInterface(Interface);

    return;

} // CnpOfflineInterfaceWrapper



NTSTATUS
CnpOnlineInterface(
    PCNP_INTERFACE  Interface
    )
/*++

Routine Description:

    Called to change an OnlinePending interface to the Online state
    after a heartbeat has been (re)established.

Arguments:

    Interface - A pointer to the interface to change.

Return Value:

    None.

Notes:

    Called with associated node and network locks held.
    Returns with network lock released.

--*/
{
    NTSTATUS             status = STATUS_SUCCESS;
    PCNP_NODE            node = Interface->Node;
    PCNP_NETWORK         network = Interface->Network;


    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK | CNP_NETWORK_OBJECT_LOCK),   // Required
        0,                                                  // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX                         // Maximum
        );

    if ( (network->State == ClusnetNetworkStateOnline) &&
         ( (Interface->State == ClusnetInterfaceStateOnlinePending) ||
           (Interface->State == ClusnetInterfaceStateUnreachable)
         )
       )
    {
        IF_CNDBG( CN_DEBUG_IFOBJ )
            CNPRINT((
                "[CNP] Moving interface (%u, %u) to Online state.\n",
                node->Id,
                network->Id
                ));

        //
        // Move the interface to the online state.
        //
        Interface->State = ClusnetInterfaceStateOnline;

        CnAssert(network->Irql == DISPATCH_LEVEL);
        CnReleaseLockFromDpc(&(network->Lock));

        //
        // Update the node's CurrentInterface if appropriate.
        //
        if (!CnpIsNetworkRestricted(network)) {
            if (CnpIsBetterInterface(Interface, node->CurrentInterface)) {
                node->CurrentInterface = Interface;

                IF_CNDBG( CN_DEBUG_IFOBJ )
                    CNPRINT((
                        "[CNP] Network %u is now the best route to node %u\n",
                        network->Id,
                        node->Id
                        ));
            }

            if (CnpIsNodeUnreachable(node)) {
                CnpDeclareNodeReachable(node);
            }
        }
    }
    else {
        CnAssert(network->Irql == DISPATCH_LEVEL);
        CnReleaseLockFromDpc(&(network->Lock));
        status = STATUS_CLUSTER_INVALID_REQUEST;
    }

    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK),   // Required
        0,                        // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX  // Maximum
        );

    return(status);

}  // CnpOnlineInterface



NTSTATUS
CnpFailInterface(
    PCNP_INTERFACE   Interface
    )
/*++

Routine Description:

    Called to change an Online or OnlinePending interface to the Failed
    state after the heartbeat has been lost for some time.

Arguments:

    Interface - A pointer to the interface to change.

Return Value:

    None.

Notes:

    Called with associated node and network locks held.
    Returns with network lock released.

--*/
{
    NTSTATUS             status = STATUS_SUCCESS;
    PCNP_NODE            node = Interface->Node;
    PCNP_NETWORK         network = Interface->Network;


    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK | CNP_NETWORK_OBJECT_LOCK),   // Required
        0,                                                  // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX                         // Maximum
        );

    if ( (network->State == ClusnetNetworkStateOnline) &&
         (Interface->State >= ClusnetInterfaceStateOnlinePending)
       )
    {
        IF_CNDBG( CN_DEBUG_IFOBJ )
            CNPRINT((
                "[CNP] Moving interface (%u, %u) to Failed state.\n",
                node->Id,
                network->Id
                ));

        Interface->State = ClusnetInterfaceStateUnreachable;

        CnAssert(network->Irql == DISPATCH_LEVEL);

        //
        // Reference the network so that it can't be deleted
        // while we release the lock.
        //
        CnpReferenceNetwork(network);

        CnReleaseLockFromDpc(&(network->Lock));

        //
        // Update the node's CurrentInterface value if appropriate.
        //
        if (node->CurrentInterface == Interface) {
            CnpUpdateNodeCurrentInterface(node);

            if ( (node->CurrentInterface == NULL)
                 ||
                 ( node->CurrentInterface->State <
                   ClusnetInterfaceStateOnlinePending
                 )
               )
            {
                //
                // This node is now unreachable.
                //
                CnpDeclareNodeUnreachable(node);
            }
        }

        //
        // Change the node's reachability status via this network.
        //
        CnpMulticastChangeNodeReachability(
            network, 
            node, 
            FALSE,      // not reachable
            TRUE,       // raise event
            NULL        // OUT new mask
            );
        
        //
        // Drop the network reference. This releases the network
        // lock.
        //
        CnAcquireLock(&(network->Lock), &(network->Irql));
        CnpDereferenceNetwork(network);
    }
    else {
        CnAssert(network->Irql == DISPATCH_LEVEL);
        CnReleaseLockFromDpc(&(network->Lock));
        status = STATUS_CLUSTER_INVALID_REQUEST;
    }

    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK),   // Required
        0,                        // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX  // Maximum
        );

    return(status);

}  // CnpFailInterface



VOID
CnpDeleteInterface(
    IN PCNP_INTERFACE Interface
    )
/*++

/*++

Routine Description:

    Called to delete an interface.

Arguments:

    Interface - A pointer to the interface to delete.

Return Value:

    None.

Notes:

    Called with node and network object locks held.
    Returns with the network lock released.

    Conforms to calling convention for PCNP_INTERFACE_UPDATE_ROUTINE.

--*/
{
    CL_NODE_ID      nodeId = Interface->Node->Id;
    CL_NETWORK_ID   networkId = Interface->Network->Id;
    PCNP_NODE       node = Interface->Node;
    PCNP_NETWORK    network = Interface->Network;
    BOOLEAN         isLocal = FALSE;


    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK | CNP_NETWORK_OBJECT_LOCK),   // Required
        0,                                                  // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX                         // Maximum
        );

    IF_CNDBG( CN_DEBUG_IFOBJ )
        CNPRINT((
            "[CNP] Deleting interface (%u, %u)\n",
            nodeId,
            networkId
            ));

    if (Interface->State >= ClusnetInterfaceStateUnreachable) {
        (VOID) CnpOfflineInterface(Interface);

        //
        // The call released the network lock.
        // Reacquire it.
        //
        CnAcquireLockAtDpc(&(network->Lock));
        network->Irql = DISPATCH_LEVEL;
    }

    //
    // Remove the interface from the node's interface list.
    //
#if DBG
    {
        PLIST_ENTRY      entry;
        PCNP_INTERFACE   oldInterface = NULL;


        for (entry = node->InterfaceList.Flink;
             entry != &(node->InterfaceList);
             entry = entry->Flink
            )
        {
            oldInterface = CONTAINING_RECORD(
                            entry,
                            CNP_INTERFACE,
                            NodeLinkage
                            );

            if (oldInterface == Interface) {
                break;
            }
        }

        CnAssert(oldInterface == Interface);
    }
#endif // DBG

    RemoveEntryList(&(Interface->NodeLinkage));

    //
    // Remove the base reference that this node had on the network.
    // This releases the network lock.
    //
    CnpDereferenceNetwork(network);

    //
    //  Update the node's CurrentInterface if appropriate.
    //
    if (node->CurrentInterface == Interface) {
        if (IsListEmpty(&(node->InterfaceList))) {
            node->CurrentInterface = NULL;
        }
        else {
            CnpUpdateNodeCurrentInterface(node);
        }
    }

    CnFreePool(Interface);

    IF_CNDBG( CN_DEBUG_IFOBJ )
        CNPRINT((
            "[CNP] Deleted interface (%u, %u)\n",
            nodeId,
            networkId
            ));

    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK),   // Required
        0,                        // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX  // Maximum
        );

    return;

}  // CnpDeleteInterface



VOID
CnpReevaluateInterfaceRole(
    IN PCNP_INTERFACE  Interface
    )
/*++

Routine Description:

    Reevaluates the role of an interface after the corresponding network's
    restriction state has been changed.

Arguments:

    Interface - A pointer to the interface on which to operate.

Return Value:

    None.

Notes:

    Called with associated node and network locks held.
    Returns with network lock released.

    Conforms to calling convention for PCNP_INTERFACE_UPDATE_ROUTINE.

--*/
{
    PCNP_NODE      node = Interface->Node;
    PCNP_NETWORK   network = Interface->Network;
    BOOLEAN        restricted = CnpIsNetworkRestricted(network);


    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK | CNP_NETWORK_OBJECT_LOCK),   // Required
        0,                                                  // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX                         // Maximum
        );

    //
    // We don't really need the network lock.  It's just part of
    // the calling convention.
    //
    CnReleaseLockFromDpc(&(network->Lock));

    if (restricted) {
        if (node->CurrentInterface == Interface) {
            CnpUpdateNodeCurrentInterface(node);
        }
    }
    else if (node->CurrentInterface != Interface) {
        CnpUpdateNodeCurrentInterface(node);
    }

    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK),   // Required
        0,                        // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX  // Maximum
        );

    return;

}  // CnpReevaluateInterfaceRole



VOID
CnpRecalculateInterfacePriority(
    IN PCNP_INTERFACE  Interface
    )
/*++

Routine Description:

    Recalculates the priority of interfaces which get their
    priority from their associated network. Called after the network's
    priority changes.

Arguments:

    Interface - A pointer to the interface on which to operate.

Return Value:

    None.

Notes:

    Called with associated node and network locks held.
    Returns with network lock released.

    Conforms to calling convention for PCNP_INTERFACE_UPDATE_ROUTINE.

--*/
{
    PCNP_NODE      node = Interface->Node;
    PCNP_NETWORK   network = Interface->Network;
    ULONG          networkPriority = network->Priority;
    ULONG          oldPriority = Interface->Priority;
    BOOLEAN        restricted = CnpIsNetworkRestricted(network);


    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK | CNP_NETWORK_OBJECT_LOCK),   // Required
        0,                                                  // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX                         // Maximum
        );

    //
    // We don't really need the network lock.  It's just part of
    // the calling convention.
    //
    CnReleaseLockFromDpc(&(network->Lock));

    if (CnpIsInterfaceUsingNetworkPriority(Interface)) {
        Interface->Priority = networkPriority;

        if (!restricted) {
            if (Interface == node->CurrentInterface) {
                if (CnpIsLowerPriority(Interface->Priority, oldPriority)) {
                    //
                    // Our priority got worse. Recalculate the best route.
                    //
                    CnpUpdateNodeCurrentInterface(node);
                }
                //
                // Else, priority same or better. Nothing to do.
                //
            }
            else if ( CnpIsBetterInterface(
                          Interface,
                          node->CurrentInterface
                          )
                    )
            {
                //
                // Our priority got better.
                //
                IF_CNDBG(( CN_DEBUG_NODEOBJ | CN_DEBUG_NETOBJ ))
                    CNPRINT((
                        "[CNP] Network %u is now the best route to node %u\n",
                        network->Id,
                        node->Id
                        ));

                node->CurrentInterface = Interface;
            }
        }
    }

    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK),   // Required
        0,                        // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX  // Maximum
        );

    return;

}  // CnpRecalculateInterfacePriority



VOID
CnpUpdateNodeCurrentInterface(
    IN PCNP_NODE  Node
    )
/*++

Routine Description:

    Called to determine the best available interface for a node
    after one of its interfaces changes state or priority.

Arguments:

    Node  - A pointer to the node on which to operate.

Return Value:

    None.

Notes:

    Called with node object lock held.

--*/
{
    PLIST_ENTRY      entry;
    PCNP_INTERFACE   interface;
    PCNP_INTERFACE   bestInterface = NULL;


    CnVerifyCpuLockMask(
        CNP_NODE_OBJECT_LOCK,     // Required
        0,                        // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX  // Maximum
        );

    CnAssert(!IsListEmpty(&(Node->InterfaceList)));
    // CnAssert(Node->CurrentInterface != NULL);

    for (entry = Node->InterfaceList.Flink;
         entry != &(Node->InterfaceList);
         entry = entry->Flink
        )
    {
        interface = CONTAINING_RECORD(entry, CNP_INTERFACE, NodeLinkage);

        if ( !CnpIsNetworkRestricted(interface->Network) &&
             !CnpIsNetworkLocalDisconn(interface->Network) &&
             CnpIsBetterInterface(interface, bestInterface)
           )
        {
            bestInterface = interface;
        }
    }

    Node->CurrentInterface = bestInterface;

    IF_CNDBG(( CN_DEBUG_NODEOBJ | CN_DEBUG_NETOBJ )) {
        if (bestInterface == NULL) {
            CNPRINT((
                "[CNP] No route for node %u!!!!\n",
                Node->Id
                ));
        }
        else {
            CNPRINT((
                "[CNP] Best route for node %u is now network %u.\n",
                Node->Id,
                bestInterface->Network->Id
                ));
        }
    }

    CnVerifyCpuLockMask(
        CNP_NODE_OBJECT_LOCK,     // Required
        0,                        // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX  // Maximum
        );

    return;

}  // CnpUpdateNodeCurrentInterface



VOID
CnpResetAndOnlinePendingInterface(
    IN PCNP_INTERFACE  Interface
    )
/*++

Routine Description:

    Resets the sequence numbers used to authenticate packets
    sent by a node over a particular network. Also takes the
    node's interface online.

    This operation is performed when a node is joining a cluster.

Arguments:

    Interface - A pointer to the interface on which to operate.

Return Value:

    None.

Notes:

    Called with associated node and network locks held.
    Returns with network lock released.

    Conforms to calling convention for PCNP_INTERFACE_UPDATE_ROUTINE.

--*/
{
    PCNP_NODE          node = Interface->Node;
    PCNP_NETWORK       network = Interface->Network;


    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK | CNP_NETWORK_OBJECT_LOCK),   // Required
        0,                                                  // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX                         // Maximum
        );

    IF_CNDBG(( CN_DEBUG_NODEOBJ | CN_DEBUG_NETOBJ ))
        CNPRINT((
            "[CNP] Reseting sequence numbers for node %u on network %u\n",
            node->Id,
            network->Id
            ));

    Interface->SequenceToSend = 0;
    Interface->LastSequenceReceived = 0;

    //
    // Take the interface online.
    //
    (VOID) CnpOnlinePendingInterface(Interface);

    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK),   // Required
        0,                        // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX  // Maximum
        );

    return;

}  // CnpRecalculateInterfacePriority



NTSTATUS
CnpFindInterface(
    IN  CL_NODE_ID         NodeId,
    IN  CL_NETWORK_ID      NetworkId,
    OUT PCNP_INTERFACE *   Interface
    )
{
    NTSTATUS           status;
    PCNP_INTERFACE     interface;
    PCNP_NODE          node;
    PCNP_NETWORK       network;
    PLIST_ENTRY        entry;


    CnVerifyCpuLockMask(
        0,                          // Required
        0,                          // Forbidden
        CNP_PRECEEDING_LOCK_RANGE   // Maximum
        );

    status = CnpValidateAndFindNode(NodeId, &node);

    if (status ==  STATUS_SUCCESS) {

        network = CnpFindNetwork(NetworkId);

        if (network != NULL) {

            for (entry = node->InterfaceList.Flink;
                 entry != &(node->InterfaceList);
                 entry = entry->Flink
                )
            {
                interface = CONTAINING_RECORD(
                                entry,
                                CNP_INTERFACE,
                                NodeLinkage
                                );

                if (interface->Network == network) {
                    *Interface = interface;

                    CnVerifyCpuLockMask(
                        (CNP_NODE_OBJECT_LOCK | CNP_NETWORK_OBJECT_LOCK),
                        0,                            // Forbidden
                        CNP_NETWORK_OBJECT_LOCK_MAX   // Maximum
                        );

                    return(STATUS_SUCCESS);
                }
            }

            CnReleaseLock(&(network->Lock), network->Irql);
        }

        CnReleaseLock(&(node->Lock), node->Irql);
    }

    CnVerifyCpuLockMask(
        0,                          // Required
        0,                          // Forbidden
        CNP_PRECEEDING_LOCK_RANGE   // Maximum
        );

    return(STATUS_CLUSTER_NETINTERFACE_NOT_FOUND);

}  // CnpFindInterface



//
// Cluster Transport Public Routines
//
NTSTATUS
CxRegisterInterface(
    CL_NODE_ID          NodeId,
    CL_NETWORK_ID       NetworkId,
    ULONG               Priority,
    PUWSTR              AdapterId,
    ULONG               AdapterIdLength,
    ULONG               TdiAddressLength,
    PTRANSPORT_ADDRESS  TdiAddress,
    PULONG              MediaStatus
    )
{
    NTSTATUS           status;
    PLIST_ENTRY        entry;
    PCNP_INTERFACE     interface;
    PCNP_NODE          node;
    PCNP_NETWORK       network;
    ULONG              allocSize;
    PWCHAR             adapterDevNameBuffer = NULL;
    HANDLE             adapterDevHandle = NULL;
    BOOLEAN            localAdapter = FALSE;

    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    //
    // Allocate and initialize an interface object.
    //
    allocSize = FIELD_OFFSET(CNP_INTERFACE, TdiAddress) + TdiAddressLength;

    interface = CnAllocatePool(allocSize);

    if (interface == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlZeroMemory(interface, allocSize);

    CN_INIT_SIGNATURE(interface, CNP_INTERFACE_SIG);
    interface->State = ClusnetInterfaceStateOffline;

    RtlMoveMemory(&(interface->TdiAddress), TdiAddress, TdiAddressLength);
    interface->TdiAddressLength = TdiAddressLength;

    //
    // Register the new interface object
    //
    status = CnpValidateAndFindNode(NodeId, &node);

    if (NT_SUCCESS(status)) {

        //
        // If this adapter is on the local node, use the adapter ID
        // to find the corresponding WMI Provider ID.
        //
        localAdapter = (BOOLEAN)(node == CnpLocalNode);
        if (localAdapter) {

            PWCHAR             adapterDevNamep, brace;
            PFILE_OBJECT       adapterFileObject;
            PDEVICE_OBJECT     adapterDeviceObject;
            
            // first drop the node lock
            CnReleaseLock(&(node->Lock), node->Irql);

            // allocate a buffer for the adapter device name
            allocSize = wcslen(L"\\Device\\") * sizeof(WCHAR)
                        + AdapterIdLength
                        + sizeof(UNICODE_NULL);
            brace = L"{";
            if (*((PWCHAR)AdapterId) != *brace) {
                allocSize += 2 * sizeof(WCHAR);
            }
            adapterDevNameBuffer = CnAllocatePool(allocSize);
            if (adapterDevNameBuffer == NULL) {
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto error_exit;
            }

            // build the adapter device name from the adapter ID
            RtlZeroMemory(adapterDevNameBuffer, allocSize);

            adapterDevNamep = adapterDevNameBuffer;

            RtlCopyMemory(
                adapterDevNamep,
                L"\\Device\\",
                wcslen(L"\\Device\\") * sizeof(WCHAR)
                );

            adapterDevNamep += wcslen(L"\\Device\\");

            if (*((PWCHAR)AdapterId) != *brace) {
                *adapterDevNamep = *brace;
                adapterDevNamep++;
            }

            RtlCopyMemory(adapterDevNamep, AdapterId, AdapterIdLength);

            if (*((PWCHAR)AdapterId) != *brace) {
                brace = L"}";
                adapterDevNamep = 
                    (PWCHAR)((PUCHAR)adapterDevNamep + AdapterIdLength);
                *adapterDevNamep = *brace;
            }

            // open the adapter device
            status = CnpOpenDevice(
                         adapterDevNameBuffer, 
                         &adapterDevHandle
                         );
            if (!NT_SUCCESS(status)) {
                IF_CNDBG( CN_DEBUG_IFOBJ )
                    CNPRINT((
                             "[CNP] Failed to open adapter "
                             "device %S while registering "
                             "interface (%u, %u), status %lx.\n",
                             adapterDevNameBuffer,
                             NodeId,
                             NetworkId,
                             status
                             ));
                goto error_exit;
            }

            status = ObReferenceObjectByHandle(
                         adapterDevHandle,
                         0L,  // DesiredAccess
                         NULL,
                         KernelMode,
                         &adapterFileObject,
                         NULL
                         );
            if (!NT_SUCCESS(status)) {
                IF_CNDBG( CN_DEBUG_IFOBJ )
                    CNPRINT((
                             "[CNP] Failed to reference handle "
                             "for adapter device %S while "
                             "registering interface (%u, %u), "
                             "status %lx.\n",
                             adapterDevNameBuffer,
                             NodeId,
                             NetworkId,
                             status
                             ));
                ZwClose(adapterDevHandle);
                adapterDevHandle = NULL;
                goto error_exit;
            }

            adapterDeviceObject = IoGetRelatedDeviceObject(
                                      adapterFileObject
                                      );

            // convert the adapter device object into the
            // WMI provider ID
            interface->AdapterWMIProviderId = 
                IoWMIDeviceObjectToProviderId(adapterDeviceObject);

            IF_CNDBG( CN_DEBUG_IFOBJ )
                CNPRINT((
                         "[CNP] Found WMI Provider ID %lx for adapter "
                         "device %S while "
                         "registering interface (%u, %u).\n",
                         interface->AdapterWMIProviderId,
                         adapterDevNameBuffer,
                         NodeId,
                         NetworkId
                         ));

            // we no longer need the file object or device name 
            // buffer, but we hold onto the adapter device handle
            // in order to query the current media status.
            ObDereferenceObject(adapterFileObject);
            CnFreePool(adapterDevNameBuffer);
            adapterDevNameBuffer = NULL;

            // reacquire the local node lock
            status = CnpValidateAndFindNode(NodeId, &node);

            if (!NT_SUCCESS(status)) {
                status = STATUS_CLUSTER_NODE_NOT_FOUND;
                goto error_exit;
            }
        }

        network = CnpFindNetwork(NetworkId);

        if (network != NULL) {
            //
            // Check if the specified interface already exists.
            //
            status = STATUS_SUCCESS;

            for (entry = node->InterfaceList.Flink;
                 entry != &(node->InterfaceList);
                 entry = entry->Flink
                )
            {
                PCNP_INTERFACE  oldInterface = CONTAINING_RECORD(
                                                   entry,
                                                   CNP_INTERFACE,
                                                   NodeLinkage
                                                   );

                if (oldInterface->Network == network) {
                    status = STATUS_CLUSTER_NETINTERFACE_EXISTS;
                    break;
                }
            }

            if (NT_SUCCESS(status)) {

                interface->Node = node;
                interface->Network = network;

                if (Priority != 0) {
                    interface->Priority = Priority;
                }
                else {
                    interface->Priority = network->Priority;
                    interface->Flags |= CNP_IF_FLAG_USE_NETWORK_PRIORITY;
                }

                IF_CNDBG( CN_DEBUG_IFOBJ )
                    CNPRINT((
                             "[CNP] Registering interface (%u, %u) pri %u...\n",
                             NodeId,
                             NetworkId,
                             interface->Priority
                             ));

                //
                // Place a reference on the network for this interface.
                //
                CnpReferenceNetwork(network);

                //
                // Insert the interface into the node's interface list.
                //
                InsertTailList(
                    &(node->InterfaceList),
                    &(interface->NodeLinkage)
                    );

                //
                // Update the node's CurrentInterface if appropriate.
                //
                if ( !CnpIsNetworkRestricted(network)
                     &&
                     CnpIsBetterInterface(interface, node->CurrentInterface)
                   )
                {
                    IF_CNDBG( CN_DEBUG_IFOBJ )
                        CNPRINT((
                            "[CNP] Network %u is now the best route to node %u.\n",
                            network->Id,
                            node->Id
                            ));

                    node->CurrentInterface = interface;
                }

                IF_CNDBG( CN_DEBUG_IFOBJ )
                    CNPRINT((
                        "[CNP] Registered interface (%u, %u).\n",
                        NodeId,
                        NetworkId
                        ));

                if (network->State == ClusnetNetworkStateOnline) {
                    (VOID) CnpOnlinePendingInterface(interface);

                    //
                    // The network lock was released.
                    //
                }
                else {
                    CnReleaseLockFromDpc(&(network->Lock));
                }

                CnReleaseLock(&(node->Lock), node->Irql);

                //
                // Determine the initial media status state of this
                // interface if it is local.
                //
                if (localAdapter) {
                    CxQueryMediaStatus(
                        adapterDevHandle,
                        NetworkId,
                        MediaStatus
                        );
                } else {
                    //
                    // Assume remote interfaces are connected
                    //
                    *MediaStatus = NdisMediaStateConnected;
                }

                if (adapterDevHandle != NULL) {
                    ZwClose(adapterDevHandle);
                    adapterDevHandle = NULL;
                }

                return(STATUS_SUCCESS);
            }

            CnReleaseLockFromDpc(&(network->Lock));
        }
        else {
            status = STATUS_CLUSTER_NETWORK_NOT_FOUND;
        }

        CnReleaseLock(&(node->Lock), node->Irql);
    }
    else {
        status = STATUS_CLUSTER_NODE_NOT_FOUND;
    }

error_exit:

    if (!NT_SUCCESS(status)) {
        CnFreePool(interface);
    }

    if (adapterDevHandle != NULL) {
        ZwClose(adapterDevHandle);
        adapterDevHandle = NULL;
    }

    if (adapterDevNameBuffer != NULL) {
        CnFreePool(adapterDevNameBuffer);
        adapterDevNameBuffer = NULL;
    }

    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    return(status);

} // CxRegisterInterface



NTSTATUS
CxDeregisterInterface(
    CL_NODE_ID          NodeId,
    CL_NETWORK_ID       NetworkId
    )
{
    NTSTATUS           status;
    PCNP_INTERFACE     interface;
    ULONG              i;
    PCNP_NODE          node;
    PCNP_NETWORK       network;
    CN_IRQL            tableIrql;


    if ((NodeId == ClusterAnyNodeId) && (NetworkId == ClusterAnyNetworkId)) {
        //
        // Destroy all interfaces on all networks.
        //
        IF_CNDBG(( CN_DEBUG_IFOBJ | CN_DEBUG_CLEANUP ))
            CNPRINT(("[CNP] Destroying all interfaces on all networks\n"));

        CnAcquireLock(&CnpNodeTableLock, &tableIrql);

        CnAssert(CnMinValidNodeId != ClusterInvalidNodeId);
        CnAssert(CnMaxValidNodeId != ClusterInvalidNodeId);

        for (i=CnMinValidNodeId; i <= CnMaxValidNodeId; i++) {
            node = CnpNodeTable[i];

            if (node != NULL) {
                CnAcquireLockAtDpc(&(node->Lock));
                CnReleaseLockFromDpc(&CnpNodeTableLock);
                node->Irql = tableIrql;

                CnpWalkInterfacesOnNode(node, CnpDeleteInterface);

                CnReleaseLock(&(node->Lock), node->Irql);
                CnAcquireLock(&CnpNodeTableLock, &tableIrql);
            }
        }

        CnReleaseLock(&CnpNodeTableLock, tableIrql);

        status = STATUS_SUCCESS;
    }
    else if (NodeId == ClusterAnyNodeId) {
        //
        // Destroy all interfaces on a specific network.
        //
        IF_CNDBG(( CN_DEBUG_IFOBJ | CN_DEBUG_NETOBJ | CN_DEBUG_CLEANUP ))
            CNPRINT((
                     "[CNP] Destroying all interfaces on network %u\n",
                     NetworkId
                     ));

        network = CnpFindNetwork(NetworkId);

        if (network != NULL) {
            CnpReferenceNetwork(network);
            CnReleaseLock(&(network->Lock), network->Irql);

            CnpWalkInterfacesOnNetwork(network, CnpDeleteInterface);

            CnAcquireLock(&(network->Lock), &(network->Irql));
            CnpDereferenceNetwork(network);

            status = STATUS_SUCCESS;
        }
        else {
            status = STATUS_CLUSTER_NETWORK_NOT_FOUND;
        }
    }
    else if (NetworkId == ClusterAnyNetworkId) {
        //
        // Destroy all interfaces on a specified node.
        //
        IF_CNDBG(( CN_DEBUG_IFOBJ | CN_DEBUG_NODEOBJ | CN_DEBUG_CLEANUP ))
            CNPRINT((
                     "[CNP] Destroying all interfaces on node %u\n",
                     NodeId
                     ));

        status = CnpValidateAndFindNode(NodeId, &node);

        if (status == STATUS_SUCCESS) {
            CnpWalkInterfacesOnNode(node, CnpDeleteInterface);
            CnReleaseLock(&(node->Lock), node->Irql);
        }
    }
    else {
        //
        // Delete a specific interface
        //
        status = CnpFindInterface(NodeId, NetworkId, &interface);

        if (NT_SUCCESS(status)) {
            node = interface->Node;

            CnpDeleteInterface(interface);
            //
            // The network lock was released.
            //

            CnReleaseLock(&(node->Lock), node->Irql);
        }
    }

    return(status);

}  // CxDeregisterNetwork



NTSTATUS
CxSetInterfacePriority(
    IN CL_NODE_ID          NodeId,
    IN CL_NETWORK_ID       NetworkId,
    IN ULONG               Priority
    )
{
    NTSTATUS           status;
    PCNP_INTERFACE     interface;
    PCNP_NODE          node;
    PCNP_NETWORK       network;
    ULONG              oldPriority;
    BOOLEAN            restricted;


    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    status = CnpFindInterface(NodeId, NetworkId, &interface);

    if (status ==  STATUS_SUCCESS) {
        node = interface->Node;
        network = interface->Network;

        oldPriority = interface->Priority;
        restricted = CnpIsNetworkRestricted(network);

        if (Priority != 0) {
            interface->Priority = Priority;
            interface->Flags &= ~(CNP_IF_FLAG_USE_NETWORK_PRIORITY);
        }
        else {
            interface->Priority = network->Priority;
            interface->Flags |= CNP_IF_FLAG_USE_NETWORK_PRIORITY;
        }

        IF_CNDBG( CN_DEBUG_IFOBJ )
            CNPRINT((
                "[CNP] Set interface (%u, %u) to priority %u\n",
                NodeId,
                NetworkId,
                interface->Priority
                ));

        CnReleaseLockFromDpc(&(network->Lock));

        if (!restricted) {
            if (interface == node->CurrentInterface) {
                if (interface->Priority > oldPriority) {
                    //
                    // Our priority got worse. Recalculate the best route.
                    //
                    CnpUpdateNodeCurrentInterface(node);
                }
                //
                // Else interface priority is same or better. Nothing to do.
                //
            }
            else if ( CnpIsBetterInterface(
                          interface,
                          node->CurrentInterface
                          )
                    )
            {
                //
                // Our priority got better.
                //
                IF_CNDBG(( CN_DEBUG_NODEOBJ | CN_DEBUG_NETOBJ ))
                    CNPRINT((
                        "[CNP] Network %u is now the best route to node %u\n",
                        network->Id,
                        node->Id
                        ));

                node->CurrentInterface = interface;
            }
        }

        CnReleaseLock(&(node->Lock), node->Irql);
    }

    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    return(status);

}  // CxSetInterfacePriority



NTSTATUS
CxGetInterfacePriority(
    IN  CL_NODE_ID          NodeId,
    IN  CL_NETWORK_ID       NetworkId,
    OUT PULONG              InterfacePriority,
    OUT PULONG              NetworkPriority
    )
{
    NTSTATUS           status;
    PCNP_INTERFACE     interface;
    PCNP_NODE          node;
    PCNP_NETWORK       network;


    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    status = CnpFindInterface(NodeId, NetworkId, &interface);

    if (status ==  STATUS_SUCCESS) {
        node = interface->Node;
        network = interface->Network;

        *NetworkPriority = network->Priority;

        if (CnpIsInterfaceUsingNetworkPriority(interface)) {
            *InterfacePriority = 0;
        }
        else {
            *InterfacePriority = interface->Priority;
        }

        CnReleaseLockFromDpc(&(network->Lock));

        CnReleaseLock(&(node->Lock), node->Irql);
    }

    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    return(status);

}  // CxGetInterfacePriority



NTSTATUS
CxGetInterfaceState(
    IN  CL_NODE_ID                NodeId,
    IN  CL_NETWORK_ID             NetworkId,
    OUT PCLUSNET_INTERFACE_STATE  State
    )
{
    NTSTATUS       status;
    PCNP_INTERFACE interface;
    PCNP_NODE      node;
    PCNP_NETWORK   network;

    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    status = CnpFindInterface(NodeId, NetworkId, &interface);

    if (status == STATUS_SUCCESS) {
        node = interface->Node;
        network = interface->Network;

        *State = interface->State;

        CnAssert(network->Irql == DISPATCH_LEVEL);
        CnReleaseLockFromDpc(&(network->Lock));
        CnReleaseLock(&(node->Lock), node->Irql);
    }

    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    return(status);

}  // CxGetInterfaceState



//
// Test APIs
//
#if DBG


NTSTATUS
CxOnlinePendingInterface(
    IN  CL_NODE_ID          NodeId,
    IN  CL_NETWORK_ID       NetworkId
    )
{
    NTSTATUS           status;
    PCNP_INTERFACE     interface;
    PCNP_NODE          node;
    PCNP_NETWORK       network;


    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    status = CnpFindInterface(NodeId, NetworkId, &interface);

    if (status ==  STATUS_SUCCESS) {
        node = interface->Node;
        network = interface->Network;

        status = CnpOnlinePendingInterface(interface);

        //
        // The network lock was released
        //

        CnReleaseLock(&(node->Lock), node->Irql);
    }

    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    return(status);

}  // CxOnlinePendingInterface



NTSTATUS
CxOnlineInterface(
    IN  CL_NODE_ID          NodeId,
    IN  CL_NETWORK_ID       NetworkId
    )
{
    NTSTATUS           status;
    PCNP_INTERFACE     interface;
    PCNP_NODE          node;


    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    status = CnpFindInterface(NodeId, NetworkId, &interface);

    if (status ==  STATUS_SUCCESS) {
        node = interface->Node;

        status = CnpOnlineInterface(interface);

        //
        // The network lock was released
        //

        CnReleaseLock(&(node->Lock), node->Irql);
    }

    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    return(status);

}  // CxOnlineInterface



NTSTATUS
CxOfflineInterface(
    IN  CL_NODE_ID          NodeId,
    IN  CL_NETWORK_ID       NetworkId
    )
{
    NTSTATUS           status;
    PCNP_INTERFACE     interface;
    PCNP_NODE          node;


    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    status = CnpFindInterface(NodeId, NetworkId, &interface);

    if (status ==  STATUS_SUCCESS) {
        node = interface->Node;

        status = CnpOfflineInterface(interface);

        //
        // The network lock was released
        //

        CnReleaseLock(&(node->Lock), node->Irql);
    }

    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    return(status);

}  // CxOfflineInterface


NTSTATUS
CxFailInterface(
    IN  CL_NODE_ID          NodeId,
    IN  CL_NETWORK_ID       NetworkId
    )
{
    NTSTATUS           status;
    PCNP_INTERFACE     interface;
    PCNP_NODE          node;


    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    status = CnpFindInterface(NodeId, NetworkId, &interface);

    if (status ==  STATUS_SUCCESS) {
        node = interface->Node;

        status = CnpFailInterface(interface);

        //
        // The network lock was released
        //

        CnReleaseLock(&(node->Lock), node->Irql);
    }

    CnVerifyCpuLockMask(
        0,                          // Required
        0xFFFFFFFF,                 // Forbidden
        0                           // Maximum
        );

    return(status);

}  // CxOfflineInterface



#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\xport\cnprecv.c ===
/*++                                                    

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cnprecv.c

Abstract:

    Cluster Network Protocol receive processing code.

Author:

    Mike Massa (mikemas)           January 24, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-24-97    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "cnprecv.tmh"

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, CnpCreateSendRequestPool)

#endif // ALLOC_PRAGMA

//
// Local types
//
typedef struct {
    ULONG        TdiReceiveDatagramFlags;
    ULONG        TsduSize;
    PCNP_NETWORK Network;
    ULONG        CnpReceiveFlags;
} CNP_RECEIVE_CONTEXT, *PCNP_RECEIVE_CONTEXT;


//
// Local Data
//
PCN_RESOURCE_POOL  CnpReceiveRequestPool = NULL;

#define CNP_RECEIVE_REQUEST_POOL_DEPTH 2

//
// Routines exported within the Cluster Transport
//
NTSTATUS
CnpLoad(
    VOID
    )
{
    IF_CNDBG(CN_DEBUG_INIT){
        CNPRINT(("[CNP] Loading...\n"));
    }

    CnpReceiveRequestPool = CnpCreateReceiveRequestPool(
                                sizeof(CNP_RECEIVE_CONTEXT),
                                CNP_RECEIVE_REQUEST_POOL_DEPTH
                                );

    if (CnpReceiveRequestPool == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    IF_CNDBG(CN_DEBUG_INIT){
        CNPRINT(("[CNP] Loading complete.\n"));
    }

    return(STATUS_SUCCESS);

}  // CnpInitializeReceive

VOID
CnpUnload(
    VOID
    )
{
    IF_CNDBG(CN_DEBUG_INIT){
        CNPRINT(("[CNP] Unloading...\n"));
    }

    if (CnpReceiveRequestPool != NULL) {
        CnpDeleteReceiveRequestPool(CnpReceiveRequestPool);
        CnpReceiveRequestPool = NULL;
    }

    IF_CNDBG(CN_DEBUG_INIT){
        CNPRINT(("[CNP] Unloading complete.\n"));
    }

    return;

}  // CnpCleanupReceive

//
// Private Utility Fumctions
//
PCN_RESOURCE
CnpCreateReceiveRequest(
    IN PVOID   Context
    )
{
    PCNP_RECEIVE_REQUEST_POOL_CONTEXT   context = Context;
    PCNP_RECEIVE_REQUEST                request;
    PIRP                                irp;


    //
    // Allocate a new receive request. Include space for the upper protocol
    // context.
    //
    request = CnAllocatePool(
                  sizeof(CNP_RECEIVE_REQUEST) +
                      context->UpperProtocolContextSize
                  );

    if (request != NULL) {
        request->UpperProtocolContext = request + 1;
    }

    return(&(request->CnResource));

}  // CnpCreateReceiveRequest


VOID
CnpDeleteReceiveRequest(
    PCN_RESOURCE  Resource
    )
{
    PCNP_RECEIVE_REQUEST  request = CONTAINING_RECORD(
                                        Resource,
                                        CNP_RECEIVE_REQUEST,
                                        CnResource
                                        );

    CnFreePool(request);

    return;

} // CnpDeleteReceiveRequest


//
// Routines Exported within the Cluster Transport
//
PCN_RESOURCE_POOL
CnpCreateReceiveRequestPool(
    IN ULONG  UpperProtocolContextSize,
    IN USHORT PoolDepth
    )
{
    PCN_RESOURCE_POOL                   pool;
    PCNP_RECEIVE_REQUEST_POOL_CONTEXT   context;


    PAGED_CODE();

    pool = CnAllocatePool(
               sizeof(CN_RESOURCE_POOL) +
                   sizeof(CNP_RECEIVE_REQUEST_POOL_CONTEXT)
               );

    if (pool != NULL) {
        context = (PCNP_RECEIVE_REQUEST_POOL_CONTEXT) (pool + 1);

        context->UpperProtocolContextSize = UpperProtocolContextSize;

        CnInitializeResourcePool(
                   pool,
                   PoolDepth,
                   CnpCreateReceiveRequest,
                   context,
                   CnpDeleteReceiveRequest
                   );
    }

    return(pool);

}  // CnpCreateReceiveRequestPool


PCNP_RECEIVE_REQUEST
CnpAllocateReceiveRequest(
    IN PCN_RESOURCE_POOL  RequestPool,
    IN PVOID              Network,
    IN ULONG              BytesToReceive,
    IN PVOID              CompletionRoutine
    )
{
    PCNP_NETWORK          network = Network;
    PCNP_RECEIVE_REQUEST  request = (PCNP_RECEIVE_REQUEST)
                                    CnAllocateResource(RequestPool);

    if (request != NULL) {

        //
        // Allocate a buffer to hold the data.
        //
        request->DataBuffer = CnAllocatePool(BytesToReceive);

        if (request->DataBuffer != NULL) {
            request->Irp = IoAllocateIrp(
                               network->DatagramDeviceObject->StackSize,
                               FALSE
                               );

            if (request->Irp != NULL) {
                PMDL  mdl = IoAllocateMdl(
                                request->DataBuffer,
                                BytesToReceive,
                                FALSE,
                                FALSE,
                                NULL
                                );

                if (mdl != NULL) {
                    PIRP  irp = request->Irp;

                    MmBuildMdlForNonPagedPool(mdl);

                    //
                    // Build the irp.
                    //
                    irp->Flags = 0;
                    irp->RequestorMode = KernelMode;
                    irp->PendingReturned = FALSE;
                    irp->UserIosb = NULL;
                    irp->UserEvent = NULL;
                    irp->Overlay.AsynchronousParameters.UserApcRoutine =
                        NULL;
                    irp->AssociatedIrp.SystemBuffer = NULL;
                    irp->UserBuffer = NULL;
                    irp->Tail.Overlay.Thread = 0;
                    irp->Tail.Overlay.OriginalFileObject =
                        network->DatagramFileObject;
                    irp->Tail.Overlay.AuxiliaryBuffer = NULL;

                    TdiBuildReceiveDatagram(
                        irp,
                        network->DatagramDeviceObject,
                        network->DatagramFileObject,
                        CompletionRoutine,
                        request,
                        mdl,
                        BytesToReceive,
                        NULL,
                        NULL,
                        0
                        );

                    //
                    // Make the next stack location current.
                    // Normally IoCallDriver would do this, but
                    // since we're bypassing that, we do it directly.
                    //
                    IoSetNextIrpStackLocation( irp );

                    return(request);
                }

                IoFreeIrp(request->Irp);
                request->Irp = NULL;
            }

            CnFreePool(request->DataBuffer);
            request->DataBuffer = NULL;
        }

        CnFreeResource((PCN_RESOURCE) request);
    }

    return(NULL);

}  // CnpAllocateReceiveRequest


VOID
CnpFreeReceiveRequest(
    PCNP_RECEIVE_REQUEST  Request
    )
{
    IoFreeMdl(Request->Irp->MdlAddress);
    Request->Irp->MdlAddress = NULL;

    IoFreeIrp(Request->Irp);
    Request->Irp = NULL;

    CnFreePool(Request->DataBuffer);
    Request->DataBuffer = NULL;

    CnFreeResource((PCN_RESOURCE) Request);

    return;

}  // CnpFreeReceiveRequest


NTSTATUS
CnpIndicateData(
    IN  PCNP_NETWORK   Network,
    IN  UCHAR          NextHeader,
    IN  CL_NODE_ID     SourceNodeId,
    IN  ULONG          CnpReceiveFlags,
    IN  ULONG          TdiReceiveDatagramFlags,
    IN  ULONG          BytesIndicated,
    IN  ULONG          BytesAvailable,
    OUT PULONG         BytesTaken,
    IN  PVOID          Tsdu,
    OUT PIRP *         Irp
    )
/*++

Routine Description:

    Indicate data to the next highest protocol.
    
--*/
{
    NTSTATUS status;

    if (NextHeader == PROTOCOL_CDP) {

        CnTrace(CNP_RECV_DETAIL, CnpTraceIndicateDataPacket,
            "[CNP] Indicating data packet from node %u net %u, "
            "BI %u, BA %u, CNP Flags %x.",
            SourceNodeId, // LOGULONG
            Network->Id, // LOGULONG
            BytesIndicated, // LOGULONG
            BytesAvailable, // LOGULONG
            CnpReceiveFlags // LOGXLONG
            );        

        status = CdpReceivePacketHandler(
                     Network,
                     SourceNodeId,
                     CnpReceiveFlags,
                     TdiReceiveDatagramFlags,
                     BytesIndicated,
                     BytesAvailable,
                     BytesTaken,
                     Tsdu,
                     Irp
                     );
    }
    else if (NextHeader == PROTOCOL_CCMP) {

        CnTrace(CNP_RECV_DETAIL, CnpTraceIndicateControlPacket,
            "[CNP] Indicating control packet from node %u net %u, "
            "BI %u, BA %u, CNP Flags %x.",
            SourceNodeId, // LOGULONG
            Network->Id, // LOGULONG
            BytesIndicated, // LOGULONG
            BytesAvailable, // LOGULONG
            CnpReceiveFlags // LOGXLONG
            );        

        status = CcmpReceivePacketHandler(
                     Network,
                     SourceNodeId,
                     CnpReceiveFlags,
                     TdiReceiveDatagramFlags,
                     BytesIndicated,
                     BytesAvailable,
                     BytesTaken,
                     Tsdu,
                     Irp
                     );
    }
    else {
        IF_CNDBG(CN_DEBUG_CNPRECV) {
            CNPRINT((
                "[CNP] Received packet for unknown protocol %u\n",
                NextHeader
                ));
        }
        CnTrace(CNP_RECV_DETAIL, CnpTraceRecvUnknownProtocol,
            "[CNP] Received packet for unknown protocol (%u) "
            " from node %u net %u, BI %u, BA %u, CNP Flags %x.",
            NextHeader,
            SourceNodeId, // LOGULONG
            Network->Id, // LOGULONG
            BytesIndicated, // LOGULONG
            BytesAvailable, // LOGULONG
            CnpReceiveFlags // LOGXLONG
            );        

        status = STATUS_SUCCESS;
    }

    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    return(status);

} // CnpIndicateData


NTSTATUS
CnpCompleteReceivePacket(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    )
{
    NTSTATUS               status;
    PCNP_RECEIVE_REQUEST   request = Context;
    PCNP_RECEIVE_CONTEXT   context = request->UpperProtocolContext;
    CNP_HEADER UNALIGNED * cnpHeader = request->DataBuffer;
    ULONG                  consumed;
    ULONG                  dataLength;
    PIRP                   irp = NULL;
    ULONG                  bytesTaken = 0;
    BOOLEAN                currentMcastGroup = FALSE;


    if (Irp->IoStatus.Status == STATUS_SUCCESS) {
        
        CnAssert(Irp->IoStatus.Information == context->TsduSize);
        
        CnAssert(context->CnpReceiveFlags & CNP_RECV_FLAG_MULTICAST);
        CnAssert(
            !(context->CnpReceiveFlags & CNP_RECV_FLAG_SIGNATURE_VERIFIED)
            );
        CnAssert(
            !(context->CnpReceiveFlags & CNP_RECV_FLAG_CURRENT_MULTICAST_GROUP)
            );

        dataLength = (ULONG)Irp->IoStatus.Information;

        //
        // This routine is only called for multicast packets,
        // so we need to verify the signature.
        //
        status = CnpVerifyMulticastMessage(
                     context->Network,
                     cnpHeader + 1,
                     dataLength - sizeof(CNP_HEADER),
                     cnpHeader->PayloadLength,
                     &consumed,
                     &currentMcastGroup
                     );
        if (status != SEC_E_OK) {
            CnTrace(CNP_RECV_ERROR, CnpTraceRecvBadSig,
                "[CNP] Failed to verify multicast "
                "packet, status %x, src node %u, net %u, "
                "data length %u, CNP flags %x.",
                status,
                cnpHeader->SourceAddress, // LOGULONG
                context->Network->Id,
                dataLength,
                context->CnpReceiveFlags
                );
            goto error_exit;
        }

        context->CnpReceiveFlags |= CNP_RECV_FLAG_SIGNATURE_VERIFIED;

        if (currentMcastGroup) {
            context->CnpReceiveFlags |= CNP_RECV_FLAG_CURRENT_MULTICAST_GROUP;
        }

        consumed += sizeof(CNP_HEADER);

        //
        // Indicate the data to the next highest protocol.
        //
        status = CnpIndicateData(
                     context->Network,
                     cnpHeader->NextHeader,
                     cnpHeader->SourceAddress,
                     context->CnpReceiveFlags,
                     context->TdiReceiveDatagramFlags,
                     dataLength - consumed,
                     dataLength - consumed,
                     &bytesTaken,
                     (PUCHAR)cnpHeader + consumed,
                     &irp
                     );

        CnAssert(status != STATUS_MORE_PROCESSING_REQUIRED);
        CnAssert(bytesTaken == dataLength - consumed);
        CnAssert(irp == NULL);

        if (irp != NULL) {
            CnTrace(CNP_RECV_ERROR, CnpTraceCompleteReceiveIrp,
                "[CNP] Upper layer protocol requires more"
                "processing. Failing request."
                );        
            irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
            irp->IoStatus.Information = 0;
            IoCompleteRequest(irp, IO_NETWORK_INCREMENT);
        }
    }
    else {
        CnTrace(CNP_RECV_ERROR, CnpTraceCompleteReceiveFailed,
            "[CNP] Failed to fetch packet, src node %u, "
            "status %!status!",
            cnpHeader->SourceAddress, // LOGULONG
            Irp->IoStatus.Status // LOGSTATUS
            );        
    }

error_exit:

    //
    // Drop the active reference on the network.
    //
    if (context->Network != NULL) {
        CnAcquireLock(&(context->Network->Lock), &(context->Network->Irql));
        CnpActiveDereferenceNetwork(context->Network);
        context->Network = NULL;
    }

    CnpFreeReceiveRequest(request);

    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    return(STATUS_MORE_PROCESSING_REQUIRED);

} // CdpCompleteReceivePacket


NTSTATUS
CnpTdiReceiveDatagramHandler(
    IN  PVOID    TdiEventContext,
    IN  LONG     SourceAddressLength,
    IN  PVOID    SourceAddress,
    IN  LONG     OptionsLength,
    IN  PVOID    Options,
    IN  ULONG    ReceiveDatagramFlags,
    IN  ULONG    BytesIndicated,
    IN  ULONG    BytesAvailable,
    OUT PULONG   BytesTaken,
    IN  PVOID    Tsdu,
    OUT PIRP *   Irp
    )
{
    NTSTATUS                        status;
    CNP_HEADER UNALIGNED *          cnpHeader = Tsdu;
    PCNP_NETWORK                    network = TdiEventContext;
    PCNP_NODE                       srcNode;
    ULONG                           cnpRecvFlags = 0;
    BOOLEAN                         cnpSigDataIndicated = FALSE;
    ULONG                           consumed;
    PCNP_RECEIVE_REQUEST            request;

    
    CnAssert(KeGetCurrentIrql() == DISPATCH_LEVEL);
    CnAssert(network->State > ClusnetNetworkStateOffline);
    CnAssert(CnLocalNodeId != ClusterInvalidNodeId);
    CnAssert(CnpLocalNode != NULL);

    //
    // Validate the CNP header.
    //
    // First make sure it exists.
    //
    if (BytesIndicated < sizeof(CNP_HEADER)) {
        goto error_exit;
    }

    if ((cnpHeader->SourceAddress < CnMinValidNodeId) ||
        (cnpHeader->SourceAddress > CnMaxValidNodeId)) {
        goto error_exit;
    }

    if (cnpHeader->Version == CNP_VERSION_UNICAST) {
        //
        // Unicast checks.
        //
        if ((cnpHeader->PayloadLength + 
             sizeof(CNP_HEADER) != BytesAvailable) ||
            (cnpHeader->DestinationAddress != CnLocalNodeId)) {
            goto error_exit;
        }
    } else if (cnpHeader->Version == CNP_VERSION_MULTICAST) {
        //
        // Multicast checks. 
        // 
        // Defer payload length check until the signature 
        // length is known.
        //
        if (cnpHeader->DestinationAddress != ClusterAnyNodeId) {
            goto error_exit;
        }

        cnpRecvFlags |= CNP_RECV_FLAG_MULTICAST;
    }

    //
    // Validate the source and destination nodes.
    //
    CnAcquireLockAtDpc(&CnpNodeTableLock);

    srcNode = CnpNodeTable[cnpHeader->SourceAddress];

    if (srcNode == NULL) {
        CnReleaseLockFromDpc(&CnpNodeTableLock);
        goto error_exit;
    }

    if ( (srcNode->CommState == ClusnetNodeCommStateOnline) &&
         (CnpLocalNode->CommState == ClusnetNodeCommStateOnline)
       )
    {
        cnpRecvFlags |= CNP_RECV_FLAG_NODE_STATE_CHECK_PASSED;
    }

    CnReleaseLockFromDpc(&CnpNodeTableLock);

    if ((cnpRecvFlags & CNP_RECV_FLAG_MULTICAST) != 0) {

        //
        // Multicast packets need to be verified. Verification
        // cannot proceed unless the entire packet is present.
        //
        if (BytesIndicated == BytesAvailable) {
        
            BOOLEAN     currentMcastGroup = FALSE;
            
            //
            // The entire message is indicated. We can 
            // verify it now. 
            //
            status = CnpVerifyMulticastMessage(
                         network,
                         cnpHeader + 1,
                         BytesIndicated - sizeof(CNP_HEADER),
                         cnpHeader->PayloadLength,
                         &consumed,
                         &currentMcastGroup
                         );
            if (status != SEC_E_OK) {
                CnTrace(CNP_RECV_DETAIL, CdpTraceRecvBadSig,
                    "[CNP] Failed to verify multicast "
                    "packet, status %x, "
                    "src node %u, BI %u, BA %u",
                    status,
                    cnpHeader->SourceAddress, // LOGULONG
                    BytesIndicated, // LOGULONG
                    BytesAvailable // LOGULONG
                    );
                goto error_exit;
            }
    
            cnpRecvFlags |= CNP_RECV_FLAG_SIGNATURE_VERIFIED;

            if (currentMcastGroup) {
                cnpRecvFlags |= CNP_RECV_FLAG_CURRENT_MULTICAST_GROUP;
            }
            consumed += sizeof(CNP_HEADER);
        
        } else {

            //
            // The entire message is not indicated. We need
            // to submit a request and wait for the rest of 
            // the data.
            //
            request = CnpAllocateReceiveRequest(
                          CnpReceiveRequestPool,
                          network,
                          BytesAvailable,
                          CnpCompleteReceivePacket
                          );
            if (request != NULL) {

                PCNP_RECEIVE_CONTEXT  context;

                context = request->UpperProtocolContext;

                context->TdiReceiveDatagramFlags = ReceiveDatagramFlags;
                context->TsduSize = BytesAvailable;
                context->Network = network;
                context->CnpReceiveFlags = cnpRecvFlags;

                //
                // Take a reference on the network so that it 
                // doesn't disappear before the IRP completes.
                //
                CnAcquireLock(&(network->Lock), &(network->Irql));
                CnpActiveReferenceNetwork(network);
                CnReleaseLock(&(network->Lock), network->Irql);

                *Irp = request->Irp;

                CnTrace(CNP_RECV_DETAIL, CnpTraceCompleteReceive,
                    "[CNP] Fetching CNP multicast data, src "
                    "node %u, BI %u, BA %u, CNP flags %x.",
                    cnpHeader->SourceAddress, // LOGULONG
                    BytesIndicated, // LOGULONG
                    BytesAvailable, // LOGULONG
                    context->CnpReceiveFlags // LOGXLONG
                    );        

                CnVerifyCpuLockMask(
                    0,                // Required
                    0xFFFFFFFF,       // Forbidden
                    0                 // Maximum
                    );

                return(STATUS_MORE_PROCESSING_REQUIRED);

            }

            CnTrace(CNP_RECV_ERROR, CnpTraceDropReceiveNoIrp,
                "[CNP] Dropping packet: failed to allocate "
                "receive request."
                );

            //
            // Out of resources. Drop the packet.
            //
            goto error_exit;
        }

    } else {

        //
        // Unicast packets do not need to verified.
        //
        consumed = sizeof(CNP_HEADER);
    }

    //
    // Deliver the packet to the appropriate upper layer protocol.
    //
    *BytesTaken = consumed;
    BytesIndicated -= consumed;
    BytesAvailable -= consumed;

    return (CnpIndicateData(
                network,
                cnpHeader->NextHeader,
                cnpHeader->SourceAddress,
                cnpRecvFlags,
                ReceiveDatagramFlags,
                BytesIndicated,
                BytesAvailable,
                BytesTaken,
                (PUCHAR)Tsdu + consumed,
                Irp
                )
            );

error_exit:

    //
    // Something went wrong. Drop the packet by
    // indicating that we consumed it.
    //

    *BytesTaken = BytesAvailable;
    *Irp = NULL;

    CnTrace(CNP_RECV_ERROR, CnpTraceDropReceive,
        "[CNP] Dropped packet from net %u, BI %u, BA %u, CNP flags %x.",
        network->Id, // LOGULONG
        BytesIndicated, // LOGULONG
        BytesAvailable, // LOGULONG
        cnpRecvFlags // LOGXLONG
        );

    IF_CNDBG(CN_DEBUG_CNPRECV) {
        CNPRINT(("[CNP] Dropped packet from net %u, BI %u, BA %u.\n",
                 network->Id, BytesIndicated, BytesAvailable));
    }

    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    return(STATUS_SUCCESS);

}  // CnpTdiReceiveDatagramHandler
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\xport\cnpnode.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cnpnode.c

Abstract:

    Node management routines for the Cluster Network Protocol.

Author:

    Mike Massa (mikemas)           July 29, 1996

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     07-29-96    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "cnpnode.tmh"


//
// Global Node Data
//
PCNP_NODE *        CnpNodeTable = NULL;
LIST_ENTRY         CnpDeletingNodeList = {NULL, NULL};
#if DBG
CN_LOCK            CnpNodeTableLock = {0, 0};
#else  // DBG
CN_LOCK            CnpNodeTableLock = 0;
#endif // DBG
PCNP_NODE          CnpLocalNode = NULL;
BOOLEAN            CnpIsNodeShutdownPending = FALSE;
PKEVENT            CnpNodeShutdownEvent = NULL;

//
// static data
//

//
// Membership state table. This table is used to determine the validity
// of membership state transitions. Row is current state; col is the state
// to which a transition is made. Dead to Unconfigured is currently illegal,
// but someday, if we support dynamically shrinking the size of the
// cluster, we'd need to allow this transition.
//

typedef enum _MM_ACTION {
    MMActionIllegal = 0,
    MMActionWarning,
    MMActionNodeAlive,
    MMActionNodeDead,
    MMActionConfigured,
    MMActionUnconfigured
} MM_ACTION;

MM_ACTION MembershipStateTable[ClusnetNodeStateLastEntry][ClusnetNodeStateLastEntry] = {
              // Alive              Joining            Dead                NC'ed
/* Alive */    { MMActionWarning,   MMActionIllegal,   MMActionNodeDead,   MMActionIllegal },
/* Join  */    { MMActionNodeAlive, MMActionIllegal,   MMActionNodeDead,   MMActionIllegal },
/* Dead  */    { MMActionNodeAlive, MMActionNodeAlive, MMActionWarning,    MMActionIllegal },
/* NC'ed */    { MMActionIllegal,   MMActionIllegal,   MMActionConfigured, MMActionIllegal }
};

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, CnpLoadNodes)
#pragma alloc_text(PAGE, CnpInitializeNodes)

#endif // ALLOC_PRAGMA


//
// Private utility routines
//

VOID
CnpDestroyNode(
    PCNP_NODE  Node
    )
/*++

Notes:

    Called with no locks held. There should be no outstanding references
    to the target node.

    Synchronization with CnpCancelDeregisterNode() is achieved via
    CnpNodeTableLock.

--*/
{
    PLIST_ENTRY    entry;
    CN_IRQL        tableIrql;
    BOOLEAN        setCleanupEvent = FALSE;


    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    IF_CNDBG( CN_DEBUG_NODEOBJ )
        CNPRINT(("[CNP] Destroying node %u\n", Node->Id));

    CnAcquireLock(&CnpNodeTableLock, &tableIrql);

    //
    // Remove the node from the deleting list.
    //
#if DBG
    {
        PCNP_NODE      node = NULL;

        //
        // Verify that the node object is on the deleting list.
        //
        for (entry = CnpDeletingNodeList.Flink;
             entry != &CnpDeletingNodeList;
             entry = entry->Flink
            )
        {
            node = CONTAINING_RECORD(entry, CNP_NODE, Linkage);

            if (node == Node) {
                break;
            }
        }

        CnAssert(node == Node);
    }

#endif // DBG

    RemoveEntryList(&(Node->Linkage));

    if (CnpIsNodeShutdownPending) {
        if (IsListEmpty(&CnpDeletingNodeList)) {
            setCleanupEvent = TRUE;
        }
    }

    CnReleaseLock(&CnpNodeTableLock, tableIrql);

    if (Node->PendingDeleteIrp != NULL) {
        CnAcquireCancelSpinLock(&(Node->PendingDeleteIrp->CancelIrql));

        CnCompletePendingRequest(Node->PendingDeleteIrp, STATUS_SUCCESS, 0);

        //
        // The IoCancelSpinLock was released by CnCompletePendingRequest()
        //
    }

    CnFreePool(Node);

    if (setCleanupEvent) {
        IF_CNDBG(CN_DEBUG_CLEANUP) {
            CNPRINT(("[CNP] Setting node cleanup event.\n"));
        }

        KeSetEvent(CnpNodeShutdownEvent, 0, FALSE);
    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return;

}  // CnpDestroyNode



BOOLEAN
CnpDeleteNode(
    IN  PCNP_NODE    Node,
    IN  PVOID        Unused,
    IN  CN_IRQL      NodeTableIrql
    )
/*++

Routine Description:

    Deletes a node object.

Arguments:

    Node   - A pointer to the node object to be deleted.

    Unused - An umused parameter.

    NodeTableIrql  - The IRQL value at which the CnpNodeTable lock was
                     acquired,

Return Value:

    Returns TRUE if the CnpNodeTable lock is still held.
    Returns FALSE if the CnpNodeTable lock is released.

Notes:

    Called with CnpNodeTable and node object locks held.
    Releases both locks.

    Conforms to the calling convention for PCNP_NODE_UPDATE_ROUTINE

--*/
{
    PLIST_ENTRY      entry;
    PCNP_INTERFACE   interface;
    PCNP_NETWORK     network;
    CL_NODE_ID       nodeId = Node->Id;


    CnVerifyCpuLockMask(
        (CNP_NODE_TABLE_LOCK | CNP_NODE_OBJECT_LOCK),  // Required
        0,                                             // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX                       // Maximum
        );

    IF_CNDBG( CN_DEBUG_NODEOBJ )
        CNPRINT(("[CNP] Deleting node %u\n", nodeId));

    if (CnpLocalNode == Node) {
        CnAssert(CnLocalNodeId == Node->Id);
        CnpLocalNode = NULL;
    }

    //
    // Move the node to the deleting list.
    //
    CnpNodeTable[nodeId] = NULL;
    InsertTailList(&CnpDeletingNodeList, &(Node->Linkage));

    IF_CNDBG( CN_DEBUG_NODEOBJ )
        CNPRINT((
            "[CNP] Moved node %u to deleting list\n",
            nodeId
            ));

    CnReleaseLockFromDpc(&CnpNodeTableLock);
    Node->Irql = NodeTableIrql;

    //
    // From this point on, the cancel routine may run and
    // complete the irp.
    //

    Node->Flags |= CNP_NODE_FLAG_DELETING;

    Node->CommState = ClusnetNodeCommStateOffline;

    //
    // Delete all the node's interfaces.
    //
    IF_CNDBG( CN_DEBUG_NODEOBJ )
        CNPRINT((
            "[CNP] Deleting all interfaces on node %u\n",
            Node->Id
            ));

    while (!IsListEmpty(&(Node->InterfaceList))) {

        interface = CONTAINING_RECORD(
                        Node->InterfaceList.Flink,
                        CNP_INTERFACE,
                        NodeLinkage
                        );

        network = interface->Network;

        CnAcquireLockAtDpc(&(network->Lock));
        network->Irql = DISPATCH_LEVEL;

        CnpDeleteInterface(interface);

        //
        // The network object lock was released.
        //
    }

    //
    // Remove initial reference on node object. When the reference
    // count goes to zero, the node will be deleted. This releases
    // the node lock.
    //
    CnpDereferenceNode(Node);

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(FALSE);
}



//
// CNP Internal Routines
//
VOID
CnpWalkNodeTable(
    PCNP_NODE_UPDATE_ROUTINE  UpdateRoutine,
    PVOID                     UpdateContext
    )
{
    ULONG         i;
    CN_IRQL       tableIrql;
    PCNP_NODE     node;
    BOOLEAN       isNodeTableLockHeld;


    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    CnAcquireLock(&CnpNodeTableLock, &tableIrql);

    CnAssert(CnMinValidNodeId != ClusterInvalidNodeId);
    CnAssert(CnMaxValidNodeId != ClusterInvalidNodeId);

    for (i=CnMinValidNodeId; i <= CnMaxValidNodeId; i++) {
        node = CnpNodeTable[i];

        if (node != NULL) {

            CnAcquireLockAtDpc(&(node->Lock));
            node->Irql = DISPATCH_LEVEL;

            isNodeTableLockHeld = (*UpdateRoutine)(
                                      node,
                                      UpdateContext,
                                      tableIrql
                                      );

            //
            // The node object lock was released.
            // The node table lock may also have been released.
            //
            if (!isNodeTableLockHeld) {
                CnAcquireLock(&CnpNodeTableLock, &tableIrql);
            }
        }
    }

    CnReleaseLock(&CnpNodeTableLock, tableIrql);

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return;

} // CnpWalkNodeTable



NTSTATUS
CnpValidateAndFindNode(
    IN  CL_NODE_ID    NodeId,
    OUT PCNP_NODE *   Node
    )
{
    NTSTATUS           status;
    CN_IRQL            tableIrql;
    PCNP_NODE          node = NULL;


    CnVerifyCpuLockMask(
        0,                           // Required
        CNP_LOCK_RANGE,              // Forbidden
        CNP_PRECEEDING_LOCK_RANGE    // Maximum
        );

    if (CnIsValidNodeId(NodeId)) {
        CnAcquireLock(&CnpNodeTableLock, &tableIrql);

        node = CnpNodeTable[NodeId];

        if (node != NULL) {
            CnAcquireLockAtDpc(&(node->Lock));
            CnReleaseLockFromDpc(&CnpNodeTableLock);
            node->Irql = tableIrql;

            *Node = node;

            CnVerifyCpuLockMask(
                CNP_NODE_OBJECT_LOCK,        // Required
                CNP_NODE_TABLE_LOCK,         // Forbidden
                CNP_NODE_OBJECT_LOCK_MAX     // Maximum
                );

            return(STATUS_SUCCESS);
        }
        else {
            status = STATUS_CLUSTER_NODE_NOT_FOUND;
        }

        CnReleaseLock(&CnpNodeTableLock, tableIrql);
    }
    else {
        status = STATUS_CLUSTER_INVALID_NODE;
    }

    CnVerifyCpuLockMask(
        0,                           // Required
        CNP_LOCK_RANGE,              // Forbidden
        CNP_PRECEEDING_LOCK_RANGE    // Maximum
        );

    return(status);

}  // CnpValidateAndFindNode


PCNP_NODE
CnpLockedFindNode(
    IN  CL_NODE_ID    NodeId,
    IN  CN_IRQL       NodeTableIrql
    )
/*++

Routine Description:

    Searches the node table for a specified node object.

Arguments:

    NodeId      - The ID of the node object to locate.

    NodeTableIrql  - The IRQL level at which the node table lock was
                     acquired before calling this routine.

Return Value:

    A pointer to the requested node object, if it exists.
    NULL otherwise.

Notes:

    Called with CnpNodeTableLock held.
    Returns with CnpNodeTableLock released.
    If return value is non-NULL, returns with node object lock held.

--*/
{
    NTSTATUS           status;
    CN_IRQL            tableIrql;
    PCNP_NODE          node;


    CnVerifyCpuLockMask(
        CNP_NODE_TABLE_LOCK,             // Required
        0,                               // Forbidden
        CNP_NODE_TABLE_LOCK_MAX          // Maximum
        );

    node = CnpNodeTable[NodeId];

    if (node != NULL) {
        CnAcquireLockAtDpc(&(node->Lock));
        CnReleaseLockFromDpc(&CnpNodeTableLock);
        node->Irql = NodeTableIrql;

        CnVerifyCpuLockMask(
            CNP_NODE_OBJECT_LOCK,          // Required
            CNP_NODE_TABLE_LOCK,           // Forbidden
            CNP_NODE_OBJECT_LOCK_MAX       // Maximum
            );

        return(node);
    }

    CnReleaseLock(&CnpNodeTableLock, NodeTableIrql);

    CnVerifyCpuLockMask(
        0,                                                    // Required
        (CNP_NODE_TABLE_LOCK | CNP_NODE_OBJECT_LOCK),         // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX                              // Maximum
        );

    return(NULL);

}  // CnpLockedFindNode



PCNP_NODE
CnpFindNode(
    IN  CL_NODE_ID    NodeId
    )
{
    CN_IRQL            tableIrql;


    CnVerifyCpuLockMask(
        0,                           // Required
        CNP_LOCK_RANGE,              // Forbidden
        CNP_PRECEEDING_LOCK_RANGE    // Maximum
        );

    CnAcquireLock(&CnpNodeTableLock, &tableIrql);

    return(CnpLockedFindNode(NodeId, tableIrql));

}  // CnpFindNode



VOID
CnpDeclareNodeUnreachable(
    PCNP_NODE  Node
    )
/*++

Notes:

    Called with node object lock held.

--*/
{
    CnVerifyCpuLockMask(
        CNP_NODE_OBJECT_LOCK,        // Required
        0,                           // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX     // Maximum
        );

    if ( (Node->CommState == ClusnetNodeCommStateOnline) &&
         !CnpIsNodeUnreachable(Node)
       )
    {
        IF_CNDBG( CN_DEBUG_NODEOBJ )
            CNPRINT(("[CNP] Declaring node %u unreachable\n", Node->Id));

        Node->Flags |= CNP_NODE_FLAG_UNREACHABLE;
    }

    return;

}  // CnpDeclareNodeUnreachable



VOID
CnpDeclareNodeReachable(
    PCNP_NODE  Node
    )
/*++

Notes:

    Called with node object lock held.

--*/
{
    CnVerifyCpuLockMask(
        CNP_NODE_OBJECT_LOCK,        // Required
        0,                           // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX     // Maximum
        );

    if ( (Node->CommState == ClusnetNodeCommStateOnline) &&
         CnpIsNodeUnreachable(Node)
       )
    {
        IF_CNDBG( CN_DEBUG_NODEOBJ )
            CNPRINT(("[CNP] Declaring node %u reachable again\n", Node->Id));

        Node->Flags &= ~(CNP_NODE_FLAG_UNREACHABLE);
    }

    return;

}  // CnpDeclareNodeUnreachable



VOID
CnpReferenceNode(
    PCNP_NODE  Node
    )
/*++

Notes:

    Called with node object lock held.

--*/
{
    CnVerifyCpuLockMask(
        CNP_NODE_OBJECT_LOCK,        // Required
        0,                           // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX     // Maximum
        );

    CnAssert(Node->RefCount != 0xFFFFFFFF);

    Node->RefCount++;

    IF_CNDBG( CN_DEBUG_CNPREF )
        CNPRINT((
            "[CNP] Referencing node %u, new refcount %u\n",
            Node->Id,
            Node->RefCount
            ));

    return;

}  // CnpReferenceNode



VOID
CnpDereferenceNode(
    PCNP_NODE  Node
    )
/*++

Notes:

    Called with node object lock held.
    Returns with node object lock released.

--*/
{
    BOOLEAN   isDeleting = FALSE;
    ULONG     newRefCount;


    CnVerifyCpuLockMask(
        CNP_NODE_OBJECT_LOCK,        // Required
        0,                           // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX     // Maximum
    );

    CnAssert(Node->RefCount != 0);

    newRefCount = --(Node->RefCount);

    IF_CNDBG( CN_DEBUG_CNPREF )
        CNPRINT((
            "[CNP] Dereferencing node %u, new refcount %u\n",
            Node->Id,
            newRefCount
            ));

    CnReleaseLock(&(Node->Lock), Node->Irql);

    if (newRefCount > 0) {
        CnVerifyCpuLockMask(
            0,                           // Required
            CNP_NODE_OBJECT_LOCK,        // Forbidden
            CNP_NODE_TABLE_LOCK_MAX      // Maximum
            );

        return;
    }

    CnpDestroyNode(Node);

    CnVerifyCpuLockMask(
        0,                           // Required
        CNP_NODE_OBJECT_LOCK,        // Forbidden
        CNP_NODE_TABLE_LOCK_MAX      // Maximum
        );

    return;

}  // CnpDereferenceNode



//
// Cluster Transport Public Routines
//
NTSTATUS
CnpLoadNodes(
    VOID
    )
/*++

Routine Description:

    Called when the Cluster Network driver is loading. Initializes
    static node-related data structures.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS  status;
    ULONG     i;


    CnInitializeLock(&CnpNodeTableLock, CNP_NODE_TABLE_LOCK);
    InitializeListHead(&CnpDeletingNodeList);

    return(STATUS_SUCCESS);

}  // CnpLoadNodes


NTSTATUS
CnpInitializeNodes(
    VOID
    )
/*++

Routine Description:

    Called when the Cluster Network driver is being (re)initialized.
    Initializes dynamic node-related data structures.

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS  status;
    ULONG     i;


    PAGED_CODE();

    CnAssert(CnLocalNodeId != ClusterInvalidNodeId);
    CnAssert(CnMinValidNodeId != ClusterInvalidNodeId);
    CnAssert(CnMaxValidNodeId != ClusterInvalidNodeId);
    CnAssert(CnpNodeTable == NULL);
    CnAssert(CnpNodeShutdownEvent == NULL);
    CnAssert(IsListEmpty(&CnpDeletingNodeList));

    CnpNodeShutdownEvent = CnAllocatePool(sizeof(KEVENT));

    if (CnpNodeShutdownEvent == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    KeInitializeEvent(CnpNodeShutdownEvent, NotificationEvent, FALSE);
    CnpIsNodeShutdownPending = FALSE;

    CnpNodeTable = CnAllocatePool(
                       (sizeof(PCNP_NODE) * (CnMaxValidNodeId + 1))
                       );

    if (CnpNodeTable == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlZeroMemory(CnpNodeTable, (sizeof(PCNP_NODE) * (CnMaxValidNodeId + 1)) );

    //
    // Register the local node.
    //
    status = CxRegisterNode(CnLocalNodeId);

    if (!NT_SUCCESS(status)) {
        return(status);
    }

    CnVerifyCpuLockMask(
        0,                           // Required
        0xFFFFFFFF,                  // Forbidden
        0                            // Maximum
        );

    return(STATUS_SUCCESS);

}  // CnpInitializeNodes



VOID
CnpShutdownNodes(
    VOID
    )
/*++

Routine Description:

    Called when a shutdown request is issued to the Cluster Network
    Driver. Deletes all node objects.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG         i;
    CN_IRQL       tableIrql;
    PCNP_NODE     node;
    PCNP_NODE *   table;
    BOOLEAN       waitEvent = FALSE;
    NTSTATUS      status;


    CnVerifyCpuLockMask(
        0,                           // Required
        0xFFFFFFFF,                  // Forbidden
        0                            // Maximum
        );

    if (CnpNodeShutdownEvent != NULL) {
        CnAssert(CnpIsNodeShutdownPending == FALSE);

        IF_CNDBG(CN_DEBUG_CLEANUP) {
            CNPRINT(("[CNP] Cleaning up nodes...\n"));
        }

        if (CnpNodeTable != NULL) {

            CnpWalkNodeTable(CnpDeleteNode, NULL);

            CnAcquireLock(&CnpNodeTableLock, &tableIrql);

            if (!IsListEmpty(&CnpDeletingNodeList)) {
                CnpIsNodeShutdownPending = TRUE;
                waitEvent = TRUE;
            }

            CnReleaseLock(&CnpNodeTableLock, tableIrql);

            if (waitEvent) {
                IF_CNDBG(CN_DEBUG_CLEANUP) {
                    CNPRINT(("[CNP] Node deletes are pending...\n"));
                }

                status = KeWaitForSingleObject(
                             CnpNodeShutdownEvent,
                             Executive,
                             KernelMode,
                             FALSE,        // not alertable
                             NULL          // no timeout
                             );
                CnAssert(status == STATUS_SUCCESS);
            }

            CnAssert(IsListEmpty(&CnpDeletingNodeList));

            IF_CNDBG(CN_DEBUG_CLEANUP) {
                CNPRINT(("[CNP] All nodes deleted.\n"));
            }

            CnFreePool(CnpNodeTable); CnpNodeTable = NULL;
        }

        CnFreePool(CnpNodeShutdownEvent); CnpNodeShutdownEvent = NULL;

        IF_CNDBG(CN_DEBUG_CLEANUP) {
            CNPRINT(("[CNP] Nodes cleaned up.\n"));
        }
    }

    CnVerifyCpuLockMask(
        0,                           // Required
        0xFFFFFFFF,                  // Forbidden
        0                            // Maximum
        );

    return;

}  // CnpShutdownNodes



NTSTATUS
CxRegisterNode(
    CL_NODE_ID    NodeId
    )
{
    NTSTATUS           status = STATUS_SUCCESS;
    CN_IRQL            tableIrql;
    PCNP_NODE          node = NULL;


    CnVerifyCpuLockMask(
        0,                           // Required
        0xFFFFFFFF,                  // Forbidden
        0                            // Maximum
        );

    if (CnIsValidNodeId(NodeId)) {
        //
        // Allocate and initialize a node object.
        //
        node = CnAllocatePool(sizeof(CNP_NODE));

        if (node == NULL) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        RtlZeroMemory(node, sizeof(CNP_NODE));

        CN_INIT_SIGNATURE(node, CNP_NODE_SIG);
        node->Id = NodeId;
        node->CommState = ClusnetNodeCommStateOffline;
        node->MMState = ClusnetNodeStateDead;
        node->RefCount = 1;

        //
        // NodeDownIssued is init'ed to true so that the first recv'd
        // heart beat msg will cause a node up event to be triggered
        //

        node->NodeDownIssued = TRUE;
        InitializeListHead(&(node->InterfaceList));
        CnInitializeLock(&(node->Lock), CNP_NODE_OBJECT_LOCK);

        CnAcquireLock(&CnpNodeTableLock, &tableIrql);

        //
        // Make sure this isn't a duplicate registration
        //
        if (CnpNodeTable[NodeId] == NULL) {
            if (NodeId == CnLocalNodeId) {
                node->Flags |= CNP_NODE_FLAG_LOCAL;
                CnpLocalNode = node;
            }

            CnpNodeTable[NodeId] = node;

            status = STATUS_SUCCESS;
        }
        else {
            status = STATUS_CLUSTER_NODE_EXISTS;
        }

        CnReleaseLock(&CnpNodeTableLock, tableIrql);

        if (!NT_SUCCESS(status)) {
            CnFreePool(node);
        }
        else {
            IF_CNDBG( CN_DEBUG_NODEOBJ )
                CNPRINT(("[CNP] Registered node %u\n", NodeId));
        }
    }
    else {
        status = STATUS_CLUSTER_INVALID_NODE;
    }

    CnVerifyCpuLockMask(
        0,                           // Required
        0xFFFFFFFF,                  // Forbidden
        0                            // Maximum
        );

    return(status);

} // CxRegisterNode



VOID
CxCancelDeregisterNode(
    PDEVICE_OBJECT   DeviceObject,
    PIRP             Irp
    )
/*++

Routine Description:

    Cancellation handler for DeregisterNode requests.

Return Value:

    None.

Notes:

    Called with cancel spinlock held.
    Returns with cancel spinlock released.

--*/

{
    PFILE_OBJECT   fileObject;
    CN_IRQL        cancelIrql = Irp->CancelIrql;
    PLIST_ENTRY    entry;
    PCNP_NODE      node;


    CnVerifyCpuLockMask(
        0,                           // Required
        0xFFFFFFFF,                  // Forbidden
        0                            // Maximum
        );

    CnMarkIoCancelLockAcquired();

    IF_CNDBG( CN_DEBUG_IRP )
        CNPRINT((
            "[CNP] Attempting to cancel DeregisterNode irp %p\n",
            Irp
            ));

    CnAssert(DeviceObject == CnDeviceObject);

    fileObject = CnBeginCancelRoutine(Irp);

    CnAcquireLockAtDpc(&CnpNodeTableLock);

    CnReleaseCancelSpinLock(DISPATCH_LEVEL);

    //
    // We can only complete the irp if we can find it stashed in a
    // deleting node object. The deleting node object could have
    // been destroyed and the IRP completed before we acquired the
    // CnpNetworkListLock.
    //
    for (entry = CnpDeletingNodeList.Flink;
         entry != &CnpDeletingNodeList;
         entry = entry->Flink
        )
    {
        node = CONTAINING_RECORD(entry, CNP_NODE, Linkage);

        if (node->PendingDeleteIrp == Irp) {
            IF_CNDBG( CN_DEBUG_IRP )
                CNPRINT((
                    "[CNP] Found dereg irp on node %u\n",
                    node->Id
                    ));

            //
            // Found the Irp. Now take it away and complete it.
            //
            node->PendingDeleteIrp = NULL;

            CnReleaseLock(&CnpNodeTableLock, cancelIrql);

            CnAcquireCancelSpinLock(&(Irp->CancelIrql));

            CnEndCancelRoutine(fileObject);

            CnCompletePendingRequest(Irp, STATUS_CANCELLED, 0);

            //
            // IoCancelSpinLock was released by CnCompletePendingRequest().
            //

            CnVerifyCpuLockMask(
                0,                  // Required
                0xFFFFFFFF,         // Forbidden
                0                   // Maximum
                );

            return;
        }
    }

    CnReleaseLock(&CnpNodeTableLock, cancelIrql);

    CnAcquireCancelSpinLock(&cancelIrql);

    CnEndCancelRoutine(fileObject);

    CnReleaseCancelSpinLock(cancelIrql);

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return;

}  // CnpCancelApiDeregisterNode



NTSTATUS
CxDeregisterNode(
    CL_NODE_ID           NodeId,
    PIRP                 Irp,
    PIO_STACK_LOCATION   IrpSp
    )
{
    NTSTATUS           status;
    CN_IRQL            cancelIrql;
    PCNP_NODE          node = NULL;
    BOOLEAN            isNodeTableLockHeld;


    CnVerifyCpuLockMask(
        0,                           // Required
        0xFFFFFFFF,                  // Forbidden
        0                            // Maximum
        );

    if (CnIsValidNodeId(NodeId)) {
        if (NodeId != CnLocalNodeId) {
            CnAcquireCancelSpinLock(&cancelIrql);
            CnAcquireLockAtDpc(&CnpNodeTableLock);

            node = CnpNodeTable[NodeId];

            if (node != NULL) {
                status = CnMarkRequestPending(
                             Irp,
                             IrpSp,
                             CxCancelDeregisterNode
                             );

                if (status != STATUS_CANCELLED) {

                    CnReleaseCancelSpinLock(DISPATCH_LEVEL);

                    CnAssert(status == STATUS_SUCCESS);

                    CnAcquireLockAtDpc(&(node->Lock));

                    IF_CNDBG( CN_DEBUG_NODEOBJ )
                        CNPRINT(("[CNP] Deregistering node %u\n", NodeId));

                    //
                    // Save a pointer to pending irp. Note this is protected
                    // by the table lock, not the object lock.
                    //
                    node->PendingDeleteIrp = Irp;

                    isNodeTableLockHeld = CnpDeleteNode(node, NULL, cancelIrql);

                    if (isNodeTableLockHeld) {
                        CnReleaseLock(&CnpNodeTableLock, cancelIrql);
                    }

                    CnVerifyCpuLockMask(
                        0,                           // Required
                        0xFFFFFFFF,                  // Forbidden
                        0                            // Maximum
                        );

                    return(STATUS_PENDING);
                }
            }
            else {
                status = STATUS_CLUSTER_NODE_NOT_FOUND;
            }

            CnReleaseLockFromDpc(&CnpNodeTableLock);
            CnReleaseCancelSpinLock(cancelIrql);
        }
        else {
            status = STATUS_CLUSTER_INVALID_REQUEST;
        }
    }
    else {
        status = STATUS_CLUSTER_INVALID_NODE;
    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(status);

}  // CxDeregisterNode



NTSTATUS
CxOnlineNodeComm(
    CL_NODE_ID     NodeId
    )
{
    NTSTATUS           status;
    PCNP_NODE          node;


    CnVerifyCpuLockMask(
        0,                           // Required
        0xFFFFFFFF,                  // Forbidden
        0                            // Maximum
        );

    status = CnpValidateAndFindNode(NodeId, &node);

    if (status == STATUS_SUCCESS) {

        if (node->CommState == ClusnetNodeCommStateOffline) {
            IF_CNDBG( CN_DEBUG_NODEOBJ )
                CNPRINT((
                    "[CNP] Moving node %u comm state to online.\n",
                    NodeId
                    ));

            CnTrace(
                CNP_NODE_DETAIL,
                CnpTraceOnlineNodeComm,
                "[CNP] Moving node %u comm state to online.\n",
                NodeId
                );

            node->CommState = ClusnetNodeCommStateOnline;

            CnpWalkInterfacesOnNode(node, CnpResetAndOnlinePendingInterface);

        }
        else {
            status = STATUS_CLUSTER_NODE_ALREADY_UP;
        }

        CnReleaseLock(&(node->Lock), node->Irql);
    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(status);

}  // CxOnlineNodeComm



NTSTATUS
CxOfflineNodeComm(
    IN CL_NODE_ID          NodeId,
    IN PIRP                Irp,
    IN PIO_STACK_LOCATION  IrpSp
    )
/*++

Notes:


--*/
{
    PCNP_NODE   node;
    NTSTATUS    status;


    CnVerifyCpuLockMask(
        0,                           // Required
        0xFFFFFFFF,                  // Forbidden
        0                            // Maximum
        );

    status = CnpValidateAndFindNode(NodeId, &node);

    if (status == STATUS_SUCCESS) {
        if (node->CommState == ClusnetNodeCommStateOnline) {
            IF_CNDBG( CN_DEBUG_NODEOBJ )
                CNPRINT((
                    "[CNP] Moving node %u comm state to offline.\n",
                    NodeId
                    ));

            CnTrace(
                CNP_NODE_DETAIL,
                CnpTraceOfflineNodeComm,
                "[CNP] Moving node %u comm state to offline.\n",
                NodeId
                );
            
            node->CommState = ClusnetNodeCommStateOffline;

            CnpWalkInterfacesOnNode(node, CnpOfflineInterfaceWrapper);

        }
        else {
            status = STATUS_CLUSTER_NODE_ALREADY_DOWN;
        }

        CnReleaseLock(&(node->Lock), node->Irql);
    }
    else {
        status = STATUS_CLUSTER_NODE_NOT_FOUND;
    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(status);

}  // CxOfflineNodeComm



NTSTATUS
CxGetNodeCommState(
    IN  CL_NODE_ID                NodeId,
    OUT PCLUSNET_NODE_COMM_STATE  CommState
    )
{
    NTSTATUS       status;
    PCNP_NODE      node;


    CnVerifyCpuLockMask(
        0,                           // Required
        0xFFFFFFFF,                  // Forbidden
        0                            // Maximum
        );

    status = CnpValidateAndFindNode(NodeId, &node);

    if (status == STATUS_SUCCESS) {
        if (CnpIsNodeUnreachable(node)) {
            *CommState = ClusnetNodeCommStateUnreachable;
        }
        else {
            *CommState = node->CommState;
        }

        CnReleaseLock(&(node->Lock), node->Irql);
    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(status);

}  // CxGetNodeCommState


NTSTATUS
CxGetNodeMembershipState(
    IN  CL_NODE_ID              NodeId,
    OUT PCLUSNET_NODE_STATE   State
    )
{
    NTSTATUS       status;
    PCNP_NODE      node;


    CnVerifyCpuLockMask(
        0,                           // Required
        0xFFFFFFFF,                  // Forbidden
        0                            // Maximum
        );

    status = CnpValidateAndFindNode(NodeId, &node);

    if (status == STATUS_SUCCESS) {

        *State = node->MMState;

        CnReleaseLock(&(node->Lock), node->Irql);
    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(status);

}  // CxGetNodeMembershipState


NTSTATUS
CxSetNodeMembershipState(
    IN  CL_NODE_ID              NodeId,
    IN  CLUSNET_NODE_STATE    State
    )
{
    NTSTATUS status;
    PCNP_NODE node;
    MM_ACTION MMAction;
    BOOLEAN   nodeLockAcquired = FALSE;

    CnVerifyCpuLockMask(
        0,                           // Required
        0xFFFFFFFF,                  // Forbidden
        0                            // Maximum
        );

    status = CnpValidateAndFindNode(NodeId, &node);

    if (status == STATUS_SUCCESS) {
        nodeLockAcquired = TRUE;

        IF_CNDBG( CN_DEBUG_MMSTATE ) {
            CNPRINT(("[Clusnet] Changing Node %u (%08X) MMState from %u to %u\n",
                     node->Id, node, node->MMState, State));
        }

        //
        // look up the routine to call (if any) based on the old and new
        // state
        //
        switch ( MembershipStateTable[ node->MMState ][ State ] ) {

        case MMActionIllegal:
            status = STATUS_CLUSTER_INVALID_REQUEST;
            break;

        case MMActionWarning:

            //
            // warning about null transitions
            //

            if ( node->MMState == ClusnetNodeStateAlive &&
                 State == ClusnetNodeStateAlive ) {

                status = STATUS_CLUSTER_NODE_ALREADY_UP;
            } else if ( node->MMState == ClusnetNodeStateDead &&
                        State == ClusnetNodeStateDead ) {

                status = STATUS_CLUSTER_NODE_ALREADY_DOWN;
            }
            break;

        case MMActionNodeAlive:
            node->MMState = State;
            //
            // if we're transitioning our own node from Dead to
            // Joining or Alive then start heartbeat code
            //

            if (( node->MMState != ClusnetNodeStateJoining ||
                  State != ClusnetNodeStateAlive )
                &&
                CnpIsNodeLocal( node )) {

                node->MissedHBs = 0;
                node->HBWasMissed = FALSE;

                //
                // Release the node lock before starting heartbeats. Note
                // that we are holding the global resource here, which will
                // synchronize this code with shutdown.
                //
                CnReleaseLock(&(node->Lock), node->Irql);
                nodeLockAcquired = FALSE;

                CnpStartHeartBeats();
            }

            break;

        case MMActionNodeDead:

            //
            // reset this flag so when node is being brought
            // online again, we'll issue a Node Up event on
            // first HB received from this node.
            //

            node->NodeDownIssued = TRUE;
            node->MMState = State;

            if ( CnpIsNodeLocal( node )) {
                //
                // Release the node lock before stopping heartbeats. Note
                // that we are holding the global resource here, which will
                // synchronize this code with shutdown.
                //
                CnReleaseLock(&(node->Lock), node->Irql);
                nodeLockAcquired = FALSE;

                CnpStopHeartBeats();
            }

            break;

        case MMActionConfigured:
            node->MMState = State;
            break;
        }

        if ( NT_ERROR( status )) {

            CN_DBGCHECK;
        }

        if (nodeLockAcquired) {
            CnReleaseLock(&(node->Lock), node->Irql);
        }
    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(status);

}  // CxSetNodeMembershipState
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\xport\cnpnet.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cnpnet.c

Abstract:

    Network management routines for the Cluster Network Protocol.

Author:

    Mike Massa (mikemas)           July 29, 1996

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     07-29-96    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "cnpnet.tmh"

#include <tdiinfo.h>
#include <tcpinfo.h>
#include <align.h>
#include <sspi.h>

//
// Global Data
//
LIST_ENTRY          CnpNetworkList = {NULL, NULL};
LIST_ENTRY          CnpDeletingNetworkList = {NULL, NULL};
#if DBG
CN_LOCK             CnpNetworkListLock = {0,0};
#else  // DBG
CN_LOCK             CnpNetworkListLock = 0;
#endif // DBG
BOOLEAN             CnpIsNetworkShutdownPending = FALSE;
PKEVENT             CnpNetworkShutdownEvent = NULL;
USHORT              CnpReservedClusnetPort = 0;



#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, CnpLoadNetworks)
#pragma alloc_text(PAGE, CnpInitializeNetworks)

#endif // ALLOC_PRAGMA


//
// Private utiltity routines
//
#define CnpIpAddrPrintArgs(_ip) \
    ((_ip >> 0 ) & 0xff),       \
    ((_ip >> 8 ) & 0xff),       \
    ((_ip >> 16) & 0xff),       \
    ((_ip >> 24) & 0xff)


#define CnpIsInternalMulticastNetwork(_network)                  \
            (((_network)->State = ClusnetNetworkStateOnline) &&  \
             (!CnpIsNetworkRestricted((_network))) &&            \
             (CnpIsNetworkMulticastCapable((_network))))


VOID
CnpMulticastGetReachableNodesLocked(
    OUT CX_CLUSTERSCREEN * McastReachableNodes,
    OUT ULONG            * McastReachableCount
    )
{
    PLIST_ENTRY      entry;
    PCNP_NETWORK     network = NULL;
    
    CnVerifyCpuLockMask(
        CNP_NETWORK_LIST_LOCK,      // required
        0,                          // forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX // max
        );
    
    if (!IsListEmpty(&CnpNetworkList)) {
        
        entry = CnpNetworkList.Flink;
        network = CONTAINING_RECORD(entry, CNP_NETWORK, Linkage);
        
        //
        // The old screen and count are only valid if
        // this is a valid internal network.
        //
        if (CnpIsInternalMulticastNetwork(network)) {
            *McastReachableNodes = network->McastReachableNodes;
            *McastReachableCount = network->McastReachableCount;
        } else {
            network = NULL;
        }
    } 
    if (network == NULL) {
        RtlZeroMemory(McastReachableNodes, sizeof(*McastReachableNodes));
        *McastReachableCount = 0;
    }

    return;

} // CnpMulticastGetReachableNodesLocked


BOOLEAN
CnpRemoveNetworkListEntryLocked(
    IN  PCNP_NETWORK       Network,
    IN  BOOLEAN            RaiseEvent,
    OUT CX_CLUSTERSCREEN * McastReachableNodes   OPTIONAL
    )
/*++

Routine Description:

    Remove Network from the network list and return the new
    multicast reachable mask.
    
Return value:

    TRUE if the reachable set changed
    
Notes:

    Called and returns with network list lock held.
    
--*/
{
    ULONG                count;
    BOOLEAN              setChanged;
    CX_CLUSTERSCREEN     oldScreen;
    CX_CLUSTERSCREEN     newScreen;

    CnVerifyCpuLockMask(
        CNP_NETWORK_LIST_LOCK,      // required
        0,                          // forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX // max
        );
    
    CnpMulticastGetReachableNodesLocked(&oldScreen, &count);

    RemoveEntryList(&(Network->Linkage));
    Network->Flags &= ~CNP_NET_FLAG_MCASTSORTED;

    CnpMulticastGetReachableNodesLocked(&newScreen, &count);

    setChanged = (BOOLEAN)
        (oldScreen.UlongScreen != newScreen.UlongScreen);

    if (RaiseEvent && setChanged) {

        CnTrace(CNP_NET_DETAIL, CnpTraceMulticastReachEventRemove,
            "[CNP] Issuing event for new multicast "
            "reachable set (%lx) after removing "
            "network %u.",
            newScreen.UlongScreen,
            Network->Id
            );

        CnIssueEvent(
            ClusnetEventMulticastSet,
            newScreen.UlongScreen,
            0
            );
    }

    if (McastReachableNodes != NULL) {
        *McastReachableNodes = newScreen;
    }

    CnVerifyCpuLockMask(
        CNP_NETWORK_LIST_LOCK,    // required
        0,                        // forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX // max
        );
    
    return(setChanged);

} // CnpRemoveNetworkListEntryLocked


BOOLEAN
CnpIsBetterMulticastNetwork(
    IN PCNP_NETWORK        Network1,
    IN PCNP_NETWORK        Network2
    )
/*++

Routine Description:

    Compares two networks according to multicast reachability
    criteria:
    1. online/registered AND 
       not restricted (e.g. enabled for intracluster comm) AND
       not disconnected AND
       multicast-enabled
    2. priority
    3. number of multicast reachable nodes
    
Return value:

    TRUE if Network1 is better than Network2
    
--*/
{
    if (!CnpIsInternalMulticastNetwork(Network1)) {
        return(FALSE);
    }

    if (!CnpIsInternalMulticastNetwork(Network2)) {
        return(TRUE);
    }

    //
    // Both networks are equal with respect to basic
    // multicast requirements.
    //
    // Now compare the priority.
    //
    if (CnpIsEqualPriority(Network1->Priority, Network2->Priority)) {

        //
        // The priority is the same. Although this is unexpected,
        // we now compare the number of nodes reachable by 
        // multicast.
        //
        return(Network1->McastReachableCount > Network2->McastReachableCount);
    
    } else {

        return(CnpIsHigherPriority(Network1->Priority, Network2->Priority));
    }

} // CnpIsBetterMulticastNetwork


BOOLEAN
CnpSortMulticastNetworkLocked(
    IN  PCNP_NETWORK        Network,
    IN  BOOLEAN             RaiseEvent,
    OUT CX_CLUSTERSCREEN  * NewMcastReachableNodes      OPTIONAL
    )
/*++

Routine Description:

    Positions Network in network list according to multicast
    reachability. Network must already be inserted in the
    network list.
    
    The network list is always sorted, but it is possible
    for one network in the list to be "perturbed". In this
    case, that entry must be repositioned correctly. This
    routine handles repositioning.
    
    Returns new screen through NewMcastReachableNodes.
    
Return value:

    TRUE if number of reachable nodes changes.    
    
Notes:

    Called and returns with network list locked.
    
--*/
{
    ULONG            count;
    CX_CLUSTERSCREEN oldScreen;
    CX_CLUSTERSCREEN newScreen;
    PLIST_ENTRY      entry;
    PCNP_NETWORK     network = NULL;
    KIRQL            irql;
    BOOLEAN          move = FALSE;
    BOOLEAN          setChanged = FALSE;


    CnVerifyCpuLockMask(
        CNP_NETWORK_LIST_LOCK,      // required
        0,                          // forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX // max
        );

    //
    // If the network has already been removed from the 
    // sorted list, there is no sense in resorting it.
    //
    if (CnpIsNetworkMulticastSorted(Network)) {

        //
        // Remember the current screen and count to detect
        // changes.
        //
        CnpMulticastGetReachableNodesLocked(&oldScreen, &count);

        //
        // Check if it needs to be moved up.
        //
        for (entry = Network->Linkage.Blink;
             entry != &CnpNetworkList;
             entry = entry->Blink) {

            network = CONTAINING_RECORD(entry, CNP_NETWORK, Linkage);

            if (CnpIsBetterMulticastNetwork(Network, network)) {
                move = TRUE;
            } else {
                break;
            }
        }

        if (move) {
            RemoveEntryList(&(Network->Linkage));
            InsertHeadList(entry, &(Network->Linkage));
        } else {

            //
            // Check if it needs to be moved down.
            //
            for (entry = Network->Linkage.Flink;
                 entry != &CnpNetworkList;
                 entry = entry->Flink) {

                network = CONTAINING_RECORD(entry, CNP_NETWORK, Linkage);

                if (CnpIsBetterMulticastNetwork(network, Network)) {
                    move = TRUE;
                } else {
                    break;
                }
            }

            if (move) {
                RemoveEntryList(&(Network->Linkage));
                InsertTailList(entry, &(Network->Linkage));
            }
        }

        //
        // Determine if the set of reachable nodes has changed.
        //
        CnpMulticastGetReachableNodesLocked(&newScreen, &count);

        setChanged = (BOOLEAN)
            (oldScreen.UlongScreen != newScreen.UlongScreen);
    }

    if (RaiseEvent && setChanged) {

        CnTrace(CNP_NET_DETAIL, CnpTraceMulticastReachEventSort,
            "[CNP] Issuing event for new multicast "
            "reachable set (%lx) after sorting "
            "network %u.",
            newScreen.UlongScreen,
            Network->Id
            );

        CnIssueEvent(
            ClusnetEventMulticastSet,
            newScreen.UlongScreen,
            0
            );
    }

    if (NewMcastReachableNodes != NULL) {
        *NewMcastReachableNodes = newScreen;
    }

    CnVerifyCpuLockMask(
        CNP_NETWORK_LIST_LOCK,      // required
        0,                          // forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX // max
        );

    return(setChanged);

} // CnpSortMulticastNetworkLocked


BOOLEAN
CnpMulticastChangeNodeReachabilityLocked(
    IN  PCNP_NETWORK       Network,
    IN  PCNP_NODE          Node,
    IN  BOOLEAN            Reachable,
    IN  BOOLEAN            RaiseEvent,
    OUT CX_CLUSTERSCREEN * NewMcastReachableNodes    OPTIONAL
    )
/*++

Routine Description:

    Changes the multicast reachability state of Node
    on Network.
    
    If the set of reachable nodes changes, returns
    the new screen through NewMcastReachableNodes.
    
Return value:

    TRUE if set of reachable nodes changes.
    
Notes:

    Called and returns with node lock held.
    Called and returns with network list lock held.
    
--*/
{
    KIRQL            irql;
    BOOLEAN          netSetChanged = FALSE;
    BOOLEAN          setChanged = FALSE;
    CX_CLUSTERSCREEN oldScreen;
    CX_CLUSTERSCREEN newScreen;
    ULONG            count;

    CnVerifyCpuLockMask(
        CNP_NODE_OBJECT_LOCK | CNP_NETWORK_LIST_LOCK, // required
        0,                                            // forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX                   // max
        );

    if (Reachable) {
        if (Node != CnpLocalNode) {
            if (!CnpClusterScreenMember(
                     Network->McastReachableNodes.ClusterScreen,
                     INT_NODE(Node->Id)
                     )) {
                
                //
                // Remember the current screen and count to detect
                // changes.
                //
                CnpMulticastGetReachableNodesLocked(&oldScreen, &count);

                CnpClusterScreenInsert(
                    Network->McastReachableNodes.ClusterScreen,
                    INT_NODE(Node->Id)
                    );
                Network->McastReachableCount++;
                netSetChanged = TRUE;
            }
        }
    } else {
        if (Node == CnpLocalNode) {
            
            //
            // Remember the current screen and count to detect
            // changes.
            //
            CnpMulticastGetReachableNodesLocked(&oldScreen, &count);

            //
            // The local interface on this network
            // no longer speaks multicast. Declare all 
            // other nodes unreachable.
            //
            CnpNetworkResetMcastReachableNodes(Network);
            if (Network->McastReachableCount != 0) {
                netSetChanged = TRUE;
            }
            Network->McastReachableCount = 0;
        } else {
            if (CnpClusterScreenMember(
                    Network->McastReachableNodes.ClusterScreen,
                    INT_NODE(Node->Id)
                    )) {
                
                //
                // Remember the current screen and count to detect
                // changes.
                //
                CnpMulticastGetReachableNodesLocked(&oldScreen, &count);

                CnpClusterScreenDelete(
                    Network->McastReachableNodes.ClusterScreen,
                    INT_NODE(Node->Id)
                    );
                Network->McastReachableCount--;
                netSetChanged = TRUE;
            }
        }
    }

    if (netSetChanged) {

        CnpSortMulticastNetworkLocked(Network, FALSE, &newScreen);

        setChanged = (BOOLEAN)(oldScreen.UlongScreen != newScreen.UlongScreen);
    }

    if (RaiseEvent && setChanged) {

        CnTrace(CNP_NET_DETAIL, CnpTraceMulticastReachEventReach,
            "[CNP] Issuing event for new multicast "
            "reachable set (%lx) after setting "
            "reachability for network %u to %!bool!.",
            newScreen.UlongScreen,
            Network->Id, Reachable
            );

        CnIssueEvent(
            ClusnetEventMulticastSet,
            newScreen.UlongScreen,
            0
            );
    }

    if (NewMcastReachableNodes != NULL) {
        *NewMcastReachableNodes = newScreen;
    }
    
    CnVerifyCpuLockMask(
        CNP_NODE_OBJECT_LOCK | CNP_NETWORK_LIST_LOCK, // required
        0,                                            // forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX                   // max
        );

    return(setChanged);

} // CnpMulticastChangeNodeReachabilityLocked


PCNP_NETWORK
CnpLockedFindNetwork(
    IN CL_NETWORK_ID  NetworkId,
    IN CN_IRQL        ListIrql
    )
/*++

Routine Description:

    Searches the network list for a specified network object.

Arguments:

    NetworkId   - The ID of the network object to locate.

    ListIrql    - The IRQL level at which the network list lock was
                  acquired before calling this routine.

Return Value:

    A pointer to the requested network object, if it exists.
    NULL otherwise.

Notes:

    Called with CnpNetworkListLock held.
    Returns with CnpNetworkListLock released.
    If return value is non-NULL, returns with network object lock held.

--*/
{
    PLIST_ENTRY        entry;
    CN_IRQL            networkIrql;
    PCNP_NETWORK       network = NULL;


    CnVerifyCpuLockMask(
        CNP_NETWORK_LIST_LOCK,           // Required
        0,                               // Forbidden
        CNP_NETWORK_LIST_LOCK_MAX        // Maximum
        );

    for (entry = CnpNetworkList.Flink;
         entry != &CnpNetworkList;
         entry = entry->Flink
        )
    {
        network = CONTAINING_RECORD(entry, CNP_NETWORK, Linkage);

        CnAcquireLock(&(network->Lock), &networkIrql);

        if (NetworkId == network->Id) {
            CnReleaseLock(&CnpNetworkListLock, networkIrql);
            network->Irql = ListIrql;

            CnVerifyCpuLockMask(
                CNP_NETWORK_OBJECT_LOCK,          // Required
                CNP_NETWORK_LIST_LOCK,            // Forbidden
                CNP_NETWORK_OBJECT_LOCK_MAX       // Maximum
                );

            return(network);
        }

        CnReleaseLock(&(network->Lock), networkIrql);
    }

    CnReleaseLock(&CnpNetworkListLock, ListIrql);

    CnVerifyCpuLockMask(
        0,                                                    // Required
        (CNP_NETWORK_LIST_LOCK | CNP_NETWORK_OBJECT_LOCK),    // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX                              // Maximum
        );

    return(NULL);

}  // CnpLockedFindNetwork




VOID
CnpOfflineNetwork(
    PCNP_NETWORK    Network
    )
/*++

Notes:

    Called with network object lock held.
    Returns with network object lock released.
    May not be called while holding any higher-ranked locks.

--*/
{
    CnVerifyCpuLockMask(
        CNP_NETWORK_OBJECT_LOCK,               // Required
        (ULONG) ~(CNP_NETWORK_OBJECT_LOCK),    // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX            // Maximum
        );

    CnAssert(Network->State >= ClusnetNetworkStateOnlinePending);

    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT((
            "[CNP] Offline of network %u pending....\n",
            Network->Id
            ));
    }

    Network->State = ClusnetNetworkStateOfflinePending;

    CnReleaseLock(&(Network->Lock), Network->Irql);

    CnTrace(
        CNP_NET_DETAIL, CnpTraceNetworkOfflinePending,
        "[CNP] Offline of network %u pending.",
        Network->Id
        );

    //
    // If the network is still on the sorted network list,
    // re-sort.
    //
    CnpSortMulticastNetwork(Network, TRUE, NULL);

    //
    // Take all of the interfaces on this network offline.
    //
    // Note that the network cannot go away while we do this
    // because we still hold an active reference on it.
    //
    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT((
            "[CNP] Taking all interfaces on network %u offline...\n",
            Network->Id
            ));
    }

    CnpWalkInterfacesOnNetwork(Network, CnpOfflineInterfaceWrapper);

    CnAcquireLock(&(Network->Lock), &(Network->Irql));

    //
    // Remove the initial active reference. When the active
    // reference count goes to zero, the network will be taken
    // offline and the irp completed.
    //
    // The network object lock will be released by
    // the dereference.
    //
    CnpActiveDereferenceNetwork(Network);

    CnVerifyCpuLockMask(
        0,                                 // Required
        0xFFFFFFFF,                        // Forbidden
        0                                  // Maximum
        );

    return;

}  // CnpOfflineNetwork



VOID
CnpOfflineNetworkWorkRoutine(
    IN PVOID  Parameter
    )
/*++

Routine Description:

    Performs the actual work involved in taking a network offline.
    This routine runs in the context of an ExWorkerThread.

Arguments:

    Parameter - A pointer to the network object on which to operate.

Return Value:

    None.

--*/

{
    NTSTATUS             status;
    HANDLE               handle = NULL;
    PFILE_OBJECT         fileObject = NULL;
    PIRP                 offlineIrp;
    PCNP_NETWORK         network = Parameter;


    CnAssert(KeGetCurrentIrql() == PASSIVE_LEVEL);
    CnAssert(network->State == ClusnetNetworkStateOfflinePending);
    CnAssert(CnSystemProcess == (PKPROCESS) IoGetCurrentProcess());

    CnAcquireLock(&(network->Lock), &(network->Irql));

    handle = network->DatagramHandle;
    network->DatagramHandle = NULL;

    fileObject = network->DatagramFileObject;
    network->DatagramFileObject = NULL;

    network->DatagramDeviceObject = NULL;

    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT(("[CNP] Taking network %u offline...\n", network->Id));
    }

    CnReleaseLock(&(network->Lock), network->Irql);

    CnTrace(CNP_NET_DETAIL, CnpTraceNetworkTakingOffline,
        "[CNP] Taking network %u offline, dgram handle %p, "
        "dgram fileobj %p.",
        network->Id, // LOGULONG
        handle, // LOGHANDLE
        fileObject // LOGPTR
        );                

    if (fileObject != NULL) {
        ObDereferenceObject(fileObject);
    }

    if (handle != NULL) {

        status = ZwClose(handle);
        IF_CNDBG(CN_DEBUG_CONFIG) {
            if (!NT_SUCCESS(status)) {
                CNPRINT(("[CNP] Failed to close handle for network %u, "
                         "status %lx.\n",
                         network->Id, status));
            }
        }
        CnAssert(NT_SUCCESS(status));
        
        CnTrace(CNP_NET_DETAIL, CnpTraceNetworkClosed,
            "[CNP] Closed handle %p for network ID %u, status %!status!",
            handle, // LOGHANDLE
            network->Id, // LOGULONG
            status // LOGSTATUS
            );                
    }

    CnAcquireLock(&(network->Lock), &(network->Irql));

    CnAssert(network->State == ClusnetNetworkStateOfflinePending);

    network->State = ClusnetNetworkStateOffline;

    offlineIrp = network->PendingOfflineIrp;
    network->PendingOfflineIrp = NULL;

    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT(("[CNP] Network %u is now offline.\n", network->Id));
    }

    //
    // Remove the active reference from the base refcount.
    // This releases the network object lock.
    //
    CnpDereferenceNetwork(network);

    if (offlineIrp != NULL) {
        CN_IRQL              cancelIrql;

        CnAcquireCancelSpinLock(&cancelIrql);
        offlineIrp->CancelIrql = cancelIrql;

        CnCompletePendingRequest(offlineIrp, STATUS_SUCCESS, 0);
    }

    CnAssert(KeGetCurrentIrql() == PASSIVE_LEVEL);

    return;

} // CnpOfflineNetworkWorkRoutine


VOID
CnpDeleteNetwork(
    PCNP_NETWORK  Network,
    CN_IRQL       NetworkListIrql
    )
/*++

Notes:

    Called with the CnpNetworkListLock and network object lock held.
    Returns with both locks released.

--*/

{
    NTSTATUS           status;
    ULONG              i;
    PCNP_INTERFACE     interface;
    CL_NETWORK_ID      networkId = Network->Id;


    CnVerifyCpuLockMask(
        (CNP_NETWORK_LIST_LOCK | CNP_NETWORK_OBJECT_LOCK),  // Required
        0,                                                  // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX                         // Maximum
        );

    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT(("[CNP] Deleting network %u\n", Network->Id));
    }

    //
    // Move the network to the deleting list. Once we do this,
    // no new threads can reference the network object.
    //
    CnpRemoveNetworkListEntryLocked(Network, TRUE, NULL);
    InsertTailList(&CnpDeletingNetworkList, &(Network->Linkage));

    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT((
            "[CNP] Moved network %u to deleting list\n",
            Network->Id
            ));
    }

    CnReleaseLockFromDpc(&CnpNetworkListLock);
    Network->Irql = NetworkListIrql;

    Network->Flags |= CNP_NET_FLAG_DELETING;

    if (Network->State >= ClusnetNetworkStateOnlinePending) {
        //
        // Take the network offline. This will force all of the
        // associated interfaces offline as well.
        //
        // This will release the network object lock.
        //
        CnpOfflineNetwork(Network);
    }
    else {
        CnReleaseLock(&(Network->Lock), Network->Irql);
    }

    //
    // Delete all the interfaces on this network.
    //
    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT((
            "[CNP] Deleting all interfaces on network %u...\n",
            Network->Id
            ));
    }

    CnpWalkInterfacesOnNetwork(Network, CnpDeleteInterface);

    //
    // Remove the initial reference on the object. The object will be
    // destroyed when the reference count goes to zero. The delete irp
    // will be completed at that time.
    //
    CnAcquireLock(&(Network->Lock), &(Network->Irql));

    CnpDereferenceNetwork(Network);

    CnVerifyCpuLockMask(
        0,                                                    // Required
        (CNP_NETWORK_OBJECT_LOCK | CNP_NETWORK_OBJECT_LOCK),  // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX                              // Maximum
        );

    return;

} // CnpDeleteNework


VOID
CnpDestroyNetworkWorkRoutine(
    IN PVOID  Parameter
    )
/*++

Routine Description:

    Performs the actual work involved in destroying a network.
    This routine runs in the context of an ExWorkerThread.

Arguments:

    Parameter - A pointer to the network object on which to operate.

Return Value:

    None.

--*/
{
    PLIST_ENTRY    entry;
    CN_IRQL        listIrql;
    BOOLEAN        setCleanupEvent = FALSE;
    PCNP_NETWORK   network = Parameter;


    CnAssert(KeGetCurrentIrql() == PASSIVE_LEVEL);
    CnAssert(network->State == ClusnetNetworkStateOffline);
    CnAssert(CnSystemProcess == (PKPROCESS) IoGetCurrentProcess());

    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT(("[CNP] Destroying network %u\n", network->Id));
    }

    CnAcquireLock(&CnpNetworkListLock, &listIrql);

#if DBG
    {
        PCNP_NETWORK   oldNetwork = NULL;

        //
        // Verify that the network object is on the deleting list.
        //
        for (entry = CnpDeletingNetworkList.Flink;
             entry != &CnpDeletingNetworkList;
             entry = entry->Flink
            )
        {
            oldNetwork = CONTAINING_RECORD(entry, CNP_NETWORK, Linkage);

            if (oldNetwork == network) {
                break;
            }
        }

        CnAssert(oldNetwork == network);
    }
#endif // DBG

    RemoveEntryList(&(network->Linkage));

    if (CnpIsNetworkShutdownPending) {
        if (IsListEmpty(&CnpDeletingNetworkList)) {
            setCleanupEvent = TRUE;
        }
    }

    CnReleaseLock(&CnpNetworkListLock, listIrql);

    if (network->PendingDeleteIrp != NULL) {
        CnAcquireCancelSpinLock(&(network->PendingDeleteIrp->CancelIrql));

        CnCompletePendingRequest(
            network->PendingDeleteIrp,
            STATUS_SUCCESS,
            0
            );

        //
        // The IoCancelSpinLock was released by CnCompletePendingRequest()
        //
    }

    if (network->CurrentMcastGroup != NULL) {
        CnpDereferenceMulticastGroup(network->CurrentMcastGroup);
        network->CurrentMcastGroup = NULL;
    }

    if (network->PreviousMcastGroup != NULL) {
        CnpDereferenceMulticastGroup(network->PreviousMcastGroup);
        network->PreviousMcastGroup = NULL;
    }

    CnFreePool(network);

    if (setCleanupEvent) {
        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[CNP] Setting network cleanup event.\n"));
        }

        KeSetEvent(CnpNetworkShutdownEvent, 0, FALSE);
    }

    CnAssert(KeGetCurrentIrql() == PASSIVE_LEVEL);

    return;

}  // CnpDestroyNetworkWorkRoutine



//
// Routines exported within CNP
//
PCNP_NETWORK
CnpFindNetwork(
    IN CL_NETWORK_ID  NetworkId
    )
/*++

Notes:

--*/
{
    CN_IRQL   listIrql;


    CnAcquireLock(&CnpNetworkListLock, &listIrql);

    return(CnpLockedFindNetwork(NetworkId, listIrql));

}  // CnpFindNetwork



VOID
CnpReferenceNetwork(
    PCNP_NETWORK  Network
    )
/*++

Notes:

    Called with network object lock held.

--*/
{
    CnAssert(Network->RefCount != 0xFFFFFFFF);

    CnVerifyCpuLockMask(
        CNP_NETWORK_OBJECT_LOCK,      // Required
        0,                            // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX   // Maximum
        );

    Network->RefCount++;

    IF_CNDBG(CN_DEBUG_CNPREF) {
        CNPRINT((
            "[CNP] Referencing network %u, new refcount %u\n",
            Network->Id,
            Network->RefCount
            ));
    }

    return;

}  // CnpReferenceNetwork



VOID
CnpDereferenceNetwork(
    PCNP_NETWORK  Network
    )
/*++

Notes:

    Called with network object lock held.
    Returns with network object lock released.

    Sometimes called with a node object lock held as well.

--*/
{
    PLIST_ENTRY    entry;
    CN_IRQL        listIrql;
    BOOLEAN        setCleanupEvent = FALSE;
    ULONG          newRefCount;
    PCNP_NETWORK   network;


    CnVerifyCpuLockMask(
        CNP_NETWORK_OBJECT_LOCK,      // Required
        0,                            // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX   // Maximum
        );

    CnAssert(Network->RefCount != 0);

    newRefCount = --(Network->RefCount);

    IF_CNDBG(CN_DEBUG_CNPREF) {
        CNPRINT((
            "[CNP] Dereferencing network %u, new refcount %u\n",
            Network->Id,
            Network->RefCount
            ));
    }

    CnReleaseLock(&(Network->Lock), Network->Irql);

    if (newRefCount > 0) {

        CnVerifyCpuLockMask(
            0,                            // Required
            CNP_NETWORK_OBJECT_LOCK,      // Forbidden
            CNP_NETWORK_LIST_LOCK_MAX     // Maximum
            );

        return;
    }

    CnAssert(Network->ActiveRefCount == 0);
    CnAssert(Network->State == ClusnetNetworkStateOffline);
    CnAssert(Network->DatagramHandle == NULL);

    //
    // Schedule an ExWorkerThread to destroy the network.
    // We do this because we don't know if a higher-level lock,
    // such as a node object lock, is held when this routine is
    // called. We may need to acquire the IoCancelSpinLock,
    // which must be acquired before a node lock, in
    // order to complete a deregister Irp.
    //
    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT((
            "[CNP] Posting destroy work item for network %u.\n",
            Network->Id
            ));
    }

    ExInitializeWorkItem(
        &(Network->ExWorkItem),
        CnpDestroyNetworkWorkRoutine,
        Network
        );

    ExQueueWorkItem(&(Network->ExWorkItem), DelayedWorkQueue);

    CnVerifyCpuLockMask(
        0,                            // Required
        CNP_NETWORK_OBJECT_LOCK,      // Forbidden
        CNP_NETWORK_LIST_LOCK_MAX     // Maximum
        );

    return;

}  // CnpDereferenceNetwork



VOID
CnpActiveReferenceNetwork(
    PCNP_NETWORK  Network
    )
/*++

Notes:

    Called with network object lock held.

--*/
{
    CnVerifyCpuLockMask(
        CNP_NETWORK_OBJECT_LOCK,      // Required
        0,                            // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX   // Maximum
        );

    CnAssert(Network->ActiveRefCount != 0xFFFFFFFF);
    CnAssert(Network->RefCount != 0);

    Network->ActiveRefCount++;

    return;

}  // CnpActiveReferenceNetwork



VOID
CnpActiveDereferenceNetwork(
    PCNP_NETWORK   Network
    )
/*++

Notes:

    Called with network object lock held.
    Returns with network object lock released.

--*/
{
    ULONG                newRefCount;


    CnVerifyCpuLockMask(
        CNP_NETWORK_OBJECT_LOCK,      // Required
        0,                            // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX   // Maximum
        );

    CnAssert(Network->ActiveRefCount != 0);
    CnAssert(Network->State != ClusnetNetworkStateOffline);

    newRefCount = --(Network->ActiveRefCount);

    CnReleaseLock(&(Network->Lock), Network->Irql);

    if (newRefCount > 0) {

        CnVerifyCpuLockMask(
            0,                            // Required
            CNP_NETWORK_OBJECT_LOCK,      // Forbidden
            CNP_NETWORK_LIST_LOCK_MAX     // Maximum
            );

        return;
    }

    //
    // The network's active reference count has gone to zero.
    //
    CnAssert(Network->State == ClusnetNetworkStateOfflinePending);

    //
    // Schedule an ExWorkerThread to take the network offline.
    // We do this because we don't know if a higher-level lock,
    // such as a node object lock, is held when this routine is
    // called. The base transport file handle must be closed at
    // PASSIVE_LEVEL. We may also need to acquire the IoCancelSpinLock
    // in order to complete an Offline Irp.
    //
    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT((
            "[CNP] Posting offline work item for network %u.\n",
            Network->Id
            ));
    }

    CnTrace(
        CNP_NET_DETAIL, CnpTraceNetworkSchedulingOffline,
        "[CNP] Scheduling offline of network %u.",
        Network->Id
        );                

    ExInitializeWorkItem(
        &(Network->ExWorkItem),
        CnpOfflineNetworkWorkRoutine,
        Network
        );

    ExQueueWorkItem(&(Network->ExWorkItem), DelayedWorkQueue);

    CnVerifyCpuLockMask(
        0,                            // Required
        CNP_NETWORK_OBJECT_LOCK,      // Forbidden
        CNP_NETWORK_LIST_LOCK_MAX     // Maximum
        );

    return;

}  // CnpActiveDereferenceNetwork


NTSTATUS
CnpAllocateMulticastGroup(
    IN  ULONG                     Brand,
    IN  PTRANSPORT_ADDRESS        TdiMulticastAddress,
    IN  ULONG                     TdiMulticastAddressLength,
    IN  PVOID                     Key,
    IN  ULONG                     KeyLength,
    IN  PVOID                     Salt,
    IN  ULONG                     SaltLength,
    OUT PCNP_MULTICAST_GROUP    * Group
    )
/*++

Routine Description:

    Allocates and initializes a network multicast group
    structure.

--*/
{
    PCNP_MULTICAST_GROUP group;
    ULONG                groupSize;
    UCHAR                keyBuffer[DES_BLOCKLEN];
    PUCHAR               key;

    //
    // Allocate the data structure.
    //
    groupSize = sizeof(CNP_MULTICAST_GROUP);
    
    if (TdiMulticastAddressLength != 0) {
        groupSize = ROUND_UP_COUNT(groupSize, 
                                   TYPE_ALIGNMENT(TRANSPORT_ADDRESS)) +
                    TdiMulticastAddressLength;
    }

    if (KeyLength != 0) {
        groupSize = ROUND_UP_COUNT(groupSize, TYPE_ALIGNMENT(PVOID)) +
                    KeyLength;
    }

    if (SaltLength != 0) {
        groupSize = ROUND_UP_COUNT(groupSize, TYPE_ALIGNMENT(PVOID)) +
                    SaltLength;
    }
    group = CnAllocatePool(groupSize);
    if (group == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
                   
    //
    // Fill in parameter fields.
    //
    group->McastNetworkBrand = Brand;
    
    group->McastTdiAddress = (PTRANSPORT_ADDRESS)
        ROUND_UP_POINTER((PUCHAR)group + sizeof(CNP_MULTICAST_GROUP),
                         TYPE_ALIGNMENT(TRANSPORT_ADDRESS));
    group->McastTdiAddressLength = TdiMulticastAddressLength;
    RtlCopyMemory(
        group->McastTdiAddress,
        TdiMulticastAddress,
        TdiMulticastAddressLength
        );

    group->Key = (PVOID)
        ROUND_UP_POINTER((PUCHAR)group->McastTdiAddress 
                         + TdiMulticastAddressLength,
                         TYPE_ALIGNMENT(PVOID));
    group->KeyLength = KeyLength;
    RtlCopyMemory(
        group->Key,
        Key,
        KeyLength
        );

    group->Salt = (PVOID)
        ROUND_UP_POINTER((PUCHAR)group->Key + KeyLength,
                         TYPE_ALIGNMENT(PVOID));
    group->SaltLength = SaltLength;
    RtlCopyMemory(
        group->Salt,
        Salt,
        SaltLength
        );

    //
    // Build the DES key table for encryption and decryption.
    // If the provided key is not long enough, pad it by 
    // repeating the salt.
    //
    // Skip these steps if there is no key or salt.
    //
    if (KeyLength > 0 && SaltLength > 0) {

        SecBufferDesc sigBufDesc;
        SecBuffer     sigBuf;
        NTSTATUS      status;

        if (KeyLength < DES_BLOCKLEN) {
            ULONG resid, offset;
            RtlCopyMemory(&keyBuffer[0], Key, KeyLength);
            resid = DES_BLOCKLEN - KeyLength;
            offset = KeyLength;
            while (resid > 0) {
                ULONG copyLen = (KeyLength < resid) ? KeyLength : resid;
                RtlCopyMemory(
                    &keyBuffer[offset],
                    Salt,
                    copyLen
                    );
                resid -= copyLen;
                offset += copyLen;
            }
            key = &keyBuffer[0];
        } else {
            key = Key;
        }
        CxFipsFunctionTable.FipsDesKey(&group->DesTable, key);

        group->SignatureLength = CX_SIGNATURE_LENGTH;
    }

    //
    // Set the initial refcount to 1.
    //
    group->RefCount = 1;

    *Group = group;

    return(STATUS_SUCCESS);

} // CnpAllocateMulticastGroup


VOID
CnpFreeMulticastGroup(
    IN PCNP_MULTICAST_GROUP Group
    )
{
    if (Group != NULL) {
        CnFreePool(Group);
    }

    return;

} // CnpFreeMulticastGroup
    

NTSTATUS
CnpConfigureBasicMulticastSettings(
    IN  HANDLE             Handle,
    IN  PFILE_OBJECT       FileObject,
    IN  PDEVICE_OBJECT     DeviceObject,
    IN  PTDI_ADDRESS_INFO  TdiBindAddressInfo,
    IN  ULONG              McastTtl,
    IN  UCHAR              McastLoop,
    IN  PIRP               Irp
    )
/*++

Routine Description:

    Set basic multicast parameters on the address object 
    represented by Handle, FileObject, and DeviceObject 
    using the interface represented by TdiBindAddressInfo.
    
Notes:

    This routine attaches to the system process when using
    handles, so it should not be called pre-attached.
    
--*/
{
    UDPMCastIFReq     mcastIfReq;
    ULONG             ifBindIp;
    BOOLEAN           attached = FALSE;

    NTSTATUS          status;

    //
    // Set this interface for outgoing multicast traffic.
    //
    ifBindIp = *((ULONG UNALIGNED *)
                 (&(((PTA_IP_ADDRESS)&(TdiBindAddressInfo->Address))
                   ->Address[0].Address[0].in_addr)
                  )
                 );

    mcastIfReq.umi_addr = ifBindIp;

    KeAttachProcess(CnSystemProcess);
    attached = TRUE;

    status = CnpSetTcpInfoEx(
                 Handle,
                 CL_TL_ENTITY,
                 INFO_CLASS_PROTOCOL,
                 INFO_TYPE_ADDRESS_OBJECT,
                 AO_OPTION_MCASTIF,
                 &mcastIfReq,
                 sizeof(mcastIfReq)
                 );

    IF_CNDBG(CN_DEBUG_NETOBJ) {
        CNPRINT(("[CNP] Set mcast interface for "
                 "AO handle %p, IF %d.%d.%d.%d, status %x.\n",
                 Handle,
                 CnpIpAddrPrintArgs(ifBindIp),
                 status
                 ));
    }

    if (!NT_SUCCESS(status)) {
        goto error_exit;
    }
    
    status = CnpSetTcpInfoEx(
                 Handle,
                 CL_TL_ENTITY,
                 INFO_CLASS_PROTOCOL,
                 INFO_TYPE_ADDRESS_OBJECT,
                 AO_OPTION_MCASTTTL,
                 &McastTtl,
                 sizeof(McastTtl)
                 );

    IF_CNDBG(CN_DEBUG_NETOBJ) {
        CNPRINT(("[CNP] Set mcast TTL to %d on "
                 "AO handle %p, IF %d.%d.%d.%d, "
                 "status %x.\n",
                 McastTtl,
                 Handle,
                 CnpIpAddrPrintArgs(ifBindIp),
                 status
                 ));
    }
    
    if (!NT_SUCCESS(status)) {
        goto error_exit;
    }

    status = CnpSetTcpInfoEx(
                 Handle,
                 CL_TL_ENTITY,
                 INFO_CLASS_PROTOCOL,
                 INFO_TYPE_ADDRESS_OBJECT,
                 AO_OPTION_MCASTLOOP,
                 &McastLoop,
                 sizeof(McastLoop)
                 );

    IF_CNDBG(CN_DEBUG_NETOBJ) {
        CNPRINT(("[CNP] Set mcast loopback flag to %d on "
                 "AO handle %p, IF %d.%d.%d.%d, status %x.\n",
                 McastLoop,
                 Handle,
                 CnpIpAddrPrintArgs(ifBindIp),
                 status
                 ));
    }
    
    if (!NT_SUCCESS(status)) {
        goto error_exit;
    }

error_exit:

    if (attached) {
        KeDetachProcess();
        attached = FALSE;
    }

    return(status);

}  // CnpConfigureBasicMulticastSettings


NTSTATUS
CnpAddRemoveMulticastAddress(
    IN  HANDLE             Handle,
    IN  PFILE_OBJECT       FileObject,
    IN  PDEVICE_OBJECT     DeviceObject,
    IN  PTDI_ADDRESS_INFO  TdiBindAddressInfo,
    IN  PTRANSPORT_ADDRESS TdiMcastBindAddress,
    IN  ULONG              OpId,
    IN  PIRP               Irp
    )
/*++

Routine Description:

    Add or remove the multicast address specified by
    TdiMcastBindAddress from the interface specified
    by TdiBindAddressInfo.
    
Arguments:

    OpId - either AO_OPTION_ADD_MCAST or AO_OPTION_DEL_MCAST
    
Notes:

    This routine attaches to the system process when using
    handles, so it should not be called pre-attached.
    
--*/
{
    UDPMCastReq    mcastAddDelReq;
    ULONG          mcastBindIp;
    ULONG          ifBindIp;
    BOOLEAN        attached = FALSE;

    NTSTATUS       status;
    
    mcastBindIp = *((ULONG UNALIGNED *)
                    (&(((PTA_IP_ADDRESS)TdiMcastBindAddress)
                       ->Address[0].Address[0].in_addr)
                     )
                    );
    ifBindIp = *((ULONG UNALIGNED *)
                 (&(((PTA_IP_ADDRESS)&(TdiBindAddressInfo->Address))
                    ->Address[0].Address[0].in_addr)
                  )
                 );

    mcastAddDelReq.umr_addr = mcastBindIp;
    mcastAddDelReq.umr_if = ifBindIp;

    KeAttachProcess(CnSystemProcess);
    attached = TRUE;

    status = CnpSetTcpInfoEx(
                 Handle,
                 CL_TL_ENTITY,
                 INFO_CLASS_PROTOCOL,
                 INFO_TYPE_ADDRESS_OBJECT,
                 OpId,
                 &mcastAddDelReq,
                 sizeof(mcastAddDelReq)
                 );

    IF_CNDBG(CN_DEBUG_NETOBJ) {
        CNPRINT(("[CNP] Adjusted mcast binding on "
                 "interface for AO handle %p, "
                 "IF %d.%d.%d.%d, mcast addr %d.%d.%d.%d, "
                 "OpId %d, status %x.\n",
                 Handle,
                 CnpIpAddrPrintArgs(ifBindIp),
                 CnpIpAddrPrintArgs(mcastBindIp),
                 OpId,
                 status
                 ));
    }
    
    if (!NT_SUCCESS(status)) {
        goto error_exit;
    }

error_exit:

    if (attached) {
        KeDetachProcess();
        attached = FALSE;
    }

    return(status);

} // CnpAddRemoveMulticastAddress


VOID
CnpStartInterfaceMcastTransition(
    PCNP_INTERFACE  Interface
    )
/*++

Routine Description:

    Called during a multicast group transition. Clears
    the multicast received flag and enables discovery.

Arguments:

    Interface - A pointer to the interface to change.

Return Value:

    None.

Notes:

    Conforms to the calling convention for 
    PCNP_INTERFACE_UPDATE_ROUTINE.
    
    Called with associated node and network locks held.
    Returns with network lock released.

--*/
{
    if (Interface->Node != CnpLocalNode) {
        CnpInterfaceClearReceivedMulticast(Interface);
        Interface->McastDiscoverCount = CNP_INTERFACE_MCAST_DISCOVERY;
    }

    CnReleaseLock(&(Interface->Network->Lock), Interface->Network->Irql);

    return;

} // CnpStartInterfaceMcastTransition



//
// Cluster Transport Public Routines
//
NTSTATUS
CnpLoadNetworks(
    VOID
    )
/*++

Routine Description:

    Called when the Cluster Network driver is loading. Initializes
    static network-related data structures.

Arguments:

    None.

Return Value:

    None.

--*/
{
    InitializeListHead(&CnpNetworkList);
    InitializeListHead(&CnpDeletingNetworkList);
    CnInitializeLock(&CnpNetworkListLock, CNP_NETWORK_LIST_LOCK);

    return(STATUS_SUCCESS);

} // CnpLoadNetworks


NTSTATUS
CnpInitializeNetworks(
    VOID
    )
/*++

Routine Description:

    Called when the Cluster Network driver is being (re)initialized.
    Initializes dynamic network-related data structures.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PAGED_CODE();


    CnAssert(CnpNetworkShutdownEvent == NULL);
    CnAssert(IsListEmpty(&CnpNetworkList));
    CnAssert(IsListEmpty(&CnpDeletingNetworkList));

    CnpNetworkShutdownEvent = CnAllocatePool(sizeof(KEVENT));

    if (CnpNetworkShutdownEvent == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    KeInitializeEvent(CnpNetworkShutdownEvent, NotificationEvent, FALSE);
    CnpIsNetworkShutdownPending = FALSE;

    return(STATUS_SUCCESS);

} // CnpInitializeNetworks



VOID
CnpShutdownNetworks(
    VOID
    )
/*++

Routine Description:

    Called when a shutdown request is issued to the Cluster Network
    Driver. Deletes all network objects.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PLIST_ENTRY   entry;
    CN_IRQL       listIrql;
    CN_IRQL       networkIrql;
    PCNP_NETWORK  network;
    NTSTATUS      status;
    BOOLEAN       waitEvent = FALSE;


    if (CnpNetworkShutdownEvent != NULL) {

        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[CNP] Cleaning up networks...\n"));
        }

        CnAcquireLock(&CnpNetworkListLock, &listIrql);

        while (!IsListEmpty(&CnpNetworkList)) {

            entry = CnpNetworkList.Flink;

            network = CONTAINING_RECORD(entry, CNP_NETWORK, Linkage);

            CnAcquireLockAtDpc(&(network->Lock));
            network->Irql = DISPATCH_LEVEL;

            CnpDeleteNetwork(network, listIrql);

            //
            // Both locks were released.
            //

            CnAcquireLock(&CnpNetworkListLock, &listIrql);
        }

        if (!IsListEmpty(&CnpDeletingNetworkList)) {
            CnpIsNetworkShutdownPending = TRUE;
            waitEvent = TRUE;
            KeResetEvent(CnpNetworkShutdownEvent);
        }

        CnReleaseLock(&CnpNetworkListLock, listIrql);

        if (waitEvent) {
            IF_CNDBG(CN_DEBUG_INIT) {
                CNPRINT(("[CNP] Network deletes are pending...\n"));
            }

            status = KeWaitForSingleObject(
                         CnpNetworkShutdownEvent,
                         Executive,
                         KernelMode,
                         FALSE,        // not alertable
                         NULL          // no timeout
                         );

            CnAssert(status == STATUS_SUCCESS);
        }

        CnAssert(IsListEmpty(&CnpNetworkList));
        CnAssert(IsListEmpty(&CnpDeletingNetworkList));

        CnFreePool(CnpNetworkShutdownEvent); CnpNetworkShutdownEvent = NULL;

        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[CNP] Networks cleaned up.\n"));
        }

    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return;
}



NTSTATUS
CxRegisterNetwork(
    CL_NETWORK_ID       NetworkId,
    ULONG               Priority,
    BOOLEAN             Restricted
    )
{
    NTSTATUS           status = STATUS_SUCCESS;
    PLIST_ENTRY        entry;
    CN_IRQL            listIrql;
    PCNP_NETWORK       network = NULL;


    if (!CnpIsValidNetworkId(NetworkId)) {
        return(STATUS_CLUSTER_INVALID_NETWORK);
    }

    //
    // Allocate and initialize a network object.
    //
    network = CnAllocatePool(sizeof(CNP_NETWORK));

    if (network == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlZeroMemory(network, sizeof(CNP_NETWORK));

    CN_INIT_SIGNATURE(network, CNP_NETWORK_SIG);
    network->RefCount = 1;
    network->Id = NetworkId;
    network->State = ClusnetNetworkStateOffline;
    network->Priority = Priority;

    if (Restricted) {
        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT(("[CNP] Registering network %u as restricted\n", NetworkId));
        }
        network->Flags |= CNP_NET_FLAG_RESTRICTED;
    }
    else {
        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT(("[CNP] Registering network %u as unrestricted\n", NetworkId));
        }
    }

    CnpNetworkResetMcastReachableNodes(network);

    CnInitializeLock(&(network->Lock), CNP_NETWORK_OBJECT_LOCK);

    CnAcquireLock(&CnpNetworkListLock, &listIrql);

    //
    // Check if the specified network already exists.
    //
    for (entry = CnpNetworkList.Flink;
         entry != &CnpNetworkList;
         entry = entry->Flink
        )
    {
        PCNP_NETWORK  oldNetwork = CONTAINING_RECORD(
                                       entry,
                                       CNP_NETWORK,
                                       Linkage
                                       );

        CnAcquireLock(&(oldNetwork->Lock), &(oldNetwork->Irql));

        if (NetworkId == oldNetwork->Id) {
            CnReleaseLock(&(oldNetwork->Lock), oldNetwork->Irql);
            CnReleaseLock(&CnpNetworkListLock, listIrql);

            status = STATUS_CLUSTER_NETWORK_EXISTS;

            IF_CNDBG(CN_DEBUG_CONFIG) {
                CNPRINT(("[CNP] Network %u already exists\n", NetworkId));
            }

            goto error_exit;
        }

        CnReleaseLock(&(oldNetwork->Lock), oldNetwork->Irql);
    }

    InsertTailList(&CnpNetworkList, &(network->Linkage));
    network->Flags |= CNP_NET_FLAG_MCASTSORTED;

    CnReleaseLock(&CnpNetworkListLock, listIrql);

    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT(("[CNP] Registered network %u\n", NetworkId));
    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(STATUS_SUCCESS);


error_exit:

    if (network != NULL) {
        CnFreePool(network);
    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(status);

} // CxRegisterNetwork



VOID
CxCancelDeregisterNetwork(
    PDEVICE_OBJECT   DeviceObject,
    PIRP             Irp
    )
/*++

Routine Description:

    Cancellation handler for DeregisterNetwork requests.

Return Value:

    None.

Notes:

    Called with cancel spinlock held.
    Returns with cancel spinlock released.

--*/

{
    PFILE_OBJECT   fileObject;
    CN_IRQL        cancelIrql = Irp->CancelIrql;
    PLIST_ENTRY    entry;
    PCNP_NETWORK   network;


    CnMarkIoCancelLockAcquired();

    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT((
            "[CNP] Attempting to cancel DeregisterNetwork irp %p\n",
            Irp
            ));
    }

    CnAssert(DeviceObject == CnDeviceObject);

    fileObject = CnBeginCancelRoutine(Irp);

    CnAcquireLockAtDpc(&CnpNetworkListLock);

    CnReleaseCancelSpinLock(DISPATCH_LEVEL);

    //
    // We can only complete the irp if we can find it stashed in a
    // deleting network object. The deleting network object could have
    // been destroyed and the IRP completed before we acquired the
    // CnpNetworkListLock.
    //
    for (entry = CnpDeletingNetworkList.Flink;
         entry != &CnpDeletingNetworkList;
         entry = entry->Flink
        )
    {
        network = CONTAINING_RECORD(entry, CNP_NETWORK, Linkage);

        if (network->PendingDeleteIrp == Irp) {
            IF_CNDBG(CN_DEBUG_CONFIG) {
                CNPRINT((
                    "[CNP] Found dereg irp on network %u\n",
                    network->Id
                    ));
            }

            //
            // Found the Irp. Now take it away and complete it.
            //
            network->PendingDeleteIrp = NULL;

            CnReleaseLock(&CnpNetworkListLock, cancelIrql);

            CnAcquireCancelSpinLock(&(Irp->CancelIrql));

            CnEndCancelRoutine(fileObject);

            CnCompletePendingRequest(Irp, STATUS_CANCELLED, 0);

            //
            // IoCancelSpinLock was released by CnCompletePendingRequest().
            //

            CnVerifyCpuLockMask(
                0,                  // Required
                0xFFFFFFFF,         // Forbidden
                0                   // Maximum
                );

            return;
        }
    }

    CnReleaseLock(&CnpNetworkListLock, cancelIrql);

    CnAcquireCancelSpinLock(&cancelIrql);

    CnEndCancelRoutine(fileObject);

    CnReleaseCancelSpinLock(cancelIrql);

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return;

}  // CnpCancelApiDeregisterNetwork



NTSTATUS
CxDeregisterNetwork(
    IN CL_NETWORK_ID       NetworkId,
    IN PIRP                Irp,
    IN PIO_STACK_LOCATION  IrpSp
    )
{
    NTSTATUS           status;
    PLIST_ENTRY        entry;
    CN_IRQL            irql;
    PCNP_NETWORK       network = NULL;


    CnAcquireCancelSpinLock(&irql);
    CnAcquireLockAtDpc(&CnpNetworkListLock);

    status = CnMarkRequestPending(Irp, IrpSp, CxCancelDeregisterNetwork);

    CnReleaseCancelSpinLock(DISPATCH_LEVEL);

    if (status != STATUS_CANCELLED) {
        CnAssert(status == STATUS_SUCCESS);

        for (entry = CnpNetworkList.Flink;
             entry != &CnpNetworkList;
             entry = entry->Flink
            )
        {
            network = CONTAINING_RECORD(entry, CNP_NETWORK, Linkage);

            CnAcquireLockAtDpc(&(network->Lock));

            if (NetworkId == network->Id) {
                IF_CNDBG(CN_DEBUG_CONFIG) {
                    CNPRINT((
                        "[CNP] Deregistering network %u.\n",
                        NetworkId
                        ));
                }

                //
                // Save a pointer to pending irp. Note this is protected
                // by the list lock, not the object lock.
                //
                network->PendingDeleteIrp = Irp;

                CnpDeleteNetwork(network, irql);

                //
                // Both locks were released.
                // Irp will be completed when the network is destroyed
                // or the irp is cancelled.
                //

                CnVerifyCpuLockMask(
                    0,                  // Required
                    0xFFFFFFFF,         // Forbidden
                    0                   // Maximum
                    );

                return(STATUS_PENDING);
            }

            CnReleaseLockFromDpc(&(network->Lock));
        }

        CnReleaseLock(&CnpNetworkListLock, irql);

        CnAcquireCancelSpinLock(&(Irp->CancelIrql));

        CnCompletePendingRequest(Irp, STATUS_CLUSTER_NETWORK_NOT_FOUND, 0);

        CnVerifyCpuLockMask(
            0,                  // Required
            0xFFFFFFFF,         // Forbidden
            0                   // Maximum
            );

        return(STATUS_PENDING);
    }

    CnAssert(status == STATUS_CANCELLED);

    CnReleaseLock(&CnpNetworkListLock, irql);

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(status);

}  // CxDeregisterNetwork



NTSTATUS
CxOnlineNetwork(
    IN  CL_NETWORK_ID       NetworkId,
    IN  PWCHAR              TdiProviderName,
    IN  ULONG               TdiProviderNameLength,
    IN  PTRANSPORT_ADDRESS  TdiBindAddress,
    IN  ULONG               TdiBindAddressLength,
    IN  PWCHAR              AdapterName,
    IN  ULONG               AdapterNameLength,
    OUT PTDI_ADDRESS_INFO   TdiBindAddressInfo,
    IN  ULONG               TdiBindAddressInfoLength,
    IN  PIRP                Irp                       OPTIONAL
)
/*++

Notes:

    Each associated interface will be brought online when a heartbeat
    is established for the target of the interface.

--*/
{

    NTSTATUS                               status;
    PCNP_NETWORK                           network;
    OBJECT_ATTRIBUTES                      objectAttributes;
    IO_STATUS_BLOCK                        iosb;
    PFILE_FULL_EA_INFORMATION              ea = NULL;
    ULONG                                  eaBufferLength;
    HANDLE                                 addressHandle = NULL;
    PFILE_OBJECT                           addressFileObject = NULL;
    PDEVICE_OBJECT                         addressDeviceObject = NULL;
    BOOLEAN                                attached = FALSE;
    UNICODE_STRING                         unicodeString;
    TDI_REQUEST_KERNEL_QUERY_INFORMATION   queryInfo;
    PTDI_ADDRESS_INFO                      addressInfo;


    //
    // Allocate memory to hold the EA buffer we'll use to specify the
    // transport address to NtCreateFile.
    //
    eaBufferLength = FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                     TDI_TRANSPORT_ADDRESS_LENGTH + 1 +
                     TdiBindAddressLength;

    ea = CnAllocatePool(eaBufferLength);

    if (ea == NULL) {
        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT((
                "[CNP] memory allocation of %u bytes failed.\n",
                eaBufferLength
                ));
        }
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Initialize the EA using the network's transport information.
    //
    ea->NextEntryOffset = 0;
    ea->Flags = 0;
    ea->EaNameLength = TDI_TRANSPORT_ADDRESS_LENGTH;
    ea->EaValueLength = (USHORT) TdiBindAddressLength;

    RtlMoveMemory(
        ea->EaName,
        TdiTransportAddress,
        ea->EaNameLength + 1
        );

    RtlMoveMemory(
        &(ea->EaName[ea->EaNameLength + 1]),
        TdiBindAddress,
        TdiBindAddressLength
        );

    RtlInitUnicodeString(&unicodeString, TdiProviderName);

    network = CnpFindNetwork(NetworkId);

    if (network == NULL) {
        CnFreePool(ea);
        return(STATUS_CLUSTER_NETWORK_NOT_FOUND);
    }

    if (network->State != ClusnetNetworkStateOffline) {
        CnReleaseLock(&(network->Lock), network->Irql);
        CnFreePool(ea);
        return(STATUS_CLUSTER_NETWORK_ALREADY_ONLINE);
    }

    CnAssert(network->DatagramHandle == NULL);
    CnAssert(network->DatagramFileObject == NULL);
    CnAssert(network->DatagramDeviceObject == NULL);
    CnAssert(network->ActiveRefCount == 0);

    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT(("[CNP] Bringing network %u online...\n", NetworkId));
    }

    //
    // Set the initial active refcount to 2. One reference will be removed
    // when the network is successfully brought online. The other will be
    // removed when the network is to be taken offline. Also increment the
    // base refcount to account for the active refcount. Change to
    // the online pending state.
    //
    network->ActiveRefCount = 2;
    CnpReferenceNetwork(network);
    network->State = ClusnetNetworkStateOnlinePending;

    CnReleaseLock(&(network->Lock), network->Irql);

    //
    // Prepare for opening the address object.
    //
    InitializeObjectAttributes(
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,         // attributes
        NULL,
        NULL
        );

    //
    // Attach to the system process so the handle we open will remain valid
    // after the calling process goes away.
    //
    KeAttachProcess(CnSystemProcess);
    attached = TRUE;

    //
    // Perform the actual open of the address object.
    //
    status = ZwCreateFile(
                 &addressHandle,
                 GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                 &objectAttributes,
                 &iosb,                          // returned status information.
                 0,                              // block size (unused).
                 0,                              // file attributes.
                 0,                              // not shareable
                 FILE_CREATE,                    // create disposition.
                 0,                              // create options.
                 ea,
                 eaBufferLength
                 );

    CnFreePool(ea); ea = NULL;

    if (status != STATUS_SUCCESS) {
        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT((
                "[CNP] Failed to open address for network %u, status %lx.\n",
                NetworkId,
                status
                ));
        }

        goto error_exit;
    }

    //
    // Get a pointer to the file object of the address.
    //
    status = ObReferenceObjectByHandle(
                 addressHandle,
                 0L,                         // DesiredAccess
                 NULL,
                 KernelMode,
                 &addressFileObject,
                 NULL
                 );

    if (status != STATUS_SUCCESS) {
        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT((
                "[CNP] Failed to reference address handle, status %lx.\n",
                status
                ));
        }

        goto error_exit;
    }

    //
    // Remember the device object to which we need to give requests for
    // this address object.  We can't just use the fileObject->DeviceObject
    // pointer because there may be a device attached to the transport
    // protocol.
    //
    addressDeviceObject = IoGetRelatedDeviceObject(
                              addressFileObject
                              );

    //
    // Adjust the StackSize of CdpDeviceObject so that we can pass CDP
    // IRPs through for this network.
    //
    CnAdjustDeviceObjectStackSize(CdpDeviceObject, addressDeviceObject);

    //
    // Get the transport provider info
    //
    queryInfo.QueryType = TDI_QUERY_PROVIDER_INFO;
    queryInfo.RequestConnectionInformation = NULL;

    status = CnpIssueDeviceControl(
                 addressFileObject,
                 addressDeviceObject,
                 &queryInfo,
                 sizeof(queryInfo),
                 &(network->ProviderInfo),
                 sizeof(network->ProviderInfo),
                 TDI_QUERY_INFORMATION,
                 Irp
                 );

    if (!NT_SUCCESS(status)) {
        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT((
                "[CNP] Failed to get provider info, status %lx\n",
                status
                ));
        }
        goto error_exit;
    }

    if (! ( network->ProviderInfo.ServiceFlags &
            TDI_SERVICE_CONNECTIONLESS_MODE)
       )
    {
        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT((
                "[CNP] Provider doesn't support datagrams!\n"
                ));
        }
        status = STATUS_CLUSTER_INVALID_NETWORK_PROVIDER;
        goto error_exit;
    }

    //
    // Get the address to which we were bound.
    //
    queryInfo.QueryType = TDI_QUERY_ADDRESS_INFO;
    queryInfo.RequestConnectionInformation = NULL;

    status = CnpIssueDeviceControl(
                 addressFileObject,
                 addressDeviceObject,
                 &queryInfo,
                 sizeof(queryInfo),
                 TdiBindAddressInfo,
                 TdiBindAddressInfoLength,
                 TDI_QUERY_INFORMATION,
                 Irp
                 );

    if (!NT_SUCCESS(status)) {
        IF_CNDBG(CN_DEBUG_CONFIG) {        
            CNPRINT((
                "[CNP] Failed to get address info, status %lx\n",
                status
                ));
        }
        goto error_exit;
    }

    //
    // Set up indication handlers on the address object. We are eligible
    // to receive indications as soon as we do this.
    //
    status = CnpTdiSetEventHandler(
                 addressFileObject,
                 addressDeviceObject,
                 TDI_EVENT_ERROR,
                 CnpTdiErrorHandler,
                 network,
                 Irp
                 );

    if ( !NT_SUCCESS(status) ) {
        IF_CNDBG(CN_DEBUG_CONFIG) {        
            CNPRINT((
                "[CNP] Setting TDI_EVENT_ERROR failed: %lx\n",
                status
                ));
        }
        goto error_exit;
    }

    status = CnpTdiSetEventHandler(
                 addressFileObject,
                 addressDeviceObject,
                 TDI_EVENT_RECEIVE_DATAGRAM,
                 CnpTdiReceiveDatagramHandler,
                 network,
                 Irp
                 );

    if ( !NT_SUCCESS(status) ) {
        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT((
                "[CNP] Setting TDI_EVENT_RECEIVE_DATAGRAM failed: %lx\n",
                status
                ));
        }
        goto error_exit;
    }

    //
    // We're done working with handles, so detach from the system process.
    //
    KeDetachProcess();

    //
    // Finish transition to online state. Note that an offline request
    // could have been issued in the meantime.
    //
    CnAcquireLock(&(network->Lock), &(network->Irql));

    network->DatagramHandle = addressHandle;
    addressHandle = NULL;
    network->DatagramFileObject = addressFileObject;
    addressFileObject = NULL;
    network->DatagramDeviceObject = addressDeviceObject;
    addressDeviceObject = NULL;

    //
    // If an offline wasn't issued, change to the online state.
    //
    if (network->State == ClusnetNetworkStateOnlinePending) {
        
        CnAssert(network->ActiveRefCount == 2);
        network->State = ClusnetNetworkStateOnline;

        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT(("[CNP] Network %u is now online.\n", NetworkId));
        }

        CnReleaseLock(&(network->Lock), network->Irql);

        //
        // Bring all of the interfaces on this network online.
        //
        // The network can't be taken offline because we still hold
        // the 2nd active reference.
        //
        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT((
                "[CNP] Bringing all interfaces on network %u online...\n",
                network->Id
                ));
        }

        CnpWalkInterfacesOnNetwork(network, CnpOnlinePendingInterfaceWrapper);

        //
        // Position the network in the network list according to 
        // multicast reachability.
        //
        CnpSortMulticastNetwork(network, TRUE, NULL);

        //
        // Reacquire the lock to drop the active reference.
        //
        CnAcquireLock(&(network->Lock), &(network->Irql));
    }
    else {
        //
        // An offline was issued. It will take effect when we
        // remove our 2nd active reference. The offline operation removed
        // the first one. No send threads could have accessed this network
        // yet because we never brought the associated interfaces online.
        //
        CnAssert(network->State == ClusnetNetworkStateOfflinePending);

        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT((
                "[CNP] An offline request was issued on network %u during online pending.\n",
                NetworkId
                ));
        }
    }

    CnpActiveDereferenceNetwork(network);

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(STATUS_SUCCESS);


error_exit:

    if (addressFileObject != NULL) {
        ObDereferenceObject(addressFileObject);
    }

    if (addressHandle != NULL) {
        ZwClose(addressHandle);
    }

    KeDetachProcess();

    CnAcquireLock(&(network->Lock), &(network->Irql));

    if (network->State == ClusnetNetworkStateOnlinePending) {
        //
        // Remove our 2nd active reference and call the offline code.
        // The offline function will release the network object lock.
        //
        CnAssert(network->ActiveRefCount == 2);

        --(network->ActiveRefCount);

        CnpOfflineNetwork(network);
    }
    else {
        CnAssert(network->State == ClusnetNetworkStateOfflinePending);
        //
        // An offline was issued. It will take effect when we
        // remove our 2nd active reference. The offline operation removed
        // the first one. The dereference will release the network object
        // lock.
        //
        CnAssert(network->State == ClusnetNetworkStateOfflinePending);
        CnAssert(network->ActiveRefCount == 1);

        CnpActiveDereferenceNetwork(network);
    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(status);

}  // CxOnlineNetwork



VOID
CxCancelOfflineNetwork(
    PDEVICE_OBJECT   DeviceObject,
    PIRP             Irp
    )
/*++

Routine Description:

    Cancellation handler for OfflineNetwork requests.

Return Value:

    None.

Notes:

    Called with cancel spinlock held.
    Returns with cancel spinlock released.

--*/

{
    PFILE_OBJECT   fileObject;
    CN_IRQL        cancelIrql = Irp->CancelIrql;
    PLIST_ENTRY    entry;
    PCNP_NETWORK   network;
    PCNP_NETWORK   offlineNetwork = NULL;


    CnMarkIoCancelLockAcquired();

    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT((
            "[CNP] Attempting to cancel OfflineNetwork irp %p\n",
            Irp
            ));
    }

    CnAssert(DeviceObject == CnDeviceObject);

    fileObject = CnBeginCancelRoutine(Irp);

    CnAcquireLockAtDpc(&CnpNetworkListLock);

    CnReleaseCancelSpinLock(DISPATCH_LEVEL);

    //
    // We can only complete the irp if we can find it stashed in a
    // network object. The network object could have been destroyed
    // and the IRP completed before we acquired the CnpNetworkListLock.
    //
    for (entry = CnpNetworkList.Flink;
         entry != &CnpNetworkList;
         entry = entry->Flink
        )
    {
        network = CONTAINING_RECORD(entry, CNP_NETWORK, Linkage);

        CnAcquireLockAtDpc(&(network->Lock));

        if (network->PendingOfflineIrp == Irp) {
            IF_CNDBG(CN_DEBUG_CONFIG) {
                CNPRINT((
                    "[CNP] Found offline irp on network %u\n",
                    network->Id
                    ));
            }

            network->PendingOfflineIrp = NULL;
            offlineNetwork = network;

            CnReleaseLockFromDpc(&(network->Lock));

            break;
        }

        CnReleaseLockFromDpc(&(network->Lock));
    }

    if (offlineNetwork == NULL) {
        for (entry = CnpDeletingNetworkList.Flink;
             entry != &CnpDeletingNetworkList;
             entry = entry->Flink
            )
        {
            network = CONTAINING_RECORD(entry, CNP_NETWORK, Linkage);

            CnAcquireLockAtDpc(&(network->Lock));

            if (network->PendingOfflineIrp == Irp) {
                IF_CNDBG(CN_DEBUG_CONFIG) {
                    CNPRINT((
                        "[CNP] Found offline irp on network %u\n",
                        network->Id
                        ));
                }

                network->PendingOfflineIrp = NULL;
                offlineNetwork = network;

                CnReleaseLockFromDpc(&(network->Lock));

                break;
            }

            CnReleaseLockFromDpc(&(network->Lock));
        }
    }

    CnReleaseLock(&CnpNetworkListLock, cancelIrql);

    CnAcquireCancelSpinLock(&cancelIrql);

    CnEndCancelRoutine(fileObject);

    if (offlineNetwork != NULL) {
        //
        // Found the Irp. Now take it away and complete it.
        // This releases the cancel spinlock
        //
        Irp->CancelIrql = cancelIrql;
        CnCompletePendingRequest(Irp, STATUS_CANCELLED, 0);
    }
    else {
        CnReleaseCancelSpinLock(cancelIrql);
    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return;

}  // CnpCancelApiOfflineNetwork



NTSTATUS
CxOfflineNetwork(
    IN CL_NETWORK_ID       NetworkId,
    IN PIRP                Irp,
    IN PIO_STACK_LOCATION  IrpSp
    )
/*++

Notes:


--*/
{
    PCNP_NETWORK   network;
    CN_IRQL        irql;
    NTSTATUS       status;


    CnAcquireCancelSpinLock(&irql);
    CnAcquireLockAtDpc(&CnpNetworkListLock);

    status = CnMarkRequestPending(Irp, IrpSp, CxCancelOfflineNetwork);

    CnReleaseCancelSpinLock(DISPATCH_LEVEL);

    if (status != STATUS_CANCELLED) {
        CnAssert(status == STATUS_SUCCESS);

        network = CnpLockedFindNetwork(NetworkId, irql);

        //
        // CnpNetworkListLock was released.
        //

        if (network != NULL) {
            if (network->State >= ClusnetNetworkStateOnlinePending) {

                network->PendingOfflineIrp = Irp;

                CnpOfflineNetwork(network);

                return(STATUS_PENDING);
            }

            CnReleaseLock(&(network->Lock), network->Irql);

            status = STATUS_CLUSTER_NETWORK_ALREADY_OFFLINE;
        }
        else {
            status = STATUS_CLUSTER_NETWORK_NOT_FOUND;
        }

        CnAcquireCancelSpinLock(&irql);
        Irp->CancelIrql = irql;

        CnCompletePendingRequest(Irp, status, 0);

        CnVerifyCpuLockMask(
            0,                  // Required
            0xFFFFFFFF,         // Forbidden
            0                   // Maximum
            );

        return(STATUS_PENDING);
    }

    CnAssert(status == STATUS_CANCELLED);

    CnReleaseLock(&CnpNetworkListLock, irql);

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(status);

}  // CxOfflineNetwork



NTSTATUS
CxSetNetworkRestriction(
    IN CL_NETWORK_ID  NetworkId,
    IN BOOLEAN        Restricted,
    IN ULONG          NewPriority
    )
{
    NTSTATUS           status;
    PCNP_NETWORK       network;


    network = CnpFindNetwork(NetworkId);

    if (network != NULL) {
        if (Restricted) {
            IF_CNDBG(CN_DEBUG_CONFIG) {
                CNPRINT((
                    "[CNP] Restricting network %u.\n",
                    network->Id
                    ));
            }

            network->Flags |= CNP_NET_FLAG_RESTRICTED;
        }
        else {
            IF_CNDBG(CN_DEBUG_CONFIG) {
                CNPRINT((
                    "[CNP] Unrestricting network %u.\n",
                    network->Id
                    ));
            }

            network->Flags &= ~CNP_NET_FLAG_RESTRICTED;

            if (NewPriority != 0) {
                network->Priority = NewPriority;
            }
        }

        //
        // Reference the network so it can't go away while we
        // reprioritize the associated interfaces.
        //
        CnpReferenceNetwork(network);

        CnReleaseLock(&(network->Lock), network->Irql);

        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT((
                "[CNP] Recalculating priority for all interfaces on network %u ...\n",
                network->Id
                ));
        }

        if (!Restricted) {
            CnpWalkInterfacesOnNetwork(
                network,
                CnpRecalculateInterfacePriority
                );
        }

        CnpWalkInterfacesOnNetwork(network, CnpReevaluateInterfaceRole);

        //
        // Reposition the network according to multicast reachability.
        //
        CnpSortMulticastNetwork(network, TRUE, NULL);

        CnAcquireLock(&(network->Lock), &(network->Irql));

        CnpDereferenceNetwork(network);

        status = STATUS_SUCCESS;
    }
    else {
        status = STATUS_CLUSTER_NETWORK_NOT_FOUND;
    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(status);

}  // CxSetNetworkRestriction



NTSTATUS
CxSetNetworkPriority(
    IN CL_NETWORK_ID  NetworkId,
    IN ULONG          Priority
    )
{
    NTSTATUS           status;
    PCNP_NETWORK       network;


    if (Priority == 0) {
        return(STATUS_INVALID_PARAMETER);
    }

    network = CnpFindNetwork(NetworkId);

    if (network != NULL) {
        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT((
                "[CNP] Network %u old priority %u, new priority %u.\n",
                network->Id,
                network->Priority,
                Priority
                ));
        }

        network->Priority = Priority;

        //
        // Reference the network so it can't go away while we
        // reprioritize the associated interfaces.
        //
        CnpReferenceNetwork(network);

        CnReleaseLock(&(network->Lock), network->Irql);

        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT((
                "[CNP] Recalculating priority for all interfaces on network %u ...\n",
                network->Id
                ));
        }

        CnpWalkInterfacesOnNetwork(network, CnpRecalculateInterfacePriority);

        //
        // Reposition the network according to multicast reachability.
        //
        CnpSortMulticastNetwork(network, TRUE, NULL);

        CnAcquireLock(&(network->Lock), &(network->Irql));

        CnpDereferenceNetwork(network);

        status = STATUS_SUCCESS;
    }
    else {
        status = STATUS_CLUSTER_NETWORK_NOT_FOUND;
    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(status);

}  // CxSetNetworkPriority



NTSTATUS
CxGetNetworkPriority(
    IN  CL_NETWORK_ID   NetworkId,
    OUT PULONG          Priority
    )
{
    NTSTATUS       status;
    PCNP_NETWORK   network;


    network = CnpFindNetwork(NetworkId);

    if (network != NULL) {
        *Priority = network->Priority;

        CnReleaseLock(&(network->Lock), network->Irql);

        status = STATUS_SUCCESS;
    }
    else {
        status = STATUS_CLUSTER_NETWORK_NOT_FOUND;
    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(status);

}  // CxGetNetworkPriority



NTSTATUS
CxGetNetworkState(
    IN  CL_NETWORK_ID           NetworkId,
    OUT PCLUSNET_NETWORK_STATE  State
    )
{
    NTSTATUS       status;
    PCNP_NETWORK   network;


    network = CnpFindNetwork(NetworkId);

    if (network != NULL) {
        *State = network->State;

        CnReleaseLock(&(network->Lock), network->Irql);

        status = STATUS_SUCCESS;
    }
    else {
        status = STATUS_CLUSTER_NETWORK_NOT_FOUND;
    }

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return(status);

}  // CxGetNetworkState


NTSTATUS
CxUnreserveClusnetEndpoint(
    VOID
    )
/*++

Routine Description:

    Unreserves port number previously reserved with
    CxUnreserveClusnetEndpoint.
    
    CnResource should already be held when this routine
    is called. Alternately, this routine is called without
    CnResource held during unload of the clusnet driver.

Arguments:

    None.

Return Value:

    Status of TCP/IP ioctl.

--*/
{
    HANDLE tcpHandle = (HANDLE) NULL;
    TCP_RESERVE_PORT_RANGE portRange;
    NTSTATUS status = STATUS_SUCCESS;

    // Check if we have a port reserved
    if (CnpReservedClusnetPort != 0) {

        status = CnpOpenDevice(
                     DD_TCP_DEVICE_NAME,
                     &tcpHandle
                     );
        if (NT_SUCCESS(status)) {

            // TCP/IP interprets port ranges in host order
            portRange.LowerRange = CnpReservedClusnetPort;
            portRange.UpperRange = CnpReservedClusnetPort;

            status = CnpZwDeviceControl(
                         tcpHandle,
                         IOCTL_TCP_UNRESERVE_PORT_RANGE,
                         &portRange,
                         sizeof(portRange),
                         NULL,
                         0
                         );
            if (!NT_SUCCESS(status)) {
                IF_CNDBG(CN_DEBUG_CONFIG) {
                    CNPRINT(("[Clusnet] Failed to unreserve "
                             "port %d: %lx\n", 
                             CnpReservedClusnetPort, status));
                }
            } else {
                IF_CNDBG(CN_DEBUG_CONFIG) {
                    CNPRINT(("[Clusnet] Unreserved "
                             "port %d.\n", 
                             CnpReservedClusnetPort));
                }
            }

            ZwClose(tcpHandle);

        } else {
            IF_CNDBG(CN_DEBUG_CONFIG) {
                CNPRINT(("[Clusnet] Failed to open device %S, "
                         "status %lx\n", 
                         DD_TCP_DEVICE_NAME, status));
            }
        }

        CnpReservedClusnetPort = 0;
    }

    return status;
}


NTSTATUS
CxReserveClusnetEndpoint(
    IN USHORT Port
    )
/*++

Routine Description:

    Reserves assigned clusnet endpoint port number so that 
    the TCP/IP driver will not hand it out to applications
    requesting a wildcard port.

Arguments:

    Port - port number to reserve, in host byte-order format

Return Value:

    Status of TCP/IP ioctl.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    HANDLE tcpHandle = (HANDLE) NULL;
    TCP_RESERVE_PORT_RANGE portRange;

    // Check for invalid port number 0
    if (Port == 0) {
        return STATUS_INVALID_PARAMETER;
    }

    // Check if we already have a port reserved.
    if (CnpReservedClusnetPort != 0
        && CnpReservedClusnetPort != Port) {

        status = CxUnreserveClusnetEndpoint();
    }

    if (CnpReservedClusnetPort == 0) {

        // Reserve Port with the TCP/IP driver.
        status = CnpOpenDevice(
                     DD_TCP_DEVICE_NAME,
                     &tcpHandle
                     );
        if (NT_SUCCESS(status)) {
        
            // TCP/IP interprets port ranges in host order
            portRange.LowerRange = Port;
            portRange.UpperRange = Port;

            status = CnpZwDeviceControl(
                         tcpHandle,
                         IOCTL_TCP_RESERVE_PORT_RANGE,
                         &portRange,
                         sizeof(portRange),
                         NULL,
                         0
                         );
            if (!NT_SUCCESS(status)) {
                IF_CNDBG(CN_DEBUG_CONFIG) {
                    CNPRINT(("[Clusnet] Failed to reserve "
                             "port %d: %lx\n", 
                             Port, status));
                }
            } else {
                IF_CNDBG(CN_DEBUG_CONFIG) {
                    CNPRINT(("[Clusnet] Reserved "
                             "port %d.\n", 
                             Port));
                }
                CnpReservedClusnetPort = Port;
            }
        
            ZwClose(tcpHandle);
        
        } else {
            IF_CNDBG(CN_DEBUG_CONFIG) {
                CNPRINT(("[Clusnet] Failed to open device %S, "
                         "status %lx\n", 
                         DD_TCP_DEVICE_NAME, status));
            }
        }
    }

    return status;

} // CxReserveClusnetEndpoint


NTSTATUS
CxConfigureMulticast(
    IN CL_NETWORK_ID       NetworkId,
    IN ULONG               MulticastNetworkBrand,
    IN PTRANSPORT_ADDRESS  TdiMcastBindAddress,
    IN ULONG               TdiMcastBindAddressLength,
    IN PVOID               Key,
    IN ULONG               KeyLength,
    IN PVOID               Salt,
    IN ULONG               SaltLength,
    IN PIRP                Irp
    )
/*++

Routine Description:

    Configures a network for multicast.
    
Notes:

    The network multicast flag is turned off at the
    beginning of this routine to prevent multicasts
    during the transition. If the routine does not
    complete successfully, the multicast flag is 
    purposely left cleared.
    
--*/
{
    NTSTATUS                               status;
    KIRQL                                  irql;
    PLIST_ENTRY                            entry;
    PCNP_NETWORK                           network;
    BOOLEAN                                networkLocked = FALSE;
    BOOLEAN                                mcastEnabled = FALSE;
    TDI_REQUEST_KERNEL_QUERY_INFORMATION   queryInfo;
    PTDI_ADDRESS_INFO                      addressInfo;
    HANDLE                                 networkHandle;
    PFILE_OBJECT                           networkFileObject;
    PDEVICE_OBJECT                         networkDeviceObject;

    PCNP_MULTICAST_GROUP                   group = NULL;
    PCNP_MULTICAST_GROUP                   delGroup = NULL;
    PCNP_MULTICAST_GROUP                   currGroup = NULL;
    PCNP_MULTICAST_GROUP                   prevGroup = NULL;
    BOOLEAN                                prevGroupMatch = FALSE;
    
    UCHAR addressInfoBuffer[FIELD_OFFSET(TDI_ADDRESS_INFO, Address) +
                            sizeof(TA_IP_ADDRESS)] = {0};

    //
    // Validate multicast bind address parameter. Even if this
    // request only leaves a group, the multicast address data
    // structure must be provided.
    //
    if (TdiMcastBindAddressLength != sizeof(TA_IP_ADDRESS)) {
        return (STATUS_INVALID_PARAMETER);
    }

    //
    // Acquire the lock on the local node, but go through the
    // node table to be extra paranoid.
    //
    CnAcquireLock(&CnpNodeTableLock, &irql);

    if (CnpLocalNode != NULL) {
        
        CnAcquireLockAtDpc(&(CnpLocalNode->Lock));
        CnReleaseLockFromDpc(&CnpNodeTableLock);
        CnpLocalNode->Irql = irql;

        //
        // Find the network object in the network object table.
        //
        CnAcquireLockAtDpc(&CnpNetworkListLock);

        for (entry = CnpNetworkList.Flink;
             entry != &CnpNetworkList;
             entry = entry->Flink
            )
        {
            network = CONTAINING_RECORD(entry, CNP_NETWORK, Linkage);

            CnAcquireLockAtDpc(&(network->Lock));

            if (NetworkId == network->Id) {

                //
                // We now hold locks on the node, the network list,
                // and the network.
                
                //
                // Verify the network state.
                //
                if (network->State < ClusnetNetworkStateOnline) {
                    CnReleaseLockFromDpc(&(network->Lock));
                    CnReleaseLockFromDpc(&CnpNetworkListLock);
                    CnReleaseLock(&(CnpLocalNode->Lock), CnpLocalNode->Irql);
                    return(STATUS_CLUSTER_INVALID_NETWORK);
                }

                //
                // Take a reference on the network so that it doesn't
                // disappear while we're working with it.
                //
                CnpActiveReferenceNetwork(network);

                //
                // Clear the reachable set for this network.
                //
                CnpMulticastChangeNodeReachabilityLocked(
                    network,
                    CnpLocalNode,
                    FALSE,
                    TRUE,
                    NULL
                    );

                //
                // Remember whether the network was multicast-capable. Then
                // clear the multicast capable flag so that we don't try to
                // send multicasts during the transition period.
                //
                mcastEnabled = (BOOLEAN) CnpIsNetworkMulticastCapable(network);
                network->Flags &= ~CNP_NET_FLAG_MULTICAST;

                networkHandle = network->DatagramHandle;
                networkFileObject = network->DatagramFileObject;
                networkDeviceObject = network->DatagramDeviceObject;

                currGroup = network->CurrentMcastGroup;
                if (currGroup != NULL) {
                    CnpReferenceMulticastGroup(currGroup);
                }
                prevGroup = network->PreviousMcastGroup;
                if (prevGroup != NULL) {
                    CnpReferenceMulticastGroup(prevGroup);
                }

                //
                // Release the network lock.
                //
                CnReleaseLockFromDpc(&(network->Lock));
                networkLocked = FALSE;

                //
                // Break out of the network search.
                //
                break;
            
            } else {
                CnReleaseLockFromDpc(&(network->Lock));
                network = NULL;
            }
        }

        //
        // Release the network list lock.
        //
        CnReleaseLockFromDpc(&CnpNetworkListLock);

        //
        // Release the local node lock.
        //
        CnReleaseLock(&(CnpLocalNode->Lock), CnpLocalNode->Irql);

    } else {
        CnReleaseLock(&CnpNodeTableLock, irql);
        
        CnTrace(CNP_NET_DETAIL, CnpTraceMcastPreConfigNoHost,
            "[CNP] Cannot configure multicast for network %u "
            "because local host not found.",
            NetworkId
            );

        return(STATUS_HOST_UNREACHABLE);
    }

    //
    // Verify that we found the network.
    //
    if (network == NULL) {
        return (STATUS_CLUSTER_NETWORK_NOT_FOUND);
    }

    //
    // Allocate a multicast group data structure with the
    // new configuration parameters.
    //
    status = CnpAllocateMulticastGroup(
                 MulticastNetworkBrand,
                 TdiMcastBindAddress,
                 TdiMcastBindAddressLength,
                 Key,
                 KeyLength,
                 Salt,
                 SaltLength,
                 &group
                 );
    if (!NT_SUCCESS(status)) {
        IF_CNDBG(CN_DEBUG_NETOBJ) {
            CNPRINT((
                "[CNP] Failed to allocate mcast group, "
                "status %lx\n",
                status
                ));
        }
        goto error_exit;
    }

    //
    // Get the local interface address.
    //
    addressInfo = (PTDI_ADDRESS_INFO) &addressInfoBuffer[0];
    queryInfo.QueryType = TDI_QUERY_ADDRESS_INFO;
    queryInfo.RequestConnectionInformation = NULL;

    status = CnpIssueDeviceControl(
                 networkFileObject,
                 networkDeviceObject,
                 &queryInfo,
                 sizeof(queryInfo),
                 addressInfo,
                 sizeof(addressInfoBuffer),
                 TDI_QUERY_INFORMATION,
                 Irp
                 );
    if (!NT_SUCCESS(status)) {
        IF_CNDBG(CN_DEBUG_NETOBJ) {
            CNPRINT((
                "[CNP] Failed to get address info, status %lx\n",
                status
                ));
        }        
        goto error_exit;
    }

    //
    // Determine if the multicast bind address is valid. If not,
    // we are disabling.
    //
    if (CnpIsIPv4McastTransportAddress(TdiMcastBindAddress)) {

        //
        // We are trying to join a new multicast group. Fail
        // immediately if there is no key or salt.
        //
        if (KeyLength == 0 || SaltLength == 0) {
            IF_CNDBG(CN_DEBUG_NETOBJ) {
                CNPRINT((
                    "[CNP] Cannot configure new multicast group "
                    "without key and salt.\n"
                    ));
            }            
            status = STATUS_INVALID_PARAMETER;
            goto error_exit;
        }

        //
        // Configure basic multicast settings if not done
        // previously (though this call is idempotent).
        //
        if (!mcastEnabled) {

            status = CnpConfigureBasicMulticastSettings(
                         networkHandle,
                         networkFileObject,
                         networkDeviceObject,
                         addressInfo,
                         1, // ttl
                         0, // disable loopback
                         Irp
                         );
            if (!NT_SUCCESS(status)) {
                IF_CNDBG(CN_DEBUG_NETOBJ) {
                    CNPRINT((
                        "[CNP] Failed to configure basic "
                        "multicast settings, status %lx\n",
                        status
                        ));
                }
                goto error_exit;
            }
        }

        //
        // Add the group address if we are not already in
        // this multicast group (e.g. the multicast bind
        // address is the same as the current group or
        // previous group).
        //
        if (prevGroup != NULL &&
            CnpIsIPv4McastSameGroup(
                prevGroup->McastTdiAddress,
                TdiMcastBindAddress
                )
            ) {
            prevGroupMatch = TRUE;
            IF_CNDBG(CN_DEBUG_NETOBJ) {
                CNPRINT(("[CNP] New mcast address matches "
                         "previous mcast address.\n"));
            }
        } 
        else if (currGroup != NULL &&
                 CnpIsIPv4McastSameGroup(
                     currGroup->McastTdiAddress,
                     TdiMcastBindAddress
                     )
                 ) {
            IF_CNDBG(CN_DEBUG_NETOBJ) {
                CNPRINT(("[CNP] New mcast address matches "
                         "current mcast address.\n"));
            }
        } else {
            
            status = CnpAddRemoveMulticastAddress(
                         networkHandle,
                         networkFileObject,
                         networkDeviceObject,
                         addressInfo,
                         TdiMcastBindAddress,
                         AO_OPTION_ADD_MCAST,
                         Irp
                         );
            if (!NT_SUCCESS(status)) {
                IF_CNDBG(CN_DEBUG_NETOBJ) {
                    CNPRINT((
                        "[CNP] Failed to add mcast address, "
                        "status %lx\n",
                        status
                        ));
                }
                goto error_exit;
            }
        }
    }

    //
    // Leave membership for previous group if
    // - the previous group does not match the new group, AND
    // - the previous group does not match the current group
    //
    if (!prevGroupMatch && 
        prevGroup != NULL &&
        CnpIsIPv4McastTransportAddress(prevGroup->McastTdiAddress)) {

        if (!CnpIsIPv4McastSameGroup(
                 prevGroup->McastTdiAddress,
                 currGroup->McastTdiAddress
                 )) {
            
            status = CnpAddRemoveMulticastAddress(
                         networkHandle,
                         networkFileObject,
                         networkDeviceObject,
                         addressInfo,
                         prevGroup->McastTdiAddress,
                         AO_OPTION_DEL_MCAST,
                         Irp
                         );
            if (!NT_SUCCESS(status)) {
                IF_CNDBG(CN_DEBUG_NETOBJ) {
                    ULONG         mcastBindIp;
                    ULONG         ifBindIp;

                    mcastBindIp = *((ULONG UNALIGNED *)
                                    (&(((PTA_IP_ADDRESS)prevGroup->McastTdiAddress)
                                       ->Address[0].Address[0].in_addr)
                                     )
                                    );
                    ifBindIp = *((ULONG UNALIGNED *)
                                 (&(((PTA_IP_ADDRESS)&(addressInfo->Address))
                                    ->Address[0].Address[0].in_addr)
                                  )
                                 );
                    CNPRINT((
                        "[CNP] Failed to leave mcast group, "
                        "IF %d.%d.%d.%d, mcast addr %d.%d.%d.%d, "
                        "status %lx.\n",
                        CnpIpAddrPrintArgs(ifBindIp),
                        CnpIpAddrPrintArgs(mcastBindIp),
                        status
                        ));
                }
                // not considered a fatal error
                status = STATUS_SUCCESS;
            }
        } else {
            IF_CNDBG(CN_DEBUG_NETOBJ) {
                CNPRINT(("[CNP] Prev mcast address matches "
                         "current mcast address.\n"));
            }
        }
    }

    //
    // Reacquire the network lock to make changes
    // to the network object data structure, including
    // shifting the multicast group data structures and
    // turning on the multicast flag. The multicast flag 
    // was turned off earlier in this routine before 
    // starting the transition. It is only re-enabled if
    // the new multicast bind address is a valid multicast
    // address.
    //
    CnAcquireLock(&(network->Lock), &(network->Irql));
    networkLocked = TRUE;
    
    delGroup = network->PreviousMcastGroup;
    network->PreviousMcastGroup = network->CurrentMcastGroup;
    network->CurrentMcastGroup = group;
    group = NULL;
    
    if (CnpIsIPv4McastTransportAddress(TdiMcastBindAddress)) {
        network->Flags |= CNP_NET_FLAG_MULTICAST;
    }    

    CnReleaseLock(&(network->Lock), network->Irql);
    networkLocked = FALSE;

    //
    // Transition into new multicast group, if appropriate.
    //
    if (CnpIsIPv4McastTransportAddress(TdiMcastBindAddress)) {

        //
        // Switch all outgoing heartbeats on this node to
        // unicast with discovery.
        //
        CnpWalkInterfacesOnNetwork(
            network,
            CnpStartInterfaceMcastTransition
            );
    }
    
error_exit:

    if (networkLocked) {    
        CnReleaseLock(&(network->Lock), network->Irql);
        networkLocked = FALSE;
    }

    //
    // Reposition the network according to multicast reachability.
    //
    CnpSortMulticastNetwork(network, TRUE, NULL);
    
    CnAcquireLock(&(network->Lock), &(network->Irql));

    CnpActiveDereferenceNetwork(network);

    if (group != NULL) {
        CnpDereferenceMulticastGroup(group);
    }

    if (currGroup != NULL) {
        CnpDereferenceMulticastGroup(currGroup);
    }

    if (prevGroup != NULL) {
        CnpDereferenceMulticastGroup(prevGroup);
    }

    if (delGroup != NULL) {
        CnpDereferenceMulticastGroup(delGroup);
    }

    return(status);

} // CxConfigureMulticast


BOOLEAN
CnpSortMulticastNetwork(
    IN  PCNP_NETWORK        Network,
    IN  BOOLEAN             RaiseEvent,
    OUT CX_CLUSTERSCREEN  * McastReachableNodes      OPTIONAL
    )
/*++

Routine Description:

    Wrapper for CnpSortMulticastNetworkLocked.
    
Return value:

    TRUE if reachable node set changed
    
Notes:

    Acquires and releases CnpNetworkListLock.
    
--*/
{
    KIRQL    irql;
    BOOLEAN  setChanged = FALSE;

    CnVerifyCpuLockMask(
        0,                       // required
        CNP_NETWORK_LIST_LOCK,   // forbidden
        CNP_NODE_OBJECT_LOCK_MAX // max
        );

    CnAcquireLock(&CnpNetworkListLock, &irql);

    setChanged = CnpSortMulticastNetworkLocked(
                     Network,
                     RaiseEvent,
                     McastReachableNodes
                     );

    CnReleaseLock(&CnpNetworkListLock, irql);

    CnVerifyCpuLockMask(
        0,                       // required
        CNP_NETWORK_LIST_LOCK,   // forbidden
        CNP_NODE_OBJECT_LOCK_MAX // max
        );

    return(setChanged);

} // CnpSortMulticastNetwork


BOOLEAN
CnpMulticastChangeNodeReachability(
    IN  PCNP_NETWORK       Network,
    IN  PCNP_NODE          Node,
    IN  BOOLEAN            Reachable,
    IN  BOOLEAN            RaiseEvent,
    OUT CX_CLUSTERSCREEN * NewMcastReachableNodes
    )
/*++

Routine Description:

    Changes the multicast reachability state of Node
    on Network.
    
    If the set of reachable nodes changes, returns
    the new screen through NewMcastReachableNodes.
    
Return value:

    TRUE if set of reachable nodes changes.
    
Notes:

    Called and returns with node lock held.
    
--*/
{
    KIRQL            irql;
    BOOLEAN          setChanged = FALSE;

    CnVerifyCpuLockMask(
        CNP_NODE_OBJECT_LOCK,    // required
        CNP_NETWORK_LIST_LOCK,   // forbidden
        CNP_NODE_OBJECT_LOCK_MAX // max
        );

    CnAcquireLock(&CnpNetworkListLock, &irql);

    setChanged = CnpMulticastChangeNodeReachabilityLocked(
                     Network,
                     Node,
                     Reachable,
                     RaiseEvent,
                     NewMcastReachableNodes
                     );
    
    CnReleaseLock(&CnpNetworkListLock, irql);

    CnVerifyCpuLockMask(
        CNP_NODE_OBJECT_LOCK,    // required
        CNP_NETWORK_LIST_LOCK,   // forbidden
        CNP_NODE_OBJECT_LOCK_MAX // max
        );

    return(setChanged);

} // CnpMulticastChangeNodeReachability


PCNP_NETWORK
CnpGetBestMulticastNetwork(
    VOID
    )
/*++

Routine Description:

    Returns network object that currently has best
    node reachability.
    
Return value:

    Best network object, or NULL if there are no
    internal multicast networks. 
    
Notes:

    Must not be called with network list lock held.
    Returns with network locked (if found).
    
--*/
{
    PCNP_NETWORK   network = NULL;
    KIRQL          listIrql;
    KIRQL          networkIrql;

    CnVerifyCpuLockMask(
        0,                                                 // required
        (CNP_NETWORK_LIST_LOCK | CNP_NETWORK_OBJECT_LOCK), // forbidden
        CNP_NODE_OBJECT_LOCK_MAX                           // max
        );

    CnAcquireLock(&CnpNetworkListLock, &listIrql);

    if (!IsListEmpty(&CnpNetworkList)) {
        
        network = CONTAINING_RECORD(
                      CnpNetworkList.Flink,
                      CNP_NETWORK,
                      Linkage
                      );

        CnAcquireLock(&(network->Lock), &networkIrql);

        if (CnpIsInternalMulticastNetwork(network)) {

            CnReleaseLock(&CnpNetworkListLock, networkIrql);
            network->Irql = listIrql;

            CnVerifyCpuLockMask(
                CNP_NETWORK_OBJECT_LOCK,          // required
                CNP_NETWORK_LIST_LOCK,            // forbidden
                CNP_NETWORK_OBJECT_LOCK_MAX       // max
                );
        
        } else {

            CnReleaseLock(&(network->Lock), networkIrql);
            network = NULL;
        }
    }

    if (network == NULL) {

        CnReleaseLock(&CnpNetworkListLock, listIrql);

        CnVerifyCpuLockMask(
            0,                                                 // required
            (CNP_NETWORK_LIST_LOCK | CNP_NETWORK_OBJECT_LOCK), // forbidden
            CNP_NODE_OBJECT_LOCK_MAX                           // max
            );
    }

    return(network);

} // CnpGetBestMulticastNetwork


NTSTATUS
CxGetMulticastReachableSet(
    IN  CL_NETWORK_ID      NetworkId,
    OUT ULONG            * NodeScreen
    )
/*++

Routine Description:

    Queries multicast reachable set for specified network.
    The multicast reachable set is protected by the network
    list lock.
    
--*/
{
    KIRQL               irql;
    PLIST_ENTRY         entry;
    PCNP_NETWORK        network;
    CX_CLUSTERSCREEN    nodeScreen;
    BOOLEAN             found = FALSE;

    CnVerifyCpuLockMask(
        0,                       // required
        CNP_NETWORK_LIST_LOCK,   // forbidden
        CNP_NODE_OBJECT_LOCK_MAX // max
        );

    CnAcquireLock(&CnpNetworkListLock, &irql);

    for (entry = CnpNetworkList.Flink;
         entry != &CnpNetworkList && !found;
         entry = entry->Flink
        )
    {
        network = CONTAINING_RECORD(entry, CNP_NETWORK, Linkage);

        CnAcquireLockAtDpc(&(network->Lock));

        if (NetworkId == network->Id) {
            nodeScreen = network->McastReachableNodes;
            found = TRUE;
        }
        
        CnReleaseLockFromDpc(&(network->Lock));
    }

    CnReleaseLock(&CnpNetworkListLock, irql);

    if (!found) {
        return(STATUS_CLUSTER_NETWORK_NOT_FOUND);
    } else {
        *NodeScreen = nodeScreen.UlongScreen;
        return(STATUS_SUCCESS);
    }

} // CxGetMulticastReachableSet
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\xport\cnpsend.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cnpsend.c

Abstract:

    Cluster Network Protocol send processing code.

Author:

    Mike Massa (mikemas)           January 24, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-24-97    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "cnpsend.tmh"

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, CnpCreateSendRequestPool)

#endif // ALLOC_PRAGMA


//
// Private Utility Functions
//
PCN_RESOURCE
CnpCreateSendRequest(
    IN PVOID   Context
    )
{
    PCNP_SEND_REQUEST_POOL_CONTEXT   context = Context;
    PCNP_SEND_REQUEST                request;
    PCNP_HEADER                      cnpHeader;
    ULONG                            cnpHeaderSize;

    //
    // The CNP header size includes signature data for version 2.
    //
    cnpHeaderSize = sizeof(CNP_HEADER);
    if (context->CnpVersionNumber == 2) {
        cnpHeaderSize += CNP_SIG_LENGTH(CX_SIGNATURE_LENGTH);
    }

    //
    // Allocate a new send request. Include space for the upper protocol
    // and CNP headers.
    //
    request = CnAllocatePool(
                  sizeof(CNP_SEND_REQUEST) + cnpHeaderSize +
                  ((ULONG) context->UpperProtocolHeaderLength) +
                  context->UpperProtocolContextSize
                  );

    if (request != NULL) {
        //
        // Allocate an MDL to describe the CNP and upper transport headers.
        //
        
        // On I64 Context has to be 64 bit aligned, 
        // let's put it before CnpHeader
        if (context->UpperProtocolContextSize > 0) {
            request->UpperProtocolContext = request + 1;
            request->CnpHeader = ( ((PCHAR) request->UpperProtocolContext) +
                                     context->UpperProtocolContextSize );
        } else {
            request->UpperProtocolContext = NULL;
            request->CnpHeader = request + 1;
        }

        request->HeaderMdl = IoAllocateMdl(
                                 request->CnpHeader,
                                 (ULONG) (context->UpperProtocolHeaderLength +
                                          cnpHeaderSize),
                                 FALSE,
                                 FALSE,
                                 NULL
                                 );

        if (request->HeaderMdl != NULL) {
            MmBuildMdlForNonPagedPool(request->HeaderMdl);

            //
            // Finish initializing the request.
            //
            request->UpperProtocolHeader = ( ((PCHAR) request->CnpHeader) +
                                             cnpHeaderSize );

            request->UpperProtocolHeaderLength =
                context->UpperProtocolHeaderLength;

            RtlZeroMemory(
                &(request->TdiSendDatagramInfo),
                sizeof(request->TdiSendDatagramInfo)
                );

            request->McastGroup = NULL;

            //
            // Fill in the constant CNP header values.
            //
            cnpHeader = request->CnpHeader;
            cnpHeader->Version = context->CnpVersionNumber;
            cnpHeader->NextHeader = context->UpperProtocolNumber;

            return((PCN_RESOURCE) request);
        }

        CnFreePool(request);
    }

    return(NULL);

}  // CnpCreateSendRequest


VOID
CnpDeleteSendRequest(
    PCN_RESOURCE  Resource
    )
{
    PCNP_SEND_REQUEST  request = (PCNP_SEND_REQUEST) Resource;

    IoFreeMdl(request->HeaderMdl);
    CnFreePool(request);

    return;

} // CnpDeleteSendRequest


//
// Routines Exported within the Cluster Transport
//
PCN_RESOURCE_POOL
CnpCreateSendRequestPool(
    IN UCHAR  CnpVersionNumber,
    IN UCHAR  UpperProtocolNumber,
    IN USHORT UpperProtocolHeaderSize,
    IN USHORT UpperProtocolContextSize,
    IN USHORT PoolDepth
    )
{
    PCN_RESOURCE_POOL                pool;
    PCNP_SEND_REQUEST_POOL_CONTEXT   context;


    PAGED_CODE();

    CnAssert((0xFFFF - sizeof(CNP_HEADER)) >= UpperProtocolHeaderSize);

    pool = CnAllocatePool(
               sizeof(CN_RESOURCE_POOL) +
                   sizeof(CNP_SEND_REQUEST_POOL_CONTEXT)
               );

    if (pool != NULL) {
        context = (PCNP_SEND_REQUEST_POOL_CONTEXT) (pool + 1);

        context->UpperProtocolNumber = UpperProtocolNumber;
        context->UpperProtocolHeaderLength = UpperProtocolHeaderSize;
        context->UpperProtocolContextSize = UpperProtocolContextSize;
        context->CnpVersionNumber = CnpVersionNumber;

        CnInitializeResourcePool(
                   pool,
                   PoolDepth,
                   CnpCreateSendRequest,
                   context,
                   CnpDeleteSendRequest
                   );
    }

    return(pool);

}  // CnpCreateSendRequestPool



VOID
CnpCompleteSendPacketCommon(
    IN PIRP              Irp,
    IN PCNP_SEND_REQUEST Request,
    IN PMDL              DataMdl
    )
{
    PCNP_NETWORK       network = Request->Network;
    ULONG              bytesSent = (ULONG)Irp->IoStatus.Information;
    NTSTATUS           status = Irp->IoStatus.Status;
    PCNP_HEADER        cnpHeader = Request->CnpHeader;


    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    if (NT_SUCCESS(status)) {
        //
        // Subtract the CNP header from the count of bytes sent.
        //
        if (bytesSent >= sizeof(CNP_HEADER)) {
            bytesSent -= sizeof(CNP_HEADER);
        }
        else {
            CnAssert(FALSE);
            bytesSent = 0;
        }

        //
        // If CNP signed the message, subtract the signature
        // data from the count of bytes sent.
        //
        if (cnpHeader->Version == CNP_VERSION_MULTICAST) {
            CNP_SIGNATURE UNALIGNED * cnpSig;

            cnpSig = (CNP_SIGNATURE UNALIGNED *)(cnpHeader + 1);

            if (bytesSent >= (ULONG)CNP_SIGHDR_LENGTH &&
                bytesSent >= cnpSig->PayloadOffset) {
                bytesSent -= cnpSig->PayloadOffset;
            } else {
                CnAssert(FALSE);
                bytesSent = 0;
            }
        }

        CnTrace(CNP_SEND_DETAIL, CnpTraceSendComplete,
            "[CNP] Send of packet to node %u on net %u complete, "
            "bytes sent %u.",
            cnpHeader->DestinationAddress, // LOGULONG
            network->Id, // LOGULONG
            bytesSent // LOGULONG
            );                
    }
    else {
        //
        // It is possible to reach this path with 
        // status = c0000240 (STATUS_REQUEST_ABORTED) and
        // bytesSent > 0.
        //
        bytesSent = 0;

        CnTrace(CNP_SEND_ERROR, CnpTraceSendFailedBelow,
            "[CNP] Tcpip failed to send packet to node %u on net %u, "
            "data len %u, status %!status!",
            cnpHeader->DestinationAddress, // LOGULONG
            network->Id, // LOGULONG
            cnpHeader->PayloadLength, // LOGUSHORT
            status // LOGSTATUS
            );                
    }

    //
    // Remove the active reference we put on the network.
    //
    CnAcquireLock(&(network->Lock), &(network->Irql));
    CnpActiveDereferenceNetwork(network);

    //
    // Free the TDI address buffer
    //
    CnFreePool(Request->TdiSendDatagramInfo.RemoteAddress);

    //
    // Call the upper protocol's completion routine
    //
    if (Request->CompletionRoutine) {
        (*(Request->CompletionRoutine))(
            status,
            &bytesSent,
            Request,
            DataMdl
            );
    }

    //
    // Update the Information field of the completed IRP to
    // reflect the actual bytes sent (adjusted for the CNP
    // and upper protocol headers).
    //
    Irp->IoStatus.Information = bytesSent;

    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    return;

}  // CnpCompleteSendPacketCommon



NTSTATUS
CnpCompleteSendPacketNewIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
{
    PCNP_SEND_REQUEST  request = Context;
    PIRP               upperIrp = request->UpperProtocolIrp;
    PMDL               dataMdl;
    
    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    //
    // Unlink the data MDL chain from the header MDL.
    //
    CnAssert(Irp->MdlAddress == request->HeaderMdl);
    dataMdl = request->HeaderMdl->Next;
    request->HeaderMdl->Next = NULL;
    Irp->MdlAddress = NULL;

    CnpCompleteSendPacketCommon(Irp, request, dataMdl);

    //
    // Complete the upper-level IRP, if there is one
    //
    if (upperIrp != NULL) {
        
        IF_CNDBG( CN_DEBUG_CNPSEND )
            CNPRINT(("[CNP] CnpCompleteSendPacketNewIrp calling "
                     "CnCompleteRequest for IRP %p with status "
                     "%08x\n",
                     upperIrp, Irp->IoStatus.Status));
        
        CnAcquireCancelSpinLock(&(upperIrp->CancelIrql));
        CnCompletePendingRequest(
            upperIrp,
            Irp->IoStatus.Status,            // status
            (ULONG)Irp->IoStatus.Information // bytes returned
            );
        
        //
        // The IoCancelSpinLock was released by the completion routine.
        //
    }

    //
    // Free the new IRP
    //
    IoFreeIrp(Irp);

    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    return(STATUS_MORE_PROCESSING_REQUIRED);

}  // CnpCompleteSendPacketNewIrp



NTSTATUS
CnpCompleteSendPacketReuseIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
{
    PCNP_SEND_REQUEST  request = Context;
    PMDL               dataMdl;
    
    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    //
    // Unlink the data MDL chain from the header MDL.
    //
    CnAssert(Irp->MdlAddress == request->HeaderMdl);
    dataMdl = request->HeaderMdl->Next;
    request->HeaderMdl->Next = NULL;

    //
    // Restore the requestor mode of the upper protocol IRP.
    //
    Irp->RequestorMode = request->UpperProtocolIrpMode;

    //
    // Restore the MDL of the upper protocol IRP.
    //
    Irp->MdlAddress = request->UpperProtocolMdl;

    CnpCompleteSendPacketCommon(Irp, request, dataMdl);

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    IF_CNDBG( CN_DEBUG_CNPSEND )
        CNPRINT(("[CNP] CnpCompleteSendPacketReuseIrp returning "
                 "IRP %p to I/O Manager\n",
                 Irp));

    CnVerifyCpuLockMask(
        0,                // Required
        0xFFFFFFFF,       // Forbidden
        0                 // Maximum
        );

    return(STATUS_SUCCESS);

}  // CnpCompleteSendPacketReuseIrp



NTSTATUS
CnpSendPacket(
    IN PCNP_SEND_REQUEST    SendRequest,
    IN CL_NODE_ID           DestNodeId,
    IN PMDL                 DataMdl,
    IN USHORT               DataLength,
    IN BOOLEAN              CheckDestState,
    IN CL_NETWORK_ID        NetworkId        OPTIONAL
    )
/*++

Routine Description:

    Main send routine for CNP. Handles unicast and multicast
    sends.
    
--*/
{
    NTSTATUS               status = STATUS_SUCCESS;
    PCNP_HEADER            cnpHeader = SendRequest->CnpHeader;
    PIRP                   upperIrp = SendRequest->UpperProtocolIrp;
    CN_IRQL                tableIrql;
    BOOLEAN                multicast = FALSE;
    CL_NETWORK_ID          networkId = NetworkId;
    CN_IRQL                cancelIrql;
    BOOLEAN                cnComplete = FALSE;
    BOOLEAN                destNodeLocked = FALSE;
    PCNP_NODE              destNode;
    ULONG                  sigDataLen;
    PCNP_INTERFACE         interface;
    PCNP_NETWORK           network;
    BOOLEAN                networkReferenced = FALSE;
    PIRP                   irp;
    PVOID                  addressBuffer = NULL;
    PIO_COMPLETION_ROUTINE compRoutine;
    PDEVICE_OBJECT         targetDeviceObject;
    PFILE_OBJECT           targetFileObject;
    BOOLEAN                mcastGroupReferenced = FALSE;


    CnVerifyCpuLockMask(
        0,                           // Required
        CNP_LOCK_RANGE,              // Forbidden
        CNP_PRECEEDING_LOCK_RANGE    // Maximum
        );

    IF_CNDBG( CN_DEBUG_CNPSEND )
        CNPRINT(("[CNP] CnpSendPacket called with upper IRP %p\n",
                 upperIrp));

    //
    // Make all the tests to see if we can send the packet.
    //

    //
    // Acquire the node table lock to match the destination node id
    // to a node object.
    //
    CnAcquireLock(&CnpNodeTableLock, &tableIrql);

    if (CnpNodeTable == NULL) {
        CnReleaseLock(&CnpNodeTableLock, tableIrql);
        status = STATUS_NETWORK_UNREACHABLE;
        goto error_exit;
    }

    //
    // Fill in the local node ID while we still hold the node table lock.
    //
    CnAssert(CnLocalNodeId != ClusterInvalidNodeId);
    cnpHeader->SourceAddress = CnLocalNodeId;

    //
    // Check first if the destination node id indicates that this is
    // a multicast.
    //
    if (DestNodeId == ClusterAnyNodeId) {

        //
        // This is a multicast. For multicasts, we use the local
        // node in place of the dest node to validate the network
        // and interface.
        //
        multicast = TRUE;
        destNode = CnpLockedFindNode(CnLocalNodeId, tableIrql);
    }

    //
    // Not a multicast. The destination node id must be valid.
    //
    else if (!CnIsValidNodeId(DestNodeId)) {
        CnReleaseLock(&CnpNodeTableLock, tableIrql);
        status = STATUS_INVALID_ADDRESS_COMPONENT;
        goto error_exit;
    }

    //
    // Find the destination node object in the node table.
    //
    else {
        destNode = CnpLockedFindNode(DestNodeId, tableIrql);
    }

    //
    // The NodeTableLock was released. Verify that we know about
    // the destination node.
    //
    if (destNode == NULL) {
        status = STATUS_HOST_UNREACHABLE;
        goto error_exit;
    }

    destNodeLocked = TRUE;

    //
    // CNP multicast messages must be signed.
    //
    if (multicast) {

        CnAssert(((CNP_HEADER UNALIGNED *)(SendRequest->CnpHeader))
                 ->Version = CNP_VERSION_MULTICAST);

        //
        // Sign the data, starting with the upper protocol header
        // and finishing with the data payload.
        // 
        // If we are requesting the current best multicast network,
        // we need to make sure that the mcast group data structure
        // is dereferenced.
        //
        mcastGroupReferenced = (BOOLEAN)(networkId == ClusterAnyNetworkId);

        status = CnpSignMulticastMessage(
                     SendRequest,
                     DataMdl,
                     &networkId,
                     &sigDataLen
                     );
        if (status != STATUS_SUCCESS) {
            mcastGroupReferenced = FALSE;
            goto error_exit;
        }


    } else {
        sigDataLen = 0;
    }

    //
    // Choose the destination interface.
    //
    if (networkId != ClusterAnyNetworkId) {
        
        //
        // we really want to send this packet over the indicated
        // network. walk the node's interface list matching the
        // supplied network id to the interface's network ID and
        // send the packet on that interface
        //
        
        PLIST_ENTRY      entry;
        
        for (entry = destNode->InterfaceList.Flink;
             entry != &(destNode->InterfaceList);
             entry = entry->Flink
             )
            {
                interface = CONTAINING_RECORD(
                                entry,
                                CNP_INTERFACE,
                                NodeLinkage
                                );

                if ( interface->Network->Id == networkId ) {
                    break;
                }
            }

        if ( entry == &destNode->InterfaceList ) {
            //
            // no network object with the specified ID. if 
            // this is the network the sender designated,
            // fail the send.
            //
            status = STATUS_NETWORK_UNREACHABLE;
            goto error_exit;
        }
    } else {
        interface = destNode->CurrentInterface;
    }

    //
    // Verify that we know about the destination interface.
    //
    if (interface == NULL) {
        // No interface for node. Must be down. Note that the
        // HOST_DOWN error code should cause the caller to give
        // up immediately.
        status = STATUS_HOST_DOWN;
        // status = STATUS_HOST_UNREACHABLE;

        goto error_exit;
    }

    //
    // Verify that everything is online. If all looks okay,
    // take an active reference on the network.
    //
    // For unicasts, verify the state of destination interface,
    // node, and intervening network.
    //
    // For multicasts, verify the state of the network and 
    // its multicast capability.
    //
    network = interface->Network;

    if ( (!multicast)
         && 
         ( (interface->State > ClusnetInterfaceStateOfflinePending)
           &&
           (destNode->CommState == ClusnetNodeCommStateOnline)
         )
       )
    {
        //
        // Everything checks out. Reference the network so
        // it can't go offline while we are using it.
        //
        CnAcquireLockAtDpc(&(network->Lock));
        CnAssert(network->State >= ClusnetNetworkStateOfflinePending);
        CnpActiveReferenceNetwork(network);
        CnReleaseLockFromDpc(&(network->Lock));
        networkReferenced = TRUE;

    } else {
        //
        // Either the node is not online or this is a 
        // multicast (in which case we don't bother checking
        // the status of all the nodes). Figure out what to do.
        //
        if (!multicast && CheckDestState) {
            //
            // Caller doesn't want to send to a down node.
            // Bail out. Note that the HOST_DOWN error code
            // should cause the caller to give up immediately.
            //
            status = STATUS_HOST_DOWN;
            // status = STATUS_HOST_UNREACHABLE;

            goto error_exit;
        }

        CnAcquireLockAtDpc(&(network->Lock));

        if (network->State <= ClusnetNetworkStateOfflinePending) {
            //
            // The chosen network is not online.
            // Bail out.
            //
            CnReleaseLockFromDpc(&(network->Lock));
            status = STATUS_HOST_UNREACHABLE;
            goto error_exit;
        }

        //
        // Multicast checks.
        //
        if (multicast) {

            //
            // Verify that the chosen network has been
            // enabled for multicast.
            //
            if (!CnpIsNetworkMulticastCapable(network)) {
                CnReleaseLockFromDpc(&(network->Lock));
                status = STATUS_HOST_UNREACHABLE;
                goto error_exit;
            }
        }

        //
        // The network is online, even if the host isn't.
        // The caller doesn't care. Go for it.
        //
        CnpActiveReferenceNetwork(network);
        CnReleaseLockFromDpc(&(network->Lock));
        networkReferenced = TRUE;
    }

    //
    // Allocate a buffer for the destination address.
    //
    addressBuffer = CnAllocatePool(interface->TdiAddressLength);

    if (addressBuffer == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto error_exit;
    }

    //
    // Fill in the address buffer, and save it in the send
    // request data structure.
    //
    if (multicast) {

        PCNP_MULTICAST_GROUP   mcastGroup = SendRequest->McastGroup;
        
        CnAssert(mcastGroup != NULL);

        CnAssert(
            CnpIsIPv4McastTransportAddress(mcastGroup->McastTdiAddress)
            );
        CnAssert(
            mcastGroup->McastTdiAddressLength == interface->TdiAddressLength
            );

        RtlMoveMemory(
            addressBuffer,
            mcastGroup->McastTdiAddress,
            mcastGroup->McastTdiAddressLength
            );

        SendRequest->TdiSendDatagramInfo.RemoteAddressLength =
            mcastGroup->McastTdiAddressLength;

        if (mcastGroupReferenced) {
            CnpDereferenceMulticastGroup(mcastGroup);
            mcastGroupReferenced = FALSE;
            SendRequest->McastGroup = NULL;
        }

        targetFileObject = network->DatagramFileObject;
        targetDeviceObject = network->DatagramDeviceObject;

    } else {

        CnAssert(mcastGroupReferenced == FALSE);
        
        RtlMoveMemory(
            addressBuffer,
            &(interface->TdiAddress),
            interface->TdiAddressLength
            );

        SendRequest->TdiSendDatagramInfo.RemoteAddressLength =
            interface->TdiAddressLength;

        targetFileObject = network->DatagramFileObject;
        targetDeviceObject = network->DatagramDeviceObject;
    }

    SendRequest->TdiSendDatagramInfo.RemoteAddress =
        addressBuffer;

    //
    // Release the node lock.
    //
    CnReleaseLock(&(destNode->Lock), destNode->Irql);
    destNodeLocked = FALSE;

    //
    // If there is an upper protocol IRP, see 
    // if it has enough stack locations.
    //
    if ( (upperIrp != NULL)
         && 
         (CnpIsIrpStackSufficient(upperIrp, targetDeviceObject))
       ) {

        //
        // We can use the upper protocol IRP.
        //
        irp = upperIrp;
        compRoutine = CnpCompleteSendPacketReuseIrp;

        //
        // Ensure that IRP is marked as a kernel request,
        // but first save the current requestor mode so
        // that it can be restored later.
        //
        SendRequest->UpperProtocolIrpMode = irp->RequestorMode;
        irp->RequestorMode = KernelMode;

        //
        // Save the upper protocol IRP MDL to restore
        // later. This is probably the same as DataMdl,
        // but we don't want to make any assumptions.
        //
        SendRequest->UpperProtocolMdl = irp->MdlAddress;

    } else {

        //
        // We cannot use the upper protocol IRP.
        //
        // If there is an upper protocol IRP, it needs
        // to be marked pending.
        //
        if (upperIrp != NULL) {

            CnAcquireCancelSpinLock(&cancelIrql);

            status = CnMarkRequestPending(
                         upperIrp, 
                         IoGetCurrentIrpStackLocation(upperIrp),
                         NULL
                         );

            CnReleaseCancelSpinLock(cancelIrql);

            if (status == STATUS_CANCELLED) {
                //
                // Bail out
                //
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto error_exit;

            } else {
                //
                // If IoAllocateIrp fails, we need
                // to call CnCompletePendingRequest
                // now that we've called 
                // CnMarkRequestPending.
                //
                cnComplete = TRUE;
            }
        }

        //
        // Allocate a new IRP
        //
        irp = IoAllocateIrp(
                  targetDeviceObject->StackSize,
                  FALSE
                  );
        if (irp == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto error_exit;
        }
    
        //
        // Use the completion routine for having
        // allocated a new IRP
        //
        compRoutine = CnpCompleteSendPacketNewIrp;

        //
        // Fill in IRP fields that are not specific
        // to any one stack location.
        //
        irp->Flags = 0;
        irp->RequestorMode = KernelMode;
        irp->PendingReturned = FALSE;

        irp->UserIosb = NULL;
        irp->UserEvent = NULL;

        irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;

        irp->AssociatedIrp.SystemBuffer = NULL;
        irp->UserBuffer = NULL;

        irp->Tail.Overlay.Thread = PsGetCurrentThread();
        irp->Tail.Overlay.AuxiliaryBuffer = NULL;
    }

    //
    // Ok, we can finally send the packet.
    //
    SendRequest->Network = network;

    //
    // Link the data MDL chain after the header MDL.
    //
    SendRequest->HeaderMdl->Next = DataMdl;

    //
    // Finish building the CNP header.
    //
    cnpHeader->DestinationAddress = DestNodeId;
    cnpHeader->PayloadLength =
        SendRequest->UpperProtocolHeaderLength + DataLength;

    //
    // Build the next irp stack location.
    //
    TdiBuildSendDatagram(
        irp,
        targetDeviceObject,
        targetFileObject,
        compRoutine,
        SendRequest,
        SendRequest->HeaderMdl,
        cnpHeader->PayloadLength + sizeof(CNP_HEADER) + sigDataLen,
        &(SendRequest->TdiSendDatagramInfo)
        );

    CnTrace(CNP_SEND_DETAIL, CnpTraceSend,
        "[CNP] Sending packet to node %u on net %u, "
        "data len %u",
        cnpHeader->DestinationAddress, // LOGULONG
        network->Id, // LOGULONG
        cnpHeader->PayloadLength // LOGUSHORT
        );         

    //
    // Now send the packet.
    //
    status = IoCallDriver(
                 targetDeviceObject,
                 irp
                 );

    CnVerifyCpuLockMask(
        0,                           // Required
        CNP_LOCK_RANGE,              // Forbidden
        CNP_PRECEEDING_LOCK_RANGE    // Maximum
        );

    return(status);


    //
    // The following code is only executed in an error condition,
    // No send IRP has been submitted to a lower-level driver.
    //

error_exit:

    CnTrace(CNP_SEND_ERROR, CnpTraceSendFailedInternal,
        "[CNP] Failed to send packet to node %u on net %u, "
        "data len %u, status %!status!",
        cnpHeader->DestinationAddress, // LOGULONG
        NetworkId, // LOGULONG
        cnpHeader->PayloadLength, // LOGUSHORT
        status // LOGSTATUS
        );

    if (destNodeLocked) {
        CnReleaseLock(&(destNode->Lock), destNode->Irql);
        destNodeLocked = FALSE;
    }
    
    if (networkReferenced) {
        //
        // Remove the active reference we put on the network.
        //
        CnAcquireLock(&(network->Lock), &(network->Irql));
        CnpActiveDereferenceNetwork(network);
        networkReferenced = FALSE;
    }

    if (mcastGroupReferenced) {
        CnAssert(SendRequest->McastGroup != NULL);
        CnpDereferenceMulticastGroup(SendRequest->McastGroup);
        SendRequest->McastGroup = NULL;
        mcastGroupReferenced = FALSE;
    }

    if (addressBuffer != NULL) {
        CnFreePool(addressBuffer);
    }

    //
    // Call the upper protocol completion routine
    //
    if (SendRequest->CompletionRoutine) {

        ULONG bytesSent = 0;

        (*SendRequest->CompletionRoutine)(
            status,
            &bytesSent,
            SendRequest,
            DataMdl
            );
    }

    //
    // Complete the upper protocol IRP, if there is one
    //
    if (upperIrp) {

        if (cnComplete) {

            //
            // CnMarkRequestPending was called for upperIrp.
            //
            IF_CNDBG( CN_DEBUG_CNPSEND )
                CNPRINT(("[CNP] Calling CnCompletePendingRequest "
                         "for IRP %p with status %08x\n",
                         upperIrp, status));

            CnCompletePendingRequest(upperIrp, status, 0);
        
        } else {
            
            IF_CNDBG( CN_DEBUG_CNPSEND )
                CNPRINT(("[CNP] Completing IRP %p with status %08x\n",
                         upperIrp, status));

            upperIrp->IoStatus.Status = status;
            upperIrp->IoStatus.Information = 0;
            IoCompleteRequest(upperIrp, IO_NO_INCREMENT);
        }        
    }
    
    CnVerifyCpuLockMask(
        0,                           // Required
        CNP_LOCK_RANGE,              // Forbidden
        CNP_PRECEEDING_LOCK_RANGE    // Maximum
        );

    return(status);

} // CnpSendPacket
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\xport\cxaddr.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cxaddr.c

Abstract:

    TDI Address Object management code.

Author:

    Mike Massa (mikemas)           February 20, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     02-20-97    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "cxaddr.tmh"


#define CX_WILDCARD_PORT   0           // 0 means assign a port.

#define CX_MIN_USER_PORT   1025        // Minimum value for a wildcard port
#define CX_MAX_USER_PORT   5000        // Maximim value for a user port.
#define CX_NUM_USER_PORTS  (CX_MAX_USER_PORT - CX_MIN_USER_PORT + 1)

//
// Address Object Data
//
USHORT              CxNextUserPort = CX_MIN_USER_PORT;
LIST_ENTRY          CxAddrObjTable[CX_ADDROBJ_TABLE_SIZE];
#if DBG
CN_LOCK             CxAddrObjTableLock = {0,0};
#else  // DBG
CN_LOCK             CxAddrObjTableLock = 0;
#endif // DBG



NTSTATUS
CxParseTransportAddress(
    IN  TRANSPORT_ADDRESS UNALIGNED *AddrList,
    IN  ULONG                        AddressListLength,
    OUT CL_NODE_ID *                 Node,
    OUT PUSHORT                      Port
    )
{
    LONG                             i;
    PTA_ADDRESS                      currentAddr;
    TDI_ADDRESS_CLUSTER UNALIGNED *  validAddr;

    if (AddressListLength >= sizeof(TA_CLUSTER_ADDRESS)) {
        //
        // Find an address we can use.
        //
        currentAddr = (PTA_ADDRESS) AddrList->Address;

        for (i = 0; i < AddrList->TAAddressCount; i++) {
            if ( (currentAddr->AddressType == TDI_ADDRESS_TYPE_CLUSTER) &&
                 (currentAddr->AddressLength >= TDI_ADDRESS_LENGTH_CLUSTER)
               )
            {
                validAddr = (TDI_ADDRESS_CLUSTER UNALIGNED *)
                            currentAddr->Address;

                *Node = validAddr->Node;
                *Port = validAddr->Port;

                return(STATUS_SUCCESS);
            }
            else {
                if ( AddressListLength >=
                     (currentAddr->AddressLength + sizeof(TA_CLUSTER_ADDRESS))
                   )
                {
                    AddressListLength -= currentAddr->AddressLength;

                    currentAddr = (PTA_ADDRESS)
                                  ( currentAddr->Address +
                                    currentAddr->AddressLength
                                  );
                }
                else {
                    break;
                }
            }
        }
    }

    return(STATUS_INVALID_ADDRESS_COMPONENT);

} // CxParseTransportAddress


PCX_ADDROBJ
CxFindAddressObject(
    IN USHORT  Port
    )
/*++

Notes:

    Called with AO Table lock held.
    Returns with address object lock held.

--*/
{
    PLIST_ENTRY          entry;
    ULONG                hashBucket = CX_ADDROBJ_TABLE_HASH(Port);
    PCX_ADDROBJ          addrObj;


    for ( entry = CxAddrObjTable[hashBucket].Flink;
          entry != &(CxAddrObjTable[hashBucket]);
          entry = entry->Flink
        )
    {
        addrObj = CONTAINING_RECORD(
                      entry,
                      CX_ADDROBJ,
                      AOTableLinkage
                      );

        if (addrObj->LocalPort == Port) {
            CnAcquireLockAtDpc(&(addrObj->Lock));
            addrObj->Irql = DISPATCH_LEVEL;

            return(addrObj);
        }
    }

    return(NULL);

}  // CxFindAddressObject


NTSTATUS
CxOpenAddress(
    OUT PCN_FSCONTEXT *                CnFsContext,
    IN  TRANSPORT_ADDRESS UNALIGNED *  TransportAddress,
    IN  ULONG                          TransportAddressLength
    )
{
    PCX_ADDROBJ          addrObj, oldAddrObj;
    NTSTATUS             status;
    CL_NODE_ID           nodeId;
    USHORT               port;
    CN_IRQL              tableIrql;
    ULONG                i;
    ULONG                hashBucket;


    status = CxParseTransportAddress(
                 TransportAddress,
                 TransportAddressLength,
                 &nodeId,
                 &port
                 );

    if (status != STATUS_SUCCESS) {
        IF_CNDBG(CN_DEBUG_ADDROBJ) {
            CNPRINT((
                "[Clusnet] Open address - failed to parse address, status %lx\n",
                status
                ));
        }
        return(status);
    }

    addrObj = CnAllocatePool(sizeof(CX_ADDROBJ));

    if (addrObj == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlZeroMemory(addrObj, sizeof(CX_ADDROBJ));
    CN_INIT_SIGNATURE(&(addrObj->FsContext), CX_ADDROBJ_SIG);
    CnInitializeLock(&(addrObj->Lock), CX_ADDROBJ_LOCK);
    addrObj->Flags |= CX_AO_FLAG_CHECKSTATE;

    CnAcquireLock(&CxAddrObjTableLock, &tableIrql);

    // If no port is specified we have to assign one. If there is a
    // port specified, we need to make sure that the port isn't
    // already open. If the input address is a wildcard, we need to
    // assign one ourselves.

    if (port == CX_WILDCARD_PORT) {
        port = CxNextUserPort;

        for (i = 0; i < CX_NUM_USER_PORTS; i++, port++) {
            if (port > CX_MAX_USER_PORT) {
                port = CX_MIN_USER_PORT;
            }

            oldAddrObj = CxFindAddressObject(port);

            if (oldAddrObj == NULL) {
                IF_CNDBG(CN_DEBUG_ADDROBJ) {
                    CNPRINT(("[Clusnet] Assigning port %u\n", port));
                }
                break;              // Found an unused port.
            }

            CnReleaseLockFromDpc(&(oldAddrObj->Lock));
        }

        if (i == CX_NUM_USER_PORTS) {  // Couldn't find a free port.
            IF_CNDBG(CN_DEBUG_ADDROBJ) {
                CNPRINT((
                    "[Clusnet] No free wildcard ports.\n"
                    ));
            }

            CnReleaseLock(&CxAddrObjTableLock, tableIrql);
            CnFreePool(addrObj);
            return (STATUS_TOO_MANY_ADDRESSES);
        }

        CxNextUserPort = port + 1;

    } else {                        // Address was specificed
        oldAddrObj = CxFindAddressObject(port);

        if (oldAddrObj != NULL) {
            IF_CNDBG(CN_DEBUG_ADDROBJ) {
                CNPRINT((
                    "[Clusnet] Port %u is already in use.\n",
                    port
                    ));
            }

            CnReleaseLockFromDpc(&(oldAddrObj->Lock));
            CnReleaseLock(&CxAddrObjTableLock, tableIrql);
            CnFreePool(addrObj);
            return (STATUS_ADDRESS_ALREADY_EXISTS);
        }
    }

    addrObj->LocalPort = port;

    hashBucket = CX_ADDROBJ_TABLE_HASH(port);

    InsertHeadList(
        &(CxAddrObjTable[hashBucket]),
        &(addrObj->AOTableLinkage)
        );

    *CnFsContext = (PCN_FSCONTEXT) addrObj;

    IF_CNDBG(CN_DEBUG_ADDROBJ) {
        CNPRINT((
            "[Clusnet] Opened address object %p for port %u\n",
            addrObj,
            port
            ));
    }

    CnTrace(
        CDP_ADDR_DETAIL, CdpTraceOpenAO,
        "[Clusnet] Opened address object %p for port %u.",
        addrObj,
        port
        );

    CnReleaseLock(&CxAddrObjTableLock, tableIrql);

    return(STATUS_SUCCESS);

}  // CxOpenAddress


NTSTATUS
CxCloseAddress(
    IN PCN_FSCONTEXT CnFsContext
    )
{
    PCX_ADDROBJ   addrObj = (PCX_ADDROBJ) CnFsContext;
    CN_IRQL       tableIrql;


    IF_CNDBG(CN_DEBUG_ADDROBJ) {
        CNPRINT((
            "[Clusnet] Closed address object %p for port %u\n",
            addrObj,
            addrObj->LocalPort
            ));
    }

    CnTrace(
        CDP_ADDR_DETAIL, CdpTraceCloseAO,
        "[Clusnet] Closed address object %p for port %u.",
        addrObj,
        addrObj->LocalPort
        );

    CnAcquireLock(&CxAddrObjTableLock, &tableIrql);
    CnAcquireLockAtDpc(&(addrObj->Lock));

    RemoveEntryList(&(addrObj->AOTableLinkage));

    CnReleaseLockFromDpc(&(addrObj->Lock));
    CnReleaseLock(&CxAddrObjTableLock, tableIrql);

    //
    // The address object memory will be freed by the common code.
    //

    return(STATUS_SUCCESS);

} // CxCloseAddress


NTSTATUS
CxSetEventHandler(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp
    )
{
    NTSTATUS status = STATUS_SUCCESS;
    PTDI_REQUEST_KERNEL_SET_EVENT request;
    PCX_ADDROBJ addrObj;
    CN_IRQL irql;


    //
    // Since this ioctl registers a callback function pointer, ensure
    // that it was issued by a kernel-mode component.
    //
    if (Irp->RequestorMode != KernelMode) {
        return(STATUS_ACCESS_DENIED);
    }

    addrObj = (PCX_ADDROBJ) IrpSp->FileObject->FsContext;
    request = (PTDI_REQUEST_KERNEL_SET_EVENT) &(IrpSp->Parameters);

    IF_CNDBG(CN_DEBUG_ADDROBJ) {
        CNPRINT((
            "[Clusnet] TdiSetEvent type %u handler %p context %p\n",
            request->EventType,
            request->EventHandler,
            request->EventContext
            ));
    }

    CnAcquireLock(&(addrObj->Lock), &irql);

    switch (request->EventType) {

        case TDI_EVENT_ERROR:
            addrObj->ErrorHandler = request->EventHandler;
            addrObj->ErrorContext = request->EventContext;
            break;
        case TDI_EVENT_RECEIVE_DATAGRAM:
            addrObj->ReceiveDatagramHandler = request->EventHandler;
            addrObj->ReceiveDatagramContext = request->EventContext;
            break;
        case TDI_EVENT_CHAINED_RECEIVE_DATAGRAM:
            addrObj->ChainedReceiveDatagramHandler = request->EventHandler;
            addrObj->ChainedReceiveDatagramContext = request->EventContext;
            break;
        default:
            status = STATUS_INVALID_PARAMETER;
            break;
    }

    CnReleaseLock(&(addrObj->Lock), irql);

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    return(status);

}  // CxSetEventHandler


VOID
CxBuildTdiAddress(
    PVOID        Buffer,
    CL_NODE_ID   Node,
    USHORT       Port,
    BOOLEAN      Verified
    )
/*++

Routine Description:

    Called when we need to build a TDI address structure. We fill in
    the specifed buffer with the correct information in the correct
    format.

Arguments:

    Buffer      - Buffer to be filled in as TDI address structure.
    Node        - Node ID to fill in.
    Port        - Port to be filled in.
    Verified    - During a receive, whether clusnet verified the
                  signature and data

Return Value:

    Nothing

--*/
{
    PTRANSPORT_ADDRESS      xportAddr;
    PTA_ADDRESS             taAddr;

    xportAddr = (PTRANSPORT_ADDRESS) Buffer;
    xportAddr->TAAddressCount = 1;
    taAddr = xportAddr->Address;
    taAddr->AddressType = TDI_ADDRESS_TYPE_CLUSTER;
    taAddr->AddressLength = sizeof(TDI_ADDRESS_CLUSTER);
    ((PTDI_ADDRESS_CLUSTER) taAddr->Address)->Port = Port;
    ((PTDI_ADDRESS_CLUSTER) taAddr->Address)->Node = Node;
    ((PTDI_ADDRESS_CLUSTER) taAddr->Address)->ReservedMBZ = 
        ((Verified) ? 1 : 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\xport\cxinfo.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cxinfo.c

Abstract:

    TDI Set/Query Information routines.

Author:

    Mike Massa (mikemas)           February 20, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     02-20-97    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "cxinfo.tmh"


#ifdef ALLOC_PRAGMA


#endif // ALLOC_PRAGMA


#if 0

#define CDP_SERVICE_FLAGS    (TDI_SERVICE_CONNECTIONLESS_MODE | \
                             TDI_SERVICE_BROADCAST_SUPPORTED)
#else // 0

#define CDP_SERVICE_FLAGS    (TDI_SERVICE_CONNECTIONLESS_MODE)

#endif // 0


NTSTATUS
CxQueryInformation(
    IN PIRP                  Irp,
    IN PIO_STACK_LOCATION    IrpSp
    )
{
    NTSTATUS                                status = STATUS_SUCCESS;
    PCN_FSCONTEXT                           fsContext;
    PCX_ADDROBJ                             addrObj;
    CN_IRQL                                 irql;
    PTDI_REQUEST_KERNEL_QUERY_INFORMATION   queryInformation;
    ULONG                                   fileType;
    ULONG                                   infoSize;
    PVOID                                   infoBuffer;
    union {
        TDI_PROVIDER_INFO  ProviderInfo;
        TDI_ADDRESS_INFO   AddressInfo;
        struct {
            TDI_ADDRESS_INFO     AddressInfo;
            TDI_ADDRESS_CLUSTER  ClusterAddress;
        } DummyAddressInfo;
    } info;


    fsContext = (PCN_FSCONTEXT) IrpSp->FileObject->FsContext;
    fileType = PtrToUlong(IrpSp->FileObject->FsContext2);
    queryInformation = (PTDI_REQUEST_KERNEL_QUERY_INFORMATION)
                           &(IrpSp->Parameters);

    IF_CNDBG(CN_DEBUG_INFO) {
        CNPRINT((
            "[Clusnet] TDI query info type %u\n",
            queryInformation->QueryType
            ));
    }

    switch(queryInformation->QueryType) {

    case TDI_QUERY_BROADCAST_ADDRESS:
        CnAssert(fileType == TDI_CONTROL_CHANNEL_FILE);
        status = STATUS_NOT_IMPLEMENTED;
        break;

    case TDI_QUERY_PROVIDER_INFO:
        CnAssert(fileType == TDI_CONTROL_CHANNEL_FILE);

        infoSize = sizeof(info.ProviderInfo);
        infoBuffer = &(info.ProviderInfo);
        info.ProviderInfo.Version = 0x0100;
        info.ProviderInfo.MaxSendSize = 0;
        info.ProviderInfo.MaxConnectionUserData = 0;
        info.ProviderInfo.MaxDatagramSize = 
            CDP_MAX_SEND_SIZE(CX_SIGNATURE_LENGTH);
        info.ProviderInfo.ServiceFlags = CDP_SERVICE_FLAGS;
        info.ProviderInfo.MinimumLookaheadData = 1;
        info.ProviderInfo.MaximumLookaheadData = 0xFFFFF;
        info.ProviderInfo.NumberOfResources = 0;
        info.ProviderInfo.StartTime.QuadPart = 0;

        break;

    case TDI_QUERY_PROVIDER_STATISTICS:
        CnAssert(fileType == TDI_CONTROL_CHANNEL_FILE);
        status = STATUS_NOT_IMPLEMENTED;
        break;

    case TDI_QUERY_ADDRESS_INFO:
        if (fileType == TDI_TRANSPORT_ADDRESS_FILE) {
            infoSize = FIELD_OFFSET(TDI_ADDRESS_INFO, Address) +
                       sizeof(TA_CLUSTER_ADDRESS);
            infoBuffer = &(info.AddressInfo);
            addrObj = (PCX_ADDROBJ) fsContext;

            //
            // Since no one knows what the activity count means, we'll just set
            // it to 1.
            //
            info.AddressInfo.ActivityCount = 1;

            CnAcquireLock(&(addrObj->Lock), &irql);

            CxBuildTdiAddress(
                &(info.AddressInfo.Address),
                CnLocalNodeId,
                addrObj->LocalPort,
                FALSE
                );

            CnReleaseLock(&(addrObj->Lock), irql);
        }
        else {
            status = STATUS_INVALID_DEVICE_REQUEST;
        }

        break;

    default:
        status = STATUS_INVALID_PARAMETER;
        break;
    }

    if (status == STATUS_SUCCESS) {

        PULONG pnBytes = &((ULONG)(Irp->IoStatus.Information));

        status = TdiCopyBufferToMdl(
                     infoBuffer,
                     0,
                     infoSize,
                     Irp->MdlAddress,
                     0,
                     pnBytes
                     );
    }

    IF_CNDBG(CN_DEBUG_INFO) {
        CNPRINT((
            "[Clusnet] TDI query info returning status %lx, %u bytes\n",
            status,
            (ULONG)(Irp->IoStatus.Information)
            ));
    }

    return(status);

}  // CxQueryInformation
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\xport\cxdisp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cxdisp.c

Abstract:

    Dispatch routines for the Cluster Transport.

Author:

    Mike Massa (mikemas)           July 29, 1996

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     07-29-96    created

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#include "cxdisp.tmh"

#include <align.h>

//
// Local Prototypes
//
NTSTATUS
CxDispatchRegisterNode(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchDeregisterNode(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchRegisterNetwork(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchDeregisterNetwork(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchRegisterInterface(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchDeregisterInterface(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchOnlineNodeComm(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchOfflineNodeComm(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchOnlineNetwork(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchOfflineNetwork(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchSetNetworkRestriction(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchGetNetworkPriority(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchSetNetworkPriority(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchGetInterfacePriority(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchSetInterfacePriority(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchGetNodeState(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchGetNetworkState(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchGetInterfaceState(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchIgnoreNodeState(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchGetNodeMembershipState(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchSetNodeMembershipState(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchSendPoisonPacket(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchSetOuterscreen(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchRegroupFinished(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchImportSecurityContext(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchReserveClusnetEndpoint(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchConfigureMulticast(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchGetMulticastReachableSet(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );


#if DBG

NTSTATUS
CxDispatchOnlinePendingInterface(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchOnlineInterface(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchOfflineInterface(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchFailInterface(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
CxDispatchSendMmMsg(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    );


#endif // DBG


#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, CxDispatchDeviceControl)
#pragma alloc_text(PAGE, CxDispatchRegisterNode)
#pragma alloc_text(PAGE, CxDispatchDeregisterNode)
#pragma alloc_text(PAGE, CxDispatchRegisterNetwork)
#pragma alloc_text(PAGE, CxDispatchDeregisterNetwork)
#pragma alloc_text(PAGE, CxDispatchRegisterInterface)
#pragma alloc_text(PAGE, CxDispatchDeregisterInterface)
#pragma alloc_text(PAGE, CxDispatchOnlineNodeComm)
#pragma alloc_text(PAGE, CxDispatchOfflineNodeComm)
#pragma alloc_text(PAGE, CxDispatchOnlineNetwork)
#pragma alloc_text(PAGE, CxDispatchOfflineNetwork)
#pragma alloc_text(PAGE, CxDispatchSetNetworkRestriction)
#pragma alloc_text(PAGE, CxDispatchGetNetworkPriority)
#pragma alloc_text(PAGE, CxDispatchSetNetworkPriority)
#pragma alloc_text(PAGE, CxDispatchGetInterfacePriority)
#pragma alloc_text(PAGE, CxDispatchSetInterfacePriority)
#pragma alloc_text(PAGE, CxDispatchGetNodeState)
#pragma alloc_text(PAGE, CxDispatchGetNetworkState)
#pragma alloc_text(PAGE, CxDispatchGetInterfaceState)
#pragma alloc_text(PAGE, CxDispatchGetNodeMembershipState)
#pragma alloc_text(PAGE, CxDispatchSetNodeMembershipState)
#pragma alloc_text(PAGE, CxDispatchSendPoisonPacket)
#pragma alloc_text(PAGE, CxDispatchSetOuterscreen)
#pragma alloc_text(PAGE, CxDispatchRegroupFinished)
#pragma alloc_text(PAGE, CxDispatchImportSecurityContext)
#pragma alloc_text(PAGE, CxDispatchReserveClusnetEndpoint)
#pragma alloc_text(PAGE, CxDispatchConfigureMulticast)
#pragma alloc_text(PAGE, CxDispatchGetMulticastReachableSet)


#if DBG

#pragma alloc_text(PAGE, CxDispatchOnlinePendingInterface)
#pragma alloc_text(PAGE, CxDispatchOnlineInterface)
#pragma alloc_text(PAGE, CxDispatchOfflineInterface)
#pragma alloc_text(PAGE, CxDispatchFailInterface)
#ifdef MM_IN_CLUSNET
#pragma alloc_text(PAGE, CxDispatchSendMmMsg)
#endif // MM_IN_CLUSNET

#endif // DBG

#endif // ALLOC_PRAGMA




NTSTATUS
CxDispatchDeviceControl(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    Dispatch routine for device control ioctls.

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

Notes:

    Any IRP for which the return value is not STATUS_PENDING will be
    completed by the calling routine.

--*/

{
    NTSTATUS              status;


    PAGED_CODE();

    switch(IrpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_CX_REGISTER_NODE:
            status = CxDispatchRegisterNode(Irp, IrpSp);
            break;

        case IOCTL_CX_DEREGISTER_NODE:
            status = CxDispatchDeregisterNode(Irp, IrpSp);
            break;

        case IOCTL_CX_REGISTER_NETWORK:
            status = CxDispatchRegisterNetwork(Irp, IrpSp);
            break;

        case IOCTL_CX_DEREGISTER_NETWORK:
            status = CxDispatchDeregisterNetwork(Irp, IrpSp);
            break;

        case IOCTL_CX_REGISTER_INTERFACE:
            status = CxDispatchRegisterInterface(Irp, IrpSp);
            break;

        case IOCTL_CX_DEREGISTER_INTERFACE:
            status = CxDispatchDeregisterInterface(Irp, IrpSp);
            break;

        case IOCTL_CX_ONLINE_NODE_COMM:
            status = CxDispatchOnlineNodeComm(Irp, IrpSp);
            break;

        case IOCTL_CX_OFFLINE_NODE_COMM:
            status = CxDispatchOfflineNodeComm(Irp, IrpSp);
            break;

        case IOCTL_CX_ONLINE_NETWORK:
            status = CxDispatchOnlineNetwork(Irp, IrpSp);
            break;

        case IOCTL_CX_OFFLINE_NETWORK:
            status = CxDispatchOfflineNetwork(Irp, IrpSp);
            break;

        case IOCTL_CX_SET_NETWORK_RESTRICTION:
            status = CxDispatchSetNetworkRestriction(Irp, IrpSp);
            break;

        case IOCTL_CX_GET_NETWORK_PRIORITY:
            status = CxDispatchGetNetworkPriority(Irp, IrpSp);
            break;

        case IOCTL_CX_SET_NETWORK_PRIORITY:
            status = CxDispatchSetNetworkPriority(Irp, IrpSp);
            break;

        case IOCTL_CX_GET_INTERFACE_PRIORITY:
            status = CxDispatchGetInterfacePriority(Irp, IrpSp);
            break;

        case IOCTL_CX_SET_INTERFACE_PRIORITY:
            status = CxDispatchSetInterfacePriority(Irp, IrpSp);
            break;

        case IOCTL_CX_GET_NODE_STATE:
            status = CxDispatchGetNodeState(Irp, IrpSp);
            break;

        case IOCTL_CX_GET_NETWORK_STATE:
            status = CxDispatchGetNetworkState(Irp, IrpSp);
            break;

        case IOCTL_CX_GET_INTERFACE_STATE:
            status = CxDispatchGetInterfaceState(Irp, IrpSp);
            break;

        case IOCTL_CX_IGNORE_NODE_STATE:
            status = CxDispatchIgnoreNodeState(Irp, IrpSp);
            break;

        case IOCTL_CX_GET_NODE_MMSTATE:
            status = CxDispatchGetNodeMembershipState(Irp, IrpSp);
            break;

        case IOCTL_CX_SET_NODE_MMSTATE:
            status = CxDispatchSetNodeMembershipState(Irp, IrpSp);
            break;

        case IOCTL_CX_SEND_POISON_PACKET:
            status = CxDispatchSendPoisonPacket(Irp, IrpSp);
            break;

        case IOCTL_CX_SET_OUTERSCREEN:
            status = CxDispatchSetOuterscreen(Irp, IrpSp);
            break;

        case IOCTL_CX_REGROUP_FINISHED:
            status = CxDispatchRegroupFinished(Irp, IrpSp);
            break;

        case IOCTL_CX_IMPORT_SECURITY_CONTEXTS:
            status = CxDispatchImportSecurityContext(Irp, IrpSp);
            break;

        case IOCTL_CX_RESERVE_ENDPOINT:
            status = CxDispatchReserveClusnetEndpoint(Irp, IrpSp);
            break;

        case IOCTL_CX_CONFIGURE_MULTICAST:
            status = CxDispatchConfigureMulticast(Irp, IrpSp);
            break;

        case IOCTL_CX_GET_MULTICAST_REACHABLE_SET:
            status = CxDispatchGetMulticastReachableSet(Irp, IrpSp);
            break;

#if DBG

        case IOCTL_CX_ONLINE_PENDING_INTERFACE:
            status = CxDispatchOnlinePendingInterface(Irp, IrpSp);
            break;

        case IOCTL_CX_ONLINE_INTERFACE:
            status = CxDispatchOnlineInterface(Irp, IrpSp);
            break;

        case IOCTL_CX_OFFLINE_INTERFACE:
            status = CxDispatchOfflineInterface(Irp, IrpSp);
            break;

        case IOCTL_CX_FAIL_INTERFACE:
            status = CxDispatchFailInterface(Irp, IrpSp);
            break;

#ifdef MM_IN_CLUSNET
        case IOCTL_CX_SEND_MM_MSG:
            status = CxDispatchSendMmMsg(Irp, IrpSp);
            break;
#endif // MM_IN_CLUSNET

#endif // DBG

        default:
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    return(status);

} // CxDispatchDeviceControl


NTSTATUS
CxDispatchRegisterNode(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS               status;
    PCX_NODE_REG_REQUEST   request;
    ULONG                  requestSize;


    PAGED_CODE();

    request = (PCX_NODE_REG_REQUEST) Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_NODE_REG_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxRegisterNode(
                 request->Id
                 );

    return(status);

}   // CxDispatchRegisterNode


NTSTATUS
CxDispatchDeregisterNode(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                 status;
    PCX_NODE_DEREG_REQUEST   request;
    ULONG                    requestSize;


    PAGED_CODE();

    request = (PCX_NODE_DEREG_REQUEST) Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_NODE_DEREG_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxDeregisterNode(request->Id, Irp, IrpSp);

    return(status);

}   // CxDispatchDeregisterNode


NTSTATUS
CxDispatchRegisterNetwork(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                    status;
    PCX_NETWORK_REG_REQUEST     request;
    ULONG                       requestSize;


    PAGED_CODE();

    request = (PCX_NETWORK_REG_REQUEST) Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_NETWORK_REG_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxRegisterNetwork(
                 request->Id,
                 request->Priority,
                 request->Restricted
                 );

    return(status);

}   // CxDispatchRegisterNetwork


NTSTATUS
CxDispatchDeregisterNetwork(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                    status;
    PCX_NETWORK_DEREG_REQUEST   request;
    ULONG                       requestSize;


    PAGED_CODE();

    request = (PCX_NETWORK_DEREG_REQUEST) Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_NETWORK_DEREG_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxDeregisterNetwork(request->Id, Irp, IrpSp);

    return(status);

}   // CxDispatchDeregisterNetwork


NTSTATUS
CxDispatchRegisterInterface(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                   status;
    PCX_INTERFACE_REG_REQUEST  request;
    ULONG                      requestSize, resid;
    PCX_INTERFACE_REG_RESPONSE response;
    ULONG                      responseSize;

    PWCHAR                     adapterId;

    PAGED_CODE();

    // Verify that the request buffer has sufficient size, given the 
    // offsets and lengths.

    request = (PCX_INTERFACE_REG_REQUEST) Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_INTERFACE_REG_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    response = (PCX_INTERFACE_REG_RESPONSE) Irp->AssociatedIrp.SystemBuffer;
    responseSize = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if (responseSize < sizeof(CX_INTERFACE_REG_RESPONSE)) {
        return(STATUS_INVALID_PARAMETER);
    }

    resid = requestSize 
        - FIELD_OFFSET(CX_INTERFACE_REG_REQUEST, TdiAddress[0]);

    if (resid < request->TdiAddressLength) {
        return(STATUS_INVALID_PARAMETER);
    }

    resid -= request->TdiAddressLength;

    if (request->AdapterIdOffset
        < FIELD_OFFSET(CX_INTERFACE_REG_REQUEST, TdiAddress[0])
        + request->TdiAddressLength
        || request->AdapterIdOffset > requestSize) {
        return(STATUS_INVALID_PARAMETER);
    }

    if (resid < request->AdapterIdLength) {
        return(STATUS_INVALID_PARAMETER);
    }

    // Verify that the string offset is properly aligned
    adapterId = (PWCHAR)((PUCHAR)request + request->AdapterIdOffset);

    if (!POINTER_IS_ALIGNED(adapterId, TYPE_ALIGNMENT(WCHAR))) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxRegisterInterface(
                 request->NodeId,
                 request->NetworkId,
                 request->Priority,
                 (PUWSTR)((PUCHAR)request + request->AdapterIdOffset),
                 request->AdapterIdLength,
                 request->TdiAddressLength,
                 (PTRANSPORT_ADDRESS) &(request->TdiAddress[0]),
                 &response->MediaStatus
                 );

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = sizeof(CX_INTERFACE_REG_RESPONSE);
    }

    return(status);

}   // CxDispatchRegisterInterface


NTSTATUS
CxDispatchDeregisterInterface(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                      status;
    PCX_INTERFACE_DEREG_REQUEST   request;
    ULONG                         requestSize;


    PAGED_CODE();

    request = (PCX_INTERFACE_DEREG_REQUEST) Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_INTERFACE_DEREG_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxDeregisterInterface(request->NodeId, request->NetworkId);

    return(status);

}   // CxDispatchDeregisterInterface


NTSTATUS
CxDispatchOnlineNodeComm(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                  status;
    PCX_ONLINE_NODE_COMM_REQUEST   request;
    ULONG                     requestSize;


    PAGED_CODE();

    request = (PCX_ONLINE_NODE_COMM_REQUEST) Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_ONLINE_NODE_COMM_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxOnlineNodeComm(request->Id);

    return(status);

}  // CxDispatchOnlineNodeComm


NTSTATUS
CxDispatchOfflineNodeComm(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                      status;
    PCX_OFFLINE_NODE_COMM_REQUEST      request;
    ULONG                         requestSize;


    PAGED_CODE();

    request = (PCX_OFFLINE_NODE_COMM_REQUEST) Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_OFFLINE_NODE_COMM_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxOfflineNodeComm(request->Id, Irp, IrpSp);

    return(status);

}  // CxDispatchOfflineNodeComm


NTSTATUS
CxDispatchOnlineNetwork(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                    status;
    PCX_ONLINE_NETWORK_REQUEST  request;
    ULONG                       requestSize;
    PTDI_ADDRESS_INFO           response;
    ULONG                       responseSize;
    ULONG                       requiredSize = sizeof(
                                                   CX_ONLINE_NETWORK_REQUEST
                                                   );
    PWCHAR                      tdiProviderName;
    PTRANSPORT_ADDRESS          tdiBindAddress;
    PWCHAR                      adapterName;


    PAGED_CODE();

    //
    // Validate the request buffer
    //

    // First validate that the request buffer size matches the offsets
    // and lengths.
    request = (PCX_ONLINE_NETWORK_REQUEST) Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < requiredSize) {
        return(STATUS_INVALID_PARAMETER);
    }

    // Validate that all offset length pairs are within the request
    // buffer.
    if ( ( request->TdiProviderNameOffset + request->TdiProviderNameLength
           < request->TdiProviderNameOffset
         ) ||
         ( request->TdiProviderNameOffset + request->TdiProviderNameLength
           > requestSize
         ) ||
         ( request->TdiBindAddressOffset + request->TdiBindAddressLength
           < request->TdiBindAddressOffset
         ) ||
         ( request->TdiBindAddressOffset + request->TdiBindAddressLength
           > requestSize
         ) ||
         ( request->AdapterNameOffset + request->AdapterNameLength
           < request->AdapterNameOffset
         ) ||
         ( request->AdapterNameOffset + request->AdapterNameLength
           > requestSize
         )
       ) 
    {
        return(STATUS_INVALID_PARAMETER);
    }

    // Construct pointers to the parameters.
    tdiBindAddress = (PTRANSPORT_ADDRESS)
                     ( ((PUCHAR) request) + request->TdiBindAddressOffset );

    tdiProviderName = (PWCHAR)
                      ( ((PUCHAR) request) + request->TdiProviderNameOffset );

    adapterName = (PWCHAR)
                  ( ((PUCHAR) request) + request->AdapterNameOffset );

    // Validate that the resulting pointers are properly aligned and
    // within the request buffer.
    if ( ( ((PUCHAR) tdiBindAddress) < ((PUCHAR) request) ) ||
         ( ((PUCHAR) tdiBindAddress) > ((PUCHAR) request) + requestSize ) ||
         ( !POINTER_IS_ALIGNED(tdiBindAddress, 
                               TYPE_ALIGNMENT(TRANSPORT_ADDRESS)) ) ||
         ( ((PUCHAR) tdiProviderName) < ((PUCHAR) request) ) ||
         ( ((PUCHAR) tdiProviderName) > ((PUCHAR) request) + requestSize ) ||
         ( !POINTER_IS_ALIGNED(tdiProviderName, TYPE_ALIGNMENT(WCHAR)) ) ||
         ( ((PUCHAR) adapterName) < ((PUCHAR) request) ) ||
         ( ((PUCHAR) adapterName) > ((PUCHAR) request) + requestSize ) ||
         ( !POINTER_IS_ALIGNED(adapterName, TYPE_ALIGNMENT(WCHAR)) )
        )
    {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Validate the response buffer
    //
    response = (PTDI_ADDRESS_INFO) Irp->AssociatedIrp.SystemBuffer;
    responseSize = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    requiredSize = FIELD_OFFSET(TDI_ADDRESS_INFO, Address) +
                   request->TdiBindAddressLength;

    if (responseSize < requiredSize) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxOnlineNetwork(
                 request->Id,
                 tdiProviderName,
                 request->TdiProviderNameLength,
                 tdiBindAddress,
                 request->TdiBindAddressLength,
                 adapterName,
                 request->AdapterNameLength,
                 response,
                 responseSize,
                 Irp
                 );

    if (NT_SUCCESS(status)) {
        Irp->IoStatus.Information = responseSize;
    }

    return(status);

}  // CxDispatchOnlineNetwork


NTSTATUS
CxDispatchOfflineNetwork(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                      status;
    PCX_OFFLINE_NETWORK_REQUEST   request;
    ULONG                         requestSize;


    PAGED_CODE();

    request = (PCX_OFFLINE_NETWORK_REQUEST) Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_OFFLINE_NETWORK_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxOfflineNetwork(request->Id, Irp, IrpSp);

    return(status);

}  // CxDispatchOfflineNetwork


NTSTATUS
CxDispatchSetNetworkRestriction(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                             status;
    ULONG                                requestSize;
    PCX_SET_NETWORK_RESTRICTION_REQUEST  request;


    PAGED_CODE();

    request = (PCX_SET_NETWORK_RESTRICTION_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_SET_NETWORK_RESTRICTION_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxSetNetworkRestriction(
                 request->Id,
                 request->Restricted,
                 request->NewPriority
                 );

    return(status);

}   // CxDispatchSetNetworkRestriction


NTSTATUS
CxDispatchGetNetworkPriority(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                             status;
    PCX_GET_NETWORK_PRIORITY_REQUEST     request;
    PCX_GET_NETWORK_PRIORITY_RESPONSE    response;
    ULONG                                requestSize;
    ULONG                                responseSize;


    PAGED_CODE();

    request = (PCX_GET_NETWORK_PRIORITY_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    response = (PCX_GET_NETWORK_PRIORITY_RESPONSE) request;
    responseSize = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if ( (requestSize < sizeof(CX_GET_NETWORK_PRIORITY_REQUEST)) ||
         (responseSize < sizeof(CX_GET_NETWORK_PRIORITY_RESPONSE))
       )
    {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxGetNetworkPriority(
                 request->Id,
                 &(response->Priority)
                 );

    if (status == STATUS_SUCCESS) {
        Irp->IoStatus.Information = sizeof(CX_GET_NETWORK_PRIORITY_RESPONSE);
    }

    return(status);

}   // CxDispatchGetNetworkPriority


NTSTATUS
CxDispatchSetNetworkPriority(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS        status;
    ULONG           requestSize;
    PCX_SET_NETWORK_PRIORITY_REQUEST  request;


    PAGED_CODE();

    request = (PCX_SET_NETWORK_PRIORITY_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_SET_NETWORK_PRIORITY_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxSetNetworkPriority(
                 request->Id,
                 request->Priority
                 );

    return(status);

}   // CxDispatchSetNetworkPriority


NTSTATUS
CxDispatchGetInterfacePriority(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                             status;
    PCX_GET_INTERFACE_PRIORITY_REQUEST   request;
    PCX_GET_INTERFACE_PRIORITY_RESPONSE  response;
    ULONG                                requestSize;
    ULONG                                responseSize;


    PAGED_CODE();

    request = (PCX_GET_INTERFACE_PRIORITY_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    response = (PCX_GET_INTERFACE_PRIORITY_RESPONSE) request;
    responseSize = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if ( (requestSize < sizeof(CX_GET_INTERFACE_PRIORITY_REQUEST)) ||
         (responseSize < sizeof(CX_GET_INTERFACE_PRIORITY_RESPONSE))
       )
    {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxGetInterfacePriority(
                 request->NodeId,
                 request->NetworkId,
                 &(response->InterfacePriority),
                 &(response->NetworkPriority)
                 );

    if (status == STATUS_SUCCESS) {
        Irp->IoStatus.Information = sizeof(CX_GET_INTERFACE_PRIORITY_RESPONSE);
    }

    return(status);

}   // CxDispatchGetInterfacePriority


NTSTATUS
CxDispatchSetInterfacePriority(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS        status;
    ULONG           requestSize;
    PCX_SET_INTERFACE_PRIORITY_REQUEST  request;


    PAGED_CODE();

    request = (PCX_SET_INTERFACE_PRIORITY_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_SET_INTERFACE_PRIORITY_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxSetInterfacePriority(
                 request->NodeId,
                 request->NetworkId,
                 request->Priority
                 );

    return(status);

}   // CxDispatchSetInterfacePriority


NTSTATUS
CxDispatchGetNodeState(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                             status;
    PCX_GET_NODE_STATE_REQUEST           request;
    PCX_GET_NODE_STATE_RESPONSE          response;
    ULONG                                requestSize;
    ULONG                                responseSize;


    PAGED_CODE();

    request = (PCX_GET_NODE_STATE_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    response = (PCX_GET_NODE_STATE_RESPONSE) request;
    responseSize = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if ( (requestSize < sizeof(CX_GET_NODE_STATE_REQUEST)) ||
         (responseSize < sizeof(CX_GET_NODE_STATE_RESPONSE))
       )
    {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxGetNodeCommState(
                 request->Id,
                 &(response->State)
                 );

    if (status == STATUS_SUCCESS) {
        Irp->IoStatus.Information = sizeof(CX_GET_NODE_STATE_RESPONSE);
    }

    return(status);

}   // CxDispatchGetNodeState


NTSTATUS
CxDispatchGetNetworkState(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                             status;
    PCX_GET_NETWORK_STATE_REQUEST        request;
    PCX_GET_NETWORK_STATE_RESPONSE       response;
    ULONG                                requestSize;
    ULONG                                responseSize;


    PAGED_CODE();

    request = (PCX_GET_NETWORK_STATE_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    response = (PCX_GET_NETWORK_STATE_RESPONSE) request;
    responseSize = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if ( (requestSize < sizeof(CX_GET_NETWORK_STATE_REQUEST)) ||
         (responseSize < sizeof(CX_GET_NETWORK_STATE_RESPONSE))
       )
    {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxGetNetworkState(
                 request->Id,
                 &(response->State)
                 );

    if (status == STATUS_SUCCESS) {
        Irp->IoStatus.Information = sizeof(CX_GET_NETWORK_STATE_RESPONSE);
    }

    return(status);

}   // CxDispatchGetNetworkState


NTSTATUS
CxDispatchGetInterfaceState(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                             status;
    PCX_GET_INTERFACE_STATE_REQUEST      request;
    PCX_GET_INTERFACE_STATE_RESPONSE     response;
    ULONG                                requestSize;
    ULONG                                responseSize;


    PAGED_CODE();

    request = (PCX_GET_INTERFACE_STATE_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    response = (PCX_GET_INTERFACE_STATE_RESPONSE) request;
    responseSize = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if ( (requestSize < sizeof(CX_GET_INTERFACE_STATE_REQUEST)) ||
         (responseSize < sizeof(CX_GET_INTERFACE_STATE_RESPONSE))
       )
    {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxGetInterfaceState(
                 request->NodeId,
                 request->NetworkId,
                 &(response->State)
                 );

    if (status == STATUS_SUCCESS) {
        Irp->IoStatus.Information = sizeof(CX_GET_INTERFACE_STATE_RESPONSE);
    }

    return(status);

}   // CxDispatchGetInterfaceState

NTSTATUS
CxDispatchIgnoreNodeState(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    PCX_ADDROBJ   addrObj = (PCX_ADDROBJ) (IrpSp->FileObject->FsContext);
    CN_IRQL       irql;


    CnAcquireLock(&(addrObj->Lock), &irql);

    IF_CNDBG(CN_DEBUG_ADDROBJ) {
        CNPRINT(("[CDP] Turning off checkstate flag on AO %p\n", addrObj));
    }

    addrObj->Flags &= ~(CX_AO_FLAG_CHECKSTATE);

    CnReleaseLock(&(addrObj->Lock), irql);

    return(STATUS_SUCCESS);

}   // CxDispatchIgnoreNodeState

NTSTATUS
CxDispatchGetNodeMembershipState(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS status;
    PCX_GET_NODE_MMSTATE_REQUEST request;
    PCX_GET_NODE_MMSTATE_RESPONSE response;
    ULONG requestSize;
    ULONG responseSize;


    PAGED_CODE();

    request = (PCX_GET_NODE_MMSTATE_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    response = (PCX_GET_NODE_MMSTATE_RESPONSE) request;
    responseSize = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if ( (requestSize < sizeof(CX_GET_NODE_MMSTATE_REQUEST)) ||
         (responseSize < sizeof(CX_GET_NODE_MMSTATE_RESPONSE))
       )
    {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxGetNodeMembershipState( request->Id, &(response->State));

    if (status == STATUS_SUCCESS) {
        Irp->IoStatus.Information = sizeof(CX_GET_NODE_MMSTATE_RESPONSE);
    }

    return(status);

}   // CxDispatchGetNodeMembershipState

NTSTATUS
CxDispatchSetNodeMembershipState(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS status;
    PCX_SET_NODE_MMSTATE_REQUEST request;
    ULONG requestSize;
    ULONG responseSize;


    PAGED_CODE();

    request = (PCX_SET_NODE_MMSTATE_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof( CX_SET_NODE_MMSTATE_REQUEST ) ||
        request->State >= ClusnetNodeStateLastEntry) {

        return(STATUS_INVALID_PARAMETER);
    }

    status = CxSetNodeMembershipState( request->NodeId, request->State );

    Irp->IoStatus.Information = 0;

    return(status);

}   // CxDispatchSetNodeMembershipState

VOID
CxCompleteSendPoisonPacket(
    IN NTSTATUS  Status,
    IN ULONG     BytesSent,
    IN PVOID     Context,
    IN PVOID     MessageData
    )
{
    PIRP  irp = Context;

    CnAssert(Status != STATUS_PENDING);

    IF_CNDBG(( CN_DEBUG_IRP | CN_DEBUG_POISON ))
        CNPRINT(("[Clusnet] Completing SendPoisonPacket request for "
                 "irp %p, status %08X\n",
                 irp,
                 Status));

    //
    // The irp is completed in the CNP send completion routine.
    //

    return;

} // CxCompleteSendPoisonPacket


NTSTATUS
CxDispatchSendPoisonPacket(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                     status;
    PCX_SEND_POISON_PKT_REQUEST  request;
    ULONG                        requestSize;

    PAGED_CODE();

    request = (PCX_SEND_POISON_PKT_REQUEST) Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    //
    // request size should exactly equal the size of the request struct plus
    // the data passed in
    //

    if ( requestSize != sizeof(CX_SEND_POISON_PKT_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // We will always return pending, so mark the IRP pending.
    // The IRP will be completed by CxCompleteSendPoisonPacket
    //
    IoMarkIrpPending(Irp);
    
    IF_CNDBG(( CN_DEBUG_IRP | CN_DEBUG_POISON ))
        CNPRINT(("[Clusnet] Posting SendPoisonPacket irp %p\n", Irp));

    CxSendPoisonPacket(
        request->Id,
        CxCompleteSendPoisonPacket,
        Irp,
        Irp
        );

    return(STATUS_PENDING);

} // CxDispatchSendPoisonPacket

NTSTATUS
CxDispatchSetOuterscreen(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS status;
    PCX_SET_OUTERSCREEN_REQUEST request;
    ULONG requestSize;
    ULONG responseSize;


    PAGED_CODE();

    request = (PCX_SET_OUTERSCREEN_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if ( requestSize < sizeof( CX_SET_OUTERSCREEN_REQUEST )) {

        return(STATUS_INVALID_PARAMETER);
    }

    status = CxSetOuterscreen( request->Outerscreen );

    Irp->IoStatus.Information = 0;

    return(status);

}   // CxDispatchSetOuterscreen

NTSTATUS
CxDispatchRegroupFinished(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS status;
    PCX_REGROUP_FINISHED_REQUEST request;
    ULONG requestSize;
    ULONG responseSize;

    PAGED_CODE();

    request = (PCX_REGROUP_FINISHED_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if ( requestSize < sizeof( CX_REGROUP_FINISHED_REQUEST )) {

        return(STATUS_INVALID_PARAMETER);
    }

    CxRegroupFinished( request->NewEpoch );

    Irp->IoStatus.Information = 0;

    return( STATUS_SUCCESS );

}   // CxDispatchRegroupFinished

NTSTATUS
CxDispatchImportSecurityContext(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS status;
    PCX_IMPORT_SECURITY_CONTEXT_REQUEST request;
    ULONG requestSize;
    ULONG responseSize;

    PAGED_CODE();

    request = (PCX_IMPORT_SECURITY_CONTEXT_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if ( requestSize < sizeof( CX_IMPORT_SECURITY_CONTEXT_REQUEST )) {

        return(STATUS_INVALID_PARAMETER);
    }

    status = CxImportSecurityContext(request->JoiningNodeId,
                                     request->PackageName,
                                     request->PackageNameSize,
                                     request->SignatureSize,
                                     request->ServerContext,
                                     request->ClientContext);

    Irp->IoStatus.Information = 0;

    return( status );

}   // CxDispatchImportSecurityContext

NTSTATUS
CxDispatchReserveClusnetEndpoint(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS status;
    USHORT   port;
    ULONG    requestSize;

    PAGED_CODE();

    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(USHORT)) {

        status = STATUS_INVALID_PARAMETER;
    }
    else {
        port = *((PUSHORT) Irp->AssociatedIrp.SystemBuffer);
        status = CxReserveClusnetEndpoint(port);
    }
    
    Irp->IoStatus.Information = 0;

    return (status);
}

NTSTATUS
CxDispatchConfigureMulticast(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                         status;
    PCX_CONFIGURE_MULTICAST_REQUEST  request;
    ULONG                            requestSize;
    ULONG                            requiredSize;

    PTRANSPORT_ADDRESS               tdiMcastAddress;
    PVOID                            key;
    PVOID                            salt;
    
    PAGED_CODE();

    //
    // Validate the request buffer
    //

    // First validate that the request buffer size matches the offsets
    // and lengths.
    request = (PCX_CONFIGURE_MULTICAST_REQUEST)Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    //
    // The required size is based on the size and required alignment
    // of each field of data following the structure. If there is no
    // data following the structure, only the structure is required.
    //
    requiredSize = sizeof(CX_CONFIGURE_MULTICAST_REQUEST);

    //
    // Verify that the required size is present.
    //
    if (requestSize < requiredSize)
    {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Verify that all offset length pairs are within the request size.
    //
    if ( ( request->MulticastAddress + request->MulticastAddressLength
           < request->MulticastAddress
         ) ||
         ( request->MulticastAddress + request->MulticastAddressLength
           > requestSize
         ) ||
         ( request->Key + request->KeyLength < request->Key
         ) ||
         ( request->Key + request->KeyLength > requestSize
         ) ||
         ( request->Salt + request->SaltLength < request->Salt
         ) ||
         ( request->Salt + request->SaltLength > requestSize
         )
       ) 
    {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Construct pointers using the offsets.
    //
    tdiMcastAddress = (PTRANSPORT_ADDRESS)
                      ( ((PUCHAR) request) + request->MulticastAddress );

    key = (PVOID)( ((PUCHAR) request) + request->Key );

    salt = (PVOID)( ((PUCHAR) request) + request->Salt );

    //
    // Validate that the resulting pointers are properly aligned and
    // within the request data structure.
    //
    if ( ( ((PUCHAR) tdiMcastAddress) < ((PUCHAR) request) ) ||
         ( ((PUCHAR) tdiMcastAddress) > ((PUCHAR) request) + requestSize ) ||
         ( !POINTER_IS_ALIGNED(tdiMcastAddress, 
                               TYPE_ALIGNMENT(TRANSPORT_ADDRESS))) ||
         ( ((PUCHAR) key) < ((PUCHAR) request) ) ||
         ( ((PUCHAR) key) > ((PUCHAR) request) + requestSize ) ||
         ( !POINTER_IS_ALIGNED(key, TYPE_ALIGNMENT(PVOID))) ||
         ( ((PUCHAR) salt) < ((PUCHAR) request) ) ||
         ( ((PUCHAR) salt) > ((PUCHAR) request) + requestSize ) ||
         ( !POINTER_IS_ALIGNED(salt, TYPE_ALIGNMENT(PVOID)))
       ) 
    {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxConfigureMulticast(
                 request->NetworkId,
                 request->MulticastNetworkBrand,
                 tdiMcastAddress,
                 request->MulticastAddressLength,
                 key,
                 request->KeyLength,
                 salt,
                 request->SaltLength,
                 Irp
                 );

    // No return data.
    Irp->IoStatus.Information = 0;

    return(status);

} // CxDispatchConfigureMulticast

NTSTATUS
CxDispatchGetMulticastReachableSet(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                                  status;
    PCX_GET_MULTICAST_REACHABLE_SET_REQUEST   request;
    PCX_GET_MULTICAST_REACHABLE_SET_RESPONSE  response;
    ULONG                                     requestSize;
    ULONG                                     responseSize;

    PAGED_CODE();

    request = (PCX_GET_MULTICAST_REACHABLE_SET_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    response = (PCX_GET_MULTICAST_REACHABLE_SET_RESPONSE) request;
    responseSize = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if ( (requestSize < sizeof(PCX_GET_MULTICAST_REACHABLE_SET_REQUEST)) ||
         (responseSize < sizeof(PCX_GET_MULTICAST_REACHABLE_SET_RESPONSE))
       )
    {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxGetMulticastReachableSet(
                 request->Id,
                 &(response->NodeScreen)
                 );

    if (status == STATUS_SUCCESS) {
        Irp->IoStatus.Information = 
            sizeof(CX_GET_MULTICAST_REACHABLE_SET_RESPONSE);
    }

    return(status);

} // CxDispatchGetMulticastReachableSet

//
// Test IOCTLs.
//
#if DBG

NTSTATUS
CxDispatchOnlinePendingInterface(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                               status;
    PCX_ONLINE_PENDING_INTERFACE_REQUEST   request;
    ULONG                                  requestSize;


    PAGED_CODE();

    request = (PCX_ONLINE_PENDING_INTERFACE_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_ONLINE_PENDING_INTERFACE_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxOnlinePendingInterface(request->NodeId, request->NetworkId);

    return(status);
}   // CxDispatchOnlinePendingInterface


NTSTATUS
CxDispatchOnlineInterface(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                               status;
    PCX_ONLINE_PENDING_INTERFACE_REQUEST   request;
    ULONG                                  requestSize;


    PAGED_CODE();

    request = (PCX_ONLINE_PENDING_INTERFACE_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_ONLINE_PENDING_INTERFACE_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxOnlineInterface(request->NodeId, request->NetworkId);

    return(status);

}   // CxDispatchOnlineInterface


NTSTATUS
CxDispatchOfflineInterface(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                               status;
    PCX_ONLINE_PENDING_INTERFACE_REQUEST   request;
    ULONG                                  requestSize;


    PAGED_CODE();

    request = (PCX_ONLINE_PENDING_INTERFACE_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_ONLINE_PENDING_INTERFACE_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxOfflineInterface(request->NodeId, request->NetworkId);

    return(status);

}   // CxDispatchOfflineInterface


NTSTATUS
CxDispatchFailInterface(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                               status;
    PCX_ONLINE_PENDING_INTERFACE_REQUEST   request;
    ULONG                                  requestSize;


    PAGED_CODE();

    request = (PCX_ONLINE_PENDING_INTERFACE_REQUEST)
              Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_ONLINE_PENDING_INTERFACE_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    status = CxFailInterface(request->NodeId, request->NetworkId);

    return(status);

}   // CxDispatchFailInterface


VOID
CxCompleteSendMmMsg(
    IN NTSTATUS  Status,
    IN ULONG     BytesSent,
    IN PVOID     Context,
    IN PVOID     MessageData
    )
{
    PIRP  irp = Context;

    CnAssert(Status != STATUS_PENDING);

    CNPRINT((
        "[Clusnet] Completing SendMmMsg irp %p, status %lx, bytes sent %u\n",
        irp,
        Status,
        BytesSent
        ));

    //
    // Complete the irp.
    //
    irp->IoStatus.Status = Status;
    irp->IoStatus.Information = 0;

    IoCompleteRequest(irp, IO_NETWORK_INCREMENT);

    return;

} // CxCompleteSendMmMsg

#ifdef MM_IN_CLUSNET

NTSTATUS
CxDispatchSendMmMsg(
    IN PIRP               Irp,
    IN PIO_STACK_LOCATION IrpSp
    )
{
    NTSTATUS                     status;
    PCX_SEND_MM_MSG_REQUEST      request;
    ULONG                        requestSize;


    PAGED_CODE();

    request = (PCX_SEND_MM_MSG_REQUEST) Irp->AssociatedIrp.SystemBuffer;
    requestSize = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestSize < sizeof(CX_SEND_MM_MSG_REQUEST)) {
        return(STATUS_INVALID_PARAMETER);
    }

    IoMarkIrpPending(Irp);

    CNPRINT(("[Clusnet] Posting SendMmMsg irp %p\n", Irp));

    status = CxSendMembershipMessage(
                 request->DestNodeId,
                 &(request->MessageData[0]),
                 CX_MM_MSG_DATA_LEN,
                 CxCompleteSendMmMsg,
                 Irp
                 );

    return(status);


} // CxDispatchSendMmMsg
#endif // MM_IN_CLUSNET

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\xport\precomp.h ===
#include "cxp.h"
#include "cnpdef.h"
#include "cdp.h"
#include "winerror.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\xport\cxp.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    cxp.h

Abstract:

    Common definitions for the Cluster Transport.

Author:

    Mike Massa (mikemas)           July 29, 1996

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     07-29-96    created

Notes:

--*/

#ifndef _CXP_INCLUDED_
#define _CXP_INCLUDED_


#include <clusnet.h>
#include <ntddtcp.h>
#include <ntddndis.h>


//
// Tdi Definitions
//
//
// TDI Address Object
//
// This structure represents a cluster transport address opened by a
// TDI client. It is also used as an endpoint for datagram communication.
// One such structure exists for each port address opened on the local node.
//
// Address objects are stored in a bucket hash table. The table is
// hashed by port number.
//
typedef struct {
    CN_FSCONTEXT                        FsContext;
    LIST_ENTRY                          AOTableLinkage;
    CN_LOCK                             Lock;
    CN_IRQL                             Irql;
    ULONG                               Flags;
    USHORT                              LocalPort;
    LIST_ENTRY                          ReceiveQueue;
    PTDI_IND_ERROR                      ErrorHandler;
    PVOID                               ErrorContext;
    PTDI_IND_RECEIVE_DATAGRAM           ReceiveDatagramHandler;
    PVOID                               ReceiveDatagramContext;
    PTDI_IND_CHAINED_RECEIVE_DATAGRAM   ChainedReceiveDatagramHandler;
    PVOID                               ChainedReceiveDatagramContext;
} CX_ADDROBJ, *PCX_ADDROBJ;

#define CX_ADDROBJ_SIG    'rdda'

#define CX_ADDROBJ_TABLE_SIZE  7

#define CX_ADDROBJ_TABLE_HASH(_port)  \
            ((ULONG) ((_port) % CX_ADDROBJ_TABLE_SIZE))


#define CX_AO_FLAG_DELETING      0x00000001
#define CX_AO_FLAG_CHECKSTATE    0x00000002


extern LIST_ENTRY           CxAddrObjTable[CX_ADDROBJ_TABLE_SIZE];
extern CN_LOCK              CxAddrObjTableLock;

extern HANDLE               CxTdiRegistrationHandle;


//
// Packet header structures need to be packed.
//
#include <packon.h>

//
// CNP Header
//
typedef struct {
    UCHAR      Version;
    UCHAR      NextHeader;
    USHORT     PayloadLength;
    ULONG      SourceAddress;
    ULONG      DestinationAddress;
} CNP_HEADER, *PCNP_HEADER;

//
// CDP Header
//
typedef struct {
    USHORT   SourcePort;
    USHORT   DestinationPort;
    USHORT   PayloadLength;
    USHORT   Checksum;
} CDP_HEADER, *PCDP_HEADER;

//
// Node info structure for heartbeats.
//
typedef struct _CX_HB_NODE_INFO {
    ULONG    SeqNumber;
    ULONG    AckNumber;
} CX_HB_NODE_INFO, *PCX_HB_NODE_INFO;

//
// Multicast signature data.
//
typedef struct {
    UCHAR            Version;
    UCHAR            Reserved;
    USHORT           PayloadOffset;
    CL_NETWORK_ID    NetworkId;
    ULONG            ClusterNetworkBrand;
    USHORT           SigBufferLen;
    UCHAR            SigBuffer[1]; // dynamic    
} CNP_SIGNATURE, *PCNP_SIGNATURE;


#include <packoff.h>

//
// Protocol constants
//
#define CNP_VERSION_1     0x1     // original CNP
#define CNP_VERSION_2     0x2     // original CNP + multicast

#define CNP_VERSION_UNICAST       CNP_VERSION_1
#define CNP_VERSION_MULTICAST     CNP_VERSION_2

#define PROTOCOL_CCMP     1
#define PROTOCOL_CDP      2

#define CNP_SIG_VERSION_1 0x1

//
// Size of CNP multicast signature data.
//
#define CNP_SIGHDR_LENGTH                                    \
    (FIELD_OFFSET(CNP_SIGNATURE, SigBuffer[0]))
    
#define CNP_SIG_LENGTH(_SignatureSize)                       \
    (CNP_SIGHDR_LENGTH + (_SignatureSize)) 
    
#define MAX_UDP_SEND_SIZE  ( 0xFFFF - 68 )

#define CDP_MAX_SEND_SIZE(_SignatureSize) \
    (MAX_UDP_SEND_SIZE                    \
     - sizeof(CNP_HEADER)                 \
     - CNP_SIG_LENGTH(_SignatureSize))    \
     - sizeof(CDP_HEADER)

//
// CNP Receive Flags
//
#define CNP_RECV_FLAG_NODE_STATE_CHECK_PASSED     0x00000001
#define CNP_RECV_FLAG_MULTICAST                   0x00000002
#define CNP_RECV_FLAG_CURRENT_MULTICAST_GROUP     0x00000004
#define CNP_RECV_FLAG_SIGNATURE_VERIFIED          0x00000008


//
// put here for kdcn
//

typedef enum {
    CcmpInvalidMsgType = 0,
    CcmpHeartbeatMsgType = 1,
    CcmpPoisonMsgType = 2,
    CcmpMembershipMsgType = 3,
    CcmpMcastHeartbeatMsgType = 4
} CCMP_MSG_TYPE;

//
// From MM in clussvc:
//
// The data type "cluster_t" is a bit array of size equal to the maximum
// number of nodes in the cluster. The bit array is implemented as an
// array of uint8s.
//
// Given a node#, its bit position in the bit array is computed by first
// locating the byte in the array (node# / BYTEL) and then the bit in
// the byte. Bits in the byte are numbered 0..7 (from left to right).
// Thus, node 0 is placed in byte 0, bit 0, which is the left-most bit
// in the bit array.
//
//
// The cluster type sizing defines and manipulation routines are copied
// from MM so there is some notion of how the mask is managed.
//

#define MAX_CLUSTER_SIZE    ClusterDefaultMaxNodes

#define BYTEL 8 // number of bits in a uint8
#define BYTES_IN_CLUSTER ((MAX_CLUSTER_SIZE + BYTEL - 1) / BYTEL)

#define BYTE(cluster, node) ( (cluster)[(node) / BYTEL] ) // byte# in array
#define BIT(node)           ( (node) % BYTEL )            // bit# in byte

typedef UCHAR cluster_t [BYTES_IN_CLUSTER];
typedef SHORT node_t;

typedef union _CX_CLUSTERSCREEN {
    ULONG     UlongScreen;
    cluster_t ClusterScreen;
} CX_CLUSTERSCREEN;

//
// converts external node number to internal
//
#define LOWEST_NODENUM     ((node_t)ClusterMinNodeId)  // starting node number
#define INT_NODE(ext_node) ((node_t)(ext_node - LOWEST_NODENUM))

#define CnpClusterScreenMember(c, i) \
    ((BOOLEAN)((BYTE(c,i) >> (BYTEL-1-BIT(i))) & 1))

#define CnpClusterScreenInsert(c, i) \
    (BYTE(c, i) |= (1 << (BYTEL-1-BIT(i))))

#define CnpClusterScreenDelete(c, i) \
    (BYTE(c, i) &= ~(1 << (BYTEL-1-BIT(i))))


//
// CNP Receive Request structures and routines
//

//
// Receive Request Pool
//
typedef struct {
    ULONG   UpperProtocolContextSize;
} CNP_RECEIVE_REQUEST_POOL_CONTEXT, *PCNP_RECEIVE_REQUEST_POOL_CONTEXT;

//
// Receive Request Structure
//
typedef struct {
    CN_RESOURCE      CnResource;
    PIRP             Irp;
    PVOID            DataBuffer;
    PVOID            UpperProtocolContext;
} CNP_RECEIVE_REQUEST, *PCNP_RECEIVE_REQUEST;


PCN_RESOURCE_POOL
CnpCreateReceiveRequestPool(
    IN ULONG  UpperProtocolContextSize,
    IN USHORT PoolDepth
    );

#define CnpDeleteReceiveRequestPool(_pool) \
        { \
            CnDrainResourcePool(_pool);  \
            CnFreePool(_pool);           \
        }

PCNP_RECEIVE_REQUEST
CnpAllocateReceiveRequest(
    IN PCN_RESOURCE_POOL  RequestPool,
    IN PVOID              Network,
    IN ULONG              BytesToReceive,
    IN PVOID              CompletionRoutine
    );

VOID
CnpFreeReceiveRequest(
    PCNP_RECEIVE_REQUEST  Request
    );

//
//
// Function Prototypes
//
//

VOID
CxTdiAddAddressHandler(
    IN PTA_ADDRESS       TaAddress,
    IN PUNICODE_STRING   DeviceName,
    IN PTDI_PNP_CONTEXT  Context
    );

VOID
CxTdiDelAddressHandler(
    IN PTA_ADDRESS       TaAddress,
    IN PUNICODE_STRING   DeviceName,
    IN PTDI_PNP_CONTEXT  Context
    );

NTSTATUS
CxWmiPnpLoad(
    VOID
    );

VOID
CxWmiPnpUnload(
    VOID
    );

NTSTATUS
CxWmiPnpInitialize(
    VOID
    );

VOID
CxWmiPnpShutdown(
    VOID
    );

VOID
CxReconnectLocalInterface(
    IN CL_NETWORK_ID NetworkId
    );

VOID
CxQueryMediaStatus(
    IN  HANDLE            AdapterDeviceHandle,
    IN  CL_NETWORK_ID     NetworkId,
    OUT PULONG            MediaStatus
    );

VOID
CxBuildTdiAddress(
    PVOID        Buffer,
    CL_NODE_ID   Node,
    USHORT       Port,
    BOOLEAN      Verified
    );

NTSTATUS
CxParseTransportAddress(
    IN  TRANSPORT_ADDRESS UNALIGNED *AddrList,
    IN  ULONG                        AddressListLength,
    OUT CL_NODE_ID *                 Node,
    OUT PUSHORT                      Port
    );

PCX_ADDROBJ
CxFindAddressObject(
    IN USHORT  Port
    );

NTSTATUS
CnpLoadNodes(
    VOID
    );

NTSTATUS
CnpInitializeNodes(
    VOID
    );

VOID
CnpShutdownNodes(
    VOID
    );

NTSTATUS
CnpLoadNetworks(
    VOID
    );

NTSTATUS
CnpInitializeNetworks(
    VOID
    );

VOID
CnpShutdownNetworks(
    VOID
    );

NTSTATUS
CnpLoad(
    VOID
    );

VOID
CnpUnload(
    VOID
    );

NTSTATUS
CcmpLoad(
    VOID
    );

VOID
CcmpUnload(
    VOID
    );

NTSTATUS
CdpLoad(
    VOID
    );

VOID
CdpUnload(
    VOID
    );

NTSTATUS
CdpReceivePacketHandler(
    IN  PVOID          Network,
    IN  CL_NODE_ID     SourceNodeId,
    IN  ULONG          CnpReceiveFlags,
    IN  ULONG          TdiReceiveDatagramFlags,
    IN  ULONG          BytesIndicated,
    IN  ULONG          BytesAvailable,
    OUT PULONG         BytesTaken,
    IN  PVOID          Tsdu,
    OUT PIRP *         Irp
    );

NTSTATUS
CxInitializeHeartBeat(
    VOID
    );

VOID
CxUnloadHeartBeat(
    VOID
    );

VOID
CnpStartHeartBeats(
    VOID
    );

VOID
CnpStopHeartBeats(
    VOID
    );

NTSTATUS
CxReserveClusnetEndpoint(
    IN USHORT Port
    );

NTSTATUS
CxUnreserveClusnetEndpoint(
    VOID
    );

NTSTATUS
CxSendMcastHeartBeatMessage(
    IN     CL_NETWORK_ID               NetworkId,
    IN     PVOID                       McastGroup,
    IN     CX_CLUSTERSCREEN            McastTargetNodes,
    IN     CX_HB_NODE_INFO             NodeInfo[],
    IN     PCX_SEND_COMPLETE_ROUTINE   CompletionRoutine,  OPTIONAL
    IN     PVOID                       CompletionContext   OPTIONAL
    );

NTSTATUS
CxConfigureMulticast(
    IN CL_NETWORK_ID       NetworkId,
    IN ULONG               MulticastNetworkBrand,
    IN PTRANSPORT_ADDRESS  TdiMcastBindAddress,
    IN ULONG               TdiMcastBindAddressLength,
    IN PVOID               Key,
    IN ULONG               KeyLength,
    IN PVOID               Salt,
    IN ULONG               SaltLength,
    IN PIRP                Irp
    );

NTSTATUS
CxGetMulticastReachableSet(
    IN  CL_NETWORK_ID      NetworkId,
    OUT ULONG            * NodeScreen
    );

#endif // ifndef _CXP_INCLUDED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\autostart.c ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    autostart.c

Abstract:

    Autostart wmi loggers.
    Takes arguments from tracing registry
    (This code may end up in wpp framework, hence Wpp prefix)

Author:

    Gor Nishanov (gorn) 29-Oct-2000

Revision History:

--*/

#include "clusrtlp.h"
#include <wmistr.h>
#include <evntrace.h>

#define WppDebug(x,y) 

#define WPPINIT_STATIC

#define WPP_REG_TRACE_REGKEY            L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Tracing"

#define WPP_TEXTGUID_LEN 37

static TRACEHANDLE WppQueryLogger(PCWSTR LoggerName)
{
    ULONG status;
    EVENT_TRACE_PROPERTIES LoggerInfo;

    ZeroMemory(&LoggerInfo, sizeof(LoggerInfo));
    LoggerInfo.Wnode.BufferSize = sizeof(LoggerInfo);
    LoggerInfo.Wnode.Flags = WNODE_FLAG_TRACED_GUID;

    status = QueryTraceW(0, LoggerName, &LoggerInfo);
    WppDebug(4, ("QueryLogger(%ws) => %x:%x %d\n", 
        LoggerName, LoggerInfo.Wnode.HistoricalContext, status) );   
    if (status == ERROR_SUCCESS || status == ERROR_MORE_DATA) {
        return (TRACEHANDLE) LoggerInfo.Wnode.HistoricalContext;
    }
    return 0;
}

WPPINIT_STATIC
__inline UINT WppHexVal(int ch) { 
    return isdigit(ch) ? ch - '0' : ch - 'a' + 10; 
}

WPPINIT_STATIC
UINT WppHex(LPCWSTR s, int n)
{
    UINT res = 0;
    while(n--) { res = res * 16 + WppHexVal(*s++); }
    return res;
}

WPPINIT_STATIC
VOID
WppGuidFromStr(
    IN LPCWSTR str,
    OUT LPGUID guid)
{
    guid->Data1 =            WppHex(str +  0, 8);
    guid->Data2 =    (USHORT)WppHex(str +  9, 4);
    guid->Data3 =    (USHORT)WppHex(str + 14, 4);
    guid->Data4[0] = (UCHAR) WppHex(str + 19, 2);
    guid->Data4[1] = (UCHAR) WppHex(str + 21, 2);
    guid->Data4[2] = (UCHAR) WppHex(str + 24, 2);
    guid->Data4[3] = (UCHAR) WppHex(str + 26, 2);
    guid->Data4[4] = (UCHAR) WppHex(str + 28, 2);
    guid->Data4[5] = (UCHAR) WppHex(str + 30, 2);
    guid->Data4[6] = (UCHAR) WppHex(str + 32, 2);
    guid->Data4[7] = (UCHAR) WppHex(str + 34, 2);
}

#define WPP_BUF_SIZE(hmem) ((hmem) ? (ULONG)LocalSize(hmem) : 0)

// Make sure that the buffer is at least of size dwSize
WPPINIT_STATIC 
DWORD WppGrowBuf(PVOID *Buf, DWORD dwSize)
{
    DWORD status = ERROR_SUCCESS;
    WppDebug(4, ("WppGrowBuf(%x, %d (%d)) => ", *Buf, dwSize, WPP_BUF_SIZE(*Buf)) );
    if (*Buf == 0) {
        *Buf = LocalAlloc(LMEM_FIXED, dwSize);
        if (*Buf == 0) {
            status = GetLastError();
        }
    } else if (LocalSize(*Buf) < dwSize) {
        PVOID newBuf = LocalReAlloc(*Buf, dwSize, LMEM_MOVEABLE);
        if (newBuf) {
            *Buf = newBuf;
        } else {
            status = GetLastError();
        }
    }
    WppDebug(4, ("(%x (%d), %d)\n", *Buf, WPP_BUF_SIZE(*Buf), status) );
    return status; 
}

WPPINIT_STATIC 
DWORD WppRegQueryGuid(
    IN HKEY       hKey,
    IN LPCWSTR    ValueName,
    OUT LPGUID    pGuid
    )
{
    WCHAR GuidTxt[WPP_TEXTGUID_LEN];
    DWORD status;
    DWORD dwLen = sizeof(GuidTxt);
    DWORD Type;

    status = RegQueryValueExW(
        hKey,         // handle to key
        ValueName,    // value name
        0,            // reserved
        &Type,        // type buffer
        (LPBYTE)GuidTxt,  // data buffer // 
        &dwLen    // size of data buffer
        );

    if (status != ERROR_SUCCESS || Type != REG_SZ || dwLen < 35) {
        return status;
    }

    WppGuidFromStr(GuidTxt, pGuid);

    return status;        
}

WPPINIT_STATIC 
DWORD WppRegQueryDword(
    IN HKEY       hKey,
    IN LPCWSTR     ValueName,
    IN DWORD Default,
    IN DWORD MinVal,
    IN DWORD MaxVal
    )
{
    DWORD Result = Default;
    DWORD dwLen = sizeof(DWORD);

    RegQueryValueExW(hKey, ValueName, 
        0, NULL,  // lpReserved, lpType, 
        (LPBYTE)&Result, &dwLen);

    if (Result < MinVal || Result > MaxVal) {
        Result = Default;
    }

    return Result;        
}

WPPINIT_STATIC 
DWORD WppRegQueryString(
    IN HKEY       hKey,
    IN LPCWSTR     ValueName,
    IN OUT PWCHAR *Buf,
    IN DWORD ExtraPadding // Add this amount whenever we need to alloc more memory
    )
{
    DWORD ExpandSize;
    DWORD BufSize;
    DWORD ValueSize = WPP_BUF_SIZE(*Buf);
    DWORD status;
    DWORD Type = 0;

    status = RegQueryValueExW(
        hKey,         // handle to key
        ValueName,    // value name
        0,            // reserved
        &Type,        // type buffer
        (LPBYTE)(ValueSize?*Buf:ValueName), // data buffer // 
        &ValueSize    // size of data buffer
        );
    if (status == ERROR_MORE_DATA) {
        if (Type == REG_EXPAND_SZ) {
            ExtraPadding += ValueSize + 100; // Room for ExpandEnvStrings
        }
        status = WppGrowBuf(Buf, ValueSize + ExtraPadding);
        if (status != ERROR_SUCCESS) {
            return status;
        }
        status = RegQueryValueExW(
            hKey,       // handle to key
            ValueName,  // value name
            0,          // reserved
            &Type,      // type buffer
            (LPBYTE)*Buf,       // data buffer
            &ValueSize  // size of data buffer
            );
    }
    if (status != ERROR_SUCCESS) {
        return status;
    }
    if (Type == REG_SZ) {
        return ERROR_SUCCESS;
    }
    if (Type != REG_EXPAND_SZ) {
        return ERROR_DATATYPE_MISMATCH;
    }
    if (wcschr(*Buf, '%') == 0) {
        // nothing to expand
        return ERROR_SUCCESS;
    }
    BufSize = (ULONG)LocalSize(*Buf);
    ExpandSize = sizeof(WCHAR) * ExpandEnvironmentStringsW(
        *Buf, (LPWSTR)((LPBYTE)*Buf + ValueSize), (BufSize - ValueSize) / sizeof(WCHAR) ) ;
    if (ExpandSize + ValueSize > BufSize) {
        status = WppGrowBuf(Buf, ExpandSize + max(ExpandSize, ValueSize) + ExtraPadding );
        if (status != ERROR_SUCCESS) {
            return status;
        }
        ExpandSize = ExpandEnvironmentStringsW(*Buf, (LPWSTR)((LPBYTE)*Buf + ValueSize), ExpandSize / sizeof(WCHAR));
    }
    if (ExpandSize == 0) {
        return GetLastError();
    }
    // Copy expanded string on top of the original one
    MoveMemory(*Buf, (LPBYTE)*Buf + ValueSize, ExpandSize); 
    return ERROR_SUCCESS;
}

WPPINIT_STATIC 
void
WppSetExt(LPWSTR buf, int i)
{
    buf[0] = '.';
    buf[4] = 0;
    buf[3] = (WCHAR)('0' + i % 10); i = i / 10;
    buf[2] = (WCHAR)('0' + i % 10); i = i / 10;
    buf[1] = (WCHAR)('0' + i % 10); 
}

#if !defined(WPP_DEFAULT_LOGGER_FLAGS)
#  define WPP_DEFAULT_LOGGER_FLAGS (EVENT_TRACE_FILE_MODE_CIRCULAR | EVENT_TRACE_USE_GLOBAL_SEQUENCE)
#endif

// A set of buffers used by an autostart
// Buffers are reused between iterations and recursive invocations
// to minimize number of allocations

typedef struct _WPP_AUTO_START_BUFFERS {
    PWCHAR LogSessionName;
    PWCHAR Buf;
} WPP_AUTO_START_BUFFERS, *PWPP_AUTO_START_BUFFERS;

WPPINIT_STATIC 
DWORD
WppReadLoggerInfo(
    IN HKEY          LoggerKey, 
    IN OUT PWPP_AUTO_START_BUFFERS x, 
    OUT TRACEHANDLE* Logger)
{
    DWORD status;
    PEVENT_TRACE_PROPERTIES Trace;
    DWORD len, sessionNameLen;

    DWORD MaxBackups = 0;
    DWORD ExtraPadding; // add this amount when we need to allocate

    status = WppRegQueryString(LoggerKey, L"LogSessionName", &x->LogSessionName, 0);
            
    if (status != ERROR_SUCCESS) {
        // this registry node doesn't contain a logger
        return status;
    }

    sessionNameLen = wcslen(x->LogSessionName);
    *Logger = WppQueryLogger(x->LogSessionName);

    if (*Logger) {
        WppDebug(1,("[WppInit] Logger %ls is already running\n", x->LogSessionName) );
        return ERROR_SUCCESS;
    }

    // The TraceProperties property buffer that we need to give to StartTrace
    // should be of size EVENT_TRACE_PROPERTIES + len(sessionName) + len(logFileName)
    // However, we don't know the length of logFileName at the moment. To eliminate
    // extra allocations we will add ExtraPadding to an any allocation, so that the final
    // buffer will be of required size

    ExtraPadding = sizeof(EVENT_TRACE_PROPERTIES) + (sessionNameLen + 1) * sizeof(WCHAR);

    status = WppRegQueryString(LoggerKey, L"LogFileName", &x->Buf, ExtraPadding);
    if (status != ERROR_SUCCESS) {
        WppDebug(1,("[WppInit] Read %ls\\LogFileName failed, %d\n", x->LogSessionName, status) );
        return status;
    }
    len = wcslen(x->Buf);

    MaxBackups = WppRegQueryDword(LoggerKey, L"MaxBackups", 0, 0, 999);

    if (MaxBackups) {
        int i, success;
        LPWSTR FromExt, ToExt, From, To;
        // Copy current.evm => current.evm.001, 001 => 002, etc

        // MakeSure, Buffer is big enought for two file names + .000 extensions
        WppGrowBuf(&x->Buf, (len + 5) * 2 * sizeof(WCHAR) + ExtraPadding); // .xxx\0 (5)

        From = x->Buf;                // MyFileName.evm      MyFileName.evm.001
        FromExt = From + len ;      // ^             ^     ^             ^
        To = FromExt + 5; // .xxx0  // From          Ext1  To            Ext2
        ToExt = To + len;

        memcpy(To, From, (len + 1) * sizeof(WCHAR) );
        
        for (i = MaxBackups; i >= 1; --i) {
            WppSetExt(ToExt, i); 
            if (i == 1) {
                *FromExt = 0; // remove extension
            } else {
                WppSetExt(FromExt, i-1);
            }
            success = MoveFileExW(From, To, MOVEFILE_REPLACE_EXISTING);
            if (!success) {
                status = GetLastError();
            } else {
                status = ERROR_SUCCESS;
            }
            WppDebug(3, ("[WppInit] Rename %ls => %ls, status %d\n", 
                From, To, status) );
        }
    }

    status = WppGrowBuf(&x->Buf, ExtraPadding + (len + 1) * sizeof(WCHAR) );
    if (status != ERROR_SUCCESS) {
        return status;
    }
    MoveMemory((LPBYTE)x->Buf + sizeof(EVENT_TRACE_PROPERTIES), x->Buf, (len + 1) * sizeof(WCHAR) ); // Free room for the header

    Trace = (PEVENT_TRACE_PROPERTIES)x->Buf;
    ZeroMemory(Trace, sizeof(EVENT_TRACE_PROPERTIES) );

    Trace->Wnode.BufferSize = sizeof(EVENT_TRACE_PROPERTIES) + (len + sessionNameLen + 2) * sizeof(WCHAR);
    Trace->Wnode.Flags = WNODE_FLAG_TRACED_GUID; 

    Trace->BufferSize      = WppRegQueryDword(LoggerKey, L"BufferSize",      0, 0, ~0u);
    Trace->MinimumBuffers  = WppRegQueryDword(LoggerKey, L"MinimumBuffers",  0, 0, ~0u);
    Trace->MaximumBuffers  = WppRegQueryDword(LoggerKey, L"MaximumBuffers",  0, 0, ~0u);
    Trace->MaximumFileSize = WppRegQueryDword(LoggerKey, L"MaximumFileSize", 0, 0, ~0u);
    Trace->LogFileMode     = WppRegQueryDword(LoggerKey, L"LogFileMode", WPP_DEFAULT_LOGGER_FLAGS, 0, ~0u);
    Trace->FlushTimer      = WppRegQueryDword(LoggerKey, L"FlushTimer",  0, 0, ~0u);
    Trace->EnableFlags     = WppRegQueryDword(LoggerKey, L"EnableFlags", 0, 0, ~0u);
    Trace->AgeLimit        = WppRegQueryDword(LoggerKey, L"AgeLimit",    0, 0, ~0u);

    Trace->LogFileNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
    Trace->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES) + (len + 1) * sizeof(WCHAR);

    wcscpy((LPWSTR)((LPBYTE)x->Buf + Trace->LoggerNameOffset), x->LogSessionName);

    status = StartTraceW(Logger, x->LogSessionName, Trace);
    WppDebug(1, ("[WppInit] Logger %ls started %x:%x %d\n", x->LogSessionName, *Logger, status) );
        
    return status;
}

typedef struct _WPP_INHERITED_DATA {
    TRACEHANDLE Logger;
    ULONG ControlFlags;
    ULONG ControlLevel;
} WPP_INHERITED_DATA, *PWPP_INHERITED_DATA;

WPPINIT_STATIC
ULONG
WppAutoStartInternal(
    IN HKEY Dir OPTIONAL, // if 0, use TracingKey ...
    IN LPCWSTR ProductName, 
    IN PWPP_INHERITED_DATA InheritedData OPTIONAL,
    IN OUT PWPP_AUTO_START_BUFFERS x // to minimize data allocations, the buffers are reused
    )
{
    ULONG status;
    WPP_INHERITED_DATA data;
    HKEY CloseMe = 0;
    HKEY hk      = 0;
    DWORD dwSizeOfModuleName;
    DWORD dwIndex;
    GUID  Guid;

    WppDebug(2, ("[WppInit] Init %ls\n", ProductName) );

    if (InheritedData) {
        data = *InheritedData;
    } else {
        ZeroMemory(&data, sizeof(data));
    }

    if (!Dir) {
        status = RegOpenKeyExW(HKEY_LOCAL_MACHINE, WPP_REG_TRACE_REGKEY, 0, KEY_READ, &Dir);
        if (status != ERROR_SUCCESS) {
            WppDebug(1, ("[WppInit] Failed to open Trace Key, %d\n", status) );
            goto exit_gracefully;
        }
        CloseMe = Dir;
        if (WppRegQueryDword(Dir, L"NoAutoStart", 0, 0, 1) == 1) {
            WppDebug(1, ("[WppInit] Auto-start vetoed\n") );
            goto exit_gracefully;
        }
    }

    status = RegOpenKeyExW(Dir, ProductName, 0, KEY_READ, &hk);
    if (status != ERROR_SUCCESS) {
        WppDebug(1, ("[WppInit] Failed to open %ls subkey, %d\n", ProductName, status) );
        goto exit_gracefully;
    }

    if (WppRegQueryDword(Dir, L"Active", 1, 0, 1) == 0) {
        WppDebug(1, ("[WppInit] Tracing is not active for %ls\n", ProductName) );
    	goto exit_gracefully;
    }

    WppReadLoggerInfo(hk, x, &data.Logger);

    data.ControlLevel = WppRegQueryDword(hk, L"ControlLevel", data.ControlLevel, 0, ~0u);
    data.ControlFlags = WppRegQueryDword(hk, L"ControlFlags", data.ControlFlags, 0, ~0u);

    if (WppRegQueryGuid(hk, L"Guid", &Guid) == ERROR_SUCCESS) {

        // We can try to start tracing //
        if (data.Logger) {
            status = EnableTrace(1, data.ControlFlags, data.ControlLevel,
                                 &Guid, data.Logger);
            WppDebug(1, ("[WppInit] Enable %ls, status %d\n", ProductName, status) );
        }
    }

    dwSizeOfModuleName = WPP_BUF_SIZE(x->Buf);
    dwIndex = 0;
    while (ERROR_SUCCESS == (status = RegEnumKeyExW(hk, dwIndex, 
                                                   x->Buf, &dwSizeOfModuleName,
                                                   NULL, NULL, NULL, NULL)))
    {
        status = WppAutoStartInternal(hk, x->Buf, &data, x);

        dwSizeOfModuleName = WPP_BUF_SIZE(x->Buf);
        ++dwIndex;
    }

    if (ERROR_NO_MORE_ITEMS == status) {
        status = ERROR_SUCCESS;
    }

exit_gracefully:
    if (CloseMe) {
        RegCloseKey(CloseMe);
    }
    if (hk) {
        RegCloseKey(hk);
    }
    return status;
}

ULONG
WppAutoStart(
    IN LPCWSTR ProductName
    )
{
    WPP_AUTO_START_BUFFERS x;
    ULONG status;
    x.LogSessionName = 0;
    x.Buf = 0;

    if (ProductName == NULL) {
        return ERROR_SUCCESS;
    }

    if( WppGrowBuf(&x.Buf, 1024) == ERROR_SUCCESS && 
        WppGrowBuf(&x.LogSessionName, 64) == ERROR_SUCCESS ) 
    {

        WppDebug(1, ("[WppInit] Initialize %ls\n", ProductName) );
        status = WppAutoStartInternal(0, ProductName, 0, &x);

    } else {
        WppDebug(1, ("[WppInit] Allocation failure\n") );
        status = ERROR_OUTOFMEMORY;
    }

    LocalFree(x.Buf);
    LocalFree(x.LogSessionName);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\bufpool.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

   bufpool.c

Abstract:

    Generic Buffer Pool Manager.

Author:

    Mike Massa (mikemas)           April 5, 1996

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     04-05-96    created

Notes:

    Buffer Pools provide a mechanism for managing caches of fixed size
    structures which are frequently allocated/deallocated.

--*/

#include "clusrtlp.h"


//
// Pool of generic buffers
//
typedef struct _CLRTL_BUFFER_POOL {
    DWORD                        PoolSignature;
    DWORD                        BufferSize;
    SINGLE_LIST_ENTRY            FreeList;
    DWORD                        MaximumCached;
    DWORD                        CurrentCached;
    DWORD                        MaximumAllocated;
    DWORD                        ReferenceCount;
    CLRTL_BUFFER_CONSTRUCTOR     Constructor;
    CLRTL_BUFFER_DESTRUCTOR      Destructor;
    CRITICAL_SECTION             Lock;
} CLRTL_BUFFER_POOL;


//
// Header for each allocated buffer
//
typedef struct {
    SINGLE_LIST_ENTRY    Linkage;
    PCLRTL_BUFFER_POOL   Pool;
} BUFFER_HEADER, *PBUFFER_HEADER;


#define BP_SIG   'loop'

#define ASSERT_BP_SIG(pool)  CL_ASSERT((pool)->PoolSignature == BP_SIG)


//
// Macros
//
//
#define BpAllocateMemory(size)    LocalAlloc(LMEM_FIXED, (size))
#define BpFreeMemory(buf)         LocalFree(buf)
#define BpAcquirePoolLock(Pool)   EnterCriticalSection(&((Pool)->Lock))
#define BpReleasePoolLock(Pool)   LeaveCriticalSection(&((Pool)->Lock))


//
// Public Functions
//
PCLRTL_BUFFER_POOL
ClRtlCreateBufferPool(
    IN DWORD                      BufferSize,
    IN DWORD                      MaximumCached,
    IN DWORD                      MaximumAllocated,
    IN CLRTL_BUFFER_CONSTRUCTOR   Constructor,         OPTIONAL
    IN CLRTL_BUFFER_DESTRUCTOR    Destructor           OPTIONAL
    )
/*++

Routine Description:

    Creates a pool from which fixed-size buffers may be allocated.

Arguments:

    BufferSize        - Size of the buffers managed by the pool.

    MaximumCached     - The maximum number of buffers to cache in the pool.
                        Must be less than or equal to MaximumAllocated.

    MaximumAllocated  - The maximum number of buffers to allocate from
                        system memory. Must be less than or equal to
                        CLRTL_MAX_POOL_BUFFERS.

    Constructor       - An optional routine to be called when a new buffer
                        is allocated from system memory. May be NULL

    Destructor        - An optional routine to be called when a buffer
                        is returned to system memory. May be NULL.

Return Value:

    A pointer to the created buffer pool or NULL on error.
    Extended error information is available from GetLastError().

--*/

{
    PCLRTL_BUFFER_POOL  pool;


    if ( (MaximumAllocated > CLRTL_MAX_POOL_BUFFERS) ||
         (MaximumCached > MaximumAllocated)
       )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(NULL);
    }

    pool = BpAllocateMemory(sizeof(CLRTL_BUFFER_POOL));

    if (pool != NULL) {

        InitializeCriticalSection(&(pool->Lock));

        pool->PoolSignature = BP_SIG;
        pool->BufferSize = sizeof(BUFFER_HEADER) + BufferSize;
        pool->FreeList.Next = NULL;
        pool->MaximumCached = MaximumCached;
        pool->CurrentCached = 0;
        pool->MaximumAllocated = MaximumAllocated + 1;
        pool->ReferenceCount = 1;
        pool->Constructor = Constructor;
        pool->Destructor = Destructor;
    }
    else {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return(pool);
}


VOID
ClRtlDestroyBufferPool(
    IN PCLRTL_BUFFER_POOL  Pool
    )
/*++

Routine Description:

    Destroys a previously created buffer pool.

Arguments:

    Pool  - A pointer to the pool to destroy.

Return Value:

    None.

Notes:

    The pool will not actually be destroyed until all outstanding
    buffers have been returned. Each outstanding buffer is effectively
    a reference on the pool.

--*/

{
    SINGLE_LIST_ENTRY          deleteList;
    CLRTL_BUFFER_DESTRUCTOR    destructor;
    PSINGLE_LIST_ENTRY         item;
    PBUFFER_HEADER             header;
    BOOLEAN                    freePool;


    deleteList.Next = NULL;

    ASSERT_BP_SIG(Pool);

    BpAcquirePoolLock(Pool);

    CL_ASSERT(Pool->ReferenceCount != 0);
    Pool->ReferenceCount--;          // Remove initial reference.
    destructor = Pool->Destructor;

    //
    // Free all cached buffers
    //
    item = PopEntryList(&(Pool->FreeList));

    while (item != NULL) {
        CL_ASSERT(Pool->ReferenceCount != 0);
        PushEntryList(&deleteList, item);
        Pool->ReferenceCount--;

        item = PopEntryList(&(Pool->FreeList));
    }

    if (Pool->ReferenceCount == 0) {
        BpReleasePoolLock(Pool);

        DeleteCriticalSection(&(Pool->Lock));
        BpFreeMemory(Pool);
    }
    else {
        //
        // Pool destruction is deferred until all buffers have been freed.
        //
        Pool->CurrentCached = 0;
        Pool->MaximumCached = 0;

        BpReleasePoolLock(Pool);
    }

    item = PopEntryList(&deleteList);

    while (item != NULL) {
        header = CONTAINING_RECORD(
                     item,
                     BUFFER_HEADER,
                     Linkage
                     );

        if (destructor != NULL) {
            (*destructor)(header+1);
        }

        BpFreeMemory(header);

        item = PopEntryList(&deleteList);
    }

    return;
}


PVOID
ClRtlAllocateBuffer(
    IN PCLRTL_BUFFER_POOL Pool
    )
/*++

Routine Description:

    Allocates a buffer from a previously created buffer pool.

Arguments:

    Pool - A pointer to the pool from which to allocate the buffer.

Return Value:

    A pointer to the allocated buffer if the routine was successfull.
    NULL if the routine failed. Extended error information is available
    by calling GetLastError().

--*/

{

//
// turn this fancy stuff off until it works.
//
#if 0
    PSINGLE_LIST_ENTRY    item;
    PBUFFER_HEADER        header;
    PVOID                 buffer;
    DWORD                 status;


    ASSERT_BP_SIG(Pool);

    BpAcquirePoolLock(Pool);

    //
    // First, check the cache.
    //
    item = PopEntryList(&(Pool->FreeList));

    if (item != NULL) {
        CL_ASSERT(Pool->CurrentCached != 0);
        Pool->CurrentCached--;

        BpReleasePoolLock(Pool);

        header = CONTAINING_RECORD(
                     item,
                     BUFFER_HEADER,
                     Linkage
                     );

        return(header+1);
    }

    //
    // Need to allocate a fresh buffer from system memory.
    //
    if (Pool->ReferenceCount < Pool->MaximumAllocated) {
        //
        // This is equivalent to a reference on the Pool.
        //
        Pool->ReferenceCount++;

        BpReleasePoolLock(Pool);

        header = BpAllocateMemory(Pool->BufferSize);

        if (header != NULL) {
            header->Pool = Pool;
            buffer = header+1;

            if (Pool->Constructor == NULL) {
                return(buffer);
            }

            status = (*(Pool->Constructor))(buffer);

            if (status == ERROR_SUCCESS) {
                return(buffer);
            }

            SetLastError(status);

            //
            // The constructor failed.
            //
            BpFreeMemory(header);
        }
        else {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }

        //
        // Failed - undo the reference.
        //
        BpAcquirePoolLock(Pool);

        Pool->ReferenceCount--;
    }
    else {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    BpReleasePoolLock(Pool);

    return(NULL);
#else
    return(LocalAlloc(LMEM_FIXED, Pool->BufferSize));
#endif
}


VOID
ClRtlFreeBuffer(
    PVOID Buffer
    )
/*++

Routine Description:

    Frees a buffer back to its owning pool.

Arguments:

    Buffer   - The buffer to free.

Return Value:

    None.

--*/
{
//
//  turn this fancy stuff off until it works.
//
#if 0

    PBUFFER_HEADER              header;
    PCLRTL_BUFFER_POOL          pool;
    CLRTL_BUFFER_DESTRUCTOR     destructor;


    header = ((PBUFFER_HEADER) Buffer) - 1;

    pool = header->Pool;

    ASSERT_BP_SIG(pool);

    BpAcquirePoolLock(pool);

    if (pool->CurrentCached < pool->MaximumCached) {
        //
        // Return to free list
        //
        PushEntryList(
            &(pool->FreeList),
            (PSINGLE_LIST_ENTRY) &(header->Linkage)
            );

        pool->CurrentCached++;

        BpReleasePoolLock(pool);

        return;
    }

    destructor = pool->Destructor;

    CL_ASSERT(pool->ReferenceCount != 0);

    if (--(pool->ReferenceCount) != 0) {
        BpReleasePoolLock(pool);

        if (destructor) {
            (*destructor)(Buffer);
        }

        BpFreeMemory(header);

        return;

    }

    CL_ASSERT(pool->CurrentCached == 0);
    BpReleasePoolLock(pool);
    DeleteCriticalSection(&(pool->Lock));
    BpFreeMemory(pool);

    if (destructor) {
        (*destructor)(Buffer);
    }

    BpFreeMemory(header);

    return;
#else
    LocalFree(Buffer);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\xport\cxinit.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cxinit.c

Abstract:

    Initialization code for the Cluster Network Driver.

Author:

    Mike Massa (mikemas)           January 3, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     01-03-97    created

Notes:

--*/

#include "precomp.h"

#pragma hdrstop
#include "cxinit.tmh"

//
// Tdi Data
//
HANDLE  CxTdiRegistrationHandle = NULL;
HANDLE  CxTdiPnpBindingHandle = NULL;


//
// FIPS function table
//
HANDLE              CxFipsDriverHandle = NULL;
FIPS_FUNCTION_TABLE CxFipsFunctionTable;


#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, CxLoad)
#pragma alloc_text(PAGE, CxUnload)
#pragma alloc_text(PAGE, CxInitialize)
#pragma alloc_text(PAGE, CxShutdown)

#endif // ALLOC_PRAGMA


//
// Routines
//
NTSTATUS
CxLoad(
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    Driver load routine for the cluster transport. Initializes all
    transport data structures.

Arguments:

    RegistryPath   - The driver's registry key.

Return Value:

    An NT status code.

--*/

{
    NTSTATUS                    status;
    UNICODE_STRING              deviceName;
    TDI_CLIENT_INTERFACE_INFO   info;



    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CX] Loading...\n"));
    }

    TdiInitialize();

    //
    // Register our device object with TDI.
    //
    RtlInitUnicodeString(&deviceName, DD_CDP_DEVICE_NAME);

    status = TdiRegisterDeviceObject(&deviceName, &CxTdiRegistrationHandle);

    if (!NT_SUCCESS(status)) {
        CNPRINT((
            "[CX] Unable to register device %ws with TDI, status %lx\n",
            deviceName.Buffer,
            status
            ));
        return(status);
    }

    //
    // Register for PnP events.
    //
    RtlZeroMemory(&info, sizeof(info));

    info.MajorTdiVersion = 2;
    info.MinorTdiVersion = 0;
    info.ClientName = &deviceName;
    info.AddAddressHandlerV2 = CxTdiAddAddressHandler;
    info.DelAddressHandlerV2 = CxTdiDelAddressHandler;

    status = TdiRegisterPnPHandlers(
                 &info,
                 sizeof(info),
                 &CxTdiPnpBindingHandle
                 );

    if (!NT_SUCCESS(status)) {
        CNPRINT((
            "[CX] Unable to register for TDI PnP events, status %lx\n",
            status
            ));
        return(status);
    }

    //
    // Register for WMI NDIS media status events.
    //
    status = CxWmiPnpLoad();
    if (!NT_SUCCESS(status)) {
        CNPRINT((
            "[CX] Failed to initialize WMI PnP event handlers, "
            "status %lx\n",
            status
            ));
    }

    //
    // Get the FIPS function table. Hold onto the FIPS driver
    // handle so that the FIPS driver cannot unload.
    //
    status = CnpOpenDevice(FIPS_DEVICE_NAME, &CxFipsDriverHandle);
    if (NT_SUCCESS(status)) {

        status = CnpZwDeviceControl(
                     CxFipsDriverHandle,
                     IOCTL_FIPS_GET_FUNCTION_TABLE,
                     NULL,
                     0,
                     &CxFipsFunctionTable,
                     sizeof(CxFipsFunctionTable)
                     );
        if (!NT_SUCCESS(status)) {
            IF_CNDBG(CN_DEBUG_INIT) {
                CNPRINT(("[CNP] Failed to fill FIPS function "
                         "table, status %x.\n", status));
            }
        }

    } else {
        CxFipsDriverHandle = NULL;
        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[CNP] Failed to open FIPS device, "
                     "status %x.\n", status));
        }
    }
    if (status != STATUS_SUCCESS) {
        return(status);
    }

    status = CnpLoadNodes();

    if (status != STATUS_SUCCESS) {
        return(status);
    }

    status = CnpLoadNetworks();

    if (status != STATUS_SUCCESS) {
        return(status);
    }

    status = CnpLoad();

    if (status != STATUS_SUCCESS) {
        return(status);
    }

    status = CcmpLoad();

    if (status != STATUS_SUCCESS) {
        return(status);
    }

    status = CxInitializeHeartBeat();

    if (status != STATUS_SUCCESS) {
        return(status);
    }

    status = CdpLoad();

    if (status != STATUS_SUCCESS) {
        return(status);
    }

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CX] Loaded.\n"));
    }

    return(STATUS_SUCCESS);

} // CxLoad


VOID
CxUnload(
    VOID
    )

/*++

Routine Description:

    Called when the Cluster Network driver is unloading. Frees all resources
    allocated by the Cluster Transport.

    The Transport is guaranteed not to receive any more user-mode requests,
    membership send requests, or membership events at the time
    this routine is called.

    A shutdown of the Cluster Network driver has already occured when this
    routine is called.

Arguments:

    None.

Return Value:

    None

Notes:

    This routine MUST be callable even if CxLoad() has not yet been
    called.

--*/

{
    PAGED_CODE();


    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CX] Unloading...\n"));
    }

    CxUnreserveClusnetEndpoint();

    CdpUnload();

    CxUnloadHeartBeat();

    CcmpUnload();

    CnpUnload();

    CxWmiPnpUnload();

    if (CxFipsDriverHandle != NULL) {
        ZwClose(CxFipsDriverHandle);
        CxFipsDriverHandle = NULL;
    }

    if (CxTdiPnpBindingHandle != NULL) {
        TdiDeregisterPnPHandlers(CxTdiPnpBindingHandle);
        CxTdiPnpBindingHandle = NULL;
    }

    if (CxTdiRegistrationHandle != NULL) {
        TdiDeregisterDeviceObject(CxTdiRegistrationHandle);
        CxTdiRegistrationHandle = NULL;
    }

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CX] Unloaded.\n"));
    }

    return;

} // CxUnload



NTSTATUS
CxInitialize(
    VOID
    )
/*++

Routine Description:

    Initialization routine for the Cluster Transport.
    Called when the Membership Manager is starting up.
    Enables operation of the transport.

Arguments:

    None.

Return Value:

    An NT status code.

--*/
{
    NTSTATUS   status;

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CX] Initializing...\n"));
    }

    EventEpoch = 0;

    status = CnpInitializeNodes();

    if (!NT_SUCCESS(status)) {
        return(status);
    }

    status = CnpInitializeNetworks();

    if (!NT_SUCCESS(status)) {
        return(status);
    }

    status = CxWmiPnpInitialize();

    if (!NT_SUCCESS(status)) {
        return(status);
    }

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CX] Initialized...\n"));
    }

    return(STATUS_SUCCESS);

} // CxInitialize


VOID
CxShutdown(
    VOID
    )
/*++

Routine Description:

    Terminates operation of the Cluster Transport.
    Called when the Membership Manager is shutting down.

Arguments:

    None.

Return Value:

    None.

--*/
{

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CX] Shutting down...\n"));
    }

    CnpStopHeartBeats();

    CxWmiPnpShutdown();

    CnpShutdownNetworks();

    CnpShutdownNodes();

    IF_CNDBG(CN_DEBUG_INIT) {
        CNPRINT(("[CX] Shutdown complete...\n"));
    }

    return;

} // CxShutdown
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusnet\xport\cxpnp.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cxpnp.c

Abstract:

    PnP handling code for the Cluster Network Driver.

Author:

    Mike Massa (mikemas)           March 21, 1998

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     03-22-98    created

Notes:

--*/

#include "precomp.h"

#include <ntddk.h>
#include <wmistr.h>
#include <ndisguid.h>
#include <ntddndis.h>
#include <ntpnpapi.h>
#include <zwapi.h>

#pragma hdrstop
#include "cxpnp.tmh"

//
// Local data structures
//
typedef struct _CNP_WMI_RECONNECT_WORKER_CONTEXT {
    PIO_WORKITEM  WorkItem;
    CL_NETWORK_ID NetworkId;
} CNP_WMI_RECONNECT_WORKER_CONTEXT, *PCNP_WMI_RECONNECT_WORKER_CONTEXT;

//
// WMI Data
//
PERESOURCE CnpWmiNdisMediaStatusResource = NULL;
PVOID      CnpWmiNdisMediaStatusConnectObject = NULL;
PVOID      CnpWmiNdisMediaStatusDisconnectObject = NULL;
HANDLE     CnpIpMediaSenseFileHandle = NULL;
PIRP       CnpIpDisableMediaSenseIrp = NULL;
PKEVENT    CnpIpDisableMediaSenseEvent = NULL;


//
// Local prototypes
//
NTSTATUS
CnpWmiPnpDisableMediaSenseCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

VOID
CnpWmiNdisMediaStatusConnectCallback(
    IN PVOID             Wnode,
    IN PVOID             Context
    );

VOID
CnpWmiNdisMediaStatusDisconnectCallback(
    IN PVOID             Wnode,
    IN PVOID             Context
    );

VOID
CnpReconnectLocalInterfaceWrapper(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    );

VOID
CnpDisconnectLocalInterface(
    PCNP_INTERFACE Interface,
    PCNP_NETWORK   Network
    );


#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, CxWmiPnpLoad)
#pragma alloc_text(PAGE, CxWmiPnpUnload)
#pragma alloc_text(PAGE, CxWmiPnpInitialize)
#pragma alloc_text(PAGE, CxWmiPnpShutdown)

#endif // ALLOC_PRAGMA


//
// Exported Routines
//
VOID
CxTdiAddAddressHandler(
    IN PTA_ADDRESS       TaAddress,
    IN PUNICODE_STRING   DeviceName,
    IN PTDI_PNP_CONTEXT  Context
    )
{
    if (TaAddress->AddressType == TDI_ADDRESS_TYPE_IP) {
        NTSTATUS          status;
        PTDI_ADDRESS_IP   tdiAddressIp = (PTDI_ADDRESS_IP)
                                         &(TaAddress->Address[0]);


        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT((
                "[CX] Processing PnP add event for IP address %lx\n",
                tdiAddressIp->in_addr
                ));
        }

        //
        // Ensure that this is a valid address, and that it is not one
        // that we brought online for a cluster ip address resource.
        //
        if (tdiAddressIp->in_addr != 0) {
            if (!IpaIsAddressRegistered(tdiAddressIp->in_addr)) {
                IF_CNDBG(CN_DEBUG_CONFIG) {
                    CNPRINT((
                        "[CX] Issuing address add event to cluster svc for IP address %lx\n",
                        tdiAddressIp->in_addr
                        ));
                }
                CnIssueEvent(
                    ClusnetEventAddAddress,
                    0,
                    (CL_NETWORK_ID) tdiAddressIp->in_addr
                    );
            }
            else {
                IF_CNDBG(CN_DEBUG_CONFIG) {
                    CNPRINT((
                        "[CX] PnP add event is for an IP address resource, skip.\n"
                        ));
                }
            }
        }
    }

    return;

} // CxTdiAddAddressHandler


VOID
CxTdiDelAddressHandler(
    IN PTA_ADDRESS       TaAddress,
    IN PUNICODE_STRING   DeviceName,
    IN PTDI_PNP_CONTEXT  Context
    )
{


    if (TaAddress->AddressType == TDI_ADDRESS_TYPE_IP) {
        NTSTATUS           status;
        PCNP_INTERFACE     interface;
        PCNP_NETWORK       network;
        PLIST_ENTRY        entry;
        PTA_IP_ADDRESS     taIpAddress;
        CN_IRQL            nodeTableIrql;
        CL_NODE_ID         i;
        PTDI_ADDRESS_IP    tdiAddressIp = (PTDI_ADDRESS_IP)
                                          &(TaAddress->Address[0]);

        IF_CNDBG(CN_DEBUG_CONFIG) {
            CNPRINT((
                "[CX] Processing PnP delete event for IP address %lx.\n",
                tdiAddressIp->in_addr
                ));
        }

        if (tdiAddressIp->in_addr != 0) {
            //
            // Figure out if this is the address for one of this node's
            // registered interfaces.
            //
            CnAcquireLock(&CnpNodeTableLock, &nodeTableIrql);

            if (CnpLocalNode != NULL) {
                CnAcquireLockAtDpc(&(CnpLocalNode->Lock));
                CnReleaseLockFromDpc(&CnpNodeTableLock);
                CnpLocalNode->Irql = nodeTableIrql;

                network = NULL;

                for (entry = CnpLocalNode->InterfaceList.Flink;
                     entry != &(CnpLocalNode->InterfaceList);
                     entry = entry->Flink
                    )
                {
                    interface = CONTAINING_RECORD(
                                    entry,
                                    CNP_INTERFACE,
                                    NodeLinkage
                                    );

                    taIpAddress = (PTA_IP_ADDRESS) &(interface->TdiAddress);

                    if (taIpAddress->Address[0].Address[0].in_addr ==
                        tdiAddressIp->in_addr
                       )
                    {
                        //
                        // Found the local interface corresponding to this
                        // address. Be proactive - destroy the corresponding
                        // network now.
                        //
                        network = interface->Network;

                        CnAcquireLockAtDpc(&CnpNetworkListLock);
                        CnAcquireLockAtDpc(&(network->Lock));
                        CnReleaseLockFromDpc(&(CnpLocalNode->Lock));
                        network->Irql = DISPATCH_LEVEL;

                        IF_CNDBG(CN_DEBUG_CONFIG) {
                            CNPRINT((
                                "[CX] Deleting network ID %u after PnP "
                                "delete event for IP address %lx.\n",
                                network->Id, tdiAddressIp->in_addr
                                ));
                        }

                        CnpDeleteNetwork(network, nodeTableIrql);

                        //
                        // Both locks were released.
                        //
                        break;
                    }
                }

                if (network == NULL) {
                    CnReleaseLock(&(CnpLocalNode->Lock), CnpLocalNode->Irql);
                }

                //
                // Post an event to the service.
                //
                CnIssueEvent(
                    ClusnetEventDelAddress,
                    0,
                    (CL_NETWORK_ID) tdiAddressIp->in_addr
                    );
            }
            else {
                CnReleaseLock(&CnpNodeTableLock, nodeTableIrql);
            }
        }
    }

    return;

} // CxTdiDelAddressHandler


NTSTATUS
CxWmiPnpLoad(
    VOID
    )
/*++

Notes:

    Called when clusnet driver is loaded.
    
--*/    
{
    PDEVICE_OBJECT     ipDeviceObject = NULL;
    PFILE_OBJECT       ipFileObject = NULL;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS           status;

    //
    // Allocate a synchronization resource.
    //
    CnpWmiNdisMediaStatusResource = CnAllocatePool(sizeof(ERESOURCE));

    if (CnpWmiNdisMediaStatusResource == NULL) {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    status = ExInitializeResourceLite(CnpWmiNdisMediaStatusResource);

    if (!NT_SUCCESS(status)) {
        return(status);
    }

    //
    // Get a handle to the IP device object to disable media sense
    //
    status = CnpOpenDevice(
                 DD_IP_DEVICE_NAME,
                 &CnpIpMediaSenseFileHandle
                 );
    if (!NT_SUCCESS(status)) {
        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[CX] Failed to open IP device to "
                     "disable media sense, status %lx\n", 
                     status));
        }
        return(status);
    }

    //
    // Disable IP media sense. This works by submitting an
    // IOCTL_IP_DISABLE_MEDIA_SENSE_REQUEST IRP. The IRP
    // will pend until we cancel it (re-enabling media sense).
    //
    CnpIpDisableMediaSenseEvent = CnAllocatePool(sizeof(KEVENT));

    if (CnpIpDisableMediaSenseEvent != NULL) {

        KeInitializeEvent(
            CnpIpDisableMediaSenseEvent,
            SynchronizationEvent,
            FALSE
            );

        //
        // Reference the IP file object and get the device object
        //
        status = ObReferenceObjectByHandle(
                     CnpIpMediaSenseFileHandle,
                     0,
                     NULL,
                     KernelMode,
                     &ipFileObject,
                     NULL
                     );

        if (NT_SUCCESS(status)) {

            ipDeviceObject = IoGetRelatedDeviceObject(ipFileObject);

            //
            // File object reference is no longer needed
            // because the handle is still open.
            //
            ObDereferenceObject(ipFileObject);

            CnpIpDisableMediaSenseIrp = IoAllocateIrp(
                                            ipDeviceObject->StackSize,
                                            FALSE
                                            );

            if (CnpIpDisableMediaSenseIrp != NULL) {

                irpSp = IoGetNextIrpStackLocation(CnpIpDisableMediaSenseIrp);

                irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
                irpSp->Parameters.DeviceIoControl.IoControlCode
                    = IOCTL_IP_DISABLE_MEDIA_SENSE_REQUEST;
                irpSp->DeviceObject = ipDeviceObject;
                irpSp->FileObject = ipFileObject;

                IoSetCompletionRoutine(
                    CnpIpDisableMediaSenseIrp,
                    CnpWmiPnpDisableMediaSenseCompletion,
                    NULL,
                    TRUE,
                    TRUE,
                    TRUE
                    );

                status = IoCallDriver(
                             ipDeviceObject, 
                             CnpIpDisableMediaSenseIrp
                             );

                if (status != STATUS_PENDING) {
                    IF_CNDBG(CN_DEBUG_INIT) {
                        CNPRINT(("[CX] Failed to disable IP media "
                                 "sense, status %lx\n", status));
                    }
                    KeWaitForSingleObject(
                        CnpIpDisableMediaSenseEvent,
                        Executive,
                        KernelMode,
                        FALSE,
                        NULL
                        );
                    CnFreePool(CnpIpDisableMediaSenseEvent);
                    CnpIpDisableMediaSenseEvent = NULL;
                    IoFreeIrp(CnpIpDisableMediaSenseIrp);
                    CnpIpDisableMediaSenseIrp = NULL;

                    //
                    // Cannot risk simply returning status
                    // because we need the driver load to
                    // fail.
                    //
                    if (NT_SUCCESS(status)) {
                        status = STATUS_UNSUCCESSFUL;
                    }

                } else {

                    //
                    // Need to return STATUS_SUCCESS so that
                    // the driver load will not fail.
                    //
                    status = STATUS_SUCCESS;

                    IF_CNDBG(CN_DEBUG_INIT) {
                        CNPRINT(("[CX] IP media sense disabled.\n"));
                    }

                    CnTrace(
                        CXPNP, CxWmiPnpIPMediaSenseDisabled,
                        "[CXPNP] IP media sense disabled.\n"
                        );
                }

            } else {

                IF_CNDBG(CN_DEBUG_INIT) {
                    CNPRINT(("[CX] Failed to allocate IP media sense "
                             "disable IRP.\n"));
                }
                CnFreePool(CnpIpDisableMediaSenseEvent);
                CnpIpDisableMediaSenseEvent = NULL;
                status = STATUS_INSUFFICIENT_RESOURCES;
            }

        } else {
            IF_CNDBG(CN_DEBUG_INIT) {
                CNPRINT(("[CX] Failed to reference IP device "
                         "file handle, status %lx\n", status));
            }
            CnFreePool(CnpIpDisableMediaSenseEvent);
            CnpIpDisableMediaSenseEvent = NULL;
        }

    } else {

        IF_CNDBG(CN_DEBUG_INIT) {
            CNPRINT(("[CX] Failed to allocate IP media sense "
                     "disable event.\n"));
        }
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return(status);

}  // CxWmiPnpLoad


VOID
CxWmiPnpUnload(
    VOID
    )
/*++

Notes:

    Called when clusnet driver is unloaded.
    
--*/    
{
    CnAssert(CnpWmiNdisMediaStatusConnectObject == NULL);
    CnAssert(CnpWmiNdisMediaStatusDisconnectObject == NULL);

    //
    // Re-enable IP media sense. This works by cancelling our
    // IOCTL_IP_DISABLE_MEDIA_SENSE_REQUEST IRP, which should
    // still be pending.
    //
    if (CnpIpDisableMediaSenseIrp != NULL) {
        
        if (!IoCancelIrp(CnpIpDisableMediaSenseIrp)) {

            //
            // Our disable media sense IRP could not be cancelled. This
            // probably means that it was completed because somebody
            // else submitted a media sense enable request. 
            //
            CnTrace(
                CXPNP, CnpWmiPnpDisableMediaSenseCompletionUnexpected,
                "[CXPNP] IP media sense re-enabled unexpectedly.\n"
                );

        } else {

            //
            // Irp was cancelled, and media sense is disabled as
            // expected.
            //
            CnTrace(
                CXPNP, CnpWmiPnpDisableMediaSenseCompletion,
                "[CXPNP] IP media sense re-enabled.\n"
                );
        }

        //
        // Regardless of who re-enabled media sense, we need to free
        // the media sense IRP and event. First we wait on the event,
        // which is signalled in our completion routine.
        //
        KeWaitForSingleObject(
            CnpIpDisableMediaSenseEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        CnFreePool(CnpIpDisableMediaSenseEvent);
        CnpIpDisableMediaSenseEvent = NULL;

        IoFreeIrp(CnpIpDisableMediaSenseIrp);
        CnpIpDisableMediaSenseIrp = NULL;
    } 

    CnAssert(CnpIpDisableMediaSenseIrp == NULL);

    if (CnpIpMediaSenseFileHandle != NULL) {
        ZwClose(CnpIpMediaSenseFileHandle);
        CnpIpMediaSenseFileHandle = NULL;
    }

    if (CnpWmiNdisMediaStatusResource != NULL) {
        ExDeleteResourceLite(CnpWmiNdisMediaStatusResource);
        CnFreePool(CnpWmiNdisMediaStatusResource); 
        CnpWmiNdisMediaStatusResource = NULL;
    }

}  // CxWmiPnpUnload


NTSTATUS
CxWmiPnpInitialize(
    VOID
    )
/*++

Notes:

    Called in response to initialize ioctl.
    
--*/
{
    NTSTATUS           status = STATUS_SUCCESS;
    BOOLEAN            acquired = FALSE;
    GUID               wmiGuid;

    PAGED_CODE();

    acquired = CnAcquireResourceExclusive(
                   CnpWmiNdisMediaStatusResource,
                   TRUE
                   );
    
    CnAssert(acquired == TRUE);

    //
    // Register WMI callbacks for NDIS media status events
    //

    if (CnpWmiNdisMediaStatusConnectObject == NULL) {

        wmiGuid = GUID_NDIS_STATUS_MEDIA_CONNECT;
        status = IoWMIOpenBlock(
                     &wmiGuid,
                     WMIGUID_NOTIFICATION,
                     &CnpWmiNdisMediaStatusConnectObject
                     );
        if (!NT_SUCCESS(status)) {
            CNPRINT((
                "[CX] Unable to open WMI NDIS status media connect "
                "datablock, status %lx\n",
                status
                ));
            CnpWmiNdisMediaStatusConnectObject = NULL;
            goto error_exit;
        }

        status = IoWMISetNotificationCallback(
                     CnpWmiNdisMediaStatusConnectObject,
                     CnpWmiNdisMediaStatusConnectCallback,
                     NULL
                     );
        if (!NT_SUCCESS(status)) {
            CNPRINT((
                "[CX] Unable to register WMI NDIS status media connect "
                "callback, status %lx\n",
                status
                ));
            goto error_exit;
        }

    }

    if (CnpWmiNdisMediaStatusDisconnectObject == NULL) {

        wmiGuid = GUID_NDIS_STATUS_MEDIA_DISCONNECT;
        status = IoWMIOpenBlock(
                     &wmiGuid,
                     WMIGUID_NOTIFICATION,
                     &CnpWmiNdisMediaStatusDisconnectObject
                     );
        if (!NT_SUCCESS(status)) {
            CNPRINT((
                "[CX] Unable to open WMI NDIS status media disconnect "
                "datablock, status %lx\n",
                status
                ));
            CnpWmiNdisMediaStatusDisconnectObject = NULL;
            goto error_exit;
        }

        status = IoWMISetNotificationCallback(
                     CnpWmiNdisMediaStatusDisconnectObject,
                     CnpWmiNdisMediaStatusDisconnectCallback,
                     NULL
                     );
        if (!NT_SUCCESS(status)) {
            CNPRINT((
                "[CX] Unable to register WMI NDIS status media disconnect "
                "callback, status %lx\n",
                status
                ));
            goto error_exit;
        }
    }

    goto release_exit;

error_exit:
    
    if (CnpWmiNdisMediaStatusConnectObject != NULL) {
        ObDereferenceObject(CnpWmiNdisMediaStatusConnectObject);
        CnpWmiNdisMediaStatusConnectObject = NULL;
    }

    if (CnpWmiNdisMediaStatusDisconnectObject != NULL) {
        ObDereferenceObject(CnpWmiNdisMediaStatusDisconnectObject);
        CnpWmiNdisMediaStatusDisconnectObject = NULL;
    }

release_exit:
    //
    // Release resource
    //
    if (acquired) {
        CnReleaseResourceForThread(
            CnpWmiNdisMediaStatusResource,
            (ERESOURCE_THREAD) PsGetCurrentThread()
            );
    }

    return(status);
    
}  // CxWmiPnpInitialize


VOID
CxWmiPnpShutdown(
    VOID
    )
/*++

Notes:

    Called in response to clusnet shutdown.
    
--*/
{
    BOOLEAN  acquired = FALSE;

    PAGED_CODE();

    acquired = CnAcquireResourceExclusive(
                   CnpWmiNdisMediaStatusResource,
                   TRUE
                   );
    
    CnAssert(acquired == TRUE);

    if (CnpWmiNdisMediaStatusConnectObject != NULL) {
        ObDereferenceObject(CnpWmiNdisMediaStatusConnectObject);
        CnpWmiNdisMediaStatusConnectObject = NULL;
    }

    if (CnpWmiNdisMediaStatusDisconnectObject != NULL) {
        ObDereferenceObject(CnpWmiNdisMediaStatusDisconnectObject);
        CnpWmiNdisMediaStatusDisconnectObject = NULL;
    }

    //
    // Release resource
    //
    if (acquired) {
        CnReleaseResourceForThread(
            CnpWmiNdisMediaStatusResource,
            (ERESOURCE_THREAD) PsGetCurrentThread()
            );
    }
    
    return;

}  // CxWmiPnpShutdown


VOID
CxReconnectLocalInterface(
    IN CL_NETWORK_ID NetworkId
    )
/**

Routine Description:

    Queues a worker thread to set the local interface
    associated with NetworkId to connected. Called when
    a heartbeat is received over a network that is marked
    locally disconnected.
    
Arguments:

    NetworkId - network ID of network to be reconnected
    
Return value:

    None
    
Notes:

    Can fail without reporting an error if either
    allocation fails.

--*/
{
    PCNP_WMI_RECONNECT_WORKER_CONTEXT context;
    
    context = CnAllocatePool(sizeof(CNP_WMI_RECONNECT_WORKER_CONTEXT));

    if (context != NULL) {
        
        context->WorkItem = IoAllocateWorkItem(CnDeviceObject);

        if (context->WorkItem != NULL) {

            context->NetworkId = NetworkId;

            CnTrace(
                CXPNP, CxReconnectLocalInterface,
                "[CXPNP] Queueing worker thread to reconnect local "
                "interface for network ID %u.\n",
                NetworkId // LOGULONG
                );

            IoQueueWorkItem(
                context->WorkItem, 
                CnpReconnectLocalInterfaceWrapper, 
                DelayedWorkQueue,
                context
                );
        
        } else {

            CnFreePool(context);
        }
    }

    return;
}


VOID
CxQueryMediaStatus(
    IN  HANDLE            AdapterDeviceHandle,
    IN  CL_NETWORK_ID     NetworkId,
    OUT PULONG            MediaStatus
    )
/**

Routine Description:

    Queries the status of the adapter device. Used to 
    determine whether a local interface is initially
    connected or disconnected.

Arguments:

    AdapterHandle - adapter device object handle
    NetworkId - network ID of adapter to be queried
    
Return value:

    None
    
Notes:

    NDIS query formation modeled after ndis\lib\ndisapi.c

--*/
{
    BOOLEAN                      acquired = FALSE;
    NTSTATUS                     status;

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    //
    // Set default
    //
    *MediaStatus = NdisMediaStateDisconnected;

    //
    // Acquire resource
    //
    acquired = CnAcquireResourceExclusive(
                   CnpWmiNdisMediaStatusResource,
                   TRUE
                   );
    
    CnAssert(acquired == TRUE);

    if (AdapterDeviceHandle != NULL) {
        
        //
        // Construct NDIS statistics query
        //
        
        NDIS_OID statsOidList[] =
        {
            OID_GEN_MEDIA_CONNECT_STATUS // | NDIS_OID_PRIVATE
        };
        UCHAR                  statsBuf[
                                   FIELD_OFFSET(NDIS_STATISTICS_VALUE, Data)
                                   + sizeof(LARGE_INTEGER)
                                   ];
        PNDIS_STATISTICS_VALUE pStatsBuf;
        LARGE_INTEGER          value;

        IF_CNDBG( CN_DEBUG_CONFIG ) {
            CNPRINT((
                "[CXPNP] Querying NDIS for local adapter "
                "on network %u (handle %p).\n",
                NetworkId,
                AdapterDeviceHandle
                ));
        }

        pStatsBuf = (PNDIS_STATISTICS_VALUE) &statsBuf[0];
        status = CnpZwDeviceControl(
                     AdapterDeviceHandle,
                     IOCTL_NDIS_QUERY_SELECTED_STATS,
                     statsOidList,
                     sizeof(statsOidList),
                     pStatsBuf,
                     sizeof(statsBuf)
                     );
        
        IF_CNDBG( CN_DEBUG_CONFIG ) {
            CNPRINT((
                "[CXPNP] NDIS query for local adapter "
                "on network %u returned status %lx.\n",
                NetworkId,
                status
                ));
        }

        if (pStatsBuf->DataLength == sizeof(LARGE_INTEGER)) {
            value.QuadPart = *(PULONGLONG)(&pStatsBuf->Data[0]);
        } else {
            value.LowPart = *(PULONG)(&pStatsBuf->Data[0]);
        }
        
        *MediaStatus = value.LowPart; // NdisMediaState{Disc|C}onnected
    
        IF_CNDBG( CN_DEBUG_CONFIG ) {
            CNPRINT((
                "[CXPNP] NDIS query for local adapter "
                "on network %u returned media status %lx.\n",
                NetworkId,
                *MediaStatus
                ));
        }

        CnTrace(
            CXPNP, CxQueryMediaStatus,
            "[CXPNP] Found media status %u for local network ID %u.\n",
            *MediaStatus, // LOGULONG
            NetworkId // LOGULONG
            );
    }

    //
    // If the media status is disconnected, we must disconnect the
    // local interface and network.
    //
    if (*MediaStatus == NdisMediaStateDisconnected) {

        PCNP_NETWORK                      network = NULL;
        PCNP_INTERFACE                    interface = NULL;
        CN_IRQL                           nodeTableIrql;
        PLIST_ENTRY                       entry;

        CnAcquireLock(&CnpNodeTableLock, &nodeTableIrql);

        if (CnpLocalNode != NULL) {
            CnAcquireLockAtDpc(&(CnpLocalNode->Lock));
            CnReleaseLockFromDpc(&CnpNodeTableLock);
            CnpLocalNode->Irql = nodeTableIrql;

            network = CnpFindNetwork(NetworkId);

            if (network != NULL) {

                //
                // Only go through the disconnect if the network
                // is currently marked as locally connected.
                // It is possible that we have already received
                // and processed a WMI disconnect event.
                //
                if (!CnpIsNetworkLocalDisconn(network)) {

                    for (entry = CnpLocalNode->InterfaceList.Flink;
                         entry != &(CnpLocalNode->InterfaceList);
                         entry = entry->Flink
                        )
                    {
                        interface = CONTAINING_RECORD(
                                        entry,
                                        CNP_INTERFACE,
                                        NodeLinkage
                                        );

                        if (interface->Network == network) {

                            CnpDisconnectLocalInterface(
                                interface,
                                network
                                );

                            //
                            // Both node and network locks
                            // were released.
                            //

                            break;

                        } else {
                            interface = NULL;
                        }
                    }

                } else {

                    CnTrace(
                        CXPNP, CxQueryMediaStatusDisconnectRedundant,
                        "[CXPNP] Network ID %u is already disconnected; "
                        "aborting disconnect.\n",
                        network->Id // LOGULONG
                        );
                }

                if (interface == NULL) {
                    CnReleaseLock(&(network->Lock), network->Irql);
                }
            }

            if (interface == NULL) {
                CnReleaseLock(&(CnpLocalNode->Lock), CnpLocalNode->Irql);
            }
        } else {
            CnReleaseLock(&CnpNodeTableLock, nodeTableIrql);
        }
    }
    
    //
    // Release resource
    //
    if (acquired) {
        CnReleaseResourceForThread(
            CnpWmiNdisMediaStatusResource,
            (ERESOURCE_THREAD) PsGetCurrentThread()
            );
    }
    
    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return;

}  // CxQueryMediaStatus


//
// Local Routines
//
NTSTATUS
CnpWmiPnpDisableMediaSenseCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
{
    //
    // Irp is always freed by our disable routine to prevent a race
    // condition where we don't know if we have called IoCancelIrp
    // yet or not.
    //
    KeSetEvent(CnpIpDisableMediaSenseEvent, IO_NO_INCREMENT, FALSE);

    return(STATUS_MORE_PROCESSING_REQUIRED);

}  // CnpWmiPnpDisableMediaSenseCompletion


VOID
CnpWmiPnpUpdateCurrentInterface(
    IN  PCNP_INTERFACE   UpdateInterface
    )
/*++

Routine Description:

    Updates the CurrentInterface for interfaces after the local
    interface is connected or disconnected. Called in response 
    to WMI NDIS media status events.

Arguments:

    Interface - A pointer to the interface on which to operate.

Return Value:

    None.

Notes:

    Called with associated node and network locks held.
    Returns with network lock released.

    Conforms to calling convention for PCNP_INTERFACE_UPDATE_ROUTINE.

--*/
{
    PCNP_NODE node = UpdateInterface->Node;

    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK | CNP_NETWORK_OBJECT_LOCK),   // Required
        0,                                                  // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX                         // Maximum
        );

    //
    // We don't really need the network lock.  It's just part of
    // the calling convention.
    //
    CnReleaseLockFromDpc(&(UpdateInterface->Network->Lock));

    CnpUpdateNodeCurrentInterface(node);

    if ( (node->CurrentInterface == NULL)
         ||
         ( node->CurrentInterface->State <
           ClusnetInterfaceStateOnlinePending
         )
       )
    {
        //
        // This node is now unreachable.
        //
        CnpDeclareNodeUnreachable(node);
    }
    
    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK),   // Required
        0,                        // Forbidden
        CNP_NODE_OBJECT_LOCK_MAX  // Maximum
        );

    return;

}  // CnpWmiPnpUpdateCurrentInterface


VOID
CnpReconnectLocalInterface(
    PCNP_INTERFACE Interface,
    PCNP_NETWORK   Network
    )
/*++

Routine Description:

    Changes a local interface from being disconnected to
    connected. Called in response to a WMI NDIS media status
    connect event or a heartbeat received on a disconnected
    interface.
   
Arguments:

    Interface - local interface that is reconnected
    
    Network - network associated with Interface
    
Return value:

    None
    
Notes:

    Called with CnpWmiNdisMediaStatusResource, local node lock,
    and Network lock held.
    
    Returns with CnpWmiNdisMediaStatusResource held but neither
    lock held.
    
--*/    
{
    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK | CNP_NETWORK_OBJECT_LOCK),   // Required
        0,                                                  // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX                         // Maximum
        );

    CnTrace(
        CXPNP, CnpReconnectLocalInterface,
        "[CXPNP] Reconnecting local interface for "
        "network ID %u.\n",
        Network->Id // LOGULONG
        );

    //
    // Clear the local disconnect flag in the network
    // object
    //
    Network->Flags &= ~CNP_NET_FLAG_LOCALDISCONN;

    //
    // Reference the network so it can't go away while we
    // reprioritize the associated interfaces.
    //
    CnpReferenceNetwork(Network);

    //
    // Bring the interface online. This call releases the
    // network lock.
    //
    CnpOnlineInterface(Interface);

    //
    // Release the node lock before walking the interfaces
    // on the network.
    //
    CnReleaseLock(&(CnpLocalNode->Lock), CnpLocalNode->Irql);

    //
    // Update the CurrentInterface for the other
    // nodes in the cluster to reflect the connected
    // status of the local interface.
    //
    CnpWalkInterfacesOnNetwork(
        Network, 
        CnpWmiPnpUpdateCurrentInterface
        );

    //
    // Issue InterfaceUp event to the cluster
    // service.
    //
    CnTrace(
        CXPNP, CxWmiNdisReconnectIssueEvent,
        "[CXPNP] Issuing InterfaceUp event "
        "for node %u on net %u, previous I/F state = %!ifstate!.",
        Interface->Node->Id, // LOGULONG
        Interface->Network->Id, // LOGULONG
        Interface->State // LOGIfState
        );

    CnIssueEvent(
        ClusnetEventNetInterfaceUp,
        Interface->Node->Id,
        Interface->Network->Id
        );

    //
    // Release the reference on the network object.
    //
    CnAcquireLock(&(Network->Lock), &(Network->Irql));

    CnpDereferenceNetwork(Network);

    return;

}  // CnpReconnectLocalInterface


VOID
CnpReconnectLocalInterfaceWrapper(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    )
{
    PCNP_WMI_RECONNECT_WORKER_CONTEXT context = Context;
    PCNP_NETWORK                      network = NULL;
    PCNP_INTERFACE                    interface = NULL;
    CN_IRQL                           nodeTableIrql;
    BOOLEAN                           acquired = FALSE;
    PLIST_ENTRY                       entry;

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    acquired = CnAcquireResourceExclusive(
                   CnpWmiNdisMediaStatusResource,
                   TRUE
                   );
    
    CnAssert(acquired == TRUE);

    CnAcquireLock(&CnpNodeTableLock, &nodeTableIrql);

    if (CnpLocalNode != NULL) {
        CnAcquireLockAtDpc(&(CnpLocalNode->Lock));
        CnReleaseLockFromDpc(&CnpNodeTableLock);
        CnpLocalNode->Irql = nodeTableIrql;

        network = CnpFindNetwork(context->NetworkId);
    
        if (network != NULL) {

            //
            // Only go through the reconnect if the network
            // is currently marked as locally disconnected.
            // It is possible that we have already received
            // and processed a WMI connect event.
            //
            if (CnpIsNetworkLocalDisconn(network)) {

                for (entry = CnpLocalNode->InterfaceList.Flink;
                     entry != &(CnpLocalNode->InterfaceList);
                     entry = entry->Flink
                    )
                {
                    interface = CONTAINING_RECORD(
                                    entry,
                                    CNP_INTERFACE,
                                    NodeLinkage
                                    );

                    if (interface->Network == network) {

                        CnpReconnectLocalInterface(
                            interface,
                            network
                            );

                        //
                        // Both node and network locks
                        // were released.
                        //

                        break;

                    } else {
                        interface = NULL;
                    }
                }
            
            } else {

                CnTrace(
                    CXPNP, CnpReconnectLocalInterfaceWrapperRedundant,
                    "[CXPNP] Network ID %u is already connected; "
                    "aborting reconnect in wrapper.\n",
                    network->Id // LOGULONG
                    );
            }

            if (interface == NULL) {
                CnReleaseLock(&(network->Lock), network->Irql);
            }
        }

        if (interface == NULL) {
            CnReleaseLock(&(CnpLocalNode->Lock), CnpLocalNode->Irql);
        }
    } else {
        CnReleaseLock(&CnpNodeTableLock, nodeTableIrql);
    }
    
    //
    // Release resource
    //
    if (acquired) {
        CnReleaseResourceForThread(
            CnpWmiNdisMediaStatusResource,
            (ERESOURCE_THREAD) PsGetCurrentThread()
            );
    }
    
    //
    // Free the workitem and context
    //
    IoFreeWorkItem(context->WorkItem);
    CnFreePool(context);

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return;

}  // CnpReconnectLocalInterfaceWrapper


VOID
CnpDisconnectLocalInterface(
    PCNP_INTERFACE Interface,
    PCNP_NETWORK   Network
    )
/*++

Routine Description:

    Changes a local interface from being connected to
    disconnected. Called in response to a WMI NDIS media status
    disconnect event or an NDIS query that returns media 
    disconnected.
   
Arguments:

    Interface - local interface that is reconnected
    
    Network - network associated with Interface
    
Return value:

    None
    
Notes:

    Called with CnpWmiNdisMediaStatusResource, local node lock,
    and Network lock held.
    
    Returns with CnpWmiNdisMediaStatusResource held but neither
    lock held.
    
--*/    
{
    CnVerifyCpuLockMask(
        (CNP_NODE_OBJECT_LOCK | CNP_NETWORK_OBJECT_LOCK),   // Required
        0,                                                  // Forbidden
        CNP_NETWORK_OBJECT_LOCK_MAX                         // Maximum
        );

    CnTrace(
        CXPNP, CnpDisconnectLocalInterface,
        "[CXPNP] Interface for network ID %u "
        "disconnected.\n",
        Network->Id // LOGULONG
        );

    //
    // Set the local disconnect flag in the network
    // object
    //
    Network->Flags |= CNP_NET_FLAG_LOCALDISCONN;

    //
    // Reference the network so it can't go away while we
    // reprioritize the associated interfaces.
    //
    CnpReferenceNetwork(Network);

    //
    // Fail the interface. This call releases the
    // network lock.
    //
    CnpFailInterface(Interface);

    //
    // Release the node lock before walking the interfaces
    // on the network.
    //
    CnReleaseLock(&(CnpLocalNode->Lock), CnpLocalNode->Irql);

    //
    // Update the CurrentInterface for the other
    // nodes in the cluster to reflect the disconnected
    // status of the local interface.
    //
    CnpWalkInterfacesOnNetwork(
        Network, 
        CnpWmiPnpUpdateCurrentInterface
        );

    //
    // Issue InterfaceFailed event to the cluster
    // service.
    //
    CnTrace(
        CXPNP, CnpLocalDisconnectIssueEvent,
        "[CXPNP] Issuing InterfaceFailed event "
        "for node %u on net %u, previous I/F state = %!ifstate!.",
        Interface->Node->Id, // LOGULONG
        Interface->Network->Id, // LOGULONG
        Interface->State // LOGIfState
        );

    CnIssueEvent(
        ClusnetEventNetInterfaceFailed,
        Interface->Node->Id,
        Interface->Network->Id
        );

    //
    // Release the reference on the network object.
    //
    CnAcquireLock(&(Network->Lock), &(Network->Irql));

    CnpDereferenceNetwork(Network);

    return;

}  // CnpDisconnectLocalInterface


VOID
CnpWmiNdisMediaStatusConnectCallback(
    IN PVOID Wnode,
    IN PVOID Context
    )
{
    PWNODE_SINGLE_INSTANCE wnode = (PWNODE_SINGLE_INSTANCE) Wnode;
    PCNP_INTERFACE         interface;
    PCNP_NETWORK           network;
    PLIST_ENTRY            entry;
    CN_IRQL                nodeTableIrql;
    BOOLEAN                acquired = FALSE;

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT((
            "[CX] Received WMI NDIS status media connect event.\n"
            ));
    }

    //
    // Serialize events as much as possible, since clusnet spinlocks
    // may be acquired and released repeatedly. 
    //
    // Note that there may not be any guarantees that WMI event
    // ordering is guaranteed. The fallback mechanism for clusnet
    // is heartbeats -- if a heartbeat is received on an interface,
    // we know the interface is connected.
    //
    acquired = CnAcquireResourceExclusive(
                   CnpWmiNdisMediaStatusResource,
                   TRUE
                   );

    CnAssert(acquired == TRUE);

    //
    // Figure out if this callback is for one of this node's
    // registered interfaces by comparing the WMI provider ID
    // in the WNODE header to the WMI provider IDs of this
    // node's adapters.
    //
    CnAcquireLock(&CnpNodeTableLock, &nodeTableIrql);

    if (CnpLocalNode != NULL) {
        CnAcquireLockAtDpc(&(CnpLocalNode->Lock));
        CnReleaseLockFromDpc(&CnpNodeTableLock);
        CnpLocalNode->Irql = nodeTableIrql;

        network = NULL;

        for (entry = CnpLocalNode->InterfaceList.Flink;
             entry != &(CnpLocalNode->InterfaceList);
             entry = entry->Flink
            )
        {
            interface = CONTAINING_RECORD(
                            entry,
                            CNP_INTERFACE,
                            NodeLinkage
                            );

            if (wnode->WnodeHeader.ProviderId
                == interface->AdapterWMIProviderId) {
                
                //
                // Found the local interface corresponding to this
                // address.
                //
                network = interface->Network;

                //
                // Start by checking if we believe the network is
                // currently disconnected.
                //
                CnAcquireLockAtDpc(&(network->Lock));
                network->Irql = DISPATCH_LEVEL;

                if (CnpIsNetworkLocalDisconn(network)) {

                    CnTrace(
                        CXPNP, CxWmiNdisConnectNet,
                        "[CXPNP] Interface for network ID %u "
                        "connected.\n",
                        network->Id // LOGULONG
                        );

                    CnpReconnectLocalInterface(interface, network);
                    
                    //
                    // Node and network locks were released
                    //

                } else {

                    CnTrace(
                        CXPNP, CxWmiNdisConnectNetRedundant,
                        "[CXPNP] Ignoring redundant WMI NDIS connect "
                        "event for interface for network ID %u.\n",
                        network->Id // LOGULONG
                        );
                    
                    CnReleaseLockFromDpc(&(network->Lock));
                    CnReleaseLock(&(CnpLocalNode->Lock), CnpLocalNode->Irql);
                }
                
                break;
            }
        }

        if (network == NULL) {
            CnReleaseLock(&(CnpLocalNode->Lock), CnpLocalNode->Irql);
        }
    }
    else {
        CnReleaseLock(&CnpNodeTableLock, nodeTableIrql);
    }

    IF_CNDBG(CN_DEBUG_CONFIG) {
        if (network != NULL) {
            CNPRINT((
                "[CX] Interface for network ID %u connected.\n",
                network->Id
                ));
        } else {
            CNPRINT((
                "[CX] Unknown interface connected, provider id %lx\n",
                wnode->WnodeHeader.ProviderId
                ));
        }
    }

    //
    // Release resource
    //
    if (acquired) {
        CnReleaseResourceForThread(
            CnpWmiNdisMediaStatusResource,
            (ERESOURCE_THREAD) PsGetCurrentThread()
            );
    }
    
    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return;

} // CnpWmiNdisMediaStatusConnectCallback


VOID
CnpWmiNdisMediaStatusDisconnectCallback(
    IN PVOID Wnode,
    IN PVOID Context
    )
{
    PWNODE_SINGLE_INSTANCE wnode = (PWNODE_SINGLE_INSTANCE) Wnode;
    PCNP_INTERFACE         interface;
    PCNP_NETWORK           network;
    PLIST_ENTRY            entry;
    CN_IRQL                nodeTableIrql;
    BOOLEAN                acquired = FALSE;

    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    IF_CNDBG(CN_DEBUG_CONFIG) {
        CNPRINT((
            "[CX] Received WMI NDIS status media disconnect event.\n"
            ));
    }

    CnTrace(CXPNP, CxWmiNdisDisconnect,
        "[CXPNP] Received WMI NDIS status media disconnect event.\n"
        );

    //
    // Serialize events as much as possible, since clusnet spinlocks
    // may be acquired and released repeatedly. 
    //
    // Note that there may not be any guarantees that WMI event
    // ordering is guaranteed. The fallback mechanism for clusnet
    // is heartbeats -- if a heartbeat is received on an interface,
    // we know the interface is connected.
    //
    acquired = CnAcquireResourceExclusive(
                   CnpWmiNdisMediaStatusResource,
                   TRUE
                   );

    CnAssert(acquired == TRUE);

    //
    // Figure out if this callback is for one of this node's
    // registered interfaces by comparing the WMI provider ID
    // in the WNODE header to the WMI provider IDs of this
    // node's adapters.
    //
    CnAcquireLock(&CnpNodeTableLock, &nodeTableIrql);

    if (CnpLocalNode != NULL) {
        CnAcquireLockAtDpc(&(CnpLocalNode->Lock));
        CnReleaseLockFromDpc(&CnpNodeTableLock);
        CnpLocalNode->Irql = nodeTableIrql;

        network = NULL;

        for (entry = CnpLocalNode->InterfaceList.Flink;
             entry != &(CnpLocalNode->InterfaceList);
             entry = entry->Flink
            )
        {
            interface = CONTAINING_RECORD(
                            entry,
                            CNP_INTERFACE,
                            NodeLinkage
                            );

            if (wnode->WnodeHeader.ProviderId
                == interface->AdapterWMIProviderId) {
                
                //
                // Found the local interface object corresponding
                // to this adapter.
                //
                network = interface->Network;

                CnAcquireLockAtDpc(&(network->Lock));
                network->Irql = DISPATCH_LEVEL;

                CnpDisconnectLocalInterface(interface, network);

                break;
            }
        }

        if (network == NULL) {
            CnReleaseLock(&(CnpLocalNode->Lock), CnpLocalNode->Irql);
        }
    }
    else {
        CnReleaseLock(&CnpNodeTableLock, nodeTableIrql);
    }

    IF_CNDBG(CN_DEBUG_CONFIG) {
        if (network != NULL) {
            CNPRINT((
                "[CX] Interface for network ID %u disconnected.\n",
                network->Id
                ));
        } else {
            CNPRINT((
                "[CX] Unknown interface disconnected, provider id %lx\n",
                wnode->WnodeHeader.ProviderId
                ));
        }
    }

    //
    // Release resource
    //
    if (acquired) {
        CnReleaseResourceForThread(
            CnpWmiNdisMediaStatusResource,
            (ERESOURCE_THREAD) PsGetCurrentThread()
            );
    }
    
    CnVerifyCpuLockMask(
        0,                  // Required
        0xFFFFFFFF,         // Forbidden
        0                   // Maximum
        );

    return;

} // CnpWmiNdisMediaStatusDisconnectCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\clusrtlp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    clusrtlp.h

Abstract:

    Private header file for the NT Cluster RTL library

Author:

    John Vert (jvert) 1-Dec-1995

Revision History:

--*/
#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "cluster.h"
#include "stdio.h"
#include "stdlib.h"

extern HANDLE LocalEventLog;
#define LOG_CURRENT_MODULE LOG_MODULE_CLRTL

// Adding watchdog struct definitions.....
typedef struct _WATCHDOGPAR{
    HANDLE wTimer;
    LPWSTR par;
    DWORD threadId;
} WATCHDOGPAR, *PWATCHDOGPAR;

VOID
ClRtlpFlushLogBuffers(
    VOID
    );

ULONG
WppAutoStart(
    IN LPCWSTR ProductName
    );
    
VOID
ClRtlPrintf(
    PCHAR FormatString,
    ...
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\cleanup.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      Cleanup.cpp
//
//  Abstract:
//      Implementation of the functions related to cleaning up a node that has
//      been evicted.
//
//  Author:
//      Vijayendra Vasu (vvasu) 17-AUG-2000
//
//  Revision History:
//      None.
//
/////////////////////////////////////////////////////////////////////////////

#define UNICODE 1
#define _UNICODE 1


/////////////////////////////////////////////////////////////////////////////
// Include files
/////////////////////////////////////////////////////////////////////////////
#include "clusrtlp.h"

#include <objbase.h>
#include <ClusCfgGuids.h>
#include <ClusCfgServer.h>
#include <ClusCfgClient.h>
#include <clusrtl.h>
#include <clusudef.h>


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ClRtlCleanupNode()
//
//  Routine Description:
//      Cleanup a node that has been evicted. This method tries to instantiate
//      the cleanup COM component locally (even if a remote node is being cleaned up)
//      and will therefore not work if called from computer which do not have this
//      component registered.
//
//  Arguments:
//      const WCHAR * pcszEvictedNodeNameIn
//          Name of the node on which cleanup is to be initiated. If this is NULL
//          the local node is cleaned up.
//
//      DWORD dwDelayIn
//          Number of milliseconds that will elapse before cleanup is started
//          on the target node. If some other process cleans up the target node while
//          delay is in progress, the delay is terminated. If this value is zero,
//          the node is cleaned up immediately.
//
//      DWORD dwTimeoutIn
//          Number of milliseconds that this method will wait for cleanup to complete.
//          This timeout is independent of the delay above, so if dwDelayIn is greater
//          than dwTimeoutIn, this method will most probably timeout. Once initiated,
//          however, cleanup will run to completion - this method just may not wait for it
//          to complete.
//
//  Return Value:
//      S_OK
//          If the cleanup operations were successful
//
//      RPC_S_CALLPENDING
//          If cleanup is not complete in dwTimeoutIn milliseconds
//
//      Other HRESULTS
//          In case of error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT ClRtlCleanupNode(
      const WCHAR * pcszEvictedNodeNameIn
    , DWORD dwDelayIn
    , DWORD dwTimeoutIn
    )
{
    HRESULT                     hr = S_OK;
    HRESULT                     hrInit;
    IClusCfgEvictCleanup *      pcceEvict = NULL;
    ICallFactory *              pcfCallFactory = NULL;
    ISynchronize *              psSync = NULL;
    AsyncIClusCfgEvictCleanup * paicceAsyncEvict = NULL;


    //
    //  Initialize COM - make sure it really init'ed or that we're just trying
    //  to change modes on the calling thread.  Attempting to change to mode
    //  is not reason to fail this function.
    //
    hrInit = CoInitializeEx( NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE );
    if ( ( hrInit != S_OK ) && ( hrInit != S_FALSE ) && ( hrInit != RPC_E_CHANGED_MODE ) )
    {
        hr = hrInit;
        goto Exit;
    } // if:

    hr = CoCreateInstance(
              CLSID_ClusCfgEvictCleanup
            , NULL
            , CLSCTX_LOCAL_SERVER
            , __uuidof( pcceEvict )
            , reinterpret_cast< void ** >( &pcceEvict )
            );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get a pointer to synchronous evict interface

    hr = pcceEvict->QueryInterface( __uuidof( pcfCallFactory ), reinterpret_cast< void ** >( &pcfCallFactory ) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get a pointer to the call factory interface

    hr = pcfCallFactory->CreateCall(
          __uuidof( paicceAsyncEvict )
        , NULL
        , __uuidof( paicceAsyncEvict )
        , reinterpret_cast< IUnknown ** >( &paicceAsyncEvict )
        );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get a pointer to the asynchronous evict interface

    hr = paicceAsyncEvict->QueryInterface< ISynchronize >( &psSync );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not get a pointer to the synchronization interface

    // Initiate cleanup
    if ( pcszEvictedNodeNameIn != NULL )
    {
        hr = paicceAsyncEvict->Begin_CleanupRemoteNode( pcszEvictedNodeNameIn, dwDelayIn );
    } // if: we are cleaning up a remote node
    else
    {
        hr = paicceAsyncEvict->Begin_CleanupLocalNode( dwDelayIn );
    } // else: we are cleaning up the local node

    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not initiate cleanup

    // Wait for specified time.
    hr = psSync->Wait( 0, dwTimeoutIn );
    if ( FAILED( hr ) || ( hr == RPC_S_CALLPENDING ) )
    {
        goto Cleanup;
    } // if: we could not wait till cleanup completed

    // Finish cleanup
    if ( pcszEvictedNodeNameIn != NULL )
    {
        hr = paicceAsyncEvict->Finish_CleanupRemoteNode();
    } // if: we are cleaning up a remote node
    else
    {
        hr = paicceAsyncEvict->Finish_CleanupLocalNode();
    } // else: we are cleaning up the local node

Cleanup:

    //
    // Free acquired resources
    //

    if ( pcceEvict != NULL )
    {
        pcceEvict->Release();
    } // if: we had obtained a pointer to the synchronous evict interface

    if ( pcfCallFactory != NULL )
    {
        pcfCallFactory->Release();
    } // if: we had obtained a pointer to the call factory interface

    if ( psSync != NULL )
    {
        psSync->Release();
    } // if: we had obtained a pointer to the synchronization interface

    if ( paicceAsyncEvict != NULL )
    {
        paicceAsyncEvict->Release();
    } // if: we had obtained a pointer to the asynchronous evict interface

    //
    //  Did the call to CoInitializeEx() above succeed?  If it did then
    //  we need to call CoUnitialize().  Mode changed means we don't need
    //  to call CoUnitialize().
    //
    if ( hrInit != RPC_E_CHANGED_MODE  )
    {
        CoUninitialize();
    } // if:

Exit:

    return hr;

} //*** ClRtlCleanupNode()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ClRtlAsyncCleanupNode()
//
//  Routine Description:
//      Cleanup a node that has been evicted. This method does not initiate
//      any COM component on the machine on which this call is made and therefore,
//      does not require the cleanup COM component to be registered on the local
//      machine.
//
//  Arguments:
//      const WCHAR * pcszEvictedNodeNameIn
//          Name of the node on which cleanup is to be initiated. If this is NULL
//          the local node is cleaned up.
//
//      DWORD dwDelayIn
//          Number of milliseconds that will elapse before cleanup is started
//          on the target node. If some other process cleans up the target node while
//          delay is in progress, the delay is terminated. If this value is zero,
//          the node is cleaned up immediately.
//
//      DWORD dwTimeoutIn
//          Number of milliseconds that this method will wait for cleanup to complete.
//          This timeout is independent of the delay above, so if dwDelayIn is greater
//          than dwTimeoutIn, this method will most probably timeout. Once initiated,
//          however, cleanup will run to completion - this method just may not wait for it
//          to complete.
//
//  Return Value:
//      S_OK
//          If the cleanup operations were successful
//
//      RPC_S_CALLPENDING
//          If cleanup is not complete in dwTimeoutIn milliseconds
//
//      Other HRESULTS
//          In case of error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT ClRtlAsyncCleanupNode(
      const WCHAR * pcszEvictedNodeNameIn
    , DWORD         dwDelayIn
    , DWORD         dwTimeoutIn
    )
{
    HRESULT     hr = S_OK;
    HRESULT     hrInit = S_OK;
    IDispatch * pDisp = NULL;

    //
    //  Initialize COM - make sure it really init'ed or that we're just trying
    //  to change modes on the calling thread.  Attempting to change to mode
    //  is not reason to fail this function.
    //
    hrInit = CoInitializeEx( NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE );
    if ( ( hrInit != S_OK ) && ( hrInit != S_FALSE ) && ( hrInit != RPC_E_CHANGED_MODE ) )
    {
        hr = hrInit;
        goto Exit;
    } // if:

    MULTI_QI mqiInterfaces[] =
    {
        { &IID_IDispatch, NULL, S_OK },
    };

    COSERVERINFO    csiServerInfo;
    COSERVERINFO *  pcsiServerInfoPtr = &csiServerInfo;

    if ( pcszEvictedNodeNameIn == NULL )
    {
        pcsiServerInfoPtr = NULL;
    } // if: we have to cleanup the local node
    else
    {
        csiServerInfo.dwReserved1 = 0;
        csiServerInfo.pwszName = const_cast< LPWSTR >( pcszEvictedNodeNameIn );
        csiServerInfo.pAuthInfo = NULL;
        csiServerInfo.dwReserved2 = 0;
    } // else: we have to clean up a remote node

    //
    //  Instantiate this component on the evicted node.
    //
    hr = CoCreateInstanceEx(
              CLSID_ClusCfgAsyncEvictCleanup
            , NULL
            , CLSCTX_LOCAL_SERVER
            , pcsiServerInfoPtr
            , sizeof( mqiInterfaces ) / sizeof( mqiInterfaces[0] )
            , mqiInterfaces
            );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    } // if: we could not instantiate the evict processing component

    pDisp = reinterpret_cast< IDispatch * >( mqiInterfaces[ 0 ].pItf );

    {
        OLECHAR *   pszMethodName = L"CleanupNode";
        DISPID      dispidCleanupNode;
        VARIANT     vResult;

        VARIANTARG  rgvaCleanupNodeArgs[ 3 ];

        DISPPARAMS  dpCleanupNodeParams = {
                          rgvaCleanupNodeArgs
                        , NULL
                        , sizeof( rgvaCleanupNodeArgs ) / sizeof( rgvaCleanupNodeArgs[ 0 ] )
                        , 0
                        };

        // Get the dispatch id of the CleanupNode() method.
        hr = pDisp->GetIDsOfNames( IID_NULL, &pszMethodName, 1, LOCALE_SYSTEM_DEFAULT, &dispidCleanupNode );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if: we could not get the dispid of the CleanupNode() method

        //
        // Initialize the arguments. Note, the parameters are stored in the reverse order in the array.
        //

        // Initialize the return value.
        VariantInit( &vResult );

        // The first parameter is the name of the node.
        VariantInit( &rgvaCleanupNodeArgs[ 2 ] );
        rgvaCleanupNodeArgs[ 2 ].vt = VT_BSTR;
        rgvaCleanupNodeArgs[ 2 ].bstrVal = NULL;

        // The second parameter is the delay.
        VariantInit( &rgvaCleanupNodeArgs[ 1 ] );
        rgvaCleanupNodeArgs[ 1 ].vt = VT_UI4;
        rgvaCleanupNodeArgs[ 1 ].ulVal = dwDelayIn;

        // The third parameter is the timeout.
        VariantInit( &rgvaCleanupNodeArgs[ 0 ] );
        rgvaCleanupNodeArgs[ 0 ].vt = VT_UI4;
        rgvaCleanupNodeArgs[ 0 ].ulVal = dwTimeoutIn;

        //
        //  Invoke the CleanupNode() method.
        //
        hr = pDisp->Invoke(
              dispidCleanupNode
            , IID_NULL
            , LOCALE_SYSTEM_DEFAULT
            , DISPATCH_METHOD
            , &dpCleanupNodeParams
            , &vResult
            , NULL
            , NULL
            );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if: we could not invoke the CleanupNode() method

        hr = vResult.scode;
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        } // if: CleanupNode() failed
    } // block:

Cleanup:

    //
    // Free acquired resources
    //

    if ( pDisp != NULL )
    {
        pDisp->Release();
    } // if: we had obtained a pointer to the IDispatch interface

    //
    //  Did the call to CoInitializeEx() above succeed?  If it did then
    //  we need to call CoUnitialize().  Mode changed means we don't need
    //  to call CoUnitialize().
    //
    if ( hrInit != RPC_E_CHANGED_MODE  )
    {
        CoUninitialize();
    } // if:

Exit:

    return hr;

} //*** ClRtlAsyncCleanupNode()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ClRtlHasNodeBeenEvicted()
//
//  Routine Description:
//      Finds out if a registry value indicating that this node has been
//      evicted, is set or not
//
//  Arguments:
//      BOOL *  pfNodeEvictedOut
//          Pointer to the boolean variable that will be set to TRUE if
//          the node has been evicted, but not cleaned up and FALSE
//          otherwise
//
//  Return Value:
//      ERROR_SUCCESS
//          If the eviction state could be successfully determined.
//
//      Other Win32 error codes
//          In case of error
//
//--
/////////////////////////////////////////////////////////////////////////////
DWORD ClRtlHasNodeBeenEvicted( BOOL *  pfNodeEvictedOut )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY  hNodeStateKey = NULL;

    do
    {
        DWORD   dwEvictState = 0;
        DWORD   dwType;
        DWORD   dwSize;

        // Validate parameter
        if ( pfNodeEvictedOut == NULL )
        {
            dwError = ERROR_INVALID_PARAMETER;
            break;
        } // if: the output parameter is invalid

        // Initialize output.
        *pfNodeEvictedOut = FALSE;

        // Open a registry key that holds a value indicating that this node has been evicted.
        dwError = RegOpenKeyEx(
              HKEY_LOCAL_MACHINE
            , CLUSREG_KEYNAME_NODE_DATA
            , 0
            , KEY_ALL_ACCESS
            , &hNodeStateKey
            );

        if ( dwError != ERROR_SUCCESS )
        {
            break;
        } // if: RegOpenKeyEx() has failed

        // Read the required registry value
        dwSize = sizeof( dwEvictState );
        dwError = RegQueryValueEx(
              hNodeStateKey
            , CLUSREG_NAME_EVICTION_STATE
            , 0
            , &dwType
            , reinterpret_cast< BYTE * >( &dwEvictState )
            , &dwSize
            );

        if ( dwError == ERROR_FILE_NOT_FOUND )
        {
            // This is ok - absence of the value indicates that this node has not been evicted.
            dwEvictState = 0;
            dwError = ERROR_SUCCESS;
        } // if: RegQueryValueEx did not find the value
        else if ( dwError != ERROR_SUCCESS )
        {
            break;
        } // else if: RegQueryValueEx() has failed

        *pfNodeEvictedOut = ( dwEvictState == 0 ) ? FALSE : TRUE;
    }
    while( false ); // dummy do-while loop to avoid gotos

    //
    // Free acquired resources
    //

    if ( hNodeStateKey != NULL )
    {
        RegCloseKey( hNodeStateKey );
    } // if: we had opened the node state registry key

    return dwError;
} //*** ClRtlHasNodeBeenEvicted()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\clusrtl.c ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    clusrtl.c

Abstract:

    Provides run-time library support common to any module
    of the NT Cluster.

Author:

    John Vert (jvert) 1-Dec-1995

Revision History:

--*/
#include "clusrtlp.h"
#include "stdarg.h"
#include "stdlib.h"
#include "clusverp.h"
#include "windns.h"
#include "security.h"
#include "secext.h"

#define WMI_TRACING 1
#define RPC_WMI_TRACING 1

#if defined(WMI_TRACING)

// 789aa2d3-e298-4d8b-a3a3-a8a0ec9c7702 -- Rpc
// b1599392-1a0f-11d3-ba86-00c04f8eed00 -- ClusSvc

#define WPP_CONTROL_GUIDS \
    WPP_DEFINE_CONTROL_GUID(ClusRtl,(b1599392,1a0f,11d3,ba86,00c04f8eed00), \
      WPP_DEFINE_BIT(Error)      \
      WPP_DEFINE_BIT(Unusual)    \
      WPP_DEFINE_BIT(Noise)      \
   )        \
   WPP_DEFINE_CONTROL_GUID(ClusRpc,(789aa2d3,e298,4d8b,a3a3,a8a0ec9c7702), \
      WPP_DEFINE_BIT(RpcTrace)   \
   )
    
//#define WppDebug(x,y) ClRtlPrintf y
#include "clusrtl.tmh"   

#define REG_TRACE_CLUSTERING        L"Clustering Service"


#endif // defined(WMI_TRACING)

//
// Local Macros
//

//
// SC Manager failure action parameters. set STARTUP_FAILURE_RESTART to one
// before shipping to get the normal backoff behavior.
//

#if STARTUP_FAILURE_RESTART
#define CLUSTER_FAILURE_RETRY_COUNT             -1  // forever
#else
#define CLUSTER_FAILURE_RETRY_COUNT             0
#endif

#define CLUSTER_FAILURE_MAX_STARTUP_RETRIES             30
#define CLUSTER_FAILURE_INITIAL_RETRY_INTERVAL          60 * 1000           // 60 secs
#define CLUSTER_FAILURE_FINAL_RETRY_INTERVAL            ( 60 * 1000 * 16)   // 16 mins

#define ClRtlAcquirePrintLock() \
        WaitForSingleObject( ClRtlPrintFileMutex, INFINITE );

#define ClRtlReleasePrintLock() \
        ReleaseMutex( ClRtlPrintFileMutex );

#define LOGFILE_NAME L"Cluster.log"
#define LOGENTRY_BUFFER_SIZE 512


//
// Private Data
//
BOOL                ClRtlpDbgOutputToConsole = FALSE;
BOOL                ClRtlpInitialized = FALSE;
BOOL                ClRtlPrintToFile = FALSE;
HANDLE              ClRtlPrintFile = NULL;
HANDLE              ClRtlPrintFileMutex = NULL;
DWORD               ClRtlProcessId;
PDWORD              ClRtlDbgLogLevel;
HANDLE				ClRtlWatchdogTimerQueue = NULL;

#define MAX_NUMBER_LENGTH 20

// Specify maximum file size ( DWORD / 1MB )

#define MAX_FILE_SIZE ( 0xFFFFF000 / ( 1024 * 1024 ) )

DWORD               ClRtlPrintFileLimit = ( 8 * 1024 * 1024 ); // 8 MB default
DWORD               ClRtlPrintFileLoWater = 0;

//
// Public Routines
//


// !!!!NOTE!!!!
// This initialization routine is call from DllMain(), do not add anyting out here that requires synchronization. Do not add any win32 api calls here.
//

DWORD
ClRtlInitialize(
    IN  BOOL    DbgOutputToConsole,
    IN  PDWORD  DbgLogLevel
    )
{
    WCHAR logFileBuffer[MAX_PATH];
    LPWSTR logFileName = NULL;
    DWORD Status = ERROR_SUCCESS;
    DWORD defaultLogSize = 8;
    HKEY  ClusterKey;
    WCHAR modulePath[MAX_PATH];
    DWORD envLength;
    WCHAR logFileSize[MAX_NUMBER_LENGTH];
    DWORD logSize;
    UNICODE_STRING logFileString;
    LPWSTR lpszBakFileName = NULL;
    DWORD   fileSizeHigh = 0;
    DWORD   fileSizeLow;

    //
    // init event stuff so we have a means for logging other failures
    //
    ClRtlEventLogInit();

    if (!ClRtlpInitialized) {
        ClRtlpDbgOutputToConsole = DbgOutputToConsole;
        ClRtlpInitialized = TRUE;
        ClRtlDbgLogLevel = DbgLogLevel;

		
        envLength = GetEnvironmentVariable(L"ClusterLog",
                                            logFileBuffer,
                                            sizeof(logFileBuffer)/sizeof(WCHAR));
        if ( envLength > sizeof(logFileBuffer)/sizeof(WCHAR) ) {
            logFileName = LocalAlloc( LMEM_FIXED,
                                      envLength * sizeof( WCHAR ) );
            if ( logFileName == NULL ) {
                return GetLastError();
            }

            envLength = GetEnvironmentVariable(L"ClusterLog",
                                                logFileName,
                                                envLength);
            if ( envLength == 0 ) {
                LocalFree( logFileName );
                logFileName = NULL;
            }
        } else if ( envLength != 0 ) {
            logFileName = logFileBuffer;
        }

#if CLUSTER_BETA

        //
        // always turn on logging when in beta mode
        //
        if ( ( logFileName != NULL ) && ( *logFileName == UNICODE_NULL ) ) {
            WCHAR *p;

            if ( GetModuleFileName(NULL,
                                   modulePath,
                                   MAX_PATH - sizeof(LOGFILE_NAME)/sizeof(WCHAR) ) ) {
                p = wcsrchr( modulePath, '\\' );
                if ( p != UNICODE_NULL ) {
                    p++;
                    *p = UNICODE_NULL;
                    wcscat( modulePath, LOGFILE_NAME );
                    logFileName = modulePath;
                }
            }
        }
#endif

        if ( logFileName != NULL ) {
            //
            // Try to get a limit on the log file size.
            // This number is the number of MB.
            //
            envLength = GetEnvironmentVariable(L"ClusterLogSize",
                                                logFileSize,
                                                sizeof(logFileSize)/sizeof(WCHAR));
            if ( (envLength != 0) &&
                 (envLength < MAX_NUMBER_LENGTH) ) {
                RtlInitUnicodeString( &logFileString, logFileSize );
                Status = RtlUnicodeStringToInteger( &logFileString,
                                                    10,
                                                    &logSize );
                if ( NT_SUCCESS( Status ) ) {
                    ClRtlPrintFileLimit = logSize;
                }
            } else {
                ClRtlPrintFileLimit = defaultLogSize;
            }

            Status = ERROR_SUCCESS;

            if ( ClRtlPrintFileLimit == 0 ) {
                goto exit;
            }

            if ( ClRtlPrintFileLimit > MAX_FILE_SIZE ) {
                ClRtlPrintFileLimit = MAX_FILE_SIZE;
            }
            ClRtlPrintFileLimit = ClRtlPrintFileLimit * ( 1024 * 1024 );

            ClRtlPrintFileMutex = CreateMutex( NULL,
                                               FALSE,
                                               L"ClusterRtlPrintFileMutex" );
            if ( ClRtlPrintFileMutex != NULL ) {
                BOOL createdDirectory = FALSE;
                //
                //  Chittur Subbaraman (chitturs) - 11/11/98
                //
                //  Check whether the ClusterLogOverwrite environment var is
                //  defined.
                //
                envLength = GetEnvironmentVariable( L"ClusterLogOverwrite",
                                                    NULL,
                                                    0 );
                if ( envLength != 0 )
                {
                    HANDLE  hLogFile = INVALID_HANDLE_VALUE;
                    //
                    //  Check whether someone else has an open handle to
                    //  the log file.  If so, don't attempt anything.
                    //
                    hLogFile = CreateFile( logFileName,
                                           GENERIC_READ | GENERIC_WRITE,
                                           0, // Exclusive file share mode
                                           NULL,
                                           OPEN_EXISTING,
                                           0,
                                           NULL );
                    if ( hLogFile != INVALID_HANDLE_VALUE )
                    {
                        CloseHandle( hLogFile );

                        lpszBakFileName = LocalAlloc( LMEM_FIXED,
                                                  ( 5 + lstrlenW( logFileName ) ) *
                                                  sizeof( WCHAR ) );
                        if ( lpszBakFileName == NULL )
                        {
                            Status = GetLastError();
                            ClRtlDbgPrint(LOG_CRITICAL,
                                          "[ClRtl] Mem alloc for .bak file name failed. Error %1!u!\n",
                                          Status);
                            goto exit;
                        }

                        //
                        //  Append ".bak" to the log file name
                        //
                        lstrcpyW( lpszBakFileName, logFileName );
                        lstrcatW( lpszBakFileName, L".bak" );

                        //
                        //  Copy the log file (if it exists) to a bak file
                        //  and then delete the log file
                        //
                        if ( CopyFileW( logFileName, lpszBakFileName, FALSE ) )
                        {
                            if ( !DeleteFileW( logFileName ) )
                            {
                                //
                                //  There is no reason for this to happen since the
                                //  log file should be deletable.
                                //
                                Status = GetLastError();
                                ClRtlDbgPrint(LOG_CRITICAL,
                                              "[ClRtl] Error %1!u! in deleting cluster log file\n",
                                              Status);
                                goto exit;
                            }
                        }
                    }
                }

openFileRetry:
                ClRtlPrintFile = CreateFile(logFileName,
                                            GENERIC_READ | GENERIC_WRITE,
                                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                                            NULL,
                                            OPEN_ALWAYS,
                                            0,
                                            NULL );

                if ( ClRtlPrintFile == INVALID_HANDLE_VALUE ) {
                    Status = GetLastError();

                    if ( !createdDirectory && Status == ERROR_PATH_NOT_FOUND ) {
                        PWCHAR lastSlash = wcsrchr( logFileName, '\\' );
                        WCHAR  slashChar;

                        if ( lastSlash == NULL ) {
                            lastSlash = wcsrchr( logFileName, '/' );
                        }

                        if ( lastSlash != NULL ) {
                            slashChar = *lastSlash;
                            *lastSlash = UNICODE_NULL;
                            Status = ClRtlCreateDirectory( logFileName );

                            if ( Status == ERROR_SUCCESS ) {
                                createdDirectory = TRUE;
                                *lastSlash = slashChar;
                                goto openFileRetry;
                            }
                        }
                    }

                    ClRtlDbgPrint(LOG_CRITICAL,
                                  "[ClRtl] Open of log file failed. Error %1!u!\n",
                                  Status);
                    goto exit;
                } else {
                    ClRtlPrintToFile = TRUE;
                    ClRtlProcessId = GetCurrentProcessId();

                    //
                    // determine the initial low water mark. We have 3 cases
                    // we need to handle:
                    // 1) log size is less than 1/2 limit
                    // 2) log size is within limit but more than 1/2 limit
                    // 3) log size is greater than limit
                    //
                    // case 1 requires nothing special; the low water mark
                    // will be updated on the next log write.
                    //
                    // for case 2, we need to find the beginning of a line
                    // near 1/2 the current limit. for case 3, the place to
                    // start looking is current log size - 1/2 limit. In this
                    // case, the log will be truncated before the first write
                    // occurs, so we need to take the last 1/2 limit bytes and
                    // copy them down to the front.
                    //
                    //

                    ClRtlAcquirePrintLock();
                    fileSizeLow = GetFileSize( ClRtlPrintFile, &fileSizeHigh );
                    if ( fileSizeLow < ( ClRtlPrintFileLimit / 2 )) {
                        //
                        // case 1: leave low water at zero; it will be updated
                        // with next log write
                        //
                        ;
                    } else {
#define LOGBUF_SIZE 1024                        
                        CHAR    buffer[LOGBUF_SIZE];
                        LONG    currentPosition;
                        DWORD   bytesRead;

                        if ( fileSizeLow < ClRtlPrintFileLimit ) {
                            //
                            // case 2; start looking at the 1/2 the current
                            // limit to find the starting position
                            //
                            currentPosition = ClRtlPrintFileLimit / 2;
                        } else {
                            //
                            // case 3: start at current size minus 1/2 limit
                            // to find our starting position.
                            //
                            currentPosition  = fileSizeLow - ( ClRtlPrintFileLimit / 2 );
                        }

                        //
                        // read in a block (backwards) from the initial file
                        // position and look for a newline char. When we find
                        // one, the next char is the first char on a new log
                        // line. use that as the initial starting position
                        // when we finally truncate the file.
                        //
                        ClRtlPrintFileLoWater = 0;
                        currentPosition -= LOGBUF_SIZE;

                        SetFilePointer(ClRtlPrintFile,
                                       currentPosition,
                                       &fileSizeHigh,
                                       FILE_BEGIN);
                        if ( ReadFile(ClRtlPrintFile,
                                      buffer,
                                      LOGBUF_SIZE,
                                      &bytesRead,
                                      NULL ) )                            
                        {
                            PCHAR p = &buffer[ bytesRead - 1 ];

                            while ( *p != '\n' && bytesRead-- != 0 ) {
                                --p;
                            }
                            if ( *p == '\n' ) {
                                ClRtlPrintFileLoWater = (DWORD)(currentPosition + ( p - buffer + 1 ));
                            }
                        }

                        if ( ClRtlPrintFileLoWater == 0 ) {
                            //
                            // couldn't find any reasonable data. just set it to
                            // initial current position.
                            //
                            ClRtlPrintFileLoWater = currentPosition + LOGBUF_SIZE;
                        }
                    }
                    ClRtlReleasePrintLock();
                }
            } else {
                Status = GetLastError();
                ClRtlDbgPrint(LOG_UNUSUAL,
                              "[ClRtl] Unable to create print file mutex. Error %1!u!.\n",
                              Status);
                Status = ERROR_SUCCESS;
                //goto exit;
            }
        }
    }

exit:
    if ( logFileName != logFileBuffer && logFileName != modulePath ) {
        LocalFree( logFileName );
    }

    //
    //  Chittur Subbaraman (chitturs) - 11/11/98
    //
    if ( lpszBakFileName != NULL )
    {
        LocalFree( lpszBakFileName );
    }

    return Status;

} // ClRtlInitialize

#ifdef RPC_WMI_TRACING
  
typedef
DWORD (*I_RpcEnableWmiTraceFunc )(
            VOID* fn,               // Rpc now uses TraceMessage, no need to pass trace func
            WPP_WIN2K_CONTROL_BLOCK ** pHandle
      );

HINSTANCE hInstRpcrt4;

#endif


DWORD
ClRtlIsServicesForMacintoshInstalled(
    OUT BOOL * pfInstalled
    )

/*++

Routine Description:

    Determines if SFM is installed on the local system.

Arguments:

    pfInstalled - pointer to a boolean flag to return whether SFM is installed
    returns: TRUE if SFM is installed
             FALSE if SFM is not installed

Return Value:

    Status of request. ERROR_SUCCESS if valid info in pfInstalled.
       Error Code otherwise. On error pfInstalled (if present) is set to FALSE  

--*/

{
    HANDLE  scHandle;
    HANDLE  scServiceHandle;

    if ( ARGUMENT_PRESENT( pfInstalled ) ) {
        *pfInstalled = FALSE;
    } else {
        return ERROR_INVALID_PARAMETER;
    }
    scHandle = OpenSCManager(
        NULL,       // Open on local machine
        NULL,       // Open SERVICES_ACTIVE_DATABASE
        GENERIC_READ );
    if ( scHandle == NULL ) {
        return( GetLastError() );
    }

    scServiceHandle = OpenService(
                scHandle,
                L"macfile",
                READ_CONTROL );
    if ( scServiceHandle != NULL ) {
        *pfInstalled = TRUE;
    }
    CloseServiceHandle( scServiceHandle );
    CloseServiceHandle( scHandle );

    return ERROR_SUCCESS;

} // ClRtlIsServicesForMacintoshInstalled


DWORD
ClRtlInitWmi(
    LPCWSTR ComponentName
    )
{
#if defined(RPC_WMI_TRACING)
    {
        DWORD Status = ERROR_SUCCESS;
        PWPP_WIN2K_CONTROL_BLOCK RpcCb;
        I_RpcEnableWmiTraceFunc RpcEnableWmiTrace = 0;

        hInstRpcrt4 = LoadLibrary(L"rpcrt4.dll");
        if (hInstRpcrt4) {
            RpcEnableWmiTrace = (I_RpcEnableWmiTraceFunc)
                GetProcAddress(hInstRpcrt4, "I_RpcEnableWmiTrace");

            if (RpcEnableWmiTrace) {

                Status = (*RpcEnableWmiTrace)(0, &RpcCb);
                if (Status == ERROR_SUCCESS) {
                    WPP_SET_FORWARD_PTR(RpcTrace, WPP_VER_WIN2K_CB_FORWARD_PTR, RpcCb);
                }

            } else {
                ClRtlDbgPrint(LOG_UNUSUAL,
                              "[ClRtl] rpcrt4.dll GetWmiTraceEntryPoint failed, status %1!d!.\n",
                              GetLastError() );
            }
        }
    }
#endif // RPC_WMI_TRACING
    
    WPP_INIT_TRACING(NULL); // Don't need publishing
    WppAutoStart(ComponentName);
    return ERROR_SUCCESS;
}

VOID
ClRtlCleanup(
    VOID
    )
{
    if (ClRtlpInitialized) {
        ClRtlpInitialized = FALSE;
        ClRtlEventLogCleanup();

        //Cleaning up watchdog stuff
        if(ClRtlWatchdogTimerQueue != NULL) {
        	DeleteTimerQueue(ClRtlWatchdogTimerQueue);
        	ClRtlWatchdogTimerQueue = NULL;
        	}			
        
        WPP_CLEANUP();
    #if defined(RPC_WMI_TRACING)
        if (hInstRpcrt4) {
            FreeLibrary(hInstRpcrt4);
        }
    #endif
    }

    return;
}

VOID
ClRtlpWatchdogCallback(
	PVOID par,
	BOOLEAN timedOut
	)
{

    PWATCHDOGPAR pPar=(PWATCHDOGPAR)par;

	if(!timedOut) {
		// The timer was cancelled, get out.
		ClRtlLogPrint(LOG_NOISE,
		    "[ClRtl] Watchdog Timer Cancelled, ThreadId= 0x%1!x! par= %2!ws!.\n",
		    pPar->threadId,
		    pPar->par
		    );
		return;
	}

	ClRtlLogPrint(LOG_CRITICAL,
		"[ClRtl] Watchdog timer timed out, ThreadId= 0x%1!x! par= %2!ws!.\n",
		pPar->threadId,
		pPar->par
		);

#ifdef CLUSTER_BETA
	// Breaking into NTSD if available or KD. Do it only for cluster beat builds.
	DebugBreak();
#endif

}

PVOID
ClRtlSetWatchdogTimer(
	DWORD  timeout,
	LPWSTR par
	)
{

	PWATCHDOGPAR pPar;

	// Do the initialization here not in ClRtlInitialize()
	if(ClRtlWatchdogTimerQueue == NULL) {
		if((ClRtlWatchdogTimerQueue = CreateTimerQueue()) == NULL) {
			return NULL;
		}
	}

	if((pPar = LocalAlloc(LMEM_FIXED, sizeof(WATCHDOGPAR))) == NULL) {
	    return NULL;
	    }
	pPar->par = par;
	pPar->threadId = GetCurrentThreadId();

	if(!CreateTimerQueueTimer(
			&pPar->wTimer,
			ClRtlWatchdogTimerQueue,
			ClRtlpWatchdogCallback,
			(PVOID)pPar,
			timeout,
			0,
			0)) {
			LocalFree(pPar);
			return NULL;
		}

	ClRtlLogPrint(LOG_NOISE, 
		"[ClRtl] Setting watchdog timer= 0x%1!x!, Timeout= %2!u!(ms), par= %3!ws!.\n",
		pPar->wTimer,
		timeout,
		par
		);
	return (PVOID)pPar;		

}	

VOID
ClRtlCancelWatchdogTimer(
	PVOID wTimer
	)
{

    PWATCHDOGPAR pPar=(PWATCHDOGPAR)wTimer;
    
	if((ClRtlWatchdogTimerQueue == NULL) || (wTimer == NULL)) {
		return;
		}

	if(!DeleteTimerQueueTimer(
		ClRtlWatchdogTimerQueue,
		pPar->wTimer,
		INVALID_HANDLE_VALUE
		)) {
		ClRtlLogPrint(LOG_CRITICAL,
			"[ClRtl] Failed to cancel watchdog timer 0x%1!x!.\n",
			pPar->wTimer
			);
		}
	else {
		ClRtlLogPrint(LOG_NOISE, 
			"[ClRtl] Cancelled watchdog timer 0x%1!x!.\n",
			pPar->wTimer
			);
		}
	LocalFree(wTimer);
}	
		
		

BOOL
ClRtlCheckForLogCorruption(
    LPSTR pszOutBuffer
    )
//
// Find the log corrupter. There should never be move than 4
// question marks in a row or character below 32 or above 128
// if English.
//
// Returns:
//      TRUE if it is safe to write
//      FALSE if it is NOT safe to write
//
{
    DWORD count;
    WCHAR  szLocale[ 32 ];
    static BOOL fLocaleFound = FALSE;
    static BOOL fEnglish = FALSE;

    if ( !pszOutBuffer )
        return FALSE;

    if ( !fLocaleFound )
    {
        GetLocaleInfoW(LOCALE_SYSTEM_DEFAULT, LOCALE_SENGLANGUAGE, szLocale, 32 );

        if ( lstrcmpiW( szLocale, L"ENGLISH" ) == 0 )
        {
            fEnglish = TRUE;
        }

        fLocaleFound = TRUE;
    }

    for( count = 0; *pszOutBuffer; pszOutBuffer++ )
    {
        if ( *pszOutBuffer == '?' )
        {
            count++;
            if ( count > 4 )
            {
                return FALSE;
            }
        }
        else if ( fEnglish
               && ( ( *pszOutBuffer < 32
                   && *pszOutBuffer != 0x0A    // linefeed
                   && *pszOutBuffer != 0x0D    // creturn
                   && *pszOutBuffer != 0x09 ) // tab
                 || *pszOutBuffer > 128 ) )
        {
            return FALSE;
        }
    }

    return TRUE;

} // ClRtlCheckForLogCorruption

__inline BOOL
ClRtlpIsOutputDeviceAvailable(
    VOID
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    //
    // normally, there is nothing to do
    //
    return ( ClRtlpDbgOutputToConsole || IsDebuggerPresent());
} // ClRtlpIsOutputDeviceAvailable

VOID
ClRtlpOutputString(
    IN PCHAR String
    )

/*++

Routine Description:

    Outputs the specified string based on the current settings

Arguments:

    String - Specifies the string to output.

Return Value:

    None.

--*/

{
    static PCRITICAL_SECTION    dbgPrintLock = NULL;
    PCRITICAL_SECTION           testPrintLock;

    //
    // synchronize threads by interlocking the assignment of the global lock.
    //
    if ( dbgPrintLock == NULL ) {
        testPrintLock = LocalAlloc( LMEM_FIXED, sizeof( CRITICAL_SECTION ));
        if ( testPrintLock == NULL ) {
            return;
        }

        InitializeCriticalSection( testPrintLock );
        InterlockedCompareExchangePointer( &dbgPrintLock, testPrintLock, NULL );

        //
        // only one thread did the exchange; the loser deallocates its
        // allocation and switches over to using the real lock
        //
        if ( dbgPrintLock != testPrintLock ) {
            DeleteCriticalSection( testPrintLock );
            LocalFree( testPrintLock );
        }
    }

    EnterCriticalSection( dbgPrintLock );

    //
    // print to console window has precedence. Besides, if console is the
    // debugger window, you get double output
    //
    if (ClRtlpDbgOutputToConsole) {
        printf( String );
    } else if ( IsDebuggerPresent()) {
        OutputDebugStringA(String);
    }

    LeaveCriticalSection( dbgPrintLock );

} // ClRtlpOutputString

VOID
ClRtlMsgPrint(
    IN DWORD MessageId,
    ...
    )

/*++

Routine Description:

    Prints a message to the debugger or console, as appropriate

    Does not alter the formatting of the message as it occurs in the message
    file.

Arguments:

    MessageId - The message id of the string to print

    Any FormatMessage compatible arguments to be inserted in the ErrorMessage
    before it is logged.

Return Value:

    None.

--*/

{
    CHAR szOutBuffer[LOGENTRY_BUFFER_SIZE];
    DWORD Bytes;
    NTSTATUS Status;
    va_list ArgList;

    //
    // don't go any further if nothing to do
    //
    if ( !ClRtlpIsOutputDeviceAvailable()) {
        return;
    }

    va_start(ArgList, MessageId);

    try {
        Bytes = FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE,
                               NULL,
                               MessageId,
                               0,
                               szOutBuffer,
                               sizeof(szOutBuffer) / sizeof(szOutBuffer[0]),
                               &ArgList);
    }
    except ( EXCEPTION_EXECUTE_HANDLER ) {
        Bytes = FormatMessageA(FORMAT_MESSAGE_FROM_STRING
                               | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                               L"LOGERROR(exception): Could not format message ID #%1!u!\n",
                               0,
                               0,
                               szOutBuffer,
                               sizeof(szOutBuffer) / sizeof(szOutBuffer[0]),
                               (va_list *) &MessageId );
    }

    va_end(ArgList);

    if (Bytes != 0) {
        if ( !ClRtlCheckForLogCorruption( szOutBuffer ) ) {
            Bytes = FormatMessageA(FORMAT_MESSAGE_FROM_STRING
                                   | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                   "LOGERROR: non-ASCII characters detected after formatting of message ID #%1!u!\n",
                                   0,
                                   0,
                                   szOutBuffer,
                                   sizeof(szOutBuffer) / sizeof(szOutBuffer[0]),
                                   (va_list *) &MessageId );
        }
        ClRtlpOutputString(szOutBuffer);
    }
} // ClRtlMsgPrint


VOID
ClRtlpDbgPrint(
    DWORD LogLevel,
    PCHAR FormatString,
    va_list ArgList
    )
/*++

 Routine Description:

     Prints a message to the debugger or console, as appropriate.

 Arguments:

    LogLevel - Supplies the logging level, one of
                LOG_CRITICAL 1
                LOG_UNUSUAL  2
                LOG_NOISE    3

     String - The initial message string to print.

     Any FormatMessage-compatible arguments to be inserted in the
     ErrorMessage before it is logged.

 Return Value:
     None.

--*/
{
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    WCHAR wszOutBuffer[LOGENTRY_BUFFER_SIZE];
    WCHAR wszInBuffer[LOGENTRY_BUFFER_SIZE];
    CHAR szOutBuffer[LOGENTRY_BUFFER_SIZE];
    NTSTATUS Status;
    DWORD Bytes;

    //
    // don't go any further if nothing to do
    //
    if ( !ClRtlpIsOutputDeviceAvailable()) {
        return;
    }

    //
    // next check that this message isn't filtered out by the current logging
    // level
    //
    if ( ClRtlDbgLogLevel != NULL ) {
        if ( LogLevel > *ClRtlDbgLogLevel ) {
            return;
        }
    }

    RtlInitAnsiString( &AnsiString, FormatString );
    UnicodeString.MaximumLength = LOGENTRY_BUFFER_SIZE;
    UnicodeString.Buffer = wszInBuffer;
    Status = RtlAnsiStringToUnicodeString( &UnicodeString, &AnsiString, FALSE );
    if ( !NT_SUCCESS( Status ) ) {
        return;
    }

    try {
        Bytes = FormatMessageW(FORMAT_MESSAGE_FROM_STRING,
                               UnicodeString.Buffer,
                               0,
                               0,
                               wszOutBuffer,
                               sizeof(wszOutBuffer) / sizeof(wszOutBuffer[0]),
                               &ArgList);
    }
    except ( EXCEPTION_EXECUTE_HANDLER ) {
        Bytes = FormatMessageW(FORMAT_MESSAGE_FROM_STRING
                               | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                               L"LOGERROR(exception): Could not print message: %1!hs!.",
                               0,
                               0,
                               wszOutBuffer,
                               sizeof(wszOutBuffer) / sizeof(wszOutBuffer[0]),
                               (va_list *) &FormatString );
    }

    if (Bytes != 0) {
        UnicodeString.Length = (USHORT) Bytes * sizeof(WCHAR);
        UnicodeString.Buffer = wszOutBuffer;
        AnsiString.MaximumLength = LOGENTRY_BUFFER_SIZE;
        AnsiString.Buffer = szOutBuffer;
        Status = RtlUnicodeStringToAnsiString( &AnsiString, &UnicodeString, FALSE );
        if ( NT_SUCCESS( Status ) ) {
            if ( ClRtlCheckForLogCorruption( AnsiString.Buffer ) ) {
                ClRtlpOutputString(szOutBuffer);
            }
            else
            {
                Bytes = FormatMessageA(FORMAT_MESSAGE_FROM_STRING
                                       | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                       "LOGERROR: non-ASCII characters in formatted message: %1!hs!",
                                       0,
                                       0,
                                       szOutBuffer,
                                       sizeof(szOutBuffer) / sizeof(szOutBuffer[0]),
                                       (va_list *) &FormatString );

                if ( Bytes > 0 ) {
                    ClRtlpOutputString(szOutBuffer);
                    if ( szOutBuffer[ Bytes - 1 ] != '\n' ) {
                        ClRtlpOutputString( "\n" );
                    }
                }
            }
        }
    }

} // ClRtlpDbgPrint


VOID
ClRtlDbgPrint(
    DWORD LogLevel,
    PCHAR FormatString,
    ...
    )
/*++

 Routine Description:

     Prints a message to the debugger or console, as appropriate.

 Arguments:

    LogLevel - Supplies the logging level, one of
                LOG_CRITICAL 1
                LOG_UNUSUAL  2
                LOG_NOISE    3

     String - The initial message string to print.

     Any FormatMessage-compatible arguments to be inserted in the
     ErrorMessage before it is logged.

 Return Value:
     None.

--*/
{
    va_list ArgList;

    va_start(ArgList, FormatString);
    ClRtlpDbgPrint( LogLevel, FormatString, ArgList );
    va_end(ArgList);

} // ClRtlDbgPrint


VOID
ClRtlPrintf(
    PCHAR FormatString,
    ...
    )
/*++

 Routine Description:

     Prints a message to the debugger or console, as appropriate.

 Arguments:

     Just like printf

 Return Value:
     None.

--*/
{
    char buf[128];
    va_list ArgList;

    va_start(ArgList, FormatString);
    _vsnprintf(buf, sizeof(buf), FormatString, ArgList);
    buf[127] = 0; 
    ClRtlLogPrint( 1, "%1!hs!", buf);
    va_end(ArgList);

} // ClRtlDbgPrint

DWORD
ClRtlpTruncateFile(
    IN HANDLE FileHandle,
    IN DWORD FileSize,
    IN LPDWORD LastPosition
    )

/*++

Routine Description:

    Truncate a file from the front.

Arguments:

    FileHandle - File handle.

    FileSize - Current End of File.

    LastPosition - Move from this last position to end-of-file to beginning.

Return Value:

    New end of file.

--*/

{
//
// The following buffer size should never be more than 1/4 the size of the
// file.
//
#define BUFFER_SIZE ( 64 * 1024 )
    DWORD   bytesLeft;
    DWORD   endPosition = 0;
    DWORD   bufferSize;
    DWORD   bytesRead;
    DWORD   bytesWritten;
    DWORD   fileSizeHigh = 0;
    DWORD   readPosition;
    DWORD   writePosition;
    PVOID   dataBuffer;


    if ( *LastPosition >= FileSize ) {
        goto error_exit;
    }

    bytesLeft = FileSize - *LastPosition;
    dataBuffer = LocalAlloc( LMEM_FIXED, BUFFER_SIZE );
    if ( !dataBuffer ) {
        goto error_exit;
    }
    endPosition = bytesLeft;

    //
    // Point back to last position for reading.
    //
    readPosition = *LastPosition;
    writePosition = 0;

    while ( bytesLeft ) {
        if ( bytesLeft >= BUFFER_SIZE ) {
            bufferSize = BUFFER_SIZE;
        } else {
            bufferSize = bytesLeft;
        }
        bytesLeft -= bufferSize;
        SetFilePointer( FileHandle,
                        readPosition,
                        &fileSizeHigh,
                        FILE_BEGIN );
        if ( ReadFile( FileHandle,
                       dataBuffer,
                       bufferSize,
                       &bytesRead,
                       NULL ) ) {

            SetFilePointer( FileHandle,
                            writePosition,
                            &fileSizeHigh,
                            FILE_BEGIN );
            WriteFile( FileHandle,
                       dataBuffer,
                       bytesRead,
                       &bytesWritten,
                       NULL );
        } else {
            endPosition = 0;
            break;
        }
        readPosition += bytesRead;
        writePosition += bytesWritten;
    }

    LocalFree( dataBuffer );

error_exit:

    //
    // Force end of file to get set.
    //
    SetFilePointer( FileHandle,
                    endPosition,
                    &fileSizeHigh,
                    FILE_BEGIN );

    SetEndOfFile( FileHandle );

    *LastPosition = endPosition;

    return(endPosition);

} // ClRtlpTruncateFile


VOID
ClRtlLogPrint(
    ULONG   LogLevel,
    PCHAR   FormatString,
    ...
    )
/*++

 Routine Description:

     Prints a message to a log file.

 Arguments:

    LogLevel - Supplies the logging level, one of
                LOG_CRITICAL 1
                LOG_UNUSUAL  2
                LOG_NOISE    3

     String - The initial message string to print.

     Any FormatMessage-compatible arguments to be inserted in the
     ErrorMessage before it is logged.

 Return Value:

     None.

--*/
{
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    WCHAR wszInBuffer[LOGENTRY_BUFFER_SIZE];
    WCHAR wszOutBuffer[LOGENTRY_BUFFER_SIZE];
    CHAR  szOutBuffer[LOGENTRY_BUFFER_SIZE];
    DWORD Bytes;
    DWORD PrefixBytes;
    DWORD BytesWritten;
    DWORD FileSize;
    DWORD FileSizeHigh;
    NTSTATUS Status;
    SYSTEMTIME Time;
    ULONG_PTR ArgArray[9];
    va_list ArgList;
    PWCHAR logLabel;

    //
    // init the variable arg list
    //
    va_start(ArgList, FormatString);

    ClRtlpDbgPrint( LogLevel, FormatString, ArgList );

    if ( !ClRtlPrintToFile ) {
        va_end(ArgList);
        return;
    }

    // begin_wpp config
    // CUSTOM_TYPE(level, ItemListByte(UNK0, ERR_, WARN, INFO) );
    // end_wpp

    //
    // convert nuemric LogLevel to something readable
    //
    switch ( LogLevel ) {
    case LOG_NOISE:
        logLabel = L"INFO ";
        break;

    case LOG_UNUSUAL:
        logLabel = L"WARN ";
        break;

    case LOG_CRITICAL:
        logLabel = L"ERR  ";
        break;

    default:
        ASSERT( 0 );
        logLabel = L"UNKN ";
        break;
    }

    GetSystemTime(&Time);

    ArgArray[0] = ClRtlProcessId;
    ArgArray[1] = GetCurrentThreadId();
    ArgArray[2] = Time.wYear;
    ArgArray[3] = Time.wMonth;
    ArgArray[4] = Time.wDay;
    ArgArray[5] = Time.wHour;
    ArgArray[6] = Time.wMinute;
    ArgArray[7] = Time.wSecond;
    ArgArray[8] = Time.wMilliseconds;

    PrefixBytes = FormatMessageW(FORMAT_MESSAGE_FROM_STRING |
                                 FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                 L"%1!08lx!.%2!08lx!::%3!02d!/%4!02d!/%5!02d!-%6!02d!:%7!02d!:%8!02d!.%9!03d! ",
                                 0,
                                 0,
                                 wszOutBuffer,
                                 sizeof(wszOutBuffer)/sizeof(wszOutBuffer[0]),
                                 (va_list*)&ArgArray);

    if ( PrefixBytes == 0 ) {
        va_end(ArgList);
        WmiTrace("Prefix format failed, %d: %!ARSTR!", GetLastError(), FormatString);
        return;
    }

    //
    // add on the log label at the end and adjust PrefixBytes
    //
    wcscat( wszOutBuffer, logLabel );
    PrefixBytes = wcslen( wszOutBuffer );

    // convert in the message into unicode
    RtlInitAnsiString( &AnsiString, FormatString );
    UnicodeString.MaximumLength = LOGENTRY_BUFFER_SIZE;
    UnicodeString.Buffer = wszInBuffer;
    Status = RtlAnsiStringToUnicodeString( &UnicodeString, &AnsiString, FALSE );
    if ( !NT_SUCCESS( Status ) ) {
        va_end(ArgList);
        WmiTrace("AnsiToUni failed, %x: %!ARSTR!", Status, FormatString);
        return;
    }

    try {
        Bytes = FormatMessageW(FORMAT_MESSAGE_FROM_STRING,
                               UnicodeString.Buffer,
                               0,
                               0,
                               &wszOutBuffer[PrefixBytes],
                               (sizeof(wszOutBuffer) / sizeof(wszOutBuffer[0])) - PrefixBytes,
                               &ArgList);
    }
    except ( EXCEPTION_EXECUTE_HANDLER ) {
        Bytes = FormatMessageW(FORMAT_MESSAGE_FROM_STRING
                               | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                               L"LOGERROR(exception): Could not print message: %1!hs!",
                               0,
                               0,
                               &wszOutBuffer[PrefixBytes],
                               (sizeof(wszOutBuffer) / sizeof(wszOutBuffer[0])) - PrefixBytes,
                               (va_list *) &FormatString );
    }
    va_end(ArgList);

    if (Bytes != 0) {

        // convert the out to Ansi
        UnicodeString.Buffer = wszOutBuffer;
        UnicodeString.Length = ((USHORT) Bytes + (USHORT) PrefixBytes) * sizeof(WCHAR);
        AnsiString.Buffer = szOutBuffer;
        AnsiString.MaximumLength = LOGENTRY_BUFFER_SIZE;
        Status = RtlUnicodeStringToAnsiString( &AnsiString, &UnicodeString, FALSE );
        if ( !NT_SUCCESS( Status ) ) {
            WmiTrace("UniToAnsi failed, %x: %!ARWSTR!", Status, wszOutBuffer + PrefixBytes);
            return;
        }

        ClRtlAcquirePrintLock();

        FileSize = GetFileSize( ClRtlPrintFile,
                                &FileSizeHigh );
        ASSERT( FileSizeHigh == 0 );        // We're only using DWORDs!
        if ( FileSize > ClRtlPrintFileLimit ) {
            FileSize = ClRtlpTruncateFile( ClRtlPrintFile,
                                           FileSize,
                                           &ClRtlPrintFileLoWater );
        }

        SetFilePointer( ClRtlPrintFile,
                        FileSize,
                        &FileSizeHigh,
                        FILE_BEGIN );
        if ( ClRtlCheckForLogCorruption( AnsiString.Buffer ) )
        {
#if defined(ENCRYPT_TEXT_LOG)
            int i;
            for (i = 0; i < AnsiString.Length; ++i) {
                AnsiString.Buffer[i] ^= 'a';
            }
#endif            
            WriteFile(ClRtlPrintFile,
                      AnsiString.Buffer,
                      AnsiString.Length,
                      &BytesWritten,
                      NULL);
#if defined(ENCRYPT_TEXT_LOG)
            for (i = 0; i < AnsiString.Length; ++i) {
                AnsiString.Buffer[i] ^= 'a';
            }
#endif            
        }
        else
        {
            Bytes = FormatMessageA(FORMAT_MESSAGE_FROM_STRING
                                   | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                   "LOGERROR: non-ASCII characters in formatted message: %1!hs!",
                                   0,
                                   0,
                                   &szOutBuffer[PrefixBytes],
                                   (sizeof(szOutBuffer) / sizeof(szOutBuffer[0])) - PrefixBytes,
                                   (va_list *) &FormatString );

            if ( Bytes > 0 ) {
                WriteFile(ClRtlPrintFile,
                          szOutBuffer,
                          PrefixBytes + Bytes,
                          &BytesWritten,
                          NULL);

                if ( szOutBuffer[ PrefixBytes + Bytes - 1 ] != '\n' ) {
                    WriteFile(ClRtlPrintFile,
                              "\n",
                              1,
                              &BytesWritten,
                              NULL);
                }

                RtlInitAnsiString( &AnsiString, szOutBuffer );
            }
        }

        if ( (ClRtlPrintFileLoWater == 0) &&
             (FileSize > (ClRtlPrintFileLimit / 2)) ) {
            ClRtlPrintFileLoWater = FileSize + BytesWritten;
        }

        ClRtlReleasePrintLock();

        WmiTrace("%!level! %!ARSTR!", *(UCHAR*)&LogLevel, AnsiString.Buffer + PrefixBytes);
/*
#if defined(WMI_TRACING)
        if (ClRtlWml.Trace && ClRtlWmiReg.EnableFlags) {
            ClRtlWml.Trace(10, &ClRtlTraceGuid, ClRtlWmiReg.LoggerHandle,
                LOG(UINT, ClRtlProcessId)
                LOGASTR(AnsiString.Buffer + PrefixBytes)
                0);
        }
#endif // defined(WMI_TRACING)
 */
    } else {
        WmiTrace("Format returned 0 bytes: %!ARSTR!", FormatString);
    }
    return;
} // ClRtlLogPrint


VOID
ClRtlpFlushLogBuffers(
    VOID
    )

/*++

Routine Description:

    Flush the cluster log file

Arguments:

    none

Return Value:

    none

--*/

{
    FlushFileBuffers( ClRtlPrintFile );
}

DWORD
ClRtlCreateDirectory(
    IN LPCWSTR lpszPath
    )
/*++

Routine Description:

    Creates a directory creating any subdirectories as required.

Arguments:

    lpszMultiSz - Supplies the path to the directory.  It may or
    may not be terminated by a back slash.

Return Value:

    ERROR_SUCCESS if successful, else the error code.

--*/
{
    WCHAR   cSlash = L'\\';
    DWORD   dwLen;
    LPCWSTR pszNext;
    WCHAR   lpszDir[MAX_PATH];
    LPWSTR  pszDirPath=NULL;
    DWORD   dwError = ERROR_SUCCESS;

    if (!lpszPath || ((dwLen=lstrlenW(lpszPath)) < 1))
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    pszDirPath = (LPWSTR)LocalAlloc(LMEM_FIXED, ((dwLen + 2) * sizeof(WCHAR)));
    if (pszDirPath == NULL)
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto FnExit;
    }
    lstrcpyW(pszDirPath, lpszPath);

    //if it doesnt terminate with \, terminate it
    if (pszDirPath[dwLen-1] != cSlash)
    {
        pszDirPath[dwLen] = cSlash;
        pszDirPath[dwLen+1] = L'\0';
    }

    dwLen = lstrlenW(pszDirPath);
    //handle SMB Path names e.g \\xyz\abc\lmn
    if ((dwLen > 2) && (pszDirPath[0]== L'\\') && (pszDirPath[1] == L'\\'))
    {
        //check if the name if of format \\?\UNC\XYZ\ABC\LMN
        // or if the format \\?\C:\xyz\abz
        if ((dwLen >3) && (pszDirPath[2] == L'?'))
        {
            //search for the \ after ?
            pszNext = wcschr(pszDirPath + 2, cSlash);
            //check if it is followed by UNC
            if (pszNext)
            {
                if (!wcsncmp(pszNext+1, L"UNC", lstrlenW(L"UNC")))
                {
                    //it is a UNC Path name
                    //move past the third slash from here
                    pszNext = wcschr(pszNext+1, cSlash);
                    if (pszNext) 
                        pszNext = wcschr(pszNext+1, cSlash);
                    if (pszNext) 
                        pszNext = wcschr(pszNext+1, cSlash);
                }
                else
                {
                    //it is a volume name, move to the next slash
                    pszNext = wcschr(pszNext+1, cSlash);
                }
            }                
        }
        else
        {
            //it is of type \\xyz\abc\lmn
            pszNext = wcschr(pszDirPath + 2, cSlash);
            if (pszNext) 
                pszNext = wcschr(pszNext+1, cSlash);
        }
    }
    else
    {
        pszNext = pszDirPath;
        pszNext = wcschr(pszNext, cSlash);
        // if the character before the first \ is :, skip the creation
        // of the c:\ level directory
        if (pszNext && pszNext > pszDirPath)
        {
            pszNext--;
            if (*pszNext == L':')
            {
                pszNext++;
                pszNext = wcschr(pszNext+1, cSlash);
            }
            else
                pszNext++;
        }
    }
    
    while ( pszNext)
    {
        DWORD_PTR dwptrLen;

        dwptrLen = pszNext - pszDirPath + 1;

        dwLen=(DWORD)dwptrLen;
        lstrcpynW(lpszDir, pszDirPath, dwLen+1);

        if (!CreateDirectory(lpszDir, NULL))
        {
            dwError = GetLastError();
            if (dwError == ERROR_ALREADY_EXISTS)
            {
                //this is not a problem,continue
                dwError = ERROR_SUCCESS;
            }
            else
            {
                ClRtlDbgPrint(LOG_CRITICAL,
                    "[ClRtl] CreateDirectory Failed on %1!ws!. Error %2!u!\n",
                    lpszDir, dwError);
                goto FnExit;
            }
        }

        pszNext = wcschr(pszNext+1, cSlash);
    }

FnExit:
    if (pszDirPath) LocalFree(pszDirPath);
    return(dwError);
}





BOOL
WINAPI
ClRtlIsPathValid(
    LPCWSTR  Path
    )

/*++

Routine Description:

    Returns true if the given path looks syntactically valid.

    This call is NOT network-aware.

Arguments:

    Path - String containing a path.

Return Value:

    TRUE if the path looks valid, otherwise FALSE.

--*/

{
    WCHAR   chPrev;
    WCHAR   chCur;
    DWORD   charCount = 0;
#ifdef    DBCS
    BOOL    fPrevLead = FALSE;
#endif

    CL_ASSERT(Path);
    CL_ASSERT(!*Path || !iswspace(*Path));        // no leading whitespace

    if ( iswalpha(*Path) && *(Path+1) == L':' ) {
        Path += 2;
    }

    chCur = *Path;
    chPrev = 0;

    while (chCur) {
        charCount++;
        if ( charCount > MAX_PATH ) {
            return(FALSE);
        }
#ifdef    DBCS
        if (fPrevLead) {
            fPrevLead = FALSE;
            chPrev = 0;
        } else {
            fPrevLead = IsDBCSLeadByte(chCur);
#endif    // DBCS

            switch ( chCur ) {

            // Explicit invalid characters
            case L'*' :
            case L';' :
            case L',' :
            case L'=' :
            case L'?' :
            case L'<' :
            case L'>' :
            case L'|' :
            case L':' :             // no ":" except as second char
                return(FALSE);      // no ":" allowed other than second char */

#if 0   // The following should be okay
            case L'\\' :
                if ( chPrev == chDirSep ) {
                    return(FALSE);  // no double "\\" in middle - but legal
                }
                break;
#endif

            default:
#if 0   // accept anything else for now
                if ( !iswalnum( chCur ) ) {
                    return(FALSE);
                }
#endif
                break;
            }

            chPrev = chCur;

#ifdef    DBCS
        }
#endif

        chCur = *(++Path);
    }

#ifdef    DBCS
    if (fPrevLead)
        return(FALSE);    // ends w/ lead byte
#endif

    return(TRUE);

} // ClRtlIsPathValid


/****
@func       DWORD | ClRtlGetClusterDirectory | Get the directory in which
            the cluster service is installed

@parm       IN LPWSTR | lpBuffer | Supplies the buffer in which the
            directory path is to be copied.

@parm       IN DWORD | dwBufSize | Supplies the size of the buffer.

@rdesc      Returns a Win32 error code if the operation is
            unsuccessful. ERROR_SUCCESS on success.
****/
DWORD
ClRtlGetClusterDirectory(
    IN LPWSTR   lpBuffer,
    IN DWORD    dwBufSize
    )
{
    DWORD           dwLen;
    DWORD           dwStatus;
    LPWSTR          szRegKeyName = NULL;
    HKEY            hClusSvcKey = NULL;
    LPWSTR          lpImagePath = NULL;
    WCHAR           *pTemp = NULL;

    //
    //  Chittur Subbaraman (chitturs) - 10/29/98
    //
    if ( lpBuffer == NULL )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }
    //
    // Open key to SYSTEM\CurrentControlSet\Services\ClusSvc
    //
    dwLen = lstrlenW( CLUSREG_KEYNAME_CLUSSVC_PARAMETERS );
    szRegKeyName = (LPWSTR) LocalAlloc ( LMEM_FIXED,
                                    ( dwLen + 1 ) *
                                    sizeof ( WCHAR ) );
    if ( szRegKeyName == NULL )
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    dwLen -= lstrlenW( CLUSREG_KEYNAME_PARAMETERS );

    lstrcpyW( szRegKeyName, CLUSREG_KEYNAME_CLUSSVC_PARAMETERS );
    szRegKeyName [dwLen-1] = L'\0';

    if ( ( dwStatus = RegOpenKeyW( HKEY_LOCAL_MACHINE,
                                 szRegKeyName,
                                 &hClusSvcKey ) ) != ERROR_SUCCESS )
    {
        goto FnExit;
    }

    lstrcpyW ( szRegKeyName, L"ImagePath" );
    //
    //  Try to query the clussvc key. If the ImagePath
    //  value is present, then get the length of the image
    //  path
    //
    dwLen = 0;
    if ( ( dwStatus = ClRtlRegQueryString( hClusSvcKey,
                                           szRegKeyName,
                                           REG_EXPAND_SZ,
                                           &lpImagePath,
                                           &dwLen,
                                           &dwLen ) ) != ERROR_SUCCESS )
    {
        goto FnExit;
    }

    //
    //  Now expand any environment strings present in the
    //  ImagePath
    //
    if ( ( dwLen = ExpandEnvironmentStringsW( lpImagePath,
                                              lpBuffer,
                                              dwBufSize ) ) == 0 )
    {
        dwStatus = GetLastError();
        goto FnExit;
    }

    //
    //  If the caller-supplied buffer is not big enough to hold the
    //  path value, then return an error
    //
    if ( dwLen > dwBufSize )
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

    //
    //  Replace the last '\\' character in the image path with
    //  a NULL character
    //
    pTemp = wcsrchr( lpBuffer, L'\\' );
    if ( pTemp != NULL )
    {
        *pTemp = L'\0';
    } else
    {
        dwStatus = ERROR_INVALID_PARAMETER;
        goto FnExit;
    }

FnExit:
    LocalFree( szRegKeyName );
    if( hClusSvcKey != NULL )
    {
        RegCloseKey( hClusSvcKey );
    }
    LocalFree( lpImagePath );

    return( dwStatus );
} // ClRtlGetClusterDirectory

BOOL
ClRtlGetDriveLayoutTable(
    IN  HANDLE hDisk,
    OUT PDRIVE_LAYOUT_INFORMATION * DriveLayout,
    OUT PDWORD InfoSize OPTIONAL
    )

/*++

Routine Description:

    Get the partition table for a drive. If the buffer is not large enough,
    then realloc until we get the right sized buffer. This routine is not in
    disk.cpp since that causes additional symbols to be defined.

Arguments:

    hDisk - handle to a file on the partition

    DriveLayout - address of pointer that points to

    InfoSize - address of dword that receives size of partition table

Return Value:

    TRUE if everything went ok

--*/

{
    DWORD dwSize = 0;
    PDRIVE_LAYOUT_INFORMATION driveLayout;
    DWORD status = ERROR_INSUFFICIENT_BUFFER;
    DWORD partitionCount = 4;
    DWORD layoutSize;

    while ( status == ERROR_INSUFFICIENT_BUFFER
         || status == ERROR_BAD_LENGTH
          )
    {

        layoutSize = sizeof(DRIVE_LAYOUT_INFORMATION) +
                     (sizeof(PARTITION_INFORMATION) * partitionCount);
        if ( layoutSize > 2<<16 ) {
            break;
        }

        driveLayout = (PDRIVE_LAYOUT_INFORMATION)LocalAlloc( LMEM_FIXED, layoutSize );
        if ( driveLayout == NULL ) {
            break;
        }

        if (DeviceIoControl(hDisk,
                            IOCTL_DISK_GET_DRIVE_LAYOUT,
                            NULL,
                            0,
                            driveLayout,
                            layoutSize,
                            &dwSize,
                            NULL))
        {
            status = ERROR_SUCCESS;
            break;
        } else {
            status = GetLastError();
            LocalFree( driveLayout );
            driveLayout = NULL;
            partitionCount *= 2;
        }
    }

    *DriveLayout = driveLayout;
    if ( ARGUMENT_PRESENT( InfoSize )) {
        *InfoSize = dwSize;
    }

    return status == ERROR_SUCCESS ? TRUE : FALSE;

} // ClRtlGetDriveLayoutTable


BOOL
ClRtlPathFileExists(
    LPWSTR pwszPath
    )
/*++

Routine Description:

    Determines if a file/directory exists.  This is fast.

Arguments:

    pwszPath - Path to validate.

Return Value:

    TRUE if it exists, otherwise FALSE.

    NOTE: This was borrowed from SHLWAPI.

--*/
{
   DWORD dwErrMode;
   BOOL fResult;

   dwErrMode = SetErrorMode( SEM_FAILCRITICALERRORS );

   fResult = ( (UINT) GetFileAttributes( pwszPath ) != (UINT) -1 );

   SetErrorMode( dwErrMode );

   return fResult;

}


DWORD
SetClusterFailureInformation(
    LPWSTR  NodeName OPTIONAL,
    DWORD   ResetPeriod,
    LONG    RetryCount,
    DWORD   RetryInterval
    )

/*++

Routine Description:

    Set the SC failure parameters for the cluster service.

Arguments:

    The args are loosely similar to the members of the SERVICE_FAILURE_ACTIONS
    structure. If RetryCount equals -1, then we set up a series of actions
    where the SC will exponentially back off restarting the service until it
    reaches 5 minutes, where it will continue to retry forever (well, until
    something good or bad happens). Otherwise, if RetryCount is positive, then
    we'll retry that many times (and zero is a valid number of retries) still
    using the same back off technique.

Return Value:

    ERROR_SUCCESS if everything worked ok

--*/

{
    DWORD status;
    BOOL success;
    HANDLE schSCManager;
    HANDLE serviceHandle;
    SERVICE_FAILURE_ACTIONS failureData;
    LPSC_ACTION failureActions;
    LONG i;
    BOOL tryForever = FALSE;

    CL_ASSERT( RetryCount >= -1 && RetryCount <= CLUSTER_FAILURE_MAX_STARTUP_RETRIES );

    ++RetryCount;   // add one more for the final action
    if ( RetryCount == 0 ) {
        DWORD tempInterval = RetryInterval;

        //
        // count the entries we need to go from our initial retry interval to
        // the final (longest) retry interval.
        //
        while ( tempInterval < CLUSTER_FAILURE_FINAL_RETRY_INTERVAL ) {
            tempInterval *= 2;
            ++RetryCount;
        }

        ++RetryCount;
        tryForever = TRUE;
    }
    CL_ASSERT( RetryCount > 0 );

    //
    // open the SC mgr and the service
    //

    schSCManager = OpenSCManager(NodeName,
                                 NULL,                   // database (NULL == default)
                                 SC_MANAGER_ALL_ACCESS); // access required

    if ( schSCManager ) {
        serviceHandle = OpenService(schSCManager,
                                    CLUSTER_SERVICE_NAME,
                                    SERVICE_ALL_ACCESS);

        if ( serviceHandle ) {

            failureActions = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                         RetryCount * sizeof( SC_ACTION ));
            if ( failureActions != NULL ) {

                //
                // build a list that exponentially backs off but does
                // exactly the number of retries that were specified.
                //

                for ( i = 0; i < RetryCount-1; ++i ) {
                    failureActions[i].Type = SC_ACTION_RESTART;
                    failureActions[i].Delay = RetryInterval;

                    RetryInterval = RetryInterval * 2;
                    if ( RetryInterval > CLUSTER_FAILURE_FINAL_RETRY_INTERVAL ) {
                        RetryInterval = CLUSTER_FAILURE_FINAL_RETRY_INTERVAL;
                    }
                }

                if ( tryForever ) {
                    failureActions[i].Type = SC_ACTION_RESTART;
                    failureActions[i].Delay = RetryInterval;
                } else {
                    failureActions[i].Type = SC_ACTION_NONE;
                    failureActions[i].Delay = 0;
                }

                failureData.dwResetPeriod = ResetPeriod;
                failureData.lpRebootMsg = NULL;
                failureData.lpCommand = NULL;
                failureData.cActions = RetryCount;
                failureData.lpsaActions = failureActions;

                success = ChangeServiceConfig2(serviceHandle,
                                               SERVICE_CONFIG_FAILURE_ACTIONS,
                                               &failureData);
                LocalFree( failureActions );

                if ( success ) {
                    status = ERROR_SUCCESS;
                } else {
                    status = GetLastError();
                    ClRtlDbgPrint(LOG_CRITICAL,"[ClRtl] Couldn't set SC failure info %1!u!\n", status);
                }
            } else {
                status = ERROR_OUTOFMEMORY;
                ClRtlDbgPrint(LOG_CRITICAL,"[ClRtl] Couldn't allocate memory to set SM Failure actions\n");
            }

            CloseServiceHandle( serviceHandle );
        } else {
            status = GetLastError();
            ClRtlDbgPrint(LOG_CRITICAL,"[ClRtl] Couldn't get SC handle to Cluster Service %1!u!\n", status);
        }

        CloseServiceHandle( schSCManager );
    } else {
        status = GetLastError();
        ClRtlDbgPrint(LOG_CRITICAL,"[ClRtl] Couldn't get a handle to the SC Manager %1!u!\n", status);
    }

    return status;
} // SetClusterFailureInformation

DWORD
ClRtlSetSCMFailureActions(
    LPWSTR NodeName OPTIONAL
    )

/*++

Routine Description:

    Set the service controller failure parameters for the cluster service.

Arguments:

    NodeName - pointer to string that identifies on which node to modify the
    settings. NULL indicates the local node.

Return Value:

    ERROR_SUCCESS if everything worked ok

--*/

{
    DWORD Status;

    //
    // during startup, we start with a short retry period and then
    // exponentially back off. Set the reset period to 30 minutes.
    //
    Status = SetClusterFailureInformation(NodeName,
                                          30 * 60,
                                          CLUSTER_FAILURE_RETRY_COUNT,
                                          CLUSTER_FAILURE_INITIAL_RETRY_INTERVAL);

    if ( Status != ERROR_SUCCESS ) {
        ClRtlDbgPrint(LOG_CRITICAL,
                      "[ClRtl] Couldn't set SC startup failure info %1!u!\n",
                      Status);
    }

    return Status;
} // ClRtlSetSCMFailureActions


DWORD
ClRtlGetRunningAccountInfo(
    LPWSTR *    AccountBuffer
    )

/*++

Routine Description:

    Get the calling thread's token to obtain account info. It is returned in
    an allocated buffer in the form of "domain\user". Caller is responsible
    for freeing the buffer.

Arguments:

    AccountBuffer - address of pointer to receive allocated buffer

Return Value:

    ERROR_SUCCESS if everything worked ok

--*/

{
    HANDLE          currentToken;
    PTOKEN_USER     tokenUserData;
    DWORD           sizeRequired;
    BOOL            success;
    DWORD           status = ERROR_SUCCESS;
    DWORD           accountNameSize = 128;
    LPWSTR          accountName;
    DWORD           domainNameSize = DNS_MAX_NAME_BUFFER_LENGTH;
    LPWSTR          domainName;
    SID_NAME_USE    sidType;
    DWORD           nameSize = 0;
    HMODULE         secur32Handle;
    FARPROC         getUserNameEx;
    INT_PTR         returnValue;

    //
    // initialize in case the caller doesn't check the return status (tsk, tsk!)
    //
    *AccountBuffer = NULL;

    //
    // rather than link in yet another DLL, we'll load secur32 dynamically and
    // get a pointer to GetUserNameEx.
    //
    secur32Handle = LoadLibraryW( L"secur32.dll" );
    if ( secur32Handle ) {
        getUserNameEx = GetProcAddress( secur32Handle, "GetUserNameExW" );
        if ( getUserNameEx ) {
            //
            // get the length the first time, allocate a buffer and then get the data
            //
            returnValue = (*getUserNameEx)( NameSamCompatible, NULL, &nameSize );
            success = (BOOL)returnValue;

            *AccountBuffer = LocalAlloc( LMEM_FIXED, nameSize * sizeof( WCHAR ));
            if ( *AccountBuffer != NULL ) {

                returnValue = (*getUserNameEx)( NameSamCompatible, *AccountBuffer, &nameSize );
                success = (BOOL)returnValue;
                if ( !success ) {
                    status = GetLastError();
                }
            }
            else {
                status = GetLastError();
            }
        } else {
            status = GetLastError();
        }

        FreeLibrary( secur32Handle );
    }
    else {
        status = GetLastError();
    }

    return status;

#if 0
    //
    // check if there is a thread token
    //
    if (!OpenThreadToken(GetCurrentThread(),
                         MAXIMUM_ALLOWED,
                         TRUE,
                         &currentToken))
    {
        // get the process token
        if (!OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &currentToken )) {
            return GetLastError();
        }
    }

    //
    // get the size needed
    //
    success = GetTokenInformation(currentToken,
                                  TokenUser,
                                  NULL,
                                  0,
                                  &sizeRequired);

    tokenUserData = LocalAlloc( LMEM_FIXED, sizeRequired );
    if ( tokenUserData == NULL ) {
        CloseHandle( currentToken );
        return GetLastError();
    }

    success = GetTokenInformation(currentToken,
                                  TokenUser,
                                  tokenUserData,
                                  sizeRequired,
                                  &sizeRequired);

    if ( !success ) {
        CloseHandle( currentToken );
        return GetLastError();
    }

    do {
        //
        // make initial allocs for account and domain name; 1 more byte to
        // hold slash separator. domain buffer holds the complete
        // 'domain\user' entry so it gets more space
        //
        domainName = LocalAlloc( LMEM_FIXED,
                                     (accountNameSize + domainNameSize + 1) * sizeof(WCHAR) );
        accountName = (LPWSTR) LocalAlloc( LMEM_FIXED, accountNameSize * sizeof(WCHAR) );

        if ( accountName == NULL || domainName == NULL ) {
            if ( accountName != NULL ) {
                LocalFree( accountName );
            }

            if ( domainName != NULL ) {
                LocalFree( domainName );
            }

            return ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // Attempt to Retrieve the account and domain name. If
        // LookupAccountName fails because of insufficient buffer size(s)
        // accountNameSize and domainNameSize will be correctly set for the
        // next attempt.
        //
        if ( LookupAccountSid(NULL,
                              tokenUserData->User.Sid,
                              accountName,
                              &accountNameSize,
                              domainName,
                              &domainNameSize,
                              &sidType ))
        {
            wcscat( domainName, L"\\" );
            wcscat( domainName, accountName );
            *AccountBuffer = domainName;
        }
        else {
            // free the account name buffer and find out why we failed
            LocalFree( domainName );

            status = GetLastError();
        }

        //
        // domain buffer holds complete string so we can lose the account name
        // at this point
        //
        LocalFree( accountName );
        accountName = NULL;

    } while ( status == ERROR_INSUFFICIENT_BUFFER );

    return status;
#endif

} // ClRtlGetRunningAccountInfo

#if 0
//
// no longer needed. Keep it around just in case
//
DWORD
ClRtlGetServiceAccountInfo(
    LPWSTR *    AccountBuffer
    )

/*++

Routine Description:

    Query SCM for the cluster service account info. It is returned in an
    allocated buffer in the form of "domain\user". Caller is responsible for
    freeing the buffer.

Arguments:

    AccountBuffer - address of pointer to receive allocated buffer

Return Value:

    ERROR_SUCCESS if everything worked ok

--*/

{
    DWORD status = ERROR_SUCCESS;
    HANDLE schSCManager;
    HANDLE serviceHandle = NULL;
    LPQUERY_SERVICE_CONFIG scConfigData = NULL;
    ULONG bytesNeeded;
    BOOL success;

    //
    // open a handle to the service controller manager to query the account
    // under which the cluster service was started
    //

    schSCManager = OpenSCManager(NULL,                   // machine (NULL == local)
                                 NULL,                   // database (NULL == default)
                                 SC_MANAGER_ALL_ACCESS); // access required

    if ( schSCManager == NULL ) {
        status = GetLastError();
        goto error_exit;
    }

    serviceHandle = OpenService(schSCManager,
                                CLUSTER_SERVICE_NAME,
                                SERVICE_ALL_ACCESS);

    if ( serviceHandle == NULL ) {
        status = GetLastError();
        goto error_exit;
    }

    success = QueryServiceConfig(serviceHandle, NULL, 0, &bytesNeeded);
    if ( !success ) {
        status = GetLastError();
        if ( status != ERROR_INSUFFICIENT_BUFFER ) {
            goto error_exit;
        } else {
            status = ERROR_SUCCESS;
        }
    }

    scConfigData = LocalAlloc( LMEM_FIXED, bytesNeeded );
    if ( scConfigData == NULL ) {
        status = GetLastError();
        goto error_exit;
    }

    success = QueryServiceConfig(serviceHandle,
                                 scConfigData,
                                 bytesNeeded,
                                 &bytesNeeded);
    if ( !success ) {
        status = GetLastError();
        goto error_exit;
    }

    *AccountBuffer = LocalAlloc(LMEM_FIXED,
                                (wcslen( scConfigData->lpServiceStartName ) + 1 ) * sizeof(WCHAR));

    if ( *AccountBuffer == NULL ) {
        status = GetLastError();
        goto error_exit;
    }

    wcscpy( *AccountBuffer, scConfigData->lpServiceStartName );

error_exit:
    if ( serviceHandle != NULL ) {
        CloseServiceHandle( serviceHandle );
    }

    if ( schSCManager != NULL ) {
        CloseServiceHandle( schSCManager );
    }

    if ( scConfigData != NULL ) {
        LocalFree( scConfigData );
    }

    return status;
} // ClRtlGetServiceAccountInfo
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\disk.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    disk.h

Abstract:

    Interface for routines that query and manipulate the
    disk configuration of the current system.

Author:

    John Vert (jvert) 10/10/1996

Revision History:

--*/

#ifndef _CLUSRTL_DISK_H_
#define _CLUSRTL_DISK_H_

#ifdef __cplusplus
extern "C" {
#endif
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus

#ifndef __AFX_H__
#undef ASSERT               // make afx.h happy
#endif

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcmn.h>         // MFC support for Windows 95 Common Controls

#include "afxtempl.h"

#include "winioctl.h"
#include "ntddscsi.h"
#include "ntdskreg.h"
#include "ntddft.h"
#include "ntddstor.h"

//
// classes representing info stored in Machine\System\Disk\Information
// registry key
//
class CFtInfoPartition {
public:
    // initialize from registry data
    CFtInfoPartition(class CFtInfoDisk *Disk, DISK_PARTITION UNALIGNED *Description);

    // initialize from data on disk
    CFtInfoPartition(class CFtInfoDisk *Disk, class CPhysicalPartition *Partition);
    CFtInfoPartition(class CFtInfoDisk *Disk, PARTITION_INFORMATION *PartitionInfo);

    ~CFtInfoPartition();

    VOID GetData(PDISK_PARTITION pDest);

    DWORD GetOffset();
    VOID SetOffset(DWORD NewOffset) {m_RelativeOffset = NewOffset;};
    VOID MakeSticky(UCHAR DriveLetter);

    BOOL IsFtPartition() { return(m_PartitionInfo->FtType != NotAnFtMember);};

    DISK_PARTITION UNALIGNED *m_PartitionInfo;
    class CFtInfoDisk *m_ParentDisk;

private:
    DWORD m_RelativeOffset;         // relative offset from parent DISK_DESCRIPTION
    BOOL m_Modified;
};

class CFtInfoDisk {
public:
    // initialize from registry data
    CFtInfoDisk(DISK_DESCRIPTION UNALIGNED *Description);

    // initialize from data on disk
    CFtInfoDisk(class CPhysicalDisk *Disk);
    CFtInfoDisk(DRIVE_LAYOUT_INFORMATION *DriveLayoutData);

    // ?
    CFtInfoDisk(CFtInfoDisk *DiskInfo);

    ~CFtInfoDisk();

    //
    // Overloaded operators
    //
    BOOL operator==(const CFtInfoDisk& Disk1);

    CFtInfoPartition *GetPartition(LARGE_INTEGER StartingOffset,
                                   LARGE_INTEGER Length);
    CFtInfoPartition *GetPartitionByOffset(DWORD Offset);
    CFtInfoPartition *GetPartitionByIndex(DWORD Index);
    DWORD FtPartitionCount();

    DWORD GetSize();
    VOID GetData(PBYTE pDest);

    DWORD GetOffset() {return m_Offset;};
    VOID SetOffset(DWORD NewOffset) {m_Offset = NewOffset;};

    DWORD m_PartitionCount;
    DWORD m_Signature;
private:
    DWORD m_Offset;
    CTypedPtrList<CPtrList, CFtInfoPartition*> m_PartitionInfo;
};

//
// class representing FTDISK registry information. Currently not used
//
class CFtInfoFtSet {
public:
    CFtInfoFtSet() { m_FtDescription = NULL; }
    ~CFtInfoFtSet();

    //
    // Initialization
    //
    BOOL Initialize(USHORT Type, FT_STATE FtVolumeState);
    BOOL Initialize(class CFtInfo *FtInfo, PFT_DESCRIPTION Description);

    //
    // Overloaded operators
    //
    BOOL operator==(const CFtInfoFtSet& FtSet1);

    DWORD GetSize() const;
    VOID GetData(PBYTE pDest);
    DWORD GetMemberCount() const { return((DWORD)m_Members.GetSize()); };

    BOOL IsAlone();

    DWORD AddMember(CFtInfoPartition *Partition, PFT_MEMBER_DESCRIPTION Description, USHORT FtGroup);

    CFtInfoPartition *GetMemberBySignature (DWORD Signature) const;
    CFtInfoPartition *GetMemberByIndex (DWORD Index) const;
    PFT_MEMBER_DESCRIPTION GetMemberDescription(DWORD Index) {
        return(&m_FtDescription->FtMemberDescription[Index]);
    };

    USHORT GetType() const {return(m_FtDescription->Type);};
    FT_STATE GetState() const {return(m_FtDescription->FtVolumeState);};

private:
    BOOL m_Modified;
    PFT_DESCRIPTION m_FtDescription;
    CTypedPtrArray<CPtrArray, CFtInfoPartition*> m_Members;
};

//
// main registry info class. holds lists of disk and ftset registry info along
// with methods for extracting info from lists
//
class CFtInfo {
public:
    CFtInfo();
    CFtInfo(HKEY hKey, LPWSTR lpszValueName);
    CFtInfo(PDISK_CONFIG_HEADER Header);
    CFtInfo(CFtInfoFtSet *FtSet);
    ~CFtInfo();

    //
    // commit changes to FtInfo database to the registry
    //

    DWORD CommitRegistryData();

    DWORD GetSize();
    VOID GetData(PDISK_CONFIG_HEADER pDest);

    CFtInfoPartition *FindPartition(DWORD Signature,
                                    LARGE_INTEGER StartingOffset,
                                    LARGE_INTEGER Length);
    CFtInfoPartition *FindPartition(UCHAR DriveLetter);

    CFtInfoDisk *FindDiskInfo(DWORD Signature);
    CFtInfoDisk *EnumDiskInfo(DWORD Index);

    VOID AddDiskInfo(CFtInfoDisk *NewDisk) { m_DiskInfo.AddTail( NewDisk ); }

    VOID SetDiskInfo(CFtInfoDisk *NewDisk);
    BOOL DeleteDiskInfo(DWORD Signature);

    CFtInfoFtSet *EnumFtSetInfo(DWORD Index);
    CFtInfoFtSet *FindFtSetInfo(DWORD Signature);
    BOOL DeleteFtSetInfo(CFtInfoFtSet *FtSet);
    VOID AddFtSetInfo(CFtInfoFtSet *FtSet, CFtInfoFtSet *OldFtSet = NULL);

private:
    CTypedPtrList<CPtrList, CFtInfoDisk*> m_DiskInfo;
    CTypedPtrList<CPtrList, CFtInfoFtSet*> m_FtSetInfo;
    VOID Initialize(HKEY hKey, LPWSTR lpszValueName);
    VOID Initialize(PDISK_CONFIG_HEADER Header, DWORD Length);
    VOID Initialize();

public:
    LPBYTE m_buffer;
    DWORD m_bufferLength;

};

//
// disk and related partition classes built from actual probing of disks via
// IOCTLs and other disk APIs. This info is built "bottom up" in that the disk
// config is discovered via the SetupDi APIs
//
class CPhysicalDisk  {
public:
    CPhysicalDisk() { m_FtInfo = NULL; }
    DWORD Initialize(CFtInfo *FtInfo, LPWSTR DeviceName);

    BOOL IsSticky();
    DWORD MakeSticky(CFtInfo *FtInfo);
    BOOL IsNTFS();
    DWORD FtPartitionCount() {
        if (m_FtInfo == NULL) {
            return(0);
        } else {
            return(m_FtInfo->FtPartitionCount());
        }
    };

    DWORD m_PartitionCount;
    DWORD m_Signature;
    DWORD m_DiskNumber;
    BOOL m_IsSCSI;
    BOOL m_IsRemovable;
    CTypedPtrList<CPtrList, class CPhysicalPartition*> m_PartitionList;
    CTypedPtrList<CPtrList, class CLogicalDrive*> m_LogicalDriveList;
    BOOL ShareBus(CPhysicalDisk *OtherDisk);
    SCSI_ADDRESS m_ScsiAddress;
    CString m_Identifier;
    CFtInfoDisk *m_FtInfo;


private:
    HANDLE GetPhysicalDriveHandle(DWORD Access);
    HANDLE GetPhysicalDriveHandle(DWORD Access, LPWSTR DeviceName);
};


class CPhysicalPartition {
public:
    CPhysicalPartition(CPhysicalDisk *Disk, PPARTITION_INFORMATION Info);

    CPhysicalDisk *m_PhysicalDisk;
    PARTITION_INFORMATION m_Info;
    CFtInfoPartition *m_FtPartitionInfo;
};

//
// class representing a drive as represented by a drive letter. built in a
// "top down" fashion in that each drive letter is examined to determine the
// physical partition to which the letter is mapped. This structure only
// exists if the logical drive is a real disk, i.e., not built for CDROMs,
// etc.
//
class CLogicalDrive  {

public:
    CLogicalDrive() {
        m_Partition = NULL;
        m_ContainerSet = NULL;
    }
    BOOL Initialize(CPhysicalPartition *Partition);
    BOOL IsSCSI(VOID);
    BOOL ShareBus(CLogicalDrive *OtherDrive);

    DWORD MakeSticky();

    WCHAR m_DriveLetter;
    CString m_VolumeLabel;
    CString m_Identifier;
    BOOL m_IsNTFS;
    BOOL m_IsSticky;
    CPhysicalPartition *m_Partition;
    class CFtSet *m_ContainerSet;
};

//
// logical class for FT sets. not used
//
class CFtSet {
public:
    CFtSet() { m_FtInfo = NULL; }
    BOOL Initialize(class CDiskConfig *Config, CFtInfoFtSet *FtInfo);
    CFtInfoFtSet *m_FtInfo;
    DWORD MakeSticky();
    BOOL IsSticky(VOID);
    BOOL IsNTFS(VOID);
    BOOL IsSCSI(VOID);
    BOOL ShareBus(CLogicalDrive *OtherDrive);
    CTypedPtrList<CPtrList, CLogicalDrive*> m_OtherVolumes;
    CLogicalDrive Volume;
    CTypedPtrList<CPtrList, CPhysicalPartition*> m_Member;
};

//
// main disk configuration class.
//
class CDiskConfig {

public:
    CDiskConfig() { m_SystemVolume = NULL; }
    ~CDiskConfig();
    BOOL Initialize(VOID);

    CTypedPtrList<CPtrList, CFtSet*> m_FtSetList;

    // database of physical drives indexed by drive number.
    CMap<int, int, CPhysicalDisk*, CPhysicalDisk*&> m_PhysicalDisks;

    // database of logical drives indexed by drive letter
    CMap<WCHAR, WCHAR, CLogicalDrive*, CLogicalDrive*&> m_LogicalDrives;

    VOID RemoveAllFtInfoData();
    VOID RemoveDisk(CPhysicalDisk *Disk);
    DWORD MakeSticky(CPhysicalDisk *Disk);
    DWORD MakeSticky(CFtSet *FtSet);
    VOID SetDiskInfo(CFtInfoDisk *NewDisk) {
        m_FTInfo.DeleteDiskInfo(NewDisk->m_Signature);
        m_FTInfo.SetDiskInfo(NewDisk);
        m_FTInfo.CommitRegistryData();
    };

    CPhysicalPartition *FindPartition(CFtInfoPartition *FtPartition);
    BOOL OnSystemBus(CPhysicalDisk *Disk);
    BOOL OnSystemBus(CFtSet *FtSet);
    DWORD MakeSystemDriveSticky() {
        if (m_SystemVolume) {
            return(MakeSticky(m_SystemVolume->m_Partition->m_PhysicalDisk));
        } else {
            return(ERROR_SUCCESS);
        }
    };

    CLogicalDrive *m_SystemVolume;

private:
    CFtInfo m_FTInfo;

};

typedef  struct _DRIVE_LETTER_INFO {
    UINT DriveType;
    STORAGE_DEVICE_NUMBER DeviceNumber;
} DRIVE_LETTER_INFO, *PDRIVE_LETTER_INFO;

extern DRIVE_LETTER_INFO DriveLetterMap[];

#endif


// Some handy C wrappers for the C++ stuff.
//
#ifdef __cplusplus
extern "C" {
#endif

typedef struct _FT_INFO *PFT_INFO;
typedef struct _FULL_FTSET_INFO *PFULL_FTSET_INFO;

typedef struct _FT_DISK_INFO *PFT_DISK_INFO;

typedef struct _DISK_INFO *PDISK_INFO;
typedef struct _FULL_DISK_INFO *PFULL_DISK_INFO;

PFT_INFO
DiskGetFtInfo(
    VOID
    );

VOID
DiskFreeFtInfo(
    PFT_INFO FtInfo
    );

DWORD
DiskEnumFtSetSignature(
    IN PFULL_FTSET_INFO FtSet,
    IN DWORD MemberIndex,
    OUT LPDWORD MemberSignature
    );

DWORD
DiskSetFullFtSetInfo(
    IN PFT_INFO FtInfo,
    IN PFULL_FTSET_INFO FtSet
    );

PFULL_FTSET_INFO
DiskGetFullFtSetInfo(
    IN PFT_INFO FtInfo,
    IN LPCWSTR lpszMemberList,
    OUT LPDWORD pSize
    );

PFULL_FTSET_INFO
DiskGetFullFtSetInfoByIndex(
    IN PFT_INFO FtInfo,
    IN DWORD Index,
    OUT LPDWORD pSize
    );

VOID
DiskMarkFullFtSetDirty(
    IN PFULL_FTSET_INFO FtSet
    );

DWORD
DiskDeleteFullFtSetInfo(
    IN PFT_INFO FtInfo,
    IN LPCWSTR lpszMemberList
    );

BOOL
DiskFtInfoEqual(
    IN PFULL_FTSET_INFO Info1,
    IN PFULL_FTSET_INFO Info2
    );

FT_TYPE
DiskFtInfoGetType(
    IN PFULL_FTSET_INFO Info
    );

BOOL
DiskCheckFtSetLetters(
    IN PFT_INFO FtInfo,
    IN PFULL_FTSET_INFO Bytes,
    OUT WCHAR *Letter
    );

DWORD
DiskSetFullDiskInfo(
    IN PFT_INFO FtInfo,
    IN PFULL_DISK_INFO Bytes
    );

PFULL_DISK_INFO
DiskGetFullDiskInfo(
    IN PFT_INFO FtInfo,
    IN DWORD Signature,
    OUT LPDWORD pSize
    );

enum {
   DISKRTL_REPLACE_IF_EXISTS = 0x1,
   DISKRTL_COMMIT            = 0x2,
};

DWORD
DiskAddDiskInfoEx(
    IN PFT_INFO DiskInfo,
    IN DWORD DiskIndex,
    IN DWORD Signature,
    IN DWORD Options
    );


DWORD
DiskAddDriveLetterEx(
    IN PFT_INFO DiskInfo,
    IN DWORD Signature,
    IN LARGE_INTEGER StartingOffset,
    IN LARGE_INTEGER PartitionLength,
    IN UCHAR DriveLetter,
    IN DWORD Options
    );

DWORD
DiskCommitFtInfo(
    IN PFT_INFO FtInfo
    );

PFT_INFO
DiskGetFtInfoFromFullDiskinfo(
    IN PFULL_DISK_INFO Bytes
    );

PFT_DISK_INFO
FtInfo_GetFtDiskInfoBySignature(
    IN PFT_INFO FtInfo,
    IN DWORD Signature
    );

DISK_PARTITION UNALIGNED *
FtDiskInfo_GetPartitionInfoByIndex(
    IN PFT_DISK_INFO DiskInfo,
    IN DWORD         Index
    );

DWORD
FtDiskInfo_GetPartitionCount(
    IN PFT_DISK_INFO DiskInfo
    );

//
// Error handlers to be defined by the user of this library
//
VOID
DiskErrorFatal(
    INT MessageId,
    DWORD Error,
    LPSTR File,
    DWORD Line
    );

VOID
DiskErrorLogInfo(
    LPSTR String,
    ...
    );

#ifdef __cplusplus
}
#endif

#endif // _CLUSRTL_DISK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\dsutils.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1998 Microsoft Corporation
//
//	Module Name:
//		DsUtils.h
//
//	Abstract:
//		Active Directory Service (ADS) utilities.
//
//	Author:
//		Galen Barbee	(galenb)	April 17, 1998
//
//	Revision History:
//
//	Notes:
//
/////////////////////////////////////////////////////////////////////////////

#ifndef _DSUTILS_H_
#define _DSUTILS_H_

void
DsUtlAddClusterNameToDS(
	const TCHAR *pClusterName,
	const TCHAR *pNodeName
);

#endif	// _DSUTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\disk.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    disk.c

Abstract:

    Routines that query and manipulate the
    disk configuration of the current system.

Author:

    John Vert (jvert) 10/10/1996

Revision History:

--*/
#include "disk.h"
#include <ntddvol.h>
#include <devguid.h>
#include <setupapi.h>
#include "clusrtl.h"

/*

NT5 porting notes - Charlie Wickham (2/10/98)

I tried to touch as little of this as possible since there is alot of code
here. Two major differences on NT5 are: 1) the System\Disk key is no longer
used as the central "database" of disk configuration information and 2) all
drive letters are sticky on NT5.

NT5 Clusters still needs a central point of information (such as DISK key)
since the joining node cannot determine anything about the disk configuration
when the disks are reserved by the sponsor.

Later... (3/29/99)

Much has changed since I wrote the first blurb above a year ago. This code has
been patched to keep up with the changes with slight improvements made due to
the ever changing NT5 landscape with regard to supported storage types.

*/

#if 1
#define DISKERR(_MsgId_, _Err_) (DiskErrorFatal((0),(_Err_),__FILE__, __LINE__))
#define DISKLOG(_x_) DiskErrorLogInfo _x_
#define DISKASSERT(_x_) if (!(_x_)) DISKERR(IDS_GENERAL_FAILURE,ERROR_INVALID_PARAMETER)
#else
#define DISKERR(x,y)
#define DISKLOG(_x_)
#define DISKASSERT(_x_)
#endif

//
// array that maps disk and partition numbers to drive letters. This
// facilitates figuring out which drive letters are associated with a drive
// and reduces the amount of calls to CreateFile dramatically. The array is
// indexed by drive letter.
//
DRIVE_LETTER_INFO DriveLetterMap[26];

//
// Some handy registry utility routines
//
BOOL
GetRegValue(
    IN HKEY hKey,
    IN LPCWSTR Name,
    OUT LPBYTE *Value,
    OUT LPDWORD Length
    )
{
    LPBYTE Data = NULL;
    DWORD cbData=0;
    LONG Status;

    //
    // Call once to find the required size.
    //
    Status = RegQueryValueExW(hKey,
                              Name,
                              NULL,
                              NULL,
                              NULL,
                              &cbData);
    if (Status != ERROR_SUCCESS) {
        SetLastError(Status);
        return(FALSE);
    }

    //
    // Allocate the buffer and call again to get the data.
    //
retry:
    Data = (LPBYTE)LocalAlloc(LMEM_FIXED, cbData);;
    if (!Data) {
        Status = GetLastError();
        DISKERR(IDS_MEMORY_FAILURE, Status);
        return FALSE;
    }
    Status = RegQueryValueExW(hKey,
                              Name,
                              NULL,
                              NULL,
                              Data,
                              &cbData);
    if (Status == ERROR_MORE_DATA) {
        LocalFree(Data);
        goto retry;
    }
    if (Status != ERROR_SUCCESS) {
        SetLastError(Status);
        DISKERR(IDS_REGISTRY_FAILURE, Status);
        return FALSE;
    }
    *Value = Data;
    *Length = cbData;
    return(TRUE);
}

BOOL
MapDosVolumeToPhysicalPartition(
    CString DosVolume,
    PDRIVE_LETTER_INFO DriveInfo
    )

/*++

Routine Description:

    For a given dos volume (with the object space cruft in front of
    it), build a string that reflects the drive and partition numbers
    to which it is mapped.

Arguments:

    DosVolume - pointer to "\??\C:" style name

    DeviceInfo - pointer to buffer to receive device info data

Return Value:

    TRUE if completed successfully

--*/

{
    BOOL success = TRUE;
    HANDLE hVol;
    DWORD dwSize;
    DWORD Status;
    UINT driveType;

    DriveInfo->DriveType = GetDriveType( DosVolume );
    DISKLOG(("%ws drive type = %u\n", DosVolume, DriveInfo->DriveType ));

    if ( DriveInfo->DriveType == DRIVE_FIXED ) {
        WCHAR ntDosVolume[7] = L"\\\\.\\A:";

        ntDosVolume[4] = DosVolume[0];

        //
        // get handle to partition
        //
        hVol = CreateFile(ntDosVolume,
                          GENERIC_READ,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL);

        if (hVol == INVALID_HANDLE_VALUE) {
            return FALSE;
        }

        //
        // issue storage class ioctl to get drive and partition numbers
        // for this device
        //
        success = DeviceIoControl(hVol,
                                  IOCTL_STORAGE_GET_DEVICE_NUMBER,
                                  NULL,
                                  0,
                                  &DriveInfo->DeviceNumber,
                                  sizeof( DriveInfo->DeviceNumber ),
                                  &dwSize,
                                  NULL);

        if ( !success ) {
            DISK_EXTENT diskExtent;

            success = DeviceIoControl(hVol,
                                      IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS,
                                      NULL,
                                      0,
                                      &diskExtent,
                                      sizeof( diskExtent ),
                                      &dwSize,
                                      NULL);

            if ( success ) {
                DriveInfo->DeviceNumber.DeviceType = FILE_DEVICE_DISK;
                DriveInfo->DeviceNumber.DeviceNumber = diskExtent.DiskNumber;
                DriveInfo->DeviceNumber.PartitionNumber = 0;
            }
        }

        CloseHandle( hVol );
    }

    return success;
}

CDiskConfig::~CDiskConfig()

/*++

Description:

    Destructor for CDiskConfig. Run down the list of disks selected for
    cluster control and remove them from the DiskConfig database

Arguments:

    None
Return Value:

    None

--*/

{
    CPhysicalDisk *PhysicalDisk;
    int   diskIndex;
	POSITION pos;
	for(pos = m_PhysicalDisks.GetStartPosition(); pos;){
	    m_PhysicalDisks.GetNextAssoc(pos, diskIndex, PhysicalDisk);
		RemoveDisk(PhysicalDisk);
	}
}



BOOL
CDiskConfig::Initialize(
    VOID
    )
/*++

Routine Description:

    Build up a disk config database by poking all available disks
    on the system.

Arguments:

    None

Return Value:

    True if everything worked ok

--*/

{
    WCHAR System[3];
    DWORD Status;
    POSITION DiskPos;
    DWORD index;
    CFtInfoFtSet *FtSet;
    HDEVINFO setupDiskInfo;
    GUID diskDriveGuid = DiskClassGuid;
    CPhysicalDisk * PhysicalDisk;

    //
    // enum the disks through the SetupDi APIs and create physical disk
    // objects for them
    //
    setupDiskInfo = SetupDiGetClassDevs(&diskDriveGuid,
                                        NULL,
                                        NULL,
                                        DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);

    if (setupDiskInfo != NULL ) {
        SP_DEVICE_INTERFACE_DATA interfaceData;
        GUID classGuid = DiskClassGuid;
        BOOL success;
        PSP_DEVICE_INTERFACE_DETAIL_DATA detailData;
        DWORD detailDataSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA) + MAX_PATH * sizeof(WCHAR);
        DWORD requiredSize;

        detailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)LocalAlloc(LMEM_FIXED,
                                                                  detailDataSize);

        if ( detailData != NULL ) {
            detailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
            interfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

            for (index = 0; ; ++index ) {
                success = SetupDiEnumDeviceInterfaces(
                              setupDiskInfo,
                              NULL,
                              &diskDriveGuid,
                              index,
                              &interfaceData);

                if ( success ) {
                    success = SetupDiGetDeviceInterfaceDetail(
                                  setupDiskInfo,
                                  &interfaceData,
                                  detailData,
                                  detailDataSize,
                                  &requiredSize,
                                  NULL);

                    if ( success ) {
                        PhysicalDisk = new CPhysicalDisk;
                        if (PhysicalDisk == NULL) {
                            DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
                            break;
                        }

                        DISKLOG(("Initializing disk %ws\n", detailData->DevicePath));
                        Status = PhysicalDisk->Initialize(&m_FTInfo, detailData->DevicePath);
                        if (Status != ERROR_SUCCESS) {
                            DISKLOG(("Problem init'ing disk, status = %u\n", Status));
                            delete PhysicalDisk;
                            break;
                        }

                        //
                        // Ignore disks with no partitions.
                        //
                        if (PhysicalDisk->m_PartitionCount == 0) {
                            DISKLOG(("Partition count is zero on disk %ws\n",
                                     detailData->DevicePath));
                            delete PhysicalDisk;
                        } else {
                            DISKLOG(("Drive number = %u\n", PhysicalDisk->m_DiskNumber));
                            m_PhysicalDisks[PhysicalDisk->m_DiskNumber] = PhysicalDisk;
                        }
                    } else {
                        Status = GetLastError();
                        DISKLOG(("Couldn't get detail data, status %u\n",
                                 GetLastError()));
                    }
                } else {
                    Status = GetLastError();
                    if ( Status != ERROR_NO_MORE_ITEMS ) {
                        DISKLOG(("Couldn't enum dev IF #%u - %u\n",
                                 index, Status ));
                    }
                    break;
                }
            }
            LocalFree( detailData );
        } else {
            DISKLOG(("Couldn't get memory for detail data\n"));
            SetupDiDestroyDeviceInfoList( setupDiskInfo );
            return FALSE;
        }

        SetupDiDestroyDeviceInfoList( setupDiskInfo );
    } else {
        DISKLOG(("Couldn't get ptr to device info - %u\n", GetLastError()));
        return FALSE;
    }

    //
    // Enumerate all the FT sets in the DISK registry. Add each FT set
    // that does not share a disk with any other FT set to our list.
    //
    for (index=0; ; index++) {
        CFtSet *NewSet;
        FtSet = m_FTInfo.EnumFtSetInfo(index);
        if (FtSet == NULL) {
            break;
        }
        if (FtSet->IsAlone()) {
            NewSet = new CFtSet;
            if (NewSet == NULL) {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
                return FALSE;
            }

            DISKLOG(("Initializing FTSet %u\n", index));
            if (NewSet->Initialize(this, FtSet)) {
                m_FtSetList.AddTail(NewSet);
            } else {
                DISKLOG(("Error initializing FTSet %u\n", index));
                delete NewSet;
            }
        }
    }

    //
    // get the disk/parition numbers for all defined drive letters
    //

    DWORD DriveMap = GetLogicalDrives();
    DWORD Letter = 0;
    WCHAR DosVolume[4] = L"A:\\";

    DISKLOG(("Getting Drive Letter mappings\n"));
    while (DriveMap) {
        if ( DriveMap & 1 ) {
            DosVolume[0] = (WCHAR)(Letter + L'A');
            DISKLOG(("Mapping %ws\n", DosVolume));

            if (MapDosVolumeToPhysicalPartition(DosVolume,
                                                &DriveLetterMap[ Letter ]))
            {
                if ( DriveLetterMap[ Letter ].DriveType != DRIVE_FIXED ) {
                    DISKLOG(("%ws is not a fixed disk\n", DosVolume));
                    DriveLetterMap[ Letter ].DeviceNumber.PartitionNumber = 0;
                }
            } else {
                DISKLOG(("Can't map %ws: %u\n", DosVolume, GetLastError()));
            }
        }
        DriveMap >>= 1;
        Letter += 1;
    }

    //
    // Go through all the physical partitions and create logical
    // disk objects for each one.
    //
    int diskIndex;

    DISKLOG(("Creating Logical disk objects\n"));

    DiskPos = m_PhysicalDisks.GetStartPosition();
    while (DiskPos != NULL) {
        m_PhysicalDisks.GetNextAssoc(DiskPos, diskIndex, PhysicalDisk);

        //
        // If there are no FT partitions on this disk, create the logical
        // volumes on this disk.
        //
        if (PhysicalDisk->FtPartitionCount() == 0) {
            //
            // Go through all the partitions on this disk.
            //
            POSITION PartitionPos = PhysicalDisk->m_PartitionList.GetHeadPosition();
            CPhysicalPartition *Partition;
            while (PartitionPos != NULL) {
                Partition = PhysicalDisk->m_PartitionList.GetNext(PartitionPos);

                //
                // If the partition type is recognized, create a volume object
                // for this partition.
                //
                if ( !IsFTPartition( Partition->m_Info.PartitionType ) &&
                    (IsRecognizedPartition(Partition->m_Info.PartitionType))) {
                    CLogicalDrive *Volume = new CLogicalDrive;
                    if (Volume == NULL) {
                        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
                        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                        return FALSE;
                    }

                    DISKLOG(("Init'ing logical vol for disk %u, part %u\n",
                             Partition->m_PhysicalDisk->m_DiskNumber,
                             Partition->m_Info.PartitionNumber));

                    if (Volume->Initialize(Partition)) {
                        //
                        // Add this volume to our list.
                        //
                        m_LogicalDrives[Volume->m_DriveLetter] = Volume;
                    } else {
                        DISKLOG(("Failed init logical vol\n"));
                        delete(Volume);
                    }
                }

            }
        }
    }

    //
    // Now find the volume for the system drive
    //

    DISKLOG(("Getting system drive info\n"));
    if (GetEnvironmentVariable(L"SystemDrive",
                               System,
                               sizeof(System)/sizeof(WCHAR)) == 0) {
        DISKERR(IDS_ERR_DRIVE_CONFIG, ERROR_PATH_NOT_FOUND);
        // Need to handle this failure
    }

    if (!m_LogicalDrives.Lookup(System[0], m_SystemVolume)) {
        //
        // There are some weird cases that cause us to not find the system
        // volume. For example, the system volume is on an FT set that shares
        // a member with another FT set. So we just leave m_SystemVolume==NULL
        // and assume that no other disks in our list will be on the same bus.
        //
        m_SystemVolume = NULL;
    }

    DISKLOG(("Finished gathering disk config info\n"));
    return(TRUE);
}

VOID
CDiskConfig::RemoveAllFtInfoData(
    VOID
    )

/*++

Routine Description:

    clear out all FtInfo related data associated with each
    physical disk and physical partition instance.

Arguments:

    None

Return Value:

    None.

--*/

{
    POSITION diskPos;
    POSITION partitionPos;
    CPhysicalDisk *disk;
    CPhysicalPartition *partition;
    int Index;

    //
    // run through our list of physical disks, deleting any
    // associated FtInfo data. We enum the PhysicalDisks since
    // the back pointers to the FtInfoDisk and FtInfoPartition members
    // need to be cleared and this is the only (easy) to do that
    //

    for( diskPos = m_PhysicalDisks.GetStartPosition(); diskPos; ) {

        m_PhysicalDisks.GetNextAssoc(diskPos, Index, disk);

        if ( disk->m_FtInfo != NULL ) {

            DISKLOG(("Removing %08X from FtInfo DB\n", disk->m_Signature));
            m_FTInfo.DeleteDiskInfo( disk->m_Signature );
            disk->m_FtInfo = NULL;

            partitionPos = disk->m_PartitionList.GetHeadPosition();

            while (partitionPos) {
                partition = disk->m_PartitionList.GetNext( partitionPos );
                partition->m_FtPartitionInfo = NULL;
            }
        }
    }
}

VOID
CDiskConfig::RemoveDisk(
    IN CPhysicalDisk *Disk
    )

/*++

Description:

    walk the logical drive and physical partition lists, removing all
    structures

Arguments:

    Disk - pointer to physical disk that is being removed

Return Value:

    None

--*/

{
    CLogicalDrive *Volume;

    //
    // Remove all the logical drives on this disk.
    //
    while (!Disk->m_LogicalDriveList.IsEmpty()) {
        Volume = Disk->m_LogicalDriveList.RemoveHead();
        m_LogicalDrives.RemoveKey(Volume->m_DriveLetter);

        delete(Volume);
    }

    //
    // Remove all the physical partitions on this disk.
    //
    CPhysicalPartition *Partition;
    while (!Disk->m_PartitionList.IsEmpty()) {
        Partition = Disk->m_PartitionList.RemoveHead();
        delete(Partition);
    }

    //
    // Remove this disk
    //
    m_PhysicalDisks.RemoveKey(Disk->m_DiskNumber);

    delete(Disk);
}


CPhysicalPartition *
CDiskConfig::FindPartition(
    IN CFtInfoPartition *FtPartition
    )

/*++

Routine Description:

    Given the FtInfo description of a partition, attempts to find
    the corresponding CPhysicalPartition

Arguments:

    FtPartition - Supplies an FT partition description

Return Value:

    A pointer to the CPhysicalPartition if successful

    NULL otherwise

--*/

{
    POSITION pos;
    CPhysicalDisk *Disk;
    CPhysicalPartition *Partition;
    int DiskIndex;
    BOOL Found = FALSE;

    //
    // First find the appropriate CPhysicalDisk
    //
    pos = m_PhysicalDisks.GetStartPosition();
    while (pos) {
        m_PhysicalDisks.GetNextAssoc(pos, DiskIndex, Disk);
        if (Disk->m_FtInfo) {
            if (Disk->m_FtInfo->m_Signature == FtPartition->m_ParentDisk->m_Signature) {
                Found = TRUE;
                break;
            }
        }
    }
    if (!Found) {
        return(FALSE);
    }

    //
    // Now find the appropriate CPhysicalPartition in this disk.
    //
    pos = Disk->m_PartitionList.GetHeadPosition();
    while (pos) {
        Partition = Disk->m_PartitionList.GetNext(pos);
        if (Partition->m_FtPartitionInfo == FtPartition) {
            //
            // Found a match!
            //
            return(Partition);
        }
    }

    return(FALSE);
}

DWORD
CDiskConfig::MakeSticky(
    IN CPhysicalDisk *Disk
    )
{
    DWORD Status;

    Status = Disk->MakeSticky(&m_FTInfo);
    if (Status == ERROR_SUCCESS) {
        Status = m_FTInfo.CommitRegistryData();
    }
    return(Status);
}

DWORD
CDiskConfig::MakeSticky(
    IN CFtSet *FtSet
    )
{
    DWORD Status;

    Status = FtSet->MakeSticky();
    if (Status == ERROR_SUCCESS) {
        Status = m_FTInfo.CommitRegistryData();
    }
    return(Status);
}

BOOL
CDiskConfig::OnSystemBus(
    IN CPhysicalDisk *Disk
    )
{
    CPhysicalDisk *SystemDisk;

    if (m_SystemVolume == NULL) {
        return(FALSE);
    }
    SystemDisk = m_SystemVolume->m_Partition->m_PhysicalDisk;
    if (Disk == SystemDisk) {
        return(TRUE);
    }
    if (SystemDisk->ShareBus(Disk)) {
        return(TRUE);
    }
    return(FALSE);
}

BOOL
CDiskConfig::OnSystemBus(
    IN CFtSet *FtSet
    )
{

    POSITION pos = FtSet->m_Member.GetHeadPosition();
    CPhysicalPartition *Partition;

    while (pos) {
        Partition = FtSet->m_Member.GetNext(pos);
        if (OnSystemBus(Partition->m_PhysicalDisk)) {
            return(TRUE);
        }
    }

    return(FALSE);

}


//
// Functions for the logical disk object
//

BOOL
CLogicalDrive::Initialize(
    IN CPhysicalPartition *Partition
    )
/*++

Routine Description:

    Initializes a new logical disk object.

Arguments:

    Partition - Supplies the physical partition.

Return Value:

--*/

{
    CString DosVolume;
    WCHAR DriveLabel[32];
    WCHAR FsName[16];
    DWORD MaxLength;
    DWORD Flags;
    WCHAR Buff[128];
    DISK_PARTITION UNALIGNED *FtInfo;

    //
    // See if this drive has a "sticky" drive letter in the registry.
    //
    m_Partition = Partition;
    if (Partition->m_FtPartitionInfo != NULL) {
        FtInfo = Partition->m_FtPartitionInfo->m_PartitionInfo;
    } else {
        FtInfo = NULL;
    }

    if ((FtInfo) &&
        (FtInfo->AssignDriveLetter) &&
        (FtInfo->DriveLetter != 0))
    {
        m_IsSticky = TRUE;
        m_DriveLetter = (WCHAR)FtInfo->DriveLetter;
    } else {
        m_IsSticky = FALSE;

        //
        // There is no sticky drive letter for this device.  Scan through the
        // Partition/Drive Letter map looking for a matching drive letter.
        //
        DWORD letter;

        for ( letter = 0; letter < 26; ++letter ) {
            if (DriveLetterMap[ letter ].DriveType == DRIVE_FIXED
                &&
                Partition->m_PhysicalDisk->m_DiskNumber == DriveLetterMap[ letter ].DeviceNumber.DeviceNumber
                &&
                Partition->m_Info.PartitionNumber == DriveLetterMap[ letter ].DeviceNumber.PartitionNumber)
            {
                break;
            }
        }

        if ( letter == 26 ) {
            //
            // There is no drive letter for this partition.  Just ignore it.
            //
            return(FALSE);
        }
        m_DriveLetter = (WCHAR)(letter + L'A');
    }

    DosVolume = m_DriveLetter;
    DosVolume += L":\\";
    if (GetVolumeInformation(DosVolume,
                             DriveLabel,
                             sizeof(DriveLabel)/sizeof(WCHAR),
                             NULL,
                             &MaxLength,
                             &Flags,
                             FsName,
                             sizeof(FsName)/sizeof(WCHAR))) {
        if (lstrcmpi(FsName, L"NTFS")==0) {
            m_IsNTFS = TRUE;
        } else {
            m_IsNTFS = FALSE;
        }
        m_VolumeLabel = DriveLabel;
        wsprintf(Buff,
                 L"%c: (%ws)",
                 m_DriveLetter,
                 (LPCTSTR)m_VolumeLabel);
    } else {
        m_IsNTFS = TRUE; // Lie and say it is NTFS
        wsprintf(Buff,
                 L"%c: (RAW)",
                 m_DriveLetter);
    }
    m_Identifier = Buff;

    m_Partition->m_PhysicalDisk->m_LogicalDriveList.AddTail(this);
    m_ContainerSet = NULL;
    return(TRUE);
}


BOOL
CLogicalDrive::IsSCSI(
    VOID
    )
/*++

Routine Description:

    Returns whether or not a logical drive is SCSI. A logical
    drive is SCSI if all of its partitions are on SCSI drives.

Arguments:

    None.

Return Value:

    TRUE if the drive is entirely SCSI

    FALSE otherwise.

--*/

{
    return(m_Partition->m_PhysicalDisk->m_IsSCSI);
}


DWORD
CLogicalDrive::MakeSticky(
    VOID
    )
/*++

Routine Description:

    Attempts to assign a sticky drive letter to the specified volume.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if the drive was made sticky.

    Win32 error code otherwise.

--*/

{
    m_Partition->m_FtPartitionInfo->MakeSticky((UCHAR)m_DriveLetter);
    m_IsSticky = TRUE;
    return(ERROR_SUCCESS);
}


BOOL
CLogicalDrive::ShareBus(
    IN CLogicalDrive *OtherDrive
    )
/*++

Routine Description:

    Returns whether or not this drive shares a bus with another
    drive.

Arguments:

    OtherDrive - Supplies the other drive

Return Value:

    TRUE - if the drives have any of their partitions on the same bus.

    FALSE - if the drives do not hae any of their partitiosn on the same bus.

--*/

{
    PSCSI_ADDRESS MyAddress;
    PSCSI_ADDRESS OtherAddress;

    MyAddress = &m_Partition->m_PhysicalDisk->m_ScsiAddress;
    OtherAddress = &OtherDrive->m_Partition->m_PhysicalDisk->m_ScsiAddress;

    if ( (MyAddress->PortNumber == OtherAddress->PortNumber) &&
         (MyAddress->PathId == OtherAddress->PathId) ) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


//
// Functions for the physical disk object
//

DWORD
CPhysicalDisk::Initialize(
    CFtInfo *FtInfo,
    IN LPWSTR DeviceName
    )
/*++

Routine Description:

    Initializes a physical disk object

Arguments:

    FtInfo - pointer to object's FtInfo data

    DeviceName - pointer to string of device to initialize

Return Value:

    ERROR_SUCCESS if successful

--*/

{
    HKEY DiskKey;
    WCHAR Buff[100];
    DWORD BuffSize;
    DWORD dwType;
    HANDLE hDisk;
    DWORD Status;
    DWORD dwSize;
    PDRIVE_LAYOUT_INFORMATION DriveLayout;
    WCHAR KeyName[256];
    DISK_GEOMETRY Geometry;
    STORAGE_DEVICE_NUMBER deviceNumber;

    //
    // Open the physical drive and start probing it to find disk number and
    // other attributes
    //
    hDisk = GetPhysicalDriveHandle(GENERIC_READ, DeviceName);
    if (hDisk == NULL) {
        return(GetLastError());
    }

    if (!DeviceIoControl(hDisk,
                         IOCTL_STORAGE_GET_DEVICE_NUMBER,
                         NULL,
                         0,
                         &deviceNumber,
                         sizeof(deviceNumber),
                         &dwSize,
                         NULL))
    {
        Status = GetLastError();
        DISKLOG(("get device number failed for drive %ws. status = %u\n",
                 DeviceName,
                 Status));
        return Status;
    } else {
        m_DiskNumber = deviceNumber.DeviceNumber;
    }

    if (!DeviceIoControl(hDisk,
                         IOCTL_SCSI_GET_ADDRESS,
                         NULL,
                         0,
                         &m_ScsiAddress,
                         sizeof(SCSI_ADDRESS),
                         &dwSize,
                         NULL))
    {
        //
        // If the IOCTL was invalid, the drive is not a SCSI drive.
        //
        DISKLOG(("IOCTL_SCSI_GET_ADDRESS failed for drive %u. status = %u\n",
                 m_DiskNumber,
                 GetLastError()));
        m_IsSCSI = FALSE;

    } else {

        //
        // [THINKTHINK] John Vert (jvert) 10/12/1996
        //      Need some way to make sure this is really SCSI and
        //      not ATAPI?
        //
        m_IsSCSI = TRUE;

        //
        // Get the description of the disk from the registry.
        //
        wsprintf(KeyName,
                 L"HARDWARE\\DeviceMap\\Scsi\\Scsi Port %d\\Scsi Bus %d\\Target Id %d\\Logical Unit Id %d",
                 m_ScsiAddress.PortNumber,
                 m_ScsiAddress.PathId,
                 m_ScsiAddress.TargetId,
                 m_ScsiAddress.Lun);
        Status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                               KeyName,
                               0,
                               KEY_READ,
                               &DiskKey);
        if (Status != ERROR_SUCCESS) {
            DISKERR(IDS_ERR_DRIVE_CONFIG, Status);
            // [REENGINEER] Need to handle this failure //
        }
        BuffSize = sizeof(Buff);
        Status = RegQueryValueExW(DiskKey,
                                  L"Identifier",
                                  NULL,
                                  &dwType,
                                  (LPBYTE)Buff,
                                  &BuffSize);
        RegCloseKey(DiskKey);
        if (Status != ERROR_SUCCESS) {
            DISKERR(IDS_ERR_DRIVE_CONFIG, Status);
            // [REENGINEER] Need to handle this failure //
        }
        m_Identifier = Buff;

    }

    //
    // Get the drive layout.
    //
    m_PartitionCount = 0;
    if (!ClRtlGetDriveLayoutTable( hDisk, &DriveLayout, NULL )) {
        DISKLOG(("Couldn't get partition table for drive %u. status = %u\n",
                 m_DiskNumber,
                 GetLastError()));
        m_Signature = 0;
        m_FtInfo = NULL;
    } else {
        m_Signature = DriveLayout->Signature;
        //
        // Get the FT information
        //
        m_FtInfo = FtInfo->FindDiskInfo(m_Signature);

        //
        // build the partition objects.
        //
        DWORD i;
        CPhysicalPartition *Partition;
        for (i=0; i<DriveLayout->PartitionCount; i++) {
            if (DriveLayout->PartitionEntry[i].RecognizedPartition) {
                m_PartitionCount++;
                Partition = new CPhysicalPartition(this, &DriveLayout->PartitionEntry[i]);
                if (Partition != NULL) {
                    //
                    // If we have FT information for the disk, make sure we
                    // found it for each partition.  If we didn't find it for
                    // the partition, the registry is stale and doesn't match
                    // the drive layout.
                    //
                    if ((m_FtInfo != NULL) &&
                        (Partition->m_FtPartitionInfo == NULL)) {

                        //
                        // Stale registry info.  Make up some new stuff.
                        //
                        CFtInfoPartition *FtInfoPartition;
                        FtInfoPartition = new CFtInfoPartition(m_FtInfo, Partition);
                        if (FtInfoPartition == NULL) {
                            DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
                            LocalFree( DriveLayout );
                            return ERROR_NOT_ENOUGH_MEMORY;
                        }
                        Partition->m_FtPartitionInfo = FtInfoPartition;
                    }
                    m_PartitionList.AddTail(Partition);
                } else {
                    DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
                    LocalFree( DriveLayout );
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
            }
        }
        LocalFree( DriveLayout );
    }


    //
    // Check whether it is removable or not.
    //
    if (!DeviceIoControl(hDisk,
                         IOCTL_DISK_GET_DRIVE_GEOMETRY,
                         NULL,
                         0,
                         &Geometry,
                         sizeof(Geometry),
                         &dwSize,
                         NULL)) {
        Status = GetLastError();
        if (Status == ERROR_NOT_READY) {
            //
            // Guess this must be removable!
            //
            m_IsRemovable = TRUE;
        } else {
            //
            // [FUTURE] John Vert (jvert) 10/18/1996
            //      Remove this when we require the new SCSI driver.
            //      The disk is reserved on the other system, so we can't
            //      get the geometry.
            //
            m_IsRemovable = FALSE;
        }
    } else {
        if (Geometry.MediaType == RemovableMedia) {
            m_IsRemovable = TRUE;
        } else {
            m_IsRemovable = FALSE;
        }
    }
    CloseHandle(hDisk);

    return(ERROR_SUCCESS);
}

HANDLE
CPhysicalDisk::GetPhysicalDriveHandle(DWORD Access)
{
    WCHAR Buff[100];
    HANDLE hDisk;

    wsprintf(Buff, L"\\\\.\\PhysicalDrive%d", m_DiskNumber);
    hDisk = CreateFile(Buff,
                       Access,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);
    if (hDisk == INVALID_HANDLE_VALUE) {
        DISKLOG(("Failed to get handle for drive %u. status = %u\n",
                 m_DiskNumber,
                 GetLastError()));
        return(NULL);
    }
    return(hDisk);
}

HANDLE
CPhysicalDisk::GetPhysicalDriveHandle(DWORD Access, LPWSTR DeviceName)
{
    HANDLE hDisk;

    hDisk = CreateFile(DeviceName,
                       Access,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);
    if (hDisk == INVALID_HANDLE_VALUE) {
        DISKLOG(("Failed to get handle for drive %u. status = %u\n",
                 m_DiskNumber,
                 GetLastError()));
        return(NULL);
    }
    return(hDisk);
}


BOOL
CPhysicalDisk::ShareBus(
    IN CPhysicalDisk *OtherDisk
    )
/*++

Routine Description:

    Returns whether or not this disk shares a bus with another
    disk.

Arguments:

    OtherDisk - Supplies the other disk

Return Value:

    TRUE - if the disks share the same bus.

    FALSE - if the disks do not share the same bus.

--*/

{
    //
    // Make sure they are either both SCSI or both not SCSI.
    //
    if (m_IsSCSI != OtherDisk->m_IsSCSI) {
        return(FALSE);
    }
    if ( (m_ScsiAddress.PortNumber == OtherDisk->m_ScsiAddress.PortNumber) &&
         (m_ScsiAddress.PathId == OtherDisk->m_ScsiAddress.PathId) ) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}


BOOL
CPhysicalDisk::IsSticky(
    VOID
    )
/*++

Routine Description:

    Returns whether or not this disk has a signature and all the partitions
    on it have sticky drive letters.

Arguments:

    None.

Return Value:

    TRUE - if the disk is sticky

    FALSE - if the disk is not sticky and needs to have some FT information
            applied before it is suitable for clustering.

--*/

{
    //
    // If the signature is 0, return FALSE.
    //
    if ((m_FtInfo == NULL) ||
        (m_FtInfo->m_Signature == 0)) {
        return(FALSE);
    }

    //
    // Check each volume to see if it has a sticky drive letter.
    //
    CLogicalDrive *Drive;
    POSITION pos = m_LogicalDriveList.GetHeadPosition();
    while (pos) {
        Drive = m_LogicalDriveList.GetNext(pos);
        if (!Drive->m_IsSticky) {
            return(FALSE);
        }
    }
    return(TRUE);
}


BOOL
CPhysicalDisk::IsNTFS(
    VOID
    )
/*++

Routine Description:

    Returns whether or not all the partitions on this drive are NTFS.

Arguments:

    None.

Return Value:

    TRUE - if the disk is entirely NTFS

    FALSE - if the disk is not entirely NTFS

--*/

{
    //
    // if no logical volumes were created for this drive, then it must not
    // have any NTFS partitions
    //
    if ( m_LogicalDriveList.IsEmpty()) {
        return FALSE;
    }

    //
    // Check each volume to see if it has a sticky drive letter.
    //
    CLogicalDrive *Drive;
    POSITION pos = m_LogicalDriveList.GetHeadPosition();
    while (pos) {
        Drive = m_LogicalDriveList.GetNext(pos);
        if (!Drive->m_IsNTFS) {
            return(FALSE);
        }
    }
    return(TRUE);
}


DWORD
CPhysicalDisk::MakeSticky(
    CFtInfo *FtInfo
    )
/*++

Routine Description:

    Attempts to make a disk and all of its partitions have
    sticky drive letters.

Arguments:

    FtInfo - Supplies the FT information that will be updated.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    DWORD Status;

    if (m_Signature == 0) {

        //
        // Better not be any information in the registry for a disk
        // with no signature.
        //
        if (m_FtInfo != NULL) {
            DISKERR(IDS_GENERAL_FAILURE, ERROR_FILE_NOT_FOUND);
        }

        //
        // There is no signature on this drive. Think one up and
        // stamp the drive.
        //
        HANDLE hDisk = GetPhysicalDriveHandle(GENERIC_READ | GENERIC_WRITE);
        PDRIVE_LAYOUT_INFORMATION DriveLayout;
        DWORD dwSize;
        DWORD NewSignature;
        FILETIME CurrentTime;
        BOOL success;

        if (hDisk == NULL) {
            return(GetLastError());
        }

        //
        // Get the current drive layout, change the signature field, and
        // set the new drive layout. The new drive layout will be identical
        // except for the new signature.
        //
        if (!ClRtlGetDriveLayoutTable( hDisk, &DriveLayout, &dwSize )) {
            Status = GetLastError();
            DISKERR(IDS_GENERAL_FAILURE, Status);
            CloseHandle(hDisk);
            return(Status);
        }

        GetSystemTimeAsFileTime(&CurrentTime);
        NewSignature = CurrentTime.dwLowDateTime;

        //
        // Make sure this signature is unique.
        //
        while (FtInfo->FindDiskInfo(NewSignature) != NULL) {
            NewSignature++;
        }

        //
        // Finally set the new signature information.
        //
        DriveLayout->Signature = NewSignature;
        success = DeviceIoControl(hDisk,
                                  IOCTL_DISK_SET_DRIVE_LAYOUT,
                                  DriveLayout,
                                  dwSize,
                                  NULL,
                                  0,
                                  &dwSize,
                                  NULL);
        LocalFree( DriveLayout );

        if ( !success ) {
            Status = GetLastError();
            DISKERR(IDS_GENERAL_FAILURE, Status);
            CloseHandle(hDisk);
            return(Status);
        }

        m_Signature = NewSignature;
    }

    if (m_FtInfo == NULL) {
        //
        // There is no existing FT information for this drive.
        // Create some FT information based on the drive.
        //
        m_FtInfo = new CFtInfoDisk(this);
        if (m_FtInfo == NULL) {
            DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        FtInfo->SetDiskInfo(m_FtInfo);

        //
        // Go through all our partitions and set their FT info.
        //
        POSITION pos = m_PartitionList.GetHeadPosition();
        CPhysicalPartition *Partition;
        while (pos) {
            Partition = m_PartitionList.GetNext(pos);
            Partition->m_FtPartitionInfo = m_FtInfo->GetPartition(Partition->m_Info.StartingOffset,
                                                                  Partition->m_Info.PartitionLength);
        }
    }

    //
    // Go through all the volumes on this drive and make each one
    // sticky.
    //
    CLogicalDrive *Drive;

    POSITION pos = m_LogicalDriveList.GetHeadPosition();
    while (pos) {
        Drive = m_LogicalDriveList.GetNext(pos);
        Status = Drive->MakeSticky();
        if (Status != ERROR_SUCCESS) {
            return(Status);
        }
    }
    return(ERROR_SUCCESS);
}


//
// Functions for the physical disk partition
//
CPhysicalPartition::CPhysicalPartition(
    CPhysicalDisk *Disk,
    PPARTITION_INFORMATION Info
    )
{
    m_PhysicalDisk = Disk;
    m_Info = *Info;
    if (Disk->m_FtInfo) {
        m_FtPartitionInfo = Disk->m_FtInfo->GetPartition(m_Info.StartingOffset,
                                                         m_Info.PartitionLength);
    } else {
        m_FtPartitionInfo = NULL;
    }
}

//
// Functions for the FT set object
//
BOOL
CFtSet::Initialize(
    CDiskConfig *Config,
    CFtInfoFtSet *FtInfo
    )
{
    DWORD MemberCount;
    DWORD FoundCount=0;
    DWORD Index;
    CFtInfoPartition *Partition;
    CPhysicalPartition *FoundPartition;

    m_FtInfo = FtInfo;

    //
    // Find the CPhysicalPartition that corresponds to each member of the
    // FT set.
    //
    MemberCount = FtInfo->GetMemberCount();
    for (Index=0; Index<MemberCount; Index++) {
        Partition = FtInfo->GetMemberByIndex(Index);
        if (Partition == NULL) {
            break;
        }
        FoundPartition = Config->FindPartition(Partition);
        if (FoundPartition != NULL) {
            ++FoundCount;
            m_Member.AddTail(FoundPartition);
        }
    }

    //
    // If we did not find all the required members, fail.
    //
    switch (FtInfo->GetType()) {
        case Stripe:
        case VolumeSet:
            if (FoundCount != MemberCount) {
                return(FALSE);
            }
            break;

        case Mirror:
            if (FoundCount == 0) {
                return(FALSE);
            }
            break;

        case StripeWithParity:
            if (FoundCount < (MemberCount-1)) {
                return(FALSE);
            }
            break;

        default:
            //
            // Don't know what the heck this is supposed to be.
            // Ignore it.
            //
            return(FALSE);
    }

    //
    // If there are any other partitions on any of the drives, create logical
    // volumes for them.
    //
    POSITION MemberPos;
    POSITION PartitionPos;
    CPhysicalPartition *PhysPartition;
    CPhysicalDisk *Disk;
    MemberPos = m_Member.GetHeadPosition();
    while (MemberPos) {
        Disk = m_Member.GetNext(MemberPos)->m_PhysicalDisk;

        PartitionPos = Disk->m_PartitionList.GetHeadPosition();
        while (PartitionPos) {
            PhysPartition = Disk->m_PartitionList.GetNext(PartitionPos);
            if ((!(PhysPartition->m_Info.PartitionType & PARTITION_NTFT)) &&
                (IsRecognizedPartition(PhysPartition->m_Info.PartitionType))) {
                CLogicalDrive *Vol = new CLogicalDrive;
                if (Vol == NULL) {
                    DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
                    return FALSE;
                }
                if (Vol->Initialize(PhysPartition)) {
                    //
                    // Add this volume to our list.
                    //
                    m_OtherVolumes.AddTail(Vol);
                    Vol->m_ContainerSet = this;

                    //
                    // Update the disk config.
                    //
                    Config->m_LogicalDrives[Vol->m_DriveLetter] = Vol;
                } else {
                    delete(Vol);
                }
            }
        }
    }

    if (Volume.Initialize(m_Member.GetHead())) {
        Volume.m_ContainerSet = this;
        return(TRUE);
    } else {
        return(FALSE);
    }
}

BOOL
CFtSet::IsSticky()
{
    //
    // FT sets are, by definition, sticky. Make sure any other volumes on the
    // same drive are sticky as well.
    //
    POSITION pos = m_OtherVolumes.GetHeadPosition();
    CLogicalDrive *Volume;
    while (pos) {
        Volume = m_OtherVolumes.GetNext(pos);
        if (!Volume->m_IsSticky) {
            return(FALSE);
        }
    }
    return(TRUE);
}

DWORD
CFtSet::MakeSticky()
{
    DWORD Status;

    //
    // FT sets are, by definition, sticky. Make sure any other volumes on the
    // same drive are sticky as well.
    //
    POSITION pos = m_OtherVolumes.GetHeadPosition();
    CLogicalDrive *Volume;
    while (pos) {
        Volume = m_OtherVolumes.GetNext(pos);
        Status = Volume->MakeSticky();
        if (Status != ERROR_SUCCESS) {
            return(Status);
        }
    }
    return(ERROR_SUCCESS);
}

BOOL
CFtSet::IsNTFS()
{
    if (!Volume.m_IsNTFS) {
        return(FALSE);
    }
    //
    // Check the other volumes to make sure they are NTFS as well.
    //
    POSITION pos = m_OtherVolumes.GetHeadPosition();
    CLogicalDrive *Volume;
    while (pos) {
        Volume = m_OtherVolumes.GetNext(pos);
        if (!Volume->m_IsNTFS) {
            return(FALSE);
        }
    }
    return(TRUE);
}

BOOL
CFtSet::IsSCSI()
{
    //
    // Check the other volumes to make sure they are NTFS as well.
    //
    POSITION pos = m_Member.GetHeadPosition();
    CPhysicalPartition *Partition;
    while (pos) {
        Partition = m_Member.GetNext(pos);
        if (!Partition->m_PhysicalDisk->m_IsSCSI) {
            return(FALSE);
        }
    }
    return(TRUE);
}

//
// Functions for the FT disk information
//

CFtInfo::CFtInfo()
{
    HKEY hKey;
    LONG Status;

    //
    // for NT5, the DISK info key is no longer maintained by the disk
    // system. Clusters still needs a centrally located key such that
    // the other members of the cluster can query for the disk config
    // of the sponsor's node.
    //

    Status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                           L"System\\Disk",
                           0,
                           KEY_READ | KEY_WRITE,
                           &hKey);
    if (Status == ERROR_SUCCESS) {
        Initialize(hKey, _T("Information"));
        RegCloseKey(hKey);
    } else {
        Initialize();
    }
}

CFtInfo::CFtInfo(
    HKEY hKey,
    LPWSTR lpszValueName
    )
{
    Initialize(hKey, lpszValueName);
}

CFtInfo::CFtInfo(
    PDISK_CONFIG_HEADER Header
    )
{
    DWORD Length;

    Length = Header->FtInformationOffset +
             Header->FtInformationSize;
    Initialize(Header, Length);
}

CFtInfo::CFtInfo(
    CFtInfoFtSet *FtSet
    )
/*++

Routine Description:

    Constructor for generating a CFtInfo that contains only a
    single FT set.

Arguments:

    FtSet - Supplies the FT set

Return Value:

    None

--*/

{
    //
    // Initialize an empty FT information.
    //
    Initialize();

    //
    // Add the FT set
    //
    if (FtSet != NULL) {
        AddFtSetInfo(FtSet);
    }

}

VOID
CFtInfo::Initialize(
    HKEY hKey,
    LPWSTR lpszValueName
    )
{
    PDISK_CONFIG_HEADER          regHeader;
    DWORD Length;

    if (GetRegValue(hKey,
                    lpszValueName,
                    (LPBYTE *)&regHeader,
                    &Length)) {
        Initialize(regHeader, Length);
        LocalFree(regHeader);
    } else {
        DWORD Status = GetLastError();

        if (Status == ERROR_FILE_NOT_FOUND) {

            //
            // There is no FT information on this machine.
            //
            Initialize();
        } else {
            DISKERR(IDS_GENERAL_FAILURE, Status);
        }
    }
}

VOID
CFtInfo::Initialize(
    PDISK_CONFIG_HEADER Header,
    DWORD Length
    )
{
    DWORD i;
    DISK_REGISTRY UNALIGNED *    diskRegistry;
    DISK_DESCRIPTION UNALIGNED * diskDescription;
    CFtInfoDisk *DiskInfo;

    m_buffer = new BYTE[Length];
    if (m_buffer == NULL) {
        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
        return; // [REENGINEER] we avoided an AV, but the caller wouldn't know
    }
    CopyMemory(m_buffer, Header, Length);
    m_bufferLength = Length;

    //
    // Iterate through all the disks and add each one to our list.
    //

    diskRegistry = (DISK_REGISTRY UNALIGNED *)
                         (m_buffer + ((PDISK_CONFIG_HEADER)m_buffer)->DiskInformationOffset);
    diskDescription = &diskRegistry->Disks[0];
    for (i = 0; i < diskRegistry->NumberOfDisks; i++) {
        DiskInfo = new CFtInfoDisk(diskDescription);
        if (DiskInfo) {
            //
            // Add this disk information to our list.
            //
            DiskInfo->SetOffset((DWORD)((PUCHAR)diskDescription - m_buffer));
            m_DiskInfo.AddTail(DiskInfo);
        } else {
            DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
            // [REENGINEER] do we need to exit here?
        }

        //
        // Look at the next disk
        //
        diskDescription = (DISK_DESCRIPTION UNALIGNED *)
            &diskDescription->Partitions[diskDescription->NumberOfPartitions];
    }

    if (((PDISK_CONFIG_HEADER)m_buffer)->FtInformationSize != 0) {
        //
        // Iterate through all the FT sets and add each one to our list.
        //
        PFT_REGISTRY        ftRegistry;
        PFT_DESCRIPTION     ftDescription;
        CFtInfoFtSet *FtSetInfo;
        ftRegistry = (PFT_REGISTRY)
                         (m_buffer + ((PDISK_CONFIG_HEADER)m_buffer)->FtInformationOffset);
        ftDescription = &ftRegistry->FtDescription[0];
        for (i=0; i < ftRegistry->NumberOfComponents; i++) {
            FtSetInfo = new CFtInfoFtSet;
            if (FtSetInfo) {
                if (!FtSetInfo->Initialize(this, ftDescription)) {
                    delete FtSetInfo;
                } else {
                    //
                    // Add this FT set information to the list.
                    //
                    m_FtSetInfo.AddTail(FtSetInfo);
                }
            } else {
                DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
                // [REENGINEER] do we need to exit here?
            }
            ftDescription = (PFT_DESCRIPTION)(&ftDescription->FtMemberDescription[ftDescription->NumberOfMembers]);
        }
    }

}

VOID
CFtInfo::Initialize(VOID)
{
    PDISK_CONFIG_HEADER          regHeader;
    DISK_REGISTRY UNALIGNED *    diskRegistry;

    //
    // There is no FT information on this machine.
    //
    m_bufferLength = sizeof(DISK_CONFIG_HEADER) + sizeof(DISK_REGISTRY);
    m_buffer = new BYTE[m_bufferLength];
    if (m_buffer == NULL) {
        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
        return; // [REENGINEER], we avoided an AV, but the caller wouldn't know
    }
    regHeader = (PDISK_CONFIG_HEADER)m_buffer;
    regHeader->Version = DISK_INFORMATION_VERSION;
    regHeader->CheckSum = 0;
    regHeader->DirtyShutdown = FALSE;
    regHeader->DiskInformationOffset = sizeof(DISK_CONFIG_HEADER);
    regHeader->DiskInformationSize = sizeof(DISK_REGISTRY)-sizeof(DISK_DESCRIPTION);
    regHeader->FtInformationOffset = regHeader->DiskInformationOffset +
                                     regHeader->DiskInformationSize;
    regHeader->FtInformationSize = 0;
    regHeader->FtStripeWidth = 0;
    regHeader->FtPoolSize = 0;
    regHeader->NameOffset = 0;
    regHeader->NameSize = 0;
    diskRegistry = (DISK_REGISTRY UNALIGNED *)
                         ((PUCHAR)regHeader + regHeader->DiskInformationOffset);
    diskRegistry->NumberOfDisks = 0;
    diskRegistry->ReservedShort = 0;
}

CFtInfo::~CFtInfo()
{
    CFtInfoDisk *DiskInfo;
    CFtInfoFtSet *FtSetInfo;

    POSITION pos = m_DiskInfo.GetHeadPosition();
    while (pos) {
        DiskInfo = m_DiskInfo.GetNext(pos);
        delete(DiskInfo);
    }

    pos = m_FtSetInfo.GetHeadPosition();
    while (pos) {
        FtSetInfo = m_FtSetInfo.GetNext(pos);
        delete FtSetInfo;
    }
    delete [] m_buffer;
}

DWORD
CFtInfo::CommitRegistryData()
{
    HKEY hKey;
    PDISK_CONFIG_HEADER Buffer;
    DWORD Size;
    DWORD Status = ERROR_SUCCESS;

    Status = RegCreateKeyW(HKEY_LOCAL_MACHINE, L"System\\Disk", &hKey);
    if (Status != ERROR_SUCCESS) {
        DISKERR(IDS_REGISTRY_FAILURE, Status);
        return Status;
    }
    Size = GetSize();
    Buffer = (PDISK_CONFIG_HEADER)LocalAlloc(LMEM_FIXED, Size);
    if (Buffer == NULL) {
        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
        Status = ERROR_NOT_ENOUGH_MEMORY;
    } else {
        GetData(Buffer);

        Status = RegSetValueExW(hKey,
                                L"Information",
                                0,
                                REG_BINARY,
                                (PBYTE)Buffer,
                                Size);
        if (Status != ERROR_SUCCESS) {
            DISKERR(IDS_REGISTRY_FAILURE, Status);
        }
        LocalFree(Buffer);
    }
    RegCloseKey(hKey);

    return(Status);
}

VOID
CFtInfo::SetDiskInfo(
    CFtInfoDisk *NewDisk
    )
{
    CFtInfoDisk *OldDisk;
    //
    // See if we already have disk information for this signature
    //
    OldDisk = FindDiskInfo(NewDisk->m_Signature);
    if (OldDisk == NULL) {

        DISKLOG(("CFtInfo::SetDiskInfo adding new disk information for %08X\n",NewDisk->m_Signature));
        //
        // Just add the new disk to our list.
        //
        m_DiskInfo.AddTail(NewDisk);
    } else {

        //
        // We already have some disk information. If they are the same,
        // don't do anything.
        //
        if (*OldDisk == *NewDisk) {
            DISKLOG(("CFtInfo::SetDiskInfo found identical disk information for %08X\n",OldDisk->m_Signature));
            delete (NewDisk);
            return;
        }

        //
        // We need to replace the old information with the new information.
        //
        POSITION pos = m_DiskInfo.Find(OldDisk);
        if (pos == NULL) {
            DISKLOG(("CFtInfo::SetDiskInfo did not find OldDisk %08X\n",OldDisk->m_Signature));
            DISKERR(IDS_GENERAL_FAILURE, ERROR_FILE_NOT_FOUND);
            m_DiskInfo.AddTail(NewDisk);
        } else {
            m_DiskInfo.SetAt(pos, NewDisk);
            delete(OldDisk);
        }
    }
}

CFtInfoDisk *
CFtInfo::FindDiskInfo(
    IN DWORD Signature
    )
{
    CFtInfoDisk *RetInfo;
    POSITION pos = m_DiskInfo.GetHeadPosition();
    while (pos) {
        RetInfo = m_DiskInfo.GetNext(pos);
        if (RetInfo->m_Signature == Signature) {
            return(RetInfo);
        }
    }
    return(NULL);
}

CFtInfoDisk *
CFtInfo::EnumDiskInfo(
    IN DWORD Index
    )
{
    DWORD i=0;
    CFtInfoDisk *RetInfo;
    POSITION pos = m_DiskInfo.GetHeadPosition();
    while (pos) {
        RetInfo = m_DiskInfo.GetNext(pos);
        if (Index == i) {
            return(RetInfo);
        }
        ++i;
    }
    return(NULL);
}

BOOL
CFtInfo::DeleteDiskInfo(
    IN DWORD Signature
    )
{
    CFtInfoDisk *Info = FindDiskInfo(Signature);
    CFtInfoFtSet *OldFtSet=NULL;

    if (Info == NULL) {
        DISKLOG(("CFtInfo::DeleteDiskInfo: Disk with signature %08X was not found\n",Signature));
        return(FALSE);
    }

    //
    // Remove any FT set containing this signature.
    //
    OldFtSet = FindFtSetInfo(Info->m_Signature);
    if (OldFtSet != NULL) {
        DeleteFtSetInfo(OldFtSet);
    }

    POSITION pos = m_DiskInfo.Find(Info);
    if (pos == NULL) {
        DISKLOG(("CFtInfo::DeleteDiskInfo did not find Info %08X\n",Signature));
        DISKERR(IDS_GENERAL_FAILURE, ERROR_FILE_NOT_FOUND);
        return(FALSE);
    } else {
        m_DiskInfo.RemoveAt(pos);
        delete(Info);
    }
    return(TRUE);
}

VOID
CFtInfo::AddFtSetInfo(
    CFtInfoFtSet *FtSet,
    CFtInfoFtSet *OldFtSet
    )
{
    DWORD MemberCount;
    DWORD i;
    CFtInfoPartition *Partition;
    CFtInfoPartition *NewPartition;
    CFtInfoDisk *Disk;
    CFtInfoFtSet *NewFtSet;
    USHORT FtGroup;
    POSITION pos;
    BOOL Success;

    if (OldFtSet != NULL) {
        CFtInfoFtSet *pSet;
        pos = m_FtSetInfo.GetHeadPosition();
        for (FtGroup = 1; ; FtGroup++) {
            pSet = m_FtSetInfo.GetNext(pos);
            if (pSet == NULL) {
                OldFtSet = NULL;
                break;
            }
            if (pSet == OldFtSet) {
                //
                // Reset our position back to point at the OldFtSet
                //
                pos = m_FtSetInfo.Find(OldFtSet);
                break;
            }
        }
    }
    if (OldFtSet == NULL) {
        FtGroup = (USHORT)m_FtSetInfo.GetCount()+1;
    }
    //
    // Add each disk in the FT set.
    //
    MemberCount = FtSet->GetMemberCount();
    for (i=0; i<MemberCount; i++) {
        Partition = FtSet->GetMemberByIndex(i);
        DISKASSERT(Partition != NULL);

        Disk = new CFtInfoDisk(Partition->m_ParentDisk);
        if (Disk == NULL) {
            DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
            return; // [REENGINEER], caller doesn't know about the problem
        }

        SetDiskInfo(Disk);
    }

    //
    // Create the empty FT set.
    //
    NewFtSet = new CFtInfoFtSet;
    if (NewFtSet == NULL) {
        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
        return; // [REENGINEER], caller doesn't know about the problem
    }
    Success = NewFtSet->Initialize(FtSet->GetType(), FtSet->GetState());
    DISKASSERT(Success);

    //
    // Add each member to the empty FT set
    //
    for (i=0; i<MemberCount; i++) {
        //
        // Find each partition object in our FT information.
        //
        Partition = FtSet->GetMemberByIndex(i);
        NewPartition = FindPartition(Partition->m_ParentDisk->m_Signature,
                                     Partition->m_PartitionInfo->StartingOffset,
                                     Partition->m_PartitionInfo->Length);
        DISKASSERT(NewPartition != NULL);
        NewFtSet->AddMember(NewPartition,
                            FtSet->GetMemberDescription(i),
                            FtGroup);
    }

    if (OldFtSet != NULL) {
        //
        // Replace the old FT set information
        //
        m_FtSetInfo.SetAt(pos, NewFtSet);
        delete(OldFtSet);
    } else {
        //
        // Add the new FT set to the FT information
        //
        m_FtSetInfo.AddTail(NewFtSet);
    }

}

CFtInfoFtSet *
CFtInfo::FindFtSetInfo(
    IN DWORD Signature
    )
{
    CFtInfoFtSet *RetInfo;
    POSITION pos = m_FtSetInfo.GetHeadPosition();
    while (pos) {
        RetInfo = m_FtSetInfo.GetNext(pos);
        if (RetInfo->GetMemberBySignature(Signature) != NULL) {
            return(RetInfo);
        }
    }
    return(NULL);
}

CFtInfoFtSet *
CFtInfo::EnumFtSetInfo(
    IN DWORD Index
    )
{
    DWORD i=0;
    CFtInfoFtSet *RetInfo;
    POSITION pos = m_FtSetInfo.GetHeadPosition();
    while (pos) {
        RetInfo = m_FtSetInfo.GetNext(pos);
        if (i == Index) {
            return(RetInfo);
        }
        ++i;
    }
    return(NULL);
}

BOOL
CFtInfo::DeleteFtSetInfo(
    IN CFtInfoFtSet *FtSet
    )
{

    POSITION pos = m_FtSetInfo.Find(FtSet);
    if (pos == NULL) {
        DISKLOG(("CFtInfo::DeleteFtSetInfo did not find Info %08X\n",FtSet));
        DISKERR(IDS_GENERAL_FAILURE, ERROR_FILE_NOT_FOUND);
        return(FALSE);
    } else {
        DWORD i;
        CFtInfoPartition *FtPartition;

        //
        // Set the FT group of all this set's members to -1
        //
        for (i=0; ; i++) {
            FtPartition = FtSet->GetMemberByIndex(i);
            if (FtPartition == NULL) {
                break;
            }
            FtPartition->m_PartitionInfo->FtGroup = (USHORT)-1;
            FtPartition->m_PartitionInfo->FtMember = 0;
            FtPartition->m_PartitionInfo->FtType = NotAnFtMember;
        }
        m_FtSetInfo.RemoveAt(pos);
        delete(FtSet);
    }
    return(TRUE);
}


CFtInfoPartition *
CFtInfo::FindPartition(
    DWORD Signature,
    LARGE_INTEGER StartingOffset,
    LARGE_INTEGER Length
    )
{
    CFtInfoDisk *Disk;

    Disk = FindDiskInfo(Signature);
    if (Disk == NULL) {
        return(NULL);
    }

    return(Disk->GetPartition(StartingOffset, Length));
}

CFtInfoPartition *
CFtInfo::FindPartition(
    UCHAR DriveLetter
    )
{
    CFtInfoDisk *Disk;
    CFtInfoPartition *Partition;
    DWORD DiskIndex;
    DWORD PartitionIndex;

    for (DiskIndex = 0; ; DiskIndex++) {
        Disk = EnumDiskInfo(DiskIndex);
        if (Disk == NULL) {
            break;
        }

        for (PartitionIndex = 0; ; PartitionIndex++) {
            Partition = Disk->GetPartitionByIndex(PartitionIndex);
            if (Partition == NULL) {
                break;
            }
            if (Partition->m_PartitionInfo->AssignDriveLetter &&
                (Partition->m_PartitionInfo->DriveLetter == DriveLetter)) {
                //
                // Found a match.
                //
                return(Partition);
            }
        }
    }

    return(NULL);
}

DWORD
CFtInfo::GetSize()
{
    CFtInfoDisk *DiskInfo;
    CFtInfoFtSet *FtSetInfo;
    DWORD Delta;

    //
    // Start off with the fixed size header
    //
    DWORD Size = sizeof(DISK_CONFIG_HEADER);
    DISKLOG(("CFtInfo::GetSize headersize = %x\n",Size));

    //
    // Add in the size of the DISK_REGISTRY header
    //
    Delta = sizeof(DISK_REGISTRY) - sizeof(DISK_DESCRIPTION);
    Size += Delta;
    DISKLOG(("CFtInfo::GetSize += DISK_REGISTRY(%x) = %x\n",Delta, Size));

    if (!m_DiskInfo.IsEmpty()) {

        //
        // Add the sizes of each disks partition information
        //
        POSITION pos = m_DiskInfo.GetHeadPosition();
        while (pos) {
            DiskInfo = m_DiskInfo.GetNext(pos);
            Delta = DiskInfo->GetSize();
            Size += Delta;
            DISKLOG(("CFtInfo::GetSize += DiskInfo(%x) = %x\n",Delta, Size));
        }

        if (!m_FtSetInfo.IsEmpty()) {

            //
            // Add in the size of the FT_REGISTRY header
            //
            Delta = sizeof(FT_REGISTRY) - sizeof(FT_DESCRIPTION);
            Size += Delta;
            DISKLOG(("CFtInfo::GetSize += FT_REGISTRY(%x) = %x\n",Delta, Size));

            //
            // Add the sizes of each FT sets information
            //
            pos = m_FtSetInfo.GetHeadPosition();
            while (pos) {
                FtSetInfo = m_FtSetInfo.GetNext(pos);
                Delta = FtSetInfo->GetSize();
                Size += Delta;
                DISKLOG(("CFtInfo::GetSize +=FtSetInfo(%x) = %x\n",Delta, Size));
            }
        }
    }


    return(Size);
}

VOID
CFtInfo::GetData(
    PDISK_CONFIG_HEADER pDest
    )
{
    PDISK_CONFIG_HEADER DiskConfigHeader;
    PDISK_REGISTRY DiskRegistry;
    PDISK_DESCRIPTION DiskDescription;
    PFT_REGISTRY FtRegistry;
    PFT_DESCRIPTION FtDescription;
    DWORD Count;
    POSITION pos;
    CFtInfoDisk *DiskInfo;
    CFtInfoFtSet *FtSetInfo;

    //
    // Initialize the fixed size header.
    //
    // Copy the original header, then zero out the fields we might
    // change.
    //
    DiskConfigHeader = pDest;
    CopyMemory(DiskConfigHeader, m_buffer, sizeof(DISK_CONFIG_HEADER));
    DiskConfigHeader->DiskInformationOffset = sizeof(DISK_CONFIG_HEADER);
    DiskConfigHeader->FtInformationOffset = 0;
    DiskConfigHeader->FtInformationSize = 0;

    //
    // Initialize the fixed size DISK_REGISTRY header
    //
    DiskRegistry = (PDISK_REGISTRY)(DiskConfigHeader + 1);
    DiskRegistry->NumberOfDisks = (USHORT)m_DiskInfo.GetCount();
    DiskRegistry->ReservedShort = 0;
    DiskConfigHeader->DiskInformationSize = sizeof(DISK_REGISTRY) - sizeof(DISK_DESCRIPTION);

    if (!m_DiskInfo.IsEmpty()) {
        //
        // Get each disk's information
        //
        DiskDescription = &DiskRegistry->Disks[0];
        pos = m_DiskInfo.GetHeadPosition();
        while (pos) {
            DWORD Size;
            DiskInfo = m_DiskInfo.GetNext(pos);
            DiskInfo->SetOffset((DWORD)((PUCHAR)DiskDescription - (PUCHAR)DiskConfigHeader));
            DiskInfo->GetData((PBYTE)DiskDescription);
            Size = DiskInfo->GetSize();
            DiskConfigHeader->DiskInformationSize += Size;

            DiskDescription = (PDISK_DESCRIPTION)((PUCHAR)DiskDescription + Size);
        }

        //
        // Now set the FT information
        //
        FtRegistry = (PFT_REGISTRY)DiskDescription;
        DiskConfigHeader->FtInformationOffset =(DWORD)((PBYTE)FtRegistry - (PBYTE)DiskConfigHeader);
        if (!m_FtSetInfo.IsEmpty()) {

            //
            // Initialize the fixed size FT_REGISTRY header
            //
            FtRegistry->NumberOfComponents = (USHORT)m_FtSetInfo.GetCount();
            FtRegistry->ReservedShort = 0;
            DiskConfigHeader->FtInformationSize = sizeof(FT_REGISTRY) - sizeof(FT_DESCRIPTION);
            FtDescription = &FtRegistry->FtDescription[0];
            pos = m_FtSetInfo.GetHeadPosition();
            while (pos) {
                DWORD Size;

                FtSetInfo = m_FtSetInfo.GetNext(pos);
                FtSetInfo->GetData((PBYTE)FtDescription);
                Size = FtSetInfo->GetSize();
                DiskConfigHeader->FtInformationSize += Size;

                FtDescription = (PFT_DESCRIPTION)((PUCHAR)FtDescription + Size);
            }

        }

    }

}


//********************
//
// Implementation of standard partition information
//
//********************
CFtInfoPartition::CFtInfoPartition(
    CFtInfoDisk *Disk,
    DISK_PARTITION UNALIGNED *Description
    )
{
    m_ParentDisk = Disk;
    m_Modified = TRUE;

    m_PartitionInfo = (PDISK_PARTITION)LocalAlloc(LMEM_FIXED, sizeof(DISK_PARTITION));
    if (m_PartitionInfo == NULL) {
        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
        // [REENGINEER], will AV in a second
    }
    CopyMemory(m_PartitionInfo, Description, sizeof(DISK_PARTITION));

}

CFtInfoPartition::CFtInfoPartition(
    CFtInfoDisk *Disk,
    CPhysicalPartition *Partition
    )
{
    m_ParentDisk = Disk;
    m_Modified = TRUE;

    m_PartitionInfo = (PDISK_PARTITION)LocalAlloc(LMEM_FIXED, sizeof(DISK_PARTITION));
    if (m_PartitionInfo == NULL) {
        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
        // [REENGINEER], will AV in a second
    }
    m_PartitionInfo->FtType = NotAnFtMember;
    m_PartitionInfo->FtState = Healthy;
    m_PartitionInfo->StartingOffset = Partition->m_Info.StartingOffset;
    m_PartitionInfo->Length = Partition->m_Info.PartitionLength;
    m_PartitionInfo->FtLength.QuadPart = 0;
    m_PartitionInfo->DriveLetter = 0;
    m_PartitionInfo->AssignDriveLetter = FALSE;
    m_PartitionInfo->LogicalNumber = 0;
    m_PartitionInfo->FtGroup = (USHORT)-1;
    m_PartitionInfo->FtMember = 0;
    m_PartitionInfo->Modified = FALSE;
}

CFtInfoPartition::CFtInfoPartition(
    CFtInfoDisk *Disk,
    PARTITION_INFORMATION * PartitionInfo
    )
{
    m_ParentDisk = Disk;
    m_Modified = TRUE;

    m_PartitionInfo = (PDISK_PARTITION)LocalAlloc(LMEM_FIXED, sizeof(DISK_PARTITION));
    if (m_PartitionInfo == NULL) {
        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
        // [REENGINEER], will AV in a second
    }
    m_PartitionInfo->FtType = NotAnFtMember;
    m_PartitionInfo->FtState = Healthy;
    m_PartitionInfo->StartingOffset = PartitionInfo->StartingOffset;
    m_PartitionInfo->Length = PartitionInfo->PartitionLength;
    m_PartitionInfo->FtLength.QuadPart = 0;
    m_PartitionInfo->DriveLetter = 0;
    m_PartitionInfo->AssignDriveLetter = FALSE;
    m_PartitionInfo->LogicalNumber = 0;
    m_PartitionInfo->FtGroup = (USHORT)-1;
    m_PartitionInfo->FtMember = 0;
    m_PartitionInfo->Modified = FALSE;
}

CFtInfoPartition::~CFtInfoPartition()
{
    if (m_Modified) {
        LocalFree(m_PartitionInfo);
    }
}

VOID
CFtInfoPartition::GetData(
    PDISK_PARTITION pDest
    )
{
    DISKLOG(("CFtInfoPartition::GetData %12I64X - %12I64X\n",
             m_PartitionInfo->StartingOffset.QuadPart,
             m_PartitionInfo->Length.QuadPart));

    DISKLOG(("                          %c (%s) %x %x %x\n",
             m_PartitionInfo->DriveLetter,
             m_PartitionInfo->AssignDriveLetter ? "Sticky" : "Not Sticky",
             m_PartitionInfo->LogicalNumber,
             m_PartitionInfo->FtGroup,
             m_PartitionInfo->FtMember));
    CopyMemory(pDest, m_PartitionInfo, sizeof(DISK_PARTITION));
}


DWORD
CFtInfoPartition::GetOffset(
    VOID
    )
{
    DWORD ParentOffset;

    ParentOffset = m_ParentDisk->GetOffset();

    return(ParentOffset + m_RelativeOffset);
}

VOID
CFtInfoPartition::MakeSticky(
    UCHAR DriveLetter
    )
{
    m_PartitionInfo->DriveLetter = DriveLetter;

    //
    // if drive letter is being removed, clear the sticky bit
    //
    m_PartitionInfo->AssignDriveLetter = ( DriveLetter != 0 );
}


//********************
//
// Implementation of standard disk information
//
//********************

CFtInfoDisk::CFtInfoDisk(
    DISK_DESCRIPTION UNALIGNED *Description
    )
{
    DWORD i;
    DWORD Offset;
    CFtInfoPartition *Partition;

    //
    // windisk sometimes puts in disk information
    // for disks with no partitions. Seems a bit pointless.
    //
    // DISKASSERT(Description->NumberOfPartitions > 0);
    m_PartitionCount = Description->NumberOfPartitions;
    m_Signature = Description->Signature;
    for (i=0; i<m_PartitionCount; i++) {
        Partition = new CFtInfoPartition(this, &Description->Partitions[i]);
        if (Partition != NULL) {
            Offset = sizeof(DISK_DESCRIPTION) + i*sizeof(DISK_PARTITION) - sizeof(DISK_PARTITION);
            Partition->SetOffset(Offset);
            m_PartitionInfo.AddTail(Partition);
        }
    }
}

CFtInfoDisk::CFtInfoDisk(
    CPhysicalDisk *Disk
    )
{
    DISKASSERT(Disk->m_PartitionCount > 0);
    m_PartitionCount = Disk->m_PartitionCount;
    m_Signature = Disk->m_Signature;

    //
    // Build up the partition objects
    //

    CFtInfoPartition *PartitionInfo;
    CPhysicalPartition *Partition;
    DWORD Offset;
    DWORD i=0;

    POSITION pos = Disk->m_PartitionList.GetHeadPosition();
    while (pos) {
        Partition = Disk->m_PartitionList.GetNext(pos);
        PartitionInfo = new CFtInfoPartition(this, Partition);
        if (PartitionInfo != NULL) {
            Offset = sizeof(DISK_DESCRIPTION) + i*sizeof(DISK_PARTITION) - sizeof(DISK_PARTITION);
            PartitionInfo->SetOffset(Offset);
            m_PartitionInfo.AddTail(PartitionInfo);
            ++i;
        }
    }
}

CFtInfoDisk::CFtInfoDisk(
    CFtInfoDisk *DiskInfo
    )
{
    DISKASSERT(DiskInfo->m_PartitionCount > 0);
    m_PartitionCount = DiskInfo->m_PartitionCount;
    m_Signature = DiskInfo->m_Signature;

    //
    // Build up the partition objects
    //

    CFtInfoPartition *PartitionInfo;
    CFtInfoPartition *SourcePartitionInfo;
    DWORD Offset;
    DWORD i=0;

    POSITION pos = DiskInfo->m_PartitionInfo.GetHeadPosition();
    while (pos) {
        SourcePartitionInfo = DiskInfo->m_PartitionInfo.GetNext(pos);
        PartitionInfo = new CFtInfoPartition(this, SourcePartitionInfo->m_PartitionInfo);
        if (PartitionInfo != NULL) {
            Offset = sizeof(DISK_DESCRIPTION) + i*sizeof(DISK_PARTITION) - sizeof(DISK_PARTITION);
            PartitionInfo->SetOffset(Offset);
            m_PartitionInfo.AddTail(PartitionInfo);
            ++i;
        }
    }
}

CFtInfoDisk::CFtInfoDisk(
    DRIVE_LAYOUT_INFORMATION *DriveLayout
    )
{
    DWORD i;
    CFtInfoPartition *ftInfoPartition;

    m_PartitionCount = 0; // [GN] Bugfix #278913
    m_Signature = DriveLayout->Signature;

    for (i=0; i < DriveLayout->PartitionCount; i++) {
        if (DriveLayout->PartitionEntry[i].RecognizedPartition) {
            m_PartitionCount++;

            ftInfoPartition = new CFtInfoPartition(this, &DriveLayout->PartitionEntry[i]);
            if (ftInfoPartition == NULL) {
                DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
                // [REENGINEER], we will add a 0 pointer into m_PartitionInfo ... bad
            }
            m_PartitionInfo.AddTail(ftInfoPartition);
        }
    }
}

CFtInfoDisk::~CFtInfoDisk()
{
    CFtInfoPartition *Partition;
    while (!m_PartitionInfo.IsEmpty()) {
        Partition = m_PartitionInfo.RemoveHead();
        delete(Partition);
    }
}

BOOL
CFtInfoDisk::operator==(
    const CFtInfoDisk& Disk
    )
{
    if (m_PartitionCount != Disk.m_PartitionCount) {
        DISKLOG(("CFtInfoDisk::operator== partition count %d != %d\n",
                 m_PartitionCount,
                 Disk.m_PartitionCount));
        return(FALSE);
    }
    if (m_Signature != Disk.m_Signature) {
        DISKLOG(("CFtInfoDisk::operator== signature %08lx != %08lx\n",
                 m_Signature,
                 Disk.m_Signature));
        return(FALSE);
    }

    POSITION MyPos, OtherPos;
    CFtInfoPartition *MyPartition, *OtherPartition;
    MyPos = m_PartitionInfo.GetHeadPosition();
    OtherPos = Disk.m_PartitionInfo.GetHeadPosition();
    while (MyPos || OtherPos) {
        if (!MyPos) {
            DISKLOG(("CFtInfoDisk::operator== MyPos is NULL\n"));
            return(FALSE);
        }
        if (!OtherPos) {
            DISKLOG(("CFtInfoDisk::operator== OtherPos is NULL\n"));
            return(FALSE);
        }

        MyPartition = m_PartitionInfo.GetNext(MyPos);
        OtherPartition = Disk.m_PartitionInfo.GetNext(OtherPos);
        if (memcmp(MyPartition->m_PartitionInfo,
                   OtherPartition->m_PartitionInfo,
                   sizeof(DISK_PARTITION)) != 0) {
            DISKLOG(("CFtInfoDisk::operator== DISK_PARTITIONs don't match\n"));
            return(FALSE);
        }
    }
    DISKLOG(("CFtInfoDisk::operator== disk information matches\n"));
    return(TRUE);
}


CFtInfoPartition *
CFtInfoDisk::GetPartition(
    LARGE_INTEGER StartingOffset,
    LARGE_INTEGER Length
    )
{
    DWORD i;
    CFtInfoPartition *Partition;
    POSITION pos;

    pos = m_PartitionInfo.GetHeadPosition();
    while (pos) {
        Partition = m_PartitionInfo.GetNext(pos);
        if ((Partition->m_PartitionInfo->StartingOffset.QuadPart == StartingOffset.QuadPart) &&
            (Partition->m_PartitionInfo->Length.QuadPart == Length.QuadPart)) {
            return(Partition);
        }
    }
    return(NULL);
}

CFtInfoPartition *
CFtInfoDisk::GetPartitionByOffset(
    DWORD Offset
    )
{
    CFtInfoPartition *Partition;
    POSITION pos;

    pos = m_PartitionInfo.GetHeadPosition();
    while (pos) {
        Partition = m_PartitionInfo.GetNext(pos);
        if (Partition->GetOffset() == Offset) {
            return(Partition);
        }
    }
    return(NULL);
}

CFtInfoPartition *
CFtInfoDisk::GetPartitionByIndex(
    DWORD Index
    )
{
    DWORD i = 0;
    CFtInfoPartition *Partition;
    POSITION pos;

    pos = m_PartitionInfo.GetHeadPosition();
    while (pos) {
        Partition = m_PartitionInfo.GetNext(pos);
        if (i == Index) {
            return(Partition);
        }
        ++i;
    }
    return(NULL);
}


DWORD
CFtInfoDisk::FtPartitionCount(
    VOID
    )
/*++

Routine Description:

    Returns the number of FT partitions on this disk. This is useful
    for determining whether a given FT set shares this disk with another
    FT set.

Arguments:

    None

Return Value:

    The number of FT partitions on this disk

--*/

{
    POSITION pos;
    CFtInfoPartition *Partition;
    DWORD Count = 0;

    pos = m_PartitionInfo.GetHeadPosition();
    while (pos) {
        Partition = m_PartitionInfo.GetNext(pos);
        if (Partition->IsFtPartition()) {
            ++Count;
        }
    }

    return(Count);
}

DWORD
CFtInfoDisk::GetSize(
    VOID
    )
{
    return(sizeof(DISK_DESCRIPTION) +
           (m_PartitionCount-1) * sizeof(DISK_PARTITION));
}

VOID
CFtInfoDisk::GetData(
    PBYTE pDest
    )
{
    PDISK_DESCRIPTION Description = (PDISK_DESCRIPTION)pDest;
    DWORD i;
    CFtInfoPartition *Partition;

    DISKLOG(("CFtInfoDisk::GetData signature %08lx has %d partitions\n",m_Signature, m_PartitionCount));

    Description->NumberOfPartitions = (USHORT)m_PartitionCount;
    Description->ReservedShort = 0;
    Description->Signature = m_Signature;

    POSITION pos = m_PartitionInfo.GetHeadPosition();
    i=0;
    while (pos) {
        Partition = m_PartitionInfo.GetNext(pos);
        Partition->GetData(&Description->Partitions[i]);
        ++i;
    }
}


//********************
//
// Implementation of FT registry information
//
//********************

BOOL
CFtInfoFtSet::Initialize(USHORT Type, FT_STATE FtVolumeState)
{
    m_Modified = TRUE;
    m_FtDescription = (PFT_DESCRIPTION)LocalAlloc(LMEM_FIXED, sizeof(FT_DESCRIPTION));
    DISKASSERT(m_FtDescription);

    m_FtDescription->NumberOfMembers = 0;
    m_FtDescription->Type = Type;
    m_FtDescription->Reserved = 0;
    m_FtDescription->FtVolumeState = FtVolumeState;
    return(TRUE);
}

BOOL
CFtInfoFtSet::Initialize(
    CFtInfo *FtInfo,
    PFT_DESCRIPTION Description
    )
{
    m_FtDescription = Description;
    m_Modified = FALSE;

    //
    // Create the list of members.
    //
    CFtInfoDisk *Disk;
    CFtInfoPartition *Partition;
    PFT_MEMBER_DESCRIPTION Member;
    DWORD i;

    if (Description->NumberOfMembers == 0) {
        //
        // WINDISK will sometimes put FT sets with zero members in
        // the registry after breaking a mirror set. Throw them out,
        // seems pretty pointless...
        //
        DISKLOG(("CFtInfoFtSet::Initialize - FT Set with zero members ignored\n"));
        return(FALSE);
    }

    m_Members.SetSize(Description->NumberOfMembers);
    for (i=0; i<Description->NumberOfMembers; i++) {
        Member = &Description->FtMemberDescription[i];

        //
        // Find the disk by its signature
        //
        Disk = FtInfo->FindDiskInfo(Member->Signature);
        if (Disk == NULL) {
            DISKLOG(("CFtInfoFtSet::Initialize - Disk signature %08lx not found\n",
                    Member->Signature));
            return(FALSE);
        }

        //
        // Find the partition by its offset.
        //
        Partition = Disk->GetPartitionByOffset(Member->OffsetToPartitionInfo);
        if (Partition == NULL) {
            DISKLOG(("CFtInfoFtSet::Initialize - Partition on disk %08lx at offset %08lx not found\n",
                     Member->Signature,
                     Member->OffsetToPartitionInfo));
            return(FALSE);
        }

        //
        // Add this partition to our list.
        //
        if (Partition->m_PartitionInfo->FtMember >= Description->NumberOfMembers) {
            DISKLOG(("CFtInfoFtSet::Initialize - member %d out of range\n",
                      Partition->m_PartitionInfo->FtMember));
            return(FALSE);
        }
        if (m_Members[Partition->m_PartitionInfo->FtMember] != NULL) {
            DISKLOG(("CFtInfoFtSet::Initialize - Duplicate member %d\n",
                      Partition->m_PartitionInfo->FtMember));
            return(FALSE);
        }
        m_Members.SetAt(Partition->m_PartitionInfo->FtMember, Partition);
    }
    return(TRUE);
}

CFtInfoFtSet::~CFtInfoFtSet()
{
    if (m_Modified) {
        LocalFree(m_FtDescription);
    }
}

BOOL
CFtInfoFtSet::operator==(
    const CFtInfoFtSet& FtSet1
    )
{
    DWORD MemberCount;
    DWORD i;
    CFtInfoDisk *Disk1;
    CFtInfoDisk *Disk2;

    if (GetType() != FtSet1.GetType()) {
        return(FALSE);
    }
    if (GetState() != FtSet1.GetState()) {
        return(FALSE);
    }
    MemberCount = GetMemberCount();
    if (MemberCount != FtSet1.GetMemberCount()) {
        return(FALSE);
    }
    for (i=0; i<MemberCount; i++) {
        Disk1 = GetMemberByIndex(i)->m_ParentDisk;
        Disk2 = FtSet1.GetMemberByIndex(i)->m_ParentDisk;
        if (!(*Disk1 == *Disk2)) {
            return(FALSE);
        }
    }
    DISKLOG(("CFtInfoFtSet::operator== FT information matches\n"));

    return(TRUE);
}

DWORD
CFtInfoFtSet::GetSize(
    VOID
    ) const
{
    return(sizeof(FT_DESCRIPTION) +
           (m_FtDescription->NumberOfMembers-1) * sizeof(FT_MEMBER_DESCRIPTION));
}

VOID
CFtInfoFtSet::GetData(
    PBYTE pDest
    )
{
    PFT_DESCRIPTION Description = (PFT_DESCRIPTION)pDest;

    DWORD Size = GetSize();
    CopyMemory(Description, m_FtDescription, Size);

    //
    // Now go through the partitions and update the offsets.
    //
    DWORD i;
    CFtInfoPartition *Partition;
    for (i=0; i<GetMemberCount(); i++) {
        Partition = m_Members[i];
        Description->FtMemberDescription[i].OffsetToPartitionInfo = Partition->GetOffset();
    }
}


BOOL
CFtInfoFtSet::IsAlone(
    VOID
    )
/*++

Routine Description:

    Returns whether or not this FT set has a disk in common with
    any other FT set.

Arguments:

    None

Return Value:

    TRUE if this FT set does not share any physical disk with any other
         FT set

    FALSE if there is another FT set sharing a disk as this one.

--*/

{
    //
    // Go through each member of the FT set and see if any disk has
    // more than one partition that is marked as an FT partition.
    //

    POSITION pos;
    CFtInfoPartition *Partition;
    CFtInfoDisk *Disk;
    DWORD i;

    for (i=0; i<GetMemberCount(); i++) {
        Partition = m_Members[i];
        Disk = Partition->m_ParentDisk;

        if (Disk->FtPartitionCount() > 1) {
            //
            // This disk has more than one FT partition, so there must be
            // another set sharing it.
            //
            return(FALSE);
        }

    }
    return(TRUE);

}

CFtInfoPartition *
CFtInfoFtSet::GetMemberBySignature(
    IN DWORD Signature
    ) const
{
    CFtInfoPartition *Partition;
    DWORD i;

    for (i=0; i<GetMemberCount(); i++) {
        Partition = m_Members[i];
        if (Partition->m_ParentDisk->m_Signature == Signature) {
            return(Partition);
        }
    }

    return(NULL);
}

CFtInfoPartition *
CFtInfoFtSet::GetMemberByIndex(
    IN DWORD Index
    ) const
{
    CFtInfoPartition *Partition;

    if (Index >= GetMemberCount()) {
        return(NULL);
    }
    return(m_Members[Index]);
}

DWORD
CFtInfoFtSet::AddMember(
    CFtInfoPartition *Partition,
    PFT_MEMBER_DESCRIPTION Description,
    USHORT FtGroup
    )
{
    DWORD MemberCount;
    PFT_DESCRIPTION NewBuff;
    PFT_MEMBER_DESCRIPTION NewMember;

    MemberCount = GetMemberCount();

    if (MemberCount > 0) {
        //
        // Grow the size of our structure.
        //
        if (m_Modified) {
            NewBuff = (PFT_DESCRIPTION)LocalReAlloc(m_FtDescription,
                                       sizeof(FT_DESCRIPTION) + MemberCount*sizeof(FT_MEMBER_DESCRIPTION),
                                       LMEM_MOVEABLE);
            if (NewBuff == NULL) {
                return(ERROR_NOT_ENOUGH_MEMORY);
            }
            m_FtDescription = NewBuff;
        } else {
            m_Modified = TRUE;
            NewBuff = (PFT_DESCRIPTION)LocalAlloc(LMEM_FIXED,
                                                  sizeof(FT_DESCRIPTION) + MemberCount*sizeof(FT_MEMBER_DESCRIPTION));
            if (NewBuff == NULL) {
                return(ERROR_NOT_ENOUGH_MEMORY);
            }
            CopyMemory(NewBuff,
                       m_FtDescription,
                       sizeof(FT_DESCRIPTION) + (MemberCount-1)*sizeof(FT_MEMBER_DESCRIPTION));
            m_FtDescription = NewBuff;
        }
    }
    NewMember = &m_FtDescription->FtMemberDescription[MemberCount];

    //
    // Initialize the member description. Note that the OffsetToPartitionInfo
    // will be updated when the user does a GetData.
    //
    NewMember->State = Description->State;
    NewMember->ReservedShort = Description->ReservedShort;
    NewMember->Signature = Description->Signature;
    NewMember->LogicalNumber = Description->LogicalNumber;

    //
    // Add the partition to our list.
    //
    Partition->m_PartitionInfo->FtGroup = FtGroup;
    Partition->m_PartitionInfo->FtMember = (USHORT)MemberCount;
    m_Members.SetAtGrow(Partition->m_PartitionInfo->FtMember, Partition);
    m_FtDescription->NumberOfMembers = (USHORT)GetMemberCount();

    return(ERROR_SUCCESS);
}

//
// Some C wrappers used by the FT Set resource DLL
//
extern "C" {

PFT_INFO
DiskGetFtInfo(
    VOID
    )
{
    PFT_INFO FtInfo;

    FtInfo = (PFT_INFO)new CFtInfo;

    return(FtInfo);
}

VOID
DiskFreeFtInfo(
    PFT_INFO FtInfo
    )
{
    CFtInfo *Info;

    Info = (CFtInfo *)FtInfo;
    delete Info;
}


DWORD
DiskEnumFtSetSignature(
    IN PFULL_FTSET_INFO FtSet,
    IN DWORD MemberIndex,
    OUT LPDWORD MemberSignature
    )
/*++

Routine Description:

    Returns the signature of the N'th member of the FT set.

Arguments:

    FtSet - Supplies the FT information returned by DiskGetFullFtSetInfo

    MemberIndex - Supplies the 0-based index of the member to return.

    MemberSignature - Returns the signature of the MemberIndex'th member.

Return Value:

    ERROR_SUCCESS if successful

    ERROR_NO_MORE_ITEMS if the index is greather than the number of members

--*/

{
    CFtInfo *Info;
    CFtInfoFtSet *FtSetInfo;
    CFtInfoPartition *Partition;

    Info = new CFtInfo((PDISK_CONFIG_HEADER)FtSet);
    if (Info == NULL) {
        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    FtSetInfo = Info->EnumFtSetInfo(0);
    if (FtSetInfo == NULL) {
        //
        // There is no FT set information, so just return the signature of the n'th member
        //
        CFtInfoDisk *Disk;

        Disk = Info->EnumDiskInfo(MemberIndex);
        if (Disk == NULL) {
            return(ERROR_NO_MORE_ITEMS);
        } else {
            *MemberSignature = Disk->m_Signature;
            return(ERROR_SUCCESS);
        }
    }

    Partition = FtSetInfo->GetMemberByIndex(MemberIndex);
    if (Partition == NULL) {
        return(ERROR_NO_MORE_ITEMS);
    }

    *MemberSignature = Partition->m_ParentDisk->m_Signature;
    delete Info;
    return(ERROR_SUCCESS);

}


PFULL_FTSET_INFO
DiskGetFullFtSetInfo(
    IN PFT_INFO FtInfo,
    IN LPCWSTR lpszMemberList,
    OUT LPDWORD pSize
    )
/*++

Routine Description:

    Serializes the complete information from an FT set in a form
    suitable for saving to a file or the registry. These bits can
    be restored with DiskSetFullFtSetInfo.

Arguments:

    FtInfo - supplies the FT information

    lpszMemberList - Supplies a list of signatures. The list is in the
        REG_MULTI_SZ format.

    pSize - Returns the size of the FT information bytes.

Return Value:

    A pointer to the serializable FT information if successful.

    NULL on error

--*/

{
    PDISK_CONFIG_HEADER DiskConfig;
    DWORD Length;
    CFtInfo *OriginalInfo;
    CFtInfo *NewInfo;
    CFtInfoFtSet *FtSetInfo;
    CFtInfoPartition *FtPartitionInfo;
    PDISK_PARTITION Member;
    DWORD MemberCount;
    DWORD i;
    DWORD Index;
    DWORD Signature;
    LPCWSTR lpszSignature;
    DWORD MultiSzLength;
    WCHAR SignatureString[9];

    OriginalInfo = (CFtInfo *)FtInfo;
    MultiSzLength = ClRtlMultiSzLength(lpszMemberList);

    //
    // First, try to find an FT set that has the "identity" of at least one of the
    // supplied members. This is tricky because we need to make sure that if multiple
    // FT sets are broken and reformed with different members, only one FT resource
    // picks up each FT set. We will find a matching FT set if:
    //   - One of the supplied members is the first member of a mirror or volume set.
    //   - The supplied members make up N-1 members of an N member SWP.
    //   - The supplied members make up all the members of a stripe.
    //
    for (i=0; ; i++) {
        lpszSignature = ClRtlMultiSzEnum(lpszMemberList,
                                         MultiSzLength,
                                         i);
        if (lpszSignature == NULL) {
            DISKLOG(("DiskGetFullFtSetInfo: no FTSET containing members found\n"));
            FtSetInfo = NULL;
            break;
        }
        Signature = wcstoul(lpszSignature, NULL, 16);
        DISKLOG(("DiskGetFullFtSetInfo: looking for member %08lx\n", Signature));

        FtSetInfo = OriginalInfo->FindFtSetInfo(Signature);
        if (FtSetInfo == NULL) {
            DISKLOG(("DiskGetFullFtSetInfo: member %08lx is not in any FT set\n", Signature));
        } else {
            //
            // Check to see if this is the first member of a volume set or mirror
            //
            if ((FtSetInfo->GetType() == Mirror) ||
                (FtSetInfo->GetType() == VolumeSet)) {
                //
                // Now check to see if this member is the first member of the set.
                //
                if (FtSetInfo->GetMemberByIndex(0)->m_ParentDisk->m_Signature == Signature) {
                    //
                    // We have found a matching FT set.
                    //
                    DISKLOG(("DiskGetFullFtSetInfo: member %08lx found in FT set.\n", Signature));
                    break;
                }
            } else if ((FtSetInfo->GetType() == StripeWithParity) ||
                       (FtSetInfo->GetType() == Stripe)) {
                DWORD MaxMissing;

                //
                // Check to see if the supplied member list makes up N-1 of the members
                // of a stripe with parity or all the members of a stripe.
                //
                if (FtSetInfo->GetType() == StripeWithParity) {
                    MaxMissing = 1;
                } else {
                    MaxMissing = 0;
                }
                for (Index = 0; ; Index++) {
                    FtPartitionInfo = FtSetInfo->GetMemberByIndex(Index);
                    if (FtPartitionInfo == NULL) {
                        break;
                    }

                    //
                    // Try to find this signature in the passed in member list.
                    //
                    wsprintf(SignatureString, L"%08lX", FtPartitionInfo->m_ParentDisk->m_Signature);
                    if (ClRtlMultiSzScan(lpszMemberList,SignatureString) == NULL) {
                        //
                        // This FT set member is not in the supplied list.
                        //
                        DISKLOG(("DiskGetFullFtSetInfo: member %08lx missing from old member list\n",
                                 FtPartitionInfo->m_ParentDisk->m_Signature));
                        if (MaxMissing == 0) {
                            FtSetInfo = NULL;
                            break;
                        }
                        --MaxMissing;
                    }
                }
                if (FtSetInfo != NULL) {
                    //
                    // We have found a matching FT set
                    //
                    break;
                }
            }
        }
    }

    if (FtSetInfo != NULL) {
        //
        // An FT Set exists that contains one of the supplied members.
        // Create a new CFtInfo that contains nothing but the FT set and
        // its members.
        //
        NewInfo = new CFtInfo(FtSetInfo);
        if (NewInfo == NULL) {
            SetLastError(ERROR_INVALID_DATA);
            return(NULL);
        }

    } else {
        //
        // No FT Set contains any of the supplied members. Create a new CFtInfo
        // that contains disk entries for each of the supplied members, but no
        // FT set information. Any members which are members of an FT set will
        // be excluded, since they have been assimilated into another set.
        //
        NewInfo = new CFtInfo((CFtInfoFtSet *)NULL);
        if (NewInfo == NULL) {
            SetLastError(ERROR_INVALID_DATA);
            return(NULL);
        }

        //
        // Find each member in the original FT info and add it to the new
        // FT info.
        //
        for (i=0; ; i++) {
            CFtInfoDisk *DiskInfo;

            lpszSignature = ClRtlMultiSzEnum(lpszMemberList,
                                             MultiSzLength,
                                             i);
            if (lpszSignature == NULL) {
                break;
            }
            Signature = wcstoul(lpszSignature, NULL, 16);
            if (OriginalInfo->FindFtSetInfo(Signature) != NULL) {
                DISKLOG(("DiskGetFullFtSetInfo: removing member %08lx as it is already a member of another set.\n",Signature));
            } else {
                DiskInfo = OriginalInfo->FindDiskInfo(Signature);
                if (DiskInfo != NULL) {
                    CFtInfoDisk *NewDisk;
                    NewDisk = new CFtInfoDisk(DiskInfo);
                    if ( NewDisk == NULL ) {
                        SetLastError(ERROR_INVALID_DATA);
                        return(NULL);
                    }
                    DISKLOG(("DiskGetFullFtSetInfo: adding member %08lx to new FT info\n",Signature));
                    NewInfo->SetDiskInfo(NewDisk);
                } else {
                    DISKLOG(("DiskGetFullFtSetInfo: member %08lx not found in original FT info\n",Signature));
                }
            }
        }
    }

    //
    // Get the FT data
    //
    *pSize = NewInfo->GetSize();

    DiskConfig = (PDISK_CONFIG_HEADER)LocalAlloc(LMEM_FIXED, *pSize);
    if (DiskConfig == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }
    NewInfo->GetData(DiskConfig);
    delete NewInfo;
    return((PFULL_FTSET_INFO)DiskConfig);
}


PFULL_FTSET_INFO
DiskGetFullFtSetInfoByIndex(
    IN PFT_INFO FtInfo,
    IN DWORD Index,
    OUT LPDWORD pSize
    )
/*++

Routine Description:

    Serializes the complete information from an FT set in a form
    suitable for saving to a file or the registry. These bits can
    be restored with DiskSetFullFtSetInfo.

Arguments:

    FtInfo - supplies the FT information

    Index - Supplies the index

    pSize - Returns the size of the FT information bytes.

Return Value:

    A pointer to the serializable FT information if successful.

    NULL on error

--*/

{
    PDISK_CONFIG_HEADER DiskConfig;
    DWORD Length;
    CFtInfo *OriginalInfo;
    CFtInfo *NewInfo;
    CFtInfoFtSet *FtSetInfo;

    OriginalInfo = (CFtInfo *)FtInfo;
    FtSetInfo = OriginalInfo->EnumFtSetInfo(Index);
    if (FtSetInfo == NULL) {
        return(NULL);
    }
    //
    // Create a new CFtInfo that contains nothing but the FT set and
    // its members.
    //
    NewInfo = new CFtInfo(FtSetInfo);
    if (NewInfo == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    //
    // Get the FT data
    //
    *pSize = NewInfo->GetSize();
    DiskConfig = (PDISK_CONFIG_HEADER)LocalAlloc(LMEM_FIXED, *pSize);
    if (DiskConfig == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }
    NewInfo->GetData(DiskConfig);
    delete NewInfo;
    return((PFULL_FTSET_INFO)DiskConfig);
}


BOOL
DiskCheckFtSetLetters(
    IN PFT_INFO FtInfo,
    IN PFULL_FTSET_INFO Bytes,
    OUT WCHAR *Letter
    )
/*++

Routine Description:

    This routine checks to see if the FT set info conflicts with
    any already-defined sticky drive letters on the current system.
    If a conflict is found, the conflicting drive letter is returned.

Arguments:

    FtInfo - Supplies the FT information

    Bytes - Supplies the information returned from DiskGetFullFtSetInfo

Return Value:

    TRUE if no conflicts were detected

    FALSE if a conflict was detected. If it returns FALSE, *Letter will be
          set to the conflicting drive letter.

--*/

{
    CFtInfo *RegistryInfo;
    CFtInfo *NewInfo;
    CFtInfoDisk *Disk;
    CFtInfoFtSet *FtSet;
    DWORD i;

    RegistryInfo = (CFtInfo *)FtInfo;
    NewInfo = new CFtInfo((PDISK_CONFIG_HEADER)Bytes);
    if (NewInfo == NULL) {
        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY; 
    }

    //
    // Go through each physical disk in the FT set. For each one, see if
    // there is a physical disk in the registry information with a different
    // signature and the same drive letter. If so, we have a conflict.
    //
    FtSet = NewInfo->EnumFtSetInfo(0);
    DISKASSERT(FtSet != NULL);
    for (i=0; ; i++) {
        Disk = NewInfo->EnumDiskInfo(i);
        if (Disk == NULL) {
            break;
        }

        //
        // Go through each partition on this disk and look up the drive letter
        // in the registry information.
        //
        CFtInfoPartition *Partition;
        DWORD Index;
        for (Index = 0; ; Index++) {
            Partition = Disk->GetPartitionByIndex(Index);
            if (Partition == NULL) {
                break;
            }
            //
            // If this partition has an assigned drive letter,
            // check it out.
            //
            if (Partition->m_PartitionInfo->AssignDriveLetter) {

                //
                // See if there is an existing partition with this drive
                // letter already in the registry information
                //
                CFtInfoPartition *Existing;

                Existing = RegistryInfo->FindPartition(Partition->m_PartitionInfo->DriveLetter);
                if (Existing != NULL) {
                    //
                    // If the existing partition has a different signature than
                    // the new partition, we have found a conflict.
                    //
                    if (Existing->m_ParentDisk->m_Signature !=
                        Partition->m_ParentDisk->m_Signature) {
                        *Letter = (WCHAR)Partition->m_PartitionInfo->DriveLetter;
                        delete NewInfo;
                        return(FALSE);
                    }
                }
            }
        }
    }

    delete NewInfo;
    return(TRUE);

}


DWORD
DiskSetFullFtSetInfo(
    IN PFT_INFO FtInfo,
    IN PFULL_FTSET_INFO Bytes
    )
/*++

Routine Description:

    Restores the complete information from an FT set to the DISK
    key in the registry. The FT set information must have been
    returned from DiskGetFullFtSetInfo.

Arguments:

    FtInfo - supplies the FT information

    Bytes - Supplies the information returned from DiskGetFullFtSetInfo.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error otherwise

--*/

{
    CFtInfo *RegistryInfo;
    CFtInfo *NewInfo;
    CFtInfoFtSet *OldFtSet=NULL;
    CFtInfoFtSet *NewFtSet=NULL;
    CFtInfoDisk *Disk;
    DWORD i;
    BOOL Modified = FALSE;
    DWORD Status;

    RegistryInfo = (CFtInfo *)FtInfo;
    NewInfo = new CFtInfo((PDISK_CONFIG_HEADER)Bytes);
    if (NewInfo == NULL) {
        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // If the new information contains an FT set, merge that into the
    // current registry.
    //
    if (NewInfo->EnumFtSetInfo(0) != NULL) {
        //
        // Find an FT set in the registry that has a signature
        // that is the same as one of those in the restored FT set.
        //
        NewFtSet = NewInfo->EnumFtSetInfo(0);
        DISKASSERT(NewFtSet != NULL);

        for (i=0; ; i++) {
            Disk = NewInfo->EnumDiskInfo(i);
            if (Disk == NULL) {
                break;
            }

            //
            // Try and find an existing FT set containing this signature
            //
            OldFtSet = RegistryInfo->FindFtSetInfo(Disk->m_Signature);
            if (OldFtSet != NULL) {
                break;
            }
        }
        if (Disk == NULL) {
            //
            // No matching FT set was found. We can just add this one directly.
            //
            Modified = TRUE;
            RegistryInfo->AddFtSetInfo(NewFtSet);
        } else {
            if (!(*OldFtSet == *NewFtSet)) {
                Modified = TRUE;
                RegistryInfo->AddFtSetInfo(NewFtSet, OldFtSet);
            }
        }
    } else {
        //
        // There is no FT set in the new registry. This will happen if a mirror
        // set gets broken. For each member in the new information, delete any
        // FT sets that it is a part of and merge it into the registry.
        //
        for (i=0; ; i++) {
            Disk = NewInfo->EnumDiskInfo(i);
            if (Disk == NULL) {
                break;
            }
            Modified = TRUE;

            //
            // Remove any FT sets containing this signature
            //
            OldFtSet = RegistryInfo->FindFtSetInfo(Disk->m_Signature);
            if (OldFtSet != NULL) {
                RegistryInfo->DeleteFtSetInfo(OldFtSet);
            }

            //
            // Set the FT information for this member into the registry.
            //
            CFtInfoDisk *NewDisk;
            NewDisk = new CFtInfoDisk(Disk);
            if (NewDisk == NULL) {
                DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            RegistryInfo->SetDiskInfo(NewDisk);
        }
    }

    delete NewInfo;

    if (Modified) {
        //
        // Commit these changes to the Disk key
        //
        DISKLOG(("DiskSetFullFtSetInfo: committing changes to registry\n"));
        Status = RegistryInfo->CommitRegistryData();
    } else {
        DISKLOG(("DiskSetFullFtSetInfo: no changes detected\n"));
        Status = ERROR_SUCCESS;
    }

    return(Status);
}


DWORD
DiskDeleteFullFtSetInfo(
    IN PFT_INFO FtInfo,
    IN LPCWSTR lpszMemberList
    )
/*++

Routine Description:

    Deletes any FT set information for the specified members. This is
    used when a mirror set is broken.

Arguments:

    FtInfo - supplies the FT information

    lpszMemberList - Supplies the list of members whose FT information is to
        be deleted.

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise

--*/

{
    CFtInfo *OriginalInfo;
    DWORD Signature;
    LPCWSTR lpszSignature;
    DWORD MultiSzLength;
    CFtInfoFtSet *FtSetInfo;
    DWORD i;
    BOOL Modified = FALSE;
    DWORD Status;

    OriginalInfo = (CFtInfo *)FtInfo;
    MultiSzLength = ClRtlMultiSzLength(lpszMemberList);

    //
    // Go through each disk in the MultiSzLength and remove any FT information
    // for it.
    //
    for (i=0; ; i++) {
        lpszSignature = ClRtlMultiSzEnum(lpszMemberList,
                                         MultiSzLength,
                                         i);
        if (lpszSignature == NULL) {
            break;
        }
        Signature = wcstoul(lpszSignature, NULL, 16);
        DISKLOG(("DiskDeleteFullFtSetInfo: deleting member %1!08lx!\n", Signature));

        FtSetInfo = OriginalInfo->FindFtSetInfo(Signature);
        if (FtSetInfo == NULL) {
            DISKLOG(("DiskDeleteFullFtSetInfo: member %08lx is not in any FT set\n", Signature));
        } else {
            DISKLOG(("DiskDeleteFullFtSetInfo: member %08lx found. \n", Signature));
            Modified = TRUE;
            OriginalInfo->DeleteFtSetInfo(FtSetInfo);
        }
    }

    if (Modified) {
        //
        // Commit these changes to the Disk key
        //
        DISKLOG(("DiskDeleteFullFtSetInfo: committing changes to registry\n"));
        Status = OriginalInfo->CommitRegistryData();
    } else {
        DISKLOG(("DiskDeleteFullFtSetInfo: no changes detected\n"));
        Status = ERROR_SUCCESS;
    }

    return(Status);
}
#if 0

FT_TYPE
DiskFtInfoGetType(
    IN PFULL_FTSET_INFO FtSet
    )
/*++

Routine Description:

    Returns the type of FT set

Arguments:

    FtSet - Supplies the FT set information

Return Value:

    FT_TYPE of the supplied FT set.

--*/

{
    FT_TYPE Type;
    CFtInfo *Info;
    CFtInfoFtSet *FtSetInfo;

    Info = new CFtInfo((PDISK_CONFIG_HEADER)FtSet);
    if (Info == NULL) {
        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
        // [REENGINEER] will AV in a second
    }

    FtSetInfo = Info->EnumFtSetInfo(0);
    if (FtSetInfo == NULL) {
        Type = NotAnFtMember;
    } else {
        Type = (FT_TYPE)FtSetInfo->GetType();
    }

    delete Info;

    return(Type);
}
#endif

VOID
DiskMarkFullFtSetDirty(
    IN PFULL_FTSET_INFO FtSet
    )
/*++

Routine Description:

    Changes the FT set information so that when it is mounted by FTDISK
    the redundant information will be regenerated. This is necessary because
    FTDISK only looks at the FT_REGISTRY dirty bit at boot time. By doing
    this, we simulate a per-FT Set dirty bit that FT will respect when
    sets are brought online after boot.

    Magic algorithm from norbertk:
        If (and only if) the entire FT set is healthy
            If the set is a mirror
                set state of second member to SyncRedundantCopy
            If the set is a SWP
                set state of first member to SyncRedundantCopy

Arguments:

    FtSet - Supplies the FT set information returned from DiskGetFullFtSetInfo

Return Value:

    None.

--*/

{
    DWORD i;
    CFtInfo *Info;
    CFtInfoFtSet *FtSetInfo;
    CFtInfoPartition *Partition;
    USHORT FtType;

    Info = new CFtInfo((PDISK_CONFIG_HEADER)FtSet);
    if (Info == NULL) {
        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
        return; // [REENGINEER] we avoided an AV but the caller won't know
    }

    FtSetInfo = Info->EnumFtSetInfo(0);
    if (FtSetInfo != NULL) {
        //
        // Check all the members to see if they are all healthy.
        //
        for (i=0; ; i++) {
            Partition = FtSetInfo->GetMemberByIndex(i);
            if (Partition == NULL) {
                break;
            } else {
                if (Partition->m_PartitionInfo->FtState != Healthy) {
                    break;
                }
            }
        }
        if (Partition == NULL) {
            //
            // All the members are marked healthy. Set one of them to
            // SyncRedundantCopy to force a regen.
            //
            FtType = FtSetInfo->GetType();
            if ((FtType == Mirror) || (FtType == StripeWithParity)) {
                if (FtType == Mirror) {
                    Partition = FtSetInfo->GetMemberByIndex(1);
                } else {
                    Partition = FtSetInfo->GetMemberByIndex(0);
                }
                if ( Partition != NULL ) {
                    Partition->m_PartitionInfo->FtState = SyncRedundantCopy;
                }

                //
                // Get the modified FT data
                //
                Info->GetData((PDISK_CONFIG_HEADER)FtSet);
            }
        }
    }

    delete Info;
}
#if 0

BOOL
DiskFtInfoEqual(
    IN PFULL_FTSET_INFO Info1,
    IN PFULL_FTSET_INFO Info2
    )
/*++

Routine Description:

    Compares two FT set information structures to see if they are semantically
    identical (no change).

Arguments:

    Info1 - Supplies the first information (returned from DiskGetFullFtSetInfo)

    Info2 - Supplies the second information (returned from DiskGetFullFtSetInfo)

Return Value:

    TRUE if the structures are identical (there has been no change)

    FALSE if the structures are different.

--*/

{
    CFtInfo *FtInfo1;
    CFtInfo *FtInfo2;
    CFtInfoFtSet *FtSet1;
    CFtInfoFtSet *FtSet2;
    PDISK_CONFIG_HEADER Config1;
    PDISK_CONFIG_HEADER Config2;
    BOOL Result;

    Config1 = (PDISK_CONFIG_HEADER)Info1;
    Config2 = (PDISK_CONFIG_HEADER)Info2;

    FtInfo1 = new CFtInfo(Config1);
    if (FtInfo1 == NULL) {
        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
        // [Unused Code] will AV in a second
    }
    FtInfo2 = new CFtInfo(Config2);
    if (FtInfo2 == NULL) {
        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
        // [Unused Code] will AV in a second
    }

    FtSet1 = FtInfo1->EnumFtSetInfo(0);
    FtSet2 = FtInfo2->EnumFtSetInfo(0);
    if ((FtSet1 == NULL) || (FtSet2 == NULL)){
        //
        // If there is no FT set in one of the structures, there must be no
        // FT set in both of the structures.
        //
        if ((FtSet1 != NULL) || (FtSet2 != NULL)) {
            Result = FALSE;
        } else {
            DWORD i;
            CFtInfoDisk *Disk1, *Disk2;
            //
            // Neither structure has an FT Set, so we must compare each of the
            // members individually to see if they are equal.
            //
            for (i=0; ;i++) {
                Disk1 = FtInfo1->EnumDiskInfo(i);
                Disk2 = FtInfo2->EnumDiskInfo(i);
                if ((Disk1 == NULL) && (Disk2 == NULL)) {
                    //
                    // Everything compared ok until the end of the list.
                    //
                    Result = TRUE;
                    break;
                }
                if ((Disk1 == NULL) || (Disk2 == NULL)) {
                    //
                    // A different number of members in each list.
                    //
                    Result = FALSE;
                    break;
                }
                if (!(*Disk1 == *Disk2)) {
                    Result = FALSE;
                    break;
                }
            }

        }

    } else {
        if (*FtSet1 == *FtSet2) {
            Result = TRUE;
        } else {
            Result = FALSE;
        }
    }


    delete(FtInfo1);
    delete(FtInfo2);
    return(Result);
}
#endif

PFULL_DISK_INFO
DiskGetFullDiskInfo(
    IN PFT_INFO DiskInfo,
    IN DWORD Signature,
    OUT LPDWORD pSize
    )
/*++

Routine Description:

    Serializes the complete information from a disk in a form
    suitable for saving to a file or the registry. These bits can
    be restored with DiskSetFullDiskInfo.

Arguments:

    DiskInfo - supplies the disk information.

    Signature - Supplies the signature.

    pSize - Returns the size of the disk information in bytes.

Return Value:

    A pointer to the serializable disk information if successful.

    NULL on error

--*/

{
    PDISK_CONFIG_HEADER DiskConfig;
    DWORD Length;
    CFtInfo *OriginalInfo;
    CFtInfo *NewInfo;
    CFtInfoDisk *FtDiskInfo;
    CFtInfoDisk *NewDiskInfo;

    OriginalInfo = (CFtInfo *)DiskInfo;

    //
    // First, try to find a disk that matches the supplied signature.
    //
    DISKLOG(("DiskGetFullDiskInfo: looking for signature %08lx\n", Signature));

    FtDiskInfo = OriginalInfo->FindDiskInfo(Signature);
    if (FtDiskInfo == NULL) {
        DISKLOG(("DiskGetFullDiskInfo: signature %08lx not found\n", Signature));
        SetLastError(ERROR_INVALID_DATA);
        return(NULL);
    }

    //
    // Create a new CFtInfo that contains no disk information.
    //
    NewInfo = new CFtInfo((CFtInfoFtSet *)NULL);
    if (NewInfo == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    NewDiskInfo = new CFtInfoDisk(FtDiskInfo);
    if (NewDiskInfo == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    //
    // Disk info already exists. Use that data.
    //
    NewInfo->SetDiskInfo(NewDiskInfo);

    //
    // Get the disk data
    //
    *pSize = NewInfo->GetSize();

    DiskConfig = (PDISK_CONFIG_HEADER)LocalAlloc(LMEM_FIXED, *pSize);
    if (DiskConfig == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }
    NewInfo->GetData(DiskConfig);
    delete NewInfo;
    return((PFULL_DISK_INFO)DiskConfig);

} // DiskGetFullDiskInfo



DWORD
DiskSetFullDiskInfo(
    IN PFT_INFO DiskInfo,
    IN PFULL_DISK_INFO Bytes
    )

/*++

Routine Description:

    Restores the complete information from a disk to the DISK
    key in the registry. The disk information must have been
    returned from DiskGetFullDiskInfo.

Arguments:

    DiskInfo - supplies the disk information

    Bytes - Supplies the information returned from DiskGetFullDiskInfo.

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error otherwise

--*/

{
    CFtInfo *RegistryInfo;
    CFtInfo *NewInfo;
    CFtInfoDisk *OldDisk=NULL;
    CFtInfoDisk *NewDisk=NULL;
    CFtInfoDisk *Disk;
    DWORD Status;

    RegistryInfo = (CFtInfo *)DiskInfo;
    NewInfo = new CFtInfo((PDISK_CONFIG_HEADER)Bytes);
    if (NewInfo == NULL) {
        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    DISKASSERT(NewInfo->EnumFtSetInfo(0) == NULL); // No FT sets
    DISKASSERT(NewInfo->EnumDiskInfo(1) == NULL);  // No more than 1 disk

    //
    // There is no FT set in the new registry. This will happen if a mirror
    // set gets broken. For each member in the new information, delete any
    // FT sets that it is a part of and merge it into the registry.
    //
    Disk = NewInfo->EnumDiskInfo(0);
    if ( Disk == NULL ) {
        DISKLOG(("DiskSetFullDiskInfo: no disks detected\n"));
        return(ERROR_SUCCESS);
    }

    //
    // Remove old data containing this signature
    //
    OldDisk = RegistryInfo->FindDiskInfo(Disk->m_Signature);
    if (OldDisk != NULL) {
        RegistryInfo->DeleteDiskInfo(Disk->m_Signature);
    }

    //
    // Set the disk information for this disk into the registry.
    //
    NewDisk = new CFtInfoDisk(Disk);
    if (NewDisk == NULL) {
        DISKERR(IDS_GENERAL_FAILURE, ERROR_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    RegistryInfo->SetDiskInfo(NewDisk);

    delete NewInfo;

    //
    // Commit these changes to the Disk key
    //
    DISKLOG(("DiskSetFullDiskInfo: committing changes to registry\n"));
    Status = RegistryInfo->CommitRegistryData();

    return(Status);

} // DiskSetFullDiskInfo

PFT_INFO
DiskGetFtInfoFromFullDiskinfo(
    IN PFULL_DISK_INFO Bytes
    )
{
   CFtInfo* DiskInfo = new CFtInfo((PDISK_CONFIG_HEADER)Bytes);
   if (DiskInfo) {
      SetLastError(ERROR_SUCCESS);
   } else {
      SetLastError(ERROR_OUTOFMEMORY);
   }

   return reinterpret_cast<PFT_INFO>(DiskInfo);
} // DiskGetFtInfoFromFullDiskinfo //


DWORD
DiskAddDiskInfoEx(
    IN PFT_INFO DiskInfo,
    IN DWORD DiskIndex,
    IN DWORD Signature,
    IN DWORD Options
    )

/*++

Routine Description:

    Adds an NT4 style DISK registry entry for the specified
    disk. Used to handle new disks being added to the system
    after the cluster service has started. On NT4, windisk would
    have been run to configure the disk and generate an entry
    in the DISK key. On NT5, the DISK is no longer maintained by
    the disk stack; most of the code in this module depends on
    windisk maintaining this key. For NT5,

Arguments:

    DiskIndex - the physical drive number for the new drive

    Signature - the signature of the drive; used for sanity checking

    Options - 0 or combination of the following:

        DISKRTL_REPLACE_IF_EXISTS: Replace the information for the
                                   disk if it is already exists

        DISKRTL_COMMIT: If this flag is set then registry key System\DISK
                        is updated with a new information
Return Value:

    ERROR_SUCCESS if successful.

    Win32 error otherwise

--*/

{
    DWORD status = ERROR_SUCCESS;
    CFtInfo * diskInfo;
    CFtInfoDisk * newDisk, * oldDisk;
    WCHAR physDriveBuff[100];
    HANDLE hDisk;
    PDRIVE_LAYOUT_INFORMATION driveLayout;

    diskInfo = (CFtInfo *)DiskInfo;

    //
    // read in the drive layout data for this new drive
    //

    wsprintf(physDriveBuff, L"\\\\.\\PhysicalDrive%d", DiskIndex);
    hDisk = CreateFile(physDriveBuff,
                       GENERIC_READ,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);
    if (hDisk == INVALID_HANDLE_VALUE) {
        return GetLastError();
    }

    if (ClRtlGetDriveLayoutTable( hDisk, &driveLayout, NULL )) {
        //
        // make sure signatures line up and that a
        // description for this disk doesn't already exist
        //
        if ( Signature == driveLayout->Signature ) {

            oldDisk = diskInfo->FindDiskInfo(Signature);

            if (oldDisk != NULL) {
               if (Options & DISKRTL_REPLACE_IF_EXISTS) {
                  diskInfo->DeleteDiskInfo(Signature);
                  oldDisk = NULL;
               }
            }
            if ( oldDisk == NULL ) {

                //
                // Pull in a copy of the existing data in the registry
                // and initialize a new disk and its associated partitions.
                //

                newDisk = new CFtInfoDisk( driveLayout );

                if ( newDisk != NULL ) {

                    //
                    // add the disk to the current database and
                    // commit the updated database to the registry
                    //
                    diskInfo->AddDiskInfo( newDisk );
                    if (Options & DISKRTL_COMMIT) {
                       status = diskInfo->CommitRegistryData();
                    } else {
                       status = ERROR_SUCCESS;
                    }
                } else {
                    status = ERROR_OUTOFMEMORY;
                }
            } else {
                status = ERROR_ALREADY_EXISTS;
            }
        } else {
            status = ERROR_INVALID_PARAMETER;
        }
        LocalFree( driveLayout );
    } else {
       status = GetLastError();
    }

    CloseHandle( hDisk );

    return status;

} // DiskAddDiskEx

DWORD
DiskAddDriveLetterEx(
    IN PFT_INFO DiskInfo,
    IN DWORD Signature,
    IN LARGE_INTEGER StartingOffset,
    IN LARGE_INTEGER PartitionLength,
    IN UCHAR DriveLetter,
    IN DWORD Options
    )

/*++

Routine Description:

    Add a drive letter to the specified partition

Arguments:

    Signature - the signature of the drive; used for sanity checking

    StartingOffset
    PartitionLength - describes which partition

    DriveLetter - letter to be associated with this partition

    Options - if DISKRTL_COMMIT flag is set then registry System\DISK
              is immedately updated with a new information

Return Value:

    ERROR_SUCCESS if successful.

    Win32 error otherwise

--*/

{
    DWORD status;
    CFtInfo * diskInfo;
    CFtInfoPartition * partInfo;

    diskInfo = (CFtInfo *)DiskInfo;

    partInfo = diskInfo->FindPartition( Signature, StartingOffset, PartitionLength );

    if ( partInfo != NULL ) {
        partInfo->MakeSticky( DriveLetter );
        if (Options & DISKRTL_COMMIT) {
           status = diskInfo->CommitRegistryData();
        } else {
           status = ERROR_SUCCESS;
        }
    } else {
        status = ERROR_INVALID_PARAMETER;
    }

    return status;
}

DWORD
DiskCommitFtInfo(
    IN PFT_INFO FtInfo
    )
{
    CFtInfo * info = reinterpret_cast<CFtInfo*>( FtInfo );
    DWORD     status = info->CommitRegistryData();

    return status;
}

PFT_DISK_INFO
FtInfo_GetFtDiskInfoBySignature(
    IN PFT_INFO FtInfo,
    IN DWORD Signature
    )
/*++

Routine Description:

    Finds an information for a particular drive

Arguments:

    DiskInfo - supplies the disk information

    Signature - describes which drive

Return Value:

    NULL - if not found
    CFtInfoDisk - otherwise

--*/
{
   CFtInfo* Info = reinterpret_cast<CFtInfo *>(FtInfo);
   PFT_DISK_INFO result = reinterpret_cast<PFT_DISK_INFO>(Info->FindDiskInfo(Signature));

   if (result == 0) {
      SetLastError(ERROR_FILE_NOT_FOUND);
   }

   return result;
} // FtInfo_GetFtDiskInfoBySignature //


DISK_PARTITION UNALIGNED *
FtDiskInfo_GetPartitionInfoByIndex(
    IN PFT_DISK_INFO DiskInfo,
    IN DWORD         Index
    )

/*++

Routine Description:

    Get Drive Letter for a partition specified by an offset

Arguments:

    DiskInfo - supplies the disk information

    index - describes which partition (0 based)

Return Value:

    PDISK_PARTITION stucture or NULL

    if return value is NULL, SetLastError value is set as follows:

    ERROR_FILE_NOT_FOUND: if partition cannot be found

    ERROR_INVALID_HANDLE: if partition is found, but m_PartitionInfo is unassigned

--*/
{
   CFtInfoDisk* Info = reinterpret_cast<CFtInfoDisk*>(DiskInfo);
   CFtInfoPartition* Partition = Info->GetPartitionByIndex( Index );

   if (Partition == 0) {
      SetLastError(ERROR_FILE_NOT_FOUND);
      return NULL;
   }

   if (Partition->m_PartitionInfo == 0) {
      SetLastError(ERROR_INVALID_HANDLE);
      return 0;
   }

   return Partition->m_PartitionInfo;

} // FtDiskInfo_GetDriveLetterByIndex //

DWORD
FtDiskInfo_GetPartitionCount(
    IN PFT_DISK_INFO DiskInfo
    )
{
   CFtInfoDisk* Info = reinterpret_cast<CFtInfoDisk*>(DiskInfo);
   return Info->m_PartitionCount;
} // FtDiskInfo_GetPartitionCount //

} // extern C
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\eventlog.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    eventlog.c

Abstract:

    This module provides common eventlog services for the cluster service

Author:

    John Vert (jvert) 9/13/1996

Revision History:

--*/
#define UNICODE 1
#include "clusrtlp.h"

HANDLE           LocalEventLog=NULL;
CRITICAL_SECTION EventLogLock;

//
// [GN] June 19/1999: added Async EventReporting
//
// Use ClRtlEventLogSetWorkQueue to set a queue
// for async event reporting. If it the queue is not set,
// event reporting is synchronous as it used to be before
//

static CLRTL_WORK_ITEM EvtReporterWorkItem;
static PCLRTL_WORK_QUEUE EvtReporterWorkQueue;

typedef struct _EVENT_LOG_PACKET {
    WORD       wType;
    WORD       wCategory;
    DWORD      dwEventID;
    WORD       wNumStrings;
    DWORD      dwDataSize;
    LPVOID     lpRawData;
    LPWSTR     lpStrings[0];
} *PEVENT_LOG_PACKET, EVENT_LOG_PACKET;

VOID
ClRtlEventLogSetWorkQueue(
    PCLRTL_WORK_QUEUE WorkQueue
    )
{
    EnterCriticalSection( &EventLogLock );

    EvtReporterWorkQueue = WorkQueue;
    
    LeaveCriticalSection( &EventLogLock );
}

VOID
EvtReporter(
    IN PCLRTL_WORK_ITEM   WorkItem,
    IN DWORD              Status,
    IN DWORD              BytesTransferred,
    IN ULONG_PTR          IoContext
    )
/*++

Routine Description:

    Reports queued event via advapi32!ReportEvent

Arguments:

     IoContext == EVENT_LOG_PACKET

Return Value:

     None

--*/
{
    PEVENT_LOG_PACKET data = (PEVENT_LOG_PACKET)IoContext;
    
    ReportEventW(LocalEventLog,
                 data->wType,
                 data->wCategory,
                 data->dwEventID,
                 NULL,
                 data->wNumStrings,
                 data->dwDataSize,
                 data->lpStrings,
                 data->lpRawData);
    LocalFree(data);
}



VOID
ClRtlEventLogInit(
    VOID
    )
/*++

Routine Description:

    initializes the event log

Arguments:

    None

Return Value:

    None

--*/

{

    InitializeCriticalSection(&EventLogLock);

    EvtReporterWorkQueue = 0;
    
    ClRtlInitializeWorkItem(
        &EvtReporterWorkItem,
        EvtReporter,
        0
        );
}

VOID
ClRtlEventLogCleanup(
    VOID
    )
{
    DeleteCriticalSection( &EventLogLock );
}

PEVENT_LOG_PACKET
ClRtlpBuildEventPacket(
    WORD       wType,
    WORD       wCategory,
    DWORD      dwEventID,
    WORD       wNumStrings,
    DWORD      dwDataSize,
    LPCWSTR   *lpStrings,
    LPVOID     lpRawData
    )
{
    PEVENT_LOG_PACKET data = 0;
    DWORD Count;
    UINT  i;
    LPBYTE ptr;

    Count = sizeof(EVENT_LOG_PACKET) + 
            dwDataSize + 
            wNumStrings * (sizeof(LPCWSTR) + sizeof(UNICODE_NULL));

    for (i = 0; i < wNumStrings; ++i) {
        int len = lstrlenW( lpStrings[i] );
        Count += len * sizeof(WCHAR); // (null is already accounted for)
    }

    data = LocalAlloc(LMEM_FIXED, Count);
    if (!data) {
        return 0;
    }

    data->wType     = wType;
    data->wCategory = wCategory;
    data->dwEventID = dwEventID;
    data->wNumStrings = wNumStrings;
    data->dwDataSize = dwDataSize;
    data->lpRawData =  &data->lpStrings[wNumStrings];
    // lpStrings will be filled later

    if (dwDataSize) {
        CopyMemory(data->lpRawData, lpRawData, dwDataSize);
    }

    ptr = (LPBYTE)data->lpRawData + dwDataSize;
    for (i = 0; i < wNumStrings; ++i) {
        int nBytes = (lstrlenW( lpStrings[i] ) + 1) * sizeof(WCHAR);
        CopyMemory(ptr, lpStrings[i], nBytes);
        data->lpStrings[i] = (LPWSTR)ptr;
        ptr += nBytes;
    }

    CL_ASSERT(ptr <= (LPBYTE)data + Count); 
    return data;
}




VOID
ClRtlpReportEvent(
    WORD       wType,
    WORD       wCategory,
    DWORD      dwEventID,
    WORD       wNumStrings,
    DWORD      dwDataSize,
    LPCWSTR   *lpStrings,
    LPVOID     lpRawData
    )
/*++

Routine Description:

    Common routine for reporting an event to the event log. Opens a handle
    to the event log if necessary.

Arguments:

    Identical arguments to ReportEventW

Return Value:

    None

--*/

{
    BOOL Success = FALSE;
    DWORD Status;

    //
    // If the event log hasn't been opened, try and open it now.
    //
    if (LocalEventLog == NULL) {
        EnterCriticalSection(&EventLogLock);
        if (LocalEventLog == NULL) {
            LocalEventLog = RegisterEventSource(NULL, L"ClusSvc");
        }
        LeaveCriticalSection(&EventLogLock);
        if (LocalEventLog == NULL) {
            Status = GetLastError();
            return;
        }
    }

    if (EvtReporterWorkQueue) {
        PEVENT_LOG_PACKET data = 
            ClRtlpBuildEventPacket(wType,
                                   wCategory,
                                   dwEventID,
                                   wNumStrings,
                                   dwDataSize,
                                   lpStrings,
                                   lpRawData);
        if (data) {
            EnterCriticalSection( &EventLogLock );
            if (EvtReporterWorkQueue) {
                Status = ClRtlPostItemWorkQueue(
                            EvtReporterWorkQueue,
                            &EvtReporterWorkItem,
                            0,
                            (ULONG_PTR)data
                            );
                if (Status == ERROR_SUCCESS) {
                    // worker will free data //
                    data = NULL;
                    Success = TRUE;
                }
            }
            LeaveCriticalSection( &EventLogLock );
            LocalFree( data ); // free(0) is OK
            if (Success) {
                return;
            }
        }
    }

    Success = ReportEventW(LocalEventLog,
                           wType,
                           wCategory,
                           dwEventID,
                           NULL,
                           wNumStrings,
                           dwDataSize,
                           lpStrings,
                           lpRawData);

}


VOID
ClusterLogEvent0(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes
    )
/*++

Routine Description:

    Logs an event to the event log

Arguments:

    LogLevel - Supplies the logging level, one of
                LOG_CRITICAL 1
                LOG_UNUSUAL  2
                LOG_NOISE    3

    LogModule - Supplies the module ID.

    FileName - Supplies the filename of the caller

    LineNumber - Supplies the line number of the caller

    MessageId - Supplies the message ID to be logged.

    dwByteCount - Supplies the number of error-specific bytes to log. If this
        is zero, lpBytes is ignored.

    lpBytes - Supplies the error-specific bytes to log.

Return Value:

    None.

--*/

{
    BOOL Success;
    DWORD Status;
    WORD wType;

    switch (LogLevel) {
        case LOG_CRITICAL:
            wType = EVENTLOG_ERROR_TYPE;
            break;
        case LOG_UNUSUAL:
            wType = EVENTLOG_WARNING_TYPE;
            break;
        case LOG_NOISE:
            wType = EVENTLOG_INFORMATION_TYPE;
            break;
        default:
            // Assert if invalid so that in retail we don't bring down the entire process.
            //
            CL_ASSERT( 0 );
            // Fall through to normal logging...
            wType = EVENTLOG_ERROR_TYPE;
    }

    ClRtlpReportEvent(wType,
                      (WORD)LogModule,
                      MessageId,
                      0,
                      dwByteCount,
                      NULL,
                      lpBytes);
}


VOID
ClusterLogEvent1(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1
    )
/*++

Routine Description:

    Logs an event to the event log

Arguments:

    LogLevel - Supplies the logging level, one of
                LOG_CRITICAL 1
                LOG_UNUSUAL  2
                LOG_NOISE    3

    LogModule - Supplies the module ID.

    FileName - Supplies the filename of the caller

    LineNumber - Supplies the line number of the caller

    MessageId - Supplies the message ID to be logged.

    dwByteCount - Supplies the number of error-specific bytes to log. If this
        is zero, lpBytes is ignored.

    lpBytes - Supplies the error-specific bytes to log.

    Arg1 - Supplies an insertion string

Return Value:

    None.

--*/

{
    BOOL Success;
    DWORD Status;
    WORD wType;

    switch (LogLevel) {
        case LOG_CRITICAL:
            wType = EVENTLOG_ERROR_TYPE;
            break;
        case LOG_UNUSUAL:
            wType = EVENTLOG_WARNING_TYPE;
            break;
        case LOG_NOISE:
            wType = EVENTLOG_INFORMATION_TYPE;
            break;
        default:
            // Assert if invalid so that in retail we don't bring down the entire process.
            //
            CL_ASSERT( 0 );
            // Fall through to normal logging...
            wType = EVENTLOG_ERROR_TYPE;
    }
    ClRtlpReportEvent(wType,
                      (WORD)LogModule,
                      MessageId,
                      1,
                      dwByteCount,
                      &Arg1,
                      lpBytes);
}


VOID
ClusterLogEvent2(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1,
    IN LPCWSTR Arg2
    )
/*++

Routine Description:

    Logs an event to the event log

Arguments:

    LogLevel - Supplies the logging level, one of
                LOG_CRITICAL 1
                LOG_UNUSUAL  2
                LOG_NOISE    3

    LogModule - Supplies the module ID.

    FileName - Supplies the filename of the caller

    LineNumber - Supplies the line number of the caller

    MessageId - Supplies the message ID to be logged.

    dwByteCount - Supplies the number of error-specific bytes to log. If this
        is zero, lpBytes is ignored.

    lpBytes - Supplies the error-specific bytes to log.

    Arg1 - Supplies the first insertion string

    Arg2 - Supplies the second insertion string

Return Value:

    None.

--*/

{
    BOOL Success;
    DWORD Status;
    WORD wType;
    LPCWSTR ArgArray[2];

    switch (LogLevel) {
        case LOG_CRITICAL:
            wType = EVENTLOG_ERROR_TYPE;
            break;
        case LOG_UNUSUAL:
            wType = EVENTLOG_WARNING_TYPE;
            break;
        case LOG_NOISE:
            wType = EVENTLOG_INFORMATION_TYPE;
            break;
        default:
            // Assert if invalid so that in retail we don't bring down the entire process.
            //
            CL_ASSERT( 0 );
            // Fall through to normal logging...
            wType = EVENTLOG_ERROR_TYPE;
    }

    ArgArray[0] = Arg1;
    ArgArray[1] = Arg2;

    ClRtlpReportEvent(wType,
                      (WORD)LogModule,
                      MessageId,
                      2,
                      dwByteCount,
                      ArgArray,
                      lpBytes);
}


VOID
ClusterLogEvent3(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1,
    IN LPCWSTR Arg2,
    IN LPCWSTR Arg3
    )
/*++

Routine Description:

    Logs an event to the event log

Arguments:

    LogLevel - Supplies the logging level, one of
                LOG_CRITICAL 1
                LOG_UNUSUAL  2
                LOG_NOISE    3

    LogModule - Supplies the module ID.

    FileName - Supplies the filename of the caller

    LineNumber - Supplies the line number of the caller

    MessageId - Supplies the message ID to be logged.

    dwByteCount - Supplies the number of error-specific bytes to log. If this
        is zero, lpBytes is ignored.

    lpBytes - Supplies the error-specific bytes to log.

    Arg1 - Supplies the first insertion string

    Arg2 - Supplies the second insertion string

    Arg3 - Supplies the third insertion string

Return Value:

    None.

--*/

{
    BOOL Success;
    DWORD Status;
    WORD wType;
    LPCWSTR ArgArray[3];

    switch (LogLevel) {
        case LOG_CRITICAL:
            wType = EVENTLOG_ERROR_TYPE;
            break;
        case LOG_UNUSUAL:
            wType = EVENTLOG_WARNING_TYPE;
            break;
        case LOG_NOISE:
            wType = EVENTLOG_INFORMATION_TYPE;
            break;
        default:
            // Assert if invalid so that in retail we don't bring down the entire process.
            //
            CL_ASSERT( 0 );
            // Fall through to normal logging...
            wType = EVENTLOG_ERROR_TYPE;
    }

    ArgArray[0] = Arg1;
    ArgArray[1] = Arg2;
    ArgArray[2] = Arg3;

    ClRtlpReportEvent(wType,
                      (WORD)LogModule,
                      MessageId,
                      3,
                      dwByteCount,
                      ArgArray,
                      lpBytes);
}


VOID
ClusterLogEvent4(
    IN DWORD LogLevel,
    IN DWORD LogModule,
    IN LPSTR FileName,
    IN DWORD LineNumber,
    IN DWORD MessageId,
    IN DWORD dwByteCount,
    IN PVOID lpBytes,
    IN LPCWSTR Arg1,
    IN LPCWSTR Arg2,
    IN LPCWSTR Arg3,
    IN LPCWSTR Arg4
    )
/*++

Routine Description:

    Logs an event to the event log

Arguments:

    LogLevel - Supplies the logging level, one of
                LOG_CRITICAL 1
                LOG_UNUSUAL  2
                LOG_NOISE    3

    LogModule - Supplies the module ID.

    FileName - Supplies the filename of the caller

    LineNumber - Supplies the line number of the caller

    MessageId - Supplies the message ID to be logged.

    dwByteCount - Supplies the number of error-specific bytes to log. If this
        is zero, lpBytes is ignored.

    lpBytes - Supplies the error-specific bytes to log.

    Arg1 - Supplies the first insertion string

    Arg2 - Supplies the second insertion string

    Arg3 - Supplies the third insertion string

    Arg4 - Supplies the fourth insertion string

Return Value:

    None.

--*/

{
    BOOL Success;
    DWORD Status;
    WORD wType;
    LPCWSTR ArgArray[4];

    switch (LogLevel) {
        case LOG_CRITICAL:
            wType = EVENTLOG_ERROR_TYPE;
            break;
        case LOG_UNUSUAL:
            wType = EVENTLOG_WARNING_TYPE;
            break;
        case LOG_NOISE:
            wType = EVENTLOG_INFORMATION_TYPE;
            break;
        default:
            // Assert if invalid so that in retail we don't bring down the entire process.
            //
            CL_ASSERT( 0 );
            // Fall through to normal logging...
            wType = EVENTLOG_ERROR_TYPE;
    }

    ArgArray[0] = Arg1;
    ArgArray[1] = Arg2;
    ArgArray[2] = Arg3;
    ArgArray[3] = Arg4;

    ClRtlpReportEvent(wType,
                      (WORD)LogModule,
                      MessageId,
                      4,
                      dwByteCount,
                      ArgArray,
                      lpBytes);
}


VOID
ClusterCommonLogError(
    IN ULONG MessageId,
    IN ULONG LogModule,
    IN ULONG Line,
    IN LPSTR File,
    IN ULONG ErrCode
    )
/*++

Routine Description:

    Logs an error to the eventlog

Arguments:

    MessageId - Supplies the message ID to use.

    LogModule - Supplies the module.

    Line - Supplies the line number of the caller.

    File - Supplies the filename of the caller.

    ErrCode - Supplies the specific error code.

Return Value:

    None.

--*/

{
    WCHAR LineString[20];
    WCHAR ErrString[32];
    WCHAR FileName[255];
    WCHAR Buffer[256];
    LPWSTR Strings[3];
    DWORD Bytes;

    swprintf(LineString, L"%d", Line);
    swprintf(ErrString, L"%d", ErrCode);
    mbstowcs(FileName, File, sizeof(FileName)/sizeof(WCHAR));
    Strings[0] = LineString;
    Strings[1] = FileName;
    Strings[2] = ErrString;

    ClRtlpReportEvent(EVENTLOG_ERROR_TYPE,
                      (WORD)LogModule,
                      MessageId,
                      3,
                      0,
                      Strings,
                      NULL);

    Bytes = FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE |
                           FORMAT_MESSAGE_ARGUMENT_ARRAY |
                           FORMAT_MESSAGE_MAX_WIDTH_MASK,       // remove embedded line breaks
                           NULL,
                           MessageId,
                           0,
                           Buffer,
                           sizeof(Buffer) / sizeof(WCHAR),
                           (va_list *)Strings);

    if (Bytes != 0) {
        OutputDebugStringW(Buffer);
        ClRtlLogPrint(LOG_CRITICAL, "%1!ws!\n",Buffer);
    }
}


VOID
ClusterLogFatalError(
    IN ULONG LogModule,
    IN ULONG Line,
    IN LPSTR File,
    IN ULONG ErrCode
    )
/*++

Routine Description:

    Logs a fatal error to the eventlog and breaks into the debugger if present.
    Exits the process on fatal error.

Arguments:

    LogModule - Supplies the module.

    Line - Supplies the line number of the caller.

    File - Supplies the filename of the caller.

    ErrCode - Supplies the specific error code.

Return Value:

    None.

--*/

{
    ClusterCommonLogError(UNEXPECTED_FATAL_ERROR,
                          LogModule,
                          Line,
                          File,
                          ErrCode);

    if (IsDebuggerPresent()) {
        DebugBreak();
    }

    ClRtlpFlushLogBuffers();
    ExitProcess(ErrCode);

}


VOID
ClusterLogNonFatalError(
    IN ULONG LogModule,
    IN ULONG Line,
    IN LPSTR File,
    IN ULONG ErrCode
    )
/*++

Routine Description:

    Logs a nonfatal error to the eventlog

Arguments:

    LogModule - Supplies the module.

    Line - Supplies the line number of the caller.

    File - Supplies the filename of the caller.

    ErrCode - Supplies the specific error code.

Return Value:

    None.

--*/

{
    ClusterCommonLogError(LOG_FAILURE,
                          LogModule,
                          Line,
                          File,
                          ErrCode);
}


VOID
ClusterLogAssertionFailure(
    IN ULONG LogModule,
    IN ULONG Line,
    IN LPSTR File,
    IN LPSTR Expression
    )
/*++

Routine Description:

    Logs an assertion failure to the eventlog.

Arguments:

    LogModule - Supplies the module.

    Line - Supplies the line number of the caller.

    File - Supplies the filename of the caller.

    Express - Supplies the ASSERTion expression


Return Value:

    None.

--*/

{
    WCHAR LineString[10];
    WCHAR FileName[255];
    WCHAR Buffer[256];
    LPWSTR Strings[4];
    DWORD Bytes;

    swprintf(LineString, L"%d", Line);
    mbstowcs(FileName, File, sizeof(FileName)/sizeof(WCHAR));
    mbstowcs(Buffer, Expression, sizeof(Buffer)/sizeof(WCHAR));
    Strings[0] = LineString;
    Strings[1] = FileName;
    Strings[2] = Buffer;

    ClRtlpReportEvent(EVENTLOG_ERROR_TYPE,
                     (WORD)LogModule,
                     ASSERTION_FAILURE,
                     3,
                     0,
                     Strings,
                     NULL);

    Bytes = FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE |
                           FORMAT_MESSAGE_ARGUMENT_ARRAY |
                           FORMAT_MESSAGE_MAX_WIDTH_MASK,       // removed embedded line breaks
                           NULL,
                           ASSERTION_FAILURE,
                           0,
                           Buffer,
                           sizeof(Buffer) / sizeof(WCHAR),
                           (va_list *)Strings);
    if (Bytes != 0) {
        OutputDebugStringW(Buffer);
        ClRtlLogPrint(LOG_CRITICAL, "%1!ws!\n",Buffer);
    }
    if (IsDebuggerPresent()) {
        DebugBreak();
    } else {
        ClRtlpFlushLogBuffers();
        ExitProcess(Line);
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\fixup.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    FixUp.c

Abstract:

    This module contains common security routines for
    NT Clusters rolling upgrade and backward compatibility.

Author:

    Galen Barbee (galenb) 31-Mar-1998

--*/

#include "clusrtlp.h"

PSECURITY_DESCRIPTOR
ClRtlConvertClusterSDToNT4Format(
	IN PSECURITY_DESCRIPTOR psd
	)

/*++

Routine Description:

		Convert the SD from nt 5 to nt 4 format.  This means enforcing the
		following rules:

		1. Convert denied ACE to allowed ACE.  Convert "Full Control" access
		mask to CLUAPI_NO_ACCESS.

Arguments:

		psd			[IN] Security descriptor.

Return Value:

		The new SD in self-Relative format

--*/

{
	PACL	                pacl;
	BOOL	                bHasDACL;
	BOOL	                bDACLDefaulted;
	PSECURITY_DESCRIPTOR	psec = NULL;

	if (NULL == psd) {
		return NULL;
	}

	psec = ClRtlCopySecurityDescriptor(psd);
	ASSERT(psec != NULL);

    if ( (GetSecurityDescriptorDacl(psec, (LPBOOL) &bHasDACL, (PACL *) &pacl, (LPBOOL) &bDACLDefaulted)) &&
         ( bHasDACL != FALSE ) ) {

	    ACL_SIZE_INFORMATION	asiAclSize;
	    DWORD					dwBufLength;

	    dwBufLength = sizeof(asiAclSize);

	    if (GetAclInformation(pacl, &asiAclSize, dwBufLength, AclSizeInformation)) {

		    ACCESS_DENIED_ACE *	pAce;
            DWORD               dwIndex;

		    for (dwIndex = 0; dwIndex < asiAclSize.AceCount;  dwIndex++) {

		        if (GetAce(pacl, dwIndex, (LPVOID *) &pAce)) {

					if (pAce->Header.AceType == ACCESS_DENIED_ACE_TYPE)	{

						if (pAce->Mask & SPECIFIC_RIGHTS_ALL) {
							pAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
							pAce->Mask = CLUSAPI_NO_ACCESS;
						}

					} // end if (pAce->Header.AceType == ACCESS_DENIED_ACE_TYPE)

				} // end if (GetAce())

			} // end for

	    } // end if (GetAclInformation())

	} // end if (HrGetSecurityDescriptorDacl()) and DACL is present

	ASSERT(IsValidSecurityDescriptor(psec));

	return psec;

}  //*** ClRtlConvertClusterSDToNT4Format()

PSECURITY_DESCRIPTOR
ClRtlConvertClusterSDToNT5Format(
	IN PSECURITY_DESCRIPTOR psd
	)

/*++

Routine Description:

		Convert the SD from nt 5 to nt 4 format.  This means enforcing the
		following rules:

		1. Convert allowed ACE with mask CLUAPI_NO_ACCESS to denied ACE mask full control.

Arguments:

		psd			[IN] Security descriptor.

Return Value:

		The new SD in self-Relative format

--*/

{
	PACL	pacl;
	BOOL	bHasDACL;
	BOOL	bDACLDefaulted;
	PSECURITY_DESCRIPTOR	psec = NULL;

	if (NULL == psd) {
		return NULL;
	}

    psec = ClRtlCopySecurityDescriptor(psd);
	ASSERT(psec != NULL);

    if ( (GetSecurityDescriptorDacl(psec, (LPBOOL) &bHasDACL, (PACL *) &pacl, (LPBOOL) &bDACLDefaulted)) &&
         ( bHasDACL != FALSE ) ) {

	    ACL_SIZE_INFORMATION	asiAclSize;
	    DWORD					dwBufLength;

	    dwBufLength = sizeof(asiAclSize);

	    if (GetAclInformation(pacl, &asiAclSize, dwBufLength, AclSizeInformation)) {

		    ACCESS_DENIED_ACE *	pAce;
            DWORD               dwIndex;

		    for (dwIndex = 0; dwIndex < asiAclSize.AceCount;  dwIndex++) {

		        if (GetAce(pacl, dwIndex, (LPVOID *) &pAce)) {

					if (pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) {

						if (pAce->Mask & CLUSAPI_NO_ACCESS)	{
							pAce->Header.AceType = ACCESS_DENIED_ACE_TYPE;
							pAce->Mask = SPECIFIC_RIGHTS_ALL;
						}

					} // end if (pAce->Header.AceType == ACCESS_DENIED_ACE_TYPE)

				} // end if (GetAce())

			} // end for

	    } // end if (GetAclInformation())

	} // end if (HrGetSecurityDescriptorDacl()) and DACL is present

	ASSERT(IsValidSecurityDescriptor(psec));

	return psec;

}  //*** ClRtlConvertClusterSDToNT5Format()

static GENERIC_MAPPING gmFileShareMap =
{
	FILE_GENERIC_READ,
	FILE_GENERIC_WRITE,
	FILE_GENERIC_EXECUTE,
	FILE_ALL_ACCESS
};

#define SPECIFIC_CHANGE     (DELETE | FILE_GENERIC_WRITE)
#define SPECIFIC_READ       (FILE_GENERIC_READ | FILE_LIST_DIRECTORY | FILE_EXECUTE)
#define GENERIC_CHANGE      (GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | DELETE)

PSECURITY_DESCRIPTOR
ClRtlConvertFileShareSDToNT4Format(
	IN PSECURITY_DESCRIPTOR psd
	)

/*++

Routine Description:

		Convert the SD from nt 5 to nt 4 format.  This means enforcing the
		following rules:

Arguments:

		psd			[IN] Security descriptor.

Return Value:

		The new SD in self-Relative format

--*/

{
	PACL	                pacl;
	BOOL	                bHasDACL;
	BOOL	                bDACLDefaulted;
	PSECURITY_DESCRIPTOR	psec = NULL;

	if (NULL == psd) {
		return NULL;
	}

	psec = ClRtlCopySecurityDescriptor(psd);
	ASSERT(psec != NULL);

    if ( (GetSecurityDescriptorDacl(psec, (LPBOOL) &bHasDACL, (PACL *) &pacl, (LPBOOL) &bDACLDefaulted)) &&
         ( bHasDACL != FALSE ) ) {

	    ACL_SIZE_INFORMATION	asiAclSize;
	    DWORD					dwBufLength;
        ACCESS_MASK             amTemp1;
        ACCESS_MASK             amTemp2;

	    dwBufLength = sizeof(asiAclSize);

	    if (GetAclInformation(pacl, &asiAclSize, dwBufLength, AclSizeInformation)) {

		    ACCESS_DENIED_ACE *	pAce;
			DWORD				dwSid;
            DWORD               dwIndex;

		    for (dwIndex = 0; dwIndex < asiAclSize.AceCount;  dwIndex++) {

                amTemp1 = 0;
                amTemp2 = 0;

		        if (GetAce(pacl, dwIndex, (LPVOID *) &pAce)) {

					// delete deny read ACEs since they don't mean anything to AclEdit
					if ((pAce->Header.AceType == ACCESS_DENIED_ACE_TYPE) &&
					   (pAce->Mask == SPECIFIC_READ)) {

						dwSid = pAce->SidStart;

                        if (DeleteAce(pacl, dwIndex)) {
                            asiAclSize.AceCount -= 1;
                            dwIndex -= 1;
                        }
                        else {
                            ClRtlDbgPrint(LOG_UNUSUAL,
                                          "[ClRtl] DeteteAce failed removing ACE #%1!d! due to error %2!d!\n",
                                          dwIndex,
                                          GetLastError());
                        }

                        continue;
                    }

					// convert deny change deny read ACEs to deny all ACEs
					if ((pAce->Header.AceType == ACCESS_DENIED_ACE_TYPE) &&
					   (pAce->Mask == (SPECIFIC_CHANGE | SPECIFIC_READ))) {
                        pAce->Mask = GENERIC_ALL;
                        continue;
                    }

					// convert deny change ACEs to allow read (read only) ACEs
					if ((pAce->Header.AceType == ACCESS_DENIED_ACE_TYPE) &&
					   (pAce->Mask == SPECIFIC_CHANGE)) {
                        pAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
                        pAce->Mask = GENERIC_READ | GENERIC_EXECUTE;
                        continue;
                    }

					// convert specific allow change to generic allow change
					if ((pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) &&
					   (pAce->Mask == SPECIFIC_CHANGE)) {
                        pAce->Mask = GENERIC_CHANGE;
                        continue;
                    }

					// convert specific all to generic all
                    if ((pAce->Mask & gmFileShareMap.GenericAll) == gmFileShareMap.GenericAll) {
                        amTemp1 |= GENERIC_ALL;
                        amTemp2 |= gmFileShareMap.GenericAll;
                    }
                    else {


						// convert specific read to generic read
                        if ((pAce->Mask & gmFileShareMap.GenericRead) == gmFileShareMap.GenericRead) {
                            amTemp1 |= GENERIC_READ;
                            amTemp2 |= gmFileShareMap.GenericRead;
                        }

						// convert specific write to generic write which includes delete
                        if ((pAce->Mask & gmFileShareMap.GenericWrite) == gmFileShareMap.GenericWrite) {
                            amTemp1 |= (GENERIC_WRITE | DELETE);
                            amTemp2 |= gmFileShareMap.GenericWrite;
                        }

						// convert specific execute to generic execute
                        if ((pAce->Mask & gmFileShareMap.GenericExecute) == gmFileShareMap.GenericExecute) {
                            amTemp1 |= GENERIC_EXECUTE;
                            amTemp2 |= gmFileShareMap.GenericExecute;
                        }
                    }

                    pAce->Mask &= ~amTemp2;   // turn off specific bits
                    pAce->Mask |= amTemp1;    // turn on generic bits
				} // end if (GetAce())

			} // end for

	    } // end if (GetAclInformation())

	} // end if (HrGetSecurityDescriptorDacl()) and DACL is present

	ASSERT(IsValidSecurityDescriptor(psec));

	return psec;

}  //*** ClRtlConvertFileShareSDToNT4Format()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\dbgrpt.cpp ===
/***
*DbgRpt.c - Debug Cluster Reporting Functions
*
*		Copyright (c) 1988-1998, Microsoft Corporation. All rights reserved.
*
*Purpose:
*
*******************************************************************************/

#include <malloc.h>
#include <mbstring.h>
#include <stdarg.h>
#include <stdlib.h>
#include <stdio.h>
#include <signal.h>
#include <string.h>

#include <windows.h>

#define CLRTL_INCLUDE_DEBUG_REPORTING
#include "ClRtlDbg.h"

#define _ClRtlInterlockedIncrement InterlockedIncrement
#define _ClRtlInterlockedDecrement InterlockedDecrement

/*---------------------------------------------------------------------------
 *
 * Debug Reporting
 *
 --------------------------------------------------------------------------*/

static int ClRtlMessageWindow(
	int,
	const char *,
	const char *,
	const char *,
	const char *
	);

static int __clrtlMessageBoxA(
	LPCSTR lpText,
	LPCSTR lpCaption,
	UINT uType
	);

extern "C"
{
_CLRTL_REPORT_HOOK _pfnReportHook;

long _clrtlAssertBusy = -1;

int _ClRtlDbgMode[_CLRTLDBG_ERRCNT] = {
	_CLRTLDBG_MODE_DEBUG,
	_CLRTLDBG_MODE_DEBUG | _CLRTLDBG_MODE_WNDW,
	_CLRTLDBG_MODE_DEBUG | _CLRTLDBG_MODE_WNDW
	};

_HFILE _ClRtlDbgFile[_CLRTLDBG_ERRCNT] = {
	_CLRTLDBG_INVALID_HFILE,
	_CLRTLDBG_INVALID_HFILE,
	_CLRTLDBG_INVALID_HFILE
	};
}

static const char * _ClRtlDbgModeMsg[_CLRTLDBG_ERRCNT] = { "Warning", "Error", "Assertion Failed" };

/***
*void _ClRtlDebugBreak - call OS-specific debug function
*
*Purpose:
*		call OS-specific debug function
*
*Entry:
*
*Exit:
*
*Exceptions:
*
*******************************************************************************/

#undef _ClRtlDbgBreak

extern "C" void _cdecl _ClRtlDbgBreak(
	void
	)
{
	DebugBreak();

} //*** _ClRtlDbgBreak()

/***
*int _ClRtlSetReportMode - set the reporting mode for a given report type
*
*Purpose:
*		set the reporting mode for a given report type
*
*Entry:
*		int nRptType	- the report type
*		int fMode		- new mode for given report type
*
*Exit:
*		previous mode for given report type
*
*Exceptions:
*
*******************************************************************************/
extern "C" int __cdecl _ClRtlSetReportMode(
	int nRptType,
	int fMode
	)
{
	int oldMode;

	if (nRptType < 0 || nRptType >= _CLRTLDBG_ERRCNT)
		return -1;

	if (fMode == _CLRTLDBG_REPORT_MODE)
		return _ClRtlDbgMode[nRptType];

	/* verify flags values */
	if (fMode & ~(_CLRTLDBG_MODE_FILE | _CLRTLDBG_MODE_DEBUG | _CLRTLDBG_MODE_WNDW))
		return -1;

	oldMode = _ClRtlDbgMode[nRptType];

	_ClRtlDbgMode[nRptType] = fMode;

	return oldMode;

} //*** _ClRtlSetReportMode()

/***
*int _ClRtlSetReportFile - set the reporting file for a given report type
*
*Purpose:
*		set the reporting file for a given report type
*
*Entry:
*		int nRptType	- the report type
*		_HFILE hFile	- new file for given report type
*
*Exit:
*		previous file for given report type
*
*Exceptions:
*
*******************************************************************************/
extern "C" _HFILE __cdecl _ClRtlSetReportFile(
	int nRptType,
	_HFILE hFile
	)
{
	_HFILE oldFile;

	if (nRptType < 0 || nRptType >= _CLRTLDBG_ERRCNT)
		return _CLRTLDBG_HFILE_ERROR;

	if (hFile == _CLRTLDBG_REPORT_FILE)
		return _ClRtlDbgFile[nRptType];

	oldFile = _ClRtlDbgFile[nRptType];

	if (_CLRTLDBG_FILE_STDOUT == hFile)
		_ClRtlDbgFile[nRptType] = GetStdHandle(STD_OUTPUT_HANDLE);

	else if (_CLRTLDBG_FILE_STDERR == hFile)
		_ClRtlDbgFile[nRptType] = GetStdHandle(STD_ERROR_HANDLE);
	else
		_ClRtlDbgFile[nRptType] = hFile;

	return oldFile;

} //*** _ClRtlSetReportFile()


/***
*_CLRTL_REPORT_HOOK _ClRtlSetReportHook() - set client report hook
*
*Purpose:
*		set client report hook
*
*Entry:
*		_CLRTL_REPORT_HOOK pfnNewHook - new report hook
*
*Exit:
*		return previous hook
*
*Exceptions:
*
*******************************************************************************/
extern "C" _CLRTL_REPORT_HOOK __cdecl _ClRtlSetReportHook(
	_CLRTL_REPORT_HOOK pfnNewHook
	)
{
	_CLRTL_REPORT_HOOK pfnOldHook = _pfnReportHook;
	_pfnReportHook = pfnNewHook;
	return pfnOldHook;

} //*** _ClRtlSetReportHook()


#define MAXLINELEN 64
#define MAX_MSG 4096
#define TOOLONGMSG "_ClRtlDbgReport: String too long or IO Error"


/***
*int _ClRtlDbgReport() - primary reporting function
*
*Purpose:
*		Display a message window with the following format.
*
*		================= Microsft Visual C++ Debug Library ================
*
*		{Warning! | Error! | Assertion Failed!}
*
*		Program: c:\test\mytest\foo.exe
*		[Module: c:\test\mytest\bar.dll]
*		[File: c:\test\mytest\bar.c]
*		[Line: 69]
*
*		{<warning or error message> | Expression: <expression>}
*
*		[For information on how your program can cause an assertion
*		 failure, see the Visual C++ documentation on asserts]
*
*		(Press Retry to debug the application)
*
*		===================================================================
*
*Entry:
*		int 			nRptType	- report type
*		const char *	szFile		- file name
*		int 			nLine		- line number
*		const char *	szModule	- module name
*		const char *	szFormat	- format string
*		... 						- var args
*
*Exit:
*		if (MessageBox)
*		{
*			Abort -> aborts
*			Retry -> return TRUE
*			Ignore-> return FALSE
*		}
*		else
*			return FALSE
*
*Exceptions:
*
*******************************************************************************/
extern "C" int __cdecl _ClRtlDbgReport(
	int nRptType,
	const char * szFile,
	int nLine,
	const char * szModule,
	const char * szFormat,
	...
	)
{
	int retval;
	va_list arglist;
	char szLineMessage[MAX_MSG] = {0};
	char szOutMessage[MAX_MSG] = {0};
	char szUserMessage[MAX_MSG] = {0};
	#define ASSERTINTRO1 "Assertion failed: "
	#define ASSERTINTRO2 "Assertion failed!"

	va_start(arglist, szFormat);

	if (nRptType < 0 || nRptType >= _CLRTLDBG_ERRCNT)
		return -1;

	/*
	 * handle the (hopefully rare) case of
	 *
	 * 1) ASSERT while already dealing with an ASSERT
	 *		or
	 * 2) two threads asserting at the same time
	 */
	if (_CLRTLDBG_ASSERT == nRptType && _ClRtlInterlockedIncrement(&_clrtlAssertBusy) > 0)
	{
		/* use only 'safe' functions -- must not assert in here! */
		static int (APIENTRY *pfnwsprintfA)(LPSTR, LPCSTR, ...) = NULL;

		if (NULL == pfnwsprintfA)
		{
			HINSTANCE hlib = LoadLibraryA("user32.dll");

			if (NULL == hlib || NULL == (pfnwsprintfA =
						(int (APIENTRY *)(LPSTR, LPCSTR, ...))
						GetProcAddress(hlib, "wsprintfA")))
				return -1;
		}

		(*pfnwsprintfA)( szOutMessage,
			"Second Chance Assertion Failed: File %s, Line %d\n",
			szFile, nLine);

		OutputDebugStringA(szOutMessage);

		_ClRtlInterlockedDecrement(&_clrtlAssertBusy);

		_ClRtlDbgBreak();
		return -1;
	}

	if (szFormat && _vsnprintf(szUserMessage,
				   MAX_MSG-max(sizeof(ASSERTINTRO1),sizeof(ASSERTINTRO2)),
				   szFormat,
				   arglist) < 0)
		strcpy(szUserMessage, TOOLONGMSG);

	if (_CLRTLDBG_ASSERT == nRptType)
		strcpy(szLineMessage, szFormat ? ASSERTINTRO1 : ASSERTINTRO2);

	strcat(szLineMessage, szUserMessage);

	if (_CLRTLDBG_ASSERT == nRptType)
	{
		if (_ClRtlDbgMode[nRptType] & _CLRTLDBG_MODE_FILE)
			strcat(szLineMessage, "\r");
		strcat(szLineMessage, "\n");
	}

	if (szFile)
	{
		if (_snprintf(szOutMessage, MAX_MSG, "%s(%d) : %s",
			szFile, nLine, szLineMessage) < 0)
		strcpy(szOutMessage, TOOLONGMSG);
	}
	else
		strcpy(szOutMessage, szLineMessage);

	/* user hook may handle report */
	if (_pfnReportHook && (*_pfnReportHook)(nRptType, szOutMessage, &retval))
	{
		if (_CLRTLDBG_ASSERT == nRptType)
			_ClRtlInterlockedDecrement(&_clrtlAssertBusy);
		return retval;
	}

	if (_ClRtlDbgMode[nRptType] & _CLRTLDBG_MODE_FILE)
	{
		if (_ClRtlDbgFile[nRptType] != _CLRTLDBG_INVALID_HFILE)
		{
			DWORD written;
			WriteFile(_ClRtlDbgFile[nRptType], szOutMessage, strlen(szOutMessage), &written, NULL);
		}
	}

	if (_ClRtlDbgMode[nRptType] & _CLRTLDBG_MODE_DEBUG)
	{
		OutputDebugStringA(szOutMessage);
	}

	if (_ClRtlDbgMode[nRptType] & _CLRTLDBG_MODE_WNDW)
	{
		char szLine[20];

		retval = ClRtlMessageWindow(nRptType, szFile, nLine ? _itoa(nLine, szLine, 10) : NULL, szModule, szUserMessage);
		if (_CLRTLDBG_ASSERT == nRptType)
			_ClRtlInterlockedDecrement(&_clrtlAssertBusy);
		return retval;
	}

	if (_CLRTLDBG_ASSERT == nRptType)
		_ClRtlInterlockedDecrement(&_clrtlAssertBusy);
	/* ignore */
	return FALSE;

} //*** _ClRtlDbgReport()


/***
*static int ClRtlMessageWindow() - report to a message window
*
*Purpose:
*		put report into message window, allow user to choose action to take
*
*Entry:
*		int 			nRptType	  - report type
*		const char *	szFile		  - file name
*		const char *	szLine		  - line number
*		const char *	szModule	  - module name
*		const char *	szUserMessage - user message
*
*Exit:
*		if (MessageBox)
*		{
*			Abort -> aborts
*			Retry -> return TRUE
*			Ignore-> return FALSE
*		}
*		else
*			return FALSE
*
*Exceptions:
*
*******************************************************************************/
static int ClRtlMessageWindow(
		int nRptType,
		const char * szFile,
		const char * szLine,
		const char * szModule,
		const char * szUserMessage
		)
{
	int nCode;
	char *szShortProgName;
	char *szShortModuleName;
	char szExeName[MAX_PATH];
	char szOutMessage[MAX_MSG];

	_CLRTL_ASSERTE(szUserMessage != NULL);

	/* Shorten program name */
	if (!GetModuleFileNameA(NULL, szExeName, MAX_PATH))
		strcpy(szExeName, "<program name unknown>");

	szShortProgName = szExeName;

	if (strlen(szShortProgName) > MAXLINELEN)
	{
		szShortProgName += strlen(szShortProgName) - MAXLINELEN;
		strncpy(szShortProgName, "...", 3);
	}

	/* Shorten module name */
	szShortModuleName = (char *) szModule;

	if (szShortModuleName && strlen(szShortModuleName) > MAXLINELEN)
	{
		szShortModuleName += strlen(szShortModuleName) - MAXLINELEN;
		strncpy(szShortModuleName, "...", 3);
	}

	if (_snprintf(szOutMessage, MAX_MSG,
			"Debug %s!\n\nProgram: %s%s%s%s%s%s%s%s%s%s%s"
			"\n\n(Press Retry to debug the application)",
			_ClRtlDbgModeMsg[nRptType],
			szShortProgName,
			szShortModuleName ? "\nModule: " : "",
			szShortModuleName ? szShortModuleName : "",
			szFile ? "\nFile: " : "",
			szFile ? szFile : "",
			szLine ? "\nLine: " : "",
			szLine ? szLine : "",
			szUserMessage[0] ? "\n\n" : "",
			szUserMessage[0] && _CLRTLDBG_ASSERT == nRptType ? "Expression: " : "",
			szUserMessage[0] ? szUserMessage : "",
			0 /*_CLRTLDBG_ASSERT == nRptType*/ ? // Don't display this text, it's superfluous
			"\n\nFor information on how your program can cause an assertion"
			"\nfailure, see the Visual C++ documentation on asserts."
			: "") < 0)
		strcpy(szOutMessage, TOOLONGMSG);

	/* Report the warning/error */
	nCode = __clrtlMessageBoxA(
						szOutMessage,
						"Microsoft Visual C++ Debug Library",
						MB_TASKMODAL|MB_ICONHAND|MB_ABORTRETRYIGNORE|MB_SETFOREGROUND);

	/* Abort: abort the program */
	if (IDABORT == nCode)
	{
		/* raise abort signal */
		raise(SIGABRT);

		/* We usually won't get here, but it's possible that
		   SIGABRT was ignored.  So exit the program anyway. */

		_exit(3);
	}

	/* Retry: return 1 to call the debugger */
	if (IDRETRY == nCode)
		return 1;

	/* Ignore: continue execution */
	return 0;

} //*** ClRtlMessageWindow()


/***
*__clrtlMessageBoxA - call MessageBoxA dynamically.
*
*Purpose:
*       Avoid static link with user32.dll. Only load it when actually needed.
*
*Entry:
*       see MessageBoxA docs.
*
*Exit:
*       see MessageBoxA docs.
*
*Exceptions:
*
*******************************************************************************/
static int __clrtlMessageBoxA(
	LPCSTR lpText,
	LPCSTR lpCaption,
	UINT uType
	)
{
	static int (APIENTRY *pfnMessageBoxA)(HWND, LPCSTR, LPCSTR, UINT) = NULL;
	static HWND (APIENTRY *pfnGetActiveWindow)(void) = NULL;
	static HWND (APIENTRY *pfnGetLastActivePopup)(HWND) = NULL;

	HWND hWndParent = NULL;

	if (NULL == pfnMessageBoxA)
	{
		HINSTANCE hlib = LoadLibraryA("user32.dll");

		if (NULL == hlib || NULL == (pfnMessageBoxA =
					(int (APIENTRY *)(HWND, LPCSTR, LPCSTR, UINT))
					GetProcAddress(hlib, "MessageBoxA")))
			return 0;

		pfnGetActiveWindow = (HWND (APIENTRY *)(void))
					GetProcAddress(hlib, "GetActiveWindow");

		pfnGetLastActivePopup = (HWND (APIENTRY *)(HWND))
					GetProcAddress(hlib, "GetLastActivePopup");
	}

	if (pfnGetActiveWindow)
		hWndParent = (*pfnGetActiveWindow)();

	if (hWndParent != NULL && pfnGetLastActivePopup)
		hWndParent = (*pfnGetLastActivePopup)(hWndParent);

	return (*pfnMessageBoxA)(hWndParent, lpText, lpCaption, uType);

} //*** __clrtlMessageBoxA()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\hash.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    hash.c

Abstract:

    This is a fairly generic hash table implementation.  This is used to form
    a lookup table for mapping pointers to dwords, so we can send dwords over
    the wire.  This is for sundown.

Author:

    Ken Peery (kpeery) 26-Feb-1999

Revision History:

--*/
#include "clusrtlp.h"

//
//  PLIST_ENTRY
//  NextListEntry(
//      PLIST_ENTRY ListHead
//      );
//

#define NextListEntry(ListHead)  (ListHead)->Flink



//
// local routines
//
DWORD
ClRtlFindUniqueIdHashUnSafe(
    IN PCL_HASH pTable,
    OUT PDWORD  pId
);

PVOID
ClRtlGetEntryHashUnSafe(
    IN PCL_HASH pTable,
    IN DWORD    Id
    );



VOID
ClRtlInitializeHash(
    PCL_HASH pTable
    )
/*++

Routine Description:

    Initializes a hash table for use.

Arguments:

    pTable - Supplies a pointer to a hash table structure to initialize

Return Value:

    None.

--*/

{
    DWORD index;

    if (NULL == pTable) {
        // 
        // We should never call this routine with NULL
        //
        return;
    }

    ZeroMemory(pTable,sizeof(CL_HASH));

    for(index=0; index < MAX_CL_HASH; index++) {
        InitializeListHead(&pTable->Head[index].ListHead);
    }
    
    InitializeCriticalSection(&pTable->Lock);
}



VOID
ClRtlDeleteHash(
    IN PCL_HASH pTable
    )
/*++

Routine Description:

    Releases all resources used by a hash table

Arguments:

    pTable - supplies the hash table to be deleted

Return Value:

    None.

--*/

{
    DWORD index;

    PLIST_ENTRY pItem;

    if (NULL == pTable)
        return;

    EnterCriticalSection(&pTable->Lock);

    for(index=0; index < MAX_CL_HASH; index++) {

        while(!IsListEmpty(&pTable->Head[index].ListHead)) {

            pItem=RemoveHeadList(&pTable->Head[index].ListHead);
            LocalFree(pItem);
        }

    }

    LeaveCriticalSection(&pTable->Lock);

    DeleteCriticalSection(&pTable->Lock);
}



PVOID
ClRtlRemoveEntryHash(
    IN PCL_HASH pTable,
    IN DWORD    Id
    )
/*++

Routine Description:

    Removes the item specified by the Id from the list.  If the item is
    not there then return NULL.  Then save off the pData field and delete this
    entry from the list.  Then return the pData field.

Arguments:

    Id     - the id for the entry to remove
    pTable - the hash table to search

Return Value:

    The pData field of the entry with the matching id, or NULL.

--*/

{
    DWORD index;
    PVOID pData;

    PCL_HASH_ITEM  pItem;

    pData=NULL;
    pItem=NULL;

    if ((Id == 0) || (pTable == NULL)) {
        SetLastError(ERROR_INVALID_PARAMETER);  
        return NULL;
    }

    index = Id % MAX_CL_HASH;

    //
    // Lock the table for the search
    //

    EnterCriticalSection(&pTable->Lock);

    if (pTable->Head[index].Id == Id) {

        //
        // if the entry is in the head
        //

        pData=pTable->Head[index].pData;

        if (IsListEmpty(&pTable->Head[index].ListHead)) {
    
            //
            // there are no other entries so just zero this one out
            //

            pTable->Head[index].Id = 0;
            pTable->Head[index].pData = NULL;

        } else {
    
            //
            // if there is at least one other entry move that one into the 
            // head and delete it
            //

            pItem=(PCL_HASH_ITEM)RemoveHeadList(&pTable->Head[index].ListHead);
        
            pTable->Head[index].Id = pItem->Id;
            pTable->Head[index].pData = pItem->pData;

            LocalFree(pItem);
        }

    } else {

        pItem=(PCL_HASH_ITEM)NextListEntry(&pTable->Head[index].ListHead);
        do
        {
            if (pItem->Id == Id)
            {
                pData=pItem->pData;

                RemoveEntryList(&pItem->ListHead);
                LocalFree(pItem);

                break;
            }

            pItem=(PCL_HASH_ITEM)NextListEntry(&pItem->ListHead);

        } while(pItem != &pTable->Head[index]);
        
    }

    // cache the now free value

    pTable->CacheFreeId[index]=Id;

    LeaveCriticalSection(&pTable->Lock);

    return(pData);
}



DWORD
ClRtlFindUniqueIdHashUnSafe(
    IN PCL_HASH pTable,
    OUT PDWORD  pId
)

/*++

Routine Description:

    If the tables last id value should rollover we have to make sure that the
    id choosen is unique.  This should only happen under extreme conditions
    but even still we must find a unique id as quickly as possible, the calling
    routine should already have the critical section at this point. 

Arguments:

    pTable - Supplies the hash table to search 

    pId    - sideffect to hold the id or 0 on error

Return Value:

    ERROR_SUCCESS or the appropate Win32 error code.

NOTENOTE:
    This algorithm is fairly slow essentially it is a sequential search with
    a small cache for previously freed values.  We would do better if we kept
    a ranged free list somewhere so that if we rollover we pick from the list.
    The free list would have to be maintained even before we rollover to make 
    sure we had all the available values.

--*/

{
    DWORD OldId;
    DWORD dwErr, index;
    BOOL  bFoundUniqueId;

    PCL_HASH_ITEM pItem;

    dwErr=ERROR_INVALID_PARAMETER;
    bFoundUniqueId=FALSE;
    *pId=0;

    OldId=pTable->LastId;
    
    do
    {
        index=pTable->LastId % MAX_CL_HASH;

        //
        // first check to see if there is a free value in the cache
        //
        if (pTable->CacheFreeId[index] != 0)
        {
            bFoundUniqueId=TRUE;
            *pId=pTable->CacheFreeId[index];
            pTable->CacheFreeId[index]=0;
            break;
        }

        //
        // if the cache is empty at this index, determine if this value
        // is in use.
        //
        if (NULL == ClRtlGetEntryHashUnSafe(pTable, pTable->LastId)) {
            bFoundUniqueId=TRUE;
            *pId=pTable->LastId;
            break; 
        } 

        //
        // ok, this id is in use and nothing in the cache, try the next id 
        //
        pTable->LastId++;
    
        if (pTable->LastId == 0) {
            pTable->LastId++;
        }

    } while(!bFoundUniqueId && (OldId != pTable->LastId));

    if (bFoundUniqueId) {
        dwErr=ERROR_SUCCESS;
    }

    return(dwErr);
}



DWORD
ClRtlInsertTailHash(
    IN PCL_HASH pTable,
    IN PVOID    pData,
    OUT PDWORD  pId
    )

/*++

Routine Description:

    Inserts a new pData value into the tail of one of the entries for the 
    hash table.  The unique id for this entry is returned or 0 on failure.

Arguments:

    pTable - Supplies the hash table to add the entry.

    pData  - Supplies the data entry to be added to the table.

    pId    - sideffect to hold the id or 0 on error

Return Value:

    ERROR_SUCCESS or the appropate Win32 error code.

--*/

{
    DWORD index;
    DWORD dwErr;

    PCL_HASH_ITEM pItem;

    *pId=0;
    dwErr=ERROR_SUCCESS;
    
    if (pTable == NULL) {
        return(ERROR_INVALID_PARAMETER);
    }
    
    EnterCriticalSection(&pTable->Lock);

    pTable->LastId++;

    if (pTable->LastId == 0) {
        pTable->bRollover = TRUE;
        pTable->LastId++;
    }

    index=pTable->LastId % MAX_CL_HASH;

    *pId=pTable->LastId;

    if (pTable->Head[index].Id == 0) {

        //
        // if the first entry then add it to the head
        // 
        // if we rollover, but the head is empty then the id is unique.
        //
        
        pTable->Head[index].Id = *pId;
        pTable->Head[index].pData = pData;

        if (pTable->CacheFreeId[index] == *pId) {
            pTable->CacheFreeId[index]=0;
        }

    } else {

        // if this is not the first entry then add it to the end.

        pItem=(PCL_HASH_ITEM)LocalAlloc(LMEM_FIXED,sizeof(CL_HASH_ITEM));

        if (NULL == pItem) {

            dwErr=ERROR_NOT_ENOUGH_MEMORY;

        } else {

            if (pTable->bRollover) {
                dwErr=ClRtlFindUniqueIdHashUnSafe(pTable, pId);
            }

            if (dwErr == ERROR_SUCCESS)
            {
                pItem->Id = *pId;
                pItem->pData = pData;
    
                index= *pId % MAX_CL_HASH;

                if (pTable->CacheFreeId[index] == *pId) {
                    pTable->CacheFreeId[index]=0;
                }

                InsertTailList(&pTable->Head[index].ListHead,&pItem->ListHead);
            }
            else
            {
                LocalFree(pItem);
            }
        }
    }

    LeaveCriticalSection(&pTable->Lock);

    return(dwErr);
}



PVOID
ClRtlGetEntryHash(
    IN PCL_HASH pTable,
    IN DWORD    Id
    )
/*++

Routine Description:

    Gets the data portion of the item specified by the Id from the hash table.
    If the item is not there then return NULL. 

Arguments:

    Id     - the id for the entry to find
    pTable - the hash table to search

Return Value:

    The pData field of the entry with the matching id, or NULL.

--*/

{
    PVOID pData;

    pData=NULL;

    if ((Id == 0) || (pTable == NULL)) {
        SetLastError(ERROR_INVALID_PARAMETER);  
        return NULL;
    }

    //
    // Lock the table for the search
    //

    EnterCriticalSection(&pTable->Lock);

    pData=ClRtlGetEntryHashUnSafe(pTable,Id);

    LeaveCriticalSection(&pTable->Lock);

    if (pData == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);  
    }

    return(pData);
}



PVOID
ClRtlGetEntryHashUnSafe(
    IN PCL_HASH pTable,
    IN DWORD    Id
    )
/*++

Routine Description:

    Gets the data portion of the item specified by the Id from the hash table.
    If the item is not there then return NULL. 

Arguments:

    Id     - the id for the entry to find
    pTable - the hash table to search

Return Value:

    The pData field of the entry with the matching id, or NULL.

--*/

{
    DWORD index;
    PVOID pData;

    PCL_HASH_ITEM  pItem;

    pData=NULL;
    pItem=NULL;

    if (Id == 0) { 
        return NULL;
    }

    index = Id % MAX_CL_HASH;

    if (pTable->Head[index].Id == Id) {

        //
        // if the entry is in the head
        //

        pData=pTable->Head[index].pData;

    } else {

        pItem=(PCL_HASH_ITEM)NextListEntry(&pTable->Head[index].ListHead);
        do 
        {
            if (pItem->Id == Id) {

                pData=pItem->pData;
                break;
            }

            pItem=(PCL_HASH_ITEM)NextListEntry(&pItem->ListHead);

        } while(pItem != &pTable->Head[index]);
        
    }

    return(pData);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\makefile.inc ===
$(O)\tdisk.res: tdisk.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\inststat.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-1999 Microsoft Corporation
//
//  Module Name:
//      InstallState.cpp
//
//  Desription:
//      The function(s) in this file are used to interrogate the state of the
//      Clustering Services installation.
//
//  Author:
//      C. Brent Thomas (a-brentt) 6 May 1998
//
//  Revision History:
//
//  Notes:
//
/////////////////////////////////////////////////////////////////////////////
#include <clusrtlp.h>
#include <stdlib.h>
#include "clusrtl.h"

/////////////////////////////////////////////////////////////////////////////
//++
//
//  ClRtlGetClusterInstallState
//
//  Routine Description:
//      This function retrieves an indicator of the state of the Cluster Server
//      installation.
//
//  Arguments:
//      pszNodeName - Name of the node to check, or NULL for the local machine.
//      peState - State value returned from this function:
//          eClusterInstallStateUnknown - indicates that the state of the Cluster
//                                        Server installation could not be determined.
//          eClusterInstallStateFilesCopied - indicates that clusocm.dll has prevoiusly,
//                                            successfully copied the Cluster Server files.
//          eClusterInstallStateConfigured - indicates that the Cluster Server has previously
//                                           been configured successfully.
//          See cluster\inc\clusrtl.h for the definition of eClusterInstallState.
//
//  Return Value:
//      Any error codes returned from RegConnectRegistryW, RegOpenKeyExW, or RegQueryValueExW.
//
//--
/////////////////////////////////////////////////////////////////////////////

DWORD ClRtlGetClusterInstallState(
    IN LPCWSTR pszNodeName,
    OUT eClusterInstallState * peState
    )
{
    HKEY  hKey = NULL;
    HKEY  hParentKey = HKEY_LOCAL_MACHINE;
    DWORD dwStatus;     // returned by registry API functions
    DWORD dwClusterInstallState;
    DWORD dwValueType;
    DWORD dwDataBufferSize = sizeof( DWORD );

    *peState = eClusterInstallStateUnknown;

    // Connect to a remote computer if specified.

    if ( pszNodeName != NULL )
    {
        dwStatus = RegConnectRegistryW( pszNodeName, HKEY_LOCAL_MACHINE, &hParentKey );
        if ( dwStatus != ERROR_SUCCESS )
        {
            goto FnExit;
        } // if:  error connecting to remote registry
    } // if:  node name specified

    // Read the registry key that indicates whether cluster files are installed.

    dwStatus = RegOpenKeyExW( hParentKey,
                                L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Cluster Server",
                                0,         // reserved
                                KEY_READ,
                                &hKey );

    // Was the registry key opened successfully ?
    if ( dwStatus != ERROR_SUCCESS )
    {
        if ( dwStatus == ERROR_FILE_NOT_FOUND )
        {
            dwStatus = ERROR_SUCCESS;
        }
        goto FnExit;
    }

    // Read the entry.
    dwStatus = RegQueryValueExW( hKey,
                                  L"ClusterInstallationState",
                                  0, // reserved
                                  &dwValueType,
                                  (LPBYTE) &dwClusterInstallState,
                                  &dwDataBufferSize );

    // Was the value read successfully ?
    if ( dwStatus != ERROR_SUCCESS )
    {
        if ( dwStatus == ERROR_FILE_NOT_FOUND )
        {
            dwStatus = ERROR_SUCCESS;
        }
        goto FnExit;
    }
    if ( dwValueType == REG_DWORD )
    {
        *peState = (eClusterInstallState) dwClusterInstallState;
    }

FnExit:    
    // Close the registry key.
    if ( hKey )
    {
        RegCloseKey( hKey );
    }
    if ( hParentKey != HKEY_LOCAL_MACHINE )
    {
        RegCloseKey( hParentKey );
    }

    return ( dwStatus );

} //*** ClRtlGetClusterInstallState()


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ClRtlSetClusterInstallState
//
//  Routine Description:
//      This function sets the registry value that records the state of the 
//      Clustering Service installation.
//
//  Arguments:
//      hInstance - The handle to the application instance - necessary for the calls
//          to LoadString.
//    
//      eInstallState - the state to which the registry value should be set.
//
//  Return Value:
//      TRUE - indicates that the registry value was set successfully
//      FALSE - indicates that some error occured.
//
//--
/////////////////////////////////////////////////////////////////////////////

BOOL ClRtlSetClusterInstallState( eClusterInstallState eInstallState )
{
    //initialize return to FALSE
    BOOL     fReturnValue = FALSE;

    // Set the state of the ClusterInstallationState registry key to indicate
    // that Cluster Server has been configured.

    HKEY     hKey;

    DWORD    dwStatus;     // returned by registry API functions

    // Attempt to open an existing key in the registry.

    dwStatus = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                                L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Cluster Server",
                                0,         // reserved
                                KEY_WRITE,
                                &hKey );

    // Was the regustry key opened successfully ?

    if ( dwStatus == ERROR_SUCCESS )
    {
        // Update the value.

        DWORD dwClusterInstallState = eInstallState;

        DWORD dwValueType = REG_DWORD;
        DWORD dwDataBufferSize = sizeof( DWORD );

        dwStatus = RegSetValueExW( hKey,
                                    L"ClusterInstallationState",
                                    0, // reserved
                                    dwValueType,
                                    (LPBYTE) &dwClusterInstallState,
                                    dwDataBufferSize );

        // Close the registry key.

        RegCloseKey( hKey );

        // Was the value set successfully?

        if ( dwStatus == ERROR_SUCCESS )
        {
            fReturnValue = TRUE;
        }
    }

    return ( fReturnValue );

} //*** ClRtlSetClusterInstallState()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\ipaddr.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

   ipaddr.c

Abstract:

    Ip Address validation routines.

Author:

    Sunita Shrivastava (sunitas)           July 19, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    sunitas     07-19-97    created


--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <llinfo.h>
#include <wchar.h>
#include <ipexport.h>
#include <cluster.h>
#include <icmpapi.h>
#include <llinfo.h>
#include <ipinfo.h>


//
// Define IP Address ping test data
//
#define ICMP_TTL          128
#define ICMP_TOS            0
#define ICMP_TIMEOUT      500
#define ICMP_TRY_COUNT      4
#define ICMP_BUFFER_SIZE  (sizeof(ICMP_ECHO_REPLY) + 8)





BOOL
ClRtlIsDuplicateTcpipAddress(
    IN IPAddr   IpAddr
    )
/*++

Routine Description:

    This routine checks whether a give IP Address already exists on the
    network.

Arguments:

    IpAddr - The IP Address to check for.

Return Value:

    TRUE if the specified address exists on the network.
    FALSE otherwise.

--*/
{
    DWORD                   status;
    IP_OPTION_INFORMATION   icmpOptionInfo;
    HANDLE                  icmpHandle;
    DWORD                   numberOfReplies;
    DWORD                   i;
    UCHAR                   icmpBuffer[ICMP_BUFFER_SIZE];
    PICMP_ECHO_REPLY        reply;


    icmpHandle = IcmpCreateFile();

    if (icmpHandle != INVALID_HANDLE_VALUE) {
        icmpOptionInfo.OptionsData = NULL;
        icmpOptionInfo.OptionsSize = 0;
        icmpOptionInfo.Ttl = ICMP_TTL;
        icmpOptionInfo.Tos = ICMP_TOS;
        icmpOptionInfo.Flags = 0;

        for (i=0; i<ICMP_TRY_COUNT; i++) {

            numberOfReplies = IcmpSendEcho(
                                  icmpHandle,
                                  IpAddr,
                                  NULL,
                                  0,
                                  &icmpOptionInfo,
                                  icmpBuffer,
                                  ICMP_BUFFER_SIZE,
                                  ICMP_TIMEOUT
                                  );

            reply = (PICMP_ECHO_REPLY) icmpBuffer;

            while (numberOfReplies != 0) {

                if (reply->Status == IP_SUCCESS) {
                    IcmpCloseHandle( icmpHandle );
                    return(TRUE);
                }

                reply++;
                numberOfReplies--;
            }
        }

        IcmpCloseHandle( icmpHandle );
    }

    return(FALSE);

} // ClRtlIsDuplicateTcpipAddress
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\notifications.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1996-2000 Microsoft Corporation
//
//  Module Name:
//      Notifications.cpp
//
//  Abstract:
//      Implementation of functions that send out notifications.
//
//  Author:
//      Vijayendra Vasu (vvasu) 17-AUG-2000
//
//  Revision History:
//      None.
//
/////////////////////////////////////////////////////////////////////////////

#define UNICODE 1
#define _UNICODE 1


/////////////////////////////////////////////////////////////////////////////
// Include files
/////////////////////////////////////////////////////////////////////////////
#include <objbase.h>
#include <ClusCfgGuids.h>
#include <ClusCfgServer.h>
#include "clusrtl.h"


/////////////////////////////////////////////////////////////////////////////
//++
//
//  ClRtlInitiateStartupNotification()
//
//  Routine Description:
//      Initiate operations that inform interested parties that the cluster
//      service is starting up.
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          If the notification process was successfully initiated
//
//      Other HRESULTS
//          In case of error
//
//--
/////////////////////////////////////////////////////////////////////////////
HRESULT ClRtlInitiateStartupNotification( void )
{
    HRESULT                         hr = S_OK;
    IClusCfgStartupNotify *         pccsnNotify = NULL;
    ICallFactory *                  pcfCallFactory = NULL;
    AsyncIClusCfgStartupNotify *    paccsnAsyncNotify = NULL;


    // Initialize COM
    CoInitializeEx( NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE );

    do
    {
        hr = CoCreateInstance(
                  CLSID_ClusCfgStartupNotify
                , NULL
                , CLSCTX_LOCAL_SERVER 
                , __uuidof( pccsnNotify )
                , reinterpret_cast< void ** >( &pccsnNotify )
                );

        if ( FAILED( hr ) )
        {
            break;
        } // if: we could not get a pointer to synchronous notification interface

        hr = pccsnNotify->QueryInterface( __uuidof( pcfCallFactory ), reinterpret_cast< void ** >( &pcfCallFactory ) );
        if ( FAILED( hr ) )
        {
            break;
        } // if: we could not get a pointer to the call factory interface

        hr = pcfCallFactory->CreateCall(
              __uuidof( paccsnAsyncNotify )
            , NULL
            , __uuidof( paccsnAsyncNotify )
            , reinterpret_cast< IUnknown ** >( &paccsnAsyncNotify )
            );

        if ( FAILED( hr ) )
        {
            break;
        } // if: we could not get a pointer to the asynchronous notification interface

        hr = paccsnAsyncNotify->Begin_SendNotifications();
    }
    while( false ); // dummy do-while loop to avoid gotos

    //
    // Free acquired resources
    //

    if ( pccsnNotify != NULL )
    {
        pccsnNotify->Release();
    } // if: we had obtained a pointer to the synchronous notification interface

    if ( pcfCallFactory != NULL )
    {
        pcfCallFactory->Release();
    } // if: we had obtained a pointer to the call factory interface

    if ( paccsnAsyncNotify != NULL )
    {
        paccsnAsyncNotify->Release();
    } // if: we had obtained a pointer to the asynchronous notification interface

    CoUninitialize();

    return hr;
} //*** ClRtlInitiateStartupNotification()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\netname.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    netname.c

Abstract:

    Routines for validating a network name and making sure
    that it is ok to use.

Author:

    John Vert (jvert) 4/15/1997

Revision History:

--*/
#include "clusrtlp.h"
#include <lmerr.h>
#include <lmcons.h>
#include "icanon.h"
#include "netcan.h"
#include <nb30.h>
#include <msgrutil.h>
#include <lmaccess.h>
#include <lmuse.h>
#include <lmwksta.h>
#include <netlogon.h>
#include <logonp.h>
#include <windns.h>
#include <ipexport.h>

NET_API_STATUS
NET_API_FUNCTION
NetpCheckNetBiosNameNotInUse(
    LPWSTR pszName
    );


BOOL
ClRtlIsNetNameValid(
    IN LPCWSTR NetName,
    OUT OPTIONAL CLRTL_NAME_STATUS *Result,
    IN BOOL CheckIfExists
    )
/*++

Routine Description:

    Validates a network name to make sure it is ok to use.
    If it is not ok, it optionally returns the reason.

    The checks this routine does include:
        Name must not be zero length (NetNameEmpty)
        After conversion to OEM, name must be <= MAX_COMPUTERNAME_LENGTH (NetNameTooLong)
        No spaces (NetNameInvalidChars)
        No internet characters "@, (NetNameInvalidChars)
        Name already present on network (NetNameInUse)

    This routine is netbios-centric in that the name passed in must meet the
    criteria for a valid netbios name. At some point, we'll need to pass in
    the type of validation since it is possible on NT5 to configure a
    netbios-less environment.

Arguments:

    NetName - Supplies the network name.

    Result - if present, returns the exact check that failed.

    CheckIfExists - Specifies whether a check should be made to
        see if the network name exists on the network.

Return Value:

    TRUE - the network name is valid.

    FALSE - the network name is not valid.

--*/

{
    DWORD UnicodeSize;
    DWORD OemSize;
    BOOL Valid = FALSE;
    CLRTL_NAME_STATUS Reason = NetNameOk;
    DWORD Status;

    //
    // Check the Unicode length.
    //
    UnicodeSize = lstrlenW(NetName);
    if (UnicodeSize == 0) {
        Reason = NetNameEmpty;
        goto error_exit;
    }
    if (UnicodeSize > MAX_COMPUTERNAME_LENGTH) {
        Reason = NetNameTooLong;
        goto error_exit;
    }

    //
    // netbios names are converted to multi-byte before being registered. Make
    // sure that when converted to MBCS, the name is not more than
    // MAX_COMPUTERNAME_LENGTH bytes long.
    //
    OemSize = WideCharToMultiByte(CP_OEMCP,
                                  0,
                                  NetName,
                                  UnicodeSize,
                                  NULL,
                                  0,
                                  NULL,
                                  NULL);
    if (OemSize > MAX_COMPUTERNAME_LENGTH) {
        Reason = NetNameTooLong;
        goto error_exit;
    }

    //
    // Now call NetpwNameValidate. This will only check for invalid characters since
    // we have already validated the length.
    //
    if (NetpwNameValidate((LPWSTR)NetName, NAMETYPE_COMPUTER, 0) != ERROR_SUCCESS) {
        Reason = NetNameInvalidChars;
        goto error_exit;
    }

    //
    // Now we need to check for an invalid DNS name. If this fails, it is
    // probably because of additional invalid characters. Currently we do not
    // support the thing net setup does where it creates an alternate DNS name
    // that is different than the netbios name. There should be no periods in
    // this name as well, since that will cause the DNS validate name check to
    // fail when this name is brought online.
    //
    Status = DnsValidateName_W( NetName, DnsNameHostnameLabel );
    if ( Status != ERROR_SUCCESS ) {
        if ( Status == DNS_ERROR_NON_RFC_NAME ) {
            Reason = NetNameDNSNonRFCChars;
        } else {
            Reason = NetNameInvalidChars;
        }
        goto error_exit;
    }

    //
    // Finally, check to see if this name is already present on the network.
    //
    if (CheckIfExists) {
        Status = NetpCheckNetBiosNameNotInUse((LPWSTR)NetName);
        if (Status != NERR_Success) {
            Reason = NetNameInUse;
            goto error_exit;
        }
    }

    Reason = NetNameOk;
    Valid = TRUE;

error_exit:
    if (ARGUMENT_PRESENT(Result)) {
        *Result = Reason;
    }
    return(Valid);
}

#define clearncb(x)     memset((char *)x,'\0',sizeof(NCB))

/*++

Routine Description:

    FmtNcbName - format a name NCB-style

    Given a name, a name type, and a destination address, this
    function copies the name and the type to the destination in
    the format used in the name fields of a Network Control
    Block.


    SIDE EFFECTS

    Modifies 16 bytes starting at the destination address.

Arguments:

    DestBuf - Pointer to the destination buffer.

    Name - Unicode NUL-terminated name string

    Type - Name type number (0, 3, 5, or 32) (3=NON_FWD, 5=FWD)



Return Value:

    NERR_Success - The operation was successful

    Translated Return Code from the Rtl Translate routine.

    NOTE: This should only be called from UNICODE

--*/

NET_API_STATUS
MsgFmtNcbName(
    char *  DestBuf,
    WCHAR * Name,
    DWORD   Type)
  {
    DWORD           i;                // Counter
    NTSTATUS        ntStatus;
    OEM_STRING      ansiString;
    UNICODE_STRING  unicodeString;
    PCHAR           pAnsiString;


    //
    // Convert the unicode name string into an ansi string - using the
    // current locale.
    //
    unicodeString.Length = (USHORT)(wcslen(Name) * sizeof(WCHAR));
    unicodeString.MaximumLength = unicodeString.Length + sizeof(WCHAR);
    unicodeString.Buffer = Name;

    ntStatus = RtlUnicodeStringToOemString(
                &ansiString,
                &unicodeString,
                TRUE);          // Allocate the ansiString Buffer.

    if (!NT_SUCCESS(ntStatus)) {

        return RtlNtStatusToDosError( ntStatus );
    }

    pAnsiString = ansiString.Buffer;
    *(pAnsiString+ansiString.Length) = '\0';

    //
    // copy each character until a NUL is reached, or until NCBNAMSZ-1
    // characters have been copied.
    //
    for (i=0; i < NCBNAMSZ - 1; ++i) {
        if (*pAnsiString == '\0') {
            break;
        }

        //
        // Copy the Name
        //

        *DestBuf++ = (char)toupper(*pAnsiString++);
    }



    //
    // Free the buffer that RtlUnicodeStringToOemString created for us.
    // NOTE:  only the ansiString.Buffer portion is free'd.
    //

    RtlFreeOemString( &ansiString);

    //
    // Pad the name field with spaces
    //
    for(; i < NCBNAMSZ - 1; ++i) {
        *DestBuf++ = ' ';
    }

    //
    // Set the name type.
    //

    *DestBuf = (CHAR) Type;     // Set name type

    return(NERR_Success);
  }

NET_API_STATUS
NET_API_FUNCTION
NetpCheckNetBiosNameNotInUse(
    LPWSTR pszName
    )

/*++

Routine Description:

    Attempt to discover the if the name is in use. If the name shows up on any
    LANA then consider it in use.

Arguments:

    pszName - name to check

Return Value:

    NERR_Success if ok, NERR_NameInUse otherwise

--*/

{
    //
    // initial and delta value used to allocate NAME_BUFFER buffers
    //
#define NUM_NAME_BUFFERS    10

    NCB                     ncb;
    LANA_ENUM               lanaBuffer;
    DWORD                   index;
    UCHAR                   nbStatus;
    NET_API_STATUS          netStatus = NERR_Success;
    DWORD                   numNameBuffers = NUM_NAME_BUFFERS;
    WORD                    aStatBufferSize = (WORD)(sizeof(ADAPTER_STATUS)+ numNameBuffers * sizeof(NAME_BUFFER));
    UCHAR                   staticAStat[ sizeof(ADAPTER_STATUS)+ NUM_NAME_BUFFERS * sizeof(NAME_BUFFER) ];
    PADAPTER_STATUS         adapterStatus;
    PNAME_BUFFER            nameBuffer;

    //
    // Find the number of networks by sending an enum request via
    // Netbios. there is no (easy) way to distinguish netbt from IPX.
    //
    clearncb(&ncb);
    ncb.ncb_command = NCBENUM;          // Enumerate LANA nums (wait)
    ncb.ncb_buffer = (PUCHAR)&lanaBuffer;
    ncb.ncb_length = sizeof(LANA_ENUM);

    nbStatus = Netbios (&ncb);
    if (nbStatus != NRC_GOODRET) {
        return( NetpNetBiosStatusToApiStatus( nbStatus ) );
    }

    //
    // clear the NCB and format the remote name appropriately.
    //
    clearncb(&ncb);
    netStatus = MsgFmtNcbName( (char *)ncb.ncb_callname, pszName, 0x20);
    if ( netStatus != NERR_Success ) {
        return ( netStatus );
    }

    //
    // have our buffers initially point to the static buffer
    //
    adapterStatus = (PADAPTER_STATUS)staticAStat;
    nameBuffer = (PNAME_BUFFER)(adapterStatus + 1);

    //
    // cycle through the lanas, issueing an adapter status on the remote name.
    //
    for ( index = 0; index < lanaBuffer.length && netStatus == NERR_Success; index++ ) {
        NetpNetBiosReset( lanaBuffer.lana[index] );

    astat_retry:
        ncb.ncb_command = NCBASTAT;
        ncb.ncb_buffer = (PUCHAR)adapterStatus;
        ncb.ncb_length = aStatBufferSize;
        ncb.ncb_lana_num = lanaBuffer.lana[index];
        nbStatus = Netbios( &ncb );

        if ( nbStatus == NRC_INCOMP ) {

            //
            // buffer not large enough and we don't know how big a buffer we
            // need. allocate a larger buffer and retry the request until we
            // get success or another type of failure.
            //
            if ( (PUCHAR)adapterStatus != staticAStat ) {
                LocalFree( adapterStatus );
            }

            numNameBuffers += NUM_NAME_BUFFERS;
            aStatBufferSize = (WORD)(sizeof(ADAPTER_STATUS)+ numNameBuffers * sizeof(NAME_BUFFER));
            adapterStatus = LocalAlloc( LMEM_FIXED, aStatBufferSize );

            if ( adapterStatus == NULL ) {
                return netStatus;       // err on the side of caution
            }

            nameBuffer = (PNAME_BUFFER)(adapterStatus + 1);
            goto astat_retry;
        } else
        if ( nbStatus == NRC_GOODRET ) {

            //
            // got something back. Look through the list of names to make sure
            // our name is really online. We couldv'e gotten here through a
            // stale name registration.
            //
            while ( adapterStatus->name_count-- ) {
                if (( nameBuffer->name_flags & GROUP_NAME ) == 0 ) {
                    if ( _strnicmp( nameBuffer->name, ncb.ncb_callname, NCBNAMSZ - 1 ) == 0 ) {
                        netStatus = NERR_NameInUse;
                        break;
                    }
                }
                ++nameBuffer;
            }
        }

        if ( netStatus != NERR_Success ) {
            break;
        }
    }

    if ( (PUCHAR)adapterStatus != staticAStat ) {
        LocalFree( adapterStatus );
    }

    return( netStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\netcfg.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

   netcfg.c

Abstract:

    System network configuration grovelling routines

Author:

    Mike Massa (mikemas)           May 19, 1997

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     05-19-97    created


--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>

#include <cluster.h>
#include <objbase.h>
#include <devguid.h>

#include <netcon.h>
#include <regstr.h>

#include <iphlpapi.h>

//
// Private Constants
//
#define TCPIP_INTERFACES_KEY    L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces"
#define STRING_ARRAY_DELIMITERS " \t,;"

//
// Allocing and cloning helper functions
//

#define AllocGracefully(status, result, len, name)                                  \
  result = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, len);                             \
  if (!result) {                                                                    \
      status = GetLastError();                                                      \
      ClRtlLogPrint(LOG_CRITICAL,                                                   \
                    "[ClNet] alloc of %1!hs! (%2!d! bytes) failed, status %3!d!\n", \
                    name,len,status);                                               \
      goto exit_gracefully;                                                         \
  } else {                                                                          \
      status = ERROR_SUCCESS;                                                       \
  }

#define CloneAnsiString(Status,AnsiStr,WideResult) { \
   SIZE_T len = _mbstrlen(AnsiStr) + 1; \
   AllocGracefully(status, WideResult, len * sizeof(WCHAR), # AnsiStr); \
   mbstowcs(WideResult, AnsiStr, len); \
}

#define CloneWideString(Status,WideStr,WideResult) { \
   SIZE_T _size = (wcslen(WideStr) + 1) * sizeof(WCHAR); \
   AllocGracefully(Status, WideResult, _size * sizeof(WCHAR), # WideStr); \
   memcpy(WideResult, WideStr, _size); \
}

VOID
ClRtlpDeleteInterfaceInfo(
    PCLRTL_NET_INTERFACE_INFO  InterfaceInfo
    )
{
    if (InterfaceInfo) {
        LocalFree(InterfaceInfo->InterfaceAddressString);
        LocalFree(InterfaceInfo->NetworkAddressString);
        LocalFree(InterfaceInfo->NetworkMaskString);

        LocalFree(InterfaceInfo);
    }
}  // DeleteInterfaceInfo

PCLRTL_NET_INTERFACE_INFO
ClRtlpCreateInterfaceInfo(
    IN CONST PIP_ADDR_STRING IpAddr
    )
{
    DWORD status;
    PCLRTL_NET_INTERFACE_INFO This = 0;
    ULONG Addr, Mask, Network;

    Addr = inet_addr(IpAddr->IpAddress.String);
    Mask = inet_addr(IpAddr->IpMask.String);
    Network = Addr & Mask;

    if ( (INADDR_NONE == Addr) ||
         (INADDR_NONE == Mask) ||
         ((0 == Network) && Addr && Mask)
       )
    {
        ClRtlLogPrint(LOG_CRITICAL,
            "[ClNet] Bad ip addr/mask: %1!X! %2!X! %3!X!\n",
            Addr,
            Mask,
            Network
            );
        status = ERROR_INVALID_PARAMETER;
        goto exit_gracefully;
    }

    AllocGracefully(
        status,
        This,
        sizeof(CLRTL_NET_INTERFACE_INFO),
        "CLRTL_NET_INTERFACE_INFO"
        );

    This->Context = IpAddr -> Context;

    This->InterfaceAddress = Addr;
    This->NetworkMask      = Mask;
    This->NetworkAddress   = Network;

    CloneAnsiString(
        status,
        IpAddr->IpAddress.String,
        This->InterfaceAddressString
        );
    CloneAnsiString(
        status,
        IpAddr->IpMask.String,
        This->NetworkMaskString
        );

    status = ClRtlTcpipAddressToString(
                 Network,
                 &(This->NetworkAddressString)
                 );
    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[ClNet] ClRtlTcpipAddressToString of %1!X! failed, "
            "status %2!d!\n",
            Network,
            status
            );
        goto exit_gracefully;
    }

exit_gracefully:

    if (status != ERROR_SUCCESS) {
        SetLastError(status);
        if (This) {
            ClRtlpDeleteInterfaceInfo(This);
            This = 0;
        }
    }

    return This;
} // CreateInterfaceInfo

VOID
ClRtlpDeleteAdapter(
    PCLRTL_NET_ADAPTER_INFO adapterInfo
    )
{
    if (adapterInfo) {
        PCLRTL_NET_INTERFACE_INFO interfaceInfo;

        interfaceInfo = adapterInfo->InterfaceList;

        while (interfaceInfo != NULL) {
            PCLRTL_NET_INTERFACE_INFO next = interfaceInfo->Next;

            ClRtlpDeleteInterfaceInfo(interfaceInfo);

            interfaceInfo = next;
        }

        LocalFree(adapterInfo->DeviceGuid);
        LocalFree(adapterInfo->ConnectoidName);
        LocalFree(adapterInfo->DeviceName);
        LocalFree(adapterInfo->AdapterDomainName);
        LocalFree(adapterInfo->DnsServerList);

        LocalFree(adapterInfo);

        return;
    }
} // DeleteAdapter

DWORD
ClRtlpCreateAdapter(
    IN  PIP_ADAPTER_INFO AdapterInfo,
    OUT PCLRTL_NET_ADAPTER_INFO * ppAdapter)
{
    DWORD status;
    PCLRTL_NET_ADAPTER_INFO adapter = 0;
    *ppAdapter = 0;

    AllocGracefully(status, adapter, sizeof(*adapter), "NET_ADAPTER_INFO");
    ZeroMemory(adapter, sizeof(*adapter));

    //
    // Assumption here is that:
    //
    // AdapterName contains Guid in the form {4082164E-A4B5-11D2-89C3-E37CB6BB13FC}
    // We need to store it without curly brackets
    //

    {
        SIZE_T len = _mbstrlen(AdapterInfo->AdapterName); // not including 0, but including { and } //
        AllocGracefully(status, adapter->DeviceGuid,
                        sizeof(WCHAR) * (len - 1), "adapter->DeviceGuid");
        mbstowcs(adapter->DeviceGuid, AdapterInfo->AdapterName+1, len-1);
        adapter->DeviceGuid[len - 2] = UNICODE_NULL;
    }


    adapter->Index = AdapterInfo->Index;
    {
        PIP_ADDR_STRING IpAddr = &AdapterInfo->IpAddressList;
        while ( IpAddr ) {
            PCLRTL_NET_INTERFACE_INFO interfaceInfo;

            interfaceInfo = ClRtlpCreateInterfaceInfo(IpAddr);

            if (!interfaceInfo) {
                // CreateInterfaceInfo logs the error message //
                // clean up will be done by DeleteAdapter     //
                status = GetLastError();
                goto exit_gracefully;
            }

            interfaceInfo->Next = adapter->InterfaceList;
            adapter->InterfaceList = interfaceInfo;
            ++(adapter->InterfaceCount);

            IpAddr = IpAddr -> Next;
        }

        if (adapter->InterfaceList) {
            adapter->InterfaceList->Flags |= CLRTL_NET_INTERFACE_PRIMARY;
        }
    }

exit_gracefully:
    if (status != ERROR_SUCCESS) {
        ClRtlpDeleteAdapter(adapter);
    } else {
        *ppAdapter = adapter;
    }

    return status;
} // CreateAdapter


PCLRTL_NET_ADAPTER_ENUM
ClRtlpCreateAdapterEnum()
{
    DWORD                   status;
    DWORD                   len;

    PIP_ADAPTER_INFO        SingleAdapter = 0;
    PIP_ADAPTER_INFO        AdapterInfo = 0;
    PCLRTL_NET_ADAPTER_ENUM AdapterEnum = 0;

    len = 0;
    for(;;) {
        status = GetAdaptersInfo(AdapterInfo, &len);
        if (status == ERROR_SUCCESS) {
            break;
        }
        if (status != ERROR_BUFFER_OVERFLOW) {
            ClRtlLogPrint(LOG_CRITICAL,
                          "[ClNet] GetAdaptersInfo returned %1!d!\n", status);
            goto exit_gracefully;
        }
        LocalFree(AdapterInfo);    // LocalFree(0) is OK //
        AllocGracefully(status, AdapterInfo, len, "IP_ADAPTER_INFO");
    }

    AllocGracefully(status, AdapterEnum,
                    sizeof(*AdapterEnum), "PCLRTL_NET_ADAPTER_ENUM");
    ZeroMemory(AdapterEnum, sizeof(*AdapterEnum));

    SingleAdapter = AdapterInfo;

    while (SingleAdapter) {
        if (SingleAdapter->Type != MIB_IF_TYPE_LOOPBACK &&
            SingleAdapter->Type != MIB_IF_TYPE_PPP &&
            SingleAdapter->Type != MIB_IF_TYPE_SLIP )
        {
            PCLRTL_NET_ADAPTER_INFO Adapter = 0;

            status = ClRtlpCreateAdapter(SingleAdapter, &Adapter);
            if (status != ERROR_SUCCESS) {
                ClRtlLogPrint(LOG_CRITICAL,
                              "[ClNet] CreateAdapter %1!d! failed, status %2!d!\n",
                              AdapterEnum->AdapterCount, status);
                goto exit_gracefully;
            }

            //
            // Push the adapter into Enumeration List
            //
            Adapter->Next = AdapterEnum->AdapterList;
            AdapterEnum->AdapterList = Adapter;
            ++(AdapterEnum->AdapterCount);
        }

        SingleAdapter = SingleAdapter->Next;
    }

exit_gracefully:
    if (status != ERROR_SUCCESS) {
        SetLastError(status);
        ClRtlFreeNetAdapterEnum(AdapterEnum);
        AdapterEnum = 0;
    }

    LocalFree(AdapterInfo);
    return AdapterEnum;
} // CreateAdapterEnum


HKEY
ClRtlpFindAdapterKey(
    HKEY   TcpInterfacesKey,
    LPWSTR AdapterGuidString
    )

/*++

Routine Description:

    Given the adapter GUID, look through the key names under
    TCP's Interfaces key and see if a match can be found. The
    key names should have the GUID as some part of the name.

Arguments:

    TcpInterfacesKey - handle to TCP's interfaces area

    AdapterGuidString - pointer to string representing adapter's GUID

Return Value:

    Handle to the interface key; otherwise NULL

--*/

{
    HKEY AdapterInterfaceKey = NULL;
    WCHAR KeyName[REGSTR_MAX_VALUE_LENGTH + 1];
    DWORD KeyLength = sizeof( KeyName )/sizeof(TCHAR);
    DWORD index = 0;
    BOOL FoundMatch = FALSE;
    size_t SubStringPos;
    DWORD Status;
    FILETIME FileTime;

    //
    // enum the key names under the interfaces
    //
    do {
        Status = RegEnumKeyEx(TcpInterfacesKey,
                              index,
                              KeyName,
                              &KeyLength,
                              NULL,
                              NULL,
                              NULL,
                              &FileTime);
        if ( Status != ERROR_SUCCESS ) {
            break;
        }

        //
        // find the beginning of the match
        //
        _wcsupr( KeyName );
        if (wcsstr( KeyName, AdapterGuidString )) {
            FoundMatch = TRUE;
            break;
        }

        ++index;
        KeyLength = sizeof( KeyName );
    } while ( TRUE );

    if ( FoundMatch ) {

        Status = RegOpenKeyW(TcpInterfacesKey,
                             KeyName,
                             &AdapterInterfaceKey);
        if ( Status != ERROR_SUCCESS ) {
            AdapterInterfaceKey = NULL;
        }
    }

    return AdapterInterfaceKey;
} // FindAdapterKey


DWORD
ClRtlpConvertIPAddressString(
    LPSTR       DnsServerString,
    PDWORD      ServerCount,
    PDWORD *    ServerList)

/*++

Routine Description:

    Convert the string of DNS server addresses to binary

Arguments:

    DnsServerString - concat'ed string of IP addresses that can be separated
        by white space of commas

    ServerCount - pointer to DWORD that receives # of addresses detected

    ServerList - pointer to DWORD array of converted IP addresses

Return Value:

    ERROR_SUCCESS if everything went ok

--*/

{
#define MAX_DNS_SERVER_ADDRESSES    100

    PCHAR stringPointer = DnsServerString;
    DWORD stringCount = 0;
    PDWORD serverList = NULL;
    LPSTR stringAddress[ MAX_DNS_SERVER_ADDRESSES ];

    //
    // count how many addresses are in the string and null terminate them for
    // inet_addr
    //

    stringPointer += strspn(stringPointer, STRING_ARRAY_DELIMITERS);
    stringAddress[0] = stringPointer;
    stringCount = 1;

    while (stringCount < MAX_DNS_SERVER_ADDRESSES &&
           (stringPointer = strpbrk(stringPointer, STRING_ARRAY_DELIMITERS)))
    {
        *stringPointer++ = '\0';
        stringPointer += strspn(stringPointer, STRING_ARRAY_DELIMITERS);
        stringAddress[stringCount] = stringPointer;
        if (*stringPointer) {
            ++stringCount;
        }
    }

    serverList = LocalAlloc( LMEM_FIXED, stringCount * sizeof( DWORD ));
    if ( serverList == NULL ) {
        return GetLastError();
    }

    *ServerCount = stringCount;
    *ServerList = serverList;

    while ( stringCount-- ) {
        serverList[ stringCount ] = inet_addr( stringAddress[ stringCount ]);
    }

    return ERROR_SUCCESS;
} // ConvertIPAddressString


typedef BOOLEAN (*ENUM_CALLBACK)(NETCON_PROPERTIES *,
                                 INetConnection*,
                                 PVOID Context);
HRESULT
ClRtlpHrEnumConnections(
    IN ENUM_CALLBACK enumCallback,
    IN PVOID Context
    )
/*++

Routine Description:

    Enumerate Connection Manager Connections

Arguments:

    enumCallback     - callback to be called for every connection
    Context          - to be passed to a callback

Return Value:

    S_OK or HRESULT error code

--*/
{
    HRESULT                   hr;
    INetConnectionManager     * NcManager = NULL;
    IEnumNetConnection        * EnumNc = NULL;
    INetConnection            * NetConnection = NULL;
    NETCON_PROPERTIES         * NcProps = NULL;
    DWORD                     dwNumConnectionsReturned;
    LPWSTR                    deviceGuidString = NULL;

    //
    // instantiate a connection mgr object and enum the connections
    //
    hr = CoCreateInstance((REFCLSID)&CLSID_ConnectionManager,
                          NULL,
                          CLSCTX_LOCAL_SERVER,
                          (REFIID)&IID_INetConnectionManager,
                          &NcManager);
    if (FAILED(hr)) {
        ClRtlLogPrint(LOG_CRITICAL,
                      "[ClNet] INetConnectionManager_CoCreateInstance failed, status %1!X!\n",
                      hr);
        goto exit_gracefully;
    }

    hr = INetConnectionManager_EnumConnections(NcManager,
                                               NCME_DEFAULT,
                                               &EnumNc);
    if (FAILED(hr)) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[ClNet] INetConnectionManager_EnumConnections failed, status %1!X!\n",
             hr);
        goto exit_gracefully;
    }

    IEnumNetConnection_Reset( EnumNc );

    while (TRUE) {
        hr = IEnumNetConnection_Next(EnumNc,
                                     1,
                                     &NetConnection,
                                     &dwNumConnectionsReturned);
        if (FAILED(hr)) {
            ClRtlLogPrint(LOG_CRITICAL,
                "[ClNet] IEnumNetConnection_Next failed, status %1!X!\n",
                 hr);
            goto exit_gracefully;
        }

        if ( dwNumConnectionsReturned == 0 ) {
            hr = S_OK;
            break;
        }

        hr = INetConnection_GetProperties(NetConnection, &NcProps);
        if (SUCCEEDED( hr )) {
            BOOLEAN bCont;

            bCont = enumCallback(NcProps, NetConnection, Context);

            NcFreeNetconProperties(NcProps);
            NcProps = 0;
            if (!bCont) {
                break;
            }
        }
        INetConnection_Release( NetConnection ); NetConnection = NULL;
    }

exit_gracefully:

    if (EnumNc != NULL) {
        IEnumNetConnection_Release( EnumNc );
    }

    if (NcManager != NULL) {
        INetConnectionManager_Release( NcManager );
    }

    return hr;

} // HrEnumConnections


VOID
ClRtlpProcessNetConfigurationAdapter(
    HKEY                      TcpInterfacesKey,
    PCLRTL_NET_ADAPTER_ENUM   adapterEnum,
    NETCON_PROPERTIES *       NCProps,
    LPWSTR                    DeviceGuidString
    )

/*++

Routine Description:

    For a given conn mgr object, determine if it is in use by
    TCP. This is acheived by comparing the adapter ID in the tcpip
    adapter enumeration with the connection object's guid.

Arguments:

    TcpInterfacessKey - handle to the root of the TCP\Parameters\Interfaces area

    adapterEnum - pointer to enumeration of adapters and their interfaces
        actually in use by TCP

    NCProps - Connectoid properties.

    DeviceGuidString - Guid for the connectoid (and for the associated adapter).

Return Value:

    None

--*/

{
    HKEY AdaptersKey;
    HKEY DHCPAdaptersKey = NULL;
    HKEY InterfacesKey = NULL;
    PCLRTL_NET_ADAPTER_INFO adapterInfo = NULL;
    DWORD valueSize;
    DWORD valueType;
    LPWSTR valueName;
    LPSTR ansiValueName;
    BOOL ignoreAdapter = FALSE;
    DWORD NTEContext;
    DWORD Status;
    BOOL dhcpEnabled;

    //
    // Get the TCP/IP interfaces registry key for this adapter.
    //
    InterfacesKey = ClRtlpFindAdapterKey(
                        TcpInterfacesKey,
                        DeviceGuidString
                        );

    if (InterfacesKey == NULL) {
        ClRtlLogPrint(LOG_CRITICAL, 
            "[ClNet] No Interfaces key for %1!ws!\n",
            DeviceGuidString
            );
        goto exit_gracefully;
    }

    //
    // see if we should be ignoring this adapter per the registry
    //
    valueSize = sizeof(DWORD);
    Status = RegQueryValueExW(InterfacesKey,
                              L"MSCSHidden",
                              NULL,
                              &valueType,
                              (LPBYTE) &ignoreAdapter,
                              &valueSize);

    if ( Status != ERROR_SUCCESS ) {
        ignoreAdapter = FALSE;
    }

    //
    // Search the enum for this adapter.
    //
    adapterInfo = ClRtlFindNetAdapterById(adapterEnum, DeviceGuidString);

    if (adapterInfo != NULL) {
        CloneWideString(Status, NCProps->pszwDeviceName, adapterInfo->DeviceName);
        CloneWideString(Status, NCProps->pszwName,       adapterInfo->ConnectoidName);

        //
        // Check if this is a hidden netcard.
        //
        if ( ignoreAdapter ) {
            adapterInfo->Flags |= CLRTL_NET_ADAPTER_HIDDEN;
        }

        //
        // Store the NCStatus in the adapter info structure
        //
        adapterInfo->NCStatus = NCProps->Status;

        //
        // get the domain name and DHCP server list (if any) associated
        // with this adapter.  The Domain value has precedence over
        // DhcpDomain. If that value is empty/doesn't exist, then use
        // DhcpDomain only if EnableDHCP is set to one.
        //
        Status = ClRtlRegQueryDword(InterfacesKey,
                                    L"EnableDHCP",
                                    &dhcpEnabled,
                                    NULL);

        if ( Status != ERROR_SUCCESS ) {
            dhcpEnabled = FALSE;
        }

        valueName = L"Domain";
        valueSize = 0;
        Status = RegQueryValueExW(InterfacesKey,
                                  valueName,
                                  NULL,
                                  &valueType,
                                  (LPBYTE)NULL,
                                  &valueSize);

        if ( Status != ERROR_SUCCESS || valueSize == sizeof(UNICODE_NULL)) {

            //
            // it didn't exist or the value was NULL. if were using DHCP,
            // then check to see if DHCP supplied domain name was
            // specified
            //
            if ( dhcpEnabled ) {
                valueName = L"DhcpDomain";
                Status = RegQueryValueExW(InterfacesKey,
                                          valueName,
                                          NULL,
                                          &valueType,
                                          (LPBYTE)NULL,
                                          &valueSize);
            } else {
                Status = ERROR_FILE_NOT_FOUND;
            }
        }

        if ( Status == ERROR_SUCCESS && valueSize > sizeof(UNICODE_NULL)) {

            //
            // legit domain name was found (somewhere). store it in the
            // adapter info
            //
            adapterInfo->AdapterDomainName = LocalAlloc(LMEM_FIXED,
                                                        valueSize +
                                                        sizeof(UNICODE_NULL));

            if ( adapterInfo->AdapterDomainName != NULL ) {

                Status = RegQueryValueExW(InterfacesKey,
                                          valueName,
                                          NULL,
                                          &valueType,
                                          (LPBYTE)adapterInfo->AdapterDomainName,
                                          &valueSize);

                if ( Status != ERROR_SUCCESS ) {

                    LocalFree( adapterInfo->AdapterDomainName );
                    adapterInfo->AdapterDomainName = NULL;
                }
#if CLUSTER_BETA
                else {
                    ClRtlLogPrint(LOG_NOISE,
                                    "            %1!ws! key: %2!ws!\n",
                                     valueName,
                                     adapterInfo->AdapterDomainName);
                }
#endif
            } else {
                Status = GetLastError();
            }
        }

        //
        // now get the DNS server list in a similar fashion. The
        // NameServer value has precedence over DhcpNameServer but we only
        // check the DHCP values if DHCP is enabled (just like
        // above). Note that we use the Ansi APIs since we need to convert
        // the IP addresses into binary form and there is no wide char
        // form of inet_addr.
        //
        ansiValueName = "NameServer";
        valueSize = 0;
        Status = RegQueryValueExA(InterfacesKey,
                                  ansiValueName,
                                  NULL,
                                  &valueType,
                                  (LPBYTE)NULL,
                                  &valueSize);

        if ( Status != ERROR_SUCCESS || valueSize == 1 ) {
            if ( dhcpEnabled ) {
                ansiValueName = "DhcpNameServer";
                Status = RegQueryValueExA(InterfacesKey,
                                          ansiValueName,
                                          NULL,
                                          &valueType,
                                          (LPBYTE)NULL,
                                          &valueSize);
            } else {
                Status = ERROR_FILE_NOT_FOUND;
            }
        }

        if ( Status == ERROR_SUCCESS && valueSize > 0 ) {
            PCHAR nameServerString;

            nameServerString = LocalAlloc( LMEM_FIXED, valueSize + 1 );

            if ( nameServerString != NULL ) {

                Status = RegQueryValueExA(InterfacesKey,
                                          ansiValueName,
                                          NULL,
                                          &valueType,
                                          (LPBYTE)nameServerString,
                                          &valueSize);

                if ( Status == ERROR_SUCCESS ) {
                    DWORD serverCount;
                    PDWORD serverList;

#if CLUSTER_BETA
                    ClRtlLogPrint(LOG_NOISE,
                                    "            %1!hs! key: %2!hs!\n",
                                     ansiValueName,
                                     nameServerString);
#endif
                    Status = ClRtlpConvertIPAddressString(
                                 nameServerString,
                                 &serverCount,
                                 &serverList
                                 );

                    if ( Status == ERROR_SUCCESS ) {
                        adapterInfo->DnsServerCount = serverCount;
                        adapterInfo->DnsServerList = serverList;
                    } else {
                        adapterInfo->DnsServerCount = 0;
                        adapterInfo->DnsServerList = NULL;
                    }
                } else {
                    adapterInfo->DnsServerCount = 0;
                    adapterInfo->DnsServerList = NULL;
                }

                LocalFree( nameServerString );
            } else {
                Status = GetLastError();
            }
        }
    }

    if ( adapterInfo == NULL ) {
        //
        // TCP/IP is not bound to this adapter right now. PnP?
        //
        ClRtlLogPrint(LOG_UNUSUAL,
            "[ClNet] Tcpip is not bound to adapter %1!ws!.\n",
            DeviceGuidString
            );
    }

exit_gracefully:

    if (InterfacesKey != NULL) {
        RegCloseKey( InterfacesKey );
    }

    return;
} // ProcessNetConfigurationAdapter


typedef struct _CONFIGURATION_CONTEXT
{
    PCLRTL_NET_ADAPTER_ENUM   adapterEnum;
    HKEY                      TcpInterfacesKey;
}
CONFIGURATION_CONTEXT, *PCONFIGURATION_CONTEXT;

typedef WCHAR GUIDSTR[32 * 3];
VOID GuidToStr(LPGUID Guid, PWCHAR buf)
{
    //
    // GUIDs look like this: 4082164E-A4B5-11D2-89C3-E37CB6BB13FC
    //
    wsprintfW(
        buf,
        L"%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X",
        Guid->Data1, Guid->Data2, Guid->Data3,
        Guid->Data4[0], Guid->Data4[1], Guid->Data4[2], Guid->Data4[3],
        Guid->Data4[4], Guid->Data4[5], Guid->Data4[6], Guid->Data4[7]
        );
}

BOOLEAN
ClRtlpProcessConfigurationCallback(
    NETCON_PROPERTIES * NCProps,
    INetConnection * NetConnection,
    PVOID Context
    )
{
    PCONFIGURATION_CONTEXT Ctx =
        (PCONFIGURATION_CONTEXT) Context;

    if ( NCProps->MediaType == NCM_LAN &&
         NCProps->Status != NCS_HARDWARE_NOT_PRESENT &&
         NCProps->Status != NCS_HARDWARE_DISABLED &&
         NCProps->Status != NCS_HARDWARE_MALFUNCTION)
    {
        GUIDSTR deviceGuidString;
        GuidToStr(&NCProps->guidId, deviceGuidString);

        ClRtlpProcessNetConfigurationAdapter(
            Ctx->TcpInterfacesKey,
            Ctx->adapterEnum,
            NCProps,
            deviceGuidString
            );
        //
        // the strings in the properties struct are either kept or
        // or freed in ProcessNetConfigurationAdapter. If they are
        // used, then they are freed when the adapter enum is freed
        //
    }
    return TRUE;
} // ProcessConfigurationCallback


PCLRTL_NET_ADAPTER_ENUM
ClRtlEnumNetAdapters(
    VOID
    )
/*++

Routine Description:

    Enumerates all of the installed network adapters to which TCP/IP
    is bound.

Arguments:

    None.

Return Value:

    A pointer to a network adapter enumeration, if successful.
    NULL if unsuccessful. Extended error information is available from
    GetLastError().

--*/
{
    DWORD                     status;
    PCLRTL_NET_ADAPTER_INFO   adapterInfo = NULL;
    CONFIGURATION_CONTEXT     Ctx;
    PVOID                    wTimer;

    ZeroMemory(&Ctx, sizeof(Ctx));

    //
    // First get the list of bound adapters & interfaces from the
    // tcpip stack.
    //
    Ctx.adapterEnum = ClRtlpCreateAdapterEnum();
    if (Ctx.adapterEnum == NULL) {
        status = GetLastError();
        ClRtlLogPrint(LOG_CRITICAL,
                        "[ClNet] GetTcpipAdaptersAndInterfaces failed %1!u!\n", status);

        SetLastError(status);
        return(NULL);
    }

    //
    // Open the Services portion of the registry
    //
    status = RegOpenKeyW(HKEY_LOCAL_MACHINE,
                         TCPIP_INTERFACES_KEY,
                         &Ctx.TcpInterfacesKey);

    if (status != ERROR_SUCCESS) {
        ClRtlLogPrint(LOG_CRITICAL,
            "[ClNet] Open of TCP Params key failed - %1!u!\n",
            status
            );

        goto exit_gracefully;
    }

	// This function might hang, so setting the watchdog timer to 2 mins (2 * 60 * 1000) ms
	wTimer = ClRtlSetWatchdogTimer(120000, L"Calling EnumConnections");

    status = ClRtlpHrEnumConnections(
                 ClRtlpProcessConfigurationCallback,
                 &Ctx
                 );

    ClRtlCancelWatchdogTimer(wTimer);

    if (status != S_OK) {
        goto exit_gracefully;
    }

    //
    // Finally, ensure that we found a name for each adapter in the enum.
    //
    for (adapterInfo = Ctx.adapterEnum->AdapterList;
         adapterInfo != NULL;
         adapterInfo = adapterInfo->Next
         )
    {
        if (adapterInfo->ConnectoidName == NULL) {
            if ( adapterInfo->InterfaceCount > 0 ) {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[ClNet] No installed adapter was found for IP address %1!ws!\n",
                     adapterInfo->InterfaceList->InterfaceAddressString
                     );
            } else {
                ClRtlLogPrint(LOG_CRITICAL,
                    "[ClNet] No installed adapter was found for Tcpip IF entity %1!u!\n",
                     adapterInfo->Index
                     );
            }
            status = ERROR_FILE_NOT_FOUND;
            goto exit_gracefully;
        }
    }

#if CLUSTER_BETA
    ClRtlLogPrint(LOG_NOISE,
                    "[ClNet] Successfully enumerated all adapters and interfaces\n");
#endif

    status = ERROR_SUCCESS;

exit_gracefully:

    if (Ctx.TcpInterfacesKey != NULL) {
        RegCloseKey(Ctx.TcpInterfacesKey);
    }

    if (status != ERROR_SUCCESS) {
        if (Ctx.adapterEnum != NULL) {
            ClRtlFreeNetAdapterEnum(Ctx.adapterEnum);
            Ctx.adapterEnum = NULL;
        }

        SetLastError(status);
    }

    return(Ctx.adapterEnum);

} // ClRtlEnumNetAdapters


VOID
ClRtlFreeNetAdapterEnum(
    IN PCLRTL_NET_ADAPTER_ENUM  AdapterEnum
    )
/*++

Routine Description:

    Frees a network adapter enumeration structure.

Arguments:

    AdapterEnum  -  A pointer to the structure to be freed.

Return Value:

    None.

--*/
{
    if (AdapterEnum) {
        PCLRTL_NET_ADAPTER_INFO p = AdapterEnum -> AdapterList;
        while (p) {
            PCLRTL_NET_ADAPTER_INFO next = p->Next;
            ClRtlpDeleteAdapter(p);
            p = next;
        }
        LocalFree(AdapterEnum);
    }
}  // ClRtlFreeNetAdapterEnum


PCLRTL_NET_ADAPTER_INFO
ClRtlFindNetAdapterById(
    PCLRTL_NET_ADAPTER_ENUM   AdapterEnum,
    LPWSTR                    AdapterId
    )
{
    PCLRTL_NET_ADAPTER_INFO  adapterInfo;


    for ( adapterInfo = AdapterEnum->AdapterList;
          adapterInfo != NULL;
          adapterInfo = adapterInfo->Next
        )
    {
        if (wcscmp(AdapterId, adapterInfo->DeviceGuid) == 0) {
            if (!adapterInfo->Ignore) {
                return(adapterInfo);
            }
            else {
                return(NULL);
            }
        }
    }

    return(NULL);

} // ClRtlFindNetAdapterById


PCLRTL_NET_INTERFACE_INFO
ClRtlFindNetInterfaceByNetworkAddress(
    IN PCLRTL_NET_ADAPTER_INFO   AdapterInfo,
    IN LPWSTR                    NetworkAddress
    )
{
    PCLRTL_NET_INTERFACE_INFO  interfaceInfo;

    for (interfaceInfo = AdapterInfo->InterfaceList;
         interfaceInfo != NULL;
         interfaceInfo = interfaceInfo->Next
        )
    {
        if (interfaceInfo->Ignore == FALSE) {
            //
            // We only look at the primary interface on the
            // adapter right now.
            //
            if (interfaceInfo->Flags & CLRTL_NET_INTERFACE_PRIMARY)
            {
                if ( wcscmp(
                         interfaceInfo->NetworkAddressString,
                         NetworkAddress
                         ) == 0 )
                {
                    return(interfaceInfo);
                }
            }
        }
    }

    return(NULL);

} // ClRtlFindNetInterfaceByNetworkAddress


PCLRTL_NET_ADAPTER_INFO
ClRtlFindNetAdapterByNetworkAddress(
    IN  PCLRTL_NET_ADAPTER_ENUM      AdapterEnum,
    IN  LPWSTR                       NetworkAddress,
    OUT PCLRTL_NET_INTERFACE_INFO *  InterfaceInfo
    )
{
    PCLRTL_NET_ADAPTER_INFO    adapterInfo;
    PCLRTL_NET_INTERFACE_INFO  interfaceInfo;


    for ( adapterInfo = AdapterEnum->AdapterList;
          adapterInfo != NULL;
          adapterInfo = adapterInfo->Next
        )
    {
        if (adapterInfo->Ignore == FALSE) {
            for (interfaceInfo = adapterInfo->InterfaceList;
                 interfaceInfo != NULL;
                 interfaceInfo = interfaceInfo->Next
                )
            {
                if (interfaceInfo->Ignore == FALSE) {
                    //
                    // We only look at the primary interface on the
                    // adapter right now.
                    //
                    if (interfaceInfo->Flags & CLRTL_NET_INTERFACE_PRIMARY) {
                        if ( wcscmp(
                                 interfaceInfo->NetworkAddressString,
                                 NetworkAddress
                                 ) == 0 )
                        {
                            *InterfaceInfo = interfaceInfo;

                            return(adapterInfo);
                        }
                    }
                }
            }
        }
    }

    *InterfaceInfo = NULL;

    return(NULL);

} // ClRtlFindNetAdapterByNetworkAddress


PCLRTL_NET_ADAPTER_INFO
ClRtlFindNetAdapterByInterfaceAddress(
    IN  PCLRTL_NET_ADAPTER_ENUM      AdapterEnum,
    IN  LPWSTR                       InterfaceAddressString,
    OUT PCLRTL_NET_INTERFACE_INFO *  InterfaceInfo
    )
/*++

    For a given IP interface address, find the
    adapter that is hosting that address.

--*/

{
    PCLRTL_NET_ADAPTER_INFO    adapterInfo;
    PCLRTL_NET_INTERFACE_INFO  interfaceInfo;

    for ( adapterInfo = AdapterEnum->AdapterList;
          adapterInfo != NULL;
          adapterInfo = adapterInfo->Next
        )
    {
        if (adapterInfo->Ignore == FALSE) {
            for (interfaceInfo = adapterInfo->InterfaceList;
                 interfaceInfo != NULL;
                 interfaceInfo = interfaceInfo->Next
                )
            {
                if (interfaceInfo->Ignore == FALSE ) {

                    if ( wcscmp( interfaceInfo->InterfaceAddressString,
                                 InterfaceAddressString ) == 0 ) {
                        *InterfaceInfo = interfaceInfo;
                        return(adapterInfo);
                    }
                }
            }
        }
    }

    *InterfaceInfo = NULL;
    return(NULL);

} // ClRtlFindNetAdapterByInterfaceAddress

PCLRTL_NET_INTERFACE_INFO
ClRtlGetPrimaryNetInterface(
    IN PCLRTL_NET_ADAPTER_INFO  AdapterInfo
    )
{
    PCLRTL_NET_INTERFACE_INFO  interfaceInfo;


    for (interfaceInfo = AdapterInfo->InterfaceList;
         interfaceInfo != NULL;
         interfaceInfo = interfaceInfo->Next
        )
    {
        if (interfaceInfo->Flags & CLRTL_NET_INTERFACE_PRIMARY) {
            if (!interfaceInfo->Ignore) {
                return(interfaceInfo);
            }
            else {
                return(NULL);
            }
        }
    }

    return(NULL);

} // ClRtlGetPrimaryNetInterface


LPWSTR
ClRtlGetConnectoidName(
    INetConnection * NetConnection
    )
{
    DWORD                 status;
    NETCON_PROPERTIES *   NcProps = NULL;
    LPWSTR                name = NULL;


    status = INetConnection_GetProperties(NetConnection, &NcProps);

    if (SUCCEEDED( status )) {
        DWORD nameLength = (lstrlenW(NcProps->pszwName) * sizeof(WCHAR)) +
                           sizeof(UNICODE_NULL);

        name = LocalAlloc(LMEM_FIXED, nameLength);

        if (name != NULL) {
            lstrcpyW(name, NcProps->pszwName);
        }
        else {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }

        NcFreeNetconProperties( NcProps );
    }
    else {
        SetLastError(status);
    }

    return(name);

} // ClRtlGetConnectoidName


typedef struct _FIND_CONNECTOID_CONTEXT
{
    GUID    ConnectoidGuid;
    LPCWSTR ConnectoidName;
    INetConnection * NetConnection;
}
FIND_CONNECTOID_CONTEXT, *PFIND_CONNECTOID_CONTEXT;

BOOLEAN
ClRtlpFindConnectoidByGuidCallback(
    NETCON_PROPERTIES * NcProp,
    INetConnection * NetConnection,
    PVOID Context
    )
{
    PFIND_CONNECTOID_CONTEXT Ctx =
        (PFIND_CONNECTOID_CONTEXT) Context;

    if ( IsEqualGUID(&Ctx->ConnectoidGuid, &NcProp->guidId) ) {
        INetConnection_AddRef(NetConnection);
        Ctx->NetConnection = NetConnection;
        return FALSE;
    }
    return TRUE;
} // FindConnectoidByGuidCallback

INetConnection *
ClRtlFindConnectoidByGuid(
    LPWSTR ConnectoidGuidStr
    )
{
    FIND_CONNECTOID_CONTEXT Ctx;
    HRESULT hr;
    RPC_STATUS rpcStatus;
    ZeroMemory(&Ctx, sizeof(Ctx));

    rpcStatus = UuidFromStringW (
                    (LPWSTR)ConnectoidGuidStr,
                    &Ctx.ConnectoidGuid);
    if (rpcStatus != ERROR_SUCCESS) {
        SetLastError( HRESULT_FROM_WIN32(rpcStatus) );
        return 0;
    }

    hr = ClRtlpHrEnumConnections(ClRtlpFindConnectoidByGuidCallback, &Ctx);
    if (hr != S_OK) {
        SetLastError(hr);
        return 0;
    } else {
        return Ctx.NetConnection;
    }
} // ClRtlFindConnectoidByGuid

BOOLEAN
ClRtlpFindConnectoidByNameCallback(
    NETCON_PROPERTIES * NcProp,
    INetConnection * NetConnection,
    PVOID Context
    )
{
    PFIND_CONNECTOID_CONTEXT Ctx =
        (PFIND_CONNECTOID_CONTEXT) Context;

    if ( lstrcmpiW(Ctx->ConnectoidName, NcProp->pszwName) == 0 ) {
        INetConnection_AddRef(NetConnection);
        Ctx->NetConnection = NetConnection;
        return FALSE;
    }
    return TRUE;
} // FindConnectoidByNameCallback

INetConnection *
ClRtlFindConnectoidByName(
    LPCWSTR ConnectoidName
    )
{
    FIND_CONNECTOID_CONTEXT Ctx;
    HRESULT hr;
    ZeroMemory(&Ctx, sizeof(Ctx));

    Ctx.ConnectoidName = ConnectoidName;

    hr = ClRtlpHrEnumConnections(ClRtlpFindConnectoidByNameCallback, &Ctx);
    if (hr != S_OK) {
        SetLastError(hr);
        return 0;
    } else {
        return Ctx.NetConnection;
    }
} // ClRtlFindConnectoidByName


DWORD
ClRtlSetConnectoidName(
    INetConnection *  NetConnection,
    LPWSTR            NewConnectoidName
    )

/*++

Routine Description:

    Set the conn mgr object in the connections folder to the
    supplied name. This routine must deal with collisions since
    the name change could be the result of a node joining the
    cluster whose conn obj name in the connection folder had
    changed while the cluster service was stopped on that node.

    If a collision is detected, the existing name is changed to
    have an "(previous)" appended to it.

Arguments:

    NetConnection - Connect object to set.

    NewConnectoidName - new name

Return Value:

    Win32 error status

--*/
{
    DWORD               status = E_UNEXPECTED;
    INetConnection *    connectoidObj;
    LPWSTR              tempName;
    ULONG               iteration = 2;
    GUIDSTR             connectoidGuid;

    //
    // first see if there is a collision with the new name. If so,
    // we'll rename the collided name, since we need to make all
    // the cluster connectoids the same.
    //
    connectoidObj = ClRtlFindConnectoidByName( NewConnectoidName );

    if ( connectoidObj != NULL ) {
        NETCON_PROPERTIES *   NcProps = NULL;


        status = INetConnection_GetProperties(connectoidObj, &NcProps);

        if (SUCCEEDED( status )) {

            GuidToStr(&NcProps->guidId, connectoidGuid);
            NcFreeNetconProperties( NcProps );
        }
        else {
            wsprintf(
                &(connectoidGuid[0]),
                L"????????-????-????-????-??????????????"
                );
        }

        ClRtlLogPrint(LOG_UNUSUAL, 
            "[ClNet] New connectoid name '%1!ws!' collides with name of "
            "existing connectoid (%2!ws!). Renaming existing connectoid.\n",
            NewConnectoidName,
            connectoidGuid
            );

        //
        // allocate enough space for the connectoid name with a trailing
        // "(ddd)". 3 digits for the number should be enough
        //
        tempName = LocalAlloc(
                       LMEM_FIXED,
                       (wcslen( NewConnectoidName ) + 6) * sizeof(WCHAR)
                       );

        if ( tempName == NULL ) {
            INetConnection_Release( connectoidObj );
            return ERROR_OUTOFMEMORY;
        }

        do {
            wsprintf( tempName, L"%s(%u)", NewConnectoidName, iteration++ );
            status = INetConnection_Rename( connectoidObj, tempName );
        } while ( !SUCCEEDED( status ) && iteration <= 999 );

        if ( iteration > 999 ) {
            ClRtlLogPrint(LOG_UNUSUAL, 
                "[ClNet] Failed to create a unique name for connectoid "
                "'%1!ws!' (%2!ws!)\n",
                NewConnectoidName,
                connectoidGuid
                );

            INetConnection_Release( connectoidObj );

            return(ERROR_DUP_NAME);
        }

        ClRtlLogPrint(LOG_NOISE, 
            "[ClNet] Renamed existing connectoid '%1!ws!' (%2!ws!) to '%3!ws!' "
            "due to a collision with the name of cluster network.\n",
            NewConnectoidName,
            connectoidGuid,
            tempName
            );

        INetConnection_Release( connectoidObj );
    }

    //
    // now set the connectoid to the new name
    //
    status = INetConnection_Rename( NetConnection, NewConnectoidName );

    return status;

} // ClRtlSetConnectoidName



DWORD
ClRtlFindConnectoidByNameAndSetName(
    LPWSTR ConnectoidName,
    LPWSTR NewConnectoidName
    )
{
    DWORD               status = E_UNEXPECTED;
    INetConnection *    connectoidObj;

    connectoidObj = ClRtlFindConnectoidByName( ConnectoidName );

    if ( connectoidObj != NULL ) {
        status = ClRtlSetConnectoidName(connectoidObj, NewConnectoidName);

        INetConnection_Release( connectoidObj );
    }
    else {
        status = GetLastError();
    }

    return(status);

} // ClRtlFindConnectoidByNameAndSetName



DWORD
ClRtlFindConnectoidByGuidAndSetName(
    LPWSTR ConnectoidGuid,
    LPWSTR NewConnectoidName
    )
{
    DWORD               status = E_UNEXPECTED;
    INetConnection *    connectoidObj;

    connectoidObj = ClRtlFindConnectoidByGuid( ConnectoidGuid );

    if ( connectoidObj != NULL ) {
        status = ClRtlSetConnectoidName(connectoidObj, NewConnectoidName);

        INetConnection_Release( connectoidObj );
    }
    else {
        status = GetLastError();
    }

    return(status);

} // ClRtlFindConnectoidByGuidAndSetName


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\queue.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    queue.c

Abstract:

    Generic efficient queue package.

Author:

    John Vert (jvert) 12-Jan-1996

Revision History:

--*/
#include "clusrtlp.h"


DWORD
ClRtlInitializeQueue(
    PCL_QUEUE Queue
    )
/*++

Routine Description:

    Initializes a queue for use.

Arguments:

    Queue - Supplies a pointer to a queue structure to initialize

Return Value:

    ERROR_SUCCESS if successful

    Win32 error code otherwise.

--*/

{
    DWORD Status;

    InitializeListHead(&Queue->ListHead);
    InitializeCriticalSection(&Queue->Lock);
    Queue->Count = 0;

    Queue->Event = CreateEvent(NULL,
                               TRUE,
                               FALSE,
                               NULL);
    if (Queue->Event == NULL) {
        Status = GetLastError();
        DeleteCriticalSection(&Queue->Lock);
    } else {
        Queue->Abort = CreateEvent(NULL,
                                   TRUE,
                                   FALSE,
                                   NULL);
        if (Queue->Abort == NULL) {
            Status = GetLastError();
            CloseHandle(Queue->Event);
            DeleteCriticalSection(&Queue->Lock);
        } else {
            Status = ERROR_SUCCESS;
        }
    }

    return(Status);

}


VOID
ClRtlDeleteQueue(
    IN PCL_QUEUE Queue
    )
/*++

Routine Description:

    Releases all resources used by a queue.

Arguments:

    Queue - supplies the queue to be deleted

Return Value:

    None.

--*/

{

    DeleteCriticalSection(&Queue->Lock);
    CloseHandle(Queue->Event);
    CloseHandle(Queue->Abort);

    //
    // Zero the memory in order to cause grief to people who try
    // and use a deleted queue.
    //
    ZeroMemory(Queue, sizeof(CL_QUEUE));
}


VOID
ClRtlRundownQueue(
    IN PCL_QUEUE Queue,
    OUT PLIST_ENTRY ListHead
    )
/*++

Routine Description:

    Runs down a queue that is about to be destroyed. Any threads currently
    waiting on the queue are unwaited (ClRtlRemoveHeadQueue will return NULL)
    and the contents of the queue (if any) are returned to the caller for
    cleanup.

Arguments:

    Queue - supplies the queue to be rundown

    ListHead - returns the list of items currently in the queue.

Return Value:

    None.

--*/
{
    EnterCriticalSection(&Queue->Lock);
    //
    // Set the aborted event to awaken any threads currently
    // blocked on the queue.
    //
    SetEvent(Queue->Abort);

    //
    // Move the contents of the list into the passed in listhead
    //
    if (IsListEmpty(&Queue->ListHead)) {
        InitializeListHead(ListHead);
    } else {
        *ListHead = Queue->ListHead;
        ListHead->Flink->Blink = ListHead;
        ListHead->Blink->Flink = ListHead;
    }
    Queue->ListHead.Flink = Queue->ListHead.Blink = NULL;
    Queue->Count = 0;

    LeaveCriticalSection(&Queue->Lock);
}


PLIST_ENTRY
ClRtlRemoveHeadQueue(
    IN PCL_QUEUE Queue
    )
/*++

Routine Description:

    Removes the item at the head of the queue. If the queue is empty,
    blocks until an item is inserted into the queue.

Arguments:

    Queue - Supplies the queue to remove an item from.

Return Value:

    Pointer to list entry removed from the head of the queue.

--*/

{
    return(ClRtlRemoveHeadQueueTimeout(Queue, INFINITE,NULL,NULL));
}



PLIST_ENTRY
ClRtlRemoveHeadQueueTimeout(
    IN PCL_QUEUE Queue,
    IN DWORD dwMilliseconds,
    IN CLRTL_CHECK_HEAD_QUEUE_CALLBACK pfnCallback,
    IN OUT PVOID pvContext
    )
/*++

Routine Description:

    Removes the item at the head of the queue. If the queue is empty,
    blocks until an item is inserted into the queue.

Arguments:

    Queue - Supplies the queue to remove an item from.

    Timeout - Supplies a timeout value that specifies the relative
        time, in milliseconds, over which the wait is to be completed.

    Callback - Checks to see whether we should return the event if
        we find one.  This simulates a peek.

    Context - Caller-defined data to be passed in with callback.

Return Value:

    Pointer to list entry removed from the head of the queue.

    NULL if the wait times out, the queue is run down, or the name exceeds
        the buffer length. If this routine returns NULL, GetLastError 
        will return ERROR_INVALID_HANDLE (if the queue has been rundown),
        WAIT_TIMEOUT (to indicate a timeout has occurred)

--*/

{
    DWORD Status;
    PLIST_ENTRY Entry;
    BOOL Empty;
    HANDLE WaitArray[2];
Retry:
    if (Queue->Count == 0) {
        //
        // Block until something is inserted on the queue
        //
        WaitArray[0] = Queue->Abort;
        WaitArray[1] = Queue->Event;
        Status = WaitForMultipleObjects(2, WaitArray, FALSE, dwMilliseconds);
        if ((Status == WAIT_OBJECT_0) ||
            (Status == WAIT_FAILED))  {
            //
            // The queue has been rundown, return NULL immediately.
            //
            SetLastError(ERROR_INVALID_HANDLE);
            return(NULL);
        } else if (Status == WAIT_TIMEOUT) {
            SetLastError(WAIT_TIMEOUT);
            return(NULL);
        }
        CL_ASSERT(Status == 1);
    }

    //
    // Lock the queue and try to remove something
    //
    EnterCriticalSection(&Queue->Lock);
    if (Queue->Count == 0) {
        //
        // Somebody got here before we did, drop the lock and retry
        //
        LeaveCriticalSection(&Queue->Lock);
        goto Retry;
    }

    CL_ASSERT(!IsListEmpty(&Queue->ListHead));

    if ( NULL != pfnCallback ) {
        //
        // We've got a callback function - if it returns ERROR_SUCCESS then dequeue.
        // Otherwise return NULL and SetLastError to whatever error code the callback returns.
        //
        Entry = (&Queue->ListHead)->Flink;
        Status = (*pfnCallback)( Entry, pvContext );
        
        if ( ERROR_SUCCESS == Status ) {
            //
            // The entry is appropriate to pass back.
            //
            Entry = RemoveHeadList(&Queue->ListHead);
        } else {
            Entry = NULL;
        }
        
    } else {
        Entry = RemoveHeadList(&Queue->ListHead);
        Status = ERROR_SUCCESS;
    }

    //
    // Only decrement the count if we removed the event
    //
    if ( NULL != Entry ) {
        //
        // Decrement count and check for empty list.
        //
        if (--Queue->Count == 0) {

            //
            // The queue has transitioned from full to empty,
            // reset the event.
            //
            CL_ASSERT(IsListEmpty(&Queue->ListHead));
            ResetEvent(Queue->Event);
        }
    }
    LeaveCriticalSection(&Queue->Lock);

    SetLastError( Status );
    return(Entry);
}


VOID
ClRtlInsertTailQueue(
    IN PCL_QUEUE Queue,
    IN PLIST_ENTRY Item
    )

/*++

Routine Description:

    Inserts a new entry on the tail of the queue.

Arguments:

    Queue - Supplies the queue to add the entry to.

    Item - Supplies the entry to be added to the queue.

Return Value:

    None.

--*/

{

    EnterCriticalSection(&Queue->Lock);

    InsertTailList(&Queue->ListHead, Item);
    if (++Queue->Count == 1) {
        //
        // The queue has transitioned from empty to full, set
        // the event to awaken any waiters.
        //
        SetEvent(Queue->Event);
    }

    LeaveCriticalSection(&Queue->Lock);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\registryvaluename.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	Copyright (c) 1996-1999 Microsoft Corporation
//
//	Module Name:
//		RegistryValueName.h
//
//	Implementation File:
//		RegistryValueName.cpp
//
//	Description:
//		Definition of the CRegistryValueName class.
//
//	Author:
//		Vijayendra Vasu (vvasu) February 5, 1999
//
//	Revision History:
//		None.
//
/////////////////////////////////////////////////////////////////////////////

#ifndef __REGISTRYVALUENAME_H__
#define __REGISTRYVALUENAME_H__


/////////////////////////////////////////////////////////////////////////////
//++
//
//	Class CRegistryValueName
//
//	When initialized, this class takes as input the Name and KeyName
//	fields of a property table item. It then initializes its member 
//	variables m_pszName and m_pszKeyName as follows. 
//
//	m_pszName contains all the characters of Name after the last backslash 
//	character.
//	To m_pszKeyName is appended all the characters of Name upto (but not
//	including) the last backslash character.
//
//	For example: If Name is "Groups\AdminExtensions" and KeyName is NULL,
//	m_pszKeyName will be "Groups" and m_pszName will be "AdminExtensions"
//
//	The allocated memory is automatically freed during the destruction of
//	the CRegistryValueName object.
//
//--
/////////////////////////////////////////////////////////////////////////////
class CRegistryValueName
{
private:
	LPCWSTR	m_pszName;
	LPCWSTR	m_pszKeyName;
	DWORD	m_cbNameBufferSize;
	DWORD	m_cbKeyNameBufferSize;

	// Disallow copying.
	const CRegistryValueName & operator =( const CRegistryValueName & rhs );
	CRegistryValueName( const CRegistryValueName & source );

public:
	//
	// Construction.
	//

	// Default constructor
	CRegistryValueName( void )
		: m_pszName( NULL )
		, m_pszKeyName( NULL )
		, m_cbNameBufferSize( 0 )
		, m_cbKeyNameBufferSize( 0 )
	{
	} //*** CRegistryValueName()

	// Destructor
	~CRegistryValueName( void )
	{
		FreeBuffers();

	} //*** ~CRegistryValueName()

	//
	// Initialization and deinitialization routines.
	//

	// Initialize the object
	DWORD ScInit( LPCWSTR pszOldName, LPCWSTR pszOldKeyName );

	// Deallocate buffers
	void FreeBuffers( void );

public:
	//
	// Access methods.
	//

	LPCWSTR PszName( void ) const
	{
		return m_pszName;

	} //*** PszName()

	LPCWSTR PszKeyName( void ) const
	{
		return m_pszKeyName;

	} //*** PszKeyName()

}; //*** class CRegistryValueName

#endif // __REGISTRYVALUENAME_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\cluster\clusrtl\oscheck.c ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    oscheck.c

Abstract:

    Checks all the nooks and crannies of the OS to make sure
    it is ok to run a cluster on it.

Author:

    John Vert (jvert) 11/11/1996

Revision History:

--*/
#include <clusrtlp.h>

#include <winbase.h>

static
DWORD
GetEnableClusterRegValue(
    DWORD * pdwValue
    )
/*++

Routine Description:

    Read the registry override registry value for enabling clusters.

Arguments:

    pdwValue - Return value read from the registry.

Return Value:

    ERROR_SUCCESS if the operation was successful.

    Win32 error code on failure.

--*/

{
    DWORD   sc;
    HKEY    hkey = NULL;
    DWORD   dwType;
    DWORD   cbValue = sizeof( DWORD );

    if ( !ARGUMENT_PRESENT( pdwValue ) ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Default to the value 0 - not Enabled!
    //
    *pdwValue = 0;

    //
    // Open the registry key containing the value.
    //

    sc = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Cluster Server"),
            0,
            KEY_READ,
            &hkey );
    if ( sc != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    //
    // Read the override value.
    //

    sc = RegQueryValueEx(
            hkey,
            TEXT("EnableCluster"),
            0,
            &dwType,
            (LPBYTE) pdwValue,
            &cbValue );
    if ( sc != ERROR_SUCCESS ) {
        goto Cleanup;
    }

Cleanup:
    if ( hkey != NULL ) {
        RegCloseKey( hkey );
    }

    return( sc );

} // GetEnableClusterRegValue



DWORD
GetServicePack(
    VOID
    )
/*++

Routine Description:

    Figures out what service pack is installed

Arguments:

    None

Return Value:

    The service pack number.

--*/

{
    OSVERSIONINFOW Version;
    LPWSTR p;
    DWORD sp;

    //
    // Check for required operating system version.
    //
    Version.dwOSVersionInfoSize = sizeof(Version);
    GetVersionExW(&Version);
    if (lstrlenW(Version.szCSDVersion) < lstrlenW(L"Service Pack ")) {
        return(0);
    }

    p = &Version.szCSDVersion[0] + lstrlenW(L"Service Pack ");

    sp = wcstoul(p, NULL, 10);

    return(sp);

} // GetServicePack



BOOL
ClRtlIsOSValid(
    VOID
    )
/*++

Routine Description:

    Checks all the nooks and crannies of the OS to see if it is OK to have
    a cluster there.

Arguments:

    None.

Return Value:

    TRUE if it's ok.

    FALSE if it's not ok.

--*/

{
    BOOL            fIsValid = FALSE;
    OSVERSIONINFOEX osiv;
    DWORDLONG       dwlConditionMask;

    ZeroMemory( &osiv, sizeof( OSVERSIONINFOEX ) );

    osiv.dwOSVersionInfoSize = sizeof( OSVERSIONINFOEX );

    // The following call to VerifyVersionInfo() will test the OS level and that the
    // product suite is Enterprise.
    
    osiv.dwMajorVersion = 5;
    osiv.dwMinorVersion = 1;
    osiv.wServicePackMajor = 0;
    osiv.wSuiteMask = VER_SUITE_ENTERPRISE;
 
    dwlConditionMask = (DWORDLONG) 0L;
 
    VER_SET_CONDITION( dwlConditionMask, VER_MAJORVERSION, VER_GREATER_EQUAL );
    VER_SET_CONDITION( dwlConditionMask, VER_MINORVERSION, VER_GREATER_EQUAL );
    VER_SET_CONDITION( dwlConditionMask, VER_SERVICEPACKMAJOR, VER_GREATER_EQUAL );
    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );

    if ( VerifyVersionInfo( &osiv,
                            VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR |
                            VER_SUITENAME,
                            dwlConditionMask ) ) {
        fIsValid = TRUE;
        goto Cleanup;
    }

    //
    // Check if embedded
    //
    osiv.wSuiteMask = VER_SUITE_EMBEDDEDNT;
    if ( VerifyVersionInfo( &osiv,
                            VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR |
                            VER_SUITENAME,
                            dwlConditionMask ) ) {
        fIsValid = TRUE;
        goto Cleanup;
    }

    //
    // Is the default node limit greater than 0?
    //
    if ( ClRtlGetDefaultNodeLimit( ClRtlGetSuiteType() ) > 0 ) {
        fIsValid = TRUE;
        goto Cleanup;
    }

    //
    // If we get here, the this version of the OS won't support clustering.
    //
    SetLastError( ERROR_CLUSTER_WRONG_OS_VERSION );

Cleanup:
    return( fIsValid );

} // ClRtlIsOSValid


BOOL
ClRtlIsOSTypeValid(
    VOID
    )
/*++

Routine Description:

    Checks to see if the operating system type (server, Enterprise, whatever) is
    ok to install a cluster.

Arguments:

    None.

Return Value:

    TRUE if it's ok.

    FALSE if it's not ok.

--*/

{
    BOOL            fIsValid = FALSE;
    OSVERSIONINFOEX osiv;
    DWORDLONG       dwlConditionMask;

    ZeroMemory( &osiv, sizeof( OSVERSIONINFOEX ) );

    osiv.dwOSVersionInfoSize = sizeof( OSVERSIONINFOEX );

    // The call to VerifyVersionInfo will test whether product suite is Advanced
    // Server, aka "Enterprise".
   
    osiv.wSuiteMask = VER_SUITE_ENTERPRISE;

    dwlConditionMask = (DWORDLONG) 0L;

    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );
   
    // Is this Datacenter or Advanced Server?

    if ( VerifyVersionInfo( &osiv, VER_SUITENAME, dwlConditionMask ) ) {
        fIsValid = TRUE;
        goto Cleanup;
    }

    // Is this Embedded NT?

    osiv.wSuiteMask = VER_SUITE_EMBEDDEDNT;
    if ( VerifyVersionInfo( &osiv, VER_SUITENAME, dwlConditionMask ) ) {
        fIsValid = TRUE;
        goto Cleanup;
    }

    //
    // Is the default node limit greater than 0?
    //
    if ( ClRtlGetDefaultNodeLimit( ClRtlGetSuiteType() ) > 0 ) {
        fIsValid = TRUE;
        goto Cleanup;
    }

    //
    // If we get here, the this version of the OS won't support clustering.
    //
    SetLastError( ERROR_CLUSTER_WRONG_OS_VERSION );

Cleanup:
    return( fIsValid );

} // ClRtlIsOSTypeValid

//*********************************************************

#define DATACENTER_DEFAULT_NODE_LIMIT 8
#define ADVANCEDSERVER_DEFAULT_NODE_LIMIT 4
#define EMBEDDED_DEFAULT_NODE_LIMIT 4
#define SERVER_DEFAULT_NODE_LIMIT 0 // ** not used currently **

//*********************************************************

DWORD
ClRtlGetDefaultNodeLimit(
    DWORD SuiteType
    )
/*++

Routine Description:

    Determines 